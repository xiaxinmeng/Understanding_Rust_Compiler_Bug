{"sha": "94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0Y2E4YTM2MTAyNmQxYTYyMmE5NjFlOGRjOGNhY2MzMzFlZDFhYzM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-13T02:40:19Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-22T00:16:18Z"}, "message": "Add 'feature' and 'since' to stability attributes", "tree": {"sha": "58179e85714f0a1ee618a8a9982aadbeb65822cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58179e85714f0a1ee618a8a9982aadbeb65822cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "html_url": "https://github.com/rust-lang/rust/commit/94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90aa581cff54ed1bb5f53ee2ead3764fca94fdf3", "url": "https://api.github.com/repos/rust-lang/rust/commits/90aa581cff54ed1bb5f53ee2ead3764fca94fdf3", "html_url": "https://github.com/rust-lang/rust/commit/90aa581cff54ed1bb5f53ee2ead3764fca94fdf3"}], "stats": {"total": 5383, "additions": 2822, "deletions": 2561}, "files": [{"sha": "34322f7950c3250b305e3cfb7f535867b7fcd67d", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n //! Threadsafe reference-counted boxes (the `Arc<T>` type).\n //!\n@@ -110,7 +110,7 @@ use heap::deallocate;\n /// }\n /// ```\n #[unsafe_no_drop_flag]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Arc<T> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -126,7 +126,8 @@ unsafe impl<T: Sync + Send> Sync for Arc<T> { }\n /// Weak pointers will not keep the data inside of the `Arc` alive, and can be used to break cycles\n /// between `Arc` pointers.\n #[unsafe_no_drop_flag]\n-#[unstable = \"Weak pointers may not belong in this module.\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n pub struct Weak<T> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -156,7 +157,7 @@ impl<T> Arc<T> {\n     /// let five = Arc::new(5i);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new(data: T) -> Arc<T> {\n         // Start the weak pointer count as 1 which is the weak pointer that's\n         // held by all the strong pointers (kinda), see std/rc.rs for more info\n@@ -179,7 +180,8 @@ impl<T> Arc<T> {\n     ///\n     /// let weak_five = five.downgrade();\n     /// ```\n-    #[unstable = \"Weak pointers may not belong in this module.\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"Weak pointers may not belong in this module.\")]\n     pub fn downgrade(&self) -> Weak<T> {\n         // See the clone() impl for why this is relaxed\n         self.inner().weak.fetch_add(1, Relaxed);\n@@ -200,15 +202,15 @@ impl<T> Arc<T> {\n \n /// Get the number of weak references to this value.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub fn weak_count<T>(this: &Arc<T>) -> uint { this.inner().weak.load(SeqCst) - 1 }\n \n /// Get the number of strong references to this value.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub fn strong_count<T>(this: &Arc<T>) -> uint { this.inner().strong.load(SeqCst) }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Clone for Arc<T> {\n     /// Makes a clone of the `Arc<T>`.\n     ///\n@@ -245,7 +247,7 @@ impl<T> BorrowFrom<Arc<T>> for T {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Deref for Arc<T> {\n     type Target = T;\n \n@@ -271,7 +273,7 @@ impl<T: Send + Sync + Clone> Arc<T> {\n     /// let mut_five = five.make_unique();\n     /// ```\n     #[inline]\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn make_unique(&mut self) -> &mut T {\n         // Note that we hold a strong reference, which also counts as a weak reference, so we only\n         // clone if there is an additional reference of either kind.\n@@ -289,7 +291,7 @@ impl<T: Send + Sync + Clone> Arc<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Sync + Send> Drop for Arc<T> {\n     /// Drops the `Arc<T>`.\n     ///\n@@ -355,7 +357,8 @@ impl<T: Sync + Send> Drop for Arc<T> {\n     }\n }\n \n-#[unstable = \"Weak pointers may not belong in this module.\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n impl<T: Sync + Send> Weak<T> {\n     /// Upgrades a weak reference to a strong reference.\n     ///\n@@ -393,7 +396,8 @@ impl<T: Sync + Send> Weak<T> {\n     }\n }\n \n-#[unstable = \"Weak pointers may not belong in this module.\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n impl<T: Sync + Send> Clone for Weak<T> {\n     /// Makes a clone of the `Weak<T>`.\n     ///\n@@ -417,7 +421,7 @@ impl<T: Sync + Send> Clone for Weak<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Sync + Send> Drop for Weak<T> {\n     /// Drops the `Weak<T>`.\n     ///\n@@ -460,7 +464,7 @@ impl<T: Sync + Send> Drop for Weak<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: PartialEq> PartialEq for Arc<T> {\n     /// Equality for two `Arc<T>`s.\n     ///\n@@ -492,7 +496,7 @@ impl<T: PartialEq> PartialEq for Arc<T> {\n     /// ```\n     fn ne(&self, other: &Arc<T>) -> bool { *(*self) != *(*other) }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: PartialOrd> PartialOrd for Arc<T> {\n     /// Partial comparison for two `Arc<T>`s.\n     ///\n@@ -571,11 +575,11 @@ impl<T: PartialOrd> PartialOrd for Arc<T> {\n     /// ```\n     fn ge(&self, other: &Arc<T>) -> bool { *(*self) >= *(*other) }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Ord> Ord for Arc<T> {\n     fn cmp(&self, other: &Arc<T>) -> Ordering { (**self).cmp(&**other) }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Eq> Eq for Arc<T> {}\n \n impl<T: fmt::Show> fmt::Show for Arc<T> {\n@@ -584,16 +588,16 @@ impl<T: fmt::Show> fmt::Show for Arc<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: fmt::String> fmt::String for Arc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::String::fmt(&**self, f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Default + Sync + Send> Default for Arc<T> {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn default() -> Arc<T> { Arc::new(Default::default()) }\n }\n "}, {"sha": "6f41ccbf415226562a359c3b3417e61b40381b5a", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,7 +10,7 @@\n \n //! A unique pointer type.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use core::any::Any;\n use core::clone::Clone;\n@@ -44,35 +44,36 @@ use core::ops::{Deref, DerefMut};\n /// }\n /// ```\n #[lang = \"exchange_heap\"]\n-#[unstable = \"may be renamed; uncertain about custom allocator design\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"may be renamed; uncertain about custom allocator design\")]\n pub static HEAP: () = ();\n \n /// A type that represents a uniquely-owned value.\n #[lang = \"owned_box\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Box<T>(Unique<T>);\n \n impl<T> Box<T> {\n     /// Moves `x` into a freshly allocated box on the global exchange heap.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new(x: T) -> Box<T> {\n         box x\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Default> Default for Box<T> {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn default() -> Box<T> { box Default::default() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Default for Box<[T]> {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn default() -> Box<[T]> { box [] }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Clone> Clone for Box<T> {\n     /// Returns a copy of the owned box.\n     #[inline]\n@@ -85,14 +86,14 @@ impl<T: Clone> Clone for Box<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialEq> PartialEq for Box<T> {\n     #[inline]\n     fn eq(&self, other: &Box<T>) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &Box<T>) -> bool { PartialEq::ne(&**self, &**other) }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialOrd> PartialOrd for Box<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Box<T>) -> Option<Ordering> {\n@@ -107,14 +108,14 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Box<T> {\n     #[inline]\n     fn gt(&self, other: &Box<T>) -> bool { PartialOrd::gt(&**self, &**other) }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: ?Sized + Ord> Ord for Box<T> {\n     #[inline]\n     fn cmp(&self, other: &Box<T>) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: ?Sized + Eq> Eq for Box<T> {}\n \n impl<S: hash::Hasher, T: ?Sized + Hash<S>> Hash<S> for Box<T> {\n@@ -125,19 +126,20 @@ impl<S: hash::Hasher, T: ?Sized + Hash<S>> Hash<S> for Box<T> {\n }\n \n /// Extension methods for an owning `Any` trait object.\n-#[unstable = \"this trait will likely disappear once compiler bugs blocking \\\n-              a direct impl on `Box<Any>` have been fixed \"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"this trait will likely disappear once compiler bugs blocking \\\n+                     a direct impl on `Box<Any>` have been fixed \")]\n // FIXME(#18737): this should be a direct impl on `Box<Any>`. If you're\n //                removing this please make sure that you can downcase on\n //                `Box<Any + Send>` as well as `Box<Any>`\n pub trait BoxAny {\n     /// Returns the boxed value if it is of type `T`, or\n     /// `Err(Self)` if it isn't.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn downcast<T: 'static>(self) -> Result<Box<T>, Self>;\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl BoxAny for Box<Any> {\n     #[inline]\n     fn downcast<T: 'static>(self) -> Result<Box<T>, Box<Any>> {\n@@ -162,7 +164,7 @@ impl<T: ?Sized + fmt::Show> fmt::Show for Box<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: ?Sized + fmt::String> fmt::String for Box<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::String::fmt(&**self, f)\n@@ -175,14 +177,14 @@ impl fmt::Show for Box<Any> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: ?Sized> Deref for Box<T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { &**self }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: ?Sized> DerefMut for Box<T> {\n     fn deref_mut(&mut self) -> &mut T { &mut **self }\n }"}, {"sha": "0cb97410562b57da5b22df3848157df8e28f61fa", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -80,7 +80,7 @@ pub fn usable_size(size: uint, align: uint) -> uint {\n ///\n /// These statistics may be inconsistent if other threads use the allocator\n /// during the call.\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub fn stats_print() {\n     imp::stats_print();\n }"}, {"sha": "845278933747908820f3e264523f8dba5be28aff", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -57,7 +57,7 @@\n //! default global allocator. It is not compatible with the libc allocator API.\n \n #![crate_name = \"alloc\"]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\","}, {"sha": "0b8c518a3a590e14d5b5bed4179b976bffb78120", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -142,7 +142,7 @@\n //! }\n //! ```\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use core::borrow::BorrowFrom;\n use core::cell::Cell;\n@@ -173,8 +173,8 @@ struct RcBox<T> {\n ///\n /// See the [module level documentation](../index.html) for more details.\n #[unsafe_no_drop_flag]\n-#[stable]\n #[cfg(stage0)] // NOTE remove impl after next snapshot\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Rc<T> {\n     // FIXME #12808: strange names to try to avoid interfering with field accesses of the contained\n     // type via Deref\n@@ -187,7 +187,7 @@ pub struct Rc<T> {\n ///\n /// See the [module level documentation](../index.html) for more details.\n #[unsafe_no_drop_flag]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n pub struct Rc<T> {\n     // FIXME #12808: strange names to try to avoid interfering with field accesses of the contained\n@@ -211,8 +211,8 @@ impl<T> Rc<T> {\n     ///\n     /// let five = Rc::new(5i);\n     /// ```\n-    #[stable]\n     #[cfg(stage0)] // NOTE remove after next snapshot\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new(value: T) -> Rc<T> {\n         unsafe {\n             Rc {\n@@ -239,7 +239,7 @@ impl<T> Rc<T> {\n     ///\n     /// let five = Rc::new(5i);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n     pub fn new(value: T) -> Rc<T> {\n         unsafe {\n@@ -268,7 +268,8 @@ impl<T> Rc<T> {\n     /// let weak_five = five.downgrade();\n     /// ```\n     #[cfg(stage0)] // NOTE remove after next snapshot\n-    #[unstable = \"Weak pointers may not belong in this module\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"Weak pointers may not belong in this module\")]\n     pub fn downgrade(&self) -> Weak<T> {\n         self.inc_weak();\n         Weak {\n@@ -290,7 +291,8 @@ impl<T> Rc<T> {\n     /// let weak_five = five.downgrade();\n     /// ```\n     #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n-    #[unstable = \"Weak pointers may not belong in this module\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"Weak pointers may not belong in this module\")]\n     pub fn downgrade(&self) -> Weak<T> {\n         self.inc_weak();\n         Weak { _ptr: self._ptr }\n@@ -299,12 +301,12 @@ impl<T> Rc<T> {\n \n /// Get the number of weak references to this value.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub fn weak_count<T>(this: &Rc<T>) -> uint { this.weak() - 1 }\n \n /// Get the number of strong references to this value.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub fn strong_count<T>(this: &Rc<T>) -> uint { this.strong() }\n \n /// Returns true if there are no other `Rc` or `Weak<T>` values that share the same inner value.\n@@ -320,7 +322,7 @@ pub fn strong_count<T>(this: &Rc<T>) -> uint { this.strong() }\n /// rc::is_unique(&five);\n /// ```\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub fn is_unique<T>(rc: &Rc<T>) -> bool {\n     weak_count(rc) == 0 && strong_count(rc) == 1\n }\n@@ -342,7 +344,7 @@ pub fn is_unique<T>(rc: &Rc<T>) -> bool {\n /// assert_eq!(rc::try_unwrap(x), Err(Rc::new(4u)));\n /// ```\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n     if is_unique(&rc) {\n         unsafe {\n@@ -376,7 +378,7 @@ pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n /// assert!(rc::get_mut(&mut x).is_none());\n /// ```\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub fn get_mut<'a, T>(rc: &'a mut Rc<T>) -> Option<&'a mut T> {\n     if is_unique(rc) {\n         let inner = unsafe { &mut **rc._ptr };\n@@ -402,7 +404,7 @@ impl<T: Clone> Rc<T> {\n     /// let mut_five = five.make_unique();\n     /// ```\n     #[inline]\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn make_unique(&mut self) -> &mut T {\n         if !is_unique(self) {\n             *self = Rc::new((**self).clone())\n@@ -422,7 +424,7 @@ impl<T> BorrowFrom<Rc<T>> for T {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Deref for Rc<T> {\n     type Target = T;\n \n@@ -433,7 +435,7 @@ impl<T> Deref for Rc<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Drop for Rc<T> {\n     /// Drops the `Rc<T>`.\n     ///\n@@ -481,7 +483,7 @@ impl<T> Drop for Rc<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Clone for Rc<T> {\n     /// Makes a clone of the `Rc<T>`.\n     ///\n@@ -524,7 +526,7 @@ impl<T> Clone for Rc<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Default> Default for Rc<T> {\n     /// Creates a new `Rc<T>`, with the `Default` value for `T`.\n     ///\n@@ -537,13 +539,13 @@ impl<T: Default> Default for Rc<T> {\n     /// let x: Rc<int> = Default::default();\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn default() -> Rc<T> {\n         Rc::new(Default::default())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: PartialEq> PartialEq for Rc<T> {\n     /// Equality for two `Rc<T>`s.\n     ///\n@@ -578,10 +580,10 @@ impl<T: PartialEq> PartialEq for Rc<T> {\n     fn ne(&self, other: &Rc<T>) -> bool { **self != **other }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Eq> Eq for Rc<T> {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: PartialOrd> PartialOrd for Rc<T> {\n     /// Partial comparison for two `Rc<T>`s.\n     ///\n@@ -666,7 +668,7 @@ impl<T: PartialOrd> PartialOrd for Rc<T> {\n     fn ge(&self, other: &Rc<T>) -> bool { **self >= **other }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Ord> Ord for Rc<T> {\n     /// Comparison for two `Rc<T>`s.\n     ///\n@@ -693,14 +695,14 @@ impl<S: hash::Hasher, T: Hash<S>> Hash<S> for Rc<T> {\n     }\n }\n \n-#[unstable = \"Show is experimental.\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"Show is experimental.\")]\n impl<T: fmt::Show> fmt::Show for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"Rc({:?})\", **self)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: fmt::String> fmt::String for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::String::fmt(&**self, f)\n@@ -713,8 +715,9 @@ impl<T: fmt::String> fmt::String for Rc<T> {\n ///\n /// See the [module level documentation](../index.html) for more.\n #[unsafe_no_drop_flag]\n-#[unstable = \"Weak pointers may not belong in this module.\"]\n #[cfg(stage0)] // NOTE remove impl after next snapshot\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n pub struct Weak<T> {\n     // FIXME #12808: strange names to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -729,7 +732,8 @@ pub struct Weak<T> {\n ///\n /// See the [module level documentation](../index.html) for more.\n #[unsafe_no_drop_flag]\n-#[unstable = \"Weak pointers may not belong in this module.\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n pub struct Weak<T> {\n     // FIXME #12808: strange names to try to avoid interfering with\n@@ -746,7 +750,8 @@ impl<T> !marker::Send for Weak<T> {}\n impl<T> !marker::Sync for Weak<T> {}\n \n \n-#[unstable = \"Weak pointers may not belong in this module.\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n impl<T> Weak<T> {\n     /// Upgrades a weak reference to a strong reference.\n     ///\n@@ -804,7 +809,7 @@ impl<T> Weak<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Drop for Weak<T> {\n     /// Drops the `Weak<T>`.\n     ///\n@@ -847,7 +852,8 @@ impl<T> Drop for Weak<T> {\n     }\n }\n \n-#[unstable = \"Weak pointers may not belong in this module.\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"Weak pointers may not belong in this module.\")]\n impl<T> Clone for Weak<T> {\n     /// Makes a clone of the `Weak<T>`.\n     ///\n@@ -890,7 +896,7 @@ impl<T> Clone for Weak<T> {\n     }\n }\n \n-#[unstable = \"Show is experimental.\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"Show is experimental.\")]\n impl<T: fmt::Show> fmt::Show for Weak<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"(Weak)\")"}, {"sha": "633e2bf57b6f6e15941aabac341356ce80f28e7d", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -20,7 +20,7 @@\n //! more complex, slower arena which can hold objects of any type.\n \n #![crate_name = \"arena\"]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]"}, {"sha": "fb7fa895ae35d8cfa373abd75e4f32dacfc28a81", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -148,7 +148,7 @@\n //! ```\n \n #![allow(missing_docs)]\n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use core::prelude::*;\n \n@@ -164,12 +164,12 @@ use vec::{self, Vec};\n ///\n /// This will be a max-heap.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct BinaryHeap<T> {\n     data: Vec<T>,\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Ord> Default for BinaryHeap<T> {\n     #[inline]\n     fn default() -> BinaryHeap<T> { BinaryHeap::new() }\n@@ -185,7 +185,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// let mut heap = BinaryHeap::new();\n     /// heap.push(4u);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new() -> BinaryHeap<T> { BinaryHeap { data: vec![] } }\n \n     /// Creates an empty `BinaryHeap` with a specific capacity.\n@@ -200,7 +200,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// let mut heap = BinaryHeap::with_capacity(10);\n     /// heap.push(4u);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> BinaryHeap<T> {\n         BinaryHeap { data: Vec::with_capacity(capacity) }\n     }\n@@ -238,7 +238,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { iter: self.data.iter() }\n     }\n@@ -259,7 +259,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter { iter: self.data.into_iter() }\n     }\n@@ -279,7 +279,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.peek(), Some(&5));\n     ///\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn peek(&self) -> Option<&T> {\n         self.data.get(0)\n     }\n@@ -294,7 +294,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert!(heap.capacity() >= 100);\n     /// heap.push(4u);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint { self.data.capacity() }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n@@ -317,7 +317,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert!(heap.capacity() >= 100);\n     /// heap.push(4u);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         self.data.reserve_exact(additional);\n     }\n@@ -338,13 +338,13 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert!(heap.capacity() >= 100);\n     /// heap.push(4u);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         self.data.reserve(additional);\n     }\n \n     /// Discards as much additional capacity as possible.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         self.data.shrink_to_fit();\n     }\n@@ -362,7 +362,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.pop(), Some(1));\n     /// assert_eq!(heap.pop(), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<T> {\n         self.data.pop().map(|mut item| {\n             if !self.is_empty() {\n@@ -387,7 +387,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.len(), 3);\n     /// assert_eq!(heap.peek(), Some(&5));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn push(&mut self, item: T) {\n         let old_len = self.len();\n         self.data.push(item);\n@@ -542,40 +542,41 @@ impl<T: Ord> BinaryHeap<T> {\n     }\n \n     /// Returns the length of the binary heap.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.data.len() }\n \n     /// Checks if the binary heap is empty.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the binary heap, returning an iterator over the removed elements.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<T> {\n         Drain { iter: self.data.drain() }\n     }\n \n     /// Drops all items from the binary heap.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn clear(&mut self) { self.drain(); }\n }\n \n /// `BinaryHeap` iterator.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Iter <'a, T: 'a> {\n     iter: slice::Iter<'a, T>,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> {\n         Iter { iter: self.iter.clone() }\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n@@ -586,22 +587,22 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n /// An iterator that moves out of a `BinaryHeap`.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     iter: vec::IntoIter<T>,\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n@@ -612,22 +613,22 @@ impl<T> Iterator for IntoIter<T> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /// An iterator that drains a `BinaryHeap`.\n-#[unstable = \"recent addition\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"recent addition\")]\n pub struct Drain<'a, T: 'a> {\n     iter: vec::Drain<'a, T>,\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     type Item = T;\n \n@@ -638,23 +639,23 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n     fn from_iter<Iter: Iterator<Item=T>>(iter: Iter) -> BinaryHeap<T> {\n         BinaryHeap::from_vec(iter.collect())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BinaryHeap<T> {\n     fn extend<Iter: Iterator<Item=T>>(&mut self, mut iter: Iter) {\n         let (lower, _) = iter.size_hint();"}, {"sha": "8911f67a35f48f4a27fc7dc686945fcabc693736", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 72, "deletions": 69, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -156,7 +156,8 @@ static FALSE: bool = false;\n /// println!(\"{:?}\", bv);\n /// println!(\"total bits set to true: {}\", bv.iter().filter(|x| *x).count());\n /// ```\n-#[unstable = \"RFC 509\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"RFC 509\")]\n pub struct Bitv {\n     /// Internal representation of the bit vector\n     storage: Vec<u32>,\n@@ -252,7 +253,7 @@ impl Bitv {\n     /// use std::collections::Bitv;\n     /// let mut bv = Bitv::new();\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new() -> Bitv {\n         Bitv { storage: Vec::new(), nbits: 0 }\n     }\n@@ -288,7 +289,7 @@ impl Bitv {\n     ///\n     /// It is important to note that this function does not specify the\n     /// *length* of the returned bitvector, but only the *capacity*.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn with_capacity(nbits: uint) -> Bitv {\n         Bitv {\n             storage: Vec::with_capacity(blocks_for_bits(nbits)),\n@@ -374,7 +375,7 @@ impl Bitv {\n     /// assert_eq!(bv[1], true);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn get(&self, i: uint) -> Option<bool> {\n         if i >= self.nbits {\n             return None;\n@@ -402,7 +403,8 @@ impl Bitv {\n     /// assert_eq!(bv[3], true);\n     /// ```\n     #[inline]\n-    #[unstable = \"panic semantics are likely to change in the future\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"panic semantics are likely to change in the future\")]\n     pub fn set(&mut self, i: uint, x: bool) {\n         assert!(i < self.nbits);\n         let w = i / u32::BITS;\n@@ -585,7 +587,7 @@ impl Bitv {\n     /// assert_eq!(bv.iter().filter(|x| *x).count(), 7);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter {\n         Iter { bitv: self, next_idx: 0, end_idx: self.nbits }\n     }\n@@ -706,7 +708,7 @@ impl Bitv {\n     /// bv.truncate(2);\n     /// assert!(bv.eq_vec(&[false, true]));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, len: uint) {\n         if len < self.len() {\n             self.nbits = len;\n@@ -733,7 +735,7 @@ impl Bitv {\n     /// assert_eq!(bv.len(), 3);\n     /// assert!(bv.capacity() >= 13);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         let desired_cap = self.len().checked_add(additional).expect(\"capacity overflow\");\n         let storage_len = self.storage.len();\n@@ -763,7 +765,7 @@ impl Bitv {\n     /// assert_eq!(bv.len(), 3);\n     /// assert!(bv.capacity() >= 13);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         let desired_cap = self.len().checked_add(additional).expect(\"capacity overflow\");\n         let storage_len = self.storage.len();\n@@ -785,7 +787,7 @@ impl Bitv {\n     /// assert!(bv.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.storage.capacity().checked_mul(u32::BITS).unwrap_or(uint::MAX)\n     }\n@@ -856,7 +858,7 @@ impl Bitv {\n     /// assert_eq!(bv.pop(), Some(false));\n     /// assert_eq!(bv.len(), 6);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<bool> {\n         if self.is_empty() {\n             None\n@@ -886,7 +888,7 @@ impl Bitv {\n     /// bv.push(false);\n     /// assert!(bv.eq_vec(&[true, false]));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn push(&mut self, elem: bool) {\n         if self.nbits % u32::BITS == 0 {\n             self.storage.push(0);\n@@ -898,29 +900,29 @@ impl Bitv {\n \n     /// Return the total number of bits in this vector\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.nbits }\n \n     /// Returns true if there are no bits in this vector\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears all bits in this vector.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         for w in self.storage.iter_mut() { *w = 0u32; }\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl Default for Bitv {\n     #[inline]\n     fn default() -> Bitv { Bitv::new() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl FromIterator<bool> for Bitv {\n     fn from_iter<I:Iterator<Item=bool>>(iterator: I) -> Bitv {\n         let mut ret = Bitv::new();\n@@ -929,7 +931,7 @@ impl FromIterator<bool> for Bitv {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl Extend<bool> for Bitv {\n     #[inline]\n     fn extend<I: Iterator<Item=bool>>(&mut self, mut iterator: I) {\n@@ -941,7 +943,7 @@ impl Extend<bool> for Bitv {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl Clone for Bitv {\n     #[inline]\n     fn clone(&self) -> Bitv {\n@@ -955,23 +957,23 @@ impl Clone for Bitv {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl PartialOrd for Bitv {\n     #[inline]\n     fn partial_cmp(&self, other: &Bitv) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl Ord for Bitv {\n     #[inline]\n     fn cmp(&self, other: &Bitv) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl fmt::Show for Bitv {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         for bit in self.iter() {\n@@ -981,7 +983,7 @@ impl fmt::Show for Bitv {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Bitv {\n     fn hash(&self, state: &mut S) {\n         self.nbits.hash(state);\n@@ -991,7 +993,7 @@ impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Bitv {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl cmp::PartialEq for Bitv {\n     #[inline]\n     fn eq(&self, other: &Bitv) -> bool {\n@@ -1002,19 +1004,19 @@ impl cmp::PartialEq for Bitv {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl cmp::Eq for Bitv {}\n \n /// An iterator for `Bitv`.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Iter<'a> {\n     bitv: &'a Bitv,\n     next_idx: uint,\n     end_idx: uint,\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> Iterator for Iter<'a> {\n     type Item = bool;\n \n@@ -1035,7 +1037,7 @@ impl<'a> Iterator for Iter<'a> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for Iter<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<bool> {\n@@ -1048,10 +1050,10 @@ impl<'a> DoubleEndedIterator for Iter<'a> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> ExactSizeIterator for Iter<'a> {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> RandomAccessIterator for Iter<'a> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1107,18 +1109,19 @@ impl<'a> RandomAccessIterator for Iter<'a> {\n /// assert!(bv[3]);\n /// ```\n #[derive(Clone)]\n-#[unstable = \"RFC 509\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"RFC 509\")]\n pub struct BitvSet {\n     bitv: Bitv,\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl Default for BitvSet {\n     #[inline]\n     fn default() -> BitvSet { BitvSet::new() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl FromIterator<uint> for BitvSet {\n     fn from_iter<I:Iterator<Item=uint>>(iterator: I) -> BitvSet {\n         let mut ret = BitvSet::new();\n@@ -1127,7 +1130,7 @@ impl FromIterator<uint> for BitvSet {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl Extend<uint> for BitvSet {\n     #[inline]\n     fn extend<I: Iterator<Item=uint>>(&mut self, mut iterator: I) {\n@@ -1137,7 +1140,7 @@ impl Extend<uint> for BitvSet {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl PartialOrd for BitvSet {\n     #[inline]\n     fn partial_cmp(&self, other: &BitvSet) -> Option<Ordering> {\n@@ -1146,7 +1149,7 @@ impl PartialOrd for BitvSet {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl Ord for BitvSet {\n     #[inline]\n     fn cmp(&self, other: &BitvSet) -> Ordering {\n@@ -1155,7 +1158,7 @@ impl Ord for BitvSet {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl cmp::PartialEq for BitvSet {\n     #[inline]\n     fn eq(&self, other: &BitvSet) -> bool {\n@@ -1164,7 +1167,7 @@ impl cmp::PartialEq for BitvSet {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl cmp::Eq for BitvSet {}\n \n impl BitvSet {\n@@ -1178,7 +1181,7 @@ impl BitvSet {\n     /// let mut s = BitvSet::new();\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new() -> BitvSet {\n         BitvSet { bitv: Bitv::new() }\n     }\n@@ -1195,7 +1198,7 @@ impl BitvSet {\n     /// assert!(s.capacity() >= 100);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn with_capacity(nbits: uint) -> BitvSet {\n         let bitv = Bitv::from_elem(nbits, false);\n         BitvSet::from_bitv(bitv)\n@@ -1233,7 +1236,7 @@ impl BitvSet {\n     /// assert!(s.capacity() >= 100);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.bitv.capacity()\n     }\n@@ -1254,7 +1257,7 @@ impl BitvSet {\n     /// s.reserve_len(10);\n     /// assert!(s.capacity() >= 10);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn reserve_len(&mut self, len: uint) {\n         let cur_len = self.bitv.len();\n         if len >= cur_len {\n@@ -1280,7 +1283,7 @@ impl BitvSet {\n     /// s.reserve_len_exact(10);\n     /// assert!(s.capacity() >= 10);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn reserve_len_exact(&mut self, len: uint) {\n         let cur_len = self.bitv.len();\n         if len >= cur_len {\n@@ -1374,7 +1377,7 @@ impl BitvSet {\n     /// println!(\"new capacity: {}\", s.capacity());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         let bitv = &mut self.bitv;\n         // Obtain original length\n@@ -1402,7 +1405,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn iter(&self) -> bitv_set::Iter {\n         SetIter {set: self, next_idx: 0u}\n     }\n@@ -1424,7 +1427,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a BitvSet) -> Union<'a> {\n         fn or(w1: u32, w2: u32) -> u32 { w1 | w2 }\n \n@@ -1454,7 +1457,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a BitvSet) -> Intersection<'a> {\n         fn bitand(w1: u32, w2: u32) -> u32 { w1 & w2 }\n         let min = cmp::min(self.bitv.len(), other.bitv.len());\n@@ -1491,7 +1494,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a BitvSet) -> Difference<'a> {\n         fn diff(w1: u32, w2: u32) -> u32 { w1 & !w2 }\n \n@@ -1522,7 +1525,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BitvSet) -> SymmetricDifference<'a> {\n         fn bitxor(w1: u32, w2: u32) -> u32 { w1 ^ w2 }\n \n@@ -1639,28 +1642,28 @@ impl BitvSet {\n \n     /// Return the number of set bits in this set.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint  {\n         self.bitv.blocks().fold(0, |acc, n| acc + n.count_ones())\n     }\n \n     /// Returns whether there are no bits set in this set\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n         self.bitv.none()\n     }\n \n     /// Clears all bits in this set\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         self.bitv.clear();\n     }\n \n     /// Returns `true` if this set contains the specified integer.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn contains(&self, value: &uint) -> bool {\n         let bitv = &self.bitv;\n         *value < bitv.nbits && bitv[*value]\n@@ -1669,14 +1672,14 @@ impl BitvSet {\n     /// Returns `true` if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_disjoint(&self, other: &BitvSet) -> bool {\n         self.intersection(other).next().is_none()\n     }\n \n     /// Returns `true` if the set is a subset of another.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_subset(&self, other: &BitvSet) -> bool {\n         let self_bitv = &self.bitv;\n         let other_bitv = &other.bitv;\n@@ -1690,14 +1693,14 @@ impl BitvSet {\n \n     /// Returns `true` if the set is a superset of another.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_superset(&self, other: &BitvSet) -> bool {\n         other.is_subset(self)\n     }\n \n     /// Adds a value to the set. Returns `true` if the value was not already\n     /// present in the set.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn insert(&mut self, value: uint) -> bool {\n         if self.contains(&value) {\n             return false;\n@@ -1715,7 +1718,7 @@ impl BitvSet {\n \n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn remove(&mut self, value: &uint) -> bool {\n         if !self.contains(value) {\n             return false;\n@@ -1752,7 +1755,7 @@ impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitvSet {\n \n /// An iterator for `BitvSet`.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct SetIter<'a> {\n     set: &'a BitvSet,\n     next_idx: uint\n@@ -1768,16 +1771,16 @@ struct TwoBitPositions<'a> {\n     next_idx: uint\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Union<'a>(TwoBitPositions<'a>);\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Intersection<'a>(Take<TwoBitPositions<'a>>);\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Difference<'a>(TwoBitPositions<'a>);\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct SymmetricDifference<'a>(TwoBitPositions<'a>);\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> Iterator for SetIter<'a> {\n     type Item = uint;\n \n@@ -1800,7 +1803,7 @@ impl<'a> Iterator for SetIter<'a> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> Iterator for TwoBitPositions<'a> {\n     type Item = uint;\n \n@@ -1838,31 +1841,31 @@ impl<'a> Iterator for TwoBitPositions<'a> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> Iterator for Union<'a> {\n     type Item = uint;\n \n     #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> Iterator for Intersection<'a> {\n     type Item = uint;\n \n     #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> Iterator for Difference<'a> {\n     type Item = uint;\n \n     #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> Iterator for SymmetricDifference<'a> {\n     type Item = uint;\n "}, {"sha": "8ee4a566dbc3c42f055e44945c3c30a472cfd0c7", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 73, "deletions": 60, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -81,7 +81,7 @@ use super::node::{self, Node, Found, GoDown};\n /// done on each operation isn't *catastrophic*, and *is* still bounded by O(B log<sub>B</sub>n),\n /// it is certainly much slower when it does.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct BTreeMap<K, V> {\n     root: Node<K, V>,\n     length: uint,\n@@ -96,31 +96,31 @@ struct AbsIter<T> {\n }\n \n /// An iterator over a BTreeMap's entries.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n     inner: AbsIter<Traversal<'a, K, V>>\n }\n \n /// A mutable iterator over a BTreeMap's entries.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     inner: AbsIter<MutTraversal<'a, K, V>>\n }\n \n /// An owning iterator over a BTreeMap's entries.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n     inner: AbsIter<MoveTraversal<K, V>>\n }\n \n /// An iterator over a BTreeMap's keys.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a K, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n }\n \n /// An iterator over a BTreeMap's values.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n@@ -136,7 +136,8 @@ pub struct RangeMut<'a, K: 'a, V: 'a> {\n }\n \n /// A view into a single entry in a map, which may either be vacant or occupied.\n-#[unstable = \"precise API still under development\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"precise API still under development\")]\n pub enum Entry<'a, K:'a, V:'a> {\n     /// A vacant Entry\n     Vacant(VacantEntry<'a, K, V>),\n@@ -145,21 +146,23 @@ pub enum Entry<'a, K:'a, V:'a> {\n }\n \n /// A vacant Entry.\n-#[unstable = \"precise API still under development\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"precise API still under development\")]\n pub struct VacantEntry<'a, K:'a, V:'a> {\n     key: K,\n     stack: stack::SearchStack<'a, K, V, node::handle::Edge, node::handle::Leaf>,\n }\n \n /// An occupied Entry.\n-#[unstable = \"precise API still under development\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"precise API still under development\")]\n pub struct OccupiedEntry<'a, K:'a, V:'a> {\n     stack: stack::SearchStack<'a, K, V, node::handle::KV, node::handle::LeafOrInternal>,\n }\n \n impl<K: Ord, V> BTreeMap<K, V> {\n     /// Makes a new empty BTreeMap with a reasonable choice for B.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new() -> BTreeMap<K, V> {\n         //FIXME(Gankro): Tune this as a function of size_of<K/V>?\n         BTreeMap::with_b(6)\n@@ -190,7 +193,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         let b = self.b;\n         // avoid recursive destructors by manually traversing the tree\n@@ -220,7 +223,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.get(&1), Some(&\"a\"));\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V> where Q: BorrowFrom<K> + Ord {\n         let mut cur_node = &self.root;\n         loop {\n@@ -252,7 +255,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.contains_key(&1), true);\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool where Q: BorrowFrom<K> + Ord {\n         self.get(key).is_some()\n     }\n@@ -276,7 +279,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n     // See `get` for implementation notes, this is basically a copy-paste with mut's added\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V> where Q: BorrowFrom<K> + Ord {\n         // temp_node is a Borrowck hack for having a mutable value outlive a loop iteration\n         let mut temp_node = &mut self.root;\n@@ -337,7 +340,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn insert(&mut self, mut key: K, mut value: V) -> Option<V> {\n         // This is a stack of rawptrs to nodes paired with indices, respectively\n         // representing the nodes and edges of our search path. We have to store rawptrs\n@@ -446,7 +449,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.remove(&1), Some(\"a\"));\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V> where Q: BorrowFrom<K> + Ord {\n         // See `swap` for a more thorough description of the stuff going on in here\n         let mut stack = stack::PartialSearchStack::new(self);\n@@ -807,7 +810,7 @@ mod stack {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n     fn from_iter<T: Iterator<Item=(K, V)>>(iter: T) -> BTreeMap<K, V> {\n         let mut map = BTreeMap::new();\n@@ -816,7 +819,7 @@ impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     #[inline]\n     fn extend<T: Iterator<Item=(K, V)>>(&mut self, mut iter: T) {\n@@ -826,7 +829,7 @@ impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<S: Hasher, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n     fn hash(&self, state: &mut S) {\n         for elt in self.iter() {\n@@ -835,42 +838,42 @@ impl<S: Hasher, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K: Ord, V> Default for BTreeMap<K, V> {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn default() -> BTreeMap<K, V> {\n         BTreeMap::new()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K: PartialEq, V: PartialEq> PartialEq for BTreeMap<K, V> {\n     fn eq(&self, other: &BTreeMap<K, V>) -> bool {\n         self.len() == other.len() &&\n             self.iter().zip(other.iter()).all(|(a, b)| a == b)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K: Eq, V: Eq> Eq for BTreeMap<K, V> {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K: PartialOrd, V: PartialOrd> PartialOrd for BTreeMap<K, V> {\n     #[inline]\n     fn partial_cmp(&self, other: &BTreeMap<K, V>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K: Ord, V: Ord> Ord for BTreeMap<K, V> {\n     #[inline]\n     fn cmp(&self, other: &BTreeMap<K, V>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K: Show, V: Show> Show for BTreeMap<K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"BTreeMap {{\"));\n@@ -884,7 +887,7 @@ impl<K: Show, V: Show> Show for BTreeMap<K, V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K: Ord, Q: ?Sized, V> Index<Q> for BTreeMap<K, V>\n     where Q: BorrowFrom<K> + Ord\n {\n@@ -895,7 +898,7 @@ impl<K: Ord, Q: ?Sized, V> Index<Q> for BTreeMap<K, V>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K: Ord, Q: ?Sized, V> IndexMut<Q> for BTreeMap<K, V>\n     where Q: BorrowFrom<K> + Ord\n {\n@@ -1006,75 +1009,75 @@ impl<K, V, E, T> DoubleEndedIterator for AbsIter<T> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Iter<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next_back() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for IterMut<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next_back() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K, V> Iterator for IntoIter<K, V> {\n     type Item = (K, V);\n \n     fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n     fn next_back(&mut self) -> Option<(K, V)> { self.inner.next_back() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K, V> ExactSizeIterator for IntoIter<K, V> {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     type Item = &'a K;\n \n     fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Keys<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K)> { self.inner.next_back() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {}\n \n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Values<'a, K, V> {\n     type Item = &'a V;\n \n     fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a V)> { self.inner.next_back() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {}\n \n impl<'a, K, V> Iterator for Range<'a, K, V> {\n@@ -1096,7 +1099,8 @@ impl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n }\n \n impl<'a, K: Ord, V> Entry<'a, K, V> {\n-    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n     pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> {\n         match self {\n@@ -1109,41 +1113,47 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n-    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n         self.stack.insert(self.key, value)\n     }\n }\n \n impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     /// Gets a reference to the value in the entry.\n-    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn get(&self) -> &V {\n         self.stack.peek()\n     }\n \n     /// Gets a mutable reference to the value in the entry.\n-    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn get_mut(&mut self) -> &mut V {\n         self.stack.peek_mut()\n     }\n \n     /// Converts the entry into a mutable reference to its value.\n-    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn into_mut(self) -> &'a mut V {\n         self.stack.into_top()\n     }\n \n     /// Sets the value of the entry with the OccupiedEntry's key,\n     /// and returns the entry's old value.\n-    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn insert(&mut self, mut value: V) -> V {\n         mem::swap(self.stack.peek_mut(), &mut value);\n         value\n     }\n \n     /// Takes the value of the entry out of the map, and returns it.\n-    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn remove(self) -> V {\n         self.stack.remove()\n     }\n@@ -1169,7 +1179,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// let (first_key, first_value) = map.iter().next().unwrap();\n     /// assert_eq!((*first_key, *first_value), (1u, \"a\"));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<K, V> {\n         let len = self.len();\n         // NB. The initial capacity for ringbuf is large enough to avoid reallocs in many cases.\n@@ -1202,7 +1212,7 @@ impl<K, V> BTreeMap<K, V> {\n     ///     }\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<K, V> {\n         let len = self.len();\n         let mut lca = RingBuf::new();\n@@ -1231,7 +1241,7 @@ impl<K, V> BTreeMap<K, V> {\n     ///     println!(\"{}: {}\", key, value);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<K, V> {\n         let len = self.len();\n         let mut lca = RingBuf::new();\n@@ -1258,7 +1268,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// let keys: Vec<uint> = a.keys().cloned().collect();\n     /// assert_eq!(keys, vec![1u,2,]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((&'a K, &'a V)) -> &'a K = first; // coerce to fn pointer\n@@ -1280,7 +1290,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// let values: Vec<&str> = a.values().cloned().collect();\n     /// assert_eq!(values, vec![\"a\",\"b\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n         let second: fn((&'a K, &'a V)) -> &'a V = second; // coerce to fn pointer\n@@ -1300,7 +1310,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// a.insert(1u, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.length }\n \n     /// Return true if the map contains no elements.\n@@ -1315,7 +1325,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// a.insert(1u, \"a\");\n     /// assert!(!a.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n@@ -1470,7 +1480,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// }\n     /// assert_eq!(Some((&5u, &\"b\")), map.range(Included(&4), Unbounded).next());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn range<'a>(&'a self, min: Bound<&K>, max: Bound<&K>) -> Range<'a, K, V> {\n         range_impl!(&self.root, min, max, as_slices_internal, iter, Range, edges, [])\n     }\n@@ -1496,7 +1507,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///     println!(\"{} => {}\", name, balance);\n     /// }\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn range_mut<'a>(&'a mut self, min: Bound<&K>, max: Bound<&K>) -> RangeMut<'a, K, V> {\n         range_impl!(&mut self.root, min, max, as_slices_internal_mut, iter_mut, RangeMut,\n                                                                       edges_mut, [mut])\n@@ -1528,7 +1540,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(count[\"a\"], 3u);\n     /// ```\n     /// The key must have the same ordering before or after `.to_owned()` is called.\n-    #[unstable = \"precise API still under development\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"precise API still under development\")]\n     pub fn entry<'a>(&'a mut self, mut key: K) -> Entry<'a, K, V> {\n         // same basic logic of `swap` and `pop`, blended together\n         let mut stack = stack::PartialSearchStack::new(self);"}, {"sha": "2ae8dfa4931674d9de7c42e98fadbff53ec3fa9b", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -420,7 +420,7 @@ impl<K, V> Node<K, V> {\n }\n \n // FIXME(gereeter) Write an efficient clone_from\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K: Clone, V: Clone> Clone for Node<K, V> {\n     fn clone(&self) -> Node<K, V> {\n         let mut ret = if self.is_leaf() {"}, {"sha": "00d90aefab7f0e8dceb5e33fc044e82d02d86b81", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 46, "deletions": 44, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -34,19 +34,19 @@ use Bound;\n /// See BTreeMap's documentation for a detailed discussion of this collection's performance\n /// benefits and drawbacks.\n #[derive(Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct BTreeSet<T>{\n     map: BTreeMap<T, ()>,\n }\n \n /// An iterator over a BTreeSet's items.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n     iter: Keys<'a, T, ()>\n }\n \n /// An owning iterator over a BTreeSet's items.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     iter: Map<(T, ()), T, ::btree_map::IntoIter<T, ()>, fn((T, ())) -> T>\n }\n@@ -57,28 +57,28 @@ pub struct Range<'a, T: 'a> {\n }\n \n /// A lazy iterator producing elements in the set difference (in-order).\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Difference<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set symmetric difference (in-order).\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct SymmetricDifference<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set intersection (in-order).\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Intersection<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set union (in-order).\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Union<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n@@ -94,15 +94,16 @@ impl<T: Ord> BTreeSet<T> {\n     ///\n     /// let mut set: BTreeSet<int> = BTreeSet::new();\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new() -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::new() }\n     }\n \n     /// Makes a new BTreeSet with the given B.\n     ///\n     /// B cannot be less than 2.\n-    #[unstable = \"probably want this to be on the type, eventually\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"probably want this to be on the type, eventually\")]\n     pub fn with_b(b: uint) -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::with_b(b) }\n     }\n@@ -125,7 +126,7 @@ impl<T> BTreeSet<T> {\n     /// let v: Vec<uint> = set.iter().map(|&x| x).collect();\n     /// assert_eq!(v, vec![1u,2,3,4]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { iter: self.map.keys() }\n     }\n@@ -142,7 +143,7 @@ impl<T> BTreeSet<T> {\n     /// let v: Vec<uint> = set.into_iter().collect();\n     /// assert_eq!(v, vec![1u,2,3,4]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((T, ())) -> T = first; // coerce to fn pointer\n@@ -172,7 +173,8 @@ impl<T: Ord> BTreeSet<T> {\n     /// }\n     /// assert_eq!(Some(&5u), set.range(Included(&4), Unbounded).next());\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn range<'a>(&'a self, min: Bound<&T>, max: Bound<&T>) -> Range<'a, T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((&'a T, &'a ())) -> &'a T = first; // coerce to fn pointer\n@@ -200,7 +202,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// let diff: Vec<uint> = a.difference(&b).cloned().collect();\n     /// assert_eq!(diff, vec![1u]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n         Difference{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n@@ -223,7 +225,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// let sym_diff: Vec<uint> = a.symmetric_difference(&b).cloned().collect();\n     /// assert_eq!(sym_diff, vec![1u,3]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BTreeSet<T>)\n         -> SymmetricDifference<'a, T> {\n         SymmetricDifference{a: self.iter().peekable(), b: other.iter().peekable()}\n@@ -247,7 +249,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// let intersection: Vec<uint> = a.intersection(&b).cloned().collect();\n     /// assert_eq!(intersection, vec![2u]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>)\n         -> Intersection<'a, T> {\n         Intersection{a: self.iter().peekable(), b: other.iter().peekable()}\n@@ -269,7 +271,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// let union: Vec<uint> = a.union(&b).cloned().collect();\n     /// assert_eq!(union, vec![1u,2]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {\n         Union{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n@@ -286,7 +288,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// v.insert(1i);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.map.len() }\n \n     /// Returns true if the set contains no elements\n@@ -301,7 +303,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// v.insert(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the set, removing all values.\n@@ -316,7 +318,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         self.map.clear()\n     }\n@@ -336,7 +338,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n         self.map.contains_key(value)\n     }\n@@ -358,7 +360,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// b.insert(1);\n     /// assert_eq!(a.is_disjoint(&b), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_disjoint(&self, other: &BTreeSet<T>) -> bool {\n         self.intersection(other).next().is_none()\n     }\n@@ -379,7 +381,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// set.insert(4);\n     /// assert_eq!(set.is_subset(&sup), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_subset(&self, other: &BTreeSet<T>) -> bool {\n         // Stolen from TreeMap\n         let mut x = self.iter();\n@@ -424,7 +426,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// set.insert(2);\n     /// assert_eq!(set.is_superset(&sub), true);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_superset(&self, other: &BTreeSet<T>) -> bool {\n         other.is_subset(self)\n     }\n@@ -443,7 +445,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.insert(2i), false);\n     /// assert_eq!(set.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn insert(&mut self, value: T) -> bool {\n         self.map.insert(value, ()).is_none()\n     }\n@@ -466,13 +468,13 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.remove(&2), true);\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n         self.map.remove(value).is_some()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n     fn from_iter<Iter: Iterator<Item=T>>(iter: Iter) -> BTreeSet<T> {\n         let mut set = BTreeSet::new();\n@@ -481,7 +483,7 @@ impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BTreeSet<T> {\n     #[inline]\n     fn extend<Iter: Iterator<Item=T>>(&mut self, mut iter: Iter) {\n@@ -491,15 +493,15 @@ impl<T: Ord> Extend<T> for BTreeSet<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Ord> Default for BTreeSet<T> {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn default() -> BTreeSet<T> {\n         BTreeSet::new()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     type Output = BTreeSet<T>;\n \n@@ -522,7 +524,7 @@ impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     type Output = BTreeSet<T>;\n \n@@ -545,7 +547,7 @@ impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     type Output = BTreeSet<T>;\n \n@@ -568,7 +570,7 @@ impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     type Output = BTreeSet<T>;\n \n@@ -591,7 +593,7 @@ impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Show> Show for BTreeSet<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"BTreeSet {{\"));\n@@ -605,33 +607,33 @@ impl<T: Show> Show for BTreeSet<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n     fn next(&mut self) -> Option<T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n \n@@ -654,7 +656,7 @@ fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for Difference<'a, T> {\n     type Item = &'a T;\n \n@@ -669,7 +671,7 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n     type Item = &'a T;\n \n@@ -684,7 +686,7 @@ impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n     type Item = &'a T;\n \n@@ -705,7 +707,7 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for Union<'a, T> {\n     type Item = &'a T;\n "}, {"sha": "f0f2ef3488c9a4c476f74cee53d17af81a609d8d", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 46, "deletions": 44, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -19,7 +19,7 @@\n // Backlinks over DList::prev are raw pointers that form a full chain in\n // the reverse direction.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use core::prelude::*;\n \n@@ -33,7 +33,7 @@ use core::mem;\n use core::ptr;\n \n /// A doubly-linked list.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct DList<T> {\n     length: uint,\n     list_head: Link<T>,\n@@ -57,15 +57,15 @@ struct Node<T> {\n }\n \n /// An iterator over references to the items of a `DList`.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Iter<'a, T:'a> {\n     head: &'a Link<T>,\n     tail: Rawlink<Node<T>>,\n     nelem: uint,\n }\n \n // FIXME #19839: deriving is too aggressive on the bounds (T doesn't need to be Clone).\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> {\n         Iter {\n@@ -77,7 +77,7 @@ impl<'a, T> Clone for Iter<'a, T> {\n }\n \n /// An iterator over mutable references to the items of a `DList`.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct IterMut<'a, T:'a> {\n     list: &'a mut DList<T>,\n     head: Rawlink<Node<T>>,\n@@ -87,7 +87,7 @@ pub struct IterMut<'a, T:'a> {\n \n /// An iterator over mutable references to the items of a `DList`.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     list: DList<T>\n }\n@@ -206,17 +206,17 @@ impl<T> DList<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Default for DList<T> {\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn default() -> DList<T> { DList::new() }\n }\n \n impl<T> DList<T> {\n     /// Creates an empty `DList`.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new() -> DList<T> {\n         DList{list_head: None, list_tail: Rawlink::none(), length: 0}\n     }\n@@ -273,14 +273,14 @@ impl<T> DList<T> {\n \n     /// Provides a forward iterator.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n     }\n \n     /// Provides a forward iterator with mutable references.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n         let head_raw = match self.list_head {\n             Some(ref mut h) => Rawlink::some(&mut **h),\n@@ -296,7 +296,7 @@ impl<T> DList<T> {\n \n     /// Consumes the list into an iterator yielding elements by value.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter{list: self}\n     }\n@@ -317,7 +317,7 @@ impl<T> DList<T> {\n     /// assert!(!dl.is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n         self.list_head.is_none()\n     }\n@@ -344,7 +344,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint {\n         self.length\n     }\n@@ -371,7 +371,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         *self = DList::new()\n     }\n@@ -392,7 +392,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn front(&self) -> Option<&T> {\n         self.list_head.as_ref().map(|head| &head.value)\n     }\n@@ -419,7 +419,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n         self.list_head.as_mut().map(|head| &mut head.value)\n     }\n@@ -440,7 +440,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n         self.list_tail.resolve_immut().as_ref().map(|tail| &tail.value)\n     }\n@@ -467,7 +467,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n         self.list_tail.resolve().map(|tail| &mut tail.value)\n     }\n@@ -490,7 +490,7 @@ impl<T> DList<T> {\n     /// assert_eq!(dl.front().unwrap(), &1);\n     ///\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn push_front(&mut self, elt: T) {\n         self.push_front_node(box Node::new(elt))\n     }\n@@ -516,7 +516,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     ///\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn pop_front(&mut self) -> Option<T> {\n         self.pop_front_node().map(|box Node{value, ..}| value)\n     }\n@@ -533,7 +533,7 @@ impl<T> DList<T> {\n     /// d.push_back(3);\n     /// assert_eq!(3, *d.back().unwrap());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn push_back(&mut self, elt: T) {\n         self.push_back_node(box Node::new(elt))\n     }\n@@ -552,7 +552,7 @@ impl<T> DList<T> {\n     /// d.push_back(3);\n     /// assert_eq!(d.pop_back(), Some(3));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn pop_back(&mut self) -> Option<T> {\n         self.pop_back_node().map(|box Node{value, ..}| value)\n     }\n@@ -577,7 +577,7 @@ impl<T> DList<T> {\n     /// assert_eq!(splitted.pop_front(), Some(1));\n     /// assert_eq!(splitted.pop_front(), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn split_off(&mut self, at: uint) -> DList<T> {\n         let len = self.len();\n         assert!(at < len, \"Cannot split off at a nonexistent index\");\n@@ -620,7 +620,7 @@ impl<T> DList<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Drop for DList<T> {\n     fn drop(&mut self) {\n         // Dissolve the dlist in backwards direction\n@@ -642,7 +642,7 @@ impl<T> Drop for DList<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, A> Iterator for Iter<'a, A> {\n     type Item = &'a A;\n \n@@ -664,7 +664,7 @@ impl<'a, A> Iterator for Iter<'a, A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a A> {\n@@ -679,10 +679,10 @@ impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, A> ExactSizeIterator for Iter<'a, A> {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, A> Iterator for IterMut<'a, A> {\n     type Item = &'a mut A;\n     #[inline]\n@@ -706,7 +706,7 @@ impl<'a, A> Iterator for IterMut<'a, A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut A> {\n@@ -721,7 +721,7 @@ impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n \n // private methods for IterMut\n@@ -770,7 +770,8 @@ impl<'a, A> IterMut<'a, A> {\n     /// }\n     /// ```\n     #[inline]\n-    #[unstable = \"this is probably better handled by a cursor type -- we'll see\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"this is probably better handled by a cursor type -- we'll see\")]\n     pub fn insert_next(&mut self, elt: A) {\n         self.insert_next_node(box Node::new(elt))\n     }\n@@ -791,7 +792,8 @@ impl<'a, A> IterMut<'a, A> {\n     /// assert_eq!(it.next().unwrap(), &2);\n     /// ```\n     #[inline]\n-    #[unstable = \"this is probably better handled by a cursor type -- we'll see\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"this is probably better handled by a cursor type -- we'll see\")]\n     pub fn peek_next(&mut self) -> Option<&mut A> {\n         if self.nelem == 0 {\n             return None\n@@ -800,7 +802,7 @@ impl<'a, A> IterMut<'a, A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A> Iterator for IntoIter<A> {\n     type Item = A;\n \n@@ -813,13 +815,13 @@ impl<A> Iterator for IntoIter<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A> DoubleEndedIterator for IntoIter<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.list.pop_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A> FromIterator<A> for DList<A> {\n     fn from_iter<T: Iterator<Item=A>>(iterator: T) -> DList<A> {\n         let mut ret = DList::new();\n@@ -828,14 +830,14 @@ impl<A> FromIterator<A> for DList<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A> Extend<A> for DList<A> {\n     fn extend<T: Iterator<Item=A>>(&mut self, mut iterator: T) {\n         for elt in iterator { self.push_back(elt); }\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A: PartialEq> PartialEq for DList<A> {\n     fn eq(&self, other: &DList<A>) -> bool {\n         self.len() == other.len() &&\n@@ -848,32 +850,32 @@ impl<A: PartialEq> PartialEq for DList<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A: Eq> Eq for DList<A> {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A: PartialOrd> PartialOrd for DList<A> {\n     fn partial_cmp(&self, other: &DList<A>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A: Ord> Ord for DList<A> {\n     #[inline]\n     fn cmp(&self, other: &DList<A>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A: Clone> Clone for DList<A> {\n     fn clone(&self) -> DList<A> {\n         self.iter().map(|x| x.clone()).collect()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A: fmt::Show> fmt::Show for DList<A> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"DList [\"));\n@@ -887,7 +889,7 @@ impl<A: fmt::Show> fmt::Show for DList<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for DList<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);"}, {"sha": "ec5d7cbcda91425a55624d99d96d63c5dfd63e99", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -82,19 +82,22 @@ fn bit<E:CLike>(e: &E) -> uint {\n \n impl<E:CLike> EnumSet<E> {\n     /// Returns an empty `EnumSet`.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn new() -> EnumSet<E> {\n         EnumSet {bits: 0}\n     }\n \n     /// Returns the number of elements in the given `EnumSet`.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn len(&self) -> uint {\n         self.bits.count_ones()\n     }\n \n     /// Returns true if the `EnumSet` is empty.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_empty(&self) -> bool {\n         self.bits == 0\n     }\n@@ -104,19 +107,22 @@ impl<E:CLike> EnumSet<E> {\n     }\n \n     /// Returns `false` if the `EnumSet` contains any enum of the given `EnumSet`.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_disjoint(&self, other: &EnumSet<E>) -> bool {\n         (self.bits & other.bits) == 0\n     }\n \n     /// Returns `true` if a given `EnumSet` is included in this `EnumSet`.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_superset(&self, other: &EnumSet<E>) -> bool {\n         (self.bits & other.bits) == other.bits\n     }\n \n     /// Returns `true` if this `EnumSet` is included in the given `EnumSet`.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_subset(&self, other: &EnumSet<E>) -> bool {\n         other.is_superset(self)\n     }\n@@ -132,29 +138,33 @@ impl<E:CLike> EnumSet<E> {\n     }\n \n     /// Adds an enum to the `EnumSet`, and returns `true` if it wasn't there before\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn insert(&mut self, e: E) -> bool {\n         let result = !self.contains(&e);\n         self.bits |= bit(&e);\n         result\n     }\n \n     /// Removes an enum from the EnumSet\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn remove(&mut self, e: &E) -> bool {\n         let result = self.contains(e);\n         self.bits &= !bit(e);\n         result\n     }\n \n     /// Returns `true` if an `EnumSet` contains a given enum.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn contains(&self, e: &E) -> bool {\n         (self.bits & bit(e)) != 0\n     }\n \n     /// Returns an iterator over an `EnumSet`.\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn iter(&self) -> Iter<E> {\n         Iter::new(self.bits)\n     }"}, {"sha": "9663adfb39d04a3371c27080d496560ed3ec6923", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -14,7 +14,7 @@\n \n \n #![crate_name = \"collections\"]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -70,23 +70,25 @@ pub mod string;\n pub mod vec;\n pub mod vec_map;\n \n-#[unstable = \"RFC 509\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"RFC 509\")]\n pub mod bitv {\n     pub use bit::{Bitv, Iter};\n }\n \n-#[unstable = \"RFC 509\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"RFC 509\")]\n pub mod bitv_set {\n     pub use bit::{BitvSet, Union, Intersection, Difference, SymmetricDifference};\n     pub use bit::SetIter as Iter;\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub mod btree_map {\n     pub use btree::map::*;\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub mod btree_set {\n     pub use btree::set::*;\n }"}, {"sha": "317a56b818cf4baee617f879a0b0a1d2dc0112b6", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,7 +10,7 @@\n \n /// Creates a `Vec` containing the arguments.\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n macro_rules! vec {\n     ($x:expr; $y:expr) => ({\n         let xs: $crate::boxed::Box<[_]> = $crate::boxed::Box::new([$x; $y]);"}, {"sha": "156ba129bcb5bd71972c9f4502f9540c01c894e0", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 73, "deletions": 65, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -12,7 +12,7 @@\n //! ends of the container. It also has `O(1)` indexing like a vector. The contained elements are\n //! not required to be copyable, and the queue will be sendable if the contained type is sendable.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use core::prelude::*;\n \n@@ -36,7 +36,7 @@ static INITIAL_CAPACITY: uint = 7u; // 2^3 - 1\n static MINIMUM_CAPACITY: uint = 1u; // 2 - 1\n \n /// `RingBuf` is a circular buffer, which can be used as a double-ended queue efficiently.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct RingBuf<T> {\n     // tail and head are pointers into the buffer. Tail always points\n     // to the first element that could be read, Head always points\n@@ -50,21 +50,21 @@ pub struct RingBuf<T> {\n     ptr: *mut T\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n unsafe impl<T: Send> Send for RingBuf<T> {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n unsafe impl<T: Sync> Sync for RingBuf<T> {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Clone> Clone for RingBuf<T> {\n     fn clone(&self) -> RingBuf<T> {\n         self.iter().map(|t| t.clone()).collect()\n     }\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Drop for RingBuf<T> {\n     fn drop(&mut self) {\n         self.clear();\n@@ -78,7 +78,7 @@ impl<T> Drop for RingBuf<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Default for RingBuf<T> {\n     #[inline]\n     fn default() -> RingBuf<T> { RingBuf::new() }\n@@ -146,13 +146,13 @@ impl<T> RingBuf<T> {\n \n impl<T> RingBuf<T> {\n     /// Creates an empty `RingBuf`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new() -> RingBuf<T> {\n         RingBuf::with_capacity(INITIAL_CAPACITY)\n     }\n \n     /// Creates an empty `RingBuf` with space for at least `n` elements.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn with_capacity(n: uint) -> RingBuf<T> {\n         // +1 since the ringbuffer always leaves one space empty\n         let cap = cmp::max(n + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n@@ -191,7 +191,7 @@ impl<T> RingBuf<T> {\n     /// buf.push_back(5);\n     /// assert_eq!(buf.get(1).unwrap(), &4);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn get(&self, i: uint) -> Option<&T> {\n         if i < self.len() {\n             let idx = self.wrap_index(self.tail + i);\n@@ -221,7 +221,7 @@ impl<T> RingBuf<T> {\n     ///\n     /// assert_eq!(buf[1], 7);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self, i: uint) -> Option<&mut T> {\n         if i < self.len() {\n             let idx = self.wrap_index(self.tail + i);\n@@ -250,7 +250,7 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf[0], 5);\n     /// assert_eq!(buf[2], 3);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn swap(&mut self, i: uint, j: uint) {\n         assert!(i < self.len());\n         assert!(j < self.len());\n@@ -273,7 +273,7 @@ impl<T> RingBuf<T> {\n     /// assert!(buf.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint { self.cap - 1 }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n@@ -296,7 +296,7 @@ impl<T> RingBuf<T> {\n     /// buf.reserve_exact(10);\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         self.reserve(additional);\n     }\n@@ -317,7 +317,7 @@ impl<T> RingBuf<T> {\n     /// buf.reserve(10);\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         let new_len = self.len() + additional;\n         assert!(new_len + 1 > self.len(), \"capacity overflow\");\n@@ -480,7 +480,8 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf.len(), 1);\n     /// assert_eq!(Some(&5), buf.get(0));\n     /// ```\n-    #[unstable = \"matches collection reform specification; waiting on panic semantics\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification; waiting on panic semantics\")]\n     pub fn truncate(&mut self, len: uint) {\n         for _ in range(len, self.len()) {\n             self.pop_back();\n@@ -501,7 +502,7 @@ impl<T> RingBuf<T> {\n     /// let b: &[_] = &[&5, &3, &4];\n     /// assert_eq!(buf.iter().collect::<Vec<&int>>().as_slice(), b);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter {\n             tail: self.tail,\n@@ -527,7 +528,7 @@ impl<T> RingBuf<T> {\n     /// let b: &[_] = &[&mut 3, &mut 1, &mut 2];\n     /// assert_eq!(&buf.iter_mut().collect::<Vec<&mut int>>()[], b);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n         IterMut {\n             tail: self.tail,\n@@ -539,7 +540,7 @@ impl<T> RingBuf<T> {\n     }\n \n     /// Consumes the list into an iterator yielding elements by value.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter {\n             inner: self,\n@@ -549,7 +550,8 @@ impl<T> RingBuf<T> {\n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `RingBuf`.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn as_slices<'a>(&'a self) -> (&'a [T], &'a [T]) {\n         unsafe {\n             let contiguous = self.is_contiguous();\n@@ -568,7 +570,8 @@ impl<T> RingBuf<T> {\n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `RingBuf`.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn as_mut_slices<'a>(&'a mut self) -> (&'a mut [T], &'a mut [T]) {\n         unsafe {\n             let contiguous = self.is_contiguous();\n@@ -600,7 +603,7 @@ impl<T> RingBuf<T> {\n     /// v.push_back(1i);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { count(self.tail, self.head, self.cap) }\n \n     /// Returns true if the buffer contains no elements\n@@ -615,7 +618,7 @@ impl<T> RingBuf<T> {\n     /// v.push_front(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Creates a draining iterator that clears the `RingBuf` and iterates over\n@@ -632,7 +635,8 @@ impl<T> RingBuf<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<T> {\n         Drain {\n             inner: self,\n@@ -651,7 +655,7 @@ impl<T> RingBuf<T> {\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     #[inline]\n     pub fn clear(&mut self) {\n         self.drain();\n@@ -672,7 +676,7 @@ impl<T> RingBuf<T> {\n     /// d.push_back(2i);\n     /// assert_eq!(d.front(), Some(&1i));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn front(&self) -> Option<&T> {\n         if !self.is_empty() { Some(&self[0]) } else { None }\n     }\n@@ -696,7 +700,7 @@ impl<T> RingBuf<T> {\n     /// }\n     /// assert_eq!(d.front(), Some(&9i));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n         if !self.is_empty() { Some(&mut self[0]) } else { None }\n     }\n@@ -716,7 +720,7 @@ impl<T> RingBuf<T> {\n     /// d.push_back(2i);\n     /// assert_eq!(d.back(), Some(&2i));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n         if !self.is_empty() { Some(&self[self.len() - 1]) } else { None }\n     }\n@@ -740,7 +744,7 @@ impl<T> RingBuf<T> {\n     /// }\n     /// assert_eq!(d.back(), Some(&9i));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n         let len = self.len();\n         if !self.is_empty() { Some(&mut self[len - 1]) } else { None }\n@@ -762,7 +766,7 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(d.pop_front(), Some(2i));\n     /// assert_eq!(d.pop_front(), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn pop_front(&mut self) -> Option<T> {\n         if self.is_empty() {\n             None\n@@ -785,7 +789,7 @@ impl<T> RingBuf<T> {\n     /// d.push_front(2i);\n     /// assert_eq!(d.front(), Some(&2i));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn push_front(&mut self, t: T) {\n         if self.is_full() {\n             self.reserve(1);\n@@ -809,7 +813,7 @@ impl<T> RingBuf<T> {\n     /// buf.push_back(3);\n     /// assert_eq!(3, *buf.back().unwrap());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn push_back(&mut self, t: T) {\n         if self.is_full() {\n             self.reserve(1);\n@@ -835,7 +839,7 @@ impl<T> RingBuf<T> {\n     /// buf.push_back(3);\n     /// assert_eq!(buf.pop_back(), Some(3));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn pop_back(&mut self) -> Option<T> {\n         if self.is_empty() {\n             None\n@@ -872,7 +876,8 @@ impl<T> RingBuf<T> {\n     /// buf.push_back(10);\n     /// assert_eq!(buf.swap_back_remove(1), Some(99));\n     /// ```\n-    #[unstable = \"the naming of this function may be altered\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"the naming of this function may be altered\")]\n     pub fn swap_back_remove(&mut self, index: uint) -> Option<T> {\n         let length = self.len();\n         if length > 0 && index < length - 1 {\n@@ -904,7 +909,8 @@ impl<T> RingBuf<T> {\n     /// buf.push_back(20i);\n     /// assert_eq!(buf.swap_front_remove(3), Some(99));\n     /// ```\n-    #[unstable = \"the naming of this function may be altered\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"the naming of this function may be altered\")]\n     pub fn swap_front_remove(&mut self, index: uint) -> Option<T> {\n         let length = self.len();\n         if length > 0 && index < length && index != 0 {\n@@ -1137,7 +1143,7 @@ impl<T> RingBuf<T> {\n     /// buf.remove(2);\n     /// assert_eq!(Some(&15), buf.get(2));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn remove(&mut self, i: uint) -> Option<T> {\n         if self.is_empty() || self.len() <= i {\n             return None;\n@@ -1304,7 +1310,8 @@ impl<T: Clone> RingBuf<T> {\n     ///     assert_eq!(a, b);\n     /// }\n     /// ```\n-    #[unstable = \"matches collection reform specification; waiting on panic semantics\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification; waiting on panic semantics\")]\n     pub fn resize(&mut self, new_len: uint, value: T) {\n         let len = self.len();\n \n@@ -1331,7 +1338,7 @@ fn count(tail: uint, head: uint, size: uint) -> uint {\n }\n \n /// `RingBuf` iterator.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Iter<'a, T:'a> {\n     ring: &'a [T],\n     tail: uint,\n@@ -1349,7 +1356,7 @@ impl<'a, T> Clone for Iter<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n@@ -1370,7 +1377,7 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> {\n@@ -1382,10 +1389,10 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1408,7 +1415,7 @@ impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n //       with returning the mutable reference. I couldn't find a way to\n //       make the lifetime checker happy so, but there should be a way.\n /// `RingBuf` mutable iterator.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct IterMut<'a, T:'a> {\n     ptr: *mut T,\n     tail: uint,\n@@ -1417,7 +1424,7 @@ pub struct IterMut<'a, T:'a> {\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> Iterator for IterMut<'a, T> {\n     type Item = &'a mut T;\n \n@@ -1441,7 +1448,7 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut T> {\n@@ -1456,16 +1463,16 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// A by-value RingBuf iterator\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     inner: RingBuf<T>,\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n@@ -1481,25 +1488,26 @@ impl<T> Iterator for IntoIter<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.inner.pop_back()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /// A draining RingBuf iterator\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"matches collection reform specification, waiting for dust to settle\")]\n pub struct Drain<'a, T: 'a> {\n     inner: &'a mut RingBuf<T>,\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T: 'a> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n         for _ in *self {}\n@@ -1508,7 +1516,7 @@ impl<'a, T: 'a> Drop for Drain<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     type Item = T;\n \n@@ -1524,44 +1532,44 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.inner.pop_back()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A: PartialEq> PartialEq for RingBuf<A> {\n     fn eq(&self, other: &RingBuf<A>) -> bool {\n         self.len() == other.len() &&\n             self.iter().zip(other.iter()).all(|(a, b)| a.eq(b))\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A: Eq> Eq for RingBuf<A> {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A: PartialOrd> PartialOrd for RingBuf<A> {\n     fn partial_cmp(&self, other: &RingBuf<A>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A: Ord> Ord for RingBuf<A> {\n     #[inline]\n     fn cmp(&self, other: &RingBuf<A>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for RingBuf<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n@@ -1571,7 +1579,7 @@ impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for RingBuf<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A> Index<uint> for RingBuf<A> {\n     type Output = A;\n \n@@ -1581,7 +1589,7 @@ impl<A> Index<uint> for RingBuf<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A> IndexMut<uint> for RingBuf<A> {\n     type Output = A;\n \n@@ -1591,7 +1599,7 @@ impl<A> IndexMut<uint> for RingBuf<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A> FromIterator<A> for RingBuf<A> {\n     fn from_iter<T: Iterator<Item=A>>(iterator: T) -> RingBuf<A> {\n         let (lower, _) = iterator.size_hint();\n@@ -1601,7 +1609,7 @@ impl<A> FromIterator<A> for RingBuf<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A> Extend<A> for RingBuf<A> {\n     fn extend<T: Iterator<Item=A>>(&mut self, mut iterator: T) {\n         for elt in iterator {\n@@ -1610,7 +1618,7 @@ impl<A> Extend<A> for RingBuf<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: fmt::Show> fmt::Show for RingBuf<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"RingBuf [\"));"}, {"sha": "697ed77f06fa3ae64b13048ffafcf294e2c131b2", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 81, "deletions": 70, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -86,7 +86,7 @@\n //! * Further iterators exist that split, chunk or permute the slice.\n \n #![doc(primitive = \"slice\")]\n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use alloc::boxed::Box;\n use core::borrow::{BorrowFrom, BorrowFromMut, ToOwned};\n@@ -120,9 +120,9 @@ pub use core::slice::{from_raw_buf, from_raw_mut_buf};\n ////////////////////////////////////////////////////////////////////////////////\n \n /// Allocating extension methods for slices.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait SliceExt {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     type Item;\n \n     /// Sorts the slice, in place, using `compare` to compare\n@@ -142,7 +142,7 @@ pub trait SliceExt {\n     /// v.sort_by(|a, b| b.cmp(a));\n     /// assert!(v == [5, 4, 3, 2, 1]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn sort_by<F>(&mut self, compare: F) where F: FnMut(&Self::Item, &Self::Item) -> Ordering;\n \n     /// Consumes `src` and moves as many elements as it can into `self`\n@@ -166,7 +166,8 @@ pub trait SliceExt {\n     /// assert_eq!(num_moved, 3);\n     /// assert!(a == [6i, 7, 8, 4, 5]);\n     /// ```\n-    #[unstable = \"uncertain about this API approach\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"uncertain about this API approach\")]\n     fn move_from(&mut self, src: Vec<Self::Item>, start: uint, end: uint) -> uint;\n \n     /// Returns a subslice spanning the interval [`start`, `end`).\n@@ -175,23 +176,26 @@ pub trait SliceExt {\n     /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n     ///\n     /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"will be replaced by slice syntax\")]\n     fn slice(&self, start: uint, end: uint) -> &[Self::Item];\n \n     /// Returns a subslice from `start` to the end of the slice.\n     ///\n     /// Panics when `start` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"will be replaced by slice syntax\")]\n     fn slice_from(&self, start: uint) -> &[Self::Item];\n \n     /// Returns a subslice from the start of the slice to `end`.\n     ///\n     /// Panics when `end` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing to `0` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"will be replaced by slice syntax\")]\n     fn slice_to(&self, end: uint) -> &[Self::Item];\n \n     /// Divides one slice into two at an index.\n@@ -201,31 +205,31 @@ pub trait SliceExt {\n     /// indices from `[mid, len)` (excluding the index `len` itself).\n     ///\n     /// Panics if `mid > len`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn split_at(&self, mid: uint) -> (&[Self::Item], &[Self::Item]);\n \n     /// Returns an iterator over the slice\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn iter(&self) -> Iter<Self::Item>;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`.  The matched element is not contained in the subslices.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn split<F>(&self, pred: F) -> Split<Self::Item, F>\n                 where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn splitn<F>(&self, n: uint, pred: F) -> SplitN<Self::Item, F>\n                  where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<Self::Item, F>\n                   where F: FnMut(&Self::Item) -> bool;\n \n@@ -248,7 +252,7 @@ pub trait SliceExt {\n     ///     println!(\"{:?}\", win);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn windows(&self, size: uint) -> Windows<Self::Item>;\n \n     /// Returns an iterator over `size` elements of the slice at a\n@@ -271,33 +275,33 @@ pub trait SliceExt {\n     ///     println!(\"{:?}\", win);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn chunks(&self, size: uint) -> Chunks<Self::Item>;\n \n     /// Returns the element of a slice at the given index, or `None` if the\n     /// index is out of bounds.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn get(&self, index: uint) -> Option<&Self::Item>;\n \n     /// Returns the first element of a slice, or `None` if it is empty.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn first(&self) -> Option<&Self::Item>;\n \n     /// Returns all but the first element of a slice.\n-    #[unstable = \"likely to be renamed\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"likely to be renamed\")]\n     fn tail(&self) -> &[Self::Item];\n \n     /// Returns all but the last element of a slice.\n-    #[unstable = \"likely to be renamed\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"likely to be renamed\")]\n     fn init(&self) -> &[Self::Item];\n \n     /// Returns the last element of a slice, or `None` if it is empty.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn last(&self) -> Option<&Self::Item>;\n \n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     unsafe fn get_unchecked(&self, index: uint) -> &Self::Item;\n \n     /// Returns an unsafe pointer to the slice's buffer\n@@ -307,7 +311,7 @@ pub trait SliceExt {\n     ///\n     /// Modifying the slice may cause its buffer to be reallocated, which\n     /// would also make any pointers to it invalid.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn as_ptr(&self) -> *const Self::Item;\n \n     /// Binary search a sorted slice with a comparator function.\n@@ -342,7 +346,7 @@ pub trait SliceExt {\n     /// let r = s.binary_search_by(|probe| probe.cmp(&seek));\n     /// assert!(match r { Ok(1...4) => true, _ => false, });\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn binary_search_by<F>(&self, f: F) -> Result<uint, uint> where\n         F: FnMut(&Self::Item) -> Ordering;\n \n@@ -354,7 +358,7 @@ pub trait SliceExt {\n     /// let a = [1i, 2, 3];\n     /// assert_eq!(a.len(), 3);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn len(&self) -> uint;\n \n     /// Returns true if the slice has a length of 0\n@@ -366,16 +370,16 @@ pub trait SliceExt {\n     /// assert!(!a.is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn is_empty(&self) -> bool { self.len() == 0 }\n     /// Returns a mutable reference to the element at the given index,\n     /// or `None` if the index is out of bounds\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn get_mut(&mut self, index: uint) -> Option<&mut Self::Item>;\n \n     /// Work with `self` as a mut slice.\n     /// Primarily intended for getting a &mut [T] from a [T; N].\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn as_mut_slice(&mut self) -> &mut [Self::Item];\n \n     /// Returns a mutable subslice spanning the interval [`start`, `end`).\n@@ -384,63 +388,68 @@ pub trait SliceExt {\n     /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n     ///\n     /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"will be replaced by slice syntax\")]\n     fn slice_mut(&mut self, start: uint, end: uint) -> &mut [Self::Item];\n \n     /// Returns a mutable subslice from `start` to the end of the slice.\n     ///\n     /// Panics when `start` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"will be replaced by slice syntax\")]\n     fn slice_from_mut(&mut self, start: uint) -> &mut [Self::Item];\n \n     /// Returns a mutable subslice from the start of the slice to `end`.\n     ///\n     /// Panics when `end` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing to `0` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"will be replaced by slice syntax\")]\n     fn slice_to_mut(&mut self, end: uint) -> &mut [Self::Item];\n \n     /// Returns an iterator that allows modifying each value\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn iter_mut(&mut self) -> IterMut<Self::Item>;\n \n     /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn first_mut(&mut self) -> Option<&mut Self::Item>;\n \n     /// Returns all but the first element of a mutable slice\n-    #[unstable = \"likely to be renamed or removed\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"likely to be renamed or removed\")]\n     fn tail_mut(&mut self) -> &mut [Self::Item];\n \n     /// Returns all but the last element of a mutable slice\n-    #[unstable = \"likely to be renamed or removed\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"likely to be renamed or removed\")]\n     fn init_mut(&mut self) -> &mut [Self::Item];\n \n     /// Returns a mutable pointer to the last item in the slice.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn last_mut(&mut self) -> Option<&mut Self::Item>;\n \n     /// Returns an iterator over mutable subslices separated by elements that\n     /// match `pred`.  The matched element is not contained in the subslices.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn split_mut<F>(&mut self, pred: F) -> SplitMut<Self::Item, F>\n                     where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<Self::Item, F>\n                      where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<Self::Item, F>\n                       where F: FnMut(&Self::Item) -> bool;\n \n@@ -452,7 +461,7 @@ pub trait SliceExt {\n     /// # Panics\n     ///\n     /// Panics if `chunk_size` is 0.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<Self::Item>;\n \n     /// Swaps two elements in a slice.\n@@ -473,7 +482,7 @@ pub trait SliceExt {\n     /// v.swap(1, 3);\n     /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn swap(&mut self, a: uint, b: uint);\n \n     /// Divides one `&mut` into two at an index.\n@@ -510,7 +519,7 @@ pub trait SliceExt {\n     ///     assert!(right == []);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn split_at_mut(&mut self, mid: uint) -> (&mut [Self::Item], &mut [Self::Item]);\n \n     /// Reverse the order of elements in a slice, in place.\n@@ -522,11 +531,11 @@ pub trait SliceExt {\n     /// v.reverse();\n     /// assert!(v == [3i, 2, 1]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn reverse(&mut self);\n \n     /// Returns an unsafe mutable pointer to the element in index\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut Self::Item;\n \n     /// Return an unsafe mutable pointer to the slice's buffer.\n@@ -537,11 +546,11 @@ pub trait SliceExt {\n     /// Modifying the slice may cause its buffer to be reallocated, which\n     /// would also make any pointers to it invalid.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn as_mut_ptr(&mut self) -> *mut Self::Item;\n \n     /// Copies `self` into a new `Vec`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn to_vec(&self) -> Vec<Self::Item> where Self::Item: Clone;\n \n     /// Creates an iterator that yields every possible permutation of the\n@@ -568,7 +577,7 @@ pub trait SliceExt {\n     /// assert_eq!(Some(vec![1i, 3, 2]), perms.next());\n     /// assert_eq!(Some(vec![3i, 1, 2]), perms.next());\n     /// ```\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     fn permutations(&self) -> Permutations<Self::Item> where Self::Item: Clone;\n \n     /// Copies as many elements from `src` as it can into `self` (the\n@@ -588,7 +597,7 @@ pub trait SliceExt {\n     /// assert!(dst.clone_from_slice(&src2) == 3);\n     /// assert!(dst == [3i, 4, 5]);\n     /// ```\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     fn clone_from_slice(&mut self, &[Self::Item]) -> uint where Self::Item: Clone;\n \n     /// Sorts the slice, in place.\n@@ -603,7 +612,7 @@ pub trait SliceExt {\n     /// v.sort();\n     /// assert!(v == [-5i, -3, 1, 2, 4]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn sort(&mut self) where Self::Item: Ord;\n \n     /// Binary search a sorted slice for a given element.\n@@ -629,11 +638,11 @@ pub trait SliceExt {\n     /// let r = s.binary_search(&1);\n     /// assert!(match r { Ok(1...4) => true, _ => false, });\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn binary_search(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord;\n \n     /// Deprecated: use `binary_search` instead.\n-    #[deprecated = \"use binary_search instead\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\", reason = \"use binary_search instead\")]\n     fn binary_search_elem(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord {\n         self.binary_search(x)\n     }\n@@ -654,7 +663,8 @@ pub trait SliceExt {\n     /// let b: &mut [_] = &mut [1i, 0, 2];\n     /// assert!(v == b);\n     /// ```\n-    #[unstable = \"uncertain if this merits inclusion in std\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"uncertain if this merits inclusion in std\")]\n     fn next_permutation(&mut self) -> bool where Self::Item: Ord;\n \n     /// Mutates the slice to the previous lexicographic permutation.\n@@ -673,35 +683,36 @@ pub trait SliceExt {\n     /// let b: &mut [_] = &mut [0i, 1, 2];\n     /// assert!(v == b);\n     /// ```\n-    #[unstable = \"uncertain if this merits inclusion in std\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"uncertain if this merits inclusion in std\")]\n     fn prev_permutation(&mut self) -> bool where Self::Item: Ord;\n \n     /// Find the first index containing a matching value.\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     fn position_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n \n     /// Find the last index containing a matching value.\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     fn rposition_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n \n     /// Return true if the slice contains an element with the given value.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn contains(&self, x: &Self::Item) -> bool where Self::Item: PartialEq;\n \n     /// Returns true if `needle` is a prefix of the slice.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn starts_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n \n     /// Returns true if `needle` is a suffix of the slice.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n \n     /// Convert `self` into a vector without clones or allocation.\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     fn into_vec(self: Box<Self>) -> Vec<Self::Item>;\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> SliceExt for [T] {\n     type Item = T;\n \n@@ -989,16 +1000,16 @@ impl<T> SliceExt for [T] {\n ////////////////////////////////////////////////////////////////////////////////\n // Extension traits for slices over specific kinds of data\n ////////////////////////////////////////////////////////////////////////////////\n-#[unstable = \"U should be an associated type\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"U should be an associated type\")]\n /// An extension trait for concatenating slices\n pub trait SliceConcatExt<T: ?Sized, U> {\n     /// Flattens a slice of `T` into a single value `U`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn concat(&self) -> U;\n \n     /// Flattens a slice of `T` into a single value `U`, placing a\n     /// given separator between each.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn connect(&self, sep: &T) -> U;\n }\n \n@@ -1034,7 +1045,7 @@ impl<T: Clone, V: AsSlice<T>> SliceConcatExt<T, Vec<T>> for [V] {\n ///\n /// The last generated swap is always (0, 1), and it returns the\n /// sequence to its initial order.\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct ElementSwaps {\n     sdir: Vec<SizeDirection>,\n@@ -1046,7 +1057,7 @@ pub struct ElementSwaps {\n \n impl ElementSwaps {\n     /// Creates an `ElementSwaps` iterator for a sequence of `length` elements.\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn new(length: uint) -> ElementSwaps {\n         // Initialize `sdir` with a direction that position should move in\n         // (all negative at the beginning) and the `size` of the\n@@ -1063,17 +1074,17 @@ impl ElementSwaps {\n // Standard trait implementations for slices\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is unstable\")]\n impl<T> BorrowFrom<Vec<T>> for [T] {\n     fn borrow_from(owned: &Vec<T>) -> &[T] { &owned[] }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is unstable\")]\n impl<T> BorrowFromMut<Vec<T>> for [T] {\n     fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { &mut owned[] }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is unstable\")]\n impl<T: Clone> ToOwned<Vec<T>> for [T] {\n     fn to_owned(&self) -> Vec<T> { self.to_vec() }\n }\n@@ -1092,7 +1103,7 @@ struct SizeDirection {\n     dir: Direction,\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl Iterator for ElementSwaps {\n     type Item = (uint, uint);\n \n@@ -1155,13 +1166,13 @@ impl Iterator for ElementSwaps {\n /// swap applied.\n ///\n /// Generates even and odd permutations alternately.\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub struct Permutations<T> {\n     swaps: ElementSwaps,\n     v: Vec<T>,\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is unstable\")]\n impl<T: Clone> Iterator for Permutations<T> {\n     type Item = Vec<T>;\n "}, {"sha": "e5e612b8128f77617d209f8f286d8115e5d8bb68", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 90, "deletions": 64, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -50,7 +50,7 @@\n //! is the same as `&[u8]`.\n \n #![doc(primitive = \"str\")]\n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use self::RecompositionState::*;\n use self::DecompositionType::*;\n@@ -165,15 +165,15 @@ enum DecompositionType {\n /// External iterator for a string's decomposition's characters.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub struct Decompositions<'a> {\n     kind: DecompositionType,\n     iter: Chars<'a>,\n     buffer: Vec<(char, u8)>,\n     sorted: bool\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> Iterator for Decompositions<'a> {\n     type Item = char;\n \n@@ -255,7 +255,7 @@ enum RecompositionState {\n /// External iterator for a string's recomposition's characters.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub struct Recompositions<'a> {\n     iter: Decompositions<'a>,\n     state: RecompositionState,\n@@ -264,7 +264,7 @@ pub struct Recompositions<'a> {\n     last_ccc: Option<u8>\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> Iterator for Recompositions<'a> {\n     type Item = char;\n \n@@ -352,12 +352,12 @@ impl<'a> Iterator for Recompositions<'a> {\n /// External iterator for a string's UTF16 codeunits.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub struct Utf16Units<'a> {\n     encoder: Utf16Encoder<Chars<'a>>\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> Iterator for Utf16Units<'a> {\n     type Item = u16;\n \n@@ -384,12 +384,12 @@ macro_rules! utf8_acc_cont_byte {\n     ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as u32)\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is unstable\")]\n impl BorrowFrom<String> for str {\n     fn borrow_from(owned: &String) -> &str { &owned[] }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is unstable\")]\n impl ToOwned<String> for str {\n     fn to_owned(&self) -> String {\n         unsafe {\n@@ -407,16 +407,18 @@ Section: Trait implementations\n */\n \n /// Any string that can be represented as a slice.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait StrExt: Index<FullRange, Output = str> {\n     /// Escapes each char in `s` with `char::escape_default`.\n-    #[unstable = \"return type may change to be an iterator\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"return type may change to be an iterator\")]\n     fn escape_default(&self) -> String {\n         self.chars().flat_map(|c| c.escape_default()).collect()\n     }\n \n     /// Escapes each char in `s` with `char::escape_unicode`.\n-    #[unstable = \"return type may change to be an iterator\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"return type may change to be an iterator\")]\n     fn escape_unicode(&self) -> String {\n         self.chars().flat_map(|c| c.escape_unicode()).collect()\n     }\n@@ -445,7 +447,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// // not found, so no change.\n     /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn replace(&self, from: &str, to: &str) -> String {\n         let mut result = String::new();\n         let mut last_end = 0;\n@@ -461,7 +463,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// Returns an iterator over the string in Unicode Normalization Form D\n     /// (canonical decomposition).\n     #[inline]\n-    #[unstable = \"this functionality may be moved to libunicode\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"this functionality may be moved to libunicode\")]\n     fn nfd_chars<'a>(&'a self) -> Decompositions<'a> {\n         Decompositions {\n             iter: self[].chars(),\n@@ -474,7 +477,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// Returns an iterator over the string in Unicode Normalization Form KD\n     /// (compatibility decomposition).\n     #[inline]\n-    #[unstable = \"this functionality may be moved to libunicode\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"this functionality may be moved to libunicode\")]\n     fn nfkd_chars<'a>(&'a self) -> Decompositions<'a> {\n         Decompositions {\n             iter: self[].chars(),\n@@ -487,7 +491,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// An Iterator over the string in Unicode Normalization Form C\n     /// (canonical decomposition followed by canonical composition).\n     #[inline]\n-    #[unstable = \"this functionality may be moved to libunicode\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"this functionality may be moved to libunicode\")]\n     fn nfc_chars<'a>(&'a self) -> Recompositions<'a> {\n         Recompositions {\n             iter: self.nfd_chars(),\n@@ -501,7 +506,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// An Iterator over the string in Unicode Normalization Form KC\n     /// (compatibility decomposition followed by canonical composition).\n     #[inline]\n-    #[unstable = \"this functionality may be moved to libunicode\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"this functionality may be moved to libunicode\")]\n     fn nfkc_chars<'a>(&'a self) -> Recompositions<'a> {\n         Recompositions {\n             iter: self.nfkd_chars(),\n@@ -523,7 +529,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```rust\n     /// assert!(\"bananas\".contains(\"nana\"));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn contains(&self, pat: &str) -> bool {\n         core_str::StrExt::contains(&self[], pat)\n     }\n@@ -539,7 +545,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```rust\n     /// assert!(\"hello\".contains_char('e'));\n     /// ```\n-    #[unstable = \"might get removed in favour of a more generic contains()\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"might get removed in favour of a more generic contains()\")]\n     fn contains_char<P: CharEq>(&self, pat: P) -> bool {\n         core_str::StrExt::contains_char(&self[], pat)\n     }\n@@ -553,7 +560,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<char> = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n     /// assert_eq!(v, vec!['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn chars(&self) -> Chars {\n         core_str::StrExt::chars(&self[])\n     }\n@@ -566,13 +573,13 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<u8> = \"bors\".bytes().collect();\n     /// assert_eq!(v, b\"bors\".to_vec());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn bytes(&self) -> Bytes {\n         core_str::StrExt::bytes(&self[])\n     }\n \n     /// An iterator over the characters of `self` and their byte offsets.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn char_indices(&self) -> CharIndices {\n         core_str::StrExt::char_indices(&self[])\n     }\n@@ -595,7 +602,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = \"\".split('X').collect();\n     /// assert_eq!(v, vec![\"\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn split<P: CharEq>(&self, pat: P) -> Split<P> {\n         core_str::StrExt::split(&self[], pat)\n     }\n@@ -622,7 +629,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n     /// assert_eq!(v, vec![\"\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn splitn<P: CharEq>(&self, count: uint, pat: P) -> SplitN<P> {\n         core_str::StrExt::splitn(&self[], count, pat)\n     }\n@@ -651,7 +658,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').rev().collect();\n     /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"\", \"lion\"]);\n     /// ```\n-    #[unstable = \"might get removed\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"might get removed\")]\n     fn split_terminator<P: CharEq>(&self, pat: P) -> SplitTerminator<P> {\n         core_str::StrExt::split_terminator(&self[], pat)\n     }\n@@ -672,7 +679,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n     /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"lionX\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn rsplitn<P: CharEq>(&self, count: uint, pat: P) -> RSplitN<P> {\n         core_str::StrExt::rsplitn(&self[], count, pat)\n     }\n@@ -697,7 +704,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<(uint, uint)> = \"ababa\".match_indices(\"aba\").collect();\n     /// assert_eq!(v, vec![(0, 3)]); // only the first `aba`\n     /// ```\n-    #[unstable = \"might have its iterator type changed\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"might have its iterator type changed\")]\n     fn match_indices<'a>(&'a self, pat: &'a str) -> MatchIndices<'a> {\n         core_str::StrExt::match_indices(&self[], pat)\n     }\n@@ -713,7 +721,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = \"1abcabc2\".split_str(\"abc\").collect();\n     /// assert_eq!(v, vec![\"1\", \"\", \"2\"]);\n     /// ```\n-    #[unstable = \"might get removed in the future in favor of a more generic split()\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"might get removed in the future in favor of a more generic split()\")]\n     fn split_str<'a>(&'a self, pat: &'a str) -> SplitStr<'a> {\n         core_str::StrExt::split_str(&self[], pat)\n     }\n@@ -729,7 +738,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = four_lines.lines().collect();\n     /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn lines(&self) -> Lines {\n         core_str::StrExt::lines(&self[])\n     }\n@@ -745,7 +754,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = four_lines.lines_any().collect();\n     /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn lines_any(&self) -> LinesAny {\n         core_str::StrExt::lines_any(&self[])\n     }\n@@ -780,7 +789,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// // byte 100 is outside the string\n     /// // s.slice(3, 100);\n     /// ```\n-    #[unstable = \"use slice notation [a..b] instead\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"use slice notation [a..b] instead\")]\n     fn slice(&self, begin: uint, end: uint) -> &str {\n         core_str::StrExt::slice(&self[], begin, end)\n     }\n@@ -793,7 +803,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// out of bounds.\n     ///\n     /// See also `slice`, `slice_to` and `slice_chars`.\n-    #[unstable = \"use slice notation [a..] instead\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"use slice notation [a..] instead\")]\n     fn slice_from(&self, begin: uint) -> &str {\n         core_str::StrExt::slice_from(&self[], begin)\n     }\n@@ -807,7 +818,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// out of bounds.\n     ///\n     /// See also `slice`, `slice_from` and `slice_chars`.\n-    #[unstable = \"use slice notation [..a] instead\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"use slice notation [..a] instead\")]\n     fn slice_to(&self, end: uint) -> &str {\n         core_str::StrExt::slice_to(&self[], end)\n     }\n@@ -835,7 +847,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n     /// assert_eq!(s.slice_chars(5, 7), \"\u8001\u864e\");\n     /// ```\n-    #[unstable = \"may have yet to prove its worth\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"may have yet to prove its worth\")]\n     fn slice_chars(&self, begin: uint, end: uint) -> &str {\n         core_str::StrExt::slice_chars(&self[], begin, end)\n     }\n@@ -846,7 +859,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     ///\n     /// Caller must check both UTF-8 character boundaries and the boundaries of\n     /// the entire slice as well.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     unsafe fn slice_unchecked(&self, begin: uint, end: uint) -> &str {\n         core_str::StrExt::slice_unchecked(&self[], begin, end)\n     }\n@@ -858,7 +871,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```rust\n     /// assert!(\"banana\".starts_with(\"ba\"));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn starts_with(&self, pat: &str) -> bool {\n         core_str::StrExt::starts_with(&self[], pat)\n     }\n@@ -870,7 +883,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```rust\n     /// assert!(\"banana\".ends_with(\"nana\"));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn ends_with(&self, pat: &str) -> bool {\n         core_str::StrExt::ends_with(&self[], pat)\n     }\n@@ -890,7 +903,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n     /// assert_eq!(\"123foo1bar123\".trim_matches(|&: c: char| c.is_numeric()), \"foo1bar\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn trim_matches<P: CharEq>(&self, pat: P) -> &str {\n         core_str::StrExt::trim_matches(&self[], pat)\n     }\n@@ -910,7 +923,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n     /// assert_eq!(\"123foo1bar123\".trim_left_matches(|&: c: char| c.is_numeric()), \"foo1bar123\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn trim_left_matches<P: CharEq>(&self, pat: P) -> &str {\n         core_str::StrExt::trim_left_matches(&self[], pat)\n     }\n@@ -930,7 +943,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n     /// assert_eq!(\"123foo1bar123\".trim_right_matches(|&: c: char| c.is_numeric()), \"123foo1bar\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn trim_right_matches<P: CharEq>(&self, pat: P) -> &str {\n         core_str::StrExt::trim_right_matches(&self[], pat)\n     }\n@@ -958,7 +971,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// // third byte of `\u8001`\n     /// assert!(!s.is_char_boundary(8));\n     /// ```\n-    #[unstable = \"naming is uncertain with container conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"naming is uncertain with container conventions\")]\n     fn is_char_boundary(&self, index: uint) -> bool {\n         core_str::StrExt::is_char_boundary(&self[], index)\n     }\n@@ -1016,7 +1030,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     ///\n     /// If `i` is greater than or equal to the length of the string.\n     /// If `i` is not the index of the beginning of a valid UTF-8 character.\n-    #[unstable = \"naming is uncertain with container conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"naming is uncertain with container conventions\")]\n     fn char_range_at(&self, start: uint) -> CharRange {\n         core_str::StrExt::char_range_at(&self[], start)\n     }\n@@ -1031,7 +1046,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     ///\n     /// If `i` is greater than the length of the string.\n     /// If `i` is not an index following a valid UTF-8 character.\n-    #[unstable = \"naming is uncertain with container conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"naming is uncertain with container conventions\")]\n     fn char_range_at_reverse(&self, start: uint) -> CharRange {\n         core_str::StrExt::char_range_at_reverse(&self[], start)\n     }\n@@ -1051,7 +1067,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     ///\n     /// If `i` is greater than or equal to the length of the string.\n     /// If `i` is not the index of the beginning of a valid UTF-8 character.\n-    #[unstable = \"naming is uncertain with container conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"naming is uncertain with container conventions\")]\n     fn char_at(&self, i: uint) -> char {\n         core_str::StrExt::char_at(&self[], i)\n     }\n@@ -1062,7 +1079,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     ///\n     /// If `i` is greater than the length of the string.\n     /// If `i` is not an index following a valid UTF-8 character.\n-    #[unstable = \"naming is uncertain with container conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"naming is uncertain with container conventions\")]\n     fn char_at_reverse(&self, i: uint) -> char {\n         core_str::StrExt::char_at_reverse(&self[], i)\n     }\n@@ -1074,7 +1092,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```rust\n     /// assert_eq!(\"bors\".as_bytes(), b\"bors\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn as_bytes(&self) -> &[u8] {\n         core_str::StrExt::as_bytes(&self[])\n     }\n@@ -1102,7 +1120,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(s.find(x), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn find<P: CharEq>(&self, pat: P) -> Option<uint> {\n         core_str::StrExt::find(&self[], pat)\n     }\n@@ -1130,7 +1148,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(s.rfind(x), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn rfind<P: CharEq>(&self, pat: P) -> Option<uint> {\n         core_str::StrExt::rfind(&self[], pat)\n     }\n@@ -1154,7 +1172,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(s.find_str(\"\u8001\u864e L\"), Some(6));\n     /// assert_eq!(s.find_str(\"muffin man\"), None);\n     /// ```\n-    #[unstable = \"might get removed in favor of a more generic find in the future\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"might get removed in favor of a more generic find in the future\")]\n     fn find_str(&self, needle: &str) -> Option<uint> {\n         core_str::StrExt::find_str(&self[], needle)\n     }\n@@ -1177,7 +1196,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(c, '\u00f6');\n     /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n     /// ```\n-    #[unstable = \"awaiting conventions about shifting and slices\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"awaiting conventions about shifting and slices\")]\n     fn slice_shift_char(&self) -> Option<(char, &str)> {\n         core_str::StrExt::slice_shift_char(&self[])\n     }\n@@ -1196,7 +1216,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n     /// assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n     /// ```\n-    #[unstable = \"awaiting convention about comparability of arbitrary slices\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"awaiting convention about comparability of arbitrary slices\")]\n     fn subslice_offset(&self, inner: &str) -> uint {\n         core_str::StrExt::subslice_offset(&self[], inner)\n     }\n@@ -1206,14 +1227,15 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// The caller must ensure that the string outlives this pointer,\n     /// and that it is not reallocated (e.g. by pushing to the\n     /// string).\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     #[inline]\n     fn as_ptr(&self) -> *const u8 {\n         core_str::StrExt::as_ptr(&self[])\n     }\n \n     /// Return an iterator of `u16` over the string encoded as UTF-16.\n-    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"this functionality may only be provided by libunicode\")]\n     fn utf16_units(&self) -> Utf16Units {\n         Utf16Units { encoder: Utf16Encoder::new(self[].chars()) }\n     }\n@@ -1226,7 +1248,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(\"foo\".len(), 3);\n     /// assert_eq!(\"\u0192oo\".len(), 4);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     #[inline]\n     fn len(&self) -> uint {\n         core_str::StrExt::len(&self[])\n@@ -1240,7 +1262,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert!(\"\".is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn is_empty(&self) -> bool {\n         core_str::StrExt::is_empty(&self[])\n     }\n@@ -1254,7 +1276,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(\"j\".parse::<u32>(), None);\n     /// ```\n     #[inline]\n-    #[unstable = \"this method was just created\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"this method was just created\")]\n     fn parse<F: FromStr>(&self) -> Option<F> {\n         core_str::StrExt::parse(&self[])\n     }\n@@ -1278,7 +1301,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let b: &[_] = &[\"a\", \"\\r\\n\", \"b\", \"\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\"];\n     /// assert_eq!(gr2.as_slice(), b);\n     /// ```\n-    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"this functionality may only be provided by libunicode\")]\n     fn graphemes(&self, is_extended: bool) -> Graphemes {\n         UnicodeStr::graphemes(&self[], is_extended)\n     }\n@@ -1293,7 +1317,8 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let b: &[_] = &[(0u, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n     /// assert_eq!(gr_inds.as_slice(), b);\n     /// ```\n-    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"this functionality may only be provided by libunicode\")]\n     fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n         UnicodeStr::grapheme_indices(&self[], is_extended)\n     }\n@@ -1309,7 +1334,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = some_words.words().collect();\n     /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn words(&self) -> Words {\n         UnicodeStr::words(&self[])\n     }\n@@ -1323,31 +1348,32 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n     /// recommends that these characters be treated as 1 column (i.e.,\n     /// `is_cjk` = `false`) if the locale is unknown.\n-    #[unstable = \"this functionality may only be provided by libunicode\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"this functionality may only be provided by libunicode\")]\n     fn width(&self, is_cjk: bool) -> uint {\n         UnicodeStr::width(&self[], is_cjk)\n     }\n \n     /// Returns a string with leading and trailing whitespace removed.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn trim(&self) -> &str {\n         UnicodeStr::trim(&self[])\n     }\n \n     /// Returns a string with leading whitespace removed.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn trim_left(&self) -> &str {\n         UnicodeStr::trim_left(&self[])\n     }\n \n     /// Returns a string with trailing whitespace removed.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn trim_right(&self) -> &str {\n         UnicodeStr::trim_right(&self[])\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl StrExt for str {}\n \n #[cfg(test)]"}, {"sha": "d23be315481a39779a99c7720dd6c13a88576a9d", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 58, "deletions": 54, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -12,7 +12,7 @@\n \n //! An owned, growable string that enforces that its contents are valid UTF-8.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use core::prelude::*;\n \n@@ -33,20 +33,20 @@ use vec::{DerefVec, Vec, as_vec};\n \n /// A growable string stored as a UTF-8 encoded buffer.\n #[derive(Clone, PartialOrd, Eq, Ord)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct String {\n     vec: Vec<u8>,\n }\n \n /// A possible error value from the `String::from_utf8` function.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct FromUtf8Error {\n     bytes: Vec<u8>,\n     error: Utf8Error,\n }\n \n /// A possible error value from the `String::from_utf16` function.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #[allow(missing_copy_implementations)]\n pub struct FromUtf16Error(());\n \n@@ -59,7 +59,7 @@ impl String {\n     /// let mut s = String::new();\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new() -> String {\n         String {\n             vec: Vec::new(),\n@@ -76,7 +76,7 @@ impl String {\n     /// let mut s = String::with_capacity(10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> String {\n         String {\n             vec: Vec::with_capacity(capacity),\n@@ -92,7 +92,8 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"hello\");\n     /// ```\n     #[inline]\n-    #[unstable = \"needs investigation to see if to_string() can match perf\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"needs investigation to see if to_string() can match perf\")]\n     pub fn from_str(string: &str) -> String {\n         String { vec: ::slice::SliceExt::to_vec(string.as_bytes()) }\n     }\n@@ -120,7 +121,7 @@ impl String {\n     /// assert_eq!(s.into_bytes(), vec![240, 144, 128]);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> {\n         match str::from_utf8(vec.as_slice()) {\n             Ok(..) => Ok(String { vec: vec }),\n@@ -138,7 +139,7 @@ impl String {\n     /// let output = String::from_utf8_lossy(input);\n     /// assert_eq!(output.as_slice(), \"Hello \\u{FFFD}World\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> CowString<'a> {\n         let mut i = 0;\n         match str::from_utf8(v) {\n@@ -276,7 +277,7 @@ impl String {\n     /// v[4] = 0xD800;\n     /// assert!(String::from_utf16(v).is_err());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn from_utf16(v: &[u16]) -> Result<String, FromUtf16Error> {\n         let mut s = String::with_capacity(v.len());\n         for c in unicode_str::utf16_items(v) {\n@@ -303,7 +304,7 @@ impl String {\n     ///            \"\ud834\udd1emus\\u{FFFD}ic\\u{FFFD}\".to_string());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn from_utf16_lossy(v: &[u16]) -> String {\n         unicode_str::utf16_items(v).map(|c| c.to_char_lossy()).collect()\n     }\n@@ -314,7 +315,7 @@ impl String {\n     /// * We call `Vec::from_raw_parts` to get a `Vec<u8>`;\n     /// * We assume that the `Vec` contains valid UTF-8.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub unsafe fn from_raw_parts(buf: *mut u8, length: uint, capacity: uint) -> String {\n         String {\n             vec: Vec::from_raw_parts(buf, length, capacity),\n@@ -325,7 +326,7 @@ impl String {\n     /// it contains valid UTF-8. This is unsafe because it assumes that\n     /// the UTF-8-ness of the vector has already been validated.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub unsafe fn from_utf8_unchecked(bytes: Vec<u8>) -> String {\n         String { vec: bytes }\n     }\n@@ -340,7 +341,7 @@ impl String {\n     /// assert_eq!(bytes, vec![104, 101, 108, 108, 111]);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn into_bytes(self) -> Vec<u8> {\n         self.vec\n     }\n@@ -355,7 +356,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"foobar\");\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn push_str(&mut self, string: &str) {\n         self.vec.push_all(string.as_bytes())\n     }\n@@ -370,7 +371,7 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.vec.capacity()\n     }\n@@ -391,7 +392,7 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         self.vec.reserve(additional)\n     }\n@@ -416,7 +417,7 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         self.vec.reserve_exact(additional)\n     }\n@@ -433,7 +434,7 @@ impl String {\n     /// assert_eq!(s.capacity(), 3);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         self.vec.shrink_to_fit()\n     }\n@@ -450,7 +451,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"abc123\");\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn push(&mut self, ch: char) {\n         if (ch as u32) < 0x80 {\n             self.vec.push(ch as u8);\n@@ -483,7 +484,7 @@ impl String {\n     /// assert_eq!(s.as_bytes(), b);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n         self.vec.as_slice()\n     }\n@@ -503,7 +504,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"he\");\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, new_len: uint) {\n         assert!(self.is_char_boundary(new_len));\n         self.vec.truncate(new_len)\n@@ -522,7 +523,7 @@ impl String {\n     /// assert_eq!(s.pop(), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<char> {\n         let len = self.len();\n         if len == 0 {\n@@ -558,7 +559,7 @@ impl String {\n     /// assert_eq!(s.remove(0), 'o');\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn remove(&mut self, idx: uint) -> char {\n         let len = self.len();\n         assert!(idx <= len);\n@@ -585,7 +586,7 @@ impl String {\n     /// If `idx` does not lie on a character boundary or is out of bounds, then\n     /// this function will panic.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn insert(&mut self, idx: uint, ch: char) {\n         let len = self.len();\n         assert!(idx <= len);\n@@ -622,7 +623,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"olleh\");\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub unsafe fn as_mut_vec<'a>(&'a mut self) -> &'a mut Vec<u8> {\n         &mut self.vec\n     }\n@@ -636,7 +637,7 @@ impl String {\n     /// assert_eq!(a.len(), 3);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.vec.len() }\n \n     /// Returns true if the string contains no bytes\n@@ -650,7 +651,7 @@ impl String {\n     /// assert!(!v.is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Truncates the string, returning it to 0 length.\n@@ -663,7 +664,7 @@ impl String {\n     /// assert!(s.is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         self.vec.clear()\n     }\n@@ -672,11 +673,11 @@ impl String {\n impl FromUtf8Error {\n     /// Consume this error, returning the bytes that were attempted to make a\n     /// `String` with.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn into_bytes(self) -> Vec<u8> { self.bytes }\n \n     /// Access the underlying UTF8-error that was the cause of this error.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn utf8_error(&self) -> Utf8Error { self.error }\n }\n \n@@ -686,7 +687,7 @@ impl fmt::Show for FromUtf8Error {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl fmt::String for FromUtf8Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::String::fmt(&self.error, f)\n@@ -699,14 +700,14 @@ impl fmt::Show for FromUtf16Error {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl fmt::String for FromUtf16Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::String::fmt(\"invalid utf-16: lone surrogate found\", f)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl FromIterator<char> for String {\n     fn from_iter<I:Iterator<Item=char>>(iterator: I) -> String {\n         let mut buf = String::new();\n@@ -715,7 +716,7 @@ impl FromIterator<char> for String {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> FromIterator<&'a str> for String {\n     fn from_iter<I:Iterator<Item=&'a str>>(iterator: I) -> String {\n         let mut buf = String::new();\n@@ -724,7 +725,8 @@ impl<'a> FromIterator<&'a str> for String {\n     }\n }\n \n-#[unstable = \"waiting on Extend stabilization\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"waiting on Extend stabilization\")]\n impl Extend<char> for String {\n     fn extend<I:Iterator<Item=char>>(&mut self, mut iterator: I) {\n         let (lower_bound, _) = iterator.size_hint();\n@@ -735,7 +737,8 @@ impl Extend<char> for String {\n     }\n }\n \n-#[unstable = \"waiting on Extend stabilization\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"waiting on Extend stabilization\")]\n impl<'a> Extend<&'a str> for String {\n     fn extend<I: Iterator<Item=&'a str>>(&mut self, mut iterator: I) {\n         // A guess that at least one byte per iterator element will be needed.\n@@ -747,7 +750,7 @@ impl<'a> Extend<&'a str> for String {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl PartialEq for String {\n     #[inline]\n     fn eq(&self, other: &String) -> bool { PartialEq::eq(&**self, &**other) }\n@@ -757,15 +760,15 @@ impl PartialEq for String {\n \n macro_rules! impl_eq {\n     ($lhs:ty, $rhs: ty) => {\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl<'a> PartialEq<$rhs> for $lhs {\n             #[inline]\n             fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n             #[inline]\n             fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n         }\n \n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl<'a> PartialEq<$lhs> for $rhs {\n             #[inline]\n             fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&**self, &**other) }\n@@ -779,65 +782,66 @@ macro_rules! impl_eq {\n impl_eq! { String, &'a str }\n impl_eq! { CowString<'a>, String }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, 'b> PartialEq<&'b str> for CowString<'a> {\n     #[inline]\n     fn eq(&self, other: &&'b str) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &&'b str) -> bool { PartialEq::ne(&**self, &**other) }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, 'b> PartialEq<CowString<'a>> for &'b str {\n     #[inline]\n     fn eq(&self, other: &CowString<'a>) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &CowString<'a>) -> bool { PartialEq::ne(&**self, &**other) }\n }\n \n-#[unstable = \"waiting on Str stabilization\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"waiting on Str stabilization\")]\n impl Str for String {\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn as_slice<'a>(&'a self) -> &'a str {\n         unsafe { mem::transmute(self.vec.as_slice()) }\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl Default for String {\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn default() -> String {\n         String::new()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl fmt::String for String {\n     #[inline]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::String::fmt(&**self, f)\n     }\n }\n \n-#[unstable = \"waiting on fmt stabilization\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"waiting on fmt stabilization\")]\n impl fmt::Show for String {\n     #[inline]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Show::fmt(&**self, f)\n     }\n }\n \n-#[unstable = \"waiting on Hash stabilization\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"waiting on Hash stabilization\")]\n impl<H: hash::Writer + hash::Hasher> hash::Hash<H> for String {\n     #[inline]\n     fn hash(&self, hasher: &mut H) {\n         (**self).hash(hasher)\n     }\n }\n \n-#[unstable = \"recent addition, needs more experience\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"recent addition, needs more experience\")]\n impl<'a> Add<&'a str> for String {\n     type Output = String;\n \n@@ -877,7 +881,7 @@ impl ops::Index<ops::FullRange> for String {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl ops::Deref for String {\n     type Target = str;\n \n@@ -888,7 +892,7 @@ impl ops::Deref for String {\n }\n \n /// Wrapper type providing a `&String` reference via `Deref`.\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub struct DerefString<'a> {\n     x: DerefVec<'a, u8>\n }\n@@ -916,7 +920,7 @@ impl<'a> Deref for DerefString<'a> {\n /// let string = as_string(\"foo\").clone();\n /// string_consumer(string);\n /// ```\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub fn as_string<'a>(x: &'a str) -> DerefString<'a> {\n     DerefString { x: as_vec(x.as_bytes()) }\n }\n@@ -960,7 +964,7 @@ impl<'a> IntoCow<'a, String, str> for &'a str {\n }\n \n /// A clone-on-write string\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub type CowString<'a> = Cow<'a, String, str>;\n \n impl<'a> Str for CowString<'a> {"}, {"sha": "4a8cd3e16454b61410519cdbaa92e5e177b8d1f8", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 72, "deletions": 62, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -44,7 +44,7 @@\n //! let two = xs.pop();\n //! ```\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use core::prelude::*;\n \n@@ -134,7 +134,7 @@ use core::uint;\n /// to reallocate, which can be slow. For this reason, it is recommended to use\n /// `Vec::with_capacity` whenever possible to specify how big the vector is expected to get.\n #[unsafe_no_drop_flag]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Vec<T> {\n     ptr: NonZero<*mut T>,\n     len: uint,\n@@ -159,7 +159,7 @@ impl<T> Vec<T> {\n     /// let mut vec: Vec<int> = Vec::new();\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new() -> Vec<T> {\n         // We want ptr to never be NULL so instead we set it to some arbitrary\n         // non-null value which is fine since we never call deallocate on the ptr\n@@ -194,7 +194,7 @@ impl<T> Vec<T> {\n     /// vec.push(11);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> Vec<T> {\n         if mem::size_of::<T>() == 0 {\n             Vec { ptr: unsafe { NonZero::new(EMPTY as *mut T) }, len: 0, cap: uint::MAX }\n@@ -243,7 +243,7 @@ impl<T> Vec<T> {\n     ///     }\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub unsafe fn from_raw_parts(ptr: *mut T, length: uint,\n                                  capacity: uint) -> Vec<T> {\n         Vec { ptr: NonZero::new(ptr), len: length, cap: capacity }\n@@ -255,7 +255,8 @@ impl<T> Vec<T> {\n     /// owned by the returned `Vec<T>`. The elements of the buffer are copied into the vector\n     /// without cloning, as if `ptr::read()` were called on them.\n     #[inline]\n-    #[unstable = \"may be better expressed via composition\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"may be better expressed via composition\")]\n     pub unsafe fn from_raw_buf(ptr: *const T, elts: uint) -> Vec<T> {\n         let mut dst = Vec::with_capacity(elts);\n         dst.set_len(elts);\n@@ -273,7 +274,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec.capacity(), 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.cap\n     }\n@@ -292,7 +293,7 @@ impl<T> Vec<T> {\n     /// vec.reserve(10);\n     /// assert!(vec.capacity() >= 11);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         if self.cap - self.len < additional {\n             let err_msg = \"Vec::reserve: `uint` overflow\";\n@@ -321,7 +322,7 @@ impl<T> Vec<T> {\n     /// vec.reserve_exact(10);\n     /// assert!(vec.capacity() >= 11);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         if self.cap - self.len < additional {\n             match self.len.checked_add(additional) {\n@@ -345,7 +346,7 @@ impl<T> Vec<T> {\n     /// vec.shrink_to_fit();\n     /// assert!(vec.capacity() >= 3);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         if mem::size_of::<T>() == 0 { return }\n \n@@ -376,7 +377,7 @@ impl<T> Vec<T> {\n     /// Note that this will drop any excess capacity. Calling this and\n     /// converting back to a vector with `into_vec()` is equivalent to calling\n     /// `shrink_to_fit()`.\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn into_boxed_slice(mut self) -> Box<[T]> {\n         self.shrink_to_fit();\n         unsafe {\n@@ -398,7 +399,7 @@ impl<T> Vec<T> {\n     /// vec.truncate(2);\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, len: uint) {\n         unsafe {\n             // drop any extra elements\n@@ -422,7 +423,7 @@ impl<T> Vec<T> {\n     /// foo(vec.as_mut_slice());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         unsafe {\n             mem::transmute(RawSlice {\n@@ -446,7 +447,7 @@ impl<T> Vec<T> {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         unsafe {\n             let ptr = *self.ptr;\n@@ -477,7 +478,7 @@ impl<T> Vec<T> {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub unsafe fn set_len(&mut self, len: uint) {\n         self.len = len;\n     }\n@@ -503,7 +504,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(v, vec![\"baz\", \"qux\"]);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn swap_remove(&mut self, index: uint) -> T {\n         let length = self.len();\n         self.swap(index, length - 1);\n@@ -527,7 +528,7 @@ impl<T> Vec<T> {\n     /// vec.insert(4, 5);\n     /// assert_eq!(vec, vec![1, 4, 2, 3, 5]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn insert(&mut self, index: uint, element: T) {\n         let len = self.len();\n         assert!(index <= len);\n@@ -563,7 +564,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(v.remove(1), 2);\n     /// assert_eq!(v, vec![1, 3]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn remove(&mut self, index: uint) -> T {\n         let len = self.len();\n         assert!(index < len);\n@@ -597,7 +598,7 @@ impl<T> Vec<T> {\n     /// vec.retain(|&x| x%2 == 0);\n     /// assert_eq!(vec, vec![2, 4]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn retain<F>(&mut self, mut f: F) where F: FnMut(&T) -> bool {\n         let len = self.len();\n         let mut del = 0u;\n@@ -631,7 +632,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, vec!(1, 2, 3));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn push(&mut self, value: T) {\n         if mem::size_of::<T>() == 0 {\n             // zero-size types consume no memory, so we can't rely on the\n@@ -669,7 +670,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<T> {\n         if self.len == 0 {\n             None\n@@ -696,7 +697,8 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec2, vec![]);\n     /// ```\n     #[inline]\n-    #[unstable = \"new API, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"new API, waiting for dust to settle\")]\n     pub fn append(&mut self, other: &mut Self) {\n         if mem::size_of::<T>() == 0 {\n             // zero-size types consume no memory, so we can't rely on the\n@@ -732,7 +734,8 @@ impl<T> Vec<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain<'a>(&'a mut self) -> Drain<'a, T> {\n         unsafe {\n             let begin = *self.ptr as *const T;\n@@ -762,7 +765,7 @@ impl<T> Vec<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         self.truncate(0)\n     }\n@@ -776,7 +779,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(a.len(), 3);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.len }\n \n     /// Returns `true` if the vector contains no elements.\n@@ -790,7 +793,7 @@ impl<T> Vec<T> {\n     /// v.push(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Converts a `Vec<T>` to a `Vec<U>` where `T` and `U` have the same\n@@ -814,7 +817,8 @@ impl<T> Vec<T> {\n     /// let newtyped_bytes = bytes.map_in_place(|x| Newtype(x));\n     /// assert_eq!(newtyped_bytes.as_slice(), [Newtype(0x11), Newtype(0x22)].as_slice());\n     /// ```\n-    #[unstable = \"API may change to provide stronger guarantees\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"API may change to provide stronger guarantees\")]\n     pub fn map_in_place<U, F>(self, mut f: F) -> Vec<U> where F: FnMut(T) -> U {\n         // FIXME: Assert statically that the types `T` and `U` have the same\n         // size.\n@@ -1008,7 +1012,8 @@ impl<T: Clone> Vec<T> {\n     /// vec.resize(2, 0);\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n-    #[unstable = \"matches collection reform specification; waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification; waiting for dust to settle\")]\n     pub fn resize(&mut self, new_len: uint, value: T) {\n         let len = self.len();\n \n@@ -1032,7 +1037,8 @@ impl<T: Clone> Vec<T> {\n     /// assert_eq!(vec, vec![1, 2, 3, 4]);\n     /// ```\n     #[inline]\n-    #[unstable = \"likely to be replaced by a more optimized extend\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"likely to be replaced by a more optimized extend\")]\n     pub fn push_all(&mut self, other: &[T]) {\n         self.reserve(other.len());\n \n@@ -1066,7 +1072,7 @@ impl<T: PartialEq> Vec<T> {\n     ///\n     /// assert_eq!(vec, vec![1i, 2, 3, 2]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn dedup(&mut self) {\n         unsafe {\n             // Although we have a mutable reference to `self`, we cannot make\n@@ -1200,7 +1206,7 @@ unsafe fn dealloc<T>(ptr: *mut T, len: uint) {\n // Common trait implementations for Vec\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n impl<T:Clone> Clone for Vec<T> {\n     fn clone(&self) -> Vec<T> { ::slice::SliceExt::to_vec(self.as_slice()) }\n \n@@ -1229,7 +1235,7 @@ impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for Vec<T> {\n     }\n }\n \n-#[unstable = \"waiting on Index stability\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"waiting on Index stability\")]\n impl<T> Index<uint> for Vec<T> {\n     type Output = T;\n \n@@ -1308,19 +1314,19 @@ impl<T> ops::IndexMut<ops::FullRange> for Vec<T> {\n }\n \n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> ops::Deref for Vec<T> {\n     type Target = [T];\n \n     fn deref<'a>(&'a self) -> &'a [T] { self.as_slice() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> ops::DerefMut for Vec<T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut [T] { self.as_mut_slice() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n     fn from_iter<I:Iterator<Item=T>>(mut iterator: I) -> Vec<T> {\n@@ -1333,7 +1339,7 @@ impl<T> FromIterator<T> for Vec<T> {\n     }\n }\n \n-#[unstable = \"waiting on Extend stability\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"waiting on Extend stability\")]\n impl<T> Extend<T> for Vec<T> {\n     #[inline]\n     fn extend<I: Iterator<Item=T>>(&mut self, mut iterator: I) {\n@@ -1408,18 +1414,19 @@ macro_rules! impl_eq_for_cowvec {\n impl_eq_for_cowvec! { &'b [B] }\n impl_eq_for_cowvec! { &'b mut [B] }\n \n-#[unstable = \"waiting on PartialOrd stability\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"waiting on PartialOrd stability\")]\n impl<T: PartialOrd> PartialOrd for Vec<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n         self.as_slice().partial_cmp(other.as_slice())\n     }\n }\n \n-#[unstable = \"waiting on Eq stability\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"waiting on Eq stability\")]\n impl<T: Eq> Eq for Vec<T> {}\n \n-#[unstable = \"waiting on Ord stability\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"waiting on Ord stability\")]\n impl<T: Ord> Ord for Vec<T> {\n     #[inline]\n     fn cmp(&self, other: &Vec<T>) -> Ordering {\n@@ -1439,7 +1446,7 @@ impl<T> AsSlice<T> for Vec<T> {\n     /// foo(vec.as_slice());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         unsafe {\n             mem::transmute(RawSlice {\n@@ -1450,7 +1457,8 @@ impl<T> AsSlice<T> for Vec<T> {\n     }\n }\n \n-#[unstable = \"recent addition, needs more experience\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"recent addition, needs more experience\")]\n impl<'a, T: Clone> Add<&'a [T]> for Vec<T> {\n     type Output = Vec<T>;\n \n@@ -1462,7 +1470,7 @@ impl<'a, T: Clone> Add<&'a [T]> for Vec<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Drop for Vec<T> {\n     fn drop(&mut self) {\n         // This is (and should always remain) a no-op if the fields are\n@@ -1478,15 +1486,15 @@ impl<T> Drop for Vec<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Default for Vec<T> {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn default() -> Vec<T> {\n         Vec::new()\n     }\n }\n \n-#[unstable = \"waiting on Show stability\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"waiting on Show stability\")]\n impl<T: fmt::Show> fmt::Show for Vec<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Show::fmt(self.as_slice(), f)\n@@ -1504,11 +1512,12 @@ impl<'a> fmt::Writer for Vec<u8> {\n // Clone-on-write\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[unstable = \"unclear how valuable this alias is\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"unclear how valuable this alias is\")]\n /// A clone-on-write vector\n pub type CowVec<'a, T> = Cow<'a, Vec<T>, [T]>;\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n impl<'a, T> FromIterator<T> for CowVec<'a, T> where T: Clone {\n     fn from_iter<I: Iterator<Item=T>>(it: I) -> CowVec<'a, T> {\n         Cow::Owned(FromIterator::from_iter(it))\n@@ -1532,7 +1541,7 @@ impl<'a, T> IntoCow<'a, Vec<T>, [T]> for &'a [T] where T: Clone {\n ////////////////////////////////////////////////////////////////////////////////\n \n /// An iterator that moves out of a vector.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     allocation: *mut T, // the block of memory allocated for the vector\n     cap: uint, // the capacity of the vector\n@@ -1546,7 +1555,7 @@ unsafe impl<T: Sync> Sync for IntoIter<T> { }\n impl<T> IntoIter<T> {\n     #[inline]\n     /// Drops all items that have not yet been moved and returns the empty vector.\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn into_inner(mut self) -> Vec<T> {\n         unsafe {\n             for _x in self { }\n@@ -1557,7 +1566,7 @@ impl<T> IntoIter<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n@@ -1594,7 +1603,7 @@ impl<T> Iterator for IntoIter<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back<'a>(&'a mut self) -> Option<T> {\n@@ -1618,11 +1627,11 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Drop for IntoIter<T> {\n     fn drop(&mut self) {\n         // destroy the remaining elements\n@@ -1637,14 +1646,15 @@ impl<T> Drop for IntoIter<T> {\n \n /// An iterator that drains a vector.\n #[unsafe_no_drop_flag]\n-#[unstable = \"recently added as part of collections reform 2\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"recently added as part of collections reform 2\")]\n pub struct Drain<'a, T> {\n     ptr: *const T,\n     end: *const T,\n     marker: ContravariantLifetime<'a>,\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Drain<'a, T> {\n     type Item = T;\n \n@@ -1681,7 +1691,7 @@ impl<'a, T> Iterator for Drain<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n@@ -1705,11 +1715,11 @@ impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Drain<'a, T> {}\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n         // self.ptr == self.end == null if drop has already been called,\n@@ -1725,13 +1735,13 @@ impl<'a, T> Drop for Drain<'a, T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n /// Wrapper type providing a `&Vec<T>` reference via `Deref`.\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub struct DerefVec<'a, T> {\n     x: Vec<T>,\n     l: ContravariantLifetime<'a>\n }\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n impl<'a, T> Deref for DerefVec<'a, T> {\n     type Target = Vec<T>;\n \n@@ -1742,7 +1752,7 @@ impl<'a, T> Deref for DerefVec<'a, T> {\n \n // Prevent the inner `Vec<T>` from attempting to deallocate memory.\n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> Drop for DerefVec<'a, T> {\n     fn drop(&mut self) {\n         self.x.len = 0;\n@@ -1751,7 +1761,7 @@ impl<'a, T> Drop for DerefVec<'a, T> {\n }\n \n /// Convert a slice to a wrapper type providing a `&Vec<T>` reference.\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub fn as_vec<'a, T>(x: &'a [T]) -> DerefVec<'a, T> {\n     unsafe {\n         DerefVec {"}, {"sha": "b45b86e3b9705a688280f5d934774ae1b700bd03", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 46, "deletions": 45, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -66,9 +66,9 @@ pub struct VecMap<V> {\n     v: Vec<Option<V>>,\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<V> Default for VecMap<V> {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     #[inline]\n     fn default() -> VecMap<V> { VecMap::new() }\n }\n@@ -107,7 +107,7 @@ impl<V> VecMap<V> {\n     /// use std::collections::VecMap;\n     /// let mut map: VecMap<&str> = VecMap::new();\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new() -> VecMap<V> { VecMap { v: vec![] } }\n \n     /// Creates an empty `VecMap` with space for at least `capacity`\n@@ -119,7 +119,7 @@ impl<V> VecMap<V> {\n     /// use std::collections::VecMap;\n     /// let mut map: VecMap<&str> = VecMap::with_capacity(10);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> VecMap<V> {\n         VecMap { v: Vec::with_capacity(capacity) }\n     }\n@@ -135,7 +135,7 @@ impl<V> VecMap<V> {\n     /// assert!(map.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.v.capacity()\n     }\n@@ -154,7 +154,7 @@ impl<V> VecMap<V> {\n     /// map.reserve_len(10);\n     /// assert!(map.capacity() >= 10);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn reserve_len(&mut self, len: uint) {\n         let cur_len = self.v.len();\n         if len >= cur_len {\n@@ -178,7 +178,7 @@ impl<V> VecMap<V> {\n     /// map.reserve_len_exact(10);\n     /// assert!(map.capacity() >= 10);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn reserve_len_exact(&mut self, len: uint) {\n         let cur_len = self.v.len();\n         if len >= cur_len {\n@@ -188,7 +188,7 @@ impl<V> VecMap<V> {\n \n     /// Returns an iterator visiting all keys in ascending order of the keys.\n     /// The iterator's element type is `uint`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn keys<'r>(&'r self) -> Keys<'r, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((uint, &'r V)) -> uint = first; // coerce to fn pointer\n@@ -198,7 +198,7 @@ impl<V> VecMap<V> {\n \n     /// Returns an iterator visiting all values in ascending order of the keys.\n     /// The iterator's element type is `&'r V`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn values<'r>(&'r self) -> Values<'r, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n         let second: fn((uint, &'r V)) -> &'r V = second; // coerce to fn pointer\n@@ -224,7 +224,7 @@ impl<V> VecMap<V> {\n     ///     println!(\"{}: {}\", key, value);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn iter<'r>(&'r self) -> Iter<'r, V> {\n         Iter {\n             front: 0,\n@@ -255,7 +255,7 @@ impl<V> VecMap<V> {\n     ///     assert_eq!(value, &\"x\");\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn iter_mut<'r>(&'r mut self) -> IterMut<'r, V> {\n         IterMut {\n             front: 0,\n@@ -282,7 +282,7 @@ impl<V> VecMap<V> {\n     ///\n     /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<V> {\n         fn filter<A>((i, v): (uint, Option<A>)) -> Option<(uint, A)> {\n             v.map(|v| (i, v))\n@@ -310,7 +310,8 @@ impl<V> VecMap<V> {\n     ///\n     /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain<'a>(&'a mut self) -> Drain<'a, V> {\n         fn filter<A>((i, v): (uint, Option<A>)) -> Option<(uint, A)> {\n             v.map(|v| (i, v))\n@@ -332,7 +333,7 @@ impl<V> VecMap<V> {\n     /// a.insert(1, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint {\n         self.v.iter().filter(|elt| elt.is_some()).count()\n     }\n@@ -349,7 +350,7 @@ impl<V> VecMap<V> {\n     /// a.insert(1, \"a\");\n     /// assert!(!a.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n         self.v.iter().all(|elt| elt.is_none())\n     }\n@@ -366,7 +367,7 @@ impl<V> VecMap<V> {\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn clear(&mut self) { self.v.clear() }\n \n     /// Returns a reference to the value corresponding to the key.\n@@ -381,7 +382,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.get(&1), Some(&\"a\"));\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn get(&self, key: &uint) -> Option<&V> {\n         if *key < self.v.len() {\n             match self.v[*key] {\n@@ -406,7 +407,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn contains_key(&self, key: &uint) -> bool {\n         self.get(key).is_some()\n     }\n@@ -426,7 +427,7 @@ impl<V> VecMap<V> {\n     /// }\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self, key: &uint) -> Option<&mut V> {\n         if *key < self.v.len() {\n             match *(&mut self.v[*key]) {\n@@ -454,7 +455,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn insert(&mut self, key: uint, value: V) -> Option<V> {\n         let len = self.v.len();\n         if len <= key {\n@@ -476,7 +477,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.remove(&1), Some(\"a\"));\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn remove(&mut self, key: &uint) -> Option<V> {\n         if *key >= self.v.len() {\n             return None;\n@@ -486,33 +487,33 @@ impl<V> VecMap<V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<V: PartialEq> PartialEq for VecMap<V> {\n     fn eq(&self, other: &VecMap<V>) -> bool {\n         iter::order::eq(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<V: Eq> Eq for VecMap<V> {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<V: PartialOrd> PartialOrd for VecMap<V> {\n     #[inline]\n     fn partial_cmp(&self, other: &VecMap<V>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<V: Ord> Ord for VecMap<V> {\n     #[inline]\n     fn cmp(&self, other: &VecMap<V>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<V: fmt::Show> fmt::Show for VecMap<V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"VecMap {{\"));\n@@ -526,7 +527,7 @@ impl<V: fmt::Show> fmt::Show for VecMap<V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<V> FromIterator<(uint, V)> for VecMap<V> {\n     fn from_iter<Iter: Iterator<Item=(uint, V)>>(iter: Iter) -> VecMap<V> {\n         let mut map = VecMap::new();\n@@ -535,7 +536,7 @@ impl<V> FromIterator<(uint, V)> for VecMap<V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<V> Extend<(uint, V)> for VecMap<V> {\n     fn extend<Iter: Iterator<Item=(uint, V)>>(&mut self, mut iter: Iter) {\n         for (k, v) in iter {\n@@ -553,7 +554,7 @@ impl<V> Index<uint> for VecMap<V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<V> IndexMut<uint> for VecMap<V> {\n     type Output = V;\n \n@@ -565,7 +566,7 @@ impl<V> IndexMut<uint> for VecMap<V> {\n \n macro_rules! iterator {\n     (impl $name:ident -> $elem:ty, $($getter:ident),+) => {\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl<'a, V> Iterator for $name<'a, V> {\n             type Item = $elem;\n \n@@ -600,7 +601,7 @@ macro_rules! iterator {\n \n macro_rules! double_ended_iterator {\n     (impl $name:ident -> $elem:ty, $($getter:ident),+) => {\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl<'a, V> DoubleEndedIterator for $name<'a, V> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n@@ -626,7 +627,7 @@ macro_rules! double_ended_iterator {\n }\n \n /// An iterator over the key-value pairs of a map.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Iter<'a, V:'a> {\n     front: uint,\n     back: uint,\n@@ -649,7 +650,7 @@ double_ended_iterator! { impl Iter -> (uint, &'a V), as_ref }\n \n /// An iterator over the key-value pairs of a map, with the\n /// values being mutable.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct IterMut<'a, V:'a> {\n     front: uint,\n     back: uint,\n@@ -660,7 +661,7 @@ iterator! { impl IterMut -> (uint, &'a mut V), as_mut }\n double_ended_iterator! { impl IterMut -> (uint, &'a mut V), as_mut }\n \n /// An iterator over the keys of a map.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Keys<'a, V: 'a> {\n     iter: Map<(uint, &'a V), uint, Iter<'a, V>, fn((uint, &'a V)) -> uint>\n }\n@@ -675,7 +676,7 @@ impl<'a, V> Clone for Keys<'a, V> {\n }\n \n /// An iterator over the values of a map.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Values<'a, V: 'a> {\n     iter: Map<(uint, &'a V), &'a V, Iter<'a, V>, fn((uint, &'a V)) -> &'a V>\n }\n@@ -690,7 +691,7 @@ impl<'a, V> Clone for Values<'a, V> {\n }\n \n /// A consuming iterator over the key-value pairs of a map.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct IntoIter<V> {\n     iter: FilterMap<\n     (uint, Option<V>),\n@@ -699,7 +700,7 @@ pub struct IntoIter<V> {\n     fn((uint, Option<V>)) -> Option<(uint, V)>>\n }\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub struct Drain<'a, V> {\n     iter: FilterMap<\n     (uint, Option<V>),\n@@ -708,51 +709,51 @@ pub struct Drain<'a, V> {\n     fn((uint, Option<V>)) -> Option<(uint, V)>>\n }\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n impl<'a, V> Iterator for Drain<'a, V> {\n     type Item = (uint, V);\n \n     fn next(&mut self) -> Option<(uint, V)> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n impl<'a, V> DoubleEndedIterator for Drain<'a, V> {\n     fn next_back(&mut self) -> Option<(uint, V)> { self.iter.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, V> Iterator for Keys<'a, V> {\n     type Item = uint;\n \n     fn next(&mut self) -> Option<uint> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, V> DoubleEndedIterator for Keys<'a, V> {\n     fn next_back(&mut self) -> Option<uint> { self.iter.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, V> Iterator for Values<'a, V> {\n     type Item = &'a V;\n \n     fn next(&mut self) -> Option<(&'a V)> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, V> DoubleEndedIterator for Values<'a, V> {\n     fn next_back(&mut self) -> Option<(&'a V)> { self.iter.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<V> Iterator for IntoIter<V> {\n     type Item = (uint, V);\n \n     fn next(&mut self) -> Option<(uint, V)> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<V> DoubleEndedIterator for IntoIter<V> {\n     fn next_back(&mut self) -> Option<(uint, V)> { self.iter.next_back() }\n }"}, {"sha": "4ef4db2813e9e1e279d35d2fa27d1ae46184d022", "filename": "src/libcore/any.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -69,7 +69,7 @@\n //! }\n //! ```\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use mem::transmute;\n use option::Option::{self, Some, None};\n@@ -86,10 +86,11 @@ use intrinsics;\n ///\n /// Every type with no non-`'static` references implements `Any`, so `Any` can\n /// be used as a trait object to emulate the effects dynamic typing.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait Any: 'static {\n     /// Get the `TypeId` of `self`\n-    #[unstable = \"this method will likely be replaced by an associated static\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"this method will likely be replaced by an associated static\")]\n     fn get_type_id(&self) -> TypeId;\n }\n \n@@ -103,7 +104,7 @@ impl<T: 'static> Any for T {\n \n impl Any {\n     /// Returns true if the boxed type is the same as `T`\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is<T: 'static>(&self) -> bool {\n         // Get TypeId of the type this function is instantiated with\n@@ -118,7 +119,7 @@ impl Any {\n \n     /// Returns some reference to the boxed value if it is of type `T`, or\n     /// `None` if it isn't.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     #[inline]\n     pub fn downcast_ref<T: 'static>(&self) -> Option<&T> {\n         if self.is::<T>() {\n@@ -136,7 +137,7 @@ impl Any {\n \n     /// Returns some mutable reference to the boxed value if it is of type `T`, or\n     /// `None` if it isn't.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     #[inline]\n     pub fn downcast_mut<T: 'static>(&mut self) -> Option<&mut T> {\n         if self.is::<T>() {\n@@ -167,7 +168,7 @@ impl Any {\n /// but this limitation may be removed in the future.\n #[cfg_attr(stage0, lang = \"type_id\")]\n #[derive(Clone, Copy, PartialEq, Eq, Show, Hash)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct TypeId {\n     t: u64,\n }\n@@ -176,7 +177,8 @@ impl TypeId {\n     /// Returns the `TypeId` of the type this generic function has been\n     /// instantiated with\n     #[cfg(not(stage0))]\n-    #[unstable = \"may grow a `Reflect` bound soon via marker traits\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"may grow a `Reflect` bound soon via marker traits\")]\n     pub fn of<T: ?Sized + 'static>() -> TypeId {\n         TypeId {\n             t: unsafe { intrinsics::type_id::<T>() },"}, {"sha": "86e8c4b4f036cc93411f6a46bb3bd22b7d4cea05", "filename": "src/libcore/array.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -12,7 +12,7 @@\n //! up to a certain length. Eventually we should able to generalize\n //! to all lengths.\n \n-#![unstable] // not yet reviewed\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")] // not yet reviewed\n \n use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n@@ -26,7 +26,7 @@ use option::Option;\n macro_rules! array_impls {\n     ($($N:expr)+) => {\n         $(\n-            #[stable]\n+            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n             impl<T:Copy> Clone for [T; $N] {\n                 fn clone(&self) -> [T; $N] {\n                     *self\n@@ -39,14 +39,15 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[unstable = \"waiting for Show to stabilize\"]\n+            #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+                       reason = \"waiting for Show to stabilize\")]\n             impl<T:fmt::Show> fmt::Show for [T; $N] {\n                 fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                     fmt::Show::fmt(&&self[], f)\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n             impl<A, B> PartialEq<[B; $N]> for [A; $N] where A: PartialEq<B> {\n                 #[inline]\n                 fn eq(&self, other: &[B; $N]) -> bool {\n@@ -58,7 +59,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n             impl<'a, A, B, Rhs> PartialEq<Rhs> for [A; $N] where\n                 A: PartialEq<B>,\n                 Rhs: Deref<Target=[B]>,\n@@ -73,7 +74,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n             impl<'a, A, B, Lhs> PartialEq<[B; $N]> for Lhs where\n                 A: PartialEq<B>,\n                 Lhs: Deref<Target=[A]>\n@@ -88,10 +89,10 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n             impl<T:Eq> Eq for [T; $N] { }\n \n-            #[stable]\n+            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n             impl<T:PartialOrd> PartialOrd for [T; $N] {\n                 #[inline]\n                 fn partial_cmp(&self, other: &[T; $N]) -> Option<Ordering> {\n@@ -115,7 +116,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n             impl<T:Ord> Ord for [T; $N] {\n                 #[inline]\n                 fn cmp(&self, other: &[T; $N]) -> Ordering {"}, {"sha": "44b1f2e45606e8c5c3fe47961e5f36043476cc4e", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 48, "deletions": 44, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -68,7 +68,7 @@\n //! println!(\"live tasks: {}\", old_task_count + 1);\n //! ```\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use self::Ordering::*;\n \n@@ -78,31 +78,31 @@ use intrinsics;\n use cell::UnsafeCell;\n \n /// A boolean type which can be safely shared between threads.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct AtomicBool {\n     v: UnsafeCell<usize>,\n }\n \n unsafe impl Sync for AtomicBool {}\n \n /// A signed integer type which can be safely shared between threads.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct AtomicIsize {\n     v: UnsafeCell<isize>,\n }\n \n unsafe impl Sync for AtomicIsize {}\n \n /// An unsigned integer type which can be safely shared between threads.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct AtomicUsize {\n     v: UnsafeCell<usize>,\n }\n \n unsafe impl Sync for AtomicUsize {}\n \n /// A raw pointer type which can be safely shared between threads.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct AtomicPtr<T> {\n     p: UnsafeCell<usize>,\n }\n@@ -119,42 +119,42 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n ///\n /// Rust's memory orderings are [the same as\n /// C++'s](http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync).\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #[derive(Copy)]\n pub enum Ordering {\n     /// No ordering constraints, only atomic operations.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     Relaxed,\n     /// When coupled with a store, all previous writes become visible\n     /// to another thread that performs a load with `Acquire` ordering\n     /// on the same value.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     Release,\n     /// When coupled with a load, all subsequent loads will see data\n     /// written before a store with `Release` ordering on the same value\n     /// in another thread.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     Acquire,\n     /// When coupled with a load, uses `Acquire` ordering, and with a store\n     /// `Release` ordering.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     AcqRel,\n     /// Like `AcqRel` with the additional guarantee that all threads see all\n     /// sequentially consistent operations in the same order.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     SeqCst,\n }\n \n /// An `AtomicBool` initialized to `false`.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const ATOMIC_BOOL_INIT: AtomicBool =\n         AtomicBool { v: UnsafeCell { value: 0 } };\n /// An `AtomicIsize` initialized to `0`.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const ATOMIC_ISIZE_INIT: AtomicIsize =\n         AtomicIsize { v: UnsafeCell { value: 0 } };\n /// An `AtomicUsize` initialized to `0`.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const ATOMIC_USIZE_INIT: AtomicUsize =\n         AtomicUsize { v: UnsafeCell { value: 0, } };\n \n@@ -173,7 +173,7 @@ impl AtomicBool {\n     /// let atomic_false = AtomicBool::new(false);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new(v: bool) -> AtomicBool {\n         let val = if v { UINT_TRUE } else { 0 };\n         AtomicBool { v: UnsafeCell::new(val) }\n@@ -197,7 +197,7 @@ impl AtomicBool {\n     /// let value = some_bool.load(Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn load(&self, order: Ordering) -> bool {\n         unsafe { atomic_load(self.v.get(), order) > 0 }\n     }\n@@ -220,7 +220,7 @@ impl AtomicBool {\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn store(&self, val: bool, order: Ordering) {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -241,7 +241,7 @@ impl AtomicBool {\n     /// let value = some_bool.swap(false, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn swap(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -265,7 +265,7 @@ impl AtomicBool {\n     /// let value = some_bool.store(false, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, old: bool, new: bool, order: Ordering) -> bool {\n         let old = if old { UINT_TRUE } else { 0 };\n         let new = if new { UINT_TRUE } else { 0 };\n@@ -298,7 +298,7 @@ impl AtomicBool {\n     /// assert_eq!(false, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -331,7 +331,7 @@ impl AtomicBool {\n     /// assert_eq!(true, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -363,7 +363,7 @@ impl AtomicBool {\n     /// assert_eq!(false, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -395,15 +395,15 @@ impl AtomicBool {\n     /// assert_eq!(false, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n         unsafe { atomic_xor(self.v.get(), val, order) > 0 }\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl AtomicIsize {\n     /// Creates a new `AtomicIsize`.\n     ///\n@@ -580,7 +580,7 @@ impl AtomicIsize {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl AtomicUsize {\n     /// Creates a new `AtomicUsize`.\n     ///\n@@ -769,7 +769,7 @@ impl<T> AtomicPtr<T> {\n     /// let atomic_ptr  = AtomicPtr::new(ptr);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new(p: *mut T) -> AtomicPtr<T> {\n         AtomicPtr { p: UnsafeCell::new(p as usize) }\n     }\n@@ -793,7 +793,7 @@ impl<T> AtomicPtr<T> {\n     /// let value = some_ptr.load(Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn load(&self, order: Ordering) -> *mut T {\n         unsafe {\n             atomic_load(self.p.get(), order) as *mut T\n@@ -821,7 +821,7 @@ impl<T> AtomicPtr<T> {\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n         unsafe { atomic_store(self.p.get(), ptr as usize, order); }\n     }\n@@ -843,7 +843,7 @@ impl<T> AtomicPtr<T> {\n     /// let value = some_ptr.swap(other_ptr, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n         unsafe { atomic_swap(self.p.get(), ptr as usize, order) as *mut T }\n     }\n@@ -869,7 +869,7 @@ impl<T> AtomicPtr<T> {\n     /// let value = some_ptr.compare_and_swap(other_ptr, another_ptr, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         unsafe {\n             atomic_compare_and_swap(self.p.get(), old as usize,\n@@ -890,7 +890,7 @@ unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) {\n }\n \n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_load_acq(dst),\n@@ -902,7 +902,7 @@ unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T {\n }\n \n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xchg_acq(dst, val),\n@@ -915,7 +915,7 @@ unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the old value (like __sync_fetch_and_add).\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xadd_acq(dst, val),\n@@ -928,7 +928,7 @@ unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the old value (like __sync_fetch_and_sub).\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xsub_acq(dst, val),\n@@ -940,7 +940,7 @@ unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_cxchg_acq(dst, old, new),\n@@ -952,7 +952,7 @@ unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering)\n }\n \n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_and_acq(dst, val),\n@@ -964,7 +964,7 @@ unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_nand_acq(dst, val),\n@@ -977,7 +977,7 @@ unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n \n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_or_acq(dst, val),\n@@ -990,7 +990,7 @@ unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n \n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xor_acq(dst, val),\n@@ -1023,7 +1023,7 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n ///\n /// Panics if `order` is `Relaxed`.\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub fn fence(order: Ordering) {\n     unsafe {\n         match order {\n@@ -1036,27 +1036,31 @@ pub fn fence(order: Ordering) {\n     }\n }\n \n-#[deprecated=\"renamed to AtomicIsize\"]\n+#[deprecated(feature = \"unnamed_feature\", since = \"1.0.0\",\n+             reason = \"renamed to AtomicIsize\")]\n #[allow(missing_docs)]\n pub struct AtomicInt {\n     v: UnsafeCell<int>,\n }\n \n unsafe impl Sync for AtomicInt {}\n \n-#[deprecated=\"renamed to AtomicUsize\"]\n+#[deprecated(feature = \"unnamed_feature\", since = \"1.0.0\",\n+             reason = \"renamed to AtomicUsize\")]\n #[allow(missing_docs)]\n pub struct AtomicUint {\n     v: UnsafeCell<uint>,\n }\n \n unsafe impl Sync for AtomicUint {}\n \n-#[deprecated=\"use ATOMIC_ISIZE_INIT instead\"]\n+#[deprecated(feature = \"unnamed_feature\", since = \"1.0.0\",\n+             reason = \"use ATOMIC_ISIZE_INIT instead\")]\n #[allow(missing_docs, deprecated)]\n pub const ATOMIC_INT_INIT: AtomicInt =\n         AtomicInt { v: UnsafeCell { value: 0 } };\n-#[deprecated=\"use ATOMIC_USIZE_INIT instead\"]\n+#[deprecated(feature = \"unnamed_feature\", since = \"1.0.0\",\n+             reason = \"use ATOMIC_USIZE_INIT instead\")]\n #[allow(missing_docs, deprecated)]\n pub const ATOMIC_UINT_INIT: AtomicUint =\n         AtomicUint { v: UnsafeCell { value: 0, } };"}, {"sha": "ef0cf321690c42069e5a17a12e9c81278c415515", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -42,7 +42,8 @@\n //! is desired, `to_mut` will obtain a mutable references to an owned\n //! value, cloning if necessary.\n \n-#![unstable = \"recently added as part of collections reform\"]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+            reason = \"recently added as part of collections reform\")]\n \n use clone::Clone;\n use cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd};\n@@ -142,7 +143,7 @@ pub enum Cow<'a, T, B: ?Sized + 'a> where B: ToOwned<T> {\n     Owned(T)\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> Clone for Cow<'a, T, B> where B: ToOwned<T> {\n     fn clone(&self) -> Cow<'a, T, B> {\n         match *self {\n@@ -196,7 +197,7 @@ impl<'a, T, B: ?Sized> Cow<'a, T, B> where B: ToOwned<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> Deref for Cow<'a, T, B> where B: ToOwned<T>  {\n     type Target = B;\n \n@@ -208,18 +209,18 @@ impl<'a, T, B: ?Sized> Deref for Cow<'a, T, B> where B: ToOwned<T>  {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> Eq for Cow<'a, T, B> where B: Eq + ToOwned<T> {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> Ord for Cow<'a, T, B> where B: Ord + ToOwned<T> {\n     #[inline]\n     fn cmp(&self, other: &Cow<'a, T, B>) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, 'b, T, U, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, U, C>> for Cow<'a, T, B> where\n     B: PartialEq<C> + ToOwned<T>,\n     C: ToOwned<U>,\n@@ -230,15 +231,15 @@ impl<'a, 'b, T, U, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, U, C>> for Cow<'a, T,\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> PartialOrd for Cow<'a, T, B> where B: PartialOrd + ToOwned<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Cow<'a, T, B>) -> Option<Ordering> {\n         PartialOrd::partial_cmp(&**self, &**other)\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> fmt::String for Cow<'a, T, B> where\n     B: fmt::String + ToOwned<T>,\n     T: fmt::String,"}, {"sha": "2cd793a084751d0f12d0cab59a5b85e9b506dd66", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -154,7 +154,7 @@\n // FIXME: Can't be shared between threads. Dynamic borrows\n // FIXME: Relationship to Atomic types and RWLock\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use clone::Clone;\n use cmp::PartialEq;\n@@ -165,14 +165,14 @@ use option::Option;\n use option::Option::{None, Some};\n \n /// A mutable memory location that admits only `Copy` data.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Cell<T> {\n     value: UnsafeCell<T>,\n }\n \n impl<T:Copy> Cell<T> {\n     /// Creates a new `Cell` containing the given value.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new(value: T) -> Cell<T> {\n         Cell {\n             value: UnsafeCell::new(value),\n@@ -181,14 +181,14 @@ impl<T:Copy> Cell<T> {\n \n     /// Returns a copy of the contained value.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn get(&self) -> T {\n         unsafe{ *self.value.get() }\n     }\n \n     /// Sets the contained value.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn set(&self, value: T) {\n         unsafe {\n             *self.value.get() = value;\n@@ -201,39 +201,39 @@ impl<T:Copy> Cell<T> {\n     ///\n     /// This function is `unsafe` because `UnsafeCell`'s field is public.\n     #[inline]\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub unsafe fn as_unsafe_cell<'a>(&'a self) -> &'a UnsafeCell<T> {\n         &self.value\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n unsafe impl<T> Send for Cell<T> where T: Send {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T:Copy> Clone for Cell<T> {\n     fn clone(&self) -> Cell<T> {\n         Cell::new(self.get())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T:Default + Copy> Default for Cell<T> {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn default() -> Cell<T> {\n         Cell::new(Default::default())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T:PartialEq + Copy> PartialEq for Cell<T> {\n     fn eq(&self, other: &Cell<T>) -> bool {\n         self.get() == other.get()\n     }\n }\n \n /// A mutable memory location with dynamically checked borrow rules\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct RefCell<T> {\n     value: UnsafeCell<T>,\n     borrow: Cell<BorrowFlag>,\n@@ -247,7 +247,7 @@ const WRITING: BorrowFlag = -1;\n \n impl<T> RefCell<T> {\n     /// Create a new `RefCell` containing `value`\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new(value: T) -> RefCell<T> {\n         RefCell {\n             value: UnsafeCell::new(value),\n@@ -256,7 +256,7 @@ impl<T> RefCell<T> {\n     }\n \n     /// Consumes the `RefCell`, returning the wrapped value.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> T {\n         // Since this function takes `self` (the `RefCell`) by value, the\n         // compiler statically verifies that it is not currently borrowed.\n@@ -271,7 +271,7 @@ impl<T> RefCell<T> {\n     /// immutable borrows can be taken out at the same time.\n     ///\n     /// Returns `None` if the value is currently mutably borrowed.\n-    #[unstable = \"may be renamed or removed\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"may be renamed or removed\")]\n     pub fn try_borrow<'a>(&'a self) -> Option<Ref<'a, T>> {\n         match BorrowRef::new(&self.borrow) {\n             Some(b) => Some(Ref { _value: unsafe { &*self.value.get() }, _borrow: b }),\n@@ -287,7 +287,7 @@ impl<T> RefCell<T> {\n     /// # Panics\n     ///\n     /// Panics if the value is currently mutably borrowed.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn borrow<'a>(&'a self) -> Ref<'a, T> {\n         match self.try_borrow() {\n             Some(ptr) => ptr,\n@@ -301,7 +301,7 @@ impl<T> RefCell<T> {\n     /// cannot be borrowed while this borrow is active.\n     ///\n     /// Returns `None` if the value is currently borrowed.\n-    #[unstable = \"may be renamed or removed\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"may be renamed or removed\")]\n     pub fn try_borrow_mut<'a>(&'a self) -> Option<RefMut<'a, T>> {\n         match BorrowRefMut::new(&self.borrow) {\n             Some(b) => Some(RefMut { _value: unsafe { &mut *self.value.get() }, _borrow: b }),\n@@ -317,7 +317,7 @@ impl<T> RefCell<T> {\n     /// # Panics\n     ///\n     /// Panics if the value is currently borrowed.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn borrow_mut<'a>(&'a self) -> RefMut<'a, T> {\n         match self.try_borrow_mut() {\n             Some(ptr) => ptr,\n@@ -331,31 +331,31 @@ impl<T> RefCell<T> {\n     ///\n     /// This function is `unsafe` because `UnsafeCell`'s field is public.\n     #[inline]\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub unsafe fn as_unsafe_cell<'a>(&'a self) -> &'a UnsafeCell<T> {\n         &self.value\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n unsafe impl<T> Send for RefCell<T> where T: Send {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Clone> Clone for RefCell<T> {\n     fn clone(&self) -> RefCell<T> {\n         RefCell::new(self.borrow().clone())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T:Default> Default for RefCell<T> {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn default() -> RefCell<T> {\n         RefCell::new(Default::default())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: PartialEq> PartialEq for RefCell<T> {\n     fn eq(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() == *other.borrow()\n@@ -399,15 +399,15 @@ impl<'b> Clone for BorrowRef<'b> {\n }\n \n /// Wraps a borrowed reference to a value in a `RefCell` box.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Ref<'b, T:'b> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n     _value: &'b T,\n     _borrow: BorrowRef<'b>,\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'b, T> Deref for Ref<'b, T> {\n     type Target = T;\n \n@@ -423,7 +423,8 @@ impl<'b, T> Deref for Ref<'b, T> {\n ///\n /// A `Clone` implementation would interfere with the widespread\n /// use of `r.borrow().clone()` to clone the contents of a `RefCell`.\n-#[unstable = \"likely to be moved to a method, pending language changes\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"likely to be moved to a method, pending language changes\")]\n pub fn clone_ref<'b, T:Clone>(orig: &Ref<'b, T>) -> Ref<'b, T> {\n     Ref {\n         _value: orig._value,\n@@ -457,15 +458,15 @@ impl<'b> BorrowRefMut<'b> {\n }\n \n /// Wraps a mutable borrowed reference to a value in a `RefCell` box.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct RefMut<'b, T:'b> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n     _value: &'b mut T,\n     _borrow: BorrowRefMut<'b>,\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'b, T> Deref for RefMut<'b, T> {\n     type Target = T;\n \n@@ -475,7 +476,7 @@ impl<'b, T> Deref for RefMut<'b, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'b, T> DerefMut for RefMut<'b, T> {\n     #[inline]\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n@@ -521,13 +522,13 @@ impl<'b, T> DerefMut for RefMut<'b, T> {\n /// is not recommended to access its fields directly, `get` should be used\n /// instead.\n #[lang=\"unsafe\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct UnsafeCell<T> {\n     /// Wrapped value\n     ///\n     /// This field should not be accessed directly, it is made public for static\n     /// initializers.\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub value: T,\n }\n \n@@ -537,21 +538,21 @@ impl<T> UnsafeCell<T> {\n     ///\n     /// All access to the inner value through methods is `unsafe`, and it is\n     /// highly discouraged to access the fields directly.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new(value: T) -> UnsafeCell<T> {\n         UnsafeCell { value: value }\n     }\n \n     /// Gets a mutable pointer to the wrapped value.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn get(&self) -> *mut T { &self.value as *const T as *mut T }\n \n     /// Unwraps the value\n     ///\n     /// This function is unsafe because there is no guarantee that this or other\n     /// tasks are currently inspecting the inner value.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub unsafe fn into_inner(self) -> T { self.value }\n }"}, {"sha": "3af9fdef98252c64c4221acc0dbe69ac3a87149d", "filename": "src/libcore/char.rs", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -64,12 +64,12 @@ static MAX_THREE_B: u32 =  0x10000u32;\n */\n \n /// The highest valid code point\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const MAX: char = '\\u{10ffff}';\n \n /// Converts from `u32` to a `char`\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub fn from_u32(i: u32) -> Option<char> {\n     // catch out-of-bounds and surrogates\n     if (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF) {\n@@ -92,7 +92,7 @@ pub fn from_u32(i: u32) -> Option<char> {\n /// Panics if given an `radix` > 36.\n ///\n #[inline]\n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"pending integer conventions\")]\n pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     if radix > 36 {\n         panic!(\"from_digit: radix is too high (maximum 36)\");\n@@ -111,7 +111,7 @@ pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n }\n \n /// Basic `char` manipulations.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait CharExt {\n     /// Checks if a `char` parses as a numeric digit in the given radix.\n     ///\n@@ -126,7 +126,8 @@ pub trait CharExt {\n     /// # Panics\n     ///\n     /// Panics if given a radix > 36.\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending integer conventions\")]\n     fn is_digit(self, radix: uint) -> bool;\n \n     /// Converts a character to the corresponding digit.\n@@ -140,7 +141,8 @@ pub trait CharExt {\n     /// # Panics\n     ///\n     /// Panics if given a radix outside the range [0..36].\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending integer conventions\")]\n     fn to_digit(self, radix: uint) -> Option<uint>;\n \n     /// Returns an iterator that yields the hexadecimal Unicode escape\n@@ -149,7 +151,7 @@ pub trait CharExt {\n     /// All characters are escaped with Rust syntax of the form `\\\\u{NNNN}`\n     /// where `NNNN` is the shortest hexadecimal representation of the code\n     /// point.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn escape_unicode(self) -> EscapeUnicode;\n \n     /// Returns an iterator that yields the 'default' ASCII and\n@@ -164,44 +166,46 @@ pub trait CharExt {\n     ///   escaped.\n     /// * Any other chars in the range [0x20,0x7e] are not escaped.\n     /// * Any other chars are given hex Unicode escapes; see `escape_unicode`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn escape_default(self) -> EscapeDefault;\n \n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-8.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn len_utf8(self) -> uint;\n \n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-16.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn len_utf16(self) -> uint;\n \n     /// Encodes this character as UTF-8 into the provided byte buffer,\n     /// and then returns the number of bytes written.\n     ///\n     /// If the buffer is not large enough, nothing will be written into it\n     /// and a `None` will be returned.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn encode_utf8(self, dst: &mut [u8]) -> Option<uint>;\n \n     /// Encodes this character as UTF-16 into the provided `u16` buffer,\n     /// and then returns the number of `u16`s written.\n     ///\n     /// If the buffer is not large enough, nothing will be written into it\n     /// and a `None` will be returned.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn encode_utf16(self, dst: &mut [u16]) -> Option<uint>;\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl CharExt for char {\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending integer conventions\")]\n     fn is_digit(self, radix: uint) -> bool {\n         self.to_digit(radix).is_some()\n     }\n \n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending integer conventions\")]\n     fn to_digit(self, radix: uint) -> Option<uint> {\n         if radix > 36 {\n             panic!(\"to_digit: radix is too high (maximum 36)\");\n@@ -216,12 +220,12 @@ impl CharExt for char {\n         else { None }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn escape_unicode(self) -> EscapeUnicode {\n         EscapeUnicode { c: self, state: EscapeUnicodeState::Backslash }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn escape_default(self) -> EscapeDefault {\n         let init_state = match self {\n             '\\t' => EscapeDefaultState::Backslash('t'),\n@@ -237,7 +241,7 @@ impl CharExt for char {\n     }\n \n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn len_utf8(self) -> uint {\n         let code = self as u32;\n         match () {\n@@ -249,14 +253,15 @@ impl CharExt for char {\n     }\n \n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn len_utf16(self) -> uint {\n         let ch = self as u32;\n         if (ch & 0xFFFF_u32) == ch { 1 } else { 2 }\n     }\n \n     #[inline]\n-    #[unstable = \"pending decision about Iterator/Writer/Reader\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf8(self, dst: &mut [u8]) -> Option<uint> {\n         // Marked #[inline] to allow llvm optimizing it away\n         let code = self as u32;\n@@ -284,7 +289,8 @@ impl CharExt for char {\n     }\n \n     #[inline]\n-    #[unstable = \"pending decision about Iterator/Writer/Reader\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf16(self, dst: &mut [u16]) -> Option<uint> {\n         // Marked #[inline] to allow llvm optimizing it away\n         let mut ch = self as u32;\n@@ -307,14 +313,14 @@ impl CharExt for char {\n /// An iterator over the characters that represent a `char`, as escaped by\n /// Rust's unicode escaping rules.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct EscapeUnicode {\n     c: char,\n     state: EscapeUnicodeState\n }\n \n #[derive(Clone)]\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n enum EscapeUnicodeState {\n     Backslash,\n     Type,\n@@ -324,7 +330,7 @@ enum EscapeUnicodeState {\n     Done,\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl Iterator for EscapeUnicode {\n     type Item = char;\n \n@@ -370,21 +376,21 @@ impl Iterator for EscapeUnicode {\n /// An iterator over the characters that represent a `char`, escaped\n /// for maximum portability.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct EscapeDefault {\n     state: EscapeDefaultState\n }\n \n #[derive(Clone)]\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n enum EscapeDefaultState {\n     Backslash(char),\n     Char(char),\n     Done,\n     Unicode(EscapeUnicode),\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl Iterator for EscapeDefault {\n     type Item = char;\n "}, {"sha": "0fbf9438c236f4f7adf1b731bfc9998200821da0", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -19,15 +19,15 @@\n //! explicitly, by convention implementing the `Clone` trait and calling\n //! the `clone` method.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use marker::Sized;\n \n /// A common trait for cloning an object.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait Clone : Sized {\n     /// Returns a copy of the value.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn clone(&self) -> Self;\n \n     /// Perform copy-assignment from `source`.\n@@ -36,13 +36,14 @@ pub trait Clone : Sized {\n     /// but can be overridden to reuse the resources of `a` to avoid unnecessary\n     /// allocations.\n     #[inline(always)]\n-    #[unstable = \"this function is rarely used\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"this function is rarely used\")]\n     fn clone_from(&mut self, source: &Self) {\n         *self = source.clone()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> Clone for &'a T {\n     /// Return a shallow copy of the reference.\n     #[inline]\n@@ -51,7 +52,7 @@ impl<'a, T: ?Sized> Clone for &'a T {\n \n macro_rules! clone_impl {\n     ($t:ty) => {\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl Clone for $t {\n             /// Return a deep copy of the value.\n             #[inline]\n@@ -81,7 +82,8 @@ clone_impl! { char }\n \n macro_rules! extern_fn_clone {\n     ($($A:ident),*) => (\n-        #[unstable = \"this may not be sufficient for fns with region parameters\"]\n+        #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+                   reason = \"this may not be sufficient for fns with region parameters\")]\n         impl<$($A,)* ReturnType> Clone for extern \"Rust\" fn($($A),*) -> ReturnType {\n             /// Return a copy of a function pointer\n             #[inline]"}, {"sha": "1c8ebb0e7c2bb06537660fb890a8c3ee629f1e51", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -39,7 +39,7 @@\n //! assert!(SketchyNum {num: 25} != SketchyNum {num: 57});\n //! ```\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use self::Ordering::*;\n \n@@ -68,16 +68,16 @@ use option::Option::{self, Some, None};\n /// the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and\n /// only if `a != b`.\n #[lang=\"eq\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #[old_orphan_check]\n pub trait PartialEq<Rhs: ?Sized = Self> {\n     /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn eq(&self, other: &Rhs) -> bool;\n \n     /// This method tests for `!=`.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn ne(&self, other: &Rhs) -> bool { !self.eq(other) }\n }\n \n@@ -90,7 +90,7 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n /// - reflexive: `a == a`;\n /// - symmetric: `a == b` implies `b == a`; and\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait Eq: PartialEq<Self> {\n     // FIXME #13101: this method is used solely by #[deriving] to\n     // assert that every component of a type implements #[deriving]\n@@ -106,16 +106,16 @@ pub trait Eq: PartialEq<Self> {\n \n /// An ordering is, e.g, a result of a comparison between two values.\n #[derive(Clone, Copy, PartialEq, Show)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub enum Ordering {\n     /// An ordering where a compared value is less [than another].\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     Less = -1i,\n     /// An ordering where a compared value is equal [to another].\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     Equal = 0i,\n     /// An ordering where a compared value is greater [than another].\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     Greater = 1i,\n }\n \n@@ -141,7 +141,7 @@ impl Ordering {\n     /// assert!(data == b);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn reverse(self) -> Ordering {\n         unsafe {\n             // this compiles really nicely (to a single instruction);\n@@ -164,7 +164,7 @@ impl Ordering {\n ///   true; and\n /// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for\n ///   both `==` and `>`.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait Ord: Eq + PartialOrd<Self> {\n     /// This method returns an ordering between `self` and `other` values.\n     ///\n@@ -178,26 +178,26 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// assert_eq!(10u.cmp(&5),  Greater);  // because 10 > 5\n     /// assert_eq!( 5u.cmp(&5),  Equal);    // because 5 == 5\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn cmp(&self, other: &Self) -> Ordering;\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl Eq for Ordering {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl Ord for Ordering {\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn cmp(&self, other: &Ordering) -> Ordering {\n         (*self as int).cmp(&(*other as int))\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl PartialOrd for Ordering {\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn partial_cmp(&self, other: &Ordering) -> Option<Ordering> {\n         (*self as int).partial_cmp(&(*other as int))\n     }\n@@ -224,16 +224,16 @@ impl PartialOrd for Ordering {\n /// `NaN < 0 == false` and `NaN >= 0 == false` (cf. IEEE 754-2008 section\n /// 5.11).\n #[lang=\"ord\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     /// This method returns an ordering between `self` and `other` values\n     /// if one exists.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;\n \n     /// This method tests less than (for `self` and `other`) and is used by the `<` operator.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn lt(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Less) => true,\n@@ -243,7 +243,7 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n \n     /// This method tests less than or equal to (`<=`).\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn le(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Less) | Some(Equal) => true,\n@@ -253,7 +253,7 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n \n     /// This method tests greater than (`>`).\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn gt(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Greater) => true,\n@@ -263,7 +263,7 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n \n     /// This method tests greater than or equal to (`>=`).\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn ge(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Greater) | Some(Equal) => true,\n@@ -274,14 +274,14 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n \n /// Compare and return the minimum of two values.\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub fn min<T: Ord>(v1: T, v2: T) -> T {\n     if v1 < v2 { v1 } else { v2 }\n }\n \n /// Compare and return the maximum of two values.\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub fn max<T: Ord>(v1: T, v2: T) -> T {\n     if v1 > v2 { v1 } else { v2 }\n }\n@@ -290,7 +290,7 @@ pub fn max<T: Ord>(v1: T, v2: T) -> T {\n ///\n /// Returns the first argument if the comparison determines them to be equal.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n     match v1.partial_cmp(&v2) {\n         Some(Less) | Some(Equal) => Some(v1),\n@@ -303,7 +303,7 @@ pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n ///\n /// Returns the first argument if the comparison determines them to be equal.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub fn partial_max<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n     match v1.partial_cmp(&v2) {\n         Some(Less) => Some(v2),\n@@ -322,7 +322,7 @@ mod impls {\n \n     macro_rules! partial_eq_impl {\n         ($($t:ty)*) => ($(\n-            #[stable]\n+            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n             impl PartialEq for $t {\n                 #[inline]\n                 fn eq(&self, other: &$t) -> bool { (*self) == (*other) }\n@@ -332,7 +332,7 @@ mod impls {\n         )*)\n     }\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     impl PartialEq for () {\n         #[inline]\n         fn eq(&self, _other: &()) -> bool { true }\n@@ -346,7 +346,7 @@ mod impls {\n \n     macro_rules! eq_impl {\n         ($($t:ty)*) => ($(\n-            #[stable]\n+            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n             impl Eq for $t {}\n         )*)\n     }\n@@ -355,7 +355,7 @@ mod impls {\n \n     macro_rules! partial_ord_impl {\n         ($($t:ty)*) => ($(\n-            #[stable]\n+            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n             impl PartialOrd for $t {\n                 #[inline]\n                 fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n@@ -378,15 +378,15 @@ mod impls {\n         )*)\n     }\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     impl PartialOrd for () {\n         #[inline]\n         fn partial_cmp(&self, _: &()) -> Option<Ordering> {\n             Some(Equal)\n         }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     impl PartialOrd for bool {\n         #[inline]\n         fn partial_cmp(&self, other: &bool) -> Option<Ordering> {\n@@ -398,7 +398,7 @@ mod impls {\n \n     macro_rules! ord_impl {\n         ($($t:ty)*) => ($(\n-            #[stable]\n+            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n             impl Ord for $t {\n                 #[inline]\n                 fn cmp(&self, other: &$t) -> Ordering {\n@@ -410,13 +410,13 @@ mod impls {\n         )*)\n     }\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     impl Ord for () {\n         #[inline]\n         fn cmp(&self, _other: &()) -> Ordering { Equal }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     impl Ord for bool {\n         #[inline]\n         fn cmp(&self, other: &bool) -> Ordering {\n@@ -428,14 +428,14 @@ mod impls {\n \n     // & pointers\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: & &'b B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: & &'b B) -> bool { PartialEq::ne(*self, *other) }\n     }\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b B> for &'a A where A: PartialOrd<B> {\n         #[inline]\n         fn partial_cmp(&self, other: &&'b B) -> Option<Ordering> {\n@@ -450,24 +450,24 @@ mod impls {\n         #[inline]\n         fn gt(&self, other: & &'b B) -> bool { PartialOrd::gt(*self, *other) }\n     }\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     impl<'a, A: ?Sized> Ord for &'a A where A: Ord {\n         #[inline]\n         fn cmp(&self, other: & &'a A) -> Ordering { Ord::cmp(*self, *other) }\n     }\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     impl<'a, A: ?Sized> Eq for &'a A where A: Eq {}\n \n     // &mut pointers\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a mut A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b mut B> for &'a mut A where A: PartialOrd<B> {\n         #[inline]\n         fn partial_cmp(&self, other: &&'b mut B) -> Option<Ordering> {\n@@ -482,23 +482,23 @@ mod impls {\n         #[inline]\n         fn gt(&self, other: &&'b mut B) -> bool { PartialOrd::gt(*self, *other) }\n     }\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     impl<'a, A: ?Sized> Ord for &'a mut A where A: Ord {\n         #[inline]\n         fn cmp(&self, other: &&'a mut A) -> Ordering { Ord::cmp(*self, *other) }\n     }\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     impl<'a, A: ?Sized> Eq for &'a mut A where A: Eq {}\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a mut A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b B) -> bool { PartialEq::eq(*self, *other) }"}, {"sha": "74cb062af2393f778fceace941763a16e7a1a5e8", "filename": "src/libcore/default.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -81,7 +81,7 @@\n //! }\n //! ```\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n /// A trait that types which have a useful default value should implement.\n ///\n@@ -97,7 +97,7 @@\n ///     bar: f32,\n /// }\n /// ```\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait Default {\n     /// Returns the \"default value\" for a type.\n     ///\n@@ -131,16 +131,16 @@ pub trait Default {\n     ///     fn default() -> Kind { Kind::A }\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn default() -> Self;\n }\n \n macro_rules! default_impl {\n     ($t:ty, $v:expr) => {\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl Default for $t {\n             #[inline]\n-            #[stable]\n+            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n             fn default() -> $t { $v }\n         }\n     }"}, {"sha": "fdc659a300b56ebaab6e93b607b60d9ca02c9490", "filename": "src/libcore/finally.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffinally.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -30,10 +30,11 @@\n //! })\n //! ```\n \n-#![deprecated = \"It is unclear if this module is more robust than implementing \\\n-                 Drop on a custom type, and this module is being removed with no \\\n-                 replacement. Use a custom Drop implementation to regain existing \\\n-                 functionality.\"]\n+#![deprecated(feature = \"unnamed_feature\", since = \"1.0.0\",\n+              reason = \"It is unclear if this module is more robust than implementing \\\n+                        Drop on a custom type, and this module is being removed with no \\\n+                        replacement. Use a custom Drop implementation to regain existing \\\n+                        functionality.\")]\n #![allow(deprecated)]\n \n use ops::{Drop, FnMut, FnOnce};"}, {"sha": "bd45f742b6054850c65e09b37bfc56b899fd3a2c", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 62, "deletions": 38, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -11,7 +11,7 @@\n //! Utilities for formatting and printing strings\n \n #![allow(unused_variables)]\n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use any;\n use cell::{Cell, RefCell, Ref, RefMut};\n@@ -36,7 +36,8 @@ mod num;\n mod float;\n pub mod rt;\n \n-#[unstable = \"core and I/O reconciliation may alter this definition\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"core and I/O reconciliation may alter this definition\")]\n /// The type returned by formatter methods.\n pub type Result = result::Result<(), Error>;\n \n@@ -45,7 +46,8 @@ pub type Result = result::Result<(), Error>;\n /// This type does not support transmission of an error other than that an error\n /// occurred. Any extra information must be arranged to be transmitted through\n /// some other means.\n-#[unstable = \"core and I/O reconciliation may alter this definition\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"core and I/O reconciliation may alter this definition\")]\n #[derive(Copy)]\n pub struct Error;\n \n@@ -58,7 +60,8 @@ pub struct Error;\n /// This trait should generally not be implemented by consumers of the standard\n /// library. The `write!` macro accepts an instance of `io::Writer`, and the\n /// `io::Writer` trait is favored over implementing this trait.\n-#[unstable = \"waiting for core and I/O reconciliation\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"waiting for core and I/O reconciliation\")]\n pub trait Writer {\n     /// Writes a slice of bytes into this writer, returning whether the write\n     /// succeeded.\n@@ -101,7 +104,8 @@ pub trait Writer {\n /// A struct to represent both where to emit formatting strings to and how they\n /// should be formatted. A mutable version of this is passed to all formatting\n /// traits.\n-#[unstable = \"name may change and implemented traits are also unstable\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"name may change and implemented traits are also unstable\")]\n pub struct Formatter<'a> {\n     flags: uint,\n     fill: char,\n@@ -123,7 +127,8 @@ enum Void {}\n /// family of functions. It contains a function to format the given value. At\n /// compile time it is ensured that the function and the value have the correct\n /// types, and then this struct is used to canonicalize arguments to one type.\n-#[unstable = \"implementation detail of the `format_args!` macro\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"implementation detail of the `format_args!` macro\")]\n #[derive(Copy)]\n pub struct Argument<'a> {\n     value: &'a Void,\n@@ -162,7 +167,8 @@ impl<'a> Arguments<'a> {\n     /// When using the format_args!() macro, this function is used to generate the\n     /// Arguments structure.\n     #[doc(hidden)] #[inline]\n-    #[unstable = \"implementation detail of the `format_args!` macro\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"implementation detail of the `format_args!` macro\")]\n     pub fn new(pieces: &'a [&'a str],\n                args: &'a [Argument<'a>]) -> Arguments<'a> {\n         Arguments {\n@@ -179,7 +185,8 @@ impl<'a> Arguments<'a> {\n     /// created with `argumentuint`. However, failing to do so doesn't cause\n     /// unsafety, but will ignore invalid .\n     #[doc(hidden)] #[inline]\n-    #[unstable = \"implementation detail of the `format_args!` macro\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"implementation detail of the `format_args!` macro\")]\n     pub fn with_placeholders(pieces: &'a [&'a str],\n                              fmt: &'a [rt::Argument],\n                              args: &'a [Argument<'a>]) -> Arguments<'a> {\n@@ -200,7 +207,7 @@ impl<'a> Arguments<'a> {\n /// and pass it to a function or closure, passed as the first argument. The\n /// macro validates the format string at compile-time so usage of the `write`\n /// and `format` functions can be safely performed.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #[derive(Copy)]\n pub struct Arguments<'a> {\n     // Format string pieces to print.\n@@ -220,7 +227,7 @@ impl<'a> Show for Arguments<'a> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> String for Arguments<'a> {\n     fn fmt(&self, fmt: &mut Formatter) -> Result {\n         write(fmt.buf, *self)\n@@ -229,65 +236,74 @@ impl<'a> String for Arguments<'a> {\n \n /// Format trait for the `:?` format. Useful for debugging, most all types\n /// should implement this.\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n pub trait Show {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// When a value can be semantically expressed as a String, this trait may be\n /// used. It corresponds to the default format, `{}`.\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n pub trait String {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n \n /// Format trait for the `o` character\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n pub trait Octal {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `b` character\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n pub trait Binary {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `x` character\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n pub trait LowerHex {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `X` character\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n pub trait UpperHex {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `p` character\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n pub trait Pointer {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `e` character\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n pub trait LowerExp {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `E` character\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n pub trait UpperExp {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n@@ -301,8 +317,9 @@ pub trait UpperExp {\n ///\n ///   * output - the buffer to write output to\n ///   * args - the precompiled arguments generated by `format_args!`\n-#[unstable = \"libcore and I/O have yet to be reconciled, and this is an \\\n-                  implementation detail which should not otherwise be exported\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"libcore and I/O have yet to be reconciled, and this is an \\\n+                     implementation detail which should not otherwise be exported\")]\n pub fn write(output: &mut Writer, args: Arguments) -> Result {\n     let mut formatter = Formatter {\n         flags: 0,\n@@ -398,7 +415,8 @@ impl<'a> Formatter<'a> {\n     ///\n     /// This function will correctly account for the flags provided as well as\n     /// the minimum width. It will not take precision into account.\n-    #[unstable = \"definition may change slightly over time\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"definition may change slightly over time\")]\n     pub fn pad_integral(&mut self,\n                         is_positive: bool,\n                         prefix: &str,\n@@ -474,7 +492,8 @@ impl<'a> Formatter<'a> {\n     ///               is longer than this length\n     ///\n     /// Notably this function ignored the `flag` parameters\n-    #[unstable = \"definition may change slightly over time\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"definition may change slightly over time\")]\n     pub fn pad(&mut self, s: &str) -> Result {\n         // Make sure there's a fast path up front\n         if self.width.is_none() && self.precision.is_none() {\n@@ -551,35 +570,38 @@ impl<'a> Formatter<'a> {\n \n     /// Writes some data to the underlying buffer contained within this\n     /// formatter.\n-    #[unstable = \"reconciling core and I/O may alter this definition\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"reconciling core and I/O may alter this definition\")]\n     pub fn write_str(&mut self, data: &str) -> Result {\n         self.buf.write_str(data)\n     }\n \n     /// Writes some formatted information into this instance\n-    #[unstable = \"reconciling core and I/O may alter this definition\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"reconciling core and I/O may alter this definition\")]\n     pub fn write_fmt(&mut self, fmt: Arguments) -> Result {\n         write(self.buf, fmt)\n     }\n \n     /// Flags for formatting (packed version of rt::Flag)\n-    #[unstable = \"return type may change and method was just created\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"return type may change and method was just created\")]\n     pub fn flags(&self) -> uint { self.flags }\n \n     /// Character used as 'fill' whenever there is alignment\n-    #[unstable = \"method was just created\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"method was just created\")]\n     pub fn fill(&self) -> char { self.fill }\n \n     /// Flag indicating what form of alignment was requested\n-    #[unstable = \"method was just created\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"method was just created\")]\n     pub fn align(&self) -> rt::Alignment { self.align }\n \n     /// Optionally specified integer width that the output should be\n-    #[unstable = \"method was just created\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"method was just created\")]\n     pub fn width(&self) -> Option<uint> { self.width }\n \n     /// Optionally specified precision for numeric types\n-    #[unstable = \"method was just created\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"method was just created\")]\n     pub fn precision(&self) -> Option<uint> { self.precision }\n }\n \n@@ -592,7 +614,8 @@ impl Show for Error {\n /// This is a function which calls are emitted to by the compiler itself to\n /// create the Argument structures that are passed into the `format` function.\n #[doc(hidden)] #[inline]\n-#[unstable = \"implementation detail of the `format_args!` macro\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"implementation detail of the `format_args!` macro\")]\n pub fn argument<'a, T>(f: fn(&T, &mut Formatter) -> Result,\n                        t: &'a T) -> Argument<'a> {\n     Argument::new(t, f)\n@@ -601,7 +624,8 @@ pub fn argument<'a, T>(f: fn(&T, &mut Formatter) -> Result,\n /// When the compiler determines that the type of an argument *must* be a uint\n /// (such as for width and precision), then it invokes this method.\n #[doc(hidden)] #[inline]\n-#[unstable = \"implementation detail of the `format_args!` macro\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"implementation detail of the `format_args!` macro\")]\n pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n     Argument::from_uint(s)\n }\n@@ -629,7 +653,7 @@ impl Show for bool {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl String for bool {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         String::fmt(if *self { \"true\" } else { \"false\" }, f)\n@@ -646,7 +670,7 @@ impl Show for str {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl String for str {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.pad(self)\n@@ -664,7 +688,7 @@ impl Show for char {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl String for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         let mut utf8 = [0u8; 4];\n@@ -710,7 +734,7 @@ macro_rules! floating { ($ty:ident) => {\n         }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     impl String for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n             use num::Float;\n@@ -855,7 +879,7 @@ impl<T: Copy + Show> Show for Cell<T> {\n     }\n }\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n impl<T: Show> Show for RefCell<T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         match self.try_borrow() {\n@@ -877,7 +901,7 @@ impl<'b, T: Show> Show for RefMut<'b, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl String for Utf8Error {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         match *self {"}, {"sha": "630b7489eba2aab2aabc20658c30856420315fad", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -111,7 +111,8 @@ radix! { UpperHex, 16, \"0x\", x @  0 ...  9 => b'0' + x,\n \n /// A radix with in the range of `2..36`.\n #[derive(Clone, Copy, PartialEq)]\n-#[unstable = \"may be renamed or move to a different module\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"may be renamed or move to a different module\")]\n pub struct Radix {\n     base: u8,\n }\n@@ -135,7 +136,8 @@ impl GenericRadix for Radix {\n }\n \n /// A helper type for formatting radixes.\n-#[unstable = \"may be renamed or move to a different module\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"may be renamed or move to a different module\")]\n #[derive(Copy)]\n pub struct RadixFmt<T, R>(T, R);\n \n@@ -147,7 +149,8 @@ pub struct RadixFmt<T, R>(T, R);\n /// use std::fmt::radix;\n /// assert_eq!(format!(\"{}\", radix(55i, 36)), \"1j\".to_string());\n /// ```\n-#[unstable = \"may be renamed or move to a different module\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"may be renamed or move to a different module\")]\n pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> {\n     RadixFmt(x, Radix::new(base))\n }"}, {"sha": "6056a8858b756314cd329e4507d86d491696841f", "filename": "src/libcore/fmt/rt.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -14,7 +14,8 @@\n //! These definitions are similar to their `ct` equivalents, but differ in that\n //! these can be statically allocated and are slightly optimized for the runtime\n \n-#![unstable = \"implementation detail of the `format_args!` macro\"]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+            reason = \"implementation detail of the `format_args!` macro\")]\n \n pub use self::Alignment::*;\n pub use self::Count::*;"}, {"sha": "51212bcdb68e7f258ee973272f683a58015d240c", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -56,7 +56,8 @@\n //! assert_eq!(hash::<_, SipHasher>(&person1), hash::<_, SipHasher>(&person2));\n //! ```\n \n-#![unstable = \"module was recently redesigned\"]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+            reason = \"module was recently redesigned\")]\n \n use prelude::*;\n "}, {"sha": "1492547de44d50b0253dd24c7d90421cc666a294", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -112,7 +112,7 @@ impl SipHasher {\n     }\n \n     /// Returns the computed hash.\n-    #[deprecated = \"renamed to finish\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\", reason = \"renamed to finish\")]\n     pub fn result(&self) -> u64 { self.finish() }\n }\n "}, {"sha": "5835449e94630467033b8ea6b0fc77612fa0b0e9", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -39,7 +39,7 @@\n //!   guaranteed to happen in order. This is the standard mode for working\n //!   with atomic types and is equivalent to Java's `volatile`.\n \n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n use marker::Sized;\n@@ -227,7 +227,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// `forget` is unsafe because the caller is responsible for\n     /// ensuring the argument is deallocated already.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn forget<T>(_: T) -> ();\n \n     /// Unsafely transforms a value of one type into a value of another type.\n@@ -243,7 +243,7 @@ extern \"rust-intrinsic\" {\n     /// let v: &[u8] = unsafe { mem::transmute(\"L\") };\n     /// assert!(v == [76u8]);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn transmute<T,U>(e: T) -> U;\n \n     /// Gives the address for the return value of the enclosing function.\n@@ -303,7 +303,7 @@ extern \"rust-intrinsic\" {\n     ///     }\n     /// }\n     /// ```\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint);\n \n     /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n@@ -333,12 +333,13 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// ```\n     ///\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn copy_memory<T>(dst: *mut T, src: *const T, count: uint);\n \n     /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n     /// bytes of memory starting at `dst` to `c`.\n-    #[unstable = \"uncertain about naming and semantics\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"uncertain about naming and semantics\")]\n     pub fn set_memory<T>(dst: *mut T, val: u8, count: uint);\n \n     /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with"}, {"sha": "9dc13a58311f87d266eb3387962941256962680b", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 190, "deletions": 165, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -54,7 +54,7 @@\n //!\n //! This `for` loop syntax can be applied to any iterator over any type.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use self::MinMaxResult::*;\n \n@@ -81,26 +81,26 @@ use uint;\n /// it wishes, either by returning `None` infinitely, or by doing something\n /// else.\n #[lang=\"iterator\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait Iterator {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     type Item;\n \n     /// Advance the iterator and return the next value. Return `None` when the end is reached.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn next(&mut self) -> Option<Self::Item>;\n \n     /// Returns a lower and upper bound on the remaining length of the iterator.\n     ///\n     /// An upper bound of `None` means either there is no known upper bound, or the upper bound\n     /// does not fit within a `uint`.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }\n }\n \n /// Conversion from an `Iterator`\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #[rustc_on_unimplemented=\"a collection of type `{Self}` cannot be \\\n                           built from an iterator over elements of type `{A}`\"]\n pub trait FromIterator<A> {\n@@ -109,15 +109,15 @@ pub trait FromIterator<A> {\n }\n \n /// A type growable from an `Iterator` implementation\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait Extend<A> {\n     /// Extend a container with the elements yielded by an arbitrary iterator\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn extend<T: Iterator<Item=A>>(&mut self, iterator: T);\n }\n \n /// An extension trait providing numerous methods applicable to all iterators.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait IteratorExt: Iterator + Sized {\n     /// Counts the number of elements in this iterator.\n     ///\n@@ -129,7 +129,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.count() == 5);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn count(self) -> uint {\n         self.fold(0, |cnt, _x| cnt + 1)\n     }\n@@ -144,7 +144,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.iter().last().unwrap() == &5);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn last(mut self) -> Option<Self::Item> {\n         let mut last = None;\n         for x in self { last = Some(x); }\n@@ -163,7 +163,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.nth(2) == None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn nth(&mut self, mut n: uint) -> Option<Self::Item> {\n         for x in *self {\n             if n == 0 { return Some(x) }\n@@ -187,7 +187,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn chain<U>(self, other: U) -> Chain<Self, U> where\n         U: Iterator<Item=Self::Item>,\n     {\n@@ -210,7 +210,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn zip<B, U>(self, other: U) -> Zip<Self, U> where\n         U: Iterator<Item=B>,\n     {\n@@ -230,7 +230,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn map<B, F>(self, f: F) -> Map<Self::Item, B, Self, F> where\n         F: FnMut(Self::Item) -> B,\n     {\n@@ -250,7 +250,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn filter<P>(self, predicate: P) -> Filter<Self::Item, Self, P> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n@@ -270,7 +270,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn filter_map<B, F>(self, f: F) -> FilterMap<Self::Item, B, Self, F> where\n         F: FnMut(Self::Item) -> Option<B>,\n     {\n@@ -291,7 +291,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn enumerate(self) -> Enumerate<Self> {\n         Enumerate{iter: self, count: 0}\n     }\n@@ -314,7 +314,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn peekable(self) -> Peekable<Self::Item, Self> {\n         Peekable{iter: self, peeked: None}\n     }\n@@ -334,7 +334,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn skip_while<P>(self, predicate: P) -> SkipWhile<Self::Item, Self, P> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n@@ -355,7 +355,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn take_while<P>(self, predicate: P) -> TakeWhile<Self::Item, Self, P> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n@@ -375,7 +375,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn skip(self, n: uint) -> Skip<Self> {\n         Skip{iter: self, n: n}\n     }\n@@ -394,7 +394,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn take(self, n: uint) -> Take<Self> {\n         Take{iter: self, n: n}\n     }\n@@ -420,7 +420,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn scan<St, B, F>(\n         self,\n         initial_state: St,\n@@ -450,7 +450,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn flat_map<B, U, F>(self, f: F) -> FlatMap<Self::Item, B, Self, U, F> where\n         U: Iterator<Item=B>,\n         F: FnMut(Self::Item) -> U,\n@@ -486,7 +486,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(process(x.into_iter()), 1006);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn fuse(self) -> Fuse<Self> {\n         Fuse{iter: self, done: false}\n     }\n@@ -510,7 +510,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// println!(\"{}\", sum);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn inspect<F>(self, f: F) -> Inspect<Self::Item, Self, F> where\n         F: FnMut(&Self::Item),\n     {\n@@ -532,7 +532,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// // xs.next() is now `5`\n     /// assert!(xs.next() == Some(5));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn by_ref<'r>(&'r mut self) -> ByRef<'r, Self> {\n         ByRef{iter: self}\n     }\n@@ -548,7 +548,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.as_slice() == b.as_slice());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn collect<B: FromIterator<Self::Item>>(self) -> B {\n         FromIterator::from_iter(self)\n     }\n@@ -564,7 +564,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(even, vec![2, 4]);\n     /// assert_eq!(odd, vec![1, 3]);\n     /// ```\n-    #[unstable = \"recently added as part of collections reform\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"recently added as part of collections reform\")]\n     fn partition<B, F>(mut self, mut f: F) -> (B, B) where\n         B: Default + Extend<Self::Item>,\n         F: FnMut(&Self::Item) -> bool\n@@ -593,7 +594,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.iter().fold(0, |a, &b| a + b) == 15);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n         F: FnMut(B, Self::Item) -> B,\n     {\n@@ -614,7 +615,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(!a.iter().all(|x| *x > 2));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn all<F>(mut self, mut f: F) -> bool where F: FnMut(Self::Item) -> bool {\n         for x in self { if !f(x) { return false; } }\n         true\n@@ -632,7 +633,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(!it.any(|x| *x == 3));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn any<F>(&mut self, mut f: F) -> bool where F: FnMut(Self::Item) -> bool {\n         for x in *self { if f(x) { return true; } }\n         false\n@@ -642,7 +643,7 @@ pub trait IteratorExt: Iterator + Sized {\n     ///\n     /// Does not consume the iterator past the first found element.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n@@ -654,7 +655,7 @@ pub trait IteratorExt: Iterator + Sized {\n \n     /// Return the index of the first element satisfying the specified predicate\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn position<P>(&mut self, mut predicate: P) -> Option<uint> where\n         P: FnMut(Self::Item) -> bool,\n     {\n@@ -672,7 +673,7 @@ pub trait IteratorExt: Iterator + Sized {\n     ///\n     /// If no element matches, None is returned.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn rposition<P>(&mut self, mut predicate: P) -> Option<uint> where\n         P: FnMut(Self::Item) -> bool,\n         Self: ExactSizeIterator + DoubleEndedIterator\n@@ -695,7 +696,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.iter().max().unwrap() == &5);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn max(self) -> Option<Self::Item> where Self::Item: Ord\n     {\n         self.fold(None, |max, x| {\n@@ -715,7 +716,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.iter().min().unwrap() == &1);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn min(self) -> Option<Self::Item> where Self::Item: Ord\n     {\n         self.fold(None, |min, x| {\n@@ -759,7 +760,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// let v = [1i, 1, 1, 1];\n     /// assert!(v.iter().min_max() == MinMax(&1, &1));\n     /// ```\n-    #[unstable = \"return type may change\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"return type may change\")]\n     fn min_max(mut self) -> MinMaxResult<Self::Item> where Self::Item: Ord\n     {\n         let (mut min, mut max) = match self.next() {\n@@ -816,7 +817,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n     /// ```\n     #[inline]\n-    #[unstable = \"may want to produce an Ordering directly; see #15311\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"may want to produce an Ordering directly; see #15311\")]\n     fn max_by<B: Ord, F>(self, mut f: F) -> Option<Self::Item> where\n         F: FnMut(&Self::Item) -> B,\n     {\n@@ -845,7 +847,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n     /// ```\n     #[inline]\n-    #[unstable = \"may want to produce an Ordering directly; see #15311\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"may want to produce an Ordering directly; see #15311\")]\n     fn min_by<B: Ord, F>(self, mut f: F) -> Option<Self::Item> where\n         F: FnMut(&Self::Item) -> B,\n     {\n@@ -875,7 +878,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Note: Random access with flipped indices still only applies to the first\n     /// `uint::MAX` elements of the original iterator.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn rev(self) -> Rev<Self> {\n         Rev{iter: self}\n     }\n@@ -884,7 +887,7 @@ pub trait IteratorExt: Iterator + Sized {\n     ///\n     /// Loops through the entire iterator, collecting the first component of\n     /// each item into one new container, and the second component into another.\n-    #[unstable = \"recent addition\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"recent addition\")]\n     fn unzip<A, B, FromA, FromB>(mut self) -> (FromA, FromB) where\n         FromA: Default + Extend<A>,\n         FromB: Default + Extend<B>,\n@@ -917,7 +920,7 @@ pub trait IteratorExt: Iterator + Sized {\n \n     /// Creates an iterator that clones the elements it yields. Useful for converting an\n     /// Iterator<&T> to an Iterator<T>.\n-    #[unstable = \"recent addition\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"recent addition\")]\n     fn cloned<T, D>(self) -> Cloned<Self> where\n         Self: Iterator<Item=D>,\n         D: Deref<Target=T>,\n@@ -938,14 +941,15 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(cy.next(), Some(1));\n     /// assert_eq!(cy.next(), Some(1));\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     #[inline]\n     fn cycle(self) -> Cycle<Self> where Self: Clone {\n         Cycle{orig: self.clone(), iter: self}\n     }\n \n     /// Use an iterator to reverse a container in place.\n-    #[unstable = \"uncertain about placement or widespread use\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"uncertain about placement or widespread use\")]\n     fn reverse_in_place<'a, T: 'a>(&mut self) where\n         Self: Iterator<Item=&'a mut T> + DoubleEndedIterator\n     {\n@@ -958,17 +962,17 @@ pub trait IteratorExt: Iterator + Sized {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<I> IteratorExt for I where I: Iterator {}\n \n /// A range iterator able to yield elements from both ends\n ///\n /// A `DoubleEndedIterator` can be thought of as a deque in that `next()` and `next_back()` exhaust\n /// elements from the *same* range, and do not work independently of each other.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait DoubleEndedIterator: Iterator {\n     /// Yield an element from the end of the range, returning `None` if the range is empty.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn next_back(&mut self) -> Option<Self::Item>;\n }\n \n@@ -978,7 +982,8 @@ pub trait DoubleEndedIterator: Iterator {\n /// Calling `next()` or `next_back()` on a `RandomAccessIterator`\n /// reduces the indexable range accordingly. That is, `it.idx(1)` will become `it.idx(0)`\n /// after `it.next()` is called.\n-#[unstable = \"not widely used, may be better decomposed into Index and ExactSizeIterator\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"not widely used, may be better decomposed into Index and ExactSizeIterator\")]\n pub trait RandomAccessIterator: Iterator {\n     /// Return the number of indexable elements. At most `std::uint::MAX`\n     /// elements are indexable, even if the iterator represents a longer range.\n@@ -995,7 +1000,7 @@ pub trait RandomAccessIterator: Iterator {\n ///\n /// `Iterator::size_hint` *must* return the exact size of the iterator.\n /// Note that the size must fit in `uint`.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait ExactSizeIterator: Iterator {\n     #[inline]\n     /// Return the exact length of the iterator.\n@@ -1012,32 +1017,32 @@ pub trait ExactSizeIterator: Iterator {\n \n // All adaptors that preserve the size of the wrapped iterator are fine\n // Adaptors that may overflow in `size_hint` are not, i.e. `Chain`.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {}\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, I, F> ExactSizeIterator for Inspect<A, I, F> where\n     I: ExactSizeIterator<Item=A>,\n     F: FnMut(&A),\n {}\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Rev<I> where I: ExactSizeIterator + DoubleEndedIterator {}\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, B, I, F> ExactSizeIterator for Map<A, B, I, F> where\n     I: ExactSizeIterator<Item=A>,\n     F: FnMut(A) -> B,\n {}\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, B> ExactSizeIterator for Zip<A, B> where A: ExactSizeIterator, B: ExactSizeIterator {}\n \n /// An double-ended iterator with the direction inverted\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Rev<T> {\n     iter: T\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -1047,13 +1052,13 @@ impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Rev<I> where I: DoubleEndedIterator + RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> uint { self.iter.indexable() }\n@@ -1066,12 +1071,12 @@ impl<I> RandomAccessIterator for Rev<I> where I: DoubleEndedIterator + RandomAcc\n \n /// A mutable reference to an iterator\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct ByRef<'a, I:'a> {\n     iter: &'a mut I,\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, I> Iterator for ByRef<'a, I> where I: 'a + Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -1081,14 +1086,15 @@ impl<'a, I> Iterator for ByRef<'a, I> where I: 'a + Iterator {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, I> DoubleEndedIterator for ByRef<'a, I> where I: 'a + DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }\n }\n \n /// A trait for iterators over elements which can be added together\n-#[unstable = \"needs to be re-evaluated as part of numerics reform\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"needs to be re-evaluated as part of numerics reform\")]\n pub trait AdditiveIterator<A> {\n     /// Iterates over the entire iterator, summing up all the elements\n     ///\n@@ -1106,7 +1112,7 @@ pub trait AdditiveIterator<A> {\n \n macro_rules! impl_additive {\n     ($A:ty, $init:expr) => {\n-        #[unstable = \"trait is experimental\"]\n+        #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is experimental\")]\n         impl<T: Iterator<Item=$A>> AdditiveIterator<$A> for T {\n             #[inline]\n             fn sum(self) -> $A {\n@@ -1129,7 +1135,8 @@ impl_additive! { f32,  0.0 }\n impl_additive! { f64,  0.0 }\n \n /// A trait for iterators over elements which can be multiplied together.\n-#[unstable = \"needs to be re-evaluated as part of numerics reform\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"needs to be re-evaluated as part of numerics reform\")]\n pub trait MultiplicativeIterator<A> {\n     /// Iterates over the entire iterator, multiplying all the elements\n     ///\n@@ -1150,7 +1157,7 @@ pub trait MultiplicativeIterator<A> {\n \n macro_rules! impl_multiplicative {\n     ($A:ty, $init:expr) => {\n-        #[unstable = \"trait is experimental\"]\n+        #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is experimental\")]\n         impl<T: Iterator<Item=$A>> MultiplicativeIterator<$A> for T {\n             #[inline]\n             fn product(self) -> $A {\n@@ -1174,7 +1181,8 @@ impl_multiplicative! { f64,  1.0 }\n \n /// `MinMaxResult` is an enum returned by `min_max`. See `IteratorOrdExt::min_max` for more detail.\n #[derive(Clone, PartialEq, Show)]\n-#[unstable = \"unclear whether such a fine-grained result is widely useful\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"unclear whether such a fine-grained result is widely useful\")]\n pub enum MinMaxResult<T> {\n     /// Empty iterator\n     NoElements,\n@@ -1206,7 +1214,7 @@ impl<T: Clone> MinMaxResult<T> {\n     /// let r = MinMax(1i,2i);\n     /// assert_eq!(r.into_option(), Some((1,2)));\n     /// ```\n-    #[unstable = \"type is unstable\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"type is unstable\")]\n     pub fn into_option(self) -> Option<(T,T)> {\n         match self {\n             NoElements => None,\n@@ -1217,14 +1225,14 @@ impl<T: Clone> MinMaxResult<T> {\n }\n \n /// An iterator that clones the elements of an underlying iterator\n-#[unstable = \"recent addition\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"recent addition\")]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[derive(Clone)]\n pub struct Cloned<I> {\n     it: I,\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T, D, I> Iterator for Cloned<I> where\n     T: Clone,\n     D: Deref<Target=T>,\n@@ -1241,7 +1249,7 @@ impl<T, D, I> Iterator for Cloned<I> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T, D, I> DoubleEndedIterator for Cloned<I> where\n     T: Clone,\n     D: Deref<Target=T>,\n@@ -1252,7 +1260,7 @@ impl<T, D, I> DoubleEndedIterator for Cloned<I> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T, D, I> ExactSizeIterator for Cloned<I> where\n     T: Clone,\n     D: Deref<Target=T>,\n@@ -1262,13 +1270,13 @@ impl<T, D, I> ExactSizeIterator for Cloned<I> where\n /// An iterator that repeats endlessly\n #[derive(Clone, Copy)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Cycle<I> {\n     orig: I,\n     iter: I,\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -1291,7 +1299,7 @@ impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Cycle<I> where\n     I: Clone + RandomAccessIterator,\n {\n@@ -1321,14 +1329,14 @@ impl<I> RandomAccessIterator for Cycle<I> where\n /// An iterator that strings two iterators together\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Chain<A, B> {\n     a: A,\n     b: B,\n     flag: bool,\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item=T>, B: Iterator<Item=T> {\n     type Item = T;\n \n@@ -1362,7 +1370,7 @@ impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item=T>, B: Iterator<It\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T, A, B> DoubleEndedIterator for Chain<A, B> where\n     A: DoubleEndedIterator<Item=T>,\n     B: DoubleEndedIterator<Item=T>,\n@@ -1376,7 +1384,7 @@ impl<T, A, B> DoubleEndedIterator for Chain<A, B> where\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is experimental\")]\n impl<T, A, B> RandomAccessIterator for Chain<A, B> where\n     A: RandomAccessIterator<Item=T>,\n     B: RandomAccessIterator<Item=T>,\n@@ -1401,13 +1409,13 @@ impl<T, A, B> RandomAccessIterator for Chain<A, B> where\n /// An iterator that iterates two other iterators simultaneously\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Zip<A, B> {\n     a: A,\n     b: B\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T, U, A, B> Iterator for Zip<A, B> where\n     A: Iterator<Item = T>,\n     B: Iterator<Item = U>,\n@@ -1443,7 +1451,7 @@ impl<T, U, A, B> Iterator for Zip<A, B> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T, U, A, B> DoubleEndedIterator for Zip<A, B> where\n     A: DoubleEndedIterator + ExactSizeIterator<Item=T>,\n     B: DoubleEndedIterator + ExactSizeIterator<Item=U>,\n@@ -1468,7 +1476,7 @@ impl<T, U, A, B> DoubleEndedIterator for Zip<A, B> where\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is experimental\")]\n impl<T, U, A, B> RandomAccessIterator for Zip<A, B> where\n     A: RandomAccessIterator<Item=T>,\n     B: RandomAccessIterator<Item=U>,\n@@ -1492,14 +1500,14 @@ impl<T, U, A, B> RandomAccessIterator for Zip<A, B> where\n \n /// An iterator that maps the values of `iter` with `f`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Map<A, B, I: Iterator<Item=A>, F: FnMut(A) -> B> {\n     iter: I,\n     f: F,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, B, I, F> Clone for Map<A, B, I, F> where\n     I: Clone + Iterator<Item=A>,\n     F: Clone + FnMut(A) -> B,\n@@ -1522,7 +1530,7 @@ impl<A, B, I, F> Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n     type Item = B;\n \n@@ -1538,7 +1546,7 @@ impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMu\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, B, I, F> DoubleEndedIterator for Map<A, B, I, F> where\n     I: DoubleEndedIterator<Item=A>,\n     F: FnMut(A) -> B,\n@@ -1550,7 +1558,7 @@ impl<A, B, I, F> DoubleEndedIterator for Map<A, B, I, F> where\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is experimental\")]\n impl<A, B, I, F> RandomAccessIterator for Map<A, B, I, F> where\n     I: RandomAccessIterator<Item=A>,\n     F: FnMut(A) -> B,\n@@ -1569,14 +1577,14 @@ impl<A, B, I, F> RandomAccessIterator for Map<A, B, I, F> where\n \n /// An iterator that filters the elements of `iter` with `predicate`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     iter: I,\n     predicate: P,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, I, P> Clone for Filter<A, I, P> where\n     I: Clone + Iterator<Item=A>,\n     P: Clone + FnMut(&A) -> bool,\n@@ -1589,7 +1597,7 @@ impl<A, I, P> Clone for Filter<A, I, P> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     type Item = A;\n \n@@ -1612,7 +1620,7 @@ impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, I, P> DoubleEndedIterator for Filter<A, I, P> where\n     I: DoubleEndedIterator<Item=A>,\n     P: FnMut(&A) -> bool,\n@@ -1630,14 +1638,14 @@ impl<A, I, P> DoubleEndedIterator for Filter<A, I, P> where\n \n /// An iterator that uses `f` to both filter and map elements from `iter`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct FilterMap<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> Option<B> {\n     iter: I,\n     f: F,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, B, I, F> Clone for FilterMap<A, B, I, F> where\n     I: Clone + Iterator<Item=A>,\n     F: Clone + FnMut(A) -> Option<B>,\n@@ -1650,7 +1658,7 @@ impl<A, B, I, F> Clone for FilterMap<A, B, I, F> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n     I: Iterator<Item=A>,\n     F: FnMut(A) -> Option<B>,\n@@ -1675,7 +1683,7 @@ impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, B, I, F> DoubleEndedIterator for FilterMap<A, B, I, F> where\n     I: DoubleEndedIterator<Item=A>,\n     F: FnMut(A) -> Option<B>,\n@@ -1695,13 +1703,13 @@ impl<A, B, I, F> DoubleEndedIterator for FilterMap<A, B, I, F> where\n /// An iterator that yields the current count and the element during iteration\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Enumerate<I> {\n     iter: I,\n     count: uint\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<I> Iterator for Enumerate<I> where I: Iterator {\n     type Item = (uint, <I as Iterator>::Item);\n \n@@ -1723,7 +1731,7 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<I> DoubleEndedIterator for Enumerate<I> where\n     I: ExactSizeIterator + DoubleEndedIterator\n {\n@@ -1739,7 +1747,7 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1757,14 +1765,14 @@ impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator {\n \n /// An iterator with a `peek()` that returns an optional reference to the next element.\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #[derive(Copy)]\n pub struct Peekable<T, I> where I: Iterator<Item=T> {\n     iter: I,\n     peeked: Option<T>,\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T, I> Iterator for Peekable<T, I> where I: Iterator<Item=T> {\n     type Item = T;\n \n@@ -1790,7 +1798,7 @@ impl<T, I> Iterator for Peekable<T, I> where I: Iterator<Item=T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T, I> Peekable<T, I> where I: Iterator<Item=T> {\n     /// Return a reference to the next element of the iterator with out advancing it,\n     /// or None if the iterator is exhausted.\n@@ -1814,15 +1822,15 @@ impl<T, I> Peekable<T, I> where I: Iterator<Item=T> {\n \n /// An iterator that rejects elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     iter: I,\n     flag: bool,\n     predicate: P,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, I, P> Clone for SkipWhile<A, I, P> where\n     I: Clone + Iterator<Item=A>,\n     P: Clone + FnMut(&A) -> bool,\n@@ -1836,7 +1844,7 @@ impl<A, I, P> Clone for SkipWhile<A, I, P> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, I, P> Iterator for SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     type Item = A;\n \n@@ -1860,15 +1868,15 @@ impl<A, I, P> Iterator for SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMu\n \n /// An iterator that only accepts elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     iter: I,\n     flag: bool,\n     predicate: P,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, I, P> Clone for TakeWhile<A, I, P> where\n     I: Clone + Iterator<Item=A>,\n     P: Clone + FnMut(&A) -> bool,\n@@ -1882,7 +1890,7 @@ impl<A, I, P> Clone for TakeWhile<A, I, P> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, I, P> Iterator for TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     type Item = A;\n \n@@ -1915,13 +1923,13 @@ impl<A, I, P> Iterator for TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMu\n /// An iterator that skips over `n` elements of `iter`.\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Skip<I> {\n     iter: I,\n     n: uint\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<I> Iterator for Skip<I> where I: Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -1965,7 +1973,7 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Skip<I> where I: RandomAccessIterator{\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1985,13 +1993,13 @@ impl<I> RandomAccessIterator for Skip<I> where I: RandomAccessIterator{\n /// An iterator that only iterates over the first `n` iterations of `iter`.\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Take<I> {\n     iter: I,\n     n: uint\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<I> Iterator for Take<I> where I: Iterator{\n     type Item = <I as Iterator>::Item;\n \n@@ -2020,7 +2028,7 @@ impl<I> Iterator for Take<I> where I: Iterator{\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Take<I> where I: RandomAccessIterator{\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -2040,7 +2048,7 @@ impl<I> RandomAccessIterator for Take<I> where I: RandomAccessIterator{\n \n /// An iterator to maintain state while iterating another iterator\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Scan<A, B, I, St, F> where I: Iterator, F: FnMut(&mut St, A) -> Option<B> {\n     iter: I,\n     f: F,\n@@ -2050,7 +2058,7 @@ pub struct Scan<A, B, I, St, F> where I: Iterator, F: FnMut(&mut St, A) -> Optio\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, B, I, St, F> Clone for Scan<A, B, I, St, F> where\n     I: Clone + Iterator<Item=A>,\n     St: Clone,\n@@ -2065,7 +2073,7 @@ impl<A, B, I, St, F> Clone for Scan<A, B, I, St, F> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, B, I, St, F> Iterator for Scan<A, B, I, St, F> where\n     I: Iterator<Item=A>,\n     F: FnMut(&mut St, A) -> Option<B>,\n@@ -2088,7 +2096,7 @@ impl<A, B, I, St, F> Iterator for Scan<A, B, I, St, F> where\n /// and yields the elements of the produced iterators\n ///\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct FlatMap<A, B, I, U, F> where\n     I: Iterator<Item=A>,\n     U: Iterator<Item=B>,\n@@ -2101,7 +2109,7 @@ pub struct FlatMap<A, B, I, U, F> where\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, B, I, U, F> Clone for FlatMap<A, B, I, U, F> where\n     I: Clone + Iterator<Item=A>,\n     U: Clone + Iterator<Item=B>,\n@@ -2117,7 +2125,7 @@ impl<A, B, I, U, F> Clone for FlatMap<A, B, I, U, F> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n     I: Iterator<Item=A>,\n     U: Iterator<Item=B>,\n@@ -2152,7 +2160,7 @@ impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, B, I, U, F> DoubleEndedIterator for FlatMap<A, B, I, U, F> where\n     I: DoubleEndedIterator<Item=A>,\n     U: DoubleEndedIterator<Item=B>,\n@@ -2179,13 +2187,13 @@ impl<A, B, I, U, F> DoubleEndedIterator for FlatMap<A, B, I, U, F> where\n /// yields `None` once.\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Fuse<I> {\n     iter: I,\n     done: bool\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<I> Iterator for Fuse<I> where I: Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -2214,7 +2222,7 @@ impl<I> Iterator for Fuse<I> where I: Iterator {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n@@ -2233,7 +2241,7 @@ impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n }\n \n // Allow RandomAccessIterators to be fused without affecting random-access behavior\n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Fuse<I> where I: RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -2250,7 +2258,7 @@ impl<I> Fuse<I> {\n     /// Resets the fuse such that the next call to .next() or .next_back() will\n     /// call the underlying iterator again even if it previously returned None.\n     #[inline]\n-    #[unstable = \"seems marginal\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"seems marginal\")]\n     pub fn reset_fuse(&mut self) {\n         self.done = false\n     }\n@@ -2259,14 +2267,14 @@ impl<I> Fuse<I> {\n /// An iterator that calls a function with a reference to each\n /// element before yielding it.\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     iter: I,\n     f: F,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, I, F> Clone for Inspect<A, I, F> where\n     I: Clone + Iterator<Item=A>,\n     F: Clone + FnMut(&A),\n@@ -2291,7 +2299,7 @@ impl<A, I, F> Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     type Item = A;\n \n@@ -2307,7 +2315,7 @@ impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, I, F> DoubleEndedIterator for Inspect<A, I, F> where\n     I: DoubleEndedIterator<Item=A>,\n     F: FnMut(&A),\n@@ -2319,7 +2327,7 @@ impl<A, I, F> DoubleEndedIterator for Inspect<A, I, F> where\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is experimental\")]\n impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n     I: RandomAccessIterator<Item=A>,\n     F: FnMut(&A),\n@@ -2368,15 +2376,15 @@ impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n ///     println!(\"{}\", i);\n /// }\n /// ```\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub struct Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     f: F,\n     /// Internal state that will be passed to the closure on the next iteration\n     pub state: St,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, St, F> Clone for Unfold<A, St, F> where\n     F: Clone + FnMut(&mut St) -> Option<A>,\n     St: Clone,\n@@ -2389,7 +2397,7 @@ impl<A, St, F> Clone for Unfold<A, St, F> where\n     }\n }\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n impl<A, St, F> Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     /// Creates a new iterator with the specified closure as the \"iterator\n     /// function\" and an initial state to eventually pass to the closure\n@@ -2402,7 +2410,7 @@ impl<A, St, F> Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, St, F> Iterator for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     type Item = A;\n \n@@ -2421,7 +2429,8 @@ impl<A, St, F> Iterator for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A\n /// An infinite iterator starting at `start` and advancing by `step` with each\n /// iteration\n #[derive(Clone, Copy)]\n-#[unstable = \"may be renamed or replaced by range notation adapaters\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"may be renamed or replaced by range notation adapaters\")]\n pub struct Counter<A> {\n     /// The current state the counter is at (next value to be yielded)\n     state: A,\n@@ -2431,12 +2440,13 @@ pub struct Counter<A> {\n \n /// Creates a new counter with the specified start/step\n #[inline]\n-#[unstable = \"may be renamed or replaced by range notation adapaters\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"may be renamed or replaced by range notation adapaters\")]\n pub fn count<A>(start: A, step: A) -> Counter<A> {\n     Counter{state: start, step: step}\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A: Add<Output=A> + Clone> Iterator for Counter<A> {\n     type Item = A;\n \n@@ -2455,7 +2465,8 @@ impl<A: Add<Output=A> + Clone> Iterator for Counter<A> {\n \n /// An iterator over the range [start, stop)\n #[derive(Clone, Copy)]\n-#[unstable = \"will be replaced by range notation\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"will be replaced by range notation\")]\n pub struct Range<A> {\n     state: A,\n     stop: A,\n@@ -2476,7 +2487,8 @@ pub struct Range<A> {\n /// }\n /// ```\n #[inline]\n-#[unstable = \"will be replaced by range notation\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"will be replaced by range notation\")]\n pub fn range<A: Int>(start: A, stop: A) -> Range<A> {\n     Range {\n         state: start,\n@@ -2486,7 +2498,8 @@ pub fn range<A: Int>(start: A, stop: A) -> Range<A> {\n }\n \n // FIXME: #10414: Unfortunate type bound\n-#[unstable = \"will be replaced by range notation\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"will be replaced by range notation\")]\n impl<A: Int + ToPrimitive> Iterator for Range<A> {\n     type Item = A;\n \n@@ -2536,7 +2549,8 @@ impl<A: Int + ToPrimitive> Iterator for Range<A> {\n \n /// `Int` is required to ensure the range will be the same regardless of\n /// the direction it is consumed.\n-#[unstable = \"will be replaced by range notation\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"will be replaced by range notation\")]\n impl<A: Int + ToPrimitive> DoubleEndedIterator for Range<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n@@ -2551,23 +2565,26 @@ impl<A: Int + ToPrimitive> DoubleEndedIterator for Range<A> {\n \n /// An iterator over the range [start, stop]\n #[derive(Clone)]\n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n pub struct RangeInclusive<A> {\n     range: Range<A>,\n     done: bool,\n }\n \n /// Return an iterator over the range [start, stop]\n #[inline]\n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n pub fn range_inclusive<A: Int>(start: A, stop: A) -> RangeInclusive<A> {\n     RangeInclusive {\n         range: range(start, stop),\n         done: false,\n     }\n }\n \n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n     type Item = A;\n \n@@ -2602,7 +2619,8 @@ impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n     }\n }\n \n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n impl<A: Int + ToPrimitive> DoubleEndedIterator for RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n@@ -2621,7 +2639,8 @@ impl<A: Int + ToPrimitive> DoubleEndedIterator for RangeInclusive<A> {\n \n /// An iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n #[derive(Clone)]\n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n pub struct RangeStep<A> {\n     state: A,\n     stop: A,\n@@ -2631,13 +2650,15 @@ pub struct RangeStep<A> {\n \n /// Return an iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n #[inline]\n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n pub fn range_step<A: Int>(start: A, stop: A, step: A) -> RangeStep<A> {\n     let rev = step < Int::zero();\n     RangeStep{state: start, stop: stop, step: step, rev: rev}\n }\n \n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n impl<A: Int> Iterator for RangeStep<A> {\n     type Item = A;\n \n@@ -2658,7 +2679,8 @@ impl<A: Int> Iterator for RangeStep<A> {\n \n /// An iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n #[derive(Clone)]\n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n pub struct RangeStepInclusive<A> {\n     state: A,\n     stop: A,\n@@ -2669,7 +2691,8 @@ pub struct RangeStepInclusive<A> {\n \n /// Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n #[inline]\n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepInclusive<A> {\n     let rev = step < Int::zero();\n     RangeStepInclusive {\n@@ -2681,7 +2704,8 @@ pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepIncl\n     }\n }\n \n-#[unstable = \"likely to be replaced by range notation and adapters\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"likely to be replaced by range notation and adapters\")]\n impl<A: Int> Iterator for RangeStepInclusive<A> {\n     type Item = A;\n \n@@ -2706,7 +2730,8 @@ impl<A: Int> Iterator for RangeStepInclusive<A> {\n /// directions. The `steps_between` function provides a way to\n /// compare two Step objects (it could be provided using `step()` and `Ord`,\n /// but the implementation would be so inefficient as to be useless).\n-#[unstable = \"design of range notation/iteration is in flux\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"design of range notation/iteration is in flux\")]\n pub trait Step: Ord {\n     /// Change self to the next object.\n     fn step(&mut self);\n@@ -2721,7 +2746,7 @@ pub trait Step: Ord {\n \n macro_rules! step_impl {\n     ($($t:ty)*) => ($(\n-        #[unstable = \"Trait is unstable.\"]\n+        #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"Trait is unstable.\")]\n         impl Step for $t {\n             #[inline]\n             fn step(&mut self) { *self += 1; }\n@@ -2738,7 +2763,7 @@ macro_rules! step_impl {\n \n macro_rules! step_impl_no_between {\n     ($($t:ty)*) => ($(\n-        #[unstable = \"Trait is unstable.\"]\n+        #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"Trait is unstable.\")]\n         impl Step for $t {\n             #[inline]\n             fn step(&mut self) { *self += 1; }\n@@ -2761,12 +2786,12 @@ step_impl_no_between!(u64 i64);\n \n /// An iterator that repeats an element endlessly\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Repeat<A> {\n     element: A\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A: Clone> Iterator for Repeat<A> {\n     type Item = A;\n \n@@ -2776,13 +2801,13 @@ impl<A: Clone> Iterator for Repeat<A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { (uint::MAX, None) }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.idx(0) }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is experimental\")]\n impl<A: Clone> RandomAccessIterator for Repeat<A> {\n     #[inline]\n     fn indexable(&self) -> uint { uint::MAX }\n@@ -2794,12 +2819,12 @@ type IterateState<T, F> = (F, Option<T>, bool);\n \n /// An iterator that repeatedly applies a given function, starting\n /// from a given seed value.\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub type Iterate<T, F> = Unfold<T, IterateState<T, F>, fn(&mut IterateState<T, F>) -> Option<T>>;\n \n /// Create a new iterator that produces an infinite sequence of\n /// repeated applications of the given function `f`.\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where\n     T: Clone,\n     F: FnMut(T) -> T,\n@@ -2830,7 +2855,7 @@ pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where\n \n /// Create a new iterator that endlessly repeats the element `elt`.\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n     Repeat{element: elt}\n }\n@@ -2842,7 +2867,7 @@ pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n ///\n /// If two sequences are equal up until the point where one ends,\n /// the shorter sequence compares less.\n-#[unstable = \"needs review and revision\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"needs review and revision\")]\n pub mod order {\n     use cmp;\n     use cmp::{Eq, Ord, PartialOrd, PartialEq};"}, {"sha": "ecb4af218cd129885c7392640018818164dc037e", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -48,7 +48,7 @@\n // separate crate, libcoretest, to avoid bizarre issues.\n \n #![crate_name = \"core\"]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\","}, {"sha": "65a17c91c871d0c5e1b56d1fe3a9c3298917b184", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -52,7 +52,7 @@ macro_rules! panic {\n /// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n /// ```\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n macro_rules! assert {\n     ($cond:expr) => (\n         if !$cond {\n@@ -79,7 +79,7 @@ macro_rules! assert {\n /// assert_eq!(a, b);\n /// ```\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n macro_rules! assert_eq {\n     ($left:expr , $right:expr) => ({\n         match (&($left), &($right)) {\n@@ -123,7 +123,7 @@ macro_rules! assert_eq {\n /// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n /// ```\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n macro_rules! debug_assert {\n     ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })\n }\n@@ -185,7 +185,7 @@ macro_rules! write {\n /// Equivalent to the `write!` macro, except that a newline is appended after\n /// the message is written.\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n macro_rules! writeln {\n     ($dst:expr, $fmt:expr) => (\n         write!($dst, concat!($fmt, \"\\n\"))\n@@ -235,7 +235,8 @@ macro_rules! writeln {\n /// }\n /// ```\n #[macro_export]\n-#[unstable = \"relationship with panic is unclear\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"relationship with panic is unclear\")]\n macro_rules! unreachable {\n     () => ({\n         panic!(\"internal error: entered unreachable code\")\n@@ -251,7 +252,8 @@ macro_rules! unreachable {\n /// A standardised placeholder for marking unfinished code. It panics with the\n /// message `\"not yet implemented\"` when executed.\n #[macro_export]\n-#[unstable = \"relationship with panic is unclear\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"relationship with panic is unclear\")]\n macro_rules! unimplemented {\n     () => (panic!(\"not yet implemented\"))\n }"}, {"sha": "4c9384b266aee4aed6b4a899f798146a7337c600", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -23,19 +23,20 @@\n //! implemented using unsafe code. In that case, you may want to embed\n //! some of the marker types below into your type.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use clone::Clone;\n \n /// Types able to be transferred across task boundaries.\n-#[unstable = \"will be overhauled with new lifetime rules; see RFC 458\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"will be overhauled with new lifetime rules; see RFC 458\")]\n #[lang=\"send\"]\n pub unsafe trait Send: 'static {\n     // empty.\n }\n \n /// Types with a constant size known at compile-time.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #[lang=\"sized\"]\n pub trait Sized {\n     // Empty.\n@@ -140,7 +141,7 @@ pub trait Sized {\n /// to consider though: if you think your type may _not_ be able to implement `Copy` in the future,\n /// then it might be prudent to not implement `Copy`. This is because removing `Copy` is a breaking\n /// change: that second example would fail to compile if we made `Foo` non-`Copy`.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #[lang=\"copy\"]\n pub trait Copy {\n     // Empty.\n@@ -191,7 +192,8 @@ pub trait Copy {\n /// around the value(s) which can be mutated when behind a `&`\n /// reference; not doing this is undefined behaviour (for example,\n /// `transmute`-ing from `&T` to `&mut T` is illegal).\n-#[unstable = \"will be overhauled with new lifetime rules; see RFC 458\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"will be overhauled with new lifetime rules; see RFC 458\")]\n #[lang=\"sync\"]\n pub unsafe trait Sync {\n     // Empty\n@@ -235,7 +237,8 @@ pub unsafe trait Sync {\n /// `S<T>` is a subtype of `S<U>` if `T` is a subtype of `U`\n /// (for example, `S<&'static int>` is a subtype of `S<&'a int>`\n /// for some lifetime `'a`, but not the other way around).\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"covariant_type\"]\n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n pub struct CovariantType<T: ?Sized>;\n@@ -284,7 +287,8 @@ impl<T: ?Sized> Clone for CovariantType<T> {\n /// subtype of `S<U>` if `U` is a subtype of `T`; given that the\n /// function requires arguments of type `T`, it must also accept\n /// arguments of type `U`, hence such a conversion is safe.\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"contravariant_type\"]\n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n pub struct ContravariantType<T: ?Sized>;\n@@ -314,14 +318,17 @@ impl<T: ?Sized> Clone for ContravariantType<T> {\n /// The type system would infer that `value` is only read here and\n /// never written, but in fact `Cell` uses unsafe code to achieve\n /// interior mutability.\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"invariant_type\"]\n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n pub struct InvariantType<T: ?Sized>;\n \n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"likely to change with new variance strategy\")]\n impl<T: ?Sized> Copy for InvariantType<T> {}\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"likely to change with new variance strategy\")]\n impl<T: ?Sized> Clone for InvariantType<T> {\n     fn clone(&self) -> InvariantType<T> { *self }\n }\n@@ -342,7 +349,8 @@ impl<T: ?Sized> Clone for InvariantType<T> {\n ///\n /// For more information about variance, refer to this Wikipedia\n /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"covariant_lifetime\"]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub struct CovariantLifetime<'a>;\n@@ -359,7 +367,8 @@ pub struct CovariantLifetime<'a>;\n ///\n /// For more information about variance, refer to this Wikipedia\n /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"contravariant_lifetime\"]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub struct ContravariantLifetime<'a>;\n@@ -371,7 +380,8 @@ pub struct ContravariantLifetime<'a>;\n /// pointer that is actually a pointer into memory with lifetime `'a`,\n /// and this pointer is itself stored in an inherently mutable\n /// location (such as a `Cell`).\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"invariant_lifetime\"]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub struct InvariantLifetime<'a>;\n@@ -380,7 +390,8 @@ pub struct InvariantLifetime<'a>;\n /// be safely sent between tasks, even if it is owned. This is\n /// typically embedded in other types, such as `Gc`, to ensure that\n /// their instances remain thread-local.\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"no_send_bound\"]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n #[cfg(stage0)] // NOTE remove impl after next snapshot\n@@ -389,7 +400,8 @@ pub struct NoSend;\n /// A type which is considered \"not POD\", meaning that it is not\n /// implicitly copyable. This is typically embedded in other types to\n /// ensure that they are never copied, even if they lack a destructor.\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"no_copy_bound\"]\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n #[allow(missing_copy_implementations)]\n@@ -398,15 +410,17 @@ pub struct NoCopy;\n /// A type which is considered \"not sync\", meaning that\n /// its contents are not threadsafe, hence they cannot be\n /// shared between tasks.\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"no_sync_bound\"]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n #[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct NoSync;\n \n /// A type which is considered managed by the GC. This is typically\n /// embedded in other types.\n-#[unstable = \"likely to change with new variance strategy\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"likely to change with new variance strategy\")]\n #[lang=\"managed_bound\"]\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n #[allow(missing_copy_implementations)]"}, {"sha": "b28df93b359aeec7f82ab531a173f98e8bb5e158", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -13,13 +13,13 @@\n //! This module contains functions for querying the size and alignment of\n //! types, initializing and manipulating memory.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use marker::Sized;\n use intrinsics;\n use ptr;\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub use intrinsics::transmute;\n \n /// Moves a thing into the void.\n@@ -29,7 +29,7 @@ pub use intrinsics::transmute;\n ///\n /// This function is the unsafe version of the `drop` function because it does\n /// not run any destructors.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub use intrinsics::forget;\n \n /// Returns the size of a type in bytes.\n@@ -42,7 +42,7 @@ pub use intrinsics::forget;\n /// assert_eq!(4, mem::size_of::<i32>());\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub fn size_of<T>() -> uint {\n     unsafe { intrinsics::size_of::<T>() }\n }\n@@ -57,7 +57,7 @@ pub fn size_of<T>() -> uint {\n /// assert_eq!(4, mem::size_of_val(&5i32));\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub fn size_of_val<T>(_val: &T) -> uint {\n     size_of::<T>()\n }\n@@ -74,7 +74,7 @@ pub fn size_of_val<T>(_val: &T) -> uint {\n /// assert_eq!(4, mem::min_align_of::<i32>());\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub fn min_align_of<T>() -> uint {\n     unsafe { intrinsics::min_align_of::<T>() }\n }\n@@ -89,7 +89,7 @@ pub fn min_align_of<T>() -> uint {\n /// assert_eq!(4, mem::min_align_of_val(&5i32));\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub fn min_align_of_val<T>(_val: &T) -> uint {\n     min_align_of::<T>()\n }\n@@ -107,7 +107,7 @@ pub fn min_align_of_val<T>(_val: &T) -> uint {\n /// assert_eq!(4, mem::align_of::<i32>());\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub fn align_of<T>() -> uint {\n     // We use the preferred alignment as the default alignment for a type. This\n     // appears to be what clang migrated towards as well:\n@@ -129,7 +129,7 @@ pub fn align_of<T>() -> uint {\n /// assert_eq!(4, mem::align_of_val(&5i32));\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub fn align_of_val<T>(_val: &T) -> uint {\n     align_of::<T>()\n }\n@@ -153,7 +153,7 @@ pub fn align_of_val<T>(_val: &T) -> uint {\n /// let x: int = unsafe { mem::zeroed() };\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub unsafe fn zeroed<T>() -> T {\n     intrinsics::init()\n }\n@@ -174,7 +174,7 @@ pub unsafe fn zeroed<T>() -> T {\n /// let x: int = unsafe { mem::uninitialized() };\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::uninit()\n }\n@@ -196,7 +196,7 @@ pub unsafe fn uninitialized<T>() -> T {\n /// assert_eq!(5i, *y);\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub fn swap<T>(x: &mut T, y: &mut T) {\n     unsafe {\n         // Give ourselves some scratch space to work with\n@@ -261,7 +261,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n /// }\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n     swap(dest, &mut src);\n     src\n@@ -288,7 +288,7 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// println!(\"{}\", *borrow);\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub fn drop<T>(_x: T) { }\n \n /// Interprets `src` as `&U`, and then reads `src` without moving the contained value.\n@@ -311,24 +311,26 @@ pub fn drop<T>(_x: T) { }\n /// assert_eq!(1u, one);\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     ptr::read(src as *const T as *const U)\n }\n \n /// Transforms lifetime of the second pointer to match the first.\n #[inline]\n-#[unstable = \"this function may be removed in the future due to its \\\n-              questionable utility\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"this function may be removed in the future due to its \\\n+                     questionable utility\")]\n pub unsafe fn copy_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a S,\n                                                         ptr: &T) -> &'a T {\n     transmute(ptr)\n }\n \n /// Transforms lifetime of the second mutable pointer to match the first.\n #[inline]\n-#[unstable = \"this function may be removed in the future due to its \\\n-              questionable utility\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"this function may be removed in the future due to its \\\n+                     questionable utility\")]\n pub unsafe fn copy_mut_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a mut S,\n                                                             ptr: &mut T)\n                                                             -> &'a mut T {"}, {"sha": "111d2f074b11f73dcc1c6d3677fb71e7126f6b6e", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -32,7 +32,7 @@ unsafe impl Zeroable for u64 {}\n /// NULL or 0 that might allow certain optimizations.\n #[lang=\"non_zero\"]\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Show)]\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub struct NonZero<T: Zeroable>(T);\n \n impl<T: Zeroable> NonZero<T> {"}, {"sha": "9aecd761e2a4493a41f3899d8e0cabe11ffaec24", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -14,54 +14,55 @@\n // FIXME: MIN_VALUE and MAX_VALUE literals are parsed as -inf and inf #14353\n #![allow(overflowing_literals)]\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use intrinsics;\n use mem;\n use num::Float;\n use num::FpCategory as Fp;\n use option::Option;\n \n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"pending integer conventions\")]\n pub const RADIX: uint = 2u;\n \n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"pending integer conventions\")]\n pub const MANTISSA_DIGITS: uint = 24u;\n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"pending integer conventions\")]\n pub const DIGITS: uint = 6u;\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const EPSILON: f32 = 1.19209290e-07_f32;\n \n /// Smallest finite f32 value\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const MIN_VALUE: f32 = -3.40282347e+38_f32;\n /// Smallest positive, normalized f32 value\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const MIN_POS_VALUE: f32 = 1.17549435e-38_f32;\n /// Largest finite f32 value\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const MAX_VALUE: f32 = 3.40282347e+38_f32;\n \n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"pending integer conventions\")]\n pub const MIN_EXP: int = -125;\n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"pending integer conventions\")]\n pub const MAX_EXP: int = 128;\n \n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"pending integer conventions\")]\n pub const MIN_10_EXP: int = -37;\n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"pending integer conventions\")]\n pub const MAX_10_EXP: int = 38;\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const NAN: f32 = 0.0_f32/0.0_f32;\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const INFINITY: f32 = 1.0_f32/0.0_f32;\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const NEG_INFINITY: f32 = -1.0_f32/0.0_f32;\n \n /// Various useful constants.\n-#[unstable = \"naming scheme needs to be revisited\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"naming scheme needs to be revisited\")]\n pub mod consts {\n     // FIXME: replace with mathematical constants from cmath.\n \n@@ -117,7 +118,7 @@ pub mod consts {\n     pub const LN_10: f32 = 2.30258509299404568401799145468436421_f32;\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is unstable\")]\n impl Float for f32 {\n     #[inline]\n     fn nan() -> f32 { NAN }\n@@ -177,43 +178,43 @@ impl Float for f32 {\n     }\n \n     #[inline]\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     fn mantissa_digits(_: Option<f32>) -> uint { MANTISSA_DIGITS }\n \n     #[inline]\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     fn digits(_: Option<f32>) -> uint { DIGITS }\n \n     #[inline]\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     fn epsilon() -> f32 { EPSILON }\n \n     #[inline]\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     fn min_exp(_: Option<f32>) -> int { MIN_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     fn max_exp(_: Option<f32>) -> int { MAX_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     fn min_10_exp(_: Option<f32>) -> int { MIN_10_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     fn max_10_exp(_: Option<f32>) -> int { MAX_10_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     fn min_value() -> f32 { MIN_VALUE }\n \n     #[inline]\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     fn min_pos_value(_: Option<f32>) -> f32 { MIN_POS_VALUE }\n \n     #[inline]\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     fn max_value() -> f32 { MAX_VALUE }\n \n     /// Returns the mantissa, exponent and sign as integers."}, {"sha": "1961b6cb0a81e79696dfc37a37c31c5de8e2ea28", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -14,7 +14,7 @@\n // FIXME: MIN_VALUE and MAX_VALUE literals are parsed as -inf and inf #14353\n #![allow(overflowing_literals)]\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use intrinsics;\n use mem;\n@@ -26,45 +26,46 @@ use option::Option;\n // constants are implemented in favour of referencing the respective\n // members of `Bounded` and `Float`.\n \n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"pending integer conventions\")]\n pub const RADIX: uint = 2u;\n \n pub const MANTISSA_DIGITS: uint = 53u;\n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"pending integer conventions\")]\n pub const DIGITS: uint = 15u;\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const EPSILON: f64 = 2.2204460492503131e-16_f64;\n \n /// Smallest finite f64 value\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const MIN_VALUE: f64 = -1.7976931348623157e+308_f64;\n /// Smallest positive, normalized f64 value\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const MIN_POS_VALUE: f64 = 2.2250738585072014e-308_f64;\n /// Largest finite f64 value\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const MAX_VALUE: f64 = 1.7976931348623157e+308_f64;\n \n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"pending integer conventions\")]\n pub const MIN_EXP: int = -1021;\n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"pending integer conventions\")]\n pub const MAX_EXP: int = 1024;\n \n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"pending integer conventions\")]\n pub const MIN_10_EXP: int = -307;\n-#[unstable = \"pending integer conventions\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"pending integer conventions\")]\n pub const MAX_10_EXP: int = 308;\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const NAN: f64 = 0.0_f64/0.0_f64;\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const INFINITY: f64 = 1.0_f64/0.0_f64;\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const NEG_INFINITY: f64 = -1.0_f64/0.0_f64;\n \n /// Various useful constants.\n-#[unstable = \"naming scheme needs to be revisited\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"naming scheme needs to be revisited\")]\n pub mod consts {\n     // FIXME: replace with mathematical constants from cmath.\n \n@@ -124,7 +125,7 @@ pub mod consts {\n     pub const LN_10: f64 = 2.30258509299404568401799145468436421_f64;\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is unstable\")]\n impl Float for f64 {\n     #[inline]\n     fn nan() -> f64 { NAN }\n@@ -184,43 +185,43 @@ impl Float for f64 {\n     }\n \n     #[inline]\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     fn mantissa_digits(_: Option<f64>) -> uint { MANTISSA_DIGITS }\n \n     #[inline]\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     fn digits(_: Option<f64>) -> uint { DIGITS }\n \n     #[inline]\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     fn epsilon() -> f64 { EPSILON }\n \n     #[inline]\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     fn min_exp(_: Option<f64>) -> int { MIN_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     fn max_exp(_: Option<f64>) -> int { MAX_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     fn min_10_exp(_: Option<f64>) -> int { MIN_10_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     fn max_10_exp(_: Option<f64>) -> int { MAX_10_EXP }\n \n     #[inline]\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     fn min_value() -> f64 { MIN_VALUE }\n \n     #[inline]\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     fn min_pos_value(_: Option<f64>) -> f64 { MIN_POS_VALUE }\n \n     #[inline]\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     fn max_value() -> f64 { MAX_VALUE }\n \n     /// Returns the mantissa, exponent and sign as integers."}, {"sha": "53d87a65666dca2ae962c90e12be4c0589a9a4aa", "filename": "src/libcore/num/i16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi16.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 16-bits integers (`i16` type)\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![doc(primitive = \"i16\")]\n \n int_module! { i16, 16 }"}, {"sha": "71203428225b63161835a40f80e576f5ed1fd95d", "filename": "src/libcore/num/i32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi32.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 32-bits integers (`i32` type)\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![doc(primitive = \"i32\")]\n \n int_module! { i32, 32 }"}, {"sha": "7d485317beb75486765501c8c4ce347c2ef98117", "filename": "src/libcore/num/i64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi64.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 64-bits integers (`i64` type)\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![doc(primitive = \"i64\")]\n \n int_module! { i64, 64 }"}, {"sha": "cc2a2b76a693de73925784f915b3853ae0642c79", "filename": "src/libcore/num/i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi8.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 8-bits integers (`i8` type)\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![doc(primitive = \"i8\")]\n \n int_module! { i8, 8 }"}, {"sha": "4b4e408ddd765958c5e37e7ee352f1f73c033fdc", "filename": "src/libcore/num/int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -14,7 +14,7 @@\n //! alpha cycle along with the development of clearer conventions\n //! around integer types.\n \n-#![deprecated = \"replaced by isize\"]\n+#![deprecated(feature = \"oldstuff\", since = \"1.0.0\", reason = \"replaced by isize\")]\n \n #[cfg(target_pointer_width = \"32\")] int_module! { int, 32 }\n #[cfg(target_pointer_width = \"64\")] int_module! { int, 64 }"}, {"sha": "2f0f64438777f0f745b7cfcc14d8ce6d1b809b03", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -14,21 +14,21 @@ macro_rules! int_module { ($T:ty, $bits:expr) => (\n \n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `mem::size_of` function.\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub const BITS : uint = $bits;\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `mem::size_of` function.\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub const BYTES : uint = ($bits / 8);\n \n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `Bounded::min_value` function.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const MIN: $T = (-1 as $T) << (BITS - 1);\n // FIXME(#9837): Compute MIN like this so the high bits that shouldn't exist are 0.\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `Bounded::max_value` function.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const MAX: $T = !MIN;\n \n ) }"}, {"sha": "2f5db884174192edfbac0720bd19af293431fd30", "filename": "src/libcore/num/isize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fisize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fisize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fisize.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -14,7 +14,7 @@\n //! new type will gradually take place over the alpha cycle along with\n //! the development of clearer conventions around integer types.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![doc(primitive = \"isize\")]\n \n #[cfg(target_pointer_width = \"32\")]"}, {"sha": "5b0b6f1b046019d3b09b893ed4261f926f37f99a", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 103, "deletions": 75, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -12,7 +12,7 @@\n \n //! Numeric traits and functions for the built-in numeric types.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n use char::CharExt;\n@@ -30,7 +30,7 @@ use option::Option::{Some, None};\n use str::{FromStr, StrExt};\n \n /// A built-in signed or unsigned integer.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait Int\n     : Copy + Clone\n     + NumCast\n@@ -50,22 +50,26 @@ pub trait Int\n {\n     /// Returns the `0` value of this integer type.\n     // FIXME (#5527): Should be an associated constant\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"unsure about its place in the world\")]\n     fn zero() -> Self;\n \n     /// Returns the `1` value of this integer type.\n     // FIXME (#5527): Should be an associated constant\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"unsure about its place in the world\")]\n     fn one() -> Self;\n \n     /// Returns the smallest value that can be represented by this integer type.\n     // FIXME (#5527): Should be and associated constant\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"unsure about its place in the world\")]\n     fn min_value() -> Self;\n \n     /// Returns the largest value that can be represented by this integer type.\n     // FIXME (#5527): Should be and associated constant\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"unsure about its place in the world\")]\n     fn max_value() -> Self;\n \n     /// Returns the number of ones in the binary representation of `self`.\n@@ -79,7 +83,8 @@ pub trait Int\n     ///\n     /// assert_eq!(n.count_ones(), 3);\n     /// ```\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending integer conventions\")]\n     fn count_ones(self) -> uint;\n \n     /// Returns the number of zeros in the binary representation of `self`.\n@@ -93,7 +98,8 @@ pub trait Int\n     ///\n     /// assert_eq!(n.count_zeros(), 5);\n     /// ```\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending integer conventions\")]\n     #[inline]\n     fn count_zeros(self) -> uint {\n         (!self).count_ones()\n@@ -111,7 +117,8 @@ pub trait Int\n     ///\n     /// assert_eq!(n.leading_zeros(), 10);\n     /// ```\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending integer conventions\")]\n     fn leading_zeros(self) -> uint;\n \n     /// Returns the number of trailing zeros in the binary representation\n@@ -126,7 +133,8 @@ pub trait Int\n     ///\n     /// assert_eq!(n.trailing_zeros(), 3);\n     /// ```\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending integer conventions\")]\n     fn trailing_zeros(self) -> uint;\n \n     /// Shifts the bits to the left by a specified amount amount, `n`, wrapping\n@@ -142,7 +150,8 @@ pub trait Int\n     ///\n     /// assert_eq!(n.rotate_left(12), m);\n     /// ```\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending integer conventions\")]\n     fn rotate_left(self, n: uint) -> Self;\n \n     /// Shifts the bits to the right by a specified amount amount, `n`, wrapping\n@@ -158,7 +167,8 @@ pub trait Int\n     ///\n     /// assert_eq!(n.rotate_right(12), m);\n     /// ```\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending integer conventions\")]\n     fn rotate_right(self, n: uint) -> Self;\n \n     /// Reverses the byte order of the integer.\n@@ -173,7 +183,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.swap_bytes(), m);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn swap_bytes(self) -> Self;\n \n     /// Convert an integer from big endian to the target's endianness.\n@@ -193,7 +203,7 @@ pub trait Int\n     ///     assert_eq!(Int::from_be(n), n.swap_bytes())\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     #[inline]\n     fn from_be(x: Self) -> Self {\n         if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n@@ -216,7 +226,7 @@ pub trait Int\n     ///     assert_eq!(Int::from_le(n), n.swap_bytes())\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     #[inline]\n     fn from_le(x: Self) -> Self {\n         if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n@@ -239,7 +249,7 @@ pub trait Int\n     ///     assert_eq!(n.to_be(), n.swap_bytes())\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     #[inline]\n     fn to_be(self) -> Self { // or not to be?\n         if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n@@ -262,7 +272,7 @@ pub trait Int\n     ///     assert_eq!(n.to_le(), n.swap_bytes())\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     #[inline]\n     fn to_le(self) -> Self {\n         if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n@@ -279,7 +289,7 @@ pub trait Int\n     /// assert_eq!(5u16.checked_add(65530), Some(65535));\n     /// assert_eq!(6u16.checked_add(65530), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn checked_add(self, other: Self) -> Option<Self>;\n \n     /// Checked integer subtraction. Computes `self - other`, returning `None`\n@@ -293,7 +303,7 @@ pub trait Int\n     /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n     /// assert_eq!((-128i8).checked_sub(1), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn checked_sub(self, other: Self) -> Option<Self>;\n \n     /// Checked integer multiplication. Computes `self * other`, returning\n@@ -307,7 +317,7 @@ pub trait Int\n     /// assert_eq!(5u8.checked_mul(51), Some(255));\n     /// assert_eq!(5u8.checked_mul(52), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn checked_mul(self, other: Self) -> Option<Self>;\n \n     /// Checked integer division. Computes `self / other`, returning `None` if\n@@ -322,12 +332,12 @@ pub trait Int\n     /// assert_eq!((-128i8).checked_div(-1), None);\n     /// assert_eq!((1i8).checked_div(0), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn checked_div(self, other: Self) -> Option<Self>;\n \n     /// Saturating integer addition. Computes `self + other`, saturating at\n     /// the numeric bounds instead of overflowing.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     #[inline]\n     fn saturating_add(self, other: Self) -> Self {\n         match self.checked_add(other) {\n@@ -339,7 +349,7 @@ pub trait Int\n \n     /// Saturating integer subtraction. Computes `self - other`, saturating at\n     /// the numeric bounds instead of overflowing.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     #[inline]\n     fn saturating_sub(self, other: Self) -> Self {\n         match self.checked_sub(other) {\n@@ -358,7 +368,8 @@ pub trait Int\n     ///\n     /// assert_eq!(2i.pow(4), 16);\n     /// ```\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending integer conventions\")]\n     #[inline]\n     fn pow(self, mut exp: uint) -> Self {\n         let mut base = self;\n@@ -390,7 +401,7 @@ macro_rules! uint_impl {\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl Int for $T {\n             #[inline]\n             fn zero() -> $T { 0 }\n@@ -521,7 +532,7 @@ macro_rules! int_impl {\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl Int for $T {\n             #[inline]\n             fn zero() -> $T { 0 }\n@@ -614,38 +625,38 @@ int_impl! { int = i64, u64, 64,\n     intrinsics::i64_mul_with_overflow }\n \n /// A built-in two's complement integer.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait SignedInt\n     : Int\n     + Neg<Output=Self>\n {\n     /// Computes the absolute value of `self`. `Int::min_value()` will be\n     /// returned if the number is `Int::min_value()`.\n-    #[unstable = \"overflow in debug builds?\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"overflow in debug builds?\")]\n     fn abs(self) -> Self;\n \n     /// Returns a number representing sign of `self`.\n     ///\n     /// - `0` if the number is zero\n     /// - `1` if the number is positive\n     /// - `-1` if the number is negative\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn signum(self) -> Self;\n \n     /// Returns `true` if `self` is positive and `false` if the number\n     /// is zero or negative.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn is_positive(self) -> bool;\n \n     /// Returns `true` if `self` is negative and `false` if the number\n     /// is zero or positive.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn is_negative(self) -> bool;\n }\n \n macro_rules! signed_int_impl {\n     ($T:ty) => {\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl SignedInt for $T {\n             #[inline]\n             fn abs(self) -> $T {\n@@ -677,18 +688,18 @@ signed_int_impl! { i64 }\n signed_int_impl! { int }\n \n /// A built-in unsigned integer.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait UnsignedInt: Int {\n     /// Returns `true` iff `self == 2^k` for some `k`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     #[inline]\n     fn is_power_of_two(self) -> bool {\n         (self - Int::one()) & self == Int::zero() && !(self == Int::zero())\n     }\n \n     /// Returns the smallest power of two greater than or equal to `self`.\n     /// Unspecified behavior on overflow.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     #[inline]\n     fn next_power_of_two(self) -> Self {\n         let bits = size_of::<Self>() * 8;\n@@ -699,7 +710,7 @@ pub trait UnsignedInt: Int {\n     /// Returns the smallest power of two greater than or equal to `n`. If the\n     /// next power of two is greater than the type's maximum value, `None` is\n     /// returned, otherwise the power of two is wrapped in `Some`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn checked_next_power_of_two(self) -> Option<Self> {\n         let npot = self.next_power_of_two();\n         if npot >= self {\n@@ -710,23 +721,23 @@ pub trait UnsignedInt: Int {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl UnsignedInt for uint {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl UnsignedInt for u8 {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl UnsignedInt for u16 {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl UnsignedInt for u32 {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl UnsignedInt for u64 {}\n \n /// A generic trait for converting a value to a number.\n-#[unstable = \"trait is likely to be removed\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is likely to be removed\")]\n pub trait ToPrimitive {\n     /// Converts the value of `self` to an `int`.\n     #[inline]\n@@ -991,7 +1002,7 @@ impl_to_primitive_float! { f32 }\n impl_to_primitive_float! { f64 }\n \n /// A generic trait for converting a number to a value.\n-#[unstable = \"trait is likely to be removed\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is likely to be removed\")]\n pub trait FromPrimitive : ::marker::Sized {\n     /// Convert an `int` to return an optional value of this type. If the\n     /// value cannot be represented by this value, the `None` is returned.\n@@ -1073,73 +1084,73 @@ pub trait FromPrimitive : ::marker::Sized {\n }\n \n /// A utility function that just calls `FromPrimitive::from_int`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"likely to be removed\")]\n pub fn from_int<A: FromPrimitive>(n: int) -> Option<A> {\n     FromPrimitive::from_int(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_i8`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"likely to be removed\")]\n pub fn from_i8<A: FromPrimitive>(n: i8) -> Option<A> {\n     FromPrimitive::from_i8(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_i16`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"likely to be removed\")]\n pub fn from_i16<A: FromPrimitive>(n: i16) -> Option<A> {\n     FromPrimitive::from_i16(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_i32`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"likely to be removed\")]\n pub fn from_i32<A: FromPrimitive>(n: i32) -> Option<A> {\n     FromPrimitive::from_i32(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_i64`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"likely to be removed\")]\n pub fn from_i64<A: FromPrimitive>(n: i64) -> Option<A> {\n     FromPrimitive::from_i64(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_uint`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"likely to be removed\")]\n pub fn from_uint<A: FromPrimitive>(n: uint) -> Option<A> {\n     FromPrimitive::from_uint(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_u8`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"likely to be removed\")]\n pub fn from_u8<A: FromPrimitive>(n: u8) -> Option<A> {\n     FromPrimitive::from_u8(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_u16`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"likely to be removed\")]\n pub fn from_u16<A: FromPrimitive>(n: u16) -> Option<A> {\n     FromPrimitive::from_u16(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_u32`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"likely to be removed\")]\n pub fn from_u32<A: FromPrimitive>(n: u32) -> Option<A> {\n     FromPrimitive::from_u32(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_u64`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"likely to be removed\")]\n pub fn from_u64<A: FromPrimitive>(n: u64) -> Option<A> {\n     FromPrimitive::from_u64(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_f32`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"likely to be removed\")]\n pub fn from_f32<A: FromPrimitive>(n: f32) -> Option<A> {\n     FromPrimitive::from_f32(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_f64`.\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"likely to be removed\")]\n pub fn from_f64<A: FromPrimitive>(n: f64) -> Option<A> {\n     FromPrimitive::from_f64(n)\n }\n@@ -1190,13 +1201,13 @@ impl_from_primitive! { f64, to_f64 }\n /// ```\n ///\n #[inline]\n-#[unstable = \"likely to be removed\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"likely to be removed\")]\n pub fn cast<T: NumCast,U: NumCast>(n: T) -> Option<U> {\n     NumCast::from(n)\n }\n \n /// An interface for casting between machine scalars.\n-#[unstable = \"trait is likely to be removed\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is likely to be removed\")]\n pub trait NumCast: ToPrimitive {\n     /// Creates a number from another value that can be converted into a primitive via the\n     /// `ToPrimitive` trait.\n@@ -1231,7 +1242,7 @@ impl_num_cast! { f64,   to_f64 }\n \n /// Used for representing the classification of floating point numbers\n #[derive(Copy, PartialEq, Show)]\n-#[unstable = \"may be renamed\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"may be renamed\")]\n pub enum FpCategory {\n     /// \"Not a Number\", often obtained by dividing by zero\n     Nan,\n@@ -1251,7 +1262,8 @@ pub enum FpCategory {\n //\n // FIXME(#8888): Several of these functions have a parameter named\n //               `unused_self`. Removing it requires #8888 to be fixed.\n-#[unstable = \"distribution of methods between core/std is unclear\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"distribution of methods between core/std is unclear\")]\n pub trait Float\n     : Copy + Clone\n     + NumCast\n@@ -1280,34 +1292,46 @@ pub trait Float\n     // FIXME (#5527): These should be associated constants\n \n     /// Returns the number of binary digits of mantissa that this type supports.\n-    #[deprecated = \"use `std::f32::MANTISSA_DIGITS` or `std::f64::MANTISSA_DIGITS` as appropriate\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\",\n+                 reason = \"use `std::f32::MANTISSA_DIGITS` or \\\n+                           `std::f64::MANTISSA_DIGITS` as appropriate\")]\n     fn mantissa_digits(unused_self: Option<Self>) -> uint;\n     /// Returns the number of base-10 digits of precision that this type supports.\n-    #[deprecated = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\",\n+                 reason = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\")]\n     fn digits(unused_self: Option<Self>) -> uint;\n     /// Returns the difference between 1.0 and the smallest representable number larger than 1.0.\n-    #[deprecated = \"use `std::f32::EPSILON` or `std::f64::EPSILON` as appropriate\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\",\n+                 reason = \"use `std::f32::EPSILON` or `std::f64::EPSILON` as appropriate\")]\n     fn epsilon() -> Self;\n     /// Returns the minimum binary exponent that this type can represent.\n-    #[deprecated = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\",\n+                 reason = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\")]\n     fn min_exp(unused_self: Option<Self>) -> int;\n     /// Returns the maximum binary exponent that this type can represent.\n-    #[deprecated = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\",\n+                 reason = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\")]\n     fn max_exp(unused_self: Option<Self>) -> int;\n     /// Returns the minimum base-10 exponent that this type can represent.\n-    #[deprecated = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\",\n+                 reason = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\")]\n     fn min_10_exp(unused_self: Option<Self>) -> int;\n     /// Returns the maximum base-10 exponent that this type can represent.\n-    #[deprecated = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\",\n+                 reason = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\")]\n     fn max_10_exp(unused_self: Option<Self>) -> int;\n     /// Returns the smallest finite value that this type can represent.\n-    #[deprecated = \"use `std::f32::MIN_VALUE` or `std::f64::MIN_VALUE` as appropriate\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\",\n+                 reason = \"use `std::f32::MIN_VALUE` or `std::f64::MIN_VALUE` as appropriate\")]\n     fn min_value() -> Self;\n     /// Returns the smallest normalized positive number that this type can represent.\n-    #[deprecated = \"use `std::f32::MIN_POS_VALUE` or `std::f64::MIN_POS_VALUE` as appropriate\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\",\n+                 reason = \"use `std::f32::MIN_POS_VALUE` or \\\n+                           `std::f64::MIN_POS_VALUE` as appropriate\")]\n     fn min_pos_value(unused_self: Option<Self>) -> Self;\n     /// Returns the largest finite value that this type can represent.\n-    #[deprecated = \"use `std::f32::MAX_VALUE` or `std::f64::MAX_VALUE` as appropriate\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\",\n+                 reason = \"use `std::f32::MAX_VALUE` or `std::f64::MAX_VALUE` as appropriate\")]\n     fn max_value() -> Self;\n \n     /// Returns true if this value is NaN and false otherwise.\n@@ -1394,20 +1418,21 @@ pub trait Float\n }\n \n /// A generic trait for converting a string with a radix (base) to a value\n-#[unstable = \"might need to return Result\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"might need to return Result\")]\n pub trait FromStrRadix {\n     fn from_str_radix(str: &str, radix: uint) -> Option<Self>;\n }\n \n /// A utility function that just calls FromStrRadix::from_str_radix.\n-#[unstable = \"might need to return Result\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"might need to return Result\")]\n pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> {\n     FromStrRadix::from_str_radix(str, radix)\n }\n \n macro_rules! from_str_radix_float_impl {\n     ($T:ty) => {\n-        #[unstable = \"might need to return Result\"]\n+        #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+                   reason = \"might need to return Result\")]\n         impl FromStr for $T {\n             /// Convert a string in base 10 to a float.\n             /// Accepts an optional decimal exponent.\n@@ -1440,7 +1465,8 @@ macro_rules! from_str_radix_float_impl {\n             }\n         }\n \n-        #[unstable = \"might need to return Result\"]\n+        #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+                   reason = \"might need to return Result\")]\n         impl FromStrRadix for $T {\n             /// Convert a string in a given base to a float.\n             ///\n@@ -1604,15 +1630,17 @@ from_str_radix_float_impl! { f64 }\n \n macro_rules! from_str_radix_int_impl {\n     ($T:ty) => {\n-        #[unstable = \"might need to return Result\"]\n+        #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+                   reason = \"might need to return Result\")]\n         impl FromStr for $T {\n             #[inline]\n             fn from_str(src: &str) -> Option<$T> {\n                 from_str_radix(src, 10)\n             }\n         }\n \n-        #[unstable = \"might need to return Result\"]\n+        #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+                   reason = \"might need to return Result\")]\n         impl FromStrRadix for $T {\n             fn from_str_radix(src: &str, radix: uint) -> Option<$T> {\n                 assert!(radix >= 2 && radix <= 36,"}, {"sha": "187c7c85d42bf0091065fbb34e7126230a87ff14", "filename": "src/libcore/num/u16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu16.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 16-bits integers (`u16` type)\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![doc(primitive = \"u16\")]\n \n uint_module! { u16, i16, 16 }"}, {"sha": "9a1afa64d27ad9dcda26355ffd634cc8564e8eff", "filename": "src/libcore/num/u32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu32.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 32-bits integers (`u32` type)\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![doc(primitive = \"u32\")]\n \n uint_module! { u32, i32, 32 }"}, {"sha": "390eb10825256049177ca3419b92a399f64221cb", "filename": "src/libcore/num/u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu64.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 64-bits integer (`u64` type)\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![doc(primitive = \"u64\")]\n \n uint_module! { u64, i64, 64 }"}, {"sha": "ecf9efbf3c88560c1d41dc5996dee3b0ec2ab738", "filename": "src/libcore/num/u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu8.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 8-bits integers (`u8` type)\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![doc(primitive = \"u8\")]\n \n uint_module! { u8, i8, 8 }"}, {"sha": "42f9c56c72561e01c1a96132b61ad529eb2f5593", "filename": "src/libcore/num/uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -14,6 +14,6 @@\n //! alpha cycle along with the development of clearer conventions\n //! around integer types.\n \n-#![deprecated = \"replaced by usize\"]\n+#![deprecated(feature = \"oldstuff\", since = \"1.0.0\", reason = \"replaced by usize\")]\n \n uint_module! { uint, int, ::int::BITS }"}, {"sha": "50c22d374c683539f14f38f05c480f2fdad2aa0b", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -12,14 +12,14 @@\n \n macro_rules! uint_module { ($T:ty, $T_SIGNED:ty, $bits:expr) => (\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub const BITS : uint = $bits;\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub const BYTES : uint = ($bits / 8);\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const MIN: $T = 0 as $T;\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const MAX: $T = 0 as $T - 1 as $T;\n \n ) }"}, {"sha": "4bcc21ccf512a3a42556d32dd1f1e674956474a3", "filename": "src/libcore/num/usize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fusize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fnum%2Fusize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fusize.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -14,7 +14,7 @@\n //! new type will gradually take place over the alpha cycle along with\n //! the development of clearer conventions around integer types.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![doc(primitive = \"usize\")]\n \n uint_module! { usize, isize, ::isize::BITS }"}, {"sha": "a490ad360207b114d2f12c3aad6a55c0ffce6023", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 88, "deletions": 81, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -67,7 +67,7 @@\n //! See the documentation for each trait for a minimum implementation that prints\n //! something to the screen.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use clone::Clone;\n use iter::{Step, Iterator,DoubleEndedIterator,ExactSizeIterator};\n@@ -97,18 +97,19 @@ use fmt;\n /// }\n /// ```\n #[lang=\"drop\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait Drop {\n     /// The `drop` method, called when the value goes out of scope.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn drop(&mut self);\n }\n \n // implements the unary operator \"op &T\"\n // based on \"op T\" where T is expected to be `Copy`able\n macro_rules! forward_ref_unop {\n     (impl $imp:ident, $method:ident for $t:ty) => {\n-        #[unstable = \"recently added, waiting for dust to settle\"]\n+        #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+                   reason = \"recently added, waiting for dust to settle\")]\n         impl<'a> $imp for &'a $t {\n             type Output = <$t as $imp>::Output;\n \n@@ -124,7 +125,8 @@ macro_rules! forward_ref_unop {\n // based on \"T op U\" where T and U are expected to be `Copy`able\n macro_rules! forward_ref_binop {\n     (impl $imp:ident, $method:ident for $t:ty, $u:ty) => {\n-        #[unstable = \"recently added, waiting for dust to settle\"]\n+        #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+                   reason = \"recently added, waiting for dust to settle\")]\n         impl<'a> $imp<$u> for &'a $t {\n             type Output = <$t as $imp<$u>>::Output;\n \n@@ -134,7 +136,8 @@ macro_rules! forward_ref_binop {\n             }\n         }\n \n-        #[unstable = \"recently added, waiting for dust to settle\"]\n+        #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+                   reason = \"recently added, waiting for dust to settle\")]\n         impl<'a> $imp<&'a $u> for $t {\n             type Output = <$t as $imp<$u>>::Output;\n \n@@ -144,7 +147,8 @@ macro_rules! forward_ref_binop {\n             }\n         }\n \n-        #[unstable = \"recently added, waiting for dust to settle\"]\n+        #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+                   reason = \"recently added, waiting for dust to settle\")]\n         impl<'a, 'b> $imp<&'a $u> for &'b $t {\n             type Output = <$t as $imp<$u>>::Output;\n \n@@ -185,19 +189,19 @@ macro_rules! forward_ref_binop {\n /// }\n /// ```\n #[lang=\"add\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait Add<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `+` operator\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn add(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! add_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl Add for $t {\n             type Output = $t;\n \n@@ -240,19 +244,19 @@ add_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"sub\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait Sub<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `-` operator\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn sub(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! sub_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl Sub for $t {\n             type Output = $t;\n \n@@ -295,19 +299,19 @@ sub_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"mul\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait Mul<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `*` operator\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn mul(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! mul_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl Mul for $t {\n             type Output = $t;\n \n@@ -350,19 +354,19 @@ mul_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"div\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait Div<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `/` operator\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn div(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! div_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl Div for $t {\n             type Output = $t;\n \n@@ -405,19 +409,19 @@ div_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"rem\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait Rem<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     type Output = Self;\n \n     /// The method for the `%` operator\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn rem(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! rem_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl Rem for $t {\n             type Output = $t;\n \n@@ -431,7 +435,7 @@ macro_rules! rem_impl {\n \n macro_rules! rem_float_impl {\n     ($t:ty, $fmod:ident) => {\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl Rem for $t {\n             type Output = $t;\n \n@@ -480,25 +484,25 @@ rem_float_impl! { f64, fmod }\n /// }\n /// ```\n #[lang=\"neg\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait Neg {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the unary `-` operator\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn neg(self) -> Self::Output;\n }\n \n macro_rules! neg_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl Neg for $t {\n-            #[stable]\n+            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n             type Output = $t;\n \n             #[inline]\n-            #[stable]\n+            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n             fn neg(self) -> $t { -self }\n         }\n \n@@ -508,7 +512,7 @@ macro_rules! neg_impl {\n \n macro_rules! neg_uint_impl {\n     ($t:ty, $t_signed:ty) => {\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl Neg for $t {\n             type Output = $t;\n \n@@ -559,19 +563,19 @@ neg_uint_impl! { u64, i64 }\n /// }\n /// ```\n #[lang=\"not\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait Not {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the unary `!` operator\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn not(self) -> Self::Output;\n }\n \n macro_rules! not_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl Not for $t {\n             type Output = $t;\n \n@@ -614,19 +618,19 @@ not_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitand\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait BitAnd<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `&` operator\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn bitand(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitand_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl BitAnd for $t {\n             type Output = $t;\n \n@@ -669,19 +673,19 @@ bitand_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitor\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait BitOr<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `|` operator\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn bitor(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitor_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl BitOr for $t {\n             type Output = $t;\n \n@@ -724,19 +728,19 @@ bitor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitxor\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait BitXor<RHS=Self> {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `^` operator\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn bitxor(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitxor_impl {\n     ($($t:ty)*) => ($(\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl BitXor for $t {\n             type Output = $t;\n \n@@ -779,19 +783,19 @@ bitxor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"shl\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait Shl<RHS> {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `<<` operator\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn shl(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! shl_impl {\n     ($t:ty, $f:ty) => (\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl Shl<$f> for $t {\n             type Output = $t;\n \n@@ -852,13 +856,13 @@ shl_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n /// }\n /// ```\n #[lang=\"shr\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait Shr<RHS> {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `>>` operator\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn shr(self, rhs: RHS) -> Self::Output;\n }\n \n@@ -970,10 +974,10 @@ pub trait IndexMut<Index: ?Sized> {\n /// An unbounded range.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"full_range\"]\n-#[unstable = \"API still in development\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"API still in development\")]\n pub struct FullRange;\n \n-#[unstable = \"API still in development\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"API still in development\")]\n impl fmt::Show for FullRange {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Show::fmt(\"..\", fmt)\n@@ -983,15 +987,15 @@ impl fmt::Show for FullRange {\n /// A (half-open) range which is bounded at both ends.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range\"]\n-#[unstable = \"API still in development\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"API still in development\")]\n pub struct Range<Idx> {\n     /// The lower bound of the range (inclusive).\n     pub start: Idx,\n     /// The upper bound of the range (exclusive).\n     pub end: Idx,\n }\n \n-#[unstable = \"API still in development\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"API still in development\")]\n impl<Idx: Clone + Step> Iterator for Range<Idx> {\n     type Item = Idx;\n \n@@ -1016,7 +1020,7 @@ impl<Idx: Clone + Step> Iterator for Range<Idx> {\n     }\n }\n \n-#[unstable = \"API still in development\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"API still in development\")]\n impl<Idx: Clone + Step> DoubleEndedIterator for Range<Idx> {\n     #[inline]\n     fn next_back(&mut self) -> Option<Idx> {\n@@ -1029,10 +1033,10 @@ impl<Idx: Clone + Step> DoubleEndedIterator for Range<Idx> {\n     }\n }\n \n-#[unstable = \"API still in development\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"API still in development\")]\n impl<Idx: Clone + Step> ExactSizeIterator for Range<Idx> {}\n \n-#[unstable = \"API still in development\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"API still in development\")]\n impl<Idx: fmt::Show> fmt::Show for Range<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"{:?}..{:?}\", self.start, self.end)\n@@ -1042,13 +1046,13 @@ impl<Idx: fmt::Show> fmt::Show for Range<Idx> {\n /// A range which is only bounded below.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range_from\"]\n-#[unstable = \"API still in development\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"API still in development\")]\n pub struct RangeFrom<Idx> {\n     /// The lower bound of the range (inclusive).\n     pub start: Idx,\n }\n \n-#[unstable = \"API still in development\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"API still in development\")]\n impl<Idx: Clone + Step> Iterator for RangeFrom<Idx> {\n     type Item = Idx;\n \n@@ -1061,7 +1065,7 @@ impl<Idx: Clone + Step> Iterator for RangeFrom<Idx> {\n     }\n }\n \n-#[unstable = \"API still in development\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"API still in development\")]\n impl<Idx: fmt::Show> fmt::Show for RangeFrom<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"{:?}..\", self.start)\n@@ -1071,13 +1075,13 @@ impl<Idx: fmt::Show> fmt::Show for RangeFrom<Idx> {\n /// A range which is only bounded above.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range_to\"]\n-#[unstable = \"API still in development\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"API still in development\")]\n pub struct RangeTo<Idx> {\n     /// The upper bound of the range (exclusive).\n     pub end: Idx,\n }\n \n-#[unstable = \"API still in development\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"API still in development\")]\n impl<Idx: fmt::Show> fmt::Show for RangeTo<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"..{:?}\", self.end)\n@@ -1116,24 +1120,24 @@ impl<Idx: fmt::Show> fmt::Show for RangeTo<Idx> {\n /// }\n /// ```\n #[lang=\"deref\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait Deref {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     type Target: ?Sized;\n \n     /// The method called to dereference a value\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn deref<'a>(&'a self) -> &'a Self::Target;\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> Deref for &'a T {\n     type Target = T;\n \n     fn deref(&self) -> &T { *self }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> Deref for &'a mut T {\n     type Target = T;\n \n@@ -1178,37 +1182,40 @@ impl<'a, T: ?Sized> Deref for &'a mut T {\n /// }\n /// ```\n #[lang=\"deref_mut\"]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait DerefMut: Deref {\n     /// The method called to mutably dereference a value\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn deref_mut<'a>(&'a mut self) -> &'a mut Self::Target;\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> DerefMut for &'a mut T {\n     fn deref_mut(&mut self) -> &mut T { *self }\n }\n \n /// A version of the call operator that takes an immutable receiver.\n #[lang=\"fn\"]\n-#[unstable = \"uncertain about variadic generics, input versus associated types\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"uncertain about variadic generics, input versus associated types\")]\n pub trait Fn<Args,Result> {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call(&self, args: Args) -> Result;\n }\n \n /// A version of the call operator that takes a mutable receiver.\n #[lang=\"fn_mut\"]\n-#[unstable = \"uncertain about variadic generics, input versus associated types\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"uncertain about variadic generics, input versus associated types\")]\n pub trait FnMut<Args,Result> {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Result;\n }\n \n /// A version of the call operator that takes a by-value receiver.\n #[lang=\"fn_once\"]\n-#[unstable = \"uncertain about variadic generics, input versus associated types\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"uncertain about variadic generics, input versus associated types\")]\n pub trait FnOnce<Args,Result> {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call_once(self, args: Args) -> Result;"}, {"sha": "1c44ad00ae939c22997b0dbfab5f4eb1e6913460", "filename": "src/libcore/option.rs", "status": "modified", "additions": 50, "deletions": 46, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -141,7 +141,7 @@\n //! }\n //! ```\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use self::Option::*;\n \n@@ -164,13 +164,13 @@ use slice;\n \n /// The `Option` type.\n #[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Show, Hash)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub enum Option<T> {\n     /// No value\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     None,\n     /// Some value `T`\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     Some(T)\n }\n \n@@ -195,7 +195,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.is_some(), false);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_some(&self) -> bool {\n         match *self {\n             Some(_) => true,\n@@ -215,7 +215,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.is_none(), true);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_none(&self) -> bool {\n         !self.is_some()\n     }\n@@ -241,7 +241,7 @@ impl<T> Option<T> {\n     /// println!(\"still can print num_as_str: {:?}\", num_as_str);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn as_ref<'r>(&'r self) -> Option<&'r T> {\n         match *self {\n             Some(ref x) => Some(x),\n@@ -262,7 +262,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x, Some(42u));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn as_mut<'r>(&'r mut self) -> Option<&'r mut T> {\n         match *self {\n             Some(ref mut x) => Some(x),\n@@ -285,7 +285,8 @@ impl<T> Option<T> {\n     /// assert_eq!(x, Some(\"Dirt\"));\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for mut conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"waiting for mut conventions\")]\n     pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n         match *self {\n             Some(ref mut x) => {\n@@ -322,7 +323,7 @@ impl<T> Option<T> {\n     /// x.expect(\"the world is ending\"); // panics with `world is ending`\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn expect(self, msg: &str) -> T {\n         match self {\n             Some(val) => val,\n@@ -354,7 +355,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.unwrap(), \"air\"); // fails\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn unwrap(self) -> T {\n         match self {\n             Some(val) => val,\n@@ -371,7 +372,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn unwrap_or(self, def: T) -> T {\n         match self {\n             Some(x) => x,\n@@ -389,7 +390,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.unwrap_or_else(|| 2 * k), 20u);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn unwrap_or_else<F: FnOnce() -> T>(self, f: F) -> T {\n         match self {\n             Some(x) => x,\n@@ -413,7 +414,7 @@ impl<T> Option<T> {\n     /// let num_as_int: Option<uint> = num_as_str.map(|n| n.len());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {\n         match self {\n             Some(x) => Some(f(x)),\n@@ -433,7 +434,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.map_or(42u, |v| v.len()), 42u);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn map_or<U, F: FnOnce(T) -> U>(self, def: U, f: F) -> U {\n         match self {\n             Some(t) => f(t),\n@@ -455,7 +456,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 42u);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn map_or_else<U, D: FnOnce() -> U, F: FnOnce(T) -> U>(self, def: D, f: F) -> U {\n         match self {\n             Some(t) => f(t),\n@@ -476,7 +477,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.ok_or(0i), Err(0i));\n     /// ```\n     #[inline]\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn ok_or<E>(self, err: E) -> Result<T, E> {\n         match self {\n             Some(v) => Ok(v),\n@@ -497,7 +498,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.ok_or_else(|| 0i), Err(0i));\n     /// ```\n     #[inline]\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn ok_or_else<E, F: FnOnce() -> E>(self, err: F) -> Result<T, E> {\n         match self {\n             Some(v) => Ok(v),\n@@ -521,7 +522,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.iter().next(), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { inner: Item { opt: self.as_ref() } }\n     }\n@@ -542,7 +543,8 @@ impl<T> Option<T> {\n     /// assert_eq!(x.iter_mut().next(), None);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for iterator conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"waiting for iterator conventions\")]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n         IterMut { inner: Item { opt: self.as_mut() } }\n     }\n@@ -561,7 +563,7 @@ impl<T> Option<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter { inner: Item { opt: self } }\n     }\n@@ -592,7 +594,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.and(y), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn and<U>(self, optb: Option<U>) -> Option<U> {\n         match self {\n             Some(_) => optb,\n@@ -615,7 +617,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.and_then(sq).and_then(sq), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn and_then<U, F: FnOnce(T) -> Option<U>>(self, f: F) -> Option<U> {\n         match self {\n             Some(x) => f(x),\n@@ -645,7 +647,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.or(y), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn or(self, optb: Option<T>) -> Option<T> {\n         match self {\n             Some(_) => self,\n@@ -667,7 +669,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.or_else(nobody), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn or_else<F: FnOnce() -> Option<T>>(self, f: F) -> Option<T> {\n         match self {\n             Some(_) => self,\n@@ -693,7 +695,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x, None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn take(&mut self) -> Option<T> {\n         mem::replace(self, None)\n     }\n@@ -702,7 +704,8 @@ impl<T> Option<T> {\n impl<'a, T: Clone, D: Deref<Target=T>> Option<D> {\n     /// Maps an Option<D> to an Option<T> by dereffing and cloning the contents of the Option.\n     /// Useful for converting an Option<&T> to an Option<T>.\n-    #[unstable = \"recently added as part of collections reform\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"recently added as part of collections reform\")]\n     pub fn cloned(self) -> Option<T> {\n         self.map(|t| t.deref().clone())\n     }\n@@ -732,7 +735,7 @@ impl<T: Default> Option<T> {\n     /// assert_eq!(0i, bad_year);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn unwrap_or_default(self) -> T {\n         match self {\n             Some(x) => x,\n@@ -745,7 +748,8 @@ impl<T: Default> Option<T> {\n // Trait implementations\n /////////////////////////////////////////////////////////////////////////////\n \n-#[unstable = \"waiting on the stability of the trait itself\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"waiting on the stability of the trait itself\")]\n impl<T> AsSlice<T> for Option<T> {\n     /// Convert from `Option<T>` to `&[T]` (without copying)\n     #[inline]\n@@ -760,10 +764,10 @@ impl<T> AsSlice<T> for Option<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Default for Option<T> {\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn default() -> Option<T> { None }\n }\n \n@@ -803,10 +807,10 @@ impl<A> DoubleEndedIterator for Item<A> {\n impl<A> ExactSizeIterator for Item<A> {}\n \n /// An iterator over a reference of the contained item in an Option.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Iter<'a, A: 'a> { inner: Item<&'a A> }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, A> Iterator for Iter<'a, A> {\n     type Item = &'a A;\n \n@@ -816,27 +820,27 @@ impl<'a, A> Iterator for Iter<'a, A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a A> { self.inner.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, A> ExactSizeIterator for Iter<'a, A> {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, A> Clone for Iter<'a, A> {\n     fn clone(&self) -> Iter<'a, A> {\n         Iter { inner: self.inner.clone() }\n     }\n }\n \n /// An iterator over a mutable reference of the contained item in an Option.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct IterMut<'a, A: 'a> { inner: Item<&'a mut A> }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, A> Iterator for IterMut<'a, A> {\n     type Item = &'a mut A;\n \n@@ -846,20 +850,20 @@ impl<'a, A> Iterator for IterMut<'a, A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut A> { self.inner.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n \n /// An iterator over the item contained inside an Option.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct IntoIter<A> { inner: Item<A> }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A> Iterator for IntoIter<A> {\n     type Item = A;\n \n@@ -869,20 +873,20 @@ impl<A> Iterator for IntoIter<A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A> DoubleEndedIterator for IntoIter<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.inner.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A> ExactSizeIterator for IntoIter<A> {}\n \n /////////////////////////////////////////////////////////////////////////////\n // FromIterator\n /////////////////////////////////////////////////////////////////////////////\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// Takes each element in the `Iterator`: if it is `None`, no further\n     /// elements are taken, and the `None` is returned. Should no `None` occur, a\n@@ -902,7 +906,7 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// assert!(res == Some(vec!(2u, 3u)));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn from_iter<I: Iterator<Item=Option<A>>>(iter: I) -> Option<V> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed."}, {"sha": "36ee97051ba627a25cc7adf604ae2091b9702f10", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 60, "deletions": 50, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -86,7 +86,7 @@\n //! but C APIs hand out a lot of pointers generally, so are a common source\n //! of unsafe pointers in Rust.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use mem;\n use clone::Clone;\n@@ -99,13 +99,14 @@ use cmp::Ordering::{self, Less, Equal, Greater};\n \n // FIXME #19649: intrinsic docs don't render, so these have no docs :(\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub use intrinsics::copy_nonoverlapping_memory;\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub use intrinsics::copy_memory;\n \n-#[unstable = \"uncertain about naming and semantics\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"uncertain about naming and semantics\")]\n pub use intrinsics::set_memory;\n \n \n@@ -120,7 +121,7 @@ pub use intrinsics::set_memory;\n /// assert!(p.is_null());\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub fn null<T>() -> *const T { 0 as *const T }\n \n /// Creates a null mutable raw pointer.\n@@ -134,7 +135,7 @@ pub fn null<T>() -> *const T { 0 as *const T }\n /// assert!(p.is_null());\n /// ```\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub fn null_mut<T>() -> *mut T { 0 as *mut T }\n \n /// Zeroes out `count * size_of::<T>` bytes of memory at `dst`. `count` may be\n@@ -145,7 +146,8 @@ pub fn null_mut<T>() -> *mut T { 0 as *mut T }\n /// Beyond accepting a raw pointer, this is unsafe because it will not drop the\n /// contents of `dst`, and may be used to create invalid instances of `T`.\n #[inline]\n-#[unstable = \"may play a larger role in std::ptr future extensions\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"may play a larger role in std::ptr future extensions\")]\n pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) {\n     set_memory(dst, 0, count);\n }\n@@ -158,7 +160,7 @@ pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) {\n ///\n /// This is only unsafe because it accepts a raw pointer.\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     // Give ourselves some scratch space to work with\n     let mut tmp: T = mem::uninitialized();\n@@ -182,7 +184,7 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n /// This is only unsafe because it accepts a raw pointer.\n /// Otherwise, this operation is identical to `mem::replace`.\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n     mem::swap(mem::transmute(dest), &mut src); // cannot overlap\n     src\n@@ -200,7 +202,7 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n /// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n /// because it will attempt to drop the value previously at `*src`.\n #[inline(always)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub unsafe fn read<T>(src: *const T) -> T {\n     let mut tmp: T = mem::uninitialized();\n     copy_nonoverlapping_memory(&mut tmp, src, 1);\n@@ -213,7 +215,8 @@ pub unsafe fn read<T>(src: *const T) -> T {\n ///\n /// This is unsafe for the same reasons that `read` is unsafe.\n #[inline(always)]\n-#[unstable = \"may play a larger role in std::ptr future extensions\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"may play a larger role in std::ptr future extensions\")]\n pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n     // Copy the data out from `dest`:\n     let tmp = read(&*dest);\n@@ -236,18 +239,18 @@ pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n /// This is appropriate for initializing uninitialized memory, or overwriting\n /// memory that has previously been `read` from.\n #[inline]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub unsafe fn write<T>(dst: *mut T, src: T) {\n     intrinsics::move_val_init(&mut *dst, src)\n }\n \n /// Methods on raw pointers\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait PtrExt: Sized {\n     type Target;\n \n     /// Returns true if the pointer is null.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn is_null(self) -> bool;\n \n     /// Returns `None` if the pointer is null, or else returns a reference to\n@@ -259,8 +262,9 @@ pub trait PtrExt: Sized {\n     /// null-safety, it is important to note that this is still an unsafe\n     /// operation because the returned value could be pointing to invalid\n     /// memory.\n-    #[unstable = \"Option is not clearly the right return type, and we may want \\\n-                  to tie the return lifetime to a borrow of the raw pointer\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"Option is not clearly the right return type, and we may want \\\n+                         to tie the return lifetime to a borrow of the raw pointer\")]\n     unsafe fn as_ref<'a>(&self) -> Option<&'a Self::Target>;\n \n     /// Calculates the offset from a pointer. `count` is in units of T; e.g. a\n@@ -271,12 +275,12 @@ pub trait PtrExt: Sized {\n     /// The offset must be in-bounds of the object, or one-byte-past-the-end.\n     /// Otherwise `offset` invokes Undefined Behaviour, regardless of whether\n     /// the pointer is used.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     unsafe fn offset(self, count: int) -> Self;\n }\n \n /// Methods on mutable raw pointers\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait MutPtrExt {\n     type Target;\n \n@@ -287,28 +291,30 @@ pub trait MutPtrExt {\n     ///\n     /// As with `as_ref`, this is unsafe because it cannot verify the validity\n     /// of the returned pointer.\n-    #[unstable = \"Option is not clearly the right return type, and we may want \\\n-                  to tie the return lifetime to a borrow of the raw pointer\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"Option is not clearly the right return type, and we may want \\\n+                         to tie the return lifetime to a borrow of the raw pointer\")]\n     unsafe fn as_mut<'a>(&self) -> Option<&'a mut Self::Target>;\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> PtrExt for *const T {\n     type Target = T;\n \n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn is_null(self) -> bool { self as uint == 0 }\n \n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     unsafe fn offset(self, count: int) -> *const T {\n         intrinsics::offset(self, count)\n     }\n \n     #[inline]\n-    #[unstable = \"return value does not necessarily convey all possible \\\n-                  information\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"return value does not necessarily convey all possible \\\n+                         information\")]\n     unsafe fn as_ref<'a>(&self) -> Option<&'a T> {\n         if self.is_null() {\n             None\n@@ -318,23 +324,24 @@ impl<T> PtrExt for *const T {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> PtrExt for *mut T {\n     type Target = T;\n \n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn is_null(self) -> bool { self as uint == 0 }\n \n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     unsafe fn offset(self, count: int) -> *mut T {\n         intrinsics::offset(self, count) as *mut T\n     }\n \n     #[inline]\n-    #[unstable = \"return value does not necessarily convey all possible \\\n-                  information\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"return value does not necessarily convey all possible \\\n+                         information\")]\n     unsafe fn as_ref<'a>(&self) -> Option<&'a T> {\n         if self.is_null() {\n             None\n@@ -344,13 +351,14 @@ impl<T> PtrExt for *mut T {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> MutPtrExt for *mut T {\n     type Target = T;\n \n     #[inline]\n-    #[unstable = \"return value does not necessarily convey all possible \\\n-                  information\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"return value does not necessarily convey all possible \\\n+                         information\")]\n     unsafe fn as_mut<'a>(&self) -> Option<&'a mut T> {\n         if self.is_null() {\n             None\n@@ -361,7 +369,7 @@ impl<T> MutPtrExt for *mut T {\n }\n \n // Equality for pointers\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> PartialEq for *const T {\n     #[inline]\n     fn eq(&self, other: &*const T) -> bool {\n@@ -371,10 +379,10 @@ impl<T> PartialEq for *const T {\n     fn ne(&self, other: &*const T) -> bool { !self.eq(other) }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Eq for *const T {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> PartialEq for *mut T {\n     #[inline]\n     fn eq(&self, other: &*mut T) -> bool {\n@@ -384,18 +392,18 @@ impl<T> PartialEq for *mut T {\n     fn ne(&self, other: &*mut T) -> bool { !self.eq(other) }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Eq for *mut T {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Clone for *const T {\n     #[inline]\n     fn clone(&self) -> *const T {\n         *self\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Clone for *mut T {\n     #[inline]\n     fn clone(&self) -> *mut T {\n@@ -408,7 +416,7 @@ mod externfnpointers {\n     use mem;\n     use cmp::PartialEq;\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     impl<_R> PartialEq for extern \"C\" fn() -> _R {\n         #[inline]\n         fn eq(&self, other: &extern \"C\" fn() -> _R) -> bool {\n@@ -419,7 +427,7 @@ mod externfnpointers {\n     }\n     macro_rules! fnptreq {\n         ($($p:ident),*) => {\n-            #[stable]\n+            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n             impl<_R,$($p),*> PartialEq for extern \"C\" fn($($p),*) -> _R {\n                 #[inline]\n                 fn eq(&self, other: &extern \"C\" fn($($p),*) -> _R) -> bool {\n@@ -439,7 +447,7 @@ mod externfnpointers {\n }\n \n // Comparison for pointers\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Ord for *const T {\n     #[inline]\n     fn cmp(&self, other: &*const T) -> Ordering {\n@@ -453,7 +461,7 @@ impl<T> Ord for *const T {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> PartialOrd for *const T {\n     #[inline]\n     fn partial_cmp(&self, other: &*const T) -> Option<Ordering> {\n@@ -473,7 +481,7 @@ impl<T> PartialOrd for *const T {\n     fn ge(&self, other: &*const T) -> bool { *self >= *other }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Ord for *mut T {\n     #[inline]\n     fn cmp(&self, other: &*mut T) -> Ordering {\n@@ -487,7 +495,7 @@ impl<T> Ord for *mut T {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> PartialOrd for *mut T {\n     #[inline]\n     fn partial_cmp(&self, other: &*mut T) -> Option<Ordering> {\n@@ -513,32 +521,34 @@ impl<T> PartialOrd for *mut T {\n /// raw `*mut T` (which conveys no particular ownership semantics).\n /// Useful for building abstractions like `Vec<T>` or `Box<T>`, which\n /// internally use raw pointers to manage the memory that they own.\n-#[unstable = \"recently added to this module\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"recently added to this module\")]\n pub struct Unique<T>(pub *mut T);\n \n /// `Unique` pointers are `Send` if `T` is `Send` because the data they\n /// reference is unaliased. Note that this aliasing invariant is\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n-#[unstable = \"recently added to this module\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"recently added to this module\")]\n unsafe impl<T:Send> Send for Unique<T> { }\n \n /// `Unique` pointers are `Sync` if `T` is `Sync` because the data they\n /// reference is unaliased. Note that this aliasing invariant is\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n-#[unstable = \"recently added to this module\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"recently added to this module\")]\n unsafe impl<T:Sync> Sync for Unique<T> { }\n \n impl<T> Unique<T> {\n     /// Returns a null Unique.\n-    #[unstable = \"recently added to this module\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"recently added to this module\")]\n     pub fn null() -> Unique<T> {\n         Unique(null_mut())\n     }\n \n     /// Return an (unsafe) pointer into the memory owned by `self`.\n-    #[unstable = \"recently added to this module\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"recently added to this module\")]\n     pub unsafe fn offset(self, offset: int) -> *mut T {\n         self.0.offset(offset)\n     }"}, {"sha": "4b4b493bad2a3d54c40ad0544be0a3007d48a512", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![allow(missing_docs)]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n \n //! Contains struct definitions for the layout of compiler built-in types.\n //!"}, {"sha": "a1a7ddcde570ca50695d11d2a01293b5952d8e55", "filename": "src/libcore/result.rs", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -224,7 +224,7 @@\n //!\n //! `try!` is imported by the prelude, and is available everywhere.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use self::Result::{Ok, Err};\n \n@@ -241,22 +241,22 @@ use slice;\n /// See the [`std::result`](index.html) module documentation for details.\n #[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Show, Hash)]\n #[must_use]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub enum Result<T, E> {\n     /// Contains the success value\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     Ok(T),\n \n     /// Contains the error value\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     Err(E)\n }\n \n /////////////////////////////////////////////////////////////////////////////\n // Type implementation\n /////////////////////////////////////////////////////////////////////////////\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T, E> Result<T, E> {\n     /////////////////////////////////////////////////////////////////////////\n     // Querying the contained values\n@@ -274,7 +274,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.is_ok(), false);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_ok(&self) -> bool {\n         match *self {\n             Ok(_) => true,\n@@ -294,7 +294,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.is_err(), true);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_err(&self) -> bool {\n         !self.is_ok()\n     }\n@@ -318,7 +318,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.ok(), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn ok(self) -> Option<T> {\n         match self {\n             Ok(x)  => Some(x),\n@@ -341,7 +341,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.err(), Some(\"Nothing here\"));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn err(self) -> Option<E> {\n         match self {\n             Ok(_)  => None,\n@@ -366,7 +366,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.as_ref(), Err(&\"Error\"));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn as_ref(&self) -> Result<&T, &E> {\n         match *self {\n             Ok(ref x) => Ok(x),\n@@ -393,7 +393,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.unwrap_err(), 0);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn as_mut(&mut self) -> Result<&mut T, &mut E> {\n         match *self {\n             Ok(ref mut x) => Ok(x),\n@@ -417,7 +417,8 @@ impl<T, E> Result<T, E> {\n     /// assert!(x.as_mut_slice().is_empty());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for mut conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"waiting for mut conventions\")]\n     pub fn as_mut_slice(&mut self) -> &mut [T] {\n         match *self {\n             Ok(ref mut x) => slice::mut_ref_slice(x),\n@@ -463,7 +464,7 @@ impl<T, E> Result<T, E> {\n     /// assert!(sum == 10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn map<U, F: FnOnce(T) -> U>(self, op: F) -> Result<U,E> {\n         match self {\n             Ok(t) => Ok(op(t)),\n@@ -489,7 +490,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn map_err<F, O: FnOnce(E) -> F>(self, op: O) -> Result<T,F> {\n         match self {\n             Ok(t) => Ok(t),\n@@ -513,7 +514,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.iter().next(), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { inner: self.as_ref().ok() }\n     }\n@@ -534,7 +535,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.iter_mut().next(), None);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n         IterMut { inner: self.as_mut().ok() }\n     }\n@@ -553,7 +554,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(v, vec![]);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter { inner: self.ok() }\n     }\n@@ -584,7 +585,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.and(y), Ok(\"different result type\"));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> {\n         match self {\n             Ok(_) => res,\n@@ -608,7 +609,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(Err(3).and_then(sq).and_then(sq), Err(3));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn and_then<U, F: FnOnce(T) -> Result<U, E>>(self, op: F) -> Result<U, E> {\n         match self {\n             Ok(t) => op(t),\n@@ -638,7 +639,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.or(y), Ok(2));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn or(self, res: Result<T, E>) -> Result<T, E> {\n         match self {\n             Ok(_) => self,\n@@ -662,7 +663,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(Err(3).or_else(err).or_else(err), Err(3));\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn or_else<F, O: FnOnce(E) -> Result<T, F>>(self, op: O) -> Result<T, F> {\n         match self {\n             Ok(t) => Ok(t),\n@@ -684,7 +685,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.unwrap_or(optb), optb);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn unwrap_or(self, optb: T) -> T {\n         match self {\n             Ok(t) => t,\n@@ -704,7 +705,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(Err(\"foo\").unwrap_or_else(count), 3u);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn unwrap_or_else<F: FnOnce(E) -> T>(self, op: F) -> T {\n         match self {\n             Ok(t) => t,\n@@ -713,7 +714,7 @@ impl<T, E> Result<T, E> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T, E: Show> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Ok`.\n     ///\n@@ -734,7 +735,7 @@ impl<T, E: Show> Result<T, E> {\n     /// x.unwrap(); // panics with `emergency failure`\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn unwrap(self) -> T {\n         match self {\n             Ok(t) => t,\n@@ -744,7 +745,7 @@ impl<T, E: Show> Result<T, E> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Show, E> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Err`.\n     ///\n@@ -765,7 +766,7 @@ impl<T: Show, E> Result<T, E> {\n     /// assert_eq!(x.unwrap_err(), \"emergency failure\");\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn unwrap_err(self) -> E {\n         match self {\n             Ok(t) =>\n@@ -782,7 +783,7 @@ impl<T: Show, E> Result<T, E> {\n impl<T, E> AsSlice<T> for Result<T, E> {\n     /// Convert from `Result<T, E>` to `&[T]` (without copying)\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         match *self {\n             Ok(ref x) => slice::ref_slice(x),\n@@ -800,10 +801,10 @@ impl<T, E> AsSlice<T> for Result<T, E> {\n /////////////////////////////////////////////////////////////////////////////\n \n /// An iterator over a reference to the `Ok` variant of a `Result`.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> { inner: Option<&'a T> }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n@@ -816,24 +817,24 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> { self.inner.take() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { Iter { inner: self.inner } }\n }\n \n /// An iterator over a mutable reference to the `Ok` variant of a `Result`.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> { inner: Option<&'a mut T> }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> Iterator for IterMut<'a, T> {\n     type Item = &'a mut T;\n \n@@ -846,20 +847,20 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut T> { self.inner.take() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// An iterator over the value in a `Ok` variant of a `Result`.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct IntoIter<T> { inner: Option<T> }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n@@ -872,20 +873,20 @@ impl<T> Iterator for IntoIter<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> { self.inner.take() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /////////////////////////////////////////////////////////////////////////////\n // FromIterator\n /////////////////////////////////////////////////////////////////////////////\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// Takes each element in the `Iterator`: if it is an `Err`, no further\n     /// elements are taken, and the `Err` is returned. Should no `Err` occur, a\n@@ -949,7 +950,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n /// If an `Err` is encountered, it is immediately returned.\n /// Otherwise, the folded value is returned.\n #[inline]\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub fn fold<T,\n             V,\n             E,"}, {"sha": "01082516793957d6c23262b974ac16f8271738f7", "filename": "src/libcore/simd.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsimd.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -37,7 +37,7 @@\n #![allow(non_camel_case_types)]\n #![allow(missing_docs)]\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n@@ -46,26 +46,26 @@ pub struct i8x16(pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8);\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct i16x8(pub i16, pub i16, pub i16, pub i16,\n                  pub i16, pub i16, pub i16, pub i16);\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct i32x4(pub i32, pub i32, pub i32, pub i32);\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct i64x2(pub i64, pub i64);\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n@@ -74,32 +74,32 @@ pub struct u8x16(pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8);\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct u16x8(pub u16, pub u16, pub u16, pub u16,\n                  pub u16, pub u16, pub u16, pub u16);\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct u32x4(pub u32, pub u32, pub u32, pub u32);\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct u64x2(pub u64, pub u64);\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]"}, {"sha": "99949ff138464a73a29311c34b2d962af8aec35e", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 69, "deletions": 66, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -12,7 +12,7 @@\n //!\n //! For more details `std::slice`.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![doc(primitive = \"slice\")]\n \n // How this module is organized.\n@@ -131,7 +131,7 @@ pub trait SliceExt {\n     fn clone_from_slice(&mut self, &[Self::Item]) -> uint where Self::Item: Clone;\n }\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n impl<T> SliceExt for [T] {\n     type Item = T;\n \n@@ -258,7 +258,7 @@ impl<T> SliceExt for [T] {\n         self.repr().data\n     }\n \n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     fn binary_search_by<F>(&self, mut f: F) -> Result<uint, uint> where\n         F: FnMut(&T) -> Ordering\n     {\n@@ -452,12 +452,12 @@ impl<T> SliceExt for [T] {\n         m >= n && needle == &self[(m-n)..]\n     }\n \n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     fn binary_search(&self, x: &T) -> Result<uint, uint> where T: Ord {\n         self.binary_search_by(|p| p.cmp(x))\n     }\n \n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     fn next_permutation(&mut self) -> bool where T: Ord {\n         // These cases only have 1 permutation each, so we can't do anything.\n         if self.len() < 2 { return false; }\n@@ -488,7 +488,7 @@ impl<T> SliceExt for [T] {\n         true\n     }\n \n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     fn prev_permutation(&mut self) -> bool where T: Ord {\n         // These cases only have 1 permutation each, so we can't do anything.\n         if self.len() < 2 { return false; }\n@@ -630,33 +630,34 @@ impl<T> ops::IndexMut<ops::FullRange> for [T] {\n ////////////////////////////////////////////////////////////////////////////////\n \n /// Data that is viewable as a slice.\n-#[unstable = \"will be replaced by slice syntax\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"will be replaced by slice syntax\")]\n pub trait AsSlice<T> {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a [T];\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is experimental\")]\n impl<T> AsSlice<T> for [T] {\n     #[inline(always)]\n     fn as_slice<'a>(&'a self) -> &'a [T] { self }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is experimental\")]\n impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is experimental\")]\n impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a mut U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> Default for &'a [T] {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn default() -> &'a [T] { &[] }\n }\n \n@@ -667,7 +668,7 @@ impl<'a, T> Default for &'a [T] {\n // The shared definition of the `Iter` and `IterMut` iterators\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl<'a, T> Iterator for $name<'a, T> {\n             type Item = $elem;\n \n@@ -705,7 +706,7 @@ macro_rules! iterator {\n             }\n         }\n \n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n@@ -747,14 +748,14 @@ macro_rules! make_slice {\n }\n \n /// Immutable slice iterator\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n     ptr: *const T,\n     end: *const T,\n     marker: marker::ContravariantLifetime<'a>\n }\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n impl<'a, T> ops::Index<ops::Range<uint>> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -763,7 +764,7 @@ impl<'a, T> ops::Index<ops::Range<uint>> for Iter<'a, T> {\n     }\n }\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n impl<'a, T> ops::Index<ops::RangeTo<uint>> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -772,7 +773,7 @@ impl<'a, T> ops::Index<ops::RangeTo<uint>> for Iter<'a, T> {\n     }\n }\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n impl<'a, T> ops::Index<ops::RangeFrom<uint>> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -781,7 +782,7 @@ impl<'a, T> ops::Index<ops::RangeFrom<uint>> for Iter<'a, T> {\n     }\n }\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n impl<'a, T> ops::Index<ops::FullRange> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -795,7 +796,7 @@ impl<'a, T> Iter<'a, T> {\n     ///\n     /// This has the same lifetime as the original slice, and so the\n     /// iterator can continue to be used while this exists.\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn as_slice(&self) -> &'a [T] {\n         make_slice!(T => &'a [T]: self.ptr, self.end)\n     }\n@@ -805,15 +806,15 @@ impl<'a,T> Copy for Iter<'a,T> {}\n \n iterator!{struct Iter -> *const T, &'a T}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { *self }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is experimental\")]\n impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -839,39 +840,39 @@ impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n }\n \n /// Mutable slice iterator.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n     ptr: *mut T,\n     end: *mut T,\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n impl<'a, T> ops::Index<ops::Range<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &[T] {\n         self.index(&ops::FullRange).index(index)\n     }\n }\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n impl<'a, T> ops::Index<ops::RangeTo<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n         self.index(&ops::FullRange).index(index)\n     }\n }\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n impl<'a, T> ops::Index<ops::RangeFrom<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n         self.index(&ops::FullRange).index(index)\n     }\n }\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n impl<'a, T> ops::Index<ops::FullRange> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -880,31 +881,31 @@ impl<'a, T> ops::Index<ops::FullRange> for IterMut<'a, T> {\n     }\n }\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n impl<'a, T> ops::IndexMut<ops::Range<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n         self.index_mut(&ops::FullRange).index_mut(index)\n     }\n }\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n impl<'a, T> ops::IndexMut<ops::RangeTo<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n         self.index_mut(&ops::FullRange).index_mut(index)\n     }\n }\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n impl<'a, T> ops::IndexMut<ops::RangeFrom<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n         self.index_mut(&ops::FullRange).index_mut(index)\n     }\n }\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n impl<'a, T> ops::IndexMut<ops::FullRange> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -921,15 +922,15 @@ impl<'a, T> IterMut<'a, T> {\n     /// to consume the iterator. Consider using the `Slice` and\n     /// `SliceMut` implementations for obtaining slices with more\n     /// restricted lifetimes that do not consume the iterator.\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn into_slice(self) -> &'a mut [T] {\n         make_slice!(T => &'a mut [T]: self.ptr, self.end)\n     }\n }\n \n iterator!{struct IterMut -> *mut T, &'a mut T}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// An internal abstraction over the splitting iterators, so that\n@@ -942,15 +943,15 @@ trait SplitIter: DoubleEndedIterator {\n \n /// An iterator over subslices separated by elements that match a predicate\n /// function.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Split<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     v: &'a [T],\n     pred: P,\n     finished: bool\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T, P> Clone for Split<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n     fn clone(&self) -> Split<'a, T, P> {\n         Split {\n@@ -961,7 +962,7 @@ impl<'a, T, P> Clone for Split<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     type Item = &'a [T];\n \n@@ -989,7 +990,7 @@ impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T, P> DoubleEndedIterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n@@ -1015,7 +1016,7 @@ impl<'a, T, P> SplitIter for Split<'a, T, P> where P: FnMut(&T) -> bool {\n \n /// An iterator over the subslices of the vector which are separated\n /// by elements that match `pred`.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct SplitMut<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     v: &'a mut [T],\n     pred: P,\n@@ -1034,7 +1035,7 @@ impl<'a, T, P> SplitIter for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     type Item = &'a mut [T];\n \n@@ -1069,7 +1070,7 @@ impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where\n     P: FnMut(&T) -> bool,\n {\n@@ -1124,37 +1125,37 @@ impl<T, I: SplitIter<Item=T>> Iterator for GenericSplitN<I> {\n \n /// An iterator over subslices separated by elements that match a predicate\n /// function, limited to a given number of splits.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct SplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<Split<'a, T, P>>\n }\n \n /// An iterator over subslices separated by elements that match a\n /// predicate function, limited to a given number of splits, starting\n /// from the end of the slice.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct RSplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<Split<'a, T, P>>\n }\n \n /// An iterator over subslices separated by elements that match a predicate\n /// function, limited to a given number of splits.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct SplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<SplitMut<'a, T, P>>\n }\n \n /// An iterator over subslices separated by elements that match a\n /// predicate function, limited to a given number of splits, starting\n /// from the end of the slice.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct RSplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<SplitMut<'a, T, P>>\n }\n \n macro_rules! forward_iterator {\n     ($name:ident: $elem:ident, $iter_of:ty) => {\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl<'a, $elem, P> Iterator for $name<'a, $elem, P> where\n             P: FnMut(&T) -> bool\n         {\n@@ -1180,13 +1181,13 @@ forward_iterator! { RSplitNMut: T, &'a mut [T] }\n \n /// An iterator over overlapping subslices of length `size`.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Windows<'a, T:'a> {\n     v: &'a [T],\n     size: uint\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Windows<'a, T> {\n     type Item = &'a [T];\n \n@@ -1218,13 +1219,13 @@ impl<'a, T> Iterator for Windows<'a, T> {\n /// When the slice len is not evenly divided by the chunk size, the last slice\n /// of the iteration will be the remainder.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Chunks<'a, T:'a> {\n     v: &'a [T],\n     size: uint\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Chunks<'a, T> {\n     type Item = &'a [T];\n \n@@ -1253,7 +1254,7 @@ impl<'a, T> Iterator for Chunks<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n@@ -1269,7 +1270,7 @@ impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n     }\n }\n \n-#[unstable = \"trait is experimental\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"trait is experimental\")]\n impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1293,13 +1294,13 @@ impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n /// An iterator over a slice in (non-overlapping) mutable chunks (`size`\n /// elements at a time). When the slice len is not evenly divided by the chunk\n /// size, the last slice of the iteration will be the remainder.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct ChunksMut<'a, T:'a> {\n     v: &'a mut [T],\n     chunk_size: uint\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> Iterator for ChunksMut<'a, T> {\n     type Item = &'a mut [T];\n \n@@ -1329,7 +1330,7 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n@@ -1353,15 +1354,15 @@ impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n //\n \n /// Converts a pointer to A into a slice of length 1 (without copying).\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n     unsafe {\n         transmute(RawSlice { data: s, len: 1 })\n     }\n }\n \n /// Converts a pointer to A into a slice of length 1 (without copying).\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n     unsafe {\n         let ptr: *const A = transmute(s);\n@@ -1395,7 +1396,8 @@ pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n /// }\n /// ```\n #[inline]\n-#[unstable = \"should be renamed to from_raw_parts\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"should be renamed to from_raw_parts\")]\n pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] {\n     transmute(RawSlice { data: *p, len: len })\n }\n@@ -1407,7 +1409,8 @@ pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] {\n /// not being able to provide a non-aliasing guarantee of the returned mutable\n /// slice.\n #[inline]\n-#[unstable = \"should be renamed to from_raw_parts_mut\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"should be renamed to from_raw_parts_mut\")]\n pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: uint) -> &'a mut [T] {\n     transmute(RawSlice { data: *p, len: len })\n }\n@@ -1417,7 +1420,7 @@ pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: uint) -> &'a mut [T] {\n //\n \n /// Operations on `[u8]`.\n-#[unstable = \"needs review\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"needs review\")]\n pub mod bytes {\n     use ptr;\n     use slice::SliceExt;\n@@ -1459,7 +1462,7 @@ pub mod bytes {\n // Boilerplate traits\n //\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n     fn eq(&self, other: &[B]) -> bool {\n         self.len() == other.len() &&\n@@ -1471,17 +1474,17 @@ impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Eq> Eq for [T] {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Ord> Ord for [T] {\n     fn cmp(&self, other: &[T]) -> Ordering {\n         order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: PartialOrd> PartialOrd for [T] {\n     #[inline]\n     fn partial_cmp(&self, other: &[T]) -> Option<Ordering> {\n@@ -1506,7 +1509,7 @@ impl<T: PartialOrd> PartialOrd for [T] {\n }\n \n /// Extension methods for slices containing integers.\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub trait IntSliceExt<U, S> {\n     /// Converts the slice to an immutable slice of unsigned integers with the same width.\n     fn as_unsigned<'a>(&'a self) -> &'a [U];\n@@ -1521,7 +1524,7 @@ pub trait IntSliceExt<U, S> {\n \n macro_rules! impl_int_slice {\n     ($u:ty, $s:ty, $t:ty) => {\n-        #[unstable]\n+        #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n         impl IntSliceExt<$u, $s> for [$t] {\n             #[inline]\n             fn as_unsigned(&self) -> &[$u] { unsafe { transmute(self) } }"}, {"sha": "c2f9e764a9f88f1e244edc80fa2951e28bfc4e7d", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 52, "deletions": 45, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -45,7 +45,7 @@ macro_rules! delegate_iter {\n         }\n     };\n     ($te:ty : $ti:ty) => {\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl<'a> Iterator for $ti {\n             type Item = $te;\n \n@@ -58,7 +58,7 @@ macro_rules! delegate_iter {\n                 self.0.size_hint()\n             }\n         }\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl<'a> DoubleEndedIterator for $ti {\n             #[inline]\n             fn next_back(&mut self) -> Option<$te> {\n@@ -67,7 +67,7 @@ macro_rules! delegate_iter {\n         }\n     };\n     (pattern $te:ty : $ti:ty) => {\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl<'a, P: CharEq> Iterator for $ti {\n             type Item = $te;\n \n@@ -80,7 +80,7 @@ macro_rules! delegate_iter {\n                 self.0.size_hint()\n             }\n         }\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl<'a, P: CharEq> DoubleEndedIterator for $ti {\n             #[inline]\n             fn next_back(&mut self) -> Option<$te> {\n@@ -89,7 +89,7 @@ macro_rules! delegate_iter {\n         }\n     };\n     (pattern forward $te:ty : $ti:ty) => {\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         impl<'a, P: CharEq> Iterator for $ti {\n             type Item = $te;\n \n@@ -108,7 +108,8 @@ macro_rules! delegate_iter {\n /// A trait to abstract the idea of creating a new instance of a type from a\n /// string.\n // FIXME(#17307): there should be an `E` associated type for a `Result` return\n-#[unstable = \"will return a Result once associated types are working\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"will return a Result once associated types are working\")]\n pub trait FromStr {\n     /// Parses a string `s` to return an optional value of this type. If the\n     /// string is ill-formatted, the None is returned.\n@@ -143,7 +144,8 @@ Section: Creating a string\n \n /// Errors which can occur when attempting to interpret a byte slice as a `str`.\n #[derive(Copy, Eq, PartialEq, Clone, Show)]\n-#[unstable = \"error enumeration recently added and definitions may be refined\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"error enumeration recently added and definitions may be refined\")]\n pub enum Utf8Error {\n     /// An invalid byte was detected at the byte offset given.\n     ///\n@@ -167,15 +169,15 @@ pub enum Utf8Error {\n ///\n /// Returns `Err` if the slice is not utf-8 with a description as to why the\n /// provided slice is not utf-8.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n     try!(run_utf8_validation_iterator(&mut v.iter()));\n     Ok(unsafe { from_utf8_unchecked(v) })\n }\n \n /// Converts a slice of bytes to a string slice without checking\n /// that the string contains valid UTF-8.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n     mem::transmute(v)\n }\n@@ -193,7 +195,8 @@ pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n /// # Panics\n ///\n /// This function will panic if the string pointed to by `s` is not valid UTF-8.\n-#[deprecated = \"use std::ffi::c_str_to_bytes + str::from_utf8\"]\n+#[deprecated(feature = \"oldstuff\", since = \"1.0.0\",\n+             reason = \"use std::ffi::c_str_to_bytes + str::from_utf8\")]\n pub unsafe fn from_c_str(s: *const i8) -> &'static str {\n     let s = s as *const u8;\n     let mut len = 0u;\n@@ -205,7 +208,8 @@ pub unsafe fn from_c_str(s: *const i8) -> &'static str {\n }\n \n /// Something that can be used to compare against a character\n-#[unstable = \"definition may change as pattern-related methods are stabilized\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"definition may change as pattern-related methods are stabilized\")]\n pub trait CharEq {\n     /// Determine if the splitter should split at the given character\n     fn matches(&mut self, char) -> bool;\n@@ -250,7 +254,7 @@ Section: Iterators\n ///\n /// Created with the method `.chars()`.\n #[derive(Clone, Copy)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Chars<'a> {\n     iter: slice::Iter<'a, u8>\n }\n@@ -279,7 +283,7 @@ fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> Iterator for Chars<'a> {\n     type Item = char;\n \n@@ -325,7 +329,7 @@ impl<'a> Iterator for Chars<'a> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for Chars<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<char> {\n@@ -362,13 +366,13 @@ impl<'a> DoubleEndedIterator for Chars<'a> {\n /// External iterator for a string's characters and their byte offsets.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct CharIndices<'a> {\n     front_offset: uint,\n     iter: Chars<'a>,\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> Iterator for CharIndices<'a> {\n     type Item = (uint, char);\n \n@@ -392,7 +396,7 @@ impl<'a> Iterator for CharIndices<'a> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for CharIndices<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, char)> {\n@@ -411,7 +415,7 @@ impl<'a> DoubleEndedIterator for CharIndices<'a> {\n /// Use with the `std::iter` module.\n ///\n /// Created with `StrExt::bytes`\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Bytes<'a>(Map<&'a u8, u8, slice::Iter<'a, u8>, BytesDeref>);\n delegate_iter!{exact u8 : Bytes<'a>}\n@@ -451,13 +455,13 @@ struct CharSplitsN<'a, Sep> {\n }\n \n /// An iterator over the lines of a string, separated by `\\n`.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Lines<'a> {\n     inner: CharSplits<'a, char>,\n }\n \n /// An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`).\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct LinesAny<'a> {\n     inner: Map<&'a str, &'a str, Lines<'a>, fn(&str) -> &str>,\n }\n@@ -474,7 +478,7 @@ impl<'a, Sep> CharSplits<'a, Sep> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, Sep: CharEq> Iterator for CharSplits<'a, Sep> {\n     type Item = &'a str;\n \n@@ -509,7 +513,7 @@ impl<'a, Sep: CharEq> Iterator for CharSplits<'a, Sep> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, Sep: CharEq> DoubleEndedIterator for CharSplits<'a, Sep> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> {\n@@ -551,7 +555,7 @@ impl<'a, Sep: CharEq> DoubleEndedIterator for CharSplits<'a, Sep> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, Sep: CharEq> Iterator for CharSplitsN<'a, Sep> {\n     type Item = &'a str;\n \n@@ -857,7 +861,7 @@ impl Searcher {\n /// An iterator over the start and end indices of the matches of a\n /// substring within a larger string\n #[derive(Clone)]\n-#[unstable = \"type may be removed\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"type may be removed\")]\n pub struct MatchIndices<'a> {\n     // constants\n     haystack: &'a str,\n@@ -868,14 +872,14 @@ pub struct MatchIndices<'a> {\n /// An iterator over the substrings of a string separated by a given\n /// search string\n #[derive(Clone)]\n-#[unstable = \"type may be removed\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"type may be removed\")]\n pub struct SplitStr<'a> {\n     it: MatchIndices<'a>,\n     last_end: uint,\n     finished: bool\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> Iterator for MatchIndices<'a> {\n     type Item = (uint, uint);\n \n@@ -892,7 +896,7 @@ impl<'a> Iterator for MatchIndices<'a> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> Iterator for SplitStr<'a> {\n     type Item = &'a str;\n \n@@ -1052,7 +1056,8 @@ static UTF8_CHAR_WIDTH: [u8; 256] = [\n /// the next `char` in a string.  This can be used as a data structure\n /// for iterating over the UTF-8 bytes of a string.\n #[derive(Copy)]\n-#[unstable = \"naming is uncertain with container conventions\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"naming is uncertain with container conventions\")]\n pub struct CharRange {\n     /// Current `char`\n     pub ch: char,\n@@ -1078,7 +1083,7 @@ mod traits {\n     use ops;\n     use str::{StrExt, eq_slice};\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     impl Ord for str {\n         #[inline]\n         fn cmp(&self, other: &str) -> Ordering {\n@@ -1094,7 +1099,7 @@ mod traits {\n         }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     impl PartialEq for str {\n         #[inline]\n         fn eq(&self, other: &str) -> bool {\n@@ -1104,10 +1109,10 @@ mod traits {\n         fn ne(&self, other: &str) -> bool { !(*self).eq(other) }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     impl Eq for str {}\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     impl PartialOrd for str {\n         #[inline]\n         fn partial_cmp(&self, other: &str) -> Option<Ordering> {\n@@ -1146,9 +1151,10 @@ mod traits {\n }\n \n /// Any string that can be represented as a slice\n-#[unstable = \"Instead of taking this bound generically, this trait will be \\\n-              replaced with one of slicing syntax, deref coercions, or \\\n-              a more generic conversion trait\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"Instead of taking this bound generically, this trait will be \\\n+                     replaced with one of slicing syntax, deref coercions, or \\\n+                     a more generic conversion trait\")]\n pub trait Str {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a str;\n@@ -1166,25 +1172,26 @@ impl<'a, S: ?Sized> Str for &'a S where S: Str {\n \n /// Return type of `StrExt::split`\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Split<'a, P>(CharSplits<'a, P>);\n delegate_iter!{pattern &'a str : Split<'a, P>}\n \n /// Return type of `StrExt::split_terminator`\n #[derive(Clone)]\n-#[unstable = \"might get removed in favour of a constructor method on Split\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"might get removed in favour of a constructor method on Split\")]\n pub struct SplitTerminator<'a, P>(CharSplits<'a, P>);\n delegate_iter!{pattern &'a str : SplitTerminator<'a, P>}\n \n /// Return type of `StrExt::splitn`\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct SplitN<'a, P>(CharSplitsN<'a, P>);\n delegate_iter!{pattern forward &'a str : SplitN<'a, P>}\n \n /// Return type of `StrExt::rsplitn`\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct RSplitN<'a, P>(CharSplitsN<'a, P>);\n delegate_iter!{pattern forward &'a str : RSplitN<'a, P>}\n \n@@ -1599,13 +1606,13 @@ impl StrExt for str {\n     fn parse<T: FromStr>(&self) -> Option<T> { FromStr::from_str(self) }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> Default for &'a str {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn default() -> &'a str { \"\" }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> Iterator for Lines<'a> {\n     type Item = &'a str;\n \n@@ -1615,13 +1622,13 @@ impl<'a> Iterator for Lines<'a> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for Lines<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> Iterator for LinesAny<'a> {\n     type Item = &'a str;\n \n@@ -1631,7 +1638,7 @@ impl<'a> Iterator for LinesAny<'a> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for LinesAny<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }"}, {"sha": "82d38f82b1604c69abdc729fcc15f2a1a6dfb437", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -33,7 +33,7 @@\n //! * `Ord`\n //! * `Default`\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use clone::Clone;\n use cmp::*;\n@@ -55,14 +55,14 @@ macro_rules! tuple_impls {\n         }\n     )+) => {\n         $(\n-            #[stable]\n+            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n             impl<$($T:Clone),+> Clone for ($($T,)+) {\n                 fn clone(&self) -> ($($T,)+) {\n                     ($(e!(self.$idx.clone()),)+)\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n             impl<$($T:PartialEq),+> PartialEq for ($($T,)+) {\n                 #[inline]\n                 fn eq(&self, other: &($($T,)+)) -> bool {\n@@ -74,10 +74,10 @@ macro_rules! tuple_impls {\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n             impl<$($T:Eq),+> Eq for ($($T,)+) {}\n \n-            #[stable]\n+            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n             impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+) {\n                 #[inline]\n                 fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n@@ -101,17 +101,17 @@ macro_rules! tuple_impls {\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n             impl<$($T:Ord),+> Ord for ($($T,)+) {\n                 #[inline]\n                 fn cmp(&self, other: &($($T,)+)) -> Ordering {\n                     lexical_cmp!($(self.$idx, other.$idx),+)\n                 }\n             }\n \n-            #[stable]\n+            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n             impl<$($T:Default),+> Default for ($($T,)+) {\n-                #[stable]\n+                #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n                 #[inline]\n                 fn default() -> ($($T,)+) {\n                     ($({ let x: $T = Default::default(); x},)+)"}, {"sha": "4a23eb65268351c29b317ea1981bcefaa1cbe414", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -15,7 +15,7 @@\n //! [mz]: https://code.google.com/p/miniz/\n \n #![crate_name = \"flate\"]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![staged_api]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![allow(unstable)]"}, {"sha": "3a52ead26b5649ce0d7afb6c046b350e498ed43c", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -15,7 +15,7 @@\n //! generated instead.\n \n #![crate_name = \"fmt_macros\"]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]"}, {"sha": "1f069b5c94c14e6ef7045d296c0a73c92350dd04", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -78,7 +78,8 @@\n //! ```\n \n #![crate_name = \"getopts\"]\n-#![unstable = \"use the crates.io `getopts` library instead\"]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+            reason = \"use the crates.io `getopts` library instead\")]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -538,7 +539,8 @@ pub fn opt(short_name: &str,\n \n impl Fail {\n     /// Convert a `Fail` enum into an error string.\n-    #[deprecated=\"use `fmt::String` (`{}` format specifier)\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\",\n+                 reason = \"use `fmt::String` (`{}` format specifier)\")]\n     pub fn to_err_msg(self) -> String {\n         self.to_string()\n     }"}, {"sha": "cff042271b15748aa6acbdee0df7f2b9cf44df29", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -265,7 +265,7 @@\n //! * [DOT language](http://www.graphviz.org/doc/info/lang.html)\n \n #![crate_name = \"graphviz\"]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]"}, {"sha": "e93159eca2119e2927420697fc71a643cac11d3f", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deprecated = \"use std::vec::CowVec\"]\n+#![deprecated(feature = \"oldstuff\", since = \"1.0.0\", reason = \"use std::vec::CowVec\")]\n \n pub use self::MaybeOwnedVector::*;\n "}, {"sha": "fc90a1905a8d698f3cef9515dda84be068904bf4", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,7 +10,8 @@\n \n #![crate_name = \"libc\"]\n #![crate_type = \"rlib\"]\n-#![cfg_attr(not(feature = \"cargo-build\"), unstable)]\n+#![cfg_attr(not(feature = \"cargo-build\"),\n+            unstable(feature = \"unnamed_feature\", since = \"1.0.0\"))]\n #![cfg_attr(not(feature = \"cargo-build\"), staged_api)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![allow(unstable)]"}, {"sha": "872d46c4324364dc3e7be53225b17f349083c87e", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -156,7 +156,8 @@\n //! if logging is disabled, none of the components of the log will be executed.\n \n #![crate_name = \"log\"]\n-#![unstable = \"use the crates.io `log` library instead\"]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+            reason = \"use the crates.io `log` library instead\")]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]"}, {"sha": "c03dbc280d35442363bfca9de8db9a6307093f06", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -17,7 +17,7 @@\n //! internally. The `IndependentSample` trait is for generating values\n //! that do not need to record state.\n \n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n \n use core::prelude::*;\n use core::num::{Float, Int};"}, {"sha": "e8a1cb2a18d8b97229c16d967041e7a6d66cb6cc", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -25,7 +25,7 @@\n #![allow(unknown_features)] #![feature(int_uint)]\n #![allow(unstable)]\n #![no_std]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![staged_api]\n \n #[macro_use]"}, {"sha": "d248cb888fcaab4f282bd4e8b470e3d609d17d35", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -141,9 +141,9 @@ impl<R: Rng + Default> Reseeder<R> for ReseedWithDefault {\n         *rng = Default::default();\n     }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl Default for ReseedWithDefault {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn default() -> ReseedWithDefault { ReseedWithDefault }\n }\n "}, {"sha": "2eedc0d8f8f28652d7808fd44fb08d35f6a3447a", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -16,7 +16,7 @@\n //!     http://www.matroska.org/technical/specs/rfc/index.html\n \n #![crate_name = \"rbml\"]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]"}, {"sha": "0b7ebc90bec70fe45a17b3ac2ae38e7393d69509", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -16,7 +16,8 @@\n #![crate_name = \"regex\"]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n-#![unstable = \"use the crates.io `regex` library instead\"]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+            reason = \"use the crates.io `regex` library instead\")]\n #![staged_api]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\","}, {"sha": "86329e365f5f3e94c08b31dfef8a02ffb50b26a6", "filename": "src/libregex/re.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -255,7 +255,7 @@ impl Regex {\n     }\n \n     #[doc(hidden)]\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn names_iter<'a>(&'a self) -> NamesIter<'a> {\n         match *self {\n             Native(ref n) => NamesIterNative(n.names.iter()),"}, {"sha": "ffde64957171e369e5d16683abef1af8a7ae5a3c", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -15,7 +15,7 @@\n //! This API is completely unstable and subject to change.\n \n #![crate_name = \"rustc\"]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]"}, {"sha": "23eda47303e2bbbc3ef6c8dd19514519fba105af", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -1637,19 +1637,15 @@ declare_lint! {\n /// Checks for use of items with `#[deprecated]`, `#[unstable]` and\n /// `#[unstable]` attributes, or no stability attribute.\n #[derive(Copy)]\n-pub struct Stability { this_crate_staged: bool }\n+pub struct Stability;\n \n impl Stability {\n-    pub fn new() -> Stability { Stability { this_crate_staged: false } }\n-\n     fn lint(&self, cx: &Context, id: ast::DefId, span: Span) {\n \n+        if !stability::is_staged_api(cx.tcx, id) { return  }\n+\n         let ref stability = stability::lookup(cx.tcx, id);\n         let cross_crate = !ast_util::is_local(id);\n-        let staged = (!cross_crate && self.this_crate_staged)\n-            || (cross_crate && stability::is_staged_api(cx.tcx, id));\n-\n-        if !staged { return }\n \n         // stability attributes are promises made across crates; only\n         // check DEPRECATED for crate-local usage.\n@@ -1668,7 +1664,7 @@ impl Stability {\n         fn output(cx: &Context, span: Span, stability: &Option<attr::Stability>,\n                   lint: &'static Lint, label: &'static str) {\n             let msg = match *stability {\n-                Some(attr::Stability { text: Some(ref s), .. }) => {\n+                Some(attr::Stability { reason: Some(ref s), .. }) => {\n                     format!(\"use of {} item: {}\", label, *s)\n                 }\n                 _ => format!(\"use of {} item\", label)\n@@ -1690,22 +1686,6 @@ impl LintPass for Stability {\n         lint_array!(DEPRECATED, UNSTABLE)\n     }\n \n-    fn check_crate(&mut self, _: &Context, c: &ast::Crate) {\n-        // Just mark the #[staged_api] attribute used, though nothing else is done\n-        // with it during this pass over the source.\n-        for attr in c.attrs.iter() {\n-            if attr.name().get() == \"staged_api\" {\n-                match attr.node.value.node {\n-                    ast::MetaWord(_) => {\n-                        attr::mark_used(attr);\n-                        self.this_crate_staged = true;\n-                    }\n-                    _ => (/*pass*/)\n-                }\n-            }\n-        }\n-    }\n-\n     fn check_view_item(&mut self, cx: &Context, item: &ast::ViewItem) {\n         // compiler-generated `extern crate` statements have a dummy span.\n         if item.span == DUMMY_SP { return }"}, {"sha": "17d4e0595095e800c2177bafe54ac6be212dee4d", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -211,13 +211,13 @@ impl LintStore {\n                      UnusedAllocation,\n                      MissingCopyImplementations,\n                      UnstableFeatures,\n+                     Stability,\n         );\n \n         add_builtin_with_new!(sess,\n                               TypeLimits,\n                               RawPointerDerive,\n                               MissingDoc,\n-                              Stability,\n         );\n \n         add_lint_group!(sess, \"bad_style\","}, {"sha": "9f12d849e741f7bbc95149234f0217c79c2f272b", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -11,6 +11,7 @@\n //! A pass that annotates every item and method with its stability level,\n //! propagating default levels lexically from parent to children ast nodes.\n \n+use session::Session;\n use middle::ty;\n use metadata::csearch;\n use syntax::codemap::Span;\n@@ -20,7 +21,7 @@ use syntax::ast::{Attribute, Block, Crate, DefId, FnDecl, NodeId, Variant};\n use syntax::ast::{Item, RequiredMethod, ProvidedMethod, TraitItem};\n use syntax::ast::{TypeMethod, Method, Generics, StructField, TypeTraitItem};\n use syntax::ast_util::is_local;\n-use syntax::attr::Stability;\n+use syntax::attr::{Stability, AttrMetaMethods};\n use syntax::visit::{FnKind, FkMethod, Visitor};\n use util::nodemap::{NodeMap, DefIdMap};\n use util::ppaux::Repr;\n@@ -29,30 +30,33 @@ use std::mem::replace;\n \n /// A stability index, giving the stability level for items and methods.\n pub struct Index {\n+    // Indicates whether this crate has #![staged_api]\n+    staged_api: bool,\n     // stability for crate-local items; unmarked stability == no entry\n     local: NodeMap<Stability>,\n     // cache for extern-crate items; unmarked stability == entry with None\n     extern_cache: DefIdMap<Option<Stability>>\n }\n \n // A private tree-walker for producing an Index.\n-struct Annotator {\n+struct Annotator<'a> {\n+    sess: &'a Session,\n     index: Index,\n     parent: Option<Stability>\n }\n \n-impl Annotator {\n+impl<'a> Annotator<'a> {\n     // Determine the stability for a node based on its attributes and inherited\n     // stability. The stability is recorded in the index and used as the parent.\n     fn annotate<F>(&mut self, id: NodeId, use_parent: bool,\n                    attrs: &Vec<Attribute>, f: F) where\n         F: FnOnce(&mut Annotator),\n     {\n-        match attr::find_stability(attrs.as_slice()) {\n+        match attr::find_stability(self.sess.diagnostic(), attrs.as_slice()) {\n             Some(stab) => {\n                 self.index.local.insert(id, stab.clone());\n \n-                // Don't inherit #[stable]\n+                // Don't inherit #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n                 if stab.level != attr::Stable {\n                     let parent = replace(&mut self.parent, Some(stab));\n                     f(self);\n@@ -71,7 +75,7 @@ impl Annotator {\n     }\n }\n \n-impl<'v> Visitor<'v> for Annotator {\n+impl<'a, 'v> Visitor<'v> for Annotator<'a> {\n     fn visit_item(&mut self, i: &Item) {\n         // FIXME (#18969): the following is a hack around the fact\n         // that we cannot currently annotate the stability of\n@@ -138,12 +142,30 @@ impl<'v> Visitor<'v> for Annotator {\n \n impl Index {\n     /// Construct the stability index for a crate being compiled.\n-    pub fn build(krate: &Crate) -> Index {\n+    pub fn build(sess: &Session, krate: &Crate) -> Index {\n+        let mut staged_api = false;\n+        for attr in krate.attrs.iter() {\n+            if attr.name().get() == \"staged_api\" {\n+                match attr.node.value.node {\n+                    ast::MetaWord(_) => {\n+                        attr::mark_used(attr);\n+                        staged_api = true;\n+                    }\n+                    _ => (/*pass*/)\n+                }\n+            }\n+        }\n+        let index = Index {\n+            staged_api: staged_api,\n+            local: NodeMap(),\n+            extern_cache: DefIdMap()\n+        };\n+        if !staged_api {\n+            return index;\n+        }\n         let mut annotator = Annotator {\n-            index: Index {\n-                local: NodeMap(),\n-                extern_cache: DefIdMap()\n-            },\n+            sess: sess,\n+            index: index,\n             parent: None\n         };\n         annotator.annotate(ast::CRATE_NODE_ID, true, &krate.attrs,\n@@ -197,8 +219,7 @@ pub fn is_staged_api(tcx: &ty::ctxt, id: DefId) -> bool {\n                 is_staged_api(tcx, trait_method_id)\n             }\n         _ if is_local(id) => {\n-            // Unused case\n-            unreachable!()\n+            tcx.stability.borrow().staged_api\n         }\n         _ => {\n             csearch::is_staged_api(&tcx.sess.cstore, id)"}, {"sha": "3e33dfcef5a842937cac30cb27dc3cfc3db3b77e", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -22,7 +22,7 @@\n //! build speedups.\n \n #![crate_name = \"rustc_back\"]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]"}, {"sha": "63d97b1ebe5670b9d590c9dddb25540652932519", "filename": "src/librustc_bitflags/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc_bitflags%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc_bitflags%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_bitflags%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n #![crate_name = \"rustc_bitflags\"]\n-#![unstable]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![no_std]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n \n //! A typesafe bitmask flag generator.\n "}, {"sha": "4c7454bca7b7ac431e1a516e7d068e3ebc9d19ae", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![crate_name = \"rustc_borrowck\"]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]"}, {"sha": "9c5756f8095d890e9077034372f2a124a6af8538", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -599,7 +599,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n          middle::check_loop::check_crate(&sess, krate));\n \n     let stability_index = time(time_passes, \"stability index\", (), |_|\n-                               stability::Index::build(krate));\n+                               stability::Index::build(&sess, krate));\n \n     time(time_passes, \"static item recursion checking\", (), |_|\n          middle::check_static_recursion::check_crate(&sess, krate, &def_map, &ast_map));"}, {"sha": "e35bc807d2828b9533165b090d4f3d0c603060f5", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -15,7 +15,7 @@\n //! This API is completely unstable and subject to change.\n \n #![crate_name = \"rustc_driver\"]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]"}, {"sha": "05ea7094c44c5c892d70fcdafcafd5ef1c6d321d", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -124,7 +124,7 @@ fn test_env<F>(source_string: &str,\n         resolve::resolve_crate(&sess, &ast_map, &lang_items, krate, resolve::MakeGlobMap::No);\n     let named_region_map = resolve_lifetime::krate(&sess, krate, &def_map);\n     let region_map = region::resolve_crate(&sess, krate);\n-    let stability_index = stability::Index::build(krate);\n+    let stability_index = stability::Index::build(&sess, krate);\n     let arenas = ty::CtxtArenas::new();\n     let tcx = ty::mk_ctxt(sess,\n                           &arenas,"}, {"sha": "93568f73f9d4fa3d1dd1bf3c8953a976319dd376", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -14,7 +14,7 @@\n #![allow(dead_code)]\n \n #![crate_name = \"rustc_llvm\"]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]"}, {"sha": "28841fc0076d61726520330d8bc87786fa9a4379", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![crate_name = \"rustc_privacy\"]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]"}, {"sha": "31a4cdfcae8966debf80d8f3befc764ca6d50f6b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![crate_name = \"rustc_resolve\"]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]"}, {"sha": "4ee2cf92e3d4c0ab090ae202d7c0229b05da0790", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -15,7 +15,7 @@\n //! This API is completely unstable and subject to change.\n \n #![crate_name = \"rustc_trans\"]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]"}, {"sha": "5022e301c2a349a06dcd54b00f1e3cb9d2b11155", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -64,7 +64,7 @@ This API is completely unstable and subject to change.\n */\n \n #![crate_name = \"rustc_typeck\"]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]"}, {"sha": "22c8e1f3b325c932332c170ad2189018d8075bd4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -33,6 +33,7 @@ use syntax::ast_util;\n use syntax::ast_util::PostExpansionMethod;\n use syntax::attr;\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n+use syntax::codemap;\n use syntax::codemap::{DUMMY_SP, Pos, Spanned};\n use syntax::parse::token::{self, InternedString, special_idents};\n use syntax::ptr::P;\n@@ -449,11 +450,13 @@ impl attr::AttrMetaMethods for Attribute {\n         }\n     }\n     fn meta_item_list<'a>(&'a self) -> Option<&'a [P<ast::MetaItem>]> { None }\n+    fn span(&self) -> codemap::Span { unimplemented!() }\n }\n impl<'a> attr::AttrMetaMethods for &'a Attribute {\n     fn name(&self) -> InternedString { (**self).name() }\n     fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n     fn meta_item_list(&self) -> Option<&[P<ast::MetaItem>]> { None }\n+    fn span(&self) -> codemap::Span { unimplemented!() }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n@@ -2483,15 +2486,19 @@ impl Clean<Item> for doctree::Macro {\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Stability {\n     pub level: attr::StabilityLevel,\n-    pub text: String\n+    pub feature: String,\n+    pub since: String,\n+    pub reason: String\n }\n \n impl Clean<Stability> for attr::Stability {\n     fn clean(&self, _: &DocContext) -> Stability {\n         Stability {\n             level: self.level,\n-            text: self.text.as_ref().map_or(\"\".to_string(),\n-                                            |interned| interned.get().to_string()),\n+            feature: self.feature.get().to_string(),\n+            since: self.since.get().to_string(),\n+            reason: self.reason.as_ref().map_or(\"\".to_string(),\n+                                                |interned| interned.get().to_string()),\n         }\n     }\n }"}, {"sha": "012b417a552c63300c469da5883b11c461ad9066", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -714,7 +714,7 @@ impl<'a> fmt::String for Stability<'a> {\n             Some(ref stability) => {\n                 write!(f, \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n                        lvl = stability.level,\n-                       reason = stability.text)\n+                       reason = stability.reason)\n             }\n             None => Ok(())\n         }\n@@ -728,8 +728,8 @@ impl<'a> fmt::String for ConciseStability<'a> {\n             Some(ref stability) => {\n                 write!(f, \"<a class='stability {lvl}' title='{lvl}{colon}{reason}'></a>\",\n                        lvl = stability.level,\n-                       colon = if stability.text.len() > 0 { \": \" } else { \"\" },\n-                       reason = stability.text)\n+                       colon = if stability.reason.len() > 0 { \": \" } else { \"\" },\n+                       reason = stability.reason)\n             }\n             None => {\n                 write!(f, \"<a class='stability Unmarked' title='No stability level'></a>\")"}, {"sha": "c362376620a4600f95d4076357d2069bda5f653d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![crate_name = \"rustdoc\"]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]"}, {"sha": "1fd2b6b5d9a206a2de9e5152f675e9a221b20e93", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -15,7 +15,8 @@ Core encoding and decoding interfaces.\n */\n \n #![crate_name = \"serialize\"]\n-#![unstable = \"deprecated in favor of rustc-serialize on crates.io\"]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+            reason = \"deprecated in favor of rustc-serialize on crates.io\")]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]"}, {"sha": "9e301bf9c04f45211f9a0970c78c132f275c1780", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -12,7 +12,8 @@\n \n //! Operations on ASCII strings and characters\n \n-#![unstable = \"unsure about placement and naming\"]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+            reason = \"unsure about placement and naming\")]\n \n use iter::IteratorExt;\n use ops::FnMut;\n@@ -22,7 +23,8 @@ use string::String;\n use vec::Vec;\n \n /// Extension methods for ASCII-subset only operations on owned strings\n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"would prefer to do this in a more general way\")]\n pub trait OwnedAsciiExt {\n     /// Convert the string to ASCII upper case:\n     /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n@@ -36,7 +38,8 @@ pub trait OwnedAsciiExt {\n }\n \n /// Extension methods for ASCII-subset only operations on string slices\n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"would prefer to do this in a more general way\")]\n pub trait AsciiExt<T = Self> {\n     /// Check if within the ASCII range.\n     fn is_ascii(&self) -> bool;\n@@ -57,7 +60,8 @@ pub trait AsciiExt<T = Self> {\n     fn eq_ignore_ascii_case(&self, other: &Self) -> bool;\n }\n \n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"would prefer to do this in a more general way\")]\n impl AsciiExt<String> for str {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n@@ -82,7 +86,8 @@ impl AsciiExt<String> for str {\n     }\n }\n \n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"would prefer to do this in a more general way\")]\n impl OwnedAsciiExt for String {\n     #[inline]\n     fn into_ascii_uppercase(self) -> String {\n@@ -97,7 +102,8 @@ impl OwnedAsciiExt for String {\n     }\n }\n \n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"would prefer to do this in a more general way\")]\n impl AsciiExt<Vec<u8>> for [u8] {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n@@ -123,7 +129,8 @@ impl AsciiExt<Vec<u8>> for [u8] {\n     }\n }\n \n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"would prefer to do this in a more general way\")]\n impl OwnedAsciiExt for Vec<u8> {\n     #[inline]\n     fn into_ascii_uppercase(mut self) -> Vec<u8> {\n@@ -142,7 +149,8 @@ impl OwnedAsciiExt for Vec<u8> {\n     }\n }\n \n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"would prefer to do this in a more general way\")]\n impl AsciiExt for u8 {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n@@ -165,7 +173,8 @@ impl AsciiExt for u8 {\n     }\n }\n \n-#[unstable = \"would prefer to do this in a more general way\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"would prefer to do this in a more general way\")]\n impl AsciiExt for char {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n@@ -207,7 +216,8 @@ impl AsciiExt for char {\n /// - Any other chars in the range [0x20,0x7e] are not escaped.\n /// - Any other chars are given hex escapes.\n /// - Unicode escapes are never generated by this function.\n-#[unstable = \"needs to be updated to use an iterator\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"needs to be updated to use an iterator\")]\n pub fn escape_default<F>(c: u8, mut f: F) where\n     F: FnMut(u8),\n {"}, {"sha": "6ec1299aac5f14f94281c00bb1af90226477116a", "filename": "src/libstd/bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -11,5 +11,5 @@\n //! The boolean type\n \n #![doc(primitive = \"bool\")]\n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n "}, {"sha": "6690d3bd374a134edcfee1a72f8750faece7f0e8", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 71, "deletions": 58, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -296,7 +296,7 @@ fn test_resize_policy() {\n /// }\n /// ```\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct HashMap<K, V, S = RandomState> {\n     // All hashes are keyed on these values, to prevent hash collision attacks.\n     hash_state: S,\n@@ -499,7 +499,7 @@ impl<K: Hash<Hasher> + Eq, V> HashMap<K, V, RandomState> {\n     /// let mut map: HashMap<&str, int> = HashMap::new();\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new() -> HashMap<K, V, RandomState> {\n         Default::default()\n     }\n@@ -513,7 +513,7 @@ impl<K: Hash<Hasher> + Eq, V> HashMap<K, V, RandomState> {\n     /// let mut map: HashMap<&str, int> = HashMap::with_capacity(10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> HashMap<K, V, RandomState> {\n         HashMap::with_capacity_and_hash_state(capacity, Default::default())\n     }\n@@ -539,7 +539,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// map.insert(1i, 2u);\n     /// ```\n     #[inline]\n-    #[unstable = \"hasher stuff is unclear\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"hasher stuff is unclear\")]\n     pub fn with_hash_state(hash_state: S) -> HashMap<K, V, S> {\n         HashMap {\n             hash_state:    hash_state,\n@@ -567,7 +567,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// map.insert(1i, 2u);\n     /// ```\n     #[inline]\n-    #[unstable = \"hasher stuff is unclear\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"hasher stuff is unclear\")]\n     pub fn with_capacity_and_hash_state(capacity: uint, hash_state: S)\n                                         -> HashMap<K, V, S> {\n         let resize_policy = DefaultResizePolicy::new();\n@@ -591,7 +591,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert!(map.capacity() >= 100);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.resize_policy.usable_capacity(self.table.capacity())\n     }\n@@ -611,7 +611,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// let mut map: HashMap<&str, int> = HashMap::new();\n     /// map.reserve(10);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         let new_size = self.len().checked_add(additional).expect(\"capacity overflow\");\n         let min_cap = self.resize_policy.min_capacity(new_size);\n@@ -723,7 +723,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// map.shrink_to_fit();\n     /// assert!(map.capacity() >= 2);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         let min_capacity = self.resize_policy.min_capacity(self.len());\n         let min_capacity = max(min_capacity.next_power_of_two(), INITIAL_CAPACITY);\n@@ -817,7 +817,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///     println!(\"{}\", key);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((&'a K,&'a V)) -> &'a K = first; // coerce to fn ptr\n@@ -842,7 +842,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///     println!(\"{}\", key);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n         let second: fn((&'a K,&'a V)) -> &'a V = second; // coerce to fn ptr\n@@ -867,7 +867,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///     println!(\"key: {} val: {}\", key, val);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<K, V> {\n         Iter { inner: self.table.iter() }\n     }\n@@ -895,7 +895,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///     println!(\"key: {} val: {}\", key, val);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<K, V> {\n         IterMut { inner: self.table.iter_mut() }\n     }\n@@ -917,7 +917,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// // Not possible with .iter()\n     /// let vec: Vec<(&str, int)> = map.into_iter().collect();\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<K, V> {\n         fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n         let last_two: fn((SafeHash, K, V)) -> (K, V) = last_two;\n@@ -928,7 +928,8 @@ impl<K, V, S, H> HashMap<K, V, S>\n     }\n \n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n-    #[unstable = \"precise API still being fleshed out\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"precise API still being fleshed out\")]\n     pub fn entry<'a>(&'a mut self, key: K) -> Entry<'a, K, V>\n     {\n         // Gotta resize now.\n@@ -950,7 +951,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// a.insert(1u, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.table.size() }\n \n     /// Return true if the map contains no elements.\n@@ -966,7 +967,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert!(!a.is_empty());\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n@@ -989,7 +990,8 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert!(a.is_empty());\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<K, V> {\n         fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n         let last_two: fn((SafeHash, K, V)) -> (K, V) = last_two; // coerce to fn pointer\n@@ -1012,7 +1014,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     #[inline]\n     pub fn clear(&mut self) {\n         self.drain();\n@@ -1034,7 +1036,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert_eq!(map.get(&1), Some(&\"a\"));\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n         where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n@@ -1057,7 +1059,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert_eq!(map.contains_key(&1), true);\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n         where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n@@ -1083,7 +1085,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// }\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n         where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n@@ -1106,7 +1108,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n         let hash = self.make_hash(&k);\n         self.reserve(1);\n@@ -1135,7 +1137,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert_eq!(map.remove(&1), Some(\"a\"));\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n         where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n@@ -1208,14 +1210,14 @@ impl<K, V, S, H> PartialEq for HashMap<K, V, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K, V, S, H> Eq for HashMap<K, V, S>\n     where K: Eq + Hash<H>, V: Eq,\n           S: HashState<Hasher=H>,\n           H: hash::Hasher<Output=u64>\n {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K, V, S, H> Show for HashMap<K, V, S>\n     where K: Eq + Hash<H> + Show, V: Show,\n           S: HashState<Hasher=H>,\n@@ -1233,7 +1235,7 @@ impl<K, V, S, H> Show for HashMap<K, V, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K, V, S, H> Default for HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           S: HashState<Hasher=H> + Default,\n@@ -1244,7 +1246,7 @@ impl<K, V, S, H> Default for HashMap<K, V, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K, Q: ?Sized, V, S, H> Index<Q> for HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           Q: Eq + Hash<H> + BorrowFrom<K>,\n@@ -1259,7 +1261,7 @@ impl<K, Q: ?Sized, V, S, H> Index<Q> for HashMap<K, V, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K, V, S, H, Q: ?Sized> IndexMut<Q> for HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           Q: Eq + Hash<H> + BorrowFrom<K>,\n@@ -1275,7 +1277,7 @@ impl<K, V, S, H, Q: ?Sized> IndexMut<Q> for HashMap<K, V, S>\n }\n \n /// HashMap iterator\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n     inner: table::Iter<'a, K, V>\n }\n@@ -1290,13 +1292,13 @@ impl<'a, K, V> Clone for Iter<'a, K, V> {\n }\n \n /// HashMap mutable values iterator\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     inner: table::IterMut<'a, K, V>\n }\n \n /// HashMap move iterator\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n     inner: iter::Map<\n         (SafeHash, K, V),\n@@ -1307,7 +1309,7 @@ pub struct IntoIter<K, V> {\n }\n \n /// HashMap keys iterator\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a K, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n }\n@@ -1322,7 +1324,7 @@ impl<'a, K, V> Clone for Keys<'a, K, V> {\n }\n \n /// HashMap values iterator\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n@@ -1337,7 +1339,8 @@ impl<'a, K, V> Clone for Values<'a, K, V> {\n }\n \n /// HashMap drain iterator\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"matches collection reform specification, waiting for dust to settle\")]\n pub struct Drain<'a, K: 'a, V: 'a> {\n     inner: iter::Map<\n         (SafeHash, K, V),\n@@ -1348,21 +1351,24 @@ pub struct Drain<'a, K: 'a, V: 'a> {\n }\n \n /// A view into a single occupied location in a HashMap\n-#[unstable = \"precise API still being fleshed out\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"precise API still being fleshed out\")]\n pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n }\n \n /// A view into a single empty location in a HashMap\n-#[unstable = \"precise API still being fleshed out\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"precise API still being fleshed out\")]\n pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     hash: SafeHash,\n     key: K,\n     elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n }\n \n /// A view into a single location in a map, which may be vacant or occupied\n-#[unstable = \"precise API still being fleshed out\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"precise API still being fleshed out\")]\n pub enum Entry<'a, K: 'a, V: 'a> {\n     /// An occupied Entry\n     Occupied(OccupiedEntry<'a, K, V>),\n@@ -1379,79 +1385,80 @@ enum VacantEntryState<K, V, M> {\n     NoElem(EmptyBucket<K, V, M>),\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n     #[inline] fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n     #[inline] fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K, V> Iterator for IntoIter<K, V> {\n     type Item = (K, V);\n \n     #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     type Item = &'a K;\n \n     #[inline] fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Values<'a, K, V> {\n     type Item = &'a V;\n \n     #[inline] fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Drain<'a, K, V> {\n     type Item = (K, V);\n \n     #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n impl<'a, K, V> Entry<'a, K, V> {\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n     pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> {\n@@ -1462,7 +1469,8 @@ impl<'a, K, V> Entry<'a, K, V> {\n     }\n }\n \n-#[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// Gets a reference to the value in the entry\n     pub fn get(&self) -> &V {\n@@ -1493,7 +1501,8 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     }\n }\n \n-#[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it\n@@ -1509,7 +1518,7 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K, V, S, H> FromIterator<(K, V)> for HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           S: HashState<Hasher=H> + Default,\n@@ -1524,7 +1533,7 @@ impl<K, V, S, H> FromIterator<(K, V)> for HashMap<K, V, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K, V, S, H> Extend<(K, V)> for HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -1545,13 +1554,15 @@ impl<K, V, S, H> Extend<(K, V)> for HashMap<K, V, S>\n /// instances are unlikely to produce the same result for the same values.\n #[derive(Clone)]\n #[allow(missing_copy_implementations)]\n-#[unstable = \"hashing an hash maps may be altered\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"hashing an hash maps may be altered\")]\n pub struct RandomState {\n     k0: u64,\n     k1: u64,\n }\n \n-#[unstable = \"hashing an hash maps may be altered\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"hashing an hash maps may be altered\")]\n impl RandomState {\n     /// Construct a new `RandomState` that is initialized with random keys.\n     #[inline]\n@@ -1561,15 +1572,17 @@ impl RandomState {\n     }\n }\n \n-#[unstable = \"hashing an hash maps may be altered\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"hashing an hash maps may be altered\")]\n impl HashState for RandomState {\n     type Hasher = Hasher;\n     fn hasher(&self) -> Hasher {\n         Hasher { inner: SipHasher::new_with_keys(self.k0, self.k1) }\n     }\n }\n \n-#[unstable = \"hashing an hash maps may be altered\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"hashing an hash maps may be altered\")]\n impl Default for RandomState {\n     #[inline]\n     fn default() -> RandomState {"}, {"sha": "c4fecc00bbd60d25fdb18c3fcd365b99e9d00d96", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 53, "deletions": 52, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -90,7 +90,7 @@ use super::state::HashState;\n /// }\n /// ```\n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct HashSet<T, S = RandomState> {\n     map: HashMap<T, (), S>\n }\n@@ -105,7 +105,7 @@ impl<T: Hash<Hasher> + Eq> HashSet<T, RandomState> {\n     /// let mut set: HashSet<int> = HashSet::new();\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new() -> HashSet<T, RandomState> {\n         HashSet::with_capacity(INITIAL_CAPACITY)\n     }\n@@ -120,7 +120,7 @@ impl<T: Hash<Hasher> + Eq> HashSet<T, RandomState> {\n     /// let mut set: HashSet<int> = HashSet::with_capacity(10);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> HashSet<T, RandomState> {\n         HashSet { map: HashMap::with_capacity(capacity) }\n     }\n@@ -147,7 +147,7 @@ impl<T, S, H> HashSet<T, S>\n     /// set.insert(2u);\n     /// ```\n     #[inline]\n-    #[unstable = \"hasher stuff is unclear\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"hasher stuff is unclear\")]\n     pub fn with_hash_state(hash_state: S) -> HashSet<T, S> {\n         HashSet::with_capacity_and_hash_state(INITIAL_CAPACITY, hash_state)\n     }\n@@ -171,7 +171,7 @@ impl<T, S, H> HashSet<T, S>\n     /// set.insert(1i);\n     /// ```\n     #[inline]\n-    #[unstable = \"hasher stuff is unclear\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"hasher stuff is unclear\")]\n     pub fn with_capacity_and_hash_state(capacity: uint, hash_state: S)\n                                         -> HashSet<T, S> {\n         HashSet {\n@@ -189,7 +189,7 @@ impl<T, S, H> HashSet<T, S>\n     /// assert!(set.capacity() >= 100);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.map.capacity()\n     }\n@@ -209,7 +209,7 @@ impl<T, S, H> HashSet<T, S>\n     /// let mut set: HashSet<int> = HashSet::new();\n     /// set.reserve(10);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         self.map.reserve(additional)\n     }\n@@ -230,7 +230,7 @@ impl<T, S, H> HashSet<T, S>\n     /// set.shrink_to_fit();\n     /// assert!(set.capacity() >= 2);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         self.map.shrink_to_fit()\n     }\n@@ -251,7 +251,7 @@ impl<T, S, H> HashSet<T, S>\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { iter: self.map.keys() }\n     }\n@@ -276,7 +276,7 @@ impl<T, S, H> HashSet<T, S>\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((T, ())) -> T = first;\n@@ -306,7 +306,7 @@ impl<T, S, H> HashSet<T, S>\n     /// let diff: HashSet<int> = b.difference(&a).map(|&x| x).collect();\n     /// assert_eq!(diff, [4i].iter().map(|&x| x).collect());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a HashSet<T, S>) -> Difference<'a, T, S> {\n         Difference {\n             iter: self.iter(),\n@@ -334,7 +334,7 @@ impl<T, S, H> HashSet<T, S>\n     /// assert_eq!(diff1, diff2);\n     /// assert_eq!(diff1, [1i, 4].iter().map(|&x| x).collect());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, S>)\n         -> SymmetricDifference<'a, T, S> {\n         SymmetricDifference { iter: self.difference(other).chain(other.difference(self)) }\n@@ -357,7 +357,7 @@ impl<T, S, H> HashSet<T, S>\n     /// let diff: HashSet<int> = a.intersection(&b).map(|&x| x).collect();\n     /// assert_eq!(diff, [2i, 3].iter().map(|&x| x).collect());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a HashSet<T, S>) -> Intersection<'a, T, S> {\n         Intersection {\n             iter: self.iter(),\n@@ -382,7 +382,7 @@ impl<T, S, H> HashSet<T, S>\n     /// let diff: HashSet<int> = a.union(&b).map(|&x| x).collect();\n     /// assert_eq!(diff, [1i, 2, 3, 4].iter().map(|&x| x).collect());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a HashSet<T, S>) -> Union<'a, T, S> {\n         Union { iter: self.iter().chain(other.difference(self)) }\n     }\n@@ -399,7 +399,7 @@ impl<T, S, H> HashSet<T, S>\n     /// v.insert(1u);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.map.len() }\n \n     /// Returns true if the set contains no elements\n@@ -414,12 +414,13 @@ impl<T, S, H> HashSet<T, S>\n     /// v.insert(1u);\n     /// assert!(!v.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.map.len() == 0 }\n \n     /// Clears the set, returning all elements in an iterator.\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((T, ())) -> T = first; // coerce to fn pointer\n@@ -439,7 +440,7 @@ impl<T, S, H> HashSet<T, S>\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn clear(&mut self) { self.map.clear() }\n \n     /// Returns `true` if the set contains a value.\n@@ -457,7 +458,7 @@ impl<T, S, H> HashSet<T, S>\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n         where Q: BorrowFrom<T> + Hash<H> + Eq\n     {\n@@ -481,7 +482,7 @@ impl<T, S, H> HashSet<T, S>\n     /// b.insert(1);\n     /// assert_eq!(a.is_disjoint(&b), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_disjoint(&self, other: &HashSet<T, S>) -> bool {\n         self.iter().all(|v| !other.contains(v))\n     }\n@@ -502,7 +503,7 @@ impl<T, S, H> HashSet<T, S>\n     /// set.insert(4);\n     /// assert_eq!(set.is_subset(&sup), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_subset(&self, other: &HashSet<T, S>) -> bool {\n         self.iter().all(|v| other.contains(v))\n     }\n@@ -527,7 +528,7 @@ impl<T, S, H> HashSet<T, S>\n     /// assert_eq!(set.is_superset(&sub), true);\n     /// ```\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_superset(&self, other: &HashSet<T, S>) -> bool {\n         other.is_subset(self)\n     }\n@@ -546,7 +547,7 @@ impl<T, S, H> HashSet<T, S>\n     /// assert_eq!(set.insert(2), false);\n     /// assert_eq!(set.len(), 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()).is_none() }\n \n     /// Removes a value from the set. Returns `true` if the value was\n@@ -567,15 +568,15 @@ impl<T, S, H> HashSet<T, S>\n     /// assert_eq!(set.remove(&2), true);\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n         where Q: BorrowFrom<T> + Hash<H> + Eq\n     {\n         self.map.remove(value).is_some()\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T, S, H> PartialEq for HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -588,14 +589,14 @@ impl<T, S, H> PartialEq for HashSet<T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T, S, H> Eq for HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n           H: hash::Hasher<Output=u64>\n {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T, S, H> fmt::Show for HashSet<T, S>\n     where T: Eq + Hash<H> + fmt::Show,\n           S: HashState<Hasher=H>,\n@@ -613,7 +614,7 @@ impl<T, S, H> fmt::Show for HashSet<T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T, S, H> FromIterator<T> for HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H> + Default,\n@@ -627,7 +628,7 @@ impl<T, S, H> FromIterator<T> for HashSet<T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T, S, H> Extend<T> for HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -640,19 +641,19 @@ impl<T, S, H> Extend<T> for HashSet<T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T, S, H> Default for HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H> + Default,\n           H: hash::Hasher<Output=u64>\n {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn default() -> HashSet<T, S> {\n         HashSet::with_hash_state(Default::default())\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, 'b, T, S, H> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash<H> + Clone,\n           S: HashState<Hasher=H> + Default,\n@@ -685,7 +686,7 @@ impl<'a, 'b, T, S, H> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, 'b, T, S, H> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash<H> + Clone,\n           S: HashState<Hasher=H> + Default,\n@@ -718,7 +719,7 @@ impl<'a, 'b, T, S, H> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, 'b, T, S, H> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash<H> + Clone,\n           S: HashState<Hasher=H> + Default,\n@@ -751,7 +752,7 @@ impl<'a, 'b, T, S, H> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, 'b, T, S, H> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash<H> + Clone,\n           S: HashState<Hasher=H> + Default,\n@@ -785,25 +786,25 @@ impl<'a, 'b, T, S, H> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n }\n \n /// HashSet iterator\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a> {\n     iter: Keys<'a, K, ()>\n }\n \n /// HashSet move iterator\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct IntoIter<K> {\n     iter: Map<(K, ()), K, map::IntoIter<K, ()>, fn((K, ())) -> K>\n }\n \n /// HashSet drain iterator\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Drain<'a, K: 'a> {\n     iter: Map<(K, ()), K, map::Drain<'a, K, ()>, fn((K, ())) -> K>,\n }\n \n /// Intersection iterator\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Intersection<'a, T: 'a, S: 'a> {\n     // iterator of the first set\n     iter: Iter<'a, T>,\n@@ -812,7 +813,7 @@ pub struct Intersection<'a, T: 'a, S: 'a> {\n }\n \n /// Difference iterator\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Difference<'a, T: 'a, S: 'a> {\n     // iterator of the first set\n     iter: Iter<'a, T>,\n@@ -821,54 +822,54 @@ pub struct Difference<'a, T: 'a, S: 'a> {\n }\n \n /// Symmetric difference iterator.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct SymmetricDifference<'a, T: 'a, S: 'a> {\n     iter: Chain<Difference<'a, T, S>, Difference<'a, T, S>>\n }\n \n /// Set union iterator.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Union<'a, T: 'a, S: 'a> {\n     iter: Chain<Iter<'a, T>, Difference<'a, T, S>>\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K> Iterator for Iter<'a, K> {\n     type Item = &'a K;\n \n     fn next(&mut self) -> Option<&'a K> { self.iter.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K> ExactSizeIterator for Iter<'a, K> {\n     fn len(&self) -> usize { self.iter.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K> Iterator for IntoIter<K> {\n     type Item = K;\n \n     fn next(&mut self) -> Option<K> { self.iter.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<K> ExactSizeIterator for IntoIter<K> {\n     fn len(&self) -> usize { self.iter.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K> Iterator for Drain<'a, K> {\n     type Item = K;\n \n     fn next(&mut self) -> Option<K> { self.iter.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, K> ExactSizeIterator for Drain<'a, K> {\n     fn len(&self) -> usize { self.iter.len() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T, S, H> Iterator for Intersection<'a, T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -893,7 +894,7 @@ impl<'a, T, S, H> Iterator for Intersection<'a, T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T, S, H> Iterator for Difference<'a, T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -918,7 +919,7 @@ impl<'a, T, S, H> Iterator for Difference<'a, T, S>\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T, S, H> Iterator for SymmetricDifference<'a, T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -930,7 +931,7 @@ impl<'a, T, S, H> Iterator for SymmetricDifference<'a, T, S>\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T, S, H> Iterator for Union<'a, T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,"}, {"sha": "2e2d70546aeb6276e701e3ec479c2c960574ed6c", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -309,7 +309,7 @@\n //! }\n //! ```\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n pub use core_collections::Bound;\n pub use core_collections::{BinaryHeap, Bitv, BitvSet, BTreeMap, BTreeSet};\n@@ -323,21 +323,21 @@ pub use self::hash_set::HashSet;\n \n mod hash;\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub mod hash_map {\n     //! A hashmap\n     pub use super::hash::map::*;\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub mod hash_set {\n     //! A hashset\n     pub use super::hash::set::*;\n }\n \n /// Experimental support for providing custom hash algorithms to a HashMap and\n /// HashSet.\n-#[unstable = \"module was recently added\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"module was recently added\")]\n pub mod hash_state {\n     pub use super::hash::state::*;\n }"}, {"sha": "493f5ad2dc69cca790a31ee1f798be6472e16203", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -12,7 +12,7 @@\n //!\n //! A simple wrapper over the platform's dynamic library facilities\n \n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n use prelude::v1::*;"}, {"sha": "91603fb711981616830c55e8c51e1aa1435fc043", "filename": "src/libstd/error.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -78,15 +78,16 @@\n //! }\n //! ```\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use prelude::v1::*;\n \n use str::Utf8Error;\n use string::{FromUtf8Error, FromUtf16Error};\n \n /// Base functionality for all errors in Rust.\n-#[unstable = \"the exact API of this trait may change\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"the exact API of this trait may change\")]\n pub trait Error {\n     /// A short description of the error; usually a static string.\n     fn description(&self) -> &str;\n@@ -99,21 +100,21 @@ pub trait Error {\n }\n \n /// A trait for types that can be converted from a given error type `E`.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait FromError<E> {\n     /// Perform the conversion.\n     fn from_error(err: E) -> Self;\n }\n \n // Any type is convertable from itself\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<E> FromError<E> for E {\n     fn from_error(err: E) -> E {\n         err\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl Error for Utf8Error {\n     fn description(&self) -> &str {\n         match *self {\n@@ -125,13 +126,13 @@ impl Error for Utf8Error {\n     fn detail(&self) -> Option<String> { Some(self.to_string()) }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl Error for FromUtf8Error {\n     fn description(&self) -> &str { \"invalid utf-8\" }\n     fn detail(&self) -> Option<String> { Some(self.to_string()) }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl Error for FromUtf16Error {\n     fn description(&self) -> &str { \"invalid utf-16\" }\n }"}, {"sha": "e6b3348e6905b451cd064bd101d3a92859c01372", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n \n use prelude::v1::*;\n "}, {"sha": "6017a62e3bef4fa669aff8910d4af145ab0d062c", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,8 +10,9 @@\n \n //! Utilities related to FFI bindings.\n \n-#![unstable = \"module just underwent fairly large reorganization and the dust \\\n-               still needs to settle\"]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+            reason = \"module just underwent fairly large reorganization and the dust \\\n+                      still needs to settle\")]\n \n pub use self::c_str::CString;\n pub use self::c_str::c_str_to_bytes;"}, {"sha": "d28e84f3cdd4dead9f3f23782e973266683769cb", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -403,7 +403,7 @@\n //! them with the same character. For example, the `{` character is escaped with\n //! `{{` and the `}` character is escaped with `}}`.\n \n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n \n use string;\n \n@@ -432,8 +432,9 @@ pub use core::fmt::{argument, argumentuint};\n /// let s = fmt::format(format_args!(\"Hello, {}!\", \"world\"));\n /// assert_eq!(s, \"Hello, world!\".to_string());\n /// ```\n-#[unstable = \"this is an implementation detail of format! and should not \\\n-                  be called directly\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"this is an implementation detail of format! and should not \\\n+                     be called directly\")]\n pub fn format(args: Arguments) -> string::String {\n     let mut output = string::String::new();\n     let _ = write!(&mut output, \"{}\", args);"}, {"sha": "2cdad79c584465d33441ced4d5b6f923403723c1", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -134,7 +134,7 @@ impl ChanWriter {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl Clone for ChanWriter {\n     fn clone(&self) -> ChanWriter {\n         ChanWriter { tx: self.tx.clone() }"}, {"sha": "43d7db6cbbff85f89bdc0c47b11ba9ed0a13edc2", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -62,7 +62,8 @@ impl Writer for Vec<u8> {\n ///\n /// assert_eq!(w.into_inner(), vec!(0, 1, 2));\n /// ```\n-#[deprecated = \"use the Vec<u8> Writer implementation directly\"]\n+#[deprecated(feature = \"oldstuff\", since = \"1.0.0\",\n+             reason = \"use the Vec<u8> Writer implementation directly\")]\n #[derive(Clone)]\n pub struct MemWriter {\n     buf: Vec<u8>,"}, {"sha": "f680f8962381e5b0efccd88d888f289b33da50db", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -219,7 +219,7 @@\n //! concerned with error handling; instead its caller is responsible for\n //! responding to errors that may occur while attempting to read the numbers.\n \n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![deny(unused_must_use)]\n \n pub use self::SeekStyle::*;\n@@ -1744,15 +1744,15 @@ pub struct FileStat {\n     ///\n     /// Usage of this field is discouraged, but if access is desired then the\n     /// fields are located here.\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub unstable: UnstableFileStat,\n }\n \n /// This structure represents all of the possible information which can be\n /// returned from a `stat` syscall which is not contained in the `FileStat`\n /// structure. This information is not necessarily platform independent, and may\n /// have different meanings or no meaning at all on some platforms.\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #[derive(Copy, Hash)]\n pub struct UnstableFileStat {\n     /// The ID of the device containing the file.\n@@ -1815,9 +1815,9 @@ bitflags! {\n }\n \n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl Default for FilePermission {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     #[inline]\n     fn default() -> FilePermission { FilePermission::empty() }\n }"}, {"sha": "6705b22c92fa2d46dda0a96ac0c6a4c2d65e74e4", "filename": "src/libstd/io/net/pipe.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -68,7 +68,8 @@ impl UnixStream {\n     ///\n     /// If a `timeout` with zero or negative duration is specified then\n     /// the function returns `Err`, with the error kind set to `TimedOut`.\n-    #[unstable = \"the timeout argument is likely to change types\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"the timeout argument is likely to change types\")]\n     pub fn connect_timeout<P>(path: P, timeout: Duration)\n                               -> IoResult<UnixStream>\n                               where P: BytesContainer {\n@@ -107,23 +108,26 @@ impl UnixStream {\n     /// Sets the read/write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[unstable = \"the timeout argument may change in type and value\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"the timeout argument may change in type and value\")]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_timeout(timeout_ms)\n     }\n \n     /// Sets the read timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[unstable = \"the timeout argument may change in type and value\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"the timeout argument may change in type and value\")]\n     pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_read_timeout(timeout_ms)\n     }\n \n     /// Sets the write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[unstable = \"the timeout argument may change in type and value\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"the timeout argument may change in type and value\")]\n     pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_write_timeout(timeout_ms)\n     }\n@@ -217,8 +221,9 @@ impl UnixAcceptor {\n     /// When using this method, it is likely necessary to reset the timeout as\n     /// appropriate, the timeout specified is specific to this object, not\n     /// specific to the next request.\n-    #[unstable = \"the name and arguments to this function are likely \\\n-                      to change\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"the name and arguments to this function are likely \\\n+                         to change\")]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_timeout(timeout_ms)\n     }\n@@ -227,7 +232,7 @@ impl UnixAcceptor {\n     ///\n     /// This function has the same semantics as `TcpAcceptor::close_accept`, and\n     /// more information can be found in that documentation.\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn close_accept(&mut self) -> IoResult<()> {\n         self.inner.close_accept()\n     }"}, {"sha": "180deae6a25b8b4a7c1f67a9e83a9d856faab819", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -85,7 +85,8 @@ impl TcpStream {\n     ///\n     /// If a `timeout` with zero or negative duration is specified then\n     /// the function returns `Err`, with the error kind set to `TimedOut`.\n-    #[unstable = \"the timeout argument may eventually change types\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"the timeout argument may eventually change types\")]\n     pub fn connect_timeout<A: ToSocketAddr>(addr: A,\n                                             timeout: Duration) -> IoResult<TcpStream> {\n         if timeout <= Duration::milliseconds(0) {\n@@ -109,7 +110,7 @@ impl TcpStream {\n     }\n \n     /// Sets the nodelay flag on this connection to the boolean specified\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> {\n         self.inner.set_nodelay(nodelay)\n     }\n@@ -119,7 +120,7 @@ impl TcpStream {\n     /// If the value specified is `None`, then the keepalive flag is cleared on\n     /// this connection. Otherwise, the keepalive timeout will be set to the\n     /// specified time, in seconds.\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn set_keepalive(&mut self, delay_in_seconds: Option<uint>) -> IoResult<()> {\n         self.inner.set_keepalive(delay_in_seconds)\n     }\n@@ -187,7 +188,8 @@ impl TcpStream {\n     ///\n     /// For clarification on the semantics of interrupting a read and a write,\n     /// take a look at `set_read_timeout` and `set_write_timeout`.\n-    #[unstable = \"the timeout argument may change in type and value\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"the timeout argument may change in type and value\")]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_timeout(timeout_ms)\n     }\n@@ -204,7 +206,8 @@ impl TcpStream {\n     /// action is taken. Otherwise, the read operation will be scheduled to\n     /// promptly return. If a timeout error is returned, then no data was read\n     /// during the timeout period.\n-    #[unstable = \"the timeout argument may change in type and value\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"the timeout argument may change in type and value\")]\n     pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_read_timeout(timeout_ms)\n     }\n@@ -231,7 +234,8 @@ impl TcpStream {\n     /// does not know how many bytes were written as part of the timeout\n     /// operation. It may be the case that bytes continue to be written in an\n     /// asynchronous fashion after the call to write returns.\n-    #[unstable = \"the timeout argument may change in type and value\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"the timeout argument may change in type and value\")]\n     pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_write_timeout(timeout_ms)\n     }\n@@ -395,8 +399,9 @@ impl TcpAcceptor {\n     /// a.set_timeout(None);\n     /// let socket = a.accept();\n     /// ```\n-    #[unstable = \"the type of the argument and name of this function are \\\n-                      subject to change\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"the type of the argument and name of this function are \\\n+                         subject to change\")]\n     pub fn set_timeout(&mut self, ms: Option<u64>) { self.inner.set_timeout(ms); }\n \n     /// Closes the accepting capabilities of this acceptor.\n@@ -442,7 +447,7 @@ impl TcpAcceptor {\n     /// // Signal our accept loop to exit\n     /// assert!(a.close_accept().is_ok());\n     /// ```\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn close_accept(&mut self) -> IoResult<()> {\n         self.inner.close_accept()\n     }"}, {"sha": "a3e4eca10bc8dfc72ee0bb8edd4faa5efdc12253", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -92,63 +92,66 @@ impl UdpSocket {\n     }\n \n     /// Joins a multicast IP address (becomes a member of it)\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n         self.inner.join_multicast(multi)\n     }\n \n     /// Leaves a multicast IP address (drops membership from it)\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n         self.inner.leave_multicast(multi)\n     }\n \n     /// Set the multicast loop flag to the specified value\n     ///\n     /// This lets multicast packets loop back to local sockets (if enabled)\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn set_multicast_loop(&mut self, on: bool) -> IoResult<()> {\n         self.inner.set_multicast_loop(on)\n     }\n \n     /// Sets the multicast TTL\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn set_multicast_ttl(&mut self, ttl: int) -> IoResult<()> {\n         self.inner.multicast_time_to_live(ttl)\n     }\n \n     /// Sets this socket's TTL\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn set_ttl(&mut self, ttl: int) -> IoResult<()> {\n         self.inner.time_to_live(ttl)\n     }\n \n     /// Sets the broadcast flag on or off\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn set_broadcast(&mut self, broadcast: bool) -> IoResult<()> {\n         self.inner.set_broadcast(broadcast)\n     }\n \n     /// Sets the read/write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[unstable = \"the timeout argument may change in type and value\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"the timeout argument may change in type and value\")]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_timeout(timeout_ms)\n     }\n \n     /// Sets the read timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[unstable = \"the timeout argument may change in type and value\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"the timeout argument may change in type and value\")]\n     pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_read_timeout(timeout_ms)\n     }\n \n     /// Sets the write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[unstable = \"the timeout argument may change in type and value\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"the timeout argument may change in type and value\")]\n     pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_write_timeout(timeout_ms)\n     }"}, {"sha": "4762719a04ea50a7e465ec1ffeb5b88079aa21ce", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -691,7 +691,8 @@ impl Process {\n     ///     p.wait()\n     /// }\n     /// ```\n-    #[unstable = \"the type of the timeout is likely to change\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"the type of the timeout is likely to change\")]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.deadline = timeout_ms.map(|i| i + sys::timer::now()).unwrap_or(0);\n     }"}, {"sha": "a86a6eb4bfe05d0f1f4a7af40da1b5a99e14cd7b", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -95,7 +95,7 @@\n //! and `format!`, also available to all Rust code.\n \n #![crate_name = \"std\"]\n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -175,7 +175,7 @@ pub use alloc::rc;\n pub use core_collections::slice;\n pub use core_collections::str;\n pub use core_collections::string;\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub use core_collections::vec;\n \n pub use unicode::char;"}, {"sha": "16d11077080862ccbe46e22ca153014c916df6b5", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -14,7 +14,7 @@\n //! library. Each macro is available for use when linking against the standard\n //! library.\n \n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n \n /// The entry point for panic of Rust tasks.\n ///\n@@ -36,7 +36,7 @@\n /// panic!(\"this is a {} {message}\", \"fancy\", message = \"message\");\n /// ```\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n macro_rules! panic {\n     () => ({\n         panic!(\"explicit panic\")\n@@ -71,15 +71,15 @@ macro_rules! panic {\n /// format!(\"x = {}, y = {y}\", 10i, y = 30i);\n /// ```\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n macro_rules! format {\n     ($($arg:tt)*) => ($crate::fmt::format(format_args!($($arg)*)))\n }\n \n /// Equivalent to the `println!` macro except that a newline is not printed at\n /// the end of the message.\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n macro_rules! print {\n     ($($arg:tt)*) => ($crate::io::stdio::print_args(format_args!($($arg)*)))\n }\n@@ -97,7 +97,7 @@ macro_rules! print {\n /// println!(\"format {} arguments\", \"some\");\n /// ```\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n macro_rules! println {\n     ($($arg:tt)*) => ($crate::io::stdio::println_args(format_args!($($arg)*)))\n }\n@@ -106,7 +106,7 @@ macro_rules! println {\n /// error if the value of the expression is `Err`. For more information, see\n /// `std::io`.\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n macro_rules! try {\n     ($expr:expr) => (match $expr {\n         $crate::result::Result::Ok(val) => val,\n@@ -148,7 +148,7 @@ macro_rules! try {\n ///\n /// For more information about select, see the `std::sync::mpsc::Select` structure.\n #[macro_export]\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n macro_rules! select {\n     (\n         $($name:pat = $rx:ident.$meth:ident() => $code:expr),+"}, {"sha": "a9e40e963327fead6ed527609a19a207f7788427", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for 32-bits floats (`f32` type)\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n #![allow(unsigned_negation)]\n #![doc(primitive = \"f32\")]\n@@ -73,7 +73,7 @@ mod cmath {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl Float for f32 {\n     #[inline]\n     fn nan() -> f32 { num::Float::nan() }\n@@ -366,7 +366,7 @@ impl Float for f32 {\n ///\n /// * num - The float value\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"may be removed or relocated\")]\n pub fn to_string(num: f32) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigAll, ExpNone, false);\n@@ -379,7 +379,7 @@ pub fn to_string(num: f32) -> String {\n ///\n /// * num - The float value\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"may be removed or relocated\")]\n pub fn to_str_hex(num: f32) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 16u, true, SignNeg, DigAll, ExpNone, false);\n@@ -394,7 +394,7 @@ pub fn to_str_hex(num: f32) -> String {\n /// * num - The float value\n /// * radix - The base to use\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"may be removed or relocated\")]\n pub fn to_str_radix_special(num: f32, rdx: uint) -> (String, bool) {\n     strconv::float_to_str_common(num, rdx, true, SignNeg, DigAll, ExpNone, false)\n }\n@@ -407,7 +407,7 @@ pub fn to_str_radix_special(num: f32, rdx: uint) -> (String, bool) {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"may be removed or relocated\")]\n pub fn to_str_exact(num: f32, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigExact(dig), ExpNone, false);\n@@ -422,7 +422,7 @@ pub fn to_str_exact(num: f32, dig: uint) -> String {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"may be removed or relocated\")]\n pub fn to_str_digits(num: f32, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigMax(dig), ExpNone, false);\n@@ -438,7 +438,7 @@ pub fn to_str_digits(num: f32, dig: uint) -> String {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"may be removed or relocated\")]\n pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigExact(dig), ExpDec, upper);\n@@ -454,7 +454,7 @@ pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"may be removed or relocated\")]\n pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigMax(dig), ExpDec, upper);"}, {"sha": "ae5db0b1fd8a079f11c1cec202008ffd12a60191", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for 64-bits floats (`f64` type)\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n #![doc(primitive = \"f64\")]\n \n@@ -81,7 +81,7 @@ mod cmath {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl Float for f64 {\n     // inlined methods from `num::Float`\n     #[inline]\n@@ -375,7 +375,7 @@ impl Float for f64 {\n ///\n /// * num - The float value\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"may be removed or relocated\")]\n pub fn to_string(num: f64) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigAll, ExpNone, false);\n@@ -388,7 +388,7 @@ pub fn to_string(num: f64) -> String {\n ///\n /// * num - The float value\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"may be removed or relocated\")]\n pub fn to_str_hex(num: f64) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 16u, true, SignNeg, DigAll, ExpNone, false);\n@@ -403,7 +403,7 @@ pub fn to_str_hex(num: f64) -> String {\n /// * num - The float value\n /// * radix - The base to use\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"may be removed or relocated\")]\n pub fn to_str_radix_special(num: f64, rdx: uint) -> (String, bool) {\n     strconv::float_to_str_common(num, rdx, true, SignNeg, DigAll, ExpNone, false)\n }\n@@ -416,7 +416,7 @@ pub fn to_str_radix_special(num: f64, rdx: uint) -> (String, bool) {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"may be removed or relocated\")]\n pub fn to_str_exact(num: f64, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigExact(dig), ExpNone, false);\n@@ -431,7 +431,7 @@ pub fn to_str_exact(num: f64, dig: uint) -> String {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"may be removed or relocated\")]\n pub fn to_str_digits(num: f64, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigMax(dig), ExpNone, false);\n@@ -447,7 +447,7 @@ pub fn to_str_digits(num: f64, dig: uint) -> String {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"may be removed or relocated\")]\n pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigExact(dig), ExpDec, upper);\n@@ -463,7 +463,7 @@ pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> String {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"may be removed or relocated\")]\n pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigMax(dig), ExpDec, upper);"}, {"sha": "38bb62d2414776c06e057c54c86c19d80ca48c4e", "filename": "src/libstd/num/float_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat_macros.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![doc(hidden)]\n \n macro_rules! assert_approx_eq {"}, {"sha": "cd4e41432af544da8ecef386d042f11a9af151e4", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 16-bits integers (`i16` type)\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![doc(primitive = \"i16\")]\n \n pub use core::i16::{BITS, BYTES, MIN, MAX};"}, {"sha": "89f3ab81c94ce47920943396be106853cd76d124", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 32-bits integers (`i32` type)\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![doc(primitive = \"i32\")]\n \n pub use core::i32::{BITS, BYTES, MIN, MAX};"}, {"sha": "6c866382ed37fb7e1228b40509a7fda17e18d93b", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 64-bits integers (`i64` type)\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![doc(primitive = \"i64\")]\n \n pub use core::i64::{BITS, BYTES, MIN, MAX};"}, {"sha": "521b24cdf73477f5dd077c5113f8e3f40f4d50f8", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 8-bits integers (`i8` type)\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![doc(primitive = \"i8\")]\n \n pub use core::i8::{BITS, BYTES, MIN, MAX};"}, {"sha": "2bf9f9b025d91d0ff9a88d3553d2fd99b6508a2a", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -14,7 +14,7 @@\n //! alpha cycle along with the development of clearer conventions\n //! around integer types.\n \n-#![deprecated = \"replaced by isize\"]\n+#![deprecated(feature = \"oldstuff\", since = \"1.0.0\", reason = \"replaced by isize\")]\n \n pub use core::int::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "640d814c046af74eff984c38264ced5387cb3fc5", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![doc(hidden)]\n \n macro_rules! int_module { ($T:ty) => ("}, {"sha": "c0ae4d6a2cd9af4d2738eca727ce240c27d1c164", "filename": "src/libstd/num/isize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fisize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fisize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fisize.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -14,7 +14,7 @@\n //! new type will gradually take place over the alpha cycle along with\n //! the development of clearer conventions around integer types.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![doc(primitive = \"isize\")]\n \n pub use core::isize::{BITS, BYTES, MIN, MAX};"}, {"sha": "82363a8e16946afc7b739f402949381191fb7973", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 96, "deletions": 72, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -13,7 +13,7 @@\n //! These are implemented for the primitive numeric types in `std::{u8, u16,\n //! u32, u64, uint, i8, i16, i32, i64, int, f32, f64}`.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n #[cfg(test)] use fmt::Show;\n@@ -33,11 +33,11 @@ pub use core::num::{FpCategory};\n \n use option::Option;\n \n-#[unstable = \"may be removed or relocated\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"may be removed or relocated\")]\n pub mod strconv;\n \n /// Mathematical operations on primitive floating point numbers.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait Float\n     : Copy + Clone\n     + NumCast\n@@ -52,267 +52,291 @@ pub trait Float\n {\n     // inlined methods from `num::Float`\n     /// Returns the NaN value.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"unsure about its place in the world\")]\n     fn nan() -> Self;\n     /// Returns the infinite value.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"unsure about its place in the world\")]\n     fn infinity() -> Self;\n     /// Returns the negative infinite value.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"unsure about its place in the world\")]\n     fn neg_infinity() -> Self;\n     /// Returns the `0` value.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"unsure about its place in the world\")]\n     fn zero() -> Self;\n     /// Returns -0.0.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"unsure about its place in the world\")]\n     fn neg_zero() -> Self;\n     /// Returns the `1` value.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"unsure about its place in the world\")]\n     fn one() -> Self;\n \n     // FIXME (#5527): These should be associated constants\n \n     /// Returns the number of binary digits of mantissa that this type supports.\n-    #[deprecated = \"use `std::f32::MANTISSA_DIGITS` or `std::f64::MANTISSA_DIGITS` as appropriate\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\",\n+                 reason = \"use `std::f32::MANTISSA_DIGITS` or \\\n+                           `std::f64::MANTISSA_DIGITS` as appropriate\")]\n     fn mantissa_digits(unused_self: Option<Self>) -> uint;\n     /// Returns the number of base-10 digits of precision that this type supports.\n-    #[deprecated = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\",\n+                 reason = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\")]\n     fn digits(unused_self: Option<Self>) -> uint;\n     /// Returns the difference between 1.0 and the smallest representable number larger than 1.0.\n-    #[deprecated = \"use `std::f32::EPSILON` or `std::f64::EPSILON` as appropriate\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\",\n+                 reason = \"use `std::f32::EPSILON` or `std::f64::EPSILON` as appropriate\")]\n     fn epsilon() -> Self;\n     /// Returns the minimum binary exponent that this type can represent.\n-    #[deprecated = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\",\n+                 reason = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\")]\n     fn min_exp(unused_self: Option<Self>) -> int;\n     /// Returns the maximum binary exponent that this type can represent.\n-    #[deprecated = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\",\n+                 reason = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\")]\n     fn max_exp(unused_self: Option<Self>) -> int;\n     /// Returns the minimum base-10 exponent that this type can represent.\n-    #[deprecated = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\",\n+                 reason = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\")]\n     fn min_10_exp(unused_self: Option<Self>) -> int;\n     /// Returns the maximum base-10 exponent that this type can represent.\n-    #[deprecated = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\",\n+                 reason = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\")]\n     fn max_10_exp(unused_self: Option<Self>) -> int;\n \n     /// Returns the smallest finite value that this type can represent.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"unsure about its place in the world\")]\n     fn min_value() -> Self;\n     /// Returns the smallest normalized positive number that this type can represent.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"unsure about its place in the world\")]\n     fn min_pos_value(unused_self: Option<Self>) -> Self;\n     /// Returns the largest finite value that this type can represent.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"unsure about its place in the world\")]\n     fn max_value() -> Self;\n \n     /// Returns true if this value is NaN and false otherwise.\n-    #[unstable = \"position is undecided\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"position is undecided\")]\n     fn is_nan(self) -> bool;\n     /// Returns true if this value is positive infinity or negative infinity and\n     /// false otherwise.\n-    #[unstable = \"position is undecided\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"position is undecided\")]\n     fn is_infinite(self) -> bool;\n     /// Returns true if this number is neither infinite nor NaN.\n-    #[unstable = \"position is undecided\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"position is undecided\")]\n     fn is_finite(self) -> bool;\n     /// Returns true if this number is neither zero, infinite, denormal, or NaN.\n-    #[unstable = \"position is undecided\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"position is undecided\")]\n     fn is_normal(self) -> bool;\n     /// Returns the category that this number falls into.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn classify(self) -> FpCategory;\n \n     /// Returns the mantissa, exponent and sign as integers, respectively.\n-    #[unstable = \"signature is undecided\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"signature is undecided\")]\n     fn integer_decode(self) -> (u64, i16, i8);\n \n     /// Return the largest integer less than or equal to a number.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn floor(self) -> Self;\n     /// Return the smallest integer greater than or equal to a number.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn ceil(self) -> Self;\n     /// Return the nearest integer to a number. Round half-way cases away from\n     /// `0.0`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn round(self) -> Self;\n     /// Return the integer part of a number.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn trunc(self) -> Self;\n     /// Return the fractional part of a number.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn fract(self) -> Self;\n \n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n     /// number is `Float::nan()`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn abs(self) -> Self;\n     /// Returns a number that represents the sign of `self`.\n     ///\n     /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n     /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n     /// - `Float::nan()` if the number is `Float::nan()`\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn signum(self) -> Self;\n     /// Returns `true` if `self` is positive, including `+0.0` and\n     /// `Float::infinity()`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn is_positive(self) -> bool;\n     /// Returns `true` if `self` is negative, including `-0.0` and\n     /// `Float::neg_infinity()`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn is_negative(self) -> bool;\n \n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n     /// error. This produces a more accurate result with better performance than\n     /// a separate multiplication operation followed by an add.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"unsure about its place in the world\")]\n     fn mul_add(self, a: Self, b: Self) -> Self;\n     /// Take the reciprocal (inverse) of a number, `1/x`.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"unsure about its place in the world\")]\n     fn recip(self) -> Self;\n \n     /// Raise a number to an integer power.\n     ///\n     /// Using this function is generally faster than using `powf`\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn powi(self, n: i32) -> Self;\n     /// Raise a number to a floating point power.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn powf(self, n: Self) -> Self;\n \n     /// Take the square root of a number.\n     ///\n     /// Returns NaN if `self` is a negative number.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn sqrt(self) -> Self;\n     /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"unsure about its place in the world\")]\n     fn rsqrt(self) -> Self;\n \n     /// Returns `e^(self)`, (the exponential function).\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn exp(self) -> Self;\n     /// Returns 2 raised to the power of the number, `2^(self)`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn exp2(self) -> Self;\n     /// Returns the natural logarithm of the number.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn ln(self) -> Self;\n     /// Returns the logarithm of the number with respect to an arbitrary base.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn log(self, base: Self) -> Self;\n     /// Returns the base 2 logarithm of the number.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn log2(self) -> Self;\n     /// Returns the base 10 logarithm of the number.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn log10(self) -> Self;\n \n     /// Convert radians to degrees.\n-    #[unstable = \"desirability is unclear\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"desirability is unclear\")]\n     fn to_degrees(self) -> Self;\n     /// Convert degrees to radians.\n-    #[unstable = \"desirability is unclear\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"desirability is unclear\")]\n     fn to_radians(self) -> Self;\n \n     /// Constructs a floating point number created by multiplying `x` by 2\n     /// raised to the power of `exp`.\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending integer conventions\")]\n     fn ldexp(x: Self, exp: int) -> Self;\n     /// Breaks the number into a normalized fraction and a base-2 exponent,\n     /// satisfying:\n     ///\n     ///  * `self = x * pow(2, exp)`\n     ///\n     ///  * `0.5 <= abs(x) < 1.0`\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending integer conventions\")]\n     fn frexp(self) -> (Self, int);\n \n     /// Returns the next representable floating-point value in the direction of\n     /// `other`.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"unsure about its place in the world\")]\n     fn next_after(self, other: Self) -> Self;\n \n     /// Returns the maximum of the two numbers.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn max(self, other: Self) -> Self;\n     /// Returns the minimum of the two numbers.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn min(self, other: Self) -> Self;\n \n     /// The positive difference of two numbers. Returns `0.0` if the number is\n     /// less than or equal to `other`, otherwise the difference between`self`\n     /// and `other` is returned.\n-    #[unstable = \"may be renamed\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"may be renamed\")]\n     fn abs_sub(self, other: Self) -> Self;\n \n     /// Take the cubic root of a number.\n-    #[unstable = \"may be renamed\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"may be renamed\")]\n     fn cbrt(self) -> Self;\n     /// Calculate the length of the hypotenuse of a right-angle triangle given\n     /// legs of length `x` and `y`.\n-    #[unstable = \"unsure about its place in the world\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"unsure about its place in the world\")]\n     fn hypot(self, other: Self) -> Self;\n \n     /// Computes the sine of a number (in radians).\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn sin(self) -> Self;\n     /// Computes the cosine of a number (in radians).\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn cos(self) -> Self;\n     /// Computes the tangent of a number (in radians).\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn tan(self) -> Self;\n \n     /// Computes the arcsine of a number. Return value is in radians in\n     /// the range [-pi/2, pi/2] or NaN if the number is outside the range\n     /// [-1, 1].\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn asin(self) -> Self;\n     /// Computes the arccosine of a number. Return value is in radians in\n     /// the range [0, pi] or NaN if the number is outside the range\n     /// [-1, 1].\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn acos(self) -> Self;\n     /// Computes the arctangent of a number. Return value is in radians in the\n     /// range [-pi/2, pi/2];\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn atan(self) -> Self;\n     /// Computes the four quadrant arctangent of a number, `y`, and another\n     /// number `x`. Return value is in radians in the range [-pi, pi].\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn atan2(self, other: Self) -> Self;\n     /// Simultaneously computes the sine and cosine of the number, `x`. Returns\n     /// `(sin(x), cos(x))`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn sin_cos(self) -> (Self, Self);\n \n     /// Returns the exponential of the number, minus 1, in a way that is\n     /// accurate even if the number is close to zero.\n-    #[unstable = \"may be renamed\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"may be renamed\")]\n     fn exp_m1(self) -> Self;\n     /// Returns the natural logarithm of the number plus 1 (`ln(1+n)`) more\n     /// accurately than if the operations were performed separately.\n-    #[unstable = \"may be renamed\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"may be renamed\")]\n     fn ln_1p(self) -> Self;\n \n     /// Hyperbolic sine function.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn sinh(self) -> Self;\n     /// Hyperbolic cosine function.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn cosh(self) -> Self;\n     /// Hyperbolic tangent function.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn tanh(self) -> Self;\n     /// Inverse hyperbolic sine function.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn asinh(self) -> Self;\n     /// Inverse hyperbolic cosine function.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn acosh(self) -> Self;\n     /// Inverse hyperbolic tangent function.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn atanh(self) -> Self;\n }\n "}, {"sha": "06773a37ab526d14eaa5d28998daac4c32f1adda", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 16-bits integers (`u16` type)\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![doc(primitive = \"u16\")]\n \n pub use core::u16::{BITS, BYTES, MIN, MAX};"}, {"sha": "a58941b00f93fd990a4cbcf47e2fdeaeee281b5a", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 32-bits integers (`u32` type)\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![doc(primitive = \"u32\")]\n \n pub use core::u32::{BITS, BYTES, MIN, MAX};"}, {"sha": "2a42382dd8f31265d55fd8124339e4f0c4dcb3b1", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 64-bits integer (`u64` type)\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![doc(primitive = \"u64\")]\n \n pub use core::u64::{BITS, BYTES, MIN, MAX};"}, {"sha": "952c8c0347f1277769a8c30b723f491cf2c3d8e4", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 8-bits integers (`u8` type)\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![doc(primitive = \"u8\")]\n \n pub use core::u8::{BITS, BYTES, MIN, MAX};"}, {"sha": "58685b059813063624a90b5f29e1c5b5bd8520ca", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -14,7 +14,7 @@\n //! alpha cycle along with the development of clearer conventions\n //! around integer types.\n \n-#![deprecated = \"replaced by usize\"]\n+#![deprecated(feature = \"oldstuff\", since = \"1.0.0\", reason = \"replaced by usize\")]\n \n pub use core::uint::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "786912f002885ef63278e58664df6c6fabe28904", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![doc(hidden)]\n #![allow(unsigned_negation)]\n "}, {"sha": "52601a92ed4151b166c5c7fcca8086fe073711b9", "filename": "src/libstd/num/usize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fusize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fnum%2Fusize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fusize.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -14,7 +14,7 @@\n //! new type will gradually take place over the alpha cycle along with\n //! the development of clearer conventions around integer types.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #![doc(primitive = \"usize\")]\n \n pub use core::usize::{BITS, BYTES, MIN, MAX};"}, {"sha": "2b5748604d16f332c011cd2109535fbba85a1cbd", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -22,7 +22,7 @@\n //! so we will not _hide_ the facts of which OS the user is on -- they should be given the\n //! opportunity to write OS-ignorant code by default.\n \n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n \n #![allow(missing_docs)]\n #![allow(non_snake_case)]"}, {"sha": "2a21f449551aa61cd605ae3e9b321ccfb32cbc02", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -59,7 +59,7 @@\n //! println!(\"path exists: {}\", path.exists());\n //! ```\n \n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n \n use core::marker::Sized;\n use ffi::CString;"}, {"sha": "7e53f45422d295ce74cd90124bde0928097d63a4", "filename": "src/libstd/prelude/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fmod.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -35,7 +35,7 @@\n //! pervasive that it would be obnoxious to import for every use, particularly\n //! those that define methods on primitive types.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub mod v1;"}, {"sha": "e0302c54a5a13930d301de0ab7caf7aac646c019", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,35 +10,54 @@\n \n //! The first version of the prelude of the standard library.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n // Reexported core operators\n-#[stable] #[doc(no_inline)] pub use marker::{Copy, Send, Sized, Sync};\n-#[stable] #[doc(no_inline)] pub use ops::{Drop, Fn, FnMut, FnOnce};\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use marker::{Copy, Send, Sized, Sync};\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use ops::{Drop, Fn, FnMut, FnOnce};\n \n // TEMPORARY\n-#[unstable] #[doc(no_inline)] pub use ops::FullRange;\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use ops::FullRange;\n \n // Reexported functions\n-#[stable] #[doc(no_inline)] pub use mem::drop;\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use mem::drop;\n \n // Reexported types and traits\n \n-#[stable] #[doc(no_inline)] pub use boxed::Box;\n-#[stable] #[doc(no_inline)] pub use char::CharExt;\n-#[stable] #[doc(no_inline)] pub use clone::Clone;\n-#[stable] #[doc(no_inline)] pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n-#[stable] #[doc(no_inline)] pub use iter::DoubleEndedIterator;\n-#[stable] #[doc(no_inline)] pub use iter::ExactSizeIterator;\n-#[stable] #[doc(no_inline)] pub use iter::{Iterator, IteratorExt, Extend};\n-#[stable] #[doc(no_inline)] pub use option::Option::{self, Some, None};\n-#[stable] #[doc(no_inline)] pub use ptr::{PtrExt, MutPtrExt};\n-#[stable] #[doc(no_inline)] pub use result::Result::{self, Ok, Err};\n-#[stable] #[doc(no_inline)] pub use slice::AsSlice;\n-#[stable] #[doc(no_inline)] pub use slice::{SliceExt, SliceConcatExt};\n-#[stable] #[doc(no_inline)] pub use str::{Str, StrExt};\n-#[stable] #[doc(no_inline)] pub use string::{String, ToString};\n-#[stable] #[doc(no_inline)] pub use vec::Vec;\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use boxed::Box;\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use char::CharExt;\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use clone::Clone;\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use iter::DoubleEndedIterator;\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use iter::ExactSizeIterator;\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use iter::{Iterator, IteratorExt, Extend};\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use option::Option::{self, Some, None};\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use ptr::{PtrExt, MutPtrExt};\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use result::Result::{self, Ok, Err};\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use slice::AsSlice;\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use slice::{SliceExt, SliceConcatExt};\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use str::{Str, StrExt};\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use string::{String, ToString};\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use vec::Vec;\n \n // NB: remove when path reform lands\n #[doc(no_inline)] pub use path::{Path, GenericPath};"}, {"sha": "24969ddb01c1737e98b5937bb835f934b1b3d22f", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -219,7 +219,7 @@\n //! }\n //! ```\n \n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n \n use cell::RefCell;\n use clone::Clone;"}, {"sha": "b4cc27ce9269d5af546e0a55f4338858cce2bf4c", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -16,7 +16,7 @@\n //! and should be considered as private implementation details for the\n //! time being.\n \n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n \n // FIXME: this should not be here.\n #![allow(missing_docs)]"}, {"sha": "1d8c7cd5910ee8ed45fd0540d658764b41ca6d3f", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -582,7 +582,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n /// Only a limited number of callbacks can be registered, and this function\n /// returns whether the callback was successfully registered or not. It is not\n /// currently possible to unregister a callback once it has been registered.\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub unsafe fn register(f: Callback) -> bool {\n     match CALLBACK_CNT.fetch_add(1, Ordering::SeqCst) {\n         // The invocation code has knowledge of this window where the count has"}, {"sha": "4a178c7d3844e156ec45b955ff945b00d40dcba0", "filename": "src/libstd/rtdeps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Frtdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Frtdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frtdeps.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -12,7 +12,7 @@\n //! the standard library This varies per-platform, but these libraries are\n //! necessary for running libstd.\n \n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n \n // All platforms need to link to rustrt\n #[cfg(not(test))]"}, {"sha": "c65a772da0499a48f3922b76f6e26a6f73633552", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -29,7 +29,7 @@ use sync::{Mutex, Condvar};\n ///     });\n /// }\n /// ```\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Barrier {\n     lock: Mutex<BarrierState>,\n     cvar: Condvar,\n@@ -54,7 +54,7 @@ impl Barrier {\n     ///\n     /// A barrier will block `n`-1 threads which call `wait` and then wake up\n     /// all threads at once when the `n`th thread calls `wait`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new(n: uint) -> Barrier {\n         Barrier {\n             lock: Mutex::new(BarrierState {\n@@ -75,7 +75,7 @@ impl Barrier {\n     /// returns `true` from `is_leader` when returning from this function, and\n     /// all other threads will receive a result that will return `false` from\n     /// `is_leader`\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn wait(&self) -> BarrierWaitResult {\n         let mut lock = self.lock.lock().unwrap();\n         let local_gen = lock.generation_id;\n@@ -102,7 +102,7 @@ impl BarrierWaitResult {\n     ///\n     /// Only one thread will have `true` returned from their result, all other\n     /// threads will have `false` returned.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn is_leader(&self) -> bool { self.0 }\n }\n "}, {"sha": "739e70720ca45e0bbd6c48393ef27be7fc5c7fbd", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -58,7 +58,7 @@ use sync::{mutex, MutexGuard};\n ///     started = cvar.wait(started).unwrap();\n /// }\n /// ```\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Condvar { inner: Box<StaticCondvar> }\n \n unsafe impl Send for Condvar {}\n@@ -76,7 +76,8 @@ unsafe impl Sync for Condvar {}\n ///\n /// static CVAR: StaticCondvar = CONDVAR_INIT;\n /// ```\n-#[unstable = \"may be merged with Condvar in the future\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"may be merged with Condvar in the future\")]\n pub struct StaticCondvar {\n     inner: sys::Condvar,\n     mutex: AtomicUsize,\n@@ -86,7 +87,8 @@ unsafe impl Send for StaticCondvar {}\n unsafe impl Sync for StaticCondvar {}\n \n /// Constant initializer for a statically allocated condition variable.\n-#[unstable = \"may be merged with Condvar in the future\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"may be merged with Condvar in the future\")]\n pub const CONDVAR_INIT: StaticCondvar = StaticCondvar {\n     inner: sys::CONDVAR_INIT,\n     mutex: ATOMIC_USIZE_INIT,\n@@ -95,7 +97,7 @@ pub const CONDVAR_INIT: StaticCondvar = StaticCondvar {\n impl Condvar {\n     /// Creates a new condition variable which is ready to be waited on and\n     /// notified.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new() -> Condvar {\n         Condvar {\n             inner: box StaticCondvar {\n@@ -131,7 +133,7 @@ impl Condvar {\n     /// over time. Each condition variable is dynamically bound to exactly one\n     /// mutex to ensure defined behavior across platforms. If this functionality\n     /// is not desired, then unsafe primitives in `sys` are provided.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn wait<'a, T>(&self, guard: MutexGuard<'a, T>)\n                        -> LockResult<MutexGuard<'a, T>> {\n         unsafe {\n@@ -154,7 +156,7 @@ impl Condvar {\n     ///\n     /// Like `wait`, the lock specified will be re-acquired when this function\n     /// returns, regardless of whether the timeout elapsed or not.\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>, dur: Duration)\n                            -> LockResult<(MutexGuard<'a, T>, bool)> {\n         unsafe {\n@@ -169,7 +171,7 @@ impl Condvar {\n     /// The semantics of this function are equivalent to `wait_timeout` except\n     /// that the implementation will repeatedly wait while the duration has not\n     /// passed and the provided function returns `false`.\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn wait_timeout_with<'a, T, F>(&self,\n                                        guard: MutexGuard<'a, T>,\n                                        dur: Duration,\n@@ -189,7 +191,7 @@ impl Condvar {\n     /// `notify_one` are not buffered in any way.\n     ///\n     /// To wake up all threads, see `notify_all()`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn notify_one(&self) { unsafe { self.inner.inner.notify_one() } }\n \n     /// Wake up all blocked threads on this condvar.\n@@ -199,11 +201,11 @@ impl Condvar {\n     /// way.\n     ///\n     /// To wake up only one thread, see `notify_one()`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn notify_all(&self) { unsafe { self.inner.inner.notify_all() } }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl Drop for Condvar {\n     fn drop(&mut self) {\n         unsafe { self.inner.inner.destroy() }\n@@ -215,7 +217,8 @@ impl StaticCondvar {\n     /// notification.\n     ///\n     /// See `Condvar::wait`.\n-    #[unstable = \"may be merged with Condvar in the future\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"may be merged with Condvar in the future\")]\n     pub fn wait<'a, T>(&'static self, guard: MutexGuard<'a, T>)\n                        -> LockResult<MutexGuard<'a, T>> {\n         let poisoned = unsafe {\n@@ -235,7 +238,8 @@ impl StaticCondvar {\n     /// specified duration.\n     ///\n     /// See `Condvar::wait_timeout`.\n-    #[unstable = \"may be merged with Condvar in the future\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"may be merged with Condvar in the future\")]\n     pub fn wait_timeout<'a, T>(&'static self, guard: MutexGuard<'a, T>, dur: Duration)\n                                -> LockResult<(MutexGuard<'a, T>, bool)> {\n         let (poisoned, success) = unsafe {\n@@ -258,7 +262,8 @@ impl StaticCondvar {\n     /// passed and the function returns `false`.\n     ///\n     /// See `Condvar::wait_timeout_with`.\n-    #[unstable = \"may be merged with Condvar in the future\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"may be merged with Condvar in the future\")]\n     pub fn wait_timeout_with<'a, T, F>(&'static self,\n                                        guard: MutexGuard<'a, T>,\n                                        dur: Duration,\n@@ -298,13 +303,15 @@ impl StaticCondvar {\n     /// Wake up one blocked thread on this condvar.\n     ///\n     /// See `Condvar::notify_one`.\n-    #[unstable = \"may be merged with Condvar in the future\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"may be merged with Condvar in the future\")]\n     pub fn notify_one(&'static self) { unsafe { self.inner.notify_one() } }\n \n     /// Wake up all blocked threads on this condvar.\n     ///\n     /// See `Condvar::notify_all`.\n-    #[unstable = \"may be merged with Condvar in the future\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"may be merged with Condvar in the future\")]\n     pub fn notify_all(&'static self) { unsafe { self.inner.notify_all() } }\n \n     /// Deallocate all resources associated with this static condvar.\n@@ -313,7 +320,8 @@ impl StaticCondvar {\n     /// active users of the condvar, and this also doesn't prevent any future\n     /// users of the condvar. This method is required to be called to not leak\n     /// memory on all platforms.\n-    #[unstable = \"may be merged with Condvar in the future\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"may be merged with Condvar in the future\")]\n     pub unsafe fn destroy(&'static self) {\n         self.inner.destroy()\n     }"}, {"sha": "bb309d5c2e81940f4deef1001ca974a1d87793a1", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -27,9 +27,10 @@\n //! ```\n \n #![allow(missing_docs)]\n-#![unstable = \"futures as-is have yet to be deeply reevaluated with recent \\\n-               core changes to Rust's synchronization story, and will likely \\\n-               become stable in the future but are unstable until that time\"]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+            reason = \"futures as-is have yet to be deeply reevaluated with recent \\\n+                      core changes to Rust's synchronization story, and will likely \\\n+                      become stable in the future but are unstable until that time\")]\n \n use core::prelude::*;\n use core::mem::replace;"}, {"sha": "9e9d204aa4635afc08c697aeec7d5325ef92fc99", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -15,7 +15,7 @@\n //! and/or blocking at all, but rather provide the necessary tools to build\n //! other types of concurrent primitives.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n pub use alloc::arc::{Arc, Weak};\n pub use core::atomic;"}, {"sha": "73ddd2e4c459d8feb77bfcf5a8686ca9f75065eb", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -163,7 +163,7 @@\n //! }\n //! ```\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n // A description of how Rust's channel implementation works\n //\n@@ -339,7 +339,7 @@ mod spsc_queue;\n \n /// The receiving-half of Rust's channel type. This half can only be owned by\n /// one task\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Receiver<T> {\n     inner: UnsafeCell<Flavor<T>>,\n }\n@@ -351,14 +351,14 @@ unsafe impl<T:Send> Send for Receiver<T> { }\n /// An iterator over messages on a receiver, this iterator will block\n /// whenever `next` is called, waiting for a new message, and `None` will be\n /// returned when the corresponding channel has hung up.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Iter<'a, T:'a> {\n     rx: &'a Receiver<T>\n }\n \n /// The sending-half of Rust's asynchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Sender<T> {\n     inner: UnsafeCell<Flavor<T>>,\n }\n@@ -369,8 +369,8 @@ unsafe impl<T:Send> Send for Sender<T> { }\n \n /// The sending-half of Rust's synchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n-#[stable]\n #[cfg(stage0)] // NOTE remove impl after next snapshot\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct SyncSender<T> {\n     inner: Arc<RacyCell<sync::Packet<T>>>,\n     // can't share in an arc\n@@ -379,7 +379,7 @@ pub struct SyncSender<T> {\n \n /// The sending-half of Rust's synchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n pub struct SyncSender<T> {\n     inner: Arc<RacyCell<sync::Packet<T>>>,\n@@ -394,50 +394,50 @@ impl<T> !marker::Sync for SyncSender<T> {}\n /// disconnected, implying that the data could never be received. The error\n /// contains the data being sent as a payload so it can be recovered.\n #[derive(PartialEq, Eq)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct SendError<T>(pub T);\n \n /// An error returned from the `recv` function on a `Receiver`.\n ///\n /// The `recv` operation can only fail if the sending half of a channel is\n /// disconnected, implying that no further messages will ever be received.\n #[derive(PartialEq, Eq, Clone, Copy)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct RecvError;\n \n /// This enumeration is the list of the possible reasons that try_recv could not\n /// return data when called.\n #[derive(PartialEq, Clone, Copy)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub enum TryRecvError {\n     /// This channel is currently empty, but the sender(s) have not yet\n     /// disconnected, so data may yet become available.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     Empty,\n \n     /// This channel's sending half has become disconnected, and there will\n     /// never be any more data received on this channel\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     Disconnected,\n }\n \n /// This enumeration is the list of the possible error outcomes for the\n /// `SyncSender::try_send` method.\n #[derive(PartialEq, Clone)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub enum TrySendError<T> {\n     /// The data could not be sent on the channel because it would require that\n     /// the callee block to send the data.\n     ///\n     /// If this is a buffered channel, then the buffer is full at this time. If\n     /// this is not a buffered channel, then there is no receiver available to\n     /// acquire the data.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     Full(T),\n \n     /// This channel's receiving half has disconnected, so the data could not be\n     /// sent. The data is returned back to the callee in this case.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     Disconnected(T),\n }\n \n@@ -495,7 +495,7 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// // Let's see what that answer was\n /// println!(\"{:?}\", rx.recv().unwrap());\n /// ```\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n     let a = Arc::new(RacyCell::new(oneshot::Packet::new()));\n     (Sender::new(Flavor::Oneshot(a.clone())), Receiver::new(Flavor::Oneshot(a)))\n@@ -535,7 +535,7 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n /// assert_eq!(rx.recv().unwrap(), 1i);\n /// assert_eq!(rx.recv().unwrap(), 2i);\n /// ```\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n     let a = Arc::new(RacyCell::new(sync::Packet::new(bound)));\n     (SyncSender::new(a.clone()), Receiver::new(Flavor::Sync(a)))\n@@ -579,7 +579,7 @@ impl<T: Send> Sender<T> {\n     /// drop(rx);\n     /// assert_eq!(tx.send(1i).err().unwrap().0, 1);\n     /// ```\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n         let (new_inner, ret) = match *unsafe { self.inner() } {\n             Flavor::Oneshot(ref p) => {\n@@ -626,7 +626,7 @@ impl<T: Send> Sender<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Send> Clone for Sender<T> {\n     fn clone(&self) -> Sender<T> {\n         let (packet, sleeper, guard) = match *unsafe { self.inner() } {\n@@ -672,7 +672,7 @@ impl<T: Send> Clone for Sender<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Send> Drop for Sender<T> {\n     fn drop(&mut self) {\n         match *unsafe { self.inner_mut() } {\n@@ -713,7 +713,7 @@ impl<T: Send> SyncSender<T> {\n     /// This function will never panic, but it may return `Err` if the\n     /// `Receiver` has disconnected and is no longer able to receive\n     /// information.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n         unsafe { (*self.inner.get()).send(t).map_err(SendError) }\n     }\n@@ -727,13 +727,13 @@ impl<T: Send> SyncSender<T> {\n     ///\n     /// See `SyncSender::send` for notes about guarantees of whether the\n     /// receiver has received the data or not if this function is successful.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> {\n         unsafe { (*self.inner.get()).try_send(t) }\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Send> Clone for SyncSender<T> {\n     fn clone(&self) -> SyncSender<T> {\n         unsafe { (*self.inner.get()).clone_chan(); }\n@@ -742,7 +742,7 @@ impl<T: Send> Clone for SyncSender<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Send> Drop for SyncSender<T> {\n     fn drop(&mut self) {\n         unsafe { (*self.inner.get()).drop_chan(); }\n@@ -766,7 +766,7 @@ impl<T: Send> Receiver<T> {\n     ///\n     /// This is useful for a flavor of \"optimistic check\" before deciding to\n     /// block on a receiver.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn try_recv(&self) -> Result<T, TryRecvError> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n@@ -827,7 +827,7 @@ impl<T: Send> Receiver<T> {\n     /// If the corresponding `Sender` has disconnected, or it disconnects while\n     /// this call is blocking, this call will wake up and return `Err` to\n     /// indicate that no more messages can ever be received on this channel.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn recv(&self) -> Result<T, RecvError> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n@@ -866,7 +866,7 @@ impl<T: Send> Receiver<T> {\n \n     /// Returns an iterator that will block waiting for messages, but never\n     /// `panic!`. It will return `None` when the channel has hung up.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { rx: self }\n     }\n@@ -958,15 +958,15 @@ impl<T: Send> select::Packet for Receiver<T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T: Send> Iterator for Iter<'a, T> {\n     type Item = T;\n \n     fn next(&mut self) -> Option<T> { self.rx.recv().ok() }\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Send> Drop for Receiver<T> {\n     fn drop(&mut self) {\n         match *unsafe { self.inner_mut() } {"}, {"sha": "9747de3b7f9b02c36f55cf29e5ab7c7ad4dc140c", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -35,7 +35,7 @@\n //! method, and see the method for more information about it. Due to this\n //! caveat, this queue may not be appropriate for all use-cases.\n \n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n \n // http://www.1024cores.net/home/lock-free-algorithms\n //                         /queues/non-intrusive-mpsc-node-based-queue\n@@ -138,7 +138,7 @@ impl<T: Send> Queue<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Send> Drop for Queue<T> {\n     fn drop(&mut self) {\n         unsafe {"}, {"sha": "1a433db2deb92b603b31a138236ee13b07d368cc", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -46,12 +46,13 @@\n //! ```\n \n #![allow(dead_code)]\n-#![unstable = \"This implementation, while likely sufficient, is unsafe and \\\n-                   likely to be error prone. At some point in the future this \\\n-                   module will likely be replaced, and it is currently \\\n-                   unknown how much API breakage that will cause. The ability \\\n-                   to select over a number of channels will remain forever, \\\n-                   but no guarantees beyond this are being made\"]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+            reason = \"This implementation, while likely sufficient, is unsafe and \\\n+                      likely to be error prone. At some point in the future this \\\n+                      module will likely be replaced, and it is currently \\\n+                      unknown how much API breakage that will cause. The ability \\\n+                      to select over a number of channels will remain forever, \\\n+                      but no guarantees beyond this are being made\")]\n \n \n use core::prelude::*;"}, {"sha": "cc7a34f8d4cb394505afe594d2b75cffc7828315", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -33,7 +33,7 @@\n //! concurrently between two tasks. This data structure is safe to use and\n //! enforces the semantics that there is one pusher and one popper.\n \n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n \n use core::prelude::*;\n "}, {"sha": "343dfbf68c77c62847cb586276211a42d739869f", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -109,7 +109,7 @@ use sys_common::mutex as sys;\n ///\n /// *guard += 1;\n /// ```\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Mutex<T> {\n     // Note that this static mutex is in a *box*, not inlined into the struct\n     // itself. Once a native mutex has been used once, its address can never\n@@ -145,7 +145,8 @@ unsafe impl<T:Send> Sync for Mutex<T> { }\n /// }\n /// // lock is unlocked here.\n /// ```\n-#[unstable = \"may be merged with Mutex in the future\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"may be merged with Mutex in the future\")]\n pub struct StaticMutex {\n     lock: sys::Mutex,\n     poison: poison::Flag,\n@@ -159,8 +160,8 @@ unsafe impl Sync for StaticMutex {}\n /// The data protected by the mutex can be access through this guard via its\n /// Deref and DerefMut implementations\n #[must_use]\n-#[stable]\n #[cfg(stage0)] // NOTE remove impl after next snapshot\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct MutexGuard<'a, T: 'a> {\n     // funny underscores due to how Deref/DerefMut currently work (they\n     // disregard field privacy).\n@@ -176,7 +177,7 @@ pub struct MutexGuard<'a, T: 'a> {\n /// The data protected by the mutex can be access through this guard via its\n /// Deref and DerefMut implementations\n #[must_use]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n pub struct MutexGuard<'a, T: 'a> {\n     // funny underscores due to how Deref/DerefMut currently work (they\n@@ -191,15 +192,16 @@ impl<'a, T> !marker::Send for MutexGuard<'a, T> {}\n \n /// Static initialization of a mutex. This constant can be used to initialize\n /// other mutex constants.\n-#[unstable = \"may be merged with Mutex in the future\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"may be merged with Mutex in the future\")]\n pub const MUTEX_INIT: StaticMutex = StaticMutex {\n     lock: sys::MUTEX_INIT,\n     poison: poison::FLAG_INIT,\n };\n \n impl<T: Send> Mutex<T> {\n     /// Creates a new mutex in an unlocked state ready for use.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new(t: T) -> Mutex<T> {\n         Mutex {\n             inner: box MUTEX_INIT,\n@@ -218,7 +220,7 @@ impl<T: Send> Mutex<T> {\n     ///\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return an error once the mutex is acquired.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn lock(&self) -> LockResult<MutexGuard<T>> {\n         unsafe { self.inner.lock.lock() }\n         MutexGuard::new(&*self.inner, &self.data)\n@@ -237,7 +239,7 @@ impl<T: Send> Mutex<T> {\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return failure if the mutex would otherwise be\n     /// acquired.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn try_lock(&self) -> TryLockResult<MutexGuard<T>> {\n         if unsafe { self.inner.lock.try_lock() } {\n             Ok(try!(MutexGuard::new(&*self.inner, &self.data)))\n@@ -248,7 +250,7 @@ impl<T: Send> Mutex<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T: Send> Drop for Mutex<T> {\n     fn drop(&mut self) {\n         // This is actually safe b/c we know that there is no further usage of\n@@ -265,15 +267,17 @@ static DUMMY: Dummy = Dummy(UnsafeCell { value: () });\n impl StaticMutex {\n     /// Acquires this lock, see `Mutex::lock`\n     #[inline]\n-    #[unstable = \"may be merged with Mutex in the future\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"may be merged with Mutex in the future\")]\n     pub fn lock(&'static self) -> LockResult<MutexGuard<()>> {\n         unsafe { self.lock.lock() }\n         MutexGuard::new(self, &DUMMY.0)\n     }\n \n     /// Attempts to grab this lock, see `Mutex::try_lock`\n     #[inline]\n-    #[unstable = \"may be merged with Mutex in the future\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"may be merged with Mutex in the future\")]\n     pub fn try_lock(&'static self) -> TryLockResult<MutexGuard<()>> {\n         if unsafe { self.lock.try_lock() } {\n             Ok(try!(MutexGuard::new(self, &DUMMY.0)))\n@@ -292,7 +296,8 @@ impl StaticMutex {\n     /// *all* platforms. It may be the case that some platforms do not leak\n     /// memory if this method is not called, but this is not guaranteed to be\n     /// true on all platforms.\n-    #[unstable = \"may be merged with Mutex in the future\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"may be merged with Mutex in the future\")]\n     pub unsafe fn destroy(&'static self) {\n         self.lock.destroy()\n     }\n@@ -325,23 +330,23 @@ impl<'mutex, T> MutexGuard<'mutex, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'mutex, T> Deref for MutexGuard<'mutex, T> {\n     type Target = T;\n \n     fn deref<'a>(&'a self) -> &'a T {\n         unsafe { &*self.__data.get() }\n     }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'mutex, T> DerefMut for MutexGuard<'mutex, T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n         unsafe { &mut *self.__data.get() }\n     }\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> Drop for MutexGuard<'a, T> {\n     #[inline]\n     fn drop(&mut self) {"}, {"sha": "82ed62966b5ee6f0c730f1eac05a0081cf68c707", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -36,7 +36,7 @@ use sync::{StaticMutex, MUTEX_INIT};\n ///     // run initialization here\n /// });\n /// ```\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Once {\n     mutex: StaticMutex,\n     cnt: AtomicIsize,\n@@ -46,7 +46,7 @@ pub struct Once {\n unsafe impl Sync for Once {}\n \n /// Initialization value for static `Once` values.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const ONCE_INIT: Once = Once {\n     mutex: MUTEX_INIT,\n     cnt: ATOMIC_ISIZE_INIT,\n@@ -63,7 +63,7 @@ impl Once {\n     ///\n     /// When this function returns, it is guaranteed that some initialization\n     /// has run and completed (it may not be the closure specified).\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn call_once<F>(&'static self, f: F) where F: FnOnce() {\n         // Optimize common path: load is much cheaper than fetch_add.\n         if self.cnt.load(Ordering::SeqCst) < 0 {"}, {"sha": "4443fc2be60a83eccb769f288a0d18b21ef4b211", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -53,22 +53,22 @@ pub struct Guard {\n /// is held. The precise semantics for when a lock is poisoned is documented on\n /// each lock, but once a lock is poisoned then all future acquisitions will\n /// return this error.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct PoisonError<T> {\n     guard: T,\n }\n \n /// An enumeration of possible errors which can occur while calling the\n /// `try_lock` method.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub enum TryLockError<T> {\n     /// The lock could not be acquired because another task failed while holding\n     /// the lock.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     Poisoned(PoisonError<T>),\n     /// The lock could not be acquired at this time because the operation would\n     /// otherwise block.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     WouldBlock,\n }\n \n@@ -79,15 +79,15 @@ pub enum TryLockError<T> {\n /// that the primitive was poisoned. Note that the `Err` variant *also* carries\n /// the associated guard, and it can be acquired through the `into_inner`\n /// method.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub type LockResult<Guard> = Result<Guard, PoisonError<Guard>>;\n \n /// A type alias for the result of a nonblocking locking method.\n ///\n /// For more information, see `LockResult`. A `TryLockResult` doesn't\n /// necessarily hold the associated guard in the `Err` type as the lock may not\n /// have been acquired for other reasons.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub type TryLockResult<Guard> = Result<Guard, TryLockError<Guard>>;\n \n impl<T> fmt::Show for PoisonError<T> {\n@@ -105,22 +105,22 @@ impl<T> Error for PoisonError<T> {\n impl<T> PoisonError<T> {\n     /// Consumes this error indicating that a lock is poisoned, returning the\n     /// underlying guard to allow access regardless.\n-    #[deprecated=\"renamed to into_inner\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\", reason = \"renamed to into_inner\")]\n     pub fn into_guard(self) -> T { self.guard }\n \n     /// Consumes this error indicating that a lock is poisoned, returning the\n     /// underlying guard to allow access regardless.\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> T { self.guard }\n \n     /// Reaches into this error indicating that a lock is poisoned, returning a\n     /// reference to the underlying guard to allow access regardless.\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn get_ref(&self) -> &T { &self.guard }\n \n     /// Reaches into this error indicating that a lock is poisoned, returning a\n     /// mutable reference to the underlying guard to allow access regardless.\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut T { &mut self.guard }\n }\n "}, {"sha": "6d0b34b3c8748eceef7cd8358752c0cd27c97795", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -58,7 +58,7 @@ use sys_common::rwlock as sys;\n ///     assert_eq!(*w, 6);\n /// } // write lock is dropped here\n /// ```\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct RwLock<T> {\n     inner: Box<StaticRwLock>,\n     data: UnsafeCell<T>,\n@@ -90,7 +90,8 @@ unsafe impl<T> Sync for RwLock<T> {}\n /// }\n /// unsafe { LOCK.destroy() } // free all resources\n /// ```\n-#[unstable = \"may be merged with RwLock in the future\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"may be merged with RwLock in the future\")]\n pub struct StaticRwLock {\n     lock: sys::RWLock,\n     poison: poison::Flag,\n@@ -100,7 +101,8 @@ unsafe impl Send for StaticRwLock {}\n unsafe impl Sync for StaticRwLock {}\n \n /// Constant initialization for a statically-initialized rwlock.\n-#[unstable = \"may be merged with RwLock in the future\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"may be merged with RwLock in the future\")]\n pub const RW_LOCK_INIT: StaticRwLock = StaticRwLock {\n     lock: sys::RWLOCK_INIT,\n     poison: poison::FLAG_INIT,\n@@ -109,7 +111,7 @@ pub const RW_LOCK_INIT: StaticRwLock = StaticRwLock {\n /// RAII structure used to release the shared read access of a lock when\n /// dropped.\n #[must_use]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct RwLockReadGuard<'a, T: 'a> {\n     __lock: &'a StaticRwLock,\n@@ -120,8 +122,8 @@ pub struct RwLockReadGuard<'a, T: 'a> {\n /// RAII structure used to release the shared read access of a lock when\n /// dropped.\n #[must_use]\n-#[stable]\n #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct RwLockReadGuard<'a, T: 'a> {\n     __lock: &'a StaticRwLock,\n     __data: &'a UnsafeCell<T>,\n@@ -133,8 +135,8 @@ impl<'a, T> !marker::Send for RwLockReadGuard<'a, T> {}\n /// RAII structure used to release the exclusive write access of a lock when\n /// dropped.\n #[must_use]\n-#[stable]\n #[cfg(stage0)] // NOTE remove impl after next snapshot\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct RwLockWriteGuard<'a, T: 'a> {\n     __lock: &'a StaticRwLock,\n     __data: &'a UnsafeCell<T>,\n@@ -145,7 +147,7 @@ pub struct RwLockWriteGuard<'a, T: 'a> {\n /// RAII structure used to release the exclusive write access of a lock when\n /// dropped.\n #[must_use]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n pub struct RwLockWriteGuard<'a, T: 'a> {\n     __lock: &'a StaticRwLock,\n@@ -158,7 +160,7 @@ impl<'a, T> !marker::Send for RwLockWriteGuard<'a, T> {}\n \n impl<T: Send + Sync> RwLock<T> {\n     /// Creates a new instance of an RwLock which is unlocked and read to go.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new(t: T) -> RwLock<T> {\n         RwLock { inner: box RW_LOCK_INIT, data: UnsafeCell::new(t) }\n     }\n@@ -181,7 +183,7 @@ impl<T: Send + Sync> RwLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock.\n     /// The failure will occur immediately after the lock has been acquired.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn read(&self) -> LockResult<RwLockReadGuard<T>> {\n         unsafe { self.inner.lock.read() }\n         RwLockReadGuard::new(&*self.inner, &self.data)\n@@ -203,7 +205,7 @@ impl<T: Send + Sync> RwLock<T> {\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn try_read(&self) -> TryLockResult<RwLockReadGuard<T>> {\n         if unsafe { self.inner.lock.try_read() } {\n             Ok(try!(RwLockReadGuard::new(&*self.inner, &self.data)))\n@@ -227,7 +229,7 @@ impl<T: Send + Sync> RwLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock.\n     /// An error will be returned when the lock is acquired.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn write(&self) -> LockResult<RwLockWriteGuard<T>> {\n         unsafe { self.inner.lock.write() }\n         RwLockWriteGuard::new(&*self.inner, &self.data)\n@@ -246,7 +248,7 @@ impl<T: Send + Sync> RwLock<T> {\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn try_write(&self) -> TryLockResult<RwLockWriteGuard<T>> {\n         if unsafe { self.inner.lock.try_read() } {\n             Ok(try!(RwLockWriteGuard::new(&*self.inner, &self.data)))\n@@ -257,7 +259,7 @@ impl<T: Send + Sync> RwLock<T> {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<T> Drop for RwLock<T> {\n     fn drop(&mut self) {\n         unsafe { self.inner.lock.destroy() }\n@@ -274,7 +276,8 @@ impl StaticRwLock {\n     ///\n     /// See `RwLock::read`.\n     #[inline]\n-    #[unstable = \"may be merged with RwLock in the future\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"may be merged with RwLock in the future\")]\n     pub fn read(&'static self) -> LockResult<RwLockReadGuard<'static, ()>> {\n         unsafe { self.lock.read() }\n         RwLockReadGuard::new(self, &DUMMY.0)\n@@ -284,7 +287,8 @@ impl StaticRwLock {\n     ///\n     /// See `RwLock::try_read`.\n     #[inline]\n-    #[unstable = \"may be merged with RwLock in the future\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"may be merged with RwLock in the future\")]\n     pub fn try_read(&'static self)\n                     -> TryLockResult<RwLockReadGuard<'static, ()>> {\n         if unsafe { self.lock.try_read() } {\n@@ -299,7 +303,8 @@ impl StaticRwLock {\n     ///\n     /// See `RwLock::write`.\n     #[inline]\n-    #[unstable = \"may be merged with RwLock in the future\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"may be merged with RwLock in the future\")]\n     pub fn write(&'static self) -> LockResult<RwLockWriteGuard<'static, ()>> {\n         unsafe { self.lock.write() }\n         RwLockWriteGuard::new(self, &DUMMY.0)\n@@ -309,7 +314,8 @@ impl StaticRwLock {\n     ///\n     /// See `RwLock::try_write`.\n     #[inline]\n-    #[unstable = \"may be merged with RwLock in the future\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"may be merged with RwLock in the future\")]\n     pub fn try_write(&'static self)\n                      -> TryLockResult<RwLockWriteGuard<'static, ()>> {\n         if unsafe { self.lock.try_write() } {\n@@ -325,7 +331,8 @@ impl StaticRwLock {\n     /// active users of the lock, and this also doesn't prevent any future users\n     /// of this lock. This method is required to be called to not leak memory on\n     /// all platforms.\n-    #[unstable = \"may be merged with RwLock in the future\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"may be merged with RwLock in the future\")]\n     pub unsafe fn destroy(&'static self) {\n         self.lock.destroy()\n     }\n@@ -382,35 +389,35 @@ impl<'rwlock, T> RwLockWriteGuard<'rwlock, T> {\n     }\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'rwlock, T> Deref for RwLockReadGuard<'rwlock, T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'rwlock, T> Deref for RwLockWriteGuard<'rwlock, T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'rwlock, T> DerefMut for RwLockWriteGuard<'rwlock, T> {\n     fn deref_mut(&mut self) -> &mut T {\n         unsafe { &mut *self.__data.get() }\n     }\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> Drop for RwLockReadGuard<'a, T> {\n     fn drop(&mut self) {\n         unsafe { self.__lock.lock.read_unlock(); }\n     }\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T> Drop for RwLockWriteGuard<'a, T> {\n     fn drop(&mut self) {\n         self.__lock.poison.done(&self.__poison);"}, {"sha": "08b620c764a88910c79d66fc8f11edf6048bf32a", "filename": "src/libstd/sync/semaphore.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable = \"the interaction between semaphores and the acquisition/release \\\n-               of resources is currently unclear\"]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+            reason = \"the interaction between semaphores and the acquisition/release \\\n+                      of resources is currently unclear\")]\n \n use ops::Drop;\n use sync::{Mutex, Condvar};\n@@ -99,7 +100,7 @@ impl Semaphore {\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a> Drop for SemaphoreGuard<'a> {\n     fn drop(&mut self) {\n         self.sem.release();"}, {"sha": "ceec18853751f446fd0b8296feeb779052a03ece", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,10 +10,11 @@\n \n //! Abstraction of a thread pool for basic parallelism.\n \n-#![unstable = \"the semantics of a failing task and whether a thread is \\\n-               re-attached to a thread pool are somewhat unclear, and the \\\n-               utility of this type in `std::sync` is questionable with \\\n-               respect to the jobs of other primitives\"]\n+#![unstable(feature = \"unnamed_feature\", since=\"1.0.0\",\n+            reason = \"the semantics of a failing task and whether a thread is \\\n+                      re-attached to a thread pool are somewhat unclear, and the \\\n+                      utility of this type in `std::sync` is questionable with \\\n+                      respect to the jobs of other primitives\")]\n \n use core::prelude::*;\n "}, {"sha": "4e846a420302fabef281d472baa954bc082b2cc8", "filename": "src/libstd/sys/unix/ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -29,7 +29,7 @@\n //! }\n //! ```\n \n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n \n use sys_common::AsInner;\n use libc;"}, {"sha": "edc46b9c162d73eba25f0c98167f8fa31dc52eff", "filename": "src/libstd/sys/windows/ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -14,7 +14,7 @@\n //! descriptors, and sockets, but its functionality will grow over\n //! time.\n \n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n \n use sys_common::AsInner;\n use libc;"}, {"sha": "7df7e75061033ec168397ad6085517865e76d2c1", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -144,7 +144,7 @@\n //!\n //! * It can be implemented highly efficiently on many platforms.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use any::Any;\n use boxed::Box;\n@@ -166,7 +166,7 @@ use sys_common::{stack, thread_info};\n \n /// Thread configuration. Provides detailed control over the properties\n /// and behavior of new threads.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Builder {\n     // A name for the thread-to-be, for identification in panic messages\n     name: Option<String>,\n@@ -181,7 +181,7 @@ pub struct Builder {\n impl Builder {\n     /// Generate the base configuration for spawning a thread, from which\n     /// configuration methods can be chained.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn new() -> Builder {\n         Builder {\n             name: None,\n@@ -193,28 +193,30 @@ impl Builder {\n \n     /// Name the thread-to-be. Currently the name is used for identification\n     /// only in panic messages.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn name(mut self, name: String) -> Builder {\n         self.name = Some(name);\n         self\n     }\n \n     /// Set the size of the stack for the new thread.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn stack_size(mut self, size: uint) -> Builder {\n         self.stack_size = Some(size);\n         self\n     }\n \n     /// Redirect thread-local stdout.\n-    #[unstable = \"Will likely go away after proc removal\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"Will likely go away after proc removal\")]\n     pub fn stdout(mut self, stdout: Box<Writer + Send>) -> Builder {\n         self.stdout = Some(stdout);\n         self\n     }\n \n     /// Redirect thread-local stderr.\n-    #[unstable = \"Will likely go away after proc removal\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"Will likely go away after proc removal\")]\n     pub fn stderr(mut self, stderr: Box<Writer + Send>) -> Builder {\n         self.stderr = Some(stderr);\n         self\n@@ -223,7 +225,8 @@ impl Builder {\n     /// Spawn a new detached thread, and return a handle to it.\n     ///\n     /// See `Thead::spawn` and the module doc for more details.\n-    #[unstable = \"may change with specifics of new Send semantics\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"may change with specifics of new Send semantics\")]\n     pub fn spawn<F>(self, f: F) -> Thread where F: FnOnce(), F: Send + 'static {\n         let (native, thread) = self.spawn_inner(Thunk::new(f), Thunk::with_arg(|_| {}));\n         unsafe { imp::detach(native) };\n@@ -234,7 +237,8 @@ impl Builder {\n     /// scope, and return a `JoinGuard`.\n     ///\n     /// See `Thead::scoped` and the module doc for more details.\n-    #[unstable = \"may change with specifics of new Send semantics\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"may change with specifics of new Send semantics\")]\n     pub fn scoped<'a, T, F>(self, f: F) -> JoinGuard<'a, T> where\n         T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n     {\n@@ -326,7 +330,7 @@ struct Inner {\n unsafe impl Sync for Inner {}\n \n #[derive(Clone)]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n /// A handle to a thread.\n pub struct Thread {\n     inner: Arc<Inner>,\n@@ -350,7 +354,8 @@ impl Thread {\n     /// main thread; the whole process is terminated when the main thread\n     /// finishes.) The thread handle can be used for low-level\n     /// synchronization. See the module documentation for additional details.\n-    #[unstable = \"may change with specifics of new Send semantics\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"may change with specifics of new Send semantics\")]\n     pub fn spawn<F>(f: F) -> Thread where F: FnOnce(), F: Send + 'static {\n         Builder::new().spawn(f)\n     }\n@@ -363,28 +368,29 @@ impl Thread {\n     /// current thread's stack (hence the \"scoped\" name), it cannot be detached;\n     /// it *must* be joined before the relevant stack frame is popped. See the\n     /// module documentation for additional details.\n-    #[unstable = \"may change with specifics of new Send semantics\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"may change with specifics of new Send semantics\")]\n     pub fn scoped<'a, T, F>(f: F) -> JoinGuard<'a, T> where\n         T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n     {\n         Builder::new().scoped(f)\n     }\n \n     /// Gets a handle to the thread that invokes it.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn current() -> Thread {\n         thread_info::current_thread()\n     }\n \n     /// Cooperatively give up a timeslice to the OS scheduler.\n-    #[unstable = \"name may change\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"name may change\")]\n     pub fn yield_now() {\n         unsafe { imp::yield_now() }\n     }\n \n     /// Determines whether the current thread is panicking.\n     #[inline]\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn panicking() -> bool {\n         unwind::panicking()\n     }\n@@ -398,7 +404,7 @@ impl Thread {\n     // future, this will be implemented in a more efficient way, perhaps along the lines of\n     //   http://cr.openjdk.java.net/~stefank/6989984.1/raw_files/new/src/os/linux/vm/os_linux.cpp\n     // or futuxes, and in either case may allow spurious wakeups.\n-    #[unstable = \"recently introduced\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"recently introduced\")]\n     pub fn park() {\n         let thread = Thread::current();\n         let mut guard = thread.inner.lock.lock().unwrap();\n@@ -411,7 +417,7 @@ impl Thread {\n     /// Atomically makes the handle's token available if it is not already.\n     ///\n     /// See the module doc for more detail.\n-    #[unstable = \"recently introduced\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"recently introduced\")]\n     pub fn unpark(&self) {\n         let mut guard = self.inner.lock.lock().unwrap();\n         if !*guard {\n@@ -421,7 +427,7 @@ impl Thread {\n     }\n \n     /// Get the thread's name.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn name(&self) -> Option<&str> {\n         self.inner.name.as_ref().map(|s| s.as_slice())\n     }\n@@ -435,7 +441,7 @@ impl thread_info::NewThread for Thread {\n /// Indicates the manner in which a thread exited.\n ///\n /// A thread that completes without panicking is considered to exit successfully.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub type Result<T> = ::result::Result<T, Box<Any + Send>>;\n \n struct Packet<T>(Arc<UnsafeCell<Option<Result<T>>>>);\n@@ -447,20 +453,21 @@ unsafe impl<T> Sync for Packet<T> {}\n ///\n /// The type `T` is the return type for the thread's main function.\n #[must_use]\n-#[unstable = \"may change with specifics of new Send semantics\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"may change with specifics of new Send semantics\")]\n pub struct JoinGuard<'a, T: 'a> {\n     native: imp::rust_thread,\n     thread: Thread,\n     joined: bool,\n     packet: Packet<T>,\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n unsafe impl<'a, T: Send + 'a> Sync for JoinGuard<'a, T> {}\n \n impl<'a, T: Send + 'a> JoinGuard<'a, T> {\n     /// Extract a handle to the thread this guard will join on.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn thread(&self) -> &Thread {\n         &self.thread\n     }\n@@ -470,7 +477,7 @@ impl<'a, T: Send + 'a> JoinGuard<'a, T> {\n     ///\n     /// If the child thread panics, `Err` is returned with the parameter given\n     /// to `panic`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn join(mut self) -> Result<T> {\n         assert!(!self.joined);\n         unsafe { imp::join(self.native) };\n@@ -483,15 +490,16 @@ impl<'a, T: Send + 'a> JoinGuard<'a, T> {\n \n impl<T: Send> JoinGuard<'static, T> {\n     /// Detaches the child thread, allowing it to outlive its parent.\n-    #[unstable = \"unsure whether this API imposes limitations elsewhere\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"unsure whether this API imposes limitations elsewhere\")]\n     pub fn detach(mut self) {\n         unsafe { imp::detach(self.native) };\n         self.joined = true; // avoid joining in the destructor\n     }\n }\n \n #[unsafe_destructor]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl<'a, T: Send + 'a> Drop for JoinGuard<'a, T> {\n     fn drop(&mut self) {\n         if !self.joined {"}, {"sha": "bf74acda72179b7bfd1c13e6f3fecf397f084209", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -34,7 +34,7 @@\n //! will want to make use of some form of **interior mutability** through the\n //! `Cell` or `RefCell` types.\n \n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n use prelude::v1::*;\n \n@@ -93,7 +93,7 @@ pub mod __impl {\n ///     assert_eq!(*f.borrow(), 2);\n /// });\n /// ```\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Key<T> {\n     // The key itself may be tagged with #[thread_local], and this `Key` is\n     // stored as a `static`, and it's not valid for a static to reference the\n@@ -113,7 +113,7 @@ pub struct Key<T> {\n \n /// Declare a new thread local storage key of type `std::thread_local::Key`.\n #[macro_export]\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n macro_rules! thread_local {\n     (static $name:ident: $t:ty = $init:expr) => (\n         static $name: ::std::thread_local::Key<$t> = {\n@@ -218,7 +218,8 @@ macro_rules! __thread_local_inner {\n }\n \n /// Indicator of the state of a thread local storage key.\n-#[unstable = \"state querying was recently added\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+           reason = \"state querying was recently added\")]\n #[derive(Eq, PartialEq, Copy)]\n pub enum State {\n     /// All keys are in this state whenever a thread starts. Keys will\n@@ -258,7 +259,7 @@ impl<T: 'static> Key<T> {\n     /// This function will `panic!()` if the key currently has its\n     /// destructor running, and it **may** panic if the destructor has\n     /// previously been run for this thread.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn with<F, R>(&'static self, f: F) -> R\n                       where F: FnOnce(&T) -> R {\n         let slot = (self.inner)();\n@@ -301,7 +302,8 @@ impl<T: 'static> Key<T> {\n     /// initialization does not panic. Keys in the `Valid` state are guaranteed\n     /// to be able to be accessed. Keys in the `Destroyed` state will panic on\n     /// any call to `with`.\n-    #[unstable = \"state querying was recently added\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"state querying was recently added\")]\n     pub fn state(&'static self) -> State {\n         unsafe {\n             match (self.inner)().get() {\n@@ -317,7 +319,8 @@ impl<T: 'static> Key<T> {\n     }\n \n     /// Deprecated\n-    #[deprecated = \"function renamed to state() and returns more info\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\",\n+                 reason = \"function renamed to state() and returns more info\")]\n     pub fn destroyed(&'static self) -> bool { self.state() == State::Destroyed }\n }\n "}, {"sha": "e7062b298d28d06cbf749bc46971c2ffb1604de8", "filename": "src/libstd/thread_local/scoped.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fthread_local%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Fthread_local%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fscoped.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -38,8 +38,9 @@\n //! });\n //! ```\n \n-#![unstable = \"scoped TLS has yet to have wide enough use to fully consider \\\n-               stabilizing its interface\"]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+            reason = \"scoped TLS has yet to have wide enough use to fully consider \\\n+                      stabilizing its interface\")]\n \n use prelude::v1::*;\n "}, {"sha": "90fd3b0138f7150a0914ab50ca09f1630a6d5192", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,7 +10,7 @@\n \n //! Temporal quantification\n \n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n \n use {fmt, i64};\n use ops::{Add, Sub, Mul, Div, Neg, FnOnce};"}, {"sha": "b06deb738fc7b617d3572bac27817110bfb61636", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -57,4 +57,4 @@\n //! ```\n \n #![doc(primitive = \"tuple\")]\n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]"}, {"sha": "0893fe8ea0653b64c666bf0a08dcfb9f76eeb787", "filename": "src/libstd/unit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibstd%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funit.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![doc(primitive = \"unit\")]\n-#![stable]\n+#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n \n //! The `()` type, sometimes called \"unit\" or \"nil\".\n //!"}, {"sha": "9aa226103f37a3ad3ee5859a6c037a239d5812ff", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 64, "deletions": 8, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -21,7 +21,7 @@ use codemap::{Span, Spanned, spanned, dummy_spanned};\n use codemap::BytePos;\n use diagnostic::SpanHandler;\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n-use parse::token::InternedString;\n+use parse::token::{InternedString, intern_and_get_ident};\n use parse::token;\n use ptr::P;\n \n@@ -56,6 +56,8 @@ pub trait AttrMetaMethods {\n     fn value_str(&self) -> Option<InternedString>;\n     /// Gets a list of inner meta items from a list MetaItem type.\n     fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]>;\n+\n+    fn span(&self) -> Span;\n }\n \n impl AttrMetaMethods for Attribute {\n@@ -73,6 +75,7 @@ impl AttrMetaMethods for Attribute {\n     fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]> {\n         self.node.value.meta_item_list()\n     }\n+    fn span(&self) -> Span { self.meta().span }\n }\n \n impl AttrMetaMethods for MetaItem {\n@@ -102,6 +105,7 @@ impl AttrMetaMethods for MetaItem {\n             _ => None\n         }\n     }\n+    fn span(&self) -> Span { self.span }\n }\n \n // Annoying, but required to get test_cfg to work\n@@ -111,6 +115,7 @@ impl AttrMetaMethods for P<MetaItem> {\n     fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]> {\n         (**self).meta_item_list()\n     }\n+    fn span(&self) -> Span { (**self).span() }\n }\n \n \n@@ -340,11 +345,13 @@ pub fn cfg_matches(diagnostic: &SpanHandler, cfgs: &[P<MetaItem>], cfg: &ast::Me\n     }\n }\n \n-/// Represents the #[deprecated=\"foo\"] and friends attributes.\n+/// Represents the #[deprecated] and friends attributes.\n #[derive(RustcEncodable,RustcDecodable,Clone,Show)]\n pub struct Stability {\n     pub level: StabilityLevel,\n-    pub text: Option<InternedString>\n+    pub feature: InternedString,\n+    pub since: InternedString,\n+    pub reason: Option<InternedString>,\n }\n \n /// The available stability levels.\n@@ -364,7 +371,7 @@ impl fmt::String for StabilityLevel {\n pub fn find_stability_generic<'a,\n                               AM: AttrMetaMethods,\n                               I: Iterator<Item=&'a AM>>\n-                             (mut attrs: I)\n+                             (diagnostic: &SpanHandler, mut attrs: I)\n                              -> Option<(Stability, &'a AM)> {\n     for attr in attrs {\n         let level = match attr.name().get() {\n@@ -374,17 +381,66 @@ pub fn find_stability_generic<'a,\n             _ => continue // not a stability level\n         };\n \n+        let (feature, since, reason) = match attr.meta_item_list() {\n+            Some(metas) => {\n+                let mut feature = None;\n+                let mut since = None;\n+                let mut reason = None;\n+                for meta in metas.iter() {\n+                    if meta.name().get() == \"feature\" {\n+                        match meta.value_str() {\n+                            Some(v) => feature = Some(v),\n+                            None => {\n+                                diagnostic.span_err(meta.span, \"incorrect meta item\");\n+                            }\n+                        }\n+                    }\n+                    if meta.name().get() == \"since\" {\n+                        match meta.value_str() {\n+                            Some(v) => since = Some(v),\n+                            None => {\n+                                diagnostic.span_err(meta.span, \"incorrect meta item\");\n+                            }\n+                        }\n+                    }\n+                    if meta.name().get() == \"reason\" {\n+                        match meta.value_str() {\n+                            Some(v) => reason = Some(v),\n+                            None => {\n+                                diagnostic.span_err(meta.span, \"incorrect meta item\");\n+                            }\n+                        }\n+                    }\n+                }\n+                (feature, since, reason)\n+            }\n+            None => {\n+                diagnostic.span_err(attr.span(), \"incorrect stability attribute type\");\n+                (None, None, None)\n+            }\n+        };\n+\n+        if feature == None {\n+            diagnostic.span_err(attr.span(), \"missing 'feature'\");\n+        }\n+\n+        if since == None {\n+            diagnostic.span_err(attr.span(), \"missing 'since'\");\n+        }\n+\n         return Some((Stability {\n             level: level,\n-                text: attr.value_str()\n-            }, attr));\n+            feature: feature.unwrap_or(intern_and_get_ident(\"bogus\")),\n+            since: since.unwrap_or(intern_and_get_ident(\"bogus\")),\n+            reason: reason,\n+        }, attr));\n     }\n     None\n }\n \n /// Find the first stability attribute. `None` if none exists.\n-pub fn find_stability(attrs: &[Attribute]) -> Option<Stability> {\n-    find_stability_generic(attrs.iter()).map(|(s, attr)| {\n+pub fn find_stability(diagnostic: &SpanHandler, attrs: &[Attribute]) -> Option<Stability> {\n+    find_stability_generic(diagnostic, attrs.iter()).map(|(s, attr)| {\n         mark_used(attr);\n         s\n     })"}, {"sha": "cd04332b47f4836780e61b361c1bd9c079f4d1f1", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -568,7 +568,8 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n \n-    #[deprecated = \"Replaced with `expander().fold_expr()`\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\",\n+                 reason = \"Replaced with `expander().fold_expr()`\")]\n     pub fn expand_expr(&mut self, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expander().fold_expr(e)\n     }"}, {"sha": "d8a0c51b5ab5a3b6c29aa515782e5635601a964e", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -15,7 +15,7 @@\n //! This API is completely unstable and subject to change.\n \n #![crate_name = \"syntax\"]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]"}, {"sha": "342fed1653d10bd78ce18da12473246e90660c58", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -112,7 +112,7 @@ impl<T> SmallVector<T> {\n     }\n \n     /// Deprecated: use `into_iter`.\n-    #[deprecated = \"use into_iter\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\", reason = \"use into_iter\")]\n     pub fn move_iter(self) -> IntoIter<T> {\n         self.into_iter()\n     }"}, {"sha": "a6ec16445c277ff4d6258a51eace1fa189526fee", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -39,7 +39,8 @@\n //! [ti]: https://en.wikipedia.org/wiki/Terminfo\n \n #![crate_name = \"term\"]\n-#![unstable = \"use the crates.io `term` library instead\"]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+            reason = \"use the crates.io `term` library instead\")]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]"}, {"sha": "be7410d901a0499c49c9ae0d74c48aaede670120", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -24,7 +24,7 @@\n // build off of.\n \n #![crate_name = \"test\"]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]"}, {"sha": "6fc6f61430865d32954c0430f875370a5363ecf2", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -21,7 +21,7 @@\n //! (yet) aim to provide a full set of Unicode tables.\n \n #![crate_name = \"unicode\"]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -59,7 +59,7 @@ mod u_str;\n /// (inclusive) are allowed. A `char` can always be safely cast to a `u32`;\n /// however the converse is not always true due to the above range limits\n /// and, as such, should be performed via the `from_u32` function..\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub mod char {\n     pub use core::char::{MAX, from_u32, from_digit};\n "}, {"sha": "64515ddf22f6749c2a3fd9ca9d16b45fddee7270", "filename": "src/libunicode/u_char.rs", "status": "modified", "additions": 60, "deletions": 42, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibunicode%2Fu_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibunicode%2Fu_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_char.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -19,7 +19,7 @@ use core::option::Option;\n use tables::{derived_property, property, general_category, conversions, charwidth};\n \n /// Functionality for manipulating `char`.\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait CharExt {\n     /// Checks if a `char` parses as a numeric digit in the given radix.\n     ///\n@@ -34,7 +34,8 @@ pub trait CharExt {\n     /// # Panics\n     ///\n     /// Panics if given a radix > 36.\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending integer conventions\")]\n     fn is_digit(self, radix: uint) -> bool;\n \n     /// Converts a character to the corresponding digit.\n@@ -48,7 +49,8 @@ pub trait CharExt {\n     /// # Panics\n     ///\n     /// Panics if given a radix outside the range [0..36].\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending integer conventions\")]\n     fn to_digit(self, radix: uint) -> Option<uint>;\n \n     /// Returns an iterator that yields the hexadecimal Unicode escape\n@@ -57,7 +59,7 @@ pub trait CharExt {\n     /// All characters are escaped with Rust syntax of the form `\\\\u{NNNN}`\n     /// where `NNNN` is the shortest hexadecimal representation of the code\n     /// point.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn escape_unicode(self) -> char::EscapeUnicode;\n \n     /// Returns an iterator that yields the 'default' ASCII and\n@@ -72,38 +74,40 @@ pub trait CharExt {\n     ///   escaped.\n     /// * Any other chars in the range [0x20,0x7e] are not escaped.\n     /// * Any other chars are given hex Unicode escapes; see `escape_unicode`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn escape_default(self) -> char::EscapeDefault;\n \n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-8.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn len_utf8(self) -> uint;\n \n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-16.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn len_utf16(self) -> uint;\n \n     /// Encodes this character as UTF-8 into the provided byte buffer,\n     /// and then returns the number of bytes written.\n     ///\n     /// If the buffer is not large enough, nothing will be written into it\n     /// and a `None` will be returned.\n-    #[unstable = \"pending decision about Iterator/Writer/Reader\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf8(self, dst: &mut [u8]) -> Option<uint>;\n \n     /// Encodes this character as UTF-16 into the provided `u16` buffer,\n     /// and then returns the number of `u16`s written.\n     ///\n     /// If the buffer is not large enough, nothing will be written into it\n     /// and a `None` will be returned.\n-    #[unstable = \"pending decision about Iterator/Writer/Reader\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf16(self, dst: &mut [u16]) -> Option<uint>;\n \n     /// Returns whether the specified character is considered a Unicode\n     /// alphabetic code point.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn is_alphabetic(self) -> bool;\n \n     /// Returns whether the specified character satisfies the 'XID_Start'\n@@ -112,7 +116,8 @@ pub trait CharExt {\n     /// 'XID_Start' is a Unicode Derived Property specified in\n     /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n     /// mostly similar to ID_Start but modified for closure under NFKx.\n-    #[unstable = \"mainly needed for compiler internals\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"mainly needed for compiler internals\")]\n     fn is_xid_start(self) -> bool;\n \n     /// Returns whether the specified `char` satisfies the 'XID_Continue'\n@@ -121,45 +126,46 @@ pub trait CharExt {\n     /// 'XID_Continue' is a Unicode Derived Property specified in\n     /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n     /// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n-    #[unstable = \"mainly needed for compiler internals\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"mainly needed for compiler internals\")]\n     fn is_xid_continue(self) -> bool;\n \n     /// Indicates whether a character is in lowercase.\n     ///\n     /// This is defined according to the terms of the Unicode Derived Core\n     /// Property `Lowercase`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn is_lowercase(self) -> bool;\n \n     /// Indicates whether a character is in uppercase.\n     ///\n     /// This is defined according to the terms of the Unicode Derived Core\n     /// Property `Uppercase`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn is_uppercase(self) -> bool;\n \n     /// Indicates whether a character is whitespace.\n     ///\n     /// Whitespace is defined in terms of the Unicode Property `White_Space`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn is_whitespace(self) -> bool;\n \n     /// Indicates whether a character is alphanumeric.\n     ///\n     /// Alphanumericness is defined in terms of the Unicode General Categories\n     /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn is_alphanumeric(self) -> bool;\n \n     /// Indicates whether a character is a control code point.\n     ///\n     /// Control code points are defined in terms of the Unicode General\n     /// Category `Cc`.\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn is_control(self) -> bool;\n \n     /// Indicates whether the character is numeric (Nd, Nl, or No).\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn is_numeric(self) -> bool;\n \n     /// Converts a character to its lowercase equivalent.\n@@ -171,7 +177,8 @@ pub trait CharExt {\n     ///\n     /// Returns the lowercase equivalent of the character, or the character\n     /// itself if no conversion is possible.\n-    #[unstable = \"pending case transformation decisions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending case transformation decisions\")]\n     fn to_lowercase(self) -> char;\n \n     /// Converts a character to its uppercase equivalent.\n@@ -194,7 +201,8 @@ pub trait CharExt {\n     /// [`SpecialCasing`.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n     ///\n     /// [2]: http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992\n-    #[unstable = \"pending case transformation decisions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending case transformation decisions\")]\n     fn to_uppercase(self) -> char;\n \n     /// Returns this character's displayed width in columns, or `None` if it is a\n@@ -206,30 +214,35 @@ pub trait CharExt {\n     /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n     /// recommends that these characters be treated as 1 column (i.e.,\n     /// `is_cjk` = `false`) if the context cannot be reliably determined.\n-    #[unstable = \"needs expert opinion. is_cjk flag stands out as ugly\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"needs expert opinion. is_cjk flag stands out as ugly\")]\n     fn width(self, is_cjk: bool) -> Option<uint>;\n }\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl CharExt for char {\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending integer conventions\")]\n     fn is_digit(self, radix: uint) -> bool { C::is_digit(self, radix) }\n-    #[unstable = \"pending integer conventions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending integer conventions\")]\n     fn to_digit(self, radix: uint) -> Option<uint> { C::to_digit(self, radix) }\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn escape_unicode(self) -> char::EscapeUnicode { C::escape_unicode(self) }\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn escape_default(self) -> char::EscapeDefault { C::escape_default(self) }\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn len_utf8(self) -> uint { C::len_utf8(self) }\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn len_utf16(self) -> uint { C::len_utf16(self) }\n-    #[unstable = \"pending decision about Iterator/Writer/Reader\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf8(self, dst: &mut [u8]) -> Option<uint> { C::encode_utf8(self, dst) }\n-    #[unstable = \"pending decision about Iterator/Writer/Reader\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf16(self, dst: &mut [u16]) -> Option<uint> { C::encode_utf16(self, dst) }\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn is_alphabetic(self) -> bool {\n         match self {\n             'a' ... 'z' | 'A' ... 'Z' => true,\n@@ -238,13 +251,15 @@ impl CharExt for char {\n         }\n     }\n \n-    #[unstable = \"mainly needed for compiler internals\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"mainly needed for compiler internals\")]\n     fn is_xid_start(self) -> bool { derived_property::XID_Start(self) }\n \n-    #[unstable = \"mainly needed for compiler internals\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"mainly needed for compiler internals\")]\n     fn is_xid_continue(self) -> bool { derived_property::XID_Continue(self) }\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn is_lowercase(self) -> bool {\n         match self {\n             'a' ... 'z' => true,\n@@ -253,7 +268,7 @@ impl CharExt for char {\n         }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn is_uppercase(self) -> bool {\n         match self {\n             'A' ... 'Z' => true,\n@@ -262,7 +277,7 @@ impl CharExt for char {\n         }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn is_whitespace(self) -> bool {\n         match self {\n             ' ' | '\\x09' ... '\\x0d' => true,\n@@ -271,15 +286,15 @@ impl CharExt for char {\n         }\n     }\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn is_alphanumeric(self) -> bool {\n         self.is_alphabetic() || self.is_numeric()\n     }\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn is_control(self) -> bool { general_category::Cc(self) }\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn is_numeric(self) -> bool {\n         match self {\n             '0' ... '9' => true,\n@@ -288,12 +303,15 @@ impl CharExt for char {\n         }\n     }\n \n-    #[unstable = \"pending case transformation decisions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending case transformation decisions\")]\n     fn to_lowercase(self) -> char { conversions::to_lower(self) }\n \n-    #[unstable = \"pending case transformation decisions\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"pending case transformation decisions\")]\n     fn to_uppercase(self) -> char { conversions::to_upper(self) }\n \n-    #[unstable = \"needs expert opinion. is_cjk flag stands out as ugly\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\",\n+               reason = \"needs expert opinion. is_cjk flag stands out as ugly\")]\n     fn width(self, is_cjk: bool) -> Option<uint> { charwidth::width(self, is_cjk) }\n }"}, {"sha": "0ee8c028fa7f1a14e69e384a72b496fbaf2daa17", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -30,7 +30,7 @@ use u_char::CharExt as UCharExt; // conflicts with core::prelude::CharExt\n use tables::grapheme::GraphemeCat;\n \n /// An iterator over the words of a string, separated by a sequence of whitespace\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct Words<'a> {\n     inner: Filter<&'a str, Split<'a, fn(char) -> bool>, fn(&&str) -> bool>,\n }"}, {"sha": "ada75c0e1492b7538d526a69236d146a035347d5", "filename": "src/test/auxiliary/inherited_stability.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Ftest%2Fauxiliary%2Finherited_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Ftest%2Fauxiliary%2Finherited_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Finherited_stability.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -9,52 +9,45 @@\n // except according to those terms.\n #![crate_name=\"inherited_stability\"]\n #![crate_type = \"lib\"]\n-#![unstable]\n+#![unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n #![staged_api]\n \n-pub fn experimental() {}\n+pub fn unstable() {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub fn stable() {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub mod stable_mod {\n-    pub fn experimental() {}\n+    pub fn unstable() {}\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn stable() {}\n }\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub mod unstable_mod {\n-    #[unstable]\n-    pub fn experimental() {}\n+    #[deprecated(feature = \"unnamed_feature\", since = \"1.0.0\")]\n+    pub fn deprecated() {}\n \n     pub fn unstable() {}\n }\n \n-pub mod experimental_mod {\n-    pub fn experimental() {}\n-\n-    #[stable]\n-    pub fn stable() {}\n-}\n-\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait Stable {\n-    fn experimental(&self);\n+    fn unstable(&self);\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn stable(&self);\n }\n \n impl Stable for uint {\n-    fn experimental(&self) {}\n+    fn unstable(&self) {}\n     fn stable(&self) {}\n }\n \n-pub enum Experimental {\n-    ExperimentalVariant,\n-    #[stable]\n+pub enum Unstable {\n+    UnstableVariant,\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     StableVariant\n }"}, {"sha": "3af319197e3bb3b392324bdcbcac5b5c90dd371b", "filename": "src/test/auxiliary/lint_output_format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Ftest%2Fauxiliary%2Flint_output_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Ftest%2Fauxiliary%2Flint_output_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_output_format.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -12,17 +12,17 @@\n #![crate_type = \"lib\"]\n #![staged_api]\n \n-#[deprecated]\n+#[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n pub fn foo() -> uint {\n     20\n }\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub fn bar() -> uint {\n     40\n }\n \n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub fn baz() -> uint {\n     30\n }"}, {"sha": "31746c062b50ceabfea21857db7e015847aa49c4", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 33, "deletions": 82, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -11,62 +11,42 @@\n #![crate_type = \"lib\"]\n #![staged_api]\n \n-#[deprecated]\n+#[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n pub fn deprecated() {}\n-#[deprecated=\"text\"]\n+#[deprecated(feature = \"oldstuff\", since = \"1.0.0\", reason = \"text\")]\n pub fn deprecated_text() {}\n \n-#[unstable]\n-pub fn experimental() {}\n-#[unstable=\"text\"]\n-pub fn experimental_text() {}\n-\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub fn unstable() {}\n-#[unstable=\"text\"]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"text\")]\n pub fn unstable_text() {}\n \n pub fn unmarked() {}\n \n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub fn stable() {}\n-#[stable=\"text\"]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\", reason = \"text\")]\n pub fn stable_text() {}\n \n-#[locked]\n-pub fn locked() {}\n-#[locked=\"text\"]\n-pub fn locked_text() {}\n-\n-#[frozen]\n-pub fn frozen() {}\n-#[frozen=\"text\"]\n-pub fn frozen_text() {}\n-\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct MethodTester;\n \n impl MethodTester {\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     pub fn method_deprecated(&self) {}\n-    #[deprecated=\"text\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\", reason = \"text\")]\n     pub fn method_deprecated_text(&self) {}\n \n-    #[unstable]\n-    pub fn method_experimental(&self) {}\n-    #[unstable=\"text\"]\n-    pub fn method_experimental_text(&self) {}\n-\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn method_unstable(&self) {}\n-    #[unstable=\"text\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"text\")]\n     pub fn method_unstable_text(&self) {}\n \n     pub fn method_unmarked(&self) {}\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn method_stable(&self) {}\n-    #[stable=\"text\"]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\", reason = \"text\")]\n     pub fn method_stable_text(&self) {}\n \n     #[locked]\n@@ -81,26 +61,21 @@ impl MethodTester {\n }\n \n pub trait Trait {\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     fn trait_deprecated(&self) {}\n-    #[deprecated=\"text\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\", reason = \"text\")]\n     fn trait_deprecated_text(&self) {}\n \n-    #[unstable]\n-    fn trait_experimental(&self) {}\n-    #[unstable=\"text\"]\n-    fn trait_experimental_text(&self) {}\n-\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     fn trait_unstable(&self) {}\n-    #[unstable=\"text\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"text\")]\n     fn trait_unstable_text(&self) {}\n \n     fn trait_unmarked(&self) {}\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn trait_stable(&self) {}\n-    #[stable=\"text\"]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\", reason = \"text\")]\n     fn trait_stable_text(&self) {}\n \n     #[locked]\n@@ -116,67 +91,43 @@ pub trait Trait {\n \n impl Trait for MethodTester {}\n \n-#[unstable]\n-pub trait ExperimentalTrait {}\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n+pub trait UnstableTrait {}\n \n-#[deprecated]\n+#[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n pub struct DeprecatedStruct { pub i: int }\n-#[unstable]\n-pub struct ExperimentalStruct { pub i: int }\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub struct UnstableStruct { pub i: int }\n pub struct UnmarkedStruct { pub i: int }\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct StableStruct { pub i: int }\n-#[frozen]\n-pub struct FrozenStruct { pub i: int }\n-#[locked]\n-pub struct LockedStruct { pub i: int }\n \n-#[deprecated]\n+#[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n pub struct DeprecatedUnitStruct;\n-#[unstable]\n-pub struct ExperimentalUnitStruct;\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub struct UnstableUnitStruct;\n pub struct UnmarkedUnitStruct;\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct StableUnitStruct;\n-#[frozen]\n-pub struct FrozenUnitStruct;\n-#[locked]\n-pub struct LockedUnitStruct;\n \n pub enum Enum {\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     DeprecatedVariant,\n-    #[unstable]\n-    ExperimentalVariant,\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     UnstableVariant,\n \n     UnmarkedVariant,\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     StableVariant,\n-    #[frozen]\n-    FrozenVariant,\n-    #[locked]\n-    LockedVariant,\n }\n \n-#[deprecated]\n+#[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n pub struct DeprecatedTupleStruct(pub int);\n-#[unstable]\n-pub struct ExperimentalTupleStruct(pub int);\n-#[unstable]\n+#[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n pub struct UnstableTupleStruct(pub int);\n pub struct UnmarkedTupleStruct(pub int);\n-#[stable]\n+#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct StableTupleStruct(pub int);\n-#[frozen]\n-pub struct FrozenTupleStruct(pub int);\n-#[locked]\n-pub struct LockedTupleStruct(pub int);\n \n #[macro_export]\n macro_rules! macro_test {"}, {"sha": "68503f15bd88f4abe8cd1bf74cf49802e08996b4", "filename": "src/test/auxiliary/stability_cfg1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Ftest%2Fauxiliary%2Fstability_cfg1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Ftest%2Fauxiliary%2Fstability_cfg1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstability_cfg1.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n #![cfg_attr(foo, experimental)]\n-#![cfg_attr(not(foo), stable)]\n+#![cfg_attr(not(foo), stable(feature = \"unnamed_feature\", since = \"1.0.0\"))]\n #![staged_api]"}, {"sha": "19fa7a4f988c2cf9a822648795a0af820caa56ac", "filename": "src/test/auxiliary/stability_cfg2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Ftest%2Fauxiliary%2Fstability_cfg2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Ftest%2Fauxiliary%2Fstability_cfg2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstability_cfg2.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -10,6 +10,6 @@\n \n // compile-flags:--cfg foo\n \n-#![cfg_attr(foo, unstable)]\n-#![cfg_attr(not(foo), stable)]\n+#![cfg_attr(foo, unstable(feature = \"unnamed_feature\", since = \"1.0.0\"))]\n+#![cfg_attr(not(foo), stable(feature = \"unnamed_feature\", since = \"1.0.0\"))]\n #![staged_api]"}, {"sha": "200888ff2f8af93dc6dcf6c925432a457926f74e", "filename": "src/test/compile-fail/issue-17337.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Ftest%2Fcompile-fail%2Fissue-17337.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Ftest%2Fcompile-fail%2Fissue-17337.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17337.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -14,7 +14,7 @@\n struct Foo;\n \n impl Foo {\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     fn foo(self) {}\n }\n "}, {"sha": "89509ac9a9b1991b5668cebbdd2ebe32efbe2905", "filename": "src/test/compile-fail/issue-20711-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Ftest%2Fcompile-fail%2Fissue-20711-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Ftest%2Fcompile-fail%2Fissue-20711-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20711-2.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -13,7 +13,7 @@ struct Foo;\n impl Foo {\n     fn foo() {}\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n } //~ ERROR expected `fn`, found `}`\n \n fn main() {}"}, {"sha": "409d35684565d2706fc1a1b037af640531a9e6f8", "filename": "src/test/compile-fail/issue-20711.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Ftest%2Fcompile-fail%2Fissue-20711.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Ftest%2Fcompile-fail%2Fissue-20711.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20711.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -11,7 +11,7 @@\n struct Foo;\n \n impl Foo {\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n } //~ ERROR expected `fn`, found `}`\n \n fn main() {}"}, {"sha": "316c971e016ff6fb2019ef22d54671f8eec7e2c9", "filename": "src/test/compile-fail/lint-stability.rs", "status": "modified", "additions": 42, "deletions": 194, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ca8a361026d1a622a961e8dc8cacc331ed1ac3/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=94ca8a361026d1a622a961e8dc8cacc331ed1ac3", "patch": "@@ -39,14 +39,6 @@ mod cross_crate {\n         foo.method_deprecated_text(); //~ ERROR use of deprecated item: text\n         foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n \n-        experimental(); //~ ERROR use of unstable item\n-        foo.method_experimental(); //~ ERROR use of unstable item\n-        foo.trait_experimental(); //~ ERROR use of unstable item\n-\n-        experimental_text(); //~ ERROR use of unstable item: text\n-        foo.method_experimental_text(); //~ ERROR use of unstable item: text\n-        foo.trait_experimental_text(); //~ ERROR use of unstable item: text\n-\n         unstable(); //~ ERROR use of unstable item\n         foo.method_unstable(); //~ ERROR use of unstable item\n         foo.trait_unstable(); //~ ERROR use of unstable item\n@@ -67,53 +59,25 @@ mod cross_crate {\n         foo.method_stable_text();\n         foo.trait_stable_text();\n \n-        frozen();\n-        foo.method_frozen();\n-        foo.trait_frozen();\n-\n-        frozen_text();\n-        foo.method_frozen_text();\n-        foo.trait_frozen_text();\n-\n-        locked();\n-        foo.method_locked();\n-        foo.trait_locked();\n-\n-        locked_text();\n-        foo.method_locked_text();\n-        foo.trait_locked_text();\n-\n         let _ = DeprecatedStruct { i: 0 }; //~ ERROR use of deprecated item\n-        let _ = ExperimentalStruct { i: 0 }; //~ ERROR use of unstable item\n         let _ = UnstableStruct { i: 0 }; //~ ERROR use of unstable item\n         let _ = UnmarkedStruct { i: 0 }; //~ ERROR use of unmarked item\n         let _ = StableStruct { i: 0 };\n-        let _ = FrozenStruct { i: 0 };\n-        let _ = LockedStruct { i: 0 };\n \n         let _ = DeprecatedUnitStruct; //~ ERROR use of deprecated item\n-        let _ = ExperimentalUnitStruct; //~ ERROR use of unstable item\n         let _ = UnstableUnitStruct; //~ ERROR use of unstable item\n         let _ = UnmarkedUnitStruct; //~ ERROR use of unmarked item\n         let _ = StableUnitStruct;\n-        let _ = FrozenUnitStruct;\n-        let _ = LockedUnitStruct;\n \n         let _ = Enum::DeprecatedVariant; //~ ERROR use of deprecated item\n-        let _ = Enum::ExperimentalVariant; //~ ERROR use of unstable item\n         let _ = Enum::UnstableVariant; //~ ERROR use of unstable item\n         let _ = Enum::UnmarkedVariant; //~ ERROR use of unmarked item\n         let _ = Enum::StableVariant;\n-        let _ = Enum::FrozenVariant;\n-        let _ = Enum::LockedVariant;\n \n         let _ = DeprecatedTupleStruct (1); //~ ERROR use of deprecated item\n-        let _ = ExperimentalTupleStruct (1); //~ ERROR use of unstable item\n         let _ = UnstableTupleStruct (1); //~ ERROR use of unstable item\n         let _ = UnmarkedTupleStruct (1); //~ ERROR use of unmarked item\n         let _ = StableTupleStruct (1);\n-        let _ = FrozenTupleStruct (1);\n-        let _ = LockedTupleStruct (1);\n \n         // At the moment, the lint checker only checks stability in\n         // in the arguments of macros.\n@@ -129,8 +93,6 @@ mod cross_crate {\n     fn test_method_param<F: Trait>(foo: F) {\n         foo.trait_deprecated(); //~ ERROR use of deprecated item\n         foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n-        foo.trait_experimental(); //~ ERROR use of unstable item\n-        foo.trait_experimental_text(); //~ ERROR use of unstable item: text\n         foo.trait_unstable(); //~ ERROR use of unstable item\n         foo.trait_unstable_text(); //~ ERROR use of unstable item: text\n         foo.trait_unmarked(); //~ ERROR use of unmarked item\n@@ -140,8 +102,6 @@ mod cross_crate {\n     fn test_method_object(foo: &Trait) {\n         foo.trait_deprecated(); //~ ERROR use of deprecated item\n         foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n-        foo.trait_experimental(); //~ ERROR use of unstable item\n-        foo.trait_experimental_text(); //~ ERROR use of unstable item: text\n         foo.trait_unstable(); //~ ERROR use of unstable item\n         foo.trait_unstable_text(); //~ ERROR use of unstable item: text\n         foo.trait_unmarked(); //~ ERROR use of unmarked item\n@@ -150,201 +110,129 @@ mod cross_crate {\n \n     struct S;\n \n-    impl ExperimentalTrait for S { } //~ ERROR use of unstable item\n+    impl UnstableTrait for S { } //~ ERROR use of unstable item\n \n-    trait LocalTrait : ExperimentalTrait { } //~ ERROR use of unstable item\n+    trait LocalTrait : UnstableTrait { } //~ ERROR use of unstable item\n }\n \n mod inheritance {\n     extern crate inherited_stability; //~ ERROR: use of unstable item\n     use self::inherited_stability::*;\n \n     fn test_inheritance() {\n-        experimental(); //~ ERROR use of unstable item\n+        unstable(); //~ ERROR use of unstable item\n         stable();\n \n-        stable_mod::experimental(); //~ ERROR use of unstable item\n+        stable_mod::unstable(); //~ ERROR use of unstable item\n         stable_mod::stable();\n \n-        unstable_mod::experimental(); //~ ERROR use of unstable item\n+        unstable_mod::deprecated(); //~ ERROR use of deprecated item\n         unstable_mod::unstable(); //~ ERROR use of unstable item\n \n-        experimental_mod::experimental(); //~ ERROR use of unstable item\n-        experimental_mod::stable();\n-\n-        let _ = Experimental::ExperimentalVariant; //~ ERROR use of unstable item\n-        let _ = Experimental::StableVariant;\n+        let _ = Unstable::UnstableVariant; //~ ERROR use of unstable item\n+        let _ = Unstable::StableVariant;\n \n         let x: usize = 0;\n-        x.experimental(); //~ ERROR use of unstable item\n+        x.unstable(); //~ ERROR use of unstable item\n         x.stable();\n     }\n }\n \n mod this_crate {\n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     pub fn deprecated() {}\n-    #[deprecated=\"text\"]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\", reason = \"text\")]\n     pub fn deprecated_text() {}\n \n-    #[unstable]\n-    pub fn experimental() {}\n-    #[unstable=\"text\"]\n-    pub fn experimental_text() {}\n-\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub fn unstable() {}\n-    #[unstable=\"text\"]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"text\")]\n     pub fn unstable_text() {}\n \n     pub fn unmarked() {}\n \n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub fn stable() {}\n-    #[stable=\"text\"]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\", reason = \"text\")]\n     pub fn stable_text() {}\n \n-    #[locked]\n-    pub fn locked() {}\n-    #[locked=\"text\"]\n-    pub fn locked_text() {}\n-\n-    #[frozen]\n-    pub fn frozen() {}\n-    #[frozen=\"text\"]\n-    pub fn frozen_text() {}\n-\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub struct MethodTester;\n \n     impl MethodTester {\n-        #[deprecated]\n+        #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n         pub fn method_deprecated(&self) {}\n-        #[deprecated=\"text\"]\n+        #[deprecated(feature = \"oldstuff\", since = \"1.0.0\", reason = \"text\")]\n         pub fn method_deprecated_text(&self) {}\n \n-        #[unstable]\n-        pub fn method_experimental(&self) {}\n-        #[unstable=\"text\"]\n-        pub fn method_experimental_text(&self) {}\n-\n-        #[unstable]\n+        #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n         pub fn method_unstable(&self) {}\n-        #[unstable=\"text\"]\n+        #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"text\")]\n         pub fn method_unstable_text(&self) {}\n \n         pub fn method_unmarked(&self) {}\n \n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         pub fn method_stable(&self) {}\n-        #[stable=\"text\"]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\", reason = \"text\")]\n         pub fn method_stable_text(&self) {}\n-\n-        #[locked]\n-        pub fn method_locked(&self) {}\n-        #[locked=\"text\"]\n-        pub fn method_locked_text(&self) {}\n-\n-        #[frozen]\n-        pub fn method_frozen(&self) {}\n-        #[frozen=\"text\"]\n-        pub fn method_frozen_text(&self) {}\n     }\n \n     pub trait Trait {\n-        #[deprecated]\n+        #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n         fn trait_deprecated(&self) {}\n-        #[deprecated=\"text\"]\n+        #[deprecated(feature = \"oldstuff\", since = \"1.0.0\", reason = \"text\")]\n         fn trait_deprecated_text(&self) {}\n \n-        #[unstable]\n-        fn trait_experimental(&self) {}\n-        #[unstable=\"text\"]\n-        fn trait_experimental_text(&self) {}\n-\n-        #[unstable]\n+        #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n         fn trait_unstable(&self) {}\n-        #[unstable=\"text\"]\n+        #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\", reason = \"text\")]\n         fn trait_unstable_text(&self) {}\n \n         fn trait_unmarked(&self) {}\n \n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         fn trait_stable(&self) {}\n-        #[stable=\"text\"]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\", reason = \"text\")]\n         fn trait_stable_text(&self) {}\n-\n-        #[locked]\n-        fn trait_locked(&self) {}\n-        #[locked=\"text\"]\n-        fn trait_locked_text(&self) {}\n-\n-        #[frozen]\n-        fn trait_frozen(&self) {}\n-        #[frozen=\"text\"]\n-        fn trait_frozen_text(&self) {}\n     }\n \n     impl Trait for MethodTester {}\n \n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     pub struct DeprecatedStruct { i: isize }\n-    #[unstable]\n-    pub struct ExperimentalStruct { i: isize }\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub struct UnstableStruct { i: isize }\n     pub struct UnmarkedStruct { i: isize }\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub struct StableStruct { i: isize }\n-    #[frozen]\n-    pub struct FrozenStruct { i: isize }\n-    #[locked]\n-    pub struct LockedStruct { i: isize }\n \n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     pub struct DeprecatedUnitStruct;\n-    #[unstable]\n-    pub struct ExperimentalUnitStruct;\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub struct UnstableUnitStruct;\n     pub struct UnmarkedUnitStruct;\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub struct StableUnitStruct;\n-    #[frozen]\n-    pub struct FrozenUnitStruct;\n-    #[locked]\n-    pub struct LockedUnitStruct;\n \n     pub enum Enum {\n-        #[deprecated]\n+        #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n         DeprecatedVariant,\n-        #[unstable]\n-        ExperimentalVariant,\n-        #[unstable]\n+        #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n         UnstableVariant,\n \n         UnmarkedVariant,\n-        #[stable]\n+        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n         StableVariant,\n-        #[frozen]\n-        FrozenVariant,\n-        #[locked]\n-        LockedVariant,\n     }\n \n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     pub struct DeprecatedTupleStruct(isize);\n-    #[unstable]\n-    pub struct ExperimentalTupleStruct(isize);\n-    #[unstable]\n+    #[unstable(feature = \"unnamed_feature\", since = \"1.0.0\")]\n     pub struct UnstableTupleStruct(isize);\n     pub struct UnmarkedTupleStruct(isize);\n-    #[stable]\n+    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub struct StableTupleStruct(isize);\n-    #[frozen]\n-    pub struct FrozenTupleStruct(isize);\n-    #[locked]\n-    pub struct LockedTupleStruct(isize);\n \n     fn test() {\n         // Only the deprecated cases of the following should generate\n@@ -361,14 +249,6 @@ mod this_crate {\n         foo.method_deprecated_text(); //~ ERROR use of deprecated item: text\n         foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n \n-        experimental();\n-        foo.method_experimental();\n-        foo.trait_experimental();\n-\n-        experimental_text();\n-        foo.method_experimental_text();\n-        foo.trait_experimental_text();\n-\n         unstable();\n         foo.method_unstable();\n         foo.trait_unstable();\n@@ -389,60 +269,30 @@ mod this_crate {\n         foo.method_stable_text();\n         foo.trait_stable_text();\n \n-        frozen();\n-        foo.method_frozen();\n-        foo.trait_frozen();\n-\n-        frozen_text();\n-        foo.method_frozen_text();\n-        foo.trait_frozen_text();\n-\n-        locked();\n-        foo.method_locked();\n-        foo.trait_locked();\n-\n-        locked_text();\n-        foo.method_locked_text();\n-        foo.trait_locked_text();\n-\n         let _ = DeprecatedStruct { i: 0 }; //~ ERROR use of deprecated item\n-        let _ = ExperimentalStruct { i: 0 };\n         let _ = UnstableStruct { i: 0 };\n         let _ = UnmarkedStruct { i: 0 };\n         let _ = StableStruct { i: 0 };\n-        let _ = FrozenStruct { i: 0 };\n-        let _ = LockedStruct { i: 0 };\n \n         let _ = DeprecatedUnitStruct; //~ ERROR use of deprecated item\n-        let _ = ExperimentalUnitStruct;\n         let _ = UnstableUnitStruct;\n         let _ = UnmarkedUnitStruct;\n         let _ = StableUnitStruct;\n-        let _ = FrozenUnitStruct;\n-        let _ = LockedUnitStruct;\n \n         let _ = Enum::DeprecatedVariant; //~ ERROR use of deprecated item\n-        let _ = Enum::ExperimentalVariant;\n         let _ = Enum::UnstableVariant;\n         let _ = Enum::UnmarkedVariant;\n         let _ = Enum::StableVariant;\n-        let _ = Enum::FrozenVariant;\n-        let _ = Enum::LockedVariant;\n \n         let _ = DeprecatedTupleStruct (1); //~ ERROR use of deprecated item\n-        let _ = ExperimentalTupleStruct (1);\n         let _ = UnstableTupleStruct (1);\n         let _ = UnmarkedTupleStruct (1);\n         let _ = StableTupleStruct (1);\n-        let _ = FrozenTupleStruct (1);\n-        let _ = LockedTupleStruct (1);\n     }\n \n     fn test_method_param<F: Trait>(foo: F) {\n         foo.trait_deprecated(); //~ ERROR use of deprecated item\n         foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n-        foo.trait_experimental();\n-        foo.trait_experimental_text();\n         foo.trait_unstable();\n         foo.trait_unstable_text();\n         foo.trait_unmarked();\n@@ -452,29 +302,27 @@ mod this_crate {\n     fn test_method_object(foo: &Trait) {\n         foo.trait_deprecated(); //~ ERROR use of deprecated item\n         foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n-        foo.trait_experimental();\n-        foo.trait_experimental_text();\n         foo.trait_unstable();\n         foo.trait_unstable_text();\n         foo.trait_unmarked();\n         foo.trait_stable();\n     }\n \n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     fn test_fn_body() {\n         fn fn_in_body() {}\n         fn_in_body();\n     }\n \n     impl MethodTester {\n-        #[deprecated]\n+        #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n         fn test_method_body(&self) {\n             fn fn_in_body() {}\n             fn_in_body();\n         }\n     }\n \n-    #[deprecated]\n+    #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     pub trait DeprecatedTrait {}\n \n     struct S;"}]}