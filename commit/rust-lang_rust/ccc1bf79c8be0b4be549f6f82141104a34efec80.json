{"sha": "ccc1bf79c8be0b4be549f6f82141104a34efec80", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjYzFiZjc5YzhiZTBiNGJlNTQ5ZjZmODIxNDExMDRhMzRlZmVjODA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-06-28T15:30:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-28T15:30:24Z"}, "message": "Rollup merge of #73757 - oli-obk:const_prop_hardening, r=wesleywiser\n\nConst prop: erase all block-only locals at the end of every block\n\nI messed up this erasure in https://github.com/rust-lang/rust/pull/73656#discussion_r446040140. I think it is too fragile to have the previous scheme. Let's benchmark the new scheme and see what happens.\n\nr? @wesleywiser\n\ncc @felix91gr", "tree": {"sha": "b9a736ae696425d03799e543641a436c101883e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9a736ae696425d03799e543641a436c101883e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccc1bf79c8be0b4be549f6f82141104a34efec80", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe+LeQCRBK7hj4Ov3rIwAAdHIIAJ6JMMzxQDgiDv/mnieRlc7N\nfiHlIbCqZ4XBLhtXFu4PFDkI4b4IteWqaEOTsHZaGuOgkiXpmKe5zjRaG5UOCIdj\n8yRAoW99W8OLHeWBlTZ3W3YMJt/lcgWLW1l7E4oLWQ9tlM6VBmiYrPbHg0n4E55J\nFFYJR/NstJ+KZooXfYa0vsJ0cTCIJtGb3TLwvy5bVuJ1KZ/3gQXMH1bzPyFm15Rk\n/lFOW1yXGVK2KVC4C+gHQ5tdLsqB5+12qws98wWv8blCMh+seLzJh2VPaCqnwRLG\n8McbEDaj9QtCMZvnsx77WKNHcX1y6siI3H/VeNbMcL2PnDobhfBucbaVBBTSJjQ=\n=RdxM\n-----END PGP SIGNATURE-----\n", "payload": "tree b9a736ae696425d03799e543641a436c101883e7\nparent ec4898977a849fc73c8d3198e45c6f17c2bf177a\nparent b9f4e0dbfd3181f9f57a650e7451c807116c5921\nauthor Manish Goregaokar <manishsmail@gmail.com> 1593358224 -0700\ncommitter GitHub <noreply@github.com> 1593358224 -0700\n\nRollup merge of #73757 - oli-obk:const_prop_hardening, r=wesleywiser\n\nConst prop: erase all block-only locals at the end of every block\n\nI messed up this erasure in https://github.com/rust-lang/rust/pull/73656#discussion_r446040140. I think it is too fragile to have the previous scheme. Let's benchmark the new scheme and see what happens.\n\nr? @wesleywiser\n\ncc @felix91gr\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccc1bf79c8be0b4be549f6f82141104a34efec80", "html_url": "https://github.com/rust-lang/rust/commit/ccc1bf79c8be0b4be549f6f82141104a34efec80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccc1bf79c8be0b4be549f6f82141104a34efec80/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec4898977a849fc73c8d3198e45c6f17c2bf177a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec4898977a849fc73c8d3198e45c6f17c2bf177a", "html_url": "https://github.com/rust-lang/rust/commit/ec4898977a849fc73c8d3198e45c6f17c2bf177a"}, {"sha": "b9f4e0dbfd3181f9f57a650e7451c807116c5921", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9f4e0dbfd3181f9f57a650e7451c807116c5921", "html_url": "https://github.com/rust-lang/rust/commit/b9f4e0dbfd3181f9f57a650e7451c807116c5921"}], "stats": {"total": 106, "additions": 90, "deletions": 16}, "files": [{"sha": "602876e3de1686e97ce6bb1513e05ba6492c3a85", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ccc1bf79c8be0b4be549f6f82141104a34efec80/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccc1bf79c8be0b4be549f6f82141104a34efec80/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=ccc1bf79c8be0b4be549f6f82141104a34efec80", "patch": "@@ -132,6 +132,10 @@ pub enum LocalValue<Tag = ()> {\n }\n \n impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n+    /// Read the local's value or error if the local is not yet live or not live anymore.\n+    ///\n+    /// Note: This may only be invoked from the `Machine::access_local` hook and not from\n+    /// anywhere else. You may be invalidating machine invariants if you do!\n     pub fn access(&self) -> InterpResult<'tcx, Operand<Tag>> {\n         match self.value {\n             LocalValue::Dead => throw_ub!(DeadLocal),\n@@ -144,6 +148,9 @@ impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n \n     /// Overwrite the local.  If the local can be overwritten in place, return a reference\n     /// to do so; otherwise return the `MemPlace` to consult instead.\n+    ///\n+    /// Note: This may only be invoked from the `Machine::access_local_mut` hook and not from\n+    /// anywhere else. You may be invalidating machine invariants if you do!\n     pub fn access_mut(\n         &mut self,\n     ) -> InterpResult<'tcx, Result<&mut LocalValue<Tag>, MemPlace<Tag>>> {"}, {"sha": "ec1c93c81657ee2e733c7306239d072f580be88d", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ccc1bf79c8be0b4be549f6f82141104a34efec80/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccc1bf79c8be0b4be549f6f82141104a34efec80/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=ccc1bf79c8be0b4be549f6f82141104a34efec80", "patch": "@@ -11,7 +11,7 @@ use rustc_span::def_id::DefId;\n \n use super::{\n     AllocId, Allocation, AllocationExtra, CheckInAllocMsg, Frame, ImmTy, InterpCx, InterpResult,\n-    Memory, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Scalar,\n+    LocalValue, MemPlace, Memory, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Scalar,\n };\n \n /// Data returned by Machine::stack_pop,\n@@ -192,6 +192,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     ) -> InterpResult<'tcx>;\n \n     /// Called to read the specified `local` from the `frame`.\n+    /// Since reading a ZST is not actually accessing memory or locals, this is never invoked\n+    /// for ZST reads.\n     #[inline]\n     fn access_local(\n         _ecx: &InterpCx<'mir, 'tcx, Self>,\n@@ -201,6 +203,21 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         frame.locals[local].access()\n     }\n \n+    /// Called to write the specified `local` from the `frame`.\n+    /// Since writing a ZST is not actually accessing memory or locals, this is never invoked\n+    /// for ZST reads.\n+    #[inline]\n+    fn access_local_mut<'a>(\n+        ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n+        frame: usize,\n+        local: mir::Local,\n+    ) -> InterpResult<'tcx, Result<&'a mut LocalValue<Self::PointerTag>, MemPlace<Self::PointerTag>>>\n+    where\n+        'tcx: 'mir,\n+    {\n+        ecx.stack_mut()[frame].locals[local].access_mut()\n+    }\n+\n     /// Called before a basic block terminator is executed.\n     /// You can use this to detect endlessly running programs.\n     #[inline]"}, {"sha": "b02b5219ba1a4f95c718983d27f127e942b26a42", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ccc1bf79c8be0b4be549f6f82141104a34efec80/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccc1bf79c8be0b4be549f6f82141104a34efec80/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=ccc1bf79c8be0b4be549f6f82141104a34efec80", "patch": "@@ -432,7 +432,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         })\n     }\n \n-    /// This is used by [priroda](https://github.com/oli-obk/priroda) to get an OpTy from a local\n+    /// Read from a local. Will not actually access the local if reading from a ZST.\n+    /// Will not access memory, instead an indirect `Operand` is returned.\n+    ///\n+    /// This is public because it is used by [priroda](https://github.com/oli-obk/priroda) to get an\n+    /// OpTy from a local\n     pub fn access_local(\n         &self,\n         frame: &super::Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,"}, {"sha": "3868150c6bd288f71cb2f076b60a0f356c4de628", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ccc1bf79c8be0b4be549f6f82141104a34efec80/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccc1bf79c8be0b4be549f6f82141104a34efec80/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=ccc1bf79c8be0b4be549f6f82141104a34efec80", "patch": "@@ -741,7 +741,7 @@ where\n         // but not factored as a separate function.\n         let mplace = match dest.place {\n             Place::Local { frame, local } => {\n-                match self.stack_mut()[frame].locals[local].access_mut()? {\n+                match M::access_local_mut(self, frame, local)? {\n                     Ok(local) => {\n                         // Local can be updated in-place.\n                         *local = LocalValue::Live(Operand::Immediate(src));\n@@ -974,7 +974,7 @@ where\n     ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, Option<Size>)> {\n         let (mplace, size) = match place.place {\n             Place::Local { frame, local } => {\n-                match self.stack_mut()[frame].locals[local].access_mut()? {\n+                match M::access_local_mut(self, frame, local)? {\n                     Ok(&mut local_val) => {\n                         // We need to make an allocation.\n \n@@ -998,7 +998,7 @@ where\n                         }\n                         // Now we can call `access_mut` again, asserting it goes well,\n                         // and actually overwrite things.\n-                        *self.stack_mut()[frame].locals[local].access_mut().unwrap().unwrap() =\n+                        *M::access_local_mut(self, frame, local).unwrap().unwrap() =\n                             LocalValue::Live(Operand::Indirect(mplace));\n                         (mplace, Some(size))\n                     }"}, {"sha": "841f1c2b647f6ff24c002bb1bd11710ed85ab124", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 57, "deletions": 11, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ccc1bf79c8be0b4be549f6f82141104a34efec80/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccc1bf79c8be0b4be549f6f82141104a34efec80/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=ccc1bf79c8be0b4be549f6f82141104a34efec80", "patch": "@@ -4,6 +4,7 @@\n use std::cell::Cell;\n \n use rustc_ast::ast::Mutability;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::DefKind;\n use rustc_hir::HirId;\n use rustc_index::bit_set::BitSet;\n@@ -28,7 +29,7 @@ use rustc_trait_selection::traits;\n use crate::const_eval::error_to_const_error;\n use crate::interpret::{\n     self, compile_time_machine, AllocId, Allocation, Frame, ImmTy, Immediate, InterpCx, LocalState,\n-    LocalValue, Memory, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy, Pointer,\n+    LocalValue, MemPlace, Memory, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy, Pointer,\n     ScalarMaybeUninit, StackPopCleanup,\n };\n use crate::transform::{MirPass, MirSource};\n@@ -151,11 +152,19 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n struct ConstPropMachine<'mir, 'tcx> {\n     /// The virtual call stack.\n     stack: Vec<Frame<'mir, 'tcx, (), ()>>,\n+    /// `OnlyInsideOwnBlock` locals that were written in the current block get erased at the end.\n+    written_only_inside_own_block_locals: FxHashSet<Local>,\n+    /// Locals that need to be cleared after every block terminates.\n+    only_propagate_inside_block_locals: BitSet<Local>,\n }\n \n impl<'mir, 'tcx> ConstPropMachine<'mir, 'tcx> {\n-    fn new() -> Self {\n-        Self { stack: Vec::new() }\n+    fn new(only_propagate_inside_block_locals: BitSet<Local>) -> Self {\n+        Self {\n+            stack: Vec::new(),\n+            written_only_inside_own_block_locals: Default::default(),\n+            only_propagate_inside_block_locals,\n+        }\n     }\n }\n \n@@ -227,6 +236,18 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         l.access()\n     }\n \n+    fn access_local_mut<'a>(\n+        ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n+        frame: usize,\n+        local: Local,\n+    ) -> InterpResult<'tcx, Result<&'a mut LocalValue<Self::PointerTag>, MemPlace<Self::PointerTag>>>\n+    {\n+        if frame == 0 && ecx.machine.only_propagate_inside_block_locals.contains(local) {\n+            ecx.machine.written_only_inside_own_block_locals.insert(local);\n+        }\n+        ecx.machine.stack[frame].locals[local].access_mut()\n+    }\n+\n     fn before_access_global(\n         _memory_extra: &(),\n         _alloc_id: AllocId,\n@@ -274,8 +295,6 @@ struct ConstPropagator<'mir, 'tcx> {\n     // Because we have `MutVisitor` we can't obtain the `SourceInfo` from a `Location`. So we store\n     // the last known `SourceInfo` here and just keep revisiting it.\n     source_info: Option<SourceInfo>,\n-    // Locals we need to forget at the end of the current block\n-    locals_of_current_block: BitSet<Local>,\n }\n \n impl<'mir, 'tcx> LayoutOf for ConstPropagator<'mir, 'tcx> {\n@@ -313,8 +332,20 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let param_env = tcx.param_env(def_id).with_reveal_all();\n \n         let span = tcx.def_span(def_id);\n-        let mut ecx = InterpCx::new(tcx, span, param_env, ConstPropMachine::new(), ());\n         let can_const_prop = CanConstProp::check(body);\n+        let mut only_propagate_inside_block_locals = BitSet::new_empty(can_const_prop.len());\n+        for (l, mode) in can_const_prop.iter_enumerated() {\n+            if *mode == ConstPropMode::OnlyInsideOwnBlock {\n+                only_propagate_inside_block_locals.insert(l);\n+            }\n+        }\n+        let mut ecx = InterpCx::new(\n+            tcx,\n+            span,\n+            param_env,\n+            ConstPropMachine::new(only_propagate_inside_block_locals),\n+            (),\n+        );\n \n         let ret = ecx\n             .layout_of(body.return_ty().subst(tcx, substs))\n@@ -345,7 +376,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             //FIXME(wesleywiser) we can't steal this because `Visitor::super_visit_body()` needs it\n             local_decls: body.local_decls.clone(),\n             source_info: None,\n-            locals_of_current_block: BitSet::new_empty(body.local_decls.len()),\n         }\n     }\n \n@@ -900,7 +930,6 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                                 Will remove it from const-prop after block is finished. Local: {:?}\",\n                                 place.local\n                             );\n-                            self.locals_of_current_block.insert(place.local);\n                         }\n                         ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n                             trace!(\"can't propagate into {:?}\", place);\n@@ -1089,10 +1118,27 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                 }\n             }\n         }\n-        // We remove all Locals which are restricted in propagation to their containing blocks.\n-        for local in self.locals_of_current_block.iter() {\n+\n+        // We remove all Locals which are restricted in propagation to their containing blocks and\n+        // which were modified in the current block.\n+        // Take it out of the ecx so we can get a mutable reference to the ecx for `remove_const`\n+        let mut locals = std::mem::take(&mut self.ecx.machine.written_only_inside_own_block_locals);\n+        for &local in locals.iter() {\n             Self::remove_const(&mut self.ecx, local);\n         }\n-        self.locals_of_current_block.clear();\n+        locals.clear();\n+        // Put it back so we reuse the heap of the storage\n+        self.ecx.machine.written_only_inside_own_block_locals = locals;\n+        if cfg!(debug_assertions) {\n+            // Ensure we are correctly erasing locals with the non-debug-assert logic.\n+            for local in self.ecx.machine.only_propagate_inside_block_locals.iter() {\n+                assert!(\n+                    self.get_const(local.into()).is_none()\n+                        || self\n+                            .layout_of(self.local_decls[local].ty)\n+                            .map_or(true, |layout| layout.is_zst())\n+                )\n+            }\n+        }\n     }\n }"}]}