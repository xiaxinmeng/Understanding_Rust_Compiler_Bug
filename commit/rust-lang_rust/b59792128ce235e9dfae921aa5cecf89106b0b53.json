{"sha": "b59792128ce235e9dfae921aa5cecf89106b0b53", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1OTc5MjEyOGNlMjM1ZTlkZmFlOTIxYWE1Y2VjZjg5MTA2YjBiNTM=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-11-21T21:22:13Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-11-27T18:20:30Z"}, "message": "Move `Constructor::apply` to `Fields`", "tree": {"sha": "e3ad8798aee355305ff217fed595b1f2c3e47785", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3ad8798aee355305ff217fed595b1f2c3e47785"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b59792128ce235e9dfae921aa5cecf89106b0b53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b59792128ce235e9dfae921aa5cecf89106b0b53", "html_url": "https://github.com/rust-lang/rust/commit/b59792128ce235e9dfae921aa5cecf89106b0b53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b59792128ce235e9dfae921aa5cecf89106b0b53/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9228570668803e3e6402770d55f23a12c9ae686", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9228570668803e3e6402770d55f23a12c9ae686", "html_url": "https://github.com/rust-lang/rust/commit/c9228570668803e3e6402770d55f23a12c9ae686"}], "stats": {"total": 182, "additions": 89, "deletions": 93}, "files": [{"sha": "75c12f379af4847efd499465514220709b755cea", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 89, "deletions": 93, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/b59792128ce235e9dfae921aa5cecf89106b0b53/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b59792128ce235e9dfae921aa5cecf89106b0b53/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=b59792128ce235e9dfae921aa5cecf89106b0b53", "patch": "@@ -993,93 +993,6 @@ impl<'tcx> Constructor<'tcx> {\n             }\n         }\n     }\n-\n-    /// Apply a constructor to a list of patterns, yielding a new pattern. `pats`\n-    /// must have as many elements as this constructor's arity.\n-    ///\n-    /// This is roughly the inverse of `specialize_constructor`.\n-    ///\n-    /// Examples:\n-    /// `self`: `Constructor::Single`\n-    /// `ty`: `(u32, u32, u32)`\n-    /// `pats`: `[10, 20, _]`\n-    /// returns `(10, 20, _)`\n-    ///\n-    /// `self`: `Constructor::Variant(Option::Some)`\n-    /// `ty`: `Option<bool>`\n-    /// `pats`: `[false]`\n-    /// returns `Some(false)`\n-    fn apply<'p>(&self, pcx: PatCtxt<'_, 'p, 'tcx>, fields: Fields<'p, 'tcx>) -> Pat<'tcx> {\n-        let mut subpatterns = fields.all_patterns();\n-\n-        let pat = match self {\n-            Single | Variant(_) => match pcx.ty.kind() {\n-                ty::Adt(..) | ty::Tuple(..) => {\n-                    let subpatterns = subpatterns\n-                        .enumerate()\n-                        .map(|(i, p)| FieldPat { field: Field::new(i), pattern: p })\n-                        .collect();\n-\n-                    if let ty::Adt(adt, substs) = pcx.ty.kind() {\n-                        if adt.is_enum() {\n-                            PatKind::Variant {\n-                                adt_def: adt,\n-                                substs,\n-                                variant_index: self.variant_index_for_adt(adt),\n-                                subpatterns,\n-                            }\n-                        } else {\n-                            PatKind::Leaf { subpatterns }\n-                        }\n-                    } else {\n-                        PatKind::Leaf { subpatterns }\n-                    }\n-                }\n-                // Note: given the expansion of `&str` patterns done in `expand_pattern`, we should\n-                // be careful to reconstruct the correct constant pattern here. However a string\n-                // literal pattern will never be reported as a non-exhaustiveness witness, so we\n-                // can ignore this issue.\n-                ty::Ref(..) => PatKind::Deref { subpattern: subpatterns.next().unwrap() },\n-                ty::Slice(_) | ty::Array(..) => bug!(\"bad slice pattern {:?} {:?}\", self, pcx.ty),\n-                _ => PatKind::Wild,\n-            },\n-            Slice(slice) => match slice.kind {\n-                FixedLen(_) => {\n-                    PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n-                }\n-                VarLen(prefix, _) => {\n-                    let mut prefix: Vec<_> = subpatterns.by_ref().take(prefix as usize).collect();\n-                    if slice.array_len.is_some() {\n-                        // Improves diagnostics a bit: if the type is a known-size array, instead\n-                        // of reporting `[x, _, .., _, y]`, we prefer to report `[x, .., y]`.\n-                        // This is incorrect if the size is not known, since `[_, ..]` captures\n-                        // arrays of lengths `>= 1` whereas `[..]` captures any length.\n-                        while !prefix.is_empty() && prefix.last().unwrap().is_wildcard() {\n-                            prefix.pop();\n-                        }\n-                    }\n-                    let suffix: Vec<_> = if slice.array_len.is_some() {\n-                        // Same as above.\n-                        subpatterns.skip_while(Pat::is_wildcard).collect()\n-                    } else {\n-                        subpatterns.collect()\n-                    };\n-                    let wild = Pat::wildcard_from_ty(pcx.ty);\n-                    PatKind::Slice { prefix, slice: Some(wild), suffix }\n-                }\n-            },\n-            &Str(value) => PatKind::Constant { value },\n-            &FloatRange(lo, hi, end) => PatKind::Range(PatRange { lo, hi, end }),\n-            IntRange(range) => return range.to_pat(pcx.cx.tcx),\n-            NonExhaustive => PatKind::Wild,\n-            Opaque => bug!(\"we should not try to apply an opaque constructor\"),\n-            Wildcard => bug!(\n-                \"trying to apply a wildcard constructor; this should have been done in `apply_constructors`\"\n-            ),\n-        };\n-\n-        Pat { ty: pcx.ty, span: DUMMY_SP, kind: Box::new(pat) }\n-    }\n }\n \n /// Some fields need to be explicitly hidden away in certain cases; see the comment above the\n@@ -1228,6 +1141,93 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         ret\n     }\n \n+    /// Apply a constructor to a list of patterns, yielding a new pattern. `self`\n+    /// must have as many elements as this constructor's arity.\n+    ///\n+    /// This is roughly the inverse of `specialize_constructor`.\n+    ///\n+    /// Examples:\n+    /// `ctor`: `Constructor::Single`\n+    /// `ty`: `Foo(u32, u32, u32)`\n+    /// `self`: `[10, 20, _]`\n+    /// returns `Foo(10, 20, _)`\n+    ///\n+    /// `ctor`: `Constructor::Variant(Option::Some)`\n+    /// `ty`: `Option<bool>`\n+    /// `self`: `[false]`\n+    /// returns `Some(false)`\n+    fn apply(self, pcx: PatCtxt<'_, 'p, 'tcx>, ctor: &Constructor<'tcx>) -> Pat<'tcx> {\n+        let mut subpatterns = self.all_patterns();\n+\n+        let pat = match ctor {\n+            Single | Variant(_) => match pcx.ty.kind() {\n+                ty::Adt(..) | ty::Tuple(..) => {\n+                    let subpatterns = subpatterns\n+                        .enumerate()\n+                        .map(|(i, p)| FieldPat { field: Field::new(i), pattern: p })\n+                        .collect();\n+\n+                    if let ty::Adt(adt, substs) = pcx.ty.kind() {\n+                        if adt.is_enum() {\n+                            PatKind::Variant {\n+                                adt_def: adt,\n+                                substs,\n+                                variant_index: ctor.variant_index_for_adt(adt),\n+                                subpatterns,\n+                            }\n+                        } else {\n+                            PatKind::Leaf { subpatterns }\n+                        }\n+                    } else {\n+                        PatKind::Leaf { subpatterns }\n+                    }\n+                }\n+                // Note: given the expansion of `&str` patterns done in `expand_pattern`, we should\n+                // be careful to reconstruct the correct constant pattern here. However a string\n+                // literal pattern will never be reported as a non-exhaustiveness witness, so we\n+                // can ignore this issue.\n+                ty::Ref(..) => PatKind::Deref { subpattern: subpatterns.next().unwrap() },\n+                ty::Slice(_) | ty::Array(..) => bug!(\"bad slice pattern {:?} {:?}\", ctor, pcx.ty),\n+                _ => PatKind::Wild,\n+            },\n+            Slice(slice) => match slice.kind {\n+                FixedLen(_) => {\n+                    PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n+                }\n+                VarLen(prefix, _) => {\n+                    let mut prefix: Vec<_> = subpatterns.by_ref().take(prefix as usize).collect();\n+                    if slice.array_len.is_some() {\n+                        // Improves diagnostics a bit: if the type is a known-size array, instead\n+                        // of reporting `[x, _, .., _, y]`, we prefer to report `[x, .., y]`.\n+                        // This is incorrect if the size is not known, since `[_, ..]` captures\n+                        // arrays of lengths `>= 1` whereas `[..]` captures any length.\n+                        while !prefix.is_empty() && prefix.last().unwrap().is_wildcard() {\n+                            prefix.pop();\n+                        }\n+                    }\n+                    let suffix: Vec<_> = if slice.array_len.is_some() {\n+                        // Same as above.\n+                        subpatterns.skip_while(Pat::is_wildcard).collect()\n+                    } else {\n+                        subpatterns.collect()\n+                    };\n+                    let wild = Pat::wildcard_from_ty(pcx.ty);\n+                    PatKind::Slice { prefix, slice: Some(wild), suffix }\n+                }\n+            },\n+            &Str(value) => PatKind::Constant { value },\n+            &FloatRange(lo, hi, end) => PatKind::Range(PatRange { lo, hi, end }),\n+            IntRange(range) => return range.to_pat(pcx.cx.tcx),\n+            NonExhaustive => PatKind::Wild,\n+            Opaque => bug!(\"we should not try to apply an opaque constructor\"),\n+            Wildcard => bug!(\n+                \"trying to apply a wildcard constructor; this should have been done in `apply_constructors`\"\n+            ),\n+        };\n+\n+        Pat { ty: pcx.ty, span: DUMMY_SP, kind: Box::new(pat) }\n+    }\n+\n     /// Returns the number of patterns from the viewpoint of match-checking, i.e. excluding hidden\n     /// fields. This is what we want in most cases in this file, the only exception being\n     /// conversion to/from `Pat`.\n@@ -1534,8 +1534,7 @@ impl<'tcx> Witness<'tcx> {\n             let len = self.0.len();\n             let arity = ctor_wild_subpatterns.len();\n             let pats = self.0.drain((len - arity)..).rev();\n-            let fields = ctor_wild_subpatterns.replace_fields(pcx.cx, pats);\n-            ctor.apply(pcx, fields)\n+            ctor_wild_subpatterns.replace_fields(pcx.cx, pats).apply(pcx, ctor)\n         };\n \n         self.0.push(pat);\n@@ -2072,10 +2071,7 @@ impl<'tcx> MissingConstructors<'tcx> {\n             // it. For example, if `ctor` is a `Constructor::Variant` for\n             // `Option::Some`, we get the pattern `Some(_)`.\n             self.iter(pcx)\n-                .map(|missing_ctor| {\n-                    let fields = Fields::wildcards(pcx, &missing_ctor);\n-                    missing_ctor.apply(pcx, fields)\n-                })\n+                .map(|missing_ctor| Fields::wildcards(pcx, &missing_ctor).apply(pcx, missing_ctor))\n                 .collect()\n         }\n     }"}]}