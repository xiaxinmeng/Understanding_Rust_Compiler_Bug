{"sha": "cdb68224054eddddb0c1d2519f9c12b654a6ff8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkYjY4MjI0MDU0ZWRkZGRiMGMxZDI1MTlmOWMxMmI2NTRhNmZmOGY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-04T23:53:42Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-04T23:59:21Z"}, "message": "Add a structure for passing option flags around the compiler, put it in session, and use it.", "tree": {"sha": "cf2adf7393a984ca1a96c73eddb43270aba1cca2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf2adf7393a984ca1a96c73eddb43270aba1cca2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdb68224054eddddb0c1d2519f9c12b654a6ff8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdb68224054eddddb0c1d2519f9c12b654a6ff8f", "html_url": "https://github.com/rust-lang/rust/commit/cdb68224054eddddb0c1d2519f9c12b654a6ff8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdb68224054eddddb0c1d2519f9c12b654a6ff8f/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "619b4743e340f4d3d69addd66282e50fb1fb2cf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/619b4743e340f4d3d69addd66282e50fb1fb2cf0", "html_url": "https://github.com/rust-lang/rust/commit/619b4743e340f4d3d69addd66282e50fb1fb2cf0"}], "stats": {"total": 193, "additions": 106, "deletions": 87}, "files": [{"sha": "061b5a148403535a4907823b2e4738757eb32815", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 60, "deletions": 51, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/cdb68224054eddddb0c1d2519f9c12b654a6ff8f/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb68224054eddddb0c1d2519f9c12b654a6ff8f/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=cdb68224054eddddb0c1d2519f9c12b654a6ff8f", "patch": "@@ -78,50 +78,39 @@ fn time[T](bool do_it, str what, fn()->T thunk) -> T {\n }\n \n fn compile_input(session.session sess,\n-                        eval.env env,\n-                        str input, str output,\n-                        bool shared,\n-                        bool optimize,\n-                        bool debuginfo,\n-                        bool verify,\n-                        bool save_temps,\n-                        trans.output_type ot,\n-                        bool time_passes,\n-                        bool run_typestate,\n-                        vec[str] library_search_paths) {\n+                 eval.env env,\n+                 str input, str output) {\n+    auto time_passes = sess.get_opts().time_passes;\n     auto def = tup(0, 0);\n     auto p = parser.new_parser(sess, env, def, input, 0u);\n     auto crate = time[@ast.crate](time_passes, \"parsing\",\n-        bind parse_input(sess, p, input));\n-    if (ot == trans.output_type_none) {ret;}\n+                                  bind parse_input(sess, p, input));\n+    if (sess.get_opts().output_type == trans.output_type_none) {ret;}\n \n     crate = time[@ast.crate](time_passes, \"external crate reading\",\n-        bind creader.read_crates(sess, crate, library_search_paths));\n+                             bind creader.read_crates(sess, crate));\n     crate = time[@ast.crate](time_passes, \"resolution\",\n-        bind resolve.resolve_crate(sess, crate));\n+                             bind resolve.resolve_crate(sess, crate));\n     time[()](time_passes, \"capture checking\",\n-        bind capture.check_for_captures(sess, crate));\n+             bind capture.check_for_captures(sess, crate));\n \n     auto ty_cx = ty.mk_ctxt(sess);\n     auto typeck_result =\n         time[typeck.typecheck_result](time_passes, \"typechecking\",\n-        bind typeck.check_crate(ty_cx, crate));\n+                                      bind typeck.check_crate(ty_cx, crate));\n     crate = typeck_result._0;\n     auto type_cache = typeck_result._1;\n \n-    if (run_typestate) {\n+    if (sess.get_opts().run_typestate) {\n         crate = time[@ast.crate](time_passes, \"typestate checking\",\n             bind typestate_check.check_crate(crate));\n     }\n \n     auto llmod = time[llvm.ModuleRef](time_passes, \"translation\",\n-        bind trans.trans_crate(sess, crate, ty_cx, type_cache, output,\n-                               debuginfo, shared));\n+        bind trans.trans_crate(sess, crate, ty_cx, type_cache, output));\n \n     time[()](time_passes, \"LLVM passes\",\n-             bind trans.run_passes(llmod, optimize, debuginfo,\n-                                   verify, save_temps, output,\n-                                   ot));\n+             bind trans.run_passes(sess, llmod, output));\n }\n \n fn pretty_print_input(session.session sess,\n@@ -133,7 +122,7 @@ fn pretty_print_input(session.session sess,\n     pretty.pprust.print_file(crate.node.module, input, std.io.stdout());\n }\n \n-fn usage(session.session sess, str argv0) {\n+fn usage(str argv0) {\n     io.stdout().write_str(#fmt(\"usage: %s [options] <input>\\n\", argv0) + \"\n options:\n \n@@ -166,17 +155,12 @@ fn get_os() -> session.os {\n fn main(vec[str] args) {\n \n     // FIXME: don't hard-wire this.\n-    auto target_cfg = rec(os = get_os(),\n-                          arch = session.arch_x86,\n-                          int_type = common.ty_i32,\n-                          uint_type = common.ty_u32,\n-                          float_type = common.ty_f64 );\n-\n-    auto crate_cache = common.new_int_hash[session.crate_metadata]();\n-    auto target_crate_num = 0;\n-    let vec[@ast.meta_item] md = vec();\n-    auto sess = session.session(target_crate_num, target_cfg, crate_cache,\n-                                md, front.codemap.new_codemap());\n+    let @session.config target_cfg =\n+        @rec(os = get_os(),\n+             arch = session.arch_x86,\n+             int_type = common.ty_i32,\n+             uint_type = common.ty_u32,\n+             float_type = common.ty_f64);\n \n     auto opts = vec(optflag(\"h\"), optflag(\"glue\"),\n                     optflag(\"pretty\"), optflag(\"ls\"), optflag(\"parse-only\"),\n@@ -187,11 +171,14 @@ fn main(vec[str] args) {\n     auto binary = _vec.shift[str](args);\n     auto match;\n     alt (GetOpts.getopts(args, opts)) {\n-        case (GetOpts.failure(?f)) { sess.err(GetOpts.fail_str(f)); fail; }\n+        case (GetOpts.failure(?f)) {\n+            log_err #fmt(\"error: %s\", GetOpts.fail_str(f));\n+            fail;\n+        }\n         case (GetOpts.success(?m)) { match = m; }\n     }\n     if (opt_present(match, \"h\")) {\n-        usage(sess, binary);\n+        usage(binary);\n         ret;\n     }\n \n@@ -201,13 +188,13 @@ fn main(vec[str] args) {\n     auto shared = opt_present(match, \"shared\");\n     auto output_file = GetOpts.opt_maybe_str(match, \"o\");\n     auto library_search_paths = GetOpts.opt_strs(match, \"L\");\n-    auto ot = trans.output_type_bitcode;\n+    auto output_type = trans.output_type_bitcode;\n     if (opt_present(match, \"parse-only\")) {\n-        ot = trans.output_type_none;\n+        output_type = trans.output_type_none;\n     } else if (opt_present(match, \"S\")) {\n-        ot = trans.output_type_assembly;\n+        output_type = trans.output_type_assembly;\n     } else if (opt_present(match, \"c\")) {\n-        ot = trans.output_type_object;\n+        output_type = trans.output_type_object;\n     }\n     auto verify = !opt_present(match, \"noverify\");\n     auto save_temps = opt_present(match, \"save-temps\");\n@@ -216,14 +203,33 @@ fn main(vec[str] args) {\n     auto debuginfo = opt_present(match, \"g\");\n     auto time_passes = opt_present(match, \"time-passes\");\n     auto run_typestate = !opt_present(match, \"no-typestate\");\n+\n+    let @session.options sopts =\n+        @rec(shared = shared,\n+             optimize = optimize,\n+             debuginfo = debuginfo,\n+             verify = verify,\n+             run_typestate = run_typestate,\n+             save_temps = save_temps,\n+             time_passes = time_passes,\n+             output_type = output_type,\n+             library_search_paths = library_search_paths);\n+\n+    auto crate_cache = common.new_int_hash[session.crate_metadata]();\n+    auto target_crate_num = 0;\n+    let vec[@ast.meta_item] md = vec();\n+    auto sess =\n+        session.session(target_crate_num, target_cfg, sopts,\n+                        crate_cache, md, front.codemap.new_codemap());\n+\n     auto n_inputs = _vec.len[str](match.free);\n \n     if (glue) {\n         if (n_inputs > 0u) {\n             sess.err(\"No input files allowed with --glue.\");\n         }\n         auto out = option.from_maybe[str](\"glue.bc\", output_file);\n-        middle.trans.make_common_glue(out, optimize, verify, save_temps, ot);\n+        middle.trans.make_common_glue(sess, out);\n         ret;\n     }\n \n@@ -244,18 +250,21 @@ fn main(vec[str] args) {\n             case (none[str]) {\n                 let vec[str] parts = _str.split(ifile, '.' as u8);\n                 _vec.pop[str](parts);\n-                parts += vec(\"bc\");\n+                alt (output_type) {\n+                    case (trans.output_type_none)\n+                        { parts += vec(\"pp\"); }\n+                    case (trans.output_type_bitcode)\n+                        { parts += vec(\"bc\"); }\n+                    case (trans.output_type_assembly)\n+                        { parts += vec(\"s\"); }\n+                    case (trans.output_type_object)\n+                        { parts += vec(\"o\"); }\n+                }\n                 auto ofile = _str.connect(parts, \".\");\n-                compile_input(sess, env, ifile, ofile, shared,\n-                              optimize, debuginfo, verify,\n-                              save_temps, ot, time_passes,\n-                              run_typestate, library_search_paths);\n+                compile_input(sess, env, ifile, ofile);\n             }\n             case (some[str](?ofile)) {\n-                compile_input(sess, env, ifile, ofile, shared,\n-                              optimize, debuginfo, verify,\n-                              save_temps, ot, time_passes,\n-                              run_typestate, library_search_paths);\n+                compile_input(sess, env, ifile, ofile);\n             }\n         }\n     }"}, {"sha": "ec924f51f7dc77bc0eb2e5fdd332e3546208f253", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cdb68224054eddddb0c1d2519f9c12b654a6ff8f/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb68224054eddddb0c1d2519f9c12b654a6ff8f/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=cdb68224054eddddb0c1d2519f9c12b654a6ff8f", "patch": "@@ -19,11 +19,21 @@ tag arch {\n     arch_arm;\n }\n \n-type cfg = rec(os os,\n-               arch arch,\n-               ty_mach int_type,\n-               ty_mach uint_type,\n-               ty_mach float_type);\n+type config = rec(os os,\n+                  arch arch,\n+                  ty_mach int_type,\n+                  ty_mach uint_type,\n+                  ty_mach float_type);\n+\n+type options = rec(bool shared,\n+                   bool optimize,\n+                   bool debuginfo,\n+                   bool verify,\n+                   bool run_typestate,\n+                   bool save_temps,\n+                   bool time_passes,\n+                   middle.trans.output_type output_type,\n+                   vec[str] library_search_paths);\n \n type crate_metadata = rec(str name,\n                           vec[u8] data);\n@@ -47,13 +57,18 @@ fn emit_diagnostic(span sp, str msg, str kind, u8 color, codemap.codemap cm) {\n     io.stdout().write_str(#fmt(\" %s\\n\", msg));\n }\n \n-state obj session(ast.crate_num cnum, cfg targ,\n+state obj session(ast.crate_num cnum,\n+                  @config targ_cfg, @options opts,\n                   map.hashmap[int, crate_metadata] crates,\n                   mutable vec[@ast.meta_item] metadata,\n                   codemap.codemap cm) {\n \n-    fn get_targ_cfg() -> cfg {\n-        ret targ;\n+    fn get_targ_cfg() -> @config {\n+        ret targ_cfg;\n+    }\n+\n+    fn get_opts() -> @options {\n+        ret opts;\n     }\n \n     fn get_targ_crate_num() -> ast.crate_num {"}, {"sha": "cdbafe5a0999084a03b32f260bb2459d28210e21", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cdb68224054eddddb0c1d2519f9c12b654a6ff8f/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb68224054eddddb0c1d2519f9c12b654a6ff8f/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=cdb68224054eddddb0c1d2519f9c12b654a6ff8f", "patch": "@@ -459,12 +459,11 @@ fn fold_view_item_use(&env e, &span sp, ast.ident ident,\n \n // Reads external crates referenced by \"use\" directives.\n fn read_crates(session.session sess,\n-               @ast.crate crate,\n-               vec[str] library_search_paths) -> @ast.crate {\n+               @ast.crate crate) -> @ast.crate {\n     auto e = @rec(\n         sess=sess,\n         crate_cache=@common.new_str_hash[int](),\n-        library_search_paths=library_search_paths,\n+        library_search_paths=sess.get_opts().library_search_paths,\n         mutable next_crate_num=1\n     );\n "}, {"sha": "5f222cd43d9f66efc2f860f7e12773e6d109d468", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdb68224054eddddb0c1d2519f9c12b654a6ff8f/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb68224054eddddb0c1d2519f9c12b654a6ff8f/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=cdb68224054eddddb0c1d2519f9c12b654a6ff8f", "patch": "@@ -687,9 +687,9 @@ fn encode_metadata(@trans.crate_ctxt cx, @ast.crate crate)\n     ret C_postr(string_w.get_str());\n }\n \n-fn write_metadata(@trans.crate_ctxt cx, bool shared, @ast.crate crate) {\n+fn write_metadata(@trans.crate_ctxt cx, @ast.crate crate) {\n     auto llmeta = C_postr(\"\");\n-    if (shared) {\n+    if (cx.sess.get_opts().shared) {\n         llmeta = encode_metadata(cx, crate);\n     }\n "}, {"sha": "7f9eebc814f8f594823b595149bb05b4ad1ac6d2", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cdb68224054eddddb0c1d2519f9c12b654a6ff8f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb68224054eddddb0c1d2519f9c12b654a6ff8f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=cdb68224054eddddb0c1d2519f9c12b654a6ff8f", "patch": "@@ -116,8 +116,7 @@ state type crate_ctxt = rec(session.session sess,\n                             std.sha1.sha1 sha,\n                             hashmap[ty.t, str] type_sha1s,\n                             hashmap[ty.t, metadata.ty_abbrev] type_abbrevs,\n-                            ty.ctxt tcx,\n-                            bool debuginfo);\n+                            ty.ctxt tcx);\n \n type local_ctxt = rec(vec[str] path,\n                       vec[str] module_path,\n@@ -1787,7 +1786,7 @@ fn declare_generic_glue(@local_ctxt cx,\n                         TypeRef llfnty,\n                         str name) -> ValueRef {\n     auto fn_nm;\n-    if (cx.ccx.debuginfo) {\n+    if (cx.ccx.sess.get_opts().debuginfo) {\n         fn_nm = mangle_name_by_type_only(cx.ccx, t, \"glue_\" + name);\n         fn_nm = sanitize(fn_nm);\n     } else {\n@@ -7247,18 +7246,18 @@ fn is_object_or_assembly(output_type ot) -> bool {\n     ret false;\n }\n \n-fn run_passes(ModuleRef llmod, bool opt, bool dbg, bool verify,\n-              bool save_temps, str output, output_type ot) {\n+fn run_passes(session.session sess, ModuleRef llmod, str output) {\n     auto pm = mk_pass_manager();\n+    auto opts = sess.get_opts();\n \n     // TODO: run the linter here also, once there are llvm-c bindings for it.\n \n     // Generate a pre-optimization intermediate file if -save-temps was\n     // specified.\n-    if (save_temps) {\n-        alt (ot) {\n+    if (opts.save_temps) {\n+        alt (opts.output_type) {\n             case (output_type_bitcode) {\n-                if (opt) {\n+                if (opts.optimize) {\n                     auto filename = mk_intermediate_name(output, \"no-opt.bc\");\n                     llvm.LLVMWriteBitcodeToFile(llmod, _str.buf(filename));\n                 }\n@@ -7274,7 +7273,7 @@ fn run_passes(ModuleRef llmod, bool opt, bool dbg, bool verify,\n     // available in the C api.\n     // FIXME2: We might want to add optmization levels like -O1, -O2, -Os, etc\n     // FIXME3: Should we expose and use the pass lists used by the opt tool?\n-    if (opt) {\n+    if (opts.optimize) {\n         auto fpm = mk_pass_manager();\n \n         // createStandardFunctionPasses\n@@ -7330,25 +7329,25 @@ fn run_passes(ModuleRef llmod, bool opt, bool dbg, bool verify,\n         llvm.LLVMAddConstantMergePass(pm.llpm);\n     }\n \n-    if (verify) {\n+    if (opts.verify) {\n         llvm.LLVMAddVerifierPass(pm.llpm);\n     }\n \n     // TODO: Write .s if -c was specified and -save-temps was on.\n-    if (is_object_or_assembly(ot)) {\n+    if (is_object_or_assembly(opts.output_type)) {\n         let int LLVMAssemblyFile = 0;\n         let int LLVMObjectFile = 1;\n         let int LLVMNullFile = 2;\n         auto FileType;\n-        if (ot == output_type_object) {\n+        if (opts.output_type == output_type_object) {\n             FileType = LLVMObjectFile;\n         } else {\n             FileType = LLVMAssemblyFile;\n         }\n \n         // Write optimized bitcode if --save-temps was on.\n-        if (save_temps) {\n-            alt (ot) {\n+        if (opts.save_temps) {\n+            alt (opts.output_type) {\n                 case (output_type_bitcode) { /* nothing to do */ }\n                 case (_) {\n                     auto filename = mk_intermediate_name(output, \"opt.bc\");\n@@ -7712,8 +7711,7 @@ fn make_glues(ModuleRef llmod, type_names tn) -> @glue_fns {\n              vec_append_glue = make_vec_append_glue(llmod, tn));\n }\n \n-fn make_common_glue(str output, bool optimize, bool verify, bool save_temps,\n-                    output_type ot) {\n+fn make_common_glue(session.session sess, str output) {\n     // FIXME: part of this is repetitive and is probably a good idea\n     // to autogen it, but things like the memcpy implementation are not\n     // and it might be better to just check in a .ll file.\n@@ -7739,7 +7737,7 @@ fn make_common_glue(str output, bool optimize, bool verify, bool save_temps,\n \n     trans_exit_task_glue(glues, new_str_hash[ValueRef](), tn, llmod);\n \n-    run_passes(llmod, optimize, false, verify, save_temps, output, ot);\n+    run_passes(sess, llmod, output);\n }\n \n fn create_module_map(@crate_ctxt ccx) -> ValueRef {\n@@ -7791,8 +7789,7 @@ fn create_crate_map(@crate_ctxt ccx) -> ValueRef {\n }\n \n fn trans_crate(session.session sess, @ast.crate crate, ty.ctxt tcx,\n-               ty.type_cache type_cache, str output,\n-               bool debuginfo, bool shared)\n+               ty.type_cache type_cache, str output)\n         -> ModuleRef {\n     auto llmod =\n         llvm.LLVMModuleCreateWithNameInContext(_str.buf(\"rust_out\"),\n@@ -7842,8 +7839,7 @@ fn trans_crate(session.session sess, @ast.crate crate, ty.ctxt tcx,\n                     sha = std.sha1.mk_sha1(),\n                     type_sha1s = sha1s,\n                     type_abbrevs = abbrevs,\n-                    tcx = tcx,\n-                    debuginfo = debuginfo);\n+                    tcx = tcx);\n     auto cx = new_local_ctxt(ccx);\n \n     create_typedefs(ccx);\n@@ -7854,12 +7850,12 @@ fn trans_crate(session.session sess, @ast.crate crate, ty.ctxt tcx,\n     trans_mod(cx, crate.node.module);\n     trans_vec_append_glue(cx);\n     auto crate_map = create_crate_map(ccx);\n-    if (!shared) {\n+    if (!sess.get_opts().shared) {\n         trans_main_fn(cx, crate_ptr, crate_map);\n     }\n \n     // Translate the metadata.\n-    middle.metadata.write_metadata(cx.ccx, shared, crate);\n+    middle.metadata.write_metadata(cx.ccx, crate);\n \n     ret llmod;\n }"}]}