{"sha": "8a466454ab280f0dd405b713c1a3610de234d9ce", "node_id": "C_kwDOAAsO6NoAKDhhNDY2NDU0YWIyODBmMGRkNDA1YjcxM2MxYTM2MTBkZTIzNGQ5Y2U", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-01-31T20:45:49Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-18T14:11:15Z"}, "message": "Lint enum-to-int casts with `cast_possible_truncation`", "tree": {"sha": "5628010c6dd47d63a6883cdc719cda60c45f47e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5628010c6dd47d63a6883cdc719cda60c45f47e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a466454ab280f0dd405b713c1a3610de234d9ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a466454ab280f0dd405b713c1a3610de234d9ce", "html_url": "https://github.com/rust-lang/rust/commit/8a466454ab280f0dd405b713c1a3610de234d9ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a466454ab280f0dd405b713c1a3610de234d9ce/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02f3c17593e653e30e8835500319ef412855fa34", "url": "https://api.github.com/repos/rust-lang/rust/commits/02f3c17593e653e30e8835500319ef412855fa34", "html_url": "https://github.com/rust-lang/rust/commit/02f3c17593e653e30e8835500319ef412855fa34"}], "stats": {"total": 297, "additions": 258, "deletions": 39}, "files": [{"sha": "2384e4a37483fd2f88606c1a6f007322e88b00e2", "filename": "clippy_lints/src/casts/cast_possible_truncation.rs", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8a466454ab280f0dd405b713c1a3610de234d9ce/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a466454ab280f0dd405b713c1a3610de234d9ce/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs?ref=8a466454ab280f0dd405b713c1a3610de234d9ce", "patch": "@@ -2,6 +2,7 @@ use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::expr_or_init;\n use clippy_utils::ty::is_isize_or_usize;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, FloatTy, Ty};\n@@ -75,8 +76,8 @@ fn apply_reductions(cx: &LateContext<'_>, nbits: u64, expr: &Expr<'_>, signed: b\n }\n \n pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n-    let msg = match (cast_from.is_integral(), cast_to.is_integral()) {\n-        (true, true) => {\n+    let msg = match (cast_from.kind(), cast_to.is_integral()) {\n+        (ty::Int(_) | ty::Uint(_), true) => {\n             let from_nbits = apply_reductions(\n                 cx,\n                 utils::int_ty_to_nbits(cast_from, cx.tcx),\n@@ -108,19 +109,43 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>,\n             )\n         },\n \n-        (false, true) => {\n-            format!(\"casting `{}` to `{}` may truncate the value\", cast_from, cast_to)\n-        },\n-\n-        (_, _) => {\n-            if matches!(cast_from.kind(), &ty::Float(FloatTy::F64))\n-                && matches!(cast_to.kind(), &ty::Float(FloatTy::F32))\n+        (ty::Adt(def, _), true) if def.is_enum() => {\n+            if let ExprKind::Path(p) = &cast_expr.kind\n+                && let Res::Def(DefKind::Ctor(..), _) = cx.qpath_res(p, cast_expr.hir_id)\n             {\n-                \"casting `f64` to `f32` may truncate the value\".to_string()\n+                return\n+            }\n+\n+            let from_nbits = utils::enum_ty_to_nbits(def, cx.tcx);\n+            let to_nbits = utils::int_ty_to_nbits(cast_to, cx.tcx);\n+\n+            let suffix = if is_isize_or_usize(cast_to) {\n+                if from_nbits > 32 {\n+                    \" on targets with 32-bit wide pointers\"\n+                } else {\n+                    return;\n+                }\n+            } else if to_nbits < from_nbits {\n+                \"\"\n             } else {\n                 return;\n-            }\n+            };\n+\n+            format!(\n+                \"casting `{}` to `{}` may truncate the value{}\",\n+                cast_from, cast_to, suffix,\n+            )\n+        },\n+\n+        (ty::Float(_), true) => {\n+            format!(\"casting `{}` to `{}` may truncate the value\", cast_from, cast_to)\n         },\n+\n+        (ty::Float(FloatTy::F64), false) if matches!(cast_to.kind(), &ty::Float(FloatTy::F32)) => {\n+            \"casting `f64` to `f32` may truncate the value\".to_string()\n+        },\n+\n+        _ => return,\n     };\n \n     span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span, &msg);"}, {"sha": "b8c9f7db994d9374adc52c8f042e0fd6354adf69", "filename": "clippy_lints/src/casts/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a466454ab280f0dd405b713c1a3610de234d9ce/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a466454ab280f0dd405b713c1a3610de234d9ce/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs?ref=8a466454ab280f0dd405b713c1a3610de234d9ce", "patch": "@@ -445,13 +445,12 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n             fn_to_numeric_cast_with_truncation::check(cx, expr, cast_expr, cast_from, cast_to);\n \n             if cast_to.is_numeric() && !in_external_macro(cx.sess(), expr.span) {\n+                cast_possible_truncation::check(cx, expr, cast_expr, cast_from, cast_to);\n                 if cast_from.is_numeric() {\n-                    cast_possible_truncation::check(cx, expr, cast_expr, cast_from, cast_to);\n                     cast_possible_wrap::check(cx, expr, cast_from, cast_to);\n                     cast_precision_loss::check(cx, expr, cast_from, cast_to);\n                     cast_sign_loss::check(cx, expr, cast_expr, cast_from, cast_to);\n                 }\n-\n                 cast_lossless::check(cx, expr, cast_expr, cast_from, cast_to, &self.msrv);\n             }\n         }"}, {"sha": "d41e745d733597965b6a097b8f0cbe0b2302b84c", "filename": "clippy_lints/src/casts/utils.rs", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8a466454ab280f0dd405b713c1a3610de234d9ce/clippy_lints%2Fsrc%2Fcasts%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a466454ab280f0dd405b713c1a3610de234d9ce/clippy_lints%2Fsrc%2Fcasts%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Futils.rs?ref=8a466454ab280f0dd405b713c1a3610de234d9ce", "patch": "@@ -1,4 +1,6 @@\n-use rustc_middle::ty::{self, IntTy, Ty, TyCtxt, UintTy};\n+use rustc_middle::mir::interpret::{ConstValue, Scalar};\n+use rustc_middle::ty::{self, AdtDef, IntTy, Ty, TyCtxt, UintTy, VariantDiscr};\n+use rustc_target::abi::Size;\n \n /// Returns the size in bits of an integral type.\n /// Will return 0 if the type is not an int or uint variant\n@@ -23,3 +25,57 @@ pub(super) fn int_ty_to_nbits(typ: Ty<'_>, tcx: TyCtxt<'_>) -> u64 {\n         _ => 0,\n     }\n }\n+\n+pub(super) fn enum_ty_to_nbits(adt: &AdtDef, tcx: TyCtxt<'_>) -> u64 {\n+    let mut explicit = 0i128;\n+    let (start, end) = adt\n+        .variants\n+        .iter()\n+        .fold((i128::MAX, i128::MIN), |(start, end), variant| match variant.discr {\n+            VariantDiscr::Relative(x) => match explicit.checked_add(i128::from(x)) {\n+                Some(x) => (start, end.max(x)),\n+                None => (i128::MIN, end),\n+            },\n+            VariantDiscr::Explicit(id) => {\n+                let ty = tcx.type_of(id);\n+                if let Ok(ConstValue::Scalar(Scalar::Int(value))) = tcx.const_eval_poly(id) {\n+                    #[allow(clippy::cast_possible_truncation, clippy::cast_possible_wrap)]\n+                    let value = match (value.size().bytes(), ty.kind()) {\n+                        (1, ty::Int(_)) => i128::from(value.assert_bits(Size::from_bytes(1)) as u8 as i8),\n+                        (1, ty::Uint(_)) => i128::from(value.assert_bits(Size::from_bytes(1)) as u8),\n+                        (2, ty::Int(_)) => i128::from(value.assert_bits(Size::from_bytes(2)) as u16 as i16),\n+                        (2, ty::Uint(_)) => i128::from(value.assert_bits(Size::from_bytes(2)) as u16),\n+                        (4, ty::Int(_)) => i128::from(value.assert_bits(Size::from_bytes(4)) as u32 as i32),\n+                        (4, ty::Uint(_)) => i128::from(value.assert_bits(Size::from_bytes(4)) as u32),\n+                        (8, ty::Int(_)) => i128::from(value.assert_bits(Size::from_bytes(8)) as u64 as i64),\n+                        (8, ty::Uint(_)) => i128::from(value.assert_bits(Size::from_bytes(8)) as u64),\n+                        (16, ty::Int(_)) => value.assert_bits(Size::from_bytes(16)) as i128,\n+                        (16, ty::Uint(_)) => match i128::try_from(value.assert_bits(Size::from_bytes(16))) {\n+                            Ok(x) => x,\n+                            // Requires 128 bits\n+                            Err(_) => return (i128::MIN, end),\n+                        },\n+                        // Shouldn't happen if compilation was successful\n+                        _ => return (start, end),\n+                    };\n+                    explicit = value;\n+                    (start.min(value), end.max(value))\n+                } else {\n+                    // Shouldn't happen if compilation was successful\n+                    (start, end)\n+                }\n+            },\n+        });\n+\n+    if start >= end {\n+        0\n+    } else {\n+        let neg_bits = if start < 0 {\n+            128 - (-(start + 1)).leading_zeros() + 1\n+        } else {\n+            0\n+        };\n+        let pos_bits = if end > 0 { 128 - end.leading_zeros() } else { 0 };\n+        neg_bits.max(pos_bits).into()\n+    }\n+}"}, {"sha": "371bf292f747771f70633f4cce17ac4063155aa8", "filename": "tests/ui/cast.rs", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/8a466454ab280f0dd405b713c1a3610de234d9ce/tests%2Fui%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a466454ab280f0dd405b713c1a3610de234d9ce/tests%2Fui%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast.rs?ref=8a466454ab280f0dd405b713c1a3610de234d9ce", "patch": "@@ -1,3 +1,6 @@\n+#![feature(repr128)]\n+#![allow(incomplete_features)]\n+\n #[warn(\n     clippy::cast_precision_loss,\n     clippy::cast_possible_truncation,\n@@ -115,4 +118,116 @@ fn main() {\n     }) as u8;\n     999999u64.clamp(0, 255) as u8;\n     999999u64.clamp(0, 256) as u8; // should still be linted\n+\n+    #[derive(Clone, Copy)]\n+    enum E1 {\n+        A,\n+        B,\n+        C,\n+    }\n+    impl E1 {\n+        fn test(self) {\n+            let _ = self as u8; // Don't lint. `0..=2` fits in u8\n+        }\n+    }\n+\n+    #[derive(Clone, Copy)]\n+    enum E2 {\n+        A = 255,\n+        B,\n+    }\n+    impl E2 {\n+        fn test(self) {\n+            let _ = self as u8;\n+            let _ = self as i16; // Don't lint. `255..=256` fits in i16\n+        }\n+    }\n+\n+    #[derive(Clone, Copy)]\n+    enum E3 {\n+        A = -1,\n+        B,\n+        C = 50,\n+    }\n+    impl E3 {\n+        fn test(self) {\n+            let _ = self as i8; // Don't lint. `-1..=50` fits in i8\n+        }\n+    }\n+\n+    #[derive(Clone, Copy)]\n+    enum E4 {\n+        A = -128,\n+        B,\n+    }\n+    impl E4 {\n+        fn test(self) {\n+            let _ = self as i8; // Don't lint. `-128..=-127` fits in i8\n+        }\n+    }\n+\n+    #[derive(Clone, Copy)]\n+    enum E5 {\n+        A = -129,\n+        B = 127,\n+    }\n+    impl E5 {\n+        fn test(self) {\n+            let _ = self as i8;\n+            let _ = self as i16; // Don't lint. `-129..=127` fits in i16\n+        }\n+    }\n+\n+    #[derive(Clone, Copy)]\n+    #[repr(u32)]\n+    enum E6 {\n+        A = u16::MAX as u32,\n+        B,\n+    }\n+    impl E6 {\n+        fn test(self) {\n+            let _ = self as i16;\n+            let _ = Self::A as u16; // Don't lint. `2^16-1` fits in u16\n+            let _ = self as u32; // Don't lint. `2^16-1..=2^16` fits in u32\n+        }\n+    }\n+\n+    #[derive(Clone, Copy)]\n+    #[repr(u64)]\n+    enum E7 {\n+        A = u32::MAX as u64,\n+        B,\n+    }\n+    impl E7 {\n+        fn test(self) {\n+            let _ = self as usize;\n+            let _ = self as u64; // Don't lint. `2^32-1..=2^32` fits in u64\n+        }\n+    }\n+\n+    #[derive(Clone, Copy)]\n+    #[repr(i128)]\n+    enum E8 {\n+        A = i128::MIN,\n+        B,\n+        C = 0,\n+        D = i128::MAX,\n+    }\n+    impl E8 {\n+        fn test(self) {\n+            let _ = self as i128; // Don't lint. `-(2^127)..=2^127-1` fits it i128\n+        }\n+    }\n+\n+    #[derive(Clone, Copy)]\n+    #[repr(u128)]\n+    enum E9 {\n+        A,\n+        B = u128::MAX,\n+    }\n+    impl E9 {\n+        fn test(self) {\n+            let _ = self as u128; // Don't lint. `0..=2^128-1` fits in u128\n+        }\n+    }\n }"}, {"sha": "0fc66f73981197180878560cd004b3f435f89dc1", "filename": "tests/ui/cast.stderr", "status": "modified", "additions": 49, "deletions": 25, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/8a466454ab280f0dd405b713c1a3610de234d9ce/tests%2Fui%2Fcast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a466454ab280f0dd405b713c1a3610de234d9ce/tests%2Fui%2Fcast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast.stderr?ref=8a466454ab280f0dd405b713c1a3610de234d9ce", "patch": "@@ -1,154 +1,178 @@\n error: casting `i32` to `f32` causes a loss of precision (`i32` is 32 bits wide, but `f32`'s mantissa is only 23 bits wide)\n-  --> $DIR/cast.rs:11:5\n+  --> $DIR/cast.rs:14:5\n    |\n LL |     x0 as f32;\n    |     ^^^^^^^^^\n    |\n    = note: `-D clippy::cast-precision-loss` implied by `-D warnings`\n \n error: casting `i64` to `f32` causes a loss of precision (`i64` is 64 bits wide, but `f32`'s mantissa is only 23 bits wide)\n-  --> $DIR/cast.rs:13:5\n+  --> $DIR/cast.rs:16:5\n    |\n LL |     x1 as f32;\n    |     ^^^^^^^^^\n \n error: casting `i64` to `f64` causes a loss of precision (`i64` is 64 bits wide, but `f64`'s mantissa is only 52 bits wide)\n-  --> $DIR/cast.rs:14:5\n+  --> $DIR/cast.rs:17:5\n    |\n LL |     x1 as f64;\n    |     ^^^^^^^^^\n \n error: casting `u32` to `f32` causes a loss of precision (`u32` is 32 bits wide, but `f32`'s mantissa is only 23 bits wide)\n-  --> $DIR/cast.rs:16:5\n+  --> $DIR/cast.rs:19:5\n    |\n LL |     x2 as f32;\n    |     ^^^^^^^^^\n \n error: casting `u64` to `f32` causes a loss of precision (`u64` is 64 bits wide, but `f32`'s mantissa is only 23 bits wide)\n-  --> $DIR/cast.rs:18:5\n+  --> $DIR/cast.rs:21:5\n    |\n LL |     x3 as f32;\n    |     ^^^^^^^^^\n \n error: casting `u64` to `f64` causes a loss of precision (`u64` is 64 bits wide, but `f64`'s mantissa is only 52 bits wide)\n-  --> $DIR/cast.rs:19:5\n+  --> $DIR/cast.rs:22:5\n    |\n LL |     x3 as f64;\n    |     ^^^^^^^^^\n \n error: casting `f32` to `i32` may truncate the value\n-  --> $DIR/cast.rs:21:5\n+  --> $DIR/cast.rs:24:5\n    |\n LL |     1f32 as i32;\n    |     ^^^^^^^^^^^\n    |\n    = note: `-D clippy::cast-possible-truncation` implied by `-D warnings`\n \n error: casting `f32` to `u32` may truncate the value\n-  --> $DIR/cast.rs:22:5\n+  --> $DIR/cast.rs:25:5\n    |\n LL |     1f32 as u32;\n    |     ^^^^^^^^^^^\n \n error: casting `f32` to `u32` may lose the sign of the value\n-  --> $DIR/cast.rs:22:5\n+  --> $DIR/cast.rs:25:5\n    |\n LL |     1f32 as u32;\n    |     ^^^^^^^^^^^\n    |\n    = note: `-D clippy::cast-sign-loss` implied by `-D warnings`\n \n error: casting `f64` to `f32` may truncate the value\n-  --> $DIR/cast.rs:23:5\n+  --> $DIR/cast.rs:26:5\n    |\n LL |     1f64 as f32;\n    |     ^^^^^^^^^^^\n \n error: casting `i32` to `i8` may truncate the value\n-  --> $DIR/cast.rs:24:5\n+  --> $DIR/cast.rs:27:5\n    |\n LL |     1i32 as i8;\n    |     ^^^^^^^^^^\n \n error: casting `i32` to `u8` may truncate the value\n-  --> $DIR/cast.rs:25:5\n+  --> $DIR/cast.rs:28:5\n    |\n LL |     1i32 as u8;\n    |     ^^^^^^^^^^\n \n error: casting `f64` to `isize` may truncate the value\n-  --> $DIR/cast.rs:26:5\n+  --> $DIR/cast.rs:29:5\n    |\n LL |     1f64 as isize;\n    |     ^^^^^^^^^^^^^\n \n error: casting `f64` to `usize` may truncate the value\n-  --> $DIR/cast.rs:27:5\n+  --> $DIR/cast.rs:30:5\n    |\n LL |     1f64 as usize;\n    |     ^^^^^^^^^^^^^\n \n error: casting `f64` to `usize` may lose the sign of the value\n-  --> $DIR/cast.rs:27:5\n+  --> $DIR/cast.rs:30:5\n    |\n LL |     1f64 as usize;\n    |     ^^^^^^^^^^^^^\n \n error: casting `u8` to `i8` may wrap around the value\n-  --> $DIR/cast.rs:29:5\n+  --> $DIR/cast.rs:32:5\n    |\n LL |     1u8 as i8;\n    |     ^^^^^^^^^\n    |\n    = note: `-D clippy::cast-possible-wrap` implied by `-D warnings`\n \n error: casting `u16` to `i16` may wrap around the value\n-  --> $DIR/cast.rs:30:5\n+  --> $DIR/cast.rs:33:5\n    |\n LL |     1u16 as i16;\n    |     ^^^^^^^^^^^\n \n error: casting `u32` to `i32` may wrap around the value\n-  --> $DIR/cast.rs:31:5\n+  --> $DIR/cast.rs:34:5\n    |\n LL |     1u32 as i32;\n    |     ^^^^^^^^^^^\n \n error: casting `u64` to `i64` may wrap around the value\n-  --> $DIR/cast.rs:32:5\n+  --> $DIR/cast.rs:35:5\n    |\n LL |     1u64 as i64;\n    |     ^^^^^^^^^^^\n \n error: casting `usize` to `isize` may wrap around the value\n-  --> $DIR/cast.rs:33:5\n+  --> $DIR/cast.rs:36:5\n    |\n LL |     1usize as isize;\n    |     ^^^^^^^^^^^^^^^\n \n error: casting `i32` to `u32` may lose the sign of the value\n-  --> $DIR/cast.rs:36:5\n+  --> $DIR/cast.rs:39:5\n    |\n LL |     -1i32 as u32;\n    |     ^^^^^^^^^^^^\n \n error: casting `isize` to `usize` may lose the sign of the value\n-  --> $DIR/cast.rs:38:5\n+  --> $DIR/cast.rs:41:5\n    |\n LL |     -1isize as usize;\n    |     ^^^^^^^^^^^^^^^^\n \n error: casting `i64` to `i8` may truncate the value\n-  --> $DIR/cast.rs:105:5\n+  --> $DIR/cast.rs:108:5\n    |\n LL |     (-99999999999i64).min(1) as i8; // should be linted because signed\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: casting `u64` to `u8` may truncate the value\n-  --> $DIR/cast.rs:117:5\n+  --> $DIR/cast.rs:120:5\n    |\n LL |     999999u64.clamp(0, 256) as u8; // should still be linted\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 24 previous errors\n+error: casting `main::E2` to `u8` may truncate the value\n+  --> $DIR/cast.rs:141:21\n+   |\n+LL |             let _ = self as u8;\n+   |                     ^^^^^^^^^^\n+\n+error: casting `main::E5` to `i8` may truncate the value\n+  --> $DIR/cast.rs:176:21\n+   |\n+LL |             let _ = self as i8;\n+   |                     ^^^^^^^^^^\n+\n+error: casting `main::E6` to `i16` may truncate the value\n+  --> $DIR/cast.rs:189:21\n+   |\n+LL |             let _ = self as i16;\n+   |                     ^^^^^^^^^^^\n+\n+error: casting `main::E7` to `usize` may truncate the value on targets with 32-bit wide pointers\n+  --> $DIR/cast.rs:203:21\n+   |\n+LL |             let _ = self as usize;\n+   |                     ^^^^^^^^^^^^^\n+\n+error: aborting due to 28 previous errors\n "}]}