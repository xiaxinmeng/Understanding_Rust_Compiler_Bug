{"sha": "a4a504e1328111c184603ddc0b2c113ad5a5c555", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0YTUwNGUxMzI4MTExYzE4NDYwM2RkYzBiMmMxMTNhZDVhNWM1NTU=", "commit": {"author": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-08-05T21:26:28Z"}, "committer": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-08-14T11:26:25Z"}, "message": "SSR: Explicitly autoderef and ref placeholders as needed\n\nStructured search replace now inserts *, & and &mut in the replacement to match any auto[de]ref in the matched code.", "tree": {"sha": "bb6b430c8b393dfb4fd92df21b5b52defeda1b54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb6b430c8b393dfb4fd92df21b5b52defeda1b54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4a504e1328111c184603ddc0b2c113ad5a5c555", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4a504e1328111c184603ddc0b2c113ad5a5c555", "html_url": "https://github.com/rust-lang/rust/commit/a4a504e1328111c184603ddc0b2c113ad5a5c555", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4a504e1328111c184603ddc0b2c113ad5a5c555/comments", "author": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c84f98385a28eeb7595f38b7cfaf861a6e06f4ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/c84f98385a28eeb7595f38b7cfaf861a6e06f4ea", "html_url": "https://github.com/rust-lang/rust/commit/c84f98385a28eeb7595f38b7cfaf861a6e06f4ea"}], "stats": {"total": 247, "additions": 222, "deletions": 25}, "files": [{"sha": "ba669fd56c98631f7a88dce6c50cbd799d2eeb6e", "filename": "crates/ssr/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a4a504e1328111c184603ddc0b2c113ad5a5c555/crates%2Fssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a504e1328111c184603ddc0b2c113ad5a5c555/crates%2Fssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2Fsrc%2Flib.rs?ref=a4a504e1328111c184603ddc0b2c113ad5a5c555", "patch": "@@ -21,7 +21,10 @@\n // code in the `foo` module, we'll insert just `Bar`.\n //\n // Inherent method calls should generally be written in UFCS form. e.g. `foo::Bar::baz($s, $a)` will\n-// match `$s.baz($a)`, provided the method call `baz` resolves to the method `foo::Bar::baz`.\n+// match `$s.baz($a)`, provided the method call `baz` resolves to the method `foo::Bar::baz`. When a\n+// placeholder is the receiver of a method call in the search pattern (e.g. `$s.foo()`), but not in\n+// the replacement template (e.g. `bar($s)`), then *, & and &mut will be added as needed to mirror\n+// whatever autoderef and autoref was happening implicitly in the matched code.\n //\n // The scope of the search / replace will be restricted to the current selection if any, otherwise\n // it will apply to the whole workspace."}, {"sha": "8bb5ced9007ff3e70f1c2c9a614d9cce0daf95eb", "filename": "crates/ssr/src/matching.rs", "status": "modified", "additions": 66, "deletions": 24, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a4a504e1328111c184603ddc0b2c113ad5a5c555/crates%2Fssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a504e1328111c184603ddc0b2c113ad5a5c555/crates%2Fssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2Fsrc%2Fmatching.rs?ref=a4a504e1328111c184603ddc0b2c113ad5a5c555", "patch": "@@ -65,6 +65,10 @@ pub(crate) struct PlaceholderMatch {\n     pub(crate) range: FileRange,\n     /// More matches, found within `node`.\n     pub(crate) inner_matches: SsrMatches,\n+    /// How many times the code that the placeholder matched needed to be dereferenced. Will only be\n+    /// non-zero if the placeholder matched to the receiver of a method call.\n+    pub(crate) autoderef_count: usize,\n+    pub(crate) autoref_kind: ast::SelfParamKind,\n }\n \n #[derive(Debug)]\n@@ -169,7 +173,7 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n         code: &SyntaxNode,\n     ) -> Result<(), MatchFailed> {\n         // Handle placeholders.\n-        if let Some(placeholder) = self.get_placeholder(&SyntaxElement::Node(pattern.clone())) {\n+        if let Some(placeholder) = self.get_placeholder_for_node(pattern) {\n             for constraint in &placeholder.constraints {\n                 self.check_constraint(constraint, code)?;\n             }\n@@ -178,9 +182,10 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n                 // We validated the range for the node when we started the match, so the placeholder\n                 // probably can't fail range validation, but just to be safe...\n                 self.validate_range(&original_range)?;\n-                matches_out\n-                    .placeholder_values\n-                    .insert(placeholder.ident.clone(), PlaceholderMatch::new(code, original_range));\n+                matches_out.placeholder_values.insert(\n+                    placeholder.ident.clone(),\n+                    PlaceholderMatch::new(Some(code), original_range),\n+                );\n             }\n             return Ok(());\n         }\n@@ -531,18 +536,40 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n         if pattern_ufcs.function != code_resolved_function {\n             fail_match!(\"Method call resolved to a different function\");\n         }\n-        if code_resolved_function.has_self_param(self.sema.db) {\n-            if let (Some(pattern_type), Some(expr)) = (&pattern_ufcs.qualifier_type, &code.expr()) {\n-                self.check_expr_type(pattern_type, expr)?;\n-            }\n-        }\n         // Check arguments.\n         let mut pattern_args = pattern_ufcs\n             .call_expr\n             .arg_list()\n             .ok_or_else(|| match_error!(\"Pattern function call has no args\"))?\n             .args();\n-        self.attempt_match_opt(phase, pattern_args.next(), code.expr())?;\n+        // If the function we're calling takes a self parameter, then we store additional\n+        // information on the placeholder match about autoderef and autoref. This allows us to use\n+        // the placeholder in a context where autoderef and autoref don't apply.\n+        if code_resolved_function.has_self_param(self.sema.db) {\n+            if let (Some(pattern_type), Some(expr)) = (&pattern_ufcs.qualifier_type, &code.expr()) {\n+                let deref_count = self.check_expr_type(pattern_type, expr)?;\n+                let pattern_receiver = pattern_args.next();\n+                self.attempt_match_opt(phase, pattern_receiver.clone(), code.expr())?;\n+                if let Phase::Second(match_out) = phase {\n+                    if let Some(placeholder_value) = pattern_receiver\n+                        .and_then(|n| self.get_placeholder_for_node(n.syntax()))\n+                        .and_then(|placeholder| {\n+                            match_out.placeholder_values.get_mut(&placeholder.ident)\n+                        })\n+                    {\n+                        placeholder_value.autoderef_count = deref_count;\n+                        placeholder_value.autoref_kind = self\n+                            .sema\n+                            .resolve_method_call_as_callable(code)\n+                            .and_then(|callable| callable.receiver_param(self.sema.db))\n+                            .map(|self_param| self_param.kind())\n+                            .unwrap_or(ast::SelfParamKind::Owned);\n+                    }\n+                }\n+            }\n+        } else {\n+            self.attempt_match_opt(phase, pattern_args.next(), code.expr())?;\n+        }\n         let mut code_args =\n             code.arg_list().ok_or_else(|| match_error!(\"Code method call has no args\"))?.args();\n         loop {\n@@ -570,26 +597,35 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n         self.attempt_match_node_children(phase, pattern_ufcs.call_expr.syntax(), code.syntax())\n     }\n \n+    /// Verifies that `expr` matches `pattern_type`, possibly after dereferencing some number of\n+    /// times. Returns the number of times it needed to be dereferenced.\n     fn check_expr_type(\n         &self,\n         pattern_type: &hir::Type,\n         expr: &ast::Expr,\n-    ) -> Result<(), MatchFailed> {\n+    ) -> Result<usize, MatchFailed> {\n         use hir::HirDisplay;\n         let code_type = self.sema.type_of_expr(&expr).ok_or_else(|| {\n             match_error!(\"Failed to get receiver type for `{}`\", expr.syntax().text())\n         })?;\n-        if !code_type\n+        // Temporary needed to make the borrow checker happy.\n+        let res = code_type\n             .autoderef(self.sema.db)\n-            .any(|deref_code_type| *pattern_type == deref_code_type)\n-        {\n-            fail_match!(\n-                \"Pattern type `{}` didn't match code type `{}`\",\n-                pattern_type.display(self.sema.db),\n-                code_type.display(self.sema.db)\n-            );\n-        }\n-        Ok(())\n+            .enumerate()\n+            .find(|(_, deref_code_type)| pattern_type == deref_code_type)\n+            .map(|(count, _)| count)\n+            .ok_or_else(|| {\n+                match_error!(\n+                    \"Pattern type `{}` didn't match code type `{}`\",\n+                    pattern_type.display(self.sema.db),\n+                    code_type.display(self.sema.db)\n+                )\n+            });\n+        res\n+    }\n+\n+    fn get_placeholder_for_node(&self, node: &SyntaxNode) -> Option<&Placeholder> {\n+        self.get_placeholder(&SyntaxElement::Node(node.clone()))\n     }\n \n     fn get_placeholder(&self, element: &SyntaxElement) -> Option<&Placeholder> {\n@@ -671,12 +707,18 @@ fn recording_match_fail_reasons() -> bool {\n }\n \n impl PlaceholderMatch {\n-    fn new(node: &SyntaxNode, range: FileRange) -> Self {\n-        Self { node: Some(node.clone()), range, inner_matches: SsrMatches::default() }\n+    fn new(node: Option<&SyntaxNode>, range: FileRange) -> Self {\n+        Self {\n+            node: node.cloned(),\n+            range,\n+            inner_matches: SsrMatches::default(),\n+            autoderef_count: 0,\n+            autoref_kind: ast::SelfParamKind::Owned,\n+        }\n     }\n \n     fn from_range(range: FileRange) -> Self {\n-        Self { node: None, range, inner_matches: SsrMatches::default() }\n+        Self::new(None, range)\n     }\n }\n "}, {"sha": "21d0aa8a8cdab52456a73c0a1c8804fc44f72ac3", "filename": "crates/ssr/src/replacing.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a4a504e1328111c184603ddc0b2c113ad5a5c555/crates%2Fssr%2Fsrc%2Freplacing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a504e1328111c184603ddc0b2c113ad5a5c555/crates%2Fssr%2Fsrc%2Freplacing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2Fsrc%2Freplacing.rs?ref=a4a504e1328111c184603ddc0b2c113ad5a5c555", "patch": "@@ -118,6 +118,27 @@ impl ReplacementRenderer<'_> {\n                 let range = &placeholder_value.range.range;\n                 let mut matched_text =\n                     self.file_src[usize::from(range.start())..usize::from(range.end())].to_owned();\n+                // If a method call is performed directly on the placeholder, then autoderef and\n+                // autoref will apply, so we can just substitute whatever the placeholder matched to\n+                // directly. If we're not applying a method call, then we need to add explicitly\n+                // deref and ref in order to match whatever was being done implicitly at the match\n+                // site.\n+                if !token_is_method_call_receiver(token)\n+                    && (placeholder_value.autoderef_count > 0\n+                        || placeholder_value.autoref_kind != ast::SelfParamKind::Owned)\n+                {\n+                    let ref_kind = match placeholder_value.autoref_kind {\n+                        ast::SelfParamKind::Owned => \"\",\n+                        ast::SelfParamKind::Ref => \"&\",\n+                        ast::SelfParamKind::MutRef => \"&mut \",\n+                    };\n+                    matched_text = format!(\n+                        \"{}{}{}\",\n+                        ref_kind,\n+                        \"*\".repeat(placeholder_value.autoderef_count),\n+                        matched_text\n+                    );\n+                }\n                 let edit = matches_to_edit_at_offset(\n                     &placeholder_value.inner_matches,\n                     self.file_src,\n@@ -178,6 +199,31 @@ impl ReplacementRenderer<'_> {\n     }\n }\n \n+/// Returns whether token is the receiver of a method call. Note, being within the receiver of a\n+/// method call doesn't count. e.g. if the token is `$a`, then `$a.foo()` will return true, while\n+/// `($a + $b).foo()` or `x.foo($a)` will return false.\n+fn token_is_method_call_receiver(token: &SyntaxToken) -> bool {\n+    use syntax::ast::AstNode;\n+    // Find the first method call among the ancestors of `token`, then check if the only token\n+    // within the receiver is `token`.\n+    if let Some(receiver) = token\n+        .ancestors()\n+        .find(|node| node.kind() == SyntaxKind::METHOD_CALL_EXPR)\n+        .and_then(|node| ast::MethodCallExpr::cast(node).unwrap().expr())\n+    {\n+        let mut tokens = receiver.syntax().descendants_with_tokens().filter_map(|node_or_token| {\n+            match node_or_token {\n+                SyntaxElement::Token(t) => Some(t),\n+                _ => None,\n+            }\n+        });\n+        if let (Some(only_token), None) = (tokens.next(), tokens.next()) {\n+            return only_token == *token;\n+        }\n+    }\n+    false\n+}\n+\n fn parse_as_kind(code: &str, kind: SyntaxKind) -> Option<SyntaxNode> {\n     use syntax::ast::AstNode;\n     if ast::Expr::can_cast(kind) {"}, {"sha": "0ad3512bade59a4cfb469ed5e2a400ef6cac1766", "filename": "crates/ssr/src/tests.rs", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/a4a504e1328111c184603ddc0b2c113ad5a5c555/crates%2Fssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4a504e1328111c184603ddc0b2c113ad5a5c555/crates%2Fssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2Fsrc%2Ftests.rs?ref=a4a504e1328111c184603ddc0b2c113ad5a5c555", "patch": "@@ -1172,3 +1172,109 @@ fn match_trait_method_call() {\n     assert_matches(\"Bar::foo($a, $b)\", code, &[\"v1.foo(1)\", \"Bar::foo(&v1, 3)\", \"v1_ref.foo(5)\"]);\n     assert_matches(\"Bar2::foo($a, $b)\", code, &[\"v2.foo(2)\", \"Bar2::foo(&v2, 4)\", \"v2_ref.foo(6)\"]);\n }\n+\n+#[test]\n+fn replace_autoref_autoderef_capture() {\n+    // Here we have several calls to `$a.foo()`. In the first case autoref is applied, in the\n+    // second, we already have a reference, so it isn't. When $a is used in a context where autoref\n+    // doesn't apply, we need to prefix it with `&`. Finally, we have some cases where autoderef\n+    // needs to be applied.\n+    let code = r#\"\n+        struct Foo {}\n+        impl Foo {\n+            fn foo(&self) {}\n+            fn foo2(&self) {}\n+        }\n+        fn bar(_: &Foo) {}\n+        fn main() {\n+            let f = Foo {};\n+            let fr = &f;\n+            let fr2 = &fr;\n+            let fr3 = &fr2;\n+            f.foo();\n+            fr.foo();\n+            fr2.foo();\n+            fr3.foo();\n+        }\n+        \"#;\n+    assert_ssr_transform(\n+        \"Foo::foo($a) ==>> bar($a)\",\n+        code,\n+        expect![[r#\"\n+            struct Foo {}\n+            impl Foo {\n+                fn foo(&self) {}\n+                fn foo2(&self) {}\n+            }\n+            fn bar(_: &Foo) {}\n+            fn main() {\n+                let f = Foo {};\n+                let fr = &f;\n+                let fr2 = &fr;\n+                let fr3 = &fr2;\n+                bar(&f);\n+                bar(&*fr);\n+                bar(&**fr2);\n+                bar(&***fr3);\n+            }\n+        \"#]],\n+    );\n+    // If the placeholder is used as the receiver of another method call, then we don't need to\n+    // explicitly autoderef or autoref.\n+    assert_ssr_transform(\n+        \"Foo::foo($a) ==>> $a.foo2()\",\n+        code,\n+        expect![[r#\"\n+            struct Foo {}\n+            impl Foo {\n+                fn foo(&self) {}\n+                fn foo2(&self) {}\n+            }\n+            fn bar(_: &Foo) {}\n+            fn main() {\n+                let f = Foo {};\n+                let fr = &f;\n+                let fr2 = &fr;\n+                let fr3 = &fr2;\n+                f.foo2();\n+                fr.foo2();\n+                fr2.foo2();\n+                fr3.foo2();\n+            }\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn replace_autoref_mut() {\n+    let code = r#\"\n+        struct Foo {}\n+        impl Foo {\n+            fn foo(&mut self) {}\n+        }\n+        fn bar(_: &mut Foo) {}\n+        fn main() {\n+            let mut f = Foo {};\n+            f.foo();\n+            let fr = &mut f;\n+            fr.foo();\n+        }\n+        \"#;\n+    assert_ssr_transform(\n+        \"Foo::foo($a) ==>> bar($a)\",\n+        code,\n+        expect![[r#\"\n+            struct Foo {}\n+            impl Foo {\n+                fn foo(&mut self) {}\n+            }\n+            fn bar(_: &mut Foo) {}\n+            fn main() {\n+                let mut f = Foo {};\n+                bar(&mut f);\n+                let fr = &mut f;\n+                bar(&mut *fr);\n+            }\n+        \"#]],\n+    );\n+}"}]}