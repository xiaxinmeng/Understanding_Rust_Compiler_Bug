{"sha": "6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiMjk4M2FmMWE4NWQ4NTdhZTNhOTM0NWFjOTNiYTA1NjRhYjdhNzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-01T11:03:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-01T11:03:16Z"}, "message": "Auto merge of #69606 - JohnTitor:rollup-i3nrrcf, r=JohnTitor\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #69397 (bootstrap: Remove commit hash from LLVM version suffix to avoid rebuilds)\n - #69549 (Improve MinGW detection when cross compiling )\n - #69562 (Don't `bug` when taking discriminant of generator during dataflow)\n - #69579 (parser: Remove `Parser::prev_span`)\n - #69580 (use .copied() instead of .map(|x| *x) on iterators)\n - #69583 (Do not ICE on invalid type node after parse recovery)\n - #69605 (Use `opt_def_id()` over `def_id()`)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "049a278f407d4c8dc3aeeda4acb0978c98a092a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/049a278f407d4c8dc3aeeda4acb0978c98a092a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "html_url": "https://github.com/rust-lang/rust/commit/6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee50590803f37abd7ad5f5f4bbd3bb844511fcf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee50590803f37abd7ad5f5f4bbd3bb844511fcf5", "html_url": "https://github.com/rust-lang/rust/commit/ee50590803f37abd7ad5f5f4bbd3bb844511fcf5"}, {"sha": "47d87d7ca5d1c0b1bb9321893e9f62d77e109d01", "url": "https://api.github.com/repos/rust-lang/rust/commits/47d87d7ca5d1c0b1bb9321893e9f62d77e109d01", "html_url": "https://github.com/rust-lang/rust/commit/47d87d7ca5d1c0b1bb9321893e9f62d77e109d01"}], "stats": {"total": 677, "additions": 368, "deletions": 309}, "files": [{"sha": "76478abd0dea78ecbab27b65ce8c9edecfca6f9a", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -234,7 +234,14 @@ fn make_win_dist(\n         }\n     }\n \n-    let target_tools = [\"gcc.exe\", \"ld.exe\", \"dlltool.exe\", \"libwinpthread-1.dll\"];\n+    let compiler = if target_triple == \"i686-pc-windows-gnu\" {\n+        \"i686-w64-mingw32-gcc.exe\"\n+    } else if target_triple == \"x86_64-pc-windows-gnu\" {\n+        \"x86_64-w64-mingw32-gcc.exe\"\n+    } else {\n+        \"gcc.exe\"\n+    };\n+    let target_tools = [compiler, \"ld.exe\", \"dlltool.exe\", \"libwinpthread-1.dll\"];\n     let mut rustc_dlls = vec![\"libwinpthread-1.dll\"];\n     if target_triple.starts_with(\"i686-\") {\n         rustc_dlls.push(\"libgcc_s_dw2-1.dll\");"}, {"sha": "c22c2a336f1240e16d08d6ed9e80f329d5a215a8", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -241,12 +241,8 @@ impl Step for Llvm {\n                 cfg.define(\"LLVM_VERSION_SUFFIX\", suffix);\n             }\n         } else {\n-            let mut default_suffix =\n-                format!(\"-rust-{}-{}\", channel::CFG_RELEASE_NUM, builder.config.channel,);\n-            if let Some(sha) = llvm_info.sha_short() {\n-                default_suffix.push_str(\"-\");\n-                default_suffix.push_str(sha);\n-            }\n+            let default_suffix =\n+                format!(\"-rust-{}-{}\", channel::CFG_RELEASE_NUM, builder.config.channel);\n             cfg.define(\"LLVM_VERSION_SUFFIX\", default_suffix);\n         }\n "}, {"sha": "f28e26ef2c396b31f027785d2f84daf813db800c", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -20,7 +20,7 @@ use std::cmp::Ord;\n \n fn compute_ignored_attr_names() -> FxHashSet<Symbol> {\n     debug_assert!(!ich::IGNORED_ATTRIBUTES.is_empty());\n-    ich::IGNORED_ATTRIBUTES.iter().map(|&s| s).collect()\n+    ich::IGNORED_ATTRIBUTES.iter().copied().collect()\n }\n \n /// This is the context state available during incr. comp. hashing. It contains"}, {"sha": "1d043f5dcdefacd7198e2f2b3b9367cf0c358334", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -635,7 +635,7 @@ impl<'tcx> ScopeTree {\n     /// Used to sanity check visit_expr call count when\n     /// calculating generator interiors.\n     pub fn body_expr_count(&self, body_id: hir::BodyId) -> Option<usize> {\n-        self.body_expr_count.get(&body_id).map(|r| *r)\n+        self.body_expr_count.get(&body_id).copied()\n     }\n }\n "}, {"sha": "7038387caa9bfb8e8b0787d22223c4d9c897e9cc", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -1179,7 +1179,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let from_err_expr =\n                 self.wrap_in_try_constructor(sym::from_error, unstable_span, from_expr, try_span);\n             let thin_attrs = ThinVec::from(attrs);\n-            let catch_scope = self.catch_scopes.last().map(|x| *x);\n+            let catch_scope = self.catch_scopes.last().copied();\n             let ret_expr = if let Some(catch_node) = catch_scope {\n                 let target_id = Ok(self.lower_node_id(catch_node));\n                 self.arena.alloc(self.expr("}, {"sha": "9811a6621afa51726112b007f36d7915ad3ade25", "filename": "src/librustc_builtin_macros/asm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_builtin_macros%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_builtin_macros%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fasm.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -151,7 +151,7 @@ fn parse_inline_asm<'a>(\n \n                     let constraint = parse_asm_str(&mut p)?;\n \n-                    let span = p.prev_span;\n+                    let span = p.prev_token.span;\n \n                     p.expect(&token::OpenDelim(token::Paren))?;\n                     let expr = p.parse_expr()?;\n@@ -202,15 +202,15 @@ fn parse_inline_asm<'a>(\n                     if constraint.as_str().starts_with('=') {\n                         struct_span_err!(\n                             cx.parse_sess.span_diagnostic,\n-                            p.prev_span,\n+                            p.prev_token.span,\n                             E0662,\n                             \"input operand constraint contains '='\"\n                         )\n                         .emit();\n                     } else if constraint.as_str().starts_with('+') {\n                         struct_span_err!(\n                             cx.parse_sess.span_diagnostic,\n-                            p.prev_span,\n+                            p.prev_token.span,\n                             E0663,\n                             \"input operand constraint contains '+'\"\n                         )\n@@ -233,11 +233,11 @@ fn parse_inline_asm<'a>(\n                     let s = parse_asm_str(&mut p)?;\n \n                     if OPTIONS.iter().any(|&opt| s == opt) {\n-                        cx.span_warn(p.prev_span, \"expected a clobber, found an option\");\n+                        cx.span_warn(p.prev_token.span, \"expected a clobber, found an option\");\n                     } else if s.as_str().starts_with('{') || s.as_str().ends_with('}') {\n                         struct_span_err!(\n                             cx.parse_sess.span_diagnostic,\n-                            p.prev_span,\n+                            p.prev_token.span,\n                             E0664,\n                             \"clobber should not be surrounded by braces\"\n                         )\n@@ -259,7 +259,7 @@ fn parse_inline_asm<'a>(\n                 } else if option == sym::intel {\n                     dialect = AsmDialect::Intel;\n                 } else {\n-                    cx.span_warn(p.prev_span, \"unrecognized option\");\n+                    cx.span_warn(p.prev_token.span, \"unrecognized option\");\n                 }\n \n                 if p.token == token::Comma {"}, {"sha": "5da4a540940c24055e44c8a63767c7758d817846", "filename": "src/librustc_builtin_macros/assert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_builtin_macros%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_builtin_macros%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fassert.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -106,7 +106,7 @@ fn parse_assert<'a>(\n     let custom_message =\n         if let token::Literal(token::Lit { kind: token::Str, .. }) = parser.token.kind {\n             let mut err = cx.struct_span_warn(parser.token.span, \"unexpected string literal\");\n-            let comma_span = parser.prev_span.shrink_to_hi();\n+            let comma_span = parser.prev_token.span.shrink_to_hi();\n             err.span_suggestion_short(\n                 comma_span,\n                 \"try adding a comma\","}, {"sha": "6e2b3ec5fd22259ba67aa1dc3075513addc1fe2f", "filename": "src/librustc_builtin_macros/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_builtin_macros%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_builtin_macros%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fformat.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -359,7 +359,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             refs.sort();\n             refs.dedup();\n             let (arg_list, mut sp) = if refs.len() == 1 {\n-                let spans: Vec<_> = spans.into_iter().filter_map(|sp| sp.map(|sp| *sp)).collect();\n+                let spans: Vec<_> = spans.into_iter().filter_map(|sp| sp.copied()).collect();\n                 (\n                     format!(\"argument {}\", refs[0]),\n                     if spans.is_empty() {"}, {"sha": "b02c935039512239909c33b0e89e88e69464de27", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -970,7 +970,7 @@ fn check_matcher_core(\n                                         msg,\n                                         ts[..ts.len() - 1]\n                                             .iter()\n-                                            .map(|s| *s)\n+                                            .copied()\n                                             .collect::<Vec<_>>()\n                                             .join(\", \"),\n                                         ts[ts.len() - 1],"}, {"sha": "ea0cc2f0c8bf254c76c0dd3da28c0ab359da16da", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -503,7 +503,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             },\n             proc_macro_data,\n             proc_macro_stability: if is_proc_macro {\n-                tcx.lookup_stability(DefId::local(CRATE_DEF_INDEX)).map(|stab| *stab)\n+                tcx.lookup_stability(DefId::local(CRATE_DEF_INDEX)).copied()\n             } else {\n                 None\n             },"}, {"sha": "1487129f6c77c2a10473223681a96b4bde3e2ad0", "filename": "src/librustc_mir/dataflow/generic/engine.rs", "status": "modified", "additions": 72, "deletions": 54, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -239,14 +239,24 @@ where\n             }\n \n             SwitchInt { ref targets, ref values, ref discr, .. } => {\n-                self.propagate_bits_into_switch_int_successors(\n-                    in_out,\n-                    (bb, bb_data),\n-                    dirty_list,\n-                    discr,\n-                    &*values,\n-                    &*targets,\n-                );\n+                // If this is a switch on an enum discriminant, a custom effect may be applied\n+                // along each outgoing edge.\n+                if let Some(place) = discr.place() {\n+                    let enum_def = switch_on_enum_discriminant(self.tcx, self.body, bb_data, place);\n+                    if let Some(enum_def) = enum_def {\n+                        self.propagate_bits_into_enum_discriminant_switch_successors(\n+                            in_out, bb, enum_def, place, dirty_list, &*values, &*targets,\n+                        );\n+\n+                        return;\n+                    }\n+                }\n+\n+                // Otherwise, it's just a normal `SwitchInt`, and every successor sees the same\n+                // exit state.\n+                for target in targets.iter().copied() {\n+                    self.propagate_bits_into_entry_set_for(&in_out, target, dirty_list);\n+                }\n             }\n \n             Call { cleanup, ref destination, ref func, ref args, .. } => {\n@@ -293,64 +303,72 @@ where\n         }\n     }\n \n-    fn propagate_bits_into_switch_int_successors(\n+    fn propagate_bits_into_enum_discriminant_switch_successors(\n         &mut self,\n         in_out: &mut BitSet<A::Idx>,\n-        (bb, bb_data): (BasicBlock, &mir::BasicBlockData<'tcx>),\n+        bb: BasicBlock,\n+        enum_def: &'tcx ty::AdtDef,\n+        enum_place: &mir::Place<'tcx>,\n         dirty_list: &mut WorkQueue<BasicBlock>,\n-        switch_on: &mir::Operand<'tcx>,\n         values: &[u128],\n         targets: &[BasicBlock],\n     ) {\n-        match bb_data.statements.last().map(|stmt| &stmt.kind) {\n-            // Look at the last statement to see if it is an assignment of an enum discriminant to\n-            // the local that determines the target of a `SwitchInt` like so:\n-            //   _42 = discriminant(..)\n-            //   SwitchInt(_42, ..)\n-            Some(mir::StatementKind::Assign(box (lhs, mir::Rvalue::Discriminant(enum_))))\n-                if Some(lhs) == switch_on.place() =>\n-            {\n-                let adt = match enum_.ty(self.body, self.tcx).ty.kind {\n-                    ty::Adt(def, _) => def,\n-                    _ => bug!(\"Switch on discriminant of non-ADT\"),\n-                };\n-\n-                // MIR building adds discriminants to the `values` array in the same order as they\n-                // are yielded by `AdtDef::discriminants`. We rely on this to match each\n-                // discriminant in `values` to its corresponding variant in linear time.\n-                let mut tmp = BitSet::new_empty(in_out.domain_size());\n-                let mut discriminants = adt.discriminants(self.tcx);\n-                for (value, target) in values.iter().zip(targets.iter().copied()) {\n-                    let (variant_idx, _) =\n-                        discriminants.find(|&(_, discr)| discr.val == *value).expect(\n-                            \"Order of `AdtDef::discriminants` differed \\\n-                                 from that of `SwitchInt::values`\",\n-                        );\n+        // MIR building adds discriminants to the `values` array in the same order as they\n+        // are yielded by `AdtDef::discriminants`. We rely on this to match each\n+        // discriminant in `values` to its corresponding variant in linear time.\n+        let mut tmp = BitSet::new_empty(in_out.domain_size());\n+        let mut discriminants = enum_def.discriminants(self.tcx);\n+        for (value, target) in values.iter().zip(targets.iter().copied()) {\n+            let (variant_idx, _) = discriminants.find(|&(_, discr)| discr.val == *value).expect(\n+                \"Order of `AdtDef::discriminants` differed from that of `SwitchInt::values`\",\n+            );\n \n-                    tmp.overwrite(in_out);\n-                    self.analysis.apply_discriminant_switch_effect(\n-                        &mut tmp,\n-                        bb,\n-                        enum_,\n-                        adt,\n-                        variant_idx,\n-                    );\n-                    self.propagate_bits_into_entry_set_for(&tmp, target, dirty_list);\n-                }\n+            tmp.overwrite(in_out);\n+            self.analysis.apply_discriminant_switch_effect(\n+                &mut tmp,\n+                bb,\n+                enum_place,\n+                enum_def,\n+                variant_idx,\n+            );\n+            self.propagate_bits_into_entry_set_for(&tmp, target, dirty_list);\n+        }\n \n-                std::mem::drop(tmp);\n+        std::mem::drop(tmp);\n \n-                // Propagate dataflow state along the \"otherwise\" edge.\n-                let otherwise = targets.last().copied().unwrap();\n-                self.propagate_bits_into_entry_set_for(&in_out, otherwise, dirty_list);\n-            }\n+        // Propagate dataflow state along the \"otherwise\" edge.\n+        let otherwise = targets.last().copied().unwrap();\n+        self.propagate_bits_into_entry_set_for(&in_out, otherwise, dirty_list);\n+    }\n+}\n \n-            _ => {\n-                for target in targets.iter().copied() {\n-                    self.propagate_bits_into_entry_set_for(&in_out, target, dirty_list);\n-                }\n+/// Look at the last statement of a block that ends with  to see if it is an assignment of an enum\n+/// discriminant to the local that determines the target of a `SwitchInt` like so:\n+///   _42 = discriminant(..)\n+///   SwitchInt(_42, ..)\n+fn switch_on_enum_discriminant(\n+    tcx: TyCtxt<'tcx>,\n+    body: &mir::Body<'tcx>,\n+    block: &mir::BasicBlockData<'tcx>,\n+    switch_on: &mir::Place<'tcx>,\n+) -> Option<&'tcx ty::AdtDef> {\n+    match block.statements.last().map(|stmt| &stmt.kind) {\n+        Some(mir::StatementKind::Assign(box (lhs, mir::Rvalue::Discriminant(discriminated))))\n+            if lhs == switch_on =>\n+        {\n+            match &discriminated.ty(body, tcx).ty.kind {\n+                ty::Adt(def, _) => Some(def),\n+\n+                // `Rvalue::Discriminant` is also used to get the active yield point for a\n+                // generator, but we do not need edge-specific effects in that case. This may\n+                // change in the future.\n+                ty::Generator(..) => None,\n+\n+                t => bug!(\"`discriminant` called on unexpected type {:?}\", t),\n             }\n         }\n+\n+        _ => None,\n     }\n }\n "}, {"sha": "53e10f86a2cecd511060c7b6ecf0c0ae3624cff2", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -305,7 +305,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         let mut caller_iter = caller_args\n                             .iter()\n                             .filter(|op| !rust_abi || !op.layout.is_zst())\n-                            .map(|op| *op);\n+                            .copied();\n \n                         // Now we have to spread them out across the callee's locals,\n                         // taking into account the `spread_arg`.  If we could write"}, {"sha": "46d49b6b4933f863464a1635ad1fe97754cf94b6", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -187,13 +187,12 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                 if let Some((adt_def, index)) = adt_data {\n                     let substs = cx.tables().node_substs(fun.hir_id);\n                     let user_provided_types = cx.tables().user_provided_types();\n-                    let user_ty =\n-                        user_provided_types.get(fun.hir_id).map(|u_ty| *u_ty).map(|mut u_ty| {\n-                            if let UserType::TypeOf(ref mut did, _) = &mut u_ty.value {\n-                                *did = adt_def.did;\n-                            }\n-                            u_ty\n-                        });\n+                    let user_ty = user_provided_types.get(fun.hir_id).copied().map(|mut u_ty| {\n+                        if let UserType::TypeOf(ref mut did, _) = &mut u_ty.value {\n+                            *did = adt_def.did;\n+                        }\n+                        u_ty\n+                    });\n                     debug!(\"make_mirror_unadjusted: (call) user_ty={:?}\", user_ty);\n \n                     let field_refs = args\n@@ -329,7 +328,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n             ty::Adt(adt, substs) => match adt.adt_kind() {\n                 AdtKind::Struct | AdtKind::Union => {\n                     let user_provided_types = cx.tables().user_provided_types();\n-                    let user_ty = user_provided_types.get(expr.hir_id).map(|u_ty| *u_ty);\n+                    let user_ty = user_provided_types.get(expr.hir_id).copied();\n                     debug!(\"make_mirror_unadjusted: (struct/union) user_ty={:?}\", user_ty);\n                     ExprKind::Adt {\n                         adt_def: adt,\n@@ -351,7 +350,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n \n                             let index = adt.variant_index_with_id(variant_id);\n                             let user_provided_types = cx.tables().user_provided_types();\n-                            let user_ty = user_provided_types.get(expr.hir_id).map(|u_ty| *u_ty);\n+                            let user_ty = user_provided_types.get(expr.hir_id).copied();\n                             debug!(\"make_mirror_unadjusted: (variant) user_ty={:?}\", user_ty);\n                             ExprKind::Adt {\n                                 adt_def: adt,\n@@ -570,7 +569,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n         }\n         hir::ExprKind::Type(ref source, ref ty) => {\n             let user_provided_types = cx.tables.user_provided_types();\n-            let user_ty = user_provided_types.get(ty.hir_id).map(|u_ty| *u_ty);\n+            let user_ty = user_provided_types.get(ty.hir_id).copied();\n             debug!(\"make_mirror_unadjusted: (type) user_ty={:?}\", user_ty);\n             if source.is_syntactic_place_expr() {\n                 ExprKind::PlaceTypeAscription { source: source.to_ref(), user_ty }\n@@ -605,7 +604,7 @@ fn user_substs_applied_to_res<'tcx>(\n         | Res::Def(DefKind::Ctor(_, CtorKind::Fn), _)\n         | Res::Def(DefKind::Const, _)\n         | Res::Def(DefKind::AssocConst, _) => {\n-            cx.tables().user_provided_types().get(hir_id).map(|u_ty| *u_ty)\n+            cx.tables().user_provided_types().get(hir_id).copied()\n         }\n \n         // A unit struct/variant which is used as a value (e.g.,\n@@ -744,7 +743,7 @@ fn convert_path_expr<'a, 'tcx>(\n \n         Res::Def(DefKind::Ctor(_, CtorKind::Const), def_id) => {\n             let user_provided_types = cx.tables.user_provided_types();\n-            let user_provided_type = user_provided_types.get(expr.hir_id).map(|u_ty| *u_ty);\n+            let user_provided_type = user_provided_types.get(expr.hir_id).copied();\n             debug!(\"convert_path_expr: user_provided_type={:?}\", user_provided_type);\n             let ty = cx.tables().node_type(expr.hir_id);\n             match ty.kind {"}, {"sha": "90e4f53647846c531656230704a4cf92c986b5f5", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -411,7 +411,7 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n     }\n \n     fn iter(&self) -> impl Iterator<Item = &Pat<'tcx>> {\n-        self.0.iter().map(|p| *p)\n+        self.0.iter().copied()\n     }\n \n     // If the first pattern is an or-pattern, expand this pattern. Otherwise, return `None`."}, {"sha": "c5f8b2dd862a51403c953d85b966f0815e246789", "filename": "src/librustc_parse/parser/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fattr.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -116,7 +116,7 @@ impl<'a> Parser<'a> {\n                 self.expect(&token::OpenDelim(token::Bracket))?;\n                 let item = self.parse_attr_item()?;\n                 self.expect(&token::CloseDelim(token::Bracket))?;\n-                let hi = self.prev_span;\n+                let hi = self.prev_token.span;\n \n                 let attr_sp = lo.to(hi);\n \n@@ -255,7 +255,7 @@ impl<'a> Parser<'a> {\n         while self.token.kind != token::Eof {\n             let lo = self.token.span;\n             let item = self.parse_attr_item()?;\n-            expanded_attrs.push((item, lo.to(self.prev_span)));\n+            expanded_attrs.push((item, lo.to(self.prev_token.span)));\n             if !self.eat(&token::Comma) {\n                 break;\n             }\n@@ -303,7 +303,7 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n         let path = self.parse_path(PathStyle::Mod)?;\n         let kind = self.parse_meta_item_kind()?;\n-        let span = lo.to(self.prev_span);\n+        let span = lo.to(self.prev_token.span);\n         Ok(ast::MetaItem { path, kind, span })\n     }\n "}, {"sha": "0759c43d45206281ae7eaf94034dcc48514a63cd", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -260,24 +260,24 @@ impl<'a> Parser<'a> {\n             };\n             (\n                 format!(\"expected one of {}, found {}\", expect, actual),\n-                (self.prev_span.shrink_to_hi(), format!(\"expected one of {}\", short_expect)),\n+                (self.prev_token.span.shrink_to_hi(), format!(\"expected one of {}\", short_expect)),\n             )\n         } else if expected.is_empty() {\n             (\n                 format!(\"unexpected token: {}\", actual),\n-                (self.prev_span, \"unexpected token after this\".to_string()),\n+                (self.prev_token.span, \"unexpected token after this\".to_string()),\n             )\n         } else {\n             (\n                 format!(\"expected {}, found {}\", expect, actual),\n-                (self.prev_span.shrink_to_hi(), format!(\"expected {}\", expect)),\n+                (self.prev_token.span.shrink_to_hi(), format!(\"expected {}\", expect)),\n             )\n         };\n         self.last_unexpected_token_span = Some(self.token.span);\n         let mut err = self.struct_span_err(self.token.span, &msg_exp);\n         let sp = if self.token == token::Eof {\n             // This is EOF; don't want to point at the following char, but rather the last token.\n-            self.prev_span\n+            self.prev_token.span\n         } else {\n             label_sp\n         };\n@@ -298,7 +298,7 @@ impl<'a> Parser<'a> {\n         }\n \n         let sm = self.sess.source_map();\n-        if self.prev_span == DUMMY_SP {\n+        if self.prev_token.span == DUMMY_SP {\n             // Account for macro context where the previous span might not be\n             // available to avoid incorrect output (#54841).\n             err.span_label(self.token.span, label_exp);\n@@ -577,7 +577,7 @@ impl<'a> Parser<'a> {\n         match inner_op.kind {\n             ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n                 // Respan to include both operators.\n-                let op_span = op.span.to(self.prev_span);\n+                let op_span = op.span.to(self.prev_token.span);\n                 let mut err =\n                     self.struct_span_err(op_span, \"comparison operators cannot be chained\");\n \n@@ -632,7 +632,7 @@ impl<'a> Parser<'a> {\n                                 // FIXME: actually check that the two expressions in the binop are\n                                 // paths and resynthesize new fn call expression instead of using\n                                 // `ExprKind::Err` placeholder.\n-                                mk_err_expr(self, inner_op.span.to(self.prev_span))\n+                                mk_err_expr(self, inner_op.span.to(self.prev_token.span))\n                             }\n                             Err(mut expr_err) => {\n                                 expr_err.cancel();\n@@ -654,7 +654,7 @@ impl<'a> Parser<'a> {\n                                 // FIXME: actually check that the two expressions in the binop are\n                                 // paths and resynthesize new fn call expression instead of using\n                                 // `ExprKind::Err` placeholder.\n-                                mk_err_expr(self, inner_op.span.to(self.prev_span))\n+                                mk_err_expr(self, inner_op.span.to(self.prev_token.span))\n                             }\n                         }\n                     } else {\n@@ -723,7 +723,7 @@ impl<'a> Parser<'a> {\n \n         self.bump(); // `+`\n         let bounds = self.parse_generic_bounds(None)?;\n-        let sum_span = ty.span.to(self.prev_span);\n+        let sum_span = ty.span.to(self.prev_token.span);\n \n         let mut err = struct_span_err!(\n             self.sess.span_diagnostic,\n@@ -790,7 +790,7 @@ impl<'a> Parser<'a> {\n \n         let mut path = ast::Path { segments: Vec::new(), span: DUMMY_SP };\n         self.parse_path_segments(&mut path.segments, T::PATH_STYLE)?;\n-        path.span = ty_span.to(self.prev_span);\n+        path.span = ty_span.to(self.prev_token.span);\n \n         let ty_str = self.span_to_snippet(ty_span).unwrap_or_else(|_| pprust::ty_to_string(&ty));\n         self.struct_span_err(path.span, \"missing angle brackets in associated item path\")\n@@ -809,9 +809,9 @@ impl<'a> Parser<'a> {\n \n     pub(super) fn maybe_consume_incorrect_semicolon(&mut self, items: &[P<Item>]) -> bool {\n         if self.eat(&token::Semi) {\n-            let mut err = self.struct_span_err(self.prev_span, \"expected item, found `;`\");\n+            let mut err = self.struct_span_err(self.prev_token.span, \"expected item, found `;`\");\n             err.span_suggestion_short(\n-                self.prev_span,\n+                self.prev_token.span,\n                 \"remove this semicolon\",\n                 String::new(),\n                 Applicability::MachineApplicable,\n@@ -854,10 +854,10 @@ impl<'a> Parser<'a> {\n             }\n             // We don't want to point at the following span after DUMMY_SP.\n             // This happens when the parser finds an empty TokenStream.\n-            _ if self.prev_span == DUMMY_SP => (self.token.span, self.token.span),\n+            _ if self.prev_token.span == DUMMY_SP => (self.token.span, self.token.span),\n             // EOF, don't want to point at the following char, but rather the last token.\n-            (token::Eof, None) => (self.prev_span, self.token.span),\n-            _ => (self.prev_span.shrink_to_hi(), self.token.span),\n+            (token::Eof, None) => (self.prev_token.span, self.token.span),\n+            _ => (self.prev_token.span.shrink_to_hi(), self.token.span),\n         };\n         let msg = format!(\n             \"expected `{}`, found {}\",\n@@ -894,10 +894,10 @@ impl<'a> Parser<'a> {\n         let sm = self.sess.source_map();\n         let msg = format!(\"expected `;`, found `{}`\", super::token_descr(&self.token));\n         let appl = Applicability::MachineApplicable;\n-        if self.token.span == DUMMY_SP || self.prev_span == DUMMY_SP {\n+        if self.token.span == DUMMY_SP || self.prev_token.span == DUMMY_SP {\n             // Likely inside a macro, can't provide meaninful suggestions.\n             return self.expect(&token::Semi).map(drop);\n-        } else if !sm.is_multiline(self.prev_span.until(self.token.span)) {\n+        } else if !sm.is_multiline(self.prev_token.span.until(self.token.span)) {\n             // The current token is in the same line as the prior token, not recoverable.\n         } else if self.look_ahead(1, |t| {\n             t == &token::CloseDelim(token::Brace) || t.can_begin_expr() && t.kind != token::Colon\n@@ -910,7 +910,7 @@ impl<'a> Parser<'a> {\n             //   let x = 32:\n             //   let y = 42;\n             self.bump();\n-            let sp = self.prev_span;\n+            let sp = self.prev_token.span;\n             self.struct_span_err(sp, &msg)\n                 .span_suggestion(sp, \"change this to `;`\", \";\".to_string(), appl)\n                 .emit();\n@@ -927,7 +927,7 @@ impl<'a> Parser<'a> {\n             //\n             //   let x = 32\n             //   let y = 42;\n-            let sp = self.prev_span.shrink_to_hi();\n+            let sp = self.prev_token.span.shrink_to_hi();\n             self.struct_span_err(sp, &msg)\n                 .span_label(self.token.span, \"unexpected token\")\n                 .span_suggestion_short(sp, \"add `;` here\", \";\".to_string(), appl)\n@@ -961,7 +961,7 @@ impl<'a> Parser<'a> {\n         self.expect(&token::OpenDelim(token::Paren))?;\n         let expr = self.parse_expr()?;\n         self.expect(&token::CloseDelim(token::Paren))?;\n-        Ok((self.prev_span, expr, false))\n+        Ok((self.prev_token.span, expr, false))\n     }\n \n     fn recover_await_prefix(&mut self, await_sp: Span) -> PResult<'a, (Span, P<Expr>, bool)> {\n@@ -1036,10 +1036,10 @@ impl<'a> Parser<'a> {\n                     .span_to_snippet(pat.span.trim_start(begin_par_sp).unwrap())\n                     .unwrap_or_else(|_| pprust::pat_to_string(&pat));\n \n-                self.struct_span_err(self.prev_span, \"unexpected closing `)`\")\n+                self.struct_span_err(self.prev_token.span, \"unexpected closing `)`\")\n                     .span_label(begin_par_sp, \"opening `(`\")\n                     .span_suggestion(\n-                        begin_par_sp.to(self.prev_span),\n+                        begin_par_sp.to(self.prev_token.span),\n                         \"remove parenthesis in `for` loop\",\n                         format!(\"{} in {}\", pat_str, pprust::expr_to_string(&expr)),\n                         // With e.g. `for (x) in y)` this would replace `(x) in y)`\n@@ -1091,7 +1091,7 @@ impl<'a> Parser<'a> {\n                 err.emit();\n                 // Recover from parse error, callers expect the closing delim to be consumed.\n                 self.consume_block(delim, ConsumeClosingDelim::Yes);\n-                self.mk_expr(lo.to(self.prev_span), ExprKind::Err, AttrVec::new())\n+                self.mk_expr(lo.to(self.prev_token.span), ExprKind::Err, AttrVec::new())\n             }\n         }\n     }\n@@ -1138,7 +1138,7 @@ impl<'a> Parser<'a> {\n                     err.span_label(sp, \"unclosed delimiter\");\n                 }\n                 err.span_suggestion_short(\n-                    self.prev_span.shrink_to_hi(),\n+                    self.prev_token.span.shrink_to_hi(),\n                     &format!(\"{} may belong here\", delim.to_string()),\n                     delim.to_string(),\n                     Applicability::MaybeIncorrect,\n@@ -1246,9 +1246,9 @@ impl<'a> Parser<'a> {\n     pub(super) fn check_for_for_in_in_typo(&mut self, in_span: Span) {\n         if self.eat_keyword(kw::In) {\n             // a common typo: `for _ in in bar {}`\n-            self.struct_span_err(self.prev_span, \"expected iterable, found keyword `in`\")\n+            self.struct_span_err(self.prev_token.span, \"expected iterable, found keyword `in`\")\n                 .span_suggestion_short(\n-                    in_span.until(self.prev_span),\n+                    in_span.until(self.prev_token.span),\n                     \"remove the duplicated `in`\",\n                     String::new(),\n                     Applicability::MachineApplicable,"}, {"sha": "18ddd23588e48c60ab08cf02497445dd21b4654c", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 69, "deletions": 60, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -166,7 +166,7 @@ impl<'a> Parser<'a> {\n             // Adjust the span for interpolated LHS to point to the `$lhs` token\n             // and not to what it refers to.\n             let lhs_span = match self.prev_token.kind {\n-                TokenKind::Interpolated(..) => self.prev_span,\n+                TokenKind::Interpolated(..) => self.prev_token.span,\n                 _ => lhs.span,\n             };\n \n@@ -523,7 +523,7 @@ impl<'a> Parser<'a> {\n         expr.map(|e| {\n             (\n                 match self.prev_token.kind {\n-                    TokenKind::Interpolated(..) => self.prev_span,\n+                    TokenKind::Interpolated(..) => self.prev_token.span,\n                     _ => e.span,\n                 },\n                 e,\n@@ -614,7 +614,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_assoc_op_ascribe(&mut self, lhs: P<Expr>, lhs_span: Span) -> PResult<'a, P<Expr>> {\n         let maybe_path = self.could_ascription_be_path(&lhs.kind);\n-        self.last_type_ascription = Some((self.prev_span, maybe_path));\n+        self.last_type_ascription = Some((self.prev_token.span, maybe_path));\n         let lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Type)?;\n         self.sess.gated_spans.gate(sym::type_ascription, lhs.span);\n         Ok(lhs)\n@@ -636,7 +636,7 @@ impl<'a> Parser<'a> {\n             let found_raw = self.eat_keyword(kw::Raw);\n             assert!(found_raw);\n             let mutability = self.parse_const_or_mut().unwrap();\n-            self.sess.gated_spans.gate(sym::raw_ref_op, lo.to(self.prev_span));\n+            self.sess.gated_spans.gate(sym::raw_ref_op, lo.to(self.prev_token.span));\n             (ast::BorrowKind::Raw, mutability)\n         } else {\n             // `mut?`\n@@ -683,7 +683,7 @@ impl<'a> Parser<'a> {\n         loop {\n             if self.eat(&token::Question) {\n                 // `expr?`\n-                e = self.mk_expr(lo.to(self.prev_span), ExprKind::Try(e), AttrVec::new());\n+                e = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Try(e), AttrVec::new());\n                 continue;\n             }\n             if self.eat(&token::Dot) {\n@@ -735,8 +735,8 @@ impl<'a> Parser<'a> {\n         let fstr = sym.as_str();\n         let msg = format!(\"unexpected token: `{}`\", sym);\n \n-        let mut err = self.struct_span_err(self.prev_span, &msg);\n-        err.span_label(self.prev_span, \"unexpected token\");\n+        let mut err = self.struct_span_err(self.prev_token.span, &msg);\n+        err.span_label(self.prev_token.span, \"unexpected token\");\n \n         if fstr.chars().all(|x| \"0123456789.\".contains(x)) {\n             let float = match fstr.parse::<f64>() {\n@@ -756,7 +756,7 @@ impl<'a> Parser<'a> {\n                 s.s.word(fstr.splitn(2, '.').last().unwrap().to_string())\n             });\n             err.span_suggestion(\n-                lo.to(self.prev_span),\n+                lo.to(self.prev_token.span),\n                 \"try parenthesizing the first index\",\n                 sugg,\n                 Applicability::MachineApplicable,\n@@ -782,7 +782,7 @@ impl<'a> Parser<'a> {\n     /// Parse a function call expression, `expr(...)`.\n     fn parse_fn_call_expr(&mut self, lo: Span, fun: P<Expr>) -> P<Expr> {\n         let seq = self.parse_paren_expr_seq().map(|args| {\n-            self.mk_expr(lo.to(self.prev_span), self.mk_call(fun, args), AttrVec::new())\n+            self.mk_expr(lo.to(self.prev_token.span), self.mk_call(fun, args), AttrVec::new())\n         });\n         self.recover_seq_parse_error(token::Paren, lo, seq)\n     }\n@@ -792,7 +792,7 @@ impl<'a> Parser<'a> {\n         self.bump(); // `[`\n         let index = self.parse_expr()?;\n         self.expect(&token::CloseDelim(token::Bracket))?;\n-        Ok(self.mk_expr(lo.to(self.prev_span), self.mk_index(base, index), AttrVec::new()))\n+        Ok(self.mk_expr(lo.to(self.prev_token.span), self.mk_index(base, index), AttrVec::new()))\n     }\n \n     /// Assuming we have just parsed `.`, continue parsing into an expression.\n@@ -809,7 +809,7 @@ impl<'a> Parser<'a> {\n             let mut args = self.parse_paren_expr_seq()?;\n             args.insert(0, self_arg);\n \n-            let span = lo.to(self.prev_span);\n+            let span = lo.to(self.prev_token.span);\n             Ok(self.mk_expr(span, ExprKind::MethodCall(segment, args), AttrVec::new()))\n         } else {\n             // Field access `expr.f`\n@@ -821,7 +821,7 @@ impl<'a> Parser<'a> {\n                 .emit();\n             }\n \n-            let span = lo.to(self.prev_span);\n+            let span = lo.to(self.prev_token.span);\n             Ok(self.mk_expr(span, ExprKind::Field(self_arg, segment.ident), AttrVec::new()))\n         }\n     }\n@@ -867,18 +867,18 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(kw::If) {\n             self.parse_if_expr(attrs)\n         } else if self.eat_keyword(kw::For) {\n-            self.parse_for_expr(None, self.prev_span, attrs)\n+            self.parse_for_expr(None, self.prev_token.span, attrs)\n         } else if self.eat_keyword(kw::While) {\n-            self.parse_while_expr(None, self.prev_span, attrs)\n+            self.parse_while_expr(None, self.prev_token.span, attrs)\n         } else if let Some(label) = self.eat_label() {\n             self.parse_labeled_expr(label, attrs)\n         } else if self.eat_keyword(kw::Loop) {\n-            self.parse_loop_expr(None, self.prev_span, attrs)\n+            self.parse_loop_expr(None, self.prev_token.span, attrs)\n         } else if self.eat_keyword(kw::Continue) {\n             let kind = ExprKind::Continue(self.eat_label());\n-            Ok(self.mk_expr(lo.to(self.prev_span), kind, attrs))\n+            Ok(self.mk_expr(lo.to(self.prev_token.span), kind, attrs))\n         } else if self.eat_keyword(kw::Match) {\n-            let match_sp = self.prev_span;\n+            let match_sp = self.prev_token.span;\n             self.parse_match_expr(attrs).map_err(|mut err| {\n                 err.span_label(match_sp, \"while parsing this match expression\");\n                 err\n@@ -921,7 +921,7 @@ impl<'a> Parser<'a> {\n                     self.parse_closure_expr(attrs)\n                 }\n             } else if self.eat_keyword(kw::Await) {\n-                self.recover_incorrect_await_syntax(lo, self.prev_span, attrs)\n+                self.recover_incorrect_await_syntax(lo, self.prev_token.span, attrs)\n             } else {\n                 self.parse_lit_expr(attrs)\n             }\n@@ -934,7 +934,7 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n         match self.parse_opt_lit() {\n             Some(literal) => {\n-                let expr = self.mk_expr(lo.to(self.prev_span), ExprKind::Lit(literal), attrs);\n+                let expr = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Lit(literal), attrs);\n                 self.maybe_recover_from_bad_qpath(expr, true)\n             }\n             None => return Err(self.expected_expression_found()),\n@@ -960,7 +960,7 @@ impl<'a> Parser<'a> {\n             // `(e,)` is a tuple with only one field, `e`.\n             ExprKind::Tup(es)\n         };\n-        let expr = self.mk_expr(lo.to(self.prev_span), kind, attrs);\n+        let expr = self.mk_expr(lo.to(self.prev_token.span), kind, attrs);\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n@@ -995,7 +995,7 @@ impl<'a> Parser<'a> {\n                 ExprKind::Array(vec![first_expr])\n             }\n         };\n-        let expr = self.mk_expr(lo.to(self.prev_span), kind, attrs);\n+        let expr = self.mk_expr(lo.to(self.prev_token.span), kind, attrs);\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n@@ -1011,7 +1011,7 @@ impl<'a> Parser<'a> {\n                 args: self.parse_mac_args()?,\n                 prior_type_ascription: self.last_type_ascription,\n             };\n-            (self.prev_span, ExprKind::Mac(mac))\n+            (self.prev_token.span, ExprKind::Mac(mac))\n         } else if self.check(&token::OpenDelim(token::Brace)) {\n             if let Some(expr) = self.maybe_parse_struct_expr(lo, &path, &attrs) {\n                 return expr;\n@@ -1055,7 +1055,7 @@ impl<'a> Parser<'a> {\n         self.bump(); // `do`\n         self.bump(); // `catch`\n \n-        let span_dc = lo.to(self.prev_span);\n+        let span_dc = lo.to(self.prev_token.span);\n         self.struct_span_err(span_dc, \"found removed `do catch` syntax\")\n             .span_suggestion(\n                 span_dc,\n@@ -1076,15 +1076,15 @@ impl<'a> Parser<'a> {\n \n     /// Parse `\"return\" expr?`.\n     fn parse_return_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n-        let lo = self.prev_span;\n+        let lo = self.prev_token.span;\n         let kind = ExprKind::Ret(self.parse_expr_opt()?);\n-        let expr = self.mk_expr(lo.to(self.prev_span), kind, attrs);\n+        let expr = self.mk_expr(lo.to(self.prev_token.span), kind, attrs);\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n     /// Parse `\"('label \":\")? break expr?`.\n     fn parse_break_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n-        let lo = self.prev_span;\n+        let lo = self.prev_token.span;\n         let label = self.eat_label();\n         let kind = if self.token != token::OpenDelim(token::Brace)\n             || !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n@@ -1093,15 +1093,15 @@ impl<'a> Parser<'a> {\n         } else {\n             None\n         };\n-        let expr = self.mk_expr(lo.to(self.prev_span), ExprKind::Break(label, kind), attrs);\n+        let expr = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Break(label, kind), attrs);\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n     /// Parse `\"yield\" expr?`.\n     fn parse_yield_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n-        let lo = self.prev_span;\n+        let lo = self.prev_token.span;\n         let kind = ExprKind::Yield(self.parse_expr_opt()?);\n-        let span = lo.to(self.prev_span);\n+        let span = lo.to(self.prev_token.span);\n         self.sess.gated_spans.gate(sym::generators, span);\n         let expr = self.mk_expr(span, kind, attrs);\n         self.maybe_recover_from_bad_qpath(expr, true)\n@@ -1306,7 +1306,11 @@ impl<'a> Parser<'a> {\n         let expr = self.mk_expr(lit.span, ExprKind::Lit(lit), AttrVec::new());\n \n         if minus_present {\n-            Ok(self.mk_expr(lo.to(self.prev_span), self.mk_unary(UnOp::Neg, expr), AttrVec::new()))\n+            Ok(self.mk_expr(\n+                lo.to(self.prev_token.span),\n+                self.mk_unary(UnOp::Neg, expr),\n+                AttrVec::new(),\n+            ))\n         } else {\n             Ok(expr)\n         }\n@@ -1344,12 +1348,12 @@ impl<'a> Parser<'a> {\n             if self.normalized_token.span.rust_2018() { self.parse_asyncness() } else { Async::No };\n         if asyncness.is_async() {\n             // Feature-gate `async ||` closures.\n-            self.sess.gated_spans.gate(sym::async_closure, self.prev_span);\n+            self.sess.gated_spans.gate(sym::async_closure, self.normalized_prev_token.span);\n         }\n \n         let capture_clause = self.parse_capture_clause();\n         let decl = self.parse_fn_block_decl()?;\n-        let decl_hi = self.prev_span;\n+        let decl_hi = self.prev_token.span;\n         let body = match decl.output {\n             FnRetTy::Default(_) => {\n                 let restrictions = self.restrictions - Restrictions::STMT_EXPR;\n@@ -1404,7 +1408,7 @@ impl<'a> Parser<'a> {\n         let ty = if self.eat(&token::Colon) {\n             self.parse_ty()?\n         } else {\n-            self.mk_ty(self.prev_span, TyKind::Infer)\n+            self.mk_ty(self.prev_token.span, TyKind::Infer)\n         };\n         Ok(Param {\n             attrs: attrs.into(),\n@@ -1418,7 +1422,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses an `if` expression (`if` token already eaten).\n     fn parse_if_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n-        let lo = self.prev_span;\n+        let lo = self.prev_token.span;\n         let cond = self.parse_cond_expr()?;\n \n         // Verify that the parsed `if` condition makes sense as a condition. If it is a block, then\n@@ -1437,7 +1441,7 @@ impl<'a> Parser<'a> {\n             })?\n         };\n         let els = if self.eat_keyword(kw::Else) { Some(self.parse_else_expr()?) } else { None };\n-        Ok(self.mk_expr(lo.to(self.prev_span), ExprKind::If(cond, thn, els), attrs))\n+        Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::If(cond, thn, els), attrs))\n     }\n \n     fn error_missing_if_cond(&self, lo: Span, span: Span) -> P<ast::Block> {\n@@ -1463,7 +1467,7 @@ impl<'a> Parser<'a> {\n     /// Parses a `let $pat = $expr` pseudo-expression.\n     /// The `let` token has already been eaten.\n     fn parse_let_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n-        let lo = self.prev_span;\n+        let lo = self.prev_token.span;\n         let pat = self.parse_top_pat(GateOr::No)?;\n         self.expect(&token::Eq)?;\n         let expr = self.with_res(Restrictions::NO_STRUCT_LITERAL, |this| {\n@@ -1503,7 +1507,7 @@ impl<'a> Parser<'a> {\n         if !self.eat_keyword(kw::In) {\n             self.error_missing_in_for_loop();\n         }\n-        self.check_for_for_in_in_typo(self.prev_span);\n+        self.check_for_for_in_in_typo(self.prev_token.span);\n         let expr = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n \n         let pat = self.recover_parens_around_for_head(pat, &expr, begin_paren);\n@@ -1512,11 +1516,11 @@ impl<'a> Parser<'a> {\n         attrs.extend(iattrs);\n \n         let kind = ExprKind::ForLoop(pat, expr, loop_block, opt_label);\n-        Ok(self.mk_expr(lo.to(self.prev_span), kind, attrs))\n+        Ok(self.mk_expr(lo.to(self.prev_token.span), kind, attrs))\n     }\n \n     fn error_missing_in_for_loop(&self) {\n-        let in_span = self.prev_span.between(self.token.span);\n+        let in_span = self.prev_token.span.between(self.token.span);\n         self.struct_span_err(in_span, \"missing `in` in `for` loop\")\n             .span_suggestion_short(\n                 in_span,\n@@ -1538,7 +1542,7 @@ impl<'a> Parser<'a> {\n         let cond = self.parse_cond_expr()?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n-        Ok(self.mk_expr(lo.to(self.prev_span), ExprKind::While(cond, body, opt_label), attrs))\n+        Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::While(cond, body, opt_label), attrs))\n     }\n \n     /// Parses `loop { ... }` (`loop` token already eaten).\n@@ -1550,7 +1554,7 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, P<Expr>> {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n-        Ok(self.mk_expr(lo.to(self.prev_span), ExprKind::Loop(body, opt_label), attrs))\n+        Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::Loop(body, opt_label), attrs))\n     }\n \n     fn eat_label(&mut self) -> Option<Label> {\n@@ -1562,8 +1566,8 @@ impl<'a> Parser<'a> {\n \n     /// Parses a `match ... { ... }` expression (`match` token already eaten).\n     fn parse_match_expr(&mut self, mut attrs: AttrVec) -> PResult<'a, P<Expr>> {\n-        let match_span = self.prev_span;\n-        let lo = self.prev_span;\n+        let match_span = self.prev_token.span;\n+        let lo = self.prev_token.span;\n         let scrutinee = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n         if let Err(mut e) = self.expect(&token::OpenDelim(token::Brace)) {\n             if self.token == token::Semi {\n@@ -1676,8 +1680,10 @@ impl<'a> Parser<'a> {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         if self.eat_keyword(kw::Catch) {\n-            let mut error =\n-                self.struct_span_err(self.prev_span, \"keyword `catch` cannot follow a `try` block\");\n+            let mut error = self.struct_span_err(\n+                self.prev_token.span,\n+                \"keyword `catch` cannot follow a `try` block\",\n+            );\n             error.help(\"try using `match` on the result of the `try` block instead\");\n             error.emit();\n             Err(error)\n@@ -1711,7 +1717,7 @@ impl<'a> Parser<'a> {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         let kind = ExprKind::Async(capture_clause, DUMMY_NODE_ID, body);\n-        Ok(self.mk_expr(lo.to(self.prev_span), kind, attrs))\n+        Ok(self.mk_expr(lo.to(self.prev_token.span), kind, attrs))\n     }\n \n     fn is_async_block(&self) -> bool {\n@@ -1775,7 +1781,7 @@ impl<'a> Parser<'a> {\n         pth: ast::Path,\n         mut attrs: AttrVec,\n     ) -> PResult<'a, P<Expr>> {\n-        let struct_sp = lo.to(self.prev_span);\n+        let struct_sp = lo.to(self.prev_token.span);\n         self.bump();\n         let mut fields = Vec::new();\n         let mut base = None;\n@@ -1784,7 +1790,7 @@ impl<'a> Parser<'a> {\n \n         while self.token != token::CloseDelim(token::Brace) {\n             if self.eat(&token::DotDot) {\n-                let exp_span = self.prev_span;\n+                let exp_span = self.prev_token.span;\n                 match self.parse_expr() {\n                     Ok(e) => base = Some(e),\n                     Err(mut e) => {\n@@ -1828,7 +1834,7 @@ impl<'a> Parser<'a> {\n                     if let Some(f) = recovery_field {\n                         fields.push(f);\n                         e.span_suggestion(\n-                            self.prev_span.shrink_to_hi(),\n+                            self.prev_token.span.shrink_to_hi(),\n                             \"try adding a comma\",\n                             \",\".into(),\n                             Applicability::MachineApplicable,\n@@ -1868,15 +1874,18 @@ impl<'a> Parser<'a> {\n         if self.token != token::Comma {\n             return;\n         }\n-        self.struct_span_err(span.to(self.prev_span), \"cannot use a comma after the base struct\")\n-            .span_suggestion_short(\n-                self.token.span,\n-                \"remove this comma\",\n-                String::new(),\n-                Applicability::MachineApplicable,\n-            )\n-            .note(\"the base struct must always be the last field\")\n-            .emit();\n+        self.struct_span_err(\n+            span.to(self.prev_token.span),\n+            \"cannot use a comma after the base struct\",\n+        )\n+        .span_suggestion_short(\n+            self.token.span,\n+            \"remove this comma\",\n+            String::new(),\n+            Applicability::MachineApplicable,\n+        )\n+        .note(\"the base struct must always be the last field\")\n+        .emit();\n         self.recover_stmt();\n     }\n \n@@ -1966,7 +1975,7 @@ impl<'a> Parser<'a> {\n         limits: RangeLimits,\n     ) -> PResult<'a, ExprKind> {\n         if end.is_none() && limits == RangeLimits::Closed {\n-            self.error_inclusive_range_with_no_end(self.prev_span);\n+            self.error_inclusive_range_with_no_end(self.prev_token.span);\n             Ok(ExprKind::Err)\n         } else {\n             Ok(ExprKind::Range(start, end, limits))\n@@ -1990,7 +1999,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn mk_await_expr(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n-        let span = lo.to(self.prev_span);\n+        let span = lo.to(self.prev_token.span);\n         let await_expr = self.mk_expr(span, ExprKind::Await(self_arg), AttrVec::new());\n         self.recover_from_await_method_call();\n         Ok(await_expr)"}, {"sha": "59fd5f7c4be1fc55f414cdb6dce37c985048f1c2", "filename": "src/librustc_parse/parser/generics.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -29,7 +29,7 @@ impl<'a> Parser<'a> {\n \n         // Parse optional colon and param bounds.\n         let bounds = if self.eat(&token::Colon) {\n-            self.parse_generic_bounds(Some(self.prev_span))?\n+            self.parse_generic_bounds(Some(self.prev_token.span))?\n         } else {\n             Vec::new()\n         };\n@@ -54,7 +54,7 @@ impl<'a> Parser<'a> {\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n \n-        self.sess.gated_spans.gate(sym::const_generics, lo.to(self.prev_span));\n+        self.sess.gated_spans.gate(sym::const_generics, lo.to(self.prev_token.span));\n \n         Ok(GenericParam {\n             ident,\n@@ -150,15 +150,15 @@ impl<'a> Parser<'a> {\n         let (params, span) = if self.eat_lt() {\n             let params = self.parse_generic_params()?;\n             self.expect_gt()?;\n-            (params, span_lo.to(self.prev_span))\n+            (params, span_lo.to(self.prev_token.span))\n         } else {\n-            (vec![], self.prev_span.shrink_to_hi())\n+            (vec![], self.prev_token.span.shrink_to_hi())\n         };\n         Ok(ast::Generics {\n             params,\n             where_clause: WhereClause {\n                 predicates: Vec::new(),\n-                span: self.prev_span.shrink_to_hi(),\n+                span: self.prev_token.span.shrink_to_hi(),\n             },\n             span,\n         })\n@@ -171,12 +171,12 @@ impl<'a> Parser<'a> {\n     /// ```\n     pub(super) fn parse_where_clause(&mut self) -> PResult<'a, WhereClause> {\n         let mut where_clause =\n-            WhereClause { predicates: Vec::new(), span: self.prev_span.shrink_to_hi() };\n+            WhereClause { predicates: Vec::new(), span: self.prev_token.span.shrink_to_hi() };\n \n         if !self.eat_keyword(kw::Where) {\n             return Ok(where_clause);\n         }\n-        let lo = self.prev_span;\n+        let lo = self.prev_token.span;\n \n         // We are considering adding generics to the `where` keyword as an alternative higher-rank\n         // parameter syntax (as in `where<'a>` or `where<T>`. To avoid that being a breaking\n@@ -199,7 +199,11 @@ impl<'a> Parser<'a> {\n                 self.expect(&token::Colon)?;\n                 let bounds = self.parse_lt_param_bounds();\n                 where_clause.predicates.push(ast::WherePredicate::RegionPredicate(\n-                    ast::WhereRegionPredicate { span: lo.to(self.prev_span), lifetime, bounds },\n+                    ast::WhereRegionPredicate {\n+                        span: lo.to(self.prev_token.span),\n+                        lifetime,\n+                        bounds,\n+                    },\n                 ));\n             } else if self.check_type() {\n                 where_clause.predicates.push(self.parse_ty_where_predicate()?);\n@@ -212,7 +216,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        where_clause.span = lo.to(self.prev_span);\n+        where_clause.span = lo.to(self.prev_token.span);\n         Ok(where_clause)\n     }\n \n@@ -231,9 +235,9 @@ impl<'a> Parser<'a> {\n         // or with mandatory equality sign and the second type.\n         let ty = self.parse_ty()?;\n         if self.eat(&token::Colon) {\n-            let bounds = self.parse_generic_bounds(Some(self.prev_span))?;\n+            let bounds = self.parse_generic_bounds(Some(self.prev_token.span))?;\n             Ok(ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n-                span: lo.to(self.prev_span),\n+                span: lo.to(self.prev_token.span),\n                 bound_generic_params: lifetime_defs,\n                 bounded_ty: ty,\n                 bounds,\n@@ -243,7 +247,7 @@ impl<'a> Parser<'a> {\n         } else if self.eat(&token::Eq) || self.eat(&token::EqEq) {\n             let rhs_ty = self.parse_ty()?;\n             Ok(ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n-                span: lo.to(self.prev_span),\n+                span: lo.to(self.prev_token.span),\n                 lhs_ty: ty,\n                 rhs_ty,\n                 id: ast::DUMMY_NODE_ID,"}, {"sha": "9bca1d09901590654ce46fc13b70d2b817050a92", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -95,7 +95,7 @@ impl<'a> Parser<'a> {\n         let kind = self.parse_item_kind(&mut attrs, mac_allowed, lo, &vis, &mut def, req_name)?;\n         if let Some((ident, kind)) = kind {\n             self.error_on_unconsumed_default(def, &kind);\n-            let span = lo.to(self.prev_span);\n+            let span = lo.to(self.prev_token.span);\n             let id = DUMMY_NODE_ID;\n             let item = Item { ident, attrs, id, kind, vis, span, tokens: None };\n             return Ok(Some(item));\n@@ -247,8 +247,8 @@ impl<'a> Parser<'a> {\n         //\n         //     pub   S {}\n         //        ^^^ `sp` points here\n-        let sp = self.prev_span.between(self.token.span);\n-        let full_sp = self.prev_span.to(self.token.span);\n+        let sp = self.prev_token.span.between(self.token.span);\n+        let full_sp = self.prev_token.span.to(self.token.span);\n         let ident_sp = self.token.span;\n         if self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) {\n             // possible public struct definition where `struct` was forgotten\n@@ -402,7 +402,7 @@ impl<'a> Parser<'a> {\n             let mut generics = Generics::default();\n             // impl A for B {}\n             //    /\\ this is where `generics.span` should point when there are no type params.\n-            generics.span = self.prev_span.shrink_to_hi();\n+            generics.span = self.prev_token.span.shrink_to_hi();\n             generics\n         };\n \n@@ -423,7 +423,7 @@ impl<'a> Parser<'a> {\n         let err_path = |span| ast::Path::from_ident(Ident::new(kw::Invalid, span));\n         let ty_first = if self.token.is_keyword(kw::For) && self.look_ahead(1, |t| t != &token::Lt)\n         {\n-            let span = self.prev_span.between(self.token.span);\n+            let span = self.prev_token.span.between(self.token.span);\n             self.struct_span_err(span, \"missing trait in a trait impl\").emit();\n             P(Ty { kind: TyKind::Path(None, err_path(span)), span, id: DUMMY_NODE_ID })\n         } else {\n@@ -432,12 +432,12 @@ impl<'a> Parser<'a> {\n \n         // If `for` is missing we try to recover.\n         let has_for = self.eat_keyword(kw::For);\n-        let missing_for_span = self.prev_span.between(self.token.span);\n+        let missing_for_span = self.prev_token.span.between(self.token.span);\n \n         let ty_second = if self.token == token::DotDot {\n             // We need to report this error after `cfg` expansion for compatibility reasons\n             self.bump(); // `..`, do not add it to expected tokens\n-            Some(self.mk_ty(self.prev_span, TyKind::Err))\n+            Some(self.mk_ty(self.prev_token.span, TyKind::Err))\n         } else if has_for || self.token.can_begin_type() {\n             Some(self.parse_ty()?)\n         } else {\n@@ -524,15 +524,15 @@ impl<'a> Parser<'a> {\n                     self.struct_span_err(non_item_span, \"non-item in item list\")\n                         .span_label(open_brace_span, \"item list starts here\")\n                         .span_label(non_item_span, \"non-item starts here\")\n-                        .span_label(self.prev_span, \"item list ends here\")\n+                        .span_label(self.prev_token.span, \"item list ends here\")\n                         .emit();\n                     break;\n                 }\n                 Ok(Some(item)) => items.extend(item),\n                 Err(mut err) => {\n                     self.consume_block(token::Brace, ConsumeClosingDelim::Yes);\n                     err.span_label(open_brace_span, \"while parsing this item list starting here\")\n-                        .span_label(self.prev_span, \"the item list ends here\")\n+                        .span_label(self.prev_token.span, \"the item list ends here\")\n                         .emit();\n                     break;\n                 }\n@@ -573,7 +573,7 @@ impl<'a> Parser<'a> {\n             && self.look_ahead(1, |t| t.is_non_raw_ident_where(|i| i.name != kw::As))\n         {\n             self.bump(); // `default`\n-            Defaultness::Default(self.prev_span)\n+            Defaultness::Default(self.normalized_prev_token.span)\n         } else {\n             Defaultness::Final\n         }\n@@ -599,11 +599,14 @@ impl<'a> Parser<'a> {\n \n         // Parse optional colon and supertrait bounds.\n         let had_colon = self.eat(&token::Colon);\n-        let span_at_colon = self.prev_span;\n-        let bounds =\n-            if had_colon { self.parse_generic_bounds(Some(self.prev_span))? } else { Vec::new() };\n+        let span_at_colon = self.prev_token.span;\n+        let bounds = if had_colon {\n+            self.parse_generic_bounds(Some(self.prev_token.span))?\n+        } else {\n+            Vec::new()\n+        };\n \n-        let span_before_eq = self.prev_span;\n+        let span_before_eq = self.prev_token.span;\n         if self.eat(&token::Eq) {\n             // It's a trait alias.\n             if had_colon {\n@@ -615,7 +618,7 @@ impl<'a> Parser<'a> {\n             tps.where_clause = self.parse_where_clause()?;\n             self.expect_semi()?;\n \n-            let whole_span = lo.to(self.prev_span);\n+            let whole_span = lo.to(self.prev_token.span);\n             if is_auto == IsAuto::Yes {\n                 let msg = \"trait aliases cannot be `auto`\";\n                 self.struct_span_err(whole_span, msg).span_label(whole_span, msg).emit();\n@@ -719,7 +722,7 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        Ok(UseTree { prefix, kind, span: lo.to(self.prev_span) })\n+        Ok(UseTree { prefix, kind, span: lo.to(self.prev_token.span) })\n     }\n \n     /// Parses `*` or `{...}`.\n@@ -793,7 +796,7 @@ impl<'a> Parser<'a> {\n             // Do not include `-` as part of the expected tokens list.\n             while self.eat(&dash) {\n                 fixed_crate_name = true;\n-                replacement.push((self.prev_span, \"_\".to_string()));\n+                replacement.push((self.prev_token.span, \"_\".to_string()));\n                 idents.push(self.parse_ident()?);\n             }\n         }\n@@ -887,7 +890,7 @@ impl<'a> Parser<'a> {\n     /// Recover on `const mut` with `const` already eaten.\n     fn recover_const_mut(&mut self, const_span: Span) {\n         if self.eat_keyword(kw::Mut) {\n-            let span = self.prev_span;\n+            let span = self.prev_token.span;\n             self.struct_span_err(span, \"const globals cannot be mutable\")\n                 .span_label(span, \"cannot be mutable\")\n                 .span_suggestion(\n@@ -994,7 +997,7 @@ impl<'a> Parser<'a> {\n             attrs: variant_attrs,\n             data: struct_def,\n             disr_expr,\n-            span: vlo.to(self.prev_span),\n+            span: vlo.to(self.prev_token.span),\n             is_placeholder: false,\n         };\n \n@@ -1161,7 +1164,7 @@ impl<'a> Parser<'a> {\n             }\n             token::CloseDelim(token::Brace) => {}\n             token::DocComment(_) => {\n-                let previous_span = self.prev_span;\n+                let previous_span = self.prev_token.span;\n                 let mut err = self.span_fatal_err(self.token.span, Error::UselessDocComment);\n                 self.bump(); // consume the doc comment\n                 let comma_after_doc_seen = self.eat(&token::Comma);\n@@ -1186,7 +1189,7 @@ impl<'a> Parser<'a> {\n                 }\n             }\n             _ => {\n-                let sp = self.prev_span.shrink_to_hi();\n+                let sp = self.prev_token.span.shrink_to_hi();\n                 let mut err = self.struct_span_err(\n                     sp,\n                     &format!(\"expected `,`, or `}}`, found {}\", super::token_descr(&self.token)),\n@@ -1219,7 +1222,7 @@ impl<'a> Parser<'a> {\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n         Ok(StructField {\n-            span: lo.to(self.prev_span),\n+            span: lo.to(self.prev_token.span),\n             ident: Some(name),\n             vis,\n             id: DUMMY_NODE_ID,\n@@ -1257,7 +1260,7 @@ impl<'a> Parser<'a> {\n             return self.unexpected();\n         };\n \n-        self.sess.gated_spans.gate(sym::decl_macro, lo.to(self.prev_span));\n+        self.sess.gated_spans.gate(sym::decl_macro, lo.to(self.prev_token.span));\n         Ok((ident, ItemKind::MacroDef(ast::MacroDef { body, legacy: false })))\n     }\n \n@@ -1511,11 +1514,11 @@ impl<'a> Parser<'a> {\n         let (mut params, _) = self.parse_paren_comma_seq(|p| {\n             let param = p.parse_param_general(req_name, first_param).or_else(|mut e| {\n                 e.emit();\n-                let lo = p.prev_span;\n+                let lo = p.prev_token.span;\n                 // Skip every token until next possible arg or end.\n                 p.eat_to_tokens(&[&token::Comma, &token::CloseDelim(token::Paren)]);\n                 // Create a placeholder argument for proper arg count (issue #34264).\n-                Ok(dummy_arg(Ident::new(kw::Invalid, lo.to(p.prev_span))))\n+                Ok(dummy_arg(Ident::new(kw::Invalid, lo.to(p.prev_token.span))))\n             });\n             // ...now that we've parsed the first argument, `self` is no longer allowed.\n             first_param = false;\n@@ -1575,7 +1578,7 @@ impl<'a> Parser<'a> {\n             }\n             match ty {\n                 Ok(ty) => {\n-                    let ident = Ident::new(kw::Invalid, self.prev_span);\n+                    let ident = Ident::new(kw::Invalid, self.prev_token.span);\n                     let bm = BindingMode::ByValue(Mutability::Not);\n                     let pat = self.mk_pat_ident(ty.span, bm, ident);\n                     (pat, ty)\n@@ -1627,7 +1630,7 @@ impl<'a> Parser<'a> {\n         // Parse `self` or `self: TYPE`. We already know the current token is `self`.\n         let parse_self_possibly_typed = |this: &mut Self, m| {\n             let eself_ident = expect_self_ident(this);\n-            let eself_hi = this.prev_span;\n+            let eself_hi = this.prev_token.span;\n             let eself = if this.eat(&token::Colon) {\n                 SelfKind::Explicit(this.parse_ty()?, m)\n             } else {\n@@ -1641,7 +1644,7 @@ impl<'a> Parser<'a> {\n             let span = this.token.span;\n             this.struct_span_err(span, msg).span_label(span, msg).emit();\n \n-            Ok((SelfKind::Value(Mutability::Not), expect_self_ident(this), this.prev_span))\n+            Ok((SelfKind::Value(Mutability::Not), expect_self_ident(this), this.prev_token.span))\n         };\n \n         // Parse optional `self` parameter of a method.\n@@ -1674,7 +1677,7 @@ impl<'a> Parser<'a> {\n                     // `&not_self`\n                     return Ok(None);\n                 };\n-                (eself, expect_self_ident(self), self.prev_span)\n+                (eself, expect_self_ident(self), self.prev_token.span)\n             }\n             // `*self`\n             token::BinOp(token::Star) if is_isolated_self(self, 1) => {"}, {"sha": "74101fef8e39b606eed2e708db6661e4ccfd5340", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -78,7 +78,7 @@ macro_rules! maybe_recover_from_interpolated_ty_qpath {\n                 if let token::NtTy(ty) = &**nt {\n                     let ty = ty.clone();\n                     $self.bump();\n-                    return $self.maybe_recover_from_bad_qpath_stage_2($self.prev_span, ty);\n+                    return $self.maybe_recover_from_bad_qpath_stage_2($self.prev_token.span, ty);\n                 }\n             }\n         }\n@@ -103,8 +103,6 @@ pub struct Parser<'a> {\n     /// Use this if you need to check for `token::Ident` or `token::Lifetime` specifically,\n     /// this also includes edition checks for edition-specific keyword identifiers.\n     pub normalized_prev_token: Token,\n-    /// FIXME: Remove in favor of the equivalent `prev_token.span`.\n-    pub prev_span: Span,\n     restrictions: Restrictions,\n     /// Used to determine the path to externally loaded source files.\n     pub(super) directory: Directory,\n@@ -379,7 +377,6 @@ impl<'a> Parser<'a> {\n             normalized_token: Token::dummy(),\n             prev_token: Token::dummy(),\n             normalized_prev_token: Token::dummy(),\n-            prev_span: DUMMY_SP,\n             restrictions: Restrictions::empty(),\n             recurse_into_file_modules,\n             directory: Directory {\n@@ -498,7 +495,7 @@ impl<'a> Parser<'a> {\n             }\n             _ => Err(match self.prev_token.kind {\n                 TokenKind::DocComment(..) => {\n-                    self.span_fatal_err(self.prev_span, Error::UselessDocComment)\n+                    self.span_fatal_err(self.prev_token.span, Error::UselessDocComment)\n                 }\n                 _ => self.expected_ident_found(),\n             }),\n@@ -706,7 +703,7 @@ impl<'a> Parser<'a> {\n                             break;\n                         }\n                         Err(mut expect_err) => {\n-                            let sp = self.prev_span.shrink_to_hi();\n+                            let sp = self.prev_token.span.shrink_to_hi();\n                             let token_str = pprust::token_kind_to_string(t);\n \n                             // Attempt to keep parsing if it was a similar separator.\n@@ -850,9 +847,6 @@ impl<'a> Parser<'a> {\n         self.normalized_prev_token = self.normalized_token.take();\n         self.set_token(next_token);\n \n-        // Update fields derived from the previous token.\n-        self.prev_span = self.prev_token.span;\n-\n         // Diagnostics.\n         self.expected_tokens.clear();\n     }\n@@ -899,12 +893,20 @@ impl<'a> Parser<'a> {\n \n     /// Parses unsafety: `unsafe` or nothing.\n     fn parse_unsafety(&mut self) -> Unsafe {\n-        if self.eat_keyword(kw::Unsafe) { Unsafe::Yes(self.prev_span) } else { Unsafe::No }\n+        if self.eat_keyword(kw::Unsafe) {\n+            Unsafe::Yes(self.normalized_prev_token.span)\n+        } else {\n+            Unsafe::No\n+        }\n     }\n \n     /// Parses constness: `const` or nothing.\n     fn parse_constness(&mut self) -> Const {\n-        if self.eat_keyword(kw::Const) { Const::Yes(self.prev_span) } else { Const::No }\n+        if self.eat_keyword(kw::Const) {\n+            Const::Yes(self.normalized_prev_token.span)\n+        } else {\n+            Const::No\n+        }\n     }\n \n     /// Parses mutability (`mut` or nothing).\n@@ -928,7 +930,7 @@ impl<'a> Parser<'a> {\n         {\n             self.expect_no_suffix(self.token.span, \"a tuple index\", suffix);\n             self.bump();\n-            Ok(Ident::new(symbol, self.prev_span))\n+            Ok(Ident::new(symbol, self.prev_token.span))\n         } else {\n             self.parse_ident_common(false)\n         }\n@@ -958,7 +960,7 @@ impl<'a> Parser<'a> {\n                 }\n             } else if !delimited_only {\n                 if self.eat(&token::Eq) {\n-                    let eq_span = self.prev_span;\n+                    let eq_span = self.prev_token.span;\n                     let mut is_interpolated_expr = false;\n                     if let token::Interpolated(nt) = &self.token.kind {\n                         if let token::NtExpr(..) = **nt {\n@@ -1061,8 +1063,8 @@ impl<'a> Parser<'a> {\n         self.expected_tokens.push(TokenType::Keyword(kw::Crate));\n         if self.is_crate_vis() {\n             self.bump(); // `crate`\n-            self.sess.gated_spans.gate(sym::crate_visibility_modifier, self.prev_span);\n-            return Ok(respan(self.prev_span, VisibilityKind::Crate(CrateSugar::JustCrate)));\n+            self.sess.gated_spans.gate(sym::crate_visibility_modifier, self.prev_token.span);\n+            return Ok(respan(self.prev_token.span, VisibilityKind::Crate(CrateSugar::JustCrate)));\n         }\n \n         if !self.eat_keyword(kw::Pub) {\n@@ -1071,7 +1073,7 @@ impl<'a> Parser<'a> {\n             // beginning of the current token would seem to be the \"Schelling span\".\n             return Ok(respan(self.token.span.shrink_to_lo(), VisibilityKind::Inherited));\n         }\n-        let lo = self.prev_span;\n+        let lo = self.prev_token.span;\n \n         if self.check(&token::OpenDelim(token::Paren)) {\n             // We don't `self.bump()` the `(` yet because this might be a struct definition where\n@@ -1086,15 +1088,15 @@ impl<'a> Parser<'a> {\n                 self.bump(); // `crate`\n                 self.expect(&token::CloseDelim(token::Paren))?; // `)`\n                 let vis = VisibilityKind::Crate(CrateSugar::PubCrate);\n-                return Ok(respan(lo.to(self.prev_span), vis));\n+                return Ok(respan(lo.to(self.prev_token.span), vis));\n             } else if self.is_keyword_ahead(1, &[kw::In]) {\n                 // Parse `pub(in path)`.\n                 self.bump(); // `(`\n                 self.bump(); // `in`\n                 let path = self.parse_path(PathStyle::Mod)?; // `path`\n                 self.expect(&token::CloseDelim(token::Paren))?; // `)`\n                 let vis = VisibilityKind::Restricted { path: P(path), id: ast::DUMMY_NODE_ID };\n-                return Ok(respan(lo.to(self.prev_span), vis));\n+                return Ok(respan(lo.to(self.prev_token.span), vis));\n             } else if self.look_ahead(2, |t| t == &token::CloseDelim(token::Paren))\n                 && self.is_keyword_ahead(1, &[kw::Super, kw::SelfLower])\n             {\n@@ -1103,7 +1105,7 @@ impl<'a> Parser<'a> {\n                 let path = self.parse_path(PathStyle::Mod)?; // `super`/`self`\n                 self.expect(&token::CloseDelim(token::Paren))?; // `)`\n                 let vis = VisibilityKind::Restricted { path: P(path), id: ast::DUMMY_NODE_ID };\n-                return Ok(respan(lo.to(self.prev_span), vis));\n+                return Ok(respan(lo.to(self.prev_token.span), vis));\n             } else if let FollowedByType::No = fbt {\n                 // Provide this diagnostic if a type cannot follow;\n                 // in particular, if this is not a tuple struct."}, {"sha": "b436f1969bb48aa110641269b066a3ed747d9859", "filename": "src/librustc_parse/parser/module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmodule.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -90,7 +90,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let hi = if self.token.span.is_dummy() { inner_lo } else { self.prev_span };\n+        let hi = if self.token.span.is_dummy() { inner_lo } else { self.prev_token.span };\n \n         Ok(Mod { inner: inner_lo.to(hi), items, inline: true })\n     }"}, {"sha": "45d1aacdd3cc6cf226abbb2164c52cad273f2606", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -48,7 +48,7 @@ impl<'a> Parser<'a> {\n     pub(super) fn parse_top_pat(&mut self, gate_or: GateOr) -> PResult<'a, P<Pat>> {\n         // Allow a '|' before the pats (RFCs 1925, 2530, and 2535).\n         let gated_leading_vert = self.eat_or_separator(None) && gate_or == GateOr::Yes;\n-        let leading_vert_span = self.prev_span;\n+        let leading_vert_span = self.prev_token.span;\n \n         // Parse the possibly-or-pattern.\n         let pat = self.parse_pat_with_or(None, gate_or, RecoverComma::Yes)?;\n@@ -115,7 +115,7 @@ impl<'a> Parser<'a> {\n             self.maybe_recover_unexpected_comma(pat.span, rc)?;\n             pats.push(pat);\n         }\n-        let or_pattern_span = lo.to(self.prev_span);\n+        let or_pattern_span = lo.to(self.prev_token.span);\n \n         // Feature gate the or-pattern if instructed:\n         if gate_or == GateOr::Yes {\n@@ -206,7 +206,7 @@ impl<'a> Parser<'a> {\n             // end of the comma-sequence so we know the span to suggest parenthesizing.\n             err.cancel();\n         }\n-        let seq_span = lo.to(self.prev_span);\n+        let seq_span = lo.to(self.prev_token.span);\n         let mut err = self.struct_span_err(comma_span, \"unexpected `,` in pattern\");\n         if let Ok(seq_snippet) = self.span_to_snippet(seq_span) {\n             err.span_suggestion(\n@@ -311,7 +311,7 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(kw::Box) {\n             // Parse `box pat`\n             let pat = self.parse_pat_with_range_pat(false, None)?;\n-            self.sess.gated_spans.gate(sym::box_patterns, lo.to(self.prev_span));\n+            self.sess.gated_spans.gate(sym::box_patterns, lo.to(self.prev_token.span));\n             PatKind::Box(pat)\n         } else if self.can_be_ident_pat() {\n             // Parse `ident @ pat`\n@@ -328,7 +328,7 @@ impl<'a> Parser<'a> {\n                 // Parse an unqualified path\n                 (None, self.parse_path(PathStyle::Expr)?)\n             };\n-            let span = lo.to(self.prev_span);\n+            let span = lo.to(self.prev_token.span);\n \n             if qself.is_none() && self.check(&token::Not) {\n                 self.parse_pat_mac_invoc(path)?\n@@ -353,7 +353,7 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        let pat = self.mk_pat(lo.to(self.prev_span), pat);\n+        let pat = self.mk_pat(lo.to(self.prev_token.span), pat);\n         let pat = self.maybe_recover_from_bad_qpath(pat, true)?;\n         let pat = self.recover_intersection_pat(pat)?;\n \n@@ -459,7 +459,7 @@ impl<'a> Parser<'a> {\n         if let token::Lifetime(name) = self.token.kind {\n             self.bump(); // `'a`\n \n-            let span = self.prev_span;\n+            let span = self.prev_token.span;\n             self.struct_span_err(span, &format!(\"unexpected lifetime `{}` in pattern\", name))\n                 .span_suggestion(\n                     span,\n@@ -487,7 +487,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a mutable binding with the `mut` token already eaten.\n     fn parse_pat_ident_mut(&mut self) -> PResult<'a, PatKind> {\n-        let mut_span = self.prev_span;\n+        let mut_span = self.prev_token.span;\n \n         if self.eat_keyword(kw::Ref) {\n             return self.recover_mut_ref_ident(mut_span);\n@@ -522,7 +522,7 @@ impl<'a> Parser<'a> {\n     /// Recover on `mut ref? ident @ pat` and suggest\n     /// that the order of `mut` and `ref` is incorrect.\n     fn recover_mut_ref_ident(&mut self, lo: Span) -> PResult<'a, PatKind> {\n-        let mutref_span = lo.to(self.prev_span);\n+        let mutref_span = lo.to(self.prev_token.span);\n         self.struct_span_err(mutref_span, \"the order of `mut` and `ref` is incorrect\")\n             .span_suggestion(\n                 mutref_span,\n@@ -582,7 +582,7 @@ impl<'a> Parser<'a> {\n             return;\n         }\n \n-        let span = lo.to(self.prev_span);\n+        let span = lo.to(self.prev_token.span);\n         self.struct_span_err(span, \"`mut` on a binding may not be repeated\")\n             .span_suggestion(\n                 span,\n@@ -629,12 +629,12 @@ impl<'a> Parser<'a> {\n         } else if self.eat(&token::DotDotEq) {\n             RangeEnd::Included(RangeSyntax::DotDotEq)\n         } else if self.eat(&token::DotDot) {\n-            self.sess.gated_spans.gate(sym::exclusive_range_pattern, self.prev_span);\n+            self.sess.gated_spans.gate(sym::exclusive_range_pattern, self.prev_token.span);\n             RangeEnd::Excluded\n         } else {\n             return None;\n         };\n-        Some(respan(self.prev_span, re))\n+        Some(respan(self.prev_token.span, re))\n     }\n \n     /// Parse a range pattern `$begin $form $end?` where `$form = \"..\" | \"...\" | \"..=\" ;`.\n@@ -678,7 +678,7 @@ impl<'a> Parser<'a> {\n     /// expression syntax `...expr` for splatting in expressions.\n     fn parse_pat_range_to(&mut self, mut re: Spanned<RangeEnd>) -> PResult<'a, PatKind> {\n         let end = self.parse_pat_range_end()?;\n-        self.sess.gated_spans.gate(sym::half_open_range_patterns, re.span.to(self.prev_span));\n+        self.sess.gated_spans.gate(sym::half_open_range_patterns, re.span.to(self.prev_token.span));\n         if let RangeEnd::Included(ref mut syn @ RangeSyntax::DotDotDot) = &mut re.node {\n             *syn = RangeSyntax::DotDotEq;\n             self.struct_span_err(re.span, \"range-to patterns with `...` are not allowed\")\n@@ -714,7 +714,7 @@ impl<'a> Parser<'a> {\n                 // Parse an unqualified path\n                 (None, self.parse_path(PathStyle::Expr)?)\n             };\n-            let hi = self.prev_span;\n+            let hi = self.prev_token.span;\n             Ok(self.mk_expr(lo.to(hi), ExprKind::Path(qself, path), AttrVec::new()))\n         } else {\n             self.parse_literal_maybe_minus()\n@@ -762,9 +762,8 @@ impl<'a> Parser<'a> {\n         // binding mode then we do not end up here, because the lookahead\n         // will direct us over to `parse_enum_variant()`.\n         if self.token == token::OpenDelim(token::Paren) {\n-            return Err(\n-                self.struct_span_err(self.prev_span, \"expected identifier, found enum pattern\")\n-            );\n+            return Err(self\n+                .struct_span_err(self.prev_token.span, \"expected identifier, found enum pattern\"));\n         }\n \n         Ok(PatKind::Ident(binding_mode, ident, sub))\n@@ -826,7 +825,7 @@ impl<'a> Parser<'a> {\n \n             // check that a comma comes after every field\n             if !ate_comma {\n-                let err = self.struct_span_err(self.prev_span, \"expected `,`\");\n+                let err = self.struct_span_err(self.prev_token.span, \"expected `,`\");\n                 if let Some(mut delayed) = delayed_err {\n                     delayed.emit();\n                 }\n@@ -958,7 +957,7 @@ impl<'a> Parser<'a> {\n             let is_ref = self.eat_keyword(kw::Ref);\n             let is_mut = self.eat_keyword(kw::Mut);\n             let fieldname = self.parse_ident()?;\n-            hi = self.prev_span;\n+            hi = self.prev_token.span;\n \n             let bind_type = match (is_ref, is_mut) {\n                 (true, true) => BindingMode::ByRef(Mutability::Mut),"}, {"sha": "355b6429a7494fdc8122120e81b88c766ffeb357", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -50,7 +50,7 @@ impl<'a> Parser<'a> {\n     /// `<T as U>::F::a<S>` (without disambiguator)\n     /// `<T as U>::F::a::<S>` (with disambiguator)\n     pub(super) fn parse_qpath(&mut self, style: PathStyle) -> PResult<'a, (QSelf, Path)> {\n-        let lo = self.prev_span;\n+        let lo = self.prev_token.span;\n         let ty = self.parse_ty()?;\n \n         // `path` will contain the prefix of the path up to the `>`,\n@@ -61,7 +61,7 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(kw::As) {\n             let path_lo = self.token.span;\n             path = self.parse_path(PathStyle::Type)?;\n-            path_span = path_lo.to(self.prev_span);\n+            path_span = path_lo.to(self.prev_token.span);\n         } else {\n             path_span = self.token.span.to(self.token.span);\n             path = ast::Path { segments: Vec::new(), span: path_span };\n@@ -81,7 +81,7 @@ impl<'a> Parser<'a> {\n         let qself = QSelf { ty, path_span, position: path.segments.len() };\n         self.parse_path_segments(&mut path.segments, style)?;\n \n-        Ok((qself, Path { segments: path.segments, span: lo.to(self.prev_span) }))\n+        Ok((qself, Path { segments: path.segments, span: lo.to(self.prev_token.span) }))\n     }\n \n     /// Recover from an invalid single colon, when the user likely meant a qualified path.\n@@ -103,11 +103,11 @@ impl<'a> Parser<'a> {\n \n         self.diagnostic()\n             .struct_span_err(\n-                self.prev_span,\n+                self.prev_token.span,\n                 \"found single colon before projection in qualified path\",\n             )\n             .span_suggestion(\n-                self.prev_span,\n+                self.prev_token.span,\n                 \"use double colon\",\n                 \"::\".to_string(),\n                 Applicability::MachineApplicable,\n@@ -144,7 +144,7 @@ impl<'a> Parser<'a> {\n         }\n         self.parse_path_segments(&mut segments, style)?;\n \n-        Ok(Path { segments, span: lo.to(self.prev_span) })\n+        Ok(Path { segments, span: lo.to(self.prev_token.span) })\n     }\n \n     pub(super) fn parse_path_segments(\n@@ -221,12 +221,12 @@ impl<'a> Parser<'a> {\n                     let (args, constraints) =\n                         self.parse_generic_args_with_leading_angle_bracket_recovery(style, lo)?;\n                     self.expect_gt()?;\n-                    let span = lo.to(self.prev_span);\n+                    let span = lo.to(self.prev_token.span);\n                     AngleBracketedArgs { args, constraints, span }.into()\n                 } else {\n                     // `(T, U) -> R`\n                     let (inputs, _) = self.parse_paren_comma_seq(|p| p.parse_ty())?;\n-                    let span = ident.span.to(self.prev_span);\n+                    let span = ident.span.to(self.prev_token.span);\n                     let output = self.parse_ret_ty(AllowPlus::No, RecoverQPath::No)?;\n                     ParenthesizedArgs { inputs, output, span }.into()\n                 };\n@@ -412,13 +412,13 @@ impl<'a> Parser<'a> {\n                     AssocTyConstraintKind::Equality { ty: self.parse_ty()? }\n                 } else if self.eat(&token::Colon) {\n                     AssocTyConstraintKind::Bound {\n-                        bounds: self.parse_generic_bounds(Some(self.prev_span))?,\n+                        bounds: self.parse_generic_bounds(Some(self.prev_token.span))?,\n                     }\n                 } else {\n                     unreachable!();\n                 };\n \n-                let span = lo.to(self.prev_span);\n+                let span = lo.to(self.prev_token.span);\n \n                 // Gate associated type bounds, e.g., `Iterator<Item: Ord>`.\n                 if let AssocTyConstraintKind::Bound { .. } = kind {\n@@ -473,7 +473,7 @@ impl<'a> Parser<'a> {\n         // lose that information after parsing.\n         if !misplaced_assoc_ty_constraints.is_empty() {\n             let mut err = self.struct_span_err(\n-                args_lo.to(self.prev_span),\n+                args_lo.to(self.prev_token.span),\n                 \"associated type bindings must be declared after generic parameters\",\n             );\n             for span in misplaced_assoc_ty_constraints {"}, {"sha": "e38a7f2f1c2a251b59087a72c0bbe957c840dfd4", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -104,23 +104,23 @@ impl<'a> Parser<'a> {\n         let expr = if self.check(&token::OpenDelim(token::Brace)) {\n             self.parse_struct_expr(lo, path, AttrVec::new())?\n         } else {\n-            let hi = self.prev_span;\n+            let hi = self.prev_token.span;\n             self.mk_expr(lo.to(hi), ExprKind::Path(None, path), AttrVec::new())\n         };\n \n         let expr = self.with_res(Restrictions::STMT_EXPR, |this| {\n             let expr = this.parse_dot_or_call_expr_with(expr, lo, attrs.into())?;\n             this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr))\n         })?;\n-        Ok(self.mk_stmt(lo.to(self.prev_span), StmtKind::Expr(expr)))\n+        Ok(self.mk_stmt(lo.to(self.prev_token.span), StmtKind::Expr(expr)))\n     }\n \n     /// Parses a statement macro `mac!(args)` provided a `path` representing `mac`.\n     /// At this point, the `!` token after the path has already been eaten.\n     fn parse_stmt_mac(&mut self, lo: Span, attrs: AttrVec, path: ast::Path) -> PResult<'a, Stmt> {\n         let args = self.parse_mac_args()?;\n         let delim = args.delim();\n-        let hi = self.prev_span;\n+        let hi = self.prev_token.span;\n \n         let style =\n             if delim == token::Brace { MacStmtStyle::Braces } else { MacStmtStyle::NoBraces };\n@@ -146,7 +146,7 @@ impl<'a> Parser<'a> {\n     fn error_outer_attrs(&self, attrs: &[Attribute]) {\n         if !attrs.is_empty() {\n             if matches!(self.prev_token.kind, TokenKind::DocComment(..)) {\n-                self.span_fatal_err(self.prev_span, Error::UselessDocComment).emit();\n+                self.span_fatal_err(self.prev_token.span, Error::UselessDocComment).emit();\n             } else if attrs.iter().any(|a| a.style == AttrStyle::Outer) {\n                 self.struct_span_err(self.token.span, \"expected statement after outer attribute\")\n                     .emit();\n@@ -170,19 +170,19 @@ impl<'a> Parser<'a> {\n \n     fn parse_local_mk(&mut self, lo: Span, attrs: AttrVec) -> PResult<'a, Stmt> {\n         let local = self.parse_local(attrs)?;\n-        Ok(self.mk_stmt(lo.to(self.prev_span), StmtKind::Local(local)))\n+        Ok(self.mk_stmt(lo.to(self.prev_token.span), StmtKind::Local(local)))\n     }\n \n     /// Parses a local variable declaration.\n     fn parse_local(&mut self, attrs: AttrVec) -> PResult<'a, P<Local>> {\n-        let lo = self.prev_span;\n+        let lo = self.prev_token.span;\n         let pat = self.parse_top_pat(GateOr::Yes)?;\n \n         let (err, ty) = if self.eat(&token::Colon) {\n             // Save the state of the parser before parsing type normally, in case there is a `:`\n             // instead of an `=` typo.\n             let parser_snapshot_before_type = self.clone();\n-            let colon_sp = self.prev_span;\n+            let colon_sp = self.prev_token.span;\n             match self.parse_ty() {\n                 Ok(ty) => (None, Some(ty)),\n                 Err(mut err) => {\n@@ -235,7 +235,7 @@ impl<'a> Parser<'a> {\n                 return Err(err);\n             }\n         };\n-        let hi = if self.token == token::Semi { self.token.span } else { self.prev_span };\n+        let hi = if self.token == token::Semi { self.token.span } else { self.prev_token.span };\n         Ok(P(ast::Local { ty, pat, init, id: DUMMY_NODE_ID, span: lo.to(hi), attrs }))\n     }\n \n@@ -287,7 +287,7 @@ impl<'a> Parser<'a> {\n                 }\n                 let stmt_span = if self.eat(&token::Semi) {\n                     // Expand the span to include the semicolon.\n-                    stmt.span.with_hi(self.prev_span.hi())\n+                    stmt.span.with_hi(self.prev_token.span.hi())\n                 } else {\n                     stmt.span\n                 };\n@@ -350,7 +350,7 @@ impl<'a> Parser<'a> {\n                 continue;\n             };\n         }\n-        Ok(self.mk_block(stmts, s, lo.to(self.prev_span)))\n+        Ok(self.mk_block(stmts, s, lo.to(self.prev_token.span)))\n     }\n \n     /// Parses a statement, including the trailing semicolon.\n@@ -393,7 +393,7 @@ impl<'a> Parser<'a> {\n                     e.emit();\n                     self.recover_stmt();\n                     // Don't complain about type errors in body tail after parse error (#57383).\n-                    let sp = expr.span.to(self.prev_span);\n+                    let sp = expr.span.to(self.prev_token.span);\n                     stmt.kind = StmtKind::Expr(self.mk_expr_err(sp));\n                 }\n             }\n@@ -407,7 +407,7 @@ impl<'a> Parser<'a> {\n         if eat_semi && self.eat(&token::Semi) {\n             stmt = stmt.add_trailing_semicolon();\n         }\n-        stmt.span = stmt.span.to(self.prev_span);\n+        stmt.span = stmt.span.to(self.prev_token.span);\n         Ok(Some(stmt))\n     }\n "}, {"sha": "3d2b0c014ac4977ed29a3bdb8921cb5190e99c99", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -177,7 +177,7 @@ impl<'a> Parser<'a> {\n             return Err(err);\n         };\n \n-        let span = lo.to(self.prev_span);\n+        let span = lo.to(self.prev_token.span);\n         let ty = self.mk_ty(span, kind);\n \n         // Try to recover from use of `+` with incorrect priority.\n@@ -236,19 +236,19 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, TyKind> {\n         assert_ne!(self.token, token::Question);\n \n-        let poly_trait_ref = PolyTraitRef::new(generic_params, path, lo.to(self.prev_span));\n+        let poly_trait_ref = PolyTraitRef::new(generic_params, path, lo.to(self.prev_token.span));\n         let mut bounds = vec![GenericBound::Trait(poly_trait_ref, TraitBoundModifier::None)];\n         if parse_plus {\n             self.eat_plus(); // `+`, or `+=` gets split and `+` is discarded\n-            bounds.append(&mut self.parse_generic_bounds(Some(self.prev_span))?);\n+            bounds.append(&mut self.parse_generic_bounds(Some(self.prev_token.span))?);\n         }\n         Ok(TyKind::TraitObject(bounds, TraitObjectSyntax::None))\n     }\n \n     /// Parses a raw pointer type: `*[const | mut] $type`.\n     fn parse_ty_ptr(&mut self) -> PResult<'a, TyKind> {\n         let mutbl = self.parse_const_or_mut().unwrap_or_else(|| {\n-            let span = self.prev_span;\n+            let span = self.prev_token.span;\n             let msg = \"expected mut or const in raw pointer type\";\n             self.struct_span_err(span, msg)\n                 .span_label(span, msg)\n@@ -368,7 +368,7 @@ impl<'a> Parser<'a> {\n     fn error_illegal_c_varadic_ty(&self, lo: Span) {\n         struct_span_err!(\n             self.sess.span_diagnostic,\n-            lo.to(self.prev_span),\n+            lo.to(self.prev_token.span),\n             E0743,\n             \"C-variadic type `...` may not be nested inside another type\",\n         )\n@@ -431,7 +431,7 @@ impl<'a> Parser<'a> {\n         let mut err = self.struct_span_err(negative_bounds, \"negative bounds are not supported\");\n         err.span_label(last_span, \"negative bounds are not supported\");\n         if let Some(bound_list) = colon_span {\n-            let bound_list = bound_list.to(self.prev_span);\n+            let bound_list = bound_list.to(self.prev_token.span);\n             let mut new_bound_list = String::new();\n             if !bounds.is_empty() {\n                 let mut snippets = bounds.iter().map(|bound| self.span_to_snippet(bound.span()));\n@@ -456,7 +456,7 @@ impl<'a> Parser<'a> {\n     /// BOUND = TY_BOUND | LT_BOUND\n     /// ```\n     fn parse_generic_bound(&mut self) -> PResult<'a, Result<GenericBound, Span>> {\n-        let anchor_lo = self.prev_span;\n+        let anchor_lo = self.prev_token.span;\n         let lo = self.token.span;\n         let has_parens = self.eat(&token::OpenDelim(token::Paren));\n         let inner_lo = self.token.span;\n@@ -470,7 +470,7 @@ impl<'a> Parser<'a> {\n             self.parse_generic_ty_bound(lo, has_parens, modifiers)?\n         };\n \n-        Ok(if is_negative { Err(anchor_lo.to(self.prev_span)) } else { Ok(bound) })\n+        Ok(if is_negative { Err(anchor_lo.to(self.prev_token.span)) } else { Ok(bound) })\n     }\n \n     /// Parses a lifetime (\"outlives\") bound, e.g. `'a`, according to:\n@@ -510,15 +510,15 @@ impl<'a> Parser<'a> {\n \n     /// Recover on `('lifetime)` with `(` already eaten.\n     fn recover_paren_lifetime(&mut self, lo: Span, inner_lo: Span) -> PResult<'a, ()> {\n-        let inner_span = inner_lo.to(self.prev_span);\n+        let inner_span = inner_lo.to(self.prev_token.span);\n         self.expect(&token::CloseDelim(token::Paren))?;\n         let mut err = self.struct_span_err(\n-            lo.to(self.prev_span),\n+            lo.to(self.prev_token.span),\n             \"parenthesized lifetime bounds are not supported\",\n         );\n         if let Ok(snippet) = self.span_to_snippet(inner_span) {\n             err.span_suggestion_short(\n-                lo.to(self.prev_span),\n+                lo.to(self.prev_token.span),\n                 \"remove the parentheses\",\n                 snippet,\n                 Applicability::MachineApplicable,\n@@ -541,20 +541,20 @@ impl<'a> Parser<'a> {\n         }\n \n         // `? ...`\n-        let first_question = self.prev_span;\n+        let first_question = self.prev_token.span;\n         if !self.eat_keyword(kw::Const) {\n             return BoundModifiers { maybe: Some(first_question), maybe_const: None };\n         }\n \n         // `?const ...`\n-        let maybe_const = first_question.to(self.prev_span);\n+        let maybe_const = first_question.to(self.prev_token.span);\n         self.sess.gated_spans.gate(sym::const_trait_bound_opt_out, maybe_const);\n         if !self.eat(&token::Question) {\n             return BoundModifiers { maybe: None, maybe_const: Some(maybe_const) };\n         }\n \n         // `?const ? ...`\n-        let second_question = self.prev_span;\n+        let second_question = self.prev_token.span;\n         BoundModifiers { maybe: Some(second_question), maybe_const: Some(maybe_const) }\n     }\n \n@@ -578,7 +578,7 @@ impl<'a> Parser<'a> {\n         }\n \n         let modifier = modifiers.to_trait_bound_modifier();\n-        let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo.to(self.prev_span));\n+        let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo.to(self.prev_token.span));\n         Ok(GenericBound::Trait(poly_trait, modifier))\n     }\n "}, {"sha": "c68289adb10595474ff673e384b834ea153c7b06", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -816,7 +816,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     fn lookup_def_id(&self, ref_id: NodeId) -> Option<DefId> {\n         match self.get_path_res(ref_id) {\n             Res::PrimTy(_) | Res::SelfTy(..) | Res::Err => None,\n-            def => Some(def.def_id()),\n+            def => def.opt_def_id(),\n         }\n     }\n "}, {"sha": "39601ad76222c8f4d631f82a960dc238c9db8553", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -206,7 +206,7 @@ impl SourceMap {\n         &self,\n         stable_id: StableSourceFileId,\n     ) -> Option<Lrc<SourceFile>> {\n-        self.files.borrow().stable_id_to_source_file.get(&stable_id).map(|sf| sf.clone())\n+        self.files.borrow().stable_id_to_source_file.get(&stable_id).cloned()\n     }\n \n     fn allocate_address_space(&self, size: usize) -> Result<usize, OffsetOverflowError> {"}, {"sha": "2091902d7ce2128e207acb40cbde8cb23de0ccb5", "filename": "src/librustc_target/spec/i686_pc_windows_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_target%2Fspec%2Fi686_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_target%2Fspec%2Fi686_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fi686_pc_windows_gnu.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -5,6 +5,7 @@ pub fn target() -> TargetResult {\n     base.cpu = \"pentium4\".to_string();\n     base.max_atomic_width = Some(64);\n     base.eliminate_frame_pointer = false; // Required for backtraces\n+    base.linker = Some(\"i686-w64-mingw32-gcc\".to_string());\n \n     // Mark all dynamic libraries and executables as compatible with the larger 4GiB address\n     // space available to x86 Windows binaries on x86_64."}, {"sha": "3d3acc682dea434d93efbc5c2c8d14cbb45a2bd9", "filename": "src/librustc_target/spec/x86_64_pc_windows_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_target%2Fspec%2Fx86_64_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_target%2Fspec%2Fx86_64_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_pc_windows_gnu.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -5,6 +5,7 @@ pub fn target() -> TargetResult {\n     base.cpu = \"x86-64\".to_string();\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n     base.max_atomic_width = Some(64);\n+    base.linker = Some(\"x86_64-w64-mingw32-gcc\".to_string());\n \n     Ok(Target {\n         llvm_target: \"x86_64-pc-windows-gnu\".to_string(),"}, {"sha": "ff9fec004bbb508f79305e597ff151391819be1d", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -1312,6 +1312,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ty_span: Span,\n     ) {\n         if variant.recovered {\n+            self.set_tainted_by_errors();\n             return;\n         }\n         let mut err = self.type_error_struct_with_diag("}, {"sha": "cd96a3ad9f1270feddd1042959e749047206cca0", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -167,7 +167,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     .skip_binder()\n                                     .get(0)\n                                     .filter(|ty| ty.is_region_ptr() && !rcvr_ty.is_region_ptr())\n-                                    .map(|ty| *ty)\n+                                    .copied()\n                                     .unwrap_or(rcvr_ty),\n                             };\n                             print_disambiguation_help("}, {"sha": "4c214bd15e87e58a75ef0f0473f91212e05ad65a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -1315,7 +1315,7 @@ fn check_fn<'a, 'tcx>(\n         fcx.require_type_is_sized(yield_ty, span, traits::SizedYieldType);\n \n         // Resume type defaults to `()` if the generator has no argument.\n-        let resume_ty = fn_sig.inputs().get(0).map(|ty| *ty).unwrap_or_else(|| tcx.mk_unit());\n+        let resume_ty = fn_sig.inputs().get(0).copied().unwrap_or_else(|| tcx.mk_unit());\n \n         fcx.resume_yield_tys = Some((resume_ty, yield_ty));\n     }"}, {"sha": "2dad3d1d6d708ebd7df19d9def195df8c39767cf", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -2236,7 +2236,7 @@ fn from_target_feature(\n             };\n \n             // Only allow features whose feature gates have been enabled.\n-            let allowed = match feature_gate.as_ref().map(|s| *s) {\n+            let allowed = match feature_gate.as_ref().copied() {\n                 Some(sym::arm_target_feature) => rust_features.arm_target_feature,\n                 Some(sym::aarch64_target_feature) => rust_features.aarch64_target_feature,\n                 Some(sym::hexagon_target_feature) => rust_features.hexagon_target_feature,"}, {"sha": "f7b6e0fce5a2109b850e52c82a9cac3afa7adf28", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -25,7 +25,7 @@ fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Predicate\n             hir::ItemKind::Struct(..) | hir::ItemKind::Enum(..) | hir::ItemKind::Union(..) => {\n                 let crate_map = tcx.inferred_outlives_crate(LOCAL_CRATE);\n \n-                let predicates = crate_map.predicates.get(&item_def_id).map(|p| *p).unwrap_or(&[]);\n+                let predicates = crate_map.predicates.get(&item_def_id).copied().unwrap_or(&[]);\n \n                 if tcx.has_attr(item_def_id, sym::rustc_outlives) {\n                     let mut pred: Vec<String> = predicates"}, {"sha": "ddde11b38448bbf88e094ce3c53f600efc00f6ee", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -79,5 +79,5 @@ fn variances_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[ty::Variance] {\n     // Everything else must be inferred.\n \n     let crate_map = tcx.crate_variances(LOCAL_CRATE);\n-    crate_map.variances.get(&item_def_id).map(|p| *p).unwrap_or(&[])\n+    crate_map.variances.get(&item_def_id).copied().unwrap_or(&[])\n }"}, {"sha": "5c975c6272b97d99bcc2aa10c002dffbdc978ef2", "filename": "src/libtest/test_result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibtest%2Ftest_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Flibtest%2Ftest_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Ftest_result.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -40,7 +40,7 @@ pub fn calc_result<'a>(\n             let maybe_panic_str = err\n                 .downcast_ref::<String>()\n                 .map(|e| &**e)\n-                .or_else(|| err.downcast_ref::<&'static str>().map(|e| *e));\n+                .or_else(|| err.downcast_ref::<&'static str>().copied());\n \n             if maybe_panic_str.map(|e| e.contains(msg)).unwrap_or(false) {\n                 TestResult::TrOk"}, {"sha": "d3502c71f2d887b08e257c5bbac443415b28b183", "filename": "src/test/ui/attributes/register-attr-tool-import.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Ftest%2Fui%2Fattributes%2Fregister-attr-tool-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Ftest%2Fui%2Fattributes%2Fregister-attr-tool-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fregister-attr-tool-import.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -1,4 +1,6 @@\n // edition:2018\n+// compile-flags: -Zsave-analysis\n+// ~^ Also regression test for #69588\n \n #![feature(register_attr)]\n #![feature(register_tool)]"}, {"sha": "90b7e169a2fb7907c5c9a7f8eef8aa0cfd30c6d6", "filename": "src/test/ui/attributes/register-attr-tool-import.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Ftest%2Fui%2Fattributes%2Fregister-attr-tool-import.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Ftest%2Fui%2Fattributes%2Fregister-attr-tool-import.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fregister-attr-tool-import.stderr?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -1,35 +1,35 @@\n error: cannot use an explicitly registered attribute through an import\n-  --> $DIR/register-attr-tool-import.rs:12:3\n+  --> $DIR/register-attr-tool-import.rs:14:3\n    |\n LL | #[renamed_attr]\n    |   ^^^^^^^^^^^^\n    |\n note: the explicitly registered attribute imported here\n-  --> $DIR/register-attr-tool-import.rs:9:5\n+  --> $DIR/register-attr-tool-import.rs:11:5\n    |\n LL | use attr as renamed_attr; // OK\n    |     ^^^^^^^^^^^^^^^^^^^^\n \n error: cannot use a tool module through an import\n-  --> $DIR/register-attr-tool-import.rs:13:3\n+  --> $DIR/register-attr-tool-import.rs:15:3\n    |\n LL | #[renamed_tool::attr]\n    |   ^^^^^^^^^^^^\n    |\n note: the tool module imported here\n-  --> $DIR/register-attr-tool-import.rs:10:5\n+  --> $DIR/register-attr-tool-import.rs:12:5\n    |\n LL | use tool as renamed_tool; // OK\n    |     ^^^^^^^^^^^^^^^^^^^^\n \n error: cannot use a tool module through an import\n-  --> $DIR/register-attr-tool-import.rs:13:3\n+  --> $DIR/register-attr-tool-import.rs:15:3\n    |\n LL | #[renamed_tool::attr]\n    |   ^^^^^^^^^^^^\n    |\n note: the tool module imported here\n-  --> $DIR/register-attr-tool-import.rs:10:5\n+  --> $DIR/register-attr-tool-import.rs:12:5\n    |\n LL | use tool as renamed_tool; // OK\n    |     ^^^^^^^^^^^^^^^^^^^^"}, {"sha": "571692a5374da798c5f31bf4883d2ed303e95cd0", "filename": "src/test/ui/typeck/issue-69378-ice-on-invalid-type-node-after-recovery.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Ftest%2Fui%2Ftypeck%2Fissue-69378-ice-on-invalid-type-node-after-recovery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Ftest%2Fui%2Ftypeck%2Fissue-69378-ice-on-invalid-type-node-after-recovery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-69378-ice-on-invalid-type-node-after-recovery.rs?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -0,0 +1,9 @@\n+// Regression test for #69378: no type for node after struct parse recovery\n+\n+struct Foo { 0: u8 } //~ ERROR expected identifier\n+\n+fn test(f: Foo) {\n+    Foo{foo: 4, ..f};\n+}\n+\n+fn main() {}"}, {"sha": "6bc9c8498c9d12a5e4d883b52aa1592fff07f90c", "filename": "src/test/ui/typeck/issue-69378-ice-on-invalid-type-node-after-recovery.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Ftest%2Fui%2Ftypeck%2Fissue-69378-ice-on-invalid-type-node-after-recovery.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b2983af1a85d857ae3a9345ac93ba0564ab7a73/src%2Ftest%2Fui%2Ftypeck%2Fissue-69378-ice-on-invalid-type-node-after-recovery.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-69378-ice-on-invalid-type-node-after-recovery.stderr?ref=6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "patch": "@@ -0,0 +1,8 @@\n+error: expected identifier, found `0`\n+  --> $DIR/issue-69378-ice-on-invalid-type-node-after-recovery.rs:3:14\n+   |\n+LL | struct Foo { 0: u8 }\n+   |              ^ expected identifier\n+\n+error: aborting due to previous error\n+"}]}