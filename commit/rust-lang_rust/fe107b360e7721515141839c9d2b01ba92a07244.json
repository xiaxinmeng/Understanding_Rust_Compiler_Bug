{"sha": "fe107b360e7721515141839c9d2b01ba92a07244", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlMTA3YjM2MGU3NzIxNTE1MTQxODM5YzlkMmIwMWJhOTJhMDcyNDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-03T21:46:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-03T21:46:21Z"}, "message": "Auto merge of #25959 - pnkfelix:fsk-hack-move-val-init, r=nikomatsakis\n\nHack the move_val_init intrinsic to trans directly into the destination address.\r\n\r\nThis is to remove an intermediate (and unnecessary) alloca on the stack that one otherwise suffers when using this intrinsic.\r\n\r\nThis is part of the `box` protocol work; in particular, this is meant to address the `ptr::write` codegen issues alluded to at this comment: \r\n\r\n  https://github.com/rust-lang/rust/pull/22086#issuecomment-96168675\r\n\r\ncc #22181", "tree": {"sha": "5ef3fc4422f782e0f967e28ac23a907e98da7af0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ef3fc4422f782e0f967e28ac23a907e98da7af0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe107b360e7721515141839c9d2b01ba92a07244", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe107b360e7721515141839c9d2b01ba92a07244", "html_url": "https://github.com/rust-lang/rust/commit/fe107b360e7721515141839c9d2b01ba92a07244", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe107b360e7721515141839c9d2b01ba92a07244/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b70f49b86fa4d8780f46e869880e84e1c24c2f19", "url": "https://api.github.com/repos/rust-lang/rust/commits/b70f49b86fa4d8780f46e869880e84e1c24c2f19", "html_url": "https://github.com/rust-lang/rust/commit/b70f49b86fa4d8780f46e869880e84e1c24c2f19"}, {"sha": "0b748002ecfc9848fed131b6ee10ae434f3590a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b748002ecfc9848fed131b6ee10ae434f3590a7", "html_url": "https://github.com/rust-lang/rust/commit/0b748002ecfc9848fed131b6ee10ae434f3590a7"}], "stats": {"total": 252, "additions": 236, "deletions": 16}, "files": [{"sha": "4a7268f5dfe490e1f2e99e025a59494066b8da7c", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 42, "deletions": 16, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fe107b360e7721515141839c9d2b01ba92a07244/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe107b360e7721515141839c9d2b01ba92a07244/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=fe107b360e7721515141839c9d2b01ba92a07244", "patch": "@@ -265,6 +265,48 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n+    // For `move_val_init` we can evaluate the destination address\n+    // (the first argument) and then trans the source value (the\n+    // second argument) directly into the resulting destination\n+    // address.\n+    if &name[..] == \"move_val_init\" {\n+        if let callee::ArgExprs(ref exprs) = args {\n+            let (dest_expr, source_expr) = if exprs.len() != 2 {\n+                ccx.sess().bug(\"expected two exprs as arguments for `move_val_init` intrinsic\");\n+            } else {\n+                (&exprs[0], &exprs[1])\n+            };\n+            let arg_tys = ty::erase_late_bound_regions(bcx.tcx(), &ty::ty_fn_args(callee_ty));\n+\n+            // evaluate destination address\n+            let lldest_addr = unpack_result!(bcx, {\n+                let dest_datum = unpack_datum!(bcx, expr::trans(bcx, dest_expr));\n+                callee::trans_arg_datum(bcx,\n+                                        arg_tys[0],\n+                                        dest_datum,\n+                                        cleanup::CustomScope(cleanup_scope),\n+                                        callee::DontAutorefArg)\n+            });\n+\n+            // `expr::trans_into(bcx, expr, dest)` is equiv to\n+            //\n+            //    `trans(bcx, expr).store_to_dest(dest)`,\n+            //\n+            // which for `dest == expr::SaveIn(addr)`, is equivalent to:\n+            //\n+            //    `trans(bcx, expr).store_to(bcx, addr)`.\n+            let lldest = expr::Dest::SaveIn(lldest_addr);\n+            bcx = expr::trans_into(bcx, source_expr, lldest);\n+\n+            let llresult = C_nil(ccx);\n+            fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n+\n+            return Result::new(bcx, llresult);\n+        } else {\n+            ccx.sess().bug(\"expected two exprs as arguments for `move_val_init` intrinsic\");\n+        }\n+    }\n+\n     // Push the arguments.\n     let mut llargs = Vec::new();\n     bcx = callee::trans_args(bcx,\n@@ -356,22 +398,6 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty))\n         }\n-        (_, \"move_val_init\") => {\n-            // Create a datum reflecting the value being moved.\n-            // Use `appropriate_mode` so that the datum is by ref\n-            // if the value is non-immediate. Note that, with\n-            // intrinsics, there are no argument cleanups to\n-            // concern ourselves with, so we can use an rvalue datum.\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n-            let mode = appropriate_rvalue_mode(ccx, tp_ty);\n-            let src = Datum {\n-                val: llargs[1],\n-                ty: tp_ty,\n-                kind: Rvalue::new(mode)\n-            };\n-            bcx = src.store_to(bcx, llargs[0]);\n-            C_nil(ccx)\n-        }\n         (_, \"drop_in_place\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             glue::drop_ty(bcx, llargs[0], tp_ty, call_debug_location);"}, {"sha": "bc7a654f867ea5eb06014aa71becb6914f57cd6d", "filename": "src/test/run-pass/intrinsic-move-val-cleanups.rs", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/fe107b360e7721515141839c9d2b01ba92a07244/src%2Ftest%2Frun-pass%2Fintrinsic-move-val-cleanups.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe107b360e7721515141839c9d2b01ba92a07244/src%2Ftest%2Frun-pass%2Fintrinsic-move-val-cleanups.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-move-val-cleanups.rs?ref=fe107b360e7721515141839c9d2b01ba92a07244", "patch": "@@ -0,0 +1,194 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test is checking that the move_val_init intrinsic is\n+// respecting cleanups for both of its argument expressions.\n+//\n+// In other words, if either DEST or SOURCE in\n+//\n+//   `intrinsics::move_val_init(DEST, SOURCE)\n+//\n+// introduce temporaries that require cleanup, and SOURCE panics, then\n+// make sure the cleanups still occur.\n+\n+#![feature(core, std_misc)]\n+\n+use std::cell::RefCell;\n+use std::intrinsics;\n+use std::sync::{Arc, LockResult, Mutex, MutexGuard};\n+use std::thread;\n+\n+type LogEntry = (&'static str, i32);\n+type Guarded = RefCell<Vec<LogEntry>>;\n+#[derive(Clone)]\n+struct Log(Arc<Mutex<Guarded>>);\n+struct Acquired<'a>(MutexGuard<'a, Guarded>);\n+type LogState = (MutexWas, &'static [LogEntry]);\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum MutexWas { Poisoned, NotPoisoned }\n+\n+impl Log {\n+    fn lock(&self) -> LockResult<MutexGuard<RefCell<Vec<LogEntry>>>> { self.0.lock() }\n+    fn acquire(&self) -> Acquired { Acquired(self.0.lock().unwrap()) }\n+}\n+\n+impl<'a> Acquired<'a> {\n+    fn log(&self, s: &'static str, i: i32) { self.0.borrow_mut().push((s, i)); }\n+}\n+\n+const TEST1_EXPECT: LogState = (MutexWas::NotPoisoned,\n+                                &[(\"double-check non-poisoning path\", 1)\n+                                  ]);\n+\n+fn test1(log: Log) {\n+    {\n+        let acq = log.acquire();\n+        acq.log(\"double-check non-poisoning path\", 1);\n+    }\n+    panic!(\"every test ends in a panic\");\n+}\n+\n+const TEST2_EXPECT: LogState = (MutexWas::Poisoned,\n+                                &[(\"double-check poisoning path\", 1),\n+                                  (\"and multiple log entries\", 2),\n+                                  ]);\n+fn test2(log: Log) {\n+    let acq = log.acquire();\n+    acq.log(\"double-check poisoning path\", 1);\n+    acq.log(\"and multiple log entries\", 2);\n+    panic!(\"every test ends in a panic\");\n+}\n+\n+struct LogOnDrop<'a>(&'a Acquired<'a>, &'static str, i32);\n+impl<'a> Drop for LogOnDrop<'a> {\n+    fn drop(&mut self) {\n+        self.0.log(self.1, self.2);\n+    }\n+}\n+\n+const TEST3_EXPECT: LogState = (MutexWas::Poisoned,\n+                                &[(\"double-check destructors can log\", 1),\n+                                  (\"drop d2\", 2),\n+                                  (\"drop d1\", 3),\n+                                  ]);\n+fn test3(log: Log) {\n+    let acq = log.acquire();\n+    acq.log(\"double-check destructors can log\", 1);\n+    let _d1 = LogOnDrop(&acq, \"drop d1\", 3);\n+    let _d2 = LogOnDrop(&acq, \"drop d2\", 2);\n+    panic!(\"every test ends in a panic\");\n+}\n+\n+// The *real* tests of panic-handling for move_val_init intrinsic\n+// start here.\n+\n+const TEST4_EXPECT: LogState = (MutexWas::Poisoned,\n+                                &[(\"neither arg panics\", 1),\n+                                  (\"drop temp LOD\", 2),\n+                                  (\"drop temp LOD\", 3),\n+                                  (\"drop dest_b\", 4),\n+                                  (\"drop dest_a\", 5),\n+                                  ]);\n+fn test4(log: Log) {\n+    let acq = log.acquire();\n+    acq.log(\"neither arg panics\", 1);\n+    let mut dest_a = LogOnDrop(&acq, \"a will be overwritten, not dropped\", 0);\n+    let mut dest_b = LogOnDrop(&acq, \"b will be overwritten, not dropped\", 0);\n+    unsafe {\n+        intrinsics::move_val_init({ LogOnDrop(&acq, \"drop temp LOD\", 2); &mut dest_a },\n+                                  LogOnDrop(&acq, \"drop dest_a\", 5));\n+        intrinsics::move_val_init(&mut dest_b, { LogOnDrop(&acq, \"drop temp LOD\", 3);\n+                                                 LogOnDrop(&acq, \"drop dest_b\", 4) });\n+    }\n+    panic!(\"every test ends in a panic\");\n+}\n+\n+\n+// Check that move_val_init(PANIC, SOURCE_EXPR) never evaluates SOURCE_EXPR\n+const TEST5_EXPECT: LogState = (MutexWas::Poisoned,\n+                                &[(\"first arg panics\", 1),\n+                                  (\"drop orig dest_a\", 2),\n+                                  ]);\n+fn test5(log: Log) {\n+    let acq = log.acquire();\n+    acq.log(\"first arg panics\", 1);\n+    let mut _dest_a = LogOnDrop(&acq, \"drop orig dest_a\", 2);\n+    unsafe {\n+        intrinsics::move_val_init({ panic!(\"every test ends in a panic\") },\n+                                  LogOnDrop(&acq, \"we never get here\", 0));\n+    }\n+}\n+\n+// Check that move_val_init(DEST_EXPR, PANIC) cleans up temps from DEST_EXPR.\n+const TEST6_EXPECT: LogState = (MutexWas::Poisoned,\n+                                &[(\"second arg panics\", 1),\n+                                  (\"drop temp LOD\", 2),\n+                                  (\"drop orig dest_a\", 3),\n+                                  ]);\n+fn test6(log: Log) {\n+    let acq = log.acquire();\n+    acq.log(\"second arg panics\", 1);\n+    let mut dest_a = LogOnDrop(&acq, \"drop orig dest_a\", 3);\n+    unsafe {\n+        intrinsics::move_val_init({ LogOnDrop(&acq, \"drop temp LOD\", 2); &mut dest_a },\n+                                  { panic!(\"every test ends in a panic\"); });\n+    }\n+}\n+\n+// Check that move_val_init(DEST_EXPR, COMPLEX_PANIC) cleans up temps from COMPLEX_PANIC.\n+const TEST7_EXPECT: LogState = (MutexWas::Poisoned,\n+                                &[(\"second arg panics\", 1),\n+                                  (\"drop temp LOD\", 2),\n+                                  (\"drop temp LOD\", 3),\n+                                  (\"drop orig dest_a\", 4),\n+                                  ]);\n+fn test7(log: Log) {\n+    let acq = log.acquire();\n+    acq.log(\"second arg panics\", 1);\n+    let mut dest_a = LogOnDrop(&acq, \"drop orig dest_a\", 4);\n+    unsafe {\n+        intrinsics::move_val_init({ LogOnDrop(&acq, \"drop temp LOD\", 2); &mut dest_a },\n+                                  { LogOnDrop(&acq, \"drop temp LOD\", 3);\n+                                    panic!(\"every test ends in a panic\"); });\n+    }\n+}\n+\n+const TEST_SUITE: &'static [(&'static str, fn (Log), LogState)] =\n+    &[(\"test1\", test1, TEST1_EXPECT),\n+      (\"test2\", test2, TEST2_EXPECT),\n+      (\"test3\", test3, TEST3_EXPECT),\n+      (\"test4\", test4, TEST4_EXPECT),\n+      (\"test5\", test5, TEST5_EXPECT),\n+      (\"test6\", test6, TEST6_EXPECT),\n+      (\"test7\", test7, TEST7_EXPECT),\n+      ];\n+\n+fn main() {\n+    for &(name, test, expect) in TEST_SUITE {\n+        let log = Log(Arc::new(Mutex::new(RefCell::new(Vec::new()))));\n+        let ret = { let log = log.clone(); thread::spawn(move || test(log)).join() };\n+        assert!(ret.is_err(), \"{} must end with panic\", name);\n+        {\n+            let l = log.lock();\n+            match l {\n+                Ok(acq) => {\n+                    assert_eq!((MutexWas::NotPoisoned, &acq.borrow()[..]), expect);\n+                    println!(\"{} (unpoisoned) log: {:?}\", name, *acq);\n+                }\n+                Err(e) => {\n+                    let acq = e.into_inner();\n+                    assert_eq!((MutexWas::Poisoned, &acq.borrow()[..]), expect);\n+                    println!(\"{} (poisoned) log: {:?}\", name, *acq);\n+                }\n+            }\n+        }\n+    }\n+}"}]}