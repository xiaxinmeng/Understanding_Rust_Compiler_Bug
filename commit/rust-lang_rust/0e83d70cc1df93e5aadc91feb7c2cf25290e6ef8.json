{"sha": "0e83d70cc1df93e5aadc91feb7c2cf25290e6ef8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlODNkNzBjYzFkZjkzZTVhYWRjOTFmZWI3YzJjZjI1MjkwZTZlZjg=", "commit": {"author": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2012-12-22T01:42:15Z"}, "committer": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2012-12-22T06:14:26Z"}, "message": "Convert std::bigint to explicit self.", "tree": {"sha": "b30f29f74ab78de92dcedb047316c32f2a6ee144", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b30f29f74ab78de92dcedb047316c32f2a6ee144"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e83d70cc1df93e5aadc91feb7c2cf25290e6ef8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e83d70cc1df93e5aadc91feb7c2cf25290e6ef8", "html_url": "https://github.com/rust-lang/rust/commit/0e83d70cc1df93e5aadc91feb7c2cf25290e6ef8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e83d70cc1df93e5aadc91feb7c2cf25290e6ef8/comments", "author": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6a8778ef71684e141696f4109334bb7018742c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6a8778ef71684e141696f4109334bb7018742c8", "html_url": "https://github.com/rust-lang/rust/commit/c6a8778ef71684e141696f4109334bb7018742c8"}], "stats": {"total": 97, "additions": 52, "deletions": 45}, "files": [{"sha": "4d4bfb6bd7babaf70ced48c0508c2f1cd77f75a3", "filename": "src/libstd/bigint.rs", "status": "modified", "additions": 52, "deletions": 45, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/0e83d70cc1df93e5aadc91feb7c2cf25290e6ef8/src%2Flibstd%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e83d70cc1df93e5aadc91feb7c2cf25290e6ef8/src%2Flibstd%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbigint.rs?ref=0e83d70cc1df93e5aadc91feb7c2cf25290e6ef8", "patch": "@@ -275,11 +275,10 @@ pub impl BigUint {\n \n     static pub pure fn zero() -> BigUint { BigUint::from_at_vec(@[]) }\n     static pub pure fn one() -> BigUint { BigUint::from_at_vec(@[1]) }\n-\n-    pure fn abs() -> BigUint { self }\n+    pure fn abs(&self) -> BigUint { *self }\n \n     /// Compare two BigUint value.\n-    pure fn cmp(other: &BigUint) -> int {\n+    pure fn cmp(&self, other: &BigUint) -> int {\n         let s_len = self.data.len(), o_len = other.data.len();\n         if s_len < o_len { return -1; }\n         if s_len > o_len { return  1;  }\n@@ -294,13 +293,13 @@ pub impl BigUint {\n         return 0;\n     }\n \n-    pure fn divmod(other: &BigUint) -> (BigUint, BigUint) {\n+    pure fn divmod(&self, other: &BigUint) -> (BigUint, BigUint) {\n         if other.is_zero() { fail }\n         if self.is_zero() { return (BigUint::zero(), BigUint::zero()); }\n-        if *other == BigUint::one() { return (self, BigUint::zero()); }\n+        if *other == BigUint::one() { return (*self, BigUint::zero()); }\n \n         match self.cmp(other) {\n-            s if s < 0 => return (BigUint::zero(), self),\n+            s if s < 0 => return (BigUint::zero(), *self),\n             0          => return (BigUint::one(), BigUint::zero()),\n             _          => {} // Do nothing\n         }\n@@ -363,20 +362,24 @@ pub impl BigUint {\n         }\n     }\n \n-    pure fn quot(other: &BigUint) -> BigUint { self.quotrem(other).first() }\n-    pure fn rem(other: &BigUint) -> BigUint { self.quotrem(other).second() }\n-    pure fn quotrem(other: &BigUint) -> (BigUint, BigUint) {\n+    pure fn quot(&self, other: &BigUint) -> BigUint {\n+        self.quotrem(other).first()\n+    }\n+    pure fn rem(&self, other: &BigUint) -> BigUint {\n+        self.quotrem(other).second()\n+    }\n+    pure fn quotrem(&self, other: &BigUint) -> (BigUint, BigUint) {\n         self.divmod(other)\n     }\n \n-    pure fn is_zero() -> bool { self.data.is_empty() }\n-    pure fn is_not_zero() -> bool { self.data.is_not_empty() }\n-    pure fn is_positive() -> bool { self.is_not_zero() }\n-    pure fn is_negative() -> bool { false }\n-    pure fn is_nonpositive() -> bool { self.is_zero() }\n-    pure fn is_nonnegative() -> bool { true }\n+    pure fn is_zero(&self) -> bool { self.data.is_empty() }\n+    pure fn is_not_zero(&self) -> bool { self.data.is_not_empty() }\n+    pure fn is_positive(&self) -> bool { self.is_not_zero() }\n+    pure fn is_negative(&self) -> bool { false }\n+    pure fn is_nonpositive(&self) -> bool { self.is_zero() }\n+    pure fn is_nonnegative(&self) -> bool { true }\n \n-    pure fn to_uint() -> uint {\n+    pure fn to_uint(&self) -> uint {\n         match self.data.len() {\n             0 => 0,\n             1 => self.data[0] as uint,\n@@ -385,14 +388,14 @@ pub impl BigUint {\n         }\n     }\n \n-    pure fn to_str_radix(radix: uint) -> ~str {\n+    pure fn to_str_radix(&self, radix: uint) -> ~str {\n         assert 1 < radix && radix <= 16;\n \n-        pure fn convert_base(n: BigUint, base: uint) -> @[BigDigit] {\n+        pure fn convert_base(n: &BigUint, base: uint) -> @[BigDigit] {\n             if base == BigDigit::base { return n.data; }\n             let divider    = BigUint::from_uint(base);\n             let mut result = @[];\n-            let mut r      = n;\n+            let mut r      = *n;\n             while r > divider {\n                 let (d, r0) = r.divmod(&divider);\n                 result += [r0.to_uint() as BigDigit];\n@@ -416,14 +419,14 @@ pub impl BigUint {\n         return fill_concat(convert_base(self, base), radix, max_len);\n     }\n \n-    priv pure fn shl_unit(n_unit: uint) -> BigUint {\n-        if n_unit == 0 || self.is_zero() { return self; }\n+    priv pure fn shl_unit(&self, n_unit: uint) -> BigUint {\n+        if n_unit == 0 || self.is_zero() { return *self; }\n \n         return BigUint::from_at_vec(at_vec::from_elem(n_unit, 0) + self.data);\n     }\n \n-    priv pure fn shl_bits(n_bits: uint) -> BigUint {\n-        if n_bits == 0 || self.is_zero() { return self; }\n+    priv pure fn shl_bits(&self, n_bits: uint) -> BigUint {\n+        if n_bits == 0 || self.is_zero() { return *self; }\n \n         let mut carry = 0;\n         let shifted = do at_vec::map(self.data) |elem| {\n@@ -437,16 +440,16 @@ pub impl BigUint {\n         return BigUint::from_at_vec(shifted + [carry]);\n     }\n \n-    priv pure fn shr_unit(n_unit: uint) -> BigUint {\n-        if n_unit == 0 { return self; }\n+    priv pure fn shr_unit(&self, n_unit: uint) -> BigUint {\n+        if n_unit == 0 { return *self; }\n         if self.data.len() < n_unit { return BigUint::zero(); }\n         return BigUint::from_slice(\n             vec::view(self.data, n_unit, self.data.len())\n         );\n     }\n \n-    priv pure fn shr_bits(n_bits: uint) -> BigUint {\n-        if n_bits == 0 || self.data.is_empty() { return self; }\n+    priv pure fn shr_bits(&self, n_bits: uint) -> BigUint {\n+        if n_bits == 0 || self.data.is_empty() { return *self; }\n \n         let mut borrow = 0;\n         let mut shifted = @[];\n@@ -499,17 +502,17 @@ impl Sign : Ord {\n \n pub impl Sign {\n     /// Compare two Sign.\n-    pure fn cmp(other: &Sign) -> int {\n-        match (self, *other) {\n+    pure fn cmp(&self, other: &Sign) -> int {\n+        match (*self, *other) {\n           (Minus, Minus) | (Zero,  Zero) | (Plus, Plus) =>  0,\n           (Minus, Zero)  | (Minus, Plus) | (Zero, Plus) => -1,\n           _                                             =>  1\n         }\n     }\n \n     /// Negate Sign value.\n-    pure fn neg() -> Sign {\n-        match(self) {\n+    pure fn neg(&self) -> Sign {\n+        match *self {\n           Minus => Plus,\n           Zero  => Zero,\n           Plus  => Minus\n@@ -682,9 +685,9 @@ pub impl BigInt {\n         BigInt::from_biguint(Plus, BigUint::one())\n     }\n \n-    pure fn abs() -> BigInt { BigInt::from_biguint(Plus, self.data) }\n+    pure fn abs(&self) -> BigInt { BigInt::from_biguint(Plus, self.data) }\n \n-    pure fn cmp(other: &BigInt) -> int {\n+    pure fn cmp(&self, other: &BigInt) -> int {\n         let ss = self.sign, os = other.sign;\n         if ss < os { return -1; }\n         if ss > os { return  1; }\n@@ -697,7 +700,7 @@ pub impl BigInt {\n         }\n     }\n \n-    pure fn divmod(other: &BigInt) -> (BigInt, BigInt) {\n+    pure fn divmod(&self, other: &BigInt) -> (BigInt, BigInt) {\n         // m.sign == other.sign\n         let (d_ui, m_ui) = self.data.divmod(&other.data);\n         let d = BigInt::from_biguint(Plus, d_ui),\n@@ -719,10 +722,14 @@ pub impl BigInt {\n         }\n     }\n \n-    pure fn quot(other: &BigInt) -> BigInt { self.quotrem(other).first() }\n-    pure fn rem(other: &BigInt) -> BigInt { self.quotrem(other).second() }\n+    pure fn quot(&self, other: &BigInt) -> BigInt {\n+        self.quotrem(other).first()\n+    }\n+    pure fn rem(&self, other: &BigInt) -> BigInt {\n+        self.quotrem(other).second()\n+    }\n \n-    pure fn quotrem(other: &BigInt) -> (BigInt, BigInt) {\n+    pure fn quotrem(&self, other: &BigInt) -> (BigInt, BigInt) {\n         // r.sign == self.sign\n         let (q_ui, r_ui) = self.data.quotrem(&other.data);\n         let q = BigInt::from_biguint(Plus, q_ui);\n@@ -736,22 +743,22 @@ pub impl BigInt {\n         }\n     }\n \n-    pure fn is_zero() -> bool { self.sign == Zero }\n-    pure fn is_not_zero() -> bool { self.sign != Zero }\n-    pure fn is_positive() -> bool { self.sign == Plus }\n-    pure fn is_negative() -> bool { self.sign == Minus }\n-    pure fn is_nonpositive() -> bool { self.sign != Plus }\n-    pure fn is_nonnegative() -> bool { self.sign != Minus }\n+    pure fn is_zero(&self) -> bool { self.sign == Zero }\n+    pure fn is_not_zero(&self) -> bool { self.sign != Zero }\n+    pure fn is_positive(&self) -> bool { self.sign == Plus }\n+    pure fn is_negative(&self) -> bool { self.sign == Minus }\n+    pure fn is_nonpositive(&self) -> bool { self.sign != Plus }\n+    pure fn is_nonnegative(&self) -> bool { self.sign != Minus }\n \n-    pure fn to_uint() -> uint {\n+    pure fn to_uint(&self) -> uint {\n         match self.sign {\n             Plus  => self.data.to_uint(),\n             Zero  => 0,\n             Minus => 0\n         }\n     }\n \n-    pure fn to_str_radix(radix: uint) -> ~str {\n+    pure fn to_str_radix(&self, radix: uint) -> ~str {\n         match self.sign {\n             Plus  => self.data.to_str_radix(radix),\n             Zero  => ~\"0\","}]}