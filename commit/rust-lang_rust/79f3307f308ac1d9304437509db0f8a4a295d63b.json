{"sha": "79f3307f308ac1d9304437509db0f8a4a295d63b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZjMzMDdmMzA4YWMxZDkzMDQ0Mzc1MDlkYjBmOGE0YTI5NWQ2M2I=", "commit": {"author": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-04-05T17:09:31Z"}, "committer": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-04-05T17:09:31Z"}, "message": "Update comments, rearrange code", "tree": {"sha": "378cf462125b1f829aea6d26d55de7411eb63d14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/378cf462125b1f829aea6d26d55de7411eb63d14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79f3307f308ac1d9304437509db0f8a4a295d63b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79f3307f308ac1d9304437509db0f8a4a295d63b", "html_url": "https://github.com/rust-lang/rust/commit/79f3307f308ac1d9304437509db0f8a4a295d63b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79f3307f308ac1d9304437509db0f8a4a295d63b/comments", "author": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "committer": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac8c98da8e806a7e18dcc0cee8201085e5c7abb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac8c98da8e806a7e18dcc0cee8201085e5c7abb6", "html_url": "https://github.com/rust-lang/rust/commit/ac8c98da8e806a7e18dcc0cee8201085e5c7abb6"}], "stats": {"total": 274, "additions": 131, "deletions": 143}, "files": [{"sha": "bfb832085e0bf37dbb8062fada639ce8798338d0", "filename": "src/machine.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79f3307f308ac1d9304437509db0f8a4a295d63b/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f3307f308ac1d9304437509db0f8a4a295d63b/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=79f3307f308ac1d9304437509db0f8a4a295d63b", "patch": "@@ -217,6 +217,8 @@ pub struct Evaluator<'tcx> {\n     pub(crate) time_anchor: Instant,\n \n     /// Cached `TyLayout`s for primitive data types that are commonly used inside Miri.\n+    /// FIXME: Search through the rest of the codebase for more layout_of() calls that\n+    /// could be cached here.\n     primitive_layouts: PrimitiveLayouts<'tcx>,\n }\n "}, {"sha": "3ececb9c20bbdb684696ce88a503dd4f9895afb8", "filename": "src/shims/foreign_items/posix.rs", "status": "modified", "additions": 38, "deletions": 50, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/79f3307f308ac1d9304437509db0f8a4a295d63b/src%2Fshims%2Fforeign_items%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f3307f308ac1d9304437509db0f8a4a295d63b/src%2Fshims%2Fforeign_items%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix.rs?ref=79f3307f308ac1d9304437509db0f8a4a295d63b", "patch": "@@ -233,113 +233,101 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n \n-            // Better error for attempts to create a thread\n-            \"pthread_create\" => {\n-                throw_unsup_format!(\"Miri does not support threading\");\n-            }\n-\n-            // Miscellaneous\n-            \"isatty\" => {\n-                let _fd = this.read_scalar(args[0])?.to_i32()?;\n-                // \"returns 1 if fd is an open file descriptor referring to a terminal; otherwise 0 is returned, and errno is set to indicate the error\"\n-                // FIXME: we just say nothing is a terminal.\n-                let enotty = this.eval_libc(\"ENOTTY\")?;\n-                this.set_last_error(enotty)?;\n-                this.write_null(dest)?;\n-            }\n-            \"pthread_atfork\" => {\n-                let _prepare = this.read_scalar(args[0])?.not_undef()?;\n-                let _parent = this.read_scalar(args[1])?.not_undef()?;\n-                let _child = this.read_scalar(args[1])?.not_undef()?;\n-                // We do not support forking, so there is nothing to do here.\n-                this.write_null(dest)?;\n-            }\n-\n-            // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n-            // These shims are enabled only when the caller is in the standard library.\n-            | \"pthread_attr_init\"\n-            | \"pthread_attr_destroy\"\n-            | \"pthread_self\"\n-            | \"pthread_attr_setstacksize\"\n-            | \"pthread_condattr_init\"\n-            | \"pthread_condattr_setclock\"\n-            | \"pthread_cond_init\"\n-            | \"pthread_condattr_destroy\"\n-            | \"pthread_cond_destroy\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\")\n-            => {\n-                this.write_null(dest)?;\n-            }\n-\n+            // Synchronization primitives\n             \"pthread_mutexattr_init\" => {\n                 let result = this.pthread_mutexattr_init(args[0])?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n-\n             \"pthread_mutexattr_settype\" => {\n                 let result = this.pthread_mutexattr_settype(args[0], args[1])?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n-\n             \"pthread_mutexattr_destroy\" => {\n                 let result = this.pthread_mutexattr_destroy(args[0])?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n-\n             \"pthread_mutex_init\" => {\n                 let result = this.pthread_mutex_init(args[0], args[1])?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n-\n             \"pthread_mutex_lock\" => {\n                 let result = this.pthread_mutex_lock(args[0])?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n-\n             \"pthread_mutex_trylock\" => {\n                 let result = this.pthread_mutex_trylock(args[0])?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n-\n             \"pthread_mutex_unlock\" => {\n                 let result = this.pthread_mutex_unlock(args[0])?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n-\n             \"pthread_mutex_destroy\" => {\n                 let result = this.pthread_mutex_destroy(args[0])?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n-\n             \"pthread_rwlock_rdlock\" => {\n                 let result = this.pthread_rwlock_rdlock(args[0])?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n-\n             \"pthread_rwlock_tryrdlock\" => {\n                 let result = this.pthread_rwlock_tryrdlock(args[0])?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n-\n             \"pthread_rwlock_wrlock\" => {\n                 let result = this.pthread_rwlock_wrlock(args[0])?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n-\n             \"pthread_rwlock_trywrlock\" => {\n                 let result = this.pthread_rwlock_trywrlock(args[0])?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n-\n             \"pthread_rwlock_unlock\" => {\n                 let result = this.pthread_rwlock_unlock(args[0])?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n-\n             \"pthread_rwlock_destroy\" => {\n                 let result = this.pthread_rwlock_destroy(args[0])?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n+            // Better error for attempts to create a thread\n+            \"pthread_create\" => {\n+                throw_unsup_format!(\"Miri does not support threading\");\n+            }\n+\n+            // Miscellaneous\n+            \"isatty\" => {\n+                let _fd = this.read_scalar(args[0])?.to_i32()?;\n+                // \"returns 1 if fd is an open file descriptor referring to a terminal; otherwise 0 is returned, and errno is set to indicate the error\"\n+                // FIXME: we just say nothing is a terminal.\n+                let enotty = this.eval_libc(\"ENOTTY\")?;\n+                this.set_last_error(enotty)?;\n+                this.write_null(dest)?;\n+            }\n+            \"pthread_atfork\" => {\n+                let _prepare = this.read_scalar(args[0])?.not_undef()?;\n+                let _parent = this.read_scalar(args[1])?.not_undef()?;\n+                let _child = this.read_scalar(args[1])?.not_undef()?;\n+                // We do not support forking, so there is nothing to do here.\n+                this.write_null(dest)?;\n+            }\n+\n+            // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n+            // These shims are enabled only when the caller is in the standard library.\n+            | \"pthread_attr_init\"\n+            | \"pthread_attr_destroy\"\n+            | \"pthread_self\"\n+            | \"pthread_attr_setstacksize\"\n+            | \"pthread_condattr_init\"\n+            | \"pthread_condattr_setclock\"\n+            | \"pthread_cond_init\"\n+            | \"pthread_condattr_destroy\"\n+            | \"pthread_cond_destroy\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\")\n+            => {\n+                this.write_null(dest)?;\n+            }\n+\n             | \"signal\"\n             | \"sigaction\"\n             | \"sigaltstack\""}, {"sha": "c2ea02af5b668fd9ce8089124657171c8cf03fe8", "filename": "src/shims/sync.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/79f3307f308ac1d9304437509db0f8a4a295d63b/src%2Fshims%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f3307f308ac1d9304437509db0f8a4a295d63b/src%2Fshims%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fsync.rs?ref=79f3307f308ac1d9304437509db0f8a4a295d63b", "patch": "@@ -20,8 +20,9 @@ fn assert_ptr_target_min_size<'mir, 'tcx: 'mir>(\n \n // pthread_mutexattr_t is either 4 or 8 bytes, depending on the platform.\n \n-// Our chosen memory layout: store an i32 in the first four bytes equal to the\n-// corresponding libc mutex kind constant (i.e. PTHREAD_MUTEX_NORMAL)\n+// Our chosen memory layout for emulation (does not have to match the platform layout!):\n+// store an i32 in the first four bytes equal to the corresponding libc mutex kind constant\n+// (e.g. PTHREAD_MUTEX_NORMAL).\n \n fn mutexattr_get_kind<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n@@ -48,7 +49,7 @@ fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n \n // pthread_mutex_t is between 24 and 48 bytes, depending on the platform.\n \n-// Our chosen memory layout:\n+// Our chosen memory layout for the emulated mutex (does not have to match the platform layout!):\n // bytes 0-3: reserved for signature on macOS\n // (need to avoid this because it is set by static initializer macros)\n // bytes 4-7: count of how many times this mutex has been locked, as a u32\n@@ -117,7 +118,7 @@ fn mutex_set_kind<'mir, 'tcx: 'mir>(\n \n // pthread_rwlock_t is between 32 and 56 bytes, depending on the platform.\n \n-// Our chosen memory layout:\n+// Our chosen memory layout for the emulated rwlock (does not have to match the platform layout!):\n // bytes 0-3: reserved for signature on macOS\n // (need to avoid this because it is set by static initializer macros)\n // bytes 4-7: reader count, as a u32"}, {"sha": "7ea793089d2f2bbac3c8be98fd88023d05b0d662", "filename": "tests/run-pass/libc.rs", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/79f3307f308ac1d9304437509db0f8a4a295d63b/tests%2Frun-pass%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f3307f308ac1d9304437509db0f8a4a295d63b/tests%2Frun-pass%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Flibc.rs?ref=79f3307f308ac1d9304437509db0f8a4a295d63b", "patch": "@@ -42,7 +42,92 @@ fn test_posix_fadvise() {\n     assert_eq!(result, 0);\n }\n \n+fn test_mutex_libc_init_recursive() {\n+    unsafe {\n+        let mut attr: libc::pthread_mutexattr_t = std::mem::zeroed();\n+        assert_eq!(libc::pthread_mutexattr_init(&mut attr as *mut _), 0);\n+        assert_eq!(libc::pthread_mutexattr_settype(&mut attr as *mut _, libc::PTHREAD_MUTEX_RECURSIVE), 0);\n+        let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n+        assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, &mut attr as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), libc::EPERM);\n+        assert_eq!(libc::pthread_mutex_destroy(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutexattr_destroy(&mut attr as *mut _), 0);\n+    }\n+}\n+\n+fn test_mutex_libc_init_normal() {\n+    unsafe {\n+        let mut mutexattr: libc::pthread_mutexattr_t = std::mem::zeroed();\n+        assert_eq!(libc::pthread_mutexattr_settype(&mut mutexattr as *mut _, libc::PTHREAD_MUTEX_NORMAL), 0);\n+        let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n+        assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, &mutexattr as *const _), 0);\n+        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), libc::EBUSY);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_destroy(&mut mutex as *mut _), 0);\n+    }\n+}\n+\n+// Only linux provides PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP,\n+// libc for macOS just has the default PTHREAD_MUTEX_INITIALIZER.\n+#[cfg(target_os = \"linux\")]\n+fn test_mutex_libc_static_initializer_recursive() {\n+    let mutex = std::cell::UnsafeCell::new(libc::PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP);\n+    unsafe {\n+        assert_eq!(libc::pthread_mutex_lock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_lock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), libc::EPERM);\n+        assert_eq!(libc::pthread_mutex_destroy(mutex.get()), 0);\n+    }\n+}\n+\n+// Testing the behavior of std::sync::RwLock does not fully exercise the pthread rwlock shims, we\n+// need to go a layer deeper and test the behavior of the libc functions, because\n+// std::sys::unix::rwlock::RWLock itself keeps track of write_locked and num_readers.\n+fn test_rwlock_libc_static_initializer() {\n+    let rw = std::cell::UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER);\n+    unsafe {\n+        assert_eq!(libc::pthread_rwlock_rdlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_rdlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_tryrdlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_trywrlock(rw.get()), libc::EBUSY);\n+        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n+\n+        assert_eq!(libc::pthread_rwlock_wrlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_tryrdlock(rw.get()), libc::EBUSY);\n+        assert_eq!(libc::pthread_rwlock_trywrlock(rw.get()), libc::EBUSY);\n+        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n+\n+        assert_eq!(libc::pthread_rwlock_destroy(rw.get()), 0);\n+    }\n+}\n+\n fn main() {\n     #[cfg(not(target_os = \"macos\"))]\n     test_posix_fadvise();\n+\n+    test_mutex_libc_init_recursive();\n+    test_mutex_libc_init_normal();\n+    test_rwlock_libc_static_initializer();\n+\n+    #[cfg(target_os = \"linux\")]\n+    test_mutex_libc_static_initializer_recursive();\n }"}, {"sha": "e73e82b8ec9ed3704b857eb743fddc5e84cfbb44", "filename": "tests/run-pass/reentrant-println.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79f3307f308ac1d9304437509db0f8a4a295d63b/tests%2Frun-pass%2Freentrant-println.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f3307f308ac1d9304437509db0f8a4a295d63b/tests%2Frun-pass%2Freentrant-println.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Freentrant-println.rs?ref=79f3307f308ac1d9304437509db0f8a4a295d63b", "patch": "@@ -1,7 +1,7 @@\n use std::fmt::{Display, Error, Formatter};\n \n // This test case exercises std::sys_common::remutex::ReentrantMutex\n-// by calling println!() from inside fmt\n+// by calling println!() from inside fmt.\n \n struct InterruptingCow;\n "}, {"sha": "1ede5d42bb4babb595c061b2ba3c1a4356bbff6b", "filename": "tests/run-pass/sync.rs", "status": "modified", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/79f3307f308ac1d9304437509db0f8a4a295d63b/tests%2Frun-pass%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f3307f308ac1d9304437509db0f8a4a295d63b/tests%2Frun-pass%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fsync.rs?ref=79f3307f308ac1d9304437509db0f8a4a295d63b", "patch": "@@ -2,20 +2,11 @@\n \n use std::sync::{Mutex, TryLockError};\n \n-extern crate libc;\n-\n fn main() {\n     test_mutex_stdlib();\n     #[cfg(not(target_os = \"windows\"))] // TODO: implement RwLock on Windows\n     {\n-        test_mutex_libc_init_recursive();\n-        test_mutex_libc_init_normal();\n         test_rwlock_stdlib();\n-        test_rwlock_libc_static_initializer();\n-    }\n-    #[cfg(target_os = \"linux\")]\n-    {\n-        test_mutex_libc_static_initializer_recursive();\n     }\n }\n \n@@ -29,61 +20,6 @@ fn test_mutex_stdlib() {\n     drop(m);\n }\n \n-#[cfg(not(target_os = \"windows\"))]\n-fn test_mutex_libc_init_recursive() {\n-    unsafe {\n-        let mut attr: libc::pthread_mutexattr_t = std::mem::zeroed();\n-        assert_eq!(libc::pthread_mutexattr_init(&mut attr as *mut _), 0);\n-        assert_eq!(libc::pthread_mutexattr_settype(&mut attr as *mut _, libc::PTHREAD_MUTEX_RECURSIVE), 0);\n-        let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n-        assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, &mut attr as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), libc::EPERM);\n-        assert_eq!(libc::pthread_mutex_destroy(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutexattr_destroy(&mut attr as *mut _), 0);\n-    }\n-}\n-\n-#[cfg(not(target_os = \"windows\"))]\n-fn test_mutex_libc_init_normal() {\n-    unsafe {\n-        let mut mutexattr: libc::pthread_mutexattr_t = std::mem::zeroed();\n-        assert_eq!(libc::pthread_mutexattr_settype(&mut mutexattr as *mut _, libc::PTHREAD_MUTEX_NORMAL), 0);\n-        let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n-        assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, &mutexattr as *const _), 0);\n-        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), libc::EBUSY);\n-        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_destroy(&mut mutex as *mut _), 0);\n-    }\n-}\n-\n-#[cfg(target_os = \"linux\")]\n-fn test_mutex_libc_static_initializer_recursive() {\n-    let mutex = std::cell::UnsafeCell::new(libc::PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP);\n-    unsafe {\n-        assert_eq!(libc::pthread_mutex_lock(mutex.get()), 0);\n-        assert_eq!(libc::pthread_mutex_trylock(mutex.get()), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), 0);\n-        assert_eq!(libc::pthread_mutex_trylock(mutex.get()), 0);\n-        assert_eq!(libc::pthread_mutex_lock(mutex.get()), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), libc::EPERM);\n-        assert_eq!(libc::pthread_mutex_destroy(mutex.get()), 0);\n-    }\n-}\n-\n #[cfg(not(target_os = \"windows\"))]\n fn test_rwlock_stdlib() {\n     use std::sync::RwLock;\n@@ -102,30 +38,6 @@ fn test_rwlock_stdlib() {\n     }\n }\n \n-// need to go a layer deeper and test the behavior of libc functions, because\n-// std::sys::unix::rwlock::RWLock keeps track of write_locked and num_readers\n-\n-#[cfg(not(target_os = \"windows\"))]\n-fn test_rwlock_libc_static_initializer() {\n-    let rw = std::cell::UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER);\n-    unsafe {\n-        assert_eq!(libc::pthread_rwlock_rdlock(rw.get()), 0);\n-        assert_eq!(libc::pthread_rwlock_rdlock(rw.get()), 0);\n-        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n-        assert_eq!(libc::pthread_rwlock_tryrdlock(rw.get()), 0);\n-        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n-        assert_eq!(libc::pthread_rwlock_trywrlock(rw.get()), libc::EBUSY);\n-        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n-\n-        assert_eq!(libc::pthread_rwlock_wrlock(rw.get()), 0);\n-        assert_eq!(libc::pthread_rwlock_tryrdlock(rw.get()), libc::EBUSY);\n-        assert_eq!(libc::pthread_rwlock_trywrlock(rw.get()), libc::EBUSY);\n-        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n-\n-        assert_eq!(libc::pthread_rwlock_destroy(rw.get()), 0);\n-    }\n-}\n-\n trait TryLockErrorExt<T> {\n     fn would_block(&self) -> bool;\n }"}]}