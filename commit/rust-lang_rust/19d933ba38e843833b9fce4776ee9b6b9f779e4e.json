{"sha": "19d933ba38e843833b9fce4776ee9b6b9f779e4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ZDkzM2JhMzhlODQzODMzYjlmY2U0Nzc2ZWU5YjZiOWY3NzllNGU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-25T10:42:40Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-25T10:42:40Z"}, "message": "join lines works for lambdas", "tree": {"sha": "a4e281d3ca8ef8d3b8b24f7ea5f1cad1a24ec369", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4e281d3ca8ef8d3b8b24f7ea5f1cad1a24ec369"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19d933ba38e843833b9fce4776ee9b6b9f779e4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19d933ba38e843833b9fce4776ee9b6b9f779e4e", "html_url": "https://github.com/rust-lang/rust/commit/19d933ba38e843833b9fce4776ee9b6b9f779e4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19d933ba38e843833b9fce4776ee9b6b9f779e4e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "838820ad986e04dffa43fc2662a58da27d97db06", "url": "https://api.github.com/repos/rust-lang/rust/commits/838820ad986e04dffa43fc2662a58da27d97db06", "html_url": "https://github.com/rust-lang/rust/commit/838820ad986e04dffa43fc2662a58da27d97db06"}], "stats": {"total": 815, "additions": 811, "deletions": 4}, "files": [{"sha": "060095f28bbd64b9514a65098b592877a27a5c81", "filename": "crates/libeditor/src/typing.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/19d933ba38e843833b9fce4776ee9b6b9f779e4e/crates%2Flibeditor%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19d933ba38e843833b9fce4776ee9b6b9f779e4e/crates%2Flibeditor%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Ftyping.rs?ref=19d933ba38e843833b9fce4776ee9b6b9f779e4e", "patch": "@@ -1,5 +1,8 @@\n+use std::mem;\n+\n use libsyntax2::{\n-    TextUnit, TextRange, SyntaxNodeRef, File,\n+    TextUnit, TextRange, SyntaxNodeRef, File, AstNode,\n+    ast,\n     algo::{\n         walk::preorder,\n         find_covering_node,\n@@ -60,6 +63,9 @@ fn remove_newline(\n     offset: TextUnit,\n ) {\n     if node.kind() == WHITESPACE && node_text.bytes().filter(|&b| b == b'\\n').count() == 1 {\n+        if join_lambda_body(edit, node).is_some() {\n+            return\n+        }\n         match (node.prev_sibling(), node.next_sibling()) {\n             (Some(prev), Some(next)) => {\n                 let range = TextRange::from_to(prev.range().start(), node.range().end());\n@@ -91,6 +97,41 @@ fn remove_newline(\n     );\n }\n \n+fn join_lambda_body(\n+    edit: &mut EditBuilder,\n+    node: SyntaxNodeRef,\n+) -> Option<()> {\n+    let block = ast::Block::cast(node.parent()?)?;\n+    let block_expr = ast::BlockExpr::cast(block.syntax().parent()?)?;\n+    let _lambda = ast::LambdaExpr::cast(block_expr.syntax().parent()?)?;\n+    let expr = single_expr(block)?;\n+    edit.replace(\n+        block_expr.syntax().range(),\n+        expr.syntax().text(),\n+    );\n+    Some(())\n+}\n+\n+fn single_expr(block: ast::Block) -> Option<ast::Expr> {\n+    let mut res = None;\n+    for child in block.syntax().children() {\n+        if let Some(expr) = ast::Expr::cast(child) {\n+            if expr.syntax().text().contains('\\n') {\n+                return None;\n+            }\n+            if mem::replace(&mut res, Some(expr)).is_some() {\n+                return None;\n+            }\n+        } else {\n+            match child.kind() {\n+                WHITESPACE | L_CURLY | R_CURLY => (),\n+                _ => return None,\n+            }\n+        }\n+    }\n+    res\n+}\n+\n fn compute_ws(left: SyntaxNodeRef, right: SyntaxNodeRef) -> &'static str {\n     match left.kind() {\n         L_PAREN | L_BRACK => return \"\","}, {"sha": "7e5e75ec206ff2086f85e6083d30a0ee50361ecd", "filename": "crates/libeditor/tests/test.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/19d933ba38e843833b9fce4776ee9b6b9f779e4e/crates%2Flibeditor%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19d933ba38e843833b9fce4776ee9b6b9f779e4e/crates%2Flibeditor%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Ftests%2Ftest.rs?ref=19d933ba38e843833b9fce4776ee9b6b9f779e4e", "patch": "@@ -198,6 +198,17 @@ fn foo() {\n fn foo() {\n     <|>foo(1)\n }\n+\");\n+    do_check(r\"\n+pub fn reparse(&self, edit: &AtomEdit) -> File {\n+    <|>self.incremental_reparse(edit).unwrap_or_else(|| {\n+        self.full_reparse(edit)\n+    })\n+}\n+\", r\"\n+pub fn reparse(&self, edit: &AtomEdit) -> File {\n+    <|>self.incremental_reparse(edit).unwrap_or_else(|| self.full_reparse(edit))\n+}\n \");\n }\n "}, {"sha": "7d746a85b087fa00de98fbcba367b63a0c51e294", "filename": "crates/libsyntax2/src/ast/generated.rs", "status": "modified", "additions": 688, "deletions": 0, "changes": 688, "blob_url": "https://github.com/rust-lang/rust/blob/19d933ba38e843833b9fce4776ee9b6b9f779e4e/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19d933ba38e843833b9fce4776ee9b6b9f779e4e/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs?ref=19d933ba38e843833b9fce4776ee9b6b9f779e4e", "patch": "@@ -4,6 +4,24 @@ use {\n     SyntaxKind::*,\n };\n \n+// ArrayExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct ArrayExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for ArrayExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            ARRAY_EXPR => Some(ArrayExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> ArrayExpr<'a> {}\n+\n // ArrayType\n #[derive(Debug, Clone, Copy)]\n pub struct ArrayType<'a> {\n@@ -44,6 +62,114 @@ impl<'a> Attr<'a> {\n     }\n }\n \n+// BinExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct BinExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for BinExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            BIN_EXPR => Some(BinExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> BinExpr<'a> {}\n+\n+// Block\n+#[derive(Debug, Clone, Copy)]\n+pub struct Block<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for Block<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            BLOCK => Some(Block { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> Block<'a> {}\n+\n+// BlockExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct BlockExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for BlockExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            BLOCK_EXPR => Some(BlockExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> BlockExpr<'a> {}\n+\n+// BreakExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct BreakExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for BreakExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            BREAK_EXPR => Some(BreakExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> BreakExpr<'a> {}\n+\n+// CallExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct CallExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for CallExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            CALL_EXPR => Some(CallExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> CallExpr<'a> {}\n+\n+// CastExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct CastExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for CastExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            CAST_EXPR => Some(CastExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> CastExpr<'a> {}\n+\n // ConstDef\n #[derive(Debug, Clone, Copy)]\n pub struct ConstDef<'a> {\n@@ -65,6 +191,24 @@ impl<'a> ast::TypeParamsOwner<'a> for ConstDef<'a> {}\n impl<'a> ast::AttrsOwner<'a> for ConstDef<'a> {}\n impl<'a> ConstDef<'a> {}\n \n+// ContinueExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct ContinueExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for ContinueExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            CONTINUE_EXPR => Some(ContinueExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> ContinueExpr<'a> {}\n+\n // DynTraitType\n #[derive(Debug, Clone, Copy)]\n pub struct DynTraitType<'a> {\n@@ -104,6 +248,136 @@ impl<'a> ast::TypeParamsOwner<'a> for EnumDef<'a> {}\n impl<'a> ast::AttrsOwner<'a> for EnumDef<'a> {}\n impl<'a> EnumDef<'a> {}\n \n+// Expr\n+#[derive(Debug, Clone, Copy)]\n+pub enum Expr<'a> {\n+    TupleExpr(TupleExpr<'a>),\n+    ArrayExpr(ArrayExpr<'a>),\n+    ParenExpr(ParenExpr<'a>),\n+    PathExpr(PathExpr<'a>),\n+    LambdaExpr(LambdaExpr<'a>),\n+    IfExpr(IfExpr<'a>),\n+    LoopExpr(LoopExpr<'a>),\n+    ForExpr(ForExpr<'a>),\n+    WhileExpr(WhileExpr<'a>),\n+    ContinueExpr(ContinueExpr<'a>),\n+    BreakExpr(BreakExpr<'a>),\n+    Label(Label<'a>),\n+    BlockExpr(BlockExpr<'a>),\n+    ReturnExpr(ReturnExpr<'a>),\n+    MatchExpr(MatchExpr<'a>),\n+    MatchArmList(MatchArmList<'a>),\n+    MatchArm(MatchArm<'a>),\n+    MatchGuard(MatchGuard<'a>),\n+    StructLit(StructLit<'a>),\n+    NamedFieldList(NamedFieldList<'a>),\n+    NamedField(NamedField<'a>),\n+    CallExpr(CallExpr<'a>),\n+    IndexExpr(IndexExpr<'a>),\n+    MethodCallExpr(MethodCallExpr<'a>),\n+    FieldExpr(FieldExpr<'a>),\n+    TryExpr(TryExpr<'a>),\n+    CastExpr(CastExpr<'a>),\n+    RefExpr(RefExpr<'a>),\n+    PrefixExpr(PrefixExpr<'a>),\n+    RangeExpr(RangeExpr<'a>),\n+    BinExpr(BinExpr<'a>),\n+}\n+\n+impl<'a> AstNode<'a> for Expr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            TUPLE_EXPR => Some(Expr::TupleExpr(TupleExpr { syntax })),\n+            ARRAY_EXPR => Some(Expr::ArrayExpr(ArrayExpr { syntax })),\n+            PAREN_EXPR => Some(Expr::ParenExpr(ParenExpr { syntax })),\n+            PATH_EXPR => Some(Expr::PathExpr(PathExpr { syntax })),\n+            LAMBDA_EXPR => Some(Expr::LambdaExpr(LambdaExpr { syntax })),\n+            IF_EXPR => Some(Expr::IfExpr(IfExpr { syntax })),\n+            LOOP_EXPR => Some(Expr::LoopExpr(LoopExpr { syntax })),\n+            FOR_EXPR => Some(Expr::ForExpr(ForExpr { syntax })),\n+            WHILE_EXPR => Some(Expr::WhileExpr(WhileExpr { syntax })),\n+            CONTINUE_EXPR => Some(Expr::ContinueExpr(ContinueExpr { syntax })),\n+            BREAK_EXPR => Some(Expr::BreakExpr(BreakExpr { syntax })),\n+            LABEL => Some(Expr::Label(Label { syntax })),\n+            BLOCK_EXPR => Some(Expr::BlockExpr(BlockExpr { syntax })),\n+            RETURN_EXPR => Some(Expr::ReturnExpr(ReturnExpr { syntax })),\n+            MATCH_EXPR => Some(Expr::MatchExpr(MatchExpr { syntax })),\n+            MATCH_ARM_LIST => Some(Expr::MatchArmList(MatchArmList { syntax })),\n+            MATCH_ARM => Some(Expr::MatchArm(MatchArm { syntax })),\n+            MATCH_GUARD => Some(Expr::MatchGuard(MatchGuard { syntax })),\n+            STRUCT_LIT => Some(Expr::StructLit(StructLit { syntax })),\n+            NAMED_FIELD_LIST => Some(Expr::NamedFieldList(NamedFieldList { syntax })),\n+            NAMED_FIELD => Some(Expr::NamedField(NamedField { syntax })),\n+            CALL_EXPR => Some(Expr::CallExpr(CallExpr { syntax })),\n+            INDEX_EXPR => Some(Expr::IndexExpr(IndexExpr { syntax })),\n+            METHOD_CALL_EXPR => Some(Expr::MethodCallExpr(MethodCallExpr { syntax })),\n+            FIELD_EXPR => Some(Expr::FieldExpr(FieldExpr { syntax })),\n+            TRY_EXPR => Some(Expr::TryExpr(TryExpr { syntax })),\n+            CAST_EXPR => Some(Expr::CastExpr(CastExpr { syntax })),\n+            REF_EXPR => Some(Expr::RefExpr(RefExpr { syntax })),\n+            PREFIX_EXPR => Some(Expr::PrefixExpr(PrefixExpr { syntax })),\n+            RANGE_EXPR => Some(Expr::RangeExpr(RangeExpr { syntax })),\n+            BIN_EXPR => Some(Expr::BinExpr(BinExpr { syntax })),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> {\n+        match self {\n+            Expr::TupleExpr(inner) => inner.syntax(),\n+            Expr::ArrayExpr(inner) => inner.syntax(),\n+            Expr::ParenExpr(inner) => inner.syntax(),\n+            Expr::PathExpr(inner) => inner.syntax(),\n+            Expr::LambdaExpr(inner) => inner.syntax(),\n+            Expr::IfExpr(inner) => inner.syntax(),\n+            Expr::LoopExpr(inner) => inner.syntax(),\n+            Expr::ForExpr(inner) => inner.syntax(),\n+            Expr::WhileExpr(inner) => inner.syntax(),\n+            Expr::ContinueExpr(inner) => inner.syntax(),\n+            Expr::BreakExpr(inner) => inner.syntax(),\n+            Expr::Label(inner) => inner.syntax(),\n+            Expr::BlockExpr(inner) => inner.syntax(),\n+            Expr::ReturnExpr(inner) => inner.syntax(),\n+            Expr::MatchExpr(inner) => inner.syntax(),\n+            Expr::MatchArmList(inner) => inner.syntax(),\n+            Expr::MatchArm(inner) => inner.syntax(),\n+            Expr::MatchGuard(inner) => inner.syntax(),\n+            Expr::StructLit(inner) => inner.syntax(),\n+            Expr::NamedFieldList(inner) => inner.syntax(),\n+            Expr::NamedField(inner) => inner.syntax(),\n+            Expr::CallExpr(inner) => inner.syntax(),\n+            Expr::IndexExpr(inner) => inner.syntax(),\n+            Expr::MethodCallExpr(inner) => inner.syntax(),\n+            Expr::FieldExpr(inner) => inner.syntax(),\n+            Expr::TryExpr(inner) => inner.syntax(),\n+            Expr::CastExpr(inner) => inner.syntax(),\n+            Expr::RefExpr(inner) => inner.syntax(),\n+            Expr::PrefixExpr(inner) => inner.syntax(),\n+            Expr::RangeExpr(inner) => inner.syntax(),\n+            Expr::BinExpr(inner) => inner.syntax(),\n+        }\n+    }\n+}\n+\n+impl<'a> Expr<'a> {}\n+\n+// FieldExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct FieldExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for FieldExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            FIELD_EXPR => Some(FieldExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> FieldExpr<'a> {}\n+\n // FnDef\n #[derive(Debug, Clone, Copy)]\n pub struct FnDef<'a> {\n@@ -143,6 +417,24 @@ impl<'a> AstNode<'a> for FnPointerType<'a> {\n \n impl<'a> FnPointerType<'a> {}\n \n+// ForExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct ForExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for ForExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            FOR_EXPR => Some(ForExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> ForExpr<'a> {}\n+\n // ForType\n #[derive(Debug, Clone, Copy)]\n pub struct ForType<'a> {\n@@ -161,6 +453,24 @@ impl<'a> AstNode<'a> for ForType<'a> {\n \n impl<'a> ForType<'a> {}\n \n+// IfExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct IfExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for IfExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            IF_EXPR => Some(IfExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> IfExpr<'a> {}\n+\n // ImplItem\n #[derive(Debug, Clone, Copy)]\n pub struct ImplItem<'a> {\n@@ -197,6 +507,168 @@ impl<'a> AstNode<'a> for ImplTraitType<'a> {\n \n impl<'a> ImplTraitType<'a> {}\n \n+// IndexExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct IndexExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for IndexExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            INDEX_EXPR => Some(IndexExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> IndexExpr<'a> {}\n+\n+// Label\n+#[derive(Debug, Clone, Copy)]\n+pub struct Label<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for Label<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            LABEL => Some(Label { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> Label<'a> {}\n+\n+// LambdaExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct LambdaExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for LambdaExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            LAMBDA_EXPR => Some(LambdaExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> LambdaExpr<'a> {}\n+\n+// LoopExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct LoopExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for LoopExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            LOOP_EXPR => Some(LoopExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> LoopExpr<'a> {}\n+\n+// MatchArm\n+#[derive(Debug, Clone, Copy)]\n+pub struct MatchArm<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for MatchArm<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            MATCH_ARM => Some(MatchArm { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> MatchArm<'a> {}\n+\n+// MatchArmList\n+#[derive(Debug, Clone, Copy)]\n+pub struct MatchArmList<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for MatchArmList<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            MATCH_ARM_LIST => Some(MatchArmList { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> MatchArmList<'a> {}\n+\n+// MatchExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct MatchExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for MatchExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            MATCH_EXPR => Some(MatchExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> MatchExpr<'a> {}\n+\n+// MatchGuard\n+#[derive(Debug, Clone, Copy)]\n+pub struct MatchGuard<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for MatchGuard<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            MATCH_GUARD => Some(MatchGuard { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> MatchGuard<'a> {}\n+\n+// MethodCallExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct MethodCallExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for MethodCallExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            METHOD_CALL_EXPR => Some(MethodCallExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> MethodCallExpr<'a> {}\n+\n // Module\n #[derive(Debug, Clone, Copy)]\n pub struct Module<'a> {\n@@ -257,6 +729,24 @@ impl<'a> AstNode<'a> for NameRef<'a> {\n \n impl<'a> NameRef<'a> {}\n \n+// NamedField\n+#[derive(Debug, Clone, Copy)]\n+pub struct NamedField<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for NamedField<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            NAMED_FIELD => Some(NamedField { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> NamedField<'a> {}\n+\n // NamedFieldDef\n #[derive(Debug, Clone, Copy)]\n pub struct NamedFieldDef<'a> {\n@@ -277,6 +767,24 @@ impl<'a> ast::NameOwner<'a> for NamedFieldDef<'a> {}\n impl<'a> ast::AttrsOwner<'a> for NamedFieldDef<'a> {}\n impl<'a> NamedFieldDef<'a> {}\n \n+// NamedFieldList\n+#[derive(Debug, Clone, Copy)]\n+pub struct NamedFieldList<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for NamedFieldList<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            NAMED_FIELD_LIST => Some(NamedFieldList { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> NamedFieldList<'a> {}\n+\n // NeverType\n #[derive(Debug, Clone, Copy)]\n pub struct NeverType<'a> {\n@@ -323,6 +831,24 @@ impl<'a> ast::TypeParamsOwner<'a> for NominalDef<'a> {}\n impl<'a> ast::AttrsOwner<'a> for NominalDef<'a> {}\n impl<'a> NominalDef<'a> {}\n \n+// ParenExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct ParenExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for ParenExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            PAREN_EXPR => Some(ParenExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> ParenExpr<'a> {}\n+\n // ParenType\n #[derive(Debug, Clone, Copy)]\n pub struct ParenType<'a> {\n@@ -341,6 +867,24 @@ impl<'a> AstNode<'a> for ParenType<'a> {\n \n impl<'a> ParenType<'a> {}\n \n+// PathExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct PathExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for PathExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            PATH_EXPR => Some(PathExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> PathExpr<'a> {}\n+\n // PathType\n #[derive(Debug, Clone, Copy)]\n pub struct PathType<'a> {\n@@ -395,6 +939,60 @@ impl<'a> AstNode<'a> for PointerType<'a> {\n \n impl<'a> PointerType<'a> {}\n \n+// PrefixExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct PrefixExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for PrefixExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            PREFIX_EXPR => Some(PrefixExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> PrefixExpr<'a> {}\n+\n+// RangeExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct RangeExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for RangeExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            RANGE_EXPR => Some(RangeExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> RangeExpr<'a> {}\n+\n+// RefExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct RefExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for RefExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            REF_EXPR => Some(RefExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> RefExpr<'a> {}\n+\n // ReferenceType\n #[derive(Debug, Clone, Copy)]\n pub struct ReferenceType<'a> {\n@@ -413,6 +1011,24 @@ impl<'a> AstNode<'a> for ReferenceType<'a> {\n \n impl<'a> ReferenceType<'a> {}\n \n+// ReturnExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct ReturnExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for ReturnExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            RETURN_EXPR => Some(ReturnExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> ReturnExpr<'a> {}\n+\n // Root\n #[derive(Debug, Clone, Copy)]\n pub struct Root<'a> {\n@@ -503,6 +1119,24 @@ impl<'a> StructDef<'a> {\n     }\n }\n \n+// StructLit\n+#[derive(Debug, Clone, Copy)]\n+pub struct StructLit<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for StructLit<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            STRUCT_LIT => Some(StructLit { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> StructLit<'a> {}\n+\n // TokenTree\n #[derive(Debug, Clone, Copy)]\n pub struct TokenTree<'a> {\n@@ -541,6 +1175,42 @@ impl<'a> ast::NameOwner<'a> for TraitDef<'a> {}\n impl<'a> ast::AttrsOwner<'a> for TraitDef<'a> {}\n impl<'a> TraitDef<'a> {}\n \n+// TryExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct TryExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for TryExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            TRY_EXPR => Some(TryExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> TryExpr<'a> {}\n+\n+// TupleExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct TupleExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for TupleExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            TUPLE_EXPR => Some(TupleExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> TupleExpr<'a> {}\n+\n // TupleType\n #[derive(Debug, Clone, Copy)]\n pub struct TupleType<'a> {\n@@ -697,3 +1367,21 @@ impl<'a> AstNode<'a> for WhereClause<'a> {\n \n impl<'a> WhereClause<'a> {}\n \n+// WhileExpr\n+#[derive(Debug, Clone, Copy)]\n+pub struct WhileExpr<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for WhileExpr<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            WHILE_EXPR => Some(WhileExpr { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> WhileExpr<'a> {}\n+"}, {"sha": "a753d5e4824ea862cbc107498d520bdeede1b352", "filename": "crates/libsyntax2/src/grammar.ron", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/19d933ba38e843833b9fce4776ee9b6b9f779e4e/crates%2Flibsyntax2%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/19d933ba38e843833b9fce4776ee9b6b9f779e4e/crates%2Flibsyntax2%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fgrammar.ron?ref=19d933ba38e843833b9fce4776ee9b6b9f779e4e", "patch": "@@ -325,12 +325,81 @@ Grammar(\n             ],\n         ),\n \n+        \"TupleExpr\": (),\n+        \"ArrayExpr\": (),\n+        \"ParenExpr\": (),\n+        \"PathExpr\": (),\n+        \"LambdaExpr\": (),\n+        \"IfExpr\": (),\n+        \"LoopExpr\": (),\n+        \"ForExpr\": (),\n+        \"WhileExpr\": (),\n+        \"ContinueExpr\": (),\n+        \"BreakExpr\": (),\n+        \"Label\": (),\n+        \"BlockExpr\": (),\n+        \"ReturnExpr\": (),\n+        \"MatchExpr\": (),\n+        \"MatchArmList\": (),\n+        \"MatchArm\": (),\n+        \"MatchGuard\": (),\n+        \"StructLit\": (),\n+        \"NamedFieldList\": (),\n+        \"NamedField\": (),\n+        \"CallExpr\": (),\n+        \"IndexExpr\": (),\n+        \"MethodCallExpr\": (),\n+        \"FieldExpr\": (),\n+        \"TryExpr\": (),\n+        \"CastExpr\": (),\n+        \"RefExpr\": (),\n+        \"PrefixExpr\": (),\n+        \"RangeExpr\": (),\n+        \"BinExpr\": (),\n+\n+        \"Expr\": (\n+            enum: [\n+                \"TupleExpr\",\n+                \"ArrayExpr\",\n+                \"ParenExpr\",\n+                \"PathExpr\",\n+                \"LambdaExpr\",\n+                \"IfExpr\",\n+                \"LoopExpr\",\n+                \"ForExpr\",\n+                \"WhileExpr\",\n+                \"ContinueExpr\",\n+                \"BreakExpr\",\n+                \"Label\",\n+                \"BlockExpr\",\n+                \"ReturnExpr\",\n+                \"MatchExpr\",\n+                \"MatchArmList\",\n+                \"MatchArm\",\n+                \"MatchGuard\",\n+                \"StructLit\",\n+                \"NamedFieldList\",\n+                \"NamedField\",\n+                \"CallExpr\",\n+                \"IndexExpr\",\n+                \"MethodCallExpr\",\n+                \"FieldExpr\",\n+                \"TryExpr\",\n+                \"CastExpr\",\n+                \"RefExpr\",\n+                \"PrefixExpr\",\n+                \"RangeExpr\",\n+                \"BinExpr\",\n+            ],\n+        ),\n+\n         \"Name\": (),\n         \"NameRef\": (),\n         \"Attr\": ( options: [ [\"value\", \"TokenTree\"] ] ),\n         \"TokenTree\": (),\n         \"TypeParamList\": ( collections: [ [\"type_params\", \"TypeParam\" ] ]),\n         \"TypeParam\": ( traits: [\"NameOwner\"]),\n         \"WhereClause\": (),\n+        \"Block\": (),\n     },\n )"}, {"sha": "787dc2b5bf1f296404dce5e4d32968ac59659480", "filename": "crates/libsyntax2/src/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19d933ba38e843833b9fce4776ee9b6b9f779e4e/crates%2Flibsyntax2%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19d933ba38e843833b9fce4776ee9b6b9f779e4e/crates%2Flibsyntax2%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Flib.rs?ref=19d933ba38e843833b9fce4776ee9b6b9f779e4e", "patch": "@@ -74,9 +74,7 @@ impl File {\n         File::new(root, errors)\n     }\n     pub fn reparse(&self, edit: &AtomEdit) -> File {\n-        self.incremental_reparse(edit).unwrap_or_else(|| {\n-            self.full_reparse(edit)\n-        })\n+        self.incremental_reparse(edit).unwrap_or_else(|| self.full_reparse(edit))\n     }\n     fn incremental_reparse(&self, edit: &AtomEdit) -> Option<File> {\n         let (node, reparser) = find_reparsable_node(self.syntax(), edit.delete)?;"}]}