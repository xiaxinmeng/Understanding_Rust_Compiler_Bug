{"sha": "3219a100fab579015d56411f5a50dcb7ff10f39d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyMTlhMTAwZmFiNTc5MDE1ZDU2NDExZjVhNTBkY2I3ZmYxMGYzOWQ=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2021-02-21T06:26:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-21T06:26:36Z"}, "message": "Rollup merge of #81300 - ssomers:btree_cleanup_leak_tests, r=Mark-Simulacrum\n\nBTree: share panicky test code & test panic during clear, clone\n\nBases almost all tests of panic on the same, richer definition, and extends it to cloning to test panic during clone.\n\nr? ```@Mark-Simulacrum```", "tree": {"sha": "d7b2a0ace5e8380248e698e6133bf5e0343fc7fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7b2a0ace5e8380248e698e6133bf5e0343fc7fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3219a100fab579015d56411f5a50dcb7ff10f39d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgMf0cCRBK7hj4Ov3rIwAAdHIIAJoGsoiA8Z948yqvMBaqEg7l\nlvfHW47b1015Mf6zMZ2puqsSVdl+w8Jx26WZ7wb1LDIDbCzjoZiPzrHxb13h41hl\nAv2qI7p/ncCNknEtDHjHGfcIfMxwcdkkEPlChx45uXIL5nPkdHuU/G832gy9r9OC\nQiWD8hgFi/vetsKMAva9c1qk2RnRKU8EmfykM2Qc78qYGUJNKpHjJH8UkZGtX4iq\nFZNbBrBqhV+rBxFi/+7Bo+q0GiR6LH/PHfj4opZfIdlhMUJ0Ir3SkVk5B0mjXlw/\n8X3KLfQcMmkQ4dkIhbq0OscumPFb+OaS/j7IvWGPJTQ/imeiZAo7eK+Vkvux05Y=\n=PTQK\n-----END PGP SIGNATURE-----\n", "payload": "tree d7b2a0ace5e8380248e698e6133bf5e0343fc7fc\nparent a31c16212d70fcae3ad9d073b00d883951e573ee\nparent 3e1d602a6b3ed491e2188176addf41a059c1ff02\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1613888796 +0900\ncommitter GitHub <noreply@github.com> 1613888796 +0900\n\nRollup merge of #81300 - ssomers:btree_cleanup_leak_tests, r=Mark-Simulacrum\n\nBTree: share panicky test code & test panic during clear, clone\n\nBases almost all tests of panic on the same, richer definition, and extends it to cloning to test panic during clone.\n\nr? ```@Mark-Simulacrum```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3219a100fab579015d56411f5a50dcb7ff10f39d", "html_url": "https://github.com/rust-lang/rust/commit/3219a100fab579015d56411f5a50dcb7ff10f39d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3219a100fab579015d56411f5a50dcb7ff10f39d/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a31c16212d70fcae3ad9d073b00d883951e573ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/a31c16212d70fcae3ad9d073b00d883951e573ee", "html_url": "https://github.com/rust-lang/rust/commit/a31c16212d70fcae3ad9d073b00d883951e573ee"}, {"sha": "3e1d602a6b3ed491e2188176addf41a059c1ff02", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e1d602a6b3ed491e2188176addf41a059c1ff02", "html_url": "https://github.com/rust-lang/rust/commit/3e1d602a6b3ed491e2188176addf41a059c1ff02"}], "stats": {"total": 554, "additions": 337, "deletions": 217}, "files": [{"sha": "56d6ae57e04a57ab3b0c2b9bcf4af20d0f6327fe", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 154, "deletions": 131, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/3219a100fab579015d56411f5a50dcb7ff10f39d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3219a100fab579015d56411f5a50dcb7ff10f39d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=3219a100fab579015d56411f5a50dcb7ff10f39d", "patch": "@@ -1,4 +1,6 @@\n-use super::super::{node, DeterministicRng};\n+use super::super::testing::crash_test::{CrashTestDummy, Panic};\n+use super::super::testing::ord_chaos::{Cyclic3, Governed, Governor};\n+use super::super::testing::rng::DeterministicRng;\n use super::Entry::{Occupied, Vacant};\n use super::*;\n use crate::boxed::Box;\n@@ -15,9 +17,6 @@ use std::ops::RangeBounds;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n \n-mod ord_chaos;\n-use ord_chaos::{Cyclic3, Governed, Governor};\n-\n // Capacity of a tree with a single level,\n // i.e., a tree who's root is a leaf node at height 0.\n const NODE_CAPACITY: usize = node::CAPACITY;\n@@ -1136,103 +1135,78 @@ mod test_drain_filter {\n \n     #[test]\n     fn drop_panic_leak() {\n-        static PREDS: AtomicUsize = AtomicUsize::new(0);\n-        static DROPS: AtomicUsize = AtomicUsize::new(0);\n-\n-        struct D;\n-        impl Drop for D {\n-            fn drop(&mut self) {\n-                if DROPS.fetch_add(1, SeqCst) == 1 {\n-                    panic!(\"panic in `drop`\");\n-                }\n-            }\n-        }\n-\n-        // Keys are multiples of 4, so that each key is counted by a hexadecimal digit.\n-        let mut map = (0..3).map(|i| (i * 4, D)).collect::<BTreeMap<_, _>>();\n+        let a = CrashTestDummy::new(0);\n+        let b = CrashTestDummy::new(1);\n+        let c = CrashTestDummy::new(2);\n+        let mut map = BTreeMap::new();\n+        map.insert(a.spawn(Panic::Never), ());\n+        map.insert(b.spawn(Panic::InDrop), ());\n+        map.insert(c.spawn(Panic::Never), ());\n \n-        catch_unwind(move || {\n-            drop(map.drain_filter(|i, _| {\n-                PREDS.fetch_add(1usize << i, SeqCst);\n-                true\n-            }))\n-        })\n-        .unwrap_err();\n+        catch_unwind(move || drop(map.drain_filter(|dummy, _| dummy.query(true)))).unwrap_err();\n \n-        assert_eq!(PREDS.load(SeqCst), 0x011);\n-        assert_eq!(DROPS.load(SeqCst), 3);\n+        assert_eq!(a.queried(), 1);\n+        assert_eq!(b.queried(), 1);\n+        assert_eq!(c.queried(), 0);\n+        assert_eq!(a.dropped(), 1);\n+        assert_eq!(b.dropped(), 1);\n+        assert_eq!(c.dropped(), 1);\n     }\n \n     #[test]\n     fn pred_panic_leak() {\n-        static PREDS: AtomicUsize = AtomicUsize::new(0);\n-        static DROPS: AtomicUsize = AtomicUsize::new(0);\n-\n-        struct D;\n-        impl Drop for D {\n-            fn drop(&mut self) {\n-                DROPS.fetch_add(1, SeqCst);\n-            }\n-        }\n-\n-        // Keys are multiples of 4, so that each key is counted by a hexadecimal digit.\n-        let mut map = (0..3).map(|i| (i * 4, D)).collect::<BTreeMap<_, _>>();\n-\n-        catch_unwind(AssertUnwindSafe(|| {\n-            drop(map.drain_filter(|i, _| {\n-                PREDS.fetch_add(1usize << i, SeqCst);\n-                match i {\n-                    0 => true,\n-                    _ => panic!(),\n-                }\n-            }))\n-        }))\n-        .unwrap_err();\n-\n-        assert_eq!(PREDS.load(SeqCst), 0x011);\n-        assert_eq!(DROPS.load(SeqCst), 1);\n+        let a = CrashTestDummy::new(0);\n+        let b = CrashTestDummy::new(1);\n+        let c = CrashTestDummy::new(2);\n+        let mut map = BTreeMap::new();\n+        map.insert(a.spawn(Panic::Never), ());\n+        map.insert(b.spawn(Panic::InQuery), ());\n+        map.insert(c.spawn(Panic::InQuery), ());\n+\n+        catch_unwind(AssertUnwindSafe(|| drop(map.drain_filter(|dummy, _| dummy.query(true)))))\n+            .unwrap_err();\n+\n+        assert_eq!(a.queried(), 1);\n+        assert_eq!(b.queried(), 1);\n+        assert_eq!(c.queried(), 0);\n+        assert_eq!(a.dropped(), 1);\n+        assert_eq!(b.dropped(), 0);\n+        assert_eq!(c.dropped(), 0);\n         assert_eq!(map.len(), 2);\n-        assert_eq!(map.first_entry().unwrap().key(), &4);\n-        assert_eq!(map.last_entry().unwrap().key(), &8);\n+        assert_eq!(map.first_entry().unwrap().key().id(), 1);\n+        assert_eq!(map.last_entry().unwrap().key().id(), 2);\n         map.check();\n     }\n \n     // Same as above, but attempt to use the iterator again after the panic in the predicate\n     #[test]\n     fn pred_panic_reuse() {\n-        static PREDS: AtomicUsize = AtomicUsize::new(0);\n-        static DROPS: AtomicUsize = AtomicUsize::new(0);\n-\n-        struct D;\n-        impl Drop for D {\n-            fn drop(&mut self) {\n-                DROPS.fetch_add(1, SeqCst);\n-            }\n-        }\n-\n-        // Keys are multiples of 4, so that each key is counted by a hexadecimal digit.\n-        let mut map = (0..3).map(|i| (i * 4, D)).collect::<BTreeMap<_, _>>();\n+        let a = CrashTestDummy::new(0);\n+        let b = CrashTestDummy::new(1);\n+        let c = CrashTestDummy::new(2);\n+        let mut map = BTreeMap::new();\n+        map.insert(a.spawn(Panic::Never), ());\n+        map.insert(b.spawn(Panic::InQuery), ());\n+        map.insert(c.spawn(Panic::InQuery), ());\n \n         {\n-            let mut it = map.drain_filter(|i, _| {\n-                PREDS.fetch_add(1usize << i, SeqCst);\n-                match i {\n-                    0 => true,\n-                    _ => panic!(),\n-                }\n-            });\n+            let mut it = map.drain_filter(|dummy, _| dummy.query(true));\n             catch_unwind(AssertUnwindSafe(|| while it.next().is_some() {})).unwrap_err();\n             // Iterator behaviour after a panic is explicitly unspecified,\n             // so this is just the current implementation:\n             let result = catch_unwind(AssertUnwindSafe(|| it.next()));\n             assert!(matches!(result, Ok(None)));\n         }\n \n-        assert_eq!(PREDS.load(SeqCst), 0x011);\n-        assert_eq!(DROPS.load(SeqCst), 1);\n+        assert_eq!(a.queried(), 1);\n+        assert_eq!(b.queried(), 1);\n+        assert_eq!(c.queried(), 0);\n+        assert_eq!(a.dropped(), 1);\n+        assert_eq!(b.dropped(), 0);\n+        assert_eq!(c.dropped(), 0);\n         assert_eq!(map.len(), 2);\n-        assert_eq!(map.first_entry().unwrap().key(), &4);\n-        assert_eq!(map.last_entry().unwrap().key(), &8);\n+        assert_eq!(map.first_entry().unwrap().key().id(), 1);\n+        assert_eq!(map.last_entry().unwrap().key().id(), 2);\n         map.check();\n     }\n }\n@@ -1439,6 +1413,43 @@ fn test_bad_zst() {\n     m.check();\n }\n \n+#[test]\n+fn test_clear() {\n+    let mut map = BTreeMap::new();\n+    for &len in &[MIN_INSERTS_HEIGHT_1, MIN_INSERTS_HEIGHT_2, 0, NODE_CAPACITY] {\n+        for i in 0..len {\n+            map.insert(i, ());\n+        }\n+        assert_eq!(map.len(), len);\n+        map.clear();\n+        map.check();\n+        assert!(map.is_empty());\n+    }\n+}\n+\n+#[test]\n+fn test_clear_drop_panic_leak() {\n+    let a = CrashTestDummy::new(0);\n+    let b = CrashTestDummy::new(1);\n+    let c = CrashTestDummy::new(2);\n+\n+    let mut map = BTreeMap::new();\n+    map.insert(a.spawn(Panic::Never), ());\n+    map.insert(b.spawn(Panic::InDrop), ());\n+    map.insert(c.spawn(Panic::Never), ());\n+\n+    catch_unwind(AssertUnwindSafe(|| map.clear())).unwrap_err();\n+    assert_eq!(a.dropped(), 1);\n+    assert_eq!(b.dropped(), 1);\n+    assert_eq!(c.dropped(), 1);\n+    assert_eq!(map.len(), 0);\n+\n+    drop(map);\n+    assert_eq!(a.dropped(), 1);\n+    assert_eq!(b.dropped(), 1);\n+    assert_eq!(c.dropped(), 1);\n+}\n+\n #[test]\n fn test_clone() {\n     let mut map = BTreeMap::new();\n@@ -1484,6 +1495,35 @@ fn test_clone() {\n     map.check();\n }\n \n+#[test]\n+fn test_clone_panic_leak() {\n+    let a = CrashTestDummy::new(0);\n+    let b = CrashTestDummy::new(1);\n+    let c = CrashTestDummy::new(2);\n+\n+    let mut map = BTreeMap::new();\n+    map.insert(a.spawn(Panic::Never), ());\n+    map.insert(b.spawn(Panic::InClone), ());\n+    map.insert(c.spawn(Panic::Never), ());\n+\n+    catch_unwind(|| map.clone()).unwrap_err();\n+    assert_eq!(a.cloned(), 1);\n+    assert_eq!(b.cloned(), 1);\n+    assert_eq!(c.cloned(), 0);\n+    assert_eq!(a.dropped(), 1);\n+    assert_eq!(b.dropped(), 0);\n+    assert_eq!(c.dropped(), 0);\n+    assert_eq!(map.len(), 3);\n+\n+    drop(map);\n+    assert_eq!(a.cloned(), 1);\n+    assert_eq!(b.cloned(), 1);\n+    assert_eq!(c.cloned(), 0);\n+    assert_eq!(a.dropped(), 2);\n+    assert_eq!(b.dropped(), 1);\n+    assert_eq!(c.dropped(), 1);\n+}\n+\n #[test]\n fn test_clone_from() {\n     let mut map1 = BTreeMap::new();\n@@ -1901,29 +1941,21 @@ create_append_test!(test_append_1700, 1700);\n \n #[test]\n fn test_append_drop_leak() {\n-    static DROPS: AtomicUsize = AtomicUsize::new(0);\n-\n-    struct D;\n-\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            if DROPS.fetch_add(1, SeqCst) == 0 {\n-                panic!(\"panic in `drop`\");\n-            }\n-        }\n-    }\n-\n+    let a = CrashTestDummy::new(0);\n+    let b = CrashTestDummy::new(1);\n+    let c = CrashTestDummy::new(2);\n     let mut left = BTreeMap::new();\n     let mut right = BTreeMap::new();\n-    left.insert(0, D);\n-    left.insert(1, D); // first to be dropped during append\n-    left.insert(2, D);\n-    right.insert(1, D);\n-    right.insert(2, D);\n+    left.insert(a.spawn(Panic::Never), ());\n+    left.insert(b.spawn(Panic::InDrop), ()); // first duplicate key, dropped during append\n+    left.insert(c.spawn(Panic::Never), ());\n+    right.insert(b.spawn(Panic::Never), ());\n+    right.insert(c.spawn(Panic::Never), ());\n \n     catch_unwind(move || left.append(&mut right)).unwrap_err();\n-\n-    assert_eq!(DROPS.load(SeqCst), 4); // Rust issue #47949 ate one little piggy\n+    assert_eq!(a.dropped(), 1);\n+    assert_eq!(b.dropped(), 1); // should be 2 were it not for Rust issue #47949\n+    assert_eq!(c.dropped(), 2);\n }\n \n #[test]\n@@ -2050,51 +2082,42 @@ fn test_split_off_large_random_sorted() {\n \n #[test]\n fn test_into_iter_drop_leak_height_0() {\n-    static DROPS: AtomicUsize = AtomicUsize::new(0);\n-\n-    struct D;\n-\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            if DROPS.fetch_add(1, SeqCst) == 3 {\n-                panic!(\"panic in `drop`\");\n-            }\n-        }\n-    }\n-\n+    let a = CrashTestDummy::new(0);\n+    let b = CrashTestDummy::new(1);\n+    let c = CrashTestDummy::new(2);\n+    let d = CrashTestDummy::new(3);\n+    let e = CrashTestDummy::new(4);\n     let mut map = BTreeMap::new();\n-    map.insert(\"a\", D);\n-    map.insert(\"b\", D);\n-    map.insert(\"c\", D);\n-    map.insert(\"d\", D);\n-    map.insert(\"e\", D);\n+    map.insert(\"a\", a.spawn(Panic::Never));\n+    map.insert(\"b\", b.spawn(Panic::Never));\n+    map.insert(\"c\", c.spawn(Panic::Never));\n+    map.insert(\"d\", d.spawn(Panic::InDrop));\n+    map.insert(\"e\", e.spawn(Panic::Never));\n \n     catch_unwind(move || drop(map.into_iter())).unwrap_err();\n \n-    assert_eq!(DROPS.load(SeqCst), 5);\n+    assert_eq!(a.dropped(), 1);\n+    assert_eq!(b.dropped(), 1);\n+    assert_eq!(c.dropped(), 1);\n+    assert_eq!(d.dropped(), 1);\n+    assert_eq!(e.dropped(), 1);\n }\n \n #[test]\n fn test_into_iter_drop_leak_height_1() {\n     let size = MIN_INSERTS_HEIGHT_1;\n-    static DROPS: AtomicUsize = AtomicUsize::new(0);\n-    static PANIC_POINT: AtomicUsize = AtomicUsize::new(0);\n-\n-    struct D;\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            if DROPS.fetch_add(1, SeqCst) == PANIC_POINT.load(SeqCst) {\n-                panic!(\"panic in `drop`\");\n-            }\n-        }\n-    }\n-\n     for panic_point in vec![0, 1, size - 2, size - 1] {\n-        DROPS.store(0, SeqCst);\n-        PANIC_POINT.store(panic_point, SeqCst);\n-        let map: BTreeMap<_, _> = (0..size).map(|i| (i, D)).collect();\n+        let dummies: Vec<_> = (0..size).map(|i| CrashTestDummy::new(i)).collect();\n+        let map: BTreeMap<_, _> = (0..size)\n+            .map(|i| {\n+                let panic = if i == panic_point { Panic::InDrop } else { Panic::Never };\n+                (dummies[i].spawn(Panic::Never), dummies[i].spawn(panic))\n+            })\n+            .collect();\n         catch_unwind(move || drop(map.into_iter())).unwrap_err();\n-        assert_eq!(DROPS.load(SeqCst), size);\n+        for i in 0..size {\n+            assert_eq!(dummies[i].dropped(), 2);\n+        }\n     }\n }\n "}, {"sha": "421f842dab0acab48510fba28497f55482eb9899", "filename": "library/alloc/src/collections/btree/mod.rs", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3219a100fab579015d56411f5a50dcb7ff10f39d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3219a100fab579015d56411f5a50dcb7ff10f39d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs?ref=3219a100fab579015d56411f5a50dcb7ff10f39d", "patch": "@@ -20,32 +20,4 @@ trait Recover<Q: ?Sized> {\n }\n \n #[cfg(test)]\n-/// XorShiftRng\n-struct DeterministicRng {\n-    count: usize,\n-    x: u32,\n-    y: u32,\n-    z: u32,\n-    w: u32,\n-}\n-\n-#[cfg(test)]\n-impl DeterministicRng {\n-    fn new() -> Self {\n-        DeterministicRng { count: 0, x: 0x193a6754, y: 0xa8a7d469, z: 0x97830e05, w: 0x113ba7bb }\n-    }\n-\n-    /// Guarantees that each returned number is unique.\n-    fn next(&mut self) -> u32 {\n-        self.count += 1;\n-        assert!(self.count <= 70029);\n-        let x = self.x;\n-        let t = x ^ (x << 11);\n-        self.x = self.y;\n-        self.y = self.z;\n-        self.z = self.w;\n-        let w_ = self.w;\n-        self.w = w_ ^ (w_ >> 19) ^ (t ^ (t >> 8));\n-        self.w\n-    }\n-}\n+mod testing;"}, {"sha": "4cb6e3d6619dcb05ac25c1154f3151ee0b1a6343", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 32, "deletions": 57, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/3219a100fab579015d56411f5a50dcb7ff10f39d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3219a100fab579015d56411f5a50dcb7ff10f39d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=3219a100fab579015d56411f5a50dcb7ff10f39d", "patch": "@@ -1,10 +1,10 @@\n-use super::super::DeterministicRng;\n+use super::super::testing::crash_test::{CrashTestDummy, Panic};\n+use super::super::testing::rng::DeterministicRng;\n use super::*;\n use crate::vec::Vec;\n use std::cmp::Ordering;\n use std::iter::FromIterator;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n-use std::sync::atomic::{AtomicU32, Ordering::SeqCst};\n \n #[test]\n fn test_clone_eq() {\n@@ -349,70 +349,45 @@ fn test_drain_filter() {\n \n #[test]\n fn test_drain_filter_drop_panic_leak() {\n-    static PREDS: AtomicU32 = AtomicU32::new(0);\n-    static DROPS: AtomicU32 = AtomicU32::new(0);\n-\n-    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    struct D(i32);\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            if DROPS.fetch_add(1, SeqCst) == 1 {\n-                panic!(\"panic in `drop`\");\n-            }\n-        }\n-    }\n-\n+    let a = CrashTestDummy::new(0);\n+    let b = CrashTestDummy::new(1);\n+    let c = CrashTestDummy::new(2);\n     let mut set = BTreeSet::new();\n-    set.insert(D(0));\n-    set.insert(D(4));\n-    set.insert(D(8));\n+    set.insert(a.spawn(Panic::Never));\n+    set.insert(b.spawn(Panic::InDrop));\n+    set.insert(c.spawn(Panic::Never));\n \n-    catch_unwind(move || {\n-        drop(set.drain_filter(|d| {\n-            PREDS.fetch_add(1u32 << d.0, SeqCst);\n-            true\n-        }))\n-    })\n-    .ok();\n+    catch_unwind(move || drop(set.drain_filter(|dummy| dummy.query(true)))).ok();\n \n-    assert_eq!(PREDS.load(SeqCst), 0x011);\n-    assert_eq!(DROPS.load(SeqCst), 3);\n+    assert_eq!(a.queried(), 1);\n+    assert_eq!(b.queried(), 1);\n+    assert_eq!(c.queried(), 0);\n+    assert_eq!(a.dropped(), 1);\n+    assert_eq!(b.dropped(), 1);\n+    assert_eq!(c.dropped(), 1);\n }\n \n #[test]\n fn test_drain_filter_pred_panic_leak() {\n-    static PREDS: AtomicU32 = AtomicU32::new(0);\n-    static DROPS: AtomicU32 = AtomicU32::new(0);\n-\n-    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    struct D(i32);\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            DROPS.fetch_add(1, SeqCst);\n-        }\n-    }\n-\n+    let a = CrashTestDummy::new(0);\n+    let b = CrashTestDummy::new(1);\n+    let c = CrashTestDummy::new(2);\n     let mut set = BTreeSet::new();\n-    set.insert(D(0));\n-    set.insert(D(4));\n-    set.insert(D(8));\n-\n-    catch_unwind(AssertUnwindSafe(|| {\n-        drop(set.drain_filter(|d| {\n-            PREDS.fetch_add(1u32 << d.0, SeqCst);\n-            match d.0 {\n-                0 => true,\n-                _ => panic!(),\n-            }\n-        }))\n-    }))\n-    .ok();\n-\n-    assert_eq!(PREDS.load(SeqCst), 0x011);\n-    assert_eq!(DROPS.load(SeqCst), 1);\n+    set.insert(a.spawn(Panic::Never));\n+    set.insert(b.spawn(Panic::InQuery));\n+    set.insert(c.spawn(Panic::InQuery));\n+\n+    catch_unwind(AssertUnwindSafe(|| drop(set.drain_filter(|dummy| dummy.query(true))))).ok();\n+\n+    assert_eq!(a.queried(), 1);\n+    assert_eq!(b.queried(), 1);\n+    assert_eq!(c.queried(), 0);\n+    assert_eq!(a.dropped(), 1);\n+    assert_eq!(b.dropped(), 0);\n+    assert_eq!(c.dropped(), 0);\n     assert_eq!(set.len(), 2);\n-    assert_eq!(set.first().unwrap().0, 4);\n-    assert_eq!(set.last().unwrap().0, 8);\n+    assert_eq!(set.first().unwrap().id(), 1);\n+    assert_eq!(set.last().unwrap().id(), 2);\n }\n \n #[test]"}, {"sha": "b2527b95f5bba874009a7c5fdc8f82011c8805de", "filename": "library/alloc/src/collections/btree/testing/crash_test.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/3219a100fab579015d56411f5a50dcb7ff10f39d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Fcrash_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3219a100fab579015d56411f5a50dcb7ff10f39d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Fcrash_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Fcrash_test.rs?ref=3219a100fab579015d56411f5a50dcb7ff10f39d", "patch": "@@ -0,0 +1,119 @@\n+use crate::fmt::Debug;\n+use std::cmp::Ordering;\n+use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n+\n+/// A blueprint for crash test dummy instances that monitor particular events.\n+/// Some instances may be configured to panic at some point.\n+/// Events are `clone`, `drop` or some anonymous `query`.\n+///\n+/// Crash test dummies are identified and ordered by an id, so they can be used\n+/// as keys in a BTreeMap. The implementation intentionally uses does not rely\n+/// on anything defined in the crate, apart from the `Debug` trait.\n+#[derive(Debug)]\n+pub struct CrashTestDummy {\n+    id: usize,\n+    cloned: AtomicUsize,\n+    dropped: AtomicUsize,\n+    queried: AtomicUsize,\n+}\n+\n+impl CrashTestDummy {\n+    /// Creates a crash test dummy design. The `id` determines order and equality of instances.\n+    pub fn new(id: usize) -> CrashTestDummy {\n+        CrashTestDummy {\n+            id,\n+            cloned: AtomicUsize::new(0),\n+            dropped: AtomicUsize::new(0),\n+            queried: AtomicUsize::new(0),\n+        }\n+    }\n+\n+    /// Creates an instance of a crash test dummy that records what events it experiences\n+    /// and optionally panics.\n+    pub fn spawn(&self, panic: Panic) -> Instance<'_> {\n+        Instance { origin: self, panic }\n+    }\n+\n+    /// Returns how many times instances of the dummy have been cloned.\n+    pub fn cloned(&self) -> usize {\n+        self.cloned.load(SeqCst)\n+    }\n+\n+    /// Returns how many times instances of the dummy have been dropped.\n+    pub fn dropped(&self) -> usize {\n+        self.dropped.load(SeqCst)\n+    }\n+\n+    /// Returns how many times instances of the dummy have had their `query` member invoked.\n+    pub fn queried(&self) -> usize {\n+        self.queried.load(SeqCst)\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct Instance<'a> {\n+    origin: &'a CrashTestDummy,\n+    panic: Panic,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum Panic {\n+    Never,\n+    InClone,\n+    InDrop,\n+    InQuery,\n+}\n+\n+impl Instance<'_> {\n+    pub fn id(&self) -> usize {\n+        self.origin.id\n+    }\n+\n+    /// Some anonymous query, the result of which is already given.\n+    pub fn query<R>(&self, result: R) -> R {\n+        self.origin.queried.fetch_add(1, SeqCst);\n+        if self.panic == Panic::InQuery {\n+            panic!(\"panic in `query`\");\n+        }\n+        result\n+    }\n+}\n+\n+impl Clone for Instance<'_> {\n+    fn clone(&self) -> Self {\n+        self.origin.cloned.fetch_add(1, SeqCst);\n+        if self.panic == Panic::InClone {\n+            panic!(\"panic in `clone`\");\n+        }\n+        Self { origin: self.origin, panic: Panic::Never }\n+    }\n+}\n+\n+impl Drop for Instance<'_> {\n+    fn drop(&mut self) {\n+        self.origin.dropped.fetch_add(1, SeqCst);\n+        if self.panic == Panic::InDrop {\n+            panic!(\"panic in `drop`\");\n+        }\n+    }\n+}\n+\n+impl PartialOrd for Instance<'_> {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        self.id().partial_cmp(&other.id())\n+    }\n+}\n+\n+impl Ord for Instance<'_> {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.id().cmp(&other.id())\n+    }\n+}\n+\n+impl PartialEq for Instance<'_> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.id().eq(&other.id())\n+    }\n+}\n+\n+impl Eq for Instance<'_> {}"}, {"sha": "7a094f8a59522216ad1891e2beac432695737300", "filename": "library/alloc/src/collections/btree/testing/mod.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3219a100fab579015d56411f5a50dcb7ff10f39d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3219a100fab579015d56411f5a50dcb7ff10f39d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Fmod.rs?ref=3219a100fab579015d56411f5a50dcb7ff10f39d", "patch": "@@ -0,0 +1,3 @@\n+pub mod crash_test;\n+pub mod ord_chaos;\n+pub mod rng;"}, {"sha": "96ce7c15790463b3770285f6395859d64ea9afdc", "filename": "library/alloc/src/collections/btree/testing/ord_chaos.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3219a100fab579015d56411f5a50dcb7ff10f39d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Ford_chaos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3219a100fab579015d56411f5a50dcb7ff10f39d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Ford_chaos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Ford_chaos.rs?ref=3219a100fab579015d56411f5a50dcb7ff10f39d", "previous_filename": "library/alloc/src/collections/btree/map/tests/ord_chaos.rs"}, {"sha": "ecf543bee035a38a9adc7f08360c5c57876290c7", "filename": "library/alloc/src/collections/btree/testing/rng.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3219a100fab579015d56411f5a50dcb7ff10f39d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Frng.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3219a100fab579015d56411f5a50dcb7ff10f39d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Frng.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ftesting%2Frng.rs?ref=3219a100fab579015d56411f5a50dcb7ff10f39d", "patch": "@@ -0,0 +1,28 @@\n+/// XorShiftRng\n+pub struct DeterministicRng {\n+    count: usize,\n+    x: u32,\n+    y: u32,\n+    z: u32,\n+    w: u32,\n+}\n+\n+impl DeterministicRng {\n+    pub fn new() -> Self {\n+        DeterministicRng { count: 0, x: 0x193a6754, y: 0xa8a7d469, z: 0x97830e05, w: 0x113ba7bb }\n+    }\n+\n+    /// Guarantees that each returned number is unique.\n+    pub fn next(&mut self) -> u32 {\n+        self.count += 1;\n+        assert!(self.count <= 70029);\n+        let x = self.x;\n+        let t = x ^ (x << 11);\n+        self.x = self.y;\n+        self.y = self.z;\n+        self.z = self.w;\n+        let w_ = self.w;\n+        self.w = w_ ^ (w_ >> 19) ^ (t ^ (t >> 8));\n+        self.w\n+    }\n+}"}]}