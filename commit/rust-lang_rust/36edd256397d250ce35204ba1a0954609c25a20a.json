{"sha": "36edd256397d250ce35204ba1a0954609c25a20a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2ZWRkMjU2Mzk3ZDI1MGNlMzUyMDRiYTFhMDk1NDYwOWMyNWEyMGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-14T18:22:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-14T18:22:34Z"}, "message": "auto merge of #4925 : cpeterso/rust/docs-impl-trait-for-type, r=pcwalton\n\nReplace `impl Type: Trait` with `impl Trait for Type` throughout tutorial and manual.", "tree": {"sha": "ff38d4fc10444058bb6ef0c6353d070929923593", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff38d4fc10444058bb6ef0c6353d070929923593"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36edd256397d250ce35204ba1a0954609c25a20a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36edd256397d250ce35204ba1a0954609c25a20a", "html_url": "https://github.com/rust-lang/rust/commit/36edd256397d250ce35204ba1a0954609c25a20a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36edd256397d250ce35204ba1a0954609c25a20a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f06f68d634c0eb49dd5de851544898a689057eff", "url": "https://api.github.com/repos/rust-lang/rust/commits/f06f68d634c0eb49dd5de851544898a689057eff", "html_url": "https://github.com/rust-lang/rust/commit/f06f68d634c0eb49dd5de851544898a689057eff"}, {"sha": "5a4695d407b63faae33c37499dc3c9bac43dfaf8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a4695d407b63faae33c37499dc3c9bac43dfaf8", "html_url": "https://github.com/rust-lang/rust/commit/5a4695d407b63faae33c37499dc3c9bac43dfaf8"}], "stats": {"total": 57, "additions": 28, "deletions": 29}, "files": [{"sha": "30896307aeebf874d30bca6ba899ccaf7b0b6933", "filename": "doc/rust.md", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/36edd256397d250ce35204ba1a0954609c25a20a/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/36edd256397d250ce35204ba1a0954609c25a20a/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=36edd256397d250ce35204ba1a0954609c25a20a", "patch": "@@ -1209,7 +1209,7 @@ to pointers to the trait name, used as a type.\n \n ~~~~\n # trait Shape { }\n-# impl int: Shape { }\n+# impl Shape for int { }\n # let mycircle = 0;\n \n let myshape: Shape = @mycircle as @Shape;\n@@ -1233,7 +1233,7 @@ For example:\n trait Num {\n     static pure fn from_int(n: int) -> Self;\n }\n-impl float: Num {\n+impl Num for float {\n     static pure fn from_int(n: int) -> float { n as float }\n }\n let x: float = Num::from_int(42);\n@@ -1269,8 +1269,8 @@ Likewise, supertrait methods may also be called on trait objects.\n ~~~ {.xfail-test}\n # trait Shape { fn area() -> float; }\n # trait Circle : Shape { fn radius() -> float; }\n-# impl int: Shape { fn area() -> float { 0.0 } }\n-# impl int: Circle { fn radius() -> float { 0.0 } }\n+# impl Shape for int { fn area() -> float { 0.0 } }\n+# impl Circle for int { fn radius() -> float { 0.0 } }\n # let mycircle = 0;\n \n let mycircle: Circle = @mycircle as @Circle;\n@@ -1292,7 +1292,7 @@ Implementations are defined with the keyword `impl`.\n \n type Circle = {radius: float, center: Point};\n \n-impl Circle: Shape {\n+impl Shape for Circle {\n     fn draw(s: Surface) { do_draw_circle(s, self); }\n     fn bounding_box() -> BoundingBox {\n         let r = self.radius;\n@@ -1303,9 +1303,9 @@ impl Circle: Shape {\n ~~~~\n \n It is possible to define an implementation without referring to a trait.\n-The methods in such an implementation can only be used statically\n-(as direct calls on the values of the type that the implementation targets).\n-In such an implementation, the type after the colon is omitted.\n+The methods in such an implementation can only be used\n+as direct calls on the values of the type that the implementation targets.\n+In such an implementation, the trait type and `for` after `impl` are omitted.\n Such implementations are limited to nominal types (enums, structs),\n and the implementation must appear in the same module or a sub-module as the `self` type.\n \n@@ -1320,10 +1320,10 @@ Implementation parameters are written after after the `impl` keyword.\n ~~~~\n # trait Seq<T> { }\n \n-impl<T> ~[T]: Seq<T> {\n+impl<T> Seq<T> for ~[T] {\n    ...\n }\n-impl u32: Seq<bool> {\n+impl Seq<bool> for u32 {\n    /* Treat the integer as a sequence of bits */\n }\n ~~~~\n@@ -2801,7 +2801,7 @@ trait Printable {\n   fn to_str() -> ~str;\n }\n \n-impl int: Printable {\n+impl Printable for int {\n   fn to_str() -> ~str { int::to_str(self) }\n }\n \n@@ -2844,7 +2844,7 @@ trait Printable {\n   fn make_string() -> ~str;\n }\n \n-impl ~str: Printable {\n+impl Printable for ~str {\n   fn make_string() -> ~str { copy self }\n }\n ~~~~~~~~"}, {"sha": "a825b7f535f727e254faf6ee149987025118ebc9", "filename": "doc/tutorial.md", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/36edd256397d250ce35204ba1a0954609c25a20a/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/36edd256397d250ce35204ba1a0954609c25a20a/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=36edd256397d250ce35204ba1a0954609c25a20a", "patch": "@@ -1909,7 +1909,7 @@ struct TimeBomb {\n     explosivity: uint\n }\n \n-impl TimeBomb : Drop {\n+impl Drop for TimeBomb {\n     fn finalize(&self) {\n         for iter::repeat(self.explosivity) {\n             io::println(\"blam!\");\n@@ -1943,11 +1943,11 @@ and `&str`.\n \n ~~~~\n # trait Printable { fn print(&self); }\n-impl int: Printable {\n+impl Printable for int {\n     fn print(&self) { io::println(fmt!(\"%d\", *self)) }\n }\n \n-impl &str: Printable {\n+impl Printable for &str {\n     fn print(&self) { io::println(*self) }\n }\n \n@@ -1966,7 +1966,7 @@ trait Seq<T> {\n     fn iter(&self, b: fn(v: &T));\n }\n \n-impl<T> ~[T]: Seq<T> {\n+impl<T> Seq<T> for ~[T] {\n     fn len(&self) -> uint { vec::len(*self) }\n     fn iter(&self, b: fn(v: &T)) {\n         for vec::each(*self) |elt| { b(elt); }\n@@ -1978,7 +1978,7 @@ The implementation has to explicitly declare the type parameter that\n it binds, `T`, before using it to specify its trait type. Rust\n requires this declaration because the `impl` could also, for example,\n specify an implementation of `Seq<int>`. The trait type (appearing\n-after the colon in the `impl`) *refers* to a type, rather than\n+between `impl` and `for`) *refers* to a type, rather than\n defining one.\n \n The type parameters bound by a trait are in scope in each of the\n@@ -2000,7 +2000,7 @@ trait Eq {\n }\n \n // In an impl, `self` refers just to the value of the receiver\n-impl int: Eq {\n+impl Eq for int {\n     fn equals(&self, other: &int) -> bool { *other == *self }\n }\n ~~~~\n@@ -2021,10 +2021,10 @@ trait Shape { static fn new(area: float) -> Self; }\n struct Circle { radius: float }\n struct Square { length: float }\n \n-impl Circle: Shape {\n+impl Shape for Circle {\n     static fn new(area: float) -> Circle { Circle { radius: sqrt(area / pi) } }\n }\n-impl Square: Shape {\n+impl Shape for Square {\n     static fn new(area: float) -> Square { Square { length: sqrt(area) } }\n }\n \n@@ -2084,7 +2084,7 @@ However, consider this function:\n \n ~~~~\n # type Circle = int; type Rectangle = int;\n-# impl int: Drawable { fn draw(&self) {} }\n+# impl Drawable for int { fn draw(&self) {} }\n # fn new_circle() -> int { 1 }\n trait Drawable { fn draw(&self); }\n \n@@ -2120,9 +2120,8 @@ value to an object:\n # fn new_rectangle() -> Rectangle { true }\n # fn draw_all(shapes: &[@Drawable]) {}\n \n-impl Circle: Drawable { fn draw(&self) { ... } }\n-\n-impl Rectangle: Drawable { fn draw(&self) { ... } }\n+impl Drawable for Circle { fn draw(&self) { ... } }\n+impl Drawable for Rectangle { fn draw(&self) { ... } }\n \n let c: @Circle = @new_circle();\n let r: @Rectangle = @new_rectangle();\n@@ -2140,7 +2139,7 @@ for example, an `@Circle` may not be cast to an `~Drawable`.\n ~~~\n # type Circle = int; type Rectangle = int;\n # trait Drawable { fn draw(&self); }\n-# impl int: Drawable { fn draw(&self) {} }\n+# impl Drawable for int { fn draw(&self) {} }\n # fn new_circle() -> int { 1 }\n # fn new_rectangle() -> int { 2 }\n // A managed object\n@@ -2180,10 +2179,10 @@ Now, we can implement `Circle` on a type only if we also implement `Shape`.\n # use float::sqrt;\n # fn square(x: float) -> float { x * x }\n struct CircleStruct { center: Point, radius: float }\n-impl CircleStruct: Circle {\n+impl Circle for CircleStruct {\n     fn radius(&self) -> float { sqrt(self.area() / pi) }\n }\n-impl CircleStruct: Shape {\n+impl Shape for CircleStruct {\n     fn area(&self) -> float { pi * square(self.radius) }\n }   \n ~~~~\n@@ -2215,8 +2214,8 @@ Likewise, supertrait methods may also be called on trait objects.\n # use float::sqrt;\n # struct Point { x: float, y: float }\n # struct CircleStruct { center: Point, radius: float }\n-# impl CircleStruct: Circle { fn radius(&self) -> float { sqrt(self.area() / pi) } }\n-# impl CircleStruct: Shape { fn area(&self) -> float { pi * square(self.radius) } }\n+# impl Circle for CircleStruct { fn radius(&self) -> float { sqrt(self.area() / pi) } }\n+# impl Shape for CircleStruct { fn area(&self) -> float { pi * square(self.radius) } }\n \n let concrete = @CircleStruct{center:Point{x:3f,y:4f},radius:5f};\n let mycircle: Circle = concrete as @Circle;"}]}