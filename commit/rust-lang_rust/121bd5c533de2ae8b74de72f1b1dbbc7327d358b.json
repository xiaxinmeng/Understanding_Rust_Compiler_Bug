{"sha": "121bd5c533de2ae8b74de72f1b1dbbc7327d358b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyMWJkNWM1MzNkZTJhZThiNzRkZTcyZjFiMWRiYmM3MzI3ZDM1OGI=", "commit": {"author": {"name": "Lukas Tobias Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-03T19:34:34Z"}, "committer": {"name": "Lukas Tobias Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-03T19:34:34Z"}, "message": "Make CompletionContext expected_type smarter", "tree": {"sha": "431f6699b92b14c5363543fac3da15a24ea20ac2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/431f6699b92b14c5363543fac3da15a24ea20ac2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/121bd5c533de2ae8b74de72f1b1dbbc7327d358b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/121bd5c533de2ae8b74de72f1b1dbbc7327d358b", "html_url": "https://github.com/rust-lang/rust/commit/121bd5c533de2ae8b74de72f1b1dbbc7327d358b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/121bd5c533de2ae8b74de72f1b1dbbc7327d358b/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "544a93ee0815697ff42b79e54d1a7a5a743de1f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/544a93ee0815697ff42b79e54d1a7a5a743de1f9", "html_url": "https://github.com/rust-lang/rust/commit/544a93ee0815697ff42b79e54d1a7a5a743de1f9"}], "stats": {"total": 230, "additions": 113, "deletions": 117}, "files": [{"sha": "d8f23d1eba2f7a5f2013f2a75f709be640ae76f5", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/121bd5c533de2ae8b74de72f1b1dbbc7327d358b/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/121bd5c533de2ae8b74de72f1b1dbbc7327d358b/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=121bd5c533de2ae8b74de72f1b1dbbc7327d358b", "patch": "@@ -736,28 +736,6 @@ fn f() {}\n         );\n     }\n \n-    #[test]\n-    fn completes_function() {\n-        check(\n-            r#\"\n-fn foo(\n-    a: i32,\n-    b: i32\n-) {\n-\n-}\n-\n-fn main() {\n-    fo$0\n-}\n-\"#,\n-            expect![[r#\"\n-                fn main() fn()\n-                fn foo(\u2026) fn(i32, i32)\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn completes_self_enum() {\n         check("}, {"sha": "f3fcb712c7ea167511c0f2cd6dbffdb4738ecf13", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 113, "deletions": 95, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/121bd5c533de2ae8b74de72f1b1dbbc7327d358b/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/121bd5c533de2ae8b74de72f1b1dbbc7327d358b/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=121bd5c533de2ae8b74de72f1b1dbbc7327d358b", "patch": "@@ -301,103 +301,108 @@ impl<'a> CompletionContext<'a> {\n             .find_map(ast::Impl::cast);\n     }\n \n+    fn expected_type_and_name(&self) -> (Option<Type>, Option<NameOrNameRef>) {\n+        let mut node = match self.token.parent() {\n+            Some(it) => it,\n+            None => return (None, None),\n+        };\n+        loop {\n+            break match_ast! {\n+                match node {\n+                    ast::LetStmt(it) => {\n+                        cov_mark::hit!(expected_type_let_with_leading_char);\n+                        cov_mark::hit!(expected_type_let_without_leading_char);\n+                        let ty = it.pat()\n+                            .and_then(|pat| self.sema.type_of_pat(&pat));\n+                        let name = if let Some(ast::Pat::IdentPat(ident)) = it.pat() {\n+                            ident.name().map(NameOrNameRef::Name)\n+                        } else {\n+                            None\n+                        };\n+\n+                        (ty, name)\n+                    },\n+                    ast::ArgList(_it) => {\n+                        cov_mark::hit!(expected_type_fn_param_with_leading_char);\n+                        cov_mark::hit!(expected_type_fn_param_without_leading_char);\n+                        ActiveParameter::at_token(\n+                            &self.sema,\n+                            self.token.clone(),\n+                        ).map(|ap| {\n+                            let name = ap.ident().map(NameOrNameRef::Name);\n+                            (Some(ap.ty), name)\n+                        })\n+                        .unwrap_or((None, None))\n+                    },\n+                    ast::RecordExprFieldList(_it) => {\n+                        cov_mark::hit!(expected_type_struct_field_without_leading_char);\n+                        self.token.prev_sibling_or_token()\n+                            .and_then(|se| se.into_node())\n+                            .and_then(|node| ast::RecordExprField::cast(node))\n+                            .and_then(|rf| self.sema.resolve_record_field(&rf).zip(Some(rf)))\n+                            .map(|(f, rf)|(\n+                                Some(f.0.ty(self.db)),\n+                                rf.field_name().map(NameOrNameRef::NameRef),\n+                            ))\n+                            .unwrap_or((None, None))\n+                    },\n+                    ast::RecordExprField(it) => {\n+                        cov_mark::hit!(expected_type_struct_field_with_leading_char);\n+                        self.sema\n+                            .resolve_record_field(&it)\n+                            .map(|f|(\n+                                Some(f.0.ty(self.db)),\n+                                it.field_name().map(NameOrNameRef::NameRef),\n+                            ))\n+                            .unwrap_or((None, None))\n+                    },\n+                    ast::MatchExpr(it) => {\n+                        cov_mark::hit!(expected_type_match_arm_without_leading_char);\n+                        let ty = it.expr()\n+                            .and_then(|e| self.sema.type_of_expr(&e));\n+                        (ty, None)\n+                    },\n+                    ast::IfExpr(it) => {\n+                        cov_mark::hit!(expected_type_if_let_without_leading_char);\n+                        let ty = it.condition()\n+                            .and_then(|cond| cond.expr())\n+                            .and_then(|e| self.sema.type_of_expr(&e));\n+                        (ty, None)\n+                    },\n+                    ast::IdentPat(it) => {\n+                        cov_mark::hit!(expected_type_if_let_with_leading_char);\n+                        cov_mark::hit!(expected_type_match_arm_with_leading_char);\n+                        let ty = self.sema.type_of_pat(&ast::Pat::from(it));\n+                        (ty, None)\n+                    },\n+                    ast::Fn(it) => {\n+                        cov_mark::hit!(expected_type_fn_ret_with_leading_char);\n+                        cov_mark::hit!(expected_type_fn_ret_without_leading_char);\n+                        let def = self.sema.to_def(&it);\n+                        (def.map(|def| def.ret_type(self.db)), None)\n+                    },\n+                    ast::Stmt(it) => (None, None),\n+                    _ => {\n+                        match node.parent() {\n+                            Some(n) => {\n+                                node = n;\n+                                continue;\n+                            },\n+                            None => (None, None),\n+                        }\n+                    },\n+                }\n+            };\n+        }\n+    }\n+\n     fn fill(\n         &mut self,\n         original_file: &SyntaxNode,\n         file_with_fake_ident: SyntaxNode,\n         offset: TextSize,\n     ) {\n-        let (expected_type, expected_name) = {\n-            let mut node = match self.token.parent() {\n-                Some(it) => it,\n-                None => return,\n-            };\n-            loop {\n-                break match_ast! {\n-                    match node {\n-                        ast::LetStmt(it) => {\n-                            cov_mark::hit!(expected_type_let_with_leading_char);\n-                            cov_mark::hit!(expected_type_let_without_leading_char);\n-                            let ty = it.pat()\n-                                .and_then(|pat| self.sema.type_of_pat(&pat));\n-                            let name = if let Some(ast::Pat::IdentPat(ident)) = it.pat() {\n-                                ident.name().map(NameOrNameRef::Name)\n-                            } else {\n-                                None\n-                            };\n-\n-                            (ty, name)\n-                        },\n-                        ast::ArgList(_it) => {\n-                            cov_mark::hit!(expected_type_fn_param_with_leading_char);\n-                            cov_mark::hit!(expected_type_fn_param_without_leading_char);\n-                            ActiveParameter::at_token(\n-                                &self.sema,\n-                                self.token.clone(),\n-                            ).map(|ap| {\n-                                let name = ap.ident().map(NameOrNameRef::Name);\n-                                (Some(ap.ty), name)\n-                            })\n-                            .unwrap_or((None, None))\n-                        },\n-                        ast::RecordExprFieldList(_it) => {\n-                            cov_mark::hit!(expected_type_struct_field_without_leading_char);\n-                            self.token.prev_sibling_or_token()\n-                                .and_then(|se| se.into_node())\n-                                .and_then(|node| ast::RecordExprField::cast(node))\n-                                .and_then(|rf| self.sema.resolve_record_field(&rf).zip(Some(rf)))\n-                                .map(|(f, rf)|(\n-                                    Some(f.0.ty(self.db)),\n-                                    rf.field_name().map(NameOrNameRef::NameRef),\n-                                ))\n-                                .unwrap_or((None, None))\n-                        },\n-                        ast::RecordExprField(it) => {\n-                            cov_mark::hit!(expected_type_struct_field_with_leading_char);\n-                            self.sema\n-                                .resolve_record_field(&it)\n-                                .map(|f|(\n-                                    Some(f.0.ty(self.db)),\n-                                    it.field_name().map(NameOrNameRef::NameRef),\n-                                ))\n-                                .unwrap_or((None, None))\n-                        },\n-                        ast::MatchExpr(it) => {\n-                            cov_mark::hit!(expected_type_match_arm_without_leading_char);\n-                            let ty = it.expr()\n-                                .and_then(|e| self.sema.type_of_expr(&e));\n-\n-                            (ty, None)\n-                        },\n-                        ast::IdentPat(it) => {\n-                            cov_mark::hit!(expected_type_if_let_with_leading_char);\n-                            cov_mark::hit!(expected_type_match_arm_with_leading_char);\n-                            let ty = self.sema.type_of_pat(&ast::Pat::from(it));\n-\n-                            (ty, None)\n-                        },\n-                        ast::Fn(_it) => {\n-                            cov_mark::hit!(expected_type_fn_ret_with_leading_char);\n-                            cov_mark::hit!(expected_type_fn_ret_without_leading_char);\n-                            let ty = self.token.ancestors()\n-                                .find_map(|ancestor| ast::Expr::cast(ancestor))\n-                                .and_then(|expr| self.sema.type_of_expr(&expr));\n-\n-                            (ty, None)\n-                        },\n-                        _ => {\n-                            match node.parent() {\n-                                Some(n) => {\n-                                    node = n;\n-                                    continue;\n-                                },\n-                                None => (None, None),\n-                            }\n-                        },\n-                    }\n-                };\n-            }\n-        };\n+        let (expected_type, expected_name) = self.expected_type_and_name();\n         self.expected_type = expected_type;\n         self.expected_name = expected_name;\n         self.attribute_under_caret = find_node_at_offset(&file_with_fake_ident, offset);\n@@ -802,6 +807,7 @@ fn foo() {\n \n     #[test]\n     fn expected_type_if_let_without_leading_char() {\n+        cov_mark::check!(expected_type_if_let_without_leading_char);\n         check_expected_type_and_name(\n             r#\"\n enum Foo { Bar, Baz, Quux }\n@@ -811,8 +817,8 @@ fn foo() {\n     if let $0 = f { }\n }\n \"#,\n-            expect![[r#\"ty: (), name: ?\"#]],\n-        ) // FIXME should be `ty: u32, name: ?`\n+            expect![[r#\"ty: Foo, name: ?\"#]],\n+        )\n     }\n \n     #[test]\n@@ -840,8 +846,8 @@ fn foo() -> u32 {\n     $0\n }\n \"#,\n-            expect![[r#\"ty: (), name: ?\"#]],\n-        ) // FIXME this should be `ty: u32, name: ?`\n+            expect![[r#\"ty: u32, name: ?\"#]],\n+        )\n     }\n \n     #[test]\n@@ -852,6 +858,18 @@ fn foo() -> u32 {\n fn foo() -> u32 {\n     c$0\n }\n+\"#,\n+            expect![[r#\"ty: u32, name: ?\"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn expected_type_fn_ret_fn_ref_fully_typed() {\n+        check_expected_type_and_name(\n+            r#\"\n+fn foo() -> u32 {\n+    foo$0\n+}\n \"#,\n             expect![[r#\"ty: u32, name: ?\"#]],\n         )"}]}