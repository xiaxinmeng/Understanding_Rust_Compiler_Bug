{"sha": "c610be92e2925ab8e789efc835c88247e46c6cbf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2MTBiZTkyZTI5MjVhYjhlNzg5ZWZjODM1Yzg4MjQ3ZTQ2YzZjYmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-04T23:10:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-04T23:10:15Z"}, "message": "Auto merge of #51307 - oli-obk:miri_fixes, r=eddyb\n\nScalarPairs are offset==0 field + other non-zst field\n\nr? @eddyb\n\nfixes #51300", "tree": {"sha": "7fa9f1ef703c6c6d0079255a487c5ef2c6f06a8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fa9f1ef703c6c6d0079255a487c5ef2c6f06a8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c610be92e2925ab8e789efc835c88247e46c6cbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c610be92e2925ab8e789efc835c88247e46c6cbf", "html_url": "https://github.com/rust-lang/rust/commit/c610be92e2925ab8e789efc835c88247e46c6cbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c610be92e2925ab8e789efc835c88247e46c6cbf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41affd03eb169830773cd1b11efda562ab81fad0", "url": "https://api.github.com/repos/rust-lang/rust/commits/41affd03eb169830773cd1b11efda562ab81fad0", "html_url": "https://github.com/rust-lang/rust/commit/41affd03eb169830773cd1b11efda562ab81fad0"}, {"sha": "f7eedfab8e03ece5ebaf265f4c7255a8f69c98fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7eedfab8e03ece5ebaf265f4c7255a8f69c98fc", "html_url": "https://github.com/rust-lang/rust/commit/f7eedfab8e03ece5ebaf265f4c7255a8f69c98fc"}], "stats": {"total": 172, "additions": 82, "deletions": 90}, "files": [{"sha": "51b33fa54b249e517d44f2674b704d66ddb42ab8", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c610be92e2925ab8e789efc835c88247e46c6cbf/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c610be92e2925ab8e789efc835c88247e46c6cbf/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=c610be92e2925ab8e789efc835c88247e46c6cbf", "patch": "@@ -120,29 +120,42 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         variant: Option<usize>,\n         field: mir::Field,\n         base_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(Value, Ty<'tcx>)>> {\n+    ) -> EvalResult<'tcx, ValTy<'tcx>> {\n         let mut base_layout = self.layout_of(base_ty)?;\n         if let Some(variant_index) = variant {\n             base_layout = base_layout.for_variant(self, variant_index);\n         }\n         let field_index = field.index();\n         let field = base_layout.field(self, field_index)?;\n         if field.size.bytes() == 0 {\n-            return Ok(Some((Value::Scalar(Scalar::undef()), field.ty)))\n+            return Ok(ValTy {\n+                value: Value::Scalar(Scalar::undef()),\n+                ty: field.ty,\n+            });\n         }\n         let offset = base_layout.fields.offset(field_index);\n-        match base {\n+        let value = match base {\n             // the field covers the entire type\n             Value::ScalarPair(..) |\n-            Value::Scalar(_) if offset.bytes() == 0 && field.size == base_layout.size => Ok(Some((base, field.ty))),\n-            // split fat pointers, 2 element tuples, ...\n-            Value::ScalarPair(a, b) if base_layout.fields.count() == 2 => {\n-                let val = [a, b][field_index];\n-                Ok(Some((Value::Scalar(val), field.ty)))\n+            Value::Scalar(_) if offset.bytes() == 0 && field.size == base_layout.size => base,\n+            // extract fields from types with `ScalarPair` ABI\n+            Value::ScalarPair(a, b) => {\n+                let val = if offset.bytes() == 0 { a } else { b };\n+                Value::Scalar(val)\n             },\n-            // FIXME(oli-obk): figure out whether we should be calling `try_read_value` here\n-            _ => Ok(None),\n-        }\n+            Value::ByRef(base_ptr, align) => {\n+                let offset = base_layout.fields.offset(field_index);\n+                let ptr = base_ptr.ptr_offset(offset, self)?;\n+                let align = align.min(base_layout.align).min(field.align);\n+                assert!(!field.is_unsized());\n+                Value::ByRef(ptr, align)\n+            },\n+            Value::Scalar(val) => bug!(\"field access on non aggregate {:?}, {:?}\", val, base_ty),\n+        };\n+        Ok(ValTy {\n+            value,\n+            ty: field.ty,\n+        })\n     }\n \n     fn try_read_place_projection(\n@@ -156,7 +169,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         };\n         let base_ty = self.place_ty(&proj.base);\n         match proj.elem {\n-            Field(field, _) => Ok(self.read_field(base, None, field, base_ty)?.map(|(f, _)| f)),\n+            Field(field, _) => Ok(Some(self.read_field(base, None, field, base_ty)?.value)),\n             // The NullablePointer cases should work fine, need to take care for normal enums\n             Downcast(..) |\n             Subslice { .. } |"}, {"sha": "2994b1b387f3fa37c2e47a3621246da76bfbaef9", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 11, "deletions": 59, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/c610be92e2925ab8e789efc835c88247e46c6cbf/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c610be92e2925ab8e789efc835c88247e46c6cbf/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=c610be92e2925ab8e789efc835c88247e46c6cbf", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::layout::LayoutOf;\n use syntax::codemap::Span;\n use rustc_target::spec::abi::Abi;\n \n-use rustc::mir::interpret::{EvalResult, Scalar, Value};\n+use rustc::mir::interpret::EvalResult;\n use super::{EvalContext, Place, Machine, ValTy};\n \n use rustc_data_structures::indexed_vec::Idx;\n@@ -338,65 +338,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n                         // unpack and write all other args\n                         let layout = self.layout_of(args[1].ty)?;\n-                        if let ty::TyTuple(..) = args[1].ty.sty {\n+                        if let ty::TyTuple(_) = args[1].ty.sty {\n+                            if layout.is_zst() {\n+                                // Nothing to do, no need to unpack zsts\n+                                return Ok(());\n+                            }\n                             if self.frame().mir.args_iter().count() == layout.fields.count() + 1 {\n-                                match args[1].value {\n-                                    Value::ByRef(ptr, align) => {\n-                                        for (i, arg_local) in arg_locals.enumerate() {\n-                                            let field = layout.field(&self, i)?;\n-                                            let offset = layout.fields.offset(i);\n-                                            let arg = Value::ByRef(ptr.ptr_offset(offset, &self)?,\n-                                                                   align.min(field.align));\n-                                            let dest =\n-                                                self.eval_place(&mir::Place::Local(arg_local))?;\n-                                            trace!(\n-                                                \"writing arg {:?} to {:?} (type: {})\",\n-                                                arg,\n-                                                dest,\n-                                                field.ty\n-                                            );\n-                                            let valty = ValTy {\n-                                                value: arg,\n-                                                ty: field.ty,\n-                                            };\n-                                            self.write_value(valty, dest)?;\n-                                        }\n-                                    }\n-                                    Value::Scalar(Scalar::Bits { defined: 0, .. }) => {}\n-                                    other => {\n-                                        trace!(\"{:#?}, {:#?}\", other, layout);\n-                                        let mut layout = layout;\n-                                        'outer: loop {\n-                                            for i in 0..layout.fields.count() {\n-                                                let field = layout.field(&self, i)?;\n-                                                if layout.fields.offset(i).bytes() == 0 && layout.size == field.size {\n-                                                    layout = field;\n-                                                    continue 'outer;\n-                                                }\n-                                            }\n-                                            break;\n-                                        }\n-                                        {\n-                                            let mut write_next = |value| {\n-                                                let dest = self.eval_place(&mir::Place::Local(\n-                                                    arg_locals.next().unwrap(),\n-                                                ))?;\n-                                                let valty = ValTy {\n-                                                    value: Value::Scalar(value),\n-                                                    ty: layout.ty,\n-                                                };\n-                                                self.write_value(valty, dest)\n-                                            };\n-                                            match other {\n-                                                Value::Scalar(value) | Value::ScalarPair(value, _) => write_next(value)?,\n-                                                _ => unreachable!(),\n-                                            }\n-                                            if let Value::ScalarPair(_, value) = other {\n-                                                write_next(value)?;\n-                                            }\n-                                        }\n-                                        assert!(arg_locals.next().is_none());\n-                                    }\n+                                for (i, arg_local) in arg_locals.enumerate() {\n+                                    let field = mir::Field::new(i);\n+                                    let valty = self.read_field(args[1].value, None, field, args[1].ty)?;\n+                                    let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n+                                    self.write_value(valty, dest)?;\n                                 }\n                             } else {\n                                 trace!(\"manual impl of rust-call ABI\");"}, {"sha": "40a6610c4173caab16c2f96816f9e4e68748640a", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c610be92e2925ab8e789efc835c88247e46c6cbf/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c610be92e2925ab8e789efc835c88247e46c6cbf/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=c610be92e2925ab8e789efc835c88247e46c6cbf", "patch": "@@ -29,7 +29,7 @@ use rustc::ty::subst::Substs;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::ty::ParamEnv;\n use rustc::ty::layout::{\n-    LayoutOf, TyLayout, LayoutError, LayoutCx,\n+    LayoutOf, TyLayout, LayoutError,\n     HasTyCtxt, TargetDataLayout, HasDataLayout,\n };\n \n@@ -214,24 +214,10 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 ProjectionElem::Field(field, _) => {\n                     trace!(\"field proj on {:?}\", proj.base);\n                     let (base, ty, span) = self.eval_place(&proj.base)?;\n-                    match base {\n-                        Value::ScalarPair(a, b) => {\n-                            trace!(\"by val pair: {:?}, {:?}\", a, b);\n-                            let base_layout = self.tcx.layout_of(self.param_env.and(ty)).ok()?;\n-                            trace!(\"layout computed\");\n-                            use rustc_data_structures::indexed_vec::Idx;\n-                            let field_index = field.index();\n-                            let val = [a, b][field_index];\n-                            let cx = LayoutCx {\n-                                tcx: self.tcx,\n-                                param_env: self.param_env,\n-                            };\n-                            let field = base_layout.field(cx, field_index).ok()?;\n-                            trace!(\"projection resulted in: {:?}\", val);\n-                            Some((Value::Scalar(val), field.ty, span))\n-                        },\n-                        _ => None,\n-                    }\n+                    let valty = self.use_ecx(span, |this| {\n+                        this.ecx.read_field(base, None, field, ty)\n+                    })?;\n+                    Some((valty.value, valty.ty, span))\n                 },\n                 _ => None,\n             },"}, {"sha": "f91711c3c0f242c64321ed3af4876c629a0b5b31", "filename": "src/test/ui/const-eval/issue-51300.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c610be92e2925ab8e789efc835c88247e46c6cbf/src%2Ftest%2Fui%2Fconst-eval%2Fissue-51300.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c610be92e2925ab8e789efc835c88247e46c6cbf/src%2Ftest%2Fui%2Fconst-eval%2Fissue-51300.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fissue-51300.rs?ref=c610be92e2925ab8e789efc835c88247e46c6cbf", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+// https://github.com/rust-lang/rust/issues/51300\n+\n+#[derive(PartialEq, Eq, Clone, Copy)]\n+pub struct Stat {\n+    pub id: u8,\n+    pub index: usize,\n+}\n+\n+impl Stat {\n+    pub const STUDENT_HAPPINESS: Stat = Stat{\n+        id: 0,\n+        index: 0,\n+    };\n+    pub const STUDENT_HUNGER: Stat = Stat{\n+        id: 0,\n+        index: Self::STUDENT_HAPPINESS.index + 1,\n+    };\n+\n+}\n+\n+pub fn from_index(id: u8, index: usize) -> Option<Stat> {\n+    let stat = Stat{id, index};\n+    match stat {\n+        Stat::STUDENT_HAPPINESS => Some(Stat::STUDENT_HAPPINESS),\n+        Stat::STUDENT_HUNGER => Some(Stat::STUDENT_HUNGER),\n+        _ => None,\n+    }\n+}\n+\n+fn main() { }"}]}