{"sha": "e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzYjdmZWRjMjBmY2ZlNTRlMGRkYjI4NWZjNmU2YzZlODYyYjMyNzk=", "commit": {"author": {"name": "Joseph Crail", "email": "jbcrail@gmail.com", "date": "2015-01-07T01:53:18Z"}, "committer": {"name": "Joseph Crail", "email": "jbcrail@gmail.com", "date": "2015-01-07T01:53:18Z"}, "message": "Fix misspelled comments.\n\nI cleaned up comments prior to the 1.0 alpha release.", "tree": {"sha": "ca1ece110a6f8dc31f5c30b595687829c08f5e82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca1ece110a6f8dc31f5c30b595687829c08f5e82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "html_url": "https://github.com/rust-lang/rust/commit/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/comments", "author": {"login": "jbcrail", "id": 6038, "node_id": "MDQ6VXNlcjYwMzg=", "avatar_url": "https://avatars.githubusercontent.com/u/6038?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbcrail", "html_url": "https://github.com/jbcrail", "followers_url": "https://api.github.com/users/jbcrail/followers", "following_url": "https://api.github.com/users/jbcrail/following{/other_user}", "gists_url": "https://api.github.com/users/jbcrail/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbcrail/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbcrail/subscriptions", "organizations_url": "https://api.github.com/users/jbcrail/orgs", "repos_url": "https://api.github.com/users/jbcrail/repos", "events_url": "https://api.github.com/users/jbcrail/events{/privacy}", "received_events_url": "https://api.github.com/users/jbcrail/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbcrail", "id": 6038, "node_id": "MDQ6VXNlcjYwMzg=", "avatar_url": "https://avatars.githubusercontent.com/u/6038?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbcrail", "html_url": "https://github.com/jbcrail", "followers_url": "https://api.github.com/users/jbcrail/followers", "following_url": "https://api.github.com/users/jbcrail/following{/other_user}", "gists_url": "https://api.github.com/users/jbcrail/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbcrail/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbcrail/subscriptions", "organizations_url": "https://api.github.com/users/jbcrail/orgs", "repos_url": "https://api.github.com/users/jbcrail/repos", "events_url": "https://api.github.com/users/jbcrail/events{/privacy}", "received_events_url": "https://api.github.com/users/jbcrail/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea6f65c5f1a3f84e010d2cef02a0160804e9567a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea6f65c5f1a3f84e010d2cef02a0160804e9567a", "html_url": "https://github.com/rust-lang/rust/commit/ea6f65c5f1a3f84e010d2cef02a0160804e9567a"}], "stats": {"total": 76, "additions": 38, "deletions": 38}, "files": [{"sha": "358d20feb06e1ee3f4d71b52159b61482cb7b49d", "filename": "src/doc/reference.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -1219,7 +1219,7 @@ the guarantee that these issues are never caused by safe code.\n     (`offset` intrinsic), with\n     the exception of one byte past the end which is permitted.\n   * Using `std::ptr::copy_nonoverlapping_memory` (`memcpy32`/`memcpy64`\n-    instrinsics) on overlapping buffers\n+    intrinsics) on overlapping buffers\n * Invalid values in primitive types, even in private fields/locals:\n   * Dangling/null references or boxes\n   * A value other than `false` (0) or `true` (1) in a `bool`"}, {"sha": "250411092a8e70b02fda912170d050e90583e899", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -1220,7 +1220,7 @@ impl<K, V> Node<K, V> {\n     /// Node is full, so split it into two nodes, and yield the middle-most key-value pair\n     /// because we have one too many, and our parent now has one too few\n     fn split(&mut self) -> (K, V, Node<K, V>) {\n-        // Necessary for correctness, but in a private funtion\n+        // Necessary for correctness, but in a private function\n         debug_assert!(self.len() > 0);\n \n         let mut right = if self.is_leaf() {\n@@ -1259,7 +1259,7 @@ impl<K, V> Node<K, V> {\n         }\n     }\n \n-    /// Take all the values from right, seperated by the given key and value\n+    /// Take all the values from right, separated by the given key and value\n     fn absorb(&mut self, key: K, val: V, mut right: Node<K, V>) {\n         // Necessary for correctness, but in a private function\n         // Just as a sanity check, make sure we can fit this guy in"}, {"sha": "52e363eb67656dd7acebbc919f801505e6bc90a8", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -987,7 +987,7 @@ impl<T> SliceExt for [T] {\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n-// Extension traits for slices over specifc kinds of data\n+// Extension traits for slices over specific kinds of data\n ////////////////////////////////////////////////////////////////////////////////\n #[unstable = \"U should be an associated type\"]\n /// An extension trait for concatenating slices\n@@ -997,7 +997,7 @@ pub trait SliceConcatExt<T: ?Sized, U> {\n     fn concat(&self) -> U;\n \n     /// Flattens a slice of `T` into a single value `U`, placing a\n-    /// given seperator between each.\n+    /// given separator between each.\n     #[stable]\n     fn connect(&self, sep: &T) -> U;\n }"}, {"sha": "e8c92649634dc2d33008c241d5f6fe17abf880a7", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -97,7 +97,7 @@ use kinds::{Send, Sized, Sync};\n use cmp::{PartialEq, Eq, Ord, PartialOrd};\n use cmp::Ordering::{self, Less, Equal, Greater};\n \n-// FIXME #19649: instrinsic docs don't render, so these have no docs :(\n+// FIXME #19649: intrinsic docs don't render, so these have no docs :(\n \n #[unstable]\n pub use intrinsics::copy_nonoverlapping_memory;\n@@ -233,7 +233,7 @@ pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n /// not drop the contents of `dst`. This could leak allocations or resources,\n /// so care must be taken not to overwrite an object that should be dropped.\n ///\n-/// This is appropriate for initializing uninitialized memory, or overwritting\n+/// This is appropriate for initializing uninitialized memory, or overwriting\n /// memory that has previously been `read` from.\n #[inline]\n #[stable]"}, {"sha": "b762f58685ded50f890cf542ea069b8a1a9b60a4", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -2034,7 +2034,7 @@ pub fn encode_metadata(parms: EncodeParams, krate: &ast::Crate) -> Vec<u8> {\n \n     // And here we run into yet another obscure archive bug: in which metadata\n     // loaded from archives may have trailing garbage bytes. Awhile back one of\n-    // our tests was failing sporadially on the OSX 64-bit builders (both nopt\n+    // our tests was failing sporadically on the OSX 64-bit builders (both nopt\n     // and opt) by having rbml generate an out-of-bounds panic when looking at\n     // metadata.\n     //"}, {"sha": "814eaa873472a2247f35082294130bc7f54f81b7", "filename": "src/librustc/middle/infer/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmiddle%2Finfer%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmiddle%2Finfer%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fdoc.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -125,7 +125,7 @@\n //! Another option is to keep A and B as distinct variables but set their\n //! bounds in such a way that, whatever happens, we know that A <: B will hold.\n //! This can be achieved by ensuring that A.ub <: B.lb.  In practice there\n-//! are two ways to do that, depicted pictorally here:\n+//! are two ways to do that, depicted pictorially here:\n //!\n //! ```text\n //!     Before                Option #1            Option #2"}, {"sha": "9f5c8de8811f07ed2a30a3ce86a6de285c558ca7", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -37,7 +37,7 @@\n //!\n //! # Subtype Trace\n //!\n-//! Determing whether `T1 <: T2` often involves a number of subtypes and\n+//! Determining whether `T1 <: T2` often involves a number of subtypes and\n //! subconstraints along the way. A \"TypeTrace\" is an extended version\n //! of an origin that traces the types and other values that were being\n //! compared. It is not necessarily comprehensive (in fact, at the time of"}, {"sha": "6b520ab665c22ec89a41e5d58652a28bd38bf28b", "filename": "src/librustc/middle/infer/higher_ranked/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fdoc.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -198,7 +198,7 @@\n //!\n //! So the way we solve this is to add a fourth step that examines the\n //! constraints that refer to skolemized names. Basically, consider a\n-//! non-directed verison of the constraint graph. Let `Tainted(x)` be the\n+//! non-directed version of the constraint graph. Let `Tainted(x)` be the\n //! set of all things reachable from a skolemized variable `x`.\n //! `Tainted(x)` should not contain any regions that existed before the\n //! step at which the skolemization was performed. So this case here"}, {"sha": "2dc46af9084b3548efed004a27c09f1a30aa40f2", "filename": "src/librustc/middle/infer/region_inference/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fdoc.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -38,7 +38,7 @@\n //! - ConstrainVarSubVar(R_i, R_j) states that region variable R_i\n //!   must be a subregion of R_j\n //! - ConstrainRegSubVar(R, R_i) states that the concrete region R\n-//!   (which must not be a variable) must be a subregion of the varibale R_i\n+//!   (which must not be a variable) must be a subregion of the variable R_i\n //! - ConstrainVarSubReg(R_i, R) is the inverse\n //!\n //! # Building up the constraints"}, {"sha": "a4888e7f186dba0dd83b266dd78d6c8463468fce", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -106,7 +106,7 @@ pub enum RegionResolutionError<'tcx> {\n \n     /// `GenericBoundFailure(p, s, a, bs)\n     ///\n-    /// The parameter/assocated-type `p` must be known to outlive the lifetime\n+    /// The parameter/associated-type `p` must be known to outlive the lifetime\n     /// `a`, but it is only known to outlive `bs` (and none of the\n     /// regions in `bs` outlive `a`).\n     GenericBoundFailure(SubregionOrigin<'tcx>, GenericKind<'tcx>, Region, Vec<Region>),\n@@ -337,7 +337,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     ///\n     /// The idea is to always create a snapshot. Skolemized regions\n     /// can be created in the context of this snapshot, but once the\n-    /// snapshot is commited or rolled back, their numbers will be\n+    /// snapshot is committed or rolled back, their numbers will be\n     /// recycled, so you must be finished with them. See the extensive\n     /// comments in `higher_ranked.rs` to see how it works (in\n     /// particular, the subtyping comparison)."}, {"sha": "4a01e964fd2f114db31acb21d15aff5220de6aaf", "filename": "src/librustc/middle/traits/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -254,7 +254,7 @@ we only need to do a \"shallow\" selection for an obligation. That is, we wish to\n identify which impl applies, but we do not (yet) need to decide how to select\n any nested obligations. Nonetheless, we *do* currently do a complete resolution,\n and that is because it can sometimes inform the results of type inference. That is,\n-we do not have the full substitutions in terms of the type varibales of the impl available\n+we do not have the full substitutions in terms of the type variables of the impl available\n to us, so we must run trait selection to figure everything out.\n \n Here is an example:"}, {"sha": "60b7a90d27d05221b1febcb2212b93d2845275a3", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -31,7 +31,7 @@ pub enum ObjectSafetyViolation<'tcx> {\n     /// Self : Sized declared on the trait\n     SizedSelf,\n \n-    /// Method has someting illegal\n+    /// Method has something illegal\n     Method(Rc<ty::Method<'tcx>>, MethodViolationCode),\n }\n \n@@ -256,7 +256,7 @@ fn contains_illegal_self_type_reference<'tcx>(tcx: &ty::ctxt<'tcx>,\n             ty::ty_projection(ref data) => {\n                 // This is a projected type `<Foo as SomeTrait>::X`.\n \n-                // Compute supertraits of current trait lazilly.\n+                // Compute supertraits of current trait lazily.\n                 if supertraits.is_none() {\n                     let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n                     let trait_ref = ty::Binder(trait_def.trait_ref.clone());"}, {"sha": "165976ef7a322e54ad7356bc69f87133fdebe602", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -337,7 +337,7 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n }\n \n /// in various error cases, we just set ty_err and return an obligation\n-/// that, when fulfiled, will lead to an error\n+/// that, when fulfilled, will lead to an error\n fn normalize_to_error<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                                projection_ty: ty::ProjectionTy<'tcx>,\n                                cause: ObligationCause<'tcx>,"}, {"sha": "2db8e28616f91bd199a6732a1e5c455516724c49", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -392,7 +392,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // `$1`), on the condition that `$1 : Eq`. We will then wind\n         // up with many candidates (since that are other `Eq` impls\n         // that apply) and try to winnow things down. This results in\n-        // a recurssive evaluation that `$1 : Eq` -- as you can\n+        // a recursive evaluation that `$1 : Eq` -- as you can\n         // imagine, this is just where we started. To avoid that, we\n         // check for unbound variables and return an ambiguous (hence possible)\n         // match if we've seen this trait before.\n@@ -604,7 +604,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         // If there are *STILL* multiple candidates, give up and\n-        // report ambiguiuty.\n+        // report ambiguity.\n         if candidates.len() > 1 {\n             debug!(\"multiple matches, ambig\");\n             return Ok(None);\n@@ -1119,7 +1119,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ///\n     /// This is generally true if either:\n     /// - candidate i and candidate j are equivalent; or,\n-    /// - candidate i is a conrete impl and candidate j is a where clause bound,\n+    /// - candidate i is a concrete impl and candidate j is a where clause bound,\n     ///   and the concrete impl is applicable to the types in the where clause bound.\n     ///\n     /// The last case refers to cases where there are blanket impls (often conditional"}, {"sha": "864caf8a3fd780d47785e848370d874076a67c70", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -1067,7 +1067,7 @@ impl<'tcx> FnOutput<'tcx> {\n ///\n /// - `inputs` is the list of arguments and their modes.\n /// - `output` is the return type.\n-/// - `variadic` indicates whether this is a varidic function. (only true for foreign fns)\n+/// - `variadic` indicates whether this is a variadic function. (only true for foreign fns)\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct FnSig<'tcx> {\n     pub inputs: Vec<Ty<'tcx>>,"}, {"sha": "1421987e3b52615866b7da721bbbcdb9fa65a297", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -30,7 +30,7 @@\n //! In some cases, we follow a degenerate pattern where we do not have\n //! a `fold_T` nor `super_fold_T` method. Instead, `T.fold_with`\n //! traverses the structure directly. This is suboptimal because the\n-//! behavior cannot be overriden, but it's much less work to implement.\n+//! behavior cannot be overridden, but it's much less work to implement.\n //! If you ever *do* need an override that doesn't exist, it's not hard\n //! to convert the degenerate pattern into the proper thing.\n "}, {"sha": "d5d40a980dc779495bab89503e4a8e4eeb85211a", "filename": "src/librustc/util/snapshot_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -14,7 +14,7 @@\n //!\n //! This vector is intended to be used as part of an abstraction, not serve as a complete\n //! abstraction on its own. As such, while it will roll back most changes on its own, it also\n-//! supports a `get_mut` operation that gives you an abitrary mutable pointer into the vector. To\n+//! supports a `get_mut` operation that gives you an arbitrary mutable pointer into the vector. To\n //! ensure that any changes you make this with this pointer are rolled back, you must invoke\n //! `record` to record any changes you make and also supplying a delegate capable of reversing\n //! those changes."}, {"sha": "ecfb1667f60e11b2c16e6246f44f81a6deb7014f", "filename": "src/librustc_back/target/arm_linux_androideabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -16,7 +16,7 @@ pub fn target() -> Target {\n     // Many of the symbols defined in compiler-rt are also defined in libgcc.  Android\n     // linker doesn't like that by default.\n     base.pre_link_args.push(\"-Wl,--allow-multiple-definition\".to_string());\n-    // FIXME #17437 (and #17448): Android doesn't support position dependant executables anymore.\n+    // FIXME #17437 (and #17448): Android doesn't support position dependent executables anymore.\n     base.position_independent_executables = false;\n \n     Target {"}, {"sha": "7f45c05fbbdd9149d6a93bf1fe1c45196d823c85", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -560,7 +560,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n     let object_substs = upcast_trait_ref.substs().clone().erase_regions();\n     debug!(\"trans_object_shim: object_substs={}\", object_substs.repr(tcx));\n \n-    // Lookup the type of this method as deeclared in the trait and apply substitutions.\n+    // Lookup the type of this method as declared in the trait and apply substitutions.\n     let method_ty = match ty::trait_item(tcx, trait_id, method_offset_in_trait) {\n         ty::MethodTraitItem(method) => method,\n         ty::TypeTraitItem(_) => {"}, {"sha": "1392592a70fbfc0f3118effca4e17293c3fff655", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -97,7 +97,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n             fcx.write_ty(pat.id, lhs_ty);\n \n-            // subtyping doens't matter here, as the value is some kind of scalar\n+            // subtyping doesn't matter here, as the value is some kind of scalar\n             demand::eqtype(fcx, pat.span, expected, lhs_ty);\n         }\n         ast::PatEnum(..) | ast::PatIdent(..) if pat_is_const(&tcx.def_map, pat) => {"}, {"sha": "6352b3bb9e4ccea3d12646e2a68e9a17988174b6", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -122,7 +122,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n         // If this is an `&mut self` method, bias the receiver\n         // expression towards mutability (this will switch\n-        // e.g. `Deref` to `DerefMut` in oveloaded derefs and so on).\n+        // e.g. `Deref` to `DerefMut` in overloaded derefs and so on).\n         self.fixup_derefs_on_method_receiver_if_necessary(&callee);\n \n         callee"}, {"sha": "c38b0e8ab317071f309bcbfda2ade08d0c1660d1", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -206,7 +206,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             // We are stricter on the trait-ref in an impl than the\n             // self-type.  In particular, we enforce region\n             // relationships. The reason for this is that (at least\n-            // presently) \"appyling\" an impl does not require that the\n+            // presently) \"applying\" an impl does not require that the\n             // application site check the well-formedness constraints on the\n             // trait reference. Instead, this is done at the impl site.\n             // Arguably this is wrong and we should treat the trait-reference"}, {"sha": "f9c7d10d40e7fe8d44ab23e49b7b7aa04be4416b", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -184,7 +184,7 @@ fn test_resize_policy() {\n // simply introduce a new bit to the front of the hash. Therefore, if an\n // elements has ideal index i in the old table, it can have one of two ideal\n // locations in the new table. If the new bit is 0, then the new ideal index\n-// is i. If the new bit is 1, then the new ideal index is n + i. Intutively,\n+// is i. If the new bit is 1, then the new ideal index is n + i. Intuitively,\n // we are producing two independent tables of size n, and for each element we\n // independently choose which table to insert it into with equal probability.\n // However the rather than wrapping around themselves on overflowing their"}, {"sha": "70ea366bbf4a5bbe38efbbcbaf4008b0f792d6c9", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -104,7 +104,7 @@ impl CString {\n         unsafe { mem::transmute(self.as_slice()) }\n     }\n \n-    /// Equivalend to `as_slice_with_nul` except that the type returned is a\n+    /// Equivalent to `as_slice_with_nul` except that the type returned is a\n     /// `u8` slice instead of a `libc::c_char` slice.\n     pub fn as_bytes_with_nul(&self) -> &[u8] {\n         unsafe { mem::transmute(self.as_slice_with_nul()) }"}, {"sha": "ca797e44ccd007c08b1cb135498cf6d00dc20c10", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -106,7 +106,7 @@\n //! ```\n //!\n //! This is invalid because the first argument is both referred to as a\n-//! hexidecimal as well as an\n+//! hexadecimal as well as an\n //! octal.\n //!\n //! There are various parameters which do require a particular type, however."}, {"sha": "d371023f21880ae87d1b438676d94cc9c03854ce", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -191,7 +191,7 @@ unsafe fn unregister_dtor(key: Key) -> bool {\n //\n // The callback specified receives a number of parameters from... someone!\n // (the kernel? the runtime? I'm not qute sure!) There are a few events that\n-// this gets invoked for, but we're currentl only interested on when a\n+// this gets invoked for, but we're currently only interested on when a\n // thread or a process \"detaches\" (exits). The process part happens for the\n // last thread and the thread part happens for any normal thread.\n //"}, {"sha": "d7f30207273d57d5afa670eef4f3a1660a5d5df6", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -142,7 +142,7 @@ use thunk::Thunk;\n use sys::thread as imp;\n use sys_common::{stack, thread_info};\n \n-/// Thread configuation. Provides detailed control over the properties\n+/// Thread configuration. Provides detailed control over the properties\n /// and behavior of new threads.\n pub struct Builder {\n     // A name for the thread-to-be, for identification in panic messages"}, {"sha": "83ee3219a966aacf6e9c4f8cb77eefffe3e1b5d2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -2780,7 +2780,7 @@ impl<'a> Parser<'a> {\n                 let open_span = self.span;\n                 self.bump();\n \n-                // Parse the token trees within the delimeters\n+                // Parse the token trees within the delimiters\n                 let tts = self.parse_seq_to_before_end(\n                     &token::CloseDelim(delim),\n                     seq_sep_none(),"}, {"sha": "daaa4af89db6504f226fc629c32cb85adaada553", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=e3b7fedc20fcfe54e0ddb285fc6e6c6e862b3279", "patch": "@@ -43,7 +43,7 @@ pub enum BinOpToken {\n     Shr,\n }\n \n-/// A delimeter token\n+/// A delimiter token\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Show, Copy)]\n pub enum DelimToken {\n     /// A round parenthesis: `(` or `)`\n@@ -134,9 +134,9 @@ pub enum Token {\n     Pound,\n     Dollar,\n     Question,\n-    /// An opening delimeter, eg. `{`\n+    /// An opening delimiter, eg. `{`\n     OpenDelim(DelimToken),\n-    /// A closing delimeter, eg. `}`\n+    /// A closing delimiter, eg. `}`\n     CloseDelim(DelimToken),\n \n     /* Literals */"}]}