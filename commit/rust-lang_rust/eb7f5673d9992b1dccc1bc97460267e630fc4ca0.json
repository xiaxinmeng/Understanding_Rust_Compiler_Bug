{"sha": "eb7f5673d9992b1dccc1bc97460267e630fc4ca0", "node_id": "C_kwDOAAsO6NoAKGViN2Y1NjczZDk5OTJiMWRjY2MxYmM5NzQ2MDI2N2U2MzBmYzRjYTA", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-08T20:50:32Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-12T17:51:22Z"}, "message": "Simplify binding finalization.", "tree": {"sha": "be111c3850e38d0d4afdaf974f23dbdfd2c0ba31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be111c3850e38d0d4afdaf974f23dbdfd2c0ba31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb7f5673d9992b1dccc1bc97460267e630fc4ca0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb7f5673d9992b1dccc1bc97460267e630fc4ca0", "html_url": "https://github.com/rust-lang/rust/commit/eb7f5673d9992b1dccc1bc97460267e630fc4ca0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb7f5673d9992b1dccc1bc97460267e630fc4ca0/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9a52c27d2bca3b39742dcc89c2b5ee643660fec", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9a52c27d2bca3b39742dcc89c2b5ee643660fec", "html_url": "https://github.com/rust-lang/rust/commit/e9a52c27d2bca3b39742dcc89c2b5ee643660fec"}], "stats": {"total": 107, "additions": 54, "deletions": 53}, "files": [{"sha": "3232e66e8238a273a9d09d556b75b6ea69aca770", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 54, "deletions": 53, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/eb7f5673d9992b1dccc1bc97460267e630fc4ca0/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb7f5673d9992b1dccc1bc97460267e630fc4ca0/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=eb7f5673d9992b1dccc1bc97460267e630fc4ca0", "patch": "@@ -850,12 +850,65 @@ impl<'a> Resolver<'a> {\n         let resolution =\n             self.resolution(module, key).try_borrow_mut().map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n \n-        if let Some(binding) = resolution.binding && let Some(path_span) = finalize {\n+        if let Some(path_span) = finalize {\n+            let Some(mut binding) = resolution.binding else {\n+                return Err((Determined, Weak::No));\n+            };\n+\n             if !restricted_shadowing && binding.expansion != LocalExpnId::ROOT {\n                 if let NameBindingKind::Res(_, true) = binding.kind {\n                     self.macro_expanded_macro_export_errors.insert((path_span, binding.span));\n                 }\n             }\n+\n+            // If the primary binding is unusable, search further and return the shadowed glob\n+            // binding if it exists. What we really want here is having two separate scopes in\n+            // a module - one for non-globs and one for globs, but until that's done use this\n+            // hack to avoid inconsistent resolution ICEs during import validation.\n+            if let Some(unusable_binding) = self.unusable_binding\n+                && ptr::eq(binding, unusable_binding)\n+            {\n+                let Some(shadowed) = resolution.shadowed_glob else {\n+                    return Err((Determined, Weak::No));\n+                };\n+\n+                if ptr::eq(shadowed, unusable_binding) {\n+                    return Err((Determined, Weak::No));\n+                }\n+\n+                binding = shadowed;\n+            }\n+\n+            if !self.is_accessible_from(binding.vis, parent_scope.module) {\n+                if self.last_import_segment {\n+                    return Err((Determined, Weak::No));\n+                } else {\n+                    self.privacy_errors.push(PrivacyError {\n+                        ident,\n+                        binding,\n+                        dedup_span: path_span,\n+                    });\n+                }\n+            }\n+\n+            // Forbid expanded shadowing to avoid time travel.\n+            if let Some(shadowed_glob) = resolution.shadowed_glob\n+                && restricted_shadowing\n+                && binding.expansion != LocalExpnId::ROOT\n+                && binding.res() != shadowed_glob.res()\n+            {\n+                self.ambiguity_errors.push(AmbiguityError {\n+                    kind: AmbiguityKind::GlobVsExpanded,\n+                    ident,\n+                    b1: binding,\n+                    b2: shadowed_glob,\n+                    misc1: AmbiguityErrorMisc::None,\n+                    misc2: AmbiguityErrorMisc::None,\n+                });\n+            }\n+\n+            self.record_use(ident, binding, restricted_shadowing);\n+            return Ok(binding);\n         }\n \n         let check_usable = |this: &mut Self, binding: &'a NameBinding<'a>| {\n@@ -868,58 +921,6 @@ impl<'a> Resolver<'a> {\n             if usable { Ok(binding) } else { Err((Determined, Weak::No)) }\n         };\n \n-        if let Some(path_span) = finalize {\n-            return resolution\n-                .binding\n-                .and_then(|binding| {\n-                    // If the primary binding is unusable, search further and return the shadowed glob\n-                    // binding if it exists. What we really want here is having two separate scopes in\n-                    // a module - one for non-globs and one for globs, but until that's done use this\n-                    // hack to avoid inconsistent resolution ICEs during import validation.\n-                    if let Some(unusable_binding) = self.unusable_binding {\n-                        if ptr::eq(binding, unusable_binding) {\n-                            return resolution.shadowed_glob;\n-                        }\n-                    }\n-                    Some(binding)\n-                })\n-                .ok_or((Determined, Weak::No))\n-                .and_then(|binding| {\n-                    if self.last_import_segment && check_usable(self, binding).is_err() {\n-                        Err((Determined, Weak::No))\n-                    } else {\n-                        self.record_use(ident, binding, restricted_shadowing);\n-\n-                        if let Some(shadowed_glob) = resolution.shadowed_glob {\n-                            // Forbid expanded shadowing to avoid time travel.\n-                            if restricted_shadowing\n-                                && binding.expansion != LocalExpnId::ROOT\n-                                && binding.res() != shadowed_glob.res()\n-                            {\n-                                self.ambiguity_errors.push(AmbiguityError {\n-                                    kind: AmbiguityKind::GlobVsExpanded,\n-                                    ident,\n-                                    b1: binding,\n-                                    b2: shadowed_glob,\n-                                    misc1: AmbiguityErrorMisc::None,\n-                                    misc2: AmbiguityErrorMisc::None,\n-                                });\n-                            }\n-                        }\n-\n-                        if !self.is_accessible_from(binding.vis, parent_scope.module) {\n-                            self.privacy_errors.push(PrivacyError {\n-                                ident,\n-                                binding,\n-                                dedup_span: path_span,\n-                            });\n-                        }\n-\n-                        Ok(binding)\n-                    }\n-                });\n-        }\n-\n         // Items and single imports are not shadowable, if we have one, then it's determined.\n         if let Some(binding) = resolution.binding {\n             if !binding.is_glob_import() {"}]}