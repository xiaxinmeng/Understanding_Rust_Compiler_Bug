{"sha": "ee2de279965a27e8189a9129a4b3454dd82568b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlMmRlMjc5OTY1YTI3ZTgxODlhOTEyOWE0YjM0NTRkZDgyNTY4Yjk=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-08-28T23:34:07Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-08-29T22:36:16Z"}, "message": "Add support for aggregates in platform intrinsics.\n\nThis adds support for flattened intrinsics, which are called in Rust\nwith tuples but in LLVM without them (e.g. `foo((a, b))` becomes `foo(a,\nb)`). Unflattened ones could be supported, but are not yet.", "tree": {"sha": "d3f43aeb293ce1a7f683566dafce3bfea64f7563", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3f43aeb293ce1a7f683566dafce3bfea64f7563"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee2de279965a27e8189a9129a4b3454dd82568b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee2de279965a27e8189a9129a4b3454dd82568b9", "html_url": "https://github.com/rust-lang/rust/commit/ee2de279965a27e8189a9129a4b3454dd82568b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee2de279965a27e8189a9129a4b3454dd82568b9/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b03ca7f805ab4e2bc6a5da6182fec6c0934042c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b03ca7f805ab4e2bc6a5da6182fec6c0934042c7", "html_url": "https://github.com/rust-lang/rust/commit/b03ca7f805ab4e2bc6a5da6182fec6c0934042c7"}], "stats": {"total": 111, "additions": 101, "deletions": 10}, "files": [{"sha": "88ad2dce55cd5526723fe73254952a8ca4f8bbdc", "filename": "src/librustc_platform_intrinsics/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee2de279965a27e8189a9129a4b3454dd82568b9/src%2Flibrustc_platform_intrinsics%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2de279965a27e8189a9129a4b3454dd82568b9/src%2Flibrustc_platform_intrinsics%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Flib.rs?ref=ee2de279965a27e8189a9129a4b3454dd82568b9", "patch": "@@ -34,6 +34,7 @@ pub enum Type {\n     Float(u8),\n     Pointer(Box<Type>),\n     Vector(Box<Type>, u8),\n+    Aggregate(bool, Vec<Type>),\n }\n \n pub enum IntrinsicDef {\n@@ -44,6 +45,9 @@ fn i(width: u8) -> Type { Type::Integer(true, width) }\n fn u(width: u8) -> Type { Type::Integer(false, width) }\n fn f(width: u8) -> Type { Type::Float(width) }\n fn v(x: Type, length: u8) -> Type { Type::Vector(Box::new(x), length) }\n+fn agg(flatten: bool, types: Vec<Type>) -> Type {\n+    Type::Aggregate(flatten, types)\n+}\n \n macro_rules! ty {\n     (f32x8) => (v(f(32), 8));"}, {"sha": "267a8a15f69931e7a7f883caeeb853046b0511dc", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 80, "deletions": 10, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/ee2de279965a27e8189a9129a4b3454dd82568b9/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2de279965a27e8189a9129a4b3454dd82568b9/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=ee2de279965a27e8189a9129a4b3454dd82568b9", "patch": "@@ -171,9 +171,10 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     let _icx = push_ctxt(\"trans_intrinsic_call\");\n \n-    let ret_ty = match callee_ty.sty {\n+    let (arg_tys, ret_ty) = match callee_ty.sty {\n         ty::TyBareFn(_, ref f) => {\n-            bcx.tcx().erase_late_bound_regions(&f.sig.output())\n+            (bcx.tcx().erase_late_bound_regions(&f.sig.inputs()),\n+             bcx.tcx().erase_late_bound_regions(&f.sig.output()))\n         }\n         _ => panic!(\"expected bare_fn in trans_intrinsic_call\")\n     };\n@@ -924,25 +925,94 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 Some(intr) => intr,\n                 None => ccx.sess().span_bug(foreign_item.span, \"unknown intrinsic\"),\n             };\n-            fn ty_to_type(ccx: &CrateContext, t: &intrinsics::Type) -> Type {\n+            fn one<T>(x: Vec<T>) -> T {\n+                assert_eq!(x.len(), 1);\n+                x.into_iter().next().unwrap()\n+            }\n+            fn ty_to_type(ccx: &CrateContext, t: &intrinsics::Type,\n+                          any_flattened_aggregate: &mut bool) -> Vec<Type> {\n                 use intrinsics::Type::*;\n                 match *t {\n-                    Integer(_signed, x) => Type::ix(ccx, x as u64),\n+                    Integer(_signed, x) => vec![Type::ix(ccx, x as u64)],\n                     Float(x) => {\n                         match x {\n-                            32 => Type::f32(ccx),\n-                            64 => Type::f64(ccx),\n+                            32 => vec![Type::f32(ccx)],\n+                            64 => vec![Type::f64(ccx)],\n                             _ => unreachable!()\n                         }\n                     }\n                     Pointer(_) => unimplemented!(),\n-                    Vector(ref t, length) => Type::vector(&ty_to_type(ccx, t),\n-                                                          length as u64)\n+                    Vector(ref t, length) => {\n+                        let elem = one(ty_to_type(ccx, t,\n+                                                  any_flattened_aggregate));\n+                        vec![Type::vector(&elem,\n+                                          length as u64)]\n+                    }\n+                    Aggregate(false, _) => unimplemented!(),\n+                    Aggregate(true, ref contents) => {\n+                        *any_flattened_aggregate = true;\n+                        contents.iter()\n+                                .flat_map(|t| ty_to_type(ccx, t, any_flattened_aggregate))\n+                                .collect()\n+                    }\n+                }\n+            }\n+\n+            // This allows an argument list like `foo, (bar, baz),\n+            // qux` to be converted into `foo, bar, baz, qux`.\n+            fn flatten_aggregate<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                             t: &intrinsics::Type,\n+                                             arg_type: Ty<'tcx>,\n+                                             llarg: ValueRef)\n+                                             -> Vec<ValueRef>\n+            {\n+                match *t {\n+                    intrinsics::Type::Aggregate(true, ref contents) => {\n+                        // We found a tuple that needs squishing! So\n+                        // run over the tuple and load each field.\n+                        //\n+                        // This assumes the type is \"simple\", i.e. no\n+                        // destructors, and the contents are SIMD\n+                        // etc.\n+                        assert!(!bcx.fcx.type_needs_drop(arg_type));\n+\n+                        let repr = adt::represent_type(bcx.ccx(), arg_type);\n+                        let repr_ptr = &*repr;\n+                        (0..contents.len())\n+                            .map(|i| {\n+                                Load(bcx, adt::trans_field_ptr(bcx, repr_ptr, llarg, 0, i))\n+                            })\n+                            .collect()\n+                    }\n+                    _ => vec![llarg],\n                 }\n             }\n \n-            let inputs = intr.inputs.iter().map(|t| ty_to_type(ccx, t)).collect::<Vec<_>>();\n-            let outputs = ty_to_type(ccx, &intr.output);\n+\n+            let mut any_flattened_aggregate = false;\n+            let inputs = intr.inputs.iter()\n+                                    .flat_map(|t| ty_to_type(ccx, t, &mut any_flattened_aggregate))\n+                                    .collect::<Vec<_>>();\n+\n+            let mut out_flattening = false;\n+            let outputs = one(ty_to_type(ccx, &intr.output, &mut out_flattening));\n+            // outputting a flattened aggregate is nonsense\n+            assert!(!out_flattening);\n+\n+            let llargs = if !any_flattened_aggregate {\n+                // no aggregates to flatten, so no change needed\n+                llargs\n+            } else {\n+                // there are some aggregates that need to be flattened\n+                // in the LLVM call, so we need to run over the types\n+                // again to find them and extract the arguments\n+                intr.inputs.iter()\n+                           .zip(&llargs)\n+                           .zip(&arg_tys)\n+                           .flat_map(|((t, llarg), ty)| flatten_aggregate(bcx, t, ty, *llarg))\n+                           .collect()\n+            };\n+\n             match intr.definition {\n                 intrinsics::IntrinsicDef::Named(name) => {\n                     let f = declare::declare_cfn(ccx,"}, {"sha": "74a1926916b40db7b7214db8acd3f3aefe664c4d", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ee2de279965a27e8189a9129a4b3454dd82568b9/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2de279965a27e8189a9129a4b3454dd82568b9/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=ee2de279965a27e8189a9129a4b3454dd82568b9", "patch": "@@ -507,5 +507,22 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n                                          inner_expected,\n                                          t_ty)\n         }\n+        Aggregate(_flatten, ref expected_contents) => {\n+            match t.sty {\n+                ty::TyTuple(ref contents) => {\n+                    if contents.len() != expected_contents.len() {\n+                        simple_error(&format!(\"tuple with length {}\", contents.len()),\n+                                     &format!(\"tuple with length {}\", expected_contents.len()));\n+                        return\n+                    }\n+                    for (e, c) in expected_contents.iter().zip(contents) {\n+                        match_intrinsic_type_to_type(tcx, position, span, structural_to_nominal,\n+                                                     e, c)\n+                    }\n+                }\n+                _ => simple_error(&format!(\"`{}`\", t),\n+                                  &format!(\"tuple\")),\n+            }\n+        }\n     }\n }"}]}