{"sha": "7d4cf710e2678d31fd899c452e1d4baf48eb8a86", "node_id": "C_kwDOAAsO6NoAKDdkNGNmNzEwZTI2NzhkMzFmZDg5OWM0NTJlMWQ0YmFmNDhlYjhhODY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-06-01T15:11:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-01T15:11:04Z"}, "message": "Rollup merge of #96271 - compiler-errors:suggest-question-mark, r=estebank\n\nsuggest `?` when method is missing on `Result<T, _>` but found on `T`\n\nThe wording needs help, I think.\n\nFixes #95729", "tree": {"sha": "761f3cec0ff35c0f36bf9f8be24f52b32cce5ddc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/761f3cec0ff35c0f36bf9f8be24f52b32cce5ddc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d4cf710e2678d31fd899c452e1d4baf48eb8a86", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJil4GICRBK7hj4Ov3rIwAAvysIAExDygKc/Xa61GjAwYDGISJf\nRhpUWJufhNBxUNKKdtmnyR/fAmM2AUeYHfBfbwja2Qbas9+vStA27dcenVSoT1sr\n1kF82q0vSN4cQkklU+blNQrN4UrgLeZ7/BxPcwBOB65FLU8O8qf21F77PFLTNiCv\nLPGk9gDF4qG1yhvGpbwViYezH/OW4o7ypwkNqXPFFClbZQytbfFRxWZ8bZ4IH690\nhIDm09aQSlj6FEp/HR3fwFvfPojkpr2wk+g9YJwKIPeChUKK/fmcMdeSM0oPYnLU\nd5/EMNWW8bU0QJ9cK3Vgpj/pDrEJW5EZqkhZmqTyW2YF8dU/hz2IVZ4nrzpbaHo=\n=DN8k\n-----END PGP SIGNATURE-----\n", "payload": "tree 761f3cec0ff35c0f36bf9f8be24f52b32cce5ddc\nparent 395a09c3dafe0c7838c9ca41d2b47bb5e79a5b6d\nparent 2a61f0cc45c809c62dd149477cb2672c2022c3a4\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1654096264 +0200\ncommitter GitHub <noreply@github.com> 1654096264 +0200\n\nRollup merge of #96271 - compiler-errors:suggest-question-mark, r=estebank\n\nsuggest `?` when method is missing on `Result<T, _>` but found on `T`\n\nThe wording needs help, I think.\n\nFixes #95729\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d4cf710e2678d31fd899c452e1d4baf48eb8a86", "html_url": "https://github.com/rust-lang/rust/commit/7d4cf710e2678d31fd899c452e1d4baf48eb8a86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d4cf710e2678d31fd899c452e1d4baf48eb8a86/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "395a09c3dafe0c7838c9ca41d2b47bb5e79a5b6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/395a09c3dafe0c7838c9ca41d2b47bb5e79a5b6d", "html_url": "https://github.com/rust-lang/rust/commit/395a09c3dafe0c7838c9ca41d2b47bb5e79a5b6d"}, {"sha": "2a61f0cc45c809c62dd149477cb2672c2022c3a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a61f0cc45c809c62dd149477cb2672c2022c3a4", "html_url": "https://github.com/rust-lang/rust/commit/2a61f0cc45c809c62dd149477cb2672c2022c3a4"}], "stats": {"total": 420, "additions": 368, "deletions": 52}, "files": [{"sha": "0e198907c8d5092ed1a44e476cb0494621353581", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 151, "deletions": 52, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/7d4cf710e2678d31fd899c452e1d4baf48eb8a86/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d4cf710e2678d31fd899c452e1d4baf48eb8a86/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=7d4cf710e2678d31fd899c452e1d4baf48eb8a86", "patch": "@@ -978,45 +978,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     label_span_not_found(&mut err);\n                 }\n \n-                if let SelfSource::MethodCall(expr) = source\n-                    && let Some((fields, substs)) = self.get_field_candidates(span, actual)\n-                {\n-                    let call_expr =\n-                        self.tcx.hir().expect_expr(self.tcx.hir().get_parent_node(expr.hir_id));\n-                    for candidate_field in fields.iter() {\n-                        if let Some(field_path) = self.check_for_nested_field_satisfying(\n-                            span,\n-                            &|_, field_ty| {\n-                                self.lookup_probe(\n-                                    span,\n-                                    item_name,\n-                                    field_ty,\n-                                    call_expr,\n-                                    ProbeScope::AllTraits,\n-                                )\n-                                .is_ok()\n-                            },\n-                            candidate_field,\n-                            substs,\n-                            vec![],\n-                            self.tcx.parent_module(expr.hir_id).to_def_id(),\n-                        ) {\n-                            let field_path_str = field_path\n-                                .iter()\n-                                .map(|id| id.name.to_ident_string())\n-                                .collect::<Vec<String>>()\n-                                .join(\".\");\n-                            debug!(\"field_path_str: {:?}\", field_path_str);\n+                self.check_for_field_method(&mut err, source, span, actual, item_name);\n \n-                            err.span_suggestion_verbose(\n-                                item_name.span.shrink_to_lo(),\n-                                \"one of the expressions' fields has a method of the same name\",\n-                                format!(\"{field_path_str}.\"),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n-                    }\n-                }\n+                self.check_for_unwrap_self(&mut err, source, span, actual, item_name);\n \n                 bound_spans.sort();\n                 bound_spans.dedup();\n@@ -1343,6 +1307,145 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n+    fn check_for_field_method(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+        source: SelfSource<'tcx>,\n+        span: Span,\n+        actual: Ty<'tcx>,\n+        item_name: Ident,\n+    ) {\n+        if let SelfSource::MethodCall(expr) = source\n+            && let Some((fields, substs)) = self.get_field_candidates(span, actual)\n+        {\n+            let call_expr = self.tcx.hir().expect_expr(self.tcx.hir().get_parent_node(expr.hir_id));\n+            for candidate_field in fields.iter() {\n+                if let Some(field_path) = self.check_for_nested_field_satisfying(\n+                    span,\n+                    &|_, field_ty| {\n+                        self.lookup_probe(\n+                            span,\n+                            item_name,\n+                            field_ty,\n+                            call_expr,\n+                            ProbeScope::AllTraits,\n+                        )\n+                        .is_ok()\n+                    },\n+                    candidate_field,\n+                    substs,\n+                    vec![],\n+                    self.tcx.parent_module(expr.hir_id).to_def_id(),\n+                ) {\n+                    let field_path_str = field_path\n+                        .iter()\n+                        .map(|id| id.name.to_ident_string())\n+                        .collect::<Vec<String>>()\n+                        .join(\".\");\n+                    debug!(\"field_path_str: {:?}\", field_path_str);\n+\n+                    err.span_suggestion_verbose(\n+                        item_name.span.shrink_to_lo(),\n+                        \"one of the expressions' fields has a method of the same name\",\n+                        format!(\"{field_path_str}.\"),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_for_unwrap_self(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+        source: SelfSource<'tcx>,\n+        span: Span,\n+        actual: Ty<'tcx>,\n+        item_name: Ident,\n+    ) {\n+        let tcx = self.tcx;\n+        let SelfSource::MethodCall(expr) = source else { return; };\n+        let call_expr = tcx.hir().expect_expr(tcx.hir().get_parent_node(expr.hir_id));\n+\n+        let ty::Adt(kind, substs) = actual.kind() else { return; };\n+        if !kind.is_enum() {\n+            return;\n+        }\n+\n+        let matching_variants: Vec<_> = kind\n+            .variants()\n+            .iter()\n+            .flat_map(|variant| {\n+                let [field] = &variant.fields[..] else { return None; };\n+                let field_ty = field.ty(tcx, substs);\n+\n+                // Skip `_`, since that'll just lead to ambiguity.\n+                if self.resolve_vars_if_possible(field_ty).is_ty_var() {\n+                    return None;\n+                }\n+\n+                self.lookup_probe(span, item_name, field_ty, call_expr, ProbeScope::AllTraits)\n+                    .ok()\n+                    .map(|pick| (variant, field, pick))\n+            })\n+            .collect();\n+\n+        let ret_ty_matches = |diagnostic_item| {\n+            if let Some(ret_ty) = self\n+                .ret_coercion\n+                .as_ref()\n+                .map(|c| self.resolve_vars_if_possible(c.borrow().expected_ty()))\n+                && let ty::Adt(kind, _) = ret_ty.kind()\n+                && tcx.get_diagnostic_item(diagnostic_item) == Some(kind.did())\n+            {\n+                true\n+            } else {\n+                false\n+            }\n+        };\n+\n+        match &matching_variants[..] {\n+            [(_, field, pick)] => {\n+                let self_ty = field.ty(tcx, substs);\n+                err.span_note(\n+                    tcx.def_span(pick.item.def_id),\n+                    &format!(\"the method `{item_name}` exists on the type `{self_ty}`\"),\n+                );\n+                let (article, kind, variant, question) =\n+                    if Some(kind.did()) == tcx.get_diagnostic_item(sym::Result) {\n+                        (\"a\", \"Result\", \"Err\", ret_ty_matches(sym::Result))\n+                    } else if Some(kind.did()) == tcx.get_diagnostic_item(sym::Option) {\n+                        (\"an\", \"Option\", \"None\", ret_ty_matches(sym::Option))\n+                    } else {\n+                        return;\n+                    };\n+                if question {\n+                    err.span_suggestion_verbose(\n+                        expr.span.shrink_to_hi(),\n+                        format!(\n+                            \"use the `?` operator to extract the `{self_ty}` value, propagating \\\n+                            {article} `{kind}::{variant}` value to the caller\"\n+                        ),\n+                        \"?\".to_owned(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    err.span_suggestion_verbose(\n+                        expr.span.shrink_to_hi(),\n+                        format!(\n+                            \"consider using `{kind}::expect` to unwrap the `{self_ty}` value, \\\n+                             panicking if the value is {article} `{kind}::{variant}`\"\n+                        ),\n+                        \".expect(\\\"REASON\\\")\".to_owned(),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                }\n+            }\n+            // FIXME(compiler-errors): Support suggestions for other matching enum variants\n+            _ => {}\n+        }\n+    }\n+\n     pub(crate) fn note_unmet_impls_on_type(\n         &self,\n         err: &mut Diagnostic,\n@@ -1662,13 +1765,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 (self.tcx.mk_mut_ref(self.tcx.lifetimes.re_erased, rcvr_ty), \"&mut \"),\n                 (self.tcx.mk_imm_ref(self.tcx.lifetimes.re_erased, rcvr_ty), \"&\"),\n             ] {\n-                match self.lookup_probe(\n-                    span,\n-                    item_name,\n-                    *rcvr_ty,\n-                    rcvr,\n-                    crate::check::method::probe::ProbeScope::AllTraits,\n-                ) {\n+                match self.lookup_probe(span, item_name, *rcvr_ty, rcvr, ProbeScope::AllTraits) {\n                     Ok(pick) => {\n                         // If the method is defined for the receiver we have, it likely wasn't `use`d.\n                         // We point at the method, but we just skip the rest of the check for arbitrary\n@@ -1700,13 +1797,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     (self.tcx.mk_diagnostic_item(*rcvr_ty, sym::Arc), \"Arc::new\"),\n                     (self.tcx.mk_diagnostic_item(*rcvr_ty, sym::Rc), \"Rc::new\"),\n                 ] {\n-                    if let Some(new_rcvr_t) = *rcvr_ty && let Ok(pick) = self.lookup_probe(\n-                        span,\n-                        item_name,\n-                        new_rcvr_t,\n-                        rcvr,\n-                        crate::check::method::probe::ProbeScope::AllTraits,\n-                    ) {\n+                    if let Some(new_rcvr_t) = *rcvr_ty\n+                        && let Ok(pick) = self.lookup_probe(\n+                            span,\n+                            item_name,\n+                            new_rcvr_t,\n+                            rcvr,\n+                            ProbeScope::AllTraits,\n+                        )\n+                    {\n                         debug!(\"try_alt_rcvr: pick candidate {:?}\", pick);\n                         let did = Some(pick.item.container.id());\n                         // We don't want to suggest a container type when the missing"}, {"sha": "6499c92bc6f1545baeacbf6c66e696d6ff560139", "filename": "src/test/ui/suggestions/enum-method-probe.fixed", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/7d4cf710e2678d31fd899c452e1d4baf48eb8a86/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7d4cf710e2678d31fd899c452e1d4baf48eb8a86/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.fixed?ref=7d4cf710e2678d31fd899c452e1d4baf48eb8a86", "patch": "@@ -0,0 +1,59 @@\n+// compile-flags: --edition=2021\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn get(&self) -> u8 {\n+        42\n+    }\n+}\n+\n+fn test_result_in_result() -> Result<(), ()> {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res?.get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP use the `?` operator\n+    Ok(())\n+}\n+\n+async fn async_test_result_in_result() -> Result<(), ()> {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res?.get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP use the `?` operator\n+    Ok(())\n+}\n+\n+fn test_result_in_unit_return() {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res.expect(\"REASON\").get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is a `Result::Err`\n+}\n+\n+async fn async_test_result_in_unit_return() {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res.expect(\"REASON\").get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is a `Result::Err`\n+}\n+\n+fn test_option_in_option() -> Option<()> {\n+    let res: Option<_> = Some(Foo);\n+    res?.get();\n+    //~^ ERROR no method named `get` found for enum `Option` in the current scope\n+    //~| HELP use the `?` operator\n+    Some(())\n+}\n+\n+fn test_option_in_unit_return() {\n+    let res: Option<_> = Some(Foo);\n+    res.expect(\"REASON\").get();\n+    //~^ ERROR no method named `get` found for enum `Option` in the current scope\n+    //~| HELP consider using `Option::expect` to unwrap the `Foo` value, panicking if the value is an `Option::None`\n+}\n+\n+fn main() {}"}, {"sha": "18ea8ed8a58ffd055a155094ba4b7aed555ca786", "filename": "src/test/ui/suggestions/enum-method-probe.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/7d4cf710e2678d31fd899c452e1d4baf48eb8a86/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d4cf710e2678d31fd899c452e1d4baf48eb8a86/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.rs?ref=7d4cf710e2678d31fd899c452e1d4baf48eb8a86", "patch": "@@ -0,0 +1,59 @@\n+// compile-flags: --edition=2021\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn get(&self) -> u8 {\n+        42\n+    }\n+}\n+\n+fn test_result_in_result() -> Result<(), ()> {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res.get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP use the `?` operator\n+    Ok(())\n+}\n+\n+async fn async_test_result_in_result() -> Result<(), ()> {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res.get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP use the `?` operator\n+    Ok(())\n+}\n+\n+fn test_result_in_unit_return() {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res.get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is a `Result::Err`\n+}\n+\n+async fn async_test_result_in_unit_return() {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res.get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is a `Result::Err`\n+}\n+\n+fn test_option_in_option() -> Option<()> {\n+    let res: Option<_> = Some(Foo);\n+    res.get();\n+    //~^ ERROR no method named `get` found for enum `Option` in the current scope\n+    //~| HELP use the `?` operator\n+    Some(())\n+}\n+\n+fn test_option_in_unit_return() {\n+    let res: Option<_> = Some(Foo);\n+    res.get();\n+    //~^ ERROR no method named `get` found for enum `Option` in the current scope\n+    //~| HELP consider using `Option::expect` to unwrap the `Foo` value, panicking if the value is an `Option::None`\n+}\n+\n+fn main() {}"}, {"sha": "6ed14984f47478928e27837200a7ba96a1ab406c", "filename": "src/test/ui/suggestions/enum-method-probe.stderr", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/7d4cf710e2678d31fd899c452e1d4baf48eb8a86/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d4cf710e2678d31fd899c452e1d4baf48eb8a86/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.stderr?ref=7d4cf710e2678d31fd899c452e1d4baf48eb8a86", "patch": "@@ -0,0 +1,99 @@\n+error[E0599]: no method named `get` found for enum `Result` in the current scope\n+  --> $DIR/enum-method-probe.rs:24:9\n+   |\n+LL |     res.get();\n+   |         ^^^ method not found in `Result<Foo, ()>`\n+   |\n+note: the method `get` exists on the type `Foo`\n+  --> $DIR/enum-method-probe.rs:9:5\n+   |\n+LL |     fn get(&self) -> u8 {\n+   |     ^^^^^^^^^^^^^^^^^^^\n+help: use the `?` operator to extract the `Foo` value, propagating a `Result::Err` value to the caller\n+   |\n+LL |     res?.get();\n+   |        +\n+\n+error[E0599]: no method named `get` found for enum `Result` in the current scope\n+  --> $DIR/enum-method-probe.rs:39:9\n+   |\n+LL |     res.get();\n+   |         ^^^ method not found in `Result<Foo, ()>`\n+   |\n+note: the method `get` exists on the type `Foo`\n+  --> $DIR/enum-method-probe.rs:9:5\n+   |\n+LL |     fn get(&self) -> u8 {\n+   |     ^^^^^^^^^^^^^^^^^^^\n+help: consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is a `Result::Err`\n+   |\n+LL |     res.expect(\"REASON\").get();\n+   |        +++++++++++++++++\n+\n+error[E0599]: no method named `get` found for enum `Result` in the current scope\n+  --> $DIR/enum-method-probe.rs:16:9\n+   |\n+LL |     res.get();\n+   |         ^^^ method not found in `Result<Foo, ()>`\n+   |\n+note: the method `get` exists on the type `Foo`\n+  --> $DIR/enum-method-probe.rs:9:5\n+   |\n+LL |     fn get(&self) -> u8 {\n+   |     ^^^^^^^^^^^^^^^^^^^\n+help: use the `?` operator to extract the `Foo` value, propagating a `Result::Err` value to the caller\n+   |\n+LL |     res?.get();\n+   |        +\n+\n+error[E0599]: no method named `get` found for enum `Result` in the current scope\n+  --> $DIR/enum-method-probe.rs:32:9\n+   |\n+LL |     res.get();\n+   |         ^^^ method not found in `Result<Foo, ()>`\n+   |\n+note: the method `get` exists on the type `Foo`\n+  --> $DIR/enum-method-probe.rs:9:5\n+   |\n+LL |     fn get(&self) -> u8 {\n+   |     ^^^^^^^^^^^^^^^^^^^\n+help: consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is a `Result::Err`\n+   |\n+LL |     res.expect(\"REASON\").get();\n+   |        +++++++++++++++++\n+\n+error[E0599]: no method named `get` found for enum `Option` in the current scope\n+  --> $DIR/enum-method-probe.rs:46:9\n+   |\n+LL |     res.get();\n+   |         ^^^ method not found in `Option<Foo>`\n+   |\n+note: the method `get` exists on the type `Foo`\n+  --> $DIR/enum-method-probe.rs:9:5\n+   |\n+LL |     fn get(&self) -> u8 {\n+   |     ^^^^^^^^^^^^^^^^^^^\n+help: use the `?` operator to extract the `Foo` value, propagating an `Option::None` value to the caller\n+   |\n+LL |     res?.get();\n+   |        +\n+\n+error[E0599]: no method named `get` found for enum `Option` in the current scope\n+  --> $DIR/enum-method-probe.rs:54:9\n+   |\n+LL |     res.get();\n+   |         ^^^ method not found in `Option<Foo>`\n+   |\n+note: the method `get` exists on the type `Foo`\n+  --> $DIR/enum-method-probe.rs:9:5\n+   |\n+LL |     fn get(&self) -> u8 {\n+   |     ^^^^^^^^^^^^^^^^^^^\n+help: consider using `Option::expect` to unwrap the `Foo` value, panicking if the value is an `Option::None`\n+   |\n+LL |     res.expect(\"REASON\").get();\n+   |        +++++++++++++++++\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}]}