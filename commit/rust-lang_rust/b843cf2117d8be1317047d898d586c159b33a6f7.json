{"sha": "b843cf2117d8be1317047d898d586c159b33a6f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4NDNjZjIxMTdkOGJlMTMxNzA0N2Q4OThkNTg2YzE1OWIzM2E2Zjc=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-15T15:01:35Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-15T15:01:35Z"}, "message": "Generalize expression roots in alias analysis\n\nThis allows calls-returning-a-reference to count as expression roots,\nmaking it possible to return the result of such a call by reference.\n\nIssue #918", "tree": {"sha": "47a8492101ba1be245444ca5d1e1733f486f3f3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47a8492101ba1be245444ca5d1e1733f486f3f3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b843cf2117d8be1317047d898d586c159b33a6f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b843cf2117d8be1317047d898d586c159b33a6f7", "html_url": "https://github.com/rust-lang/rust/commit/b843cf2117d8be1317047d898d586c159b33a6f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b843cf2117d8be1317047d898d586c159b33a6f7/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29177864c353efd98182b02f5593e87183d184af", "url": "https://api.github.com/repos/rust-lang/rust/commits/29177864c353efd98182b02f5593e87183d184af", "html_url": "https://github.com/rust-lang/rust/commit/29177864c353efd98182b02f5593e87183d184af"}], "stats": {"total": 84, "additions": 49, "deletions": 35}, "files": [{"sha": "360619b73e0d2996343e44ef2ed88dfc441cb31e", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 40, "deletions": 35, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b843cf2117d8be1317047d898d586c159b33a6f7/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b843cf2117d8be1317047d898d586c159b33a6f7/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=b843cf2117d8be1317047d898d586c159b33a6f7", "patch": "@@ -1,7 +1,7 @@\n \n import syntax::{ast, ast_util};\n import ast::{ident, fn_ident, node_id, def_id};\n-import mut::{expr_root, mut_field, deref, field, index, unbox};\n+import mut::{mut_field, deref, field, index, unbox};\n import syntax::codemap::span;\n import syntax::visit;\n import visit::vt;\n@@ -89,7 +89,7 @@ fn visit_expr(cx: @ctx, ex: @ast::expr, sc: scope, v: vt<scope>) {\n       ast::expr_put(val) {\n         alt val {\n           some(ex) {\n-            let root = expr_root(cx.tcx, ex, false);\n+            let root = expr_root(*cx, ex, false);\n             if mut_field(root.ds) {\n                 cx.tcx.sess.span_err(ex.span,\n                                      \"result of put must be\" +\n@@ -177,38 +177,13 @@ fn add_bindings_for_let(cx: ctx, &bs: [binding], loc: @ast::local) {\n             cx.tcx.sess.span_err\n                 (loc.span, \"can not move into a by-reference binding\");\n         }\n-        let root = expr_root(cx.tcx, init.expr, false);\n-        let outer_ds = *root.ds;\n+        let root = expr_root(cx, init.expr, false);\n         let root_var = path_def_id(cx, root.ex);\n-        let is_temp = is_none(root_var);\n-        if is_temp {\n-            alt root.ex.node {\n-              ast::expr_call(f, args) {\n-                let fty = ty::type_autoderef(cx.tcx, ty::expr_ty(cx.tcx, f));\n-                alt ty::ty_fn_ret_style(cx.tcx, fty) {\n-                  ast::return_ref(mut, arg_n) {\n-                    let arg = args[arg_n];\n-                    let arg_root = expr_root(cx.tcx, arg, false);\n-                    root_var = path_def_id(cx, arg_root.ex);\n-                    if !is_none(root_var) {\n-                        is_temp = false;\n-                        if mut {\n-                            outer_ds = [@{mut: true, kind: unbox,\n-                                          outer_t: ty::expr_ty(cx.tcx, arg)}];\n-                        }\n-                        outer_ds = *arg_root.ds + outer_ds;\n-                    }\n-                  }\n-                }\n-              }\n-              _ {}\n-            }\n-        }\n-        if is_temp {\n+        if is_none(root_var) {\n             cx.tcx.sess.span_err(loc.span, \"a reference binding can't be \\\n                                             rooted in a temporary\");\n         }\n-        for proot in *pattern_roots(cx.tcx, outer_ds, loc.node.pat) {\n+        for proot in *pattern_roots(cx.tcx, *root.ds, loc.node.pat) {\n             let bnd = mk_binding(cx, proot.id, proot.span, root_var,\n                                  inner_mut(proot.ds));\n             // Don't implicitly copy explicit references\n@@ -252,7 +227,7 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr]) -> [binding] {\n     let i = 0u;\n     for arg_t: ty::arg in arg_ts {\n         let arg = args[i];\n-        let root = expr_root(cx.tcx, arg, false);\n+        let root = expr_root(cx, arg, false);\n         if arg_t.mode == ast::by_mut_ref {\n             alt path_def(cx, arg) {\n               some(def) {\n@@ -340,11 +315,13 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr]) -> [binding] {\n \n fn check_ret_ref(cx: ctx, sc: scope, mut: bool, arg_node_id: node_id,\n                  expr: @ast::expr) {\n-    let root = expr_root(cx.tcx, expr, false);\n+    let root = expr_root(cx, expr, false);\n     let bad = none;\n     let mut_field = mut_field(root.ds);\n     alt path_def(cx, root.ex) {\n-      none. { bad = some(\"a temporary\"); }\n+      none. {\n+        bad = some(\"a temporary\");\n+      }\n       some(ast::def_local(did, _)) | some(ast::def_binding(did)) |\n       some(ast::def_arg(did, _)) {\n         let cur_node = did.node;\n@@ -400,7 +377,7 @@ fn check_ret_ref(cx: ctx, sc: scope, mut: bool, arg_node_id: node_id,\n fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n              v: vt<scope>) {\n     v.visit_expr(input, sc, v);\n-    let root = expr_root(cx.tcx, input, true);\n+    let root = expr_root(cx, input, true);\n     for a: ast::arm in arms {\n         let new_bs = sc.bs;\n         let root_var = path_def_id(cx, root.ex);\n@@ -448,7 +425,7 @@ fn check_for_each(cx: ctx, local: @ast::local, call: @ast::expr,\n fn check_for(cx: ctx, local: @ast::local, seq: @ast::expr, blk: ast::blk,\n              sc: scope, v: vt<scope>) {\n     v.visit_expr(seq, sc, v);\n-    let root = expr_root(cx.tcx, seq, false);\n+    let root = expr_root(cx, seq, false);\n \n     // If this is a mutable vector, don't allow it to be touched.\n     let seq_t = ty::expr_ty(cx.tcx, seq);\n@@ -695,6 +672,34 @@ fn pattern_roots(tcx: ty::ctxt, base: [deref], pat: @ast::pat)\n     ret @set;\n }\n \n+// Wraps the expr_root in mut.rs to also handle roots that exist through\n+// return-by-reference\n+fn expr_root(cx: ctx, ex: @ast::expr, autoderef: bool) ->\n+   {ex: @ast::expr, ds: @[deref]} {\n+    let base_root = mut::expr_root(cx.tcx, ex, autoderef);\n+    if is_none(path_def_id(cx, base_root.ex)) {\n+        alt base_root.ex.node {\n+          ast::expr_call(f, args) {\n+            let fty = ty::type_autoderef(cx.tcx, ty::expr_ty(cx.tcx, f));\n+            alt ty::ty_fn_ret_style(cx.tcx, fty) {\n+              ast::return_ref(mut, arg_n) {\n+                let arg = args[arg_n];\n+                let arg_root = expr_root(cx, arg, false);\n+                ret {ex: arg_root.ex,\n+                     ds: @(*arg_root.ds +\n+                           (mut ? [@{mut: true, kind: unbox,\n+                                     outer_t: ty::expr_ty(cx.tcx, arg)}] : [])\n+                           + *base_root.ds)};\n+              }\n+              _ {}\n+            }\n+          }\n+          _ {}\n+        }\n+    }\n+    ret base_root;\n+}\n+\n fn inner_mut(ds: @[deref]) -> [ty::t] {\n     for d: deref in *ds { if d.mut { ret [d.outer_t]; } }\n     ret [];"}, {"sha": "1c2a3b9e50cc15c2ee1f840b9b1aced29ecb96f1", "filename": "src/test/run-pass/ret-by-reference.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b843cf2117d8be1317047d898d586c159b33a6f7/src%2Ftest%2Frun-pass%2Fret-by-reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b843cf2117d8be1317047d898d586c159b33a6f7/src%2Ftest%2Frun-pass%2Fret-by-reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fret-by-reference.rs?ref=b843cf2117d8be1317047d898d586c159b33a6f7", "patch": "@@ -10,6 +10,10 @@ fn get_mut(a: {mutable x: @int}, _b: int) -> &!0 @int {\n     ret a.x;\n }\n \n+fn get_deep(a: {mutable y: {mutable x: @int}}) -> &!@int {\n+    ret get_mut(a.y, 1);\n+}\n+\n fn main() {\n     let x = some(@50);\n     let &y = get(x);\n@@ -20,4 +24,9 @@ fn main() {\n     let &box = get_mut(y, 4);\n     assert *box == 50;\n     assert *get_mut({mutable x: @70}, 5) == 70;\n+\n+    let u = {mutable y: {mutable x: @10}};\n+    let &deep = get_deep(u);\n+    assert *deep == 10;\n+    assert *get_deep({mutable y: {mutable x: @11}}) + 2 == 13;\n }"}]}