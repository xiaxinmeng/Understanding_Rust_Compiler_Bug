{"sha": "a61a3678ebe5571842d4223e2a0313714893bbf7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2MWEzNjc4ZWJlNTU3MTg0MmQ0MjIzZTJhMDMxMzcxNDg5M2JiZjc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-11-20T23:46:49Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-11-26T16:24:18Z"}, "message": "librustuv: Remove all non-`proc` uses of `do` from `libextra` and\n`librustuv`.", "tree": {"sha": "223426e3ca003e294cd7cf39155e6c600ae7563b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/223426e3ca003e294cd7cf39155e6c600ae7563b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a61a3678ebe5571842d4223e2a0313714893bbf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a61a3678ebe5571842d4223e2a0313714893bbf7", "html_url": "https://github.com/rust-lang/rust/commit/a61a3678ebe5571842d4223e2a0313714893bbf7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a61a3678ebe5571842d4223e2a0313714893bbf7/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1eca34de7dd55719cd83153994e5caf2027f62a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1eca34de7dd55719cd83153994e5caf2027f62a2", "html_url": "https://github.com/rust-lang/rust/commit/1eca34de7dd55719cd83153994e5caf2027f62a2"}], "stats": {"total": 905, "additions": 456, "deletions": 449}, "files": [{"sha": "b9b1e324e5a964f3657112677c45c73227d5c07d", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 97, "deletions": 99, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -224,11 +224,11 @@ impl<T:Send> MutexArc<T> {\n         let state = self.x.get();\n         // Borrowck would complain about this if the function were\n         // not already unsafe. See borrow_rwlock, far below.\n-        do (&(*state).lock).lock {\n+        (&(*state).lock).lock(|| {\n             check_poison(true, (*state).failed);\n             let _z = PoisonOnFail(&mut (*state).failed);\n             blk(&mut (*state).data)\n-        }\n+        })\n     }\n \n     /// As unsafe_access(), but with a condvar, as sync::mutex.lock_cond().\n@@ -237,14 +237,14 @@ impl<T:Send> MutexArc<T> {\n                                         blk: |x: &mut T, c: &Condvar| -> U)\n                                         -> U {\n         let state = self.x.get();\n-        do (&(*state).lock).lock_cond |cond| {\n+        (&(*state).lock).lock_cond(|cond| {\n             check_poison(true, (*state).failed);\n             let _z = PoisonOnFail(&mut (*state).failed);\n             blk(&mut (*state).data,\n                 &Condvar {is_mutex: true,\n                           failed: &mut (*state).failed,\n                           cond: cond })\n-        }\n+        })\n     }\n \n     /**\n@@ -390,11 +390,11 @@ impl<T:Freeze + Send> RWArc<T> {\n     pub fn write<U>(&self, blk: |x: &mut T| -> U) -> U {\n         unsafe {\n             let state = self.x.get();\n-            do (*borrow_rwlock(state)).write {\n+            (*borrow_rwlock(state)).write(|| {\n                 check_poison(false, (*state).failed);\n                 let _z = PoisonOnFail(&mut (*state).failed);\n                 blk(&mut (*state).data)\n-            }\n+            })\n         }\n     }\n \n@@ -405,14 +405,14 @@ impl<T:Freeze + Send> RWArc<T> {\n                          -> U {\n         unsafe {\n             let state = self.x.get();\n-            do (*borrow_rwlock(state)).write_cond |cond| {\n+            (*borrow_rwlock(state)).write_cond(|cond| {\n                 check_poison(false, (*state).failed);\n                 let _z = PoisonOnFail(&mut (*state).failed);\n                 blk(&mut (*state).data,\n                     &Condvar {is_mutex: false,\n                               failed: &mut (*state).failed,\n                               cond: cond})\n-            }\n+            })\n         }\n     }\n \n@@ -428,10 +428,10 @@ impl<T:Freeze + Send> RWArc<T> {\n     pub fn read<U>(&self, blk: |x: &T| -> U) -> U {\n         unsafe {\n             let state = self.x.get();\n-            do (*state).lock.read {\n+            (*state).lock.read(|| {\n                 check_poison(false, (*state).failed);\n                 blk(&(*state).data)\n-            }\n+            })\n         }\n     }\n \n@@ -458,14 +458,14 @@ impl<T:Freeze + Send> RWArc<T> {\n     pub fn write_downgrade<U>(&self, blk: |v: RWWriteMode<T>| -> U) -> U {\n         unsafe {\n             let state = self.x.get();\n-            do (*borrow_rwlock(state)).write_downgrade |write_mode| {\n+            (*borrow_rwlock(state)).write_downgrade(|write_mode| {\n                 check_poison(false, (*state).failed);\n                 blk(RWWriteMode {\n                     data: &mut (*state).data,\n                     token: write_mode,\n                     poison: PoisonOnFail(&mut (*state).failed)\n                 })\n-            }\n+            })\n         }\n     }\n \n@@ -544,9 +544,7 @@ impl<'self, T:Freeze + Send> RWWriteMode<'self, T> {\n                 token: ref token,\n                 poison: _\n             } => {\n-                do token.write {\n-                    blk(data)\n-                }\n+                token.write(|| blk(data))\n             }\n         }\n     }\n@@ -561,7 +559,7 @@ impl<'self, T:Freeze + Send> RWWriteMode<'self, T> {\n                 token: ref token,\n                 poison: ref poison\n             } => {\n-                do token.write_cond |cond| {\n+                token.write_cond(|cond| {\n                     unsafe {\n                         let cvar = Condvar {\n                             is_mutex: false,\n@@ -570,7 +568,7 @@ impl<'self, T:Freeze + Send> RWWriteMode<'self, T> {\n                         };\n                         blk(data, &cvar)\n                     }\n-                }\n+                })\n             }\n         }\n     }\n@@ -584,7 +582,7 @@ impl<'self, T:Freeze + Send> RWReadMode<'self, T> {\n                 data: data,\n                 token: ref token\n             } => {\n-                do token.read { blk(data) }\n+                token.read(|| blk(data))\n             }\n         }\n     }\n@@ -634,19 +632,19 @@ mod tests {\n         do task::spawn || {\n             // wait until parent gets in\n             p.take().recv();\n-            do arc2.access_cond |state, cond| {\n+            arc2.access_cond(|state, cond| {\n                 *state = true;\n                 cond.signal();\n-            }\n+            })\n         }\n \n-        do arc.access_cond |state, cond| {\n+        arc.access_cond(|state, cond| {\n             c.take().send(());\n             assert!(!*state);\n             while !*state {\n                 cond.wait();\n             }\n-        }\n+        })\n     }\n \n     #[test] #[should_fail]\n@@ -657,33 +655,33 @@ mod tests {\n \n         do spawn {\n             let _ = p.recv();\n-            do arc2.access_cond |one, cond| {\n+            arc2.access_cond(|one, cond| {\n                 cond.signal();\n                 // Parent should fail when it wakes up.\n                 assert_eq!(*one, 0);\n-            }\n+            })\n         }\n \n-        do arc.access_cond |one, cond| {\n+        arc.access_cond(|one, cond| {\n             c.send(());\n             while *one == 1 {\n                 cond.wait();\n             }\n-        }\n+        })\n     }\n \n     #[test] #[should_fail]\n     fn test_mutex_arc_poison() {\n         let arc = ~MutexArc::new(1);\n         let arc2 = ~arc.clone();\n         do task::try || {\n-            do arc2.access |one| {\n+            arc2.access(|one| {\n                 assert_eq!(*one, 2);\n-            }\n+            })\n         };\n-        do arc.access |one| {\n+        arc.access(|one| {\n             assert_eq!(*one, 1);\n-        }\n+        })\n     }\n \n     #[test] #[should_fail]\n@@ -692,10 +690,10 @@ mod tests {\n         let arc2 = ~(&arc).clone();\n         let (p, c) = comm::stream();\n         do task::spawn {\n-            do arc2.access |one| {\n+            arc2.access(|one| {\n                 c.send(());\n                 assert!(*one == 2);\n-            }\n+            })\n         }\n         let _ = p.recv();\n         let one = arc.unwrap();\n@@ -710,11 +708,11 @@ mod tests {\n             let arc = ~MutexArc::new(1);\n             let arc2 = ~MutexArc::new(*arc);\n             do task::spawn || {\n-                do (*arc2).unsafe_access |mutex| {\n-                    do (*mutex).access |one| {\n+                (*arc2).unsafe_access(|mutex| {\n+                    (*mutex).access(|one| {\n                         assert!(*one == 1);\n-                    }\n-                }\n+                    })\n+                })\n             };\n         }\n     }\n@@ -724,84 +722,84 @@ mod tests {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n         do task::try {\n-            do arc2.write |one| {\n+            arc2.write(|one| {\n                 assert_eq!(*one, 2);\n-            }\n+            })\n         };\n-        do arc.read |one| {\n+        arc.read(|one| {\n             assert_eq!(*one, 1);\n-        }\n+        })\n     }\n \n     #[test] #[should_fail]\n     fn test_rw_arc_poison_ww() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n         do task::try {\n-            do arc2.write |one| {\n+            arc2.write(|one| {\n                 assert_eq!(*one, 2);\n-            }\n+            })\n         };\n-        do arc.write |one| {\n+        arc.write(|one| {\n             assert_eq!(*one, 1);\n-        }\n+        })\n     }\n     #[test] #[should_fail]\n     fn test_rw_arc_poison_dw() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n         do task::try {\n-            do arc2.write_downgrade |mut write_mode| {\n-                do write_mode.write |one| {\n+            arc2.write_downgrade(|mut write_mode| {\n+                write_mode.write(|one| {\n                     assert_eq!(*one, 2);\n-                }\n-            }\n+                })\n+            })\n         };\n-        do arc.write |one| {\n+        arc.write(|one| {\n             assert_eq!(*one, 1);\n-        }\n+        })\n     }\n     #[test]\n     fn test_rw_arc_no_poison_rr() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n         do task::try {\n-            do arc2.read |one| {\n+            arc2.read(|one| {\n                 assert_eq!(*one, 2);\n-            }\n+            })\n         };\n-        do arc.read |one| {\n+        arc.read(|one| {\n             assert_eq!(*one, 1);\n-        }\n+        })\n     }\n     #[test]\n     fn test_rw_arc_no_poison_rw() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n         do task::try {\n-            do arc2.read |one| {\n+            arc2.read(|one| {\n                 assert_eq!(*one, 2);\n-            }\n+            })\n         };\n-        do arc.write |one| {\n+        arc.write(|one| {\n             assert_eq!(*one, 1);\n-        }\n+        })\n     }\n     #[test]\n     fn test_rw_arc_no_poison_dr() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n         do task::try {\n-            do arc2.write_downgrade |write_mode| {\n+            arc2.write_downgrade(|write_mode| {\n                 let read_mode = arc2.downgrade(write_mode);\n-                do read_mode.read |one| {\n+                read_mode.read(|one| {\n                     assert_eq!(*one, 2);\n-                }\n-            }\n+                })\n+            })\n         };\n-        do arc.write |one| {\n+        arc.write(|one| {\n             assert_eq!(*one, 1);\n-        }\n+        })\n     }\n     #[test]\n     fn test_rw_arc() {\n@@ -810,29 +808,29 @@ mod tests {\n         let (p, c) = comm::stream();\n \n         do task::spawn {\n-            do arc2.write |num| {\n-                do 10.times {\n+            arc2.write(|num| {\n+                10.times(|| {\n                     let tmp = *num;\n                     *num = -1;\n                     task::deschedule();\n                     *num = tmp + 1;\n-                }\n+                });\n                 c.send(());\n-            }\n+            })\n         }\n \n         // Readers try to catch the writer in the act\n         let mut children = ~[];\n-        do 5.times {\n+        5.times(|| {\n             let arc3 = arc.clone();\n             let mut builder = task::task();\n             children.push(builder.future_result());\n             do builder.spawn {\n-                do arc3.read |num| {\n+                arc3.read(|num| {\n                     assert!(*num >= 0);\n-                }\n+                })\n             }\n-        }\n+        });\n \n         // Wait for children to pass their asserts\n         for r in children.iter() {\n@@ -841,9 +839,9 @@ mod tests {\n \n         // Wait for writer to finish\n         p.recv();\n-        do arc.read |num| {\n+        arc.read(|num| {\n             assert_eq!(*num, 10);\n-        }\n+        })\n     }\n     #[test]\n     fn test_rw_downgrade() {\n@@ -857,42 +855,42 @@ mod tests {\n \n         // Reader tasks\n         let mut reader_convos = ~[];\n-        do 10.times {\n+        10.times(|| {\n             let ((rp1, rc1), (rp2, rc2)) = (comm::stream(), comm::stream());\n             reader_convos.push((rc1, rp2));\n             let arcn = arc.clone();\n             do task::spawn {\n                 rp1.recv(); // wait for downgrader to give go-ahead\n-                do arcn.read |state| {\n+                arcn.read(|state| {\n                     assert_eq!(*state, 31337);\n                     rc2.send(());\n-                }\n+                })\n             }\n-        }\n+        });\n \n         // Writer task\n         let arc2 = arc.clone();\n         let ((wp1, wc1), (wp2, wc2)) = (comm::stream(), comm::stream());\n         do task::spawn || {\n             wp1.recv();\n-            do arc2.write_cond |state, cond| {\n+            arc2.write_cond(|state, cond| {\n                 assert_eq!(*state, 0);\n                 *state = 42;\n                 cond.signal();\n-            }\n+            });\n             wp1.recv();\n-            do arc2.write |state| {\n+            arc2.write(|state| {\n                 // This shouldn't happen until after the downgrade read\n                 // section, and all other readers, finish.\n                 assert_eq!(*state, 31337);\n                 *state = 42;\n-            }\n+            });\n             wc2.send(());\n         }\n \n         // Downgrader (us)\n-        do arc.write_downgrade |mut write_mode| {\n-            do write_mode.write_cond |state, cond| {\n+        arc.write_downgrade(|mut write_mode| {\n+            write_mode.write_cond(|state, cond| {\n                 wc1.send(()); // send to another writer who will wake us up\n                 while *state == 0 {\n                     cond.wait();\n@@ -903,17 +901,17 @@ mod tests {\n                 for &(ref rc, _) in reader_convos.iter() {\n                     rc.send(())\n                 }\n-            }\n+            });\n             let read_mode = arc.downgrade(write_mode);\n-            do read_mode.read |state| {\n+            read_mode.read(|state| {\n                 // complete handshake with other readers\n                 for &(_, ref rp) in reader_convos.iter() {\n                     rp.recv()\n                 }\n                 wc1.send(()); // tell writer to try again\n                 assert_eq!(*state, 31337);\n-            }\n-        }\n+            });\n+        });\n \n         wp2.recv(); // complete handshake with writer\n     }\n@@ -934,49 +932,49 @@ mod tests {\n         // writer task\n         let xw = x.clone();\n         do task::spawn {\n-            do xw.write_cond |state, c| {\n+            xw.write_cond(|state, c| {\n                 wc.send(()); // tell downgrader it's ok to go\n                 c.wait();\n                 // The core of the test is here: the condvar reacquire path\n                 // must involve order_lock, so that it cannot race with a reader\n                 // trying to receive the \"reader cloud lock hand-off\".\n                 *state = false;\n-            }\n+            })\n         }\n \n         wp.recv(); // wait for writer to get in\n \n-        do x.write_downgrade |mut write_mode| {\n-            do write_mode.write_cond |state, c| {\n+        x.write_downgrade(|mut write_mode| {\n+            write_mode.write_cond(|state, c| {\n                 assert!(*state);\n                 // make writer contend in the cond-reacquire path\n                 c.signal();\n-            }\n+            });\n             // make a reader task to trigger the \"reader cloud lock\" handoff\n             let xr = x.clone();\n             let (rp, rc) = comm::stream();\n             do task::spawn {\n                 rc.send(());\n-                do xr.read |_state| { }\n+                xr.read(|_state| { })\n             }\n             rp.recv(); // wait for reader task to exist\n \n             let read_mode = x.downgrade(write_mode);\n-            do read_mode.read |state| {\n+            read_mode.read(|state| {\n                 // if writer mistakenly got in, make sure it mutates state\n                 // before we assert on it\n-                do 5.times { task::deschedule(); }\n+                5.times(|| task::deschedule());\n                 // make sure writer didn't get in.\n                 assert!(*state);\n-            }\n-        }\n+            })\n+        });\n     }\n     #[test]\n     fn test_rw_write_cond_downgrade_read_race() {\n         // Ideally the above test case would have deschedule statements in it that\n         // helped to expose the race nearly 100% of the time... but adding\n         // deschedules in the intuitively-right locations made it even less likely,\n         // and I wasn't sure why :( . This is a mediocre \"next best\" option.\n-        do 8.times { test_rw_write_cond_downgrade_read_race_helper() }\n+        8.times(|| test_rw_write_cond_downgrade_read_race_helper());\n     }\n }"}, {"sha": "7da9ac2aed80b5b009fe57e4420d78b1a9c98a65", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -96,12 +96,12 @@ impl Drop for Arena {\n     fn drop(&mut self) {\n         unsafe {\n             destroy_chunk(&self.head);\n-            do self.chunks.each |chunk| {\n+            self.chunks.each(|chunk| {\n                 if !chunk.is_pod {\n                     destroy_chunk(chunk);\n                 }\n                 true\n-            };\n+            });\n         }\n     }\n }\n@@ -282,10 +282,10 @@ fn test_arena_destructors() {\n     for i in range(0u, 10) {\n         // Arena allocate something with drop glue to make sure it\n         // doesn't leak.\n-        do arena.alloc { @i };\n+        arena.alloc(|| @i);\n         // Allocate something with funny size and alignment, to keep\n         // things interesting.\n-        do arena.alloc { [0u8, 1u8, 2u8] };\n+        arena.alloc(|| [0u8, 1u8, 2u8]);\n     }\n }\n "}, {"sha": "306a2abca5506bd131fb4f5e3a4334d3bc9fb018", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -166,7 +166,9 @@ impl BigBitv {\n     }\n \n     #[inline]\n-    pub fn negate(&mut self) { do self.each_storage |w| { *w = !*w; true }; }\n+    pub fn negate(&mut self) {\n+        self.each_storage(|w| { *w = !*w; true });\n+    }\n \n     #[inline]\n     pub fn union(&mut self, b: &BigBitv, nbits: uint) -> bool {\n@@ -358,26 +360,32 @@ impl Bitv {\n     #[inline]\n     pub fn clear(&mut self) {\n         match self.rep {\n-          Small(ref mut b) => b.clear(),\n-          Big(ref mut s) => { do s.each_storage() |w| { *w = 0u; true }; }\n+            Small(ref mut b) => b.clear(),\n+            Big(ref mut s) => {\n+                s.each_storage(|w| { *w = 0u; true });\n+            }\n         }\n     }\n \n     /// Set all bits to 1\n     #[inline]\n     pub fn set_all(&mut self) {\n-      match self.rep {\n-        Small(ref mut b) => b.set_all(),\n-        Big(ref mut s) => { do s.each_storage() |w| { *w = !0u; true }; }\n-      }\n+        match self.rep {\n+            Small(ref mut b) => b.set_all(),\n+            Big(ref mut s) => {\n+                s.each_storage(|w| { *w = !0u; true });\n+            }\n+        }\n     }\n \n     /// Invert all bits\n     #[inline]\n     pub fn negate(&mut self) {\n-      match self.rep {\n-        Small(ref mut b) => b.negate(),\n-        Big(ref mut s) => { do s.each_storage() |w| { *w = !*w; true }; }\n+        match self.rep {\n+            Small(ref mut b) => b.negate(),\n+            Big(ref mut s) => {\n+                s.each_storage(|w| { *w = !*w; true });\n+            }\n       }\n     }\n \n@@ -651,10 +659,10 @@ impl BitvSet {\n     /// Creates a new bit vector set from the given bit vector\n     pub fn from_bitv(bitv: Bitv) -> BitvSet {\n         let mut size = 0;\n-        do bitv.ones |_| {\n+        bitv.ones(|_| {\n             size += 1;\n             true\n-        };\n+        });\n         let Bitv{rep, _} = bitv;\n         match rep {\n             Big(b) => BitvSet{ size: size, bitv: b },\n@@ -786,7 +794,7 @@ impl Container for BitvSet {\n \n impl Mutable for BitvSet {\n     fn clear(&mut self) {\n-        do self.bitv.each_storage |w| { *w = 0; true };\n+        self.bitv.each_storage(|w| { *w = 0; true });\n         self.size = 0;\n     }\n }\n@@ -797,9 +805,7 @@ impl Set<uint> for BitvSet {\n     }\n \n     fn is_disjoint(&self, other: &BitvSet) -> bool {\n-        do self.intersection(other) |_| {\n-            false\n-        }\n+        self.intersection(other, |_| false)\n     }\n \n     fn is_subset(&self, other: &BitvSet) -> bool {"}, {"sha": "d24f285ced21ea7a144affbf079f12313249ecc4", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -114,10 +114,10 @@ impl<T: Send> GenericPort<T> for SyncPort<T> {\n     }\n \n     fn try_recv(&self) -> Option<T> {\n-        do self.duplex_stream.try_recv().map |val| {\n+        self.duplex_stream.try_recv().map(|val| {\n             self.duplex_stream.try_send(());\n             val\n-        }\n+        })\n     }\n }\n "}, {"sha": "a261a2483052fa36532799493c2129c46ca3d285", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -165,14 +165,14 @@ impl<T> DList<T> {\n     /// Remove the first Node and return it, or None if the list is empty\n     #[inline]\n     fn pop_front_node(&mut self) -> Option<~Node<T>> {\n-        do self.list_head.take().map |mut front_node| {\n+        self.list_head.take().map(|mut front_node| {\n             self.length -= 1;\n             match front_node.next.take() {\n                 Some(node) => self.list_head = link_with_prev(node, Rawlink::none()),\n                 None => self.list_tail = Rawlink::none()\n             }\n             front_node\n-        }\n+        })\n     }\n \n     /// Add a Node last in the list\n@@ -191,14 +191,14 @@ impl<T> DList<T> {\n     /// Remove the last Node and return it, or None if the list is empty\n     #[inline]\n     fn pop_back_node(&mut self) -> Option<~Node<T>> {\n-        do self.list_tail.resolve().map_default(None) |tail| {\n+        self.list_tail.resolve().map_default(None, |tail| {\n             self.length -= 1;\n             self.list_tail = tail.prev;\n             match tail.prev.resolve() {\n                 None => self.list_head.take(),\n                 Some(tail_prev) => tail_prev.next.take()\n             }\n-        }\n+        })\n     }\n }\n \n@@ -270,19 +270,19 @@ impl<T> DList<T> {\n     /// If the list is empty, do nothing.\n     #[inline]\n     pub fn rotate_forward(&mut self) {\n-        do self.pop_back_node().map |tail| {\n+        self.pop_back_node().map(|tail| {\n             self.push_front_node(tail)\n-        };\n+        });\n     }\n \n     /// Move the first element to the back of the list.\n     ///\n     /// If the list is empty, do nothing.\n     #[inline]\n     pub fn rotate_backward(&mut self) {\n-        do self.pop_front_node().map |head| {\n+        self.pop_front_node().map(|head| {\n             self.push_back_node(head)\n-        };\n+        });\n     }\n \n     /// Add all elements from `other` to the end of the list\n@@ -444,11 +444,11 @@ impl<'self, A> Iterator<&'self A> for DListIterator<'self, A> {\n         if self.nelem == 0 {\n             return None;\n         }\n-        do self.head.as_ref().map |head| {\n+        self.head.as_ref().map(|head| {\n             self.nelem -= 1;\n             self.head = &head.next;\n             &head.value\n-        }\n+        })\n     }\n \n     #[inline]\n@@ -464,11 +464,11 @@ impl<'self, A> DoubleEndedIterator<&'self A> for DListIterator<'self, A> {\n             return None;\n         }\n         let tmp = self.tail.resolve_immut(); // FIXME: #3511: shouldn't need variable\n-        do tmp.as_ref().map |prev| {\n+        tmp.as_ref().map(|prev| {\n             self.nelem -= 1;\n             self.tail = prev.prev;\n             &prev.value\n-        }\n+        })\n     }\n }\n \n@@ -480,14 +480,14 @@ impl<'self, A> Iterator<&'self mut A> for MutDListIterator<'self, A> {\n         if self.nelem == 0 {\n             return None;\n         }\n-        do self.head.resolve().map |next| {\n+        self.head.resolve().map(|next| {\n             self.nelem -= 1;\n             self.head = match next.next {\n                 Some(ref mut node) => Rawlink::some(&mut **node),\n                 None => Rawlink::none(),\n             };\n             &mut next.value\n-        }\n+        })\n     }\n \n     #[inline]\n@@ -502,11 +502,11 @@ impl<'self, A> DoubleEndedIterator<&'self mut A> for MutDListIterator<'self, A>\n         if self.nelem == 0 {\n             return None;\n         }\n-        do self.tail.resolve().map |prev| {\n+        self.tail.resolve().map(|prev| {\n             self.nelem -= 1;\n             self.tail = prev.prev;\n             &mut prev.value\n-        }\n+        })\n     }\n }\n "}, {"sha": "19959dd2705fc939f2fad26c04d96affedf5010c", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -546,24 +546,24 @@ pub mod reader {\n \n         fn read_option<T>(&mut self, f: |&mut Decoder, bool| -> T) -> T {\n             debug!(\"read_option()\");\n-            do self.read_enum(\"Option\") |this| {\n-                do this.read_enum_variant([\"None\", \"Some\"]) |this, idx| {\n+            self.read_enum(\"Option\", |this| {\n+                this.read_enum_variant([\"None\", \"Some\"], |this, idx| {\n                     match idx {\n                         0 => f(this, false),\n                         1 => f(this, true),\n                         _ => fail!(),\n                     }\n-                }\n-            }\n+                })\n+            })\n         }\n \n         fn read_seq<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n             debug!(\"read_seq()\");\n-            do self.push_doc(EsVec) |d| {\n+            self.push_doc(EsVec, |d| {\n                 let len = d._next_uint(EsVecLen);\n                 debug!(\"  len={}\", len);\n                 f(d, len)\n-            }\n+            })\n         }\n \n         fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n@@ -574,11 +574,11 @@ pub mod reader {\n \n         fn read_map<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n             debug!(\"read_map()\");\n-            do self.push_doc(EsMap) |d| {\n+            self.push_doc(EsMap, |d| {\n                 let len = d._next_uint(EsMapLen);\n                 debug!(\"  len={}\", len);\n                 f(d, len)\n-            }\n+            })\n         }\n \n         fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n@@ -687,43 +687,43 @@ pub mod writer {\n         }\n \n         pub fn wr_tagged_u64(&mut self, tag_id: uint, v: u64) {\n-            do u64_to_be_bytes(v, 8u) |v| {\n+            u64_to_be_bytes(v, 8u, |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n-            }\n+            })\n         }\n \n         pub fn wr_tagged_u32(&mut self, tag_id: uint, v: u32) {\n-            do u64_to_be_bytes(v as u64, 4u) |v| {\n+            u64_to_be_bytes(v as u64, 4u, |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n-            }\n+            })\n         }\n \n         pub fn wr_tagged_u16(&mut self, tag_id: uint, v: u16) {\n-            do u64_to_be_bytes(v as u64, 2u) |v| {\n+            u64_to_be_bytes(v as u64, 2u, |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n-            }\n+            })\n         }\n \n         pub fn wr_tagged_u8(&mut self, tag_id: uint, v: u8) {\n             self.wr_tagged_bytes(tag_id, &[v]);\n         }\n \n         pub fn wr_tagged_i64(&mut self, tag_id: uint, v: i64) {\n-            do u64_to_be_bytes(v as u64, 8u) |v| {\n+            u64_to_be_bytes(v as u64, 8u, |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n-            }\n+            })\n         }\n \n         pub fn wr_tagged_i32(&mut self, tag_id: uint, v: i32) {\n-            do u64_to_be_bytes(v as u64, 4u) |v| {\n+            u64_to_be_bytes(v as u64, 4u, |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n-            }\n+            })\n         }\n \n         pub fn wr_tagged_i16(&mut self, tag_id: uint, v: i16) {\n-            do u64_to_be_bytes(v as u64, 2u) |v| {\n+            u64_to_be_bytes(v as u64, 2u, |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n-            }\n+            })\n         }\n \n         pub fn wr_tagged_i8(&mut self, tag_id: uint, v: i8) {"}, {"sha": "1a295010dc4dd6acc4091bac359be6abc984ec4c", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -47,7 +47,7 @@ static TINFL_FLAG_PARSE_ZLIB_HEADER : c_int = 0x1; // parse zlib header and adle\n static TDEFL_WRITE_ZLIB_HEADER : c_int = 0x01000; // write zlib header and adler32 checksum\n \n fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n-    do bytes.as_imm_buf |b, len| {\n+    bytes.as_imm_buf(|b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n             let res =\n@@ -61,7 +61,7 @@ fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n             libc::free(res);\n             out\n         }\n-    }\n+    })\n }\n \n pub fn deflate_bytes(bytes: &[u8]) -> ~[u8] {\n@@ -73,7 +73,7 @@ pub fn deflate_bytes_zlib(bytes: &[u8]) -> ~[u8] {\n }\n \n fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n-    do bytes.as_imm_buf |b, len| {\n+    bytes.as_imm_buf(|b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n             let res =\n@@ -87,7 +87,7 @@ fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n             libc::free(res);\n             out\n         }\n-    }\n+    })\n }\n \n pub fn inflate_bytes(bytes: &[u8]) -> ~[u8] {"}, {"sha": "8cdadca1cc2968f6e4732285f584c798e028425e", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -726,9 +726,9 @@ pub mod groups {\n             // here we just need to indent the start of the description\n             let rowlen = row.char_len();\n             if rowlen < 24 {\n-                do (24 - rowlen).times {\n+                (24 - rowlen).times(|| {\n                     row.push_char(' ')\n-                }\n+                })\n             } else {\n                 row.push_str(desc_sep)\n             }\n@@ -742,10 +742,10 @@ pub mod groups {\n \n             // FIXME: #5516 should be graphemes not codepoints\n             let mut desc_rows = ~[];\n-            do each_split_within(desc_normalized_whitespace, 54) |substr| {\n+            each_split_within(desc_normalized_whitespace, 54, |substr| {\n                 desc_rows.push(substr.to_owned());\n                 true\n-            };\n+            });\n \n             // FIXME: #5516 should be graphemes not codepoints\n             // wrapped description\n@@ -840,7 +840,7 @@ pub mod groups {\n     fn test_split_within() {\n         fn t(s: &str, i: uint, u: &[~str]) {\n             let mut v = ~[];\n-            do each_split_within(s, i) |s| { v.push(s.to_owned()); true };\n+            each_split_within(s, i, |s| { v.push(s.to_owned()); true });\n             assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n         t(\"\", 0, []);"}, {"sha": "3ee43ca4a5852fea5054dcae7a09551b624973fb", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -310,9 +310,9 @@ impl Pattern {\n      */\n     pub fn matches_path(&self, path: &Path) -> bool {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        do path.as_str().map_default(false) |s| {\n+        path.as_str().map_default(false, |s| {\n             self.matches(s)\n-        }\n+        })\n     }\n \n     /**\n@@ -328,9 +328,9 @@ impl Pattern {\n      */\n     pub fn matches_path_with(&self, path: &Path, options: MatchOptions) -> bool {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        do path.as_str().map_default(false) |s| {\n+        path.as_str().map_default(false, |s| {\n             self.matches_with(s, options)\n-        }\n+        })\n     }\n \n     fn matches_from(&self,"}, {"sha": "cb138099cbced8da7484fc94dfab69f74b41dcc5", "filename": "src/libextra/json.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -79,9 +79,7 @@ fn escape_str(s: &str) -> ~str {\n \n fn spaces(n: uint) -> ~str {\n     let mut ss = ~\"\";\n-    do n.times {\n-        ss.push_str(\" \");\n-    }\n+    n.times(|| ss.push_str(\" \"));\n     return ss;\n }\n "}, {"sha": "a2540d3948e8920cf3f54ff07e14ebecc5a805b2", "filename": "src/libextra/list.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flist.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -46,7 +46,7 @@ pub fn from_vec<T:Clone + 'static>(v: &[T]) -> @List<T> {\n  */\n pub fn foldl<T:Clone,U>(z: T, ls: @List<U>, f: |&T, &U| -> T) -> T {\n     let mut accum: T = z;\n-    do iter(ls) |elt| { accum = f(&accum, elt);}\n+    iter(ls, |elt| accum = f(&accum, elt));\n     accum\n }\n \n@@ -73,9 +73,9 @@ pub fn find<T:Clone>(ls: @List<T>, f: |&T| -> bool) -> Option<T> {\n /// Returns true if a list contains an element with the given value\n pub fn has<T:Eq>(ls: @List<T>, elt: T) -> bool {\n     let mut found = false;\n-    do each(ls) |e| {\n+    each(ls, |e| {\n         if *e == elt { found = true; false } else { true }\n-    };\n+    });\n     return found;\n }\n "}, {"sha": "5b3de10b8b08f42dc7ec6fa69eba0abb34e3c2af", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -158,36 +158,36 @@ impl Orderable for BigUint {\n impl BitAnd<BigUint, BigUint> for BigUint {\n     fn bitand(&self, other: &BigUint) -> BigUint {\n         let new_len = num::min(self.data.len(), other.data.len());\n-        let anded = do vec::from_fn(new_len) |i| {\n+        let anded = vec::from_fn(new_len, |i| {\n             // i will never be less than the size of either data vector\n             let ai = self.data[i];\n             let bi = other.data[i];\n             ai & bi\n-        };\n+        });\n         return BigUint::new(anded);\n     }\n }\n \n impl BitOr<BigUint, BigUint> for BigUint {\n     fn bitor(&self, other: &BigUint) -> BigUint {\n         let new_len = num::max(self.data.len(), other.data.len());\n-        let ored = do vec::from_fn(new_len) |i| {\n+        let ored = vec::from_fn(new_len, |i| {\n             let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n             let bi = if i < other.data.len() { other.data[i] } else { 0 };\n             ai | bi\n-        };\n+        });\n         return BigUint::new(ored);\n     }\n }\n \n impl BitXor<BigUint, BigUint> for BigUint {\n     fn bitxor(&self, other: &BigUint) -> BigUint {\n         let new_len = num::max(self.data.len(), other.data.len());\n-        let xored = do vec::from_fn(new_len) |i| {\n+        let xored = vec::from_fn(new_len, |i| {\n             let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n             let bi = if i < other.data.len() { other.data[i] } else { 0 };\n             ai ^ bi\n-        };\n+        });\n         return BigUint::new(xored);\n     }\n }\n@@ -230,15 +230,15 @@ impl Add<BigUint, BigUint> for BigUint {\n         let new_len = num::max(self.data.len(), other.data.len());\n \n         let mut carry = 0;\n-        let mut sum = do vec::from_fn(new_len) |i| {\n+        let mut sum = vec::from_fn(new_len, |i| {\n             let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n             let bi = if i < other.data.len() { other.data[i] } else { 0 };\n             let (hi, lo) = BigDigit::from_uint(\n                 (ai as uint) + (bi as uint) + (carry as uint)\n             );\n             carry = hi;\n             lo\n-        };\n+        });\n         if carry != 0 { sum.push(carry); }\n         return BigUint::new(sum);\n     }\n@@ -249,7 +249,7 @@ impl Sub<BigUint, BigUint> for BigUint {\n         let new_len = num::max(self.data.len(), other.data.len());\n \n         let mut borrow = 0;\n-        let diff = do vec::from_fn(new_len) |i| {\n+        let diff = vec::from_fn(new_len, |i| {\n             let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n             let bi = if i < other.data.len() { other.data[i] } else { 0 };\n             let (hi, lo) = BigDigit::from_uint(\n@@ -262,7 +262,7 @@ impl Sub<BigUint, BigUint> for BigUint {\n             */\n             borrow = if hi == 0 { 1 } else { 0 };\n             lo\n-        };\n+        });\n \n         assert_eq!(borrow, 0);     // <=> assert!((self >= other));\n         return BigUint::new(diff);\n@@ -306,13 +306,13 @@ impl Mul<BigUint, BigUint> for BigUint {\n             if n == 1 { return (*a).clone(); }\n \n             let mut carry = 0;\n-            let mut prod = do a.data.iter().map |ai| {\n+            let mut prod = a.data.iter().map(|ai| {\n                 let (hi, lo) = BigDigit::from_uint(\n                     (*ai as uint) * (n as uint) + (carry as uint)\n                 );\n                 carry = hi;\n                 lo\n-            }.collect::<~[BigDigit]>();\n+            }).collect::<~[BigDigit]>();\n             if carry != 0 { prod.push(carry); }\n             return BigUint::new(prod);\n         }\n@@ -504,14 +504,14 @@ impl Integer for BigUint {\n impl ToPrimitive for BigUint {\n     #[inline]\n     fn to_i64(&self) -> Option<i64> {\n-        do self.to_u64().and_then |n| {\n+        self.to_u64().and_then(|n| {\n             // If top bit of u64 is set, it's too large to convert to i64.\n             if n >> 63 == 0 {\n                 Some(n as i64)\n             } else {\n                 None\n             }\n-        }\n+        })\n     }\n \n     #[cfg(target_word_size = \"32\")]\n@@ -763,13 +763,13 @@ impl BigUint {\n         if n_bits == 0 || self.is_zero() { return (*self).clone(); }\n \n         let mut carry = 0;\n-        let mut shifted = do self.data.iter().map |elem| {\n+        let mut shifted = self.data.iter().map(|elem| {\n             let (hi, lo) = BigDigit::from_uint(\n                 (*elem as uint) << n_bits | (carry as uint)\n             );\n             carry = hi;\n             lo\n-        }.collect::<~[BigDigit]>();\n+        }).collect::<~[BigDigit]>();\n         if carry != 0 { shifted.push(carry); }\n         return BigUint::new(shifted);\n     }\n@@ -1182,7 +1182,7 @@ impl ToPrimitive for BigInt {\n             Plus  => self.data.to_i64(),\n             Zero  => Some(0),\n             Minus => {\n-                do self.data.to_u64().and_then |n| {\n+                self.data.to_u64().and_then(|n| {\n                     let m: u64 = 1 << 63;\n                     if n < m {\n                         Some(-(n as i64))\n@@ -1191,7 +1191,7 @@ impl ToPrimitive for BigInt {\n                     } else {\n                         None\n                     }\n-                }\n+                })\n             }\n         }\n     }\n@@ -1210,13 +1210,14 @@ impl FromPrimitive for BigInt {\n     #[inline]\n     fn from_i64(n: i64) -> Option<BigInt> {\n         if n > 0 {\n-            do FromPrimitive::from_u64(n as u64).and_then |n| {\n+            FromPrimitive::from_u64(n as u64).and_then(|n| {\n                 Some(BigInt::from_biguint(Plus, n))\n-            }\n+            })\n         } else if n < 0 {\n-            do FromPrimitive::from_u64(u64::max_value - (n as u64) + 1).and_then |n| {\n-                Some(BigInt::from_biguint(Minus, n))\n-            }\n+            FromPrimitive::from_u64(u64::max_value - (n as u64) + 1).and_then(\n+                |n| {\n+                    Some(BigInt::from_biguint(Minus, n))\n+                })\n         } else {\n             Some(Zero::zero())\n         }\n@@ -1227,9 +1228,9 @@ impl FromPrimitive for BigInt {\n         if n == 0 {\n             Some(Zero::zero())\n         } else {\n-            do FromPrimitive::from_u64(n).and_then |n| {\n+            FromPrimitive::from_u64(n).and_then(|n| {\n                 Some(BigInt::from_biguint(Plus, n))\n-            }\n+            })\n         }\n     }\n }\n@@ -2051,22 +2052,22 @@ mod biguint_tests {\n     fn test_rand_range() {\n         let mut rng = task_rng();\n \n-        do 10.times {\n+        10.times(|| {\n             assert_eq!(rng.gen_bigint_range(&FromPrimitive::from_uint(236).unwrap(),\n                                             &FromPrimitive::from_uint(237).unwrap()),\n                        FromPrimitive::from_uint(236).unwrap());\n-        }\n+        });\n \n         let l = FromPrimitive::from_uint(403469000 + 2352).unwrap();\n         let u = FromPrimitive::from_uint(403469000 + 3513).unwrap();\n-        do 1000.times {\n+        1000.times(|| {\n             let n: BigUint = rng.gen_biguint_below(&u);\n             assert!(n < u);\n \n             let n: BigUint = rng.gen_biguint_range(&l, &u);\n             assert!(n >= l);\n             assert!(n < u);\n-        }\n+        })\n     }\n \n     #[test]\n@@ -2548,19 +2549,19 @@ mod bigint_tests {\n     fn test_rand_range() {\n         let mut rng = task_rng();\n \n-        do 10.times {\n+        10.times(|| {\n             assert_eq!(rng.gen_bigint_range(&FromPrimitive::from_uint(236).unwrap(),\n                                             &FromPrimitive::from_uint(237).unwrap()),\n                        FromPrimitive::from_uint(236).unwrap());\n-        }\n+        });\n \n         fn check(l: BigInt, u: BigInt) {\n             let mut rng = task_rng();\n-            do 1000.times {\n+            1000.times(|| {\n                 let n: BigInt = rng.gen_bigint_range(&l, &u);\n                 assert!(n >= l);\n                 assert!(n < u);\n-            }\n+            });\n         }\n         let l: BigInt = FromPrimitive::from_uint(403469000 + 2352).unwrap();\n         let u: BigInt = FromPrimitive::from_uint(403469000 + 3513).unwrap();\n@@ -2614,19 +2615,19 @@ mod bench {\n \n     #[bench]\n     fn factorial_100(bh: &mut BenchHarness) {\n-        do bh.iter { factorial(100);  }\n+        bh.iter(|| factorial(100));\n     }\n \n     #[bench]\n     fn fib_100(bh: &mut BenchHarness) {\n-        do bh.iter { fib(100); }\n+        bh.iter(|| fib(100));\n     }\n \n     #[bench]\n     fn to_str(bh: &mut BenchHarness) {\n         let fac = factorial(100);\n         let fib = fib(100);\n-        do bh.iter { fac.to_str(); }\n-        do bh.iter { fib.to_str(); }\n+        bh.iter(|| fac.to_str());\n+        bh.iter(|| fib.to_str());\n     }\n }"}, {"sha": "1aa03350305fcdcb65671ec4a34d0ac67a546ef5", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -297,12 +297,12 @@ impl<T: FromStr + Clone + Integer + Ord>\n             return None\n         }\n         let a_option: Option<T> = FromStr::from_str(split[0]);\n-        do a_option.and_then |a| {\n+        a_option.and_then(|a| {\n             let b_option: Option<T> = FromStr::from_str(split[1]);\n-            do b_option.and_then |b| {\n+            b_option.and_then(|b| {\n                 Some(Ratio::new(a.clone(), b.clone()))\n-            }\n-        }\n+            })\n+        })\n     }\n }\n impl<T: FromStrRadix + Clone + Integer + Ord>\n@@ -315,13 +315,13 @@ impl<T: FromStrRadix + Clone + Integer + Ord>\n         } else {\n             let a_option: Option<T> = FromStrRadix::from_str_radix(split[0],\n                                                                    radix);\n-            do a_option.and_then |a| {\n+            a_option.and_then(|a| {\n                 let b_option: Option<T> =\n                     FromStrRadix::from_str_radix(split[1], radix);\n-                do b_option.and_then |b| {\n+                b_option.and_then(|b| {\n                     Some(Ratio::new(a.clone(), b.clone()))\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n }"}, {"sha": "cdaac93c1fcd38b1da961569985f9dbd741b4b96", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -238,14 +238,14 @@ pub fn parse(s: &str) -> Option<Version> {\n     }\n     let s = s.trim();\n     let mut bad = false;\n-    do bad_parse::cond.trap(|_| { debug!(\"bad\"); bad = true }).inside {\n+    bad_parse::cond.trap(|_| { debug!(\"bad\"); bad = true }).inside(|| {\n         let v = parse_iter(&mut s.chars());\n         if bad || v.to_str() != s.to_owned() {\n             None\n         } else {\n             Some(v)\n         }\n-    }\n+    })\n }\n \n #[test]"}, {"sha": "aa63ac102e4929c7248c4240113710b21414eb99", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -440,99 +440,99 @@ impl<D:Decoder,T:Decodable<D> + 'static> Decodable<D> for @mut T {\n \n impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self [T] {\n     fn encode(&self, s: &mut S) {\n-        do s.emit_seq(self.len()) |s| {\n+        s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))\n             }\n-        }\n+        })\n     }\n }\n \n impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~[T] {\n     fn encode(&self, s: &mut S) {\n-        do s.emit_seq(self.len()) |s| {\n+        s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))\n             }\n-        }\n+        })\n     }\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n     fn decode(d: &mut D) -> ~[T] {\n-        do d.read_seq |d, len| {\n-            do vec::from_fn(len) |i| {\n+        d.read_seq(|d, len| {\n+            vec::from_fn(len, |i| {\n                 d.read_seq_elt(i, |d| Decodable::decode(d))\n-            }\n-        }\n+            })\n+        })\n     }\n }\n \n impl<S:Encoder,T:Encodable<S>> Encodable<S> for @[T] {\n     fn encode(&self, s: &mut S) {\n-        do s.emit_seq(self.len()) |s| {\n+        s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))\n             }\n-        }\n+        })\n     }\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for @[T] {\n     fn decode(d: &mut D) -> @[T] {\n-        do d.read_seq |d, len| {\n-            do at_vec::from_fn(len) |i| {\n+        d.read_seq(|d, len| {\n+            at_vec::from_fn(len, |i| {\n                 d.read_seq_elt(i, |d| Decodable::decode(d))\n-            }\n-        }\n+            })\n+        })\n     }\n }\n \n impl<S:Encoder,T:Encodable<S>> Encodable<S> for Option<T> {\n     fn encode(&self, s: &mut S) {\n-        do s.emit_option |s| {\n+        s.emit_option(|s| {\n             match *self {\n                 None => s.emit_option_none(),\n                 Some(ref v) => s.emit_option_some(|s| v.encode(s)),\n             }\n-        }\n+        })\n     }\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for Option<T> {\n     fn decode(d: &mut D) -> Option<T> {\n-        do d.read_option |d, b| {\n+        d.read_option(|d, b| {\n             if b {\n                 Some(Decodable::decode(d))\n             } else {\n                 None\n             }\n-        }\n+        })\n     }\n }\n \n impl<S:Encoder,T0:Encodable<S>,T1:Encodable<S>> Encodable<S> for (T0, T1) {\n     fn encode(&self, s: &mut S) {\n         match *self {\n             (ref t0, ref t1) => {\n-                do s.emit_seq(2) |s| {\n+                s.emit_seq(2, |s| {\n                     s.emit_seq_elt(0, |s| t0.encode(s));\n                     s.emit_seq_elt(1, |s| t1.encode(s));\n-                }\n+                })\n             }\n         }\n     }\n }\n \n impl<D:Decoder,T0:Decodable<D>,T1:Decodable<D>> Decodable<D> for (T0, T1) {\n     fn decode(d: &mut D) -> (T0, T1) {\n-        do d.read_seq |d, len| {\n+        d.read_seq(|d, len| {\n             assert_eq!(len, 2);\n             (\n                 d.read_seq_elt(0, |d| Decodable::decode(d)),\n                 d.read_seq_elt(1, |d| Decodable::decode(d))\n             )\n-        }\n+        })\n     }\n }\n \n@@ -545,11 +545,11 @@ impl<\n     fn encode(&self, s: &mut S) {\n         match *self {\n             (ref t0, ref t1, ref t2) => {\n-                do s.emit_seq(3) |s| {\n+                s.emit_seq(3, |s| {\n                     s.emit_seq_elt(0, |s| t0.encode(s));\n                     s.emit_seq_elt(1, |s| t1.encode(s));\n                     s.emit_seq_elt(2, |s| t2.encode(s));\n-                }\n+                })\n             }\n         }\n     }\n@@ -562,14 +562,14 @@ impl<\n     T2: Decodable<D>\n > Decodable<D> for (T0, T1, T2) {\n     fn decode(d: &mut D) -> (T0, T1, T2) {\n-        do d.read_seq |d, len| {\n+        d.read_seq(|d, len| {\n             assert_eq!(len, 3);\n             (\n                 d.read_seq_elt(0, |d| Decodable::decode(d)),\n                 d.read_seq_elt(1, |d| Decodable::decode(d)),\n                 d.read_seq_elt(2, |d| Decodable::decode(d))\n             )\n-        }\n+        })\n     }\n }\n \n@@ -583,12 +583,12 @@ impl<\n     fn encode(&self, s: &mut S) {\n         match *self {\n             (ref t0, ref t1, ref t2, ref t3) => {\n-                do s.emit_seq(4) |s| {\n+                s.emit_seq(4, |s| {\n                     s.emit_seq_elt(0, |s| t0.encode(s));\n                     s.emit_seq_elt(1, |s| t1.encode(s));\n                     s.emit_seq_elt(2, |s| t2.encode(s));\n                     s.emit_seq_elt(3, |s| t3.encode(s));\n-                }\n+                })\n             }\n         }\n     }\n@@ -602,15 +602,15 @@ impl<\n     T3: Decodable<D>\n > Decodable<D> for (T0, T1, T2, T3) {\n     fn decode(d: &mut D) -> (T0, T1, T2, T3) {\n-        do d.read_seq |d, len| {\n+        d.read_seq(|d, len| {\n             assert_eq!(len, 4);\n             (\n                 d.read_seq_elt(0, |d| Decodable::decode(d)),\n                 d.read_seq_elt(1, |d| Decodable::decode(d)),\n                 d.read_seq_elt(2, |d| Decodable::decode(d)),\n                 d.read_seq_elt(3, |d| Decodable::decode(d))\n             )\n-        }\n+        })\n     }\n }\n \n@@ -625,13 +625,13 @@ impl<\n     fn encode(&self, s: &mut S) {\n         match *self {\n             (ref t0, ref t1, ref t2, ref t3, ref t4) => {\n-                do s.emit_seq(5) |s| {\n+                s.emit_seq(5, |s| {\n                     s.emit_seq_elt(0, |s| t0.encode(s));\n                     s.emit_seq_elt(1, |s| t1.encode(s));\n                     s.emit_seq_elt(2, |s| t2.encode(s));\n                     s.emit_seq_elt(3, |s| t3.encode(s));\n                     s.emit_seq_elt(4, |s| t4.encode(s));\n-                }\n+                })\n             }\n         }\n     }\n@@ -646,7 +646,7 @@ impl<\n     T4: Decodable<D>\n > Decodable<D> for (T0, T1, T2, T3, T4) {\n     fn decode(d: &mut D) -> (T0, T1, T2, T3, T4) {\n-        do d.read_seq |d, len| {\n+        d.read_seq(|d, len| {\n             assert_eq!(len, 5);\n             (\n                 d.read_seq_elt(0, |d| Decodable::decode(d)),\n@@ -655,7 +655,7 @@ impl<\n                 d.read_seq_elt(3, |d| Decodable::decode(d)),\n                 d.read_seq_elt(4, |d| Decodable::decode(d))\n             )\n-        }\n+        })\n     }\n }\n \n@@ -664,22 +664,22 @@ impl<\n     T: Encodable<S>\n > Encodable<S> for DList<T> {\n     fn encode(&self, s: &mut S) {\n-        do s.emit_seq(self.len()) |s| {\n+        s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n             }\n-        }\n+        })\n     }\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for DList<T> {\n     fn decode(d: &mut D) -> DList<T> {\n         let mut list = DList::new();\n-        do d.read_seq |d, len| {\n+        d.read_seq(|d, len| {\n             for i in range(0u, len) {\n                 list.push_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n-        }\n+        });\n         list\n     }\n }\n@@ -689,22 +689,22 @@ impl<\n     T: Encodable<S>\n > Encodable<S> for RingBuf<T> {\n     fn encode(&self, s: &mut S) {\n-        do s.emit_seq(self.len()) |s| {\n+        s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n             }\n-        }\n+        })\n     }\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for RingBuf<T> {\n     fn decode(d: &mut D) -> RingBuf<T> {\n         let mut deque = RingBuf::new();\n-        do d.read_seq |d, len| {\n+        d.read_seq(|d, len| {\n             for i in range(0u, len) {\n                 deque.push_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n-        }\n+        });\n         deque\n     }\n }\n@@ -715,14 +715,14 @@ impl<\n     V: Encodable<E>\n > Encodable<E> for HashMap<K, V> {\n     fn encode(&self, e: &mut E) {\n-        do e.emit_map(self.len()) |e| {\n+        e.emit_map(self.len(), |e| {\n             let mut i = 0;\n             for (key, val) in self.iter() {\n                 e.emit_map_elt_key(i, |e| key.encode(e));\n                 e.emit_map_elt_val(i, |e| val.encode(e));\n                 i += 1;\n             }\n-        }\n+        })\n     }\n }\n \n@@ -732,15 +732,15 @@ impl<\n     V: Decodable<D>\n > Decodable<D> for HashMap<K, V> {\n     fn decode(d: &mut D) -> HashMap<K, V> {\n-        do d.read_map |d, len| {\n+        d.read_map(|d, len| {\n             let mut map = HashMap::with_capacity(len);\n             for i in range(0u, len) {\n                 let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n                 let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n                 map.insert(key, val);\n             }\n             map\n-        }\n+        })\n     }\n }\n \n@@ -749,13 +749,13 @@ impl<\n     T: Encodable<S> + Hash + IterBytes + Eq\n > Encodable<S> for HashSet<T> {\n     fn encode(&self, s: &mut S) {\n-        do s.emit_seq(self.len()) |s| {\n+        s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n             for e in self.iter() {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n                 i += 1;\n             }\n-        }\n+        })\n     }\n }\n \n@@ -764,13 +764,13 @@ impl<\n     T: Decodable<D> + Hash + IterBytes + Eq\n > Decodable<D> for HashSet<T> {\n     fn decode(d: &mut D) -> HashSet<T> {\n-        do d.read_seq |d, len| {\n+        d.read_seq(|d, len| {\n             let mut set = HashSet::with_capacity(len);\n             for i in range(0u, len) {\n                 set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n             set\n-        }\n+        })\n     }\n }\n \n@@ -779,15 +779,15 @@ impl<\n     V: Encodable<E>\n > Encodable<E> for TrieMap<V> {\n     fn encode(&self, e: &mut E) {\n-        do e.emit_map(self.len()) |e| {\n+        e.emit_map(self.len(), |e| {\n             let mut i = 0;\n-            do self.each |key, val| {\n+            self.each(|key, val| {\n                 e.emit_map_elt_key(i, |e| key.encode(e));\n                 e.emit_map_elt_val(i, |e| val.encode(e));\n                 i += 1;\n                 true\n-            };\n-        }\n+            });\n+        })\n     }\n }\n \n@@ -796,40 +796,40 @@ impl<\n     V: Decodable<D>\n > Decodable<D> for TrieMap<V> {\n     fn decode(d: &mut D) -> TrieMap<V> {\n-        do d.read_map |d, len| {\n+        d.read_map(|d, len| {\n             let mut map = TrieMap::new();\n             for i in range(0u, len) {\n                 let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n                 let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n                 map.insert(key, val);\n             }\n             map\n-        }\n+        })\n     }\n }\n \n impl<S: Encoder> Encodable<S> for TrieSet {\n     fn encode(&self, s: &mut S) {\n-        do s.emit_seq(self.len()) |s| {\n+        s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n-            do self.each |e| {\n+            self.each(|e| {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n                 i += 1;\n                 true\n-            };\n-        }\n+            });\n+        })\n     }\n }\n \n impl<D: Decoder> Decodable<D> for TrieSet {\n     fn decode(d: &mut D) -> TrieSet {\n-        do d.read_seq |d, len| {\n+        d.read_seq(|d, len| {\n             let mut set = TrieSet::new();\n             for i in range(0u, len) {\n                 set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n             set\n-        }\n+        })\n     }\n }\n \n@@ -839,14 +839,14 @@ impl<\n     V: Encodable<E> + Eq\n > Encodable<E> for TreeMap<K, V> {\n     fn encode(&self, e: &mut E) {\n-        do e.emit_map(self.len()) |e| {\n+        e.emit_map(self.len(), |e| {\n             let mut i = 0;\n             for (key, val) in self.iter() {\n                 e.emit_map_elt_key(i, |e| key.encode(e));\n                 e.emit_map_elt_val(i, |e| val.encode(e));\n                 i += 1;\n             }\n-        }\n+        })\n     }\n }\n \n@@ -856,15 +856,15 @@ impl<\n     V: Decodable<D> + Eq\n > Decodable<D> for TreeMap<K, V> {\n     fn decode(d: &mut D) -> TreeMap<K, V> {\n-        do d.read_map |d, len| {\n+        d.read_map(|d, len| {\n             let mut map = TreeMap::new();\n             for i in range(0u, len) {\n                 let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n                 let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n                 map.insert(key, val);\n             }\n             map\n-        }\n+        })\n     }\n }\n \n@@ -873,13 +873,13 @@ impl<\n     T: Encodable<S> + Eq + TotalOrd\n > Encodable<S> for TreeSet<T> {\n     fn encode(&self, s: &mut S) {\n-        do s.emit_seq(self.len()) |s| {\n+        s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n             for e in self.iter() {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n                 i += 1;\n             }\n-        }\n+        })\n     }\n }\n \n@@ -888,13 +888,13 @@ impl<\n     T: Decodable<D> + Eq + TotalOrd\n > Decodable<D> for TreeSet<T> {\n     fn decode(d: &mut D) -> TreeSet<T> {\n-        do d.read_seq |d, len| {\n+        d.read_seq(|d, len| {\n             let mut set = TreeSet::new();\n             for i in range(0u, len) {\n                 set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n             set\n-        }\n+        })\n     }\n }\n \n@@ -909,13 +909,13 @@ pub trait EncoderHelpers {\n \n impl<S:Encoder> EncoderHelpers for S {\n     fn emit_from_vec<T>(&mut self, v: &[T], f: |&mut S, &T|) {\n-        do self.emit_seq(v.len()) |this| {\n+        self.emit_seq(v.len(), |this| {\n             for (i, e) in v.iter().enumerate() {\n-                do this.emit_seq_elt(i) |this| {\n+                this.emit_seq_elt(i, |this| {\n                     f(this, e)\n-                }\n+                })\n             }\n-        }\n+        })\n     }\n }\n \n@@ -925,10 +925,10 @@ pub trait DecoderHelpers {\n \n impl<D:Decoder> DecoderHelpers for D {\n     fn read_to_vec<T>(&mut self, f: |&mut D| -> T) -> ~[T] {\n-        do self.read_seq |this, len| {\n-            do vec::from_fn(len) |i| {\n+        self.read_seq(|this, len| {\n+            vec::from_fn(len, |i| {\n                 this.read_seq_elt(i, |this| f(this))\n-            }\n-        }\n+            })\n+        })\n     }\n }"}, {"sha": "f87ba4ed6a3e06642849c9f45f6ac600cbe7d45e", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 48, "deletions": 42, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -104,16 +104,16 @@ impl<Q:Send> Sem<Q> {\n     pub fn acquire(&self) {\n         unsafe {\n             let mut waiter_nobe = None;\n-            do (**self).with |state| {\n+            (**self).with(|state| {\n                 state.count -= 1;\n                 if state.count < 0 {\n                     // Create waiter nobe, enqueue ourself, and tell\n                     // outer scope we need to block.\n                     waiter_nobe = Some(state.waiters.wait_end());\n                 }\n-            }\n+            });\n             // Uncomment if you wish to test for sem races. Not valgrind-friendly.\n-            /* do 1000.times { task::deschedule(); } */\n+            /* 1000.times(|| task::deschedule()); */\n             // Need to wait outside the exclusive.\n             if waiter_nobe.is_some() {\n                 let _ = waiter_nobe.unwrap().recv();\n@@ -123,22 +123,22 @@ impl<Q:Send> Sem<Q> {\n \n     pub fn release(&self) {\n         unsafe {\n-            do (**self).with |state| {\n+            (**self).with(|state| {\n                 state.count += 1;\n                 if state.count <= 0 {\n                     state.waiters.signal();\n                 }\n-            }\n+            })\n         }\n     }\n \n     pub fn access<U>(&self, blk: || -> U) -> U {\n-        do (|| {\n+        (|| {\n             self.acquire();\n             blk()\n-        }).finally {\n+        }).finally(|| {\n             self.release();\n-        }\n+        })\n     }\n }\n \n@@ -147,9 +147,7 @@ impl Sem<~[WaitQueue]> {\n     fn new_and_signal(count: int, num_condvars: uint)\n         -> Sem<~[WaitQueue]> {\n         let mut queues = ~[];\n-        do num_condvars.times {\n-            queues.push(WaitQueue::new());\n-        }\n+        num_condvars.times(|| queues.push(WaitQueue::new()));\n         Sem::new(count, queues)\n     }\n }\n@@ -205,7 +203,7 @@ impl<'self> Condvar<'self> {\n         let mut out_of_bounds = None;\n         // Release lock, 'atomically' enqueuing ourselves in so doing.\n         unsafe {\n-            do (**self.sem).with |state| {\n+            (**self.sem).with(|state| {\n                 if condvar_id < state.blocked.len() {\n                     // Drop the lock.\n                     state.count += 1;\n@@ -218,18 +216,18 @@ impl<'self> Condvar<'self> {\n                 } else {\n                     out_of_bounds = Some(state.blocked.len());\n                 }\n-            }\n+            })\n         }\n \n         // If deschedule checks start getting inserted anywhere, we can be\n         // killed before or after enqueueing.\n-        do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.wait_on()\") {\n+        check_cvar_bounds(out_of_bounds, condvar_id, \"cond.wait_on()\", || {\n             // Unconditionally \"block\". (Might not actually block if a\n             // signaller already sent -- I mean 'unconditionally' in contrast\n             // with acquire().)\n-            do (|| {\n+            (|| {\n                 let _ = WaitEnd.take_unwrap().recv();\n-            }).finally {\n+            }).finally(|| {\n                 // Reacquire the condvar.\n                 match self.order {\n                     Just(lock) => do lock.access {\n@@ -239,8 +237,8 @@ impl<'self> Condvar<'self> {\n                         self.sem.acquire();\n                     },\n                 }\n-            }\n-        }\n+            })\n+        })\n     }\n \n     /// Wake up a blocked task. Returns false if there was no blocked task.\n@@ -251,16 +249,17 @@ impl<'self> Condvar<'self> {\n         unsafe {\n             let mut out_of_bounds = None;\n             let mut result = false;\n-            do (**self.sem).with |state| {\n+            (**self.sem).with(|state| {\n                 if condvar_id < state.blocked.len() {\n                     result = state.blocked[condvar_id].signal();\n                 } else {\n                     out_of_bounds = Some(state.blocked.len());\n                 }\n-            }\n-            do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {\n-                result\n-            }\n+            });\n+            check_cvar_bounds(out_of_bounds,\n+                              condvar_id,\n+                              \"cond.signal_on()\",\n+                              || result)\n         }\n     }\n \n@@ -272,7 +271,7 @@ impl<'self> Condvar<'self> {\n         let mut out_of_bounds = None;\n         let mut queue = None;\n         unsafe {\n-            do (**self.sem).with |state| {\n+            (**self.sem).with(|state| {\n                 if condvar_id < state.blocked.len() {\n                     // To avoid :broadcast_heavy, we make a new waitqueue,\n                     // swap it out with the old one, and broadcast on the\n@@ -282,11 +281,14 @@ impl<'self> Condvar<'self> {\n                 } else {\n                     out_of_bounds = Some(state.blocked.len());\n                 }\n-            }\n-            do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {\n+            });\n+            check_cvar_bounds(out_of_bounds,\n+                              condvar_id,\n+                              \"cond.signal_on()\",\n+                              || {\n                 let queue = queue.take_unwrap();\n                 queue.broadcast()\n-            }\n+            })\n         }\n     }\n }\n@@ -315,9 +317,13 @@ impl Sem<~[WaitQueue]> {\n     // The only other places that condvars get built are rwlock.write_cond()\n     // and rwlock_write_mode.\n     pub fn access_cond<U>(&self, blk: |c: &Condvar| -> U) -> U {\n-        do self.access {\n-            blk(&Condvar { sem: self, order: Nothing, token: NonCopyable })\n-        }\n+        self.access(|| {\n+            blk(&Condvar {\n+                sem: self,\n+                order: Nothing,\n+                token: NonCopyable\n+            })\n+        })\n     }\n }\n \n@@ -474,17 +480,17 @@ impl RWLock {\n      */\n     pub fn read<U>(&self, blk: || -> U) -> U {\n         unsafe {\n-            do (&self.order_lock).access {\n+            (&self.order_lock).access(|| {\n                 let state = &mut *self.state.get();\n                 let old_count = state.read_count.fetch_add(1, atomics::Acquire);\n                 if old_count == 0 {\n                     (&self.access_lock).acquire();\n                     state.read_mode = true;\n                 }\n-            }\n-            do (|| {\n+            });\n+            (|| {\n                 blk()\n-            }).finally {\n+            }).finally(|| {\n                 let state = &mut *self.state.get();\n                 assert!(state.read_mode);\n                 let old_count = state.read_count.fetch_sub(1, atomics::Release);\n@@ -497,7 +503,7 @@ impl RWLock {\n                     // this access MUST NOT go inside the exclusive access.\n                     (&self.access_lock).release();\n                 }\n-            }\n+            })\n         }\n     }\n \n@@ -507,10 +513,10 @@ impl RWLock {\n      */\n     pub fn write<U>(&self, blk: || -> U) -> U {\n         (&self.order_lock).acquire();\n-        do (&self.access_lock).access {\n+        (&self.access_lock).access(|| {\n             (&self.order_lock).release();\n             blk()\n-        }\n+        })\n     }\n \n     /**\n@@ -547,12 +553,12 @@ impl RWLock {\n         // The astute reader will also note that making waking writers use the\n         // order_lock is better for not starving readers.\n         (&self.order_lock).acquire();\n-        do (&self.access_lock).access_cond |cond| {\n+        (&self.access_lock).access_cond(|cond| {\n             (&self.order_lock).release();\n             let opt_lock = Just(&self.order_lock);\n             blk(&Condvar { sem: cond.sem, order: opt_lock,\n                            token: NonCopyable })\n-        }\n+        })\n     }\n \n     /**\n@@ -582,9 +588,9 @@ impl RWLock {\n         (&self.order_lock).acquire();\n         (&self.access_lock).acquire();\n         (&self.order_lock).release();\n-        do (|| {\n+        (|| {\n             blk(RWLockWriteMode { lock: self, token: NonCopyable })\n-        }).finally {\n+        }).finally(|| {\n             let writer_or_last_reader;\n             // Check if we're releasing from read mode or from write mode.\n             let state = unsafe { &mut *self.state.get() };\n@@ -609,7 +615,7 @@ impl RWLock {\n                 // Nobody left inside; release the \"reader cloud\" lock.\n                 (&self.access_lock).release();\n             }\n-        }\n+        })\n     }\n \n     /// To be called inside of the write_downgrade block."}, {"sha": "1bb07a396ffda30e7fe0d264ccb3c41986b15f19", "filename": "src/libextra/task_pool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftask_pool.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -53,7 +53,7 @@ impl<T> TaskPool<T> {\n                -> TaskPool<T> {\n         assert!(n_tasks >= 1);\n \n-        let channels = do vec::from_fn(n_tasks) |i| {\n+        let channels = vec::from_fn(n_tasks, |i| {\n             let (port, chan) = comm::stream::<Msg<T>>();\n             let init_fn = init_fn_factory();\n \n@@ -81,7 +81,7 @@ impl<T> TaskPool<T> {\n             }\n \n             chan\n-        };\n+        });\n \n         return TaskPool { channels: channels, next_index: 0 };\n     }"}, {"sha": "aace15ee7a6714cdc18e5b8f43f7af85a0315647", "filename": "src/libextra/term.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -220,9 +220,9 @@ impl<T: Writer> Terminal<T> {\n                 cap = self.ti.strings.find_equiv(&(\"op\"));\n             }\n         }\n-        let s = do cap.map_default(Err(~\"can't find terminfo capability `sgr0`\")) |op| {\n+        let s = cap.map_default(Err(~\"can't find terminfo capability `sgr0`\"), |op| {\n             expand(*op, [], &mut Variables::new())\n-        };\n+        });\n         if s.is_ok() {\n             self.out.write(s.unwrap());\n         } else if self.num_colors > 0 {"}, {"sha": "eac450d9562f2c34fb8f267569911268f69ea962", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -494,14 +494,14 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n                     match op {\n                         FormatDigit => {\n                             let sign = if flags.sign { SignAll } else { SignNeg };\n-                            do int_to_str_bytes_common(d, radix, sign) |c| {\n+                            int_to_str_bytes_common(d, radix, sign, |c| {\n                                 s.push(c);\n-                            }\n+                            })\n                         }\n                         _ => {\n-                            do int_to_str_bytes_common(d as uint, radix, SignNone) |c| {\n+                            int_to_str_bytes_common(d as uint, radix, SignNone, |c| {\n                                 s.push(c);\n-                            }\n+                            })\n                         }\n                     };\n                     if flags.precision > s.len() {"}, {"sha": "c94cb196bea6be1ea9901eb1941ac49b64430157", "filename": "src/libextra/test.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -176,7 +176,7 @@ pub fn test_main(args: &[~str], tests: ~[TestDescAndFn]) {\n // semantics into parallel test runners, which in turn requires a ~[]\n // rather than a &[].\n pub fn test_main_static(args: &[~str], tests: &[TestDescAndFn]) {\n-    let owned_tests = do tests.map |t| {\n+    let owned_tests = tests.map(|t| {\n         match t.testfn {\n             StaticTestFn(f) =>\n             TestDescAndFn { testfn: StaticTestFn(f), desc: t.desc.clone() },\n@@ -188,7 +188,7 @@ pub fn test_main_static(args: &[~str], tests: &[TestDescAndFn]) {\n                 fail!(\"non-static tests passed to test::test_main_static\");\n             }\n         }\n-    };\n+    });\n     test_main(args, owned_tests)\n }\n \n@@ -730,12 +730,12 @@ fn run_tests(opts: &TestOpts,\n     callback(TeFiltered(filtered_descs));\n \n     let (filtered_tests, filtered_benchs_and_metrics) =\n-        do filtered_tests.partition |e| {\n-        match e.testfn {\n-            StaticTestFn(_) | DynTestFn(_) => true,\n-            _ => false\n-        }\n-    };\n+        filtered_tests.partition(|e| {\n+            match e.testfn {\n+                StaticTestFn(_) | DynTestFn(_) => true,\n+                _ => false\n+            }\n+        });\n \n     // It's tempting to just spawn all the tests at once, but since we have\n     // many tests that run in other processes we would be making a big mess.\n@@ -1044,12 +1044,12 @@ impl MetricMap {\n         };\n \n         let diff : MetricDiff = self.compare_to_old(&old, pct);\n-        let ok = do diff.iter().all() |(_, v)| {\n+        let ok = diff.iter().all(|(_, v)| {\n             match *v {\n                 Regression(_) => false,\n                 _ => true\n             }\n-        };\n+        });\n \n         if ok {\n             debug!(\"rewriting file '{:?}' with updated metrics\", p);"}, {"sha": "05bca853e3bb530f9ad50ac2fc0999d3ad79e333", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -394,15 +394,15 @@ impl<'self, T> Iterator<&'self T> for TreeSetIterator<'self, T> {\n     /// Advance the iterator to the next node (in order). If there are no more nodes, return `None`.\n     #[inline]\n     fn next(&mut self) -> Option<&'self T> {\n-        do self.iter.next().map |(value, _)| { value }\n+        self.iter.next().map(|(value, _)| value)\n     }\n }\n \n impl<'self, T> Iterator<&'self T> for TreeSetRevIterator<'self, T> {\n     /// Advance the iterator to the next node (in order). If there are no more nodes, return `None`.\n     #[inline]\n     fn next(&mut self) -> Option<&'self T> {\n-        do self.iter.next().map |(value, _)| { value }\n+        self.iter.next().map(|(value, _)| value)\n     }\n }\n "}, {"sha": "beb211339083dcce2bd8560a334b06f2f6ef36be", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -373,15 +373,15 @@ impl<'self> Prep<'self> {\n             None => fail!(\"missing freshness-function for '{}'\", kind),\n             Some(f) => (*f)(name, val)\n         };\n-        do self.ctxt.logger.write |lg| {\n+        self.ctxt.logger.write(|lg| {\n             if fresh {\n                 lg.info(format!(\"{} {}:{} is fresh\",\n                              cat, kind, name));\n             } else {\n                 lg.info(format!(\"{} {}:{} is not fresh\",\n                              cat, kind, name))\n             }\n-        };\n+        });\n         fresh\n     }\n \n@@ -411,9 +411,9 @@ impl<'self> Prep<'self> {\n \n         debug!(\"exec_work: looking up {} and {:?}\", self.fn_name,\n                self.declared_inputs);\n-        let cached = do self.ctxt.db.read |db| {\n+        let cached = self.ctxt.db.read(|db| {\n             db.prepare(self.fn_name, &self.declared_inputs)\n-        };\n+        });\n \n         match cached {\n             Some((ref disc_in, ref disc_out, ref res))\n@@ -432,7 +432,7 @@ impl<'self> Prep<'self> {\n                 let blk = bo.take_unwrap();\n                 let chan = Cell::new(chan);\n \n-// What happens if the task fails?\n+                // XXX: What happens if the task fails?\n                 do task::spawn {\n                     let mut exe = Exec {\n                         discovered_inputs: WorkMap::new(),\n@@ -467,13 +467,13 @@ impl<'self, T:Send +\n             WorkFromTask(prep, port) => {\n                 let (exe, v) = port.recv();\n                 let s = json_encode(&v);\n-                do prep.ctxt.db.write |db| {\n+                prep.ctxt.db.write(|db| {\n                     db.cache(prep.fn_name,\n                              &prep.declared_inputs,\n                              &exe.discovered_inputs,\n                              &exe.discovered_outputs,\n-                             s);\n-                }\n+                             s)\n+                });\n                 v\n             }\n         }\n@@ -507,7 +507,7 @@ fn test() {\n                           RWArc::new(Logger::new()),\n                           Arc::new(TreeMap::new()));\n \n-    let s = do cx.with_prep(\"test1\") |prep| {\n+    let s = cx.with_prep(\"test1\", |prep| {\n \n         let subcx = cx.clone();\n         let pth = pth.clone();\n@@ -529,7 +529,7 @@ fn test() {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             out.as_str().unwrap().to_owned()\n         }\n-    };\n+    });\n \n     println(s);\n }"}, {"sha": "da096880859bc751dfc8cd87090eacbf78eca74e", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -55,11 +55,11 @@ impl GetAddrInfoRequest {\n \n         let hint = hints.map(|hint| {\n             let mut flags = 0;\n-            do each_ai_flag |cval, aival| {\n+            each_ai_flag(|cval, aival| {\n                 if hint.flags & (aival as uint) != 0 {\n                     flags |= cval as i32;\n                 }\n-            }\n+            });\n             let socktype = 0;\n             let protocol = 0;\n \n@@ -86,9 +86,9 @@ impl GetAddrInfoRequest {\n                 req.defuse(); // uv callback now owns this request\n                 let mut cx = Ctx { slot: None, status: 0, addrinfo: None };\n \n-                do wait_until_woken_after(&mut cx.slot) {\n+                wait_until_woken_after(&mut cx.slot, || {\n                     req.set_data(&cx);\n-                }\n+                });\n \n                 match cx.status {\n                     0 => Ok(accum_addrinfo(cx.addrinfo.get_ref())),\n@@ -144,11 +144,11 @@ pub fn accum_addrinfo(addr: &Addrinfo) -> ~[ai::Info] {\n             let rustaddr = net::sockaddr_to_socket_addr((*addr).ai_addr);\n \n             let mut flags = 0;\n-            do each_ai_flag |cval, aival| {\n+            each_ai_flag(|cval, aival| {\n                 if (*addr).ai_flags & cval != 0 {\n                     flags |= aival as uint;\n                 }\n-            }\n+            });\n \n             /* XXX: do we really want to support these\n             let protocol = match (*addr).ai_protocol {"}, {"sha": "0f1e967f9bc46badc83e01bbb2707e25728c3552", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -111,14 +111,14 @@ impl RemoteCallback for AsyncWatcher {\n impl Drop for AsyncWatcher {\n     fn drop(&mut self) {\n         unsafe {\n-            do self.exit_flag.with |should_exit| {\n+            self.exit_flag.with(|should_exit| {\n                 // NB: These two things need to happen atomically. Otherwise\n                 // the event handler could wake up due to a *previous*\n                 // signal and see the exit flag, destroying the handle\n                 // before the final send.\n                 *should_exit = true;\n                 uvll::uv_async_send(self.handle)\n-            }\n+            })\n         }\n     }\n }"}, {"sha": "7aef62af8eef429700416489dc328557459d5a28", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -86,13 +86,13 @@ impl FsRequest {\n     pub fn read(loop_: &Loop, fd: c_int, buf: &mut [u8], offset: i64)\n         -> Result<int, UvError>\n     {\n-        do execute(|req, cb| unsafe {\n+        execute(|req, cb| unsafe {\n             uvll::uv_fs_read(loop_.handle, req,\n                              fd, vec::raw::to_ptr(buf) as *c_void,\n                              buf.len() as size_t, offset, cb)\n-        }).map |req| {\n+        }).map(|req| {\n             req.get_result() as int\n-        }\n+        })\n     }\n \n     pub fn mkdir(loop_: &Loop, path: &CString, mode: c_int)\n@@ -142,24 +142,25 @@ impl FsRequest {\n             let mut paths = ~[];\n             let path = CString::new(path.with_ref(|p| p), false);\n             let parent = Path::new(path);\n-            do c_str::from_c_multistring(req.get_ptr() as *libc::c_char,\n-                                         Some(req.get_result() as uint)) |rel| {\n+            c_str::from_c_multistring(req.get_ptr() as *libc::c_char,\n+                                      Some(req.get_result() as uint),\n+                                      |rel| {\n                 let p = rel.as_bytes();\n                 paths.push(parent.join(p.slice_to(rel.len())));\n-            };\n+            });\n             paths\n         })\n     }\n \n     pub fn readlink(loop_: &Loop, path: &CString) -> Result<Path, UvError> {\n-        do execute(|req, cb| unsafe {\n+        execute(|req, cb| unsafe {\n             uvll::uv_fs_readlink(loop_.handle, req,\n                                  path.with_ref(|p| p), cb)\n-        }).map |req| {\n+        }).map(|req| {\n             Path::new(unsafe {\n                 CString::new(req.get_ptr() as *libc::c_char, false)\n             })\n-        }\n+        })\n     }\n \n     pub fn chown(loop_: &Loop, path: &CString, uid: int, gid: int)\n@@ -305,16 +306,15 @@ fn execute(f: |*uvll::uv_fs_t, uvll::uv_fs_cb| -> c_int)\n         0 => {\n             req.fired = true;\n             let mut slot = None;\n-            do wait_until_woken_after(&mut slot) {\n+            wait_until_woken_after(&mut slot, || {\n                 unsafe { uvll::set_data_for_req(req.req, &slot) }\n-            }\n+            });\n             match req.get_result() {\n                 n if n < 0 => Err(UvError(n)),\n                 _ => Ok(req),\n             }\n         }\n         n => Err(UvError(n))\n-\n     };\n \n     extern fn fs_cb(req: *uvll::uv_fs_t) {"}, {"sha": "205a2d20e92149a6ff88fb696a1ac9cc850be169", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -138,9 +138,9 @@ pub trait UvHandle<T> {\n             uvll::uv_close(self.uv_handle() as *uvll::uv_handle_t, close_cb);\n             uvll::set_data_for_uv_handle(self.uv_handle(), ptr::null::<()>());\n \n-            do wait_until_woken_after(&mut slot) {\n+            wait_until_woken_after(&mut slot, || {\n                 uvll::set_data_for_uv_handle(self.uv_handle(), &slot);\n-            }\n+            })\n         }\n \n         extern fn close_cb(handle: *uvll::uv_handle_t) {\n@@ -201,10 +201,10 @@ fn wait_until_woken_after(slot: *mut Option<BlockedTask>, f: ||) {\n     unsafe {\n         assert!((*slot).is_none());\n         let sched: ~Scheduler = Local::take();\n-        do sched.deschedule_running_task_and_then |_, task| {\n+        sched.deschedule_running_task_and_then(|_, task| {\n             f();\n             *slot = Some(task);\n-        }\n+        })\n     }\n }\n \n@@ -390,15 +390,15 @@ pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n #[cfg(test)]\n fn local_loop() -> &'static mut Loop {\n     unsafe {\n-        cast::transmute(do Local::borrow |sched: &mut Scheduler| {\n+        cast::transmute(Local::borrow(|sched: &mut Scheduler| {\n             let mut io = None;\n             do sched.event_loop.io |i| {\n                 let (_vtable, uvio): (uint, &'static mut uvio::UvIoFactory) =\n                     cast::transmute(i);\n                 io = Some(uvio);\n             }\n             io.unwrap()\n-        }.uv_loop())\n+        }).uv_loop())\n     }\n }\n "}, {"sha": "eb679553e7642eead29e45ec84ff089bcbab83b7", "filename": "src/librustuv/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibrustuv%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibrustuv%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fmacros.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -29,7 +29,7 @@ macro_rules! uvdebug (\n \n // get a handle for the current scheduler\n macro_rules! get_handle_to_current_scheduler(\n-    () => (do Local::borrow |sched: &mut Scheduler| { sched.make_handle() })\n+    () => (Local::borrow(|sched: &mut Scheduler| sched.make_handle()))\n )\n \n pub fn dumb_println(args: &fmt::Arguments) {"}, {"sha": "cad1ac6709f7b29f72639144789858ee38d45b78", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -42,11 +42,11 @@ fn socket_addr_as_sockaddr<T>(addr: SocketAddr, f: |*sockaddr| -> T) -> T {\n \n     let ip = addr.ip.to_str();\n     let addr = ip.with_c_str(|p| unsafe { malloc(p, addr.port as c_int) });\n-    do (|| {\n+    (|| {\n         f(addr)\n-    }).finally {\n+    }).finally(|| {\n         unsafe { libc::free(addr) };\n-    }\n+    })\n }\n \n pub fn sockaddr_to_socket_addr(addr: *sockaddr) -> SocketAddr {\n@@ -88,19 +88,19 @@ pub fn sockaddr_to_socket_addr(addr: *sockaddr) -> SocketAddr {\n fn test_ip4_conversion() {\n     use std::rt;\n     let ip4 = rt::test::next_test_ip4();\n-    do socket_addr_as_sockaddr(ip4) |addr| {\n+    socket_addr_as_sockaddr(ip4, |addr| {\n         assert_eq!(ip4, sockaddr_to_socket_addr(addr));\n-    }\n+    })\n }\n \n #[cfg(test)]\n #[test]\n fn test_ip6_conversion() {\n     use std::rt;\n     let ip6 = rt::test::next_test_ip6();\n-    do socket_addr_as_sockaddr(ip6) |addr| {\n+    socket_addr_as_sockaddr(ip6, |addr| {\n         assert_eq!(ip6, sockaddr_to_socket_addr(addr));\n-    }\n+    })\n }\n \n enum SocketNameKind {\n@@ -176,7 +176,7 @@ impl TcpWatcher {\n         struct Ctx { status: c_int, task: Option<BlockedTask> }\n \n         let tcp = TcpWatcher::new(loop_);\n-        let ret = do socket_addr_as_sockaddr(address) |addr| {\n+        let ret = socket_addr_as_sockaddr(address, |addr| {\n             let mut req = Request::new(uvll::UV_CONNECT);\n             let result = unsafe {\n                 uvll::uv_tcp_connect(req.handle, tcp.handle, addr,\n@@ -196,7 +196,7 @@ impl TcpWatcher {\n                 }\n                 n => Err(UvError(n))\n             }\n-        };\n+        });\n \n         return match ret {\n             Ok(()) => Ok(tcp),\n@@ -286,8 +286,7 @@ impl Drop for TcpWatcher {\n \n impl TcpListener {\n     pub fn bind(loop_: &mut Loop, address: SocketAddr)\n-        -> Result<~TcpListener, UvError>\n-    {\n+                -> Result<~TcpListener, UvError> {\n         let handle = unsafe { uvll::malloc_handle(uvll::UV_TCP) };\n         assert_eq!(unsafe {\n             uvll::uv_tcp_init(loop_.handle, handle)\n@@ -419,8 +418,7 @@ pub struct UdpWatcher {\n \n impl UdpWatcher {\n     pub fn bind(loop_: &Loop, address: SocketAddr)\n-        -> Result<UdpWatcher, UvError>\n-    {\n+                -> Result<UdpWatcher, UvError> {\n         let udp = UdpWatcher {\n             handle: unsafe { uvll::malloc_handle(uvll::UV_UDP) },\n             home: get_handle_to_current_scheduler!(),\n@@ -473,9 +471,9 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                     buf: Some(slice_to_uv_buf(buf)),\n                     result: None,\n                 };\n-                do wait_until_woken_after(&mut cx.task) {\n+                wait_until_woken_after(&mut cx.task, || {\n                     unsafe { uvll::set_data_for_uv_handle(self.handle, &cx) }\n-                }\n+                });\n                 match cx.result.take_unwrap() {\n                     (n, _) if n < 0 =>\n                         Err(uv_error_to_io_error(UvError(n as c_int))),\n@@ -545,9 +543,9 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n             0 => {\n                 req.defuse(); // uv callback now owns this request\n                 let mut cx = Ctx { task: None, result: 0 };\n-                do wait_until_woken_after(&mut cx.task) {\n+                wait_until_woken_after(&mut cx.task, || {\n                     req.set_data(&cx);\n-                }\n+                });\n                 match cx.result {\n                     0 => Ok(()),\n                     n => Err(uv_error_to_io_error(UvError(n)))\n@@ -570,22 +568,22 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n     fn join_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n         let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n-            do multi.to_str().with_c_str |m_addr| {\n+            multi.to_str().with_c_str(|m_addr| {\n                 uvll::uv_udp_set_membership(self.handle,\n                                             m_addr, ptr::null(),\n                                             uvll::UV_JOIN_GROUP)\n-            }\n+            })\n         })\n     }\n \n     fn leave_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n         let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n-            do multi.to_str().with_c_str |m_addr| {\n+            multi.to_str().with_c_str(|m_addr| {\n                 uvll::uv_udp_set_membership(self.handle,\n                                             m_addr, ptr::null(),\n                                             uvll::UV_LEAVE_GROUP)\n-            }\n+            })\n         })\n     }\n \n@@ -1101,11 +1099,11 @@ mod test {\n             };\n \n             unsafe fn local_io() -> &'static mut IoFactory {\n-                do Local::borrow |sched: &mut Scheduler| {\n+                Local::borrow(|sched: &mut Scheduler| {\n                     let mut io = None;\n                     sched.event_loop.io(|i| io = Some(i));\n                     cast::transmute(io.unwrap())\n-                }\n+                })\n             }\n \n             let test_function: proc() = || {\n@@ -1117,14 +1115,14 @@ mod test {\n \n                 // block self on sched1\n                 let scheduler: ~Scheduler = Local::take();\n-                do scheduler.deschedule_running_task_and_then |_, task| {\n+                scheduler.deschedule_running_task_and_then(|_, task| {\n                     // unblock task\n-                    do task.wake().map |task| {\n+                    task.wake().map(|task| {\n                         // send self to sched2\n                         tasksFriendHandle.take().send(TaskFromFriend(task));\n-                    };\n+                    });\n                     // sched1 should now sleep since it has nothing else to do\n-                }\n+                })\n                 // sched2 will wake up and get the task as we do nothing else,\n                 // the function ends and the socket goes out of scope sched2\n                 // will start to run the destructor the destructor will first"}, {"sha": "6b48e823e4286645323cf86108d751ec76f13be0", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -77,7 +77,7 @@ impl PipeWatcher {\n         let mut req = Request::new(uvll::UV_CONNECT);\n         let pipe = PipeWatcher::new(loop_, false);\n \n-        do wait_until_woken_after(&mut cx.task) {\n+        wait_until_woken_after(&mut cx.task, || {\n             unsafe {\n                 uvll::uv_pipe_connect(req.handle,\n                                       pipe.handle(),\n@@ -86,7 +86,7 @@ impl PipeWatcher {\n             }\n             req.set_data(&cx);\n             req.defuse(); // uv callback now owns this request\n-        }\n+        });\n         return match cx.result {\n             0 => Ok(pipe),\n             n => Err(UvError(n))"}, {"sha": "0577d19ec4603c98fa0d936d00384bd2d98958de", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -57,8 +57,8 @@ impl Process {\n             }\n         }\n \n-        let ret = do with_argv(config.program, config.args) |argv| {\n-            do with_env(config.env) |envp| {\n+        let ret = with_argv(config.program, config.args, |argv| {\n+            with_env(config.env, |envp| {\n                 let options = uvll::uv_process_options_t {\n                     exit_cb: on_exit,\n                     file: unsafe { *argv },\n@@ -88,8 +88,8 @@ impl Process {\n                     0 => Ok(process.install()),\n                     err => Err(UvError(err)),\n                 }\n-            }\n-        };\n+            })\n+        });\n \n         match ret {\n             Ok(p) => Ok((p, ret_io)),"}, {"sha": "0304b89dd6fdeae36e4206dec97a614452ebae25", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -123,9 +123,9 @@ impl StreamWatcher {\n                 let mut wcx = WriteContext { result: 0, task: None, };\n                 req.defuse(); // uv callback now owns this request\n \n-                do wait_until_woken_after(&mut wcx.task) {\n+                wait_until_woken_after(&mut wcx.task, || {\n                     req.set_data(&wcx);\n-                }\n+                });\n                 self.last_write_req = Some(Request::wrap(req.handle));\n                 match wcx.result {\n                     0 => Ok(()),"}, {"sha": "b7babed05024ba2dee30b1a2dc75ce43130e07df", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -88,10 +88,10 @@ impl RtioTimer for TimerWatcher {\n         let _f = ForbidUnwind::new(\"timer\");\n \n         let sched: ~Scheduler = Local::take();\n-        do sched.deschedule_running_task_and_then |_sched, task| {\n+        sched.deschedule_running_task_and_then(|_sched, task| {\n             self.action = Some(WakeTask(task));\n             self.start(msecs, 0);\n-        }\n+        });\n         self.stop();\n     }\n "}, {"sha": "976c0fbf9bc57efa9d96991294abe3348e12992c", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61a3678ebe5571842d4223e2a0313714893bbf7/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=a61a3678ebe5571842d4223e2a0313714893bbf7", "patch": "@@ -46,23 +46,23 @@ pub trait HomingIO {\n \n         let _f = ForbidUnwind::new(\"going home\");\n \n-        let current_sched_id = do Local::borrow |sched: &mut Scheduler| {\n+        let current_sched_id = Local::borrow(|sched: &mut Scheduler| {\n             sched.sched_id()\n-        };\n+        });\n \n         // Only need to invoke a context switch if we're not on the right\n         // scheduler.\n         if current_sched_id != self.home().sched_id {\n             let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                do task.wake().map |task| {\n+            scheduler.deschedule_running_task_and_then(|_, task| {\n+                task.wake().map(|task| {\n                     self.home().send(RunOnce(task));\n-                };\n-            }\n+                });\n+            })\n         }\n-        let current_sched_id = do Local::borrow |sched: &mut Scheduler| {\n+        let current_sched_id = Local::borrow(|sched: &mut Scheduler| {\n             sched.sched_id()\n-        };\n+        });\n         assert!(current_sched_id == self.home().sched_id);\n \n         self.home().sched_id\n@@ -114,11 +114,11 @@ impl Drop for HomingMissile {\n         // original scheduler. Otherwise, we can just return and keep running\n         if !Task::on_appropriate_sched() {\n             let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                do task.wake().map |task| {\n+            scheduler.deschedule_running_task_and_then(|_, task| {\n+                task.wake().map(|task| {\n                     Scheduler::run_task(task);\n-                };\n-            }\n+                });\n+            })\n         }\n \n         util::ignore(f);"}]}