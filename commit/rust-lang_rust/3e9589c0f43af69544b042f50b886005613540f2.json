{"sha": "3e9589c0f43af69544b042f50b886005613540f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlOTU4OWMwZjQzYWY2OTU0NGIwNDJmNTBiODg2MDA1NjEzNTQwZjI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-10-24T01:18:44Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-01-30T00:25:20Z"}, "message": "trans: Reimplement unwinding on MSVC\n\nThis commit transitions the compiler to using the new exception handling\ninstructions in LLVM for implementing unwinding for MSVC. This affects both 32\nand 64-bit MSVC as they're both now using SEH-based strategies. In terms of\nstandard library support, lots more details about how SEH unwinding is\nimplemented can be found in the commits.\n\nIn terms of trans, this change necessitated a few modifications:\n\n* Branches were added to detect when the old landingpad instruction is used or\n  the new cleanuppad instruction is used to `trans::cleanup`.\n* The return value from `cleanuppad` is not stored in an `alloca` (because it\n  cannot be).\n* Each block in trans now has an `Option<LandingPad>` instead of `is_lpad: bool`\n  for indicating whether it's in a landing pad or not. The new exception\n  handling intrinsics require that on MSVC each `call` inside of a landing pad\n  is annotated with which landing pad that it's in. This change to the basic\n  block means that whenever a `call` or `invoke` instruction is generated we\n  know whether to annotate it as part of a cleanuppad or not.\n* Lots of modifications were made to the instruction builders to construct the\n  new instructions as well as pass the tagging information for the call/invoke\n  instructions.\n* The translation of the `try` intrinsics for MSVC has been overhauled to use\n  the new `catchpad` instruction. The filter function is now also a\n  rustc-generated function instead of a purely libstd-defined function. The\n  libstd definition still exists, it just has a stable ABI across architectures\n  and leaves some of the really weird implementation details to the compiler\n  (e.g. the `localescape` and `localrecover` intrinsics).", "tree": {"sha": "ac718169258ed337a5164fe2943ad6b79a8c15df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac718169258ed337a5164fe2943ad6b79a8c15df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e9589c0f43af69544b042f50b886005613540f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e9589c0f43af69544b042f50b886005613540f2", "html_url": "https://github.com/rust-lang/rust/commit/3e9589c0f43af69544b042f50b886005613540f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e9589c0f43af69544b042f50b886005613540f2/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1cace17af31ddb21aeb8a3d94cb3eda934047d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1cace17af31ddb21aeb8a3d94cb3eda934047d9", "html_url": "https://github.com/rust-lang/rust/commit/d1cace17af31ddb21aeb8a3d94cb3eda934047d9"}], "stats": {"total": 1556, "additions": 1131, "deletions": 425}, "files": [{"sha": "2e2292d63f4c63addd1e0f23f8fb6026bd58754e", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=3e9589c0f43af69544b042f50b886005613540f2", "patch": "@@ -552,7 +552,15 @@ extern \"rust-intrinsic\" {\n     pub fn discriminant_value<T>(v: &T) -> u64;\n \n     /// Rust's \"try catch\" construct which invokes the function pointer `f` with\n-    /// the data pointer `data`, returning the exception payload if an exception\n-    /// is thrown (aka the thread panics).\n+    /// the data pointer `data`.\n+    ///\n+    /// The third pointer is a target-specific data pointer which is filled in\n+    /// with the specifics of the exception that occurred. For examples on Unix\n+    /// platforms this is a `*mut *mut T` which is filled in by the compiler and\n+    /// on MSVC it's `*mut [usize; 2]`. For more information see the compiler's\n+    /// source as well as std's catch implementation.\n+    #[cfg(not(stage0))]\n+    pub fn try(f: fn(*mut u8), data: *mut u8, local_ptr: *mut u8) -> i32;\n+    #[cfg(stage0)]\n     pub fn try(f: fn(*mut u8), data: *mut u8) -> *mut u8;\n }"}, {"sha": "14ce27350519ce95c6f4e145f74a75d4f0c2a0ec", "filename": "src/librustc_back/target/x86_64_pc_windows_msvc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs?ref=3e9589c0f43af69544b042f50b886005613540f2", "patch": "@@ -13,7 +13,6 @@ use target::Target;\n pub fn target() -> Target {\n     let mut base = super::windows_msvc_base::opts();\n     base.cpu = \"x86-64\".to_string();\n-    base.custom_unwind_resume = true;\n \n     Target {\n         llvm_target: \"x86_64-pc-windows-msvc\".to_string(),"}, {"sha": "2ddc803fe493fbf8a58d66ba686770dd485e5efe", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 78, "deletions": 14, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=3e9589c0f43af69544b042f50b886005613540f2", "patch": "@@ -544,6 +544,9 @@ pub type SMDiagnosticRef = *mut SMDiagnostic_opaque;\n #[allow(missing_copy_implementations)]\n pub enum RustArchiveMember_opaque {}\n pub type RustArchiveMemberRef = *mut RustArchiveMember_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum OperandBundleDef_opaque {}\n+pub type OperandBundleDefRef = *mut OperandBundleDef_opaque;\n \n pub type DiagnosticHandler = unsafe extern \"C\" fn(DiagnosticInfoRef, *mut c_void);\n pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(SMDiagnosticRef, *const c_void, c_uint);\n@@ -1149,14 +1152,15 @@ extern {\n                                Addr: ValueRef,\n                                NumDests: c_uint)\n                                -> ValueRef;\n-    pub fn LLVMBuildInvoke(B: BuilderRef,\n-                           Fn: ValueRef,\n-                           Args: *const ValueRef,\n-                           NumArgs: c_uint,\n-                           Then: BasicBlockRef,\n-                           Catch: BasicBlockRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n+    pub fn LLVMRustBuildInvoke(B: BuilderRef,\n+                               Fn: ValueRef,\n+                               Args: *const ValueRef,\n+                               NumArgs: c_uint,\n+                               Then: BasicBlockRef,\n+                               Catch: BasicBlockRef,\n+                               Bundle: OperandBundleDefRef,\n+                               Name: *const c_char)\n+                               -> ValueRef;\n     pub fn LLVMRustBuildLandingPad(B: BuilderRef,\n                                    Ty: TypeRef,\n                                    PersFn: ValueRef,\n@@ -1167,6 +1171,31 @@ extern {\n     pub fn LLVMBuildResume(B: BuilderRef, Exn: ValueRef) -> ValueRef;\n     pub fn LLVMBuildUnreachable(B: BuilderRef) -> ValueRef;\n \n+    pub fn LLVMRustBuildCleanupPad(B: BuilderRef,\n+                                   ParentPad: ValueRef,\n+                                   ArgCnt: c_uint,\n+                                   Args: *const ValueRef,\n+                                   Name: *const c_char) -> ValueRef;\n+    pub fn LLVMRustBuildCleanupRet(B: BuilderRef,\n+                                   CleanupPad: ValueRef,\n+                                   UnwindBB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMRustBuildCatchPad(B: BuilderRef,\n+                                 ParentPad: ValueRef,\n+                                 ArgCnt: c_uint,\n+                                 Args: *const ValueRef,\n+                                 Name: *const c_char) -> ValueRef;\n+    pub fn LLVMRustBuildCatchRet(B: BuilderRef,\n+                                 Pad: ValueRef,\n+                                 BB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMRustBuildCatchSwitch(Builder: BuilderRef,\n+                                    ParentPad: ValueRef,\n+                                    BB: BasicBlockRef,\n+                                    NumHandlers: c_uint,\n+                                    Name: *const c_char) -> ValueRef;\n+    pub fn LLVMRustAddHandler(CatchSwitch: ValueRef,\n+                              Handler: BasicBlockRef);\n+    pub fn LLVMRustSetPersonalityFn(B: BuilderRef, Pers: ValueRef);\n+\n     /* Add a case to the switch instruction */\n     pub fn LLVMAddCase(Switch: ValueRef,\n                        OnVal: ValueRef,\n@@ -1476,12 +1505,13 @@ extern {\n     /* Miscellaneous instructions */\n     pub fn LLVMBuildPhi(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n                         -> ValueRef;\n-    pub fn LLVMBuildCall(B: BuilderRef,\n-                         Fn: ValueRef,\n-                         Args: *const ValueRef,\n-                         NumArgs: c_uint,\n-                         Name: *const c_char)\n-                         -> ValueRef;\n+    pub fn LLVMRustBuildCall(B: BuilderRef,\n+                             Fn: ValueRef,\n+                             Args: *const ValueRef,\n+                             NumArgs: c_uint,\n+                             Bundle: OperandBundleDefRef,\n+                             Name: *const c_char)\n+                             -> ValueRef;\n     pub fn LLVMBuildSelect(B: BuilderRef,\n                            If: ValueRef,\n                            Then: ValueRef,\n@@ -2126,6 +2156,12 @@ extern {\n     pub fn LLVMRustSetDataLayoutFromTargetMachine(M: ModuleRef,\n                                                   TM: TargetMachineRef);\n     pub fn LLVMRustGetModuleDataLayout(M: ModuleRef) -> TargetDataRef;\n+\n+    pub fn LLVMRustBuildOperandBundleDef(Name: *const c_char,\n+                                         Inputs: *const ValueRef,\n+                                         NumInputs: c_uint)\n+                                         -> OperandBundleDefRef;\n+    pub fn LLVMRustFreeOperandBundleDef(Bundle: OperandBundleDefRef);\n }\n \n #[cfg(have_component_x86)]\n@@ -2418,6 +2454,34 @@ pub fn last_error() -> Option<String> {\n     }\n }\n \n+pub struct OperandBundleDef {\n+    inner: OperandBundleDefRef,\n+}\n+\n+impl OperandBundleDef {\n+    pub fn new(name: &str, vals: &[ValueRef]) -> OperandBundleDef {\n+        let name = CString::new(name).unwrap();\n+        let def = unsafe {\n+            LLVMRustBuildOperandBundleDef(name.as_ptr(),\n+                                          vals.as_ptr(),\n+                                          vals.len() as c_uint)\n+        };\n+        OperandBundleDef { inner: def }\n+    }\n+\n+    pub fn raw(&self) -> OperandBundleDefRef {\n+        self.inner\n+    }\n+}\n+\n+impl Drop for OperandBundleDef {\n+    fn drop(&mut self) {\n+        unsafe {\n+            LLVMRustFreeOperandBundleDef(self.inner);\n+        }\n+    }\n+}\n+\n // The module containing the native LLVM dependencies, generated by the build system\n // Note that this must come after the rustllvm extern declaration so that\n // parts of LLVM that rustllvm depends on aren't thrown away by the linker."}, {"sha": "cbdadac4dc77c5bca76e21dd0a300ad5ca7dbd24", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=3e9589c0f43af69544b042f50b886005613540f2", "patch": "@@ -334,7 +334,7 @@ impl<'a> ArchiveBuilder<'a> {\n         // all SYMDEF files as these are just magical placeholders which get\n         // re-created when we make a new archive anyway.\n         for file in archive.iter() {\n-            let file = try!(file.map_err(string2io));\n+            let file = try!(file.map_err(string_to_io_error));\n             if !is_relevant_child(&file) {\n                 continue\n             }\n@@ -455,7 +455,7 @@ impl<'a> ArchiveBuilder<'a> {\n         unsafe {\n             if let Some(archive) = self.src_archive() {\n                 for child in archive.iter() {\n-                    let child = try!(child.map_err(string2io));\n+                    let child = try!(child.map_err(string_to_io_error));\n                     let child_name = match child.name() {\n                         Some(s) => s,\n                         None => continue,\n@@ -484,7 +484,7 @@ impl<'a> ArchiveBuilder<'a> {\n                     }\n                     Addition::Archive { archive, archive_name: _, mut skip } => {\n                         for child in archive.iter() {\n-                            let child = try!(child.map_err(string2io));\n+                            let child = try!(child.map_err(string_to_io_error));\n                             if !is_relevant_child(&child) {\n                                 continue\n                             }\n@@ -541,6 +541,6 @@ impl<'a> ArchiveBuilder<'a> {\n     }\n }\n \n-fn string2io(s: String) -> io::Error {\n+fn string_to_io_error(s: String) -> io::Error {\n     io::Error::new(io::ErrorKind::Other, format!(\"bad archive: {}\", s))\n }"}, {"sha": "441fdef0d4e26d5b2d7eff4c8461be1cefb8b0af", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=3e9589c0f43af69544b042f50b886005613540f2", "patch": "@@ -958,23 +958,11 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// currently uses SEH-ish unwinding with DWARF info tables to the side (same as\n /// 64-bit MinGW) instead of \"full SEH\".\n pub fn wants_msvc_seh(sess: &Session) -> bool {\n-    sess.target.target.options.is_like_msvc && sess.target.target.arch == \"x86\"\n+    sess.target.target.options.is_like_msvc\n }\n \n pub fn avoid_invoke(bcx: Block) -> bool {\n-    // FIXME(#25869) currently SEH-based unwinding is pretty buggy in LLVM and\n-    //               is being overhauled as this is being written. Until that\n-    //               time such that upstream LLVM's implementation is more solid\n-    //               and we start binding it we need to skip invokes for any\n-    //               target which wants SEH-based unwinding.\n-    if bcx.sess().no_landing_pads() || wants_msvc_seh(bcx.sess()) {\n-        true\n-    } else if bcx.is_lpad {\n-        // Avoid using invoke if we are already inside a landing pad.\n-        true\n-    } else {\n-        false\n-    }\n+    bcx.sess().no_landing_pads() || bcx.lpad.borrow().is_some()\n }\n \n pub fn need_invoke(bcx: Block) -> bool {\n@@ -1122,10 +1110,9 @@ pub fn init_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, local: &hir::Local) -> Blo\n }\n \n pub fn raw_block<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n-                             is_lpad: bool,\n                              llbb: BasicBlockRef)\n                              -> Block<'blk, 'tcx> {\n-    common::BlockS::new(llbb, is_lpad, None, fcx)\n+    common::BlockS::new(llbb, None, fcx)\n }\n \n pub fn with_cond<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>, val: ValueRef, f: F) -> Block<'blk, 'tcx>\n@@ -1298,7 +1285,7 @@ fn memfill<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>, byte:\n     let volatile = C_bool(ccx, false);\n     b.call(llintrinsicfn,\n            &[llptr, llzeroval, size, align, volatile],\n-           None);\n+           None, None);\n }\n \n /// In general, when we create an scratch value in an alloca, the\n@@ -1372,7 +1359,7 @@ pub fn alloca_dropped<'blk, 'tcx>(cx: Block<'blk, 'tcx>, ty: Ty<'tcx>, name: &st\n     // Block, which we do not have for `alloca_insert_pt`).\n     core_lifetime_emit(cx.ccx(), p, Lifetime::Start, |ccx, size, lifetime_start| {\n         let ptr = b.pointercast(p, Type::i8p(ccx));\n-        b.call(lifetime_start, &[C_u64(ccx, size), ptr], None);\n+        b.call(lifetime_start, &[C_u64(ccx, size), ptr], None, None);\n     });\n     memfill(&b, p, ty, adt::DTOR_DONE);\n     p\n@@ -1594,7 +1581,7 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n         alloca_insert_pt: Cell::new(None),\n         llreturn: Cell::new(None),\n         needs_ret_allocas: nested_returns,\n-        personality: Cell::new(None),\n+        landingpad_alloca: Cell::new(None),\n         caller_expects_out_pointer: uses_outptr,\n         lllocals: RefCell::new(NodeMap()),\n         llupvars: RefCell::new(NodeMap()),\n@@ -1873,7 +1860,7 @@ pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n             if !last_bcx.terminated.get() {\n                 Br(last_bcx, llreturn, DebugLoc::None);\n             }\n-            raw_block(fcx, false, llreturn)\n+            raw_block(fcx, llreturn)\n         }\n         None => last_bcx,\n     };\n@@ -2663,11 +2650,12 @@ pub fn create_entry_wrapper(ccx: &CrateContext, sp: Span, main_llfn: ValueRef) {\n                 (rust_main, args)\n             };\n \n-            let result = llvm::LLVMBuildCall(bld,\n-                                             start_fn,\n-                                             args.as_ptr(),\n-                                             args.len() as c_uint,\n-                                             noname());\n+            let result = llvm::LLVMRustBuildCall(bld,\n+                                                 start_fn,\n+                                                 args.as_ptr(),\n+                                                 args.len() as c_uint,\n+                                                 0 as *mut _,\n+                                                 noname());\n \n             llvm::LLVMBuildRet(bld, result);\n         }"}, {"sha": "e501855b5d5f9d766c1776b83dfd87257136fb05", "filename": "src/librustc_trans/trans/build.rs", "status": "modified", "additions": 56, "deletions": 3, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs?ref=3e9589c0f43af69544b042f50b886005613540f2", "patch": "@@ -150,7 +150,9 @@ pub fn Invoke(cx: Block,\n            cx.val_to_string(fn_),\n            args.iter().map(|a| cx.val_to_string(*a)).collect::<Vec<String>>().join(\", \"));\n     debug_loc.apply(cx.fcx);\n-    B(cx).invoke(fn_, args, then, catch, attributes)\n+    let lpad = cx.lpad.borrow();\n+    let bundle = lpad.as_ref().and_then(|b| b.bundle());\n+    B(cx).invoke(fn_, args, then, catch, bundle, attributes)\n }\n \n pub fn Unreachable(cx: Block) {\n@@ -914,7 +916,9 @@ pub fn Call(cx: Block,\n         return _UndefReturn(cx, fn_);\n     }\n     debug_loc.apply(cx.fcx);\n-    B(cx).call(fn_, args, attributes)\n+    let lpad = cx.lpad.borrow();\n+    let bundle = lpad.as_ref().and_then(|b| b.bundle());\n+    B(cx).call(fn_, args, bundle, attributes)\n }\n \n pub fn CallWithConv(cx: Block,\n@@ -928,7 +932,9 @@ pub fn CallWithConv(cx: Block,\n         return _UndefReturn(cx, fn_);\n     }\n     debug_loc.apply(cx.fcx);\n-    B(cx).call_with_conv(fn_, args, conv, attributes)\n+    let lpad = cx.lpad.borrow();\n+    let bundle = lpad.as_ref().and_then(|b| b.bundle());\n+    B(cx).call_with_conv(fn_, args, conv, bundle, attributes)\n }\n \n pub fn AtomicFence(cx: Block, order: AtomicOrdering, scope: SynchronizationScope) {\n@@ -1050,6 +1056,10 @@ pub fn SetCleanup(cx: Block, landing_pad: ValueRef) {\n     B(cx).set_cleanup(landing_pad)\n }\n \n+pub fn SetPersonalityFn(cx: Block, f: ValueRef) {\n+    B(cx).set_personality_fn(f)\n+}\n+\n pub fn Resume(cx: Block, exn: ValueRef) -> ValueRef {\n     check_not_terminated(cx);\n     terminate(cx, \"Resume\");\n@@ -1068,3 +1078,46 @@ pub fn AtomicRMW(cx: Block, op: AtomicBinOp,\n                  order: AtomicOrdering) -> ValueRef {\n     B(cx).atomic_rmw(op, dst, src, order)\n }\n+\n+pub fn CleanupPad(cx: Block,\n+                  parent: Option<ValueRef>,\n+                  args: &[ValueRef]) -> ValueRef {\n+    check_not_terminated(cx);\n+    assert!(!cx.unreachable.get());\n+    B(cx).cleanup_pad(parent, args)\n+}\n+\n+pub fn CleanupRet(cx: Block,\n+                  cleanup: ValueRef,\n+                  unwind: Option<BasicBlockRef>) -> ValueRef {\n+    check_not_terminated(cx);\n+    terminate(cx, \"CleanupRet\");\n+    B(cx).cleanup_ret(cleanup, unwind)\n+}\n+\n+pub fn CatchPad(cx: Block,\n+                parent: ValueRef,\n+                args: &[ValueRef]) -> ValueRef {\n+    check_not_terminated(cx);\n+    assert!(!cx.unreachable.get());\n+    B(cx).catch_pad(parent, args)\n+}\n+\n+pub fn CatchRet(cx: Block, pad: ValueRef, unwind: BasicBlockRef) -> ValueRef {\n+    check_not_terminated(cx);\n+    terminate(cx, \"CatchRet\");\n+    B(cx).catch_ret(pad, unwind)\n+}\n+\n+pub fn CatchSwitch(cx: Block,\n+                   parent: Option<ValueRef>,\n+                   unwind: Option<BasicBlockRef>,\n+                   num_handlers: usize) -> ValueRef {\n+    check_not_terminated(cx);\n+    terminate(cx, \"CatchSwitch\");\n+    B(cx).catch_switch(parent, unwind, num_handlers)\n+}\n+\n+pub fn AddHandler(cx: Block, catch_switch: ValueRef, handler: BasicBlockRef) {\n+    B(cx).add_handler(catch_switch, handler)\n+}"}, {"sha": "878d01f46b63f36268995632697310d18038aacc", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 112, "deletions": 22, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=3e9589c0f43af69544b042f50b886005613540f2", "patch": "@@ -12,7 +12,7 @@\n \n use llvm;\n use llvm::{CallConv, AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect, AttrBuilder};\n-use llvm::{Opcode, IntPredicate, RealPredicate, False};\n+use llvm::{Opcode, IntPredicate, RealPredicate, False, OperandBundleDef};\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ModuleRef};\n use trans::base;\n use trans::common::*;\n@@ -158,6 +158,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                   args: &[ValueRef],\n                   then: BasicBlockRef,\n                   catch: BasicBlockRef,\n+                  bundle: Option<&OperandBundleDef>,\n                   attributes: Option<AttrBuilder>)\n                   -> ValueRef {\n         self.count_insn(\"invoke\");\n@@ -169,17 +170,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                    .collect::<Vec<String>>()\n                    .join(\", \"));\n \n+        let bundle = bundle.as_ref().map(|b| b.raw()).unwrap_or(0 as *mut _);\n+\n         unsafe {\n-            let v = llvm::LLVMBuildInvoke(self.llbuilder,\n-                                          llfn,\n-                                          args.as_ptr(),\n-                                          args.len() as c_uint,\n-                                          then,\n-                                          catch,\n-                                          noname());\n-            match attributes {\n-                Some(a) => a.apply_callsite(v),\n-                None => {}\n+            let v = llvm::LLVMRustBuildInvoke(self.llbuilder,\n+                                              llfn,\n+                                              args.as_ptr(),\n+                                              args.len() as c_uint,\n+                                              then,\n+                                              catch,\n+                                              bundle,\n+                                              noname());\n+            if let Some(a) = attributes {\n+                a.apply_callsite(v);\n             }\n             v\n         }\n@@ -771,7 +774,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                          comment_text.as_ptr(), noname(), False,\n                                          False)\n             };\n-            self.call(asm, &[], None);\n+            self.call(asm, &[], None, None);\n         }\n     }\n \n@@ -796,11 +799,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         unsafe {\n             let v = llvm::LLVMInlineAsm(\n                 fty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);\n-            self.call(v, inputs, None)\n+            self.call(v, inputs, None, None)\n         }\n     }\n \n     pub fn call(&self, llfn: ValueRef, args: &[ValueRef],\n+                bundle: Option<&OperandBundleDef>,\n                 attributes: Option<AttrBuilder>) -> ValueRef {\n         self.count_insn(\"call\");\n \n@@ -837,21 +841,25 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n \n+        let bundle = bundle.as_ref().map(|b| b.raw()).unwrap_or(0 as *mut _);\n+\n         unsafe {\n-            let v = llvm::LLVMBuildCall(self.llbuilder, llfn, args.as_ptr(),\n-                                        args.len() as c_uint, noname());\n-            match attributes {\n-                Some(a) => a.apply_callsite(v),\n-                None => {}\n+            let v = llvm::LLVMRustBuildCall(self.llbuilder, llfn, args.as_ptr(),\n+                                            args.len() as c_uint, bundle,\n+                                            noname());\n+            if let Some(a) = attributes {\n+                a.apply_callsite(v);\n             }\n             v\n         }\n     }\n \n     pub fn call_with_conv(&self, llfn: ValueRef, args: &[ValueRef],\n-                          conv: CallConv, attributes: Option<AttrBuilder>) -> ValueRef {\n+                          conv: CallConv,\n+                          bundle: Option<&OperandBundleDef>,\n+                          attributes: Option<AttrBuilder>) -> ValueRef {\n         self.count_insn(\"callwithconv\");\n-        let v = self.call(llfn, args, attributes);\n+        let v = self.call(llfn, args, bundle, attributes);\n         llvm::SetInstructionCallConv(v, conv);\n         v\n     }\n@@ -948,8 +956,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             assert!((t as isize != 0));\n             let args: &[ValueRef] = &[];\n             self.count_insn(\"trap\");\n-            llvm::LLVMBuildCall(\n-                self.llbuilder, t, args.as_ptr(), args.len() as c_uint, noname());\n+            llvm::LLVMRustBuildCall(self.llbuilder, t,\n+                                    args.as_ptr(), args.len() as c_uint,\n+                                    0 as *mut _,\n+                                    noname());\n         }\n     }\n \n@@ -983,6 +993,86 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    pub fn cleanup_pad(&self,\n+                       parent: Option<ValueRef>,\n+                       args: &[ValueRef]) -> ValueRef {\n+        self.count_insn(\"cleanuppad\");\n+        let parent = parent.unwrap_or(0 as *mut _);\n+        let name = CString::new(\"cleanuppad\").unwrap();\n+        let ret = unsafe {\n+            llvm::LLVMRustBuildCleanupPad(self.llbuilder,\n+                                          parent,\n+                                          args.len() as c_uint,\n+                                          args.as_ptr(),\n+                                          name.as_ptr())\n+        };\n+        assert!(!ret.is_null(), \"LLVM does not have support for cleanuppad\");\n+        return ret\n+    }\n+\n+    pub fn cleanup_ret(&self, cleanup: ValueRef,\n+                       unwind: Option<BasicBlockRef>) -> ValueRef {\n+        self.count_insn(\"cleanupret\");\n+        let unwind = unwind.unwrap_or(0 as *mut _);\n+        let ret = unsafe {\n+            llvm::LLVMRustBuildCleanupRet(self.llbuilder, cleanup, unwind)\n+        };\n+        assert!(!ret.is_null(), \"LLVM does not have support for cleanupret\");\n+        return ret\n+    }\n+\n+    pub fn catch_pad(&self,\n+                     parent: ValueRef,\n+                     args: &[ValueRef]) -> ValueRef {\n+        self.count_insn(\"catchpad\");\n+        let name = CString::new(\"catchpad\").unwrap();\n+        let ret = unsafe {\n+            llvm::LLVMRustBuildCatchPad(self.llbuilder, parent,\n+                                        args.len() as c_uint, args.as_ptr(),\n+                                        name.as_ptr())\n+        };\n+        assert!(!ret.is_null(), \"LLVM does not have support for catchpad\");\n+        return ret\n+    }\n+\n+    pub fn catch_ret(&self, pad: ValueRef, unwind: BasicBlockRef) -> ValueRef {\n+        self.count_insn(\"catchret\");\n+        let ret = unsafe {\n+            llvm::LLVMRustBuildCatchRet(self.llbuilder, pad, unwind)\n+        };\n+        assert!(!ret.is_null(), \"LLVM does not have support for catchret\");\n+        return ret\n+    }\n+\n+    pub fn catch_switch(&self,\n+                        parent: Option<ValueRef>,\n+                        unwind: Option<BasicBlockRef>,\n+                        num_handlers: usize) -> ValueRef {\n+        self.count_insn(\"catchswitch\");\n+        let parent = parent.unwrap_or(0 as *mut _);\n+        let unwind = unwind.unwrap_or(0 as *mut _);\n+        let name = CString::new(\"catchswitch\").unwrap();\n+        let ret = unsafe {\n+            llvm::LLVMRustBuildCatchSwitch(self.llbuilder, parent, unwind,\n+                                           num_handlers as c_uint,\n+                                           name.as_ptr())\n+        };\n+        assert!(!ret.is_null(), \"LLVM does not have support for catchswitch\");\n+        return ret\n+    }\n+\n+    pub fn add_handler(&self, catch_switch: ValueRef, handler: BasicBlockRef) {\n+        unsafe {\n+            llvm::LLVMRustAddHandler(catch_switch, handler);\n+        }\n+    }\n+\n+    pub fn set_personality_fn(&self, personality: ValueRef) {\n+        unsafe {\n+            llvm::LLVMRustSetPersonalityFn(self.llbuilder, personality);\n+        }\n+    }\n+\n     // Atomic Operations\n     pub fn atomic_cmpxchg(&self, dst: ValueRef,\n                          cmp: ValueRef, src: ValueRef,"}, {"sha": "dee9fb3447b4533ba8a35950a51d4c9cd166c174", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 151, "deletions": 86, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=3e9589c0f43af69544b042f50b886005613540f2", "patch": "@@ -123,7 +123,7 @@ use llvm::{BasicBlockRef, ValueRef};\n use trans::base;\n use trans::build;\n use trans::common;\n-use trans::common::{Block, FunctionContext, NodeIdAndSpan};\n+use trans::common::{Block, FunctionContext, NodeIdAndSpan, LandingPad};\n use trans::datum::{Datum, Lvalue};\n use trans::debuginfo::{DebugLoc, ToDebugLoc};\n use trans::glue;\n@@ -185,11 +185,17 @@ impl<'blk, 'tcx: 'blk> fmt::Debug for CleanupScopeKind<'blk, 'tcx> {\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum EarlyExitLabel {\n-    UnwindExit,\n+    UnwindExit(UnwindKind),\n     ReturnExit,\n     LoopExit(ast::NodeId, usize)\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub enum UnwindKind {\n+    LandingPad,\n+    CleanupPad(ValueRef),\n+}\n+\n #[derive(Copy, Clone)]\n pub struct CachedEarlyExit {\n     label: EarlyExitLabel,\n@@ -372,16 +378,17 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         self.ccx.sess().bug(\"no loop scope found\");\n     }\n \n-    /// Returns a block to branch to which will perform all pending cleanups and then\n-    /// break/continue (depending on `exit`) out of the loop with id `cleanup_scope`\n+    /// Returns a block to branch to which will perform all pending cleanups and\n+    /// then break/continue (depending on `exit`) out of the loop with id\n+    /// `cleanup_scope`\n     fn normal_exit_block(&'blk self,\n                          cleanup_scope: ast::NodeId,\n                          exit: usize) -> BasicBlockRef {\n         self.trans_cleanups_to_exit_scope(LoopExit(cleanup_scope, exit))\n     }\n \n-    /// Returns a block to branch to which will perform all pending cleanups and then return from\n-    /// this function\n+    /// Returns a block to branch to which will perform all pending cleanups and\n+    /// then return from this function\n     fn return_exit_block(&'blk self) -> BasicBlockRef {\n         self.trans_cleanups_to_exit_scope(ReturnExit)\n     }\n@@ -400,7 +407,8 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n \n-    /// Schedules a (deep) drop of `val`, which is a pointer to an instance of `ty`\n+    /// Schedules a (deep) drop of `val`, which is a pointer to an instance of\n+    /// `ty`\n     fn schedule_drop_mem(&self,\n                          cleanup_scope: ScopeId,\n                          val: ValueRef,\n@@ -585,8 +593,9 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         self.scopes.borrow().iter().rev().any(|s| s.needs_invoke())\n     }\n \n-    /// Returns a basic block to branch to in the event of a panic. This block will run the panic\n-    /// cleanups and eventually invoke the LLVM `Resume` instruction.\n+    /// Returns a basic block to branch to in the event of a panic. This block\n+    /// will run the panic cleanups and eventually resume the exception that\n+    /// caused the landing pad to be run.\n     fn get_landing_pad(&'blk self) -> BasicBlockRef {\n         let _icx = base::push_ctxt(\"get_landing_pad\");\n \n@@ -682,9 +691,10 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n         f(self.scopes.borrow().last().unwrap())\n     }\n \n-    /// Used when the caller wishes to jump to an early exit, such as a return, break, continue, or\n-    /// unwind. This function will generate all cleanups between the top of the stack and the exit\n-    /// `label` and return a basic block that the caller can branch to.\n+    /// Used when the caller wishes to jump to an early exit, such as a return,\n+    /// break, continue, or unwind. This function will generate all cleanups\n+    /// between the top of the stack and the exit `label` and return a basic\n+    /// block that the caller can branch to.\n     ///\n     /// For example, if the current stack of cleanups were as follows:\n     ///\n@@ -695,15 +705,15 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n     ///      Custom 2\n     ///      AST 24\n     ///\n-    /// and the `label` specifies a break from `Loop 23`, then this function would generate a\n-    /// series of basic blocks as follows:\n+    /// and the `label` specifies a break from `Loop 23`, then this function\n+    /// would generate a series of basic blocks as follows:\n     ///\n     ///      Cleanup(AST 24) -> Cleanup(Custom 2) -> break_blk\n     ///\n-    /// where `break_blk` is the block specified in `Loop 23` as the target for breaks. The return\n-    /// value would be the first basic block in that sequence (`Cleanup(AST 24)`). The caller could\n-    /// then branch to `Cleanup(AST 24)` and it will perform all cleanups and finally branch to the\n-    /// `break_blk`.\n+    /// where `break_blk` is the block specified in `Loop 23` as the target for\n+    /// breaks. The return value would be the first basic block in that sequence\n+    /// (`Cleanup(AST 24)`). The caller could then branch to `Cleanup(AST 24)`\n+    /// and it will perform all cleanups and finally branch to the `break_blk`.\n     fn trans_cleanups_to_exit_scope(&'blk self,\n                                     label: EarlyExitLabel)\n                                     -> BasicBlockRef {\n@@ -725,21 +735,30 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n         loop {\n             if self.scopes_len() == 0 {\n                 match label {\n-                    UnwindExit => {\n-                        // Generate a block that will `Resume`.\n-                        let prev_bcx = self.new_block(true, \"resume\", None);\n-                        let personality = self.personality.get().expect(\n-                            \"create_landing_pad() should have set this\");\n-                        let lp = build::Load(prev_bcx, personality);\n-                        base::call_lifetime_end(prev_bcx, personality);\n-                        base::trans_unwind_resume(prev_bcx, lp);\n-                        prev_llbb = prev_bcx.llbb;\n+                    UnwindExit(val) => {\n+                        // Generate a block that will resume unwinding to the\n+                        // calling function\n+                        let bcx = self.new_block(\"resume\", None);\n+                        match val {\n+                            UnwindKind::LandingPad => {\n+                                let addr = self.landingpad_alloca.get()\n+                                               .unwrap();\n+                                let lp = build::Load(bcx, addr);\n+                                base::call_lifetime_end(bcx, addr);\n+                                base::trans_unwind_resume(bcx, lp);\n+                            }\n+                            UnwindKind::CleanupPad(_) => {\n+                                let pad = build::CleanupPad(bcx, None, &[]);\n+                                build::CleanupRet(bcx, pad, None);\n+                            }\n+                        }\n+                        prev_llbb = bcx.llbb;\n                         break;\n                     }\n \n                     ReturnExit => {\n                         prev_llbb = self.get_llreturn();\n-                        break;\n+                        break\n                     }\n \n                     LoopExit(id, _) => {\n@@ -754,12 +773,9 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n             // scope for this label. If so, we can stop popping scopes\n             // and branch to the cached label, since it contains the\n             // cleanups for any subsequent scopes.\n-            match self.top_scope(|s| s.cached_early_exit(label)) {\n-                Some(cleanup_block) => {\n-                    prev_llbb = cleanup_block;\n-                    break;\n-                }\n-                None => { }\n+            if let Some(exit) = self.top_scope(|s| s.cached_early_exit(label)) {\n+                prev_llbb = exit;\n+                break;\n             }\n \n             // Pop off the scope, since we will be generating\n@@ -769,15 +785,11 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n             popped_scopes.push(self.pop_scope());\n             let scope = popped_scopes.last().unwrap();\n             match label {\n-                UnwindExit | ReturnExit => { }\n+                UnwindExit(..) | ReturnExit => { }\n                 LoopExit(id, exit) => {\n-                    match scope.kind.early_exit_block(id, exit) {\n-                        Some(exitllbb) => {\n-                            prev_llbb = exitllbb;\n-                            break;\n-                        }\n-\n-                        None => { }\n+                    if let Some(exit) = scope.kind.early_exit_block(id, exit) {\n+                        prev_llbb = exit;\n+                        break\n                     }\n                 }\n             }\n@@ -810,18 +822,17 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n             if !scope.cleanups.is_empty() {\n                 let name = scope.block_name(\"clean\");\n                 debug!(\"generating cleanups for {}\", name);\n-                let bcx_in = self.new_block(label.is_unwind(),\n-                                            &name[..],\n-                                            None);\n+\n+                let bcx_in = self.new_block(&name[..], None);\n+                let exit_label = label.start(bcx_in);\n                 let mut bcx_out = bcx_in;\n                 for cleanup in scope.cleanups.iter().rev() {\n-                    bcx_out = cleanup.trans(bcx_out,\n-                                            scope.debug_loc);\n+                    bcx_out = cleanup.trans(bcx_out, scope.debug_loc);\n                 }\n-                build::Br(bcx_out, prev_llbb, DebugLoc::None);\n+                exit_label.branch(bcx_out, prev_llbb);\n                 prev_llbb = bcx_in.llbb;\n \n-                scope.add_cached_early_exit(label, prev_llbb);\n+                scope.add_cached_early_exit(exit_label, prev_llbb);\n             }\n             self.push_scope(scope);\n         }\n@@ -832,14 +843,14 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n         prev_llbb\n     }\n \n-    /// Creates a landing pad for the top scope, if one does not exist.  The landing pad will\n-    /// perform all cleanups necessary for an unwind and then `resume` to continue error\n-    /// propagation:\n+    /// Creates a landing pad for the top scope, if one does not exist.  The\n+    /// landing pad will perform all cleanups necessary for an unwind and then\n+    /// `resume` to continue error propagation:\n     ///\n     ///     landing_pad -> ... cleanups ... -> [resume]\n     ///\n-    /// (The cleanups and resume instruction are created by `trans_cleanups_to_exit_scope()`, not\n-    /// in this function itself.)\n+    /// (The cleanups and resume instruction are created by\n+    /// `trans_cleanups_to_exit_scope()`, not in this function itself.)\n     fn get_or_create_landing_pad(&'blk self) -> BasicBlockRef {\n         let pad_bcx;\n \n@@ -850,47 +861,58 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n             let mut scopes = self.scopes.borrow_mut();\n             let last_scope = scopes.last_mut().unwrap();\n             match last_scope.cached_landing_pad {\n-                Some(llbb) => { return llbb; }\n+                Some(llbb) => return llbb,\n                 None => {\n                     let name = last_scope.block_name(\"unwind\");\n-                    pad_bcx = self.new_block(true, &name[..], None);\n+                    pad_bcx = self.new_block(&name[..], None);\n                     last_scope.cached_landing_pad = Some(pad_bcx.llbb);\n                 }\n             }\n-        }\n-\n-        // The landing pad return type (the type being propagated). Not sure what\n-        // this represents but it's determined by the personality function and\n-        // this is what the EH proposal example uses.\n-        let llretty = Type::struct_(self.ccx,\n-                                    &[Type::i8p(self.ccx), Type::i32(self.ccx)],\n-                                    false);\n+        };\n \n         let llpersonality = pad_bcx.fcx.eh_personality();\n \n-        // The only landing pad clause will be 'cleanup'\n-        let llretval = build::LandingPad(pad_bcx, llretty, llpersonality, 1);\n+        let val = if base::wants_msvc_seh(self.ccx.sess()) {\n+            // A cleanup pad requires a personality function to be specified, so\n+            // we do that here explicitly (happens implicitly below through\n+            // creation of the landingpad instruction). We then create a\n+            // cleanuppad instruction which has no filters to run cleanup on all\n+            // exceptions.\n+            build::SetPersonalityFn(pad_bcx, llpersonality);\n+            let llretval = build::CleanupPad(pad_bcx, None, &[]);\n+            UnwindKind::CleanupPad(llretval)\n+        } else {\n+            // The landing pad return type (the type being propagated). Not sure\n+            // what this represents but it's determined by the personality\n+            // function and this is what the EH proposal example uses.\n+            let llretty = Type::struct_(self.ccx,\n+                                        &[Type::i8p(self.ccx), Type::i32(self.ccx)],\n+                                        false);\n \n-        // The landing pad block is a cleanup\n-        build::SetCleanup(pad_bcx, llretval);\n+            // The only landing pad clause will be 'cleanup'\n+            let llretval = build::LandingPad(pad_bcx, llretty, llpersonality, 1);\n \n-        // We store the retval in a function-central alloca, so that calls to\n-        // Resume can find it.\n-        match self.personality.get() {\n-            Some(addr) => {\n-                build::Store(pad_bcx, llretval, addr);\n-            }\n-            None => {\n-                let addr = base::alloca(pad_bcx, common::val_ty(llretval), \"\");\n-                base::call_lifetime_start(pad_bcx, addr);\n-                self.personality.set(Some(addr));\n-                build::Store(pad_bcx, llretval, addr);\n-            }\n-        }\n+            // The landing pad block is a cleanup\n+            build::SetCleanup(pad_bcx, llretval);\n+\n+            let addr = match self.landingpad_alloca.get() {\n+                Some(addr) => addr,\n+                None => {\n+                    let addr = base::alloca(pad_bcx, common::val_ty(llretval),\n+                                            \"\");\n+                    base::call_lifetime_start(pad_bcx, addr);\n+                    self.landingpad_alloca.set(Some(addr));\n+                    addr\n+                }\n+            };\n+            build::Store(pad_bcx, llretval, addr);\n+            UnwindKind::LandingPad\n+        };\n \n         // Generate the cleanup block and branch to it.\n-        let cleanup_llbb = self.trans_cleanups_to_exit_scope(UnwindExit);\n-        build::Br(pad_bcx, cleanup_llbb, DebugLoc::None);\n+        let label = UnwindExit(val);\n+        let cleanup_llbb = self.trans_cleanups_to_exit_scope(label);\n+        label.branch(pad_bcx, cleanup_llbb);\n \n         return pad_bcx.llbb;\n     }\n@@ -992,10 +1014,53 @@ impl<'blk, 'tcx> CleanupScopeKind<'blk, 'tcx> {\n }\n \n impl EarlyExitLabel {\n-    fn is_unwind(&self) -> bool {\n+    /// Generates a branch going from `from_bcx` to `to_llbb` where `self` is\n+    /// the exit label attached to the start of `from_bcx`.\n+    ///\n+    /// Transitions from an exit label to other exit labels depend on the type\n+    /// of label. For example with MSVC exceptions unwind exit labels will use\n+    /// the `cleanupret` instruction instead of the `br` instruction.\n+    fn branch(&self, from_bcx: Block, to_llbb: BasicBlockRef) {\n+        if let UnwindExit(UnwindKind::CleanupPad(pad)) = *self {\n+            build::CleanupRet(from_bcx, pad, Some(to_llbb));\n+        } else {\n+            build::Br(from_bcx, to_llbb, DebugLoc::None);\n+        }\n+    }\n+\n+    /// Generates the necessary instructions at the start of `bcx` to prepare\n+    /// for the same kind of early exit label that `self` is.\n+    ///\n+    /// This function will appropriately configure `bcx` based on the kind of\n+    /// label this is. For UnwindExit labels, the `lpad` field of the block will\n+    /// be set to `Some`, and for MSVC exceptions this function will generate a\n+    /// `cleanuppad` instruction at the start of the block so it may be jumped\n+    /// to in the future (e.g. so this block can be cached as an early exit).\n+    ///\n+    /// Returns a new label which will can be used to cache `bcx` in the list of\n+    /// early exits.\n+    fn start(&self, bcx: Block) -> EarlyExitLabel {\n         match *self {\n-            UnwindExit => true,\n-            _ => false\n+            UnwindExit(UnwindKind::CleanupPad(..)) => {\n+                let pad = build::CleanupPad(bcx, None, &[]);\n+                *bcx.lpad.borrow_mut() = Some(LandingPad::msvc(pad));\n+                UnwindExit(UnwindKind::CleanupPad(pad))\n+            }\n+            UnwindExit(UnwindKind::LandingPad) => {\n+                *bcx.lpad.borrow_mut() = Some(LandingPad::gnu());\n+                *self\n+            }\n+            label => label,\n+        }\n+    }\n+}\n+\n+impl PartialEq for UnwindKind {\n+    fn eq(&self, val: &UnwindKind) -> bool {\n+        match (*self, *val) {\n+            (UnwindKind::LandingPad, UnwindKind::LandingPad) |\n+            (UnwindKind::CleanupPad(..), UnwindKind::CleanupPad(..)) => true,\n+            _ => false,\n         }\n     }\n }"}, {"sha": "303fc17ce81b467e22af76d45425c769d1f8a4cd", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 62, "deletions": 12, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=3e9589c0f43af69544b042f50b886005613540f2", "patch": "@@ -17,7 +17,7 @@ pub use self::ExprOrMethodCall::*;\n use session::Session;\n use llvm;\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ContextRef, TypeKind};\n-use llvm::{True, False, Bool};\n+use llvm::{True, False, Bool, OperandBundleDef};\n use middle::cfg;\n use middle::def::Def;\n use middle::def_id::DefId;\n@@ -326,9 +326,13 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // we use a separate alloca for each return\n     pub needs_ret_allocas: bool,\n \n-    // The a value alloca'd for calls to upcalls.rust_personality. Used when\n-    // outputting the resume instruction.\n-    pub personality: Cell<Option<ValueRef>>,\n+    // When working with landingpad-based exceptions this value is alloca'd and\n+    // later loaded when using the resume instruction. This ends up being\n+    // critical to chaining landing pads and resuing already-translated\n+    // cleanups.\n+    //\n+    // Note that for cleanuppad-based exceptions this is not used.\n+    pub landingpad_alloca: Cell<Option<ValueRef>>,\n \n     // True if the caller expects this fn to use the out pointer to\n     // return. Either way, your code should write into the slot llretslotptr\n@@ -424,7 +428,6 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     }\n \n     pub fn new_block(&'a self,\n-                     is_lpad: bool,\n                      name: &str,\n                      opt_node_id: Option<ast::NodeId>)\n                      -> Block<'a, 'tcx> {\n@@ -433,21 +436,21 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n             let llbb = llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(),\n                                                            self.llfn,\n                                                            name.as_ptr());\n-            BlockS::new(llbb, is_lpad, opt_node_id, self)\n+            BlockS::new(llbb, opt_node_id, self)\n         }\n     }\n \n     pub fn new_id_block(&'a self,\n                         name: &str,\n                         node_id: ast::NodeId)\n                         -> Block<'a, 'tcx> {\n-        self.new_block(false, name, Some(node_id))\n+        self.new_block(name, Some(node_id))\n     }\n \n     pub fn new_temp_block(&'a self,\n                           name: &str)\n                           -> Block<'a, 'tcx> {\n-        self.new_block(false, name, None)\n+        self.new_block(name, None)\n     }\n \n     pub fn join_blocks(&'a self,\n@@ -577,8 +580,9 @@ pub struct BlockS<'blk, 'tcx: 'blk> {\n     pub terminated: Cell<bool>,\n     pub unreachable: Cell<bool>,\n \n-    // Is this block part of a landing pad?\n-    pub is_lpad: bool,\n+    // If this block part of a landing pad, then this is `Some` indicating what\n+    // kind of landing pad its in, otherwise this is none.\n+    pub lpad: RefCell<Option<LandingPad>>,\n \n     // AST node-id associated with this block, if any. Used for\n     // debugging purposes only.\n@@ -593,15 +597,14 @@ pub type Block<'blk, 'tcx> = &'blk BlockS<'blk, 'tcx>;\n \n impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     pub fn new(llbb: BasicBlockRef,\n-               is_lpad: bool,\n                opt_node_id: Option<ast::NodeId>,\n                fcx: &'blk FunctionContext<'blk, 'tcx>)\n                -> Block<'blk, 'tcx> {\n         fcx.block_arena.alloc(BlockS {\n             llbb: llbb,\n             terminated: Cell::new(false),\n             unreachable: Cell::new(false),\n-            is_lpad: is_lpad,\n+            lpad: RefCell::new(None),\n             opt_node_id: opt_node_id,\n             fcx: fcx\n         })\n@@ -658,6 +661,53 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     }\n }\n \n+/// A structure representing an active landing pad for the duration of a basic\n+/// block.\n+///\n+/// Each `Block` may contain an instance of this, indicating whether the block\n+/// is part of a landing pad or not. This is used to make decision about whether\n+/// to emit `invoke` instructions (e.g. in a landing pad we don't continue to\n+/// use `invoke`) and also about various function call metadata.\n+///\n+/// For GNU exceptions (`landingpad` + `resume` instructions) this structure is\n+/// just a bunch of `None` instances (not too interesting), but for MSVC\n+/// exceptions (`cleanuppad` + `cleanupret` instructions) this contains data.\n+/// When inside of a landing pad, each function call in LLVM IR needs to be\n+/// annotated with which landing pad it's a part of. This is accomplished via\n+/// the `OperandBundleDef` value created for MSVC landing pads.\n+pub struct LandingPad {\n+    cleanuppad: Option<ValueRef>,\n+    operand: Option<OperandBundleDef>,\n+}\n+\n+impl LandingPad {\n+    pub fn gnu() -> LandingPad {\n+        LandingPad { cleanuppad: None, operand: None }\n+    }\n+\n+    pub fn msvc(cleanuppad: ValueRef) -> LandingPad {\n+        LandingPad {\n+            cleanuppad: Some(cleanuppad),\n+            operand: Some(OperandBundleDef::new(\"funclet\", &[cleanuppad])),\n+        }\n+    }\n+\n+    pub fn bundle(&self) -> Option<&OperandBundleDef> {\n+        self.operand.as_ref()\n+    }\n+}\n+\n+impl Clone for LandingPad {\n+    fn clone(&self) -> LandingPad {\n+        LandingPad {\n+            cleanuppad: self.cleanuppad,\n+            operand: self.cleanuppad.map(|p| {\n+                OperandBundleDef::new(\"funclet\", &[p])\n+            }),\n+        }\n+    }\n+}\n+\n pub struct Result<'blk, 'tcx: 'blk> {\n     pub bcx: Block<'blk, 'tcx>,\n     pub val: ValueRef"}, {"sha": "fda8577f99f9c4753d0b527c3c6c702188b08600", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=3e9589c0f43af69544b042f50b886005613540f2", "patch": "@@ -833,6 +833,16 @@ fn declare_intrinsic(ccx: &CrateContext, key: &str) -> Option<ValueRef> {\n                 return Some(f);\n             }\n         );\n+        ($name:expr, fn(...) -> $ret:expr) => (\n+            if key == $name {\n+                let f = declare::declare_cfn(ccx, $name,\n+                                             Type::variadic_func(&[], &$ret),\n+                                             ccx.tcx().mk_nil());\n+                llvm::SetUnnamedAddr(f, false);\n+                ccx.intrinsics().borrow_mut().insert($name, f.clone());\n+                return Some(f);\n+            }\n+        );\n         ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n             if key == $name {\n                 let f = declare::declare_cfn(ccx, $name, Type::func(&[$($arg),*], &$ret),\n@@ -841,7 +851,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: &str) -> Option<ValueRef> {\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n-        )\n+        );\n     }\n     macro_rules! mk_struct {\n         ($($field_ty:expr),*) => (Type::struct_(ccx, &[$($field_ty),*], false))\n@@ -869,6 +879,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: &str) -> Option<ValueRef> {\n \n     ifn!(\"llvm.trap\", fn() -> void);\n     ifn!(\"llvm.debugtrap\", fn() -> void);\n+    ifn!(\"llvm.frameaddress\", fn(t_i32) -> i8p);\n \n     ifn!(\"llvm.powi.f32\", fn(t_f32, t_i32) -> t_f32);\n     ifn!(\"llvm.powi.f64\", fn(t_f64, t_i32) -> t_f64);\n@@ -969,6 +980,9 @@ fn declare_intrinsic(ccx: &CrateContext, key: &str) -> Option<ValueRef> {\n \n     ifn!(\"llvm.expect.i1\", fn(i1, i1) -> i1);\n     ifn!(\"llvm.eh.typeid.for\", fn(i8p) -> t_i32);\n+    ifn!(\"llvm.localescape\", fn(...) -> void);\n+    ifn!(\"llvm.localrecover\", fn(i8p, i8p, t_i32) -> i8p);\n+    ifn!(\"llvm.x86.seh.recoverfp\", fn(i8p, i8p) -> i8p);\n \n     // Some intrinsics were introduced in later versions of LLVM, but they have\n     // fallbacks in libc or libm and such."}, {"sha": "3689f30e38f236fd12d308f2217a0a144f38cd88", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=3e9589c0f43af69544b042f50b886005613540f2", "patch": "@@ -844,7 +844,8 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         debug!(\"calling llrustfn = {}, t = {:?}\",\n                ccx.tn().val_to_string(llrustfn), t);\n         let attributes = attributes::from_fn_type(ccx, t);\n-        let llrust_ret_val = builder.call(llrustfn, &llrust_args, Some(attributes));\n+        let llrust_ret_val = builder.call(llrustfn, &llrust_args,\n+                                          None, Some(attributes));\n \n         // Get the return value where the foreign fn expects it.\n         let llforeign_ret_ty = match tys.fn_ty.ret_ty.cast {"}, {"sha": "c6fb119ff0ba4678109afb3ef189110d6f3d19db", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 234, "deletions": 131, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=3e9589c0f43af69544b042f50b886005613540f2", "patch": "@@ -316,18 +316,21 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     // For `try` we need some custom control flow\n     if &name[..] == \"try\" {\n         if let callee::ArgExprs(ref exprs) = args {\n-            let (func, data) = if exprs.len() != 2 {\n-                ccx.sess().bug(\"expected two exprs as arguments for \\\n+            let (func, data, local_ptr) = if exprs.len() != 3 {\n+                ccx.sess().bug(\"expected three exprs as arguments for \\\n                                 `try` intrinsic\");\n             } else {\n-                (&exprs[0], &exprs[1])\n+                (&exprs[0], &exprs[1], &exprs[2])\n             };\n \n             // translate arguments\n             let func = unpack_datum!(bcx, expr::trans(bcx, func));\n             let func = unpack_datum!(bcx, func.to_rvalue_datum(bcx, \"func\"));\n             let data = unpack_datum!(bcx, expr::trans(bcx, data));\n             let data = unpack_datum!(bcx, data.to_rvalue_datum(bcx, \"data\"));\n+            let local_ptr = unpack_datum!(bcx, expr::trans(bcx, local_ptr));\n+            let local_ptr = local_ptr.to_rvalue_datum(bcx, \"local_ptr\");\n+            let local_ptr = unpack_datum!(bcx, local_ptr);\n \n             let dest = match dest {\n                 expr::SaveIn(d) => d,\n@@ -336,7 +339,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             };\n \n             // do the invoke\n-            bcx = try_intrinsic(bcx, func.val, data.val, dest,\n+            bcx = try_intrinsic(bcx, func.val, data.val, local_ptr.val, dest,\n                                 call_debug_location);\n \n             fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n@@ -1045,149 +1048,123 @@ fn with_overflow_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn try_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              func: ValueRef,\n                              data: ValueRef,\n+                             local_ptr: ValueRef,\n                              dest: ValueRef,\n                              dloc: DebugLoc) -> Block<'blk, 'tcx> {\n     if bcx.sess().no_landing_pads() {\n         Call(bcx, func, &[data], None, dloc);\n         Store(bcx, C_null(Type::i8p(bcx.ccx())), dest);\n         bcx\n     } else if wants_msvc_seh(bcx.sess()) {\n-        trans_msvc_try(bcx, func, data, dest, dloc)\n+        trans_msvc_try(bcx, func, data, local_ptr, dest, dloc)\n     } else {\n-        trans_gnu_try(bcx, func, data, dest, dloc)\n+        trans_gnu_try(bcx, func, data, local_ptr, dest, dloc)\n     }\n }\n \n-// MSVC's definition of the `rust_try` function. The exact implementation here\n-// is a little different than the GNU (standard) version below, not only because\n-// of the personality function but also because of the other fiddly bits about\n-// SEH. LLVM also currently requires us to structure this in a very particular\n-// way as explained below.\n+// MSVC's definition of the `rust_try` function.\n //\n-// Like with the GNU version we generate a shim wrapper\n+// This implementation uses the new exception handling instructions in LLVM\n+// which have support in LLVM for SEH on MSVC targets. Although these\n+// instructions are meant to work for all targets, as of the time of this\n+// writing, however, LLVM does not recommend the usage of these new instructions\n+// as the old ones are still more optimized.\n fn trans_msvc_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               func: ValueRef,\n                               data: ValueRef,\n+                              local_ptr: ValueRef,\n                               dest: ValueRef,\n                               dloc: DebugLoc) -> Block<'blk, 'tcx> {\n-    let llfn = get_rust_try_fn(bcx.fcx, &mut |try_fn_ty, output| {\n+    let llfn = get_rust_try_fn(bcx.fcx, &mut |bcx| {\n         let ccx = bcx.ccx();\n         let dloc = DebugLoc::None;\n-        let rust_try = declare::define_internal_rust_fn(ccx, \"__rust_try\",\n-                                                         try_fn_ty);\n-        let (fcx, block_arena);\n-        block_arena = TypedArena::new();\n-        fcx = new_fn_ctxt(ccx, rust_try, ast::DUMMY_NODE_ID, false,\n-                          output, ccx.tcx().mk_substs(Substs::trans_empty()),\n-                          None, &block_arena);\n-        let bcx = init_function(&fcx, true, output);\n-        let then = fcx.new_temp_block(\"then\");\n-        let catch = fcx.new_temp_block(\"catch\");\n-        let catch_return = fcx.new_temp_block(\"catch-return\");\n-        let catch_resume = fcx.new_temp_block(\"catch-resume\");\n-        let personality = fcx.eh_personality();\n-\n-        let eh_typeid_for = ccx.get_intrinsic(&\"llvm.eh.typeid.for\");\n-        let rust_try_filter = match bcx.tcx().lang_items.msvc_try_filter() {\n-            Some(did) => callee::trans_fn_ref(ccx, did, ExprId(0),\n-                                              bcx.fcx.param_substs).val,\n-            None => bcx.sess().bug(\"msvc_try_filter not defined\"),\n-        };\n \n-        // Type indicator for the exception being thrown, not entirely sure\n-        // what's going on here but it's what all the examples in LLVM use.\n-        let lpad_ty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)],\n-                                    false);\n+        SetPersonalityFn(bcx, bcx.fcx.eh_personality());\n \n-        llvm::SetFunctionAttribute(rust_try, llvm::Attribute::NoInline);\n-        llvm::SetFunctionAttribute(rust_try, llvm::Attribute::OptimizeNone);\n-        let func = llvm::get_param(rust_try, 0);\n-        let data = llvm::get_param(rust_try, 1);\n+        let normal = bcx.fcx.new_temp_block(\"normal\");\n+        let catchswitch = bcx.fcx.new_temp_block(\"catchswitch\");\n+        let catchpad = bcx.fcx.new_temp_block(\"catchpad\");\n+        let caught = bcx.fcx.new_temp_block(\"caught\");\n \n-        // Invoke the function, specifying our two temporary landing pads as the\n-        // ext point. After the invoke we've terminated our basic block.\n-        Invoke(bcx, func, &[data], then.llbb, catch.llbb, None, dloc);\n+        let func = llvm::get_param(bcx.fcx.llfn, 0);\n+        let data = llvm::get_param(bcx.fcx.llfn, 1);\n+        let local_ptr = llvm::get_param(bcx.fcx.llfn, 2);\n \n-        // All the magic happens in this landing pad, and this is basically the\n-        // only landing pad in rust tagged with \"catch\" to indicate that we're\n-        // catching an exception. The other catch handlers in the GNU version\n-        // below just catch *all* exceptions, but that's because most exceptions\n-        // are already filtered out by the gnu personality function.\n+        // We're generating an IR snippet that looks like:\n+        //\n+        //   declare i32 @rust_try(%func, %data, %ptr) {\n+        //      %slot = alloca i8*\n+        //      call @llvm.localescape(%slot)\n+        //      store %ptr, %slot\n+        //      invoke %func(%data) to label %normal unwind label %catchswitch\n+        //\n+        //   normal:\n+        //      ret i32 0\n         //\n-        // For MSVC we're just using a standard personality function that we\n-        // can't customize (e.g. _except_handler3 or __C_specific_handler), so\n-        // we need to do the exception filtering ourselves. This is currently\n-        // performed by the `__rust_try_filter` function. This function,\n-        // specified in the landingpad instruction, will be invoked by Windows\n-        // SEH routines and will return whether the exception in question can be\n-        // caught (aka the Rust runtime is the one that threw the exception).\n+        //   catchswitch:\n+        //      %cs = catchswitch within none [%catchpad] unwind to caller\n         //\n-        // To get this to compile (currently LLVM segfaults if it's not in this\n-        // particular structure), when the landingpad is executing we test to\n-        // make sure that the ID of the exception being thrown is indeed the one\n-        // that we were expecting. If it's not, we resume the exception, and\n-        // otherwise we return the pointer that we got Full disclosure: It's not\n-        // clear to me what this `llvm.eh.typeid` stuff is doing *other* then\n-        // just allowing LLVM to compile this file without segfaulting. I would\n-        // expect the entire landing pad to just be:\n+        //   catchpad:\n+        //      %tok = catchpad within %cs [%rust_try_filter]\n+        //      catchret from %tok to label %caught\n         //\n-        //     %vals = landingpad ...\n-        //     %ehptr = extractvalue { i8*, i32 } %vals, 0\n-        //     ret i8* %ehptr\n+        //   caught:\n+        //      ret i32 1\n+        //   }\n         //\n-        // but apparently LLVM chokes on this, so we do the more complicated\n-        // thing to placate it.\n-        let vals = LandingPad(catch, lpad_ty, personality, 1);\n-        let rust_try_filter = BitCast(catch, rust_try_filter, Type::i8p(ccx));\n-        AddClause(catch, vals, rust_try_filter);\n-        let ehptr = ExtractValue(catch, vals, 0);\n-        let sel = ExtractValue(catch, vals, 1);\n-        let filter_sel = Call(catch, eh_typeid_for, &[rust_try_filter], None,\n-                              dloc);\n-        let is_filter = ICmp(catch, llvm::IntEQ, sel, filter_sel, dloc);\n-        CondBr(catch, is_filter, catch_return.llbb, catch_resume.llbb, dloc);\n-\n-        // Our \"catch-return\" basic block is where we've determined that we\n-        // actually need to catch this exception, in which case we just return\n-        // the exception pointer.\n-        Ret(catch_return, ehptr, dloc);\n-\n-        // The \"catch-resume\" block is where we're running this landing pad but\n-        // we actually need to not catch the exception, so just resume the\n-        // exception to return.\n-        trans_unwind_resume(catch_resume, vals);\n-\n-        // On the successful branch we just return null.\n-        Ret(then, C_null(Type::i8p(ccx)), dloc);\n-\n-        return rust_try\n+        // This structure follows the basic usage of the instructions in LLVM\n+        // (see their documentation/test cases for examples), but a\n+        // perhaps-surprising part here is the usage of the `localescape`\n+        // intrinsic. This is used to allow the filter function (also generated\n+        // here) to access variables on the stack of this intrinsic. This\n+        // ability enables us to transfer information about the exception being\n+        // thrown to this point, where we're catching the exception.\n+        //\n+        // More information can be found in libstd's seh.rs implementation.\n+        let slot = Alloca(bcx, Type::i8p(ccx), \"slot\");\n+        let localescape = ccx.get_intrinsic(&\"llvm.localescape\");\n+        Call(bcx, localescape, &[slot], None, dloc);\n+        Store(bcx, local_ptr, slot);\n+        Invoke(bcx, func, &[data], normal.llbb, catchswitch.llbb, None, dloc);\n+\n+        Ret(normal, C_i32(ccx, 0), dloc);\n+\n+        let cs = CatchSwitch(catchswitch, None, None, 1);\n+        AddHandler(catchswitch, cs, catchpad.llbb);\n+\n+        let filter = generate_filter_fn(bcx.fcx, bcx.fcx.llfn);\n+        let filter = BitCast(catchpad, filter, Type::i8p(ccx));\n+        let tok = CatchPad(catchpad, cs, &[filter]);\n+        CatchRet(catchpad, tok, caught.llbb);\n+\n+        Ret(caught, C_i32(ccx, 1), dloc);\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = Call(bcx, llfn, &[func, data], None, dloc);\n+    let ret = Call(bcx, llfn, &[func, data, local_ptr], None, dloc);\n     Store(bcx, ret, dest);\n-    return bcx;\n+    return bcx\n }\n \n // Definition of the standard \"try\" function for Rust using the GNU-like model\n // of exceptions (e.g. the normal semantics of LLVM's landingpad and invoke\n // instructions).\n //\n-// This translation is a little surprising because\n-// we always call a shim function instead of inlining the call to `invoke`\n-// manually here. This is done because in LLVM we're only allowed to have one\n-// personality per function definition. The call to the `try` intrinsic is\n-// being inlined into the function calling it, and that function may already\n-// have other personality functions in play. By calling a shim we're\n-// guaranteed that our shim will have the right personality function.\n-//\n+// This translation is a little surprising because we always call a shim\n+// function instead of inlining the call to `invoke` manually here. This is done\n+// because in LLVM we're only allowed to have one personality per function\n+// definition. The call to the `try` intrinsic is being inlined into the\n+// function calling it, and that function may already have other personality\n+// functions in play. By calling a shim we're guaranteed that our shim will have\n+// the right personality function.\n fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              func: ValueRef,\n                              data: ValueRef,\n+                             local_ptr: ValueRef,\n                              dest: ValueRef,\n                              dloc: DebugLoc) -> Block<'blk, 'tcx> {\n-    let llfn = get_rust_try_fn(bcx.fcx, &mut |try_fn_ty, output| {\n+    let llfn = get_rust_try_fn(bcx.fcx, &mut |bcx| {\n         let ccx = bcx.ccx();\n         let dloc = DebugLoc::None;\n \n@@ -1197,60 +1174,82 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         //      invoke %func(%args...) normal %normal unwind %catch\n         //\n         //   normal:\n-        //      ret null\n+        //      ret 0\n         //\n         //   catch:\n         //      (ptr, _) = landingpad\n-        //      ret ptr\n+        //      store ptr, %local_ptr\n+        //      ret 1\n+        //\n+        // Note that the `local_ptr` data passed into the `try` intrinsic is\n+        // expected to be `*mut *mut u8` for this to actually work, but that's\n+        // managed by the standard library.\n \n-        let rust_try = declare::define_internal_rust_fn(ccx, \"__rust_try\", try_fn_ty);\n-        attributes::emit_uwtable(rust_try, true);\n+        attributes::emit_uwtable(bcx.fcx.llfn, true);\n         let catch_pers = match bcx.tcx().lang_items.eh_personality_catch() {\n             Some(did) => callee::trans_fn_ref(ccx, did, ExprId(0),\n                                               bcx.fcx.param_substs).val,\n             None => bcx.tcx().sess.bug(\"eh_personality_catch not defined\"),\n         };\n \n-        let (fcx, block_arena);\n-        block_arena = TypedArena::new();\n-        fcx = new_fn_ctxt(ccx, rust_try, ast::DUMMY_NODE_ID, false,\n-                          output, ccx.tcx().mk_substs(Substs::trans_empty()),\n-                          None, &block_arena);\n-        let bcx = init_function(&fcx, true, output);\n         let then = bcx.fcx.new_temp_block(\"then\");\n         let catch = bcx.fcx.new_temp_block(\"catch\");\n \n-        let func = llvm::get_param(rust_try, 0);\n-        let data = llvm::get_param(rust_try, 1);\n+        let func = llvm::get_param(bcx.fcx.llfn, 0);\n+        let data = llvm::get_param(bcx.fcx.llfn, 1);\n+        let local_ptr = llvm::get_param(bcx.fcx.llfn, 2);\n         Invoke(bcx, func, &[data], then.llbb, catch.llbb, None, dloc);\n-        Ret(then, C_null(Type::i8p(ccx)), dloc);\n+        Ret(then, C_i32(ccx, 0), dloc);\n \n         // Type indicator for the exception being thrown.\n-        // The first value in this tuple is a pointer to the exception object being thrown.\n-        // The second value is a \"selector\" indicating which of the landing pad clauses\n-        // the exception's type had been matched to.  rust_try ignores the selector.\n+        //\n+        // The first value in this tuple is a pointer to the exception object\n+        // being thrown.  The second value is a \"selector\" indicating which of\n+        // the landing pad clauses the exception's type had been matched to.\n+        // rust_try ignores the selector.\n         let lpad_ty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)],\n                                     false);\n         let vals = LandingPad(catch, lpad_ty, catch_pers, 1);\n         AddClause(catch, vals, C_null(Type::i8p(ccx)));\n         let ptr = ExtractValue(catch, vals, 0);\n-        Ret(catch, ptr, dloc);\n-        fcx.cleanup();\n-\n-        return rust_try\n+        Store(catch, ptr, BitCast(catch, local_ptr, Type::i8p(ccx).ptr_to()));\n+        Ret(catch, C_i32(ccx, 1), dloc);\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = Call(bcx, llfn, &[func, data], None, dloc);\n+    let ret = Call(bcx, llfn, &[func, data, local_ptr], None, dloc);\n     Store(bcx, ret, dest);\n     return bcx;\n }\n \n-// Helper to generate the `Ty` associated with `rust_try`\n+// Helper function to give a Block to a closure to translate a shim function.\n+// This is currently primarily used for the `try` intrinsic functions above.\n+fn gen_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n+                    name: &str,\n+                    ty: Ty<'tcx>,\n+                    output: ty::FnOutput<'tcx>,\n+                    trans: &mut for<'b> FnMut(Block<'b, 'tcx>))\n+                    -> ValueRef {\n+    let ccx = fcx.ccx;\n+    let llfn = declare::define_internal_rust_fn(ccx, name, ty);\n+    let (fcx, block_arena);\n+    block_arena = TypedArena::new();\n+    fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false,\n+                      output, ccx.tcx().mk_substs(Substs::trans_empty()),\n+                      None, &block_arena);\n+    let bcx = init_function(&fcx, true, output);\n+    trans(bcx);\n+    fcx.cleanup();\n+    return llfn\n+}\n+\n+// Helper function used to get a handle to the `__rust_try` function used to\n+// catch exceptions.\n+//\n+// This function is only generated once and is then cached.\n fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n-                             f: &mut FnMut(Ty<'tcx>,\n-                                           ty::FnOutput<'tcx>) -> ValueRef)\n+                             trans: &mut for<'b> FnMut(Block<'b, 'tcx>))\n                              -> ValueRef {\n     let ccx = fcx.ccx;\n     if let Some(llfn) = *ccx.rust_try_fn().borrow() {\n@@ -1270,21 +1269,125 @@ fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         }),\n     });\n     let fn_ty = tcx.mk_fn(None, fn_ty);\n-    let output = ty::FnOutput::FnConverging(i8p);\n+    let output = ty::FnOutput::FnConverging(tcx.types.i32);\n     let try_fn_ty  = tcx.mk_bare_fn(ty::BareFnTy {\n         unsafety: hir::Unsafety::Unsafe,\n         abi: abi::Rust,\n         sig: ty::Binder(ty::FnSig {\n-            inputs: vec![fn_ty, i8p],\n+            inputs: vec![fn_ty, i8p, i8p],\n             output: output,\n             variadic: false,\n         }),\n     });\n-    let rust_try = f(tcx.mk_fn(None, try_fn_ty), output);\n+    let rust_try = gen_fn(fcx, \"__rust_try\", tcx.mk_fn(None, try_fn_ty), output,\n+                          trans);\n     *ccx.rust_try_fn().borrow_mut() = Some(rust_try);\n     return rust_try\n }\n \n+// For MSVC-style exceptions (SEH), the compiler generates a filter function\n+// which is used to determine whether an exception is being caught (e.g. if it's\n+// a Rust exception or some other).\n+//\n+// This function is used to generate said filter function. The shim generated\n+// here is actually just a thin wrapper to call the real implementation in the\n+// standard library itself. For reasons as to why, see seh.rs in the standard\n+// library.\n+fn generate_filter_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n+                                rust_try_fn: ValueRef)\n+                                -> ValueRef {\n+    let ccx = fcx.ccx;\n+    let tcx = ccx.tcx();\n+    let dloc = DebugLoc::None;\n+\n+    let rust_try_filter = match ccx.tcx().lang_items.msvc_try_filter() {\n+        Some(did) => callee::trans_fn_ref(ccx, did, ExprId(0),\n+                                          fcx.param_substs).val,\n+        None => ccx.sess().bug(\"msvc_try_filter not defined\"),\n+    };\n+\n+    let output = ty::FnOutput::FnConverging(tcx.types.i32);\n+    let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n+\n+    let frameaddress = ccx.get_intrinsic(&\"llvm.frameaddress\");\n+    let recoverfp = ccx.get_intrinsic(&\"llvm.x86.seh.recoverfp\");\n+    let localrecover = ccx.get_intrinsic(&\"llvm.localrecover\");\n+\n+    // On all platforms, once we have the EXCEPTION_POINTERS handle as well as\n+    // the base pointer, we follow the standard layout of:\n+    //\n+    //      block:\n+    //          %parentfp = call i8* llvm.x86.seh.recoverfp(@rust_try_fn, %bp)\n+    //          %arg = call i8* llvm.localrecover(@rust_try_fn, %parentfp, 0)\n+    //          %ret = call i32 @the_real_filter_function(%ehptrs, %arg)\n+    //          ret i32 %ret\n+    //\n+    // The recoverfp intrinsic is used to recover the frame frame pointer of the\n+    // `rust_try_fn` function, which is then in turn passed to the\n+    // `localrecover` intrinsic (pairing with the `localescape` intrinsic\n+    // mentioned above). Putting all this together means that we now have a\n+    // handle to the arguments passed into the `try` function, allowing writing\n+    // to the stack over there.\n+    //\n+    // For more info, see seh.rs in the standard library.\n+    let do_trans = |bcx: Block, ehptrs, base_pointer| {\n+        let rust_try_fn = BitCast(bcx, rust_try_fn, Type::i8p(ccx));\n+        let parentfp = Call(bcx, recoverfp, &[rust_try_fn, base_pointer],\n+                            None, dloc);\n+        let arg = Call(bcx, localrecover,\n+                       &[rust_try_fn, parentfp, C_i32(ccx, 0)], None, dloc);\n+        let ret = Call(bcx, rust_try_filter, &[ehptrs, arg], None, dloc);\n+        Ret(bcx, ret, dloc);\n+    };\n+\n+    if ccx.tcx().sess.target.target.arch == \"x86\" {\n+        // On x86 the filter function doesn't actually receive any arguments.\n+        // Instead the %ebp register contains some contextual information.\n+        //\n+        // Unfortunately I don't know of any great documentation as to what's\n+        // going on here, all I can say is that there's a few tests cases in\n+        // LLVM's test suite which follow this pattern of instructions, so we\n+        // just do the same.\n+        let filter_fn_ty = tcx.mk_bare_fn(ty::BareFnTy {\n+            unsafety: hir::Unsafety::Unsafe,\n+            abi: abi::Rust,\n+            sig: ty::Binder(ty::FnSig {\n+                inputs: vec![],\n+                output: output,\n+                variadic: false,\n+            }),\n+        });\n+        let filter_fn_ty = tcx.mk_fn(None, filter_fn_ty);\n+        gen_fn(fcx, \"__rustc_try_filter\", filter_fn_ty, output, &mut |bcx| {\n+            let ebp = Call(bcx, frameaddress, &[C_i32(ccx, 1)], None, dloc);\n+            let exn = InBoundsGEP(bcx, ebp, &[C_i32(ccx, -20)]);\n+            let exn = Load(bcx, BitCast(bcx, exn, Type::i8p(ccx).ptr_to()));\n+            do_trans(bcx, exn, ebp);\n+        })\n+    } else if ccx.tcx().sess.target.target.arch == \"x86_64\" {\n+        // Conveniently on x86_64 the EXCEPTION_POINTERS handle and base pointer\n+        // are passed in as arguments to the filter function, so we just pass\n+        // those along.\n+        let filter_fn_ty = tcx.mk_bare_fn(ty::BareFnTy {\n+            unsafety: hir::Unsafety::Unsafe,\n+            abi: abi::Rust,\n+            sig: ty::Binder(ty::FnSig {\n+                inputs: vec![i8p, i8p],\n+                output: output,\n+                variadic: false,\n+            }),\n+        });\n+        let filter_fn_ty = tcx.mk_fn(None, filter_fn_ty);\n+        gen_fn(fcx, \"__rustc_try_filter\", filter_fn_ty, output, &mut |bcx| {\n+            let exn = llvm::get_param(bcx.fcx.llfn, 0);\n+            let rbp = llvm::get_param(bcx.fcx.llfn, 1);\n+            do_trans(bcx, exn, rbp);\n+        })\n+    } else {\n+        panic!(\"unknown target to generate a filter function\")\n+    }\n+}\n+\n fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n     span_err!(a, b, E0511, \"{}\", c);\n }"}, {"sha": "5651710aa8091eded3ed1741841945e472505305", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=3e9589c0f43af69544b042f50b886005613540f2", "patch": "@@ -16,7 +16,7 @@ use trans::adt;\n use trans::attributes;\n use trans::base;\n use trans::build;\n-use trans::common::{self, Block};\n+use trans::common::{self, Block, LandingPad};\n use trans::debuginfo::DebugLoc;\n use trans::foreign;\n use trans::type_of;\n@@ -162,7 +162,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         let cleanup = self.bcx(targets.1);\n                         let landingpad = self.make_landing_pad(cleanup);\n                         let (target, postinvoke) = if must_copy_dest {\n-                            (bcx.fcx.new_block(false, \"\", None), Some(self.bcx(targets.0)))\n+                            (bcx.fcx.new_block(\"\", None),\n+                             Some(self.bcx(targets.0)))\n                         } else {\n                             (self.bcx(targets.0), None)\n                         };\n@@ -267,7 +268,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     }\n \n     fn make_landing_pad(&mut self, cleanup: Block<'bcx, 'tcx>) -> Block<'bcx, 'tcx> {\n-        let bcx = cleanup.fcx.new_block(true, \"cleanup\", None);\n+        let bcx = cleanup.fcx.new_block(\"cleanup\", None);\n+        // FIXME(#30941) this doesn't handle msvc-style exceptions\n+        *bcx.lpad.borrow_mut() = Some(LandingPad::gnu());\n         let ccx = bcx.ccx();\n         let llpersonality = bcx.fcx.eh_personality();\n         let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n@@ -283,7 +286,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         match self.unreachable_block {\n             Some(b) => b,\n             None => {\n-                let bl = self.fcx.new_block(false, \"unreachable\", None);\n+                let bl = self.fcx.new_block(\"unreachable\", None);\n                 build::Unreachable(bl);\n                 self.unreachable_block = Some(bl);\n                 bl"}, {"sha": "cfe48af35ca467942f68ee5f63efa1134c0d88af", "filename": "src/librustc_trans/trans/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs?ref=3e9589c0f43af69544b042f50b886005613540f2", "patch": "@@ -14,7 +14,7 @@ use rustc::mir::repr as mir;\n use rustc::mir::tcx::LvalueTy;\n use trans::base;\n use trans::build;\n-use trans::common::{self, Block};\n+use trans::common::{self, Block, LandingPad};\n use trans::debuginfo::DebugLoc;\n use trans::expr;\n use trans::type_of;\n@@ -114,8 +114,12 @@ pub fn trans_mir<'bcx, 'tcx>(bcx: Block<'bcx, 'tcx>) {\n     let block_bcxs: Vec<Block<'bcx,'tcx>> =\n         mir_blocks.iter()\n                   .map(|&bb|{\n-                      let is_cleanup = mir.basic_block_data(bb).is_cleanup;\n-                      fcx.new_block(is_cleanup, &format!(\"{:?}\", bb), None)\n+                      let bcx = fcx.new_block(&format!(\"{:?}\", bb), None);\n+                      // FIXME(#30941) this doesn't handle msvc-style exceptions\n+                      if mir.basic_block_data(bb).is_cleanup {\n+                          *bcx.lpad.borrow_mut() = Some(LandingPad::gnu())\n+                      }\n+                      bcx\n                   })\n                   .collect();\n "}, {"sha": "e280eff34c89474d58cc37d2a9b45d11934c892b", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=3e9589c0f43af69544b042f50b886005613540f2", "patch": "@@ -220,7 +220,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         let (llval, ll_t_in, signed) = if let CastTy::Int(IntTy::CEnum) = r_t_in {\n                             let repr = adt::represent_type(bcx.ccx(), operand.ty);\n                             let llval = operand.immediate();\n-                            let discr = adt::trans_get_discr(bcx, &*repr, llval, None);\n+                            let discr = adt::trans_get_discr(bcx, &*repr, llval,\n+                                                             None, true);\n                             (discr, common::val_ty(discr), adt::is_discr_signed(&*repr))\n                         } else {\n                             (operand.immediate(), ll_t_in, operand.ty.is_signed())"}, {"sha": "61d468c59ce83e768acbeceb50e6d803cc75ad96", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=3e9589c0f43af69544b042f50b886005613540f2", "patch": "@@ -293,7 +293,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n                     }),\n                 };\n                 let fn_ty = tcx.mk_bare_fn(fn_ty);\n-                (0, vec![tcx.mk_fn(None, fn_ty), mut_u8], mut_u8)\n+                (0, vec![tcx.mk_fn(None, fn_ty), mut_u8, mut_u8], tcx.types.i32)\n             }\n \n             ref other => {"}, {"sha": "12cd07a4f4f181ab615488802403e6ba3d52da34", "filename": "src/libstd/sys/common/unwind/gcc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fgcc.rs?ref=3e9589c0f43af69544b042f50b886005613540f2", "patch": "@@ -41,6 +41,11 @@ pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! {\n     }\n }\n \n+#[cfg(not(stage0))]\n+pub fn payload() -> *mut u8 {\n+    0 as *mut u8\n+}\n+\n pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send + 'static> {\n     let my_ep = ptr as *mut Exception;\n     let cause = (*my_ep).cause.take();"}, {"sha": "d9641e63760e5c102c4ec68a3735ebae33cbd3e9", "filename": "src/libstd/sys/common/unwind/mod.rs", "status": "modified", "additions": 47, "deletions": 38, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fmod.rs?ref=3e9589c0f43af69544b042f50b886005613540f2", "patch": "@@ -83,13 +83,13 @@ use sys_common::mutex::Mutex;\n // implementations. One goes through SEH on Windows and the other goes through\n // libgcc via the libunwind-like API.\n \n-// i686-pc-windows-msvc\n-#[cfg(all(windows, target_arch = \"x86\", target_env = \"msvc\"))]\n+// *-pc-windows-msvc\n+#[cfg(target_env = \"msvc\")]\n #[path = \"seh.rs\"] #[doc(hidden)]\n pub mod imp;\n \n-// x86_64-pc-windows-*\n-#[cfg(all(windows, target_arch = \"x86_64\"))]\n+// x86_64-pc-windows-gnu\n+#[cfg(all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))]\n #[path = \"seh64_gnu.rs\"] #[doc(hidden)]\n pub mod imp;\n \n@@ -122,45 +122,54 @@ pub unsafe fn try<F: FnOnce()>(f: F) -> Result<(), Box<Any + Send>> {\n     let mut f = Some(f);\n     return inner_try(try_fn::<F>, &mut f as *mut _ as *mut u8);\n \n-    // If an inner function were not used here, then this generic function `try`\n-    // uses the native symbol `rust_try`, for which the code is statically\n-    // linked into the standard library. This means that the DLL for the\n-    // standard library must have `rust_try` as an exposed symbol that\n-    // downstream crates can link against (because monomorphizations of `try` in\n-    // downstream crates will have a reference to the `rust_try` symbol).\n-    //\n-    // On MSVC this requires the symbol `rust_try` to be tagged with\n-    // `dllexport`, but it's easier to not have conditional `src/rt/rust_try.ll`\n-    // files and instead just have this non-generic shim the compiler can take\n-    // care of exposing correctly.\n-    unsafe fn inner_try(f: fn(*mut u8), data: *mut u8)\n-                        -> Result<(), Box<Any + Send>> {\n-        PANIC_COUNT.with(|s| {\n-            let prev = s.get();\n-            s.set(0);\n-            let ep = intrinsics::try(f, data);\n-            s.set(prev);\n-            if ep.is_null() {\n-                Ok(())\n-            } else {\n-                Err(imp::cleanup(ep))\n-            }\n-        })\n-    }\n-\n     fn try_fn<F: FnOnce()>(opt_closure: *mut u8) {\n         let opt_closure = opt_closure as *mut Option<F>;\n         unsafe { (*opt_closure).take().unwrap()(); }\n     }\n+}\n \n-    extern {\n-        // Rust's try-catch\n-        // When f(...) returns normally, the return value is null.\n-        // When f(...) throws, the return value is a pointer to the caught\n-        // exception object.\n-        fn rust_try(f: extern fn(*mut u8),\n-                    data: *mut u8) -> *mut u8;\n-    }\n+#[cfg(not(stage0))]\n+unsafe fn inner_try(f: fn(*mut u8), data: *mut u8)\n+                    -> Result<(), Box<Any + Send>> {\n+    PANIC_COUNT.with(|s| {\n+        let prev = s.get();\n+        s.set(0);\n+\n+        // The \"payload\" here is a platform-specific region of memory which is\n+        // used to transmit information about the exception being thrown from\n+        // the point-of-throw back to this location.\n+        //\n+        // A pointer to this data is passed to the `try` intrinsic itself,\n+        // allowing this function, the `try` intrinsic, imp::payload(), and\n+        // imp::cleanup() to all work in concert to transmit this information.\n+        //\n+        // More information about what this pointer actually is can be found in\n+        // each implementation as well as browsing the compiler source itself.\n+        let mut payload = imp::payload();\n+        let r = intrinsics::try(f, data, &mut payload as *mut _ as *mut _);\n+        s.set(prev);\n+        if r == 0 {\n+            Ok(())\n+        } else {\n+            Err(imp::cleanup(payload))\n+        }\n+    })\n+}\n+\n+#[cfg(stage0)]\n+unsafe fn inner_try(f: fn(*mut u8), data: *mut u8)\n+                    -> Result<(), Box<Any + Send>> {\n+    PANIC_COUNT.with(|s| {\n+        let prev = s.get();\n+        s.set(0);\n+        let ep = intrinsics::try(f, data);\n+        s.set(prev);\n+        if ep.is_null() {\n+            Ok(())\n+        } else {\n+            Err(imp::cleanup(ep))\n+        }\n+    })\n }\n \n /// Determines whether the current thread is unwinding because of panic."}, {"sha": "f8d3a92b3b65ba48c8f887d5083f2a5c77f9829d", "filename": "src/libstd/sys/common/unwind/seh.rs", "status": "modified", "additions": 142, "deletions": 76, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh.rs?ref=3e9589c0f43af69544b042f50b886005613540f2", "patch": "@@ -8,109 +8,175 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Win64 SEH (see http://msdn.microsoft.com/en-us/library/1eyas8tf.aspx)\n+//! Windows SEH\n //!\n //! On Windows (currently only on MSVC), the default exception handling\n //! mechanism is Structured Exception Handling (SEH). This is quite different\n //! than Dwarf-based exception handling (e.g. what other unix platforms use) in\n //! terms of compiler internals, so LLVM is required to have a good deal of\n-//! extra support for SEH. Currently this support is somewhat lacking, so what's\n-//! here is the bare bones of SEH support.\n+//! extra support for SEH.\n //!\n //! In a nutshell, what happens here is:\n //!\n //! 1. The `panic` function calls the standard Windows function `RaiseException`\n //!    with a Rust-specific code, triggering the unwinding process.\n-//! 2. All landing pads generated by the compiler (just \"cleanup\" landing pads)\n-//!    use the personality function `__C_specific_handler`, a function in the\n-//!    CRT, and the unwinding code in Windows will use this personality function\n-//!    to execute all cleanup code on the stack.\n-//! 3. Eventually the \"catch\" code in `rust_try` (located in\n-//!    src/rt/rust_try_msvc_64.ll) is executed, which will ensure that the\n-//!    exception being caught is indeed a Rust exception, returning control back\n-//!    into Rust.\n+//! 2. All landing pads generated by the compiler use the personality function\n+//!    `__C_specific_handler` on 64-bit and `__except_handler3` on 32-bit,\n+//!    functions in the CRT, and the unwinding code in Windows will use this\n+//!    personality function to execute all cleanup code on the stack.\n+//! 3. All compiler-generated calls to `invoke` have a landing pad set as a\n+//!    `cleanuppad` LLVM instruction, which indicates the start of the cleanup\n+//!    routine. The personality (in step 2, defined in the CRT) is responsible\n+//!    for running the cleanup routines.\n+//! 4. Eventually the \"catch\" code in the `try` intrinsic (generated by the\n+//!    compiler) is executed, which will ensure that the exception being caught\n+//!    is indeed a Rust exception, indicating that control should come back to\n+//!    Rust. This is done via a `catchswitch` plus a `catchpad` instruction in\n+//!    LLVM IR terms, finally returning normal control to the program with a\n+//!    `catchret` instruction. The `try` intrinsic uses a filter function to\n+//!    detect what kind of exception is being thrown, and this detection is\n+//!    implemented as the msvc_try_filter language item below.\n //!\n //! Some specific differences from the gcc-based exception handling are:\n //!\n //! * Rust has no custom personality function, it is instead *always*\n-//!   __C_specific_handler, so the filtering is done in a C++-like manner\n-//!   instead of in the personality function itself. Note that the specific\n-//!   syntax for this (found in the rust_try_msvc_64.ll) is taken from an LLVM\n-//!   test case for SEH.\n+//!   __C_specific_handler or __except_handler3, so the filtering is done in a\n+//!   C++-like manner instead of in the personality function itself. Note that\n+//!   the precise codegen for this was lifted from an LLVM test case for SEH\n+//!   (this is the `__rust_try_filter` function below).\n //! * We've got some data to transmit across the unwinding boundary,\n-//!   specifically a `Box<Any + Send + 'static>`. In Dwarf-based unwinding this\n-//!   data is part of the payload of the exception, but I have not currently\n-//!   figured out how to do this with LLVM's bindings. Judging by some comments\n-//!   in the LLVM test cases this may not even be possible currently with LLVM,\n-//!   so this is just abandoned entirely. Instead the data is stored in a\n-//!   thread-local in `panic` and retrieved during `cleanup`.\n+//!   specifically a `Box<Any + Send + 'static>`. Like with Dwarf exceptions\n+//!   these two pointers are stored as a payload in the exception itself. On\n+//!   MSVC, however, there's no need for an extra allocation because the call\n+//!   stack is preserved while filter functions are being executed. This means\n+//!   that the pointers are passed directly to `RaiseException` which are then\n+//!   recovered in the filter function to be written to the stack frame of the\n+//!   `try` intrinsic.\n //!\n-//! So given all that, the bindings here are pretty small,\n+//! [win64]: http://msdn.microsoft.com/en-us/library/1eyas8tf.aspx\n+//! [llvm]: http://llvm.org/docs/ExceptionHandling.html#background-on-windows-exceptions\n \n-#![allow(bad_style)]\n+use sys::c;\n \n-use prelude::v1::*;\n+// A code which indicates panics that originate from Rust. Note that some of the\n+// upper bits are used by the system so we just set them to 0 and ignore them.\n+//                           0x 0 R S T\n+const RUST_PANIC: c::DWORD = 0x00525354;\n \n-use any::Any;\n-use ptr;\n-use sys_common::thread_local::StaticKey;\n-use sys::c;\n+pub use self::imp::*;\n+\n+#[cfg(stage0)]\n+mod imp {\n+    use prelude::v1::*;\n+    use any::Any;\n \n-//                           0x R U S T\n-const RUST_PANIC: c::DWORD = 0x52555354;\n-static PANIC_DATA: StaticKey = StaticKey::new(None);\n-\n-pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! {\n-    // See module docs above for an explanation of why `data` is stored in a\n-    // thread local instead of being passed as an argument to the\n-    // `RaiseException` function (which can in theory carry along arbitrary\n-    // data).\n-    let exception = Box::new(data);\n-    rtassert!(PANIC_DATA.get().is_null());\n-    PANIC_DATA.set(Box::into_raw(exception) as *mut u8);\n-\n-    c::RaiseException(RUST_PANIC, 0, 0, ptr::null());\n-    rtabort!(\"could not unwind stack\");\n+    pub unsafe fn panic(_data: Box<Any + Send + 'static>) -> ! {\n+        rtabort!(\"cannot unwind SEH in stage0\")\n+    }\n+\n+    pub unsafe fn cleanup(_ptr: *mut u8) -> Box<Any + Send + 'static> {\n+        rtabort!(\"can't cleanup SEH in stage0\")\n+    }\n+\n+    #[lang = \"msvc_try_filter\"]\n+    #[linkage = \"external\"]\n+    unsafe extern fn __rust_try_filter() -> i32 {\n+        0\n+    }\n+\n+    #[lang = \"eh_unwind_resume\"]\n+    #[unwind]\n+    unsafe extern fn rust_eh_unwind_resume(_ptr: *mut u8) -> ! {\n+        rtabort!(\"can't resume unwind SEH in stage0\")\n+    }\n+    #[lang = \"eh_personality_catch\"]\n+    unsafe extern fn rust_eh_personality_catch() {}\n }\n \n-pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send + 'static> {\n-    // The `ptr` here actually corresponds to the code of the exception, and our\n-    // real data is stored in our thread local.\n-    rtassert!(ptr as c::DWORD == RUST_PANIC);\n+#[cfg(not(stage0))]\n+mod imp {\n+    use prelude::v1::*;\n+\n+    use any::Any;\n+    use mem;\n+    use raw;\n+    use super::RUST_PANIC;\n+    use sys::c;\n \n-    let data = PANIC_DATA.get() as *mut Box<Any + Send + 'static>;\n-    PANIC_DATA.set(ptr::null_mut());\n-    rtassert!(!data.is_null());\n+    pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! {\n+        // As mentioned above, the call stack here is preserved while the filter\n+        // functions are running, so it's ok to pass stack-local arrays into\n+        // `RaiseException`.\n+        //\n+        // The two pointers of the `data` trait object are written to the stack,\n+        // passed to `RaiseException`, and they're later extracted by the filter\n+        // function below in the \"custom exception information\" section of the\n+        // `EXCEPTION_RECORD` type.\n+        let ptrs = mem::transmute::<_, raw::TraitObject>(data);\n+        let ptrs = [ptrs.data, ptrs.vtable];\n+        c::RaiseException(RUST_PANIC, 0, 2, ptrs.as_ptr() as *mut _);\n+        rtabort!(\"could not unwind stack\");\n+    }\n+\n+    pub fn payload() -> [usize; 2] {\n+        [0; 2]\n+    }\n \n-    *Box::from_raw(data)\n+    pub unsafe fn cleanup(payload: [usize; 2]) -> Box<Any + Send + 'static> {\n+        mem::transmute(raw::TraitObject {\n+            data: payload[0] as *mut _,\n+            vtable: payload[1] as *mut _,\n+        })\n+    }\n+\n+    // This is quite a special function, and it's not literally passed in as the\n+    // filter function for the `catchpad` of the `try` intrinsic. The compiler\n+    // actually generates its own filter function wrapper which will delegate to\n+    // this for the actual execution logic for whether the exception should be\n+    // caught. The reasons for this are:\n+    //\n+    // * Each architecture has a slightly different ABI for the filter function\n+    //   here. For example on x86 there are no arguments but on x86_64 there are\n+    //   two.\n+    // * This function needs access to the stack frame of the `try` intrinsic\n+    //   which is using this filter as a catch pad. This is because the payload\n+    //   of this exception, `Box<Any>`, needs to be transmitted to that\n+    //   location.\n+    //\n+    // Both of these differences end up using a ton of weird llvm-specific\n+    // intrinsics, so it's actually pretty difficult to express the entire\n+    // filter function in Rust itself. As a compromise, the compiler takes care\n+    // of all the weird LLVM-specific and platform-specific stuff, getting to\n+    // the point where this function makes the actual decision about what to\n+    // catch given two parameters.\n+    //\n+    // The first parameter is `*mut EXCEPTION_POINTERS` which is some contextual\n+    // information about the exception being filtered, and the second pointer is\n+    // `*mut *mut [usize; 2]` (the payload here). This value points directly\n+    // into the stack frame of the `try` intrinsic itself, and we use it to copy\n+    // information from the exception onto the stack.\n+    #[lang = \"msvc_try_filter\"]\n+    #[cfg(not(test))]\n+    unsafe extern fn __rust_try_filter(eh_ptrs: *mut u8,\n+                                       payload: *mut u8) -> i32 {\n+        let eh_ptrs = eh_ptrs as *mut c::EXCEPTION_POINTERS;\n+        let payload = payload as *mut *mut [usize; 2];\n+        let record = &*(*eh_ptrs).ExceptionRecord;\n+        if record.ExceptionCode != RUST_PANIC {\n+            return 0\n+        }\n+        (**payload)[0] = record.ExceptionInformation[0] as usize;\n+        (**payload)[1] = record.ExceptionInformation[1] as usize;\n+        return 1\n+    }\n }\n \n-// This is required by the compiler to exist (e.g. it's a lang item), but it's\n-// never actually called by the compiler because __C_specific_handler is the\n-// personality function that is always used. Hence this is just an aborting\n-// stub.\n+// This is required by the compiler to exist (e.g. it's a lang item), but\n+// it's never actually called by the compiler because __C_specific_handler\n+// or _except_handler3 is the personality function that is always used.\n+// Hence this is just an aborting stub.\n #[lang = \"eh_personality\"]\n+#[cfg(not(test))]\n fn rust_eh_personality() {\n     unsafe { ::intrinsics::abort() }\n }\n-\n-// This is a function referenced from `rust_try_msvc_64.ll` which is used to\n-// filter the exceptions being caught by that function.\n-//\n-// In theory local variables can be accessed through the `rbp` parameter of this\n-// function, but a comment in an LLVM test case indicates that this is not\n-// implemented in LLVM, so this is just an idempotent function which doesn't\n-// ferry along any other information.\n-//\n-// This function just takes a look at the current EXCEPTION_RECORD being thrown\n-// to ensure that it's code is RUST_PANIC, which was set by the call to\n-// `RaiseException` above in the `panic` function.\n-#[lang = \"msvc_try_filter\"]\n-#[linkage = \"external\"]\n-#[allow(private_no_mangle_fns)]\n-extern fn __rust_try_filter(eh_ptrs: *mut c::EXCEPTION_POINTERS,\n-                            _rbp: *mut u8) -> i32 {\n-    unsafe {\n-        ((*(*eh_ptrs).ExceptionRecord).ExceptionCode == RUST_PANIC) as i32\n-    }\n-}"}, {"sha": "8afef081673d000fa9275f3ef6da803a0bd6b804", "filename": "src/libstd/sys/common/unwind/seh64_gnu.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e9589c0f43af69544b042f50b886005613540f2/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh64_gnu.rs?ref=3e9589c0f43af69544b042f50b886005613540f2", "patch": "@@ -50,6 +50,11 @@ pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! {\n     rtabort!(\"could not unwind stack\");\n }\n \n+#[cfg(not(stage0))]\n+pub fn payload() -> *mut u8 {\n+    0 as *mut u8\n+}\n+\n pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send + 'static> {\n     let panic_ctx = Box::from_raw(ptr as *mut PanicData);\n     return panic_ctx.data;"}, {"sha": "0c18051dac755129c0a050e0852bf82cc062b41d", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/3e9589c0f43af69544b042f50b886005613540f2/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3e9589c0f43af69544b042f50b886005613540f2/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=3e9589c0f43af69544b042f50b886005613540f2", "patch": "@@ -987,3 +987,181 @@ LLVMRustBuildLandingPad(LLVMBuilderRef Builder,\n                         LLVMValueRef F) {\n     return LLVMBuildLandingPad(Builder, Ty, PersFn, NumClauses, Name);\n }\n+\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildCleanupPad(LLVMBuilderRef Builder,\n+                        LLVMValueRef ParentPad,\n+                        unsigned ArgCnt,\n+                        LLVMValueRef *LLArgs,\n+                        const char *Name) {\n+#if LLVM_VERSION_MINOR >= 8\n+    Value **Args = unwrap(LLArgs);\n+    if (ParentPad == NULL) {\n+        Type *Ty = Type::getTokenTy(unwrap(Builder)->getContext());\n+        ParentPad = wrap(Constant::getNullValue(Ty));\n+    }\n+    return wrap(unwrap(Builder)->CreateCleanupPad(unwrap(ParentPad),\n+                                                  ArrayRef<Value*>(Args, ArgCnt),\n+                                                  Name));\n+#else\n+    return NULL;\n+#endif\n+}\n+\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildCleanupRet(LLVMBuilderRef Builder,\n+                        LLVMValueRef CleanupPad,\n+                        LLVMBasicBlockRef UnwindBB) {\n+#if LLVM_VERSION_MINOR >= 8\n+    CleanupPadInst *Inst = cast<CleanupPadInst>(unwrap(CleanupPad));\n+    return wrap(unwrap(Builder)->CreateCleanupRet(Inst, unwrap(UnwindBB)));\n+#else\n+    return NULL;\n+#endif\n+}\n+\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildCatchPad(LLVMBuilderRef Builder,\n+                      LLVMValueRef ParentPad,\n+                      unsigned ArgCnt,\n+                      LLVMValueRef *LLArgs,\n+                      const char *Name) {\n+#if LLVM_VERSION_MINOR >= 8\n+    Value **Args = unwrap(LLArgs);\n+    return wrap(unwrap(Builder)->CreateCatchPad(unwrap(ParentPad),\n+                                                ArrayRef<Value*>(Args, ArgCnt),\n+                                                Name));\n+#else\n+    return NULL;\n+#endif\n+}\n+\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildCatchRet(LLVMBuilderRef Builder,\n+                      LLVMValueRef Pad,\n+                      LLVMBasicBlockRef BB) {\n+#if LLVM_VERSION_MINOR >= 8\n+    return wrap(unwrap(Builder)->CreateCatchRet(cast<CatchPadInst>(unwrap(Pad)),\n+                                                unwrap(BB)));\n+#else\n+    return NULL;\n+#endif\n+}\n+\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildCatchSwitch(LLVMBuilderRef Builder,\n+                         LLVMValueRef ParentPad,\n+                         LLVMBasicBlockRef BB,\n+                         unsigned NumHandlers,\n+                         const char *Name) {\n+#if LLVM_VERSION_MINOR >= 8\n+    if (ParentPad == NULL) {\n+        Type *Ty = Type::getTokenTy(unwrap(Builder)->getContext());\n+        ParentPad = wrap(Constant::getNullValue(Ty));\n+    }\n+    return wrap(unwrap(Builder)->CreateCatchSwitch(unwrap(ParentPad),\n+                                                   unwrap(BB),\n+                                                   NumHandlers,\n+                                                   Name));\n+#else\n+    return NULL;\n+#endif\n+}\n+\n+extern \"C\" void\n+LLVMRustAddHandler(LLVMValueRef CatchSwitchRef,\n+                   LLVMBasicBlockRef Handler) {\n+#if LLVM_VERSION_MINOR >= 8\n+    Value *CatchSwitch = unwrap(CatchSwitchRef);\n+    cast<CatchSwitchInst>(CatchSwitch)->addHandler(unwrap(Handler));\n+#endif\n+}\n+\n+extern \"C\" void\n+LLVMRustSetPersonalityFn(LLVMBuilderRef B,\n+                         LLVMValueRef Personality) {\n+#if LLVM_VERSION_MINOR >= 8\n+    unwrap(B)->GetInsertBlock()\n+             ->getParent()\n+             ->setPersonalityFn(cast<Function>(unwrap(Personality)));\n+#endif\n+}\n+\n+#if LLVM_VERSION_MINOR >= 8\n+extern \"C\" OperandBundleDef*\n+LLVMRustBuildOperandBundleDef(const char *Name,\n+                              LLVMValueRef *Inputs,\n+                              unsigned NumInputs) {\n+  return new OperandBundleDef(Name, makeArrayRef(unwrap(Inputs), NumInputs));\n+}\n+\n+extern \"C\" void\n+LLVMRustFreeOperandBundleDef(OperandBundleDef* Bundle) {\n+  delete Bundle;\n+}\n+\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildCall(LLVMBuilderRef B,\n+                    LLVMValueRef Fn,\n+                    LLVMValueRef *Args,\n+                    unsigned NumArgs,\n+                    OperandBundleDef *Bundle,\n+                    const char *Name) {\n+    unsigned len = Bundle ? 1 : 0;\n+    ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, len);\n+    return wrap(unwrap(B)->CreateCall(unwrap(Fn),\n+                                      makeArrayRef(unwrap(Args), NumArgs),\n+                                      Bundles,\n+                                      Name));\n+}\n+\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildInvoke(LLVMBuilderRef B,\n+                    LLVMValueRef Fn,\n+                    LLVMValueRef *Args,\n+                    unsigned NumArgs,\n+                    LLVMBasicBlockRef Then,\n+                    LLVMBasicBlockRef Catch,\n+                    OperandBundleDef *Bundle,\n+                    const char *Name) {\n+    unsigned len = Bundle ? 1 : 0;\n+    ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, len);\n+    return wrap(unwrap(B)->CreateInvoke(unwrap(Fn), unwrap(Then), unwrap(Catch),\n+                                        makeArrayRef(unwrap(Args), NumArgs),\n+                                        Bundles,\n+                                        Name));\n+}\n+#else\n+extern \"C\" void*\n+LLVMRustBuildOperandBundleDef(const char *Name,\n+                              LLVMValueRef *Inputs,\n+                              unsigned NumInputs) {\n+  return NULL;\n+}\n+\n+extern \"C\" void\n+LLVMRustFreeOperandBundleDef(void* Bundle) {\n+}\n+\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildCall(LLVMBuilderRef B,\n+                    LLVMValueRef Fn,\n+                    LLVMValueRef *Args,\n+                    unsigned NumArgs,\n+                    void *Bundle,\n+                    const char *Name) {\n+    return LLVMBuildCall(B, Fn, Args, NumArgs, Name);\n+}\n+\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildInvoke(LLVMBuilderRef B,\n+                    LLVMValueRef Fn,\n+                    LLVMValueRef *Args,\n+                    unsigned NumArgs,\n+                    LLVMBasicBlockRef Then,\n+                    LLVMBasicBlockRef Catch,\n+                    void *Bundle,\n+                    const char *Name) {\n+    return LLVMBuildInvoke(B, Fn, Args, NumArgs, Then, Catch, Name);\n+}\n+#endif"}]}