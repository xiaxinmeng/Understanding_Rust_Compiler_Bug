{"sha": "ab54a9c73c0bdb7df9693598c9e18840fccac6e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiNTRhOWM3M2MwYmRiN2RmOTY5MzU5OGM5ZTE4ODQwZmNjYWM2ZTE=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-01-21T22:11:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-01-21T22:11:38Z"}, "message": "Rollup merge of #47334 - etaoins:only-call-res-init-on-gnu-unix, r=alexcrichton\n\nOnly link res_init() on GNU/*nix\n\nTo workaround a bug in glibc <= 2.26 lookup_host() calls res_init() based on the glibc version detected at runtime. While this avoids calling res_init() on platforms where it's not required we will still end up linking against the symbol.\n\nThis causes an issue on macOS where res_init() is implemented in a separate library (libresolv.9.dylib) from the main libc. While this is harmless for standalone programs it becomes a problem if Rust code is statically linked against another program. If the linked program doesn't already specify -lresolv it will cause the link to fail. This is captured in issue #46797\n\nFix this by hooking in to the glibc workaround in `cvt_gai` and only activating it for the \"gnu\" environment on Unix This should include all glibc platforms while excluding musl, windows-gnu, macOS, FreeBSD, etc.\n\nThis has the side benefit of removing the #[cfg] in sys_common; only unix.rs has code related to the workaround now.\n\nBefore this commit:\n```shell\n> cat main.rs\nuse std::net::ToSocketAddrs;\n\n#[no_mangle]\npub extern \"C\" fn resolve_test() -> () {\n    let addr_list = (\"google.com.au\", 0).to_socket_addrs().unwrap();\n    println!(\"{:?}\", addr_list);\n}\n> rustc --crate-type=staticlib main.rs\n> clang libmain.a test.c -o combined\nUndefined symbols for architecture x86_64:\n  \"_res_9_init\", referenced from:\n      std::net::lookup_host::h93c17fe9ad38464a in libmain.a(std-826c8d3b356e180c.std0.rcgu.o)\nld: symbol(s) not found for architecture x86_64\nclang-5.0: error: linker command failed with exit code 1 (use -v to see invocation)\n```\n\nAfterwards:\n```shell\n> rustc --crate-type=staticlib main.rs\n> clang libmain.a test.c -o combined\n> ./combined\nIntoIter([V4(172.217.25.131:0)])\n```\n\nFixes  #46797", "tree": {"sha": "8e86e7a787122aeb3034e74da05ec15eaddba08d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e86e7a787122aeb3034e74da05ec15eaddba08d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab54a9c73c0bdb7df9693598c9e18840fccac6e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab54a9c73c0bdb7df9693598c9e18840fccac6e1", "html_url": "https://github.com/rust-lang/rust/commit/ab54a9c73c0bdb7df9693598c9e18840fccac6e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab54a9c73c0bdb7df9693598c9e18840fccac6e1/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bb1b0dd3793db24fb1214640af72a5e8c66dded", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bb1b0dd3793db24fb1214640af72a5e8c66dded", "html_url": "https://github.com/rust-lang/rust/commit/6bb1b0dd3793db24fb1214640af72a5e8c66dded"}, {"sha": "090a968fe7680cce0d3aa8fde25a5dc48948e43e", "url": "https://api.github.com/repos/rust-lang/rust/commits/090a968fe7680cce0d3aa8fde25a5dc48948e43e", "html_url": "https://github.com/rust-lang/rust/commit/090a968fe7680cce0d3aa8fde25a5dc48948e43e"}], "stats": {"total": 48, "additions": 16, "deletions": 32}, "files": [{"sha": "21218489679393a92a655bf0012caa5ad242f962", "filename": "src/libstd/sys/unix/l4re.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab54a9c73c0bdb7df9693598c9e18840fccac6e1/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab54a9c73c0bdb7df9693598c9e18840fccac6e1/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs?ref=ab54a9c73c0bdb7df9693598c9e18840fccac6e1", "patch": "@@ -437,9 +437,5 @@ pub mod net {\n     pub fn lookup_host(_: &str) -> io::Result<LookupHost> {\n         unimpl!();\n     }\n-\n-    pub fn res_init_if_glibc_before_2_26() -> io::Result<()> {\n-        unimpl!();\n-    }\n }\n "}, {"sha": "3f65975e608800a7198d6c36bb84832e4a437a62", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ab54a9c73c0bdb7df9693598c9e18840fccac6e1/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab54a9c73c0bdb7df9693598c9e18840fccac6e1/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=ab54a9c73c0bdb7df9693598c9e18840fccac6e1", "patch": "@@ -51,6 +51,10 @@ pub fn cvt_gai(err: c_int) -> io::Result<()> {\n     if err == 0 {\n         return Ok(())\n     }\n+\n+    // We may need to trigger a glibc workaround. See on_resolver_failure() for details.\n+    on_resolver_failure();\n+\n     if err == EAI_SYSTEM {\n         return Err(io::Error::last_os_error())\n     }\n@@ -377,21 +381,22 @@ impl IntoInner<c_int> for Socket {\n // res_init unconditionally, we call it only when we detect we're linking\n // against glibc version < 2.26. (That is, when we both know its needed and\n // believe it's thread-safe).\n-pub fn res_init_if_glibc_before_2_26() -> io::Result<()> {\n+#[cfg(target_env = \"gnu\")]\n+fn on_resolver_failure() {\n     // If the version fails to parse, we treat it the same as \"not glibc\".\n     if let Some(Ok(version_str)) = glibc_version_cstr().map(CStr::to_str) {\n         if let Some(version) = parse_glibc_version(version_str) {\n             if version < (2, 26) {\n-                let ret = unsafe { libc::res_init() };\n-                if ret != 0 {\n-                    return Err(io::Error::last_os_error());\n-                }\n+                unsafe { libc::res_init() };\n             }\n         }\n     }\n-    Ok(())\n }\n \n+#[cfg(not(target_env = \"gnu\"))]\n+fn on_resolver_failure() {}\n+\n+#[cfg(target_env = \"gnu\")]\n fn glibc_version_cstr() -> Option<&'static CStr> {\n     weak! {\n         fn gnu_get_libc_version() -> *const libc::c_char\n@@ -405,6 +410,7 @@ fn glibc_version_cstr() -> Option<&'static CStr> {\n \n // Returns Some((major, minor)) if the string is a valid \"x.y\" version,\n // ignoring any extra dot-separated parts. Otherwise return None.\n+#[cfg(target_env = \"gnu\")]\n fn parse_glibc_version(version: &str) -> Option<(usize, usize)> {\n     let mut parsed_ints = version.split(\".\").map(str::parse::<usize>).fuse();\n     match (parsed_ints.next(), parsed_ints.next()) {\n@@ -413,7 +419,7 @@ fn parse_glibc_version(version: &str) -> Option<(usize, usize)> {\n     }\n }\n \n-#[cfg(test)]\n+#[cfg(all(test, taget_env = \"gnu\"))]\n mod test {\n     use super::*;\n "}, {"sha": "b841afe1a5141dfd2db749ad09077400c8cc1933", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ab54a9c73c0bdb7df9693598c9e18840fccac6e1/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab54a9c73c0bdb7df9693598c9e18840fccac6e1/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=ab54a9c73c0bdb7df9693598c9e18840fccac6e1", "patch": "@@ -166,27 +166,9 @@ pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n     hints.ai_socktype = c::SOCK_STREAM;\n     let mut res = ptr::null_mut();\n     unsafe {\n-        match cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), &hints, &mut res)) {\n-            Ok(_) => {\n-                Ok(LookupHost { original: res, cur: res })\n-            },\n-            #[cfg(unix)]\n-            Err(e) => {\n-                // If we're running glibc prior to version 2.26, the lookup\n-                // failure could be caused by caching a stale /etc/resolv.conf.\n-                // We need to call libc::res_init() to clear the cache. But we\n-                // shouldn't call it in on any other platform, because other\n-                // res_init implementations aren't thread-safe. See\n-                // https://github.com/rust-lang/rust/issues/41570 and\n-                // https://github.com/rust-lang/rust/issues/43592.\n-                use sys::net::res_init_if_glibc_before_2_26;\n-                let _ = res_init_if_glibc_before_2_26();\n-                Err(e)\n-            },\n-            // the cfg is needed here to avoid an \"unreachable pattern\" warning\n-            #[cfg(not(unix))]\n-            Err(e) => Err(e),\n-        }\n+        cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), &hints, &mut res)).map(|_| {\n+            LookupHost { original: res, cur: res }\n+        })\n     }\n }\n "}]}