{"sha": "7cae9ddeeb14aa81a911a0e69d9eec265cc364d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjYWU5ZGRlZWIxNGFhODFhOTExYTBlNjlkOWVlYzI2NWNjMzY0ZDM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-21T16:05:15Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-21T16:08:54Z"}, "message": "move diagnostics to ide_api", "tree": {"sha": "dbdc74944dfc953c573863e8f0f4b5bcb8a6a40d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbdc74944dfc953c573863e8f0f4b5bcb8a6a40d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cae9ddeeb14aa81a911a0e69d9eec265cc364d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cae9ddeeb14aa81a911a0e69d9eec265cc364d3", "html_url": "https://github.com/rust-lang/rust/commit/7cae9ddeeb14aa81a911a0e69d9eec265cc364d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cae9ddeeb14aa81a911a0e69d9eec265cc364d3/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48472f55c3eba0746c088613888a163b48d07398", "url": "https://api.github.com/repos/rust-lang/rust/commits/48472f55c3eba0746c088613888a163b48d07398", "html_url": "https://github.com/rust-lang/rust/commit/48472f55c3eba0746c088613888a163b48d07398"}], "stats": {"total": 508, "additions": 250, "deletions": 258}, "files": [{"sha": "d487722258a0b88ad5787008243c803a76132c8a", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 250, "deletions": 10, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/7cae9ddeeb14aa81a911a0e69d9eec265cc364d3/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cae9ddeeb14aa81a911a0e69d9eec265cc364d3/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=7cae9ddeeb14aa81a911a0e69d9eec265cc364d3", "patch": "@@ -1,21 +1,20 @@\n+use itertools::Itertools;\n use hir::{Problem, source_binder};\n use ra_ide_api_light::Severity;\n use ra_db::SourceDatabase;\n+use ra_syntax::{\n+    Location, SourceFile, SyntaxKind, TextRange, SyntaxNode,\n+    ast::{self, AstNode},\n \n-use crate::{Diagnostic, FileId, FileSystemEdit, SourceChange, db::RootDatabase};\n+};\n+use ra_text_edit::{TextEdit, TextEditBuilder};\n+\n+use crate::{Diagnostic, FileId, FileSystemEdit, SourceChange, SourceFileEdit, db::RootDatabase};\n \n pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic> {\n     let syntax = db.parse(file_id);\n \n-    let mut res = ra_ide_api_light::diagnostics(&syntax)\n-        .into_iter()\n-        .map(|d| Diagnostic {\n-            range: d.range,\n-            message: d.msg,\n-            severity: d.severity,\n-            fix: d.fix.map(|fix| SourceChange::from_local_edit(file_id, fix)),\n-        })\n-        .collect::<Vec<_>>();\n+    let mut res = syntax_diagnostics(file_id, &syntax);\n     if let Some(m) = source_binder::module_from_file_id(db, file_id) {\n         for (name_node, problem) in m.problems(db) {\n             let source_root = db.file_source_root(file_id);\n@@ -63,3 +62,244 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n     };\n     res\n }\n+\n+fn syntax_diagnostics(file_id: FileId, file: &SourceFile) -> Vec<Diagnostic> {\n+    fn location_to_range(location: Location) -> TextRange {\n+        match location {\n+            Location::Offset(offset) => TextRange::offset_len(offset, 1.into()),\n+            Location::Range(range) => range,\n+        }\n+    }\n+\n+    let mut errors: Vec<Diagnostic> = file\n+        .errors()\n+        .into_iter()\n+        .map(|err| Diagnostic {\n+            range: location_to_range(err.location()),\n+            message: format!(\"Syntax Error: {}\", err),\n+            severity: Severity::Error,\n+            fix: None,\n+        })\n+        .collect();\n+\n+    for node in file.syntax().descendants() {\n+        check_unnecessary_braces_in_use_statement(file_id, &mut errors, node);\n+        check_struct_shorthand_initialization(file_id, &mut errors, node);\n+    }\n+\n+    errors\n+}\n+\n+fn check_unnecessary_braces_in_use_statement(\n+    file_id: FileId,\n+    acc: &mut Vec<Diagnostic>,\n+    node: &SyntaxNode,\n+) -> Option<()> {\n+    let use_tree_list = ast::UseTreeList::cast(node)?;\n+    if let Some((single_use_tree,)) = use_tree_list.use_trees().collect_tuple() {\n+        let range = use_tree_list.syntax().range();\n+        let edit =\n+            text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(single_use_tree)\n+                .unwrap_or_else(|| {\n+                    let to_replace = single_use_tree.syntax().text().to_string();\n+                    let mut edit_builder = TextEditBuilder::default();\n+                    edit_builder.delete(range);\n+                    edit_builder.insert(range.start(), to_replace);\n+                    edit_builder.finish()\n+                });\n+\n+        acc.push(Diagnostic {\n+            range,\n+            message: format!(\"Unnecessary braces in use statement\"),\n+            severity: Severity::WeakWarning,\n+            fix: Some(SourceChange {\n+                label: \"Remove unnecessary braces\".to_string(),\n+                source_file_edits: vec![SourceFileEdit { file_id, edit }],\n+                file_system_edits: Vec::new(),\n+                cursor_position: None,\n+            }),\n+        });\n+    }\n+\n+    Some(())\n+}\n+\n+fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n+    single_use_tree: &ast::UseTree,\n+) -> Option<TextEdit> {\n+    let use_tree_list_node = single_use_tree.syntax().parent()?;\n+    if single_use_tree.path()?.segment()?.syntax().first_child()?.kind() == SyntaxKind::SELF_KW {\n+        let start = use_tree_list_node.prev_sibling()?.range().start();\n+        let end = use_tree_list_node.range().end();\n+        let range = TextRange::from_to(start, end);\n+        let mut edit_builder = TextEditBuilder::default();\n+        edit_builder.delete(range);\n+        return Some(edit_builder.finish());\n+    }\n+    None\n+}\n+\n+fn check_struct_shorthand_initialization(\n+    file_id: FileId,\n+    acc: &mut Vec<Diagnostic>,\n+    node: &SyntaxNode,\n+) -> Option<()> {\n+    let struct_lit = ast::StructLit::cast(node)?;\n+    let named_field_list = struct_lit.named_field_list()?;\n+    for named_field in named_field_list.fields() {\n+        if let (Some(name_ref), Some(expr)) = (named_field.name_ref(), named_field.expr()) {\n+            let field_name = name_ref.syntax().text().to_string();\n+            let field_expr = expr.syntax().text().to_string();\n+            if field_name == field_expr {\n+                let mut edit_builder = TextEditBuilder::default();\n+                edit_builder.delete(named_field.syntax().range());\n+                edit_builder.insert(named_field.syntax().range().start(), field_name);\n+                let edit = edit_builder.finish();\n+\n+                acc.push(Diagnostic {\n+                    range: named_field.syntax().range(),\n+                    message: format!(\"Shorthand struct initialization\"),\n+                    severity: Severity::WeakWarning,\n+                    fix: Some(SourceChange {\n+                        label: \"use struct shorthand initialization\".to_string(),\n+                        source_file_edits: vec![SourceFileEdit { file_id, edit }],\n+                        file_system_edits: Vec::new(),\n+                        cursor_position: None,\n+                    }),\n+                });\n+            }\n+        }\n+    }\n+    Some(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use test_utils::assert_eq_text;\n+\n+    use super::*;\n+\n+    type DiagnosticChecker = fn(FileId, &mut Vec<Diagnostic>, &SyntaxNode) -> Option<()>;\n+\n+    fn check_not_applicable(code: &str, func: DiagnosticChecker) {\n+        let file = SourceFile::parse(code);\n+        let mut diagnostics = Vec::new();\n+        for node in file.syntax().descendants() {\n+            func(FileId(0), &mut diagnostics, node);\n+        }\n+        assert!(diagnostics.is_empty());\n+    }\n+\n+    fn check_apply(before: &str, after: &str, func: DiagnosticChecker) {\n+        let file = SourceFile::parse(before);\n+        let mut diagnostics = Vec::new();\n+        for node in file.syntax().descendants() {\n+            func(FileId(0), &mut diagnostics, node);\n+        }\n+        let diagnostic =\n+            diagnostics.pop().unwrap_or_else(|| panic!(\"no diagnostics for:\\n{}\\n\", before));\n+        let mut fix = diagnostic.fix.unwrap();\n+        let edit = fix.source_file_edits.pop().unwrap().edit;\n+        let actual = edit.apply(&before);\n+        assert_eq_text!(after, &actual);\n+    }\n+\n+    #[test]\n+    fn test_check_unnecessary_braces_in_use_statement() {\n+        check_not_applicable(\n+            \"\n+            use a;\n+            use a::{c, d::e};\n+        \",\n+            check_unnecessary_braces_in_use_statement,\n+        );\n+        check_apply(\"use {b};\", \"use b;\", check_unnecessary_braces_in_use_statement);\n+        check_apply(\"use a::{c};\", \"use a::c;\", check_unnecessary_braces_in_use_statement);\n+        check_apply(\"use a::{self};\", \"use a;\", check_unnecessary_braces_in_use_statement);\n+        check_apply(\n+            \"use a::{c, d::{e}};\",\n+            \"use a::{c, d::e};\",\n+            check_unnecessary_braces_in_use_statement,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_check_struct_shorthand_initialization() {\n+        check_not_applicable(\n+            r#\"\n+            struct A {\n+                a: &'static str\n+            }\n+\n+            fn main() {\n+                A {\n+                    a: \"hello\"\n+                }\n+            }\n+        \"#,\n+            check_struct_shorthand_initialization,\n+        );\n+\n+        check_apply(\n+            r#\"\n+struct A {\n+    a: &'static str\n+}\n+\n+fn main() {\n+    let a = \"haha\";\n+    A {\n+        a: a\n+    }\n+}\n+        \"#,\n+            r#\"\n+struct A {\n+    a: &'static str\n+}\n+\n+fn main() {\n+    let a = \"haha\";\n+    A {\n+        a\n+    }\n+}\n+        \"#,\n+            check_struct_shorthand_initialization,\n+        );\n+\n+        check_apply(\n+            r#\"\n+struct A {\n+    a: &'static str,\n+    b: &'static str\n+}\n+\n+fn main() {\n+    let a = \"haha\";\n+    let b = \"bb\";\n+    A {\n+        a: a,\n+        b\n+    }\n+}\n+        \"#,\n+            r#\"\n+struct A {\n+    a: &'static str,\n+    b: &'static str\n+}\n+\n+fn main() {\n+    let a = \"haha\";\n+    let b = \"bb\";\n+    A {\n+        a,\n+        b\n+    }\n+}\n+        \"#,\n+            check_struct_shorthand_initialization,\n+        );\n+    }\n+}"}, {"sha": "7c383ca2af69f575ba4bab3adf8dc89baf714405", "filename": "crates/ra_ide_api_light/src/diagnostics.rs", "status": "removed", "additions": 0, "deletions": 246, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/48472f55c3eba0746c088613888a163b48d07398/crates%2Fra_ide_api_light%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48472f55c3eba0746c088613888a163b48d07398/crates%2Fra_ide_api_light%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Fdiagnostics.rs?ref=48472f55c3eba0746c088613888a163b48d07398", "patch": "@@ -1,246 +0,0 @@\n-use itertools::Itertools;\n-\n-use ra_syntax::{\n-    Location, SourceFile, SyntaxKind, TextRange, SyntaxNode,\n-    ast::{self, AstNode},\n-\n-};\n-use ra_text_edit::{TextEdit, TextEditBuilder};\n-\n-use crate::{Diagnostic, LocalEdit, Severity};\n-\n-pub fn diagnostics(file: &SourceFile) -> Vec<Diagnostic> {\n-    fn location_to_range(location: Location) -> TextRange {\n-        match location {\n-            Location::Offset(offset) => TextRange::offset_len(offset, 1.into()),\n-            Location::Range(range) => range,\n-        }\n-    }\n-\n-    let mut errors: Vec<Diagnostic> = file\n-        .errors()\n-        .into_iter()\n-        .map(|err| Diagnostic {\n-            range: location_to_range(err.location()),\n-            msg: format!(\"Syntax Error: {}\", err),\n-            severity: Severity::Error,\n-            fix: None,\n-        })\n-        .collect();\n-\n-    for node in file.syntax().descendants() {\n-        check_unnecessary_braces_in_use_statement(&mut errors, node);\n-        check_struct_shorthand_initialization(&mut errors, node);\n-    }\n-\n-    errors\n-}\n-\n-fn check_unnecessary_braces_in_use_statement(\n-    acc: &mut Vec<Diagnostic>,\n-    node: &SyntaxNode,\n-) -> Option<()> {\n-    let use_tree_list = ast::UseTreeList::cast(node)?;\n-    if let Some((single_use_tree,)) = use_tree_list.use_trees().collect_tuple() {\n-        let range = use_tree_list.syntax().range();\n-        let edit =\n-            text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(single_use_tree)\n-                .unwrap_or_else(|| {\n-                    let to_replace = single_use_tree.syntax().text().to_string();\n-                    let mut edit_builder = TextEditBuilder::default();\n-                    edit_builder.delete(range);\n-                    edit_builder.insert(range.start(), to_replace);\n-                    edit_builder.finish()\n-                });\n-\n-        acc.push(Diagnostic {\n-            range,\n-            msg: format!(\"Unnecessary braces in use statement\"),\n-            severity: Severity::WeakWarning,\n-            fix: Some(LocalEdit {\n-                label: \"Remove unnecessary braces\".to_string(),\n-                edit,\n-                cursor_position: None,\n-            }),\n-        });\n-    }\n-\n-    Some(())\n-}\n-\n-fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n-    single_use_tree: &ast::UseTree,\n-) -> Option<TextEdit> {\n-    let use_tree_list_node = single_use_tree.syntax().parent()?;\n-    if single_use_tree.path()?.segment()?.syntax().first_child()?.kind() == SyntaxKind::SELF_KW {\n-        let start = use_tree_list_node.prev_sibling()?.range().start();\n-        let end = use_tree_list_node.range().end();\n-        let range = TextRange::from_to(start, end);\n-        let mut edit_builder = TextEditBuilder::default();\n-        edit_builder.delete(range);\n-        return Some(edit_builder.finish());\n-    }\n-    None\n-}\n-\n-fn check_struct_shorthand_initialization(\n-    acc: &mut Vec<Diagnostic>,\n-    node: &SyntaxNode,\n-) -> Option<()> {\n-    let struct_lit = ast::StructLit::cast(node)?;\n-    let named_field_list = struct_lit.named_field_list()?;\n-    for named_field in named_field_list.fields() {\n-        if let (Some(name_ref), Some(expr)) = (named_field.name_ref(), named_field.expr()) {\n-            let field_name = name_ref.syntax().text().to_string();\n-            let field_expr = expr.syntax().text().to_string();\n-            if field_name == field_expr {\n-                let mut edit_builder = TextEditBuilder::default();\n-                edit_builder.delete(named_field.syntax().range());\n-                edit_builder.insert(named_field.syntax().range().start(), field_name);\n-                let edit = edit_builder.finish();\n-\n-                acc.push(Diagnostic {\n-                    range: named_field.syntax().range(),\n-                    msg: format!(\"Shorthand struct initialization\"),\n-                    severity: Severity::WeakWarning,\n-                    fix: Some(LocalEdit {\n-                        label: \"use struct shorthand initialization\".to_string(),\n-                        edit,\n-                        cursor_position: None,\n-                    }),\n-                });\n-            }\n-        }\n-    }\n-    Some(())\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::test_utils::assert_eq_text;\n-\n-    use super::*;\n-\n-    type DiagnosticChecker = fn(&mut Vec<Diagnostic>, &SyntaxNode) -> Option<()>;\n-\n-    fn check_not_applicable(code: &str, func: DiagnosticChecker) {\n-        let file = SourceFile::parse(code);\n-        let mut diagnostics = Vec::new();\n-        for node in file.syntax().descendants() {\n-            func(&mut diagnostics, node);\n-        }\n-        assert!(diagnostics.is_empty());\n-    }\n-\n-    fn check_apply(before: &str, after: &str, func: DiagnosticChecker) {\n-        let file = SourceFile::parse(before);\n-        let mut diagnostics = Vec::new();\n-        for node in file.syntax().descendants() {\n-            func(&mut diagnostics, node);\n-        }\n-        let diagnostic =\n-            diagnostics.pop().unwrap_or_else(|| panic!(\"no diagnostics for:\\n{}\\n\", before));\n-        let fix = diagnostic.fix.unwrap();\n-        let actual = fix.edit.apply(&before);\n-        assert_eq_text!(after, &actual);\n-    }\n-\n-    #[test]\n-    fn test_check_unnecessary_braces_in_use_statement() {\n-        check_not_applicable(\n-            \"\n-            use a;\n-            use a::{c, d::e};\n-        \",\n-            check_unnecessary_braces_in_use_statement,\n-        );\n-        check_apply(\"use {b};\", \"use b;\", check_unnecessary_braces_in_use_statement);\n-        check_apply(\"use a::{c};\", \"use a::c;\", check_unnecessary_braces_in_use_statement);\n-        check_apply(\"use a::{self};\", \"use a;\", check_unnecessary_braces_in_use_statement);\n-        check_apply(\n-            \"use a::{c, d::{e}};\",\n-            \"use a::{c, d::e};\",\n-            check_unnecessary_braces_in_use_statement,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_check_struct_shorthand_initialization() {\n-        check_not_applicable(\n-            r#\"\n-            struct A {\n-                a: &'static str\n-            }\n-\n-            fn main() {\n-                A {\n-                    a: \"hello\"\n-                }\n-            }\n-        \"#,\n-            check_struct_shorthand_initialization,\n-        );\n-\n-        check_apply(\n-            r#\"\n-struct A {\n-    a: &'static str\n-}\n-\n-fn main() {\n-    let a = \"haha\";\n-    A {\n-        a: a\n-    }\n-}\n-        \"#,\n-            r#\"\n-struct A {\n-    a: &'static str\n-}\n-\n-fn main() {\n-    let a = \"haha\";\n-    A {\n-        a\n-    }\n-}\n-        \"#,\n-            check_struct_shorthand_initialization,\n-        );\n-\n-        check_apply(\n-            r#\"\n-struct A {\n-    a: &'static str,\n-    b: &'static str\n-}\n-\n-fn main() {\n-    let a = \"haha\";\n-    let b = \"bb\";\n-    A {\n-        a: a,\n-        b\n-    }\n-}\n-        \"#,\n-            r#\"\n-struct A {\n-    a: &'static str,\n-    b: &'static str\n-}\n-\n-fn main() {\n-    let a = \"haha\";\n-    let b = \"bb\";\n-    A {\n-        a,\n-        b\n-    }\n-}\n-        \"#,\n-            check_struct_shorthand_initialization,\n-        );\n-    }\n-}"}, {"sha": "47b30255b9c14f547d9d38573a7e1eac428fb0fa", "filename": "crates/ra_ide_api_light/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cae9ddeeb14aa81a911a0e69d9eec265cc364d3/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cae9ddeeb14aa81a911a0e69d9eec265cc364d3/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs?ref=7cae9ddeeb14aa81a911a0e69d9eec265cc364d3", "patch": "@@ -11,7 +11,6 @@ mod structure;\n mod test_utils;\n mod join_lines;\n mod typing;\n-mod diagnostics;\n \n use rustc_hash::FxHashSet;\n use ra_text_edit::TextEditBuilder;\n@@ -27,7 +26,6 @@ pub use crate::{\n     line_index::{LineCol, LineIndex},\n     line_index_utils::translate_offset_with_edit,\n     structure::{file_structure, StructureNode},\n-    diagnostics::diagnostics,\n     join_lines::join_lines,\n     typing::{on_enter, on_dot_typed, on_eq_typed},\n };"}]}