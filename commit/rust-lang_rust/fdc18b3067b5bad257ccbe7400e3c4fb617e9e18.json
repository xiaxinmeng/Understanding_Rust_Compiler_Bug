{"sha": "fdc18b3067b5bad257ccbe7400e3c4fb617e9e18", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkYzE4YjMwNjdiNWJhZDI1N2NjYmU3NDAwZTNjNGZiNjE3ZTllMTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-22T11:11:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-22T11:11:47Z"}, "message": "Auto merge of #47353 - nikomatsakis:nll-issue-47189, r=pnkfelix+nmatsakis\n\nrenumber regions in generators\n\nThis fixes #47189, but I think we still have to double check various things around how to treat generators in MIR type check + borrow check (e.g., what borrows should be invalidated by a `Suspend`? What consistency properties should type check be enforcing anyway around the \"interior\" type?)\n\nAlso fixes #47587 thanks to @spastorino's commit.\n\nr? @pnkfelix", "tree": {"sha": "ebe74cccf12324474726ee5d39a3ecc19d6f70b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebe74cccf12324474726ee5d39a3ecc19d6f70b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdc18b3067b5bad257ccbe7400e3c4fb617e9e18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdc18b3067b5bad257ccbe7400e3c4fb617e9e18", "html_url": "https://github.com/rust-lang/rust/commit/fdc18b3067b5bad257ccbe7400e3c4fb617e9e18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdc18b3067b5bad257ccbe7400e3c4fb617e9e18/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b887317da6ba0f70b34c0439ade8508e1b525fb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b887317da6ba0f70b34c0439ade8508e1b525fb0", "html_url": "https://github.com/rust-lang/rust/commit/b887317da6ba0f70b34c0439ade8508e1b525fb0"}, {"sha": "8f2cc02bc347aca311e6a5ce5548a62c7a896047", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f2cc02bc347aca311e6a5ce5548a62c7a896047", "html_url": "https://github.com/rust-lang/rust/commit/8f2cc02bc347aca311e6a5ce5548a62c7a896047"}], "stats": {"total": 107, "additions": 99, "deletions": 8}, "files": [{"sha": "57ed41f2f06e63c7ef6968409e55754ef44f3dbc", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fdc18b3067b5bad257ccbe7400e3c4fb617e9e18/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc18b3067b5bad257ccbe7400e3c4fb617e9e18/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=fdc18b3067b5bad257ccbe7400e3c4fb617e9e18", "patch": "@@ -277,6 +277,13 @@ macro_rules! make_mir_visitor {\n \n             fn super_mir(&mut self,\n                          mir: & $($mutability)* Mir<'tcx>) {\n+                if let Some(yield_ty) = &$($mutability)* mir.yield_ty {\n+                    self.visit_ty(yield_ty, TyContext::YieldTy(SourceInfo {\n+                        span: mir.span,\n+                        scope: ARGUMENT_VISIBILITY_SCOPE,\n+                    }));\n+                }\n+\n                 // for best performance, we want to use an iterator rather\n                 // than a for-loop, to avoid calling Mir::invalidate for\n                 // each basic block.\n@@ -852,6 +859,8 @@ pub enum TyContext {\n     /// The return type of the function.\n     ReturnTy(SourceInfo),\n \n+    YieldTy(SourceInfo),\n+\n     /// A type found at some location.\n     Location(Location),\n }"}, {"sha": "3a39eb5c908de3660efe06d05d7a7da6e2d4d9a1", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fdc18b3067b5bad257ccbe7400e3c4fb617e9e18/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc18b3067b5bad257ccbe7400e3c4fb617e9e18/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=fdc18b3067b5bad257ccbe7400e3c4fb617e9e18", "patch": "@@ -69,6 +69,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n     fn visit_ty(&mut self, ty: &ty::Ty<'tcx>, ty_context: TyContext) {\n         match ty_context {\n             TyContext::ReturnTy(source_info) |\n+            TyContext::YieldTy(source_info) |\n             TyContext::LocalDecl { source_info, .. } => {\n                 span_bug!(source_info.span,\n                           \"should not be visiting outside of the CFG: {:?}\","}, {"sha": "c54acda8a6252786b26cb30083b1c85663fd7c37", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fdc18b3067b5bad257ccbe7400e3c4fb617e9e18/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc18b3067b5bad257ccbe7400e3c4fb617e9e18/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=fdc18b3067b5bad257ccbe7400e3c4fb617e9e18", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, ClosureSubsts, Ty, TypeFoldable};\n+use rustc::ty::{self, ClosureSubsts, GeneratorInterior, Ty, TypeFoldable};\n use rustc::mir::{BasicBlock, Location, Mir, Statement, StatementKind};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n@@ -90,6 +90,21 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n         *constant = self.renumber_regions(ty_context, &*constant);\n     }\n \n+    fn visit_generator_interior(&mut self,\n+                                interior: &mut GeneratorInterior<'tcx>,\n+                                location: Location) {\n+        debug!(\n+            \"visit_generator_interior(interior={:?}, location={:?})\",\n+            interior,\n+            location,\n+        );\n+\n+        let ty_context = TyContext::Location(location);\n+        *interior = self.renumber_regions(ty_context, interior);\n+\n+        debug!(\"visit_generator_interior: interior={:?}\", interior);\n+    }\n+\n     fn visit_closure_substs(&mut self, substs: &mut ClosureSubsts<'tcx>, location: Location) {\n         debug!(\n             \"visit_closure_substs(substs={:?}, location={:?})\","}, {"sha": "b1aeae0b76bb112b48234a286e1909d050db9dd9", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fdc18b3067b5bad257ccbe7400e3c4fb617e9e18/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc18b3067b5bad257ccbe7400e3c4fb617e9e18/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=fdc18b3067b5bad257ccbe7400e3c4fb617e9e18", "patch": "@@ -60,6 +60,15 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             self.equate_normalized_input_or_output(start_position, input_ty, mir_input_ty);\n         }\n \n+        assert!(\n+            mir.yield_ty.is_some() && universal_regions.yield_ty.is_some() ||\n+            mir.yield_ty.is_none() && universal_regions.yield_ty.is_none()\n+            );\n+        if let Some(mir_yield_ty) = mir.yield_ty {\n+            let ur_yield_ty = universal_regions.yield_ty.unwrap();\n+            self.equate_normalized_input_or_output(start_position, ur_yield_ty, mir_yield_ty);\n+        }\n+\n         // Return types are a bit more complex. They may contain existential `impl Trait`\n         // types.\n         debug!("}, {"sha": "e47e3c728dff21327697f69dbd55674052c23fa4", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fdc18b3067b5bad257ccbe7400e3c4fb617e9e18/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc18b3067b5bad257ccbe7400e3c4fb617e9e18/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=fdc18b3067b5bad257ccbe7400e3c4fb617e9e18", "patch": "@@ -96,6 +96,8 @@ pub struct UniversalRegions<'tcx> {\n     /// our special inference variable there, we would mess that up.\n     pub region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n \n+    pub yield_ty: Option<Ty<'tcx>>,\n+\n     relations: UniversalRegionRelations,\n }\n \n@@ -505,6 +507,13 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n             num_universals\n         );\n \n+        let yield_ty = match defining_ty {\n+            DefiningTy::Generator(def_id, substs, _) => {\n+                Some(substs.generator_yield_ty(def_id, self.infcx.tcx))\n+            }\n+            _ => None,\n+        };\n+\n         UniversalRegions {\n             indices,\n             fr_static,\n@@ -516,6 +525,7 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n             unnormalized_output_ty,\n             unnormalized_input_tys,\n             region_bound_pairs: self.region_bound_pairs,\n+            yield_ty: yield_ty,\n             relations: self.relations,\n         }\n     }\n@@ -794,10 +804,12 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n     /// during initialization. Relies on the `indices` map having been\n     /// fully initialized.\n     pub fn to_region_vid(&self, r: ty::Region<'tcx>) -> RegionVid {\n-        match r {\n-            ty::ReEarlyBound(..) | ty::ReStatic => *self.indices.get(&r).unwrap(),\n-            ty::ReVar(..) => r.to_region_vid(),\n-            _ => bug!(\"cannot convert `{:?}` to a region vid\", r),\n+        if let ty::ReVar(..) = r {\n+            r.to_region_vid()\n+        } else {\n+            *self.indices.get(&r).unwrap_or_else(|| {\n+                bug!(\"cannot convert `{:?}` to a region vid\", r)\n+            })\n         }\n     }\n "}, {"sha": "6ab5fee79c661e72b82d7f7c85cb5dcc1f541c73", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fdc18b3067b5bad257ccbe7400e3c4fb617e9e18/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc18b3067b5bad257ccbe7400e3c4fb617e9e18/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=fdc18b3067b5bad257ccbe7400e3c4fb617e9e18", "patch": "@@ -518,7 +518,7 @@ pub fn write_mir_intro<'a, 'gcx, 'tcx>(\n     w: &mut Write,\n ) -> io::Result<()> {\n     write_mir_sig(tcx, src, mir, w)?;\n-    writeln!(w, \" {{\")?;\n+    writeln!(w, \"{{\")?;\n \n     // construct a scope tree and write it out\n     let mut scope_tree: FxHashMap<VisibilityScope, Vec<VisibilityScope>> = FxHashMap();\n@@ -581,13 +581,20 @@ fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write) -> io::R\n                 write!(w, \"{:?}: {}\", Place::Local(arg), mir.local_decls[arg].ty)?;\n             }\n \n-            write!(w, \") -> {}\", mir.return_ty())\n+            write!(w, \") -> {}\", mir.return_ty())?;\n         }\n         (hir::BodyOwnerKind::Const, _) | (hir::BodyOwnerKind::Static(_), _) | (_, Some(_)) => {\n             assert_eq!(mir.arg_count, 0);\n-            write!(w, \": {} =\", mir.return_ty())\n+            write!(w, \": {} =\", mir.return_ty())?;\n         }\n     }\n+\n+    if let Some(yield_ty) = mir.yield_ty {\n+        writeln!(w)?;\n+        writeln!(w, \"yields {}\", yield_ty)?;\n+    }\n+\n+    Ok(())\n }\n \n fn write_temp_decls(mir: &Mir, w: &mut Write) -> io::Result<()> {"}, {"sha": "7e8a0d1e2b925de0641fd6c0ae550e83b0560e4e", "filename": "src/test/run-pass/generator/yield-subtype.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fdc18b3067b5bad257ccbe7400e3c4fb617e9e18/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-subtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc18b3067b5bad257ccbe7400e3c4fb617e9e18/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-subtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-subtype.rs?ref=fdc18b3067b5bad257ccbe7400e3c4fb617e9e18", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions:lexical nll\n+#![cfg_attr(nll, feature(nll))]\n+\n #![feature(generators)]\n \n fn bar<'a>() {"}, {"sha": "60f67b1766c2c5baaa74d29e5420dbe0b27efc26", "filename": "src/test/ui/nll/generator-distinct-lifetime.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fdc18b3067b5bad257ccbe7400e3c4fb617e9e18/src%2Ftest%2Fui%2Fnll%2Fgenerator-distinct-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc18b3067b5bad257ccbe7400e3c4fb617e9e18/src%2Ftest%2Fui%2Fnll%2Fgenerator-distinct-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fgenerator-distinct-lifetime.rs?ref=fdc18b3067b5bad257ccbe7400e3c4fb617e9e18", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators, nll)]\n+\n+// Test for issue #47189. Here, both `s` and `t` are live for the\n+// generator's lifetime, but within the generator they have distinct\n+// lifetimes. We accept this code -- even though the borrow extends\n+// over a yield -- because the data that is borrowed (`*x`) is not\n+// stored on the stack.\n+\n+// must-compile-successfully\n+\n+fn foo(x: &mut u32) {\n+    move || {\n+        let s = &mut *x;\n+        yield;\n+        *s += 1;\n+\n+        let t = &mut *x;\n+        yield;\n+        *t += 1;\n+    };\n+}\n+\n+fn main() {\n+    foo(&mut 0);\n+}"}]}