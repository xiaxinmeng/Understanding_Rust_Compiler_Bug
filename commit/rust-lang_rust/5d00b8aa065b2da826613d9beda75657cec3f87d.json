{"sha": "5d00b8aa065b2da826613d9beda75657cec3f87d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkMDBiOGFhMDY1YjJkYTgyNjYxM2Q5YmVkYTc1NjU3Y2VjM2Y4N2Q=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-02T00:28:50Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-02T06:01:47Z"}, "message": "rustc_trans: load C-like enums larger than usize from memory with -Zorbit.", "tree": {"sha": "550be978863c5c612162a1d0c3025980f89408ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/550be978863c5c612162a1d0c3025980f89408ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d00b8aa065b2da826613d9beda75657cec3f87d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d00b8aa065b2da826613d9beda75657cec3f87d", "html_url": "https://github.com/rust-lang/rust/commit/5d00b8aa065b2da826613d9beda75657cec3f87d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d00b8aa065b2da826613d9beda75657cec3f87d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90ba77a7a9807a3a463f2820a4e652052e32efa0", "url": "https://api.github.com/repos/rust-lang/rust/commits/90ba77a7a9807a3a463f2820a4e652052e32efa0", "html_url": "https://github.com/rust-lang/rust/commit/90ba77a7a9807a3a463f2820a4e652052e32efa0"}], "stats": {"total": 58, "additions": 33, "deletions": 25}, "files": [{"sha": "97d65ce9c53614bf1a2600fd48e6c0fb1f15f3cc", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5d00b8aa065b2da826613d9beda75657cec3f87d/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d00b8aa065b2da826613d9beda75657cec3f87d/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=5d00b8aa065b2da826613d9beda75657cec3f87d", "patch": "@@ -244,18 +244,46 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             }\n                         }\n                     }\n-                    mir::CastKind::Misc if common::type_is_immediate(bcx.ccx(), operand.ty) => {\n+                    mir::CastKind::Misc if common::type_is_fat_ptr(bcx.tcx(), operand.ty) => {\n+                        let ll_cast_ty = type_of::immediate_type_of(bcx.ccx(), cast_ty);\n+                        let ll_from_ty = type_of::immediate_type_of(bcx.ccx(), operand.ty);\n+                        if let OperandValue::Pair(data_ptr, meta_ptr) = operand.val {\n+                            if common::type_is_fat_ptr(bcx.tcx(), cast_ty) {\n+                                let ll_cft = ll_cast_ty.field_types();\n+                                let ll_fft = ll_from_ty.field_types();\n+                                let data_cast = bcx.pointercast(data_ptr, ll_cft[0]);\n+                                assert_eq!(ll_cft[1].kind(), ll_fft[1].kind());\n+                                OperandValue::Pair(data_cast, meta_ptr)\n+                            } else { // cast to thin-ptr\n+                                // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n+                                // pointer-cast of that pointer to desired pointer type.\n+                                let llval = bcx.pointercast(data_ptr, ll_cast_ty);\n+                                OperandValue::Immediate(llval)\n+                            }\n+                        } else {\n+                            bug!(\"Unexpected non-Pair operand\")\n+                        }\n+                    }\n+                    mir::CastKind::Misc => {\n                         debug_assert!(common::type_is_immediate(bcx.ccx(), cast_ty));\n                         let r_t_in = CastTy::from_ty(operand.ty).expect(\"bad input type for cast\");\n                         let r_t_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                         let ll_t_in = type_of::immediate_type_of(bcx.ccx(), operand.ty);\n                         let ll_t_out = type_of::immediate_type_of(bcx.ccx(), cast_ty);\n-                        let llval = operand.immediate();\n-                        let signed = if let CastTy::Int(IntTy::CEnum) = r_t_in {\n+                        let (llval, signed) = if let CastTy::Int(IntTy::CEnum) = r_t_in {\n                             let repr = adt::represent_type(bcx.ccx(), operand.ty);\n-                            adt::is_discr_signed(&repr)\n+                            let discr = match operand.val {\n+                                OperandValue::Immediate(llval) => llval,\n+                                OperandValue::Ref(llptr) => {\n+                                    bcx.with_block(|bcx| {\n+                                        adt::trans_get_discr(bcx, &repr, llptr, None, true)\n+                                    })\n+                                }\n+                                OperandValue::Pair(..) => bug!(\"Unexpected Pair operand\")\n+                            };\n+                            (discr, adt::is_discr_signed(&repr))\n                         } else {\n-                            operand.ty.is_signed()\n+                            (operand.immediate(), operand.ty.is_signed())\n                         };\n \n                         let newval = match (r_t_in, r_t_out) {\n@@ -304,26 +332,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         };\n                         OperandValue::Immediate(newval)\n                     }\n-                    mir::CastKind::Misc => { // Casts from a fat-ptr.\n-                        let ll_cast_ty = type_of::immediate_type_of(bcx.ccx(), cast_ty);\n-                        let ll_from_ty = type_of::immediate_type_of(bcx.ccx(), operand.ty);\n-                        if let OperandValue::Pair(data_ptr, meta_ptr) = operand.val {\n-                            if common::type_is_fat_ptr(bcx.tcx(), cast_ty) {\n-                                let ll_cft = ll_cast_ty.field_types();\n-                                let ll_fft = ll_from_ty.field_types();\n-                                let data_cast = bcx.pointercast(data_ptr, ll_cft[0]);\n-                                assert_eq!(ll_cft[1].kind(), ll_fft[1].kind());\n-                                OperandValue::Pair(data_cast, meta_ptr)\n-                            } else { // cast to thin-ptr\n-                                // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n-                                // pointer-cast of that pointer to desired pointer type.\n-                                let llval = bcx.pointercast(data_ptr, ll_cast_ty);\n-                                OperandValue::Immediate(llval)\n-                            }\n-                        } else {\n-                            bug!(\"Unexpected non-Pair operand\")\n-                        }\n-                    }\n                 };\n                 let operand = OperandRef {\n                     val: val,"}]}