{"sha": "884ba4f11f4cac31b9fda402cbd925af4bc286d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NGJhNGYxMWY0Y2FjMzFiOWZkYTQwMmNiZDkyNWFmNGJjMjg2ZDQ=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-04-12T17:30:07Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-04-22T16:57:43Z"}, "message": "Use internal mutability for predecessor cache", "tree": {"sha": "a5fdcb083e02ae2aa055312bfd8543dfaa38b297", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5fdcb083e02ae2aa055312bfd8543dfaa38b297"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/884ba4f11f4cac31b9fda402cbd925af4bc286d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/884ba4f11f4cac31b9fda402cbd925af4bc286d4", "html_url": "https://github.com/rust-lang/rust/commit/884ba4f11f4cac31b9fda402cbd925af4bc286d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/884ba4f11f4cac31b9fda402cbd925af4bc286d4/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00f677d8974b393ff32ca25bf916b6b9650c75b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/00f677d8974b393ff32ca25bf916b6b9650c75b0", "html_url": "https://github.com/rust-lang/rust/commit/00f677d8974b393ff32ca25bf916b6b9650c75b0"}], "stats": {"total": 420, "additions": 133, "deletions": 287}, "files": [{"sha": "12822cea418d7b9bdd83558b391d6b6d0789b0a4", "filename": "src/librustc_middle/mir/cache.rs", "status": "removed", "additions": 0, "deletions": 276, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/00f677d8974b393ff32ca25bf916b6b9650c75b0/src%2Flibrustc_middle%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f677d8974b393ff32ca25bf916b6b9650c75b0/src%2Flibrustc_middle%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fcache.rs?ref=00f677d8974b393ff32ca25bf916b6b9650c75b0", "patch": "@@ -1,276 +0,0 @@\n-use crate::ich::StableHashingContext;\n-use crate::mir::{BasicBlock, BasicBlockData, Body, LocalDecls, Location, Successors};\n-use rustc_data_structures::graph::dominators::{dominators, Dominators};\n-use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_index::vec::IndexVec;\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n-use smallvec::SmallVec;\n-use std::iter;\n-use std::ops::{Deref, DerefMut, Index, IndexMut};\n-use std::vec::IntoIter;\n-\n-#[derive(Clone, Debug)]\n-pub struct Cache {\n-    // Typically 95%+ of the inner vectors have 4 or fewer elements.\n-    predecessors: Option<IndexVec<BasicBlock, SmallVec<[BasicBlock; 4]>>>,\n-}\n-\n-impl rustc_serialize::Encodable for Cache {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        Encodable::encode(&(), s)\n-    }\n-}\n-\n-impl rustc_serialize::Decodable for Cache {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n-        Decodable::decode(d).map(|_v: ()| Self::new())\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for Cache {\n-    fn hash_stable(&self, _: &mut StableHashingContext<'a>, _: &mut StableHasher) {\n-        // Do nothing.\n-    }\n-}\n-\n-impl Cache {\n-    pub fn new() -> Self {\n-        Self { predecessors: None }\n-    }\n-\n-    pub fn invalidate_predecessors(&mut self) {\n-        // FIXME: consider being more fine-grained\n-        self.predecessors = None;\n-    }\n-\n-    pub fn ensure_predecessors(&mut self, body: &Body<'_>) {\n-        if self.predecessors.is_none() {\n-            let mut result = IndexVec::from_elem(smallvec![], body.basic_blocks());\n-            for (bb, data) in body.basic_blocks().iter_enumerated() {\n-                if let Some(ref term) = data.terminator {\n-                    for &tgt in term.successors() {\n-                        result[tgt].push(bb);\n-                    }\n-                }\n-            }\n-\n-            self.predecessors = Some(result)\n-        }\n-    }\n-\n-    /// This will recompute the predecessors cache if it is not available\n-    fn predecessors(\n-        &mut self,\n-        body: &Body<'_>,\n-    ) -> &IndexVec<BasicBlock, SmallVec<[BasicBlock; 4]>> {\n-        self.ensure_predecessors(body);\n-        self.predecessors.as_ref().unwrap()\n-    }\n-\n-    fn unwrap_predecessors_for(&self, bb: BasicBlock) -> &[BasicBlock] {\n-        &self.predecessors.as_ref().unwrap()[bb]\n-    }\n-\n-    fn unwrap_predecessor_locations<'a>(\n-        &'a self,\n-        loc: Location,\n-        body: &'a Body<'a>,\n-    ) -> impl Iterator<Item = Location> + 'a {\n-        let if_zero_locations = if loc.statement_index == 0 {\n-            let predecessor_blocks = self.unwrap_predecessors_for(loc.block);\n-            let num_predecessor_blocks = predecessor_blocks.len();\n-            Some(\n-                (0..num_predecessor_blocks)\n-                    .map(move |i| predecessor_blocks[i])\n-                    .map(move |bb| body.terminator_loc(bb)),\n-            )\n-        } else {\n-            None\n-        };\n-\n-        let if_not_zero_locations = if loc.statement_index == 0 {\n-            None\n-        } else {\n-            Some(Location { block: loc.block, statement_index: loc.statement_index - 1 })\n-        };\n-\n-        if_zero_locations.into_iter().flatten().chain(if_not_zero_locations)\n-    }\n-\n-    pub fn basic_blocks_mut<'a, 'tcx>(\n-        &mut self,\n-        body: &'a mut Body<'tcx>,\n-    ) -> &'a mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n-        debug!(\"bbm: Clearing predecessors cache for body at: {:?}\", body.span.data());\n-        self.invalidate_predecessors();\n-        &mut body.basic_blocks\n-    }\n-\n-    pub fn basic_blocks_and_local_decls_mut<'a, 'tcx>(\n-        &mut self,\n-        body: &'a mut Body<'tcx>,\n-    ) -> (&'a mut IndexVec<BasicBlock, BasicBlockData<'tcx>>, &'a mut LocalDecls<'tcx>) {\n-        debug!(\"bbaldm: Clearing predecessors cache for body at: {:?}\", body.span.data());\n-        self.invalidate_predecessors();\n-        (&mut body.basic_blocks, &mut body.local_decls)\n-    }\n-}\n-\n-#[derive(Clone, Debug, HashStable, RustcEncodable, RustcDecodable, TypeFoldable)]\n-pub struct BodyAndCache<'tcx> {\n-    body: Body<'tcx>,\n-    cache: Cache,\n-}\n-\n-impl BodyAndCache<'tcx> {\n-    pub fn new(body: Body<'tcx>) -> Self {\n-        Self { body, cache: Cache::new() }\n-    }\n-}\n-\n-#[macro_export]\n-macro_rules! read_only {\n-    ($body:expr) => {{\n-        $body.ensure_predecessors();\n-        $body.unwrap_read_only()\n-    }};\n-}\n-\n-impl BodyAndCache<'tcx> {\n-    pub fn ensure_predecessors(&mut self) {\n-        self.cache.ensure_predecessors(&self.body);\n-    }\n-\n-    pub fn predecessors(&mut self) -> &IndexVec<BasicBlock, SmallVec<[BasicBlock; 4]>> {\n-        self.cache.predecessors(&self.body)\n-    }\n-\n-    pub fn unwrap_read_only(&self) -> ReadOnlyBodyAndCache<'_, 'tcx> {\n-        ReadOnlyBodyAndCache::new(&self.body, &self.cache)\n-    }\n-\n-    pub fn basic_blocks_mut(&mut self) -> &mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n-        self.cache.basic_blocks_mut(&mut self.body)\n-    }\n-\n-    pub fn basic_blocks_and_local_decls_mut(\n-        &mut self,\n-    ) -> (&mut IndexVec<BasicBlock, BasicBlockData<'tcx>>, &mut LocalDecls<'tcx>) {\n-        self.cache.basic_blocks_and_local_decls_mut(&mut self.body)\n-    }\n-}\n-\n-impl<'tcx> Index<BasicBlock> for BodyAndCache<'tcx> {\n-    type Output = BasicBlockData<'tcx>;\n-\n-    fn index(&self, index: BasicBlock) -> &BasicBlockData<'tcx> {\n-        &self.body[index]\n-    }\n-}\n-\n-impl<'tcx> IndexMut<BasicBlock> for BodyAndCache<'tcx> {\n-    fn index_mut(&mut self, index: BasicBlock) -> &mut Self::Output {\n-        &mut self.basic_blocks_mut()[index]\n-    }\n-}\n-\n-impl<'tcx> Deref for BodyAndCache<'tcx> {\n-    type Target = Body<'tcx>;\n-\n-    fn deref(&self) -> &Self::Target {\n-        &self.body\n-    }\n-}\n-\n-impl<'tcx> DerefMut for BodyAndCache<'tcx> {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        &mut self.body\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub struct ReadOnlyBodyAndCache<'a, 'tcx> {\n-    body: &'a Body<'tcx>,\n-    cache: &'a Cache,\n-}\n-\n-impl ReadOnlyBodyAndCache<'a, 'tcx> {\n-    fn new(body: &'a Body<'tcx>, cache: &'a Cache) -> Self {\n-        assert!(\n-            cache.predecessors.is_some(),\n-            \"Cannot construct ReadOnlyBodyAndCache without computed predecessors\"\n-        );\n-        Self { body, cache }\n-    }\n-\n-    pub fn predecessors(&self) -> &IndexVec<BasicBlock, SmallVec<[BasicBlock; 4]>> {\n-        self.cache.predecessors.as_ref().unwrap()\n-    }\n-\n-    pub fn predecessors_for(&self, bb: BasicBlock) -> &[BasicBlock] {\n-        self.cache.unwrap_predecessors_for(bb)\n-    }\n-\n-    pub fn predecessor_locations(&self, loc: Location) -> impl Iterator<Item = Location> + '_ {\n-        self.cache.unwrap_predecessor_locations(loc, self.body)\n-    }\n-\n-    pub fn basic_blocks(&self) -> &IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n-        &self.body.basic_blocks\n-    }\n-\n-    pub fn dominators(&self) -> Dominators<BasicBlock> {\n-        dominators(self)\n-    }\n-}\n-\n-impl graph::DirectedGraph for ReadOnlyBodyAndCache<'a, 'tcx> {\n-    type Node = BasicBlock;\n-}\n-\n-impl graph::GraphPredecessors<'graph> for ReadOnlyBodyAndCache<'a, 'tcx> {\n-    type Item = BasicBlock;\n-    type Iter = IntoIter<BasicBlock>;\n-}\n-\n-impl graph::WithPredecessors for ReadOnlyBodyAndCache<'a, 'tcx> {\n-    fn predecessors(&self, node: Self::Node) -> <Self as GraphPredecessors<'_>>::Iter {\n-        self.cache.unwrap_predecessors_for(node).to_vec().into_iter()\n-    }\n-}\n-\n-impl graph::WithNumNodes for ReadOnlyBodyAndCache<'a, 'tcx> {\n-    fn num_nodes(&self) -> usize {\n-        self.body.num_nodes()\n-    }\n-}\n-\n-impl graph::WithStartNode for ReadOnlyBodyAndCache<'a, 'tcx> {\n-    fn start_node(&self) -> Self::Node {\n-        self.body.start_node()\n-    }\n-}\n-\n-impl graph::WithSuccessors for ReadOnlyBodyAndCache<'a, 'tcx> {\n-    fn successors(&self, node: Self::Node) -> <Self as GraphSuccessors<'_>>::Iter {\n-        self.body.successors(node)\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx> graph::GraphSuccessors<'b> for ReadOnlyBodyAndCache<'a, 'tcx> {\n-    type Item = BasicBlock;\n-    type Iter = iter::Cloned<Successors<'b>>;\n-}\n-\n-impl Deref for ReadOnlyBodyAndCache<'a, 'tcx> {\n-    type Target = &'a Body<'tcx>;\n-\n-    fn deref(&self) -> &Self::Target {\n-        &self.body\n-    }\n-}\n-\n-CloneTypeFoldableAndLiftImpls! {\n-    Cache,\n-}"}, {"sha": "3295e48b7b413637bb4da273388f606b04710e22", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 66, "deletions": 11, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/884ba4f11f4cac31b9fda402cbd925af4bc286d4/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/884ba4f11f4cac31b9fda402cbd925af4bc286d4/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=884ba4f11f4cac31b9fda402cbd925af4bc286d4", "patch": "@@ -21,27 +21,28 @@ use polonius_engine::Atom;\n pub use rustc_ast::ast::Mutability;\n use rustc_ast::ast::Name;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::graph::dominators::Dominators;\n+use rustc_data_structures::graph::dominators::{dominators, Dominators};\n use rustc_data_structures::graph::{self, GraphSuccessors};\n+use rustc_data_structures::sync::MappedLockGuard;\n use rustc_index::bit_set::BitMatrix;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n use rustc_serialize::{Decodable, Encodable};\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n+use smallvec::SmallVec;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n-use std::ops::Index;\n+use std::ops::{Index, IndexMut};\n use std::slice;\n use std::{iter, mem, option};\n \n-pub use self::cache::{BodyAndCache, ReadOnlyBodyAndCache};\n+use self::predecessors::{PredecessorCache, Predecessors};\n pub use self::query::*;\n-pub use crate::read_only;\n \n-mod cache;\n pub mod interpret;\n pub mod mono;\n+mod predecessors;\n mod query;\n pub mod tcx;\n pub mod traversal;\n@@ -108,7 +109,7 @@ pub struct Body<'tcx> {\n     pub yield_ty: Option<Ty<'tcx>>,\n \n     /// Generator drop glue.\n-    pub generator_drop: Option<Box<BodyAndCache<'tcx>>>,\n+    pub generator_drop: Option<Box<Body<'tcx>>>,\n \n     /// The layout of a generator. Produced by the state transformation.\n     pub generator_layout: Option<GeneratorLayout<'tcx>>,\n@@ -164,6 +165,8 @@ pub struct Body<'tcx> {\n     /// implementation without the flag hid this situation silently.\n     /// FIXME(oli-obk): rewrite the promoted during promotion to eliminate the cell components.\n     pub ignore_interior_mut_in_const_validation: bool,\n+\n+    pub predecessor_cache: PredecessorCache,\n }\n \n impl<'tcx> Body<'tcx> {\n@@ -202,6 +205,7 @@ impl<'tcx> Body<'tcx> {\n             span,\n             ignore_interior_mut_in_const_validation: false,\n             control_flow_destroyed,\n+            predecessor_cache: PredecessorCache::new(),\n         }\n     }\n \n@@ -227,6 +231,7 @@ impl<'tcx> Body<'tcx> {\n             generator_kind: None,\n             var_debug_info: Vec::new(),\n             ignore_interior_mut_in_const_validation: false,\n+            predecessor_cache: PredecessorCache::new(),\n         }\n     }\n \n@@ -235,6 +240,25 @@ impl<'tcx> Body<'tcx> {\n         &self.basic_blocks\n     }\n \n+    #[inline]\n+    pub fn basic_blocks_mut(&mut self) -> &mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        // Because the user could mutate basic block terminators via this reference, we need to\n+        // invalidate the predecessor cache.\n+        //\n+        // FIXME: Use a finer-grained API for this, so only transformations that alter terminators\n+        // invalidate the predecessor cache.\n+        self.predecessor_cache.invalidate();\n+        &mut self.basic_blocks\n+    }\n+\n+    #[inline]\n+    pub fn basic_blocks_and_local_decls_mut(\n+        &mut self,\n+    ) -> (&mut IndexVec<BasicBlock, BasicBlockData<'tcx>>, &mut LocalDecls<'tcx>) {\n+        self.predecessor_cache.invalidate();\n+        (&mut self.basic_blocks, &mut self.local_decls)\n+    }\n+\n     /// Returns `true` if a cycle exists in the control-flow graph that is reachable from the\n     /// `START_BLOCK`.\n     pub fn is_cfg_cyclic(&self) -> bool {\n@@ -365,6 +389,23 @@ impl<'tcx> Body<'tcx> {\n     pub fn terminator_loc(&self, bb: BasicBlock) -> Location {\n         Location { block: bb, statement_index: self[bb].statements.len() }\n     }\n+\n+    pub fn predecessors_for(\n+        &self,\n+        bb: BasicBlock,\n+    ) -> impl std::ops::Deref<Target = SmallVec<[BasicBlock; 4]>> + '_ {\n+        let predecessors = self.predecessor_cache.compute(&self.basic_blocks);\n+        MappedLockGuard::map(predecessors, |preds| &mut preds[bb])\n+    }\n+\n+    pub fn predecessors(&self) -> impl std::ops::Deref<Target = Predecessors> + '_ {\n+        self.predecessor_cache.compute(&self.basic_blocks)\n+    }\n+\n+    #[inline]\n+    pub fn dominators(&self) -> Dominators<BasicBlock> {\n+        dominators(self)\n+    }\n }\n \n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n@@ -387,6 +428,13 @@ impl<'tcx> Index<BasicBlock> for Body<'tcx> {\n     }\n }\n \n+impl<'tcx> IndexMut<BasicBlock> for Body<'tcx> {\n+    #[inline]\n+    fn index_mut(&mut self, index: BasicBlock) -> &mut BasicBlockData<'tcx> {\n+        &mut self.basic_blocks_mut()[index]\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug, HashStable, TypeFoldable)]\n pub enum ClearCrossCrate<T> {\n     Clear,\n@@ -2613,6 +2661,17 @@ impl<'a, 'b> graph::GraphSuccessors<'b> for Body<'a> {\n     type Iter = iter::Cloned<Successors<'b>>;\n }\n \n+impl graph::GraphPredecessors<'graph> for Body<'tcx> {\n+    type Item = BasicBlock;\n+    type Iter = smallvec::IntoIter<[BasicBlock; 4]>;\n+}\n+\n+impl graph::WithPredecessors for Body<'tcx> {\n+    fn predecessors(&self, node: Self::Node) -> <Self as graph::GraphPredecessors<'_>>::Iter {\n+        self.predecessors_for(node).clone().into_iter()\n+    }\n+}\n+\n /// `Location` represents the position of the start of the statement; or, if\n /// `statement_index` equals the number of statements, then the start of the\n /// terminator.\n@@ -2642,11 +2701,7 @@ impl Location {\n     }\n \n     /// Returns `true` if `other` is earlier in the control flow graph than `self`.\n-    pub fn is_predecessor_of<'tcx>(\n-        &self,\n-        other: Location,\n-        body: ReadOnlyBodyAndCache<'_, 'tcx>,\n-    ) -> bool {\n+    pub fn is_predecessor_of<'tcx>(&self, other: Location, body: &Body<'tcx>) -> bool {\n         // If we are in the same block as the other location and are an earlier statement\n         // then we are a predecessor of `other`.\n         if self.block == other.block && self.statement_index < other.statement_index {"}, {"sha": "90cf1e3ce4e295e61fc62b9eb675acfbd9def53a", "filename": "src/librustc_middle/mir/predecessors.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/884ba4f11f4cac31b9fda402cbd925af4bc286d4/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/884ba4f11f4cac31b9fda402cbd925af4bc286d4/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs?ref=884ba4f11f4cac31b9fda402cbd925af4bc286d4", "patch": "@@ -0,0 +1,67 @@\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::sync::{Lock, LockGuard, MappedLockGuard};\n+use rustc_index::vec::IndexVec;\n+use rustc_serialize as serialize;\n+use smallvec::SmallVec;\n+\n+use crate::mir::{BasicBlock, BasicBlockData};\n+\n+// Typically 95%+ of basic blocks have 4 or fewer predecessors.\n+pub type Predecessors = IndexVec<BasicBlock, SmallVec<[BasicBlock; 4]>>;\n+\n+#[derive(Clone, Debug)]\n+pub struct PredecessorCache {\n+    cache: Lock<Option<Predecessors>>,\n+}\n+\n+impl PredecessorCache {\n+    pub fn new() -> Self {\n+        PredecessorCache { cache: Lock::new(None) }\n+    }\n+\n+    pub fn invalidate(&mut self) {\n+        *self.cache.get_mut() = None;\n+    }\n+\n+    pub fn compute(\n+        &self,\n+        basic_blocks: &IndexVec<BasicBlock, BasicBlockData<'_>>,\n+    ) -> MappedLockGuard<'_, Predecessors> {\n+        LockGuard::map(self.cache.lock(), |cache| {\n+            cache.get_or_insert_with(|| {\n+                let mut preds = IndexVec::from_elem(SmallVec::new(), basic_blocks);\n+                for (bb, data) in basic_blocks.iter_enumerated() {\n+                    if let Some(term) = &data.terminator {\n+                        for &succ in term.successors() {\n+                            preds[succ].push(bb);\n+                        }\n+                    }\n+                }\n+\n+                preds\n+            })\n+        })\n+    }\n+}\n+\n+impl serialize::Encodable for PredecessorCache {\n+    fn encode<S: serialize::Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        serialize::Encodable::encode(&(), s)\n+    }\n+}\n+\n+impl serialize::Decodable for PredecessorCache {\n+    fn decode<D: serialize::Decoder>(d: &mut D) -> Result<Self, D::Error> {\n+        serialize::Decodable::decode(d).map(|_v: ()| Self::new())\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for PredecessorCache {\n+    fn hash_stable(&self, _: &mut CTX, _: &mut StableHasher) {\n+        // do nothing\n+    }\n+}\n+\n+CloneTypeFoldableAndLiftImpls! {\n+    PredecessorCache,\n+}"}]}