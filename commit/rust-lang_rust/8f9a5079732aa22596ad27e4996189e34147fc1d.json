{"sha": "8f9a5079732aa22596ad27e4996189e34147fc1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmOWE1MDc5NzMyYWEyMjU5NmFkMjdlNDk5NjE4OWUzNDE0N2ZjMWQ=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-01-08T03:46:45Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-01-09T16:55:37Z"}, "message": "core: add self to all vec methods", "tree": {"sha": "c4add8846e2f2aa3278dd4a205a92ecf8dd6ccd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4add8846e2f2aa3278dd4a205a92ecf8dd6ccd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f9a5079732aa22596ad27e4996189e34147fc1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f9a5079732aa22596ad27e4996189e34147fc1d", "html_url": "https://github.com/rust-lang/rust/commit/8f9a5079732aa22596ad27e4996189e34147fc1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f9a5079732aa22596ad27e4996189e34147fc1d/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc7183ed0e5da6317d7b3cc3ea25ae30e1a91bcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc7183ed0e5da6317d7b3cc3ea25ae30e1a91bcd", "html_url": "https://github.com/rust-lang/rust/commit/dc7183ed0e5da6317d7b3cc3ea25ae30e1a91bcd"}], "stats": {"total": 115, "additions": 60, "deletions": 55}, "files": [{"sha": "bf3fd8166c28aca7eb540786a3e6ba23628f97e7", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 60, "deletions": 55, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/8f9a5079732aa22596ad27e4996189e34147fc1d/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f9a5079732aa22596ad27e4996189e34147fc1d/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=8f9a5079732aa22596ad27e4996189e34147fc1d", "patch": "@@ -1539,94 +1539,96 @@ pub mod traits {\n }\n \n pub trait ConstVector {\n-    pure fn is_empty() -> bool;\n-    pure fn is_not_empty() -> bool;\n-    pure fn len() -> uint;\n+    pure fn is_empty(&self) -> bool;\n+    pure fn is_not_empty(&self) -> bool;\n+    pure fn len(&self) -> uint;\n }\n \n /// Extension methods for vectors\n impl<T> &[const T]: ConstVector {\n     /// Returns true if a vector contains no elements\n     #[inline]\n-    pure fn is_empty() -> bool { is_empty(self) }\n+    pure fn is_empty(&self) -> bool { is_empty(*self) }\n     /// Returns true if a vector contains some elements\n     #[inline]\n-    pure fn is_not_empty() -> bool { is_not_empty(self) }\n+    pure fn is_not_empty(&self) -> bool { is_not_empty(*self) }\n     /// Returns the length of a vector\n     #[inline]\n-    pure fn len() -> uint { len(self) }\n+    pure fn len(&self) -> uint { len(*self) }\n }\n \n pub trait CopyableVector<T> {\n-    pure fn head() -> T;\n-    pure fn init() -> ~[T];\n-    pure fn last() -> T;\n-    pure fn slice(start: uint, end: uint) -> ~[T];\n-    pure fn tail() -> ~[T];\n+    pure fn head(&self) -> T;\n+    pure fn init(&self) -> ~[T];\n+    pure fn last(&self) -> T;\n+    pure fn slice(&self, start: uint, end: uint) -> ~[T];\n+    pure fn tail(&self) -> ~[T];\n }\n \n /// Extension methods for vectors\n impl<T: Copy> &[const T]: CopyableVector<T> {\n     /// Returns the first element of a vector\n     #[inline]\n-    pure fn head() -> T { head(self) }\n+    pure fn head(&self) -> T { head(*self) }\n \n     /// Returns all but the last elemnt of a vector\n     #[inline]\n-    pure fn init() -> ~[T] { init(self) }\n+    pure fn init(&self) -> ~[T] { init(*self) }\n \n     /// Returns the last element of a `v`, failing if the vector is empty.\n     #[inline]\n-    pure fn last() -> T { last(self) }\n+    pure fn last(&self) -> T { last(*self) }\n \n     /// Returns a copy of the elements from [`start`..`end`) from `v`.\n     #[inline]\n-    pure fn slice(start: uint, end: uint) -> ~[T] { slice(self, start, end) }\n+    pure fn slice(&self, start: uint, end: uint) -> ~[T] {\n+        slice(*self, start, end)\n+    }\n \n     /// Returns all but the first element of a vector\n     #[inline]\n-    pure fn tail() -> ~[T] { tail(self) }\n+    pure fn tail(&self) -> ~[T] { tail(*self) }\n }\n \n pub trait ImmutableVector<T> {\n-    pure fn view(start: uint, end: uint) -> &self/[T];\n-    pure fn foldr<U: Copy>(z: U, p: fn(t: &T, u: U) -> U) -> U;\n-    pure fn map<U>(f: fn(t: &T) -> U) -> ~[U];\n-    pure fn mapi<U>(f: fn(uint, t: &T) -> U) -> ~[U];\n-    fn map_r<U>(f: fn(x: &T) -> U) -> ~[U];\n-    pure fn alli(f: fn(uint, t: &T) -> bool) -> bool;\n-    pure fn flat_map<U>(f: fn(t: &T) -> ~[U]) -> ~[U];\n-    pure fn filter_map<U: Copy>(f: fn(t: &T) -> Option<U>) -> ~[U];\n+    pure fn view(&self, start: uint, end: uint) -> &self/[T];\n+    pure fn foldr<U: Copy>(&self, z: U, p: fn(t: &T, u: U) -> U) -> U;\n+    pure fn map<U>(&self, f: fn(t: &T) -> U) -> ~[U];\n+    pure fn mapi<U>(&self, f: fn(uint, t: &T) -> U) -> ~[U];\n+    fn map_r<U>(&self, f: fn(x: &T) -> U) -> ~[U];\n+    pure fn alli(&self, f: fn(uint, t: &T) -> bool) -> bool;\n+    pure fn flat_map<U>(&self, f: fn(t: &T) -> ~[U]) -> ~[U];\n+    pure fn filter_map<U: Copy>(&self, f: fn(t: &T) -> Option<U>) -> ~[U];\n }\n \n /// Extension methods for vectors\n impl<T> &[T]: ImmutableVector<T> {\n     /// Return a slice that points into another slice.\n     #[inline]\n-    pure fn view(start: uint, end: uint) -> &self/[T] {\n-        view(self, start, end)\n+    pure fn view(&self, start: uint, end: uint) -> &self/[T] {\n+        view(*self, start, end)\n     }\n \n     /// Reduce a vector from right to left\n     #[inline]\n-    pure fn foldr<U: Copy>(z: U, p: fn(t: &T, u: U) -> U) -> U {\n-        foldr(self, z, p)\n+    pure fn foldr<U: Copy>(&self, z: U, p: fn(t: &T, u: U) -> U) -> U {\n+        foldr(*self, z, p)\n     }\n \n     /// Apply a function to each element of a vector and return the results\n     #[inline]\n-    pure fn map<U>(f: fn(t: &T) -> U) -> ~[U] { map(self, f) }\n+    pure fn map<U>(&self, f: fn(t: &T) -> U) -> ~[U] { map(*self, f) }\n \n     /**\n      * Apply a function to the index and value of each element in the vector\n      * and return the results\n      */\n-    pure fn mapi<U>(f: fn(uint, t: &T) -> U) -> ~[U] {\n-        mapi(self, f)\n+    pure fn mapi<U>(&self, f: fn(uint, t: &T) -> U) -> ~[U] {\n+        mapi(*self, f)\n     }\n \n     #[inline]\n-    fn map_r<U>(f: fn(x: &T) -> U) -> ~[U] {\n+    fn map_r<U>(&self, f: fn(x: &T) -> U) -> ~[U] {\n         let mut r = ~[];\n         let mut i = 0;\n         while i < self.len() {\n@@ -1641,16 +1643,16 @@ impl<T> &[T]: ImmutableVector<T> {\n      *\n      *     If the vector is empty, true is returned.\n      */\n-    pure fn alli(f: fn(uint, t: &T) -> bool) -> bool {\n-        alli(self, f)\n+    pure fn alli(&self, f: fn(uint, t: &T) -> bool) -> bool {\n+        alli(*self, f)\n     }\n     /**\n      * Apply a function to each element of a vector and return a concatenation\n      * of each result vector\n      */\n     #[inline]\n-    pure fn flat_map<U>(f: fn(t: &T) -> ~[U]) -> ~[U] {\n-        flat_map(self, f)\n+    pure fn flat_map<U>(&self, f: fn(t: &T) -> ~[U]) -> ~[U] {\n+        flat_map(*self, f)\n     }\n     /**\n      * Apply a function to each element of a vector and return the results\n@@ -1659,16 +1661,17 @@ impl<T> &[T]: ImmutableVector<T> {\n      * the resulting vector.\n      */\n     #[inline]\n-    pure fn filter_map<U: Copy>(f: fn(t: &T) -> Option<U>) -> ~[U] {\n-        filter_map(self, f)\n+    pure fn filter_map<U: Copy>(&self, f: fn(t: &T) -> Option<U>) -> ~[U] {\n+        filter_map(*self, f)\n     }\n+\n }\n \n pub trait ImmutableEqVector<T: Eq> {\n-    pure fn position(f: fn(t: &T) -> bool) -> Option<uint>;\n-    pure fn position_elem(t: &T) -> Option<uint>;\n-    pure fn rposition(f: fn(t: &T) -> bool) -> Option<uint>;\n-    pure fn rposition_elem(t: &T) -> Option<uint>;\n+    pure fn position(&self, f: fn(t: &T) -> bool) -> Option<uint>;\n+    pure fn position_elem(&self, t: &T) -> Option<uint>;\n+    pure fn rposition(&self, f: fn(t: &T) -> bool) -> Option<uint>;\n+    pure fn rposition_elem(&self, t: &T) -> Option<uint>;\n }\n \n impl<T: Eq> &[T]: ImmutableEqVector<T> {\n@@ -1680,14 +1683,14 @@ impl<T: Eq> &[T]: ImmutableEqVector<T> {\n      * elements then none is returned.\n      */\n     #[inline]\n-    pure fn position(f: fn(t: &T) -> bool) -> Option<uint> {\n-        position(self, f)\n+    pure fn position(&self, f: fn(t: &T) -> bool) -> Option<uint> {\n+        position(*self, f)\n     }\n \n     /// Find the first index containing a matching value\n     #[inline]\n-    pure fn position_elem(x: &T) -> Option<uint> {\n-        position_elem(self, x)\n+    pure fn position_elem(&self, x: &T) -> Option<uint> {\n+        position_elem(*self, x)\n     }\n \n     /**\n@@ -1698,21 +1701,21 @@ impl<T: Eq> &[T]: ImmutableEqVector<T> {\n      * returned. If `f` matches no elements then none is returned.\n      */\n     #[inline]\n-    pure fn rposition(f: fn(t: &T) -> bool) -> Option<uint> {\n-        rposition(self, f)\n+    pure fn rposition(&self, f: fn(t: &T) -> bool) -> Option<uint> {\n+        rposition(*self, f)\n     }\n \n     /// Find the last index containing a matching value\n     #[inline]\n-    pure fn rposition_elem(t: &T) -> Option<uint> {\n-        rposition_elem(self, t)\n+    pure fn rposition_elem(&self, t: &T) -> Option<uint> {\n+        rposition_elem(*self, t)\n     }\n }\n \n pub trait ImmutableCopyableVector<T> {\n-    pure fn filter(f: fn(t: &T) -> bool) -> ~[T];\n+    pure fn filter(&self, f: fn(t: &T) -> bool) -> ~[T];\n \n-    pure fn rfind(f: fn(t: &T) -> bool) -> Option<T>;\n+    pure fn rfind(&self, f: fn(t: &T) -> bool) -> Option<T>;\n }\n \n /// Extension methods for vectors\n@@ -1725,8 +1728,8 @@ impl<T: Copy> &[T]: ImmutableCopyableVector<T> {\n      * containing only those elements for which `f` returned true.\n      */\n     #[inline]\n-    pure fn filter(f: fn(t: &T) -> bool) -> ~[T] {\n-        filter(self, f)\n+    pure fn filter(&self, f: fn(t: &T) -> bool) -> ~[T] {\n+        filter(*self, f)\n     }\n \n     /**\n@@ -1737,7 +1740,9 @@ impl<T: Copy> &[T]: ImmutableCopyableVector<T> {\n      * returned. If `f` matches no elements then none is returned.\n      */\n     #[inline]\n-    pure fn rfind(f: fn(t: &T) -> bool) -> Option<T> { rfind(self, f) }\n+    pure fn rfind(&self, f: fn(t: &T) -> bool) -> Option<T> {\n+        rfind(*self, f)\n+    }\n }\n \n pub trait OwnedVector<T> {"}]}