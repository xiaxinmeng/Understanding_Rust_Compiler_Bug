{"sha": "9b67d099f50aca92c788d2e5b63b3efe02ea7951", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliNjdkMDk5ZjUwYWNhOTJjNzg4ZDJlNWI2M2IzZWZlMDJlYTc5NTE=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-03-15T11:25:58Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-03-21T17:36:23Z"}, "message": "Switch newtype Index wrappers to use NonZero instead of INVALID constants.", "tree": {"sha": "2b0006a231da76c5efdf6cd91b347fed411d85f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b0006a231da76c5efdf6cd91b347fed411d85f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b67d099f50aca92c788d2e5b63b3efe02ea7951", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b67d099f50aca92c788d2e5b63b3efe02ea7951", "html_url": "https://github.com/rust-lang/rust/commit/9b67d099f50aca92c788d2e5b63b3efe02ea7951", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b67d099f50aca92c788d2e5b63b3efe02ea7951/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d53a25b38b5dfd3e2d60eede247116e2ffff9a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d53a25b38b5dfd3e2d60eede247116e2ffff9a2", "html_url": "https://github.com/rust-lang/rust/commit/7d53a25b38b5dfd3e2d60eede247116e2ffff9a2"}], "stats": {"total": 166, "additions": 88, "deletions": 78}, "files": [{"sha": "69aaae91c49fa38132a40669598cd4c225bab02a", "filename": "src/librustc_borrowck/borrowck/mir/dataflow.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9b67d099f50aca92c788d2e5b63b3efe02ea7951/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67d099f50aca92c788d2e5b63b3efe02ea7951/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs?ref=9b67d099f50aca92c788d2e5b63b3efe02ea7951", "patch": "@@ -56,7 +56,7 @@ impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n                                      &move_data.move_paths,\n                                      move_path_index,\n                                      &|in_out, mpi| {\n-                                         in_out.clear_bit(mpi.idx().unwrap());\n+                                         in_out.clear_bit(mpi.idx());\n                                      });\n             },\n         };\n@@ -109,7 +109,7 @@ impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n                                              move_paths,\n                                              move_path_index,\n                                              &|kill_set, mpi| {\n-                                                 kill_set.set_bit(mpi.idx().unwrap());\n+                                                 kill_set.set_bit(mpi.idx());\n                                              });\n                     }\n                 }\n@@ -124,7 +124,7 @@ impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n         }\n \n         fn zero_to_one(gen_set: &mut [usize], move_index: MoveOutIndex) {\n-            let retval = gen_set.set_bit(move_index.idx().unwrap());\n+            let retval = gen_set.set_bit(move_index.idx());\n             assert!(retval);\n         }\n     }\n@@ -137,8 +137,6 @@ fn on_all_children_bits<Each>(set: &mut [usize],\n                               each_child: &Each)\n     where Each: Fn(&mut [usize], MoveOutIndex)\n {\n-    assert!(move_path_index.idx().is_some());\n-\n     // 1. invoke `each_child` callback for all moves that directly\n     //    influence path for `move_path_index`\n     for move_index in &path_map[move_path_index] {\n@@ -150,10 +148,10 @@ fn on_all_children_bits<Each>(set: &mut [usize],\n     //\n     // (Unnamed children are irrelevant to dataflow; by\n     // definition they have no associated moves.)\n-    let mut child_index = move_paths[move_path_index].first_child;\n-    while let Some(_) = child_index.idx() {\n+    let mut next_child_index = move_paths[move_path_index].first_child;\n+    while let Some(child_index) = next_child_index {\n         on_all_children_bits(set, path_map, move_paths, child_index, each_child);\n-        child_index = move_paths[child_index].next_sibling;\n+        next_child_index = move_paths[child_index].next_sibling;\n     }\n }\n "}, {"sha": "5b28852f193decd14a693dd2302934efb1c3bb36", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 80, "deletions": 70, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/9b67d099f50aca92c788d2e5b63b3efe02ea7951/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67d099f50aca92c788d2e5b63b3efe02ea7951/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=9b67d099f50aca92c788d2e5b63b3efe02ea7951", "patch": "@@ -20,36 +20,43 @@ use std::collections::hash_map::Entry;\n use std::fmt;\n use std::iter;\n use std::ops::Index;\n-use std::usize;\n \n use super::dataflow::BitDenotation;\n use super::abs_domain::{AbstractElem, Lift};\n \n-macro_rules! new_index {\n-    ($Index:ident, $INVALID_INDEX:ident) => {\n-        #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-        pub struct $Index(usize);\n-\n-        const $INVALID_INDEX: $Index = $Index(usize::MAX);\n-\n-        impl $Index {\n-            pub fn idx(&self) -> Option<usize> {\n-                if *self == $INVALID_INDEX {\n-                    None\n-                } else {\n-                    Some(self.0)\n+// This submodule holds some newtype'd Index wrappers that are using\n+// NonZero to ensure that Option<Index> occupies only a single word.\n+// They are in a submodule to impose privacy restrictions; namely, to\n+// ensure that other code does not accidentally access `index.0`\n+// (which is likely to yield a subtle off-by-one error).\n+mod indexes {\n+    use core::nonzero::NonZero;\n+\n+    macro_rules! new_index {\n+        ($Index:ident) => {\n+            #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+            pub struct $Index(NonZero<usize>);\n+\n+            impl $Index {\n+                pub fn new(idx: usize) -> Self {\n+                    unsafe { $Index(NonZero::new(idx + 1)) }\n+                }\n+                pub fn idx(&self) -> usize {\n+                    *self.0 - 1\n                 }\n             }\n         }\n     }\n-}\n \n-/// Index into MovePathData.move_paths\n-new_index!(MovePathIndex, INVALID_MOVE_PATH_INDEX);\n+    /// Index into MovePathData.move_paths\n+    new_index!(MovePathIndex);\n \n-/// Index into MoveData.moves.\n-new_index!(MoveOutIndex, INVALID_MOVE_OUT_INDEX);\n+    /// Index into MoveData.moves.\n+    new_index!(MoveOutIndex);\n+}\n \n+pub use self::indexes::MovePathIndex;\n+pub use self::indexes::MoveOutIndex;\n \n /// `MovePath` is a canonicalized representation of a path that is\n /// moved or assigned to.\n@@ -65,9 +72,9 @@ new_index!(MoveOutIndex, INVALID_MOVE_OUT_INDEX);\n /// they both have the MovePath representing `x` as their parent.\n #[derive(Clone)]\n pub struct MovePath<'tcx> {\n-    pub next_sibling: MovePathIndex,\n-    pub first_child: MovePathIndex,\n-    pub parent: MovePathIndex,\n+    pub next_sibling: Option<MovePathIndex>,\n+    pub first_child: Option<MovePathIndex>,\n+    pub parent: Option<MovePathIndex>,\n     pub lvalue: Lvalue<'tcx>,\n }\n \n@@ -76,9 +83,9 @@ pub struct MovePath<'tcx> {\n /// children of each path.\n #[derive(Clone)]\n struct PreMovePath<'tcx> {\n-    pub next_sibling: MovePathIndex,\n-    pub first_child: Cell<MovePathIndex>,\n-    pub parent: MovePathIndex,\n+    pub next_sibling: Option<MovePathIndex>,\n+    pub first_child: Cell<Option<MovePathIndex>>,\n+    pub parent: Option<MovePathIndex>,\n     pub lvalue: Lvalue<'tcx>,\n }\n \n@@ -96,14 +103,14 @@ impl<'tcx> PreMovePath<'tcx> {\n impl<'tcx> fmt::Debug for MovePath<'tcx> {\n     fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(w, \"MovePath {{\"));\n-        if self.parent != INVALID_MOVE_PATH_INDEX {\n-            try!(write!(w, \" parent: {:?},\", self.parent));\n+        if let Some(parent) = self.parent {\n+            try!(write!(w, \" parent: {:?},\", parent));\n         }\n-        if self.first_child != INVALID_MOVE_PATH_INDEX {\n-            try!(write!(w, \" first_child: {:?},\", self.first_child));\n+        if let Some(first_child) = self.first_child {\n+            try!(write!(w, \" first_child: {:?},\", first_child));\n         }\n-        if self.next_sibling != INVALID_MOVE_PATH_INDEX {\n-            try!(write!(w, \" next_sibling: {:?}\", self.next_sibling));\n+        if let Some(next_sibling) = self.next_sibling {\n+            try!(write!(w, \" next_sibling: {:?}\", next_sibling));\n         }\n         write!(w, \" lvalue: {:?} }}\", self.lvalue)\n     }\n@@ -147,8 +154,7 @@ pub struct PathMap {\n impl Index<MovePathIndex> for PathMap {\n     type Output = [MoveOutIndex];\n     fn index(&self, index: MovePathIndex) -> &Self::Output {\n-        assert!(index != INVALID_MOVE_PATH_INDEX);\n-        &self.map[index.0]\n+        &self.map[index.idx()]\n     }\n }\n \n@@ -168,7 +174,7 @@ pub struct MoveOut {\n \n impl fmt::Debug for MoveOut {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"p{}@{:?}\", self.path.0, self.source)\n+        write!(fmt, \"p{}@{:?}\", self.path.idx(), self.source)\n     }\n }\n \n@@ -194,13 +200,13 @@ pub struct MovePathData<'tcx> {\n impl<'tcx> Index<MovePathIndex> for MovePathData<'tcx> {\n     type Output = MovePath<'tcx>;\n     fn index(&self, i: MovePathIndex) -> &MovePath<'tcx> {\n-        &self.move_paths[i.idx().unwrap()]\n+        &self.move_paths[i.idx()]\n     }\n }\n \n-/// MovePathRevIndex maps from a uint in an lvalue-category to the\n+/// MovePathInverseMap maps from a uint in an lvalue-category to the\n /// MovePathIndex for the MovePath for that lvalue.\n-type MovePathRevIndex = Vec<MovePathIndex>;\n+type MovePathInverseMap = Vec<Option<MovePathIndex>>;\n \n struct MovePathDataBuilder<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n@@ -210,9 +216,9 @@ struct MovePathDataBuilder<'a, 'tcx: 'a> {\n \n /// Tables mapping from an l-value to its MovePathIndex.\n pub struct MovePathLookup<'tcx> {\n-    vars: MovePathRevIndex,\n-    temps: MovePathRevIndex,\n-    args: MovePathRevIndex,\n+    vars: MovePathInverseMap,\n+    temps: MovePathInverseMap,\n+    args: MovePathInverseMap,\n     statics: FnvHashMap<DefId, MovePathIndex>,\n     return_ptr: Option<MovePathIndex>,\n \n@@ -254,7 +260,7 @@ enum LookupKind { Generate, Reuse }\n struct Lookup<T>(LookupKind, T);\n \n impl Lookup<MovePathIndex> {\n-    fn idx(&self) -> usize { (self.1).0 }\n+    fn idx(&self) -> usize { (self.1).idx() }\n }\n \n impl<'tcx> MovePathLookup<'tcx> {\n@@ -266,28 +272,31 @@ impl<'tcx> MovePathLookup<'tcx> {\n             statics: Default::default(),\n             return_ptr: None,\n             projections: vec![],\n-            next_index: MovePathIndex(0),\n+            next_index: MovePathIndex::new(0),\n         }\n     }\n \n     fn next_index(next: &mut MovePathIndex) -> MovePathIndex {\n         let i = *next;\n-        *next = MovePathIndex(i.0 + 1);\n+        *next = MovePathIndex::new(i.idx() + 1);\n         i\n     }\n \n-    fn lookup_or_generate(vec: &mut Vec<MovePathIndex>,\n+    fn lookup_or_generate(vec: &mut Vec<Option<MovePathIndex>>,\n                           idx: u32,\n                           next_index: &mut MovePathIndex) -> Lookup<MovePathIndex> {\n         let idx = idx as usize;\n-        vec.fill_to_with(idx, INVALID_MOVE_PATH_INDEX);\n+        vec.fill_to_with(idx, None);\n         let entry = &mut vec[idx];\n-        if *entry == INVALID_MOVE_PATH_INDEX {\n-            let i = Self::next_index(next_index);\n-            *entry = i;\n-            Lookup(LookupKind::Generate, i)\n-        } else {\n-            Lookup(LookupKind::Reuse, *entry)\n+        match *entry {\n+            None => {\n+                let i = Self::next_index(next_index);\n+                *entry = Some(i);\n+                Lookup(LookupKind::Generate, i)\n+            }\n+            Some(entry_idx) => {\n+                Lookup(LookupKind::Reuse, entry_idx)\n+            }\n         }\n     }\n \n@@ -342,8 +351,8 @@ impl<'tcx> MovePathLookup<'tcx> {\n                    base: MovePathIndex) -> Lookup<MovePathIndex> {\n         let MovePathLookup { ref mut projections,\n                              ref mut next_index, .. } = *self;\n-        projections.fill_to(base.0);\n-        match projections[base.0].entry(proj.elem.lift()) {\n+        projections.fill_to(base.idx());\n+        match projections[base.idx()].entry(proj.elem.lift()) {\n             Entry::Occupied(ent) => {\n                 Lookup(LookupKind::Reuse, *ent.get())\n             }\n@@ -362,14 +371,14 @@ impl<'tcx> MovePathLookup<'tcx> {\n     // unknown l-value; it will simply panic.\n     pub fn find(&self, lval: &Lvalue<'tcx>) -> MovePathIndex {\n         match *lval {\n-            Lvalue::Var(var_idx) => self.vars[var_idx as usize],\n-            Lvalue::Temp(temp_idx) => self.temps[temp_idx as usize],\n-            Lvalue::Arg(arg_idx) => self.args[arg_idx as usize],\n+            Lvalue::Var(var_idx) => self.vars[var_idx as usize].unwrap(),\n+            Lvalue::Temp(temp_idx) => self.temps[temp_idx as usize].unwrap(),\n+            Lvalue::Arg(arg_idx) => self.args[arg_idx as usize].unwrap(),\n             Lvalue::Static(ref def_id) => self.statics[def_id],\n             Lvalue::ReturnPointer => self.return_ptr.unwrap(),\n             Lvalue::Projection(ref proj) => {\n                 let base_index = self.find(&proj.base);\n-                self.projections[base_index.0 as usize][&proj.elem.lift()]\n+                self.projections[base_index.idx()][&proj.elem.lift()]\n             }\n         }\n     }\n@@ -418,8 +427,8 @@ impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n             match *lval {\n                 Lvalue::Var(_) | Lvalue::Temp(_) | Lvalue::Arg(_) |\n                 Lvalue::Static(_) | Lvalue::ReturnPointer => {\n-                    sibling = INVALID_MOVE_PATH_INDEX;\n-                    parent = INVALID_MOVE_PATH_INDEX;\n+                    sibling = None;\n+                    parent = None;\n                 }\n                 Lvalue::Projection(ref proj) => {\n                     // Here, install new MovePath as new first_child.\n@@ -428,22 +437,23 @@ impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n \n                     // Note: `parent` previously allocated (Projection\n                     // case of match above established this).\n-                    parent = self.move_path_for(&proj.base);\n+                    let idx = self.move_path_for(&proj.base);\n+                    parent = Some(idx);\n \n                     pre_move_paths = self.pre_move_paths.borrow_mut();\n-                    let parent_move_path = &mut pre_move_paths[parent.0];\n+                    let parent_move_path = &mut pre_move_paths[idx.idx()];\n \n                     // At last: Swap in the new first_child.\n                     sibling = parent_move_path.first_child.get();\n-                    parent_move_path.first_child.set(mpi);\n+                    parent_move_path.first_child.set(Some(mpi));\n                 }\n             };\n \n             let move_path = PreMovePath {\n                 next_sibling: sibling,\n                 parent: parent,\n                 lvalue: lval.clone(),\n-                first_child: Cell::new(INVALID_MOVE_PATH_INDEX),\n+                first_child: Cell::new(None),\n             };\n \n             pre_move_paths.push(move_path);\n@@ -610,8 +620,8 @@ fn gather_moves<'tcx>(mir: &Mir<'tcx>, tcx: &ty::TyCtxt<'tcx>) -> MoveData<'tcx>\n         let mut seen: Vec<_> = move_paths.iter().map(|_| false).collect();\n         for (j, &MoveOut { ref path, ref source }) in moves.iter().enumerate() {\n             debug!(\"MovePathData moves[{}]: MoveOut {{ path: {:?} = {:?}, source: {:?} }}\",\n-                   j, path, move_paths[path.0], source);\n-            seen[path.0] = true;\n+                   j, path, move_paths[path.idx()], source);\n+            seen[path.idx()] = true;\n         }\n         for (j, path) in move_paths.iter().enumerate() {\n             if !seen[j] {\n@@ -664,24 +674,24 @@ impl<'b, 'a: 'b, 'tcx: 'a> BlockContext<'b, 'a, 'tcx> {\n             return;\n         }\n         let i = source.index;\n-        let index = MoveOutIndex(self.moves.len());\n+        let index = MoveOutIndex::new(self.moves.len());\n \n         let path = builder.move_path_for(lval);\n         self.moves.push(MoveOut { path: path, source: source.clone() });\n-        self.path_map.fill_to(path.0);\n+        self.path_map.fill_to(path.idx());\n \n         debug!(\"ctxt: {:?} add consume of lval: {:?} \\\n                 at index: {:?} \\\n                 to path_map for path: {:?} and \\\n                 to loc_map for loc: {:?}\",\n                stmt_kind, lval, index, path, source);\n \n-        debug_assert!(path.0 < self.path_map.len());\n+        debug_assert!(path.idx() < self.path_map.len());\n         // this is actually a questionable assert; at the very\n         // least, incorrect input code can probably cause it to\n         // fire.\n-        assert!(self.path_map[path.0].iter().find(|idx| **idx == index).is_none());\n-        self.path_map[path.0].push(index);\n+        assert!(self.path_map[path.idx()].iter().find(|idx| **idx == index).is_none());\n+        self.path_map[path.idx()].push(index);\n \n         debug_assert!(i < self.loc_map_bb.len());\n         debug_assert!(self.loc_map_bb[i].iter().find(|idx| **idx == index).is_none());"}, {"sha": "65e9b79224181a8abd4fb763241acf4d96a8518a", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b67d099f50aca92c788d2e5b63b3efe02ea7951/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b67d099f50aca92c788d2e5b63b3efe02ea7951/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=9b67d099f50aca92c788d2e5b63b3efe02ea7951", "patch": "@@ -24,6 +24,7 @@\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(associated_consts)]\n+#![feature(nonzero)]\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n \n@@ -33,6 +34,7 @@ extern crate graphviz as dot;\n extern crate rustc;\n extern crate rustc_front;\n extern crate rustc_mir;\n+extern crate core; // for NonZero\n \n pub use borrowck::check_crate;\n pub use borrowck::build_borrowck_dataflow_data_for_fn;"}]}