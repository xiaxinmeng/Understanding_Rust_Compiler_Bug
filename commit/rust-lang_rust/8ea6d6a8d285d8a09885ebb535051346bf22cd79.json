{"sha": "8ea6d6a8d285d8a09885ebb535051346bf22cd79", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlYTZkNmE4ZDI4NWQ4YTA5ODg1ZWJiNTM1MDUxMzQ2YmYyMmNkNzk=", "commit": {"author": {"name": "Yati Sagade", "email": "yati.sagade@gmail.com", "date": "2017-04-09T12:07:11Z"}, "committer": {"name": "Yati Sagade", "email": "yati.sagade@gmail.com", "date": "2017-04-09T12:07:11Z"}, "message": "needless_continue: Refactor to use stuff from utils, and move some stuff to utils.\n\nI had my own implementation of what `trim_multiline()` seems to be doing, so\nI just started using `trim_multiline()`. Some other functions, like\nthose block alignment, are general enough to be used elsewhere, so moved\nthem to utils.", "tree": {"sha": "ade377e3c5cfe7cd7d754c5d9095a10e073b8301", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ade377e3c5cfe7cd7d754c5d9095a10e073b8301"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ea6d6a8d285d8a09885ebb535051346bf22cd79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ea6d6a8d285d8a09885ebb535051346bf22cd79", "html_url": "https://github.com/rust-lang/rust/commit/8ea6d6a8d285d8a09885ebb535051346bf22cd79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ea6d6a8d285d8a09885ebb535051346bf22cd79/comments", "author": {"login": "yati-sagade", "id": 966274, "node_id": "MDQ6VXNlcjk2NjI3NA==", "avatar_url": "https://avatars.githubusercontent.com/u/966274?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yati-sagade", "html_url": "https://github.com/yati-sagade", "followers_url": "https://api.github.com/users/yati-sagade/followers", "following_url": "https://api.github.com/users/yati-sagade/following{/other_user}", "gists_url": "https://api.github.com/users/yati-sagade/gists{/gist_id}", "starred_url": "https://api.github.com/users/yati-sagade/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yati-sagade/subscriptions", "organizations_url": "https://api.github.com/users/yati-sagade/orgs", "repos_url": "https://api.github.com/users/yati-sagade/repos", "events_url": "https://api.github.com/users/yati-sagade/events{/privacy}", "received_events_url": "https://api.github.com/users/yati-sagade/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yati-sagade", "id": 966274, "node_id": "MDQ6VXNlcjk2NjI3NA==", "avatar_url": "https://avatars.githubusercontent.com/u/966274?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yati-sagade", "html_url": "https://github.com/yati-sagade", "followers_url": "https://api.github.com/users/yati-sagade/followers", "following_url": "https://api.github.com/users/yati-sagade/following{/other_user}", "gists_url": "https://api.github.com/users/yati-sagade/gists{/gist_id}", "starred_url": "https://api.github.com/users/yati-sagade/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yati-sagade/subscriptions", "organizations_url": "https://api.github.com/users/yati-sagade/orgs", "repos_url": "https://api.github.com/users/yati-sagade/repos", "events_url": "https://api.github.com/users/yati-sagade/events{/privacy}", "received_events_url": "https://api.github.com/users/yati-sagade/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ee34e7851362aa8e01afd06fcc824864d10e02f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ee34e7851362aa8e01afd06fcc824864d10e02f", "html_url": "https://github.com/rust-lang/rust/commit/1ee34e7851362aa8e01afd06fcc824864d10e02f"}], "stats": {"total": 364, "additions": 229, "deletions": 135}, "files": [{"sha": "5784032b750e0a5550908152ad8a23a13540e352", "filename": "clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 41, "deletions": 135, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/8ea6d6a8d285d8a09885ebb535051346bf22cd79/clippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea6d6a8d285d8a09885ebb535051346bf22cd79/clippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_continue.rs?ref=8ea6d6a8d285d8a09885ebb535051346bf22cd79", "patch": "@@ -27,12 +27,13 @@\n //! ```\n //!\n //! This lint is **warn** by default.\n-use std;\n use rustc::lint::*;\n use syntax::ast;\n use syntax::codemap::{original_sp,DUMMY_SP};\n+use std::borrow::Cow;\n \n-use utils::{in_macro, span_help_and_lint, snippet_block, snippet};\n+use utils::{in_macro, span_help_and_lint, snippet_block, snippet, trim_multiline,\n+            left_pad_lines_with_spaces, align_snippets};\n \n /// **What it does:** The lint checks for `if`-statements appearing in loops\n /// that contain a `continue` statement in either their main blocks or their\n@@ -110,7 +111,7 @@ impl LintPass for NeedlessContinue {\n \n impl EarlyLintPass for NeedlessContinue {\n     fn check_expr(&mut self, ctx: &EarlyContext, expr: &ast::Expr) {\n-        if !in_macro(ctx, expr.span) {\n+        if !in_macro(expr.span) {\n             check_and_warn(ctx, expr);\n         }\n     }\n@@ -290,7 +291,7 @@ fn suggestion_snippet_for_continue_inside_if<'a>(ctx: &EarlyContext,\n     // region B\n     let else_code = snippet(ctx, data.else_expr.span, \"..\").into_owned();\n     let else_code = erode_block(&else_code);\n-    let else_code = trim_indent(&else_code, false);\n+    let else_code = trim_multiline(Cow::from(else_code), false);\n \n     let mut ret = String::from(header);\n     ret.push_str(&if_code);\n@@ -309,7 +310,7 @@ fn suggestion_snippet_for_continue_inside_else<'a>(ctx: &EarlyContext,\n     // Region B\n     let block_code = &snippet(ctx, data.if_block.span, \"..\").into_owned();\n     let block_code = erode_block(block_code);\n-    let block_code = trim_indent(&block_code, false);\n+    let block_code = trim_multiline(Cow::from(block_code), false);\n     let block_code = left_pad_lines_with_spaces(&block_code, 4_usize);\n \n     if_code.push_str(&block_code);\n@@ -321,7 +322,7 @@ fn suggestion_snippet_for_continue_inside_else<'a>(ctx: &EarlyContext,\n     let to_annex = data.block_stmts[data.stmt_idx+1..]\n                    .iter()\n                    .map(|stmt| {\n-                        original_sp(ctx.sess().codemap(), stmt.span, DUMMY_SP)\n+                        original_sp(stmt.span, DUMMY_SP)\n                     })\n                    .map(|span| snippet_block(ctx, span, \"..\").into_owned())\n                    .collect::<Vec<_>>().join(\"\\n\");\n@@ -360,19 +361,21 @@ fn check_and_warn<'a>(ctx: &EarlyContext, expr: &'a ast::Expr) {\n /// continues eating till a non-whitespace character is found.\n /// e.g., the string\n ///\n-/// \"\n-/// {\n-///     let x = 5;\n-/// }\n-/// \"\n+///     \"\n+///     {\n+///         let x = 5;\n+///     }\n+///     \"\n ///\n /// is transformed to\n ///\n-/// \"\n-/// {\n-///     let x = 5;\"\n+///     \"\n+///     {\n+///         let x = 5;\"\n ///\n-fn erode_from_back(s: &str) -> String {\n+/// NOTE: when there is no closing brace in `s`, `s` is _not_ preserved, i.e.,\n+/// an empty string will be returned in that case.\n+pub fn erode_from_back(s: &str) -> String {\n     let mut ret = String::from(s);\n     while ret.pop().map_or(false, |c| c != '}') { }\n     while let Some(c) = ret.pop() {\n@@ -384,132 +387,35 @@ fn erode_from_back(s: &str) -> String {\n     ret\n }\n \n-fn erode_from_front(s: &str) -> String {\n+/// Eats at `s` from the front by first skipping all leading whitespace. Then,\n+/// any number of opening braces are eaten, followed by any number of newlines.\n+/// e.g.,  the string\n+///\n+///     \"\n+///         {\n+///             something();\n+///             inside_a_block();\n+///         }\n+///     \"\n+///\n+/// is transformed to\n+///\n+///     \"        something();\n+///             inside_a_block();\n+///         }\n+///     \"\n+///\n+pub fn erode_from_front(s: &str) -> String {\n     s.chars()\n      .skip_while(|c| c.is_whitespace())\n      .skip_while(|c| *c == '{')\n      .skip_while(|c| *c == '\\n')\n      .collect::<String>()\n }\n \n-fn erode_block(s: &str) -> String {\n+/// If `s` contains the code for a block, delimited by braces, this function\n+/// tries to get the contents of the block. If there is no closing brace present,\n+/// an empty string is returned.\n+pub fn erode_block(s: &str) -> String {\n     erode_from_back(&erode_from_front(s))\n }\n-\n-fn is_all_whitespace(s: &str) -> bool { s.chars().all(|c| c.is_whitespace()) }\n-\n-/// Returns true if a string is empty or just spaces.\n-fn is_null(s: &str) -> bool { s.is_empty() || is_all_whitespace(s) }\n-\n-/// Returns the indentation level of a string. It just returns the count of\n-/// whitespace characters in the string before a non-whitespace character\n-/// is encountered.\n-fn indent_level(s: &str) -> usize {\n-    s.chars()\n-     .enumerate()\n-     .find(|&(_, c)| !c.is_whitespace())\n-     .map_or(0_usize, |(i, _)| i)\n-}\n-\n-/// Trims indentation from a snippet such that the line with the minimum\n-/// indentation has no indentation after the trasformation.\n-fn trim_indent(s: &str, skip_first_line: bool) -> String {\n-    let min_indent_level = s.lines()\n-                            .filter(|line| !is_null(line))\n-                            .skip(skip_first_line as usize)\n-                            .map(indent_level)\n-                            .min()\n-                            .unwrap_or(0_usize);\n-    let ret = s.lines().map(|line| {\n-        if is_null(line) {\n-            String::from(line)\n-        } else {\n-            line.chars()\n-                .enumerate()\n-                .skip_while(|&(i, c)| c.is_whitespace() && i < min_indent_level)\n-                .map(|pair| pair.1)\n-                .collect::<String>()\n-        }\n-    }).collect::<Vec<String>>();\n-    ret.join(\"\\n\")\n-}\n-\n-/// Add `n` spaces to the left of `s`.\n-fn left_pad_with_spaces(s: &str, n: usize) -> String {\n-    let mut new_s = std::iter::repeat(' '/* <-space */).take(n).collect::<String>();\n-    new_s.push_str(s);\n-    new_s\n-}\n-\n-/// Add `n` spaces to the left of each line in `s` and return the result\n-/// in a new String.\n-fn left_pad_lines_with_spaces(s: &str, n: usize) -> String {\n-    s.lines()\n-     .map(|line| left_pad_with_spaces(line, n))\n-     .collect::<Vec<_>>()\n-     .join(\"\\n\")\n-}\n-\n-/// Remove upto `n` whitespace characters from the beginning of `s`.\n-fn remove_whitespace_from_left(s: &str, n: usize) -> String {\n-    s.chars()\n-     .enumerate()\n-     .skip_while(|&(i, c)| i < n && c.is_whitespace())\n-     .map(|(_, c)| c)\n-     .collect::<String>()\n-}\n-\n-/// Aligns two snippets such that the indentation level of the last non-empty,\n-/// non-space line of the first snippet matches the first non-empty, non-space\n-/// line of the second.\n-fn align_two_snippets(s: &str, t: &str) -> String {\n-    // indent level of the last nonempty, non-whitespace line of s.\n-    let target_ilevel = s.lines()\n-                         .rev()\n-                         .skip_while(|line| line.is_empty() || is_all_whitespace(line))\n-                         .next()\n-                         .map_or(0_usize, indent_level);\n-\n-    // We want to align the first nonempty, non-all-whitespace line of t to\n-    // have the same indent level as target_ilevel\n-    let level = t.lines()\n-                 .skip_while(|line| line.is_empty() || is_all_whitespace(line))\n-                 .next()\n-                 .map_or(0_usize, indent_level);\n-\n-    let add_or_not_remove = target_ilevel > level; /* when true, we add spaces,\n-                                                      otherwise eat. */\n-\n-    let delta = if add_or_not_remove {\n-        target_ilevel - level\n-    } else {\n-        level - target_ilevel\n-    };\n-\n-    let new_t = t.lines()\n-                 .filter_map(|line| {\n-                     if is_null(line) {\n-                         None\n-                     } else if add_or_not_remove {\n-                         Some(left_pad_with_spaces(line, delta))\n-                     } else {\n-                         Some(remove_whitespace_from_left(line, delta))\n-                     }\n-                 })\n-                 .collect::<Vec<_>>().join(\"\\n\");\n-\n-    format!(\"{}\\n{}\", s, new_t)\n-}\n-\n-fn align_snippets(xs: &[&str]) -> String {\n-    if xs.is_empty() {\n-        String::from(\"\")\n-    } else {\n-        let mut ret = xs[0].to_string();\n-        for x in xs.iter().skip(1_usize) {\n-            ret = align_two_snippets(&ret, x);\n-        }\n-        ret\n-    }\n-}\n-"}, {"sha": "2e35140cdf55eb8dd7fdd175bdd8ba4c1c572753", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/8ea6d6a8d285d8a09885ebb535051346bf22cd79/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea6d6a8d285d8a09885ebb535051346bf22cd79/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=8ea6d6a8d285d8a09885ebb535051346bf22cd79", "patch": "@@ -22,6 +22,7 @@ use syntax::codemap::{ExpnFormat, ExpnInfo, MultiSpan, Span, DUMMY_SP};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n+use std::iter;\n \n pub mod comparisons;\n pub mod conf;\n@@ -978,3 +979,190 @@ pub fn type_size<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>) -> Opti\n         .infer_ctxt((), Reveal::All)\n         .enter(|infcx| ty.layout(&infcx).ok().map(|lay| lay.size(&TargetDataLayout::parse(cx.sess())).bytes()))\n }\n+\n+/// Add `n` spaces to the left of `s`.\n+pub fn left_pad_with_spaces(s: &str, n: usize) -> String {\n+    let mut new_s = iter::repeat(' ').take(n).collect::<String>();\n+    new_s.push_str(s);\n+    new_s\n+}\n+\n+/// Add `n` spaces to the left of each line in `s` and return the result\n+/// in a new String.\n+/// e.g., when n = 2, the string\n+///\n+///     \"   fn foo() {\n+///             bar()\n+///         }\"\n+///\n+/// becomes\n+///\n+///     \"     fn foo() {\n+///               bar()\n+///           }\"\n+///\n+/// # Example\n+///\n+/// ```\n+/// use clippy_lints::utils::left_pad_with_spaces;\n+///\n+/// let input = \"\\\n+/// fn main() {\n+///     println!(\"hello world!\");\n+/// }\";\n+///\n+/// let expected =\n+/// \"    fn main() {\n+///         println!(\"hello world!\");\n+///      }\";\n+///\n+/// assert_eq!(expected, input);\n+/// ```\n+pub fn left_pad_lines_with_spaces(s: &str, n: usize) -> String {\n+    s.lines()\n+     .map(|line| left_pad_with_spaces(line, n))\n+     .collect::<Vec<_>>()\n+     .join(\"\\n\")\n+}\n+\n+/// Remove upto `n` whitespace characters from the beginning of `s`.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// let s = \"    foobar  \";\n+/// assert_eq!(\"foobar \", remove_whitespace_from_left(s, 100));\n+/// assert_eq!(\"  foobar \", remove_whitespace_from_left(s, 2));\n+/// assert_eq(\"\", remove_whitespace_from_left(\"   \", 50));\n+/// ```\n+pub fn remove_whitespace_from_left(s: &str, n: usize) -> String {\n+    s.chars()\n+     .enumerate()\n+     .skip_while(|&(i, c)| i < n && c.is_whitespace())\n+     .map(|(_, c)| c)\n+     .collect::<String>()\n+}\n+\n+/// Aligns two snippets such that the indentation level of the last non-empty,\n+/// non-space line of the first snippet matches the first non-empty, non-space\n+/// line of the second.\n+pub fn align_two_snippets(s: &str, t: &str) -> String {\n+    // indent level of the last nonempty, non-whitespace line of s.\n+    let target_ilevel = s.lines()\n+                         .rev()\n+                         .skip_while(|line| line.is_empty() || is_all_whitespace(line))\n+                         .next()\n+                         .map_or(0_usize, indent_level);\n+\n+    // We want to align the first nonempty, non-all-whitespace line of t to\n+    // have the same indent level as target_ilevel\n+    let level = t.lines()\n+                 .skip_while(|line| line.is_empty() || is_all_whitespace(line))\n+                 .next()\n+                 .map_or(0_usize, indent_level);\n+\n+    // When add_spaces=true, we add spaces, otherwise eat.\n+    let add_spaces = target_ilevel > level;\n+\n+    let delta = if add_spaces {\n+        target_ilevel - level\n+    } else {\n+        level - target_ilevel\n+    };\n+\n+    let new_t = t.lines()\n+                 .map(|line| {\n+                     if is_null(line) {\n+                         // leave empty lines alone\n+                         String::from(line)\n+                     } else if add_spaces {\n+                         left_pad_with_spaces(line, delta)\n+                     } else {\n+                         remove_whitespace_from_left(line, delta)\n+                     }\n+                 })\n+                 .collect::<Vec<_>>().join(\"\\n\");\n+\n+    format!(\"{}\\n{}\", s, new_t)\n+}\n+\n+/// Aligns strings in `xs` pairwise from the start, such that for any pair of\n+/// strings, the first string's last line is aligned with the first line of\n+/// the second string. See `align_two_snippets`. Use this to merge code regions\n+/// into a reasonably aligned chunk of code.\n+///\n+/// For example, consider\n+///\n+///         let s1 = \"\\\n+///     if (condition()) {\n+///         do_something()\";\n+///\n+///         let s2 = \"\\\n+///             code_from_somewhere_else();\"\n+///\n+///         let s3 = \"\\\n+///     another_piece_of_code();\n+///         indented_here();\";\n+///\n+///\n+///\n+///\n+/// Now calling `align_snippets(&[s1, s2, s3])` will yield the following:\n+///\n+///     \"\\\n+///     if (condition()) {\n+///         do_something();\n+///         code_from_somewhere_else();\n+///         another_piece_of_code();\n+///             indented_here();\"\n+pub fn align_snippets(xs: &[&str]) -> String {\n+    if xs.is_empty() {\n+        String::from(\"\")\n+    } else {\n+        let mut ret = xs[0].to_string();\n+        for x in xs.iter().skip(1_usize) {\n+            ret = align_two_snippets(&ret, x);\n+        }\n+        ret\n+    }\n+}\n+\n+\n+/// # Examples\n+/// ```\n+/// use clippy_lints::utils::is_all_whitespace;\n+///\n+/// assert_eq!(true, \"   \\n\\t  \");\n+/// assert_eq!(false, \"\");\n+/// assert_eq!(false, \"hello world!\\n\");\n+/// ```\n+pub fn is_all_whitespace(s: &str) -> bool {\n+    s.chars().all(|c| c.is_whitespace())\n+}\n+\n+/// Returns true if a string is empty or just spaces.\n+pub fn is_null(s: &str) -> bool {\n+    s.is_empty() || is_all_whitespace(s)\n+}\n+\n+/// Returns the indentation level of a string. It just returns the count of\n+/// whitespace characters in the string before a non-whitespace character\n+/// is encountered.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use clippy_lints::utils::indent_level;\n+///\n+/// let s = \"    fn foo() { \";\n+/// assert_eq!(4, indent_level(s));\n+///\n+/// let s = \"fn foo() { \";\n+/// assert_eq!(0, indent_level(s));\n+/// ```\n+pub fn indent_level(s: &str) -> usize {\n+    s.chars()\n+     .enumerate()\n+     .find(|&(_, c)| !c.is_whitespace())\n+     .map_or(0_usize, |(i, _)| i)\n+}"}]}