{"sha": "2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkNmNiZDIxYjJjNTgxOWM3ZmE0MmViNWEzNzEzNjY3YjY3ZTRmMDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-12T09:34:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-12T09:34:37Z"}, "message": "Auto merge of #76637 - RalfJung:rollup-eaykf93, r=RalfJung\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #76114 (Add saturating methods for `Duration`)\n - #76297 (rustdoc: fix min_const_generics with ty::Param)\n - #76484 (Add MaybeUninit::assume_init_drop.)\n - #76530 (Eliminate mut reference UB in Drop impl for Rc<T>)\n - #76583 (Update `std::os` module documentation.)\n - #76599 (Finish off revisions for const generics UI tests.)\n - #76615 (Add missing examples on binary core traits)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "4d75c6781771701eaa7c64fef207d00a354e05e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d75c6781771701eaa7c64fef207d00a354e05e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "html_url": "https://github.com/rust-lang/rust/commit/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e2e7dec73a210dd7699496daf81a9442b69371b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e2e7dec73a210dd7699496daf81a9442b69371b", "html_url": "https://github.com/rust-lang/rust/commit/2e2e7dec73a210dd7699496daf81a9442b69371b"}, {"sha": "0ed4bc59931ac4ec35c50aa7faafe42cbec9efb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ed4bc59931ac4ec35c50aa7faafe42cbec9efb0", "html_url": "https://github.com/rust-lang/rust/commit/0ed4bc59931ac4ec35c50aa7faafe42cbec9efb0"}], "stats": {"total": 582, "additions": 488, "deletions": 94}, "files": [{"sha": "f998e49dcfcde8dcb4a26c0e9a549ed47b84652e", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 75, "deletions": 38, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -295,6 +295,13 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Rc<U>> for Rc<T> {}\n impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Rc<U>> for Rc<T> {}\n \n impl<T: ?Sized> Rc<T> {\n+    #[inline(always)]\n+    fn inner(&self) -> &RcBox<T> {\n+        // This unsafety is ok because while this Rc is alive we're guaranteed\n+        // that the inner pointer is valid.\n+        unsafe { self.ptr.as_ref() }\n+    }\n+\n     fn from_inner(ptr: NonNull<RcBox<T>>) -> Self {\n         Self { ptr, phantom: PhantomData }\n     }\n@@ -469,7 +476,7 @@ impl<T> Rc<T> {\n                 // the strong count, and then remove the implicit \"strong weak\"\n                 // pointer while also handling drop logic by just crafting a\n                 // fake Weak.\n-                this.dec_strong();\n+                this.inner().dec_strong();\n                 let _weak = Weak { ptr: this.ptr };\n                 forget(this);\n                 Ok(val)\n@@ -735,7 +742,7 @@ impl<T: ?Sized> Rc<T> {\n     /// ```\n     #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n     pub fn downgrade(this: &Self) -> Weak<T> {\n-        this.inc_weak();\n+        this.inner().inc_weak();\n         // Make sure we do not create a dangling Weak\n         debug_assert!(!is_dangling(this.ptr));\n         Weak { ptr: this.ptr }\n@@ -756,7 +763,7 @@ impl<T: ?Sized> Rc<T> {\n     #[inline]\n     #[stable(feature = \"rc_counts\", since = \"1.15.0\")]\n     pub fn weak_count(this: &Self) -> usize {\n-        this.weak() - 1\n+        this.inner().weak() - 1\n     }\n \n     /// Gets the number of strong (`Rc`) pointers to this allocation.\n@@ -774,7 +781,7 @@ impl<T: ?Sized> Rc<T> {\n     #[inline]\n     #[stable(feature = \"rc_counts\", since = \"1.15.0\")]\n     pub fn strong_count(this: &Self) -> usize {\n-        this.strong()\n+        this.inner().strong()\n     }\n \n     /// Returns `true` if there are no other `Rc` or [`Weak`] pointers to\n@@ -844,7 +851,9 @@ impl<T: ?Sized> Rc<T> {\n     #[inline]\n     #[unstable(feature = \"get_mut_unchecked\", issue = \"63292\")]\n     pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {\n-        unsafe { &mut this.ptr.as_mut().value }\n+        // We are careful to *not* create a reference covering the \"count\" fields, as\n+        // this would conflict with accesses to the reference counts (e.g. by `Weak`).\n+        unsafe { &mut (*this.ptr.as_ptr()).value }\n     }\n \n     #[inline]\n@@ -931,10 +940,10 @@ impl<T: Clone> Rc<T> {\n             unsafe {\n                 let mut swap = Rc::new(ptr::read(&this.ptr.as_ref().value));\n                 mem::swap(this, &mut swap);\n-                swap.dec_strong();\n+                swap.inner().dec_strong();\n                 // Remove implicit strong-weak ref (no need to craft a fake\n                 // Weak here -- we know other Weaks can clean up for us)\n-                swap.dec_weak();\n+                swap.inner().dec_weak();\n                 forget(swap);\n             }\n         }\n@@ -1192,16 +1201,16 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n     /// ```\n     fn drop(&mut self) {\n         unsafe {\n-            self.dec_strong();\n-            if self.strong() == 0 {\n+            self.inner().dec_strong();\n+            if self.inner().strong() == 0 {\n                 // destroy the contained object\n-                ptr::drop_in_place(self.ptr.as_mut());\n+                ptr::drop_in_place(Self::get_mut_unchecked(self));\n \n                 // remove the implicit \"strong weak\" pointer now that we've\n                 // destroyed the contents.\n-                self.dec_weak();\n+                self.inner().dec_weak();\n \n-                if self.weak() == 0 {\n+                if self.inner().weak() == 0 {\n                     Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n                 }\n             }\n@@ -1227,7 +1236,7 @@ impl<T: ?Sized> Clone for Rc<T> {\n     /// ```\n     #[inline]\n     fn clone(&self) -> Rc<T> {\n-        self.inc_strong();\n+        self.inner().inc_strong();\n         Self::from_inner(self.ptr)\n     }\n }\n@@ -1851,6 +1860,13 @@ pub(crate) fn is_dangling<T: ?Sized>(ptr: NonNull<T>) -> bool {\n     address == usize::MAX\n }\n \n+/// Helper type to allow accessing the reference counts without\n+/// making any assertions about the data field.\n+struct WeakInner<'a> {\n+    weak: &'a Cell<usize>,\n+    strong: &'a Cell<usize>,\n+}\n+\n impl<T: ?Sized> Weak<T> {\n     /// Attempts to upgrade the `Weak` pointer to an [`Rc`], delaying\n     /// dropping of the inner value if successful.\n@@ -1910,11 +1926,21 @@ impl<T: ?Sized> Weak<T> {\n             .unwrap_or(0)\n     }\n \n-    /// Returns `None` when the pointer is dangling and there is no allocated `RcBox`\n+    /// Returns `None` when the pointer is dangling and there is no allocated `RcBox`,\n     /// (i.e., when this `Weak` was created by `Weak::new`).\n     #[inline]\n-    fn inner(&self) -> Option<&RcBox<T>> {\n-        if is_dangling(self.ptr) { None } else { Some(unsafe { self.ptr.as_ref() }) }\n+    fn inner(&self) -> Option<WeakInner<'_>> {\n+        if is_dangling(self.ptr) {\n+            None\n+        } else {\n+            // We are careful to *not* create a reference covering the \"data\" field, as\n+            // the field may be mutated concurrently (for example, if the last `Rc`\n+            // is dropped, the data field will be dropped in-place).\n+            Some(unsafe {\n+                let ptr = self.ptr.as_ptr();\n+                WeakInner { strong: &(*ptr).strong, weak: &(*ptr).weak }\n+            })\n+        }\n     }\n \n     /// Returns `true` if the two `Weak`s point to the same allocation (similar to\n@@ -1992,14 +2018,14 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// assert!(other_weak_foo.upgrade().is_none());\n     /// ```\n     fn drop(&mut self) {\n-        if let Some(inner) = self.inner() {\n-            inner.dec_weak();\n-            // the weak count starts at 1, and will only go to zero if all\n-            // the strong pointers have disappeared.\n-            if inner.weak() == 0 {\n-                unsafe {\n-                    Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n-                }\n+        let inner = if let Some(inner) = self.inner() { inner } else { return };\n+\n+        inner.dec_weak();\n+        // the weak count starts at 1, and will only go to zero if all\n+        // the strong pointers have disappeared.\n+        if inner.weak() == 0 {\n+            unsafe {\n+                Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n             }\n         }\n     }\n@@ -2065,12 +2091,13 @@ impl<T> Default for Weak<T> {\n // clone these much in Rust thanks to ownership and move-semantics.\n \n #[doc(hidden)]\n-trait RcBoxPtr<T: ?Sized> {\n-    fn inner(&self) -> &RcBox<T>;\n+trait RcInnerPtr {\n+    fn weak_ref(&self) -> &Cell<usize>;\n+    fn strong_ref(&self) -> &Cell<usize>;\n \n     #[inline]\n     fn strong(&self) -> usize {\n-        self.inner().strong.get()\n+        self.strong_ref().get()\n     }\n \n     #[inline]\n@@ -2084,17 +2111,17 @@ trait RcBoxPtr<T: ?Sized> {\n         if strong == 0 || strong == usize::MAX {\n             abort();\n         }\n-        self.inner().strong.set(strong + 1);\n+        self.strong_ref().set(strong + 1);\n     }\n \n     #[inline]\n     fn dec_strong(&self) {\n-        self.inner().strong.set(self.strong() - 1);\n+        self.strong_ref().set(self.strong() - 1);\n     }\n \n     #[inline]\n     fn weak(&self) -> usize {\n-        self.inner().weak.get()\n+        self.weak_ref().get()\n     }\n \n     #[inline]\n@@ -2108,26 +2135,36 @@ trait RcBoxPtr<T: ?Sized> {\n         if weak == 0 || weak == usize::MAX {\n             abort();\n         }\n-        self.inner().weak.set(weak + 1);\n+        self.weak_ref().set(weak + 1);\n     }\n \n     #[inline]\n     fn dec_weak(&self) {\n-        self.inner().weak.set(self.weak() - 1);\n+        self.weak_ref().set(self.weak() - 1);\n     }\n }\n \n-impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n+impl<T: ?Sized> RcInnerPtr for RcBox<T> {\n     #[inline(always)]\n-    fn inner(&self) -> &RcBox<T> {\n-        unsafe { self.ptr.as_ref() }\n+    fn weak_ref(&self) -> &Cell<usize> {\n+        &self.weak\n+    }\n+\n+    #[inline(always)]\n+    fn strong_ref(&self) -> &Cell<usize> {\n+        &self.strong\n     }\n }\n \n-impl<T: ?Sized> RcBoxPtr<T> for RcBox<T> {\n+impl<'a> RcInnerPtr for WeakInner<'a> {\n     #[inline(always)]\n-    fn inner(&self) -> &RcBox<T> {\n-        self\n+    fn weak_ref(&self) -> &Cell<usize> {\n+        self.weak\n+    }\n+\n+    #[inline(always)]\n+    fn strong_ref(&self) -> &Cell<usize> {\n+        self.strong\n     }\n }\n "}, {"sha": "cafb002c01a1106433f5e5647adafb3936f524fd", "filename": "library/core/src/array/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fiter.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -103,7 +103,7 @@ impl<T, const N: usize> Iterator for IntoIter<T, N> {\n             // dead now (i.e. do not touch). As `idx` was the start of the\n             // alive-zone, the alive zone is now `data[alive]` again, restoring\n             // all invariants.\n-            unsafe { self.data.get_unchecked(idx).read() }\n+            unsafe { self.data.get_unchecked(idx).assume_init_read() }\n         })\n     }\n \n@@ -136,7 +136,7 @@ impl<T, const N: usize> DoubleEndedIterator for IntoIter<T, N> {\n             // dead now (i.e. do not touch). As `idx` was the end of the\n             // alive-zone, the alive zone is now `data[alive]` again, restoring\n             // all invariants.\n-            unsafe { self.data.get_unchecked(idx).read() }\n+            unsafe { self.data.get_unchecked(idx).assume_init_read() }\n         })\n     }\n }"}, {"sha": "c3cadcbb01e31b339071c6d3bb8c12d4ab76bb75", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -100,6 +100,7 @@\n #![feature(doc_cfg)]\n #![feature(doc_spotlight)]\n #![feature(duration_consts_2)]\n+#![feature(duration_saturating_ops)]\n #![feature(extern_types)]\n #![feature(fundamental)]\n #![feature(intrinsics)]"}, {"sha": "b0ebaa6a12b51186c8dbf433813b8e44225e1329", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -2,6 +2,7 @@ use crate::any::type_name;\n use crate::fmt;\n use crate::intrinsics;\n use crate::mem::ManuallyDrop;\n+use crate::ptr;\n \n /// A wrapper type to construct uninitialized instances of `T`.\n ///\n@@ -471,6 +472,8 @@ impl<T> MaybeUninit<T> {\n     /// *immediate* undefined behavior, but will cause undefined behavior with most\n     /// safe operations (including dropping it).\n     ///\n+    /// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n+    ///\n     /// # Examples\n     ///\n     /// Correct usage of this method:\n@@ -519,8 +522,8 @@ impl<T> MaybeUninit<T> {\n     /// this initialization invariant.\n     ///\n     /// Moreover, this leaves a copy of the same data behind in the `MaybeUninit<T>`. When using\n-    /// multiple copies of the data (by calling `read` multiple times, or first\n-    /// calling `read` and then [`assume_init`]), it is your responsibility\n+    /// multiple copies of the data (by calling `assume_init_read` multiple times, or first\n+    /// calling `assume_init_read` and then [`assume_init`]), it is your responsibility\n     /// to ensure that that data may indeed be duplicated.\n     ///\n     /// [inv]: #initialization-invariant\n@@ -536,16 +539,16 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// let mut x = MaybeUninit::<u32>::uninit();\n     /// x.write(13);\n-    /// let x1 = unsafe { x.read() };\n+    /// let x1 = unsafe { x.assume_init_read() };\n     /// // `u32` is `Copy`, so we may read multiple times.\n-    /// let x2 = unsafe { x.read() };\n+    /// let x2 = unsafe { x.assume_init_read() };\n     /// assert_eq!(x1, x2);\n     ///\n     /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n     /// x.write(None);\n-    /// let x1 = unsafe { x.read() };\n+    /// let x1 = unsafe { x.assume_init_read() };\n     /// // Duplicating a `None` value is okay, so we may read multiple times.\n-    /// let x2 = unsafe { x.read() };\n+    /// let x2 = unsafe { x.assume_init_read() };\n     /// assert_eq!(x1, x2);\n     /// ```\n     ///\n@@ -557,14 +560,14 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n     /// x.write(Some(vec![0,1,2]));\n-    /// let x1 = unsafe { x.read() };\n-    /// let x2 = unsafe { x.read() };\n+    /// let x1 = unsafe { x.assume_init_read() };\n+    /// let x2 = unsafe { x.assume_init_read() };\n     /// // We now created two copies of the same vector, leading to a double-free \u26a0\ufe0f when\n     /// // they both get dropped!\n     /// ```\n     #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n     #[inline(always)]\n-    pub unsafe fn read(&self) -> T {\n+    pub unsafe fn assume_init_read(&self) -> T {\n         // SAFETY: the caller must guarantee that `self` is initialized.\n         // Reading from `self.as_ptr()` is safe since `self` should be initialized.\n         unsafe {\n@@ -573,6 +576,34 @@ impl<T> MaybeUninit<T> {\n         }\n     }\n \n+    /// Drops the contained value in place.\n+    ///\n+    /// If you have ownership of the `MaybeUninit`, you can use [`assume_init`] instead.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is\n+    /// in an initialized state. Calling this when the content is not yet fully\n+    /// initialized causes undefined behavior.\n+    ///\n+    /// On top of that, all additional invariants of the type `T` must be\n+    /// satisfied, as the `Drop` implementation of `T` (or its members) may\n+    /// rely on this. For example, a `1`-initialized [`Vec<T>`] is considered\n+    /// initialized (under the current implementation; this does not constitute\n+    /// a stable guarantee) because the only requirement the compiler knows\n+    /// about it is that the data pointer must be non-null. Dropping such a\n+    /// `Vec<T>` however will cause undefined behaviour.\n+    ///\n+    /// [`assume_init`]: MaybeUninit::assume_init\n+    /// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n+    #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n+    pub unsafe fn assume_init_drop(&mut self) {\n+        // SAFETY: the caller must guarantee that `self` is initialized and\n+        // satisfies all invariants of `T`.\n+        // Dropping the value in place is safe if that is the case.\n+        unsafe { ptr::drop_in_place(self.as_mut_ptr()) }\n+    }\n+\n     /// Gets a shared reference to the contained value.\n     ///\n     /// This can be useful when we want to access a `MaybeUninit` that has been"}, {"sha": "3d71e0b0002c2da6a7c29eb7a78790e817519d3d", "filename": "library/core/src/ops/bit.rs", "status": "modified", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fcore%2Fsrc%2Fops%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fcore%2Fsrc%2Fops%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fbit.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -36,6 +36,15 @@ pub trait Not {\n     type Output;\n \n     /// Performs the unary `!` operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!(!true, false);\n+    /// assert_eq!(!false, true);\n+    /// assert_eq!(!1u8, 254);\n+    /// assert_eq!(!0u8, 255);\n+    /// ```\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn not(self) -> Self::Output;\n@@ -122,6 +131,15 @@ pub trait BitAnd<Rhs = Self> {\n     type Output;\n \n     /// Performs the `&` operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!(true & false, false);\n+    /// assert_eq!(true & true, true);\n+    /// assert_eq!(5u8 & 1u8, 1);\n+    /// assert_eq!(5u8 & 2u8, 0);\n+    /// ```\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitand(self, rhs: Rhs) -> Self::Output;\n@@ -208,6 +226,15 @@ pub trait BitOr<Rhs = Self> {\n     type Output;\n \n     /// Performs the `|` operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!(true | false, true);\n+    /// assert_eq!(false | false, false);\n+    /// assert_eq!(5u8 | 1u8, 5);\n+    /// assert_eq!(5u8 | 2u8, 7);\n+    /// ```\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitor(self, rhs: Rhs) -> Self::Output;\n@@ -297,6 +324,15 @@ pub trait BitXor<Rhs = Self> {\n     type Output;\n \n     /// Performs the `^` operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!(true ^ false, true);\n+    /// assert_eq!(true ^ true, false);\n+    /// assert_eq!(5u8 ^ 1u8, 4);\n+    /// assert_eq!(5u8 ^ 2u8, 7);\n+    /// ```\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitxor(self, rhs: Rhs) -> Self::Output;\n@@ -387,6 +423,13 @@ pub trait Shl<Rhs = Self> {\n     type Output;\n \n     /// Performs the `<<` operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!(5u8 << 1, 10);\n+    /// assert_eq!(1u8 << 1, 2);\n+    /// ```\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn shl(self, rhs: Rhs) -> Self::Output;\n@@ -498,6 +541,13 @@ pub trait Shr<Rhs = Self> {\n     type Output;\n \n     /// Performs the `>>` operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!(5u8 >> 1, 2);\n+    /// assert_eq!(2u8 >> 1, 1);\n+    /// ```\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn shr(self, rhs: Rhs) -> Self::Output;\n@@ -612,6 +662,26 @@ shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n )]\n pub trait BitAndAssign<Rhs = Self> {\n     /// Performs the `&=` operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut x = true;\n+    /// x &= false;\n+    /// assert_eq!(x, false);\n+    ///\n+    /// let mut x = true;\n+    /// x &= true;\n+    /// assert_eq!(x, true);\n+    ///\n+    /// let mut x: u8 = 5;\n+    /// x &= 1;\n+    /// assert_eq!(x, 1);\n+    ///\n+    /// let mut x: u8 = 5;\n+    /// x &= 2;\n+    /// assert_eq!(x, 0);\n+    /// ```\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn bitand_assign(&mut self, rhs: Rhs);\n }\n@@ -663,6 +733,26 @@ bitand_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n )]\n pub trait BitOrAssign<Rhs = Self> {\n     /// Performs the `|=` operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut x = true;\n+    /// x |= false;\n+    /// assert_eq!(x, true);\n+    ///\n+    /// let mut x = false;\n+    /// x |= false;\n+    /// assert_eq!(x, false);\n+    ///\n+    /// let mut x: u8 = 5;\n+    /// x |= 1;\n+    /// assert_eq!(x, 5);\n+    ///\n+    /// let mut x: u8 = 5;\n+    /// x |= 2;\n+    /// assert_eq!(x, 7);\n+    /// ```\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn bitor_assign(&mut self, rhs: Rhs);\n }\n@@ -714,6 +804,26 @@ bitor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n )]\n pub trait BitXorAssign<Rhs = Self> {\n     /// Performs the `^=` operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut x = true;\n+    /// x ^= false;\n+    /// assert_eq!(x, true);\n+    ///\n+    /// let mut x = true;\n+    /// x ^= true;\n+    /// assert_eq!(x, false);\n+    ///\n+    /// let mut x: u8 = 5;\n+    /// x ^= 1;\n+    /// assert_eq!(x, 4);\n+    ///\n+    /// let mut x: u8 = 5;\n+    /// x ^= 2;\n+    /// assert_eq!(x, 7);\n+    /// ```\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn bitxor_assign(&mut self, rhs: Rhs);\n }\n@@ -763,6 +873,18 @@ bitxor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n )]\n pub trait ShlAssign<Rhs = Self> {\n     /// Performs the `<<=` operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut x: u8 = 5;\n+    /// x <<= 1;\n+    /// assert_eq!(x, 10);\n+    ///\n+    /// let mut x: u8 = 1;\n+    /// x <<= 1;\n+    /// assert_eq!(x, 2);\n+    /// ```\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn shl_assign(&mut self, rhs: Rhs);\n }\n@@ -833,6 +955,18 @@ shl_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n )]\n pub trait ShrAssign<Rhs = Self> {\n     /// Performs the `>>=` operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut x: u8 = 5;\n+    /// x >>= 1;\n+    /// assert_eq!(x, 2);\n+    ///\n+    /// let mut x: u8 = 2;\n+    /// x >>= 1;\n+    /// assert_eq!(x, 1);\n+    /// ```\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn shr_assign(&mut self, rhs: Rhs);\n }"}, {"sha": "f39781788d7c04e09a5da36744a9ab77e5b37553", "filename": "library/core/src/time.rs", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -108,6 +108,34 @@ impl Duration {\n     #[unstable(feature = \"duration_constants\", issue = \"57391\")]\n     pub const NANOSECOND: Duration = Duration::from_nanos(1);\n \n+    /// The minimum duration.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(duration_constants)]\n+    /// use std::time::Duration;\n+    ///\n+    /// assert_eq!(Duration::MIN, Duration::new(0, 0));\n+    /// ```\n+    #[unstable(feature = \"duration_constants\", issue = \"57391\")]\n+    pub const MIN: Duration = Duration::from_nanos(0);\n+\n+    /// The maximum duration.\n+    ///\n+    /// It is roughly equal to a duration of 584,942,417,355 years.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(duration_constants)]\n+    /// use std::time::Duration;\n+    ///\n+    /// assert_eq!(Duration::MAX, Duration::new(u64::MAX, 1_000_000_000 - 1));\n+    /// ```\n+    #[unstable(feature = \"duration_constants\", issue = \"57391\")]\n+    pub const MAX: Duration = Duration::new(u64::MAX, NANOS_PER_SEC - 1);\n+\n     /// Creates a new `Duration` from the specified number of whole seconds and\n     /// additional nanoseconds.\n     ///\n@@ -450,6 +478,29 @@ impl Duration {\n         }\n     }\n \n+    /// Saturating `Duration` addition. Computes `self + other`, returning [`Duration::MAX`]\n+    /// if overflow occurred.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(duration_saturating_ops)]\n+    /// #![feature(duration_constants)]\n+    /// use std::time::Duration;\n+    ///\n+    /// assert_eq!(Duration::new(0, 0).saturating_add(Duration::new(0, 1)), Duration::new(0, 1));\n+    /// assert_eq!(Duration::new(1, 0).saturating_add(Duration::new(u64::MAX, 0)), Duration::MAX);\n+    /// ```\n+    #[unstable(feature = \"duration_saturating_ops\", issue = \"76416\")]\n+    #[inline]\n+    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n+    pub const fn saturating_add(self, rhs: Duration) -> Duration {\n+        match self.checked_add(rhs) {\n+            Some(res) => res,\n+            None => Duration::MAX,\n+        }\n+    }\n+\n     /// Checked `Duration` subtraction. Computes `self - other`, returning [`None`]\n     /// if the result would be negative or if overflow occurred.\n     ///\n@@ -485,6 +536,29 @@ impl Duration {\n         }\n     }\n \n+    /// Saturating `Duration` subtraction. Computes `self - other`, returning [`Duration::MIN`]\n+    /// if the result would be negative or if overflow occurred.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(duration_saturating_ops)]\n+    /// #![feature(duration_constants)]\n+    /// use std::time::Duration;\n+    ///\n+    /// assert_eq!(Duration::new(0, 1).saturating_sub(Duration::new(0, 0)), Duration::new(0, 1));\n+    /// assert_eq!(Duration::new(0, 0).saturating_sub(Duration::new(0, 1)), Duration::MIN);\n+    /// ```\n+    #[unstable(feature = \"duration_saturating_ops\", issue = \"76416\")]\n+    #[inline]\n+    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n+    pub const fn saturating_sub(self, rhs: Duration) -> Duration {\n+        match self.checked_sub(rhs) {\n+            Some(res) => res,\n+            None => Duration::MIN,\n+        }\n+    }\n+\n     /// Checked `Duration` multiplication. Computes `self * other`, returning\n     /// [`None`] if overflow occurred.\n     ///\n@@ -515,6 +589,29 @@ impl Duration {\n         None\n     }\n \n+    /// Saturating `Duration` multiplication. Computes `self * other`, returning\n+    /// [`Duration::MAX`] if overflow occurred.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(duration_saturating_ops)]\n+    /// #![feature(duration_constants)]\n+    /// use std::time::Duration;\n+    ///\n+    /// assert_eq!(Duration::new(0, 500_000_001).saturating_mul(2), Duration::new(1, 2));\n+    /// assert_eq!(Duration::new(u64::MAX - 1, 0).saturating_mul(2), Duration::MAX);\n+    /// ```\n+    #[unstable(feature = \"duration_saturating_ops\", issue = \"76416\")]\n+    #[inline]\n+    #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n+    pub const fn saturating_mul(self, rhs: u32) -> Duration {\n+        match self.checked_mul(rhs) {\n+            Some(res) => res,\n+            None => Duration::MAX,\n+        }\n+    }\n+\n     /// Checked `Duration` division. Computes `self / other`, returning [`None`]\n     /// if `other == 0`.\n     ///"}, {"sha": "a2e294ace1860f2226350fb80c1df9fd2c647e82", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -10,6 +10,8 @@\n #![feature(core_private_diy_float)]\n #![feature(debug_non_exhaustive)]\n #![feature(dec2flt)]\n+#![feature(duration_constants)]\n+#![feature(duration_saturating_ops)]\n #![feature(exact_size_is_empty)]\n #![feature(fixed_size_array)]\n #![feature(flt2dec)]"}, {"sha": "4f90eb63b0472393c2d8e7beeaef66b9f56d0cdb", "filename": "library/core/tests/time.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Ftime.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -89,6 +89,16 @@ fn checked_add() {\n     assert_eq!(Duration::new(1, 0).checked_add(Duration::new(u64::MAX, 0)), None);\n }\n \n+#[test]\n+fn saturating_add() {\n+    assert_eq!(Duration::new(0, 0).saturating_add(Duration::new(0, 1)), Duration::new(0, 1));\n+    assert_eq!(\n+        Duration::new(0, 500_000_000).saturating_add(Duration::new(0, 500_000_001)),\n+        Duration::new(1, 1)\n+    );\n+    assert_eq!(Duration::new(1, 0).saturating_add(Duration::new(u64::MAX, 0)), Duration::MAX);\n+}\n+\n #[test]\n fn sub() {\n     assert_eq!(Duration::new(0, 1) - Duration::new(0, 0), Duration::new(0, 1));\n@@ -107,6 +117,17 @@ fn checked_sub() {\n     assert_eq!(zero.checked_sub(one_sec), None);\n }\n \n+#[test]\n+fn saturating_sub() {\n+    let zero = Duration::new(0, 0);\n+    let one_nano = Duration::new(0, 1);\n+    let one_sec = Duration::new(1, 0);\n+    assert_eq!(one_nano.saturating_sub(zero), Duration::new(0, 1));\n+    assert_eq!(one_sec.saturating_sub(one_nano), Duration::new(0, 999_999_999));\n+    assert_eq!(zero.saturating_sub(one_nano), Duration::MIN);\n+    assert_eq!(zero.saturating_sub(one_sec), Duration::MIN);\n+}\n+\n #[test]\n #[should_panic]\n fn sub_bad1() {\n@@ -136,6 +157,15 @@ fn checked_mul() {\n     assert_eq!(Duration::new(u64::MAX - 1, 0).checked_mul(2), None);\n }\n \n+#[test]\n+fn saturating_mul() {\n+    assert_eq!(Duration::new(0, 1).saturating_mul(2), Duration::new(0, 2));\n+    assert_eq!(Duration::new(1, 1).saturating_mul(3), Duration::new(3, 3));\n+    assert_eq!(Duration::new(0, 500_000_001).saturating_mul(4), Duration::new(2, 4));\n+    assert_eq!(Duration::new(0, 500_000_001).saturating_mul(4000), Duration::new(2000, 4000));\n+    assert_eq!(Duration::new(u64::MAX - 1, 0).saturating_mul(2), Duration::MAX);\n+}\n+\n #[test]\n fn div() {\n     assert_eq!(Duration::new(0, 1) / 2, Duration::new(0, 0));"}, {"sha": "ff23c3d67e3b4749711572281bc128513f85126d", "filename": "library/std/src/os/linux/fs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fstd%2Fsrc%2Fos%2Flinux%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fstd%2Fsrc%2Fos%2Flinux%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Flinux%2Ffs.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -1,3 +1,5 @@\n+//! Linux-specific extensions to primitives in the `std::fs` module.\n+\n #![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n \n use crate::fs::Metadata;"}, {"sha": "f179a524336fc1ecd6b1a2e8f14dd519af9628f5", "filename": "library/std/src/os/linux/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fmod.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -1,4 +1,4 @@\n-//! Linux-specific definitions\n+//! Linux-specific definitions.\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n "}, {"sha": "a007fd2b6be04c4b879756b7c9f4b49f2ade3f32", "filename": "library/std/src/os/linux/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fraw.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -1,4 +1,4 @@\n-//! Linux-specific raw type definitions\n+//! Linux-specific raw type definitions.\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n #![rustc_deprecated("}, {"sha": "123f85deaf9e3f4320bde10bd6436bb4f900d653", "filename": "library/std/src/sys/unix/ext/ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fffi.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -1,4 +1,4 @@\n-//! Unix-specific extension to the primitives in the `std::ffi` module\n+//! Unix-specific extension to the primitives in the `std::ffi` module.\n //!\n //! # Examples\n //!"}, {"sha": "ec7a32b675c02fa50cbb5723214bf44b56ed6022", "filename": "library/std/src/sys/unix/ext/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fio.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -1,4 +1,4 @@\n-//! Unix-specific extensions to general I/O primitives\n+//! Unix-specific extensions to general I/O primitives.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "320378e30ccb10524303a8225b8df87924770c85", "filename": "library/std/src/sys/unix/ext/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -1,6 +1,6 @@\n-#![stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+//! Unix-specific networking functionality.\n \n-//! Unix-specific networking functionality\n+#![stable(feature = \"unix_socket\", since = \"1.10.0\")]\n \n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests;"}, {"sha": "3199a0bff0bcc57310919ada57e928ee2711cbe2", "filename": "library/std/src/sys/unix/ext/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fraw.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -1,4 +1,4 @@\n-//! Unix-specific primitives available on all unix platforms\n+//! Unix-specific primitives available on all unix platforms.\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n #![rustc_deprecated("}, {"sha": "e75f9a4bfd5e337ca75e4eb1b031079caa1f5d2a", "filename": "library/std/src/sys/windows/ext/io.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Fio.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -1,3 +1,5 @@\n+//! Windows-specific extensions to general I/O primitives.\n+\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::fs;"}, {"sha": "5014e008eb599c12d911a9b89eaf7d3d42d4388d", "filename": "library/std/src/sys/windows/ext/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Fraw.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -1,4 +1,4 @@\n-//! Windows-specific primitives\n+//! Windows-specific primitives.\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n "}, {"sha": "9d784d24609dc5ea294be1cda5fd6c764a1edcda", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -1364,16 +1364,16 @@ impl Clean<Type> for hir::Ty<'_> {\n             TyKind::Slice(ref ty) => Slice(box ty.clean(cx)),\n             TyKind::Array(ref ty, ref length) => {\n                 let def_id = cx.tcx.hir().local_def_id(length.hir_id);\n-                let length = match cx.tcx.const_eval_poly(def_id.to_def_id()) {\n-                    Ok(length) => {\n-                        print_const(cx, ty::Const::from_value(cx.tcx, length, cx.tcx.types.usize))\n-                    }\n-                    Err(_) => cx\n-                        .sess()\n-                        .source_map()\n-                        .span_to_snippet(cx.tcx.def_span(def_id))\n-                        .unwrap_or_else(|_| \"_\".to_string()),\n-                };\n+                // NOTE(min_const_generics): We can't use `const_eval_poly` for constants\n+                // as we currently do not supply the parent generics to anonymous constants\n+                // but do allow `ConstKind::Param`.\n+                //\n+                // `const_eval_poly` tries to to first substitute generic parameters which\n+                // results in an ICE while manually constructing the constant and using `eval`\n+                // does nothing for `ConstKind::Param`.\n+                let ct = ty::Const::from_anon_const(cx.tcx, def_id);\n+                let param_env = cx.tcx.param_env(def_id);\n+                let length = print_const(cx, ct.eval(cx.tcx, param_env));\n                 Array(box ty.clean(cx), length)\n             }\n             TyKind::Tup(ref tys) => Tuple(tys.clean(cx)),"}, {"sha": "3064d0701e3006afa1c59725ef04013dc24f437b", "filename": "src/test/rustdoc/const-generics/type-alias.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Ftest%2Frustdoc%2Fconst-generics%2Ftype-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Ftest%2Frustdoc%2Fconst-generics%2Ftype-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-generics%2Ftype-alias.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -0,0 +1,6 @@\n+// ignore-tidy-linelength\n+#![feature(min_const_generics)]\n+#![crate_name = \"foo\"]\n+\n+// @has foo/type.CellIndex.html '//pre[@class=\"rust typedef\"]' 'type CellIndex<const D: usize> = [i64; D];'\n+pub type CellIndex<const D: usize> = [i64; D];"}, {"sha": "b2816367ea107c7b48c598c47c9a3b4aada99d10", "filename": "src/test/ui/const-generics/const_evaluatable_checked/feature-gate-const_evaluatable_checked.full.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffeature-gate-const_evaluatable_checked.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffeature-gate-const_evaluatable_checked.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffeature-gate-const_evaluatable_checked.full.stderr?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -1,5 +1,5 @@\n error: constant expression depends on a generic parameter\n-  --> $DIR/feature-gate-const_evaluatable_checked.rs:6:30\n+  --> $DIR/feature-gate-const_evaluatable_checked.rs:9:30\n    |\n LL | fn test<const N: usize>() -> Arr<N> where Arr<N>: Default {\n    |                              ^^^^^^", "previous_filename": "src/test/ui/const-generics/const_evaluatable_checked/feature-gate-const_evaluatable_checked.stderr"}, {"sha": "269710db164b1225b1c0e61abfc4d240db43b140", "filename": "src/test/ui/const-generics/const_evaluatable_checked/feature-gate-const_evaluatable_checked.min.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffeature-gate-const_evaluatable_checked.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffeature-gate-const_evaluatable_checked.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffeature-gate-const_evaluatable_checked.min.stderr?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -0,0 +1,10 @@\n+error: generic parameters must not be used inside of non trivial constant values\n+  --> $DIR/feature-gate-const_evaluatable_checked.rs:6:33\n+   |\n+LL | type Arr<const N: usize> = [u8; N - 1];\n+   |                                 ^ non-trivial anonymous constants must not depend on the parameter `N`\n+   |\n+   = help: it is currently only allowed to use either `N` or `{ N }` as generic constants\n+\n+error: aborting due to previous error\n+"}, {"sha": "af3090115f24a8cc2c717164aae16c55017cb6eb", "filename": "src/test/ui/const-generics/const_evaluatable_checked/feature-gate-const_evaluatable_checked.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffeature-gate-const_evaluatable_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffeature-gate-const_evaluatable_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffeature-gate-const_evaluatable_checked.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -1,10 +1,13 @@\n-#![feature(const_generics)]\n-#![allow(incomplete_features)]\n+// revisions: full min\n+#![cfg_attr(full, feature(const_generics))]\n+#![cfg_attr(full, allow(incomplete_features))]\n+#![cfg_attr(min, feature(min_const_generics))]\n \n type Arr<const N: usize> = [u8; N - 1];\n+//[min]~^ ERROR generic parameters must not be used inside of non trivial constant values\n \n fn test<const N: usize>() -> Arr<N> where Arr<N>: Default {\n-    //~^ ERROR constant expression depends\n+    //[full]~^ ERROR constant expression depends\n     Default::default()\n }\n "}, {"sha": "da8ccdaee414661f554d939f2b7b8f895476a35b", "filename": "src/test/ui/const-generics/const_evaluatable_checked/simple.min.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple.min.stderr?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -0,0 +1,10 @@\n+error: generic parameters must not be used inside of non trivial constant values\n+  --> $DIR/simple.rs:8:33\n+   |\n+LL | type Arr<const N: usize> = [u8; N - 1];\n+   |                                 ^ non-trivial anonymous constants must not depend on the parameter `N`\n+   |\n+   = help: it is currently only allowed to use either `N` or `{ N }` as generic constants\n+\n+error: aborting due to previous error\n+"}, {"sha": "27dc6b103200dc696517156b828103735d1bca33", "filename": "src/test/ui/const-generics/const_evaluatable_checked/simple.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -1,8 +1,12 @@\n-// run-pass\n-#![feature(const_generics, const_evaluatable_checked)]\n+// [full] run-pass\n+// revisions: full min\n+#![cfg_attr(full, feature(const_generics))]\n+#![cfg_attr(min, feature(min_const_generics))]\n+#![feature(const_evaluatable_checked)]\n #![allow(incomplete_features)]\n \n type Arr<const N: usize> = [u8; N - 1];\n+//[min]~^ ERROR generic parameters must not be used inside of non trivial constant values\n \n fn test<const N: usize>() -> Arr<N> where Arr<N>: Default {\n     Default::default()"}, {"sha": "104cab8667c70623d34e10a1cabb1559669186ea", "filename": "src/test/ui/const-generics/const_evaluatable_checked/simple_fail.full.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple_fail.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple_fail.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple_fail.full.stderr?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -1,5 +1,5 @@\n error[E0080]: evaluation of constant value failed\n-  --> $DIR/simple_fail.rs:4:33\n+  --> $DIR/simple_fail.rs:7:33\n    |\n LL | type Arr<const N: usize> = [u8; N - 1];\n    |                                 ^^^^^ attempt to compute `0_usize - 1_usize` which would overflow", "previous_filename": "src/test/ui/const-generics/const_evaluatable_checked/simple_fail.stderr"}, {"sha": "042710f13273e191108965e7e858dacc1509f988", "filename": "src/test/ui/const-generics/const_evaluatable_checked/simple_fail.min.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple_fail.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple_fail.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple_fail.min.stderr?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -0,0 +1,10 @@\n+error: generic parameters must not be used inside of non trivial constant values\n+  --> $DIR/simple_fail.rs:7:33\n+   |\n+LL | type Arr<const N: usize> = [u8; N - 1];\n+   |                                 ^ non-trivial anonymous constants must not depend on the parameter `N`\n+   |\n+   = help: it is currently only allowed to use either `N` or `{ N }` as generic constants\n+\n+error: aborting due to previous error\n+"}, {"sha": "b15e0ff183954f7d5470eb491b9c7b4dc2c3a7f8", "filename": "src/test/ui/const-generics/const_evaluatable_checked/simple_fail.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple_fail.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -1,7 +1,11 @@\n-#![feature(const_generics, const_evaluatable_checked)]\n+// revisions: full min\n+#![cfg_attr(full, feature(const_generics))]\n+#![cfg_attr(min, feature(min_const_generics))]\n+#![feature(const_evaluatable_checked)]\n #![allow(incomplete_features)]\n \n-type Arr<const N: usize> = [u8; N - 1]; //~ ERROR evaluation of constant\n+type Arr<const N: usize> = [u8; N - 1]; //[full]~ ERROR evaluation of constant\n+//[min]~^ ERROR generic parameters must not be used inside of non trivial constant values\n \n fn test<const N: usize>() -> Arr<N> where Arr<N>: Sized {\n     todo!()"}, {"sha": "aa85376bf0d75268a0a898bca3423d317acc705c", "filename": "src/test/ui/const-generics/type-dependent/auxiliary/type_dependent_lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Ftest%2Fui%2Fconst-generics%2Ftype-dependent%2Fauxiliary%2Ftype_dependent_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Ftest%2Fui%2Fconst-generics%2Ftype-dependent%2Fauxiliary%2Ftype_dependent_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ftype-dependent%2Fauxiliary%2Ftype_dependent_lib.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -1,5 +1,6 @@\n-#![feature(const_generics)]\n-#![allow(incomplete_features)]\n+#![cfg_attr(full, feature(const_generics))]\n+#![cfg_attr(full, allow(incomplete_features))]\n+#![cfg_attr(min, feature(min_const_generics))]\n \n pub struct Struct<const N: usize>(());\n "}, {"sha": "bc0969e4f1fbadfb9454ab2b0c6855be6b94b5f9", "filename": "src/test/ui/consts/duration-consts-2.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Ftest%2Fui%2Fconsts%2Fduration-consts-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03/src%2Ftest%2Fui%2Fconsts%2Fduration-consts-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fduration-consts-2.rs?ref=2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "patch": "@@ -3,6 +3,7 @@\n #![feature(const_panic)]\n #![feature(duration_consts_2)]\n #![feature(div_duration)]\n+#![feature(duration_saturating_ops)]\n \n use std::time::Duration;\n \n@@ -15,29 +16,29 @@ fn duration() {\n \n     const MAX : Duration = Duration::new(u64::MAX, 1_000_000_000 - 1);\n \n-    const MAX_ADD_ZERO : Option<Duration> = MAX.checked_add(ZERO);\n-    assert_eq!(MAX_ADD_ZERO, Some(MAX));\n+    const MAX_CHECKED_ADD_ZERO : Option<Duration> = MAX.checked_add(ZERO);\n+    assert_eq!(MAX_CHECKED_ADD_ZERO, Some(MAX));\n \n-    const MAX_ADD_ONE : Option<Duration> = MAX.checked_add(ONE);\n-    assert_eq!(MAX_ADD_ONE, None);\n+    const MAX_CHECKED_ADD_ONE : Option<Duration> = MAX.checked_add(ONE);\n+    assert_eq!(MAX_CHECKED_ADD_ONE, None);\n \n-    const ONE_SUB_ONE : Option<Duration> = ONE.checked_sub(ONE);\n-    assert_eq!(ONE_SUB_ONE, Some(ZERO));\n+    const ONE_CHECKED_SUB_ONE : Option<Duration> = ONE.checked_sub(ONE);\n+    assert_eq!(ONE_CHECKED_SUB_ONE, Some(ZERO));\n \n-    const ZERO_SUB_ONE : Option<Duration> = ZERO.checked_sub(ONE);\n-    assert_eq!(ZERO_SUB_ONE, None);\n+    const ZERO_CHECKED_SUB_ONE : Option<Duration> = ZERO.checked_sub(ONE);\n+    assert_eq!(ZERO_CHECKED_SUB_ONE, None);\n \n-    const ONE_MUL_ONE : Option<Duration> = ONE.checked_mul(1);\n-    assert_eq!(ONE_MUL_ONE, Some(ONE));\n+    const ONE_CHECKED_MUL_ONE : Option<Duration> = ONE.checked_mul(1);\n+    assert_eq!(ONE_CHECKED_MUL_ONE, Some(ONE));\n \n-    const MAX_MUL_TWO : Option<Duration> = MAX.checked_mul(2);\n-    assert_eq!(MAX_MUL_TWO, None);\n+    const MAX_CHECKED_MUL_TWO : Option<Duration> = MAX.checked_mul(2);\n+    assert_eq!(MAX_CHECKED_MUL_TWO, None);\n \n-    const ONE_DIV_ONE : Option<Duration> = ONE.checked_div(1);\n-    assert_eq!(ONE_DIV_ONE, Some(ONE));\n+    const ONE_CHECKED_DIV_ONE : Option<Duration> = ONE.checked_div(1);\n+    assert_eq!(ONE_CHECKED_DIV_ONE, Some(ONE));\n \n-    const ONE_DIV_ZERO : Option<Duration> = ONE.checked_div(0);\n-    assert_eq!(ONE_DIV_ZERO, None);\n+    const ONE_CHECKED_DIV_ZERO : Option<Duration> = ONE.checked_div(0);\n+    assert_eq!(ONE_CHECKED_DIV_ZERO, None);\n \n     const MAX_AS_F32 : f32 = MAX.as_secs_f32();\n     assert_eq!(MAX_AS_F32, 18446744000000000000.0_f32);\n@@ -50,6 +51,15 @@ fn duration() {\n \n     const ONE_AS_F64 : f64 = ONE.div_duration_f64(ONE);\n     assert_eq!(ONE_AS_F64, 1.0_f64);\n+\n+    const MAX_SATURATING_ADD_ONE : Duration = MAX.saturating_add(ONE);\n+    assert_eq!(MAX_SATURATING_ADD_ONE, MAX);\n+\n+    const ZERO_SATURATING_SUB_ONE : Duration = ZERO.saturating_sub(ONE);\n+    assert_eq!(ZERO_SATURATING_SUB_ONE, ZERO);\n+\n+    const MAX_SATURATING_MUL_TWO : Duration = MAX.saturating_mul(2);\n+    assert_eq!(MAX_SATURATING_MUL_TWO, MAX);\n }\n \n fn main() {"}]}