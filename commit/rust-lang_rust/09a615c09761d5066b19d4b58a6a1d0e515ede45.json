{"sha": "09a615c09761d5066b19d4b58a6a1d0e515ede45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5YTYxNWMwOTc2MWQ1MDY2YjE5ZDRiNThhNmExZDBlNTE1ZWRlNDU=", "commit": {"author": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2018-08-26T19:13:44Z"}, "committer": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2018-08-26T19:22:54Z"}, "message": "Reduce number of syscalls in `rand`\n\nIn case that it is statically known that the OS doesn't support\n`getrandom` (non-Linux) or becomes clear at runtime that `getrandom`\nisn't available (`ENOSYS`), the opened fd (\"/dev/urandom\") isn't closed\nafter the function, so that future calls can reuse it. This saves\nrepeated `open`/`close` system calls at the cost of one permanently open\nfd.\n\nAdditionally, this skips the initial zero-length `getrandom` call and\ndirectly hands the user buffer to the operating system, saving one\n`getrandom` syscall.", "tree": {"sha": "f8153ed4abd6ee15c1f314d38d0460572ca69619", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8153ed4abd6ee15c1f314d38d0460572ca69619"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09a615c09761d5066b19d4b58a6a1d0e515ede45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09a615c09761d5066b19d4b58a6a1d0e515ede45", "html_url": "https://github.com/rust-lang/rust/commit/09a615c09761d5066b19d4b58a6a1d0e515ede45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09a615c09761d5066b19d4b58a6a1d0e515ede45/comments", "author": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caed80ba4ba8d9f4d3fa8aa9af6c4092d779cd9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/caed80ba4ba8d9f4d3fa8aa9af6c4092d779cd9d", "html_url": "https://github.com/rust-lang/rust/commit/caed80ba4ba8d9f4d3fa8aa9af6c4092d779cd9d"}], "stats": {"total": 96, "additions": 57, "deletions": 39}, "files": [{"sha": "857d0370c299be514c1527e3275cff06b27620e8", "filename": "src/libstd/sys/unix/rand.rs", "status": "modified", "additions": 57, "deletions": 39, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/09a615c09761d5066b19d4b58a6a1d0e515ede45/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a615c09761d5066b19d4b58a6a1d0e515ede45/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frand.rs?ref=09a615c09761d5066b19d4b58a6a1d0e515ede45", "patch": "@@ -30,8 +30,23 @@ mod imp {\n     use fs::File;\n     use io::Read;\n     use libc;\n+    use sync::atomic::{AtomicBool, AtomicI32, Ordering};\n     use sys::os::errno;\n \n+    static GETRANDOM_URANDOM_FD: AtomicI32 = AtomicI32::new(-1);\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    static GETRANDOM_UNAVAILABLE: AtomicBool = AtomicBool::new(false);\n+\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    fn is_getrandom_permanently_unavailable() -> bool {\n+        GETRANDOM_UNAVAILABLE.load(Ordering::Relaxed)\n+    }\n+\n+    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n+    fn is_getrandom_permanently_unavailable() -> bool {\n+        true\n+    }\n+\n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n     fn getrandom(buf: &mut [u8]) -> libc::c_long {\n         unsafe {\n@@ -40,71 +55,74 @@ mod imp {\n     }\n \n     #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n-    fn getrandom(_buf: &mut [u8]) -> libc::c_long { -1 }\n+    fn getrandom_fill_bytes(_buf: &mut [u8]) -> bool { false }\n \n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n     fn getrandom_fill_bytes(v: &mut [u8]) -> bool {\n+        if is_getrandom_permanently_unavailable() {\n+            return false;\n+        }\n+\n         let mut read = 0;\n         while read < v.len() {\n             let result = getrandom(&mut v[read..]);\n             if result == -1 {\n                 let err = errno() as libc::c_int;\n                 if err == libc::EINTR {\n                     continue;\n+                } else if err == libc::ENOSYS {\n+                    GETRANDOM_UNAVAILABLE.store(true, Ordering::Relaxed);\n                 } else if err == libc::EAGAIN {\n-                    return false\n+                    return false;\n                 } else {\n                     panic!(\"unexpected getrandom error: {}\", err);\n                 }\n             } else {\n                 read += result as usize;\n             }\n         }\n-\n-        return true\n+        true\n     }\n \n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    fn is_getrandom_available() -> bool {\n-        use io;\n-        use sync::atomic::{AtomicBool, Ordering};\n-        use sync::Once;\n-\n-        static CHECKER: Once = Once::new();\n-        static AVAILABLE: AtomicBool = AtomicBool::new(false);\n-\n-        CHECKER.call_once(|| {\n-            let mut buf: [u8; 0] = [];\n-            let result = getrandom(&mut buf);\n-            let available = if result == -1 {\n-                let err = io::Error::last_os_error().raw_os_error();\n-                err != Some(libc::ENOSYS)\n-            } else {\n-                true\n-            };\n-            AVAILABLE.store(available, Ordering::Relaxed);\n-        });\n-\n-        AVAILABLE.load(Ordering::Relaxed)\n-    }\n-\n-    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n-    fn is_getrandom_available() -> bool { false }\n-\n     pub fn fill_bytes(v: &mut [u8]) {\n         // getrandom_fill_bytes here can fail if getrandom() returns EAGAIN,\n         // meaning it would have blocked because the non-blocking pool (urandom)\n-        // has not initialized in the kernel yet due to a lack of entropy the\n+        // has not initialized in the kernel yet due to a lack of entropy. The\n         // fallback we do here is to avoid blocking applications which could\n         // depend on this call without ever knowing they do and don't have a\n-        // work around.  The PRNG of /dev/urandom will still be used but not\n-        // over a completely full entropy pool\n-        if is_getrandom_available() && getrandom_fill_bytes(v) {\n-            return\n+        // work around. The PRNG of /dev/urandom will still be used but over a\n+        // possibly predictable entropy pool.\n+        if getrandom_fill_bytes(v) {\n+            return;\n         }\n \n-        let mut file = File::open(\"/dev/urandom\")\n-            .expect(\"failed to open /dev/urandom\");\n-        file.read_exact(v).expect(\"failed to read /dev/urandom\");\n+        // getrandom failed for some reason. If the getrandom call is\n+        // permanently unavailable (OS without getrandom, or OS version without\n+        // getrandom), we'll keep around the fd for /dev/urandom for future\n+        // requests, to avoid re-opening the file on every call.\n+        //\n+        // Otherwise, open /dev/urandom, read from it, and close it again.\n+        use super::super::ext::io::{FromRawFd, IntoRawFd};\n+        let mut fd = GETRANDOM_URANDOM_FD.load(Ordering::Relaxed);\n+        let mut close_fd = false;\n+        if fd == -1 {\n+            if !is_getrandom_permanently_unavailable() {\n+                close_fd = true;\n+            }\n+            let file = File::open(\"/dev/urandom\").expect(\"failed to open /dev/urandom\");\n+            fd = file.into_raw_fd();\n+            // If some other thread also opened /dev/urandom and set the global\n+            // fd already, we close our fd at the end of the function.\n+            if !close_fd && GETRANDOM_URANDOM_FD.compare_and_swap(-1, fd, Ordering::Relaxed) != -1 {\n+                close_fd = true;\n+            }\n+        }\n+        let mut file = unsafe { File::from_raw_fd(fd) };\n+        let res = file.read_exact(v);\n+        if !close_fd {\n+            let _ = file.into_raw_fd();\n+        }\n+        res.expect(\"failed to read /dev/urandom\");\n     }\n }\n "}]}