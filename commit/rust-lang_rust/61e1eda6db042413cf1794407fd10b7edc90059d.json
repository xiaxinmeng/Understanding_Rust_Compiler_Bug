{"sha": "61e1eda6db042413cf1794407fd10b7edc90059d", "node_id": "C_kwDOAAsO6NoAKDYxZTFlZGE2ZGIwNDI0MTNjZjE3OTQ0MDdmZDEwYjdlZGM5MDA1OWQ", "commit": {"author": {"name": "Le\u00f3n Orell Valerian Liehr", "email": "me@fmease.dev", "date": "2023-03-29T01:24:35Z"}, "committer": {"name": "Le\u00f3n Orell Valerian Liehr", "email": "me@fmease.dev", "date": "2023-05-04T14:59:11Z"}, "message": "IAT: Rustdoc integration", "tree": {"sha": "411915ab2c3c7c06c0862ab1f67a019c5b8b0c07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/411915ab2c3c7c06c0862ab1f67a019c5b8b0c07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61e1eda6db042413cf1794407fd10b7edc90059d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEXSQFaHGAjVoD5I3F0XoHIV9o5xMFAmRTyD8ACgkQ0XoHIV9o\n5xMwiA/+KPvVhR37ISrd0SieR4Qnjil8RpKgnjtIYPrPQ7gn+/qSxXJnAkfuHsCw\nRdtYnfDibipYL5YzqmMFBl0TiFj88fXSnHwPah7M1bfvCht78tCenKO1FwH/mJgw\nDC02gwhfKRxRTWilN2ft7hJNqCgtXuLi5rwJgO4pOh254rGVxCH5kWkR+9PISmw2\nlY+ad18+TUqh4xzZDhQqghBTj5QzlggchD3PW8ar12Czaqp+3xp3/ZegWTNxJMID\nmomt398MTpQKbKnrw3BHeu1G7M2bZ3Ez8eulVSfntJUK9eWOu02IWKq8qPrz1kKE\n5ys40ZCnxm/IWj2jhxDYZijXZdTT1YWmV4Gh9NcWYi8+OgJNryUD9EJKrWRTQmNj\nojCW50X5nYTaqoDFWLhVfp4lEpDY8nY/C2anCZk4tKYWiHiMwWdGDFhIwlObHE4Q\nlta2Xfz8TRlgCYZ75yw4X6gG1uQuiGeB8LslIw6Rulf/pNdtGY0CFl/rvHzHIXA+\nihAfdcDrewDkSVNOX7OqAalDgdIe3z/Mn2Muwz1lDTC+B3dsMF8KpFfNlA+qF2Vo\nx+QzZqcv9L86Lk/8yj00yzaJbUIT4VRB7k+LBVeekvpQmliKZoE6hWGDdQAPcYB4\numJGfNnagrOzYHtSUcCfD5NJcLOHKAOsIvLmTZAT72p0Lme/HOo=\n=Ncmj\n-----END PGP SIGNATURE-----", "payload": "tree 411915ab2c3c7c06c0862ab1f67a019c5b8b0c07\nparent 46ec3486116dacbd4fcfa1d92943de7fcc17921a\nauthor Le\u00f3n Orell Valerian Liehr <me@fmease.dev> 1680053075 +0200\ncommitter Le\u00f3n Orell Valerian Liehr <me@fmease.dev> 1683212351 +0200\n\nIAT: Rustdoc integration\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61e1eda6db042413cf1794407fd10b7edc90059d", "html_url": "https://github.com/rust-lang/rust/commit/61e1eda6db042413cf1794407fd10b7edc90059d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61e1eda6db042413cf1794407fd10b7edc90059d/comments", "author": {"login": "fmease", "id": 14913065, "node_id": "MDQ6VXNlcjE0OTEzMDY1", "avatar_url": "https://avatars.githubusercontent.com/u/14913065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmease", "html_url": "https://github.com/fmease", "followers_url": "https://api.github.com/users/fmease/followers", "following_url": "https://api.github.com/users/fmease/following{/other_user}", "gists_url": "https://api.github.com/users/fmease/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmease/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmease/subscriptions", "organizations_url": "https://api.github.com/users/fmease/orgs", "repos_url": "https://api.github.com/users/fmease/repos", "events_url": "https://api.github.com/users/fmease/events{/privacy}", "received_events_url": "https://api.github.com/users/fmease/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fmease", "id": 14913065, "node_id": "MDQ6VXNlcjE0OTEzMDY1", "avatar_url": "https://avatars.githubusercontent.com/u/14913065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmease", "html_url": "https://github.com/fmease", "followers_url": "https://api.github.com/users/fmease/followers", "following_url": "https://api.github.com/users/fmease/following{/other_user}", "gists_url": "https://api.github.com/users/fmease/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmease/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmease/subscriptions", "organizations_url": "https://api.github.com/users/fmease/orgs", "repos_url": "https://api.github.com/users/fmease/repos", "events_url": "https://api.github.com/users/fmease/events{/privacy}", "received_events_url": "https://api.github.com/users/fmease/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46ec3486116dacbd4fcfa1d92943de7fcc17921a", "url": "https://api.github.com/repos/rust-lang/rust/commits/46ec3486116dacbd4fcfa1d92943de7fcc17921a", "html_url": "https://github.com/rust-lang/rust/commit/46ec3486116dacbd4fcfa1d92943de7fcc17921a"}], "stats": {"total": 223, "additions": 183, "deletions": 40}, "files": [{"sha": "baf2b0a8585297e1654dbf08112eb83fad7c0868", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/61e1eda6db042413cf1794407fd10b7edc90059d/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e1eda6db042413cf1794407fd10b7edc90059d/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=61e1eda6db042413cf1794407fd10b7edc90059d", "patch": "@@ -556,7 +556,10 @@ where\n                 WherePredicate::EqPredicate { lhs, rhs, bound_params } => {\n                     match *lhs {\n                         Type::QPath(box QPathData {\n-                            ref assoc, ref self_type, ref trait_, ..\n+                            ref assoc,\n+                            ref self_type,\n+                            trait_: Some(ref trait_),\n+                            ..\n                         }) => {\n                             let ty = &*self_type;\n                             let mut new_trait = trait_.clone();"}, {"sha": "c852f9cca2bfde764fd4086449cdf143d5fe89a5", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/61e1eda6db042413cf1794407fd10b7edc90059d/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e1eda6db042413cf1794407fd10b7edc90059d/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=61e1eda6db042413cf1794407fd10b7edc90059d", "patch": "@@ -706,7 +706,12 @@ fn filter_non_trait_generics(trait_did: DefId, mut g: clean::Generics) -> clean:\n \n     g.where_predicates.retain(|pred| match pred {\n         clean::WherePredicate::BoundPredicate {\n-            ty: clean::QPath(box clean::QPathData { self_type: clean::Generic(ref s), trait_, .. }),\n+            ty:\n+                clean::QPath(box clean::QPathData {\n+                    self_type: clean::Generic(ref s),\n+                    trait_: Some(trait_),\n+                    ..\n+                }),\n             bounds,\n             ..\n         } => !(bounds.is_empty() || *s == kw::SelfUpper && trait_.def_id() == trait_did),"}, {"sha": "657f3c9ec4577fc598a237069a727de4cec02873", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 45, "deletions": 15, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/61e1eda6db042413cf1794407fd10b7edc90059d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e1eda6db042413cf1794407fd10b7edc90059d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=61e1eda6db042413cf1794407fd10b7edc90059d", "patch": "@@ -441,7 +441,7 @@ fn clean_projection<'tcx>(\n         assoc: projection_to_path_segment(ty, cx),\n         should_show_cast,\n         self_type,\n-        trait_,\n+        trait_: Some(trait_),\n     }))\n }\n \n@@ -1330,7 +1330,13 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n                 let mut bounds: Vec<GenericBound> = Vec::new();\n                 generics.where_predicates.retain_mut(|pred| match *pred {\n                     WherePredicate::BoundPredicate {\n-                        ty: QPath(box QPathData { ref assoc, ref self_type, ref trait_, .. }),\n+                        ty:\n+                            QPath(box QPathData {\n+                                ref assoc,\n+                                ref self_type,\n+                                trait_: Some(ref trait_),\n+                                ..\n+                            }),\n                         bounds: ref mut pred_bounds,\n                         ..\n                     } => {\n@@ -1492,25 +1498,30 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n                 assoc: clean_path_segment(p.segments.last().expect(\"segments were empty\"), cx),\n                 should_show_cast,\n                 self_type,\n-                trait_,\n+                trait_: Some(trait_),\n             }))\n         }\n         hir::QPath::TypeRelative(qself, segment) => {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-            let res = match ty.kind() {\n+            let self_type = clean_ty(qself, cx);\n+\n+            let (trait_, should_show_cast) = match ty.kind() {\n                 ty::Alias(ty::Projection, proj) => {\n-                    Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id)\n+                    let res = Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id);\n+                    let trait_ = clean_path(&hir::Path { span, res, segments: &[] }, cx);\n+                    register_res(cx, trait_.res);\n+                    let self_def_id = res.opt_def_id();\n+                    let should_show_cast =\n+                        compute_should_show_cast(self_def_id, &trait_, &self_type);\n+\n+                    (Some(trait_), should_show_cast)\n                 }\n+                ty::Alias(ty::Inherent, _) => (None, false),\n                 // Rustdoc handles `ty::Error`s by turning them into `Type::Infer`s.\n                 ty::Error(_) => return Type::Infer,\n-                // Otherwise, this is an inherent associated type.\n-                _ => return clean_middle_ty(ty::Binder::dummy(ty), cx, None),\n+                _ => bug!(\"clean: expected associated type, found `{ty:?}`\"),\n             };\n-            let trait_ = clean_path(&hir::Path { span, res, segments: &[] }, cx);\n-            register_res(cx, trait_.res);\n-            let self_def_id = res.opt_def_id();\n-            let self_type = clean_ty(qself, cx);\n-            let should_show_cast = compute_should_show_cast(self_def_id, &trait_, &self_type);\n+\n             Type::QPath(Box::new(QPathData {\n                 assoc: clean_path_segment(segment, cx),\n                 should_show_cast,\n@@ -1836,9 +1847,28 @@ pub(crate) fn clean_middle_ty<'tcx>(\n             clean_projection(bound_ty.rebind(*data), cx, parent_def_id)\n         }\n \n-        // FIXME(fmease): Clean inherent projections properly. This requires making the trait ref in\n-        // `QPathData` optional or alternatively adding a new `clean::Type` variant.\n-        ty::Alias(ty::Inherent, _data) => Type::Infer,\n+        ty::Alias(ty::Inherent, alias_ty) => {\n+            let alias_ty = bound_ty.rebind(alias_ty);\n+            let self_type = clean_middle_ty(alias_ty.map_bound(|ty| ty.self_ty()), cx, None);\n+\n+            Type::QPath(Box::new(QPathData {\n+                assoc: PathSegment {\n+                    name: cx.tcx.associated_item(alias_ty.skip_binder().def_id).name,\n+                    args: GenericArgs::AngleBracketed {\n+                        args: substs_to_args(\n+                            cx,\n+                            alias_ty.map_bound(|ty| ty.substs.as_slice()),\n+                            true,\n+                        )\n+                        .into(),\n+                        bindings: Default::default(),\n+                    },\n+                },\n+                should_show_cast: false,\n+                self_type,\n+                trait_: None,\n+            }))\n+        }\n \n         ty::Param(ref p) => {\n             if let Some(bounds) = cx.impl_trait_bounds.remove(&p.index.into()) {"}, {"sha": "38664c3e359a6b5fc44260599db35812cadd8599", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61e1eda6db042413cf1794407fd10b7edc90059d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e1eda6db042413cf1794407fd10b7edc90059d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=61e1eda6db042413cf1794407fd10b7edc90059d", "patch": "@@ -1660,7 +1660,7 @@ impl Type {\n \n     pub(crate) fn projection(&self) -> Option<(&Type, DefId, PathSegment)> {\n         if let QPath(box QPathData { self_type, trait_, assoc, .. }) = self {\n-            Some((self_type, trait_.def_id(), assoc.clone()))\n+            Some((self_type, trait_.as_ref()?.def_id(), assoc.clone()))\n         } else {\n             None\n         }\n@@ -1704,7 +1704,7 @@ pub(crate) struct QPathData {\n     pub self_type: Type,\n     /// FIXME: compute this field on demand.\n     pub should_show_cast: bool,\n-    pub trait_: Path,\n+    pub trait_: Option<Path>,\n }\n \n /// A primitive (aka, builtin) type."}, {"sha": "d963d6092c48f5b201fbc985ded3e589f7698916", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/61e1eda6db042413cf1794407fd10b7edc90059d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e1eda6db042413cf1794407fd10b7edc90059d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=61e1eda6db042413cf1794407fd10b7edc90059d", "patch": "@@ -1116,14 +1116,17 @@ fn fmt_type<'cx>(\n             ref trait_,\n             should_show_cast,\n         }) => {\n+            // FIXME(inherent_associated_types): Once we support non-ADT self-types (#106719),\n+            // we need to surround them with angle brackets in some cases (e.g. `<dyn \u2026>::P`).\n+\n             if f.alternate() {\n-                if should_show_cast {\n+                if let Some(trait_) = trait_ && should_show_cast {\n                     write!(f, \"<{:#} as {:#}>::\", self_type.print(cx), trait_.print(cx))?\n                 } else {\n                     write!(f, \"{:#}::\", self_type.print(cx))?\n                 }\n             } else {\n-                if should_show_cast {\n+                if let Some(trait_) = trait_ && should_show_cast {\n                     write!(f, \"&lt;{} as {}&gt;::\", self_type.print(cx), trait_.print(cx))?\n                 } else {\n                     write!(f, \"{}::\", self_type.print(cx))?\n@@ -1139,15 +1142,36 @@ fn fmt_type<'cx>(\n             //        the ugliness comes from inlining across crates where\n             //        everything comes in as a fully resolved QPath (hard to\n             //        look at).\n-            if !f.alternate() && let Ok((url, _, path)) = href(trait_.def_id(), cx) {\n-                write!(\n-                    f,\n-                    \"<a class=\\\"associatedtype\\\" href=\\\"{url}#{shortty}.{name}\\\" \\\n-                                title=\\\"type {path}::{name}\\\">{name}</a>\",\n-                    shortty = ItemType::AssocType,\n-                    name = assoc.name,\n-                    path = join_with_double_colon(&path),\n-                )\n+            if !f.alternate() {\n+                // FIXME(inherent_associated_types): We always link to the very first associated\n+                // type (in respect to source order) that bears the given name (`assoc.name`) and that is\n+                // affiliated with the computed `DefId`. This is obviously incorrect when we have\n+                // multiple impl blocks. Ideally, we would thread the `DefId` of the assoc ty itself\n+                // through here and map it to the corresponding HTML ID that was generated by\n+                // `render::Context::derive_id` when the impl blocks were rendered.\n+                // There is no such mapping unfortunately.\n+                // As a hack, we could badly imitate `derive_id` here by keeping *count* when looking\n+                // for the assoc ty `DefId` in `tcx.associated_items(self_ty_did).in_definition_order()`\n+                // considering privacy, `doc(hidden)`, etc.\n+                // I don't feel like that right now :cold_sweat:.\n+\n+                let parent_href = match trait_ {\n+                    Some(trait_) => href(trait_.def_id(), cx).ok(),\n+                    None => self_type.def_id(cx.cache()).and_then(|did| href(did, cx).ok()),\n+                };\n+\n+                if let Some((url, _, path)) = parent_href {\n+                    write!(\n+                        f,\n+                        \"<a class=\\\"associatedtype\\\" href=\\\"{url}#{shortty}.{name}\\\" \\\n+                                    title=\\\"type {path}::{name}\\\">{name}</a>\",\n+                        shortty = ItemType::AssocType,\n+                        name = assoc.name,\n+                        path = join_with_double_colon(&path),\n+                    )\n+                } else {\n+                    write!(f, \"{}\", assoc.name)\n+                }\n             } else {\n                 write!(f, \"{}\", assoc.name)\n             }?;"}, {"sha": "d6773169639c37e51b87d060a4d009e5678eb732", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61e1eda6db042413cf1794407fd10b7edc90059d/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e1eda6db042413cf1794407fd10b7edc90059d/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=61e1eda6db042413cf1794407fd10b7edc90059d", "patch": "@@ -2202,7 +2202,9 @@ fn collect_paths_for_type(first_ty: clean::Type, cache: &Cache) -> Vec<String> {\n             }\n             clean::Type::QPath(box clean::QPathData { self_type, trait_, .. }) => {\n                 work.push_back(self_type);\n-                process_path(trait_.def_id());\n+                if let Some(trait_) = trait_ {\n+                    process_path(trait_.def_id());\n+                }\n             }\n             _ => {}\n         }"}, {"sha": "b1cef20b434a650d1e7235dbf8fbd702d0cb264e", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61e1eda6db042413cf1794407fd10b7edc90059d/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e1eda6db042413cf1794407fd10b7edc90059d/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=61e1eda6db042413cf1794407fd10b7edc90059d", "patch": "@@ -574,7 +574,7 @@ impl FromWithTcx<clean::Type> for Type {\n                 name: assoc.name.to_string(),\n                 args: Box::new(assoc.args.into_tcx(tcx)),\n                 self_type: Box::new(self_type.into_tcx(tcx)),\n-                trait_: trait_.into_tcx(tcx),\n+                trait_: trait_.map(|trait_| trait_.into_tcx(tcx)),\n             },\n         }\n     }"}, {"sha": "3556834071fc964272e902fbdf3d706b5780cdad", "filename": "src/rustdoc-json-types/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61e1eda6db042413cf1794407fd10b7edc90059d/src%2Frustdoc-json-types%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e1eda6db042413cf1794407fd10b7edc90059d/src%2Frustdoc-json-types%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2Flib.rs?ref=61e1eda6db042413cf1794407fd10b7edc90059d", "patch": "@@ -8,7 +8,7 @@ use serde::{Deserialize, Serialize};\n use std::path::PathBuf;\n \n /// rustdoc format-version.\n-pub const FORMAT_VERSION: u32 = 24;\n+pub const FORMAT_VERSION: u32 = 25;\n \n /// A `Crate` is the root of the emitted JSON blob. It contains all type/documentation information\n /// about the language items in the local crate, as well as info about external items to allow\n@@ -581,13 +581,15 @@ pub enum Type {\n         #[serde(rename = \"type\")]\n         type_: Box<Type>,\n     },\n-    /// `<Type as Trait>::Name` or associated types like `T::Item` where `T: Iterator`\n+    /// Associated types like `<Type as Trait>::Name` and `T::Item` where\n+    /// `T: Iterator` or inherent associated types like `Struct::Name`.\n     QualifiedPath {\n         name: String,\n         args: Box<GenericArgs>,\n         self_type: Box<Type>,\n+        /// `None` iff this is an *inherent* associated type.\n         #[serde(rename = \"trait\")]\n-        trait_: Path,\n+        trait_: Option<Path>,\n     },\n }\n "}, {"sha": "bf8a64acf08d69237d717d1745085a0f2f8e7cb2", "filename": "src/tools/jsondoclint/src/validator.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61e1eda6db042413cf1794407fd10b7edc90059d/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e1eda6db042413cf1794407fd10b7edc90059d/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs?ref=61e1eda6db042413cf1794407fd10b7edc90059d", "patch": "@@ -273,7 +273,9 @@ impl<'a> Validator<'a> {\n             Type::QualifiedPath { name: _, args, self_type, trait_ } => {\n                 self.check_generic_args(&**args);\n                 self.check_type(&**self_type);\n-                self.check_path(trait_, PathKind::Trait);\n+                if let Some(trait_) = trait_ {\n+                    self.check_path(trait_, PathKind::Trait);\n+                }\n             }\n         }\n     }"}, {"sha": "9bda0acaf83fe7808a3e00eac2b1f1679278c99f", "filename": "tests/rustdoc/inherent-projections.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/61e1eda6db042413cf1794407fd10b7edc90059d/tests%2Frustdoc%2Finherent-projections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e1eda6db042413cf1794407fd10b7edc90059d/tests%2Frustdoc%2Finherent-projections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Finherent-projections.rs?ref=61e1eda6db042413cf1794407fd10b7edc90059d", "patch": "@@ -1,14 +1,44 @@\n #![feature(inherent_associated_types)]\n #![allow(incomplete_features)]\n \n-// FIXME(fmease): Properly render inherent projections.\n-\n-// @has inherent_projections/fn.create.html\n-// @has - '//pre[@class=\"rust item-decl\"]' \"create() -> _\"\n+// @has 'inherent_projections/fn.create.html'\n+// @has - '//pre[@class=\"rust item-decl\"]' \"create() -> Owner::Metadata\"\n+// @has - '//pre[@class=\"rust item-decl\"]//a[@class=\"associatedtype\"]/@href' 'struct.Owner.html#associatedtype.Metadata'\n pub fn create() -> Owner::Metadata {}\n \n pub struct Owner;\n \n impl Owner {\n     pub type Metadata = ();\n }\n+\n+// Make sure we handle bound vars correctly.\n+// @has 'inherent_projections/type.User.html' '//pre[@class=\"rust item-decl\"]' \"for<'a> fn(_: Carrier<'a>::Focus)\"\n+pub type User = for<'a> fn(Carrier<'a>::Focus);\n+\n+pub struct Carrier<'a>(&'a ());\n+\n+impl<'a> Carrier<'a> {\n+    pub type Focus = &'a mut i32;\n+}\n+\n+////////////////////////////////////////\n+\n+// FIXME(inherent_associated_types): Below we link to `Proj` but we should link to `Proj-1`.\n+// The current test checks for the buggy behavior for demonstration purposes.\n+\n+// @has 'inherent_projections/type.Test.html'\n+// @has - '//pre[@class=\"rust item-decl\"]' \"Parametrized<i32>\"\n+// @has - '//pre[@class=\"rust item-decl\"]//a[@class=\"associatedtype\"]/@href' 'struct.Parametrized.html#associatedtype.Proj'\n+// @!has - '//pre[@class=\"rust item-decl\"]//a[@class=\"associatedtype\"]/@href' 'struct.Parametrized.html#associatedtype.Proj-1'\n+pub type Test = Parametrized<i32>::Proj;\n+\n+pub struct Parametrized<T>(T);\n+\n+impl Parametrized<bool> {\n+    pub type Proj = ();\n+}\n+\n+impl Parametrized<i32> {\n+    pub type Proj = String;\n+}"}, {"sha": "2b28d2ae60bd4c45de72448f70c73c260062049b", "filename": "tests/rustdoc/intra-doc/inherent-associated-types.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/61e1eda6db042413cf1794407fd10b7edc90059d/tests%2Frustdoc%2Fintra-doc%2Finherent-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e1eda6db042413cf1794407fd10b7edc90059d/tests%2Frustdoc%2Fintra-doc%2Finherent-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fintra-doc%2Finherent-associated-types.rs?ref=61e1eda6db042413cf1794407fd10b7edc90059d", "patch": "@@ -0,0 +1,45 @@\n+#![feature(inherent_associated_types)]\n+\n+#![allow(incomplete_features)]\n+#![deny(rustdoc::broken_intra_doc_links)]\n+\n+// @has inherent_associated_types/index.html\n+\n+// @has - '//a/@href' 'enum.Simple.html#associatedtype.Type'\n+//! [`Simple::Type`]\n+\n+pub enum Simple {}\n+\n+impl Simple {\n+    pub type Type = ();\n+}\n+\n+////////////////////////////////////////\n+\n+// @has 'inherent_associated_types/type.Test0.html' '//a/@href' \\\n+//          'struct.Parametrized.html#associatedtype.Proj'\n+/// [`Parametrized<bool>::Proj`]\n+pub type Test0 = ();\n+\n+// FIXME(inherent_associated_types): The intra-doc link below should point to `Proj-1` not `Proj`.\n+// The current test checks for the buggy behavior for demonstration purposes.\n+// The same bug happens for inherent associated functions and constants (see #85960, #93398).\n+//\n+// Further, at some point we should reject the intra-doc link `Parametrized::Proj`.\n+// It currently links to `Parametrized<bool>::Proj`.\n+\n+// @has 'inherent_associated_types/type.Test1.html'\n+// @has - '//a/@href' 'struct.Parametrized.html#associatedtype.Proj'\n+// @!has - '//a/@href' 'struct.Parametrized.html#associatedtype.Proj-1'\n+/// [`Parametrized<i32>::Proj`]\n+pub type Test1 = ();\n+\n+pub struct Parametrized<T>(T);\n+\n+impl Parametrized<bool> {\n+    pub type Proj = ();\n+}\n+\n+impl Parametrized<i32> {\n+    pub type Proj = String;\n+}"}]}