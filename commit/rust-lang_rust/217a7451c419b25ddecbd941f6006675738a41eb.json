{"sha": "217a7451c419b25ddecbd941f6006675738a41eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxN2E3NDUxYzQxOWIyNWRkZWNiZDk0MWY2MDA2Njc1NzM4YTQxZWI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-06-09T19:27:37Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-06-09T19:36:28Z"}, "message": "expand: Give reasonable NodeIds to lints associated with macro definitions", "tree": {"sha": "ef0ecd3a5e77d292c5eba665f9f1446dd8e081e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef0ecd3a5e77d292c5eba665f9f1446dd8e081e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/217a7451c419b25ddecbd941f6006675738a41eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/217a7451c419b25ddecbd941f6006675738a41eb", "html_url": "https://github.com/rust-lang/rust/commit/217a7451c419b25ddecbd941f6006675738a41eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/217a7451c419b25ddecbd941f6006675738a41eb/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73d5cb0a456116f142e773a803715bbdb25988b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/73d5cb0a456116f142e773a803715bbdb25988b1", "html_url": "https://github.com/rust-lang/rust/commit/73d5cb0a456116f142e773a803715bbdb25988b1"}], "stats": {"total": 56, "additions": 36, "deletions": 20}, "files": [{"sha": "ca3e68fa6706e25972862965cb03b148d9b942c2", "filename": "src/librustc_expand/mbe/macro_check.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/217a7451c419b25ddecbd941f6006675738a41eb/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217a7451c419b25ddecbd941f6006675738a41eb/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs?ref=217a7451c419b25ddecbd941f6006675738a41eb", "patch": "@@ -106,7 +106,7 @@\n //! bound.\n use crate::mbe::{KleeneToken, TokenTree};\n \n-use rustc_ast::ast::NodeId;\n+use rustc_ast::ast::{NodeId, DUMMY_NODE_ID};\n use rustc_ast::token::{DelimToken, Token, TokenKind};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_session::lint::builtin::META_VARIABLE_MISUSE;\n@@ -626,5 +626,8 @@ fn ops_is_prefix(\n }\n \n fn buffer_lint(sess: &ParseSess, span: MultiSpan, node_id: NodeId, message: &str) {\n-    sess.buffer_lint(&META_VARIABLE_MISUSE, span, node_id, message);\n+    // Macros loaded from other crates have dummy node ids.\n+    if node_id != DUMMY_NODE_ID {\n+        sess.buffer_lint(&META_VARIABLE_MISUSE, span, node_id, message);\n+    }\n }"}, {"sha": "db8258a77863b8c3d3043fa656dd8267f2decdfe", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/217a7451c419b25ddecbd941f6006675738a41eb/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217a7451c419b25ddecbd941f6006675738a41eb/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=217a7451c419b25ddecbd941f6006675738a41eb", "patch": "@@ -383,7 +383,7 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n                 }\n             }\n             TokenTree::MetaVarDecl(span, _, id) if id.name == kw::Invalid => {\n-                if sess.missing_fragment_specifiers.borrow_mut().remove(&span) {\n+                if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n                     return Err((span, \"missing fragment specifier\".to_string()));\n                 }\n             }\n@@ -566,7 +566,7 @@ fn inner_parse_loop<'root, 'tt>(\n \n                 // We need to match a metavar (but the identifier is invalid)... this is an error\n                 TokenTree::MetaVarDecl(span, _, id) if id.name == kw::Invalid => {\n-                    if sess.missing_fragment_specifiers.borrow_mut().remove(&span) {\n+                    if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n                         return Error(span, \"missing fragment specifier\".to_string());\n                     }\n                 }"}, {"sha": "8cdb5b09c9e8b3dade6fdab096cc3391df435631", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/217a7451c419b25ddecbd941f6006675738a41eb/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217a7451c419b25ddecbd941f6006675738a41eb/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=217a7451c419b25ddecbd941f6006675738a41eb", "patch": "@@ -474,7 +474,9 @@ pub fn compile_declarative_macro(\n             .map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        let tt = mbe::quoted::parse(tt.clone().into(), true, sess).pop().unwrap();\n+                        let tt = mbe::quoted::parse(tt.clone().into(), true, sess, def.id)\n+                            .pop()\n+                            .unwrap();\n                         valid &= check_lhs_nt_follows(sess, features, &def.attrs, &tt);\n                         return tt;\n                     }\n@@ -491,7 +493,9 @@ pub fn compile_declarative_macro(\n             .map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        return mbe::quoted::parse(tt.clone().into(), false, sess).pop().unwrap();\n+                        return mbe::quoted::parse(tt.clone().into(), false, sess, def.id)\n+                            .pop()\n+                            .unwrap();\n                     }\n                 }\n                 sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n@@ -509,9 +513,7 @@ pub fn compile_declarative_macro(\n         valid &= check_lhs_no_empty_seq(sess, slice::from_ref(lhs));\n     }\n \n-    // We use CRATE_NODE_ID instead of `def.id` otherwise we may emit buffered lints for a node id\n-    // that is not lint-checked and trigger the \"failed to process buffered lint here\" bug.\n-    valid &= macro_check::check_meta_variables(sess, ast::CRATE_NODE_ID, def.span, &lhses, &rhses);\n+    valid &= macro_check::check_meta_variables(sess, def.id, def.span, &lhses, &rhses);\n \n     let (transparency, transparency_error) = attr::find_transparency(&def.attrs, macro_rules);\n     match transparency_error {"}, {"sha": "de66c2ada40e62ff32c72272c4f3bce76518b80c", "filename": "src/librustc_expand/mbe/quoted.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/217a7451c419b25ddecbd941f6006675738a41eb/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217a7451c419b25ddecbd941f6006675738a41eb/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs?ref=217a7451c419b25ddecbd941f6006675738a41eb", "patch": "@@ -1,6 +1,7 @@\n use crate::mbe::macro_parser;\n use crate::mbe::{Delimited, KleeneOp, KleeneToken, SequenceRepetition, TokenTree};\n \n+use rustc_ast::ast::{NodeId, DUMMY_NODE_ID};\n use rustc_ast::token::{self, Token};\n use rustc_ast::tokenstream;\n use rustc_ast_pretty::pprust;\n@@ -36,6 +37,7 @@ pub(super) fn parse(\n     input: tokenstream::TokenStream,\n     expect_matchers: bool,\n     sess: &ParseSess,\n+    node_id: NodeId,\n ) -> Vec<TokenTree> {\n     // Will contain the final collection of `self::TokenTree`\n     let mut result = Vec::new();\n@@ -46,7 +48,7 @@ pub(super) fn parse(\n     while let Some(tree) = trees.next() {\n         // Given the parsed tree, if there is a metavar and we are expecting matchers, actually\n         // parse out the matcher (i.e., in `$id:ident` this would parse the `:` and `ident`).\n-        let tree = parse_tree(tree, &mut trees, expect_matchers, sess);\n+        let tree = parse_tree(tree, &mut trees, expect_matchers, sess, node_id);\n         match tree {\n             TokenTree::MetaVar(start_sp, ident) if expect_matchers => {\n                 let span = match trees.next() {\n@@ -65,7 +67,10 @@ pub(super) fn parse(\n                     }\n                     tree => tree.as_ref().map(tokenstream::TokenTree::span).unwrap_or(start_sp),\n                 };\n-                sess.missing_fragment_specifiers.borrow_mut().insert(span);\n+                if node_id != DUMMY_NODE_ID {\n+                    // Macros loaded from other crates have dummy node ids.\n+                    sess.missing_fragment_specifiers.borrow_mut().insert(span, node_id);\n+                }\n                 result.push(TokenTree::MetaVarDecl(span, ident, Ident::invalid()));\n             }\n \n@@ -96,6 +101,7 @@ fn parse_tree(\n     trees: &mut impl Iterator<Item = tokenstream::TokenTree>,\n     expect_matchers: bool,\n     sess: &ParseSess,\n+    node_id: NodeId,\n ) -> TokenTree {\n     // Depending on what `tree` is, we could be parsing different parts of a macro\n     match tree {\n@@ -111,7 +117,7 @@ fn parse_tree(\n                     sess.span_diagnostic.span_err(span.entire(), &msg);\n                 }\n                 // Parse the contents of the sequence itself\n-                let sequence = parse(tts, expect_matchers, sess);\n+                let sequence = parse(tts, expect_matchers, sess, node_id);\n                 // Get the Kleene operator and optional separator\n                 let (separator, kleene) = parse_sep_and_kleene_op(trees, span.entire(), sess);\n                 // Count the number of captured \"names\" (i.e., named metavars)\n@@ -158,7 +164,7 @@ fn parse_tree(\n         // descend into the delimited set and further parse it.\n         tokenstream::TokenTree::Delimited(span, delim, tts) => TokenTree::Delimited(\n             span,\n-            Lrc::new(Delimited { delim, tts: parse(tts, expect_matchers, sess) }),\n+            Lrc::new(Delimited { delim, tts: parse(tts, expect_matchers, sess, node_id) }),\n         ),\n     }\n }"}, {"sha": "1a9bf4e1e8f3d0268f877df2cd00ffcb99f7d8ac", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/217a7451c419b25ddecbd941f6006675738a41eb/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217a7451c419b25ddecbd941f6006675738a41eb/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=217a7451c419b25ddecbd941f6006675738a41eb", "patch": "@@ -307,16 +307,21 @@ fn configure_and_expand_inner<'a>(\n             ecx.check_unused_macros();\n         });\n \n-        let mut missing_fragment_specifiers: Vec<_> =\n-            ecx.parse_sess.missing_fragment_specifiers.borrow().iter().cloned().collect();\n-        missing_fragment_specifiers.sort();\n+        let mut missing_fragment_specifiers: Vec<_> = ecx\n+            .parse_sess\n+            .missing_fragment_specifiers\n+            .borrow()\n+            .iter()\n+            .map(|(span, node_id)| (*span, *node_id))\n+            .collect();\n+        missing_fragment_specifiers.sort_unstable_by_key(|(span, _)| *span);\n \n         let recursion_limit_hit = ecx.reduced_recursion_limit.is_some();\n \n-        for span in missing_fragment_specifiers {\n+        for (span, node_id) in missing_fragment_specifiers {\n             let lint = lint::builtin::MISSING_FRAGMENT_SPECIFIER;\n             let msg = \"missing fragment specifier\";\n-            resolver.lint_buffer().buffer_lint(lint, ast::CRATE_NODE_ID, span, msg);\n+            resolver.lint_buffer().buffer_lint(lint, node_id, span, msg);\n         }\n         if cfg!(windows) {\n             env::set_var(\"PATH\", &old_path);"}, {"sha": "ddbc95fb1b0b8ed61888b9b91a4829924aec1913", "filename": "src/librustc_session/parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/217a7451c419b25ddecbd941f6006675738a41eb/src%2Flibrustc_session%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217a7451c419b25ddecbd941f6006675738a41eb/src%2Flibrustc_session%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fparse.rs?ref=217a7451c419b25ddecbd941f6006675738a41eb", "patch": "@@ -119,7 +119,7 @@ pub struct ParseSess {\n     pub unstable_features: UnstableFeatures,\n     pub config: CrateConfig,\n     pub edition: Edition,\n-    pub missing_fragment_specifiers: Lock<FxHashSet<Span>>,\n+    pub missing_fragment_specifiers: Lock<FxHashMap<Span, NodeId>>,\n     /// Places where raw identifiers were used. This is used for feature-gating raw identifiers.\n     pub raw_identifier_spans: Lock<Vec<Span>>,\n     /// Used to determine and report recursive module inclusions.\n@@ -150,7 +150,7 @@ impl ParseSess {\n             unstable_features: UnstableFeatures::from_environment(),\n             config: FxHashSet::default(),\n             edition: ExpnId::root().expn_data().edition,\n-            missing_fragment_specifiers: Lock::new(FxHashSet::default()),\n+            missing_fragment_specifiers: Default::default(),\n             raw_identifier_spans: Lock::new(Vec::new()),\n             included_mod_stack: Lock::new(vec![]),\n             source_map,"}]}