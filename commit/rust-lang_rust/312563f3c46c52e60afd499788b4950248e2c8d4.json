{"sha": "312563f3c46c52e60afd499788b4950248e2c8d4", "node_id": "C_kwDOAAsO6NoAKDMxMjU2M2YzYzQ2YzUyZTYwYWZkNDk5Nzg4YjQ5NTAyNDhlMmM4ZDQ", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-08-18T15:57:21Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-08-18T15:58:22Z"}, "message": "Use walk_chain for function span too\n\nThis is a correctness fix", "tree": {"sha": "a65150f2b1a254cba28ce0d125360deb52f7b4ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a65150f2b1a254cba28ce0d125360deb52f7b4ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/312563f3c46c52e60afd499788b4950248e2c8d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/312563f3c46c52e60afd499788b4950248e2c8d4", "html_url": "https://github.com/rust-lang/rust/commit/312563f3c46c52e60afd499788b4950248e2c8d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/312563f3c46c52e60afd499788b4950248e2c8d4/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "259b21fd46b9ccfd084bce3ec8043543ca9ea61a", "url": "https://api.github.com/repos/rust-lang/rust/commits/259b21fd46b9ccfd084bce3ec8043543ca9ea61a", "html_url": "https://github.com/rust-lang/rust/commit/259b21fd46b9ccfd084bce3ec8043543ca9ea61a"}], "stats": {"total": 85, "additions": 40, "deletions": 45}, "files": [{"sha": "eb1365167717fea880727054c843bc5e257f9566", "filename": "src/debuginfo/line_info.rs", "status": "modified", "additions": 40, "deletions": 45, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/312563f3c46c52e60afd499788b4950248e2c8d4/src%2Fdebuginfo%2Fline_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312563f3c46c52e60afd499788b4950248e2c8d4/src%2Fdebuginfo%2Fline_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fline_info.rs?ref=312563f3c46c52e60afd499788b4950248e2c8d4", "patch": "@@ -5,6 +5,7 @@ use std::path::{Component, Path};\n \n use crate::prelude::*;\n \n+use rustc_data_structures::sync::Lrc;\n use rustc_span::{\n     FileName, Pos, SourceFile, SourceFileAndLine, SourceFileHash, SourceFileHashAlgorithm,\n };\n@@ -47,9 +48,33 @@ fn osstr_as_utf8_bytes(path: &OsStr) -> &[u8] {\n     }\n }\n \n-pub(crate) const MD5_LEN: usize = 16;\n+fn get_span_loc(tcx: TyCtxt<'_>, function_span: Span, span: Span) -> (Lrc<SourceFile>, u64, u64) {\n+    // Based on https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src/librustc_codegen_ssa/mir/mod.rs#L116-L131\n+    // In order to have a good line stepping behavior in debugger, we overwrite debug\n+    // locations of macro expansions with that of the outermost expansion site\n+    // (unless the crate is being compiled with `-Z debug-macros`).\n+    let span = if !span.from_expansion() || tcx.sess.opts.unstable_opts.debug_macros {\n+        span\n+    } else {\n+        // Walk up the macro expansion chain until we reach a non-expanded span.\n+        // We also stop at the function body level because no line stepping can occur\n+        // at the level above that.\n+        rustc_span::hygiene::walk_chain(span, function_span.ctxt())\n+    };\n+\n+    match tcx.sess.source_map().lookup_line(span.lo()) {\n+        Ok(SourceFileAndLine { sf: file, line }) => {\n+            let line_pos = file.line_begin_pos(span.lo());\n+\n+            (file, u64::try_from(line).unwrap() + 1, u64::from((span.lo() - line_pos).to_u32()) + 1)\n+        }\n+        Err(file) => (file, 0, 0),\n+    }\n+}\n+\n+const MD5_LEN: usize = 16;\n \n-pub(crate) fn make_file_info(hash: SourceFileHash) -> Option<FileInfo> {\n+fn make_file_info(hash: SourceFileHash) -> Option<FileInfo> {\n     if hash.kind == SourceFileHashAlgorithm::Md5 {\n         let mut buf = [0u8; MD5_LEN];\n         buf.copy_from_slice(hash.hash_bytes());\n@@ -97,22 +122,6 @@ fn line_program_add_file(\n }\n \n impl DebugContext {\n-    fn emit_location(&mut self, tcx: TyCtxt<'_>, entry_id: UnitEntryId, span: Span) {\n-        let loc = tcx.sess.source_map().lookup_char_pos(span.lo());\n-\n-        let file_id = line_program_add_file(\n-            &mut self.dwarf.unit.line_program,\n-            &mut self.dwarf.line_strings,\n-            &loc.file,\n-        );\n-\n-        let entry = self.dwarf.unit.get_mut(entry_id);\n-\n-        entry.set(gimli::DW_AT_decl_file, AttributeValue::FileIndex(Some(file_id)));\n-        entry.set(gimli::DW_AT_decl_line, AttributeValue::Udata(loc.line as u64));\n-        entry.set(gimli::DW_AT_decl_column, AttributeValue::Udata(loc.col.to_usize() as u64));\n-    }\n-\n     pub(super) fn create_debug_lines(\n         &mut self,\n         tcx: TyCtxt<'_>,\n@@ -136,31 +145,7 @@ impl DebugContext {\n             }\n             last_span = Some(span);\n \n-            // Based on https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src/librustc_codegen_ssa/mir/mod.rs#L116-L131\n-            // In order to have a good line stepping behavior in debugger, we overwrite debug\n-            // locations of macro expansions with that of the outermost expansion site\n-            // (unless the crate is being compiled with `-Z debug-macros`).\n-            let span = if !span.from_expansion() || tcx.sess.opts.unstable_opts.debug_macros {\n-                span\n-            } else {\n-                // Walk up the macro expansion chain until we reach a non-expanded span.\n-                // We also stop at the function body level because no line stepping can occur\n-                // at the level above that.\n-                rustc_span::hygiene::walk_chain(span, function_span.ctxt())\n-            };\n-\n-            let (file, line, col) = match tcx.sess.source_map().lookup_line(span.lo()) {\n-                Ok(SourceFileAndLine { sf: file, line }) => {\n-                    let line_pos = file.line_begin_pos(span.lo());\n-\n-                    (\n-                        file,\n-                        u64::try_from(line).unwrap() + 1,\n-                        u64::from((span.lo() - line_pos).to_u32()) + 1,\n-                    )\n-                }\n-                Err(file) => (file, 0, 0),\n-            };\n+            let (file, line, col) = get_span_loc(tcx, function_span, span);\n \n             // line_program_add_file is very slow.\n             // Optimize for the common case of the current file not being changed.\n@@ -204,14 +189,24 @@ impl DebugContext {\n \n         assert_ne!(func_end, 0);\n \n+        let (function_file, function_line, function_col) =\n+            get_span_loc(tcx, function_span, function_span);\n+\n+        let function_file_id = line_program_add_file(\n+            &mut self.dwarf.unit.line_program,\n+            &mut self.dwarf.line_strings,\n+            &function_file,\n+        );\n+\n         let entry = self.dwarf.unit.get_mut(entry_id);\n         entry.set(\n             gimli::DW_AT_low_pc,\n             AttributeValue::Address(Address::Symbol { symbol, addend: 0 }),\n         );\n         entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(u64::from(func_end)));\n-\n-        self.emit_location(tcx, entry_id, function_span);\n+        entry.set(gimli::DW_AT_decl_file, AttributeValue::FileIndex(Some(function_file_id)));\n+        entry.set(gimli::DW_AT_decl_line, AttributeValue::Udata(function_line));\n+        entry.set(gimli::DW_AT_decl_column, AttributeValue::Udata(function_col));\n \n         func_end\n     }"}]}