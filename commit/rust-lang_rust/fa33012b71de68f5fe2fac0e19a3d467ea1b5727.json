{"sha": "fa33012b71de68f5fe2fac0e19a3d467ea1b5727", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhMzMwMTJiNzFkZTY4ZjVmZTJmYWMwZTE5YTNkNDY3ZWExYjU3Mjc=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-15T10:15:56Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-22T16:06:54Z"}, "message": "rustc: de-@ mem_categorization.", "tree": {"sha": "098ab4a589c36f1f74b1e1d8bb89eb85281a811f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/098ab4a589c36f1f74b1e1d8bb89eb85281a811f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa33012b71de68f5fe2fac0e19a3d467ea1b5727", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa33012b71de68f5fe2fac0e19a3d467ea1b5727", "html_url": "https://github.com/rust-lang/rust/commit/fa33012b71de68f5fe2fac0e19a3d467ea1b5727", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa33012b71de68f5fe2fac0e19a3d467ea1b5727/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d55deaeb217aeec7c1a5af859d389d926b08f80a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d55deaeb217aeec7c1a5af859d389d926b08f80a", "html_url": "https://github.com/rust-lang/rust/commit/d55deaeb217aeec7c1a5af859d389d926b08f80a"}], "stats": {"total": 352, "additions": 177, "deletions": 175}, "files": [{"sha": "e09507f5d5f44ac9fdc296796a6ad9dd19c0735a", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fa33012b71de68f5fe2fac0e19a3d467ea1b5727/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa33012b71de68f5fe2fac0e19a3d467ea1b5727/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=fa33012b71de68f5fe2fac0e19a3d467ea1b5727", "patch": "@@ -390,10 +390,9 @@ impl<'a> CheckLoanCtxt<'a> {\n         // Mutable values can be assigned, as long as they obey loans\n         // and aliasing restrictions:\n         if cmt.mutbl.is_mutable() {\n-            if check_for_aliasable_mutable_writes(self, expr, cmt) {\n+            if check_for_aliasable_mutable_writes(self, expr, cmt.clone()) {\n                 if check_for_assignment_to_restricted_or_frozen_location(\n-                    self, expr, cmt)\n-                {\n+                    self, expr, cmt.clone()) {\n                     // Safe, but record for lint pass later:\n                     mark_variable_as_used_mut(self, cmt);\n                 }\n@@ -403,9 +402,9 @@ impl<'a> CheckLoanCtxt<'a> {\n \n         // For immutable local variables, assignments are legal\n         // if they cannot already have been assigned\n-        if self.is_local_variable(cmt) {\n+        if self.is_local_variable(cmt.clone()) {\n             assert!(cmt.mutbl.is_immutable()); // no \"const\" locals\n-            let lp = opt_loan_path(cmt).unwrap();\n+            let lp = opt_loan_path(&cmt).unwrap();\n             self.move_data.each_assignment_of(expr.id, &lp, |assign| {\n                 self.bccx.report_reassigned_immutable_variable(\n                     expr.span,\n@@ -417,21 +416,21 @@ impl<'a> CheckLoanCtxt<'a> {\n         }\n \n         // Otherwise, just a plain error.\n-        match opt_loan_path(cmt) {\n+        match opt_loan_path(&cmt) {\n             Some(lp) => {\n                 self.bccx.span_err(\n                     expr.span,\n                     format!(\"cannot assign to {} {} `{}`\",\n                             cmt.mutbl.to_user_str(),\n-                            self.bccx.cmt_to_str(cmt),\n+                            self.bccx.cmt_to_str(&*cmt),\n                             self.bccx.loan_path_to_str(&*lp)));\n             }\n             None => {\n                 self.bccx.span_err(\n                     expr.span,\n                     format!(\"cannot assign to {} {}\",\n                             cmt.mutbl.to_user_str(),\n-                            self.bccx.cmt_to_str(cmt)));\n+                            self.bccx.cmt_to_str(&*cmt)));\n             }\n         }\n         return;\n@@ -448,7 +447,7 @@ impl<'a> CheckLoanCtxt<'a> {\n             loop {\n                 debug!(\"mark_writes_through_upvars_as_used_mut(cmt={})\",\n                        cmt.repr(this.tcx()));\n-                match cmt.cat {\n+                match cmt.cat.clone() {\n                     mc::cat_local(id) | mc::cat_arg(id) => {\n                         this.tcx().used_mut_nodes.borrow_mut().insert(id);\n                         return;\n@@ -496,10 +495,10 @@ impl<'a> CheckLoanCtxt<'a> {\n             debug!(\"check_for_aliasable_mutable_writes(cmt={}, guarantor={})\",\n                    cmt.repr(this.tcx()), guarantor.repr(this.tcx()));\n             match guarantor.cat {\n-                mc::cat_deref(b, _, mc::BorrowedPtr(ty::MutBorrow, _)) => {\n+                mc::cat_deref(ref b, _, mc::BorrowedPtr(ty::MutBorrow, _)) => {\n                     // Statically prohibit writes to `&mut` when aliasable\n \n-                    check_for_aliasability_violation(this, expr, b);\n+                    check_for_aliasability_violation(this, expr, b.clone());\n                 }\n \n                 _ => {}\n@@ -537,7 +536,7 @@ impl<'a> CheckLoanCtxt<'a> {\n             //! Check for assignments that violate the terms of an\n             //! outstanding loan.\n \n-            let loan_path = match opt_loan_path(cmt) {\n+            let loan_path = match opt_loan_path(&cmt) {\n                 Some(lp) => lp,\n                 None => { return true; /* no loan path, can't be any loans */ }\n             };\n@@ -814,7 +813,7 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n           if !this.move_data.is_assignee(expr.id) {\n               let cmt = this.bccx.cat_expr_unadjusted(expr);\n               debug!(\"path cmt={}\", cmt.repr(this.tcx()));\n-              for lp in opt_loan_path(cmt).iter() {\n+              for lp in opt_loan_path(&cmt).iter() {\n                   this.check_if_path_is_moved(expr.id, expr.span, MovedInUse, lp);\n               }\n           }"}, {"sha": "f4eee0526dd9321ebb2a9e5f91bae43093d8fe7b", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fa33012b71de68f5fe2fac0e19a3d467ea1b5727/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa33012b71de68f5fe2fac0e19a3d467ea1b5727/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=fa33012b71de68f5fe2fac0e19a3d467ea1b5727", "patch": "@@ -23,15 +23,15 @@ use syntax::ast;\n use syntax::codemap::Span;\n use util::ppaux::Repr;\n \n+use std::rc::Rc;\n+\n struct GatherMoveInfo {\n     id: ast::NodeId,\n     kind: MoveKind,\n     cmt: mc::cmt,\n     span_path_opt: Option<MoveSpanAndPath>\n }\n \n-use std::rc::Rc;\n-\n pub fn gather_decl(bccx: &BorrowckCtxt,\n                    move_data: &MoveData,\n                    decl_id: ast::NodeId,\n@@ -107,7 +107,7 @@ fn gather_move(bccx: &BorrowckCtxt,\n            move_info.id, move_info.cmt.repr(bccx.tcx));\n \n     let potentially_illegal_move =\n-                check_and_get_illegal_move_origin(bccx, move_info.cmt);\n+                check_and_get_illegal_move_origin(bccx, &move_info.cmt);\n     match potentially_illegal_move {\n         Some(illegal_move_origin) => {\n             let error = MoveError::with_move_info(illegal_move_origin,\n@@ -118,7 +118,7 @@ fn gather_move(bccx: &BorrowckCtxt,\n         None => ()\n     }\n \n-    match opt_loan_path(move_info.cmt) {\n+    match opt_loan_path(&move_info.cmt) {\n         Some(loan_path) => {\n             move_data.add_move(bccx.tcx, loan_path,\n                                move_info.id, move_info.kind);\n@@ -158,14 +158,14 @@ pub fn gather_move_and_assignment(bccx: &BorrowckCtxt,\n }\n \n fn check_and_get_illegal_move_origin(bccx: &BorrowckCtxt,\n-                                     cmt: mc::cmt) -> Option<mc::cmt> {\n+                                     cmt: &mc::cmt) -> Option<mc::cmt> {\n     match cmt.cat {\n         mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n         mc::cat_deref(_, _, mc::GcPtr) |\n         mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n         mc::cat_upvar(..) | mc::cat_static_item |\n         mc::cat_copied_upvar(mc::CopiedUpvar { onceness: ast::Many, .. }) => {\n-            Some(cmt)\n+            Some(cmt.clone())\n         }\n \n         // Can move out of captured upvars only if the destination closure\n@@ -181,12 +181,12 @@ fn check_and_get_illegal_move_origin(bccx: &BorrowckCtxt,\n             None\n         }\n \n-        mc::cat_downcast(b) |\n-        mc::cat_interior(b, _) => {\n+        mc::cat_downcast(ref b) |\n+        mc::cat_interior(ref b, _) => {\n             match ty::get(b.ty).sty {\n                 ty::ty_struct(did, _) | ty::ty_enum(did, _) => {\n                     if ty::has_dtor(bccx.tcx, did) {\n-                        Some(cmt)\n+                        Some(cmt.clone())\n                     } else {\n                         check_and_get_illegal_move_origin(bccx, b)\n                     }\n@@ -197,8 +197,8 @@ fn check_and_get_illegal_move_origin(bccx: &BorrowckCtxt,\n             }\n         }\n \n-        mc::cat_deref(b, _, mc::OwnedPtr) |\n-        mc::cat_discr(b, _) => {\n+        mc::cat_deref(ref b, _, mc::OwnedPtr) |\n+        mc::cat_discr(ref b, _) => {\n             check_and_get_illegal_move_origin(bccx, b)\n         }\n     }"}, {"sha": "a27fe5cec225260b32d44ec880199c97c330e4d2", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fa33012b71de68f5fe2fac0e19a3d467ea1b5727/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa33012b71de68f5fe2fac0e19a3d467ea1b5727/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=fa33012b71de68f5fe2fac0e19a3d467ea1b5727", "patch": "@@ -39,9 +39,9 @@ pub fn guarantee_lifetime(bccx: &BorrowckCtxt,\n                                          cause: cause,\n                                          loan_region: loan_region,\n                                          loan_kind: loan_kind,\n-                                         cmt_original: cmt,\n+                                         cmt_original: cmt.clone(),\n                                          root_scope_id: root_scope_id};\n-    ctxt.check(cmt, None)\n+    ctxt.check(&cmt, None)\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -69,7 +69,7 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n         self.bccx.tcx\n     }\n \n-    fn check(&self, cmt: mc::cmt, discr_scope: Option<ast::NodeId>) -> R {\n+    fn check(&self, cmt: &mc::cmt, discr_scope: Option<ast::NodeId>) -> R {\n         //! Main routine. Walks down `cmt` until we find the \"guarantor\".\n         debug!(\"guarantee_lifetime.check(cmt={}, loan_region={})\",\n                cmt.repr(self.bccx.tcx),\n@@ -83,15 +83,14 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             mc::cat_upvar(..) |\n             mc::cat_deref(_, _, mc::BorrowedPtr(..)) |  // L-Deref-Borrowed\n             mc::cat_deref(_, _, mc::UnsafePtr(..)) => {\n-                let scope = self.scope(cmt);\n-                self.check_scope(scope)\n+                self.check_scope(self.scope(cmt))\n             }\n \n             mc::cat_static_item => {\n                 Ok(())\n             }\n \n-            mc::cat_deref(base, derefs, mc::GcPtr) => {\n+            mc::cat_deref(ref base, derefs, mc::GcPtr) => {\n                 let base_scope = self.scope(base);\n \n                 // L-Deref-Managed-Imm-User-Root\n@@ -111,13 +110,13 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n                 }\n             }\n \n-            mc::cat_downcast(base) |\n-            mc::cat_deref(base, _, mc::OwnedPtr) |     // L-Deref-Send\n-            mc::cat_interior(base, _) => {             // L-Field\n+            mc::cat_downcast(ref base) |\n+            mc::cat_deref(ref base, _, mc::OwnedPtr) |     // L-Deref-Send\n+            mc::cat_interior(ref base, _) => {             // L-Field\n                 self.check(base, discr_scope)\n             }\n \n-            mc::cat_discr(base, new_discr_scope) => {\n+            mc::cat_discr(ref base, new_discr_scope) => {\n                 // Subtle: in a match, we must ensure that each binding\n                 // variable remains valid for the duration of the arm in\n                 // which it appears, presuming that this arm is taken.\n@@ -176,7 +175,7 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n     }\n \n     fn is_rvalue_or_immutable(&self,\n-                              cmt: mc::cmt) -> bool {\n+                              cmt: &mc::cmt) -> bool {\n         //! We can omit the root on an `@T` value if the location\n         //! that holds the box is either (1) an rvalue, in which case\n         //! it is in a non-user-accessible temporary, or (2) an immutable\n@@ -189,8 +188,8 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n     }\n \n     fn check_root(&self,\n-                  cmt_deref: mc::cmt,\n-                  cmt_base: mc::cmt,\n+                  cmt_deref: &mc::cmt,\n+                  cmt_base: &mc::cmt,\n                   derefs: uint,\n                   discr_scope: Option<ast::NodeId>) -> R {\n         debug!(\"check_root(cmt_deref={}, cmt_base={}, derefs={:?}, \\\n@@ -253,7 +252,7 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n         }\n     }\n \n-    fn is_moved(&self, cmt: mc::cmt) -> bool {\n+    fn is_moved(&self, cmt: &mc::cmt) -> bool {\n         //! True if `cmt` is something that is potentially moved\n         //! out of the current stack frame.\n \n@@ -269,17 +268,17 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             mc::cat_upvar(..) => {\n                 false\n             }\n-            r @ mc::cat_downcast(..) |\n-            r @ mc::cat_interior(..) |\n-            r @ mc::cat_discr(..) => {\n+            ref r @ mc::cat_downcast(..) |\n+            ref r @ mc::cat_interior(..) |\n+            ref r @ mc::cat_discr(..) => {\n                 self.tcx().sess.span_bug(\n                     cmt.span,\n                     format!(\"illegal guarantor category: {:?}\", r));\n             }\n         }\n     }\n \n-    fn scope(&self, cmt: mc::cmt) -> ty::Region {\n+    fn scope(&self, cmt: &mc::cmt) -> ty::Region {\n         //! Returns the maximal region scope for the which the\n         //! lvalue `cmt` is guaranteed to be valid without any\n         //! rooting etc, and presuming `cmt` is not mutated.\n@@ -307,18 +306,18 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             mc::cat_deref(_, _, mc::BorrowedPtr(_, r)) => {\n                 r\n             }\n-            mc::cat_downcast(cmt) |\n-            mc::cat_deref(cmt, _, mc::OwnedPtr) |\n-            mc::cat_deref(cmt, _, mc::GcPtr) |\n-            mc::cat_interior(cmt, _) |\n-            mc::cat_discr(cmt, _) => {\n+            mc::cat_downcast(ref cmt) |\n+            mc::cat_deref(ref cmt, _, mc::OwnedPtr) |\n+            mc::cat_deref(ref cmt, _, mc::GcPtr) |\n+            mc::cat_interior(ref cmt, _) |\n+            mc::cat_discr(ref cmt, _) => {\n                 self.scope(cmt)\n             }\n         }\n     }\n \n     fn report_error(&self, code: bckerr_code) {\n-        self.bccx.report(BckError { cmt: self.cmt_original,\n+        self.bccx.report(BckError { cmt: self.cmt_original.clone(),\n                                     span: self.span,\n                                     cause: self.cause,\n                                     code: code });"}, {"sha": "7f748dffd702b6d16f27db7c19929974bb9a8ee4", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fa33012b71de68f5fe2fac0e19a3d467ea1b5727/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa33012b71de68f5fe2fac0e19a3d467ea1b5727/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=fa33012b71de68f5fe2fac0e19a3d467ea1b5727", "patch": "@@ -230,7 +230,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n         let cmt = this.bccx.cat_expr(ex_v);\n         for arm in arms.iter() {\n             for pat in arm.pats.iter() {\n-                this.gather_pat(cmt, *pat, Some((arm.body.id, ex.id)));\n+                this.gather_pat(cmt.clone(), *pat, Some((arm.body.id, ex.id)));\n             }\n         }\n         visit::walk_expr(this, ex, ());\n@@ -300,7 +300,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n \n fn with_assignee_loan_path(bccx: &BorrowckCtxt, expr: &ast::Expr, op: |Rc<LoanPath>|) {\n     let cmt = bccx.cat_expr(expr);\n-    match opt_loan_path(cmt) {\n+    match opt_loan_path(&cmt) {\n         Some(lp) => op(lp),\n         None => {\n             // This can occur with e.g. `*foo() = 5`.  In such\n@@ -552,28 +552,28 @@ impl<'a> GatherLoanCtxt<'a> {\n         // Check that the lifetime of the borrow does not exceed\n         // the lifetime of the data being borrowed.\n         if lifetime::guarantee_lifetime(self.bccx, self.item_ub, root_ub,\n-                                        borrow_span, cause, cmt, loan_region,\n+                                        borrow_span, cause, cmt.clone(), loan_region,\n                                         req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         // Check that we don't allow mutable borrows of non-mutable data.\n         if check_mutability(self.bccx, borrow_span, cause,\n-                            cmt, req_kind).is_err() {\n+                            cmt.clone(), req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         // Check that we don't allow mutable borrows of aliasable data.\n         if check_aliasability(self.bccx, borrow_span, cause,\n-                              cmt, req_kind).is_err() {\n+                              cmt.clone(), req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         // Compute the restrictions that are required to enforce the\n         // loan is safe.\n         let restr = restrictions::compute_restrictions(\n             self.bccx, borrow_span, cause,\n-            cmt, loan_region, self.restriction_set(req_kind));\n+            cmt.clone(), loan_region, self.restriction_set(req_kind));\n \n         // Create the loan record (if needed).\n         let loan = match restr {"}, {"sha": "24d873e0ff76b878c353c9f31783c734bf2eac7b", "filename": "src/librustc/middle/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa33012b71de68f5fe2fac0e19a3d467ea1b5727/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa33012b71de68f5fe2fac0e19a3d467ea1b5727/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=fa33012b71de68f5fe2fac0e19a3d467ea1b5727", "patch": "@@ -79,7 +79,7 @@ pub struct GroupedMoveErrors {\n fn report_move_errors(bccx: &BorrowckCtxt, errors: &Vec<MoveError>) {\n     let grouped_errors = group_errors_with_same_origin(errors);\n     for error in grouped_errors.iter() {\n-        report_cannot_move_out_of(bccx, error.move_from);\n+        report_cannot_move_out_of(bccx, error.move_from.clone());\n         let mut is_first_note = true;\n         for move_to in error.move_to_places.iter() {\n             note_move_destination(bccx, move_to.span,\n@@ -112,7 +112,7 @@ fn group_errors_with_same_origin(errors: &Vec<MoveError>)\n             }\n         }\n         grouped_errors.push(GroupedMoveErrors {\n-            move_from: error.move_from,\n+            move_from: error.move_from.clone(),\n             move_to_places: move_to\n         })\n     }\n@@ -128,11 +128,11 @@ fn report_cannot_move_out_of(bccx: &BorrowckCtxt, move_from: mc::cmt) {\n             bccx.span_err(\n                 move_from.span,\n                 format!(\"cannot move out of {}\",\n-                        bccx.cmt_to_str(move_from)));\n+                        bccx.cmt_to_str(&*move_from)));\n         }\n \n-        mc::cat_downcast(b) |\n-        mc::cat_interior(b, _) => {\n+        mc::cat_downcast(ref b) |\n+        mc::cat_interior(ref b, _) => {\n             match ty::get(b.ty).sty {\n                 ty::ty_struct(did, _)\n                 | ty::ty_enum(did, _) if ty::has_dtor(bccx.tcx, did) => {"}, {"sha": "de4ce84fb0a59fd655886e49f8d472dbaba98d9b", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa33012b71de68f5fe2fac0e19a3d467ea1b5727/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa33012b71de68f5fe2fac0e19a3d467ea1b5727/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=fa33012b71de68f5fe2fac0e19a3d467ea1b5727", "patch": "@@ -35,7 +35,7 @@ pub fn compute_restrictions(bccx: &BorrowckCtxt,\n         bccx: bccx,\n         span: span,\n         cause: cause,\n-        cmt_original: cmt,\n+        cmt_original: cmt.clone(),\n         loan_region: loan_region,\n     };\n \n@@ -61,7 +61,7 @@ impl<'a> RestrictionsContext<'a> {\n                cmt.repr(self.bccx.tcx),\n                restrictions.repr(self.bccx.tcx));\n \n-        match cmt.cat {\n+        match cmt.cat.clone() {\n             mc::cat_rvalue(..) => {\n                 // Effectively, rvalues are stored into a\n                 // non-aliasable temporary on the stack. Since they"}, {"sha": "06491d36b021b5312ece3a25cb5b926800e66080", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fa33012b71de68f5fe2fac0e19a3d467ea1b5727/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa33012b71de68f5fe2fac0e19a3d467ea1b5727/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=fa33012b71de68f5fe2fac0e19a3d467ea1b5727", "patch": "@@ -225,7 +225,7 @@ impl LoanPath {\n     }\n }\n \n-pub fn opt_loan_path(cmt: mc::cmt) -> Option<Rc<LoanPath>> {\n+pub fn opt_loan_path(cmt: &mc::cmt) -> Option<Rc<LoanPath>> {\n     //! Computes the `LoanPath` (if any) for a `cmt`.\n     //! Note that this logic is somewhat duplicated in\n     //! the method `compute()` found in `gather_loans::restrictions`,\n@@ -246,20 +246,20 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<Rc<LoanPath>> {\n             Some(Rc::new(LpVar(id)))\n         }\n \n-        mc::cat_deref(cmt_base, _, pk) => {\n+        mc::cat_deref(ref cmt_base, _, pk) => {\n             opt_loan_path(cmt_base).map(|lp| {\n                 Rc::new(LpExtend(lp, cmt.mutbl, LpDeref(pk)))\n             })\n         }\n \n-        mc::cat_interior(cmt_base, ik) => {\n+        mc::cat_interior(ref cmt_base, ik) => {\n             opt_loan_path(cmt_base).map(|lp| {\n                 Rc::new(LpExtend(lp, cmt.mutbl, LpInterior(ik)))\n             })\n         }\n \n-        mc::cat_downcast(cmt_base) |\n-        mc::cat_discr(cmt_base, _) => {\n+        mc::cat_downcast(ref cmt_base) |\n+        mc::cat_discr(ref cmt_base, _) => {\n             opt_loan_path(cmt_base)\n         }\n     }\n@@ -469,14 +469,16 @@ impl<'a> BorrowckCtxt<'a> {\n     }\n \n     pub fn cat_discr(&self, cmt: mc::cmt, match_id: ast::NodeId) -> mc::cmt {\n-        @mc::cmt_ {cat:mc::cat_discr(cmt, match_id),\n-                   mutbl:cmt.mutbl.inherit(),\n-                   ..*cmt}\n+        Rc::new(mc::cmt_ {\n+            cat: mc::cat_discr(cmt.clone(), match_id),\n+            mutbl: cmt.mutbl.inherit(),\n+            ..*cmt\n+        })\n     }\n \n     pub fn cat_pattern(&self,\n                        cmt: mc::cmt,\n-                       pat: @ast::Pat,\n+                       pat: &ast::Pat,\n                        op: |mc::cmt, &ast::Pat|) {\n         let r = self.mc().cat_pattern(cmt, pat, |_,x,y| op(x,y));\n         assert!(r.is_ok());\n@@ -485,7 +487,7 @@ impl<'a> BorrowckCtxt<'a> {\n     pub fn report(&self, err: BckError) {\n         self.span_err(\n             err.span,\n-            self.bckerr_to_str(err));\n+            self.bckerr_to_str(&err));\n         self.note_and_explain_bckerr(err);\n     }\n \n@@ -607,16 +609,16 @@ impl<'a> BorrowckCtxt<'a> {\n         self.tcx.sess.span_end_note(s, m);\n     }\n \n-    pub fn bckerr_to_str(&self, err: BckError) -> ~str {\n+    pub fn bckerr_to_str(&self, err: &BckError) -> ~str {\n         match err.code {\n             err_mutbl => {\n-                let descr = match opt_loan_path(err.cmt) {\n+                let descr = match opt_loan_path(&err.cmt) {\n                     None => format!(\"{} {}\",\n                                     err.cmt.mutbl.to_user_str(),\n-                                    self.cmt_to_str(err.cmt)),\n+                                    self.cmt_to_str(&*err.cmt)),\n                     Some(lp) => format!(\"{} {} `{}`\",\n                                         err.cmt.mutbl.to_user_str(),\n-                                        self.cmt_to_str(err.cmt),\n+                                        self.cmt_to_str(&*err.cmt),\n                                         self.loan_path_to_str(&*lp)),\n                 };\n \n@@ -633,16 +635,16 @@ impl<'a> BorrowckCtxt<'a> {\n                 format!(\"cannot root managed value long enough\")\n             }\n             err_out_of_scope(..) => {\n-                let msg = match opt_loan_path(err.cmt) {\n+                let msg = match opt_loan_path(&err.cmt) {\n                     None => format!(\"borrowed value\"),\n                     Some(lp) => format!(\"`{}`\", self.loan_path_to_str(&*lp)),\n                 };\n                 format!(\"{} does not live long enough\", msg)\n             }\n             err_borrowed_pointer_too_short(..) => {\n-                let descr = match opt_loan_path(err.cmt) {\n+                let descr = match opt_loan_path(&err.cmt) {\n                     Some(lp) => format!(\"`{}`\", self.loan_path_to_str(&*lp)),\n-                    None => self.cmt_to_str(err.cmt),\n+                    None => self.cmt_to_str(&*err.cmt),\n                 };\n \n                 format!(\"lifetime of {} is too short to guarantee \\\n@@ -734,9 +736,9 @@ impl<'a> BorrowckCtxt<'a> {\n             }\n \n             err_borrowed_pointer_too_short(loan_scope, ptr_scope, _) => {\n-                let descr = match opt_loan_path(err.cmt) {\n+                let descr = match opt_loan_path(&err.cmt) {\n                     Some(lp) => format!(\"`{}`\", self.loan_path_to_str(&*lp)),\n-                    None => self.cmt_to_str(err.cmt),\n+                    None => self.cmt_to_str(&*err.cmt),\n                 };\n                 note_and_explain_region(\n                     self.tcx,\n@@ -809,7 +811,7 @@ impl<'a> BorrowckCtxt<'a> {\n         result.into_owned()\n     }\n \n-    pub fn cmt_to_str(&self, cmt: mc::cmt) -> ~str {\n+    pub fn cmt_to_str(&self, cmt: &mc::cmt_) -> ~str {\n         self.mc().cmt_to_str(cmt)\n     }\n }"}, {"sha": "35124aa9916990ddd32a5a56036809c2613d3060", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 80, "deletions": 78, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/fa33012b71de68f5fe2fac0e19a3d467ea1b5727/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa33012b71de68f5fe2fac0e19a3d467ea1b5727/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=fa33012b71de68f5fe2fac0e19a3d467ea1b5727", "patch": "@@ -74,8 +74,9 @@ use syntax::print::pprust;\n use syntax::parse::token;\n \n use std::cell::RefCell;\n+use std::rc::Rc;\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub enum categorization {\n     cat_rvalue(ty::Region),            // temporary val, argument is its scope\n     cat_static_item,\n@@ -91,14 +92,14 @@ pub enum categorization {\n     // (*1) downcast is only required if the enum has more than one variant\n }\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct CopiedUpvar {\n     pub upvar_id: ast::NodeId,\n     pub onceness: ast::Onceness,\n }\n \n // different kinds of pointers:\n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub enum PointerKind {\n     OwnedPtr,\n     GcPtr,\n@@ -108,26 +109,26 @@ pub enum PointerKind {\n \n // We use the term \"interior\" to mean \"something reachable from the\n // base without a pointer dereference\", e.g. a field\n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub enum InteriorKind {\n     InteriorField(FieldName),\n     InteriorElement(ElementKind),\n }\n \n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub enum FieldName {\n     NamedField(ast::Name),\n     PositionalField(uint)\n }\n \n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub enum ElementKind {\n     VecElement,\n     StrElement,\n     OtherElement,\n }\n \n-#[deriving(Eq, TotalEq, Hash, Show)]\n+#[deriving(Clone, Eq, TotalEq, Hash, Show)]\n pub enum MutabilityCategory {\n     McImmutable, // Immutable.\n     McDeclared,  // Directly declared as mutable.\n@@ -148,7 +149,7 @@ pub enum MutabilityCategory {\n // dereference, but its type is the type *before* the dereference\n // (`@T`). So use `cmt.type` to find the type of the value in a consistent\n // fashion. For more details, see the method `cat_pattern`\n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n pub struct cmt_ {\n     pub id: ast::NodeId,          // id of expr/pat producing this value\n     pub span: Span,                // span of same expr/pat\n@@ -157,7 +158,7 @@ pub struct cmt_ {\n     pub ty: ty::t                  // type of the expr (*see WARNING above*)\n }\n \n-pub type cmt = @cmt_;\n+pub type cmt = Rc<cmt_>;\n \n // We pun on *T to mean both actual deref of a ptr as well\n // as accessing of components:\n@@ -368,7 +369,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         self.typer.node_ty(id)\n     }\n \n-    fn pat_ty(&self, pat: @ast::Pat) -> McResult<ty::t> {\n+    fn pat_ty(&self, pat: &ast::Pat) -> McResult<ty::t> {\n         self.typer.node_ty(pat.id)\n     }\n \n@@ -385,8 +386,9 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                         // Implicity casts a concrete object to trait object\n                         // so just patch up the type\n                         let expr_ty = if_ok!(self.expr_ty_adjusted(expr));\n-                        let expr_cmt = if_ok!(self.cat_expr_unadjusted(expr));\n-                        Ok(@cmt_ {ty: expr_ty, ..*expr_cmt})\n+                        let mut expr_cmt = (*if_ok!(self.cat_expr_unadjusted(expr))).clone();\n+                        expr_cmt.ty = expr_ty;\n+                        Ok(Rc::new(expr_cmt))\n                     }\n \n                     ty::AutoAddEnv(..) => {\n@@ -492,23 +494,23 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n           ast::DefUse(_) | ast::DefTrait(_) | ast::DefTy(_) | ast::DefPrimTy(_) |\n           ast::DefTyParam(..) | ast::DefTyParamBinder(..) | ast::DefRegion(_) |\n           ast::DefLabel(_) | ast::DefSelfTy(..) | ast::DefMethod(..) => {\n-              Ok(@cmt_ {\n+              Ok(Rc::new(cmt_ {\n                   id:id,\n                   span:span,\n                   cat:cat_static_item,\n                   mutbl: McImmutable,\n                   ty:expr_ty\n-              })\n+              }))\n           }\n \n           ast::DefStatic(_, true) => {\n-              Ok(@cmt_ {\n+              Ok(Rc::new(cmt_ {\n                   id:id,\n                   span:span,\n                   cat:cat_static_item,\n                   mutbl: McDeclared,\n                   ty:expr_ty\n-              })\n+              }))\n           }\n \n           ast::DefArg(vid, binding_mode) => {\n@@ -520,13 +522,13 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                 ast::BindByValue(ast::MutMutable) => McDeclared,\n                 _ => McImmutable\n             };\n-            Ok(@cmt_ {\n+            Ok(Rc::new(cmt_ {\n                 id: id,\n                 span: span,\n                 cat: cat_arg(vid),\n                 mutbl: m,\n                 ty:expr_ty\n-            })\n+            }))\n           }\n \n           ast::DefUpvar(var_id, _, fn_node_id, _) => {\n@@ -550,15 +552,15 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                           self.cat_upvar(id, span, var_id, fn_node_id)\n                       } else {\n                           // FIXME #2152 allow mutation of moved upvars\n-                          Ok(@cmt_ {\n+                          Ok(Rc::new(cmt_ {\n                               id:id,\n                               span:span,\n                               cat:cat_copied_upvar(CopiedUpvar {\n                                   upvar_id: var_id,\n                                   onceness: closure_ty.onceness}),\n                               mutbl:McImmutable,\n                               ty:expr_ty\n-                          })\n+                          }))\n                       }\n                   }\n                   _ => {\n@@ -578,13 +580,13 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                 _ => McImmutable\n             };\n \n-            Ok(@cmt_ {\n+            Ok(Rc::new(cmt_ {\n                 id: id,\n                 span: span,\n                 cat: cat_local(vid),\n                 mutbl: m,\n                 ty: expr_ty\n-            })\n+            }))\n           }\n         }\n     }\n@@ -618,23 +620,23 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         // give err type. Nobody should be inspecting this type anyhow.\n         let upvar_ty = ty::mk_err();\n \n-        let base_cmt = @cmt_ {\n+        let base_cmt = Rc::new(cmt_ {\n             id:id,\n             span:span,\n             cat:cat_upvar(upvar_id, upvar_borrow),\n             mutbl:McImmutable,\n             ty:upvar_ty,\n-        };\n+        });\n \n         let ptr = BorrowedPtr(upvar_borrow.kind, upvar_borrow.region);\n \n-        let deref_cmt = @cmt_ {\n+        let deref_cmt = Rc::new(cmt_ {\n             id:id,\n             span:span,\n             cat:cat_deref(base_cmt, 0, ptr),\n             mutbl:MutabilityCategory::from_borrow_kind(upvar_borrow.kind),\n             ty:var_ty,\n-        };\n+        });\n \n         Ok(deref_cmt)\n     }\n@@ -659,13 +661,13 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                       span: Span,\n                       temp_scope: ty::Region,\n                       expr_ty: ty::t) -> cmt {\n-        @cmt_ {\n+        Rc::new(cmt_ {\n             id:cmt_id,\n             span:span,\n             cat:cat_rvalue(temp_scope),\n             mutbl:McDeclared,\n             ty:expr_ty\n-        }\n+        })\n     }\n \n     pub fn cat_field<N:ast_node>(&self,\n@@ -674,13 +676,13 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                                  f_name: ast::Ident,\n                                  f_ty: ty::t)\n                                  -> cmt {\n-        @cmt_ {\n+        Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n-            cat: cat_interior(base_cmt, InteriorField(NamedField(f_name.name))),\n             mutbl: base_cmt.mutbl.inherit(),\n+            cat: cat_interior(base_cmt, InteriorField(NamedField(f_name.name))),\n             ty: f_ty\n-        }\n+        })\n     }\n \n     pub fn cat_deref_obj<N:ast_node>(&self, node: &N, base_cmt: cmt) -> cmt {\n@@ -736,13 +738,13 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                 (base_cmt.mutbl.inherit(), cat_interior(base_cmt, interior))\n             }\n         };\n-        @cmt_ {\n+        Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             cat: cat,\n             mutbl: m,\n             ty: deref_ty\n-        }\n+        })\n     }\n \n     pub fn cat_index<N:ast_node>(&self,\n@@ -798,21 +800,21 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n             let m = MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr);\n \n             // the deref is explicit in the resulting cmt\n-            let deref_cmt = @cmt_ {\n+            let deref_cmt = Rc::new(cmt_ {\n                 id:elt.id(),\n                 span:elt.span(),\n-                cat:cat_deref(base_cmt, derefs, ptr),\n+                cat:cat_deref(base_cmt.clone(), derefs, ptr),\n                 mutbl:m,\n                 ty:element_ty\n-            };\n+            });\n \n             interior(elt, deref_cmt, base_cmt.ty, m.inherit(), element_ty)\n           }\n \n           deref_interior(_) => {\n             // fixed-length vectors have no deref\n             let m = base_cmt.mutbl.inherit();\n-            interior(elt, base_cmt, base_cmt.ty, m, element_ty)\n+            interior(elt, base_cmt.clone(), base_cmt.ty, m, element_ty)\n           }\n         };\n \n@@ -822,19 +824,19 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                                  mutbl: MutabilityCategory,\n                                  element_ty: ty::t) -> cmt\n         {\n-            @cmt_ {\n+            Rc::new(cmt_ {\n                 id:elt.id(),\n                 span:elt.span(),\n                 cat:cat_interior(of_cmt, InteriorElement(element_kind(vec_ty))),\n                 mutbl:mutbl,\n                 ty:element_ty\n-            }\n+            })\n         }\n     }\n \n     pub fn cat_slice_pattern(&self,\n                              vec_cmt: cmt,\n-                             slice_pat: @ast::Pat)\n+                             slice_pat: &ast::Pat)\n                              -> McResult<(cmt, ast::Mutability, ty::Region)> {\n         /*!\n          * Given a pattern P like: `[_, ..Q, _]`, where `vec_cmt` is\n@@ -854,7 +856,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         return Ok((cmt_slice, slice_mutbl, slice_r));\n \n         fn vec_slice_info(tcx: &ty::ctxt,\n-                          pat: @ast::Pat,\n+                          pat: &ast::Pat,\n                           slice_ty: ty::t)\n                           -> (ast::Mutability, ty::Region) {\n             /*!\n@@ -885,27 +887,27 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                                         interior_ty: ty::t,\n                                         interior: InteriorKind)\n                                         -> cmt {\n-        @cmt_ {\n+        Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n-            cat: cat_interior(base_cmt, interior),\n             mutbl: base_cmt.mutbl.inherit(),\n+            cat: cat_interior(base_cmt, interior),\n             ty: interior_ty\n-        }\n+        })\n     }\n \n     pub fn cat_downcast<N:ast_node>(&self,\n                                     node: &N,\n                                     base_cmt: cmt,\n                                     downcast_ty: ty::t)\n                                     -> cmt {\n-        @cmt_ {\n+        Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n-            cat: cat_downcast(base_cmt),\n             mutbl: base_cmt.mutbl.inherit(),\n+            cat: cat_downcast(base_cmt),\n             ty: downcast_ty\n-        }\n+        })\n     }\n \n     pub fn cat_pattern(&self,\n@@ -964,7 +966,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                pat.id, pprust::pat_to_str(pat),\n                cmt.repr(self.tcx()));\n \n-        op(self, cmt, pat);\n+        op(self, cmt.clone(), pat);\n \n         match pat.node {\n           ast::PatWild | ast::PatWildMulti => {\n@@ -983,7 +985,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                         if ty::enum_is_univariant(self.tcx(), enum_did) {\n                             cmt // univariant, no downcast needed\n                         } else {\n-                            self.cat_downcast(pat, cmt, cmt.ty)\n+                            self.cat_downcast(pat, cmt.clone(), cmt.ty)\n                         }\n                     };\n \n@@ -992,7 +994,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n \n                         let subcmt =\n                             self.cat_imm_interior(\n-                                pat, downcast_cmt, subpat_ty,\n+                                pat, downcast_cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n \n                         if_ok!(self.cat_pattern(subcmt, subpat, |x,y,z| op(x,y,z)));\n@@ -1004,14 +1006,14 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                         let subpat_ty = if_ok!(self.pat_ty(subpat)); // see (*2)\n                         let cmt_field =\n                             self.cat_imm_interior(\n-                                pat, cmt, subpat_ty,\n+                                pat, cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n                         if_ok!(self.cat_pattern(cmt_field, subpat, |x,y,z| op(x,y,z)));\n                     }\n                 }\n                 Some(&ast::DefStatic(..)) => {\n                     for &subpat in subpats.iter() {\n-                        if_ok!(self.cat_pattern(cmt, subpat, |x,y,z| op(x,y,z)));\n+                        if_ok!(self.cat_pattern(cmt.clone(), subpat, |x,y,z| op(x,y,z)));\n                     }\n                 }\n                 _ => {\n@@ -1034,7 +1036,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n             // {f1: p1, ..., fN: pN}\n             for fp in field_pats.iter() {\n                 let field_ty = if_ok!(self.pat_ty(fp.pat)); // see (*2)\n-                let cmt_field = self.cat_field(pat, cmt, fp.ident, field_ty);\n+                let cmt_field = self.cat_field(pat, cmt.clone(), fp.ident, field_ty);\n                 if_ok!(self.cat_pattern(cmt_field, fp.pat, |x,y,z| op(x,y,z)));\n             }\n           }\n@@ -1045,7 +1047,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                 let subpat_ty = if_ok!(self.pat_ty(subpat)); // see (*2)\n                 let subcmt =\n                     self.cat_imm_interior(\n-                        pat, cmt, subpat_ty,\n+                        pat, cmt.clone(), subpat_ty,\n                         InteriorField(PositionalField(i)));\n                 if_ok!(self.cat_pattern(subcmt, subpat, |x,y,z| op(x,y,z)));\n             }\n@@ -1060,15 +1062,15 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n           ast::PatVec(ref before, slice, ref after) => {\n               let elt_cmt = self.cat_index(pat, cmt, 0);\n               for &before_pat in before.iter() {\n-                  if_ok!(self.cat_pattern(elt_cmt, before_pat, |x,y,z| op(x,y,z)));\n+                  if_ok!(self.cat_pattern(elt_cmt.clone(), before_pat, |x,y,z| op(x,y,z)));\n               }\n               for &slice_pat in slice.iter() {\n                   let slice_ty = if_ok!(self.pat_ty(slice_pat));\n                   let slice_cmt = self.cat_rvalue_node(pat.id(), pat.span(), slice_ty);\n                   if_ok!(self.cat_pattern(slice_cmt, slice_pat, |x,y,z| op(x,y,z)));\n               }\n               for &after_pat in after.iter() {\n-                  if_ok!(self.cat_pattern(elt_cmt, after_pat, |x,y,z| op(x,y,z)));\n+                  if_ok!(self.cat_pattern(elt_cmt.clone(), after_pat, |x,y,z| op(x,y,z)));\n               }\n           }\n \n@@ -1080,7 +1082,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         Ok(())\n     }\n \n-    pub fn cmt_to_str(&self, cmt: cmt) -> ~str {\n+    pub fn cmt_to_str(&self, cmt: &cmt_) -> ~str {\n         match cmt.cat {\n           cat_static_item => {\n               \"static item\".to_owned()\n@@ -1097,7 +1099,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n           cat_arg(..) => {\n               \"argument\".to_owned()\n           }\n-          cat_deref(base, _, pk) => {\n+          cat_deref(ref base, _, pk) => {\n               match base.cat {\n                   cat_upvar(..) => {\n                       format!(\"captured outer variable\")\n@@ -1125,11 +1127,11 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n           cat_upvar(..) => {\n               \"captured outer variable\".to_owned()\n           }\n-          cat_discr(cmt, _) => {\n-            self.cmt_to_str(cmt)\n+          cat_discr(ref cmt, _) => {\n+            self.cmt_to_str(&**cmt)\n           }\n-          cat_downcast(cmt) => {\n-            self.cmt_to_str(cmt)\n+          cat_downcast(ref cmt) => {\n+            self.cmt_to_str(&**cmt)\n           }\n         }\n     }\n@@ -1149,7 +1151,7 @@ pub enum AliasableReason {\n }\n \n impl cmt_ {\n-    pub fn guarantor(self) -> cmt {\n+    pub fn guarantor(&self) -> cmt {\n         //! Returns `self` after stripping away any owned pointer derefs or\n         //! interior content. The return value is basically the `cmt` which\n         //! determines how long the value in `self` remains live.\n@@ -1164,12 +1166,12 @@ impl cmt_ {\n             cat_deref(_, _, GcPtr(..)) |\n             cat_deref(_, _, BorrowedPtr(..)) |\n             cat_upvar(..) => {\n-                @self\n+                Rc::new((*self).clone())\n             }\n-            cat_downcast(b) |\n-            cat_discr(b, _) |\n-            cat_interior(b, _) |\n-            cat_deref(b, _, OwnedPtr) => {\n+            cat_downcast(ref b) |\n+            cat_discr(ref b, _) |\n+            cat_interior(ref b, _) |\n+            cat_deref(ref b, _, OwnedPtr) => {\n                 b.guarantor()\n             }\n         }\n@@ -1186,12 +1188,12 @@ impl cmt_ {\n         // aliased and eventually recused.\n \n         match self.cat {\n-            cat_deref(b, _, BorrowedPtr(ty::MutBorrow, _)) |\n-            cat_deref(b, _, BorrowedPtr(ty::UniqueImmBorrow, _)) |\n-            cat_downcast(b) |\n-            cat_deref(b, _, OwnedPtr) |\n-            cat_interior(b, _) |\n-            cat_discr(b, _) => {\n+            cat_deref(ref b, _, BorrowedPtr(ty::MutBorrow, _)) |\n+            cat_deref(ref b, _, BorrowedPtr(ty::UniqueImmBorrow, _)) |\n+            cat_downcast(ref b) |\n+            cat_deref(ref b, _, OwnedPtr) |\n+            cat_interior(ref b, _) |\n+            cat_discr(ref b, _) => {\n                 // Aliasability depends on base cmt\n                 b.freely_aliasable(ctxt)\n             }\n@@ -1255,21 +1257,21 @@ impl Repr for categorization {\n             cat_arg(..) => {\n                 format!(\"{:?}\", *self)\n             }\n-            cat_deref(cmt, derefs, ptr) => {\n+            cat_deref(ref cmt, derefs, ptr) => {\n                 format!(\"{}-{}{}->\",\n                         cmt.cat.repr(tcx),\n                         ptr_sigil(ptr),\n                         derefs)\n             }\n-            cat_interior(cmt, interior) => {\n+            cat_interior(ref cmt, interior) => {\n                 format!(\"{}.{}\",\n                      cmt.cat.repr(tcx),\n                      interior.repr(tcx))\n             }\n-            cat_downcast(cmt) => {\n+            cat_downcast(ref cmt) => {\n                 format!(\"{}->(enum)\", cmt.cat.repr(tcx))\n             }\n-            cat_discr(cmt, _) => {\n+            cat_discr(ref cmt, _) => {\n                 cmt.cat.repr(tcx)\n             }\n         }"}, {"sha": "7273023e1bfeb0b3fe60e9e7a6daa84be40d0c9a", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fa33012b71de68f5fe2fac0e19a3d467ea1b5727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa33012b71de68f5fe2fac0e19a3d467ea1b5727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=fa33012b71de68f5fe2fac0e19a3d467ea1b5727", "patch": "@@ -1065,7 +1065,7 @@ fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n     debug!(\"discr_cmt={}\", discr_cmt.repr(mc.typer.tcx()));\n     for arm in arms.iter() {\n         for &root_pat in arm.pats.iter() {\n-            link_pattern(mc, discr_cmt, root_pat);\n+            link_pattern(mc, discr_cmt.clone(), root_pat);\n         }\n     }\n }\n@@ -1194,7 +1194,7 @@ fn link_region(rcx: &Rcx,\n                region_min.repr(rcx.tcx()),\n                mutbl.repr(rcx.tcx()),\n                cmt_borrowed.repr(rcx.tcx()));\n-        match cmt_borrowed.cat {\n+        match cmt_borrowed.cat.clone() {\n             mc::cat_deref(base, _, mc::BorrowedPtr(_, r_borrowed)) => {\n                 // References to an upvar `x` are translated to\n                 // `*x`, since that is what happens in the\n@@ -1304,7 +1304,7 @@ fn adjust_upvar_borrow_kind_for_mut(rcx: &Rcx,\n         debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={})\",\n                cmt.repr(rcx.tcx()));\n \n-        match cmt.cat {\n+        match cmt.cat.clone() {\n             mc::cat_deref(base, _, mc::OwnedPtr) |\n             mc::cat_interior(base, _) |\n             mc::cat_downcast(base) |\n@@ -1328,14 +1328,14 @@ fn adjust_upvar_borrow_kind_for_mut(rcx: &Rcx,\n                         return adjust_upvar_borrow_kind(*upvar_id, ub, ty::MutBorrow);\n                     }\n \n-                    _ => {\n-                        // assignment to deref of an `&mut`\n-                        // borrowed pointer implies that the\n-                        // pointer itself must be unique, but not\n-                        // necessarily *mutable*\n-                        return adjust_upvar_borrow_kind_for_unique(rcx, base);\n-                    }\n+                    _ => {}\n                 }\n+\n+                // assignment to deref of an `&mut`\n+                // borrowed pointer implies that the\n+                // pointer itself must be unique, but not\n+                // necessarily *mutable*\n+                return adjust_upvar_borrow_kind_for_unique(rcx, base);\n             }\n \n             mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n@@ -1358,7 +1358,7 @@ fn adjust_upvar_borrow_kind_for_unique(rcx: &Rcx, cmt: mc::cmt) {\n         debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={})\",\n                cmt.repr(rcx.tcx()));\n \n-        match cmt.cat {\n+        match cmt.cat.clone() {\n             mc::cat_deref(base, _, mc::OwnedPtr) |\n             mc::cat_interior(base, _) |\n             mc::cat_downcast(base) |\n@@ -1381,12 +1381,12 @@ fn adjust_upvar_borrow_kind_for_unique(rcx: &Rcx, cmt: mc::cmt) {\n                         return adjust_upvar_borrow_kind(*upvar_id, ub, ty::UniqueImmBorrow);\n                     }\n \n-                    _ => {\n-                        // for a borrowed pointer to be unique, its\n-                        // base must be unique\n-                        return adjust_upvar_borrow_kind_for_unique(rcx, base);\n-                    }\n+                    _ => {}\n                 }\n+\n+                // for a borrowed pointer to be unique, its\n+                // base must be unique\n+                return adjust_upvar_borrow_kind_for_unique(rcx, base);\n             }\n \n             mc::cat_deref(_, _, mc::UnsafePtr(..)) |"}]}