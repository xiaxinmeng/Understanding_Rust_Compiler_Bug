{"sha": "64f5dbc9f872492bbd211da67d651e8e1942b99b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0ZjVkYmM5Zjg3MjQ5MmJiZDIxMWRhNjdkNjUxZThlMTk0MmI5OWI=", "commit": {"author": {"name": "Josh Holmer", "email": "joshua.holmer@nextgearcapital.com", "date": "2017-01-04T04:40:42Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2017-01-04T23:50:30Z"}, "message": "Rustup to rustc 1.16.0-nightly (468227129 2017-01-03): Body fixes for rustup", "tree": {"sha": "38417078257a27897b5fd3f946cd52d162489ce5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38417078257a27897b5fd3f946cd52d162489ce5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64f5dbc9f872492bbd211da67d651e8e1942b99b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64f5dbc9f872492bbd211da67d651e8e1942b99b", "html_url": "https://github.com/rust-lang/rust/commit/64f5dbc9f872492bbd211da67d651e8e1942b99b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64f5dbc9f872492bbd211da67d651e8e1942b99b/comments", "author": null, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f552f170db6da0133fb5452ea22cf80551dbc875", "url": "https://api.github.com/repos/rust-lang/rust/commits/f552f170db6da0133fb5452ea22cf80551dbc875", "html_url": "https://github.com/rust-lang/rust/commit/f552f170db6da0133fb5452ea22cf80551dbc875"}], "stats": {"total": 222, "additions": 118, "deletions": 104}, "files": [{"sha": "f5ba053d28cee2ce9acc694ce0c79ab5204417b6", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -157,23 +157,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n \n fn is_relevant_item(cx: &LateContext, item: &Item) -> bool {\n     if let ItemFn(_, _, _, _, _, eid) = item.node {\n-        is_relevant_expr(cx, cx.tcx.map.expr(eid))\n+        is_relevant_expr(cx, &cx.tcx.map.body(eid).value)\n     } else {\n         false\n     }\n }\n \n fn is_relevant_impl(cx: &LateContext, item: &ImplItem) -> bool {\n     match item.node {\n-        ImplItemKind::Method(_, eid) => is_relevant_expr(cx, cx.tcx.map.expr(eid)),\n+        ImplItemKind::Method(_, eid) => is_relevant_expr(cx, &cx.tcx.map.body(eid).value),\n         _ => false,\n     }\n }\n \n fn is_relevant_trait(cx: &LateContext, item: &TraitItem) -> bool {\n     match item.node {\n-        TraitItemKind::Method(_, None) => true,\n-        TraitItemKind::Method(_, Some(eid)) => is_relevant_expr(cx, cx.tcx.map.expr(eid)),\n+        TraitItemKind::Method(_, TraitMethod::Required(_)) => true,\n+        TraitItemKind::Method(_, TraitMethod::Provided(eid)) => is_relevant_expr(cx, &cx.tcx.map.body(eid).value),\n         _ => false,\n     }\n }"}, {"sha": "2e2b6ee8b93704de35a0c85039daa81033658b31", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -57,9 +57,9 @@ struct ExVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx: 'a> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if let ExprClosure(_, _, eid, _) = expr.node {\n-            let expr = self.cx.tcx.map.expr(eid);\n+            let expr = self.cx.tcx.map.body(eid).value;\n             if matches!(expr.node, ExprBlock(_)) {\n-                self.found_block = Some(expr);\n+                self.found_block = Some(&expr);\n                 return;\n             }\n         }"}, {"sha": "cb73d419eb2467e1b332deb3a228dc6b44ae63e0", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -258,8 +258,12 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             ExprLit(ref lit) => Some(lit_to_constant(&lit.node)),\n             ExprArray(ref vec) => self.multi(vec).map(Constant::Vec),\n             ExprTup(ref tup) => self.multi(tup).map(Constant::Tuple),\n-            ExprRepeat(ref value, ref number) => {\n-                self.binop_apply(value, number, |v, n| Some(Constant::Repeat(Box::new(v), n.as_u64() as usize)))\n+            ExprRepeat(ref value, numberId) => {\n+                if let Some(lcx) = self.lcx {\n+                    self.binop_apply(value, &lcx.tcx.map.body(numberId).value, |v, n| Some(Constant::Repeat(Box::new(v), n.as_u64() as usize)))\n+                } else {\n+                    None\n+                }\n             },\n             ExprUnary(op, ref operand) => {\n                 self.expr(operand).and_then(|o| {"}, {"sha": "f2aabfca69e6f45f9da448dcc4fd6ddc56859a15", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -94,20 +94,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CyclomaticComplexity {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemFn(_, _, _, _, _, eid) = item.node {\n             if !attr::contains_name(&item.attrs, \"test\") {\n-                self.check(cx, cx.tcx.map.expr(eid), item.span);\n+                self.check(cx, &cx.tcx.map.body(eid).value, item.span);\n             }\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n         if let ImplItemKind::Method(_, eid) = item.node {\n-            self.check(cx, cx.tcx.map.expr(eid), item.span);\n+            self.check(cx, &cx.tcx.map.body(eid).value, item.span);\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n-        if let TraitItemKind::Method(_, Some(eid)) = item.node {\n-            self.check(cx, cx.tcx.map.expr(eid), item.span);\n+        if let TraitItemKind::Method(_, TraitMethod::Provided(eid)) = item.node {\n+            self.check(cx, &cx.tcx.map.body(eid).value, item.span);\n         }\n     }\n "}, {"sha": "72a88be016e9b52dec178a86dfdd98e014337879", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -42,9 +42,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n         if let ItemEnum(ref def, _) = item.node {\n             for var in &def.variants {\n                 let variant = &var.node;\n-                if let Some(ref disr) = variant.disr_expr {\n+                if let Some(bodyId) = variant.disr_expr {\n                     use rustc_const_eval::*;\n-                    let bad = match eval_const_expr_partial(cx.tcx, &**disr, EvalHint::ExprTypeChecked, None) {\n+                    let bad = match eval_const_expr_partial(cx.tcx, &cx.tcx.map.body(bodyId).value, EvalHint::ExprTypeChecked, None) {\n                         Ok(ConstVal::Integral(Usize(Us64(i)))) => i as u32 as u64 != i,\n                         Ok(ConstVal::Integral(Isize(Is64(i)))) => i as i32 as i64 != i,\n                         _ => false,"}, {"sha": "3384693c51ec9dc3d056ea9ea8d2e479a9803685", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -64,8 +64,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         &mut self,\n         cx: &LateContext<'a, 'tcx>,\n         _: visit::FnKind<'tcx>,\n-        decl: &'tcx FnDecl,\n-        body: &'tcx Expr,\n+        _: &'tcx FnDecl,\n+        body: &'tcx Body,\n         _: Span,\n         id: NodeId\n     ) {\n@@ -82,7 +82,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         let infcx = cx.tcx.borrowck_fake_infer_ctxt(param_env);\n         {\n             let mut vis = ExprUseVisitor::new(&mut v, &infcx);\n-            vis.walk_fn(decl, body);\n+            vis.consume_body(body);\n         }\n \n         for node in v.set {"}, {"sha": "a30cd87554c5fbdf2f5566ad2f39b05edb43986e", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -49,14 +49,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaPass {\n \n fn check_closure(cx: &LateContext, expr: &Expr) {\n     if let ExprClosure(_, ref decl, eid, _) = expr.node {\n-        let ex = cx.tcx.map.expr(eid);\n+        let ex = cx.tcx.map.body(eid).value;\n         if let ExprCall(ref caller, ref args) = ex.node {\n             if args.len() != decl.inputs.len() {\n                 // Not the same number of arguments, there\n                 // is no way the closure is the same as the function\n                 return;\n             }\n-            if is_adjusted(cx, ex) || args.iter().any(|arg| is_adjusted(cx, arg)) {\n+            if is_adjusted(cx, &ex) || args.iter().any(|arg| is_adjusted(cx, arg)) {\n                 // Are the expression or the arguments type-adjusted? Then we need the closure\n                 return;\n             }\n@@ -72,7 +72,7 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n                 _ => (),\n             }\n             for (a1, a2) in decl.inputs.iter().zip(args) {\n-                if let PatKind::Binding(_, _, ident, _) = a1.pat.node {\n+                if let PatKind::Binding(_, _, ident, _) = a1.node {\n                     // XXXManishearth Should I be checking the binding mode here?\n                     if let ExprPath(QPath::Resolved(None, ref p)) = a2.node {\n                         if p.segments.len() != 1 {"}, {"sha": "7194f45d9501a0767459f5cf1198256904445955", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -81,7 +81,7 @@ pub fn get_argument_fmtstr_parts<'a, 'b>(cx: &LateContext<'a, 'b>, expr: &'a Exp\n         let Some(NodeItem(decl)) = cx.tcx.map.find(decl.id),\n         &*decl.name.as_str() == \"__STATIC_FMTSTR\",\n         let ItemStatic(_, _, ref expr) = decl.node,\n-        let ExprAddrOf(_, ref expr) = expr.node, // &[\"\u2026\", \"\u2026\", \u2026]\n+        let ExprAddrOf(_, ref expr) = cx.tcx.map.body(*expr).value.node, // &[\"\u2026\", \"\u2026\", \u2026]\n         let ExprArray(ref exprs) = expr.node,\n     ], {\n         let mut result = Vec::new();"}, {"sha": "18bc644a26389afb2e51f345bf3266bfaa80605e", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n         cx: &LateContext<'a, 'tcx>,\n         kind: intravisit::FnKind<'tcx>,\n         decl: &'tcx hir::FnDecl,\n-        expr: &'tcx hir::Expr,\n+        body: &'tcx hir::Body,\n         span: Span,\n         nodeid: ast::NodeId\n     ) {\n@@ -102,7 +102,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n             }\n         }\n \n-        self.check_raw_ptr(cx, unsafety, decl, expr, nodeid);\n+        self.check_raw_ptr(cx, unsafety, decl, &body.value, nodeid);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem) {\n@@ -112,9 +112,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n                 self.check_arg_number(cx, &sig.decl, item.span);\n             }\n \n-            if let Some(eid) = eid {\n-                let expr = cx.tcx.map.expr(eid);\n-                self.check_raw_ptr(cx, sig.unsafety, &sig.decl, expr, item.id);\n+            if let hir::TraitMethod::Provided(eid) = eid {\n+                let expr = cx.tcx.map.body(eid).value;\n+                self.check_raw_ptr(cx, sig.unsafety, &sig.decl, &expr, item.id);\n             }\n         }\n     }\n@@ -154,8 +154,8 @@ impl<'a, 'tcx> Functions {\n     }\n }\n \n-fn raw_ptr_arg(_cx: &LateContext, arg: &hir::Arg) -> Option<hir::def_id::DefId> {\n-    if let (&hir::PatKind::Binding(_, def_id, _, _), &hir::TyPtr(_)) = (&arg.pat.node, &arg.ty.node) {\n+fn raw_ptr_arg(cx: &LateContext, arg: &hir::Arg) -> Option<hir::def_id::DefId> {\n+    if let (&hir::PatKind::Binding(_, def_id, _, _), &hir::TyPtr(_)) = (&arg.pat.node, &cx.tcx.map.get(arg.id)) {\n         Some(def_id)\n     } else {\n         None"}, {"sha": "42ba0ebfc402598393d09dc0d5f72eea07c5a8c6", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -4,7 +4,8 @@ use rustc::ty;\n use rustc::hir::*;\n use syntax::ast::{Lit, LitKind, Name};\n use syntax::codemap::{Span, Spanned};\n-use utils::{get_item_name, in_macro, snippet, span_lint, span_lint_and_then, walk_ptrs_ty};\n+use utils::{get_item_name, in_macro, snippet, span_lint, span_lint_and_then, walk_ptrs_ty,\n+    is_self, has_self};\n \n /// **What it does:** Checks for getting the length of something via `.len()`\n /// just to compare to zero, and suggests using `.is_empty()` where applicable.\n@@ -89,16 +90,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n \n fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[TraitItem]) {\n     fn is_named_self(item: &TraitItem, name: &str) -> bool {\n-        &*item.name.as_str() == name &&\n         if let TraitItemKind::Method(ref sig, _) = item.node {\n-            if sig.decl.has_self() {\n-                sig.decl.inputs.len() == 1\n-            } else {\n-                false\n-            }\n-        } else {\n-            false\n+            return has_self(&*sig.decl) && &*item.name.as_str() == name && sig.decl.inputs.len() == 1;\n         }\n+        false\n     }\n \n     if !trait_items.iter().any(|i| is_named_self(i, \"is_empty\")) {"}, {"sha": "2c3b06a98c4e7b38cb724be107de220a53705294", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -137,7 +137,7 @@ fn could_use_elision<'a, 'tcx: 'a, T: Iterator<Item = &'tcx Lifetime>>(\n \n     // extract lifetimes in input argument types\n     for arg in &func.inputs {\n-        input_visitor.visit_ty(&arg.ty);\n+        input_visitor.visit_ty(&arg);\n     }\n     // extract lifetimes in output type\n     if let Return(ref ty) = func.output {"}, {"sha": "1418a18d3c55e941601c55ff7ff3f3964f2fdb4a", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -31,18 +31,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             if &*name.node.as_str() == \"map\" && args.len() == 2 {\n                 match args[1].node {\n                     ExprClosure(_, ref decl, closure_eid, _) => {\n-                        let closure_expr = remove_blocks(cx.tcx.map.expr(closure_eid));\n+                        let closure_expr = remove_blocks(&cx.tcx.map.body(closure_eid).value);\n                         if_let_chain! {[\n                             // nothing special in the argument, besides reference bindings\n                             // (e.g. .map(|&x| x) )\n-                            let Some(arg_ident) = get_arg_name(&*decl.inputs[0].pat),\n+                            let Some(arg_ident) = get_arg_name(&*decl.inputs[0]),\n                             // the method is being called on a known type (option or iterator)\n                             let Some(type_name) = get_type_name(cx, expr, &args[0])\n                         ], {\n                             // look for derefs, for .map(|x| *x)\n                             if only_derefs(cx, &*closure_expr, arg_ident) &&\n                                 // .cloned() only removes one level of indirection, don't lint on more\n-                                walk_ptrs_ty_depth(cx.tcx.tables().pat_ty(&*decl.inputs[0].pat)).1 == 1\n+                                walk_ptrs_ty_depth(cx.tcx.tables().pat_ty(&*decl.inputs[0])).1 == 1\n                             {\n                                 span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n                                     \"you seem to be using .map() to clone the contents of an {}, consider \\\n@@ -90,7 +90,7 @@ fn expr_eq_name(expr: &Expr, id: ast::Name) -> bool {\n                                    name: id,\n                                    parameters: PathParameters::none(),\n                                }];\n-            !path.global && path.segments[..] == arg_segment\n+            !path.is_global() && path.segments[..] == arg_segment\n         },\n         _ => false,\n     }"}, {"sha": "f25b5d01cea812921f558e2074662c90b084fcb7", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -219,10 +219,10 @@ fn check_single_match_opt_like(\n             if inner.iter().any(|pat| pat.node != PatKind::Wild) {\n                 return;\n             }\n-            path.to_string()\n+            print::to_string(print::NO_ANN, |s| s.print_qpath(path, false))\n         },\n         PatKind::Binding(BindByValue(MutImmutable), _, ident, None) => ident.node.to_string(),\n-        PatKind::Path(ref path) => path.to_string(),\n+        PatKind::Path(ref path) => print::to_string(print::NO_ANN, |s| s.print_qpath(path, false)),\n         _ => return,\n     };\n "}, {"sha": "c6986cb5456e1d95d51c043cb749143e4ac7c352", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -11,7 +11,7 @@ use syntax::codemap::Span;\n use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, match_path, match_trait_method,\n             match_type, method_chain_args, return_ty, same_tys, snippet, span_lint, span_lint_and_then,\n             span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, last_path_segment, single_segment_path,\n-            match_def_path};\n+            match_def_path, is_self};\n use utils::paths;\n use utils::sugg;\n \n@@ -645,7 +645,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 if &*name.as_str() == method_name &&\n                    sig.decl.inputs.len() == n_args &&\n                    out_type.matches(&sig.decl.output) &&\n-                   self_kind.matches(&first_arg, false) {\n+                   self_kind.matches(&**first_arg, false) {\n                     span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n                         \"defining a method called `{}` on this type; consider implementing \\\n                          the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n@@ -658,8 +658,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             for &(ref conv, self_kinds) in &CONVENTIONS {\n                 if_let_chain! {[\n                     conv.check(&name.as_str()),\n-                    let Some(explicit_self) = sig.decl.inputs.get(0).and_then(hir::Arg::to_self),\n-                    !self_kinds.iter().any(|k| k.matches(&explicit_self, is_copy)),\n+                    let Some(explicit_self) = sig.decl.inputs.get(0),\n+                    !self_kinds.iter().any(|k| k.matches(&**explicit_self, is_copy)),\n                 ], {\n                     let lint = if item.vis == hir::Visibility::Public {\n                         WRONG_PUB_SELF_CONVENTION\n@@ -684,7 +684,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                !ret_ty.walk().any(|t| same_tys(cx, t, ty, implitem.id)) {\n                 span_lint(cx,\n                           NEW_RET_NO_SELF,\n-                          explicit_self.span,\n+                          first_arg.span,\n                           \"methods called `new` usually return `Self`\");\n             }\n         }}\n@@ -751,7 +751,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n     ) {\n         // don't lint for constant values\n         // FIXME: can we `expect` here instead of match?\n-        let promotable = cx.tcx().rvalue_promotable_to_static.borrow()\n+        let promotable = cx.tcx.rvalue_promotable_to_static.borrow()\n                              .get(&arg.id).cloned().unwrap_or(true);\n         if !promotable {\n             return;\n@@ -1338,7 +1338,7 @@ const PATTERN_METHODS: [(&'static str, usize); 17] = [\n ];\n \n \n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, PartialEq)]\n enum SelfKind {\n     Value,\n     Ref,\n@@ -1348,18 +1348,19 @@ enum SelfKind {\n \n impl SelfKind {\n     fn matches(self, slf: &hir::Arg, allow_value_for_ref: bool) -> bool {\n-        if !slf.has_self() {\n-            return self == No;\n-        }\n-        match (self, &slf.node) {\n-            (SelfKind::Value, &hir::SelfKind::Value(_)) |\n-            (SelfKind::Ref, &hir::SelfKind::Region(_, hir::Mutability::MutImmutable)) |\n-            (SelfKind::RefMut, &hir::SelfKind::Region(_, hir::Mutability::MutMutable)) => true,\n-            (SelfKind::Ref, &hir::SelfKind::Value(_)) |\n-            (SelfKind::RefMut, &hir::SelfKind::Value(_)) => allow_value_for_ref,\n-            (_, &hir::SelfKind::Explicit(ref ty, _)) => self.matches_explicit_type(ty, allow_value_for_ref),\n-\n-            _ => false,\n+        if is_self(slf) {\n+           match (self, &slf.pat.node) {\n+                (SelfKind::Value, &hir::PatKind::Binding(hir::BindingMode::BindByValue(_), ..)) |\n+                (SelfKind::Ref, &hir::PatKind::Ref(_, hir::Mutability::MutImmutable)) |\n+                (SelfKind::RefMut, &hir::PatKind::Ref(_, hir::Mutability::MutMutable)) => true,\n+                (SelfKind::Ref, &hir::PatKind::Binding(hir::BindingMode::BindByRef(hir::Mutability::MutImmutable), ..)) |\n+                (SelfKind::RefMut, &hir::PatKind::Binding(hir::BindingMode::BindByRef(hir::Mutability::MutMutable), ..)) => allow_value_for_ref,\n+//                (_, &hir::PatKind::Explicit(ref ty, _)) => self.matches_explicit_type(ty, allow_value_for_ref),\n+\n+                _ => false,\n+            }\n+        } else {\n+            self == SelfKind::No\n         }\n     }\n "}, {"sha": "e81b9c989cd4ff20b02dcba06668afd844dbecd9", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -175,7 +175,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         cx: &LateContext<'a, 'tcx>,\n         k: FnKind<'tcx>,\n         decl: &'tcx FnDecl,\n-        _: &'tcx Expr,\n+        _: &'tcx Body,\n         _: Span,\n         _: NodeId\n     ) {\n@@ -184,10 +184,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             return;\n         }\n         for arg in &decl.inputs {\n-            if let PatKind::Binding(BindByRef(_), _, _, _) = arg.pat.node {\n+            if let PatKind::Binding(BindByRef(_), _, _, _) = arg.node {\n                 span_lint(cx,\n                           TOPLEVEL_REF_ARG,\n-                          arg.pat.span,\n+                          arg.span,\n                           \"`ref` directly on a function argument is ignored. Consider using a reference type instead.\");\n             }\n         }"}, {"sha": "a181c33ebb961868ea09dda8d3ec199f69f1fe04", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -42,7 +42,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n                     .expect(\"A function with an unknown type is called. If this happened, the compiler would have \\\n                              aborted the compilation long ago\");\n                 if let ExprPath(ref path) = fn_expr.node {\n-                    check_arguments(cx, arguments, function_type, &path.to_string());\n+                    check_arguments(cx, arguments, function_type, &print::to_string(print::NO_ANN, |s| s.print_qpath(path, false)));\n                 }\n             },\n             ExprMethodCall(ref name, _, ref arguments) => {"}, {"sha": "5477204b79c12777a472c146455ad1a25faf7a32", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n         cx: &LateContext<'a, 'tcx>,\n         kind: FnKind<'tcx>,\n         decl: &'tcx hir::FnDecl,\n-        _: &'tcx hir::Expr,\n+        _: &'tcx hir::Body,\n         span: Span,\n         id: ast::NodeId\n     ) {"}, {"sha": "ec5da909d60abe39c20fcf7f3e79c60a1b74de46", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         ], {\n             let is_result_type = match_type(cx, cx.tcx.tables().expr_ty(&result_types[0]), &paths::RESULT);\n             let some_expr_string = snippet(cx, y[0].span, \"\");\n-            if print::path_to_string(x) == \"Some\" && is_result_type {\n+            if print::to_string(print::NO_ANN, |s| s.print_path(x, false)) == \"Some\" && is_result_type {\n                 span_help_and_lint(cx, IF_LET_SOME_RESULT, expr.span,\n                 \"Matching on `Some` with `ok()` is redundant\",\n                 &format!(\"Consider matching on `Ok({})` and removing the call to `ok` instead\", some_expr_string));"}, {"sha": "78fdc06708a9b942400ed75bd25020911554bd57", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -99,13 +99,13 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n             if match_type(cx, ty, &paths::VEC) {\n                 span_lint(cx,\n                           PTR_ARG,\n-                          arg.ty.span,\n+                          arg.span,\n                           \"writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used \\\n                            with non-Vec-based slices. Consider changing the type to `&[...]`\");\n             } else if match_type(cx, ty, &paths::STRING) {\n                 span_lint(cx,\n                           PTR_ARG,\n-                          arg.ty.span,\n+                          arg.span,\n                           \"writing `&String` instead of `&str` involves a new object where a slice will do. \\\n                            Consider changing the type to `&str`\");\n             }"}, {"sha": "17160a5a1244ade2de19c71c04113fdd1b369c99", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -85,21 +85,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         cx: &LateContext<'a, 'tcx>,\n         _: FnKind<'tcx>,\n         decl: &'tcx FnDecl,\n-        expr: &'tcx Expr,\n+        body: &'tcx Body,\n         _: Span,\n         _: NodeId\n     ) {\n-        if in_external_macro(cx, expr.span) {\n+        if in_external_macro(cx, body.value.span) {\n             return;\n         }\n-        check_fn(cx, decl, expr);\n+        check_fn(cx, decl, &body.value);\n     }\n }\n \n fn check_fn<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl, expr: &'tcx Expr) {\n     let mut bindings = Vec::new();\n     for arg in &decl.inputs {\n-        if let PatKind::Binding(_, _, ident, _) = arg.pat.node {\n+        if let PatKind::Binding(_, _, ident, _) = arg.node {\n             bindings.push((ident.node, ident.span))\n         }\n     }\n@@ -341,9 +341,9 @@ fn check_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty, bindings: &mut V\n     match ty.node {\n         TyObjectSum(ref sty, _) |\n         TySlice(ref sty) => check_ty(cx, sty, bindings),\n-        TyArray(ref fty, ref expr) => {\n+        TyArray(ref fty, bodyId) => {\n             check_ty(cx, fty, bindings);\n-            check_expr(cx, expr, bindings);\n+            check_expr(cx, &cx.tcx.map.body(bodyId).value, bindings);\n         },\n         TyPtr(MutTy { ty: ref mty, .. }) |\n         TyRptr(_, MutTy { ty: ref mty, .. }) => check_ty(cx, mty, bindings),\n@@ -352,7 +352,7 @@ fn check_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty, bindings: &mut V\n                 check_ty(cx, t, bindings)\n             }\n         },\n-        TyTypeof(ref expr) => check_expr(cx, expr, bindings),\n+        TyTypeof(bodyId) => check_expr(cx, &cx.tcx.map.body(bodyId).value, bindings),\n         _ => (),\n     }\n }\n@@ -371,7 +371,7 @@ fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n }\n \n fn path_eq_name(name: Name, path: &Path) -> bool {\n-    !path.global && path.segments.len() == 1 && path.segments[0].name.as_str() == name.as_str()\n+    !path.is_global() && path.segments.len() == 1 && path.segments[0].name.as_str() == name.as_str()\n }\n \n struct ContainsSelf<'a, 'tcx: 'a> {"}, {"sha": "0b8308933f1ba1360da4b2a69e0f4b43934599cc", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -70,7 +70,7 @@ impl LintPass for TypePass {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypePass {\n-    fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl, _: &Expr, _: Span, id: NodeId) {\n+    fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl, _: &Body, _: Span, id: NodeId) {\n         // skip trait implementations, see #605\n         if let Some(map::NodeItem(item)) = cx.tcx.map.find(cx.tcx.map.get_parent(id)) {\n             if let ItemImpl(_, _, _, Some(..), _, _) = item.node {\n@@ -97,7 +97,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypePass {\n \n fn check_fn_decl(cx: &LateContext, decl: &FnDecl) {\n     for input in &decl.inputs {\n-        check_ty(cx, &input.ty);\n+        check_ty(cx, &input);\n     }\n \n     if let FunctionRetTy::Return(ref ty) = decl.output {\n@@ -601,7 +601,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeComplexityPass {\n         cx: &LateContext<'a, 'tcx>,\n         _: FnKind<'tcx>,\n         decl: &'tcx FnDecl,\n-        _: &'tcx Expr,\n+        _: &'tcx Body,\n         _: Span,\n         _: NodeId\n     ) {\n@@ -626,7 +626,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeComplexityPass {\n         match item.node {\n             TraitItemKind::Const(ref ty, _) |\n             TraitItemKind::Type(_, Some(ref ty)) => self.check_type(cx, ty),\n-            TraitItemKind::Method(MethodSig { ref decl, .. }, None) => self.check_fndecl(cx, decl),\n+            TraitItemKind::Method(MethodSig { ref decl, .. }, TraitMethod::Required(_)) => self.check_fndecl(cx, decl),\n             // methods with default impl are covered by check_fn\n             _ => (),\n         }\n@@ -651,7 +651,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeComplexityPass {\n impl<'a, 'tcx> TypeComplexityPass {\n     fn check_fndecl(&self, cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl) {\n         for arg in &decl.inputs {\n-            self.check_type(cx, &arg.ty);\n+            self.check_type(cx, &arg);\n         }\n         if let Return(ref ty) = decl.output {\n             self.check_type(cx, ty);"}, {"sha": "5136a821c546f549fb854375f9b1a88b4ee8ac2f", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedLabel {\n         cx: &LateContext<'a, 'tcx>,\n         kind: FnKind<'tcx>,\n         decl: &'tcx hir::FnDecl,\n-        body: &'tcx hir::Expr,\n+        body: &'tcx hir::Body,\n         span: Span,\n         fn_id: ast::NodeId\n     ) {\n@@ -58,7 +58,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedLabel {\n             cx: cx,\n             labels: HashMap::new(),\n         };\n-        walk_fn(&mut v, kind, decl, body.expr_id(), span, fn_id);\n+        walk_fn(&mut v, kind, decl, body.id(), span, fn_id);\n \n         for (label, span) in v.labels {\n             span_lint(cx, UNUSED_LABEL, span, &format!(\"unused label `{}`\", label));"}, {"sha": "643b5249654376998abeef2e2d43c2fd9d9e995e", "filename": "clippy_lints/src/utils/hir.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                 !self.ignore_fn && l_name.node == r_name.node && over(l_tys, r_tys, |l, r| self.eq_ty(l, r)) &&\n                 self.eq_exprs(l_args, r_args)\n             },\n-            (&ExprRepeat(ref le, ref ll), &ExprRepeat(ref re, ref rl)) => self.eq_expr(le, re) && self.eq_expr(ll, rl),\n+            (&ExprRepeat(ref le, llId), &ExprRepeat(ref re, rlId)) => self.eq_expr(le, re) && self.eq_expr(&self.cx.tcx.map.body(llId).value, &self.cx.tcx.map.body(rlId).value),\n             (&ExprRet(ref l), &ExprRet(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n             (&ExprPath(ref l), &ExprPath(ref r)) => self.eq_qpath(l, r),\n             (&ExprStruct(ref l_path, ref lf, ref lo), &ExprStruct(ref r_path, ref rf, ref ro)) => {\n@@ -183,7 +183,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n     }\n \n     fn eq_path(&self, left: &Path, right: &Path) -> bool {\n-        left.global == right.global && over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r))\n+        left.is_global() == right.is_global() && over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r))\n     }\n \n     fn eq_path_parameters(&self, left: &PathParameters, right: &PathParameters) -> bool {\n@@ -211,7 +211,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n     fn eq_ty(&self, left: &Ty, right: &Ty) -> bool {\n         match (&left.node, &right.node) {\n             (&TySlice(ref l_vec), &TySlice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n-            (&TyArray(ref lt, ref ll), &TyArray(ref rt, ref rl)) => self.eq_ty(lt, rt) && self.eq_expr(ll, rl),\n+            (&TyArray(ref lt, llId), &TyArray(ref rt, rlId)) => self.eq_ty(lt, rt) && self.eq_expr(&self.cx.tcx.map.body(llId).value, &self.cx.tcx.map.body(rlId).value),\n             (&TyPtr(ref l_mut), &TyPtr(ref r_mut)) => l_mut.mutbl == r_mut.mutbl && self.eq_ty(&*l_mut.ty, &*r_mut.ty),\n             (&TyRptr(_, ref l_rmut), &TyRptr(_, ref r_rmut)) => {\n                 l_rmut.mutbl == r_rmut.mutbl && self.eq_ty(&*l_rmut.ty, &*r_rmut.ty)\n@@ -363,7 +363,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_, _, _, _) -> _ = ExprClosure;\n                 c.hash(&mut self.s);\n                 cap.hash(&mut self.s);\n-                self.hash_expr(self.cx.tcx.map.expr(eid));\n+                self.hash_expr(&self.cx.tcx.map.body(eid).value);\n             },\n             ExprField(ref e, ref f) => {\n                 let c: fn(_, _) -> _ = ExprField;\n@@ -424,11 +424,11 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 self.hash_name(&name.node);\n                 self.hash_exprs(args);\n             },\n-            ExprRepeat(ref e, ref l) => {\n+            ExprRepeat(ref e, lId) => {\n                 let c: fn(_, _) -> _ = ExprRepeat;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n-                self.hash_expr(l);\n+                self.hash_expr(&self.cx.tcx.map.body(lId).value);\n             },\n             ExprRet(ref e) => {\n                 let c: fn(_) -> _ = ExprRet;\n@@ -524,7 +524,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n     }\n \n     pub fn hash_path(&mut self, p: &Path) {\n-        p.global.hash(&mut self.s);\n+        p.is_global().hash(&mut self.s);\n         for p in &p.segments {\n             self.hash_name(&p.name);\n         }"}, {"sha": "220d4572e81d755613daa32de6ae638edd659427", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -4,6 +4,7 @@\n \n use rustc::lint::*;\n use rustc::hir;\n+use rustc::hir::print;\n use syntax::ast::Attribute;\n use syntax::attr;\n \n@@ -52,16 +53,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         match item.vis {\n             hir::Visibility::Public => println!(\"public\"),\n             hir::Visibility::Crate => println!(\"visible crate wide\"),\n-            hir::Visibility::Restricted { ref path, .. } => println!(\"visible in module `{}`\", path),\n+            hir::Visibility::Restricted { ref path, .. } => println!(\"visible in module `{}`\", print::to_string(print::NO_ANN, |s| s.print_path(path, false))),\n             hir::Visibility::Inherited => println!(\"visibility inherited from outer item\"),\n         }\n         if item.defaultness.is_default() {\n             println!(\"default\");\n         }\n         match item.node {\n-            hir::ImplItemKind::Const(_, ref e) => {\n+            hir::ImplItemKind::Const(_, bodyId) => {\n                 println!(\"associated constant\");\n-                print_expr(cx, e, 1);\n+                print_expr(cx, &cx.tcx.map.body(bodyId).value, 1);\n             },\n             hir::ImplItemKind::Method(..) => println!(\"method\"),\n             hir::ImplItemKind::Type(_) => println!(\"associated type\"),\n@@ -323,12 +324,12 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n                 print_expr(cx, base, indent + 1);\n             }\n         },\n-        hir::ExprRepeat(ref val, ref n) => {\n+        hir::ExprRepeat(ref val, bodyId) => {\n             println!(\"{}Repeat, {}\", ind, ty);\n             println!(\"{}value:\", ind);\n             print_expr(cx, val, indent + 1);\n             println!(\"{}repeat count:\", ind);\n-            print_expr(cx, n, indent + 1);\n+            print_expr(cx, &cx.tcx.map.body(bodyId).value, indent + 1);\n         },\n     }\n }\n@@ -339,7 +340,7 @@ fn print_item(cx: &LateContext, item: &hir::Item) {\n     match item.vis {\n         hir::Visibility::Public => println!(\"public\"),\n         hir::Visibility::Crate => println!(\"visible crate wide\"),\n-        hir::Visibility::Restricted { ref path, .. } => println!(\"visible in module `{}`\", path),\n+        hir::Visibility::Restricted { ref path, .. } => println!(\"visible in module `{}`\", print::to_string(print::NO_ANN, |s| s.print_path(path, false))),\n         hir::Visibility::Inherited => println!(\"visibility inherited from outer item\"),\n     }\n     match item.node {\n@@ -413,7 +414,7 @@ fn print_pat(cx: &LateContext, pat: &hir::Pat, indent: usize) {\n         },\n         hir::PatKind::Struct(ref path, ref fields, ignore) => {\n             println!(\"{}Struct\", ind);\n-            println!(\"{}name: {}\", ind, path);\n+            println!(\"{}name: {}\", ind, print::to_string(print::NO_ANN, |s| s.print_qpath(path, false)));\n             println!(\"{}ignore leftover fields: {}\", ind, ignore);\n             println!(\"{}fields:\", ind);\n             for field in fields {\n@@ -426,7 +427,7 @@ fn print_pat(cx: &LateContext, pat: &hir::Pat, indent: usize) {\n         },\n         hir::PatKind::TupleStruct(ref path, ref fields, opt_dots_position) => {\n             println!(\"{}TupleStruct\", ind);\n-            println!(\"{}path: {}\", ind, path);\n+            println!(\"{}path: {}\", ind, print::to_string(print::NO_ANN, |s| s.print_qpath(path, false)));\n             if let Some(dot_position) = opt_dots_position {\n                 println!(\"{}dot position: {}\", ind, dot_position);\n             }"}, {"sha": "d2da4f9085b907c3be19900dcedb86c4a64bf4c2", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -106,15 +106,15 @@ impl LintPass for LintWithoutLintPass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemStatic(ref ty, MutImmutable, ref expr) = item.node {\n+        if let ItemStatic(ref ty, MutImmutable, bodyId) = item.node {\n             if is_lint_ref_type(ty) {\n                 self.declared_lints.insert(item.name, item.span);\n             } else if is_lint_array_type(ty) && item.vis == Visibility::Inherited && item.name == \"ARRAY\" {\n                 let mut collector = LintCollector {\n                     output: &mut self.registered_lints,\n                     cx: cx,\n                 };\n-                collector.visit_expr(expr);\n+                collector.visit_expr(&cx.tcx.map.body(bodyId).value);\n             }\n         }\n     }"}, {"sha": "e9c77f027e84035e29a991bfb9b3016629454ecf", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f5dbc9f872492bbd211da67d651e8e1942b99b/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=64f5dbc9f872492bbd211da67d651e8e1942b99b", "patch": "@@ -19,6 +19,7 @@ use syntax::attr;\n use syntax::codemap::{ExpnFormat, ExpnInfo, MultiSpan, Span, DUMMY_SP};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ptr::P;\n+use syntax::symbol::keywords;\n \n pub mod cargo;\n pub mod comparisons;\n@@ -487,7 +488,7 @@ pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: NodeI\n         match node {\n             Node::NodeBlock(block) => Some(block),\n             Node::NodeItem(&Item { node: ItemFn(_, _, _, _, _, eid), .. }) => {\n-                match cx.tcx.map.expr(eid).node {\n+                match cx.tcx.map.body(eid).value.node {\n                     ExprBlock(ref block) => Some(block),\n                     _ => None,\n                 }\n@@ -896,3 +897,15 @@ pub fn opt_def_id(def: Def) -> Option<DefId> {\n         Def::Label(..) | Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => None,\n     }\n }\n+\n+pub fn is_self(slf: &Arg) -> bool {\n+    if let PatKind::Binding(_, _, name, _) = slf.pat.node {\n+        name.node == keywords::SelfValue.name()\n+    } else {\n+        false\n+    }\n+}\n+\n+pub fn has_self(slf: &FnDecl) -> bool {\n+    slf.inputs.get(0).map(|arg| is_self(&arg)).unwrap_or(false)\n+}"}]}