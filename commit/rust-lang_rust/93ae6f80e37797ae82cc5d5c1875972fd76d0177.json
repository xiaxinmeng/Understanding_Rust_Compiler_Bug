{"sha": "93ae6f80e37797ae82cc5d5c1875972fd76d0177", "node_id": "C_kwDOAAsO6NoAKDkzYWU2ZjgwZTM3Nzk3YWU4MmNjNWQ1YzE4NzU5NzJmZDc2ZDAxNzc", "commit": {"author": {"name": "Eduardo S\u00e1nchez Mu\u00f1oz", "email": "eduardosm-dev@e64.io", "date": "2022-04-15T14:59:40Z"}, "committer": {"name": "Eduardo S\u00e1nchez Mu\u00f1oz", "email": "eduardosm-dev@e64.io", "date": "2022-04-15T15:04:59Z"}, "message": "Make some `usize`-typed masks definition agnostic to the size of `usize`\n\nSome masks where defined as\n```rust\nconst NONASCII_MASK: usize = 0x80808080_80808080u64 as usize;\n```\nwhere it was assumed that `usize` is never wider than 64, which is currently true.\n\nTo make those constants valid in a hypothetical 128-bit target, these constants have been redefined in an `usize`-width-agnostic way\n```rust\nconst NONASCII_MASK: usize = usize::from_ne_bytes([0x80; size_of::<usize>()]);\n```\n\nThere are already some cases where Rust anticipates the possibility of supporting 128-bit targets, such as not implementing `From<usize>` for `u64`.", "tree": {"sha": "735804aa5c9b2f9a3f01035f867247d306323047", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/735804aa5c9b2f9a3f01035f867247d306323047"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93ae6f80e37797ae82cc5d5c1875972fd76d0177", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93ae6f80e37797ae82cc5d5c1875972fd76d0177", "html_url": "https://github.com/rust-lang/rust/commit/93ae6f80e37797ae82cc5d5c1875972fd76d0177", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93ae6f80e37797ae82cc5d5c1875972fd76d0177/comments", "author": {"login": "eduardosm", "id": 761151, "node_id": "MDQ6VXNlcjc2MTE1MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/761151?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eduardosm", "html_url": "https://github.com/eduardosm", "followers_url": "https://api.github.com/users/eduardosm/followers", "following_url": "https://api.github.com/users/eduardosm/following{/other_user}", "gists_url": "https://api.github.com/users/eduardosm/gists{/gist_id}", "starred_url": "https://api.github.com/users/eduardosm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eduardosm/subscriptions", "organizations_url": "https://api.github.com/users/eduardosm/orgs", "repos_url": "https://api.github.com/users/eduardosm/repos", "events_url": "https://api.github.com/users/eduardosm/events{/privacy}", "received_events_url": "https://api.github.com/users/eduardosm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eduardosm", "id": 761151, "node_id": "MDQ6VXNlcjc2MTE1MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/761151?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eduardosm", "html_url": "https://github.com/eduardosm", "followers_url": "https://api.github.com/users/eduardosm/followers", "following_url": "https://api.github.com/users/eduardosm/following{/other_user}", "gists_url": "https://api.github.com/users/eduardosm/gists{/gist_id}", "starred_url": "https://api.github.com/users/eduardosm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eduardosm/subscriptions", "organizations_url": "https://api.github.com/users/eduardosm/orgs", "repos_url": "https://api.github.com/users/eduardosm/repos", "events_url": "https://api.github.com/users/eduardosm/events{/privacy}", "received_events_url": "https://api.github.com/users/eduardosm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7575f9670f3c837def3d186ae09366c75c7632e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7575f9670f3c837def3d186ae09366c75c7632e", "html_url": "https://github.com/rust-lang/rust/commit/e7575f9670f3c837def3d186ae09366c75c7632e"}], "stats": {"total": 42, "additions": 29, "deletions": 13}, "files": [{"sha": "a42a1dcfe39881d50134ab409e4ca38713f1fcb1", "filename": "library/core/benches/ascii/is_ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93ae6f80e37797ae82cc5d5c1875972fd76d0177/library%2Fcore%2Fbenches%2Fascii%2Fis_ascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93ae6f80e37797ae82cc5d5c1875972fd76d0177/library%2Fcore%2Fbenches%2Fascii%2Fis_ascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Fascii%2Fis_ascii.rs?ref=93ae6f80e37797ae82cc5d5c1875972fd76d0177", "patch": "@@ -77,6 +77,6 @@ fn is_ascii_align_to_unrolled(bytes: &[u8]) -> bool {\n \n #[inline]\n fn contains_nonascii(v: usize) -> bool {\n-    const NONASCII_MASK: usize = 0x80808080_80808080u64 as usize;\n+    const NONASCII_MASK: usize = usize::from_ne_bytes([0x80; core::mem::size_of::<usize>()]);\n     (NONASCII_MASK & v) != 0\n }"}, {"sha": "66193eaf5da73c1da12d93265d8b8b8f5a78636c", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/93ae6f80e37797ae82cc5d5c1875972fd76d0177/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93ae6f80e37797ae82cc5d5c1875972fd76d0177/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=93ae6f80e37797ae82cc5d5c1875972fd76d0177", "patch": "@@ -890,6 +890,27 @@ impl usize {\n     widening_impl! { usize, u128, 64, unsigned }\n }\n \n+impl usize {\n+    /// Returns an `usize` where every byte is equal to `x`.\n+    #[inline]\n+    pub(crate) const fn repeat_u8(x: u8) -> usize {\n+        usize::from_ne_bytes([x; mem::size_of::<usize>()])\n+    }\n+\n+    /// Returns an `usize` where every byte pair is equal to `x`.\n+    #[inline]\n+    pub(crate) const fn repeat_u16(x: u16) -> usize {\n+        let mut r = 0usize;\n+        let mut i = 0;\n+        while i < mem::size_of::<usize>() {\n+            // Use `wrapping_shl` to make it work on targets with 16-bit `usize`\n+            r = r.wrapping_shl(16) | (x as usize);\n+            i += 2;\n+        }\n+        r\n+    }\n+}\n+\n /// A classification of floating point numbers.\n ///\n /// This `enum` is used as the return type for [`f32::classify`] and [`f64::classify`]. See"}, {"sha": "63715a6b86b97fd42913bf06d71241c8afab3a28", "filename": "library/core/src/slice/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93ae6f80e37797ae82cc5d5c1875972fd76d0177/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93ae6f80e37797ae82cc5d5c1875972fd76d0177/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs?ref=93ae6f80e37797ae82cc5d5c1875972fd76d0177", "patch": "@@ -235,7 +235,7 @@ impl<'a> fmt::Debug for EscapeAscii<'a> {\n /// from `../str/mod.rs`, which does something similar for utf8 validation.\n #[inline]\n fn contains_nonascii(v: usize) -> bool {\n-    const NONASCII_MASK: usize = 0x80808080_80808080u64 as usize;\n+    const NONASCII_MASK: usize = usize::repeat_u8(0x80);\n     (NONASCII_MASK & v) != 0\n }\n "}, {"sha": "dffeaf6a834e75739ac296dc31ab29138d78ac28", "filename": "library/core/src/slice/memchr.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/93ae6f80e37797ae82cc5d5c1875972fd76d0177/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93ae6f80e37797ae82cc5d5c1875972fd76d0177/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs?ref=93ae6f80e37797ae82cc5d5c1875972fd76d0177", "patch": "@@ -4,12 +4,8 @@\n use crate::cmp;\n use crate::mem;\n \n-const LO_U64: u64 = 0x0101010101010101;\n-const HI_U64: u64 = 0x8080808080808080;\n-\n-// Use truncation.\n-const LO_USIZE: usize = LO_U64 as usize;\n-const HI_USIZE: usize = HI_U64 as usize;\n+const LO_USIZE: usize = usize::repeat_u8(0x01);\n+const HI_USIZE: usize = usize::repeat_u8(0x80);\n const USIZE_BYTES: usize = mem::size_of::<usize>();\n \n /// Returns `true` if `x` contains any zero byte."}, {"sha": "28567a7e753aa88b1eee668928bb47b0c1d4c69a", "filename": "library/core/src/str/count.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/93ae6f80e37797ae82cc5d5c1875972fd76d0177/library%2Fcore%2Fsrc%2Fstr%2Fcount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93ae6f80e37797ae82cc5d5c1875972fd76d0177/library%2Fcore%2Fsrc%2Fstr%2Fcount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fcount.rs?ref=93ae6f80e37797ae82cc5d5c1875972fd76d0177", "patch": "@@ -112,16 +112,16 @@ fn do_count_chars(s: &str) -> usize {\n // true)\n #[inline]\n fn contains_non_continuation_byte(w: usize) -> usize {\n-    const LSB: usize = 0x0101_0101_0101_0101u64 as usize;\n+    const LSB: usize = usize::repeat_u8(0x01);\n     ((!w >> 7) | (w >> 6)) & LSB\n }\n \n // Morally equivalent to `values.to_ne_bytes().into_iter().sum::<usize>()`, but\n // more efficient.\n #[inline]\n fn sum_bytes_in_usize(values: usize) -> usize {\n-    const LSB_SHORTS: usize = 0x0001_0001_0001_0001_u64 as usize;\n-    const SKIP_BYTES: usize = 0x00ff_00ff_00ff_00ff_u64 as usize;\n+    const LSB_SHORTS: usize = usize::repeat_u16(0x0001);\n+    const SKIP_BYTES: usize = usize::repeat_u16(0x00ff);\n \n     let pair_sum: usize = (values & SKIP_BYTES) + ((values >> 8) & SKIP_BYTES);\n     pair_sum.wrapping_mul(LSB_SHORTS) >> ((USIZE_SIZE - 2) * 8)"}, {"sha": "04bc665233e385dc859f466730c030cf9b64ac20", "filename": "library/core/src/str/validations.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/93ae6f80e37797ae82cc5d5c1875972fd76d0177/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93ae6f80e37797ae82cc5d5c1875972fd76d0177/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs?ref=93ae6f80e37797ae82cc5d5c1875972fd76d0177", "patch": "@@ -112,8 +112,7 @@ where\n     Some(ch)\n }\n \n-// use truncation to fit u64 into usize\n-const NONASCII_MASK: usize = 0x80808080_80808080u64 as usize;\n+const NONASCII_MASK: usize = usize::repeat_u8(0x80);\n \n /// Returns `true` if any byte in the word `x` is nonascii (>= 128).\n #[inline]"}]}