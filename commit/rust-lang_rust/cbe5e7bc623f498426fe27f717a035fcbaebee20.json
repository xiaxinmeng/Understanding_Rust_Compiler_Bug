{"sha": "cbe5e7bc623f498426fe27f717a035fcbaebee20", "node_id": "C_kwDOAAsO6NoAKGNiZTVlN2JjNjIzZjQ5ODQyNmZlMjdmNzE3YTAzNWZjYmFlYmVlMjA", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-10-15T10:15:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-15T10:15:30Z"}, "message": "Rollup merge of #102773 - joboet:apple_parker, r=thomcc\n\nUse semaphores for thread parking on Apple platforms\n\nCurrently we use a mutex-condvar pair for thread parking on Apple systems. Unfortunately, `pthread_cond_timedwait` uses the real-time clock for measuring time, which causes problems when the system time changes. The parking implementation in this PR uses a semaphore instead, which measures monotonic time by default, avoiding these issues. As a further benefit, this has the potential to improve performance a bit, since `unpark` does not need to wait for a lock to be released.\n\nSince the Mach semaphores are poorly documented (I could not find availability or stability guarantees for instance), this uses a [dispatch semaphore](https://developer.apple.com/documentation/dispatch/dispatch_semaphore?language=objc) instead. While it adds a layer of indirection (it uses Mach semaphores internally), the overhead is probably negligible.\n\nTested on macOS 12.5.\n\nr? ``````@thomcc``````", "tree": {"sha": "4dec736abd78a4fd2d137bbe5da0ec5393623931", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4dec736abd78a4fd2d137bbe5da0ec5393623931"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbe5e7bc623f498426fe27f717a035fcbaebee20", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjSohCCRBK7hj4Ov3rIwAAsbIIAH3WkwKPzAx9vZStm4W/c46Y\nXXjtmlxbcnAtsT4mmm8yT2OMK0YOnc3c4Znb/2VOJbVtA5/NG2JmjIjeJbn3bpHG\nmDqk3VWEFepJvTnU4LwVG8rQHcSPFoooWnRIKh8iMoQDTlhQgmxtrU4fVaqp/k5J\nVioG5rPjsGpTg7lOYjF6rxdeH4hlpsC/BjD9bRpoeqJkOyZw+Y/IWkfAfXicZqho\nflO3n4qmTO+y8zYXYjPN+qOdcf0aSwXqv1YD8x3QGoTq4PsupNraZyYuOoSHbO9/\n9sn1R7oXi7CSrdzn+LCnW1YUa2AYblgtfqzf+RBVzvK2KJXe7s+F6a8Ambh84P0=\n=ZtQz\n-----END PGP SIGNATURE-----\n", "payload": "tree 4dec736abd78a4fd2d137bbe5da0ec5393623931\nparent 46244f335b5262ef9bdc34cc564b4dea221948f6\nparent c320ab98ff1d4adb32cece206aa895e4effae175\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1665828930 +0530\ncommitter GitHub <noreply@github.com> 1665828930 +0530\n\nRollup merge of #102773 - joboet:apple_parker, r=thomcc\n\nUse semaphores for thread parking on Apple platforms\n\nCurrently we use a mutex-condvar pair for thread parking on Apple systems. Unfortunately, `pthread_cond_timedwait` uses the real-time clock for measuring time, which causes problems when the system time changes. The parking implementation in this PR uses a semaphore instead, which measures monotonic time by default, avoiding these issues. As a further benefit, this has the potential to improve performance a bit, since `unpark` does not need to wait for a lock to be released.\n\nSince the Mach semaphores are poorly documented (I could not find availability or stability guarantees for instance), this uses a [dispatch semaphore](https://developer.apple.com/documentation/dispatch/dispatch_semaphore?language=objc) instead. While it adds a layer of indirection (it uses Mach semaphores internally), the overhead is probably negligible.\n\nTested on macOS 12.5.\n\nr? ``````@thomcc``````\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbe5e7bc623f498426fe27f717a035fcbaebee20", "html_url": "https://github.com/rust-lang/rust/commit/cbe5e7bc623f498426fe27f717a035fcbaebee20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbe5e7bc623f498426fe27f717a035fcbaebee20/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46244f335b5262ef9bdc34cc564b4dea221948f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/46244f335b5262ef9bdc34cc564b4dea221948f6", "html_url": "https://github.com/rust-lang/rust/commit/46244f335b5262ef9bdc34cc564b4dea221948f6"}, {"sha": "c320ab98ff1d4adb32cece206aa895e4effae175", "url": "https://api.github.com/repos/rust-lang/rust/commits/c320ab98ff1d4adb32cece206aa895e4effae175", "html_url": "https://github.com/rust-lang/rust/commit/c320ab98ff1d4adb32cece206aa895e4effae175"}], "stats": {"total": 166, "additions": 165, "deletions": 1}, "files": [{"sha": "2f5356fe2276bbb31df2c0dea47d115364860fdc", "filename": "library/std/src/sys/unix/thread_parker/darwin.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/cbe5e7bc623f498426fe27f717a035fcbaebee20/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fdarwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe5e7bc623f498426fe27f717a035fcbaebee20/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fdarwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fdarwin.rs?ref=cbe5e7bc623f498426fe27f717a035fcbaebee20", "patch": "@@ -0,0 +1,131 @@\n+//! Thread parking for Darwin-based systems.\n+//!\n+//! Darwin actually has futex syscalls (`__ulock_wait`/`__ulock_wake`), but they\n+//! cannot be used in `std` because they are non-public (their use will lead to\n+//! rejection from the App Store) and because they are only available starting\n+//! with macOS version 10.12, even though the minimum target version is 10.7.\n+//!\n+//! Therefore, we need to look for other synchronization primitives. Luckily, Darwin\n+//! supports semaphores, which allow us to implement the behaviour we need with\n+//! only one primitive (as opposed to a mutex-condvar pair). We use the semaphore\n+//! provided by libdispatch, as the underlying Mach semaphore is only dubiously\n+//! public.\n+\n+use crate::pin::Pin;\n+use crate::sync::atomic::{\n+    AtomicI8,\n+    Ordering::{Acquire, Release},\n+};\n+use crate::time::Duration;\n+\n+type dispatch_semaphore_t = *mut crate::ffi::c_void;\n+type dispatch_time_t = u64;\n+\n+const DISPATCH_TIME_NOW: dispatch_time_t = 0;\n+const DISPATCH_TIME_FOREVER: dispatch_time_t = !0;\n+\n+// Contained in libSystem.dylib, which is linked by default.\n+extern \"C\" {\n+    fn dispatch_time(when: dispatch_time_t, delta: i64) -> dispatch_time_t;\n+    fn dispatch_semaphore_create(val: isize) -> dispatch_semaphore_t;\n+    fn dispatch_semaphore_wait(dsema: dispatch_semaphore_t, timeout: dispatch_time_t) -> isize;\n+    fn dispatch_semaphore_signal(dsema: dispatch_semaphore_t) -> isize;\n+    fn dispatch_release(object: *mut crate::ffi::c_void);\n+}\n+\n+const EMPTY: i8 = 0;\n+const NOTIFIED: i8 = 1;\n+const PARKED: i8 = -1;\n+\n+pub struct Parker {\n+    semaphore: dispatch_semaphore_t,\n+    state: AtomicI8,\n+}\n+\n+unsafe impl Sync for Parker {}\n+unsafe impl Send for Parker {}\n+\n+impl Parker {\n+    pub unsafe fn new(parker: *mut Parker) {\n+        let semaphore = dispatch_semaphore_create(0);\n+        assert!(\n+            !semaphore.is_null(),\n+            \"failed to create dispatch semaphore for thread synchronization\"\n+        );\n+        parker.write(Parker { semaphore, state: AtomicI8::new(EMPTY) })\n+    }\n+\n+    // Does not need `Pin`, but other implementation do.\n+    pub unsafe fn park(self: Pin<&Self>) {\n+        // The semaphore counter must be zero at this point, because unparking\n+        // threads will not actually increase it until we signalled that we\n+        // are waiting.\n+\n+        // Change NOTIFIED to EMPTY and EMPTY to PARKED.\n+        if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n+            return;\n+        }\n+\n+        // Another thread may increase the semaphore counter from this point on.\n+        // If it is faster than us, we will decrement it again immediately below.\n+        // If we are faster, we wait.\n+\n+        // Ensure that the semaphore counter has actually been decremented, even\n+        // if the call timed out for some reason.\n+        while dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER) != 0 {}\n+\n+        // At this point, the semaphore counter is zero again.\n+\n+        // We were definitely woken up, so we don't need to check the state.\n+        // Still, we need to reset the state using a swap to observe the state\n+        // change with acquire ordering.\n+        self.state.swap(EMPTY, Acquire);\n+    }\n+\n+    // Does not need `Pin`, but other implementation do.\n+    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n+        if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n+            return;\n+        }\n+\n+        let nanos = dur.as_nanos().try_into().unwrap_or(i64::MAX);\n+        let timeout = dispatch_time(DISPATCH_TIME_NOW, nanos);\n+\n+        let timeout = dispatch_semaphore_wait(self.semaphore, timeout) != 0;\n+\n+        let state = self.state.swap(EMPTY, Acquire);\n+        if state == NOTIFIED && timeout {\n+            // If the state was NOTIFIED but semaphore_wait returned without\n+            // decrementing the count because of a timeout, it means another\n+            // thread is about to call semaphore_signal. We must wait for that\n+            // to happen to ensure the semaphore count is reset.\n+            while dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER) != 0 {}\n+        } else {\n+            // Either a timeout occurred and we reset the state before any thread\n+            // tried to wake us up, or we were woken up and reset the state,\n+            // making sure to observe the state change with acquire ordering.\n+            // Either way, the semaphore counter is now zero again.\n+        }\n+    }\n+\n+    // Does not need `Pin`, but other implementation do.\n+    pub fn unpark(self: Pin<&Self>) {\n+        let state = self.state.swap(NOTIFIED, Release);\n+        if state == PARKED {\n+            unsafe {\n+                dispatch_semaphore_signal(self.semaphore);\n+            }\n+        }\n+    }\n+}\n+\n+impl Drop for Parker {\n+    fn drop(&mut self) {\n+        // SAFETY:\n+        // We always ensure that the semaphore count is reset, so this will\n+        // never cause an exception.\n+        unsafe {\n+            dispatch_release(self.semaphore);\n+        }\n+    }\n+}"}, {"sha": "35f1e68a87e5b431faa49a551e6f32e43a97a4df", "filename": "library/std/src/sys/unix/thread_parker/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cbe5e7bc623f498426fe27f717a035fcbaebee20/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe5e7bc623f498426fe27f717a035fcbaebee20/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fmod.rs?ref=cbe5e7bc623f498426fe27f717a035fcbaebee20", "patch": "@@ -11,7 +11,18 @@\n )))]\n \n cfg_if::cfg_if! {\n-    if #[cfg(target_os = \"netbsd\")] {\n+    if #[cfg(all(\n+        any(\n+            target_os = \"macos\",\n+            target_os = \"ios\",\n+            target_os = \"watchos\",\n+            target_os = \"tvos\",\n+        ),\n+        not(miri),\n+    ))] {\n+        mod darwin;\n+        pub use darwin::Parker;\n+    } else if #[cfg(target_os = \"netbsd\")] {\n         mod netbsd;\n         pub use netbsd::Parker;\n     } else {"}, {"sha": "dfb8765ab4eed3a3e558dbbf5c97c44e693afe30", "filename": "library/std/src/thread/tests.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cbe5e7bc623f498426fe27f717a035fcbaebee20/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbe5e7bc623f498426fe27f717a035fcbaebee20/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs?ref=cbe5e7bc623f498426fe27f717a035fcbaebee20", "patch": "@@ -244,6 +244,28 @@ fn test_try_panic_any_message_unit_struct() {\n     }\n }\n \n+#[test]\n+fn test_park_unpark_before() {\n+    for _ in 0..10 {\n+        thread::current().unpark();\n+        thread::park();\n+    }\n+}\n+\n+#[test]\n+fn test_park_unpark_called_other_thread() {\n+    for _ in 0..10 {\n+        let th = thread::current();\n+\n+        let _guard = thread::spawn(move || {\n+            super::sleep(Duration::from_millis(50));\n+            th.unpark();\n+        });\n+\n+        thread::park();\n+    }\n+}\n+\n #[test]\n fn test_park_timeout_unpark_before() {\n     for _ in 0..10 {"}]}