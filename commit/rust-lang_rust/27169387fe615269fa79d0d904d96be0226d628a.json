{"sha": "27169387fe615269fa79d0d904d96be0226d628a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3MTY5Mzg3ZmU2MTUyNjlmYTc5ZDBkOTA0ZDk2YmUwMjI2ZDYyOGE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-16T19:34:52Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-16T19:35:50Z"}, "message": "Remove partial DPS back-end\n\nIt won't be finished on the short term, and it's already bit-rotting\nfast. We can fetch this from git's autumn annals if we need it.", "tree": {"sha": "6e07ea721e025d53e33a16e0e98112c28aa3b8d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e07ea721e025d53e33a16e0e98112c28aa3b8d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27169387fe615269fa79d0d904d96be0226d628a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27169387fe615269fa79d0d904d96be0226d628a", "html_url": "https://github.com/rust-lang/rust/commit/27169387fe615269fa79d0d904d96be0226d628a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27169387fe615269fa79d0d904d96be0226d628a/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3db300b06e11b3dee9d6f1780f3c7b9ccad575aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/3db300b06e11b3dee9d6f1780f3c7b9ccad575aa", "html_url": "https://github.com/rust-lang/rust/commit/3db300b06e11b3dee9d6f1780f3c7b9ccad575aa"}], "stats": {"total": 835, "additions": 12, "deletions": 823}, "files": [{"sha": "0500244d0100925d9917d1bfe9c61a9598cdc84f", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/27169387fe615269fa79d0d904d96be0226d628a/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27169387fe615269fa79d0d904d96be0226d628a/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=27169387fe615269fa79d0d904d96be0226d628a", "patch": "@@ -278,7 +278,6 @@ options:\n     --sysroot <path>   override the system root (default: rustc's directory)\n     --no-typestate     don't run the typestate pass (unsafe!)\n     --test             build test harness\n-    --dps              translate via destination-passing style (experimental)\n     --gc               garbage collect shared data (experimental/temporary)\n \n \");\n@@ -384,7 +383,6 @@ fn build_session_options(binary: str, match: getopts::match, binary_dir: str)\n         };\n     let cfg = parse_cfgspecs(getopts::opt_strs(match, \"cfg\"));\n     let test = opt_present(match, \"test\");\n-    let dps = opt_present(match, \"dps\");\n     let do_gc = opt_present(match, \"gc\");\n     let sopts: @session::options =\n         @{library: library,\n@@ -402,7 +400,6 @@ fn build_session_options(binary: str, match: getopts::match, binary_dir: str)\n           sysroot: sysroot,\n           cfg: cfg,\n           test: test,\n-          dps: dps,\n           parse_only: parse_only,\n           no_trans: no_trans,\n           do_gc: do_gc};\n@@ -437,7 +434,7 @@ fn opts() -> [getopts::opt] {\n           optopt(\"sysroot\"), optflag(\"stats\"), optflag(\"time-passes\"),\n           optflag(\"time-llvm-passes\"), optflag(\"no-typestate\"),\n           optflag(\"noverify\"), optmulti(\"cfg\"), optflag(\"test\"),\n-          optflag(\"lib\"), optflag(\"static\"), optflag(\"dps\"), optflag(\"gc\")];\n+          optflag(\"lib\"), optflag(\"static\"), optflag(\"gc\")];\n }\n \n fn main(args: vec[str]) {"}, {"sha": "fb5ab24966950b370348c061397a62c618c2c1c2", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27169387fe615269fa79d0d904d96be0226d628a/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27169387fe615269fa79d0d904d96be0226d628a/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=27169387fe615269fa79d0d904d96be0226d628a", "patch": "@@ -41,7 +41,6 @@ type options =\n      sysroot: str,\n      cfg: ast::crate_cfg,\n      test: bool,\n-     dps: bool,\n      parse_only: bool,\n      no_trans: bool,\n      do_gc: bool"}, {"sha": "2fbb855425389571aac80cc7a79e2cc9a714104b", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/27169387fe615269fa79d0d904d96be0226d628a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27169387fe615269fa79d0d904d96be0226d628a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=27169387fe615269fa79d0d904d96be0226d628a", "patch": "@@ -6021,23 +6021,17 @@ fn trans_closure(bcx_maybe: &option::t[@block_ctxt],\n     let lltop = bcx.llbb;\n     let block_ty = node_id_type(cx.ccx, f.body.node.id);\n \n-    if cx.ccx.sess.get_opts().dps {\n-        // Call into the new destination-passing-style translation engine.\n-        let dest = trans_dps::dest_move(cx.ccx.tcx, fcx.llretptr, block_ty);\n-        bcx = trans_dps::trans_block(bcx, dest, f.body);\n-    } else {\n-        // This call to trans_block is the place where we bridge between\n-        // translation calls that don't have a return value (trans_crate,\n-        // trans_mod, trans_item, trans_obj, et cetera) and those that do\n-        // (trans_block, trans_expr, et cetera).\n-        let rslt =\n-            if !ty::type_is_nil(cx.ccx.tcx, block_ty) &&\n-               !ty::type_is_bot(cx.ccx.tcx, block_ty) &&\n-               f.proto != ast::proto_iter {\n-                trans_block(bcx, f.body, save_in(fcx.llretptr))\n-            } else { trans_block(bcx, f.body, return) };\n-        bcx = rslt.bcx;\n-    }\n+    // This call to trans_block is the place where we bridge between\n+    // translation calls that don't have a return value (trans_crate,\n+    // trans_mod, trans_item, trans_obj, et cetera) and those that do\n+    // (trans_block, trans_expr, et cetera).\n+    let rslt =\n+        if !ty::type_is_nil(cx.ccx.tcx, block_ty) &&\n+           !ty::type_is_bot(cx.ccx.tcx, block_ty) &&\n+           f.proto != ast::proto_iter {\n+        trans_block(bcx, f.body, save_in(fcx.llretptr))\n+    } else { trans_block(bcx, f.body, return) };\n+    bcx = rslt.bcx;\n \n     if !is_terminated(bcx) {\n         // FIXME: until LLVM has a unit type, we are moving around"}, {"sha": "25897669f5b6691d70f23621c2732ccd53e971ff", "filename": "src/comp/middle/trans_dps.rs", "status": "removed", "additions": 0, "deletions": 580, "changes": 580, "blob_url": "https://github.com/rust-lang/rust/blob/3db300b06e11b3dee9d6f1780f3c7b9ccad575aa/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3db300b06e11b3dee9d6f1780f3c7b9ccad575aa/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs?ref=3db300b06e11b3dee9d6f1780f3c7b9ccad575aa", "patch": "@@ -1,580 +0,0 @@\n-// Translates individual functions in the completed AST to the LLVM IR, using\n-// destination-passing style.\n-\n-import back::abi;\n-import back::link;\n-import lib::llvm::llvm;\n-import llvm::TypeRef;\n-import llvm::ValueRef;\n-import middle::trans_common;\n-import middle::ty;\n-import syntax::ast;\n-import syntax::codemap::span;\n-import util::ppaux;\n-import trans_common::*;\n-import std::vec;\n-import std::option::none;\n-import std::option::some;\n-import std::str;\n-import std::uint;\n-\n-import LLFalse = lib::llvm::False;\n-import LLTrue = lib::llvm::True;\n-import ll = lib::llvm;\n-import lltype_of = trans_common::val_ty;\n-import option = std::option::t;\n-import tc = trans_common;\n-import type_of_node = trans::node_id_type;\n-\n-\n-// LLVM utilities\n-\n-fn llelement_type(llty: TypeRef) -> TypeRef {\n-    lib::llvm::llvm::LLVMGetElementType(llty)\n-}\n-\n-fn llalign_of(ccx: &@crate_ctxt, llty: TypeRef) -> uint {\n-    ret llvm::LLVMPreferredAlignmentOfType(ccx.td.lltd, llty);\n-}\n-\n-fn llsize_of(ccx: &@crate_ctxt, llty: TypeRef) -> uint {\n-    ret llvm::LLVMStoreSizeOfType(ccx.td.lltd, llty);\n-}\n-\n-fn mk_const(ccx: &@crate_ctxt, name: &str, exported: bool, llval: ValueRef) ->\n-   ValueRef {\n-    let llglobal =\n-        llvm::LLVMAddGlobal(ccx.llmod, tc::val_ty(llval), str::buf(name));\n-\n-    llvm::LLVMSetInitializer(llglobal, llval);\n-    llvm::LLVMSetGlobalConstant(llglobal, LLTrue);\n-\n-    if !exported {\n-        llvm::LLVMSetLinkage(llglobal,\n-                             lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n-    }\n-\n-    ret llglobal;\n-}\n-\n-\n-// Type utilities\n-\n-fn size_of(ccx: &@crate_ctxt, sp: &span, t: ty::t) -> uint {\n-    if ty::type_has_dynamic_size(ccx.tcx, t) {\n-        ccx.sess.bug(\"trans_dps::size_of() called on a type with dynamic \" +\n-                         \"size\");\n-    }\n-    ret llsize_of(ccx, trans::type_of_inner(ccx, sp, t));\n-}\n-\n-\n-// Destination utilities\n-\n-tag dest {\n-    dst_nil; // Unit destination; ignore.\n-\n-    dst_imm(@mutable option[ValueRef]); // Fill with an immediate value.\n-\n-    dst_alias(@mutable option[ValueRef]); // Fill with an alias pointer.\n-\n-    dst_copy(ValueRef); // Copy to the given address.\n-\n-    dst_move(ValueRef); // Move to the given address.\n-}\n-\n-fn dest_imm(tcx: &ty::ctxt, t: ty::t) -> dest {\n-    if ty::type_is_nil(tcx, t) { dst_nil } else { dst_imm(@mutable none) }\n-}\n-\n-fn dest_alias(tcx: &ty::ctxt, t: ty::t) -> dest {\n-    if ty::type_is_nil(tcx, t) { dst_nil } else { dst_alias(@mutable none) }\n-}\n-\n-fn dest_copy(tcx: &ty::ctxt, llptr: ValueRef, t: ty::t) -> dest {\n-    if ty::type_is_nil(tcx, t) { dst_nil } else { dst_copy(llptr) }\n-}\n-\n-fn dest_move(tcx: &ty::ctxt, llptr: ValueRef, t: ty::t) -> dest {\n-    if ty::type_is_nil(tcx, t) { dst_nil } else { dst_move(llptr) }\n-}\n-\n-// Invariant: the type of the destination must be structural (non-immediate).\n-fn dest_ptr(dest: &dest) -> ValueRef {\n-    alt dest {\n-      dst_nil. { fail \"nil dest in dest_ptr\" }\n-      dst_imm(_) { fail \"immediate dest in dest_ptr\" }\n-      dst_alias(box) {\n-        alt *box {\n-          none. { fail \"alias wasn't filled in prior to dest_ptr\" }\n-          some(llval) { llval }\n-        }\n-      }\n-      dst_copy(llptr) { llptr }\n-      dst_move(llptr) { llptr }\n-    }\n-}\n-\n-fn dest_llval(dest: &dest) -> ValueRef {\n-    alt dest {\n-      dst_nil. { ret tc::C_nil(); }\n-      dst_imm(box) {\n-        alt *box {\n-          none. { fail \"immediate wasn't filled in prior to dest_llval\"; }\n-          some(llval) { ret llval; }\n-        }\n-      }\n-      dst_alias(box) {\n-        alt *box {\n-          none. { fail \"alias wasn't filled in prior to dest_llval\"; }\n-          some(llval) { ret llval; }\n-        }\n-      }\n-      dst_copy(llptr) { ret llptr; }\n-      dst_move(llptr) { ret llptr; }\n-    }\n-}\n-\n-fn dest_is_alias(dest: &dest) -> bool {\n-    alt dest { dst_alias(_) { true } _ { false } }\n-}\n-\n-\n-// Common operations\n-\n-fn memmove(bcx: &@block_ctxt, lldestptr: ValueRef, llsrcptr: ValueRef,\n-           llsz: ValueRef) {\n-    let lldestty = llelement_type(tc::val_ty(lldestptr));\n-    let llsrcty = llelement_type(tc::val_ty(llsrcptr));\n-    let dest_align = llalign_of(bcx_ccx(bcx), lldestty);\n-    let src_align = llalign_of(bcx_ccx(bcx), llsrcty);\n-    let align = uint::min(dest_align, src_align);\n-    let llfn = bcx_ccx(bcx).intrinsics.get(\"llvm.memmove.p0i8.p0i8.i32\");\n-    let lldestptr_i8 =\n-        bcx.build.PointerCast(lldestptr, tc::T_ptr(tc::T_i8()));\n-    let llsrcptr_i8 = bcx.build.PointerCast(llsrcptr, tc::T_ptr(tc::T_i8()));\n-    bcx.build.Call(llfn,\n-                   ~[lldestptr_i8, llsrcptr_i8, llsz, tc::C_uint(align),\n-                     tc::C_bool(false)]);\n-}\n-\n-// If \"cast\" is true, casts dest appropriately before the store.\n-fn store_imm(bcx: &@block_ctxt, dest: &dest, llsrc: ValueRef, cast: bool) ->\n-   @block_ctxt {\n-    alt dest {\n-      dst_nil. {/* no-op */ }\n-      dst_imm(box) {\n-        assert (std::option::is_none(*box));\n-        *box = some(llsrc);\n-      }\n-      dst_alias(box) {\n-        bcx_ccx(bcx).sess.unimpl(\"dst_alias spill in store_imm\");\n-      }\n-      dst_copy(lldestptr_orig) | dst_move(lldestptr_orig) {\n-        let lldestptr = lldestptr_orig;\n-        if cast {\n-            lldestptr =\n-                bcx.build.PointerCast(lldestptr, tc::T_ptr(lltype_of(llsrc)));\n-        }\n-        bcx.build.Store(llsrc, lldestptr);\n-      }\n-    }\n-    ret bcx;\n-}\n-\n-fn store_ptr(bcx: &@block_ctxt, dest: &dest, llsrcptr: ValueRef) ->\n-   @block_ctxt {\n-    alt dest {\n-      dst_nil. {/* no-op */ }\n-      dst_imm(box) {\n-        assert (std::option::is_none(*box));\n-        *box = some(bcx.build.Load(llsrcptr));\n-      }\n-      dst_alias(box) {\n-        assert (std::option::is_none(*box));\n-        *box = some(llsrcptr);\n-      }\n-      dst_copy(lldestptr) | dst_move(lldestptr) {\n-        let llsrcty = llelement_type(tc::val_ty(llsrcptr));\n-        let llsz = tc::C_uint(llsize_of(bcx_ccx(bcx), llsrcty));\n-        memmove(bcx, lldestptr, llsrcptr, llsz);\n-        ret bcx;\n-      }\n-    }\n-    ret bcx;\n-}\n-\n-// Allocates a value of the given LLVM size on either the task heap or the\n-// shared heap.\n-//\n-// TODO: This should *not* use destination-passing style, because doing so\n-// makes callers incur an extra load.\n-tag heap { hp_task; hp_shared; }\n-fn malloc(bcx: &@block_ctxt, lldest: ValueRef, heap: heap,\n-          llcustom_size_opt: option[ValueRef]) -> @block_ctxt {\n-    let llptrty = llelement_type(lltype_of(lldest));\n-    let llty = llelement_type(llptrty);\n-\n-    let lltydescptr = tc::C_null(tc::T_ptr(bcx_ccx(bcx).tydesc_type));\n-\n-    let llsize;\n-    alt llcustom_size_opt {\n-      none. { llsize = trans::llsize_of(llty); }\n-      some(llcustom_size) { llsize = llcustom_size; }\n-    }\n-\n-    let llupcall;\n-    alt heap {\n-      hp_task. { llupcall = bcx_ccx(bcx).upcalls.malloc; }\n-      hp_shared. { llupcall = bcx_ccx(bcx).upcalls.shared_malloc; }\n-    }\n-\n-    let llresult =\n-        bcx.build.Call(llupcall,\n-                       ~[bcx_fcx(bcx).lltaskptr, llsize, lltydescptr]);\n-    llresult = bcx.build.PointerCast(llresult, llptrty);\n-    bcx.build.Store(llresult, lldest);\n-    ret bcx;\n-}\n-\n-// If the supplied destination is an alias, spills to a temporary. Returns the\n-// new destination.\n-fn spill_alias(cx: &@block_ctxt, dest: &dest, t: ty::t) ->\n-   {bcx: @block_ctxt, dest: dest} {\n-    let bcx = cx;\n-    alt dest {\n-      dst_alias(box) {\n-        // TODO: Mark the alias as needing a cleanup.\n-        assert (std::option::is_none(*box));\n-        let r = trans::alloc_ty(cx, t);\n-        bcx = r.bcx;\n-        let llptr = r.val;\n-        *box = some(llptr);\n-        ret {bcx: bcx, dest: dst_move(llptr)};\n-      }\n-      _ { ret {bcx: bcx, dest: dest}; }\n-    }\n-}\n-\n-fn mk_temp(cx: &@block_ctxt, t: ty::t) -> {bcx: @block_ctxt, dest: dest} {\n-    let bcx = cx;\n-    if ty::type_is_nil(bcx_tcx(bcx), t) { ret {bcx: bcx, dest: dst_nil}; }\n-    if trans::type_is_immediate(bcx_ccx(bcx), t) {\n-        ret {bcx: bcx, dest: dst_imm(@mutable none)};\n-    }\n-\n-    let r = trans::alloc_ty(cx, t);\n-    bcx = r.bcx;\n-    let llptr = r.val;\n-    ret {bcx: bcx, dest: dst_copy(llptr)};\n-}\n-\n-\n-// AST substructure translation, with destinations\n-\n-fn trans_lit(cx: &@block_ctxt, dest: &dest, lit: &ast::lit) -> @block_ctxt {\n-    let bcx = cx;\n-    alt lit.node {\n-      ast::lit_str(s, ast::sk_unique.) {\n-        let r = trans_lit_str_common(bcx_ccx(bcx), s, dest_is_alias(dest));\n-        let llstackpart = r.stack;\n-        let llheappartopt = r.heap;\n-        bcx = store_ptr(bcx, dest, llstackpart);\n-        alt llheappartopt {\n-          none. {/* no-op */ }\n-          some(llheappart) {\n-            let lldestptrptr =\n-                bcx.build.InBoundsGEP(dest_ptr(dest),\n-                                      ~[tc::C_int(0),\n-                                        tc::C_uint(abi::ivec_elt_elems)]);\n-            let llheappartty = lltype_of(llheappart);\n-            lldestptrptr =\n-                bcx.build.PointerCast(lldestptrptr,\n-                                      tc::T_ptr(tc::T_ptr(llheappartty)));\n-            malloc(bcx, lldestptrptr, hp_shared, none);\n-            let lldestptr = bcx.build.Load(lldestptrptr);\n-            store_ptr(bcx, dst_copy(lldestptr), llheappart);\n-          }\n-        }\n-      }\n-      _ {\n-        bcx =\n-            store_imm(bcx, dest, trans_lit_common(bcx_ccx(bcx), lit), false);\n-      }\n-    }\n-\n-    ret bcx;\n-}\n-\n-fn trans_binary(cx: &@block_ctxt, dest: &dest, sp: &span, op: ast::binop,\n-                lhs: &@ast::expr, rhs: &@ast::expr) -> @block_ctxt {\n-    let bcx = cx;\n-    alt op {\n-      ast::add. {\n-        bcx =\n-            trans_vec::trans_concat(bcx, dest, sp,\n-                                    ty::expr_ty(bcx_tcx(bcx), rhs), lhs, rhs);\n-      }\n-    }\n-    // TODO: Many more to add here.\n-    ret bcx;\n-}\n-\n-fn trans_log(cx: &@block_ctxt, sp: &span, level: int, expr: &@ast::expr) ->\n-   @block_ctxt {\n-    fn trans_log_level(lcx: &@local_ctxt) -> ValueRef {\n-        let modname = str::connect(lcx.module_path, \"::\");\n-\n-        if lcx_ccx(lcx).module_data.contains_key(modname) {\n-            ret lcx_ccx(lcx).module_data.get(modname);\n-        }\n-\n-        let s =\n-            link::mangle_internal_name_by_path_and_seq(lcx_ccx(lcx),\n-                                                       lcx.module_path,\n-                                                       \"loglevel\");\n-        let lllevelptr =\n-            llvm::LLVMAddGlobal(lcx.ccx.llmod, tc::T_int(), str::buf(s));\n-        llvm::LLVMSetGlobalConstant(lllevelptr, LLFalse);\n-        llvm::LLVMSetInitializer(lllevelptr, tc::C_int(0));\n-        llvm::LLVMSetLinkage(lllevelptr,\n-                             lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n-        lcx_ccx(lcx).module_data.insert(modname, lllevelptr);\n-        ret lllevelptr;\n-    }\n-\n-    let bcx = cx;\n-\n-    let lllevelptr = trans_log_level(bcx_lcx(bcx));\n-\n-    let log_bcx = trans::new_scope_block_ctxt(bcx, \"log\");\n-    let next_bcx = trans::new_scope_block_ctxt(bcx, \"next_log\");\n-\n-    let should_log =\n-        bcx.build.ICmp(ll::LLVMIntSGE, bcx.build.Load(lllevelptr),\n-                       tc::C_int(level));\n-    bcx.build.CondBr(should_log, log_bcx.llbb, next_bcx.llbb);\n-\n-    let expr_t = ty::expr_ty(bcx_tcx(log_bcx), expr);\n-    let arg_dest = dest_alias(bcx_tcx(log_bcx), expr_t);\n-    log_bcx = trans_expr(log_bcx, arg_dest, expr);\n-\n-    let llarg = dest_llval(arg_dest);\n-    let llarg_i8 = bcx.build.PointerCast(llarg, T_ptr(T_i8()));\n-\n-    let ti = none;\n-    let r2 = trans::get_tydesc(bcx, expr_t, false, ti);\n-    bcx = r2.bcx;\n-    let lltydesc = r2.val;\n-\n-    log_bcx.build.Call(bcx_ccx(log_bcx).upcalls.log_type,\n-                       ~[bcx_fcx(bcx).lltaskptr, lltydesc, llarg_i8,\n-                         tc::C_int(level)]);\n-\n-    log_bcx =\n-        trans::trans_block_cleanups(log_bcx, tc::find_scope_cx(log_bcx));\n-    log_bcx.build.Br(next_bcx.llbb);\n-    ret next_bcx;\n-}\n-\n-fn trans_path(bcx: &@block_ctxt, dest: &dest, path: &ast::path,\n-              id: ast::node_id) -> @block_ctxt {\n-    alt bcx_tcx(bcx).def_map.get(id) {\n-      ast::def_local(def_id) {\n-        alt bcx_fcx(bcx).lllocals.find(def_id.node) {\n-          none. { bcx_ccx(bcx).sess.unimpl(\"upvar in trans_path\"); }\n-          some(llptr) {\n-            // TODO: Copy hooks.\n-            store_ptr(bcx, dest, llptr);\n-          }\n-        }\n-      }\n-      _ { bcx_ccx(bcx).sess.unimpl(\"def variant in trans_dps::trans_path\"); }\n-    }\n-    ret bcx;\n-}\n-\n-fn trans_expr(bcx: &@block_ctxt, dest: &dest, expr: &@ast::expr) ->\n-   @block_ctxt {\n-    alt expr.node {\n-      ast::expr_lit(lit) { trans_lit(bcx, dest, *lit); ret bcx; }\n-      ast::expr_log(level, operand) {\n-        ret trans_log(bcx, expr.span, level, operand);\n-      }\n-      ast::expr_binary(op, lhs, rhs) {\n-        ret trans_binary(bcx, dest, expr.span, op, lhs, rhs);\n-      }\n-      ast::expr_path(path) { ret trans_path(bcx, dest, path, expr.id); }\n-      _ { fail \"unhandled expr type in trans_expr\"; }\n-    }\n-}\n-\n-fn trans_recv(bcx: &@block_ctxt, dest: &dest, expr: &@ast::expr) ->\n-   @block_ctxt {\n-    ret bcx; // TODO\n-}\n-\n-fn trans_block(cx: &@block_ctxt, dest: &dest, blk: &ast::blk) -> @block_ctxt {\n-    let bcx = cx;\n-    for each local: @ast::local in trans::block_locals(blk) {\n-        bcx = trans::alloc_local(bcx, local).bcx;\n-    }\n-\n-    for stmt: @ast::stmt in blk.node.stmts {\n-        bcx = trans_stmt(bcx, stmt);\n-\n-\n-        // If we hit a terminator, control won't go any further so\n-        // we're in dead-code land. Stop here.\n-        if trans::is_terminated(bcx) { ret bcx; }\n-    }\n-\n-    alt blk.node.expr {\n-      some(e) { bcx = trans_expr(bcx, dest, e); }\n-      none. {/* no-op */ }\n-    }\n-\n-    bcx = trans::trans_block_cleanups(bcx, tc::find_scope_cx(bcx));\n-    ret bcx;\n-}\n-\n-\n-\n-// AST substructure translation, without destinations\n-\n-// Common setup code shared between the crate-constant literal string case and\n-// the block-local literal string case. We don't use destination-passing style\n-// since that doesn't work for crate constants.\n-//\n-// If |expand| is true, we never spill to the heap. This should be used\n-// whenever the destination size isn't fixed.\n-fn trans_lit_str_common(ccx: &@crate_ctxt, s: &str, expand: bool) ->\n-   {stack: ValueRef, heap: option[ValueRef]} {\n-    let llstackpart;\n-    let llheappartopt;\n-\n-    let len = str::byte_len(s);\n-\n-    let array = ~[];\n-    for ch: u8 in s { array += ~[tc::C_u8(ch as uint)]; }\n-    array += ~[tc::C_u8(0u)];\n-\n-    if expand {\n-        llstackpart =\n-            tc::C_struct(~[tc::C_uint(len + 1u), tc::C_uint(len + 1u),\n-                           tc::C_array(tc::T_i8(), array)]);\n-        llheappartopt = none;\n-    } else if (len < abi::ivec_default_length - 1u)\n-     { // minus one for the null\n-        while vec::len(array) < abi::ivec_default_length {\n-            array += ~[tc::C_u8(0u)];\n-        }\n-\n-        llstackpart =\n-            tc::C_struct(~[tc::C_uint(len + 1u),\n-                           tc::C_uint(abi::ivec_default_length),\n-                           tc::C_array(tc::T_i8(), array)]);\n-        llheappartopt = none;\n-    } else {\n-        let llheappart =\n-            tc::C_struct(~[tc::C_uint(len), tc::C_array(tc::T_i8(), array)]);\n-        llstackpart =\n-            tc::C_struct(~[tc::C_uint(0u),\n-                           tc::C_uint(abi::ivec_default_length),\n-                           tc::C_null(tc::T_ptr(lltype_of(llheappart)))]);\n-        llheappartopt =\n-            some(mk_const(ccx, \"const_istr_heap\", false, llheappart));\n-    }\n-\n-    ret {stack: mk_const(ccx, \"const_istr_stack\", false, llstackpart),\n-         heap: llheappartopt};\n-}\n-\n-// As above, we don't use destination-passing style here.\n-fn trans_lit_common(ccx: &@crate_ctxt, lit: &ast::lit) -> ValueRef {\n-    alt lit.node {\n-      ast::lit_int(i) { ret tc::C_int(i); }\n-      ast::lit_uint(u) { ret tc::C_int(u as int); }\n-      ast::lit_mach_int(tm, i) {\n-        // FIXME: the entire handling of mach types falls apart\n-        // if target int width is larger than host, at the moment;\n-        // re-do the mach-int types using 'big' when that works.\n-\n-        let t = tc::T_int();\n-        let s = LLTrue;\n-        alt tm {\n-          ast::ty_u8. { t = tc::T_i8(); s = LLFalse; }\n-          ast::ty_u16. { t = tc::T_i16(); s = LLFalse; }\n-          ast::ty_u32. { t = tc::T_i32(); s = LLFalse; }\n-          ast::ty_u64. { t = tc::T_i64(); s = LLFalse; }\n-          ast::ty_i8. { t = tc::T_i8(); }\n-          ast::ty_i16. { t = tc::T_i16(); }\n-          ast::ty_i32. { t = tc::T_i32(); }\n-          ast::ty_i64. { t = tc::T_i64(); }\n-        }\n-        ret tc::C_integral(t, i as uint, s);\n-      }\n-      ast::lit_float(fs) { ret tc::C_float(fs); }\n-      ast::lit_mach_float(tm, s) {\n-        let t = tc::T_float();\n-        alt tm {\n-          ast::ty_f32. { t = tc::T_f32(); }\n-          ast::ty_f64. { t = tc::T_f64(); }\n-        }\n-        ret tc::C_floating(s, t);\n-      }\n-      ast::lit_char(c) {\n-        ret tc::C_integral(tc::T_char(), c as uint, LLFalse);\n-      }\n-      ast::lit_bool(b) { ret tc::C_bool(b); }\n-      ast::lit_nil. { ret tc::C_nil(); }\n-      ast::lit_str(s, ast::sk_rc.) { ret tc::C_str(ccx, s); }\n-      ast::lit_str(s, ast::sk_unique.) {\n-        fail \"unique str in trans_lit_common\";\n-      }\n-    }\n-}\n-\n-fn trans_init_local(bcx: &@block_ctxt, local: &@ast::local) -> @block_ctxt {\n-    let llptr = bcx_fcx(bcx).lllocals.get(local.node.pat.id); // FIXME DESTR\n-\n-    let t = type_of_node(bcx_ccx(bcx), local.node.pat.id);\n-    tc::add_clean(bcx, llptr, t);\n-\n-\n-    alt local.node.init {\n-      some(init) {\n-        alt init.op {\n-          ast::init_assign. {\n-            ret trans_expr(bcx, dest_copy(bcx_tcx(bcx), llptr, t), init.expr);\n-          }\n-          ast::init_move. {\n-            ret trans_expr(bcx, dest_move(bcx_tcx(bcx), llptr, t), init.expr);\n-          }\n-        }\n-      }\n-      none. { ret bcx; }\n-    }\n-}\n-\n-fn trans_stmt(cx: &@block_ctxt, stmt: &@ast::stmt) -> @block_ctxt {\n-    let bcx = cx;\n-    alt stmt.node {\n-      ast::stmt_expr(e, _) {\n-        let tmp = dest_alias(bcx_tcx(bcx), ty::expr_ty(bcx_tcx(bcx), e));\n-        ret trans_expr(bcx, tmp, e);\n-      }\n-      ast::stmt_decl(d, _) {\n-        alt d.node {\n-          ast::decl_local(locals) {\n-            for local: @ast::local in locals {\n-                bcx = trans_init_local(bcx, local);\n-            }\n-          }\n-          ast::decl_item(item) { trans::trans_item(bcx_lcx(bcx), *item); }\n-        }\n-        ret bcx;\n-      }\n-    }\n-}\n-"}, {"sha": "d2b30593b483ee487ac58a3d9f0885ebb50e70ac", "filename": "src/comp/middle/trans_vec.rs", "status": "removed", "additions": 0, "deletions": 219, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/3db300b06e11b3dee9d6f1780f3c7b9ccad575aa/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3db300b06e11b3dee9d6f1780f3c7b9ccad575aa/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=3db300b06e11b3dee9d6f1780f3c7b9ccad575aa", "patch": "@@ -1,219 +0,0 @@\n-// Translation of vector operations to LLVM IR, in destination-passing style.\n-\n-import back::abi;\n-import lib::llvm::llvm;\n-import llvm::ValueRef;\n-import middle::trans;\n-import middle::trans_common;\n-import middle::trans_dps;\n-import middle::ty;\n-import syntax::ast;\n-import syntax::codemap::span;\n-import trans::alloca;\n-import trans::load_inbounds;\n-import trans::new_sub_block_ctxt;\n-import trans::type_of_or_i8;\n-import trans_common::block_ctxt;\n-import trans_common::struct_elt;\n-import trans_common::C_int;\n-import trans_common::C_null;\n-import trans_common::C_uint;\n-import trans_common::T_int;\n-import trans_common::T_ivec_heap;\n-import trans_common::T_ivec_heap_part;\n-import trans_common::T_opaque_ivec;\n-import trans_common::T_ptr;\n-import trans_common::bcx_ccx;\n-import trans_common::bcx_tcx;\n-import trans_dps::dest;\n-import trans_dps::llsize_of;\n-import trans_dps::mk_temp;\n-\n-import std::option::none;\n-import std::option::some;\n-import tc = middle::trans_common;\n-\n-// Returns the length of an interior vector and a pointer to its first\n-// element, in that order.\n-//\n-// TODO: We can optimize this in the cases in which we statically know the\n-// vector must be on the stack.\n-fn get_len_and_data(cx: &@block_ctxt, t: ty::t, llvecptr: ValueRef) ->\n-   {bcx: @block_ctxt, len: ValueRef, data: ValueRef} {\n-    let bcx = cx;\n-\n-    // If this interior vector has dynamic size, we can't assume anything\n-    // about the LLVM type of the value passed in, so we cast it to an\n-    // opaque vector type.\n-    let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), t);\n-    let v;\n-    if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n-        v = bcx.build.PointerCast(llvecptr, T_ptr(T_opaque_ivec()));\n-    } else { v = llvecptr; }\n-\n-    let llunitty = type_of_or_i8(bcx, unit_ty);\n-    let stack_len =\n-        load_inbounds(bcx, v, ~[C_int(0), C_uint(abi::ivec_elt_len)]);\n-    let stack_elem =\n-        bcx.build.InBoundsGEP(v,\n-                              ~[C_int(0), C_uint(abi::ivec_elt_elems),\n-                                C_int(0)]);\n-    let on_heap = bcx.build.ICmp(lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n-    let on_heap_cx = new_sub_block_ctxt(bcx, \"on_heap\");\n-    let next_cx = new_sub_block_ctxt(bcx, \"next\");\n-    bcx.build.CondBr(on_heap, on_heap_cx.llbb, next_cx.llbb);\n-    let heap_stub =\n-        on_heap_cx.build.PointerCast(v, T_ptr(T_ivec_heap(llunitty)));\n-    let heap_ptr =\n-        load_inbounds(on_heap_cx, heap_stub,\n-                      ~[C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)]);\n-\n-    // Check whether the heap pointer is null. If it is, the vector length\n-    // is truly zero.\n-\n-    let llstubty = T_ivec_heap(llunitty);\n-    let llheapptrty = struct_elt(llstubty, abi::ivec_heap_stub_elt_ptr);\n-    let heap_ptr_is_null =\n-        on_heap_cx.build.ICmp(lib::llvm::LLVMIntEQ, heap_ptr,\n-                              C_null(T_ptr(llheapptrty)));\n-    let zero_len_cx = new_sub_block_ctxt(bcx, \"zero_len\");\n-    let nonzero_len_cx = new_sub_block_ctxt(bcx, \"nonzero_len\");\n-    on_heap_cx.build.CondBr(heap_ptr_is_null, zero_len_cx.llbb,\n-                            nonzero_len_cx.llbb);\n-    // Technically this context is unnecessary, but it makes this function\n-    // clearer.\n-\n-    let zero_len = C_int(0);\n-    let zero_elem = C_null(T_ptr(llunitty));\n-    zero_len_cx.build.Br(next_cx.llbb);\n-    // If we're here, then we actually have a heapified vector.\n-\n-    let heap_len =\n-        load_inbounds(nonzero_len_cx, heap_ptr,\n-                      ~[C_int(0), C_uint(abi::ivec_heap_elt_len)]);\n-    let heap_elem =\n-        {\n-            let v = ~[C_int(0), C_uint(abi::ivec_heap_elt_elems), C_int(0)];\n-            nonzero_len_cx.build.InBoundsGEP(heap_ptr, v)\n-        };\n-\n-    nonzero_len_cx.build.Br(next_cx.llbb);\n-\n-    // Now we can figure out the length of |v| and get a pointer to its\n-    // first element.\n-\n-    let len =\n-        next_cx.build.Phi(T_int(), ~[stack_len, zero_len, heap_len],\n-                          ~[bcx.llbb, zero_len_cx.llbb, nonzero_len_cx.llbb]);\n-    let elem =\n-        next_cx.build.Phi(T_ptr(llunitty),\n-                          ~[stack_elem, zero_elem, heap_elem],\n-                          ~[bcx.llbb, zero_len_cx.llbb, nonzero_len_cx.llbb]);\n-    ret {bcx: next_cx, len: len, data: elem};\n-}\n-\n-fn trans_concat(cx: &@block_ctxt, in_dest: &dest, sp: &span, t: ty::t,\n-                lhs: &@ast::expr, rhs: &@ast::expr) -> @block_ctxt {\n-    let bcx = cx;\n-\n-    // TODO: Detect \"a = a + b\" and promote to trans_append.\n-    // TODO: Detect \"a + [ literal ]\" and optimize to copying the literal\n-    //       elements in directly.\n-\n-    let t = ty::expr_ty(bcx_tcx(bcx), lhs);\n-    let skip_null = ty::type_is_str(bcx_tcx(bcx), t);\n-\n-    // Translate the LHS and RHS. Pull out their length and data.\n-    let lhs_tmp = trans_dps::dest_alias(bcx_tcx(bcx), t);\n-    bcx = trans_dps::trans_expr(bcx, lhs_tmp, lhs);\n-    let lllhsptr = trans_dps::dest_ptr(lhs_tmp);\n-\n-    let rhs_tmp = trans_dps::dest_alias(bcx_tcx(bcx), t);\n-    bcx = trans_dps::trans_expr(bcx, rhs_tmp, rhs);\n-    let llrhsptr = trans_dps::dest_ptr(rhs_tmp);\n-\n-    let r0 = get_len_and_data(bcx, t, lllhsptr);\n-    bcx = r0.bcx;\n-    let lllhslen = r0.len;\n-    let lllhsdata = r0.data;\n-    r0 = get_len_and_data(bcx, t, llrhsptr);\n-    bcx = r0.bcx;\n-    let llrhslen = r0.len;\n-    let llrhsdata = r0.data;\n-\n-    if skip_null { lllhslen = bcx.build.Sub(lllhslen, C_int(1)); }\n-\n-    // Allocate the destination.\n-    let r1 = trans_dps::spill_alias(bcx, in_dest, t);\n-    bcx = r1.bcx;\n-    let dest = r1.dest;\n-\n-    let unit_t = ty::sequence_element_type(bcx_tcx(bcx), t);\n-    let unit_sz = trans_dps::size_of(bcx_ccx(bcx), sp, unit_t);\n-\n-    let stack_elems_sz = unit_sz * abi::ivec_default_length;\n-    let lldestptr = trans_dps::dest_ptr(dest);\n-    let llunitty = trans::type_of(bcx_ccx(bcx), sp, unit_t);\n-\n-    // Decide whether to allocate the result on the stack or on the heap.\n-    let llnewlen = bcx.build.Add(lllhslen, llrhslen);\n-    let llonstack =\n-        bcx.build.ICmp(lib::llvm::LLVMIntULE, llnewlen,\n-                       C_uint(stack_elems_sz));\n-    let on_stack_bcx = new_sub_block_ctxt(bcx, \"on_stack\");\n-    let on_heap_bcx = new_sub_block_ctxt(bcx, \"on_heap\");\n-    bcx.build.CondBr(llonstack, on_stack_bcx.llbb, on_heap_bcx.llbb);\n-\n-    // On-stack case.\n-    let next_bcx = new_sub_block_ctxt(bcx, \"next\");\n-    trans::store_inbounds(on_stack_bcx, llnewlen, lldestptr,\n-                          ~[C_int(0), C_uint(abi::ivec_elt_len)]);\n-    trans::store_inbounds(on_stack_bcx, C_uint(stack_elems_sz), lldestptr,\n-                          ~[C_int(0), C_uint(abi::ivec_elt_alen)]);\n-    let llonstackdataptr =\n-        on_stack_bcx.build.InBoundsGEP(lldestptr,\n-                                       ~[C_int(0),\n-                                         C_uint(abi::ivec_elt_elems),\n-                                         C_int(0)]);\n-    on_stack_bcx.build.Br(next_bcx.llbb);\n-\n-    // On-heap case.\n-    let llheappartty = tc::T_ivec_heap(llunitty);\n-    let lldeststubptr =\n-        on_heap_bcx.build.PointerCast(lldestptr, tc::T_ptr(llheappartty));\n-    trans::store_inbounds(on_heap_bcx, C_int(0), lldeststubptr,\n-                          ~[C_int(0), C_uint(abi::ivec_elt_len)]);\n-    trans::store_inbounds(on_heap_bcx, llnewlen, lldeststubptr,\n-                          ~[C_int(0), C_uint(abi::ivec_elt_alen)]);\n-\n-    let llheappartptrptr =\n-        on_heap_bcx.build.InBoundsGEP(lldeststubptr,\n-                                      ~[C_int(0),\n-                                        C_uint(abi::ivec_elt_elems)]);\n-    let llsizeofint = C_uint(llsize_of(bcx_ccx(bcx), tc::T_int()));\n-    on_heap_bcx =\n-        trans_dps::malloc(on_heap_bcx, llheappartptrptr, trans_dps::hp_shared,\n-                          some(on_heap_bcx.build.Add(llnewlen, llsizeofint)));\n-    let llheappartptr = on_heap_bcx.build.Load(llheappartptrptr);\n-    trans::store_inbounds(on_heap_bcx, llnewlen, llheappartptr,\n-                          ~[C_int(0), C_uint(abi::ivec_heap_elt_len)]);\n-    let llheapdataptr =\n-        on_heap_bcx.build.InBoundsGEP(llheappartptr,\n-                                      ~[C_int(0),\n-                                        C_uint(abi::ivec_heap_elt_elems),\n-                                        C_int(0)]);\n-    on_heap_bcx.build.Br(next_bcx.llbb);\n-\n-    // Perform the memmove.\n-    let lldataptr =\n-        next_bcx.build.Phi(T_ptr(llunitty),\n-                           ~[llonstackdataptr, llheapdataptr],\n-                           ~[on_stack_bcx.llbb, on_heap_bcx.llbb]);\n-    trans_dps::memmove(next_bcx, lldataptr, lllhsdata, lllhslen);\n-    trans_dps::memmove(next_bcx,\n-                       next_bcx.build.InBoundsGEP(lldataptr, ~[lllhslen]),\n-                       llrhsdata, llrhslen);\n-\n-    ret next_bcx;\n-}\n-"}, {"sha": "555f8d45655d7cb813db68bab65ecdf3960419a0", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27169387fe615269fa79d0d904d96be0226d628a/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/27169387fe615269fa79d0d904d96be0226d628a/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=27169387fe615269fa79d0d904d96be0226d628a", "patch": "@@ -17,9 +17,7 @@ mod middle {\n     mod trans_common;\n     mod trans;\n     mod trans_alt;\n-    mod trans_dps;\n     mod trans_objects;\n-    mod trans_vec;\n     mod ty;\n     mod ast_map;\n     mod resolve;"}]}