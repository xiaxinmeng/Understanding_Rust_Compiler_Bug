{"sha": "57cd6b3e3f0fc3d1805a167dfa2b4d5afc2f43a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3Y2Q2YjNlM2YwZmMzZDE4MDVhMTY3ZGZhMmI0ZDVhZmMyZjQzYTU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-25T01:47:59Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-25T20:59:10Z"}, "message": "rustc: Translate and check exhaustiveness of struct-like enum variant patterns. r=nmatsakis", "tree": {"sha": "3f707466cbd8e540a73a711faf78e3b2c980516c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f707466cbd8e540a73a711faf78e3b2c980516c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57cd6b3e3f0fc3d1805a167dfa2b4d5afc2f43a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57cd6b3e3f0fc3d1805a167dfa2b4d5afc2f43a5", "html_url": "https://github.com/rust-lang/rust/commit/57cd6b3e3f0fc3d1805a167dfa2b4d5afc2f43a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57cd6b3e3f0fc3d1805a167dfa2b4d5afc2f43a5/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65ee0e1dedf76a49de03e7ecb5eed03d47d54a5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/65ee0e1dedf76a49de03e7ecb5eed03d47d54a5e", "html_url": "https://github.com/rust-lang/rust/commit/65ee0e1dedf76a49de03e7ecb5eed03d47d54a5e"}], "stats": {"total": 170, "additions": 150, "deletions": 20}, "files": [{"sha": "7ed7829cf343baef1e03910aa6940094d0450b90", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 41, "deletions": 16, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/57cd6b3e3f0fc3d1805a167dfa2b4d5afc2f43a5/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57cd6b3e3f0fc3d1805a167dfa2b4d5afc2f43a5/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=57cd6b3e3f0fc3d1805a167dfa2b4d5afc2f43a5", "patch": "@@ -234,8 +234,14 @@ fn pat_ctor_id(tcx: ty::ctxt, p: @pat) -> Option<ctor> {\n       pat_range(lo, hi) => {\n         Some(range(eval_const_expr(tcx, lo), eval_const_expr(tcx, hi)))\n       }\n-      pat_box(_) | pat_uniq(_) | pat_rec(_, _) | pat_tup(_) | pat_region(*) |\n       pat_struct(*) => {\n+        match tcx.def_map.find(pat.id) {\n+          Some(def_variant(_, id)) => Some(variant(id)),\n+          _ => Some(single)\n+        }\n+      }\n+      pat_box(_) | pat_uniq(_) | pat_rec(_, _) | pat_tup(_) |\n+      pat_region(*) => {\n         Some(single)\n       }\n     }\n@@ -366,25 +372,44 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n         Some(vec::append(args, vec::tail(r)))\n       }\n       pat_struct(_, flds, _) => {\n-        // Grab the class data that we care about.\n-        let class_fields, class_id;\n-        match ty::get(left_ty).sty {\n-            ty::ty_class(cid, _) => {\n-                class_id = cid;\n-                class_fields = ty::lookup_class_fields(tcx, class_id);\n+        // Is this a struct or an enum variant?\n+        match tcx.def_map.get(r0.id) {\n+            def_variant(_, variant_id) => {\n+                if variant(variant_id) == ctor_id {\n+                    // XXX: Is this right? --pcw\n+                    let args = flds.map(|ty_f| {\n+                        match vec::find(flds, |f| f.ident == ty_f.ident) {\n+                            Some(f) => f.pat,\n+                            _ => wild()\n+                        }\n+                    });\n+                    Some(vec::append(args, vec::tail(r)))\n+                } else {\n+                    None\n+                }\n             }\n             _ => {\n-                tcx.sess.span_bug(r0.span, ~\"struct pattern didn't resolve \\\n-                                             to a struct\");\n+                // Grab the class data that we care about.\n+                let class_fields, class_id;\n+                match ty::get(left_ty).sty {\n+                    ty::ty_class(cid, _) => {\n+                        class_id = cid;\n+                        class_fields = ty::lookup_class_fields(tcx, class_id);\n+                    }\n+                    _ => {\n+                        tcx.sess.span_bug(r0.span, ~\"struct pattern didn't \\\n+                                                     resolve to a struct\");\n+                    }\n+                }\n+                let args = vec::map(class_fields, |class_field| {\n+                    match vec::find(flds, |f| f.ident == class_field.ident ) {\n+                      Some(f) => f.pat,\n+                      _ => wild()\n+                    }\n+                });\n+                Some(vec::append(args, vec::tail(r)))\n             }\n         }\n-        let args = vec::map(class_fields, |class_field| {\n-            match vec::find(flds, |f| f.ident == class_field.ident ) {\n-              Some(f) => f.pat,\n-              _ => wild()\n-            }\n-        });\n-        Some(vec::append(args, vec::tail(r)))\n       }\n       pat_tup(args) => Some(vec::append(args, vec::tail(r))),\n       pat_box(a) | pat_uniq(a) | pat_region(a) =>"}, {"sha": "48ebda9a67e032c86b506a1fab6af95015e3a9c4", "filename": "src/rustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57cd6b3e3f0fc3d1805a167dfa2b4d5afc2f43a5/src%2Frustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57cd6b3e3f0fc3d1805a167dfa2b4d5afc2f43a5/src%2Frustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fpat_util.rs?ref=57cd6b3e3f0fc3d1805a167dfa2b4d5afc2f43a5", "patch": "@@ -24,7 +24,7 @@ fn pat_id_map(dm: resolve::DefMap, pat: @pat) -> PatIdMap {\n fn pat_is_variant(dm: resolve::DefMap, pat: @pat) -> bool {\n     match pat.node {\n       pat_enum(_, _) => true,\n-      pat_ident(_, _, None) => match dm.find(pat.id) {\n+      pat_ident(_, _, None) | pat_struct(*) => match dm.find(pat.id) {\n         Some(def_variant(_, _)) => true,\n         _ => false\n       },"}, {"sha": "b3776e499946afd1800731fa63fabe1abcaf64d8", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 63, "deletions": 3, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/57cd6b3e3f0fc3d1805a167dfa2b4d5afc2f43a5/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57cd6b3e3f0fc3d1805a167dfa2b4d5afc2f43a5/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=57cd6b3e3f0fc3d1805a167dfa2b4d5afc2f43a5", "patch": "@@ -369,6 +369,30 @@ fn enter_default(bcx: block, dm: DefMap, m: &[@Match/&r],\n     }\n }\n \n+// <pcwalton> nmatsakis: what does enter_opt do?\n+// <pcwalton> in trans/alt\n+// <pcwalton> trans/alt.rs is like stumbling around in a dark cave\n+// <nmatsakis> pcwalton: the enter family of functions adjust the set of\n+//             patterns as needed\n+// <nmatsakis> yeah, at some point I kind of achieved some level of\n+//             understanding\n+// <nmatsakis> anyhow, they adjust the patterns given that something of that\n+//             kind has been found\n+// <nmatsakis> pcwalton: ok, right, so enter_XXX() adjusts the patterns, as I\n+//             said\n+// <nmatsakis> enter_match() kind of embodies the generic code\n+// <nmatsakis> it is provided with a function that tests each pattern to see\n+//             if it might possibly apply and so forth\n+// <nmatsakis> so, if you have a pattern like {a: _, b: _, _} and one like _\n+// <nmatsakis> then _ would be expanded to (_, _)\n+// <nmatsakis> one spot for each of the sub-patterns\n+// <nmatsakis> enter_opt() is one of the more complex; it covers the fallible\n+//             cases\n+// <nmatsakis> enter_rec_or_struct() or enter_tuple() are simpler, since they\n+//             are infallible patterns\n+// <nmatsakis> so all patterns must either be records (resp. tuples) or\n+//             wildcards\n+\n fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n              variant_size: uint, val: ValueRef)\n     -> ~[@Match/&r]\n@@ -406,6 +430,35 @@ fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n             ast::pat_range(l1, l2) => {\n                 if opt_eq(tcx, &range(l1, l2), opt) {Some(~[])} else {None}\n             }\n+            ast::pat_struct(_, field_pats, _) => {\n+                if opt_eq(tcx, &variant_opt(tcx, p.id), opt) {\n+                    // Look up the struct variant ID.\n+                    let struct_id;\n+                    match tcx.def_map.get(p.id) {\n+                        ast::def_variant(_, found_struct_id) => {\n+                            struct_id = found_struct_id;\n+                        }\n+                        _ => {\n+                            tcx.sess.span_bug(p.span, ~\"expected enum \\\n+                                                        variant def\");\n+                        }\n+                    }\n+\n+                    // Reorder the patterns into the same order they were\n+                    // specified in the struct definition. Also fill in\n+                    // unspecified fields with dummy.\n+                    let reordered_patterns = dvec::DVec();\n+                    for ty::lookup_class_fields(tcx, struct_id).each |field| {\n+                        match field_pats.find(|p| p.ident == field.ident) {\n+                            None => reordered_patterns.push(dummy),\n+                            Some(fp) => reordered_patterns.push(fp.pat)\n+                        }\n+                    }\n+                    Some(dvec::unwrap(move reordered_patterns))\n+                } else {\n+                    None\n+                }\n+            }\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n                 Some(vec::from_elem(variant_size, dummy))\n@@ -599,12 +652,19 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n     return {vals: args, bcx: bcx};\n }\n \n-fn collect_record_or_struct_fields(m: &[@Match], col: uint) -> ~[ast::ident] {\n+// NB: This function does not collect fields from struct-like enum variants.\n+fn collect_record_or_struct_fields(bcx: block, m: &[@Match], col: uint) ->\n+                                   ~[ast::ident] {\n     let mut fields: ~[ast::ident] = ~[];\n     for vec::each(m) |br| {\n         match br.pats[col].node {\n           ast::pat_rec(fs, _) => extend(&mut fields, fs),\n-          ast::pat_struct(_, fs, _) => extend(&mut fields, fs),\n+          ast::pat_struct(_, fs, _) => {\n+            match ty::get(node_id_type(bcx, br.pats[col].id)).sty {\n+              ty::ty_class(*) => extend(&mut fields, fs),\n+              _ => ()\n+            }\n+          }\n           _ => ()\n         }\n     }\n@@ -939,7 +999,7 @@ fn compile_submatch(bcx: block,\n \n     root_pats_as_necessary(bcx, m, col, val);\n \n-    let rec_fields = collect_record_or_struct_fields(m, col);\n+    let rec_fields = collect_record_or_struct_fields(bcx, m, col);\n     if rec_fields.len() > 0 {\n         let pat_ty = node_id_type(bcx, pat_id);\n         do expr::with_field_tys(tcx, pat_ty, None) |_has_dtor, field_tys| {"}, {"sha": "f910161f87a89839b13563098d401dff01cb35a2", "filename": "src/test/compile-fail/struct-like-enum-nonexhaustive.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/57cd6b3e3f0fc3d1805a167dfa2b4d5afc2f43a5/src%2Ftest%2Fcompile-fail%2Fstruct-like-enum-nonexhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57cd6b3e3f0fc3d1805a167dfa2b4d5afc2f43a5/src%2Ftest%2Fcompile-fail%2Fstruct-like-enum-nonexhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-like-enum-nonexhaustive.rs?ref=57cd6b3e3f0fc3d1805a167dfa2b4d5afc2f43a5", "patch": "@@ -0,0 +1,14 @@\n+enum A {\n+    B { x: Option<int> },\n+    C\n+}\n+\n+fn main() {\n+    let x = B { x: Some(3) };\n+    match x {   //~ ERROR non-exhaustive patterns\n+        C => {}\n+        B { x: None } => {}\n+    }\n+}\n+\n+"}, {"sha": "16c63255fb7394d5ea7d1eff6b8cd0596a5c0c61", "filename": "src/test/run-pass/struct-like-variant-match.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/57cd6b3e3f0fc3d1805a167dfa2b4d5afc2f43a5/src%2Ftest%2Frun-pass%2Fstruct-like-variant-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57cd6b3e3f0fc3d1805a167dfa2b4d5afc2f43a5/src%2Ftest%2Frun-pass%2Fstruct-like-variant-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-like-variant-match.rs?ref=57cd6b3e3f0fc3d1805a167dfa2b4d5afc2f43a5", "patch": "@@ -0,0 +1,31 @@\n+enum Foo {\n+    Bar {\n+        x: int,\n+        y: int\n+    },\n+    Baz {\n+        x: float,\n+        y: float\n+    }\n+}\n+\n+fn f(x: &Foo) {\n+    match *x {\n+        Baz { x: x, y: y } => {\n+            assert x == 1.0;\n+            assert y == 2.0;\n+        }\n+        Bar { y: y, x: x } => {\n+            assert x == 1;\n+            assert y == 2;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let x = Bar { x: 1, y: 2 };\n+    f(&x);\n+    let y = Baz { x: 1.0, y: 2.0 };\n+    f(&y);\n+}\n+"}]}