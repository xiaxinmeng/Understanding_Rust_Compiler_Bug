{"sha": "9fce8c918ab90aeb1a2932d330396884cf847e9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmY2U4YzkxOGFiOTBhZWIxYTI5MzJkMzMwMzk2ODg0Y2Y4NDdlOWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-11T18:31:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-11T18:31:41Z"}, "message": "auto merge of #7652 : blake2-ppc/rust/dlist, r=huonw\n\nThis is a new doubly-linked list using owned nodes. In the forward direction, the list is linked with owned pointers, and the backwards direction is linked with &'static Node pointers.\r\n\r\nThis intends to replace the previous extra::DList that was using managed nodes and also featured freestanding nodes.  The new List does not give access to the nodes, but means to implement all relevant linked-list methods.\r\n \r\nThe list supports pop_back, push_back, pop_front, push_front, front, back, iter, mut_iter, +more iterators,  append, insert_ordered, and merge.\r\n\r\n* Add a trait Deque for double ended sequences.\r\n\r\n* Both List and Deque implement this trait. Rename Deque to ArrayDeque.\r\n\r\n*The text has been updated to summarize resolved items*\r\n\r\n## RFC Topics\r\n\r\n### Resolved\r\n\r\n* Should be in extra\r\n* Representation for the backlinks\r\n\r\n### Container Method Names and Trait Names and Type Names\r\n\r\n* Location and name of trait `extra::collection::Deque`?\r\n* Name of the ring buffer `extra::deque::ArrayDeque` ?\r\n* Name of the doubly linked list `extra::dlist::List` ?\r\n\r\nFor container methods I think we have two options:\r\n\r\n* Align with the existing methods on the vector. That would be `.push()`, `.pop()`, `.shift()`, `.unshift()`.\r\n* Use the API described in https://github.com/mozilla/rust/wiki/Containers   Obviously that's the way List is written right now.\r\n\r\nShould we use `pop_front() -> Option<T>` or `pop_front() -> T` ?\r\n\r\n### Benchmarks\r\n\r\nSome basic bench numbers for List vs. Vec, Deque and *old DList*\r\n\r\nThis List implementation's performance is dominated by the allocation of Nodes required when pushing. \r\n\r\nIterate (by-ref) collection of 128 elements\r\n\r\n    test test_bench::bench_iter ... bench: 198 ns/iter (+/- 0)\r\n    test test_bench::bench_iter_mut ... bench: 294 ns/iter (+/- 0)\r\n    test test_bench::bench_iter_rev ... bench: 198 ns/iter (+/- 0)\r\n    test test_bench::bench_iter_mut_rev ... bench: 198 ns/iter (+/- 3)\r\n\r\n    test test_bench::bench_iter_vec ... bench: 101 ns/iter (+/- 0)\r\n    test test_bench::bench_iter_deque ... bench: 581 ns/iter (+/- 0)\r\n    test test_bench::bench_iter_dlist ... bench: 9262 ns/iter (+/- 273)\r\n\r\nSequence of `.push(elt)`, `.pop()` or equivalent at the tail end\r\n\r\n    test test_bench::bench_push_back_pop_back ... bench: 72 ns/iter (+/- 0)\r\n\r\n    test test_bench::bench_push_back_pop_back_vec ... bench: 5 ns/iter (+/- 0)\r\n    test test_bench::bench_push_back_pop_back_deque ... bench: 15 ns/iter (+/- 0)\r\n    test test_bench::bench_push_back_pop_back_dlist ... bench: 234 ns/iter (+/- 0)", "tree": {"sha": "87f5e4b437cdbc99a4a21e3628f76849a9478083", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87f5e4b437cdbc99a4a21e3628f76849a9478083"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fce8c918ab90aeb1a2932d330396884cf847e9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fce8c918ab90aeb1a2932d330396884cf847e9f", "html_url": "https://github.com/rust-lang/rust/commit/9fce8c918ab90aeb1a2932d330396884cf847e9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fce8c918ab90aeb1a2932d330396884cf847e9f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "278ed50e0a66f4c549e43c82e4a545890091e9ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/278ed50e0a66f4c549e43c82e4a545890091e9ba", "html_url": "https://github.com/rust-lang/rust/commit/278ed50e0a66f4c549e43c82e4a545890091e9ba"}, {"sha": "0f9b9a5fb7348471e9d51bcc298667c71647e0e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f9b9a5fb7348471e9d51bcc298667c71647e0e1", "html_url": "https://github.com/rust-lang/rust/commit/0f9b9a5fb7348471e9d51bcc298667c71647e0e1"}], "stats": {"total": 2200, "additions": 1132, "deletions": 1068}, "files": [{"sha": "fe622289b29a6dc0c895c5dfb6d0438fe484faa9", "filename": "src/libextra/container.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9fce8c918ab90aeb1a2932d330396884cf847e9f/src%2Flibextra%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fce8c918ab90aeb1a2932d330396884cf847e9f/src%2Flibextra%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcontainer.rs?ref=9fce8c918ab90aeb1a2932d330396884cf847e9f", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Container traits for extra\n+\n+use std::container::Mutable;\n+\n+/// A double-ended sequence that allows querying, insertion and deletion at both ends.\n+pub trait Deque<T> : Mutable {\n+    /// Provide a reference to the front element, or None if the sequence is empty\n+    fn front<'a>(&'a self) -> Option<&'a T>;\n+\n+    /// Provide a mutable reference to the front element, or None if the sequence is empty\n+    fn front_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n+\n+    /// Provide a reference to the back element, or None if the sequence is empty\n+    fn back<'a>(&'a self) -> Option<&'a T>;\n+\n+    /// Provide a mutable reference to the back element, or None if the sequence is empty\n+    fn back_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n+\n+    /// Insert an element first in the sequence\n+    fn push_front(&mut self, elt: T);\n+\n+    /// Insert an element last in the sequence\n+    fn push_back(&mut self, elt: T);\n+\n+    /// Remove the last element and return it, or None if the sequence is empty\n+    fn pop_back(&mut self) -> Option<T>;\n+\n+    /// Remove the first element and return it, or None if the sequence is empty\n+    fn pop_front(&mut self) -> Option<T>;\n+}"}, {"sha": "fc6d05fcb589acdc997f49da53979c9b05a16f94", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 843, "deletions": 847, "changes": 1690, "blob_url": "https://github.com/rust-lang/rust/blob/9fce8c918ab90aeb1a2932d330396884cf847e9f/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fce8c918ab90aeb1a2932d330396884cf847e9f/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=9fce8c918ab90aeb1a2932d330396884cf847e9f", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,959 +8,955 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n+//! A doubly-linked list with owned nodes.\n+//!\n+//! The DList allows pushing and popping elements at either end.\n+//!\n+//! DList implements the trait Deque. It should be imported with `use\n+//! extra::container::Deque`.\n \n-A doubly-linked list. Supports O(1) head, tail, count, push, pop, etc.\n \n-# Safety note\n+// DList is constructed like a singly-linked list over the field `next`.\n+// including the last link being None; each Node owns its `next` field.\n+//\n+// Backlinks over DList::prev are raw pointers that form a full chain in\n+// the reverse direction.\n \n-Do not use ==, !=, <, etc on doubly-linked lists -- it may not terminate.\n+use std::cast;\n+use std::cmp;\n+use std::ptr;\n+use std::util;\n+use std::iterator::FromIterator;\n \n-*/\n+use container::Deque;\n \n+/// A doubly-linked list.\n+pub struct DList<T> {\n+    priv length: uint,\n+    priv list_head: Link<T>,\n+    priv list_tail: Rawlink<Node<T>>,\n+}\n \n-use std::managed;\n+type Link<T> = Option<~Node<T>>;\n+struct Rawlink<T> { priv p: *mut T }\n \n-pub type DListLink<T> = Option<@mut DListNode<T>>;\n+struct Node<T> {\n+    priv next: Link<T>,\n+    priv prev: Rawlink<Node<T>>,\n+    priv value: T,\n+}\n \n-#[allow(missing_doc)]\n-pub struct DListNode<T> {\n-    data: T,\n-    linked: bool, // for assertions\n-    prev: DListLink<T>,\n-    next: DListLink<T>,\n+/// DList iterator\n+pub struct ForwardIterator<'self, T> {\n+    priv list: &'self DList<T>,\n+    priv next: &'self Link<T>,\n+    priv nelem: uint,\n }\n \n-#[allow(missing_doc)]\n-pub struct DList<T> {\n-    size: uint,\n-    hd: DListLink<T>,\n-    tl: DListLink<T>,\n+/// DList reverse iterator\n+pub struct ReverseIterator<'self, T> {\n+    priv list: &'self DList<T>,\n+    priv next: Rawlink<Node<T>>,\n+    priv nelem: uint,\n }\n \n-impl<T> DListNode<T> {\n-    fn assert_links(@mut self) {\n-        match self.next {\n-            Some(neighbour) => match neighbour.prev {\n-              Some(me) => if !managed::mut_ptr_eq(self, me) {\n-                  fail!(\"Asymmetric next-link in dlist node.\")\n-              },\n-              None => fail!(\"One-way next-link in dlist node.\")\n-            },\n-            None => ()\n-        }\n-        match self.prev {\n-            Some(neighbour) => match neighbour.next {\n-              Some(me) => if !managed::mut_ptr_eq(me, self) {\n-                  fail!(\"Asymmetric prev-link in dlist node.\")\n-              },\n-              None => fail!(\"One-way prev-link in dlist node.\")\n-            },\n-            None => ()\n-        }\n-    }\n+/// DList mutable iterator\n+pub struct MutForwardIterator<'self, T> {\n+    priv list: &'self mut DList<T>,\n+    priv curs: Rawlink<Node<T>>,\n+    priv nelem: uint,\n+}\n+\n+/// DList mutable reverse iterator\n+pub struct MutReverseIterator<'self, T> {\n+    priv list: &'self mut DList<T>,\n+    priv next: Rawlink<Node<T>>,\n+    priv nelem: uint,\n+}\n+\n+/// DList consuming iterator\n+pub struct ConsumeIterator<T> {\n+    priv list: DList<T>\n+}\n+\n+/// DList reverse consuming iterator\n+pub struct ConsumeRevIterator<T> {\n+    priv list: DList<T>\n }\n \n-impl<T> DListNode<T> {\n-    /// Get the next node in the list, if there is one.\n-    pub fn next_link(@mut self) -> DListLink<T> {\n-        self.assert_links();\n-        self.next\n+/// Rawlink is a type like Option<T> but for holding a raw pointer\n+impl<T> Rawlink<T> {\n+    /// Like Option::None for Rawlink\n+    fn none() -> Rawlink<T> {\n+        Rawlink{p: ptr::mut_null()}\n     }\n-    /// Get the next node in the list, failing if there isn't one.\n-    pub fn next_node(@mut self) -> @mut DListNode<T> {\n-        match self.next_link() {\n-            Some(nobe) => nobe,\n-            None       => fail!(\"This dlist node has no next neighbour.\")\n-        }\n+\n+    /// Like Option::Some for Rawlink\n+    fn some(n: &mut T) -> Rawlink<T> {\n+        Rawlink{p: ptr::to_mut_unsafe_ptr(n)}\n     }\n-    /// Get the previous node in the list, if there is one.\n-    pub fn prev_link(@mut self) -> DListLink<T> {\n-        self.assert_links();\n-        self.prev\n+\n+    /// Convert the `Rawlink` into an Option value\n+    fn resolve_immut(&self) -> Option<&T> {\n+        unsafe { self.p.to_option() }\n     }\n-    /// Get the previous node in the list, failing if there isn't one.\n-    pub fn prev_node(@mut self) -> @mut DListNode<T> {\n-        match self.prev_link() {\n-            Some(nobe) => nobe,\n-            None       => fail!(\"This dlist node has no previous neighbour.\")\n+\n+    /// Convert the `Rawlink` into an Option value\n+    fn resolve(&mut self) -> Option<&mut T> {\n+        if self.p.is_null() {\n+            None\n+        } else {\n+            Some(unsafe { cast::transmute(self.p) })\n         }\n     }\n }\n \n-/// Creates a new dlist node with the given data.\n-pub fn new_dlist_node<T>(data: T) -> @mut DListNode<T> {\n-    @mut DListNode { data: data, linked: false, prev: None, next: None }\n+/// Set the .prev field on `next`, then return `Some(next)`\n+fn link_with_prev<T>(mut next: ~Node<T>, prev: Rawlink<Node<T>>) -> Link<T> {\n+    next.prev = prev;\n+    Some(next)\n }\n \n-/// Creates a new, empty dlist.\n-pub fn DList<T>() -> @mut DList<T> {\n-    @mut DList { size: 0, hd: None, tl: None }\n+impl<T> Container for DList<T> {\n+    /// O(1)\n+    fn is_empty(&self) -> bool {\n+        self.list_head.is_none()\n+    }\n+    /// O(1)\n+    fn len(&self) -> uint {\n+        self.length\n+    }\n }\n \n-/// Creates a new dlist with a single element\n-pub fn from_elem<T>(data: T) -> @mut DList<T> {\n-    let list = DList();\n-    list.push(data);\n-    list\n+impl<T> Mutable for DList<T> {\n+    /// Remove all elements from the DList\n+    ///\n+    /// O(N)\n+    fn clear(&mut self) {\n+        *self = DList::new()\n+    }\n }\n \n-/// Creates a new dlist from a vector of elements, maintaining the same order\n-pub fn from_vec<T:Copy>(vec: &[T]) -> @mut DList<T> {\n-    do vec.iter().fold(DList()) |list,data| {\n-        // Iterating left-to-right -- add newly to the tail.\n-        list.push(copy *data);\n-        list\n+impl<T> Deque<T> for DList<T> {\n+    /// Provide a reference to the front element, or None if the list is empty\n+    fn front<'a>(&'a self) -> Option<&'a T> {\n+        self.list_head.chain_ref(|x| Some(&x.value))\n     }\n-}\n \n-/// Produce a list from a list of lists, leaving no elements behind in the\n-/// input. O(number of sub-lists).\n-pub fn concat<T>(lists: @mut DList<@mut DList<T>>) -> @mut DList<T> {\n-    let result = DList();\n-    while !lists.is_empty() {\n-        result.append(lists.pop().get());\n+    /// Provide a mutable reference to the front element, or None if the list is empty\n+    fn front_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+        match self.list_head {\n+            None => None,\n+            Some(ref mut head) => Some(&mut head.value),\n+        }\n     }\n-    result\n-}\n \n-impl<T> DList<T> {\n-    fn new_link(data: T) -> DListLink<T> {\n-        Some(@mut DListNode {\n-            data: data,\n-            linked: true,\n-            prev: None,\n-            next: None\n-        })\n-    }\n-    fn assert_mine(@mut self, nobe: @mut DListNode<T>) {\n-        // These asserts could be stronger if we had node-root back-pointers,\n-        // but those wouldn't allow for O(1) append.\n-        if self.size == 0 {\n-            fail!(\"This dlist is empty; that node can't be on it.\")\n-        }\n-        if !nobe.linked { fail!(\"That node isn't linked to any dlist.\") }\n-        if !((nobe.prev.is_some()\n-              || managed::mut_ptr_eq(self.hd.expect(\"headless dlist?\"),\n-                                 nobe)) &&\n-             (nobe.next.is_some()\n-              || managed::mut_ptr_eq(self.tl.expect(\"tailless dlist?\"),\n-                                 nobe))) {\n-            fail!(\"That node isn't on this dlist.\")\n-        }\n-    }\n-    fn make_mine(&self, nobe: @mut DListNode<T>) {\n-        if nobe.prev.is_some() || nobe.next.is_some() || nobe.linked {\n-            fail!(\"Cannot insert node that's already on a dlist!\")\n-        }\n-        nobe.linked = true;\n-    }\n-    // Link two nodes together. If either of them are 'none', also sets\n-    // the head and/or tail pointers appropriately.\n+    /// Provide a reference to the back element, or None if the list is empty\n+    fn back<'a>(&'a self) -> Option<&'a T> {\n+        match self.list_tail.resolve_immut() {\n+            None => None,\n+            Some(tail) => Some(&tail.value),\n+        }\n+    }\n+\n+    /// Provide a mutable reference to the back element, or None if the list is empty\n+    fn back_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+        match self.list_tail.resolve() {\n+            None => None,\n+            Some(tail) => Some(&mut tail.value),\n+        }\n+    }\n+\n+    /// Add an element last in the list\n+    ///\n+    /// O(1)\n+    fn push_back(&mut self, elt: T) {\n+        match self.list_tail.resolve() {\n+            None => return self.push_front(elt),\n+            Some(tail) => {\n+                let mut new_tail = ~Node{value: elt, next: None, prev: self.list_tail};\n+                self.list_tail = Rawlink::some(new_tail);\n+                tail.next = Some(new_tail);\n+            }\n+        }\n+        self.length += 1;\n+    }\n+\n+    /// Remove the last element and return it, or None if the list is empty\n+    ///\n+    /// O(1)\n     #[inline]\n-    fn link(&mut self, before: DListLink<T>, after: DListLink<T>) {\n-        match before {\n-            Some(neighbour) => neighbour.next = after,\n-            None            => self.hd        = after\n-        }\n-        match after {\n-            Some(neighbour) => neighbour.prev = before,\n-            None            => self.tl        = before\n-        }\n-    }\n-    // Remove a node from the list.\n-    fn unlink(@mut self, nobe: @mut DListNode<T>) {\n-        self.assert_mine(nobe);\n-        assert!(self.size > 0);\n-        self.link(nobe.prev, nobe.next);\n-        nobe.prev = None; // Release extraneous references.\n-        nobe.next = None;\n-        nobe.linked = false;\n-        self.size -= 1;\n-    }\n-\n-    fn add_head(@mut self, nobe: DListLink<T>) {\n-        self.link(nobe, self.hd); // Might set tail too.\n-        self.hd = nobe;\n-        self.size += 1;\n-    }\n-    fn add_tail(@mut self, nobe: DListLink<T>) {\n-        self.link(self.tl, nobe); // Might set head too.\n-        self.tl = nobe;\n-        self.size += 1;\n-    }\n-    fn insert_left(@mut self,\n-                   nobe: DListLink<T>,\n-                   neighbour: @mut DListNode<T>) {\n-        self.assert_mine(neighbour);\n-        assert!(self.size > 0);\n-        self.link(neighbour.prev, nobe);\n-        self.link(nobe, Some(neighbour));\n-        self.size += 1;\n-    }\n-    fn insert_right(@mut self,\n-                    neighbour: @mut DListNode<T>,\n-                    nobe: DListLink<T>) {\n-        self.assert_mine(neighbour);\n-        assert!(self.size > 0);\n-        self.link(nobe, neighbour.next);\n-        self.link(Some(neighbour), nobe);\n-        self.size += 1;\n+    fn pop_back(&mut self) -> Option<T> {\n+        match self.list_tail.resolve() {\n+            None => None,\n+            Some(tail) => {\n+                self.length -= 1;\n+                let tail_own = match tail.prev.resolve() {\n+                    None => {\n+                        self.list_tail = Rawlink::none();\n+                        self.list_head.swap_unwrap()\n+                    },\n+                    Some(tail_prev) => {\n+                        self.list_tail = tail.prev;\n+                        tail_prev.next.swap_unwrap()\n+                    }\n+                };\n+                Some(tail_own.value)\n+            }\n+        }\n+    }\n+\n+    /// Add an element first in the list\n+    ///\n+    /// O(1)\n+    fn push_front(&mut self, elt: T) {\n+        let mut new_head = ~Node{value: elt, next: None, prev: Rawlink::none()};\n+        match self.list_head {\n+            None => {\n+                self.list_tail = Rawlink::some(new_head);\n+                self.list_head = Some(new_head);\n+            }\n+            Some(ref mut head) => {\n+                head.prev = Rawlink::some(new_head);\n+                util::swap(head, &mut new_head);\n+                head.next = Some(new_head);\n+            }\n+        }\n+        self.length += 1;\n+    }\n+\n+    /// Remove the first element and return it, or None if the list is empty\n+    ///\n+    /// O(1)\n+    fn pop_front(&mut self) -> Option<T> {\n+        match util::replace(&mut self.list_head, None) {\n+            None => None,\n+            Some(old_head) => {\n+                self.length -= 1;\n+                match *old_head {\n+                    Node{value: value, next: Some(next), prev: _} => {\n+                        self.list_head = link_with_prev(next, Rawlink::none());\n+                        Some(value)\n+                    }\n+                    Node{value: value, next: None, prev: _} => {\n+                        self.list_tail = Rawlink::none();\n+                        Some(value)\n+                    }\n+                }\n+            }\n+        }\n     }\n }\n \n impl<T> DList<T> {\n-    /**\n-     * Iterates through the current contents.\n-     *\n-     * Attempts to access this dlist during iteration are allowed (to\n-     * allow for e.g. breadth-first search with in-place enqueues), but\n-     * removing the current node is forbidden.\n-     */\n-    pub fn each(@mut self, f: &fn(v: &T) -> bool) -> bool {\n-        let mut link = self.peek_n();\n-        while link.is_some() {\n-            let nobe = link.get();\n-            assert!(nobe.linked);\n-\n-            {\n-                let frozen_nobe = &*nobe;\n-                if !f(&frozen_nobe.data) { return false; }\n+    /// Create an empty DList\n+    #[inline]\n+    pub fn new() -> DList<T> {\n+        DList{list_head: None, list_tail: Rawlink::none(), length: 0}\n+    }\n+\n+    /// Add all elements from `other` to the end of the list\n+    ///\n+    /// O(1)\n+    pub fn append(&mut self, other: DList<T>) {\n+        match self.list_tail.resolve() {\n+            None => *self = other,\n+            Some(tail) => {\n+                match other {\n+                    DList{list_head: None, list_tail: _, length: _} => return,\n+                    DList{list_head: Some(node), list_tail: o_tail, length: o_length} => {\n+                        tail.next = link_with_prev(node, self.list_tail);\n+                        self.list_tail = o_tail;\n+                        self.length += o_length;\n+                    }\n+                }\n             }\n+        }\n+    }\n \n-            // Check (weakly) that the user didn't do a remove.\n-            if self.size == 0 {\n-                fail!(\"The dlist became empty during iteration??\")\n+    /// Add all elements from `other` to the beginning of the list\n+    ///\n+    /// O(1)\n+    pub fn prepend(&mut self, mut other: DList<T>) {\n+        util::swap(self, &mut other);\n+        self.append(other);\n+    }\n+\n+    /// Insert `elt` before the first `x` in the list where `f(x, elt)` is true,\n+    /// or at the end.\n+    ///\n+    /// O(N)\n+    #[inline]\n+    pub fn insert_when(&mut self, elt: T, f: &fn(&T, &T) -> bool) {\n+        {\n+            let mut it = self.mut_iter();\n+            loop {\n+                match it.next() {\n+                    None => break,\n+                    Some(x) => if f(x, &elt) { it.insert_before(elt); return }\n+                }\n             }\n-            if !nobe.linked ||\n-                (!((nobe.prev.is_some()\n-                    || managed::mut_ptr_eq(self.hd.expect(\"headless dlist?\"),\n-                                           nobe))\n-                   && (nobe.next.is_some()\n-                    || managed::mut_ptr_eq(self.tl.expect(\"tailless dlist?\"),\n-                                           nobe)))) {\n-                fail!(\"Removing a dlist node during iteration is forbidden!\")\n+        }\n+        self.push_back(elt);\n+    }\n+\n+    /// Merge, using the function `f`; take `a` if `f(a, b)` is true, else `b`.\n+    ///\n+    /// O(max(N, M))\n+    pub fn merge(&mut self, mut other: DList<T>, f: &fn(&T, &T) -> bool) {\n+        {\n+            let mut it = self.mut_iter();\n+            loop {\n+                match (it.next(), other.front()) {\n+                    (None   , _      ) => break,\n+                    (_      , None   ) => return,\n+                    (Some(x), Some(y)) => if f(x, y) { loop }\n+                }\n+                it.insert_before(other.pop_front().unwrap());\n             }\n-            link = nobe.next_link();\n-        }\n-        return true;\n-    }\n-\n-    /// Get the size of the list. O(1).\n-    pub fn len(@mut self) -> uint { self.size }\n-    /// Returns true if the list is empty. O(1).\n-    pub fn is_empty(@mut self) -> bool { self.len() == 0 }\n-\n-    /// Add data to the head of the list. O(1).\n-    pub fn push_head(@mut self, data: T) {\n-        self.add_head(DList::new_link(data));\n-    }\n-    /**\n-     * Add data to the head of the list, and get the new containing\n-     * node. O(1).\n-     */\n-    pub fn push_head_n(@mut self, data: T) -> @mut DListNode<T> {\n-        let nobe = DList::new_link(data);\n-        self.add_head(nobe);\n-        nobe.get()\n-    }\n-    /// Add data to the tail of the list. O(1).\n-    pub fn push(@mut self, data: T) {\n-        self.add_tail(DList::new_link(data));\n-    }\n-    /**\n-     * Add data to the tail of the list, and get the new containing\n-     * node. O(1).\n-     */\n-    pub fn push_n(@mut self, data: T) -> @mut DListNode<T> {\n-        let nobe = DList::new_link(data);\n-        self.add_tail(nobe);\n-        nobe.get()\n-    }\n-    /**\n-     * Insert data into the middle of the list, left of the given node.\n-     * O(1).\n-     */\n-    pub fn insert_before(@mut self, data: T, neighbour: @mut DListNode<T>) {\n-        self.insert_left(DList::new_link(data), neighbour);\n-    }\n-    /**\n-     * Insert an existing node in the middle of the list, left of the\n-     * given node. O(1).\n-     */\n-    pub fn insert_n_before(@mut self,\n-                           nobe: @mut DListNode<T>,\n-                           neighbour: @mut DListNode<T>) {\n-        self.make_mine(nobe);\n-        self.insert_left(Some(nobe), neighbour);\n-    }\n-    /**\n-     * Insert data in the middle of the list, left of the given node,\n-     * and get its containing node. O(1).\n-     */\n-    pub fn insert_before_n(@mut self,\n-                           data: T,\n-                           neighbour: @mut DListNode<T>)\n-                           -> @mut DListNode<T> {\n-        let nobe = DList::new_link(data);\n-        self.insert_left(nobe, neighbour);\n-        nobe.get()\n-    }\n-    /**\n-     * Insert data into the middle of the list, right of the given node.\n-     * O(1).\n-     */\n-    pub fn insert_after(@mut self, data: T, neighbour: @mut DListNode<T>) {\n-        self.insert_right(neighbour, DList::new_link(data));\n-    }\n-    /**\n-     * Insert an existing node in the middle of the list, right of the\n-     * given node. O(1).\n-     */\n-    pub fn insert_n_after(@mut self,\n-                          nobe: @mut DListNode<T>,\n-                          neighbour: @mut DListNode<T>) {\n-        self.make_mine(nobe);\n-        self.insert_right(neighbour, Some(nobe));\n-    }\n-    /**\n-     * Insert data in the middle of the list, right of the given node,\n-     * and get its containing node. O(1).\n-     */\n-    pub fn insert_after_n(@mut self,\n-                          data: T,\n-                          neighbour: @mut DListNode<T>)\n-                          -> @mut DListNode<T> {\n-        let nobe = DList::new_link(data);\n-        self.insert_right(neighbour, nobe);\n-        nobe.get()\n-    }\n-\n-    /// Remove a node from the head of the list. O(1).\n-    pub fn pop_n(@mut self) -> DListLink<T> {\n-        let hd = self.peek_n();\n-        hd.map(|nobe| self.unlink(*nobe));\n-        hd\n-    }\n-    /// Remove a node from the tail of the list. O(1).\n-    pub fn pop_tail_n(@mut self) -> DListLink<T> {\n-        let tl = self.peek_tail_n();\n-        tl.map(|nobe| self.unlink(*nobe));\n-        tl\n-    }\n-    /// Get the node at the list's head. O(1).\n-    pub fn peek_n(@mut self) -> DListLink<T> { self.hd }\n-    /// Get the node at the list's tail. O(1).\n-    pub fn peek_tail_n(@mut self) -> DListLink<T> { self.tl }\n-\n-    /// Get the node at the list's head, failing if empty. O(1).\n-    pub fn head_n(@mut self) -> @mut DListNode<T> {\n-        match self.hd {\n-            Some(nobe) => nobe,\n-            None       => fail!(\"Attempted to get the head of an empty dlist.\")\n-        }\n-    }\n-    /// Get the node at the list's tail, failing if empty. O(1).\n-    pub fn tail_n(@mut self) -> @mut DListNode<T> {\n-        match self.tl {\n-            Some(nobe) => nobe,\n-            None       => fail!(\"Attempted to get the tail of an empty dlist.\")\n-        }\n-    }\n-\n-    /// Remove a node from anywhere in the list. O(1).\n-    pub fn remove(@mut self, nobe: @mut DListNode<T>) { self.unlink(nobe); }\n-\n-    /**\n-     * Empty another list onto the end of this list, joining this list's tail\n-     * to the other list's head. O(1).\n-     */\n-    pub fn append(@mut self, them: @mut DList<T>) {\n-        if managed::mut_ptr_eq(self, them) {\n-            fail!(\"Cannot append a dlist to itself!\")\n-        }\n-        if them.len() > 0 {\n-            self.link(self.tl, them.hd);\n-            self.tl    = them.tl;\n-            self.size += them.size;\n-            them.size  = 0;\n-            them.hd    = None;\n-            them.tl    = None;\n-        }\n-    }\n-    /**\n-     * Empty another list onto the start of this list, joining the other\n-     * list's tail to this list's head. O(1).\n-     */\n-    pub fn prepend(@mut self, them: @mut DList<T>) {\n-        if managed::mut_ptr_eq(self, them) {\n-            fail!(\"Cannot prepend a dlist to itself!\")\n-        }\n-        if them.len() > 0 {\n-            self.link(them.tl, self.hd);\n-            self.hd    = them.hd;\n-            self.size += them.size;\n-            them.size  = 0;\n-            them.hd    = None;\n-            them.tl    = None;\n-        }\n-    }\n-\n-    /// Reverse the list's elements in place. O(n).\n-    pub fn reverse(@mut self) {\n-        do self.hd.while_some |nobe| {\n-            let next_nobe = nobe.next;\n-            self.remove(nobe);\n-            self.make_mine(nobe);\n-            self.add_head(Some(nobe));\n-            next_nobe\n-        }\n-    }\n-\n-    /**\n-     * Remove everything from the list. This is important because the cyclic\n-     * links won't otherwise be automatically refcounted-collected. O(n).\n-     */\n-    pub fn clear(@mut self) {\n-        // Cute as it would be to simply detach the list and proclaim \"O(1)!\",\n-        // the GC would still be a hidden O(n). Better to be honest about it.\n-        while !self.is_empty() {\n-            let _ = self.pop_n();\n-        }\n-    }\n-\n-    /// Iterate over nodes.\n-    pub fn each_node(@mut self, f: &fn(@mut DListNode<T>) -> bool) -> bool {\n-        let mut link = self.peek_n();\n-        while link.is_some() {\n-            let nobe = link.get();\n-            if !f(nobe) { return false; }\n-            link = nobe.next_link();\n-        }\n-        return true;\n-    }\n-\n-    /// Check data structure integrity. O(n).\n-    pub fn assert_consistent(@mut self) {\n-        if self.hd.is_none() || self.tl.is_none() {\n-            assert!(self.hd.is_none() && self.tl.is_none());\n-        }\n-        // iterate forwards\n-        let mut count = 0;\n-        let mut link = self.peek_n();\n-        let mut rabbit = link;\n-        while link.is_some() {\n-            let nobe = link.get();\n-            assert!(nobe.linked);\n-            // check cycle\n-            if rabbit.is_some() {\n-                rabbit = rabbit.get().next;\n+        }\n+        self.append(other);\n+    }\n+\n+\n+    /// Provide a forward iterator\n+    pub fn iter<'a>(&'a self) -> ForwardIterator<'a, T> {\n+        ForwardIterator{nelem: self.len(), list: self, next: &self.list_head}\n+    }\n+\n+    /// Provide a reverse iterator\n+    pub fn rev_iter<'a>(&'a self) -> ReverseIterator<'a, T> {\n+        ReverseIterator{nelem: self.len(), list: self, next: self.list_tail}\n+    }\n+\n+    /// Provide a forward iterator with mutable references\n+    pub fn mut_iter<'a>(&'a mut self) -> MutForwardIterator<'a, T> {\n+        MutForwardIterator{nelem: self.len(), list: self, curs: Rawlink::none()}\n+    }\n+\n+    /// Provide a reverse iterator with mutable references\n+    pub fn mut_rev_iter<'a>(&'a mut self) -> MutReverseIterator<'a, T> {\n+        MutReverseIterator{nelem: self.len(), list: self, next: self.list_tail}\n+    }\n+\n+\n+    /// Consume the list into an iterator yielding elements by value\n+    pub fn consume_iter(self) -> ConsumeIterator<T> {\n+        ConsumeIterator{list: self}\n+    }\n+\n+    /// Consume the list into an iterator yielding elements by value, in reverse\n+    pub fn consume_rev_iter(self) -> ConsumeRevIterator<T> {\n+        ConsumeRevIterator{list: self}\n+    }\n+}\n+\n+/// Insert sorted in ascending order\n+///\n+/// O(N)\n+impl<T: cmp::TotalOrd> DList<T> {\n+    fn insert_ordered(&mut self, elt: T) {\n+        self.insert_when(elt, |a, b| a.cmp(b) != cmp::Less);\n+    }\n+}\n+\n+impl<'self, A> Iterator<&'self A> for ForwardIterator<'self, A> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'self A> {\n+        match *self.next {\n+            None => None,\n+            Some(ref next) => {\n+                self.nelem -= 1;\n+                self.next = &next.next;\n+                Some(&next.value)\n             }\n-            if rabbit.is_some() {\n-                rabbit = rabbit.get().next;\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (self.nelem, Some(self.nelem))\n+    }\n+}\n+\n+// MutForwardIterator is different because it implements ListInsertion,\n+// and can modify the list during traversal, used in insert_when and merge.\n+impl<'self, A> Iterator<&'self mut A> for MutForwardIterator<'self, A> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'self mut A> {\n+        match self.curs.resolve() {\n+            None => {\n+                match self.list.list_head {\n+                    None => None,\n+                    Some(ref mut head) => {\n+                        self.nelem -= 1;\n+                        self.curs = Rawlink::some(*head);\n+                        Some(&mut head.value)\n+                    }\n+                }\n             }\n-            if rabbit.is_some() {\n-                assert!(!managed::mut_ptr_eq(rabbit.get(), nobe));\n+            Some(curs) => {\n+                match curs.next {\n+                    None => None,\n+                    Some(ref mut head) => {\n+                        self.nelem -= 1;\n+                        self.curs = Rawlink::some(*head);\n+                        Some(&mut head.value)\n+                    }\n+                }\n             }\n-            // advance\n-            link = nobe.next_link();\n-            count += 1;\n-        }\n-        assert_eq!(count, self.len());\n-        // iterate backwards - some of this is probably redundant.\n-        link = self.peek_tail_n();\n-        rabbit = link;\n-        while link.is_some() {\n-            let nobe = link.get();\n-            assert!(nobe.linked);\n-            // check cycle\n-            if rabbit.is_some() {\n-                rabbit = rabbit.get().prev;\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (self.nelem, Some(self.nelem))\n+    }\n+}\n+\n+impl<'self, A> Iterator<&'self A> for ReverseIterator<'self, A> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'self A> {\n+        match self.next.resolve() {\n+            None => None,\n+            Some(prev) => {\n+                self.nelem -= 1;\n+                self.next = prev.prev;\n+                Some(&prev.value)\n             }\n-            if rabbit.is_some() {\n-                rabbit = rabbit.get().prev;\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (self.nelem, Some(self.nelem))\n+    }\n+}\n+\n+impl<'self, A> Iterator<&'self mut A> for MutReverseIterator<'self, A> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'self mut A> {\n+        match self.next.resolve() {\n+            None => None,\n+            Some(prev) => {\n+                self.nelem -= 1;\n+                self.next = prev.prev;\n+                Some(&mut prev.value)\n             }\n-            if rabbit.is_some() {\n-                assert!(!managed::mut_ptr_eq(rabbit.get(), nobe));\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (self.nelem, Some(self.nelem))\n+    }\n+}\n+\n+/// Allow mutating the DList while iterating\n+pub trait ListInsertion<A> {\n+    /// Insert `elt` just previous to the most recently yielded element\n+    fn insert_before(&mut self, elt: A);\n+\n+    /// Provide a reference to the next element, without changing the iterator\n+    fn peek_next<'a>(&'a mut self) -> Option<&'a mut A>;\n+}\n+\n+impl<'self, A> ListInsertion<A> for MutForwardIterator<'self, A> {\n+    fn insert_before(&mut self, elt: A) {\n+        match self.curs.resolve() {\n+            None => { self.list.push_front(elt); self.next(); }\n+            Some(node) => {\n+                let prev_node = match node.prev.resolve() {\n+                    None => return self.list.push_front(elt),\n+                    Some(prev) => prev,\n+                };\n+                let mut ins_node = ~Node{value: elt, next: None, prev: Rawlink::none()};\n+                let node_own = prev_node.next.swap_unwrap();\n+                ins_node.next = link_with_prev(node_own, Rawlink::some(ins_node));\n+                prev_node.next = link_with_prev(ins_node, Rawlink::some(prev_node));\n+                self.list.length += 1;\n+            }\n+        }\n+    }\n+\n+    fn peek_next<'a>(&'a mut self) -> Option<&'a mut A> {\n+        match self.curs.resolve() {\n+            None => self.list.front_mut(),\n+            Some(curs) => match curs.next {\n+                None => None,\n+                Some(ref mut node) => Some(&mut node.value),\n             }\n-            // advance\n-            link = nobe.prev_link();\n-            count -= 1;\n         }\n-        assert_eq!(count, 0);\n     }\n }\n \n-impl<T:Copy> DList<T> {\n-    /// Remove data from the head of the list. O(1).\n-    pub fn pop(@mut self) -> Option<T> {\n-        self.pop_n().map(|nobe| copy nobe.data)\n+impl<A> Iterator<A> for ConsumeIterator<A> {\n+    fn next(&mut self) -> Option<A> { self.list.pop_front() }\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (self.list.length, Some(self.list.length))\n     }\n+}\n \n-    /// Remove data from the tail of the list. O(1).\n-    pub fn pop_tail(@mut self) -> Option<T> {\n-        self.pop_tail_n().map(|nobe| copy nobe.data)\n+impl<A> Iterator<A> for ConsumeRevIterator<A> {\n+    fn next(&mut self) -> Option<A> { self.list.pop_back() }\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (self.list.length, Some(self.list.length))\n     }\n+}\n \n-    /// Get data at the list's head. O(1).\n-    pub fn peek(@mut self) -> Option<T> {\n-        self.peek_n().map(|nobe| copy nobe.data)\n+impl<A, T: Iterator<A>> FromIterator<A, T> for DList<A> {\n+    fn from_iterator(iterator: &mut T) -> DList<A> {\n+        let mut ret = DList::new();\n+        for iterator.advance |elt| { ret.push_back(elt); }\n+        ret\n     }\n+}\n \n-    /// Get data at the list's tail. O(1).\n-    pub fn peek_tail(@mut self) -> Option<T> {\n-        self.peek_tail_n().map (|nobe| copy nobe.data)\n+impl<A: Eq> Eq for DList<A> {\n+    fn eq(&self, other: &DList<A>) -> bool {\n+        self.len() == other.len() &&\n+            self.iter().zip(other.iter()).all(|(a, b)| a.eq(b))\n+    }\n+    fn ne(&self, other: &DList<A>) -> bool {\n+        !self.eq(other)\n     }\n+}\n \n-    /// Get data at the list's head, failing if empty. O(1).\n-    pub fn head(@mut self) -> T { copy self.head_n().data }\n+impl<A: Clone> Clone for DList<A> {\n+    fn clone(&self) -> DList<A> {\n+        self.iter().transform(|x| x.clone()).collect()\n+    }\n+}\n \n-    /// Get data at the list's tail, failing if empty. O(1).\n-    pub fn tail(@mut self) -> T { copy self.tail_n().data }\n+#[cfg(test)]\n+pub fn check_links<T>(list: &DList<T>) {\n+    let mut len = 0u;\n+    let mut last_ptr: Option<&Node<T>> = None;\n+    let mut node_ptr: &Node<T>;\n+    match list.list_head {\n+        None => { assert_eq!(0u, list.length); return }\n+        Some(ref node) => node_ptr = &**node,\n+    }\n+    loop {\n+        match (last_ptr, node_ptr.prev.resolve_immut()) {\n+            (None   , None      ) => {}\n+            (None   , _         ) => fail!(\"prev link for list_head\"),\n+            (Some(p), Some(pptr)) => {\n+                assert_eq!(p as *Node<T>, pptr as *Node<T>);\n+            }\n+            _ => fail!(\"prev link is none, not good\"),\n+        }\n+        match node_ptr.next {\n+            Some(ref next) => {\n+                last_ptr = Some(node_ptr);\n+                node_ptr = &**next;\n+                len += 1;\n+            }\n+            None => {\n+                len += 1;\n+                break;\n+            }\n+        }\n+    }\n+    assert_eq!(len, list.length);\n }\n \n #[cfg(test)]\n mod tests {\n-\n     use super::*;\n+    use std::rand;\n+    use std::int;\n+    use extra::test;\n \n     #[test]\n-    fn test_dlist_concat() {\n-        let a = from_vec([1,2]);\n-        let b = from_vec([3,4]);\n-        let c = from_vec([5,6]);\n-        let d = from_vec([7,8]);\n-        let ab = from_vec([a,b]);\n-        let cd = from_vec([c,d]);\n-        let abcd = concat(concat(from_vec([ab,cd])));\n-        abcd.assert_consistent(); assert_eq!(abcd.len(), 8);\n-        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 1);\n-        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 2);\n-        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 3);\n-        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 4);\n-        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 5);\n-        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 6);\n-        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 7);\n-        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 8);\n-        abcd.assert_consistent(); assert!(abcd.is_empty());\n-    }\n-    #[test]\n-    fn test_dlist_append() {\n-        let a = from_vec([1,2,3]);\n-        let b = from_vec([4,5,6]);\n-        a.append(b);\n-        assert_eq!(a.len(), 6);\n-        assert_eq!(b.len(), 0);\n-        b.assert_consistent();\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 1);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 2);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 3);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 4);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 5);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 6);\n-        a.assert_consistent(); assert!(a.is_empty());\n-    }\n-    #[test]\n-    fn test_dlist_append_empty() {\n-        let a = from_vec([1,2,3]);\n-        let b = DList::<int>();\n-        a.append(b);\n-        assert_eq!(a.len(), 3);\n-        assert_eq!(b.len(), 0);\n-        b.assert_consistent();\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 1);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 2);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 3);\n-        a.assert_consistent(); assert!(a.is_empty());\n+    fn test_basic() {\n+        let mut m = DList::new::<~int>();\n+        assert_eq!(m.pop_front(), None);\n+        assert_eq!(m.pop_back(), None);\n+        assert_eq!(m.pop_front(), None);\n+        m.push_front(~1);\n+        assert_eq!(m.pop_front(), Some(~1));\n+        m.push_back(~2);\n+        m.push_back(~3);\n+        assert_eq!(m.len(), 2);\n+        assert_eq!(m.pop_front(), Some(~2));\n+        assert_eq!(m.pop_front(), Some(~3));\n+        assert_eq!(m.len(), 0);\n+        assert_eq!(m.pop_front(), None);\n+        m.push_back(~1);\n+        m.push_back(~3);\n+        m.push_back(~5);\n+        m.push_back(~7);\n+        assert_eq!(m.pop_front(), Some(~1));\n+\n+        let mut n = DList::new();\n+        n.push_front(2);\n+        n.push_front(3);\n+        {\n+            assert_eq!(n.front().unwrap(), &3);\n+            let x = n.front_mut().unwrap();\n+            assert_eq!(*x, 3);\n+            *x = 0;\n+        }\n+        {\n+            assert_eq!(n.back().unwrap(), &2);\n+            let y = n.back_mut().unwrap();\n+            assert_eq!(*y, 2);\n+            *y = 1;\n+        }\n+        assert_eq!(n.pop_front(), Some(0));\n+        assert_eq!(n.pop_front(), Some(1));\n     }\n-    #[test]\n-    fn test_dlist_append_to_empty() {\n-        let a = DList::<int>();\n-        let b = from_vec([4,5,6]);\n-        a.append(b);\n-        assert_eq!(a.len(), 3);\n-        assert_eq!(b.len(), 0);\n-        b.assert_consistent();\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 4);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 5);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 6);\n-        a.assert_consistent(); assert!(a.is_empty());\n+\n+    #[cfg(test)]\n+    fn generate_test() -> DList<int> {\n+        list_from(&[0,1,2,3,4,5,6])\n     }\n-    #[test]\n-    fn test_dlist_append_two_empty() {\n-        let a = DList::<int>();\n-        let b = DList::<int>();\n-        a.append(b);\n-        assert_eq!(a.len(), 0);\n-        assert_eq!(b.len(), 0);\n-        b.assert_consistent();\n-        a.assert_consistent();\n+\n+    #[cfg(test)]\n+    fn list_from<T: Copy>(v: &[T]) -> DList<T> {\n+        v.iter().transform(|x| copy *x).collect()\n     }\n+\n     #[test]\n-    #[ignore(cfg(windows))]\n-    #[should_fail]\n-    fn test_dlist_append_self() {\n-        let a = DList::<int>();\n-        a.append(a);\n+    fn test_append() {\n+        {\n+            let mut m = DList::new();\n+            let mut n = DList::new();\n+            n.push_back(2);\n+            m.append(n);\n+            assert_eq!(m.len(), 1);\n+            assert_eq!(m.pop_back(), Some(2));\n+            check_links(&m);\n+        }\n+        {\n+            let mut m = DList::new();\n+            let n = DList::new();\n+            m.push_back(2);\n+            m.append(n);\n+            assert_eq!(m.len(), 1);\n+            assert_eq!(m.pop_back(), Some(2));\n+            check_links(&m);\n+        }\n+\n+        let v = ~[1,2,3,4,5];\n+        let u = ~[9,8,1,2,3,4,5];\n+        let mut m = list_from(v);\n+        m.append(list_from(u));\n+        check_links(&m);\n+        let sum = v + u;\n+        assert_eq!(sum.len(), m.len());\n+        for sum.consume_iter().advance |elt| {\n+            assert_eq!(m.pop_front(), Some(elt))\n+        }\n     }\n+\n     #[test]\n-    #[ignore(cfg(windows))]\n-    #[should_fail]\n-    fn test_dlist_prepend_self() {\n-        let a = DList::<int>();\n-        a.prepend(a);\n+    fn test_prepend() {\n+        {\n+            let mut m = DList::new();\n+            let mut n = DList::new();\n+            n.push_back(2);\n+            m.prepend(n);\n+            assert_eq!(m.len(), 1);\n+            assert_eq!(m.pop_back(), Some(2));\n+            check_links(&m);\n+        }\n+\n+        let v = ~[1,2,3,4,5];\n+        let u = ~[9,8,1,2,3,4,5];\n+        let mut m = list_from(v);\n+        m.prepend(list_from(u));\n+        check_links(&m);\n+        let sum = u + v;\n+        assert_eq!(sum.len(), m.len());\n+        for sum.consume_iter().advance |elt| {\n+            assert_eq!(m.pop_front(), Some(elt))\n+        }\n     }\n+\n     #[test]\n-    fn test_dlist_prepend() {\n-        let a = from_vec([1,2,3]);\n-        let b = from_vec([4,5,6]);\n-        b.prepend(a);\n-        assert_eq!(a.len(), 0);\n-        assert_eq!(b.len(), 6);\n-        a.assert_consistent();\n-        b.assert_consistent(); assert_eq!(b.pop().get(), 1);\n-        b.assert_consistent(); assert_eq!(b.pop().get(), 2);\n-        b.assert_consistent(); assert_eq!(b.pop().get(), 3);\n-        b.assert_consistent(); assert_eq!(b.pop().get(), 4);\n-        b.assert_consistent(); assert_eq!(b.pop().get(), 5);\n-        b.assert_consistent(); assert_eq!(b.pop().get(), 6);\n-        b.assert_consistent(); assert!(b.is_empty());\n+    fn test_iterator() {\n+        let m = generate_test();\n+        for m.iter().enumerate().advance |(i, elt)| {\n+            assert_eq!(i as int, *elt);\n+        }\n+        let mut n = DList::new();\n+        assert_eq!(n.iter().next(), None);\n+        n.push_front(4);\n+        let mut it = n.iter();\n+        assert_eq!(it.size_hint(), (1, Some(1)));\n+        assert_eq!(it.next().unwrap(), &4);\n+        assert_eq!(it.size_hint(), (0, Some(0)));\n+        assert_eq!(it.next(), None);\n     }\n+\n     #[test]\n-    fn test_dlist_reverse() {\n-        let a = from_vec([5,4,3,2,1]);\n-        a.reverse();\n-        assert_eq!(a.len(), 5);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 1);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 2);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 3);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 4);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 5);\n-        a.assert_consistent(); assert!(a.is_empty());\n+    fn test_rev_iter() {\n+        let m = generate_test();\n+        for m.rev_iter().enumerate().advance |(i, elt)| {\n+            assert_eq!((6 - i) as int, *elt);\n+        }\n+        let mut n = DList::new();\n+        assert_eq!(n.rev_iter().next(), None);\n+        n.push_front(4);\n+        let mut it = n.rev_iter();\n+        assert_eq!(it.size_hint(), (1, Some(1)));\n+        assert_eq!(it.next().unwrap(), &4);\n+        assert_eq!(it.size_hint(), (0, Some(0)));\n+        assert_eq!(it.next(), None);\n     }\n+\n     #[test]\n-    fn test_dlist_reverse_empty() {\n-        let a = DList::<int>();\n-        a.reverse();\n-        assert_eq!(a.len(), 0);\n-        a.assert_consistent();\n+    fn test_mut_iter() {\n+        let mut m = generate_test();\n+        let mut len = m.len();\n+        for m.mut_iter().enumerate().advance |(i, elt)| {\n+            assert_eq!(i as int, *elt);\n+            len -= 1;\n+        }\n+        assert_eq!(len, 0);\n+        let mut n = DList::new();\n+        assert!(n.mut_iter().next().is_none());\n+        n.push_front(4);\n+        let mut it = n.mut_iter();\n+        assert_eq!(it.size_hint(), (1, Some(1)));\n+        assert!(it.next().is_some());\n+        assert_eq!(it.size_hint(), (0, Some(0)));\n+        assert!(it.next().is_none());\n     }\n+\n     #[test]\n-    fn test_dlist_each_node() {\n-        let a = from_vec([1,2,4,5]);\n-        for a.each_node |nobe| {\n-            if nobe.data > 3 {\n-                a.insert_before(3, nobe);\n+    fn test_insert_prev() {\n+        let mut m = list_from(&[0,2,4,6,8]);\n+        let len = m.len();\n+        {\n+            let mut it = m.mut_iter();\n+            it.insert_before(-2);\n+            loop {\n+                match it.next() {\n+                    None => break,\n+                    Some(elt) => {\n+                        it.insert_before(*elt + 1);\n+                        match it.peek_next() {\n+                            Some(x) => assert_eq!(*x, *elt + 2),\n+                            None => assert_eq!(8, *elt),\n+                        }\n+                    }\n+                }\n             }\n+            it.insert_before(0);\n+            it.insert_before(1);\n         }\n-        assert_eq!(a.len(), 6);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 1);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 2);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 3);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 4);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 3);\n-        a.assert_consistent(); assert_eq!(a.pop().get(), 5);\n-        a.assert_consistent(); assert!(a.is_empty());\n+        check_links(&m);\n+        assert_eq!(m.len(), 3 + len * 2);\n+        assert_eq!(m.consume_iter().collect::<~[int]>(), ~[-2,1,0,3,2,5,4,7,6,9,0,1,8]);\n     }\n+\n     #[test]\n-    fn test_dlist_clear() {\n-        let a = from_vec([5,4,3,2,1]);\n-        a.clear();\n-        assert_eq!(a.len(), 0);\n-        a.assert_consistent();\n+    fn test_merge() {\n+        let mut m = list_from([0, 1, 3, 5, 6, 7, 2]);\n+        let n = list_from([-1, 0, 0, 7, 7, 9]);\n+        let len = m.len() + n.len();\n+        m.merge(n, |a, b| a <= b);\n+        assert_eq!(m.len(), len);\n+        check_links(&m);\n+        let res = m.consume_iter().collect::<~[int]>();\n+        assert_eq!(res, ~[-1, 0, 0, 1, 0, 3, 5, 6, 7, 2, 7, 7, 9]);\n     }\n+\n     #[test]\n-    fn test_dlist_is_empty() {\n-        let empty = DList::<int>();\n-        let full1 = from_vec([1,2,3]);\n-        assert!(empty.is_empty());\n-        assert!(!full1.is_empty());\n+    fn test_insert_ordered() {\n+        let mut n = DList::new();\n+        n.insert_ordered(1);\n+        assert_eq!(n.len(), 1);\n+        assert_eq!(n.pop_front(), Some(1));\n+\n+        let mut m = DList::new();\n+        m.push_back(2);\n+        m.push_back(4);\n+        m.insert_ordered(3);\n+        check_links(&m);\n+        assert_eq!(~[2,3,4], m.consume_iter().collect::<~[int]>());\n     }\n+\n     #[test]\n-    fn test_dlist_head_tail() {\n-        let l = from_vec([1,2,3]);\n-        assert_eq!(l.head(), 1);\n-        assert_eq!(l.tail(), 3);\n-        assert_eq!(l.len(), 3);\n+    fn test_mut_rev_iter() {\n+        let mut m = generate_test();\n+        for m.mut_rev_iter().enumerate().advance |(i, elt)| {\n+            assert_eq!((6-i) as int, *elt);\n+        }\n+        let mut n = DList::new();\n+        assert!(n.mut_rev_iter().next().is_none());\n+        n.push_front(4);\n+        let mut it = n.mut_rev_iter();\n+        assert!(it.next().is_some());\n+        assert!(it.next().is_none());\n     }\n+\n     #[test]\n-    fn test_dlist_pop() {\n-        let l = from_vec([1,2,3]);\n-        assert_eq!(l.pop().get(), 1);\n-        assert_eq!(l.tail(), 3);\n-        assert_eq!(l.head(), 2);\n-        assert_eq!(l.pop().get(), 2);\n-        assert_eq!(l.tail(), 3);\n-        assert_eq!(l.head(), 3);\n-        assert_eq!(l.pop().get(), 3);\n-        assert!(l.is_empty());\n-        assert!(l.pop().is_none());\n+    fn test_send() {\n+        let n = list_from([1,2,3]);\n+        do spawn {\n+            check_links(&n);\n+            assert_eq!(~[&1,&2,&3], n.iter().collect::<~[&int]>());\n+        }\n     }\n+\n     #[test]\n-    fn test_dlist_pop_tail() {\n-        let l = from_vec([1,2,3]);\n-        assert_eq!(l.pop_tail().get(), 3);\n-        assert_eq!(l.tail(), 2);\n-        assert_eq!(l.head(), 1);\n-        assert_eq!(l.pop_tail().get(), 2);\n-        assert_eq!(l.tail(), 1);\n-        assert_eq!(l.head(), 1);\n-        assert_eq!(l.pop_tail().get(), 1);\n-        assert!(l.is_empty());\n-        assert!(l.pop_tail().is_none());\n+    fn test_eq() {\n+        let mut n: DList<u8> = list_from([]);\n+        let mut m = list_from([]);\n+        assert_eq!(&n, &m);\n+        n.push_front(1);\n+        assert!(n != m);\n+        m.push_back(1);\n+        assert_eq!(&n, &m);\n     }\n+\n     #[test]\n-    fn test_dlist_push() {\n-        let l = DList::<int>();\n-        l.push(1);\n-        assert_eq!(l.head(), 1);\n-        assert_eq!(l.tail(), 1);\n-        l.push(2);\n-        assert_eq!(l.head(), 1);\n-        assert_eq!(l.tail(), 2);\n-        l.push(3);\n-        assert_eq!(l.head(), 1);\n-        assert_eq!(l.tail(), 3);\n-        assert_eq!(l.len(), 3);\n+    fn test_fuzz() {\n+        for 25.times {\n+            fuzz_test(3);\n+            fuzz_test(16);\n+            fuzz_test(189);\n+        }\n     }\n-    #[test]\n-    fn test_dlist_push_head() {\n-        let l = DList::<int>();\n-        l.push_head(3);\n-        assert_eq!(l.head(), 3);\n-        assert_eq!(l.tail(), 3);\n-        l.push_head(2);\n-        assert_eq!(l.head(), 2);\n-        assert_eq!(l.tail(), 3);\n-        l.push_head(1);\n-        assert_eq!(l.head(), 1);\n-        assert_eq!(l.tail(), 3);\n-        assert_eq!(l.len(), 3);\n+\n+    #[cfg(test)]\n+    fn fuzz_test(sz: int) {\n+        let mut m = DList::new::<int>();\n+        let mut v = ~[];\n+        for int::range(0i, sz) |i| {\n+            check_links(&m);\n+            let r: u8 = rand::random();\n+            match r % 6 {\n+                0 => {\n+                    m.pop_back();\n+                    if v.len() > 0 { v.pop(); }\n+                }\n+                1 => {\n+                    m.pop_front();\n+                    if v.len() > 0 { v.shift(); }\n+                }\n+                2 | 4 =>  {\n+                    m.push_front(-i);\n+                    v.unshift(-i);\n+                }\n+                3 | 5 | _ => {\n+                    m.push_back(i);\n+                    v.push(i);\n+                }\n+            }\n+        }\n+\n+        check_links(&m);\n+\n+        let mut i = 0u;\n+        for m.consume_iter().zip(v.iter()).advance |(a, &b)| {\n+            i += 1;\n+            assert_eq!(a, b);\n+        }\n+        assert_eq!(i, v.len());\n     }\n-    #[test]\n-    fn test_dlist_break_early() {\n-        let l = from_vec([1,2,3,4,5]);\n-        let mut x = 0;\n-        for l.each |i| {\n-            x += 1;\n-            if (*i == 3) { break; }\n+\n+    #[bench]\n+    fn bench_collect_into(b: &mut test::BenchHarness) {\n+        let v = &[0, ..64];\n+        do b.iter {\n+            let _: DList<int> = v.iter().transform(|&x|x).collect();\n         }\n-        assert_eq!(x, 3);\n     }\n-    #[test]\n-    fn test_dlist_remove_head() {\n-        let l = DList::<int>();\n-        l.assert_consistent(); let one = l.push_n(1);\n-        l.assert_consistent(); let _two = l.push_n(2);\n-        l.assert_consistent(); let _three = l.push_n(3);\n-        l.assert_consistent(); assert_eq!(l.len(), 3);\n-        l.assert_consistent(); l.remove(one);\n-        l.assert_consistent(); assert_eq!(l.len(), 2);\n-        l.assert_consistent(); assert_eq!(l.head(), 2);\n-        l.assert_consistent(); assert_eq!(l.tail(), 3);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n-        l.assert_consistent(); assert!(l.is_empty());\n+    #[bench]\n+    fn bench_collect_into_vec(b: &mut test::BenchHarness) {\n+        let v = &[0, ..64];\n+        do b.iter {\n+            let _: ~[int] = v.iter().transform(|&x|x).collect();\n+        }\n     }\n-    #[test]\n-    fn test_dlist_remove_mid() {\n-        let l = DList::<int>();\n-        l.assert_consistent(); let _one = l.push_n(1);\n-        l.assert_consistent(); let two = l.push_n(2);\n-        l.assert_consistent(); let _three = l.push_n(3);\n-        l.assert_consistent(); assert_eq!(l.len(), 3);\n-        l.assert_consistent(); l.remove(two);\n-        l.assert_consistent(); assert_eq!(l.len(), 2);\n-        l.assert_consistent(); assert_eq!(l.head(), 1);\n-        l.assert_consistent(); assert_eq!(l.tail(), 3);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n-        l.assert_consistent(); assert!(l.is_empty());\n+\n+    #[bench]\n+    fn bench_push_front(b: &mut test::BenchHarness) {\n+        let mut m = DList::new::<int>();\n+        do b.iter {\n+            m.push_front(0);\n+        }\n     }\n-    #[test]\n-    fn test_dlist_remove_tail() {\n-        let l = DList::<int>();\n-        l.assert_consistent(); let _one = l.push_n(1);\n-        l.assert_consistent(); let _two = l.push_n(2);\n-        l.assert_consistent(); let three = l.push_n(3);\n-        l.assert_consistent(); assert_eq!(l.len(), 3);\n-        l.assert_consistent(); l.remove(three);\n-        l.assert_consistent(); assert_eq!(l.len(), 2);\n-        l.assert_consistent(); assert_eq!(l.head(), 1);\n-        l.assert_consistent(); assert_eq!(l.tail(), 2);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n-        l.assert_consistent(); assert!(l.is_empty());\n+    #[bench]\n+    fn bench_push_front_vec_size10(b: &mut test::BenchHarness) {\n+        let mut m = ~[0, ..10];\n+        do b.iter {\n+            m.unshift(0);\n+            m.pop(); // to keep it fair, dont' grow the vec\n+        }\n     }\n-    #[test]\n-    fn test_dlist_remove_one_two() {\n-        let l = DList::<int>();\n-        l.assert_consistent(); let one = l.push_n(1);\n-        l.assert_consistent(); let two = l.push_n(2);\n-        l.assert_consistent(); let _three = l.push_n(3);\n-        l.assert_consistent(); assert_eq!(l.len(), 3);\n-        l.assert_consistent(); l.remove(one);\n-        l.assert_consistent(); l.remove(two);\n-        // and through and through, the vorpal blade went snicker-snack\n-        l.assert_consistent(); assert_eq!(l.len(), 1);\n-        l.assert_consistent(); assert_eq!(l.head(), 3);\n-        l.assert_consistent(); assert_eq!(l.tail(), 3);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n-        l.assert_consistent(); assert!(l.is_empty());\n+\n+    #[bench]\n+    fn bench_push_back(b: &mut test::BenchHarness) {\n+        let mut m = DList::new::<int>();\n+        do b.iter {\n+            m.push_back(0);\n+        }\n     }\n-    #[test]\n-    fn test_dlist_remove_one_three() {\n-        let l = DList::<int>();\n-        l.assert_consistent(); let one = l.push_n(1);\n-        l.assert_consistent(); let _two = l.push_n(2);\n-        l.assert_consistent(); let three = l.push_n(3);\n-        l.assert_consistent(); assert_eq!(l.len(), 3);\n-        l.assert_consistent(); l.remove(one);\n-        l.assert_consistent(); l.remove(three);\n-        l.assert_consistent(); assert_eq!(l.len(), 1);\n-        l.assert_consistent(); assert_eq!(l.head(), 2);\n-        l.assert_consistent(); assert_eq!(l.tail(), 2);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n-        l.assert_consistent(); assert!(l.is_empty());\n+    #[bench]\n+    fn bench_push_back_vec(b: &mut test::BenchHarness) {\n+        let mut m = ~[];\n+        do b.iter {\n+            m.push(0);\n+        }\n     }\n-    #[test]\n-    fn test_dlist_remove_two_three() {\n-        let l = DList::<int>();\n-        l.assert_consistent(); let _one = l.push_n(1);\n-        l.assert_consistent(); let two = l.push_n(2);\n-        l.assert_consistent(); let three = l.push_n(3);\n-        l.assert_consistent(); assert_eq!(l.len(), 3);\n-        l.assert_consistent(); l.remove(two);\n-        l.assert_consistent(); l.remove(three);\n-        l.assert_consistent(); assert_eq!(l.len(), 1);\n-        l.assert_consistent(); assert_eq!(l.head(), 1);\n-        l.assert_consistent(); assert_eq!(l.tail(), 1);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n-        l.assert_consistent(); assert!(l.is_empty());\n+\n+    #[bench]\n+    fn bench_push_back_pop_back(b: &mut test::BenchHarness) {\n+        let mut m = DList::new::<int>();\n+        do b.iter {\n+            m.push_back(0);\n+            m.pop_back();\n+        }\n     }\n-    #[test]\n-    fn test_dlist_remove_all() {\n-        let l = DList::<int>();\n-        l.assert_consistent(); let one = l.push_n(1);\n-        l.assert_consistent(); let two = l.push_n(2);\n-        l.assert_consistent(); let three = l.push_n(3);\n-        l.assert_consistent(); assert_eq!(l.len(), 3);\n-        l.assert_consistent(); l.remove(two);\n-        l.assert_consistent(); l.remove(three);\n-        l.assert_consistent(); l.remove(one); // Twenty-three is number one!\n-        l.assert_consistent(); assert!(l.peek().is_none());\n-        l.assert_consistent(); assert!(l.is_empty());\n+    #[bench]\n+    fn bench_push_back_pop_back_vec(b: &mut test::BenchHarness) {\n+        let mut m = ~[];\n+        do b.iter {\n+            m.push(0);\n+            m.pop();\n+        }\n     }\n-    #[test]\n-    fn test_dlist_insert_n_before() {\n-        let l = DList::<int>();\n-        l.assert_consistent(); let _one = l.push_n(1);\n-        l.assert_consistent(); let two = l.push_n(2);\n-        l.assert_consistent(); let three = new_dlist_node(3);\n-        l.assert_consistent(); assert_eq!(l.len(), 2);\n-        l.assert_consistent(); l.insert_n_before(three, two);\n-        l.assert_consistent(); assert_eq!(l.len(), 3);\n-        l.assert_consistent(); assert_eq!(l.head(), 1);\n-        l.assert_consistent(); assert_eq!(l.tail(), 2);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n-        l.assert_consistent(); assert!(l.is_empty());\n+\n+    #[bench]\n+    fn bench_iter(b: &mut test::BenchHarness) {\n+        let v = &[0, ..128];\n+        let m: DList<int> = v.iter().transform(|&x|x).collect();\n+        do b.iter {\n+            for m.iter().advance |_| {}\n+        }\n     }\n-    #[test]\n-    fn test_dlist_insert_n_after() {\n-        let l = DList::<int>();\n-        l.assert_consistent(); let one = l.push_n(1);\n-        l.assert_consistent(); let _two = l.push_n(2);\n-        l.assert_consistent(); let three = new_dlist_node(3);\n-        l.assert_consistent(); assert_eq!(l.len(), 2);\n-        l.assert_consistent(); l.insert_n_after(three, one);\n-        l.assert_consistent(); assert_eq!(l.len(), 3);\n-        l.assert_consistent(); assert_eq!(l.head(), 1);\n-        l.assert_consistent(); assert_eq!(l.tail(), 2);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n-        l.assert_consistent(); assert!(l.is_empty());\n+    #[bench]\n+    fn bench_iter_mut(b: &mut test::BenchHarness) {\n+        let v = &[0, ..128];\n+        let mut m: DList<int> = v.iter().transform(|&x|x).collect();\n+        do b.iter {\n+            for m.mut_iter().advance |_| {}\n+        }\n     }\n-    #[test]\n-    fn test_dlist_insert_before_head() {\n-        let l = DList::<int>();\n-        l.assert_consistent(); let one = l.push_n(1);\n-        l.assert_consistent(); let _two = l.push_n(2);\n-        l.assert_consistent(); assert_eq!(l.len(), 2);\n-        l.assert_consistent(); l.insert_before(3, one);\n-        l.assert_consistent(); assert_eq!(l.len(), 3);\n-        l.assert_consistent(); assert_eq!(l.head(), 3);\n-        l.assert_consistent(); assert_eq!(l.tail(), 2);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n-        l.assert_consistent(); assert!(l.is_empty());\n+    #[bench]\n+    fn bench_iter_rev(b: &mut test::BenchHarness) {\n+        let v = &[0, ..128];\n+        let m: DList<int> = v.iter().transform(|&x|x).collect();\n+        do b.iter {\n+            for m.rev_iter().advance |_| {}\n+        }\n     }\n-    #[test]\n-    fn test_dlist_insert_after_tail() {\n-        let l = DList::<int>();\n-        l.assert_consistent(); let _one = l.push_n(1);\n-        l.assert_consistent(); let two = l.push_n(2);\n-        l.assert_consistent(); assert_eq!(l.len(), 2);\n-        l.assert_consistent(); l.insert_after(3, two);\n-        l.assert_consistent(); assert_eq!(l.len(), 3);\n-        l.assert_consistent(); assert_eq!(l.head(), 1);\n-        l.assert_consistent(); assert_eq!(l.tail(), 3);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n-        l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n-        l.assert_consistent(); assert!(l.is_empty());\n-    }\n-    #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_dlist_asymmetric_link() {\n-        let l = DList::<int>();\n-        let _one = l.push_n(1);\n-        let two = l.push_n(2);\n-        two.prev = None;\n-        l.assert_consistent();\n-    }\n-    #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_dlist_cyclic_list() {\n-        let l = DList::<int>();\n-        let one = l.push_n(1);\n-        let _two = l.push_n(2);\n-        let three = l.push_n(3);\n-        three.next = Some(one);\n-        one.prev = Some(three);\n-        l.assert_consistent();\n-    }\n-    #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_dlist_headless() {\n-        DList::<int>().head();\n-    }\n-    #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_dlist_insert_already_present_before() {\n-        let l = DList::<int>();\n-        let one = l.push_n(1);\n-        let two = l.push_n(2);\n-        l.insert_n_before(two, one);\n-    }\n-    #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_dlist_insert_already_present_after() {\n-        let l = DList::<int>();\n-        let one = l.push_n(1);\n-        let two = l.push_n(2);\n-        l.insert_n_after(one, two);\n-    }\n-    #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_dlist_insert_before_orphan() {\n-        let l = DList::<int>();\n-        let one = new_dlist_node(1);\n-        let two = new_dlist_node(2);\n-        l.insert_n_before(one, two);\n-    }\n-    #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_dlist_insert_after_orphan() {\n-        let l = DList::<int>();\n-        let one = new_dlist_node(1);\n-        let two = new_dlist_node(2);\n-        l.insert_n_after(two, one);\n+    #[bench]\n+    fn bench_iter_mut_rev(b: &mut test::BenchHarness) {\n+        let v = &[0, ..128];\n+        let mut m: DList<int> = v.iter().transform(|&x|x).collect();\n+        do b.iter {\n+            for m.mut_rev_iter().advance |_| {}\n+        }\n+    }\n+    #[bench]\n+    fn bench_iter_vec(b: &mut test::BenchHarness) {\n+        let v = &[0, ..128];\n+        do b.iter {\n+            for v.iter().advance |_| {}\n+        }\n     }\n }\n+"}, {"sha": "66ee52f53db312bee2b77273aa411fe4d9877926", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9fce8c918ab90aeb1a2932d330396884cf847e9f/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fce8c918ab90aeb1a2932d330396884cf847e9f/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=9fce8c918ab90aeb1a2932d330396884cf847e9f", "patch": "@@ -67,10 +67,11 @@ pub mod flatpipes;\n \n // Collections\n \n+pub mod container;\n pub mod bitv;\n-pub mod deque;\n pub mod fun_treemap;\n pub mod list;\n+pub mod ringbuf;\n pub mod priority_queue;\n pub mod smallintmap;\n "}, {"sha": "1d429a18a5c9ece4adbe3e0fb333391cbe9f1d6d", "filename": "src/libextra/ringbuf.rs", "status": "renamed", "additions": 223, "deletions": 199, "changes": 422, "blob_url": "https://github.com/rust-lang/rust/blob/9fce8c918ab90aeb1a2932d330396884cf847e9f/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fce8c918ab90aeb1a2932d330396884cf847e9f/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=9fce8c918ab90aeb1a2932d330396884cf847e9f", "patch": "@@ -9,102 +9,90 @@\n // except according to those terms.\n \n //! A double-ended queue implemented as a circular buffer\n+//!\n+//! RingBuf implements the trait Deque. It should be imported with `use\n+//! extra::container::Deque`.\n \n use std::num;\n+use std::util;\n use std::uint;\n use std::vec;\n use std::iterator::FromIterator;\n \n+use container::Deque;\n+\n static INITIAL_CAPACITY: uint = 8u; // 2^3\n static MINIMUM_CAPACITY: uint = 2u;\n \n-#[allow(missing_doc)]\n+/// RingBuf is a circular buffer that implements Deque.\n #[deriving(Clone)]\n-pub struct Deque<T> {\n+pub struct RingBuf<T> {\n     priv nelts: uint,\n     priv lo: uint,\n     priv elts: ~[Option<T>]\n }\n \n-impl<T> Container for Deque<T> {\n-    /// Return the number of elements in the deque\n+impl<T> Container for RingBuf<T> {\n+    /// Return the number of elements in the RingBuf\n     fn len(&self) -> uint { self.nelts }\n \n-    /// Return true if the deque contains no elements\n+    /// Return true if the RingBufcontains no elements\n     fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n-impl<T> Mutable for Deque<T> {\n-    /// Clear the deque, removing all values.\n+impl<T> Mutable for RingBuf<T> {\n+    /// Clear the RingBuf, removing all values.\n     fn clear(&mut self) {\n         for self.elts.mut_iter().advance |x| { *x = None }\n         self.nelts = 0;\n         self.lo = 0;\n     }\n }\n \n-impl<T> Deque<T> {\n-    /// Create an empty Deque\n-    pub fn new() -> Deque<T> {\n-        Deque::with_capacity(INITIAL_CAPACITY)\n+impl<T> Deque<T> for RingBuf<T> {\n+    /// Return a reference to the first element in the RingBuf\n+    fn front<'a>(&'a self) -> Option<&'a T> {\n+        if self.nelts > 0 { Some(self.get(0)) } else { None }\n     }\n \n-    /// Create an empty Deque with space for at least `n` elements.\n-    pub fn with_capacity(n: uint) -> Deque<T> {\n-        Deque{nelts: 0, lo: 0,\n-              elts: vec::from_fn(num::max(MINIMUM_CAPACITY, n), |_| None)}\n+    /// Return a mutable reference to the first element in the RingBuf\n+    fn front_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+        if self.nelts > 0 { Some(self.get_mut(0)) } else { None }\n     }\n \n-    /// Return a reference to the first element in the deque\n-    ///\n-    /// Fails if the deque is empty\n-    pub fn peek_front<'a>(&'a self) -> &'a T { get(self.elts, self.raw_index(0)) }\n-\n-    /// Return a reference to the last element in the deque\n-    ///\n-    /// Fails if the deque is empty\n-    pub fn peek_back<'a>(&'a self) -> &'a T {\n-        if self.nelts > 0 {\n-            get(self.elts, self.raw_index(self.nelts - 1))\n-        } else {\n-            fail!(\"peek_back: empty deque\");\n-        }\n+    /// Return a reference to the last element in the RingBuf\n+    fn back<'a>(&'a self) -> Option<&'a T> {\n+        if self.nelts > 0 { Some(self.get(self.nelts - 1)) } else { None }\n     }\n \n-    /// Retrieve an element in the deque by index\n-    ///\n-    /// Fails if there is no element with the given index\n-    pub fn get<'a>(&'a self, i: int) -> &'a T {\n-        let idx = (self.lo + (i as uint)) % self.elts.len();\n-        get(self.elts, idx)\n+    /// Return a mutable reference to the last element in the RingBuf\n+    fn back_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+        if self.nelts > 0 { Some(self.get_mut(self.nelts - 1)) } else { None }\n     }\n \n-    /// Remove and return the first element in the deque\n-    ///\n-    /// Fails if the deque is empty\n-    pub fn pop_front(&mut self) -> T {\n-        let result = self.elts[self.lo].swap_unwrap();\n-        self.lo = (self.lo + 1u) % self.elts.len();\n-        self.nelts -= 1u;\n+    /// Remove and return the first element in the RingBuf, or None if it is empty\n+    fn pop_front(&mut self) -> Option<T> {\n+        let result = util::replace(&mut self.elts[self.lo], None);\n+        if result.is_some() {\n+            self.lo = (self.lo + 1u) % self.elts.len();\n+            self.nelts -= 1u;\n+        }\n         result\n     }\n \n-    /// Return index in underlying vec for a given logical element index\n-    fn raw_index(&self, idx: uint) -> uint {\n-        raw_index(self.lo, self.elts.len(), idx)\n-    }\n-\n-    /// Remove and return the last element in the deque\n-    ///\n-    /// Fails if the deque is empty\n-    pub fn pop_back(&mut self) -> T {\n-        self.nelts -= 1;\n-        let hi = self.raw_index(self.nelts);\n-        self.elts[hi].swap_unwrap()\n+    /// Remove and return the last element in the RingBuf, or None if it is empty\n+    fn pop_back(&mut self) -> Option<T> {\n+        if self.nelts > 0 {\n+            self.nelts -= 1;\n+            let hi = self.raw_index(self.nelts);\n+            util::replace(&mut self.elts[hi], None)\n+        } else {\n+            None\n+        }\n     }\n \n-    /// Prepend an element to the deque\n-    pub fn add_front(&mut self, t: T) {\n+    /// Prepend an element to the RingBuf\n+    fn push_front(&mut self, t: T) {\n         if self.nelts == self.elts.len() {\n             grow(self.nelts, &mut self.lo, &mut self.elts);\n         }\n@@ -115,17 +103,57 @@ impl<T> Deque<T> {\n         self.nelts += 1u;\n     }\n \n-    /// Append an element to the deque\n-    pub fn add_back(&mut self, t: T) {\n+    /// Append an element to the RingBuf\n+    fn push_back(&mut self, t: T) {\n         if self.nelts == self.elts.len() {\n             grow(self.nelts, &mut self.lo, &mut self.elts);\n         }\n         let hi = self.raw_index(self.nelts);\n         self.elts[hi] = Some(t);\n         self.nelts += 1u;\n     }\n+}\n \n-    /// Reserve capacity for exactly `n` elements in the given deque,\n+impl<T> RingBuf<T> {\n+    /// Create an empty RingBuf\n+    pub fn new() -> RingBuf<T> {\n+        RingBuf::with_capacity(INITIAL_CAPACITY)\n+    }\n+\n+    /// Create an empty RingBuf with space for at least `n` elements.\n+    pub fn with_capacity(n: uint) -> RingBuf<T> {\n+        RingBuf{nelts: 0, lo: 0,\n+              elts: vec::from_fn(num::max(MINIMUM_CAPACITY, n), |_| None)}\n+    }\n+\n+    /// Retrieve an element in the RingBuf by index\n+    ///\n+    /// Fails if there is no element with the given index\n+    pub fn get<'a>(&'a self, i: uint) -> &'a T {\n+        let idx = self.raw_index(i);\n+        match self.elts[idx] {\n+            None => fail!(),\n+            Some(ref v) => v\n+        }\n+    }\n+\n+    /// Retrieve an element in the RingBuf by index\n+    ///\n+    /// Fails if there is no element with the given index\n+    pub fn get_mut<'a>(&'a mut self, i: uint) -> &'a mut T {\n+        let idx = self.raw_index(i);\n+        match self.elts[idx] {\n+            None => fail!(),\n+            Some(ref mut v) => v\n+        }\n+    }\n+\n+    /// Return index in underlying vec for a given logical element index\n+    fn raw_index(&self, idx: uint) -> uint {\n+        raw_index(self.lo, self.elts.len(), idx)\n+    }\n+\n+    /// Reserve capacity for exactly `n` elements in the given RingBuf,\n     /// doing nothing if `self`'s capacity is already equal to or greater\n     /// than the requested capacity\n     ///\n@@ -136,7 +164,7 @@ impl<T> Deque<T> {\n         self.elts.reserve(n);\n     }\n \n-    /// Reserve capacity for at least `n` elements in the given deque,\n+    /// Reserve capacity for at least `n` elements in the given RingBuf,\n     /// over-allocating in case the caller needs to reserve additional\n     /// space.\n     ///\n@@ -151,24 +179,24 @@ impl<T> Deque<T> {\n     }\n \n     /// Front-to-back iterator.\n-    pub fn iter<'a>(&'a self) -> DequeIterator<'a, T> {\n-        DequeIterator{index: 0, nelts: self.nelts, elts: self.elts, lo: self.lo}\n+    pub fn iter<'a>(&'a self) -> RingBufIterator<'a, T> {\n+        RingBufIterator{index: 0, nelts: self.nelts, elts: self.elts, lo: self.lo}\n     }\n \n     /// Front-to-back iterator which returns mutable values.\n-    pub fn mut_iter<'a>(&'a mut self) -> DequeMutIterator<'a, T> {\n-        DequeMutIterator{index: 0, nelts: self.nelts, elts: self.elts, lo: self.lo}\n+    pub fn mut_iter<'a>(&'a mut self) -> RingBufMutIterator<'a, T> {\n+        RingBufMutIterator{index: 0, nelts: self.nelts, elts: self.elts, lo: self.lo}\n     }\n \n     /// Back-to-front iterator.\n-    pub fn rev_iter<'a>(&'a self) -> DequeRevIterator<'a, T> {\n-        DequeRevIterator{index: self.nelts-1, nelts: self.nelts, elts: self.elts,\n+    pub fn rev_iter<'a>(&'a self) -> RingBufRevIterator<'a, T> {\n+        RingBufRevIterator{index: self.nelts-1, nelts: self.nelts, elts: self.elts,\n                          lo: self.lo}\n     }\n \n     /// Back-to-front iterator which returns mutable values.\n-    pub fn mut_rev_iter<'a>(&'a mut self) -> DequeMutRevIterator<'a, T> {\n-        DequeMutRevIterator{index: self.nelts-1, nelts: self.nelts, elts: self.elts,\n+    pub fn mut_rev_iter<'a>(&'a mut self) -> RingBufMutRevIterator<'a, T> {\n+        RingBufMutRevIterator{index: self.nelts-1, nelts: self.nelts, elts: self.elts,\n                             lo: self.lo}\n     }\n }\n@@ -190,41 +218,41 @@ macro_rules! iterator {\n     }\n }\n \n-/// Deque iterator\n-pub struct DequeIterator<'self, T> {\n+/// RingBuf iterator\n+pub struct RingBufIterator<'self, T> {\n     priv lo: uint,\n     priv nelts: uint,\n     priv index: uint,\n     priv elts: &'self [Option<T>],\n }\n-iterator!{impl DequeIterator -> &'self T, get_ref, 1}\n+iterator!{impl RingBufIterator -> &'self T, get_ref, 1}\n \n-/// Deque reverse iterator\n-pub struct DequeRevIterator<'self, T> {\n+/// RingBuf reverse iterator\n+pub struct RingBufRevIterator<'self, T> {\n     priv lo: uint,\n     priv nelts: uint,\n     priv index: uint,\n     priv elts: &'self [Option<T>],\n }\n-iterator!{impl DequeRevIterator -> &'self T, get_ref, -1}\n+iterator!{impl RingBufRevIterator -> &'self T, get_ref, -1}\n \n-/// Deque mutable iterator\n-pub struct DequeMutIterator<'self, T> {\n+/// RingBuf mutable iterator\n+pub struct RingBufMutIterator<'self, T> {\n     priv lo: uint,\n     priv nelts: uint,\n     priv index: uint,\n     priv elts: &'self mut [Option<T>],\n }\n-iterator!{impl DequeMutIterator -> &'self mut T, get_mut_ref, 1}\n+iterator!{impl RingBufMutIterator -> &'self mut T, get_mut_ref, 1}\n \n-/// Deque mutable reverse iterator\n-pub struct DequeMutRevIterator<'self, T> {\n+/// RingBuf mutable reverse iterator\n+pub struct RingBufMutRevIterator<'self, T> {\n     priv lo: uint,\n     priv nelts: uint,\n     priv index: uint,\n     priv elts: &'self mut [Option<T>],\n }\n-iterator!{impl DequeMutRevIterator -> &'self mut T, get_mut_ref, -1}\n+iterator!{impl RingBufMutRevIterator -> &'self mut T, get_mut_ref, -1}\n \n /// Grow is only called on full elts, so nelts is also len(elts), unlike\n /// elsewhere.\n@@ -261,10 +289,6 @@ fn grow<T>(nelts: uint, loptr: &mut uint, elts: &mut ~[Option<T>]) {\n     }\n }\n \n-fn get<'r, T>(elts: &'r [Option<T>], i: uint) -> &'r T {\n-    match elts[i] { Some(ref t) => t, _ => fail!() }\n-}\n-\n /// Return index in underlying vec for a given logical element index\n fn raw_index(lo: uint, len: uint, index: uint) -> uint {\n     if lo >= len - index {\n@@ -274,21 +298,21 @@ fn raw_index(lo: uint, len: uint, index: uint) -> uint {\n     }\n }\n \n-impl<A: Eq> Eq for Deque<A> {\n-    fn eq(&self, other: &Deque<A>) -> bool {\n+impl<A: Eq> Eq for RingBuf<A> {\n+    fn eq(&self, other: &RingBuf<A>) -> bool {\n         self.nelts == other.nelts &&\n             self.iter().zip(other.iter()).all(|(a, b)| a.eq(b))\n     }\n-    fn ne(&self, other: &Deque<A>) -> bool {\n+    fn ne(&self, other: &RingBuf<A>) -> bool {\n         !self.eq(other)\n     }\n }\n \n-impl<A, T: Iterator<A>> FromIterator<A, T> for Deque<A> {\n-    fn from_iterator(iterator: &mut T) -> Deque<A> {\n-        let mut deq = Deque::new();\n+impl<A, T: Iterator<A>> FromIterator<A, T> for RingBuf<A> {\n+    fn from_iterator(iterator: &mut T) -> RingBuf<A> {\n+        let mut deq = RingBuf::new();\n         for iterator.advance |elt| {\n-            deq.add_back(elt);\n+            deq.push_back(elt);\n         }\n         deq\n     }\n@@ -304,38 +328,38 @@ mod tests {\n \n     #[test]\n     fn test_simple() {\n-        let mut d = Deque::new();\n+        let mut d = RingBuf::new();\n         assert_eq!(d.len(), 0u);\n-        d.add_front(17);\n-        d.add_front(42);\n-        d.add_back(137);\n+        d.push_front(17);\n+        d.push_front(42);\n+        d.push_back(137);\n         assert_eq!(d.len(), 3u);\n-        d.add_back(137);\n+        d.push_back(137);\n         assert_eq!(d.len(), 4u);\n-        debug!(d.peek_front());\n-        assert_eq!(*d.peek_front(), 42);\n-        debug!(d.peek_back());\n-        assert_eq!(*d.peek_back(), 137);\n-        let mut i: int = d.pop_front();\n+        debug!(d.front());\n+        assert_eq!(*d.front().unwrap(), 42);\n+        debug!(d.back());\n+        assert_eq!(*d.back().unwrap(), 137);\n+        let mut i = d.pop_front();\n         debug!(i);\n-        assert_eq!(i, 42);\n+        assert_eq!(i, Some(42));\n         i = d.pop_back();\n         debug!(i);\n-        assert_eq!(i, 137);\n+        assert_eq!(i, Some(137));\n         i = d.pop_back();\n         debug!(i);\n-        assert_eq!(i, 137);\n+        assert_eq!(i, Some(137));\n         i = d.pop_back();\n         debug!(i);\n-        assert_eq!(i, 17);\n+        assert_eq!(i, Some(17));\n         assert_eq!(d.len(), 0u);\n-        d.add_back(3);\n+        d.push_back(3);\n         assert_eq!(d.len(), 1u);\n-        d.add_front(2);\n+        d.push_front(2);\n         assert_eq!(d.len(), 2u);\n-        d.add_back(4);\n+        d.push_back(4);\n         assert_eq!(d.len(), 3u);\n-        d.add_front(1);\n+        d.push_front(1);\n         assert_eq!(d.len(), 4u);\n         debug!(d.get(0));\n         debug!(d.get(1));\n@@ -354,28 +378,28 @@ mod tests {\n         let c: @int = @64;\n         let d: @int = @175;\n \n-        let mut deq = Deque::new();\n+        let mut deq = RingBuf::new();\n         assert_eq!(deq.len(), 0);\n-        deq.add_front(a);\n-        deq.add_front(b);\n-        deq.add_back(c);\n+        deq.push_front(a);\n+        deq.push_front(b);\n+        deq.push_back(c);\n         assert_eq!(deq.len(), 3);\n-        deq.add_back(d);\n+        deq.push_back(d);\n         assert_eq!(deq.len(), 4);\n-        assert_eq!(*deq.peek_front(), b);\n-        assert_eq!(*deq.peek_back(), d);\n-        assert_eq!(deq.pop_front(), b);\n-        assert_eq!(deq.pop_back(), d);\n-        assert_eq!(deq.pop_back(), c);\n-        assert_eq!(deq.pop_back(), a);\n+        assert_eq!(deq.front(), Some(&b));\n+        assert_eq!(deq.back(), Some(&d));\n+        assert_eq!(deq.pop_front(), Some(b));\n+        assert_eq!(deq.pop_back(), Some(d));\n+        assert_eq!(deq.pop_back(), Some(c));\n+        assert_eq!(deq.pop_back(), Some(a));\n         assert_eq!(deq.len(), 0);\n-        deq.add_back(c);\n+        deq.push_back(c);\n         assert_eq!(deq.len(), 1);\n-        deq.add_front(b);\n+        deq.push_front(b);\n         assert_eq!(deq.len(), 2);\n-        deq.add_back(d);\n+        deq.push_back(d);\n         assert_eq!(deq.len(), 3);\n-        deq.add_front(a);\n+        deq.push_front(a);\n         assert_eq!(deq.len(), 4);\n         assert_eq!(*deq.get(0), a);\n         assert_eq!(*deq.get(1), b);\n@@ -385,28 +409,28 @@ mod tests {\n \n     #[cfg(test)]\n     fn test_parameterized<T:Copy + Eq>(a: T, b: T, c: T, d: T) {\n-        let mut deq = Deque::new();\n+        let mut deq = RingBuf::new();\n         assert_eq!(deq.len(), 0);\n-        deq.add_front(copy a);\n-        deq.add_front(copy b);\n-        deq.add_back(copy c);\n+        deq.push_front(copy a);\n+        deq.push_front(copy b);\n+        deq.push_back(copy c);\n         assert_eq!(deq.len(), 3);\n-        deq.add_back(copy d);\n+        deq.push_back(copy d);\n         assert_eq!(deq.len(), 4);\n-        assert_eq!(copy *deq.peek_front(), copy b);\n-        assert_eq!(copy *deq.peek_back(), copy d);\n-        assert_eq!(deq.pop_front(), copy b);\n-        assert_eq!(deq.pop_back(), copy d);\n-        assert_eq!(deq.pop_back(), copy c);\n-        assert_eq!(deq.pop_back(), copy a);\n+        assert_eq!(deq.front(), Some(&b));\n+        assert_eq!(deq.back(), Some(&d));\n+        assert_eq!(deq.pop_front(), Some(copy b));\n+        assert_eq!(deq.pop_back(), Some(copy d));\n+        assert_eq!(deq.pop_back(), Some(copy c));\n+        assert_eq!(deq.pop_back(), Some(copy a));\n         assert_eq!(deq.len(), 0);\n-        deq.add_back(copy c);\n+        deq.push_back(copy c);\n         assert_eq!(deq.len(), 1);\n-        deq.add_front(copy b);\n+        deq.push_front(copy b);\n         assert_eq!(deq.len(), 2);\n-        deq.add_back(copy d);\n+        deq.push_back(copy d);\n         assert_eq!(deq.len(), 3);\n-        deq.add_front(copy a);\n+        deq.push_front(copy a);\n         assert_eq!(deq.len(), 4);\n         assert_eq!(copy *deq.get(0), copy a);\n         assert_eq!(copy *deq.get(1), copy b);\n@@ -415,56 +439,56 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_add_front_grow() {\n-        let mut deq = Deque::new();\n-        for int::range(0, 66) |i| {\n-            deq.add_front(i);\n+    fn test_push_front_grow() {\n+        let mut deq = RingBuf::new();\n+        for uint::range(0, 66) |i| {\n+            deq.push_front(i);\n         }\n         assert_eq!(deq.len(), 66);\n \n-        for int::range(0, 66) |i| {\n+        for uint::range(0, 66) |i| {\n             assert_eq!(*deq.get(i), 65 - i);\n         }\n \n-        let mut deq = Deque::new();\n-        for int::range(0, 66) |i| {\n-            deq.add_back(i);\n+        let mut deq = RingBuf::new();\n+        for uint::range(0, 66) |i| {\n+            deq.push_back(i);\n         }\n \n-        for int::range(0, 66) |i| {\n+        for uint::range(0, 66) |i| {\n             assert_eq!(*deq.get(i), i);\n         }\n     }\n \n     #[bench]\n     fn bench_new(b: &mut test::BenchHarness) {\n         do b.iter {\n-            let _ = Deque::new::<u64>();\n+            let _ = RingBuf::new::<u64>();\n         }\n     }\n \n     #[bench]\n-    fn bench_add_back(b: &mut test::BenchHarness) {\n-        let mut deq = Deque::new();\n+    fn bench_push_back(b: &mut test::BenchHarness) {\n+        let mut deq = RingBuf::new();\n         do b.iter {\n-            deq.add_back(0);\n+            deq.push_back(0);\n         }\n     }\n \n     #[bench]\n-    fn bench_add_front(b: &mut test::BenchHarness) {\n-        let mut deq = Deque::new();\n+    fn bench_push_front(b: &mut test::BenchHarness) {\n+        let mut deq = RingBuf::new();\n         do b.iter {\n-            deq.add_front(0);\n+            deq.push_front(0);\n         }\n     }\n \n     #[bench]\n     fn bench_grow(b: &mut test::BenchHarness) {\n-        let mut deq = Deque::new();\n+        let mut deq = RingBuf::new();\n         do b.iter {\n             for 65.times {\n-                deq.add_front(1);\n+                deq.push_front(1);\n             }\n         }\n     }\n@@ -518,77 +542,77 @@ mod tests {\n \n     #[test]\n     fn test_with_capacity() {\n-        let mut d = Deque::with_capacity(0);\n-        d.add_back(1);\n+        let mut d = RingBuf::with_capacity(0);\n+        d.push_back(1);\n         assert_eq!(d.len(), 1);\n-        let mut d = Deque::with_capacity(50);\n-        d.add_back(1);\n+        let mut d = RingBuf::with_capacity(50);\n+        d.push_back(1);\n         assert_eq!(d.len(), 1);\n     }\n \n     #[test]\n     fn test_reserve() {\n-        let mut d = Deque::new();\n-        d.add_back(0u64);\n+        let mut d = RingBuf::new();\n+        d.push_back(0u64);\n         d.reserve(50);\n         assert_eq!(d.elts.capacity(), 50);\n-        let mut d = Deque::new();\n-        d.add_back(0u32);\n+        let mut d = RingBuf::new();\n+        d.push_back(0u32);\n         d.reserve(50);\n         assert_eq!(d.elts.capacity(), 50);\n     }\n \n     #[test]\n     fn test_reserve_at_least() {\n-        let mut d = Deque::new();\n-        d.add_back(0u64);\n+        let mut d = RingBuf::new();\n+        d.push_back(0u64);\n         d.reserve_at_least(50);\n         assert_eq!(d.elts.capacity(), 64);\n-        let mut d = Deque::new();\n-        d.add_back(0u32);\n+        let mut d = RingBuf::new();\n+        d.push_back(0u32);\n         d.reserve_at_least(50);\n         assert_eq!(d.elts.capacity(), 64);\n     }\n \n     #[test]\n     fn test_iter() {\n-        let mut d = Deque::new();\n+        let mut d = RingBuf::new();\n         assert_eq!(d.iter().next(), None);\n \n         for int::range(0,5) |i| {\n-            d.add_back(i);\n+            d.push_back(i);\n         }\n         assert_eq!(d.iter().collect::<~[&int]>(), ~[&0,&1,&2,&3,&4]);\n \n         for int::range(6,9) |i| {\n-            d.add_front(i);\n+            d.push_front(i);\n         }\n         assert_eq!(d.iter().collect::<~[&int]>(), ~[&8,&7,&6,&0,&1,&2,&3,&4]);\n     }\n \n     #[test]\n     fn test_rev_iter() {\n-        let mut d = Deque::new();\n+        let mut d = RingBuf::new();\n         assert_eq!(d.rev_iter().next(), None);\n \n         for int::range(0,5) |i| {\n-            d.add_back(i);\n+            d.push_back(i);\n         }\n         assert_eq!(d.rev_iter().collect::<~[&int]>(), ~[&4,&3,&2,&1,&0]);\n \n         for int::range(6,9) |i| {\n-            d.add_front(i);\n+            d.push_front(i);\n         }\n         assert_eq!(d.rev_iter().collect::<~[&int]>(), ~[&4,&3,&2,&1,&0,&6,&7,&8]);\n     }\n \n     #[test]\n     fn test_mut_iter() {\n-        let mut d = Deque::new();\n+        let mut d = RingBuf::new();\n         assert!(d.mut_iter().next().is_none());\n \n         for uint::range(0,3) |i| {\n-            d.add_front(i);\n+            d.push_front(i);\n         }\n \n         for d.mut_iter().enumerate().advance |(i, elt)| {\n@@ -607,11 +631,11 @@ mod tests {\n \n     #[test]\n     fn test_mut_rev_iter() {\n-        let mut d = Deque::new();\n+        let mut d = RingBuf::new();\n         assert!(d.mut_rev_iter().next().is_none());\n \n         for uint::range(0,3) |i| {\n-            d.add_front(i);\n+            d.push_front(i);\n         }\n \n         for d.mut_rev_iter().enumerate().advance |(i, elt)| {\n@@ -632,12 +656,12 @@ mod tests {\n     fn test_from_iterator() {\n         use std::iterator;\n         let v = ~[1,2,3,4,5,6,7];\n-        let deq: Deque<int> = v.iter().transform(|&x| x).collect();\n+        let deq: RingBuf<int> = v.iter().transform(|&x| x).collect();\n         let u: ~[int] = deq.iter().transform(|&x| x).collect();\n         assert_eq!(u, v);\n \n         let mut seq = iterator::Counter::new(0u, 2).take_(256);\n-        let deq: Deque<uint> = seq.collect();\n+        let deq: RingBuf<uint> = seq.collect();\n         for deq.iter().enumerate().advance |(i, &x)| {\n             assert_eq!(2*i, x);\n         }\n@@ -646,11 +670,11 @@ mod tests {\n \n     #[test]\n     fn test_clone() {\n-        let mut d = Deque::new();\n-        d.add_front(17);\n-        d.add_front(42);\n-        d.add_back(137);\n-        d.add_back(137);\n+        let mut d = RingBuf::new();\n+        d.push_front(17);\n+        d.push_front(42);\n+        d.push_back(137);\n+        d.push_back(137);\n         assert_eq!(d.len(), 4u);\n         let mut e = d.clone();\n         assert_eq!(e.len(), 4u);\n@@ -663,22 +687,22 @@ mod tests {\n \n     #[test]\n     fn test_eq() {\n-        let mut d = Deque::new();\n-        assert_eq!(&d, &Deque::with_capacity(0));\n-        d.add_front(137);\n-        d.add_front(17);\n-        d.add_front(42);\n-        d.add_back(137);\n-        let mut e = Deque::with_capacity(0);\n-        e.add_back(42);\n-        e.add_back(17);\n-        e.add_back(137);\n-        e.add_back(137);\n+        let mut d = RingBuf::new();\n+        assert_eq!(&d, &RingBuf::with_capacity(0));\n+        d.push_front(137);\n+        d.push_front(17);\n+        d.push_front(42);\n+        d.push_back(137);\n+        let mut e = RingBuf::with_capacity(0);\n+        e.push_back(42);\n+        e.push_back(17);\n+        e.push_back(137);\n+        e.push_back(137);\n         assert_eq!(&e, &d);\n         e.pop_back();\n-        e.add_back(0);\n+        e.push_back(0);\n         assert!(e != d);\n         e.clear();\n-        assert_eq!(e, Deque::new());\n+        assert_eq!(e, RingBuf::new());\n     }\n }", "previous_filename": "src/libextra/deque.rs"}, {"sha": "9fec58e74958ee2a2c77ba9841e7e9f4dd5077bb", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9fce8c918ab90aeb1a2932d330396884cf847e9f/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fce8c918ab90aeb1a2932d330396884cf847e9f/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=9fce8c918ab90aeb1a2932d330396884cf847e9f", "patch": "@@ -23,7 +23,8 @@ use std::hashmap::{HashMap, HashSet};\n use std::trie::{TrieMap, TrieSet};\n use std::uint;\n use std::vec;\n-use deque::Deque;\n+use ringbuf::RingBuf;\n+use container::Deque;\n use dlist::DList;\n use treemap::{TreeMap, TreeSet};\n \n@@ -652,24 +653,24 @@ impl<\n impl<\n     S: Encoder,\n     T: Encodable<S> + Copy\n-> Encodable<S> for @mut DList<T> {\n+> Encodable<S> for DList<T> {\n     fn encode(&self, s: &mut S) {\n-        do s.emit_seq(self.size) |s| {\n+        do s.emit_seq(self.len()) |s| {\n             let mut i = 0;\n-            for self.each |e| {\n+            for self.iter().advance |e| {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n                 i += 1;\n             }\n         }\n     }\n }\n \n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for @mut DList<T> {\n-    fn decode(d: &mut D) -> @mut DList<T> {\n-        let list = DList();\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for DList<T> {\n+    fn decode(d: &mut D) -> DList<T> {\n+        let mut list = DList::new();\n         do d.read_seq |d, len| {\n             for uint::range(0, len) |i| {\n-                list.push(d.read_seq_elt(i, |d| Decodable::decode(d)));\n+                list.push_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n         }\n         list\n@@ -679,7 +680,7 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for @mut DList<T> {\n impl<\n     S: Encoder,\n     T: Encodable<S>\n-> Encodable<S> for Deque<T> {\n+> Encodable<S> for RingBuf<T> {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n             for self.iter().enumerate().advance |(i, e)| {\n@@ -689,12 +690,12 @@ impl<\n     }\n }\n \n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for Deque<T> {\n-    fn decode(d: &mut D) -> Deque<T> {\n-        let mut deque = Deque::new();\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for RingBuf<T> {\n+    fn decode(d: &mut D) -> RingBuf<T> {\n+        let mut deque = RingBuf::new();\n         do d.read_seq |d, len| {\n             for uint::range(0, len) |i| {\n-                deque.add_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n+                deque.push_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n         }\n         deque"}, {"sha": "f0ffa3237b5cfda33dfc96b90e0a3bc753868e32", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9fce8c918ab90aeb1a2932d330396884cf847e9f/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fce8c918ab90aeb1a2932d330396884cf847e9f/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=9fce8c918ab90aeb1a2932d330396884cf847e9f", "patch": "@@ -19,7 +19,8 @@ An implementation of the Graph500 Breadth First Search problem in Rust.\n extern mod extra;\n use extra::arc;\n use extra::time;\n-use extra::deque::Deque;\n+use extra::ringbuf::RingBuf;\n+use extra::container::Deque;\n use extra::par;\n use std::hashmap::HashSet;\n use std::num::abs;\n@@ -133,18 +134,18 @@ fn bfs(graph: graph, key: node_id) -> bfs_result {\n     let mut marks : ~[node_id]\n         = vec::from_elem(graph.len(), -1i64);\n \n-    let mut q = Deque::new();\n+    let mut q = RingBuf::new();\n \n-    q.add_back(key);\n+    q.push_back(key);\n     marks[key] = key;\n \n     while !q.is_empty() {\n-        let t = q.pop_front();\n+        let t = q.pop_front().unwrap();\n \n         do graph[t].iter().advance |k| {\n             if marks[*k] == -1i64 {\n                 marks[*k] = t;\n-                q.add_back(*k);\n+                q.push_back(*k);\n             }\n             true\n         };"}, {"sha": "0314c7fed02cc7b7af1f5bc67ecaf0297efe9deb", "filename": "src/test/run-pass/issue-2383.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9fce8c918ab90aeb1a2932d330396884cf847e9f/src%2Ftest%2Frun-pass%2Fissue-2383.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fce8c918ab90aeb1a2932d330396884cf847e9f/src%2Ftest%2Frun-pass%2Fissue-2383.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2383.rs?ref=9fce8c918ab90aeb1a2932d330396884cf847e9f", "patch": "@@ -11,9 +11,10 @@\n // except according to those terms.\n \n extern mod extra;\n-use extra::deque::Deque;\n+use extra::ringbuf::RingBuf;\n+use extra::container::Deque;\n \n pub fn main() {\n-    let mut q = Deque::new();\n-    q.add_back(10);\n+    let mut q = RingBuf::new();\n+    q.push_back(10);\n }"}]}