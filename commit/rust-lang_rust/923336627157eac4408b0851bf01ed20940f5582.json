{"sha": "923336627157eac4408b0851bf01ed20940f5582", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyMzMzNjYyNzE1N2VhYzQ0MDhiMDg1MWJmMDFlZDIwOTQwZjU1ODI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-10-04T15:34:03Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-10-05T11:12:30Z"}, "message": "clean up misc. uses of get_dataptr/get_meta", "tree": {"sha": "752a54a1de0500695616d190a660388c88281ae9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/752a54a1de0500695616d190a660388c88281ae9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/923336627157eac4408b0851bf01ed20940f5582", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/923336627157eac4408b0851bf01ed20940f5582", "html_url": "https://github.com/rust-lang/rust/commit/923336627157eac4408b0851bf01ed20940f5582", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/923336627157eac4408b0851bf01ed20940f5582/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d54e0eb6be81bd1a880f44ed68a180275cfe329", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d54e0eb6be81bd1a880f44ed68a180275cfe329", "html_url": "https://github.com/rust-lang/rust/commit/6d54e0eb6be81bd1a880f44ed68a180275cfe329"}], "stats": {"total": 218, "additions": 82, "deletions": 136}, "files": [{"sha": "5d6dd27108b82922d5d78522a919a565536cd2ea", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 124, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/923336627157eac4408b0851bf01ed20940f5582/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923336627157eac4408b0851bf01ed20940f5582/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=923336627157eac4408b0851bf01ed20940f5582", "patch": "@@ -255,124 +255,6 @@ pub fn bin_op_to_fcmp_predicate(op: hir::BinOp_) -> llvm::RealPredicate {\n     }\n }\n \n-pub fn compare_fat_ptrs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    lhs_addr: ValueRef,\n-                                    lhs_extra: ValueRef,\n-                                    rhs_addr: ValueRef,\n-                                    rhs_extra: ValueRef,\n-                                    _t: Ty<'tcx>,\n-                                    op: hir::BinOp_,\n-                                    debug_loc: DebugLoc)\n-                                    -> ValueRef {\n-    match op {\n-        hir::BiEq => {\n-            let addr_eq = ICmp(bcx, llvm::IntEQ, lhs_addr, rhs_addr, debug_loc);\n-            let extra_eq = ICmp(bcx, llvm::IntEQ, lhs_extra, rhs_extra, debug_loc);\n-            And(bcx, addr_eq, extra_eq, debug_loc)\n-        }\n-        hir::BiNe => {\n-            let addr_eq = ICmp(bcx, llvm::IntNE, lhs_addr, rhs_addr, debug_loc);\n-            let extra_eq = ICmp(bcx, llvm::IntNE, lhs_extra, rhs_extra, debug_loc);\n-            Or(bcx, addr_eq, extra_eq, debug_loc)\n-        }\n-        hir::BiLe | hir::BiLt | hir::BiGe | hir::BiGt => {\n-            // a OP b ~ a.0 STRICT(OP) b.0 | (a.0 == b.0 && a.1 OP a.1)\n-            let (op, strict_op) = match op {\n-                hir::BiLt => (llvm::IntULT, llvm::IntULT),\n-                hir::BiLe => (llvm::IntULE, llvm::IntULT),\n-                hir::BiGt => (llvm::IntUGT, llvm::IntUGT),\n-                hir::BiGe => (llvm::IntUGE, llvm::IntUGT),\n-                _ => bug!(),\n-            };\n-\n-            let addr_eq = ICmp(bcx, llvm::IntEQ, lhs_addr, rhs_addr, debug_loc);\n-            let extra_op = ICmp(bcx, op, lhs_extra, rhs_extra, debug_loc);\n-            let addr_eq_extra_op = And(bcx, addr_eq, extra_op, debug_loc);\n-\n-            let addr_strict = ICmp(bcx, strict_op, lhs_addr, rhs_addr, debug_loc);\n-            Or(bcx, addr_strict, addr_eq_extra_op, debug_loc)\n-        }\n-        _ => {\n-            bug!(\"unexpected fat ptr binop\");\n-        }\n-    }\n-}\n-\n-pub fn compare_scalar_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                        lhs: ValueRef,\n-                                        rhs: ValueRef,\n-                                        t: Ty<'tcx>,\n-                                        op: hir::BinOp_,\n-                                        debug_loc: DebugLoc)\n-                                        -> ValueRef {\n-    match t.sty {\n-        ty::TyTuple(ref tys) if tys.is_empty() => {\n-            // We don't need to do actual comparisons for nil.\n-            // () == () holds but () < () does not.\n-            match op {\n-                hir::BiEq | hir::BiLe | hir::BiGe => return C_bool(bcx.ccx(), true),\n-                hir::BiNe | hir::BiLt | hir::BiGt => return C_bool(bcx.ccx(), false),\n-                // refinements would be nice\n-                _ => bug!(\"compare_scalar_types: must be a comparison operator\"),\n-            }\n-        }\n-        ty::TyBool => {\n-            // FIXME(#36856) -- using `from_immediate` forces these booleans into `i8`,\n-            // which works around some LLVM bugs\n-            ICmp(bcx,\n-                 bin_op_to_icmp_predicate(op, false),\n-                 from_immediate(bcx, lhs),\n-                 from_immediate(bcx, rhs),\n-                 debug_loc)\n-        }\n-        ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyUint(_) | ty::TyChar => {\n-            ICmp(bcx,\n-                 bin_op_to_icmp_predicate(op, false),\n-                 lhs,\n-                 rhs,\n-                 debug_loc)\n-        }\n-        ty::TyRawPtr(mt) if common::type_is_sized(bcx.tcx(), mt.ty) => {\n-            ICmp(bcx,\n-                 bin_op_to_icmp_predicate(op, false),\n-                 lhs,\n-                 rhs,\n-                 debug_loc)\n-        }\n-        ty::TyRawPtr(_) => {\n-            let lhs_addr = Load(bcx, GEPi(bcx, lhs, &[0, abi::FAT_PTR_ADDR]));\n-            let lhs_extra = Load(bcx, GEPi(bcx, lhs, &[0, abi::FAT_PTR_EXTRA]));\n-\n-            let rhs_addr = Load(bcx, GEPi(bcx, rhs, &[0, abi::FAT_PTR_ADDR]));\n-            let rhs_extra = Load(bcx, GEPi(bcx, rhs, &[0, abi::FAT_PTR_EXTRA]));\n-            compare_fat_ptrs(bcx,\n-                             lhs_addr,\n-                             lhs_extra,\n-                             rhs_addr,\n-                             rhs_extra,\n-                             t,\n-                             op,\n-                             debug_loc)\n-        }\n-        ty::TyInt(_) => {\n-            ICmp(bcx,\n-                 bin_op_to_icmp_predicate(op, true),\n-                 lhs,\n-                 rhs,\n-                 debug_loc)\n-        }\n-        ty::TyFloat(_) => {\n-            FCmp(bcx,\n-                 bin_op_to_fcmp_predicate(op),\n-                 lhs,\n-                 rhs,\n-                 debug_loc)\n-        }\n-        // Should never get here, because t is scalar.\n-        _ => bug!(\"non-scalar type passed to compare_scalar_types\"),\n-    }\n-}\n-\n pub fn compare_simd_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                       lhs: ValueRef,\n                                       rhs: ValueRef,\n@@ -693,12 +575,9 @@ pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t\n     debug!(\"store_ty: {:?} : {:?} <- {:?}\", Value(dst), t, Value(v));\n \n     if common::type_is_fat_ptr(cx.tcx(), t) {\n-        Store(cx,\n-              ExtractValue(cx, v, abi::FAT_PTR_ADDR),\n-              get_dataptr(cx, dst));\n-        Store(cx,\n-              ExtractValue(cx, v, abi::FAT_PTR_EXTRA),\n-              get_meta(cx, dst));\n+        let lladdr = ExtractValue(cx, v, abi::FAT_PTR_ADDR);\n+        let llextra = ExtractValue(cx, v, abi::FAT_PTR_EXTRA);\n+        store_fat_ptr(cx, lladdr, llextra, dst, t);\n     } else {\n         Store(cx, from_immediate(cx, v), dst);\n     }"}, {"sha": "c30a9dfdd9646055e610a02065785b7d46eea2a5", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 79, "deletions": 12, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/923336627157eac4408b0851bf01ed20940f5582/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923336627157eac4408b0851bf01ed20940f5582/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=923336627157eac4408b0851bf01ed20940f5582", "patch": "@@ -20,6 +20,7 @@ use common::{self, val_ty, C_bool, C_null, C_uint, BlockAndBuilder, Result};\n use debuginfo::DebugLoc;\n use adt;\n use machine;\n+use type_::Type;\n use type_of;\n use tvec;\n use value::Value;\n@@ -382,13 +383,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     match (lhs.val, rhs.val) {\n                         (OperandValue::Pair(lhs_addr, lhs_extra),\n                          OperandValue::Pair(rhs_addr, rhs_extra)) => {\n-                            bcx.with_block(|bcx| {\n-                                base::compare_fat_ptrs(bcx,\n-                                                       lhs_addr, lhs_extra,\n-                                                       rhs_addr, rhs_extra,\n-                                                       lhs.ty, op.to_hir_binop(),\n-                                                       debug_loc)\n-                            })\n+                            self.trans_fat_ptr_binop(&bcx, op,\n+                                                     lhs_addr, lhs_extra,\n+                                                     rhs_addr, rhs_extra,\n+                                                     lhs.ty)\n                         }\n                         _ => bug!()\n                     }\n@@ -485,6 +483,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                               input_ty: Ty<'tcx>) -> ValueRef {\n         let is_float = input_ty.is_fp();\n         let is_signed = input_ty.is_signed();\n+        let is_nil = input_ty.is_nil();\n+        let is_bool = input_ty.is_bool();\n         match op {\n             mir::BinOp::Add => if is_float {\n                 bcx.fadd(lhs, rhs)\n@@ -535,12 +535,79 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                    DebugLoc::None)\n                 })\n             }\n-            mir::BinOp::Eq | mir::BinOp::Lt | mir::BinOp::Gt |\n-            mir::BinOp::Ne | mir::BinOp::Le | mir::BinOp::Ge => {\n-                bcx.with_block(|bcx| {\n-                    base::compare_scalar_types(bcx, lhs, rhs, input_ty,\n-                                               op.to_hir_binop(), DebugLoc::None)\n+            mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt |\n+            mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => if is_nil {\n+                C_bool(bcx.ccx(), match op {\n+                    mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt => false,\n+                    mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => true,\n+                    _ => unreachable!()\n                 })\n+            } else if is_float {\n+                bcx.fcmp(\n+                    base::bin_op_to_fcmp_predicate(op.to_hir_binop()),\n+                    lhs, rhs\n+                )\n+            } else {\n+                let (lhs, rhs) = if is_bool {\n+                    // FIXME(#36856) -- extend the bools into `i8` because\n+                    // LLVM's i1 comparisons are broken.\n+                    (bcx.zext(lhs, Type::i8(bcx.ccx())),\n+                     bcx.zext(rhs, Type::i8(bcx.ccx())))\n+                } else {\n+                    (lhs, rhs)\n+                };\n+\n+                bcx.icmp(\n+                    base::bin_op_to_icmp_predicate(op.to_hir_binop(), is_signed),\n+                    lhs, rhs\n+                )\n+            }\n+        }\n+    }\n+\n+    pub fn trans_fat_ptr_binop(&mut self,\n+                               bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                               op: mir::BinOp,\n+                               lhs_addr: ValueRef,\n+                               lhs_extra: ValueRef,\n+                               rhs_addr: ValueRef,\n+                               rhs_extra: ValueRef,\n+                               _input_ty: Ty<'tcx>)\n+                               -> ValueRef {\n+        match op {\n+            mir::BinOp::Eq => {\n+                bcx.and(\n+                    bcx.icmp(llvm::IntEQ, lhs_addr, rhs_addr),\n+                    bcx.icmp(llvm::IntEQ, lhs_extra, rhs_extra)\n+                )\n+            }\n+            mir::BinOp::Ne => {\n+                bcx.or(\n+                    bcx.icmp(llvm::IntNE, lhs_addr, rhs_addr),\n+                    bcx.icmp(llvm::IntNE, lhs_extra, rhs_extra)\n+                )\n+            }\n+            mir::BinOp::Le | mir::BinOp::Lt |\n+            mir::BinOp::Ge | mir::BinOp::Gt => {\n+                // a OP b ~ a.0 STRICT(OP) b.0 | (a.0 == b.0 && a.1 OP a.1)\n+                let (op, strict_op) = match op {\n+                    mir::BinOp::Lt => (llvm::IntULT, llvm::IntULT),\n+                    mir::BinOp::Le => (llvm::IntULE, llvm::IntULT),\n+                    mir::BinOp::Gt => (llvm::IntUGT, llvm::IntUGT),\n+                    mir::BinOp::Ge => (llvm::IntUGE, llvm::IntUGT),\n+                    _ => bug!(),\n+                };\n+\n+                bcx.or(\n+                    bcx.icmp(strict_op, lhs_addr, rhs_addr),\n+                    bcx.and(\n+                        bcx.icmp(llvm::IntEQ, lhs_addr, rhs_addr),\n+                        bcx.icmp(op, lhs_extra, rhs_extra)\n+                    )\n+                )\n+            }\n+            _ => {\n+                bug!(\"unexpected fat ptr binop\");\n             }\n         }\n     }"}]}