{"sha": "f1d6f126effd61c21c2134751b75b6e8924d65e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxZDZmMTI2ZWZmZDYxYzIxYzIxMzQ3NTFiNzViNmU4OTI0ZDY1ZTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-12T01:50:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-12T01:50:45Z"}, "message": "Auto merge of #32200 - Manishearth:rollup, r=Manishearth\n\nRollup of 11 pull requests\n\n- Successful merges: #32137, #32158, #32171, #32174, #32178, #32179, #32180, #32181, #32183, #32186, #32197\n- Failed merges:", "tree": {"sha": "780c7a6e9898ef68bc2eb58dcc910a6971972189", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/780c7a6e9898ef68bc2eb58dcc910a6971972189"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1d6f126effd61c21c2134751b75b6e8924d65e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1d6f126effd61c21c2134751b75b6e8924d65e3", "html_url": "https://github.com/rust-lang/rust/commit/f1d6f126effd61c21c2134751b75b6e8924d65e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1d6f126effd61c21c2134751b75b6e8924d65e3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d68aadd27b1a5f4090d995bfe8076958d438479", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d68aadd27b1a5f4090d995bfe8076958d438479", "html_url": "https://github.com/rust-lang/rust/commit/0d68aadd27b1a5f4090d995bfe8076958d438479"}, {"sha": "10e4e9eec9faa935903e8a8b1dd2c2b13a8469e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/10e4e9eec9faa935903e8a8b1dd2c2b13a8469e6", "html_url": "https://github.com/rust-lang/rust/commit/10e4e9eec9faa935903e8a8b1dd2c2b13a8469e6"}], "stats": {"total": 348, "additions": 279, "deletions": 69}, "files": [{"sha": "c1fbfcda475597f804bd59eca1909e9236ddefb0", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=f1d6f126effd61c21c2134751b75b6e8924d65e3", "patch": "@@ -15,7 +15,7 @@ use std::io::prelude::*;\n use std::path::Path;\n \n pub struct ExpectedError {\n-    pub line: usize,\n+    pub line_num: usize,\n     pub kind: String,\n     pub msg: String,\n }\n@@ -53,15 +53,15 @@ pub fn load_errors(testfile: &Path, cfg: Option<&str>) -> Vec<ExpectedError> {\n \n     rdr.lines()\n        .enumerate()\n-       .filter_map(|(line_no, ln)| {\n+       .filter_map(|(line_num, line)| {\n            parse_expected(last_nonfollow_error,\n-                          line_no + 1,\n-                          &ln.unwrap(),\n+                          line_num + 1,\n+                          &line.unwrap(),\n                           &tag)\n                .map(|(which, error)| {\n                    match which {\n                        FollowPrevious(_) => {}\n-                       _ => last_nonfollow_error = Some(error.line),\n+                       _ => last_nonfollow_error = Some(error.line_num),\n                    }\n                    error\n                })\n@@ -91,23 +91,21 @@ fn parse_expected(last_nonfollow_error: Option<usize>,\n                      .skip_while(|c| !c.is_whitespace())\n                      .collect::<String>().trim().to_owned();\n \n-    let (which, line) = if follow {\n+    let (which, line_num) = if follow {\n         assert!(adjusts == 0, \"use either //~| or //~^, not both.\");\n-        let line = last_nonfollow_error.unwrap_or_else(|| {\n-            panic!(\"encountered //~| without preceding //~^ line.\")\n-        });\n-        (FollowPrevious(line), line)\n+        let line_num = last_nonfollow_error.expect(\"encountered //~| without \\\n+                                                    preceding //~^ line.\");\n+        (FollowPrevious(line_num), line_num)\n     } else {\n         let which =\n             if adjusts > 0 { AdjustBackward(adjusts) } else { ThisLine };\n-        let line = line_num - adjusts;\n-        (which, line)\n+        let line_num = line_num - adjusts;\n+        (which, line_num)\n     };\n \n     debug!(\"line={} tag={:?} which={:?} kind={:?} msg={:?}\",\n            line_num, tag, which, kind, msg);\n-\n-    Some((which, ExpectedError { line: line,\n+    Some((which, ExpectedError { line_num: line_num,\n                                  kind: kind,\n                                  msg: msg, }))\n }"}, {"sha": "8c3ee3fb5f4b6f373da59026ccf244da87bb2bd8", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=f1d6f126effd61c21c2134751b75b6e8924d65e3", "patch": "@@ -1004,7 +1004,7 @@ fn check_expected_errors(revision: Option<&str>,\n     }\n \n     let prefixes = expected_errors.iter().map(|ee| {\n-        let expected = format!(\"{}:{}:\", testpaths.file.display(), ee.line);\n+        let expected = format!(\"{}:{}:\", testpaths.file.display(), ee.line_num);\n         // On windows just translate all '\\' path separators to '/'\n         expected.replace(r\"\\\", \"/\")\n     }).collect::<Vec<String>>();\n@@ -1076,7 +1076,7 @@ fn check_expected_errors(revision: Option<&str>,\n         if !flag {\n             let ee = &expected_errors[i];\n             error(revision, &format!(\"expected {} on line {} not found: {}\",\n-                                     ee.kind, ee.line, ee.msg));\n+                                     ee.kind, ee.line_num, ee.msg));\n             not_found += 1;\n         }\n     }"}, {"sha": "b0d4c6d6dd242bced93bda01961b4e7a27900c93", "filename": "src/doc/book/getting-started.md", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Fdoc%2Fbook%2Fgetting-started.md", "raw_url": "https://github.com/rust-lang/rust/raw/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Fdoc%2Fbook%2Fgetting-started.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fgetting-started.md?ref=f1d6f126effd61c21c2134751b75b6e8924d65e3", "patch": "@@ -119,19 +119,7 @@ This will download a script, and start the installation. If it all goes well,\n you\u2019ll see this appear:\n \n ```text\n-Welcome to Rust.\n-\n-This script will download the Rust compiler and its package manager, Cargo, and\n-install them to /usr/local. You may install elsewhere by running this script\n-with the --prefix=<path> option.\n-\n-The installer will run under \u2018sudo\u2019 and may ask you for your password. If you do\n-not want the script to run \u2018sudo\u2019 then pass it the --disable-sudo flag.\n-\n-You may uninstall later by running /usr/local/lib/rustlib/uninstall.sh,\n-or by running this script again with the --uninstall flag.\n-\n-Continue? (y/N)\n+Rust is ready to roll.\n ```\n \n From here, press `y` for \u2018yes\u2019, and then follow the rest of the prompts."}, {"sha": "ba317334cfa0b55235b9205d2563b340d6e92461", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=f1d6f126effd61c21c2134751b75b6e8924d65e3", "patch": "@@ -167,6 +167,49 @@ use vec::{self, Vec};\n /// item's ordering relative to any other item, as determined by the `Ord`\n /// trait, changes while it is in the heap. This is normally only possible\n /// through `Cell`, `RefCell`, global state, I/O, or unsafe code.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::collections::BinaryHeap;\n+///\n+/// // type inference lets us omit an explicit type signature (which\n+/// // would be `BinaryHeap<i32>` in this example).\n+/// let mut heap = BinaryHeap::new();\n+///\n+/// // We can use peek to look at the next item in the heap. In this case,\n+/// // there's no items in there yet so we get None.\n+/// assert_eq!(heap.peek(), None);\n+///\n+/// // Let's add some scores...\n+/// heap.push(1);\n+/// heap.push(5);\n+/// heap.push(2);\n+///\n+/// // Now peek shows the most important item in the heap.\n+/// assert_eq!(heap.peek(), Some(&5));\n+///\n+/// // We can check the length of a heap.\n+/// assert_eq!(heap.len(), 3);\n+///\n+/// // We can iterate over the items in the heap, although they are returned in\n+/// // a random order.\n+/// for x in heap.iter() {\n+///     println!(\"{}\", x);\n+/// }\n+///\n+/// // If we instead pop these scores, they should come back in order.\n+/// assert_eq!(heap.pop(), Some(5));\n+/// assert_eq!(heap.pop(), Some(2));\n+/// assert_eq!(heap.pop(), Some(1));\n+/// assert_eq!(heap.pop(), None);\n+///\n+/// // We can clear the heap of any remaining items.\n+/// heap.clear();\n+///\n+/// // The heap should now be empty.\n+/// assert!(heap.is_empty())\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BinaryHeap<T> {\n     data: Vec<T>,\n@@ -203,6 +246,8 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::new();\n@@ -220,6 +265,8 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::with_capacity(10);\n@@ -235,6 +282,8 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n     /// let heap = BinaryHeap::from(vec![1, 2, 3, 4]);\n@@ -253,6 +302,8 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::new();\n@@ -273,6 +324,8 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::with_capacity(100);\n@@ -297,6 +350,8 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::new();\n@@ -318,6 +373,8 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::new();\n@@ -331,6 +388,19 @@ impl<T: Ord> BinaryHeap<T> {\n     }\n \n     /// Discards as much additional capacity as possible.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap: BinaryHeap<i32> = BinaryHeap::with_capacity(100);\n+    ///\n+    /// assert!(heap.capacity() >= 100);\n+    /// heap.shrink_to_fit();\n+    /// assert!(heap.capacity() == 0);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         self.data.shrink_to_fit();\n@@ -341,6 +411,8 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::from(vec![1, 3]);\n@@ -364,6 +436,8 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::new();\n@@ -386,6 +460,8 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// #![feature(binary_heap_extras)]\n     ///\n@@ -424,6 +500,8 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// #![feature(binary_heap_extras)]\n     ///\n@@ -454,6 +532,8 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n     /// let heap = BinaryHeap::from(vec![1, 2, 3, 4, 5, 6, 7]);\n@@ -474,6 +554,8 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n@@ -571,12 +653,40 @@ impl<T: Ord> BinaryHeap<T> {\n     }\n \n     /// Returns the length of the binary heap.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let heap = BinaryHeap::from(vec![1, 3]);\n+    ///\n+    /// assert_eq!(heap.len(), 2);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize {\n         self.data.len()\n     }\n \n     /// Checks if the binary heap is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap = BinaryHeap::new();\n+    ///\n+    /// assert!(heap.is_empty());\n+    ///\n+    /// heap.push(3);\n+    /// heap.push(5);\n+    /// heap.push(1);\n+    ///\n+    /// assert!(!heap.is_empty());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n         self.len() == 0\n@@ -585,13 +695,45 @@ impl<T: Ord> BinaryHeap<T> {\n     /// Clears the binary heap, returning an iterator over the removed elements.\n     ///\n     /// The elements are removed in arbitrary order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap = BinaryHeap::from(vec![1, 3]);\n+    ///\n+    /// assert!(!heap.is_empty());\n+    ///\n+    /// for x in heap.drain() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// assert!(heap.is_empty());\n+    /// ```\n     #[inline]\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain(&mut self) -> Drain<T> {\n         Drain { iter: self.data.drain(..) }\n     }\n \n     /// Drops all items from the binary heap.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap = BinaryHeap::from(vec![1, 3]);\n+    ///\n+    /// assert!(!heap.is_empty());\n+    ///\n+    /// heap.clear();\n+    ///\n+    /// assert!(heap.is_empty());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         self.drain();\n@@ -809,6 +951,8 @@ impl<T: Ord> IntoIterator for BinaryHeap<T> {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n     /// let heap = BinaryHeap::from(vec![1, 2, 3, 4]);"}, {"sha": "233e556b27ee8c608b85284dfb069bb9f2415880", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=f1d6f126effd61c21c2134751b75b6e8924d65e3", "patch": "@@ -535,6 +535,16 @@ fn slice_index_order_fail(index: usize, end: usize) -> ! {\n \n // FIXME implement indexing with inclusive ranges\n \n+/// Implements slicing with syntax `&self[begin .. end]`.\n+///\n+/// Returns a slice of self for the index range [`begin`..`end`).\n+///\n+/// This operation is `O(1)`.\n+///\n+/// # Panics\n+///\n+/// Requires that `begin <= end` and `end <= self.len()`,\n+/// otherwise slicing will panic.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::Range<usize>> for [T] {\n     type Output = [T];\n@@ -554,6 +564,13 @@ impl<T> ops::Index<ops::Range<usize>> for [T] {\n         }\n     }\n }\n+\n+/// Implements slicing with syntax `&self[.. end]`.\n+///\n+/// Returns a slice of self from the beginning until but not including\n+/// the index `end`.\n+///\n+/// Equivalent to `&self[0 .. end]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeTo<usize>> for [T] {\n     type Output = [T];\n@@ -563,6 +580,12 @@ impl<T> ops::Index<ops::RangeTo<usize>> for [T] {\n         self.index(0 .. index.end)\n     }\n }\n+\n+/// Implements slicing with syntax `&self[begin ..]`.\n+///\n+/// Returns a slice of self from and including the index `begin` until the end.\n+///\n+/// Equivalent to `&self[begin .. self.len()]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeFrom<usize>> for [T] {\n     type Output = [T];\n@@ -572,6 +595,12 @@ impl<T> ops::Index<ops::RangeFrom<usize>> for [T] {\n         self.index(index.start .. self.len())\n     }\n }\n+\n+/// Implements slicing with syntax `&self[..]`.\n+///\n+/// Returns a slice of the whole slice. This operation can not panic.\n+///\n+/// Equivalent to `&self[0 .. self.len()]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<RangeFull> for [T] {\n     type Output = [T];\n@@ -608,6 +637,16 @@ impl<T> ops::Index<ops::RangeToInclusive<usize>> for [T] {\n     }\n }\n \n+/// Implements mutable slicing with syntax `&mut self[begin .. end]`.\n+///\n+/// Returns a slice of self for the index range [`begin`..`end`).\n+///\n+/// This operation is `O(1)`.\n+///\n+/// # Panics\n+///\n+/// Requires that `begin <= end` and `end <= self.len()`,\n+/// otherwise slicing will panic.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::Range<usize>> for [T] {\n     #[inline]\n@@ -625,13 +664,26 @@ impl<T> ops::IndexMut<ops::Range<usize>> for [T] {\n         }\n     }\n }\n+\n+/// Implements mutable slicing with syntax `&mut self[.. end]`.\n+///\n+/// Returns a slice of self from the beginning until but not including\n+/// the index `end`.\n+///\n+/// Equivalent to `&mut self[0 .. end]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeTo<usize>> for [T] {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n         self.index_mut(0 .. index.end)\n     }\n }\n+\n+/// Implements mutable slicing with syntax `&mut self[begin ..]`.\n+///\n+/// Returns a slice of self from and including the index `begin` until the end.\n+///\n+/// Equivalent to `&mut self[begin .. self.len()]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFrom<usize>> for [T] {\n     #[inline]\n@@ -640,6 +692,12 @@ impl<T> ops::IndexMut<ops::RangeFrom<usize>> for [T] {\n         self.index_mut(index.start .. len)\n     }\n }\n+\n+/// Implements mutable slicing with syntax `&mut self[..]`.\n+///\n+/// Returns a slice of the whole slice. This operation can not panic.\n+///\n+/// Equivalent to `&mut self[0 .. self.len()]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<RangeFull> for [T] {\n     #[inline]"}, {"sha": "e71e61bda5efdec258bf7a5d81f302d17b66ba38", "filename": "src/libcoretest/fmt/builders.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Flibcoretest%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Flibcoretest%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fbuilders.rs?ref=f1d6f126effd61c21c2134751b75b6e8924d65e3", "patch": "@@ -53,7 +53,7 @@ mod debug_struct {\n             fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n                 fmt.debug_struct(\"Foo\")\n                     .field(\"bar\", &true)\n-                    .field(\"baz\", &format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .field(\"baz\", &format_args!(\"{}/{}\", 10, 20))\n                     .finish()\n             }\n         }\n@@ -75,7 +75,7 @@ mod debug_struct {\n             fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n                 fmt.debug_struct(\"Foo\")\n                     .field(\"bar\", &true)\n-                    .field(\"baz\", &format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .field(\"baz\", &format_args!(\"{}/{}\", 10, 20))\n                     .finish()\n             }\n         }\n@@ -150,7 +150,7 @@ mod debug_tuple {\n             fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n                 fmt.debug_tuple(\"Foo\")\n                     .field(&true)\n-                    .field(&format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .field(&format_args!(\"{}/{}\", 10, 20))\n                     .finish()\n             }\n         }\n@@ -172,7 +172,7 @@ mod debug_tuple {\n             fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n                 fmt.debug_tuple(\"Foo\")\n                     .field(&true)\n-                    .field(&format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .field(&format_args!(\"{}/{}\", 10, 20))\n                     .finish()\n             }\n         }\n@@ -247,7 +247,7 @@ mod debug_map {\n             fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n                 fmt.debug_map()\n                     .entry(&\"bar\", &true)\n-                    .entry(&10i32, &format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .entry(&10, &format_args!(\"{}/{}\", 10, 20))\n                     .finish()\n             }\n         }\n@@ -269,7 +269,7 @@ mod debug_map {\n             fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n                 fmt.debug_map()\n                     .entry(&\"bar\", &true)\n-                    .entry(&10i32, &format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .entry(&10, &format_args!(\"{}/{}\", 10, 20))\n                     .finish()\n             }\n         }\n@@ -348,7 +348,7 @@ mod debug_set {\n             fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n                 fmt.debug_set()\n                     .entry(&true)\n-                    .entry(&format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .entry(&format_args!(\"{}/{}\", 10, 20))\n                     .finish()\n             }\n         }\n@@ -370,7 +370,7 @@ mod debug_set {\n             fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n                 fmt.debug_set()\n                     .entry(&true)\n-                    .entry(&format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .entry(&format_args!(\"{}/{}\", 10, 20))\n                     .finish()\n             }\n         }\n@@ -445,7 +445,7 @@ mod debug_list {\n             fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n                 fmt.debug_list()\n                     .entry(&true)\n-                    .entry(&format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .entry(&format_args!(\"{}/{}\", 10, 20))\n                     .finish()\n             }\n         }\n@@ -467,7 +467,7 @@ mod debug_list {\n             fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n                 fmt.debug_list()\n                     .entry(&true)\n-                    .entry(&format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .entry(&format_args!(\"{}/{}\", 10, 20))\n                     .finish()\n             }\n         }"}, {"sha": "6c0cb03b5f775db269b4de142ab681b201ce7f5b", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=f1d6f126effd61c21c2134751b75b6e8924d65e3", "patch": "@@ -677,7 +677,7 @@ fn test_rev() {\n \n #[test]\n fn test_cloned() {\n-    let xs = [2u8, 4, 6, 8];\n+    let xs = [2, 4, 6, 8];\n \n     let mut it = xs.iter().cloned();\n     assert_eq!(it.len(), 4);\n@@ -861,8 +861,8 @@ fn test_range() {\n     assert_eq!((-10..-1).size_hint(), (9, Some(9)));\n     assert_eq!((-1..-10).size_hint(), (0, Some(0)));\n \n-    assert_eq!((-70..58i8).size_hint(), (128, Some(128)));\n-    assert_eq!((-128..127i8).size_hint(), (255, Some(255)));\n+    assert_eq!((-70..58).size_hint(), (128, Some(128)));\n+    assert_eq!((-128..127).size_hint(), (255, Some(255)));\n     assert_eq!((-2..isize::MAX).size_hint(),\n                (isize::MAX as usize + 2, Some(isize::MAX as usize + 2)));\n }\n@@ -1013,7 +1013,7 @@ fn bench_max_by_key2(b: &mut Bencher) {\n         array.iter().enumerate().max_by_key(|&(_, item)| item).unwrap().0\n     }\n \n-    let mut data = vec![0i32; 1638];\n+    let mut data = vec![0; 1638];\n     data[514] = 9999;\n \n     b.iter(|| max_index_iter(&data));"}, {"sha": "8d791283ab87ebd22846667445f7414dc53a60b9", "filename": "src/libcoretest/num/int_macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint_macros.rs?ref=f1d6f126effd61c21c2134751b75b6e8924d65e3", "patch": "@@ -208,11 +208,11 @@ mod tests {\n     fn test_pow() {\n         let mut r = 2 as $T;\n \n-        assert_eq!(r.pow(2u32), 4 as $T);\n-        assert_eq!(r.pow(0u32), 1 as $T);\n+        assert_eq!(r.pow(2), 4 as $T);\n+        assert_eq!(r.pow(0), 1 as $T);\n         r = -2 as $T;\n-        assert_eq!(r.pow(2u32), 4 as $T);\n-        assert_eq!(r.pow(3u32), -8 as $T);\n+        assert_eq!(r.pow(2), 4 as $T);\n+        assert_eq!(r.pow(3), -8 as $T);\n     }\n }\n "}, {"sha": "11c1bd667fb366d2da3709d99414becfcdadb4b0", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=f1d6f126effd61c21c2134751b75b6e8924d65e3", "patch": "@@ -99,8 +99,8 @@ mod tests {\n \n     #[test]\n     fn test_leading_plus() {\n-        assert_eq!(\"+127\".parse::<u8>().ok(), Some(127u8));\n-        assert_eq!(\"+9223372036854775807\".parse::<i64>().ok(), Some(9223372036854775807i64));\n+        assert_eq!(\"+127\".parse::<u8>().ok(), Some(127));\n+        assert_eq!(\"+9223372036854775807\".parse::<i64>().ok(), Some(9223372036854775807));\n     }\n \n     #[test]"}, {"sha": "51b0655f680f6186857c7e07cdedaa640326ab16", "filename": "src/libcoretest/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=f1d6f126effd61c21c2134751b75b6e8924d65e3", "patch": "@@ -251,7 +251,7 @@ fn test_collect() {\n \n #[test]\n fn test_cloned() {\n-    let val = 1u32;\n+    let val = 1;\n     let val_ref = &val;\n     let opt_none: Option<&'static u32> = None;\n     let opt_ref = Some(&val);\n@@ -263,10 +263,10 @@ fn test_cloned() {\n \n     // Immutable ref works\n     assert_eq!(opt_ref.clone(), Some(&val));\n-    assert_eq!(opt_ref.cloned(), Some(1u32));\n+    assert_eq!(opt_ref.cloned(), Some(1));\n \n     // Double Immutable ref works\n     assert_eq!(opt_ref_ref.clone(), Some(&val_ref));\n     assert_eq!(opt_ref_ref.clone().cloned(), Some(&val));\n-    assert_eq!(opt_ref_ref.cloned().cloned(), Some(1u32));\n+    assert_eq!(opt_ref_ref.cloned().cloned(), Some(1));\n }"}, {"sha": "4ceac287d19dfd463e9e96840acb51a12a347f5f", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=f1d6f126effd61c21c2134751b75b6e8924d65e3", "patch": "@@ -351,15 +351,9 @@ impl<'v> Visitor<'v> for LifeSeeder {\n             }\n             hir::ItemImpl(_, _, _, ref opt_trait, _, ref impl_items) => {\n                 for impl_item in impl_items {\n-                    match impl_item.node {\n-                        hir::ImplItemKind::Const(..) |\n-                        hir::ImplItemKind::Method(..) => {\n-                            if opt_trait.is_some() ||\n-                                    has_allow_dead_code_or_lang_attr(&impl_item.attrs) {\n-                                self.worklist.push(impl_item.id);\n-                            }\n-                        }\n-                        hir::ImplItemKind::Type(_) => {}\n+                    if opt_trait.is_some() ||\n+                            has_allow_dead_code_or_lang_attr(&impl_item.attrs) {\n+                        self.worklist.push(impl_item.id);\n                     }\n                 }\n             }"}, {"sha": "cc7c0f7865ea56de6965f5314d231a597a2d9f0b", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=f1d6f126effd61c21c2134751b75b6e8924d65e3", "patch": "@@ -737,7 +737,7 @@ pub enum Expr_ {\n     ExprBinary(BinOp, P<Expr>, P<Expr>),\n     /// A unary operation (For example: `!x`, `*x`)\n     ExprUnary(UnOp, P<Expr>),\n-    /// A literal (For example: `1u8`, `\"foo\"`)\n+    /// A literal (For example: `1`, `\"foo\"`)\n     ExprLit(P<Lit>),\n     /// A cast (`foo as f64`)\n     ExprCast(P<Expr>, P<Ty>),\n@@ -804,7 +804,7 @@ pub enum Expr_ {\n \n     /// A vector literal constructed from one repeated element.\n     ///\n-    /// For example, `[1u8; 5]`. The first expression is the element\n+    /// For example, `[1; 5]`. The first expression is the element\n     /// to be repeated; the second is the number of times to repeat it.\n     ExprRepeat(P<Expr>, P<Expr>),\n }"}, {"sha": "f376b42fbf9681630a6ceec0165fbc33c6ff7a98", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=f1d6f126effd61c21c2134751b75b6e8924d65e3", "patch": "@@ -379,7 +379,7 @@ impl Test {\n \n fn main() {\n     let x = Test;\n-    let v = &[0i32];\n+    let v = &[0];\n \n     x.method::<i32, i32>(v); // error: only one type parameter is expected!\n }\n@@ -398,7 +398,7 @@ impl Test {\n \n fn main() {\n     let x = Test;\n-    let v = &[0i32];\n+    let v = &[0];\n \n     x.method::<i32>(v); // OK, we're good!\n }\n@@ -901,7 +901,7 @@ Example of erroneous code:\n ```compile_fail\n enum Foo { FirstValue(i32) };\n \n-let u = Foo::FirstValue { value: 0i32 }; // error: Foo::FirstValue\n+let u = Foo::FirstValue { value: 0 }; // error: Foo::FirstValue\n                                          // isn't a structure!\n // or even simpler, if the name doesn't refer to a structure at all.\n let t = u32 { value: 4 }; // error: `u32` does not name a structure."}, {"sha": "d979aa264af81e44534f63916ac51e0c10c27b8c", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=f1d6f126effd61c21c2134751b75b6e8924d65e3", "patch": "@@ -22,7 +22,7 @@ use sys::os_str::{Buf, Slice};\n use sys_common::{AsInner, IntoInner, FromInner};\n \n /// A type that can represent owned, mutable platform-native strings, but is\n-/// cheaply interconvertable with Rust strings.\n+/// cheaply inter-convertible with Rust strings.\n ///\n /// The need for this type arises from the fact that:\n ///\n@@ -272,7 +272,7 @@ impl OsStr {\n         unsafe { mem::transmute(inner) }\n     }\n \n-    /// Yields a `&str` slice if the `OsStr` is valid unicode.\n+    /// Yields a `&str` slice if the `OsStr` is valid Unicode.\n     ///\n     /// This conversion may entail doing a check for UTF-8 validity.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -301,7 +301,7 @@ impl OsStr {\n     /// On Unix systems, this is a no-op.\n     ///\n     /// On Windows systems, this returns `None` unless the `OsStr` is\n-    /// valid unicode, in which case it produces UTF-8-encoded\n+    /// valid Unicode, in which case it produces UTF-8-encoded\n     /// data. This may entail checking validity.\n     #[unstable(feature = \"convert\", reason = \"recently added\", issue = \"27704\")]\n     #[rustc_deprecated(reason = \"RFC was closed, hides subtle Windows semantics\","}, {"sha": "3f9d8e5e9ec1b90eb44b4ab625026f645bdd0ee2", "filename": "src/snapshots.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=f1d6f126effd61c21c2134751b75b6e8924d65e3", "patch": "@@ -6,6 +6,7 @@ S 2016-02-17 4d3eebf\n   winnt-i386 0c336d794a65f8e285c121866c7d59aa2dd0d1e1\n   winnt-x86_64 27e75b1bf99770b3564bcebd7f3230be01135a92\n   openbsd-x86_64 ac957c6b84de2bd67f01df085d9ea515f96e22f3\n+  freebsd-x86_64 395adf223f3f25514c9dffecb524f493c42a0e5d\n \n S 2015-12-18 3391630\n   bitrig-x86_64 6476e1562df02389b55553b4c88b1f4fd121cd40"}, {"sha": "1ae078ba2211a651c9b25937cee584483bea92bb", "filename": "src/test/run-pass/lint-dead-code-associated-type.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Ftest%2Frun-pass%2Flint-dead-code-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d6f126effd61c21c2134751b75b6e8924d65e3/src%2Ftest%2Frun-pass%2Flint-dead-code-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flint-dead-code-associated-type.rs?ref=f1d6f126effd61c21c2134751b75b6e8924d65e3", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(dead_code)]\n+\n+trait Foo {\n+    type Bar;\n+}\n+\n+struct Used;\n+\n+struct Ex;\n+\n+impl Foo for Ex {\n+    type Bar = Used;\n+}\n+\n+pub fn main() {\n+    let _x = Ex;\n+}"}]}