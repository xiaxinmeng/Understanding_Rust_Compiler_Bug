{"sha": "285cb8e6d8e4802c3c36d6c00d9c3752c2cc13bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4NWNiOGU2ZDhlNDgwMmMzYzM2ZDZjMDBkOWMzNzUyYzJjYzEzYmQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-17T09:49:38Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-17T09:49:38Z"}, "message": "Rollup merge of #23399 - tbu-:pr_libflate_error, r=huonw\n\n This removes the error case of the compression functions, the only errors that\ncan occur are incorrect parameters or an out-of-memory condition, both of which\nare handled with panics in Rust.\n\nAlso introduces an extensible `Error` type instead of returning an `Option`.\nThe type implements a destructor so you can't destructure it.", "tree": {"sha": "4a029ffc2db5697e5962533ea3344e6985325113", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a029ffc2db5697e5962533ea3344e6985325113"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/285cb8e6d8e4802c3c36d6c00d9c3752c2cc13bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/285cb8e6d8e4802c3c36d6c00d9c3752c2cc13bd", "html_url": "https://github.com/rust-lang/rust/commit/285cb8e6d8e4802c3c36d6c00d9c3752c2cc13bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/285cb8e6d8e4802c3c36d6c00d9c3752c2cc13bd/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "883551b1d739993dffcba01ee9ea3237cf406d9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/883551b1d739993dffcba01ee9ea3237cf406d9a", "html_url": "https://github.com/rust-lang/rust/commit/883551b1d739993dffcba01ee9ea3237cf406d9a"}, {"sha": "1b894c65de8e5bf03225afa29664045f5622e6d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b894c65de8e5bf03225afa29664045f5622e6d7", "html_url": "https://github.com/rust-lang/rust/commit/1b894c65de8e5bf03225afa29664045f5622e6d7"}], "stats": {"total": 92, "additions": 52, "deletions": 40}, "files": [{"sha": "695c71c73eded0f14773c417e8659fb1806c5d74", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 44, "deletions": 24, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/285cb8e6d8e4802c3c36d6c00d9c3752c2cc13bd/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/285cb8e6d8e4802c3c36d6c00d9c3752c2cc13bd/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=285cb8e6d8e4802c3c36d6c00d9c3752c2cc13bd", "patch": "@@ -25,7 +25,6 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![feature(int_uint)]\n #![feature(libc)]\n #![feature(staged_api)]\n #![feature(unique)]\n@@ -35,13 +34,33 @@\n extern crate libc;\n \n use libc::{c_void, size_t, c_int};\n+use std::fmt;\n use std::ops::Deref;\n use std::ptr::Unique;\n use std::slice;\n \n+#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd)]\n+pub struct Error {\n+    _unused: (),\n+}\n+\n+impl Error {\n+    fn new() -> Error {\n+        Error {\n+            _unused: (),\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"decompression error\".fmt(f)\n+    }\n+}\n+\n pub struct Bytes {\n     ptr: Unique<u8>,\n-    len: uint,\n+    len: usize,\n }\n \n impl Deref for Bytes {\n@@ -78,55 +97,56 @@ const LZ_NORM: c_int = 0x80;  // LZ with 128 probes, \"normal\"\n const TINFL_FLAG_PARSE_ZLIB_HEADER: c_int = 0x1; // parse zlib header and adler32 checksum\n const TDEFL_WRITE_ZLIB_HEADER: c_int = 0x01000; // write zlib header and adler32 checksum\n \n-fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<Bytes> {\n+fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> Bytes {\n     unsafe {\n-        let mut outsz : size_t = 0;\n+        let mut outsz: size_t = 0;\n         let res = tdefl_compress_mem_to_heap(bytes.as_ptr() as *const _,\n                                              bytes.len() as size_t,\n                                              &mut outsz,\n                                              flags);\n-        if !res.is_null() {\n-            let res = Unique::new(res as *mut u8);\n-            Some(Bytes { ptr: res, len: outsz as uint })\n-        } else {\n-            None\n+        assert!(!res.is_null());\n+        Bytes {\n+            ptr: Unique::new(res as *mut u8),\n+            len: outsz as usize,\n         }\n     }\n }\n \n /// Compress a buffer, without writing any sort of header on the output.\n-pub fn deflate_bytes(bytes: &[u8]) -> Option<Bytes> {\n+pub fn deflate_bytes(bytes: &[u8]) -> Bytes {\n     deflate_bytes_internal(bytes, LZ_NORM)\n }\n \n /// Compress a buffer, using a header that zlib can understand.\n-pub fn deflate_bytes_zlib(bytes: &[u8]) -> Option<Bytes> {\n+pub fn deflate_bytes_zlib(bytes: &[u8]) -> Bytes {\n     deflate_bytes_internal(bytes, LZ_NORM | TDEFL_WRITE_ZLIB_HEADER)\n }\n \n-fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<Bytes> {\n+fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> Result<Bytes,Error> {\n     unsafe {\n-        let mut outsz : size_t = 0;\n+        let mut outsz: size_t = 0;\n         let res = tinfl_decompress_mem_to_heap(bytes.as_ptr() as *const _,\n                                                bytes.len() as size_t,\n                                                &mut outsz,\n                                                flags);\n         if !res.is_null() {\n-            let res = Unique::new(res as *mut u8);\n-            Some(Bytes { ptr: res, len: outsz as uint })\n+            Ok(Bytes {\n+                ptr: Unique::new(res as *mut u8),\n+                len: outsz as usize,\n+            })\n         } else {\n-            None\n+            Err(Error::new())\n         }\n     }\n }\n \n /// Decompress a buffer, without parsing any sort of header on the input.\n-pub fn inflate_bytes(bytes: &[u8]) -> Option<Bytes> {\n+pub fn inflate_bytes(bytes: &[u8]) -> Result<Bytes,Error> {\n     inflate_bytes_internal(bytes, 0)\n }\n \n /// Decompress a buffer that starts with a zlib header.\n-pub fn inflate_bytes_zlib(bytes: &[u8]) -> Option<Bytes> {\n+pub fn inflate_bytes_zlib(bytes: &[u8]) -> Result<Bytes,Error> {\n     inflate_bytes_internal(bytes, TINFL_FLAG_PARSE_ZLIB_HEADER)\n }\n \n@@ -140,7 +160,7 @@ mod tests {\n     #[test]\n     fn test_flate_round_trip() {\n         let mut r = rand::thread_rng();\n-        let mut words = vec!();\n+        let mut words = vec![];\n         for _ in 0..20 {\n             let range = r.gen_range(1, 10);\n             let v = r.gen_iter::<u8>().take(range).collect::<Vec<u8>>();\n@@ -153,8 +173,8 @@ mod tests {\n             }\n             debug!(\"de/inflate of {} bytes of random word-sequences\",\n                    input.len());\n-            let cmp = deflate_bytes(&input).expect(\"deflation failed\");\n-            let out = inflate_bytes(&cmp).expect(\"inflation failed\");\n+            let cmp = deflate_bytes(&input);\n+            let out = inflate_bytes(&cmp).unwrap();\n             debug!(\"{} bytes deflated to {} ({:.1}% size)\",\n                    input.len(), cmp.len(),\n                    100.0 * ((cmp.len() as f64) / (input.len() as f64)));\n@@ -164,9 +184,9 @@ mod tests {\n \n     #[test]\n     fn test_zlib_flate() {\n-        let bytes = vec!(1, 2, 3, 4, 5);\n-        let deflated = deflate_bytes(&bytes).expect(\"deflation failed\");\n-        let inflated = inflate_bytes(&deflated).expect(\"inflation failed\");\n+        let bytes = vec![1, 2, 3, 4, 5];\n+        let deflated = deflate_bytes(&bytes);\n+        let inflated = inflate_bytes(&deflated).unwrap();\n         assert_eq!(&*inflated, &*bytes);\n     }\n }"}, {"sha": "e466dc8a3a0181db8a7a3b99983fdffe748e5ea4", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/285cb8e6d8e4802c3c36d6c00d9c3752c2cc13bd/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/285cb8e6d8e4802c3c36d6c00d9c3752c2cc13bd/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=285cb8e6d8e4802c3c36d6c00d9c3752c2cc13bd", "patch": "@@ -784,8 +784,8 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n                        csz - vlen);\n                 let bytes = slice::from_raw_parts(cvbuf1, csz - vlen);\n                 match flate::inflate_bytes(bytes) {\n-                    Some(inflated) => return Ok(MetadataVec(inflated)),\n-                    None => {}\n+                    Ok(inflated) => return Ok(MetadataVec(inflated)),\n+                    Err(_) => {}\n                 }\n             }\n             llvm::LLVMMoveToNextSection(si.llsi);"}, {"sha": "34a23f3efac42c3011bbb2773d05f58f01aea631", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/285cb8e6d8e4802c3c36d6c00d9c3752c2cc13bd/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/285cb8e6d8e4802c3c36d6c00d9c3752c2cc13bd/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=285cb8e6d8e4802c3c36d6c00d9c3752c2cc13bd", "patch": "@@ -626,12 +626,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                                                  e))\n                 }\n \n-                let bc_data_deflated = match flate::deflate_bytes(&bc_data[..]) {\n-                    Some(compressed) => compressed,\n-                    None => sess.fatal(&format!(\"failed to compress bytecode \\\n-                                                 from {}\",\n-                                                 bc_filename.display()))\n-                };\n+                let bc_data_deflated = flate::deflate_bytes(&bc_data[..]);\n \n                 let mut bc_file_deflated = match fs::File::create(&bc_deflated_filename) {\n                     Ok(file) => file,"}, {"sha": "a3ab863c4eca475e026792ccb6ec0e1ff066cad6", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/285cb8e6d8e4802c3c36d6c00d9c3752c2cc13bd/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/285cb8e6d8e4802c3c36d6c00d9c3752c2cc13bd/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=285cb8e6d8e4802c3c36d6c00d9c3752c2cc13bd", "patch": "@@ -95,8 +95,8 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                             (link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint)];\n \n                         match flate::inflate_bytes(compressed_data) {\n-                            Some(inflated) => inflated,\n-                            None => {\n+                            Ok(inflated) => inflated,\n+                            Err(_) => {\n                                 sess.fatal(&format!(\"failed to decompress bc of `{}`\",\n                                                    name))\n                             }\n@@ -111,8 +111,8 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                 // the object must be in the old, pre-versioning format, so simply\n                 // inflate everything and let LLVM decide if it can make sense of it\n                     match flate::inflate_bytes(bc_encoded) {\n-                        Some(bc) => bc,\n-                        None => {\n+                        Ok(bc) => bc,\n+                        Err(_) => {\n                             sess.fatal(&format!(\"failed to decompress bc of `{}`\",\n                                                name))\n                         }"}, {"sha": "e9f58ec53dfb31ded8ddb81313fe06c4ff9ce634", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/285cb8e6d8e4802c3c36d6c00d9c3752c2cc13bd/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/285cb8e6d8e4802c3c36d6c00d9c3752c2cc13bd/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=285cb8e6d8e4802c3c36d6c00d9c3752c2cc13bd", "patch": "@@ -2974,10 +2974,7 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n     let metadata = encoder::encode_metadata(encode_parms, krate);\n     let mut compressed = encoder::metadata_encoding_version.to_vec();\n-    compressed.push_all(&match flate::deflate_bytes(&metadata) {\n-        Some(compressed) => compressed,\n-        None => cx.sess().fatal(\"failed to compress metadata\"),\n-    });\n+    compressed.push_all(&flate::deflate_bytes(&metadata));\n     let llmeta = C_bytes_in_context(cx.metadata_llcx(), &compressed[..]);\n     let llconst = C_struct_in_context(cx.metadata_llcx(), &[llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}\","}]}