{"sha": "ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmOWY5MmNlNTIyNGY1ZTI3YjhkYzM5ZmZjMDJlYjk0ODFmN2NmZjE=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-06-16T18:25:47Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-19T00:01:34Z"}, "message": "Merge the Bitwise and ByteOrder traits into the Int trait\n\nThis reduces the complexity of the trait hierarchy.", "tree": {"sha": "f56ac5a3288101c49c4cc5c2e85b18dd4c2c6ff7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f56ac5a3288101c49c4cc5c2e85b18dd4c2c6ff7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1", "html_url": "https://github.com/rust-lang/rust/commit/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c0f8f49f6fe860efa268efa2f4fa0b5f00a4b07", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c0f8f49f6fe860efa268efa2f4fa0b5f00a4b07", "html_url": "https://github.com/rust-lang/rust/commit/4c0f8f49f6fe860efa268efa2f4fa0b5f00a4b07"}], "stats": {"total": 689, "additions": 325, "deletions": 364}, "files": [{"sha": "1360b412c23704dfdbeebecc7240dd1caeace739", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1", "patch": "@@ -15,8 +15,6 @@\n \n use core::prelude::*;\n \n-use core::num::Bitwise;\n-\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n /// A specialized Set implementation to use enum types.\n pub struct EnumSet<E> {"}, {"sha": "07c768d0c79162fb13c3cfe1fa7a72929e64b0a9", "filename": "src/libcollections/hash/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fmod.rs?ref=ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1", "patch": "@@ -103,7 +103,6 @@ macro_rules! impl_hash {\n         impl<S: Writer> Hash<S> for $ty {\n             #[inline]\n             fn hash(&self, state: &mut S) {\n-                use core::mem::ByteOrder;\n                 let a: [u8, ..::core::$ty::BYTES] = unsafe {\n                     mem::transmute((*self as $uty).to_little_endian() as $ty)\n                 };"}, {"sha": "eab344ac7a70189584ffe0664ed159cbac784a02", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 8, "deletions": 212, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1", "patch": "@@ -13,10 +13,9 @@\n //! This module contains functions for querying the size and alignment of\n //! types, initializing and manipulating memory.\n \n-use clone::Clone;\n-use ptr;\n use intrinsics;\n-use intrinsics::{bswap16, bswap32, bswap64};\n+use num::Int;\n+use ptr;\n \n pub use intrinsics::transmute;\n \n@@ -170,155 +169,6 @@ pub unsafe fn move_val_init<T>(dst: &mut T, src: T) {\n     ptr::write(dst, src)\n }\n \n-/// A type that can have its bytes re-ordered.\n-pub trait ByteOrder: Clone {\n-    /// Reverses the byte order of the value.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::mem::ByteOrder;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    /// let m = 0xEFCDAB8967452301u64;\n-    ///\n-    /// assert_eq!(n.swap_bytes(), m);\n-    /// ```\n-    fn swap_bytes(&self) -> Self;\n-\n-    /// Convert a value from big endian to the target's endianness.\n-    ///\n-    /// On big endian this is a no-op. On little endian the bytes are swapped.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::mem::ByteOrder;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    ///\n-    /// if cfg!(target_endian = \"big\") {\n-    ///     assert_eq!(ByteOrder::from_big_endian(n), n)\n-    /// } else {\n-    ///     assert_eq!(ByteOrder::from_big_endian(n), n.swap_bytes())\n-    /// }\n-    /// ```\n-    #[inline]\n-    fn from_big_endian(x: Self) -> Self {\n-        if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n-    }\n-\n-    /// Convert a value from little endian to the target's endianness.\n-    ///\n-    /// On little endian this is a no-op. On big endian the bytes are swapped.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::mem::ByteOrder;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    ///\n-    /// if cfg!(target_endian = \"little\") {\n-    ///     assert_eq!(ByteOrder::from_little_endian(n), n)\n-    /// } else {\n-    ///     assert_eq!(ByteOrder::from_little_endian(n), n.swap_bytes())\n-    /// }\n-    /// ```\n-    #[inline]\n-    fn from_little_endian(x: Self) -> Self {\n-        if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n-    }\n-\n-    /// Convert the value to big endian from the target's endianness.\n-    ///\n-    /// On big endian this is a no-op. On little endian the bytes are swapped.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::mem::ByteOrder;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    ///\n-    /// if cfg!(target_endian = \"big\") {\n-    ///     assert_eq!(n.to_big_endian(), n)\n-    /// } else {\n-    ///     assert_eq!(n.to_big_endian(), n.swap_bytes())\n-    /// }\n-    /// ```\n-    #[inline]\n-    fn to_big_endian(&self) -> Self {\n-        if cfg!(target_endian = \"big\") { self.clone() } else { self.swap_bytes() }\n-    }\n-\n-    /// Convert the value to little endian from the target's endianness.\n-    ///\n-    /// On little endian this is a no-op. On big endian the bytes are swapped.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::mem::ByteOrder;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    ///\n-    /// if cfg!(target_endian = \"little\") {\n-    ///     assert_eq!(n.to_little_endian(), n)\n-    /// } else {\n-    ///     assert_eq!(n.to_little_endian(), n.swap_bytes())\n-    /// }\n-    /// ```\n-    #[inline]\n-    fn to_little_endian(&self) -> Self {\n-        if cfg!(target_endian = \"little\") { self.clone() } else { self.swap_bytes() }\n-    }\n-}\n-\n-impl ByteOrder for u8 {\n-    #[inline]\n-    fn swap_bytes(&self) -> u8 {\n-        *self // swapping a single byte does nothing\n-    }\n-}\n-\n-impl ByteOrder for u16 {\n-    #[inline]\n-    fn swap_bytes(&self) -> u16 {\n-        unsafe { intrinsics::bswap16(*self) }\n-    }\n-}\n-\n-impl ByteOrder for u32 {\n-    #[inline]\n-    fn swap_bytes(&self) -> u32 {\n-        unsafe { intrinsics::bswap32(*self) }\n-    }\n-}\n-\n-impl ByteOrder for u64 {\n-    #[inline]\n-    fn swap_bytes(&self) -> u64 {\n-        unsafe { intrinsics::bswap64(*self) }\n-    }\n-}\n-\n-#[cfg(target_word_size = \"32\")]\n-impl ByteOrder for uint {\n-    #[inline]\n-    fn swap_bytes(&self) -> uint {\n-        (*self as u32).swap_bytes() as uint\n-    }\n-}\n-\n-#[cfg(target_word_size = \"64\")]\n-impl ByteOrder for uint {\n-    #[inline]\n-    fn swap_bytes(&self) -> uint {\n-        (*self as u64).swap_bytes() as uint\n-    }\n-}\n-\n /// Convert an u16 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n@@ -366,42 +216,42 @@ pub fn to_be64(x: u64) -> u64 { x.to_big_endian() }\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n #[inline]\n #[stable]\n-pub fn from_le16(x: u16) -> u16 { ByteOrder::from_little_endian(x) }\n+pub fn from_le16(x: u16) -> u16 { Int::from_little_endian(x) }\n \n /// Convert an u32 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n #[inline]\n #[stable]\n-pub fn from_le32(x: u32) -> u32 { ByteOrder::from_little_endian(x) }\n+pub fn from_le32(x: u32) -> u32 { Int::from_little_endian(x) }\n \n /// Convert an u64 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n #[inline]\n #[stable]\n-pub fn from_le64(x: u64) -> u64 { ByteOrder::from_little_endian(x) }\n+pub fn from_le64(x: u64) -> u64 { Int::from_little_endian(x) }\n \n /// Convert an u16 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n #[inline]\n #[stable]\n-pub fn from_be16(x: u16) -> u16 { ByteOrder::from_big_endian(x) }\n+pub fn from_be16(x: u16) -> u16 { Int::from_big_endian(x) }\n \n /// Convert an u32 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n #[inline]\n #[stable]\n-pub fn from_be32(x: u32) -> u32 { ByteOrder::from_big_endian(x) }\n+pub fn from_be32(x: u32) -> u32 { Int::from_big_endian(x) }\n \n /// Convert an u64 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n #[inline]\n #[stable]\n-pub fn from_be64(x: u64) -> u64 { ByteOrder::from_big_endian(x) }\n+pub fn from_be64(x: u64) -> u64 { Int::from_big_endian(x) }\n \n /// Swap the values at two mutable locations of the same type, without\n /// deinitialising or copying either one.\n@@ -642,60 +492,6 @@ mod tests {\n             assert!(Vec::from_slice([76u8]) == transmute(\"L\".to_string()));\n         }\n     }\n-\n-    macro_rules! test_byte_order {\n-        ($T:ident) => {\n-            mod $T {\n-                use mem::ByteOrder;\n-\n-                static A: $T = 0b0101100;\n-                static B: $T = 0b0100001;\n-                static C: $T = 0b1111001;\n-\n-                static _0: $T = 0;\n-                static _1: $T = !0;\n-\n-                #[test]\n-                fn test_swap_bytes() {\n-                    assert_eq!(A.swap_bytes().swap_bytes(), A);\n-                    assert_eq!(B.swap_bytes().swap_bytes(), B);\n-                    assert_eq!(C.swap_bytes().swap_bytes(), C);\n-\n-                    // Swapping these should make no difference\n-                    assert_eq!(_0.swap_bytes(), _0);\n-                    assert_eq!(_1.swap_bytes(), _1);\n-                }\n-\n-                #[test]\n-                fn test_little_endian() {\n-                    assert_eq!(ByteOrder::from_little_endian(A.to_little_endian()), A);\n-                    assert_eq!(ByteOrder::from_little_endian(B.to_little_endian()), B);\n-                    assert_eq!(ByteOrder::from_little_endian(C.to_little_endian()), C);\n-                    assert_eq!(ByteOrder::from_little_endian(_0), _0);\n-                    assert_eq!(ByteOrder::from_little_endian(_1), _1);\n-                    assert_eq!(_0.to_little_endian(), _0);\n-                    assert_eq!(_1.to_little_endian(), _1);\n-                }\n-\n-                #[test]\n-                fn test_big_endian() {\n-                    assert_eq!(ByteOrder::from_big_endian(A.to_big_endian()), A);\n-                    assert_eq!(ByteOrder::from_big_endian(B.to_big_endian()), B);\n-                    assert_eq!(ByteOrder::from_big_endian(C.to_big_endian()), C);\n-                    assert_eq!(ByteOrder::from_big_endian(_0), _0);\n-                    assert_eq!(ByteOrder::from_big_endian(_1), _1);\n-                    assert_eq!(_0.to_big_endian(), _0);\n-                    assert_eq!(_1.to_big_endian(), _1);\n-                }\n-            }\n-        }\n-    }\n-\n-    test_byte_order!(u8)\n-    test_byte_order!(u16)\n-    test_byte_order!(u32)\n-    test_byte_order!(u64)\n-    test_byte_order!(uint)\n }\n \n // FIXME #13642 (these benchmarks should be in another place)"}, {"sha": "84744b3f5d7019b657575490950d6dfd60fe914d", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 54, "deletions": 15, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1", "patch": "@@ -35,7 +35,6 @@ mod tests {\n \n     use int;\n     use num;\n-    use num::Bitwise;\n     use num::CheckedDiv;\n \n     #[test]\n@@ -90,7 +89,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_bitwise() {\n+    fn test_bitwise_operators() {\n         assert!(0b1110 as $T == (0b1100 as $T).bitor(&(0b1010 as $T)));\n         assert!(0b1000 as $T == (0b1100 as $T).bitand(&(0b1010 as $T)));\n         assert!(0b0110 as $T == (0b1100 as $T).bitxor(&(0b1010 as $T)));\n@@ -99,34 +98,74 @@ mod tests {\n         assert!(-(0b11 as $T) - (1 as $T) == (0b11 as $T).not());\n     }\n \n+    static A: $T = 0b0101100;\n+    static B: $T = 0b0100001;\n+    static C: $T = 0b1111001;\n+\n+    static _0: $T = 0;\n+    static _1: $T = !0;\n+\n     #[test]\n     fn test_count_ones() {\n-        assert!((0b0101100 as $T).count_ones() == 3);\n-        assert!((0b0100001 as $T).count_ones() == 2);\n-        assert!((0b1111001 as $T).count_ones() == 5);\n+        assert!(A.count_ones() == 3);\n+        assert!(B.count_ones() == 2);\n+        assert!(C.count_ones() == 5);\n     }\n \n     #[test]\n     fn test_count_zeros() {\n-        assert!((0b0101100 as $T).count_zeros() == BITS as $T - 3);\n-        assert!((0b0100001 as $T).count_zeros() == BITS as $T - 2);\n-        assert!((0b1111001 as $T).count_zeros() == BITS as $T - 5);\n+        assert!(A.count_zeros() == BITS as $T - 3);\n+        assert!(B.count_zeros() == BITS as $T - 2);\n+        assert!(C.count_zeros() == BITS as $T - 5);\n     }\n \n     #[test]\n     fn test_rotate() {\n-        let n: $T = 0b0101100; assert_eq!(n.rotate_left(6).rotate_right(2).rotate_right(4), n);\n-        let n: $T = 0b0100001; assert_eq!(n.rotate_left(3).rotate_left(2).rotate_right(5),  n);\n-        let n: $T = 0b1111001; assert_eq!(n.rotate_left(6).rotate_right(2).rotate_right(4), n);\n+        assert_eq!(A.rotate_left(6).rotate_right(2).rotate_right(4), A);\n+        assert_eq!(B.rotate_left(3).rotate_left(2).rotate_right(5), B);\n+        assert_eq!(C.rotate_left(6).rotate_right(2).rotate_right(4), C);\n \n         // Rotating these should make no difference\n         //\n         // We test using 124 bits because to ensure that overlong bit shifts do\n         // not cause undefined behaviour. See #10183.\n-        let n: $T = 0;   assert_eq!(n.rotate_left(124), n);\n-        let n: $T = -1;  assert_eq!(n.rotate_left(124), n);\n-        let n: $T = 0;   assert_eq!(n.rotate_right(124), n);\n-        let n: $T = -1;  assert_eq!(n.rotate_right(124), n);\n+        assert_eq!(_0.rotate_left(124), _0);\n+        assert_eq!(_1.rotate_left(124), _1);\n+        assert_eq!(_0.rotate_right(124), _0);\n+        assert_eq!(_1.rotate_right(124), _1);\n+    }\n+\n+    #[test]\n+    fn test_swap_bytes() {\n+        assert_eq!(A.swap_bytes().swap_bytes(), A);\n+        assert_eq!(B.swap_bytes().swap_bytes(), B);\n+        assert_eq!(C.swap_bytes().swap_bytes(), C);\n+\n+        // Swapping these should make no difference\n+        assert_eq!(_0.swap_bytes(), _0);\n+        assert_eq!(_1.swap_bytes(), _1);\n+    }\n+\n+    #[test]\n+    fn test_little_endian() {\n+        assert_eq!(Int::from_little_endian(A.to_little_endian()), A);\n+        assert_eq!(Int::from_little_endian(B.to_little_endian()), B);\n+        assert_eq!(Int::from_little_endian(C.to_little_endian()), C);\n+        assert_eq!(Int::from_little_endian(_0), _0);\n+        assert_eq!(Int::from_little_endian(_1), _1);\n+        assert_eq!(_0.to_little_endian(), _0);\n+        assert_eq!(_1.to_little_endian(), _1);\n+    }\n+\n+    #[test]\n+    fn test_big_endian() {\n+        assert_eq!(Int::from_big_endian(A.to_big_endian()), A);\n+        assert_eq!(Int::from_big_endian(B.to_big_endian()), B);\n+        assert_eq!(Int::from_big_endian(C.to_big_endian()), C);\n+        assert_eq!(Int::from_big_endian(_0), _0);\n+        assert_eq!(Int::from_big_endian(_1), _1);\n+        assert_eq!(_0.to_big_endian(), _0);\n+        assert_eq!(_1.to_big_endian(), _1);\n     }\n \n     #[test]"}, {"sha": "ed0c24e7fa00864f917bfc3a088cdb5ab754ed17", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 202, "deletions": 103, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1", "patch": "@@ -376,193 +376,292 @@ bounded_impl!(i64, i64::MIN, i64::MAX)\n bounded_impl!(f32, f32::MIN_VALUE, f32::MAX_VALUE)\n bounded_impl!(f64, f64::MIN_VALUE, f64::MAX_VALUE)\n \n-/// Numbers with a fixed binary representation.\n-pub trait Bitwise: Bounded\n-                 + Not<Self>\n-                 + BitAnd<Self,Self>\n-                 + BitOr<Self,Self>\n-                 + BitXor<Self,Self>\n-                 + Shl<Self,Self>\n-                 + Shr<Self,Self> {\n-    /// Returns the number of ones in the binary representation of the number.\n+/// Specifies the available operations common to all of Rust's core numeric primitives.\n+/// These may not always make sense from a purely mathematical point of view, but\n+/// may be useful for systems programming.\n+pub trait Primitive: Copy\n+                   + Clone\n+                   + Num\n+                   + NumCast\n+                   + PartialOrd\n+                   + Bounded {}\n+\n+trait_impl!(Primitive for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n+\n+/// A collection of traits relevant to primitive signed and unsigned integers\n+pub trait Int: Primitive\n+             + CheckedAdd\n+             + CheckedSub\n+             + CheckedMul\n+             + CheckedDiv\n+             + Bounded\n+             + Not<Self>\n+             + BitAnd<Self,Self>\n+             + BitOr<Self,Self>\n+             + BitXor<Self,Self>\n+             + Shl<Self,Self>\n+             + Shr<Self,Self> {\n+    /// Returns the number of ones in the binary representation of the integer.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::num::Bitwise;\n-    ///\n     /// let n = 0b01001100u8;\n+    ///\n     /// assert_eq!(n.count_ones(), 3);\n     /// ```\n-    fn count_ones(&self) -> Self;\n+    fn count_ones(self) -> Self;\n \n-    /// Returns the number of zeros in the binary representation of the number.\n+    /// Returns the number of zeros in the binary representation of the integer.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::num::Bitwise;\n-    ///\n     /// let n = 0b01001100u8;\n+    ///\n     /// assert_eq!(n.count_zeros(), 5);\n     /// ```\n     #[inline]\n-    fn count_zeros(&self) -> Self {\n-        (!*self).count_ones()\n+    fn count_zeros(self) -> Self {\n+        (!self).count_ones()\n     }\n \n     /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n+    /// of the integer.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::num::Bitwise;\n-    ///\n     /// let n = 0b0101000u16;\n+    ///\n     /// assert_eq!(n.leading_zeros(), 10);\n     /// ```\n-    fn leading_zeros(&self) -> Self;\n+    fn leading_zeros(self) -> Self;\n \n     /// Returns the number of trailing zeros in the in the binary representation\n-    /// of the number.\n+    /// of the integer.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::num::Bitwise;\n-    ///\n     /// let n = 0b0101000u16;\n+    ///\n     /// assert_eq!(n.trailing_zeros(), 3);\n     /// ```\n-    fn trailing_zeros(&self) -> Self;\n+    fn trailing_zeros(self) -> Self;\n \n-    /// Shifts the bits to the left by a specified amount amount, `r`, wrapping\n-    /// the truncated bits to the end of the resulting value.\n+    /// Shifts the bits to the left by a specified amount amount, `n`, wrapping\n+    /// the truncated bits to the end of the resulting integer.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::num::Bitwise;\n-    ///\n     /// let n = 0x0123456789ABCDEFu64;\n     /// let m = 0x3456789ABCDEF012u64;\n+    ///\n     /// assert_eq!(n.rotate_left(12), m);\n     /// ```\n-    fn rotate_left(&self, r: uint) -> Self;\n+    fn rotate_left(self, n: uint) -> Self;\n \n-    /// Shifts the bits to the right by a specified amount amount, `r`, wrapping\n-    /// the truncated bits to the beginning of the resulting value.\n+    /// Shifts the bits to the right by a specified amount amount, `n`, wrapping\n+    /// the truncated bits to the beginning of the resulting integer.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::num::Bitwise;\n-    ///\n     /// let n = 0x0123456789ABCDEFu64;\n     /// let m = 0xDEF0123456789ABCu64;\n+    ///\n     /// assert_eq!(n.rotate_right(12), m);\n     /// ```\n-    fn rotate_right(&self, r: uint) -> Self;\n+    fn rotate_right(self, n: uint) -> Self;\n+\n+    /// Reverses the byte order of the integer.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let n = 0x0123456789ABCDEFu64;\n+    /// let m = 0xEFCDAB8967452301u64;\n+    ///\n+    /// assert_eq!(n.swap_bytes(), m);\n+    /// ```\n+    fn swap_bytes(self) -> Self;\n+\n+    /// Convert a integer from big endian to the target's endianness.\n+    ///\n+    /// On big endian this is a no-op. On little endian the bytes are swapped.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let n = 0x0123456789ABCDEFu64;\n+    ///\n+    /// if cfg!(target_endian = \"big\") {\n+    ///     assert_eq!(Int::from_big_endian(n), n)\n+    /// } else {\n+    ///     assert_eq!(Int::from_big_endian(n), n.swap_bytes())\n+    /// }\n+    /// ```\n+    #[inline]\n+    fn from_big_endian(x: Self) -> Self {\n+        if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n+    }\n+\n+    /// Convert a integer from little endian to the target's endianness.\n+    ///\n+    /// On little endian this is a no-op. On big endian the bytes are swapped.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let n = 0x0123456789ABCDEFu64;\n+    ///\n+    /// if cfg!(target_endian = \"little\") {\n+    ///     assert_eq!(Int::from_little_endian(n), n)\n+    /// } else {\n+    ///     assert_eq!(Int::from_little_endian(n), n.swap_bytes())\n+    /// }\n+    /// ```\n+    #[inline]\n+    fn from_little_endian(x: Self) -> Self {\n+        if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n+    }\n+\n+    /// Convert the integer to big endian from the target's endianness.\n+    ///\n+    /// On big endian this is a no-op. On little endian the bytes are swapped.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let n = 0x0123456789ABCDEFu64;\n+    ///\n+    /// if cfg!(target_endian = \"big\") {\n+    ///     assert_eq!(n.to_big_endian(), n)\n+    /// } else {\n+    ///     assert_eq!(n.to_big_endian(), n.swap_bytes())\n+    /// }\n+    /// ```\n+    #[inline]\n+    fn to_big_endian(self) -> Self {\n+        if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n+    }\n+\n+    /// Convert the integer to little endian from the target's endianness.\n+    ///\n+    /// On little endian this is a no-op. On big endian the bytes are swapped.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let n = 0x0123456789ABCDEFu64;\n+    ///\n+    /// if cfg!(target_endian = \"little\") {\n+    ///     assert_eq!(n.to_little_endian(), n)\n+    /// } else {\n+    ///     assert_eq!(n.to_little_endian(), n.swap_bytes())\n+    /// }\n+    /// ```\n+    #[inline]\n+    fn to_little_endian(self) -> Self {\n+        if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n+    }\n }\n \n-macro_rules! bitwise_impl {\n-    ($t:ty, $bits:expr, $co:path, $lz:path, $tz:path) => {\n-        impl Bitwise for $t {\n+macro_rules! int_impl {\n+    ($T:ty, $BITS:expr, $ctpop:path, $ctlz:path, $cttz:path, $bswap:path) => {\n+        impl Int for $T {\n             #[inline]\n-            fn count_ones(&self) -> $t { unsafe { $co(*self) } }\n+            fn count_ones(self) -> $T { unsafe { $ctpop(self) } }\n \n             #[inline]\n-            fn leading_zeros(&self) -> $t { unsafe { $lz(*self) } }\n+            fn leading_zeros(self) -> $T { unsafe { $ctlz(self) } }\n \n             #[inline]\n-            fn trailing_zeros(&self) -> $t { unsafe { $tz(*self) } }\n+            fn trailing_zeros(self) -> $T { unsafe { $cttz(self) } }\n \n             #[inline]\n-            fn rotate_left(&self, r: uint) -> $t {\n-                // Protect against undefined behaviour for overlong bit shifts\n-                let r = r % $bits;\n-                (*self << r) | (*self >> ($bits - r))\n+            fn rotate_left(self, n: uint) -> $T {\n+                // Protect against undefined behaviour for over-long bit shifts\n+                let n = n % $BITS;\n+                (self << n) | (self >> ($BITS - n))\n             }\n \n             #[inline]\n-            fn rotate_right(&self, r: uint) -> $t {\n-                // Protect against undefined behaviour for overlong bit shifts\n-                let r = r % $bits;\n-                (*self >> r) | (*self << ($bits - r))\n+            fn rotate_right(self, n: uint) -> $T {\n+                // Protect against undefined behaviour for over-long bit shifts\n+                let n = n % $BITS;\n+                (self >> n) | (self << ($BITS - n))\n             }\n+\n+            #[inline]\n+            fn swap_bytes(self) -> $T { unsafe { $bswap(self) } }\n         }\n     }\n }\n \n-macro_rules! bitwise_cast_impl {\n-    ($t:ty, $t_cast:ty, $bits:expr, $co:path, $lz:path, $tz:path) => {\n-        impl Bitwise for $t {\n+/// Swapping a single byte is a no-op. This is marked as `unsafe` for\n+/// consistency with the other `bswap` intrinsics.\n+unsafe fn bswap8(x: u8) -> u8 { x }\n+\n+int_impl!(u8, 8,\n+    intrinsics::ctpop8,\n+    intrinsics::ctlz8,\n+    intrinsics::cttz8,\n+    bswap8)\n+\n+int_impl!(u16, 16,\n+    intrinsics::ctpop16,\n+    intrinsics::ctlz16,\n+    intrinsics::cttz16,\n+    intrinsics::bswap16)\n+\n+int_impl!(u32, 32,\n+    intrinsics::ctpop32,\n+    intrinsics::ctlz32,\n+    intrinsics::cttz32,\n+    intrinsics::bswap32)\n+\n+int_impl!(u64, 64,\n+    intrinsics::ctpop64,\n+    intrinsics::ctlz64,\n+    intrinsics::cttz64,\n+    intrinsics::bswap64)\n+\n+macro_rules! int_cast_impl {\n+    ($T:ty, $U:ty) => {\n+        impl Int for $T {\n             #[inline]\n-            fn count_ones(&self) -> $t { unsafe { $co(*self as $t_cast) as $t } }\n+            fn count_ones(self) -> $T { (self as $U).count_ones() as $T }\n \n             #[inline]\n-            fn leading_zeros(&self) -> $t { unsafe { $lz(*self as $t_cast) as $t } }\n+            fn leading_zeros(self) -> $T { (self as $U).leading_zeros() as $T }\n \n             #[inline]\n-            fn trailing_zeros(&self) -> $t { unsafe { $tz(*self as $t_cast) as $t } }\n+            fn trailing_zeros(self) -> $T { (self as $U).trailing_zeros() as $T }\n \n             #[inline]\n-            fn rotate_left(&self, r: uint) -> $t {\n-                // cast to prevent the sign bit from being corrupted\n-                (*self as $t_cast).rotate_left(r) as $t\n-            }\n+            fn rotate_left(self, n: uint) -> $T { (self as $U).rotate_left(n) as $T }\n \n             #[inline]\n-            fn rotate_right(&self, r: uint) -> $t {\n-                // cast to prevent the sign bit from being corrupted\n-                (*self as $t_cast).rotate_right(r) as $t\n-            }\n+            fn rotate_right(self, n: uint) -> $T { (self as $U).rotate_right(n) as $T }\n+\n+            #[inline]\n+            fn swap_bytes(self) -> $T { (self as $U).swap_bytes() as $T }\n         }\n     }\n }\n \n-#[cfg(target_word_size = \"32\")]\n-bitwise_cast_impl!(uint, u32, 32, intrinsics::ctpop32, intrinsics::ctlz32, intrinsics::cttz32)\n-#[cfg(target_word_size = \"64\")]\n-bitwise_cast_impl!(uint, u64, 64, intrinsics::ctpop64, intrinsics::ctlz64, intrinsics::cttz64)\n-\n-bitwise_impl!(u8, 8, intrinsics::ctpop8, intrinsics::ctlz8, intrinsics::cttz8)\n-bitwise_impl!(u16, 16, intrinsics::ctpop16, intrinsics::ctlz16, intrinsics::cttz16)\n-bitwise_impl!(u32, 32, intrinsics::ctpop32, intrinsics::ctlz32, intrinsics::cttz32)\n-bitwise_impl!(u64, 64, intrinsics::ctpop64, intrinsics::ctlz64, intrinsics::cttz64)\n-\n-#[cfg(target_word_size = \"32\")]\n-bitwise_cast_impl!(int, u32, 32, intrinsics::ctpop32, intrinsics::ctlz32, intrinsics::cttz32)\n-#[cfg(target_word_size = \"64\")]\n-bitwise_cast_impl!(int, u64, 64, intrinsics::ctpop64, intrinsics::ctlz64, intrinsics::cttz64)\n-\n-bitwise_cast_impl!(i8, u8, 8, intrinsics::ctpop8, intrinsics::ctlz8, intrinsics::cttz8)\n-bitwise_cast_impl!(i16, u16, 16, intrinsics::ctpop16, intrinsics::ctlz16, intrinsics::cttz16)\n-bitwise_cast_impl!(i32, u32, 32, intrinsics::ctpop32, intrinsics::ctlz32, intrinsics::cttz32)\n-bitwise_cast_impl!(i64, u64, 64, intrinsics::ctpop64, intrinsics::ctlz64, intrinsics::cttz64)\n-\n-/// Specifies the available operations common to all of Rust's core numeric primitives.\n-/// These may not always make sense from a purely mathematical point of view, but\n-/// may be useful for systems programming.\n-pub trait Primitive: Copy\n-                   + Clone\n-                   + Num\n-                   + NumCast\n-                   + PartialOrd\n-                   + Bounded {}\n-\n-trait_impl!(Primitive for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n-\n-/// A collection of traits relevant to primitive signed and unsigned integers\n-pub trait Int: Primitive\n-             + Bitwise\n-             + CheckedAdd\n-             + CheckedSub\n-             + CheckedMul\n-             + CheckedDiv {}\n+int_cast_impl!(i8, u8)\n+int_cast_impl!(i16, u16)\n+int_cast_impl!(i32, u32)\n+int_cast_impl!(i64, u64)\n \n-trait_impl!(Int for uint u8 u16 u32 u64 int i8 i16 i32 i64)\n+#[cfg(target_word_size = \"32\")] int_cast_impl!(uint, u32)\n+#[cfg(target_word_size = \"64\")] int_cast_impl!(uint, u64)\n+#[cfg(target_word_size = \"32\")] int_cast_impl!(int, u32)\n+#[cfg(target_word_size = \"64\")] int_cast_impl!(int, u64)\n \n /// Returns the smallest power of 2 greater than or equal to `n`.\n #[inline]"}, {"sha": "1fe3c4cf1f1cf3d2b60e1eb0ad46fdaa5307e0a2", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 54, "deletions": 15, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1", "patch": "@@ -26,7 +26,6 @@ mod tests {\n \n     use num;\n     use num::CheckedDiv;\n-    use num::Bitwise;\n \n     #[test]\n     fn test_overflows() {\n@@ -41,7 +40,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_bitwise() {\n+    fn test_bitwise_operators() {\n         assert!(0b1110 as $T == (0b1100 as $T).bitor(&(0b1010 as $T)));\n         assert!(0b1000 as $T == (0b1100 as $T).bitand(&(0b1010 as $T)));\n         assert!(0b0110 as $T == (0b1100 as $T).bitxor(&(0b1010 as $T)));\n@@ -50,34 +49,74 @@ mod tests {\n         assert!(MAX - (0b1011 as $T) == (0b1011 as $T).not());\n     }\n \n+    static A: $T = 0b0101100;\n+    static B: $T = 0b0100001;\n+    static C: $T = 0b1111001;\n+\n+    static _0: $T = 0;\n+    static _1: $T = !0;\n+\n     #[test]\n     fn test_count_ones() {\n-        assert!((0b0101100 as $T).count_ones() == 3);\n-        assert!((0b0100001 as $T).count_ones() == 2);\n-        assert!((0b1111001 as $T).count_ones() == 5);\n+        assert!(A.count_ones() == 3);\n+        assert!(B.count_ones() == 2);\n+        assert!(C.count_ones() == 5);\n     }\n \n     #[test]\n     fn test_count_zeros() {\n-        assert!((0b0101100 as $T).count_zeros() == BITS as $T - 3);\n-        assert!((0b0100001 as $T).count_zeros() == BITS as $T - 2);\n-        assert!((0b1111001 as $T).count_zeros() == BITS as $T - 5);\n+        assert!(A.count_zeros() == BITS as $T - 3);\n+        assert!(B.count_zeros() == BITS as $T - 2);\n+        assert!(C.count_zeros() == BITS as $T - 5);\n     }\n \n     #[test]\n     fn test_rotate() {\n-        let n: $T = 0b0101100; assert_eq!(n.rotate_left(6).rotate_right(2).rotate_right(4), n);\n-        let n: $T = 0b0100001; assert_eq!(n.rotate_left(3).rotate_left(2).rotate_right(5),  n);\n-        let n: $T = 0b1111001; assert_eq!(n.rotate_left(6).rotate_right(2).rotate_right(4), n);\n+        assert_eq!(A.rotate_left(6).rotate_right(2).rotate_right(4), A);\n+        assert_eq!(B.rotate_left(3).rotate_left(2).rotate_right(5), B);\n+        assert_eq!(C.rotate_left(6).rotate_right(2).rotate_right(4), C);\n \n         // Rotating these should make no difference\n         //\n         // We test using 124 bits because to ensure that overlong bit shifts do\n         // not cause undefined behaviour. See #10183.\n-        let n: $T = 0;   assert_eq!(n.rotate_left(124), n);\n-        let n: $T = MAX; assert_eq!(n.rotate_left(124), n);\n-        let n: $T = 0;   assert_eq!(n.rotate_right(124), n);\n-        let n: $T = MAX; assert_eq!(n.rotate_right(124), n);\n+        assert_eq!(_0.rotate_left(124), _0);\n+        assert_eq!(_1.rotate_left(124), _1);\n+        assert_eq!(_0.rotate_right(124), _0);\n+        assert_eq!(_1.rotate_right(124), _1);\n+    }\n+\n+    #[test]\n+    fn test_swap_bytes() {\n+        assert_eq!(A.swap_bytes().swap_bytes(), A);\n+        assert_eq!(B.swap_bytes().swap_bytes(), B);\n+        assert_eq!(C.swap_bytes().swap_bytes(), C);\n+\n+        // Swapping these should make no difference\n+        assert_eq!(_0.swap_bytes(), _0);\n+        assert_eq!(_1.swap_bytes(), _1);\n+    }\n+\n+    #[test]\n+    fn test_little_endian() {\n+        assert_eq!(Int::from_little_endian(A.to_little_endian()), A);\n+        assert_eq!(Int::from_little_endian(B.to_little_endian()), B);\n+        assert_eq!(Int::from_little_endian(C.to_little_endian()), C);\n+        assert_eq!(Int::from_little_endian(_0), _0);\n+        assert_eq!(Int::from_little_endian(_1), _1);\n+        assert_eq!(_0.to_little_endian(), _0);\n+        assert_eq!(_1.to_little_endian(), _1);\n+    }\n+\n+    #[test]\n+    fn test_big_endian() {\n+        assert_eq!(Int::from_big_endian(A.to_big_endian()), A);\n+        assert_eq!(Int::from_big_endian(B.to_big_endian()), B);\n+        assert_eq!(Int::from_big_endian(C.to_big_endian()), C);\n+        assert_eq!(Int::from_big_endian(_0), _0);\n+        assert_eq!(Int::from_big_endian(_1), _1);\n+        assert_eq!(_0.to_big_endian(), _0);\n+        assert_eq!(_1.to_big_endian(), _1);\n     }\n \n     #[test]"}, {"sha": "23fd607aafeef74b05bedb4b57c8704fecf605b3", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1", "patch": "@@ -11,7 +11,6 @@\n use alloc::arc::Arc;\n use libc;\n use std::mem;\n-use std::mem::ByteOrder;\n use std::rt::mutex;\n use std::rt::rtio;\n use std::rt::rtio::{IoResult, IoError};\n@@ -31,7 +30,7 @@ pub fn htons(u: u16) -> u16 {\n     u.to_big_endian()\n }\n pub fn ntohs(u: u16) -> u16 {\n-    ByteOrder::from_big_endian(u)\n+    Int::from_big_endian(u)\n }\n \n enum InAddr {\n@@ -47,7 +46,7 @@ fn ip_to_inaddr(ip: rtio::IpAddr) -> InAddr {\n                      (c as u32 <<  8) |\n                      (d as u32 <<  0);\n             InAddr(libc::in_addr {\n-                s_addr: ByteOrder::from_big_endian(ip)\n+                s_addr: Int::from_big_endian(ip)\n             })\n         }\n         rtio::Ipv6Addr(a, b, c, d, e, f, g, h) => {"}, {"sha": "e9153f89e04ee8d12aad9b6c5e6a00e161b3a9b7", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1", "patch": "@@ -23,7 +23,7 @@ use std::{cmp, fmt};\n use std::default::Default;\n use std::from_str::FromStr;\n use std::num::CheckedDiv;\n-use std::num::{Bitwise, ToPrimitive, FromPrimitive};\n+use std::num::{ToPrimitive, FromPrimitive};\n use std::num::{Zero, One, ToStrRadix, FromStrRadix};\n use std::string::String;\n use std::{uint, i64, u64};"}, {"sha": "e4b28dc7aa7c2607272577259f702b870d1826fe", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1", "patch": "@@ -46,7 +46,6 @@\n #![allow(unsigned_negate)]\n \n use libc::c_ulonglong;\n-use std::num::{Bitwise};\n use std::rc::Rc;\n \n use lib::llvm::{ValueRef, True, IntEQ, IntNE};"}, {"sha": "aa7fab2565d8cf6ae910ba88d8f5d47a759b219e", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1", "patch": "@@ -11,7 +11,6 @@\n use libc::{size_t, ssize_t, c_int, c_void, c_uint};\n use libc;\n use std::mem;\n-use std::mem::ByteOrder;\n use std::ptr;\n use std::rt::rtio;\n use std::rt::rtio::IoError;\n@@ -32,7 +31,7 @@ use uvll;\n ////////////////////////////////////////////////////////////////////////////////\n \n pub fn htons(u: u16) -> u16 { u.to_big_endian() }\n-pub fn ntohs(u: u16) -> u16 { ByteOrder::from_big_endian(u) }\n+pub fn ntohs(u: u16) -> u16 { Int::from_big_endian(u) }\n \n pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n                         len: uint) -> rtio::SocketAddr {\n@@ -90,7 +89,7 @@ fn addr_to_sockaddr(addr: rtio::SocketAddr) -> (libc::sockaddr_storage, uint) {\n                 (*storage).sin_family = libc::AF_INET as libc::sa_family_t;\n                 (*storage).sin_port = htons(addr.port);\n                 (*storage).sin_addr = libc::in_addr {\n-                    s_addr: ByteOrder::from_big_endian(ip),\n+                    s_addr: Int::from_big_endian(ip),\n \n                 };\n                 mem::size_of::<libc::sockaddr_in>()"}, {"sha": "7d0c82fc9a2d5f7d8171f20c48ae625838d120a4", "filename": "src/libserialize/ebml.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibserialize%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibserialize%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml.rs?ref=ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1", "patch": "@@ -154,8 +154,6 @@ pub mod reader {\n     }\n \n     pub fn vuint_at(data: &[u8], start: uint) -> DecodeResult<Res> {\n-        use std::mem::ByteOrder;\n-\n         if data.len() - start < 4 {\n             return vuint_at_slow(data, start);\n         }\n@@ -185,7 +183,7 @@ pub mod reader {\n \n         unsafe {\n             let ptr = data.as_ptr().offset(start as int) as *u32;\n-            let val = ByteOrder::from_big_endian(*ptr);\n+            let val = Int::from_big_endian(*ptr);\n \n             let i = (val >> 28u) as uint;\n             let (shift, mask) = SHIFT_MASK_TABLE[i];"}, {"sha": "7301f9b08e9dcef30ede009c9db3b77d84adec98", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1", "patch": "@@ -22,7 +22,7 @@ use string::String;\n \n pub use core::num::{Num, div_rem, Zero, zero, One, one};\n pub use core::num::{Signed, abs, abs_sub, signum};\n-pub use core::num::{Unsigned, pow, Bounded, Bitwise};\n+pub use core::num::{Unsigned, pow, Bounded};\n pub use core::num::{Primitive, Int, Saturating};\n pub use core::num::{CheckedAdd, CheckedSub, CheckedMul, CheckedDiv};\n pub use core::num::{cast, FromPrimitive, NumCast, ToPrimitive};"}, {"sha": "bbd461e3dde0db3a4513b17dd2d0c134ce3f1a33", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1", "patch": "@@ -209,8 +209,6 @@ impl Uuid {\n     /// * `d3` A 16-bit word\n     /// * `d4` Array of 8 octets\n     pub fn from_fields(d1: u32, d2: u16, d3: u16, d4: &[u8]) -> Uuid {\n-        use std::mem::ByteOrder;\n-\n         // First construct a temporary field-based struct\n         let mut fields = UuidFields {\n                 data1: 0,\n@@ -335,7 +333,6 @@ impl Uuid {\n     ///\n     /// Example: `550e8400-e29b-41d4-a716-446655440000`\n     pub fn to_hyphenated_str(&self) -> String {\n-        use std::mem::ByteOrder;\n         // Convert to field-based struct as it matches groups in output.\n         // Ensure fields are in network byte order, as per RFC.\n         let mut uf: UuidFields;"}, {"sha": "af51157bba564d53482206d65e5b99ec46d32418", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=ff9f92ce5224f5e27b8dc39ffc02eb9481f7cff1", "patch": "@@ -16,7 +16,6 @@\n use std::io;\n use std::io::stdio::StdReader;\n use std::io::BufferedReader;\n-use std::num::Bitwise;\n use std::os;\n \n // Computes a single solution to a given 9x9 sudoku"}]}