{"sha": "29e71b92bc5992dd2bf85dc4b27b60aaf0dcead8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5ZTcxYjkyYmM1OTkyZGQyYmY4NWRjNGIyN2I2MGFhZjBkY2VhZDg=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-08T17:42:35Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-08T17:51:53Z"}, "message": "niko discussion affects", "tree": {"sha": "21df2abd3aa3be7f1b9bc11081fdf29214c1df65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21df2abd3aa3be7f1b9bc11081fdf29214c1df65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29e71b92bc5992dd2bf85dc4b27b60aaf0dcead8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29e71b92bc5992dd2bf85dc4b27b60aaf0dcead8", "html_url": "https://github.com/rust-lang/rust/commit/29e71b92bc5992dd2bf85dc4b27b60aaf0dcead8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29e71b92bc5992dd2bf85dc4b27b60aaf0dcead8/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcf4a7e5c87cf80ff8d7c142fbdfd8fd398ad3a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcf4a7e5c87cf80ff8d7c142fbdfd8fd398ad3a7", "html_url": "https://github.com/rust-lang/rust/commit/fcf4a7e5c87cf80ff8d7c142fbdfd8fd398ad3a7"}], "stats": {"total": 35, "additions": 23, "deletions": 12}, "files": [{"sha": "39ea2150973a0a27e3ff90379677c90a6afd0906", "filename": "atomics.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29e71b92bc5992dd2bf85dc4b27b60aaf0dcead8/atomics.md", "raw_url": "https://github.com/rust-lang/rust/raw/29e71b92bc5992dd2bf85dc4b27b60aaf0dcead8/atomics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/atomics.md?ref=29e71b92bc5992dd2bf85dc4b27b60aaf0dcead8", "patch": "@@ -24,7 +24,7 @@ do exactly what we said but, you know, *fast*. Wouldn't that be great?\n # Compiler Reordering\n \n Compilers fundamentally want to be able to do all sorts of crazy transformations\n-to reduce data dependencies and eleminate dead code. In particular, they may\n+to reduce data dependencies and eliminate dead code. In particular, they may\n radically change the actual order of events, or make events never occur! If we\n write something like\n "}, {"sha": "1039cb1197b6493fe616e4f5ba0de44475aeae50", "filename": "references.md", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/29e71b92bc5992dd2bf85dc4b27b60aaf0dcead8/references.md", "raw_url": "https://github.com/rust-lang/rust/raw/29e71b92bc5992dd2bf85dc4b27b60aaf0dcead8/references.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/references.md?ref=29e71b92bc5992dd2bf85dc4b27b60aaf0dcead8", "patch": "@@ -25,14 +25,16 @@ as its direct children. Each variable's direct children would be their fields\n \n From this view, every value in Rust has a unique *path* in the tree of ownership.\n References to a value can subsequently be interpreted as a path in this tree.\n-Of particular interest are *prefixes*: `x` is a prefix of `y` if `x` owns `y`\n+Of particular interest are *ancestors* and *descendants*: if `x` owns `y`, then\n+`x` is an *ancestor* of `y`, and `y` is a *descendant* of `x`. Note that this is\n+an inclusive relationship: `x` is a descendant and ancestor of itself.\n \n-However much data doesn't reside on the stack, and we must also accommodate this.\n+Tragically, plenty of data doesn't reside on the stack, and we must also accommodate this.\n Globals and thread-locals are simple enough to model as residing at the bottom\n of the stack (though we must be careful with mutable globals). Data on\n the heap poses a different problem.\n \n-If all Rust had on the heap was data uniquely by a pointer on the stack,\n+If all Rust had on the heap was data uniquely owned by a pointer on the stack,\n then we can just treat that pointer as a struct that owns the value on\n the heap. Box, Vec, String, and HashMap, are examples of types which uniquely\n own data on the heap.\n@@ -51,6 +53,10 @@ types provide exclusive access through runtime restrictions. However it is also\n possible to establish unique ownership without interior mutability. For instance,\n if an Rc has refcount 1, then it is safe to mutate or move its internals.\n \n+In order to correctly communicate to the type system that a variable or field of\n+a struct can have interior mutability, it must be wrapped in an UnsafeCell. This\n+does not in itself make it safe to perform interior mutability operations on that\n+value. You still must yourself ensure that mutual exclusion is upheld.\n \n \n \n@@ -61,9 +67,9 @@ dereferenced. Shared references are always live unless they are literally unreac\n (for instance, they reside in freed or leaked memory). Mutable references can be\n reachable but *not* live through the process of *reborrowing*.\n \n-A mutable reference can be reborrowed to either a shared or mutable reference.\n-Further, the reborrow can produce exactly the same reference, or point to a\n-path it is a prefix of. For instance, a mutable reference can be reborrowed\n+A mutable reference can be reborrowed to either a shared or mutable reference to\n+one of its descendants. A reborrowed reference will only be live again once all\n+reborrows derived from it expire. For instance, a mutable reference can be reborrowed\n to point to a field of its referent:\n \n ```rust\n@@ -79,7 +85,7 @@ let x = &mut (1, 2);\n ```\n \n It is also possible to reborrow into *multiple* mutable references, as long as\n-they are *disjoint*: no reference is a prefix of another. Rust\n+they are *disjoint*: no reference is an ancestor of another. Rust\n explicitly enables this to be done with disjoint struct fields, because\n disjointness can be statically proven:\n \n@@ -89,6 +95,7 @@ let x = &mut (1, 2);\n     // reborrow x to two disjoint subfields\n     let y = &mut x.0;\n     let z = &mut x.1;\n+\n     // y and z are now live, but x isn't\n     *y = 3;\n     *z = 4;\n@@ -105,14 +112,14 @@ To simplify things, we can model variables as a fake type of reference: *owned*\n references. Owned references have much the same semantics as mutable references:\n they can be re-borrowed in a mutable or shared manner, which makes them no longer\n live. Live owned references have the unique property that they can be moved\n-out of (though mutable references *can* be swapped out of). This is\n+out of (though mutable references *can* be swapped out of). This power is\n only given to *live* owned references because moving its referent would of\n course invalidate all outstanding references prematurely.\n \n As a local lint against inappropriate mutation, only variables that are marked\n as `mut` can be borrowed mutably.\n \n-It is also interesting to note that Box behaves exactly like an owned\n+It is interesting to note that Box behaves exactly like an owned\n reference. It can be moved out of, and Rust understands it sufficiently to\n reason about its paths like a normal variable.\n \n@@ -123,8 +130,12 @@ reason about its paths like a normal variable.\n \n With liveness and paths defined, we can now properly define *aliasing*:\n \n-**A mutable reference is aliased if there exists another live reference to it or\n-one of its prefixes.**\n+**A mutable reference is aliased if there exists another live reference to one of\n+its ancestors or descendants.**\n+\n+(If you prefer, you may also say the two live references alias *each other*.\n+This has no semantic consequences, but is probably a more useful notion when\n+verifying the soundness of a construct.)\n \n That's it. Super simple right? Except for the fact that it took us two pages\n to define all of the terms in that defintion. You know: Super. Simple."}]}