{"sha": "60db57e7eccf292064c1fc47b426e9df1a7332aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwZGI1N2U3ZWNjZjI5MjA2NGMxZmM0N2I0MjZlOWRmMWE3MzMyYWE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-22T01:25:24Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-27T14:40:45Z"}, "message": "Cleanup the unification engine to use associated types, making the code much easier to read.", "tree": {"sha": "9f2f9467b9fd7f92f6d7ab73aa64c071e14081d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f2f9467b9fd7f92f6d7ab73aa64c071e14081d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60db57e7eccf292064c1fc47b426e9df1a7332aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60db57e7eccf292064c1fc47b426e9df1a7332aa", "html_url": "https://github.com/rust-lang/rust/commit/60db57e7eccf292064c1fc47b426e9df1a7332aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60db57e7eccf292064c1fc47b426e9df1a7332aa/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "984dc03df6abcd671d3f2da255d015a3b8f1943b", "url": "https://api.github.com/repos/rust-lang/rust/commits/984dc03df6abcd671d3f2da255d015a3b8f1943b", "html_url": "https://github.com/rust-lang/rust/commit/984dc03df6abcd671d3f2da255d015a3b8f1943b"}], "stats": {"total": 177, "additions": 89, "deletions": 88}, "files": [{"sha": "eaec4fac0a3f96ef66154b698d31102ea8815288", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/60db57e7eccf292064c1fc47b426e9df1a7332aa/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60db57e7eccf292064c1fc47b426e9df1a7332aa/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=60db57e7eccf292064c1fc47b426e9df1a7332aa", "patch": "@@ -79,16 +79,13 @@ pub struct InferCtxt<'a, 'tcx: 'a> {\n     type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n \n     // Map from integral variable to the kind of integer it represents\n-    int_unification_table:\n-        RefCell<UnificationTable<ty::IntVid, Option<IntVarValue>>>,\n+    int_unification_table: RefCell<UnificationTable<ty::IntVid>>,\n \n     // Map from floating variable to the kind of float it represents\n-    float_unification_table:\n-        RefCell<UnificationTable<ty::FloatVid, Option<ast::FloatTy>>>,\n+    float_unification_table: RefCell<UnificationTable<ty::FloatVid>>,\n \n     // For region variables.\n-    region_vars:\n-        RegionVarBindings<'a, 'tcx>,\n+    region_vars: RegionVarBindings<'a, 'tcx>,\n }\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized"}, {"sha": "4bbc503579972593e39217b3077462ed9fb3784a", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/60db57e7eccf292064c1fc47b426e9df1a7332aa/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60db57e7eccf292064c1fc47b426e9df1a7332aa/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=60db57e7eccf292064c1fc47b426e9df1a7332aa", "patch": "@@ -19,7 +19,7 @@ use std::u32;\n use util::snapshot_vec as sv;\n \n pub struct TypeVariableTable<'tcx> {\n-    values: sv::SnapshotVec<TypeVariableData<'tcx>,UndoEntry,Delegate>,\n+    values: sv::SnapshotVec<Delegate<'tcx>>,\n }\n \n struct TypeVariableData<'tcx> {\n@@ -42,7 +42,7 @@ enum UndoEntry {\n     Relate(ty::TyVid, ty::TyVid),\n }\n \n-struct Delegate;\n+struct Delegate<'tcx>;\n \n type Relation = (RelationDir, ty::TyVid);\n \n@@ -195,9 +195,12 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     }\n }\n \n-impl<'tcx> sv::SnapshotVecDelegate<TypeVariableData<'tcx>,UndoEntry> for Delegate {\n+impl<'tcx> sv::SnapshotVecDelegate for Delegate<'tcx> {\n+    type Value = TypeVariableData<'tcx>;\n+    type Undo = UndoEntry;\n+\n     fn reverse(&mut self,\n-               values: &mut Vec<TypeVariableData>,\n+               values: &mut Vec<TypeVariableData<'tcx>>,\n                action: UndoEntry) {\n         match action {\n             SpecifyVar(vid, relations) => {"}, {"sha": "e15eb9c05766595424b88ca0e0c066ae2262de1e", "filename": "src/librustc/middle/infer/unify.rs", "status": "modified", "additions": 60, "deletions": 61, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/60db57e7eccf292064c1fc47b426e9df1a7332aa/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60db57e7eccf292064c1fc47b426e9df1a7332aa/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=60db57e7eccf292064c1fc47b426e9df1a7332aa", "patch": "@@ -19,7 +19,6 @@ use middle::infer::InferCtxt;\n use std::cell::RefCell;\n use std::fmt::Debug;\n use syntax::ast;\n-use util::ppaux::Repr;\n use util::snapshot_vec as sv;\n \n /// This trait is implemented by any type that can serve as a type\n@@ -32,15 +31,17 @@ use util::snapshot_vec as sv;\n /// (possibly not yet known) sort of integer.\n ///\n /// Implementations of this trait are at the end of this file.\n-pub trait UnifyKey<'tcx, V> : Clone + Debug + PartialEq + Repr<'tcx> {\n+pub trait UnifyKey : Clone + Debug + PartialEq {\n+    type Value : UnifyValue;\n+\n     fn index(&self) -> uint;\n \n     fn from_index(u: uint) -> Self;\n \n     // Given an inference context, returns the unification table\n     // appropriate to this key type.\n     fn unification_table<'v>(infcx: &'v InferCtxt)\n-                             -> &'v RefCell<UnificationTable<Self,V>>;\n+                             -> &'v RefCell<UnificationTable<Self>>;\n \n     fn tag(k: Option<Self>) -> &'static str;\n }\n@@ -51,7 +52,7 @@ pub trait UnifyKey<'tcx, V> : Clone + Debug + PartialEq + Repr<'tcx> {\n /// whose value is not yet set).\n ///\n /// Implementations of this trait are at the end of this file.\n-pub trait UnifyValue<'tcx> : Clone + Repr<'tcx> + PartialEq {\n+pub trait UnifyValue : Clone + PartialEq + Debug {\n }\n \n /// Value of a unification key. We implement Tarjan's union-find\n@@ -62,44 +63,44 @@ pub trait UnifyValue<'tcx> : Clone + Repr<'tcx> + PartialEq {\n /// to keep the DAG relatively balanced, which helps keep the running\n /// time of the algorithm under control. For more information, see\n /// <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>.\n-#[derive(PartialEq,Clone)]\n-pub enum VarValue<K,V> {\n+#[derive(PartialEq,Clone,Show)]\n+pub enum VarValue<K:UnifyKey> {\n     Redirect(K),\n-    Root(V, uint),\n+    Root(K::Value, uint),\n }\n \n /// Table of unification keys and their values.\n-pub struct UnificationTable<K,V> {\n+pub struct UnificationTable<K:UnifyKey> {\n     /// Indicates the current value of each key.\n-    values: sv::SnapshotVec<VarValue<K,V>,(),Delegate>,\n+    values: sv::SnapshotVec<Delegate<K>>,\n }\n \n /// At any time, users may snapshot a unification table.  The changes\n /// made during the snapshot may either be *committed* or *rolled back*.\n-pub struct Snapshot<K> {\n+pub struct Snapshot<K:UnifyKey> {\n     // Link snapshot to the key type `K` of the table.\n     marker: marker::CovariantType<K>,\n     snapshot: sv::Snapshot,\n }\n \n /// Internal type used to represent the result of a `get()` operation.\n /// Conveys the current root and value of the key.\n-pub struct Node<K,V> {\n+pub struct Node<K:UnifyKey> {\n     pub key: K,\n-    pub value: V,\n+    pub value: K::Value,\n     pub rank: uint,\n }\n \n #[derive(Copy)]\n-pub struct Delegate;\n+pub struct Delegate<K>;\n \n // We can't use V:LatticeValue, much as I would like to,\n // because frequently the pattern is that V=Option<U> for some\n // other type parameter U, and we have no way to say\n // Option<U>:LatticeValue.\n \n-impl<'tcx, V:PartialEq+Clone+Repr<'tcx>, K:UnifyKey<'tcx, V>> UnificationTable<K,V> {\n-    pub fn new() -> UnificationTable<K,V> {\n+impl<K:UnifyKey> UnificationTable<K> {\n+    pub fn new() -> UnificationTable<K> {\n         UnificationTable {\n             values: sv::SnapshotVec::new(Delegate),\n         }\n@@ -126,7 +127,7 @@ impl<'tcx, V:PartialEq+Clone+Repr<'tcx>, K:UnifyKey<'tcx, V>> UnificationTable<K\n         self.values.commit(snapshot.snapshot);\n     }\n \n-    pub fn new_key(&mut self, value: V) -> K {\n+    pub fn new_key(&mut self, value: K::Value) -> K {\n         let index = self.values.push(Root(value, 0));\n         let k = UnifyKey::from_index(index);\n         debug!(\"{}: created new key: {:?}\",\n@@ -137,12 +138,12 @@ impl<'tcx, V:PartialEq+Clone+Repr<'tcx>, K:UnifyKey<'tcx, V>> UnificationTable<K\n \n     /// Find the root node for `vid`. This uses the standard union-find algorithm with path\n     /// compression: http://en.wikipedia.org/wiki/Disjoint-set_data_structure\n-    pub fn get(&mut self, tcx: &ty::ctxt, vid: K) -> Node<K,V> {\n+    pub fn get(&mut self, tcx: &ty::ctxt, vid: K) -> Node<K> {\n         let index = vid.index();\n         let value = (*self.values.get(index)).clone();\n         match value {\n             Redirect(redirect) => {\n-                let node: Node<K,V> = self.get(tcx, redirect.clone());\n+                let node: Node<K> = self.get(tcx, redirect.clone());\n                 if node.key != redirect {\n                     // Path compression\n                     self.values.set(index, Redirect(node.key.clone()));\n@@ -164,33 +165,32 @@ impl<'tcx, V:PartialEq+Clone+Repr<'tcx>, K:UnifyKey<'tcx, V>> UnificationTable<K\n \n     /// Sets the value for `vid` to `new_value`. `vid` MUST be a root node! Also, we must be in the\n     /// middle of a snapshot.\n-    pub fn set(&mut self,\n-               tcx: &ty::ctxt<'tcx>,\n-               key: K,\n-               new_value: VarValue<K,V>)\n+    pub fn set<'tcx>(&mut self,\n+                     _tcx: &ty::ctxt<'tcx>,\n+                     key: K,\n+                     new_value: VarValue<K>)\n     {\n         assert!(self.is_root(&key));\n \n-        debug!(\"Updating variable {} to {}\",\n-               key.repr(tcx),\n-               new_value.repr(tcx));\n+        debug!(\"Updating variable {:?} to {:?}\",\n+               key, new_value);\n \n         self.values.set(key.index(), new_value);\n     }\n \n     /// Either redirects node_a to node_b or vice versa, depending on the relative rank. Returns\n     /// the new root and rank. You should then update the value of the new root to something\n     /// suitable.\n-    pub fn unify(&mut self,\n-                 tcx: &ty::ctxt<'tcx>,\n-                 node_a: &Node<K,V>,\n-                 node_b: &Node<K,V>)\n-                 -> (K, uint)\n+    pub fn unify<'tcx>(&mut self,\n+                       tcx: &ty::ctxt<'tcx>,\n+                       node_a: &Node<K>,\n+                       node_b: &Node<K>)\n+                       -> (K, uint)\n     {\n-        debug!(\"unify(node_a(id={}, rank={}), node_b(id={}, rank={}))\",\n-               node_a.key.repr(tcx),\n+        debug!(\"unify(node_a(id={:?}, rank={:?}), node_b(id={:?}, rank={:?}))\",\n+               node_a.key,\n                node_a.rank,\n-               node_b.key.repr(tcx),\n+               node_b.key,\n                node_b.rank);\n \n         if node_a.rank > node_b.rank {\n@@ -212,8 +212,11 @@ impl<'tcx, V:PartialEq+Clone+Repr<'tcx>, K:UnifyKey<'tcx, V>> UnificationTable<K\n     }\n }\n \n-impl<K,V> sv::SnapshotVecDelegate<VarValue<K,V>,()> for Delegate {\n-    fn reverse(&mut self, _: &mut Vec<VarValue<K,V>>, _: ()) {\n+impl<K> sv::SnapshotVecDelegate for Delegate<K> {\n+    type Value = VarValue<K>;\n+    type Undo = ();\n+\n+    fn reverse(&mut self, _: &mut Vec<VarValue<K>>, _: ()) {\n         panic!(\"Nothing to reverse\");\n     }\n }\n@@ -224,7 +227,7 @@ impl<K,V> sv::SnapshotVecDelegate<VarValue<K,V>,()> for Delegate {\n \n /// Indicates a type that does not have any kind of subtyping\n /// relationship.\n-pub trait SimplyUnifiable<'tcx> : Clone + PartialEq + Repr<'tcx> {\n+pub trait SimplyUnifiable<'tcx> : Clone + PartialEq + Debug {\n     fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx>;\n     fn to_type_err(expected_found<Self>) -> ty::type_err<'tcx>;\n }\n@@ -242,8 +245,11 @@ pub fn err<'tcx, V:SimplyUnifiable<'tcx>>(a_is_expected: bool,\n     }\n }\n \n-pub trait InferCtxtMethodsForSimplyUnifiableTypes<'tcx, V:SimplyUnifiable<'tcx>,\n-                                                  K:UnifyKey<'tcx, Option<V>>> {\n+pub trait InferCtxtMethodsForSimplyUnifiableTypes<'tcx,K,V>\n+    where K : UnifyKey<Value=Option<V>>,\n+          V : SimplyUnifiable<'tcx>,\n+          Option<V> : UnifyValue,\n+{\n     fn simple_vars(&self,\n                    a_is_expected: bool,\n                    a_id: K,\n@@ -257,8 +263,10 @@ pub trait InferCtxtMethodsForSimplyUnifiableTypes<'tcx, V:SimplyUnifiable<'tcx>,\n     fn probe_var(&self, a_id: K) -> Option<Ty<'tcx>>;\n }\n \n-impl<'a,'tcx,V:SimplyUnifiable<'tcx>,K:UnifyKey<'tcx, Option<V>>>\n-    InferCtxtMethodsForSimplyUnifiableTypes<'tcx, V, K> for InferCtxt<'a, 'tcx>\n+impl<'a,'tcx,V,K> InferCtxtMethodsForSimplyUnifiableTypes<'tcx,K,V> for InferCtxt<'a,'tcx>\n+    where K : UnifyKey<Value=Option<V>>,\n+          V : SimplyUnifiable<'tcx>,\n+          Option<V> : UnifyValue,\n {\n     /// Unifies two simple keys. Because simple keys do not have any subtyping relationships, if\n     /// both keys have already been associated with a value, then those two values must be the\n@@ -271,8 +279,8 @@ impl<'a,'tcx,V:SimplyUnifiable<'tcx>,K:UnifyKey<'tcx, Option<V>>>\n     {\n         let tcx = self.tcx;\n         let table = UnifyKey::unification_table(self);\n-        let node_a = table.borrow_mut().get(tcx, a_id);\n-        let node_b = table.borrow_mut().get(tcx, b_id);\n+        let node_a: Node<K> = table.borrow_mut().get(tcx, a_id);\n+        let node_b: Node<K> = table.borrow_mut().get(tcx, b_id);\n         let a_id = node_a.key.clone();\n         let b_id = node_b.key.clone();\n \n@@ -346,14 +354,14 @@ impl<'a,'tcx,V:SimplyUnifiable<'tcx>,K:UnifyKey<'tcx, Option<V>>>\n \n // Integral type keys\n \n-impl<'tcx> UnifyKey<'tcx, Option<IntVarValue>> for ty::IntVid {\n+impl UnifyKey for ty::IntVid {\n+    type Value = Option<IntVarValue>;\n+\n     fn index(&self) -> uint { self.index as uint }\n \n     fn from_index(i: uint) -> ty::IntVid { ty::IntVid { index: i as u32 } }\n \n-    fn unification_table<'v>(infcx: &'v InferCtxt)\n-        -> &'v RefCell<UnificationTable<ty::IntVid, Option<IntVarValue>>>\n-    {\n+    fn unification_table<'v>(infcx: &'v InferCtxt) -> &'v RefCell<UnificationTable<ty::IntVid>> {\n         return &infcx.int_unification_table;\n     }\n \n@@ -375,18 +383,18 @@ impl<'tcx> SimplyUnifiable<'tcx> for IntVarValue {\n     }\n }\n \n-impl<'tcx> UnifyValue<'tcx> for Option<IntVarValue> { }\n+impl UnifyValue for Option<IntVarValue> { }\n \n // Floating point type keys\n \n-impl<'tcx> UnifyKey<'tcx, Option<ast::FloatTy>> for ty::FloatVid {\n+impl UnifyKey for ty::FloatVid {\n+    type Value = Option<ast::FloatTy>;\n+\n     fn index(&self) -> uint { self.index as uint }\n \n     fn from_index(i: uint) -> ty::FloatVid { ty::FloatVid { index: i as u32 } }\n \n-    fn unification_table<'v>(infcx: &'v InferCtxt)\n-        -> &'v RefCell<UnificationTable<ty::FloatVid, Option<ast::FloatTy>>>\n-    {\n+    fn unification_table<'v>(infcx: &'v InferCtxt) -> &'v RefCell<UnificationTable<ty::FloatVid>> {\n         return &infcx.float_unification_table;\n     }\n \n@@ -395,7 +403,7 @@ impl<'tcx> UnifyKey<'tcx, Option<ast::FloatTy>> for ty::FloatVid {\n     }\n }\n \n-impl<'tcx> UnifyValue<'tcx> for Option<ast::FloatTy> {\n+impl UnifyValue for Option<ast::FloatTy> {\n }\n \n impl<'tcx> SimplyUnifiable<'tcx> for ast::FloatTy {\n@@ -407,12 +415,3 @@ impl<'tcx> SimplyUnifiable<'tcx> for ast::FloatTy {\n         ty::terr_float_mismatch(err)\n     }\n }\n-\n-impl<'tcx, K:Repr<'tcx>, V:Repr<'tcx>> Repr<'tcx> for VarValue<K,V> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        match *self {\n-            Redirect(ref k) => format!(\"Redirect({})\", k.repr(tcx)),\n-            Root(ref v, r) => format!(\"Root({}, {})\", v.repr(tcx), r)\n-        }\n-    }\n-}"}, {"sha": "151173b3a40850b55df8a3a8b686cd27ee1a8e70", "filename": "src/librustc/util/snapshot_vec.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/60db57e7eccf292064c1fc47b426e9df1a7332aa/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60db57e7eccf292064c1fc47b426e9df1a7332aa/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs?ref=60db57e7eccf292064c1fc47b426e9df1a7332aa", "patch": "@@ -22,8 +22,7 @@ use self::UndoLog::*;\n \n use std::mem;\n \n-#[derive(PartialEq)]\n-pub enum UndoLog<T,U> {\n+pub enum UndoLog<D:SnapshotVecDelegate> {\n     /// Indicates where a snapshot started.\n     OpenSnapshot,\n \n@@ -34,15 +33,15 @@ pub enum UndoLog<T,U> {\n     NewElem(uint),\n \n     /// Variable with given index was changed *from* the given value.\n-    SetElem(uint, T),\n+    SetElem(uint, D::Value),\n \n     /// Extensible set of actions\n-    Other(U)\n+    Other(D::Undo)\n }\n \n-pub struct SnapshotVec<T,U,D> {\n-    values: Vec<T>,\n-    undo_log: Vec<UndoLog<T,U>>,\n+pub struct SnapshotVec<D:SnapshotVecDelegate> {\n+    values: Vec<D::Value>,\n+    undo_log: Vec<UndoLog<D>>,\n     delegate: D\n }\n \n@@ -53,12 +52,15 @@ pub struct Snapshot {\n     length: uint,\n }\n \n-pub trait SnapshotVecDelegate<T,U> {\n-    fn reverse(&mut self, values: &mut Vec<T>, action: U);\n+pub trait SnapshotVecDelegate {\n+    type Value;\n+    type Undo;\n+\n+    fn reverse(&mut self, values: &mut Vec<Self::Value>, action: Self::Undo);\n }\n \n-impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n-    pub fn new(delegate: D) -> SnapshotVec<T,U,D> {\n+impl<D:SnapshotVecDelegate> SnapshotVec<D> {\n+    pub fn new(delegate: D) -> SnapshotVec<D> {\n         SnapshotVec {\n             values: Vec::new(),\n             undo_log: Vec::new(),\n@@ -70,13 +72,13 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n         !self.undo_log.is_empty()\n     }\n \n-    pub fn record(&mut self, action: U) {\n+    pub fn record(&mut self, action: D::Undo) {\n         if self.in_snapshot() {\n             self.undo_log.push(Other(action));\n         }\n     }\n \n-    pub fn push(&mut self, elem: T) -> uint {\n+    pub fn push(&mut self, elem: D::Value) -> uint {\n         let len = self.values.len();\n         self.values.push(elem);\n \n@@ -87,20 +89,20 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n         len\n     }\n \n-    pub fn get<'a>(&'a self, index: uint) -> &'a T {\n+    pub fn get<'a>(&'a self, index: uint) -> &'a D::Value {\n         &self.values[index]\n     }\n \n     /// Returns a mutable pointer into the vec; whatever changes you make here cannot be undone\n     /// automatically, so you should be sure call `record()` with some sort of suitable undo\n     /// action.\n-    pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n+    pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut D::Value {\n         &mut self.values[index]\n     }\n \n     /// Updates the element at the given index. The old value will saved (and perhaps restored) if\n     /// a snapshot is active.\n-    pub fn set(&mut self, index: uint, new_elem: T) {\n+    pub fn set(&mut self, index: uint, new_elem: D::Value) {\n         let old_elem = mem::replace(&mut self.values[index], new_elem);\n         if self.in_snapshot() {\n             self.undo_log.push(SetElem(index, old_elem));\n@@ -115,7 +117,7 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n \n     pub fn actions_since_snapshot(&self,\n                                   snapshot: &Snapshot)\n-                                  -> &[UndoLog<T,U>] {\n+                                  -> &[UndoLog<D>] {\n         &self.undo_log[snapshot.length..]\n     }\n "}]}