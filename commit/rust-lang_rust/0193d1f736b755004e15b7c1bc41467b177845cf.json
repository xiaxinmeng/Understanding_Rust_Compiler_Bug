{"sha": "0193d1f736b755004e15b7c1bc41467b177845cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxOTNkMWY3MzZiNzU1MDA0ZTE1YjdjMWJjNDE0NjdiMTc3ODQ1Y2Y=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-06-27T21:06:54Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-06-27T21:46:58Z"}, "message": "Group move errors before reporting, add suggestions", "tree": {"sha": "64b10fca13a4e2769eeb465d461a9f3bc8f69d74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64b10fca13a4e2769eeb465d461a9f3bc8f69d74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0193d1f736b755004e15b7c1bc41467b177845cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0193d1f736b755004e15b7c1bc41467b177845cf", "html_url": "https://github.com/rust-lang/rust/commit/0193d1f736b755004e15b7c1bc41467b177845cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0193d1f736b755004e15b7c1bc41467b177845cf/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43fce075d35f8d7bc09bc969d14ddf68d491ba54", "url": "https://api.github.com/repos/rust-lang/rust/commits/43fce075d35f8d7bc09bc969d14ddf68d491ba54", "html_url": "https://github.com/rust-lang/rust/commit/43fce075d35f8d7bc09bc969d14ddf68d491ba54"}], "stats": {"total": 568, "additions": 502, "deletions": 66}, "files": [{"sha": "b0b88209989fa54a98d130e48d203b3337c4da51", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0193d1f736b755004e15b7c1bc41467b177845cf/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0193d1f736b755004e15b7c1bc41467b177845cf/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=0193d1f736b755004e15b7c1bc41467b177845cf", "patch": "@@ -497,8 +497,8 @@ pub enum LocalKind {\n     ReturnPointer,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct VarBindingForm {\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+pub struct VarBindingForm<'tcx> {\n     /// Is variable bound via `x`, `mut x`, `ref x`, or `ref mut x`?\n     pub binding_mode: ty::BindingMode,\n     /// If an explicit type was provided for this variable binding,\n@@ -508,21 +508,49 @@ pub struct VarBindingForm {\n     /// doing so breaks incremental compilation (as of this writing),\n     /// while a `Span` does not cause our tests to fail.\n     pub opt_ty_info: Option<Span>,\n+    /// Place of the RHS of the =, or the subject of the `match` where this\n+    /// variable is initialized. None in the case of `let PATTERN;`.\n+    /// Some((None, ..)) in the case of and `let [mut] x = ...` because\n+    /// (a) the right-hand side isn't evaluated as a place expression.\n+    /// (b) it gives a way to separate this case from the remaining cases\n+    ///     for diagnostics.\n+    pub opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub enum BindingForm {\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+pub enum BindingForm<'tcx> {\n     /// This is a binding for a non-`self` binding, or a `self` that has an explicit type.\n-    Var(VarBindingForm),\n+    Var(VarBindingForm<'tcx>),\n     /// Binding for a `self`/`&self`/`&mut self` binding where the type is implicit.\n     ImplicitSelf,\n }\n \n-CloneTypeFoldableAndLiftImpls! { BindingForm, }\n+CloneTypeFoldableAndLiftImpls! { BindingForm<'tcx>, }\n \n-impl_stable_hash_for!(struct self::VarBindingForm { binding_mode, opt_ty_info });\n+impl_stable_hash_for!(struct self::VarBindingForm<'tcx> {\n+    binding_mode,\n+    opt_ty_info,\n+    opt_match_place\n+});\n+\n+mod binding_form_impl {\n+    use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+    use ich::StableHashingContext;\n \n-impl_stable_hash_for!(enum self::BindingForm { Var(binding), ImplicitSelf, });\n+    impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for super::BindingForm<'tcx> {\n+        fn hash_stable<W: StableHasherResult>(&self,\n+                                            hcx: &mut StableHashingContext<'a>,\n+                                            hasher: &mut StableHasher<W>) {\n+            use super::BindingForm::*;\n+            ::std::mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+            match self {\n+                Var(binding) => binding.hash_stable(hcx, hasher),\n+                ImplicitSelf => (),\n+            }\n+        }\n+    }\n+}\n \n /// A MIR local.\n ///\n@@ -542,7 +570,7 @@ pub struct LocalDecl<'tcx> {\n     /// therefore it need not be visible across crates. pnkfelix\n     /// currently hypothesized we *need* to wrap this in a\n     /// `ClearCrossCrate` as long as it carries as `HirId`.\n-    pub is_user_variable: Option<ClearCrossCrate<BindingForm>>,\n+    pub is_user_variable: Option<ClearCrossCrate<BindingForm<'tcx>>>,\n \n     /// True if this is an internal local\n     ///\n@@ -670,6 +698,7 @@ impl<'tcx> LocalDecl<'tcx> {\n             Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                 binding_mode: ty::BindingMode::BindByValue(_),\n                 opt_ty_info: _,\n+                opt_match_place: _,\n             }))) => true,\n \n             // FIXME: might be able to thread the distinction between\n@@ -688,6 +717,7 @@ impl<'tcx> LocalDecl<'tcx> {\n             Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                 binding_mode: ty::BindingMode::BindByValue(_),\n                 opt_ty_info: _,\n+                opt_match_place: _,\n             }))) => true,\n \n             Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf)) => true,"}, {"sha": "a17e897d83447c14cdf3ba54367206dc7ce75b73", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 35, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0193d1f736b755004e15b7c1bc41467b177845cf/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0193d1f736b755004e15b7c1bc41467b177845cf/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=0193d1f736b755004e15b7c1bc41467b177845cf", "patch": "@@ -35,7 +35,6 @@ use syntax_pos::Span;\n \n use dataflow::indexes::BorrowIndex;\n use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MovePathIndex};\n-use dataflow::move_paths::{IllegalMoveOriginKind, MoveError};\n use dataflow::Borrows;\n use dataflow::DataflowResultsConsumer;\n use dataflow::FlowAtLocation;\n@@ -62,6 +61,7 @@ mod path_utils;\n crate mod place_ext;\n mod prefixes;\n mod used_muts;\n+mod move_errors;\n \n pub(crate) mod nll;\n \n@@ -117,40 +117,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     let move_data: MoveData<'tcx> = match MoveData::gather_moves(mir, tcx) {\n         Ok(move_data) => move_data,\n         Err((move_data, move_errors)) => {\n-            for move_error in move_errors {\n-                let (span, kind): (Span, IllegalMoveOriginKind) = match move_error {\n-                    MoveError::UnionMove { .. } => {\n-                        unimplemented!(\"don't know how to report union move errors yet.\")\n-                    }\n-                    MoveError::IllegalMove {\n-                        cannot_move_out_of: o,\n-                    } => (o.span, o.kind),\n-                };\n-                let origin = Origin::Mir;\n-                let mut err = match kind {\n-                    IllegalMoveOriginKind::Static => {\n-                        tcx.cannot_move_out_of(span, \"static item\", origin)\n-                    }\n-                    IllegalMoveOriginKind::BorrowedContent { target_ty: ty } => {\n-                        // Inspect the type of the content behind the\n-                        // borrow to provide feedback about why this\n-                        // was a move rather than a copy.\n-                        match ty.sty {\n-                            ty::TyArray(..) | ty::TySlice(..) => {\n-                                tcx.cannot_move_out_of_interior_noncopy(span, ty, None, origin)\n-                            }\n-                            _ => tcx.cannot_move_out_of(span, \"borrowed content\", origin),\n-                        }\n-                    }\n-                    IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } => {\n-                        tcx.cannot_move_out_of_interior_of_drop(span, ty, origin)\n-                    }\n-                    IllegalMoveOriginKind::InteriorOfSliceOrArray { ty, is_index } => {\n-                        tcx.cannot_move_out_of_interior_noncopy(span, ty, Some(is_index), origin)\n-                    }\n-                };\n-                err.emit();\n-            }\n+            move_errors::report_move_errors(&mir, tcx, move_errors, &move_data);\n             move_data\n         }\n     };"}, {"sha": "bc68708decbd54a25754c199d057b070d8f3a857", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "added", "additions": 388, "deletions": 0, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/0193d1f736b755004e15b7c1bc41467b177845cf/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0193d1f736b755004e15b7c1bc41467b177845cf/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=0193d1f736b755004e15b7c1bc41467b177845cf", "patch": "@@ -0,0 +1,388 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir;\n+use rustc::mir::*;\n+use rustc::ty::{self, TyCtxt};\n+use rustc_errors::DiagnosticBuilder;\n+use syntax_pos::Span;\n+\n+use dataflow::move_paths::{IllegalMoveOrigin, IllegalMoveOriginKind, MoveData};\n+use dataflow::move_paths::{LookupResult, MoveError, MovePathIndex};\n+use util::borrowck_errors::{BorrowckErrors, Origin};\n+\n+pub(crate) fn report_move_errors<'gcx, 'tcx>(\n+    mir: &Mir<'tcx>,\n+    tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+    move_errors: Vec<MoveError<'tcx>>,\n+    move_data: &MoveData<'tcx>,\n+) {\n+    MoveErrorCtxt {\n+        mir,\n+        tcx,\n+        move_data,\n+    }.report_errors(move_errors);\n+}\n+\n+#[derive(Copy, Clone)]\n+struct MoveErrorCtxt<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    move_data: &'a MoveData<'tcx>,\n+}\n+\n+// Often when desugaring a pattern match we may have many individual moves in\n+// MIR that are all part of one operation from the user's point-of-view. For\n+// example:\n+//\n+// let (x, y) = foo()\n+//\n+// would move x from the 0 field of some temporary, and y from the 1 field. We\n+// group such errors together for cleaner error reporting.\n+//\n+// Errors are kept separate if they are from places with different parent move\n+// paths. For example, this generates two errors:\n+//\n+// let (&x, &y) = (&String::new(), &String::new());\n+#[derive(Debug)]\n+enum GroupedMoveError<'tcx> {\n+    // Match place can't be moved from\n+    // e.g. match x[0] { s => (), } where x: &[String]\n+    MovesFromMatchPlace {\n+        span: Span,\n+        move_from: Place<'tcx>,\n+        kind: IllegalMoveOriginKind<'tcx>,\n+        binds_to: Vec<Local>,\n+    },\n+    // Part of a pattern can't be moved from,\n+    // e.g. match &String::new() { &x => (), }\n+    MovesFromPattern {\n+        span: Span,\n+        move_from: MovePathIndex,\n+        kind: IllegalMoveOriginKind<'tcx>,\n+        binds_to: Vec<Local>,\n+    },\n+    // Everything that isn't from pattern matching.\n+    OtherIllegalMove {\n+        span: Span,\n+        kind: IllegalMoveOriginKind<'tcx>,\n+    },\n+}\n+\n+impl<'a, 'gcx, 'tcx> MoveErrorCtxt<'a, 'gcx, 'tcx> {\n+    fn report_errors(self, move_errors: Vec<MoveError<'tcx>>) {\n+        let grouped_errors = self.group_move_errors(move_errors);\n+        for error in grouped_errors {\n+            self.report(error);\n+        }\n+    }\n+\n+    fn group_move_errors(self, errors: Vec<MoveError<'tcx>>) -> Vec<GroupedMoveError<'tcx>> {\n+        let mut grouped_errors = Vec::new();\n+        for error in errors {\n+            self.append_to_grouped_errors(&mut grouped_errors, error);\n+        }\n+        grouped_errors\n+    }\n+\n+    fn append_to_grouped_errors(\n+        self,\n+        grouped_errors: &mut Vec<GroupedMoveError<'tcx>>,\n+        error: MoveError<'tcx>,\n+    ) {\n+        match error {\n+            MoveError::UnionMove { .. } => {\n+                unimplemented!(\"don't know how to report union move errors yet.\")\n+            }\n+            MoveError::IllegalMove {\n+                cannot_move_out_of: IllegalMoveOrigin { location, kind },\n+            } => {\n+                let stmt_source_info = self.mir.source_info(location);\n+                if let Some(StatementKind::Assign(\n+                    Place::Local(local),\n+                    Rvalue::Use(Operand::Move(move_from)),\n+                )) = self.mir.basic_blocks()[location.block]\n+                    .statements\n+                    .get(location.statement_index)\n+                    .map(|stmt| &stmt.kind)\n+                {\n+                    let local_decl = &self.mir.local_decls[*local];\n+                    if let Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                        opt_match_place: Some((ref opt_match_place, match_span)),\n+                        binding_mode: _,\n+                        opt_ty_info: _,\n+                    }))) = local_decl.is_user_variable\n+                    {\n+                        // opt_match_place is the\n+                        // match_span is the span of the expression being matched on\n+                        // match *x.y { ... }        match_place is Some(*x.y)\n+                        //       ^^^^                match_span is the span of *x.y\n+                        // opt_match_place is None for let [mut] x = ... statements,\n+                        // whether or not the right-hand side is a place expression\n+\n+                        // HACK use scopes to determine if this assignment is\n+                        // the initialization of a variable.\n+                        // FIXME(matthewjasper) This would probably be more\n+                        // reliable if it used the ever initialized dataflow\n+                        // but move errors are currently reported before the\n+                        // rest of borrowck has run.\n+                        if self\n+                            .mir\n+                            .is_sub_scope(local_decl.source_info.scope, stmt_source_info.scope)\n+                        {\n+                            self.append_binding_error(\n+                                grouped_errors,\n+                                kind,\n+                                move_from,\n+                                *local,\n+                                opt_match_place,\n+                                match_span,\n+                            );\n+                        }\n+                        return;\n+                    }\n+                }\n+                grouped_errors.push(GroupedMoveError::OtherIllegalMove {\n+                    span: stmt_source_info.span,\n+                    kind,\n+                });\n+            }\n+        }\n+    }\n+\n+    fn append_binding_error(\n+        self,\n+        grouped_errors: &mut Vec<GroupedMoveError<'tcx>>,\n+        kind: IllegalMoveOriginKind<'tcx>,\n+        move_from: &Place<'tcx>,\n+        bind_to: Local,\n+        match_place: &Option<Place<'tcx>>,\n+        match_span: Span,\n+    ) {\n+        debug!(\n+            \"append_to_grouped_errors(match_place={:?}, match_span={:?})\",\n+            match_place, match_span\n+        );\n+\n+        let from_simple_let = match_place.is_none();\n+        let match_place = match_place.as_ref().unwrap_or(move_from);\n+\n+        match self.move_data.rev_lookup.find(match_place) {\n+            // Error with the match place\n+            LookupResult::Parent(_) => {\n+                for ge in &mut *grouped_errors {\n+                    if let GroupedMoveError::MovesFromMatchPlace { span, binds_to, .. } = ge {\n+                        if match_span == *span {\n+                            debug!(\"appending local({:?}) to list\", bind_to);\n+                            if !binds_to.is_empty() {\n+                                binds_to.push(bind_to);\n+                            }\n+                            return;\n+                        }\n+                    }\n+                }\n+                debug!(\"found a new move error location\");\n+\n+                // Don't need to point to x in let x = ... .\n+                let binds_to = if from_simple_let {\n+                    vec![]\n+                } else {\n+                    vec![bind_to]\n+                };\n+                grouped_errors.push(GroupedMoveError::MovesFromMatchPlace {\n+                    span: match_span,\n+                    move_from: match_place.clone(),\n+                    kind,\n+                    binds_to,\n+                });\n+            }\n+            // Error with the pattern\n+            LookupResult::Exact(_) => {\n+                let mpi = match self.move_data.rev_lookup.find(move_from) {\n+                    LookupResult::Parent(Some(mpi)) => mpi,\n+                    // move_from should be a projection from match_place.\n+                    _ => unreachable!(\"Probably not unreachable...\"),\n+                };\n+                for ge in &mut *grouped_errors {\n+                    if let GroupedMoveError::MovesFromPattern {\n+                        span,\n+                        move_from: other_mpi,\n+                        binds_to,\n+                        ..\n+                    } = ge\n+                    {\n+                        if match_span == *span && mpi == *other_mpi {\n+                            debug!(\"appending local({:?}) to list\", bind_to);\n+                            binds_to.push(bind_to);\n+                            return;\n+                        }\n+                    }\n+                }\n+                debug!(\"found a new move error location\");\n+                grouped_errors.push(GroupedMoveError::MovesFromPattern {\n+                    span: match_span,\n+                    move_from: mpi,\n+                    kind,\n+                    binds_to: vec![bind_to],\n+                });\n+            }\n+        };\n+    }\n+\n+    fn report(self, error: GroupedMoveError<'tcx>) {\n+        let (mut err, err_span) = {\n+            let (span, kind): (Span, &IllegalMoveOriginKind) = match error {\n+                GroupedMoveError::MovesFromMatchPlace { span, ref kind, .. }\n+                | GroupedMoveError::MovesFromPattern { span, ref kind, .. }\n+                | GroupedMoveError::OtherIllegalMove { span, ref kind } => (span, kind),\n+            };\n+            let origin = Origin::Mir;\n+            (\n+                match kind {\n+                    IllegalMoveOriginKind::Static => {\n+                        self.tcx.cannot_move_out_of(span, \"static item\", origin)\n+                    }\n+                    IllegalMoveOriginKind::BorrowedContent { target_ty: ty } => {\n+                        // Inspect the type of the content behind the\n+                        // borrow to provide feedback about why this\n+                        // was a move rather than a copy.\n+                        match ty.sty {\n+                            ty::TyArray(..) | ty::TySlice(..) => self\n+                                .tcx\n+                                .cannot_move_out_of_interior_noncopy(span, ty, None, origin),\n+                            _ => self\n+                                .tcx\n+                                .cannot_move_out_of(span, \"borrowed content\", origin),\n+                        }\n+                    }\n+                    IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } => {\n+                        self.tcx\n+                            .cannot_move_out_of_interior_of_drop(span, ty, origin)\n+                    }\n+                    IllegalMoveOriginKind::InteriorOfSliceOrArray { ty, is_index } => self\n+                        .tcx\n+                        .cannot_move_out_of_interior_noncopy(span, ty, Some(*is_index), origin),\n+                },\n+                span,\n+            )\n+        };\n+\n+        self.add_move_hints(error, &mut err, err_span);\n+        err.emit();\n+    }\n+\n+    fn add_move_hints(\n+        self,\n+        error: GroupedMoveError<'tcx>,\n+        err: &mut DiagnosticBuilder<'a>,\n+        span: Span,\n+    ) {\n+        match error {\n+            GroupedMoveError::MovesFromMatchPlace {\n+                mut binds_to,\n+                move_from,\n+                ..\n+            } => {\n+                // Ok to suggest a borrow, since the target can't be moved from\n+                // anyway.\n+                if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n+                    match move_from {\n+                        Place::Projection(ref proj)\n+                            if self.suitable_to_remove_deref(proj, &snippet) =>\n+                        {\n+                            err.span_suggestion(\n+                                span,\n+                                \"consider removing this dereference operator\",\n+                                format!(\"{}\", &snippet[1..]),\n+                            );\n+                        }\n+                        _ => {\n+                            err.span_suggestion(\n+                                span,\n+                                \"consider using a reference instead\",\n+                                format!(\"&{}\", snippet),\n+                            );\n+                        }\n+                    }\n+\n+                    binds_to.sort();\n+                    binds_to.dedup();\n+                    for local in binds_to {\n+                        let bind_to = &self.mir.local_decls[local];\n+                        let binding_span = bind_to.source_info.span;\n+                        err.span_label(\n+                            binding_span,\n+                            format!(\n+                                \"move occurs because {} has type `{}`, \\\n+                                 which does not implement the `Copy` trait\",\n+                                bind_to.name.unwrap(),\n+                                bind_to.ty\n+                            ),\n+                        );\n+                    }\n+                }\n+            }\n+            GroupedMoveError::MovesFromPattern { mut binds_to, .. } => {\n+                // Suggest ref, since there might be a move in\n+                // another match arm\n+                binds_to.sort();\n+                binds_to.dedup();\n+                for local in binds_to {\n+                    let bind_to = &self.mir.local_decls[local];\n+                    let binding_span = bind_to.source_info.span;\n+\n+                    // Suggest ref mut when the user has already written mut.\n+                    let ref_kind = match bind_to.mutability {\n+                        Mutability::Not => \"ref\",\n+                        Mutability::Mut => \"ref mut\",\n+                    };\n+                    match bind_to.name {\n+                        Some(name) => {\n+                            err.span_suggestion(\n+                                binding_span,\n+                                \"to prevent move, use ref or ref mut\",\n+                                format!(\"{} {:?}\", ref_kind, name),\n+                            );\n+                        }\n+                        None => {\n+                            err.span_label(\n+                                span,\n+                                format!(\"Local {:?} is not suitable for ref\", bind_to),\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+            // Nothing to suggest.\n+            GroupedMoveError::OtherIllegalMove { .. } => (),\n+        }\n+    }\n+\n+    fn suitable_to_remove_deref(self, proj: &PlaceProjection<'tcx>, snippet: &str) -> bool {\n+        let is_shared_ref = |ty: ty::Ty| match ty.sty {\n+            ty::TypeVariants::TyRef(.., hir::Mutability::MutImmutable) => true,\n+            _ => false,\n+        };\n+\n+        proj.elem == ProjectionElem::Deref && snippet.starts_with('*') && match proj.base {\n+            Place::Local(local) => {\n+                let local_decl = &self.mir.local_decls[local];\n+                // If this is a temporary, then this could be from an\n+                // overloaded * operator.\n+                local_decl.is_user_variable.is_some() && is_shared_ref(local_decl.ty)\n+            }\n+            Place::Static(ref st) => is_shared_ref(st.ty),\n+            Place::Projection(ref proj) => match proj.elem {\n+                ProjectionElem::Field(_, ty) => is_shared_ref(ty),\n+                _ => false,\n+            },\n+        }\n+    }\n+}"}, {"sha": "bbbe757e96ec68fd49f9f27030f9e3ddae0ef867", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0193d1f736b755004e15b7c1bc41467b177845cf/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0193d1f736b755004e15b7c1bc41467b177845cf/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=0193d1f736b755004e15b7c1bc41467b177845cf", "patch": "@@ -115,11 +115,21 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // Declare the bindings, which may create a source scope.\n                     let remainder_span = remainder_scope.span(this.hir.tcx(),\n                                                               &this.hir.region_scope_tree);\n-                    let scope = this.declare_bindings(None, remainder_span, lint_level, &pattern,\n-                                                      ArmHasGuard(false));\n+\n+                    let scope;\n \n                     // Evaluate the initializer, if present.\n                     if let Some(init) = initializer {\n+                        let initializer_span = init.span();\n+\n+                        scope = this.declare_bindings(\n+                            None,\n+                            remainder_span,\n+                            lint_level,\n+                            &pattern,\n+                            ArmHasGuard(false),\n+                            Some((None, initializer_span)),\n+                        );\n                         unpack!(block = this.in_opt_scope(\n                             opt_destruction_scope.map(|de|(de, source_info)), block, |this| {\n                                 let scope = (init_scope, source_info);\n@@ -128,6 +138,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                 })\n                             }));\n                     } else {\n+                        scope = this.declare_bindings(None, remainder_span, lint_level, &pattern,\n+                                                        ArmHasGuard(false), None);\n+\n                         // FIXME(#47184): We currently only insert `UserAssertTy` statements for\n                         // patterns that are bindings, this is as we do not want to deconstruct\n                         // the type being assertion to match the pattern."}, {"sha": "79dbdfefeb8e129fc194dab843d5d286f9b0cde0", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0193d1f736b755004e15b7c1bc41467b177845cf/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0193d1f736b755004e15b7c1bc41467b177845cf/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=0193d1f736b755004e15b7c1bc41467b177845cf", "patch": "@@ -44,6 +44,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                       arms: Vec<Arm<'tcx>>)\n                       -> BlockAnd<()> {\n         let tcx = self.hir.tcx();\n+        let discriminant_span = discriminant.span();\n         let discriminant_place = unpack!(block = self.as_place(block, discriminant));\n \n         // Matching on a `discriminant_place` with an uninhabited type doesn't\n@@ -96,7 +97,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let scope = self.declare_bindings(None, body.span,\n                                               LintLevel::Inherited,\n                                               &arm.patterns[0],\n-                                              ArmHasGuard(arm.guard.is_some()));\n+                                              ArmHasGuard(arm.guard.is_some()),\n+                                              Some((Some(&discriminant_place), discriminant_span)));\n             (body, scope.unwrap_or(self.source_scope))\n         }).collect();\n \n@@ -254,15 +256,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n             _ => {\n                 let place = unpack!(block = self.as_place(block, initializer));\n-                self.place_into_pattern(block, irrefutable_pat, &place)\n+                self.place_into_pattern(block, irrefutable_pat, &place, true)\n             }\n         }\n     }\n \n     pub fn place_into_pattern(&mut self,\n                                mut block: BasicBlock,\n                                irrefutable_pat: Pattern<'tcx>,\n-                               initializer: &Place<'tcx>)\n+                               initializer: &Place<'tcx>,\n+                               set_match_place: bool)\n                                -> BlockAnd<()> {\n         // create a dummy candidate\n         let mut candidate = Candidate {\n@@ -288,6 +291,25 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                       candidate.match_pairs);\n         }\n \n+        // for matches and function arguments, the place that is being matched\n+        // can be set when creating the variables. But the place for\n+        // let PATTERN = ... might not even exist until we do the assignment.\n+        // so we set it here instead\n+        if set_match_place {\n+            for binding in &candidate.bindings {\n+                let local = self.var_local_id(binding.var_id, OutsideGuard);\n+\n+                if let Some(ClearCrossCrate::Set(BindingForm::Var(\n+                    VarBindingForm {opt_match_place: Some((ref mut match_place, _)), .. }\n+                ))) = self.local_decls[local].is_user_variable\n+                {\n+                    *match_place = Some(initializer.clone());\n+                } else {\n+                    bug!(\"Let binding to non-user variable.\")\n+                }\n+            }\n+        }\n+\n         // now apply the bindings, which will also declare the variables\n         self.bind_matched_candidate_for_arm_body(block, &candidate.bindings);\n \n@@ -302,7 +324,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             scope_span: Span,\n                             lint_level: LintLevel,\n                             pattern: &Pattern<'tcx>,\n-                            has_guard: ArmHasGuard)\n+                            has_guard: ArmHasGuard,\n+                            opt_match_place: Option<(Option<&Place<'tcx>>, Span)>)\n                             -> Option<SourceScope> {\n         assert!(!(visibility_scope.is_some() && lint_level.is_explicit()),\n                 \"can't have both a visibility and a lint scope at the same time\");\n@@ -326,7 +349,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             };\n             let visibility_scope = visibility_scope.unwrap();\n             this.declare_binding(source_info, visibility_scope, mutability, name, mode, var,\n-                                 ty, has_guard);\n+                                 ty, has_guard, opt_match_place.map(|(x, y)| (x.cloned(), y)));\n         });\n         visibility_scope\n     }\n@@ -1121,7 +1144,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                        mode: BindingMode,\n                        var_id: NodeId,\n                        var_ty: Ty<'tcx>,\n-                       has_guard: ArmHasGuard)\n+                       has_guard: ArmHasGuard,\n+                       opt_match_place: Option<(Option<Place<'tcx>>, Span)>)\n     {\n         debug!(\"declare_binding(var_id={:?}, name={:?}, mode={:?}, var_ty={:?}, \\\n                 visibility_scope={:?}, source_info={:?})\",\n@@ -1146,6 +1170,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // idents in pat; but complex w/ unclear UI payoff.\n                 // Instead, just abandon providing diagnostic info.\n                 opt_ty_info: None,\n+                opt_match_place,\n             }))),\n         };\n         let for_arm_body = self.local_decls.push(local.clone());"}, {"sha": "cdbb2a13e0ef22141bd3755502c2601ec9c7f4b6", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0193d1f736b755004e15b7c1bc41467b177845cf/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0193d1f736b755004e15b7c1bc41467b177845cf/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=0193d1f736b755004e15b7c1bc41467b177845cf", "patch": "@@ -705,6 +705,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             if let Some(pattern) = pattern {\n                 let pattern = self.hir.pattern_from_hir(pattern);\n+                let span = pattern.span;\n \n                 match *pattern.kind {\n                     // Don't introduce extra copies for simple bindings\n@@ -716,15 +717,19 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             } else {\n                                 let binding_mode = ty::BindingMode::BindByValue(mutability.into());\n                                 Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                                    binding_mode, opt_ty_info })))\n+                                    binding_mode,\n+                                    opt_ty_info,\n+                                    opt_match_place: Some((Some(place.clone()), span)),\n+                                })))\n                             };\n                         self.var_indices.insert(var, LocalsForNode::One(local));\n                     }\n                     _ => {\n                         scope = self.declare_bindings(scope, ast_body.span,\n                                                       LintLevel::Inherited, &pattern,\n-                                                      matches::ArmHasGuard(false));\n-                        unpack!(block = self.place_into_pattern(block, pattern, &place));\n+                                                      matches::ArmHasGuard(false),\n+                                                      Some((Some(&place), span)));\n+                        unpack!(block = self.place_into_pattern(block, pattern, &place, false));\n                     }\n                 }\n             }"}, {"sha": "9ffbe21e1e2cce12dc35ec2987e97e8a7a251b09", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0193d1f736b755004e15b7c1bc41467b177845cf/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0193d1f736b755004e15b7c1bc41467b177845cf/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=0193d1f736b755004e15b7c1bc41467b177845cf", "patch": "@@ -109,8 +109,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n         match *place {\n             Place::Local(local) => Ok(self.builder.data.rev_lookup.locals[local]),\n             Place::Static(..) => {\n-                let span = self.builder.mir.source_info(self.loc).span;\n-                Err(MoveError::cannot_move_out_of(span, Static))\n+                Err(MoveError::cannot_move_out_of(self.loc, Static))\n             }\n             Place::Projection(ref proj) => {\n                 self.move_path_for_projection(place, proj)\n@@ -133,13 +132,13 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n         let mir = self.builder.mir;\n         let tcx = self.builder.tcx;\n         let place_ty = proj.base.ty(mir, tcx).to_ty(tcx);\n-        match place_ty.sty {\n+ match place_ty.sty {\n             ty::TyRef(..) | ty::TyRawPtr(..) =>\n                 return Err(MoveError::cannot_move_out_of(\n-                    mir.source_info(self.loc).span,\n+                    self.loc,\n                     BorrowedContent { target_ty: place.ty(mir, tcx).to_ty(tcx) })),\n             ty::TyAdt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() =>\n-                return Err(MoveError::cannot_move_out_of(mir.source_info(self.loc).span,\n+                return Err(MoveError::cannot_move_out_of(self.loc,\n                                                          InteriorOfTypeWithDestructor {\n                     container_ty: place_ty\n                 })),\n@@ -148,7 +147,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n                 return Err(MoveError::UnionMove { path: base }),\n             ty::TySlice(_) =>\n                 return Err(MoveError::cannot_move_out_of(\n-                    mir.source_info(self.loc).span,\n+                    self.loc,\n                     InteriorOfSliceOrArray {\n                         ty: place_ty, is_index: match proj.elem {\n                             ProjectionElem::Index(..) => true,\n@@ -158,7 +157,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n             ty::TyArray(..) => match proj.elem {\n                 ProjectionElem::Index(..) =>\n                     return Err(MoveError::cannot_move_out_of(\n-                        mir.source_info(self.loc).span,\n+                        self.loc,\n                         InteriorOfSliceOrArray {\n                             ty: place_ty, is_index: true\n                         })),"}, {"sha": "3051a687eac7008c519c32b4d51ed3b854e39ce6", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0193d1f736b755004e15b7c1bc41467b177845cf/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0193d1f736b755004e15b7c1bc41467b177845cf/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=0193d1f736b755004e15b7c1bc41467b177845cf", "patch": "@@ -209,7 +209,7 @@ pub enum InitKind {\n     Deep,\n     /// Only does a shallow init\n     Shallow,\n-    /// This doesn't initialize the variabe on panic (and a panic is possible).\n+    /// This doesn't initialize the variable on panic (and a panic is possible).\n     NonPanicPathOnly,\n }\n \n@@ -271,7 +271,7 @@ impl<'tcx> MovePathLookup<'tcx> {\n \n #[derive(Debug)]\n pub struct IllegalMoveOrigin<'tcx> {\n-    pub(crate) span: Span,\n+    pub(crate) location: Location,\n     pub(crate) kind: IllegalMoveOriginKind<'tcx>,\n }\n \n@@ -304,8 +304,8 @@ pub enum MoveError<'tcx> {\n }\n \n impl<'tcx> MoveError<'tcx> {\n-    fn cannot_move_out_of(span: Span, kind: IllegalMoveOriginKind<'tcx>) -> Self {\n-        let origin = IllegalMoveOrigin { span, kind };\n+    fn cannot_move_out_of(location: Location, kind: IllegalMoveOriginKind<'tcx>) -> Self {\n+        let origin = IllegalMoveOrigin { location, kind };\n         MoveError::IllegalMove { cannot_move_out_of: origin }\n     }\n }"}, {"sha": "a8d29df86908d5d4d009a147179cc8d80099843a", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0193d1f736b755004e15b7c1bc41467b177845cf/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0193d1f736b755004e15b7c1bc41467b177845cf/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=0193d1f736b755004e15b7c1bc41467b177845cf", "patch": "@@ -315,6 +315,15 @@ pub enum LogicalOp {\n     Or,\n }\n \n+impl<'tcx> ExprRef<'tcx> {\n+    pub fn span(&self) -> Span {\n+        match self {\n+            ExprRef::Hair(expr) => expr.span,\n+            ExprRef::Mirror(expr) => expr.span,\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // The Mirror trait\n "}]}