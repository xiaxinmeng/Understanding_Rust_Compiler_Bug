{"sha": "1bb91be05f3e947364de8f6781124003ce2404ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiYjkxYmUwNWYzZTk0NzM2NGRlOGY2NzgxMTI0MDAzY2UyNDA0YWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-25T18:49:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-25T18:49:56Z"}, "message": "Auto merge of #30044 - nikomatsakis:issue-29466, r=arielb1\n\nThe graph extent mechanism is not good. I have some ideas for a better replacement, but this PR simply removes it. It also stops recursing on statement scopes and processes them using an \"on the heap\" stack, which fixes #29466.\n\nr? @dotdash", "tree": {"sha": "8a9f2f8b2c0b9400ed36e6b0108e931f767a1794", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a9f2f8b2c0b9400ed36e6b0108e931f767a1794"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1bb91be05f3e947364de8f6781124003ce2404ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1bb91be05f3e947364de8f6781124003ce2404ab", "html_url": "https://github.com/rust-lang/rust/commit/1bb91be05f3e947364de8f6781124003ce2404ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1bb91be05f3e947364de8f6781124003ce2404ab/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b9a13e6ba83a5619b628c1534b1c6d566157f62", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b9a13e6ba83a5619b628c1534b1c6d566157f62", "html_url": "https://github.com/rust-lang/rust/commit/1b9a13e6ba83a5619b628c1534b1c6d566157f62"}, {"sha": "1fe7525180dbd11b101ce65439218a8be4e2d528", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fe7525180dbd11b101ce65439218a8be4e2d528", "html_url": "https://github.com/rust-lang/rust/commit/1fe7525180dbd11b101ce65439218a8be4e2d528"}], "stats": {"total": 3850, "additions": 3711, "deletions": 139}, "files": [{"sha": "e44e3936885244c5e2403e6a8e3d4f4aa0e1ae24", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1bb91be05f3e947364de8f6781124003ce2404ab/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bb91be05f3e947364de8f6781124003ce2404ab/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=1bb91be05f3e947364de8f6781124003ce2404ab", "patch": "@@ -26,13 +26,6 @@ impl<'tcx> CFG<'tcx> {\n         &mut self.basic_blocks[blk.index()]\n     }\n \n-    pub fn end_point(&self, block: BasicBlock) -> ExecutionPoint {\n-        ExecutionPoint {\n-            block: block,\n-            statement: self.block_data(block).statements.len() as u32,\n-        }\n-    }\n-\n     pub fn start_new_block(&mut self) -> BasicBlock {\n         let node_index = self.basic_blocks.len();\n         self.basic_blocks.push(BasicBlockData::new(Terminator::Diverge));"}, {"sha": "3f3bceef1ebc37a203cb8350b06b089c29eae332", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bb91be05f3e947364de8f6781124003ce2404ab/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bb91be05f3e947364de8f6781124003ce2404ab/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=1bb91be05f3e947364de8f6781124003ce2404ab", "patch": "@@ -70,7 +70,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 this.cfg.push_assign(block, expr_span, &result, rvalue);\n \n                 // schedule a shallow free of that memory, lest we unwind:\n-                let extent = this.extent_of_innermost_scope().unwrap();\n+                let extent = this.extent_of_innermost_scope();\n                 this.schedule_drop(expr_span, extent, DropKind::Free, &result, value_ty);\n \n                 // initialize the box contents:"}, {"sha": "7d79e90b3f188ddcf098725a016bacfffa9cdb56", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bb91be05f3e947364de8f6781124003ce2404ab/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bb91be05f3e947364de8f6781124003ce2404ab/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=1bb91be05f3e947364de8f6781124003ce2404ab", "patch": "@@ -206,7 +206,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             }\n             ExprKind::Return { value } => {\n                 unpack!(block = this.into(&Lvalue::ReturnPointer, block, value));\n-                let extent = this.extent_of_outermost_scope().unwrap();\n+                let extent = this.extent_of_outermost_scope();\n                 this.exit_scope(expr_span, extent, block, END_BLOCK);\n                 this.cfg.start_new_block().unit()\n             }"}, {"sha": "cc6155844bc9a7b060d8e17372936ce5959c5abd", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bb91be05f3e947364de8f6781124003ce2404ab/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bb91be05f3e947364de8f6781124003ce2404ab/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=1bb91be05f3e947364de8f6781124003ce2404ab", "patch": "@@ -42,7 +42,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // suitable extent for all of the bindings in this match. It's\n         // easiest to do this up front because some of these arms may\n         // be unreachable or reachable multiple times.\n-        let var_extent = self.extent_of_innermost_scope().unwrap();\n+        let var_extent = self.extent_of_innermost_scope();\n         for arm in &arms {\n             self.declare_bindings(var_extent, &arm.patterns[0]);\n         }"}, {"sha": "f67c2920ba39f935b3f6d3c828a145bc4d0f2812", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1bb91be05f3e947364de8f6781124003ce2404ab/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bb91be05f3e947364de8f6781124003ce2404ab/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=1bb91be05f3e947364de8f6781124003ce2404ab", "patch": "@@ -19,7 +19,6 @@ use syntax::codemap::Span;\n \n struct Builder<'a, 'tcx: 'a> {\n     hir: Cx<'a, 'tcx>,\n-    extents: FnvHashMap<CodeExtent, Vec<GraphExtent>>,\n     cfg: CFG<'tcx>,\n     scopes: Vec<scope::Scope<'tcx>>,\n     loop_scopes: Vec<scope::LoopScope>,\n@@ -92,7 +91,6 @@ pub fn construct<'a,'tcx>(mut hir: Cx<'a,'tcx>,\n     let mut builder = Builder {\n         hir: hir,\n         cfg: cfg,\n-        extents: FnvHashMap(),\n         scopes: vec![],\n         loop_scopes: vec![],\n         temp_decls: temp_decls,\n@@ -117,7 +115,6 @@ pub fn construct<'a,'tcx>(mut hir: Cx<'a,'tcx>,\n \n     Mir {\n         basic_blocks: builder.cfg.basic_blocks,\n-        extents: builder.extents,\n         var_decls: builder.var_decls,\n         arg_decls: arg_decls,\n         temp_decls: builder.temp_decls,"}, {"sha": "1f3b6ad7bceff09a15f2316c748fed26740e038e", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 31, "deletions": 43, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1bb91be05f3e947364de8f6781124003ce2404ab/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bb91be05f3e947364de8f6781124003ce2404ab/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=1bb91be05f3e947364de8f6781124003ce2404ab", "patch": "@@ -94,7 +94,6 @@ use syntax::codemap::Span;\n \n pub struct Scope<'tcx> {\n     extent: CodeExtent,\n-    exits: Vec<ExecutionPoint>,\n     drops: Vec<(DropKind, Span, Lvalue<'tcx>)>,\n     cached_block: Option<BasicBlock>,\n }\n@@ -116,7 +115,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                -> BlockAnd<R>\n         where F: FnOnce(&mut Builder<'a, 'tcx>) -> BlockAnd<R>\n     {\n-        let extent = self.extent_of_innermost_scope().unwrap();\n+        let extent = self.extent_of_innermost_scope();\n         let loop_scope = LoopScope {\n             extent: extent.clone(),\n             continue_block: loop_block,\n@@ -128,60 +127,51 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         r\n     }\n \n-    /// Start a scope. The closure `f` should translate the contents\n-    /// of the scope. See module comment for more details.\n-    pub fn in_scope<F, R>(&mut self, extent: CodeExtent, block: BasicBlock, f: F) -> BlockAnd<R>\n+    /// Convenience wrapper that pushes a scope and then executes `f`\n+    /// to build its contents, popping the scope afterwards.\n+    pub fn in_scope<F, R>(&mut self, extent: CodeExtent, mut block: BasicBlock, f: F) -> BlockAnd<R>\n         where F: FnOnce(&mut Builder<'a, 'tcx>) -> BlockAnd<R>\n     {\n         debug!(\"in_scope(extent={:?}, block={:?})\", extent, block);\n+        self.push_scope(extent, block);\n+        let rv = unpack!(block = f(self));\n+        self.pop_scope(extent, block);\n+        debug!(\"in_scope: exiting extent={:?} block={:?}\", extent, block);\n+        block.and(rv)\n+    }\n \n-        let start_point = self.cfg.end_point(block);\n+    /// Push a scope onto the stack. You can then build code in this\n+    /// scope and call `pop_scope` afterwards. Note that these two\n+    /// calls must be paired; using `in_scope` as a convenience\n+    /// wrapper maybe preferable.\n+    pub fn push_scope(&mut self, extent: CodeExtent, block: BasicBlock) {\n+        debug!(\"push_scope({:?}, {:?})\", extent, block);\n \n         // push scope, execute `f`, then pop scope again\n         self.scopes.push(Scope {\n             extent: extent.clone(),\n             drops: vec![],\n-            exits: vec![],\n             cached_block: None,\n         });\n-        let BlockAnd(fallthrough_block, rv) = f(self);\n-        let mut scope = self.scopes.pop().unwrap();\n+    }\n+\n+    /// Pops a scope, which should have extent `extent`, adding any\n+    /// drops onto the end of `block` that are needed.  This must\n+    /// match 1-to-1 with `push_scope`.\n+    pub fn pop_scope(&mut self, extent: CodeExtent, block: BasicBlock) {\n+        debug!(\"pop_scope({:?}, {:?})\", extent, block);\n+        let scope = self.scopes.pop().unwrap();\n+\n+        assert_eq!(scope.extent, extent);\n \n         // add in any drops needed on the fallthrough path (any other\n         // exiting paths, such as those that arise from `break`, will\n         // have drops already)\n         for (kind, span, lvalue) in scope.drops {\n-            self.cfg.push_drop(fallthrough_block, span, kind, &lvalue);\n+            self.cfg.push_drop(block, span, kind, &lvalue);\n         }\n-\n-        // add the implicit fallthrough edge\n-        scope.exits.push(self.cfg.end_point(fallthrough_block));\n-\n-        // compute the extent from start to finish and store it in the graph\n-        let graph_extent = self.graph_extent(start_point, scope.exits);\n-        self.extents.entry(extent)\n-                    .or_insert(vec![])\n-                    .push(graph_extent);\n-\n-        debug!(\"in_scope: exiting extent={:?} fallthrough_block={:?}\", extent, fallthrough_block);\n-        fallthrough_block.and(rv)\n     }\n \n-    /// Creates a graph extent (SEME region) from an entry point and\n-    /// exit points.\n-    fn graph_extent(&self, entry: ExecutionPoint, exits: Vec<ExecutionPoint>) -> GraphExtent {\n-        if exits.len() == 1 && entry.block == exits[0].block {\n-            GraphExtent {\n-                entry: entry,\n-                exit: GraphExtentExit::Statement(exits[0].statement),\n-            }\n-        } else {\n-            GraphExtent {\n-                entry: entry,\n-                exit: GraphExtentExit::Points(exits),\n-            }\n-        }\n-    }\n \n     /// Finds the loop scope for a given label. This is used for\n     /// resolving `break` and `continue`.\n@@ -232,8 +222,6 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             for &(kind, drop_span, ref lvalue) in &scope.drops {\n                 self.cfg.push_drop(block, drop_span, kind, lvalue);\n             }\n-\n-            scope.exits.push(self.cfg.end_point(block));\n         }\n \n         self.cfg.terminate(block, Terminator::Goto { target: target });\n@@ -272,12 +260,12 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         }\n     }\n \n-    pub fn extent_of_innermost_scope(&self) -> Option<CodeExtent> {\n-        self.scopes.last().map(|scope| scope.extent)\n+    pub fn extent_of_innermost_scope(&self) -> CodeExtent {\n+        self.scopes.last().map(|scope| scope.extent).unwrap()\n     }\n \n-    pub fn extent_of_outermost_scope(&self) -> Option<CodeExtent> {\n-        self.scopes.first().map(|scope| scope.extent)\n+    pub fn extent_of_outermost_scope(&self) -> CodeExtent {\n+        self.scopes.first().map(|scope| scope.extent).unwrap()\n     }\n }\n "}, {"sha": "ac6b2a3c5313fc17e1e2ef5de38de969631770c6", "filename": "src/librustc_mir/build/stmt.rs", "status": "modified", "additions": 58, "deletions": 36, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/1bb91be05f3e947364de8f6781124003ce2404ab/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bb91be05f3e947364de8f6781124003ce2404ab/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs?ref=1bb91be05f3e947364de8f6781124003ce2404ab", "patch": "@@ -14,48 +14,70 @@ use repr::*;\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n     pub fn stmts(&mut self, mut block: BasicBlock, stmts: Vec<StmtRef<'tcx>>) -> BlockAnd<()> {\n-        for stmt in stmts {\n-            unpack!(block = self.stmt(block, stmt));\n-        }\n-        block.unit()\n-    }\n-\n-    pub fn stmt(&mut self, mut block: BasicBlock, stmt: StmtRef<'tcx>) -> BlockAnd<()> {\n+        // This convoluted structure is to avoid using recursion as we walk down a list\n+        // of statements. Basically, the structure we get back is something like:\n+        //\n+        //    let x = <init> in {\n+        //       let y = <init> in {\n+        //           expr1;\n+        //           expr2;\n+        //       }\n+        //    }\n+        //\n+        // To process this, we keep a stack of (Option<CodeExtent>,\n+        // vec::IntoIter<Stmt>) pairs.  At each point we pull off the\n+        // top most pair and extract one statement from the\n+        // iterator. Once it's complete, we pop the scope from the\n+        // first half the pair.\n         let this = self;\n-        let Stmt { span, kind } = this.hir.mirror(stmt);\n-        match kind {\n-            StmtKind::Let { remainder_scope,\n-                            init_scope,\n-                            pattern,\n-                            initializer: Some(initializer),\n-                            stmts } => {\n-                this.in_scope(remainder_scope, block, |this| {\n-                    unpack!(block = this.in_scope(init_scope, block, |this| {\n-                        this.expr_into_pattern(block, remainder_scope, pattern, initializer)\n+        let mut stmt_lists = vec![(None, stmts.into_iter())];\n+        while !stmt_lists.is_empty() {\n+            let stmt = {\n+                let &mut (_, ref mut stmts) = stmt_lists.last_mut().unwrap();\n+                stmts.next()\n+            };\n+\n+            let stmt = match stmt {\n+                Some(stmt) => stmt,\n+                None => {\n+                    let (extent, _) = stmt_lists.pop().unwrap();\n+                    if let Some(extent) = extent {\n+                        this.pop_scope(extent, block);\n+                    }\n+                    continue\n+                }\n+            };\n+\n+            let Stmt { span, kind } = this.hir.mirror(stmt);\n+            match kind {\n+                StmtKind::Let { remainder_scope, init_scope, pattern, initializer, stmts } => {\n+                    this.push_scope(remainder_scope, block);\n+                    stmt_lists.push((Some(remainder_scope), stmts.into_iter()));\n+                    unpack!(block = this.in_scope(init_scope, block, move |this| {\n+                        // FIXME #30046                              ^~~~\n+                        match initializer {\n+                            Some(initializer) => {\n+                                this.expr_into_pattern(block, remainder_scope, pattern, initializer)\n+                            }\n+                            None => {\n+                                this.declare_bindings(remainder_scope, &pattern);\n+                                block.unit()\n+                            }\n+                        }\n                     }));\n-                    this.stmts(block, stmts)\n-                })\n-            }\n+                }\n \n-            StmtKind::Let { remainder_scope, init_scope, pattern, initializer: None, stmts } => {\n-                this.in_scope(remainder_scope, block, |this| {\n-                    unpack!(block = this.in_scope(init_scope, block, |this| {\n-                        this.declare_bindings(remainder_scope, &pattern);\n+                StmtKind::Expr { scope, expr } => {\n+                    unpack!(block = this.in_scope(scope, block, |this| {\n+                        let expr = this.hir.mirror(expr);\n+                        let temp = this.temp(expr.ty.clone());\n+                        unpack!(block = this.into(&temp, block, expr));\n+                        this.cfg.push_drop(block, span, DropKind::Deep, &temp);\n                         block.unit()\n                     }));\n-                    this.stmts(block, stmts)\n-                })\n-            }\n-\n-            StmtKind::Expr { scope, expr } => {\n-                this.in_scope(scope, block, |this| {\n-                    let expr = this.hir.mirror(expr);\n-                    let temp = this.temp(expr.ty.clone());\n-                    unpack!(block = this.into(&temp, block, expr));\n-                    this.cfg.push_drop(block, span, DropKind::Deep, &temp);\n-                    block.unit()\n-                })\n+                }\n             }\n         }\n+        block.unit()\n     }\n }"}, {"sha": "dad8961a7883a0eda268df9d1cb0428e4420f667", "filename": "src/librustc_mir/repr.rs", "status": "modified", "additions": 12, "deletions": 47, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/1bb91be05f3e947364de8f6781124003ce2404ab/src%2Flibrustc_mir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bb91be05f3e947364de8f6781124003ce2404ab/src%2Flibrustc_mir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Frepr.rs?ref=1bb91be05f3e947364de8f6781124003ce2404ab", "patch": "@@ -10,11 +10,9 @@\n \n use rustc::middle::const_eval::ConstVal;\n use rustc::middle::def_id::DefId;\n-use rustc::middle::region::CodeExtent;\n use rustc::middle::subst::Substs;\n use rustc::middle::ty::{AdtDef, ClosureSubsts, FnOutput, Region, Ty};\n use rustc_back::slice;\n-use rustc_data_structures::fnv::FnvHashMap;\n use rustc_front::hir::InlineAsm;\n use syntax::ast::Name;\n use syntax::codemap::Span;\n@@ -23,15 +21,24 @@ use std::u32;\n \n /// Lowered representation of a single function.\n pub struct Mir<'tcx> {\n+    /// List of basic blocks. References to basic block use a newtyped index type `BasicBlock`\n+    /// that indexes into this vector.\n     pub basic_blocks: Vec<BasicBlockData<'tcx>>,\n \n+    /// Return type of the function.\n     pub return_ty: FnOutput<'tcx>,\n \n-    // for every node id\n-    pub extents: FnvHashMap<CodeExtent, Vec<GraphExtent>>,\n-\n+    /// Variables: these are stack slots corresponding to user variables. They may be\n+    /// assigned many times.\n     pub var_decls: Vec<VarDecl<'tcx>>,\n+\n+    /// Args: these are stack slots corresponding to the input arguments.\n     pub arg_decls: Vec<ArgDecl<'tcx>>,\n+\n+    /// Temp declarations: stack slots that for temporaries created by\n+    /// the compiler. These are assigned once, but they are not SSA\n+    /// values in that it is possible to borrow them and mutate them\n+    /// through the resulting reference.\n     pub temp_decls: Vec<TempDecl<'tcx>>,\n }\n \n@@ -147,48 +154,6 @@ pub struct ArgDecl<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// Graph extents\n-\n-/// A moment in the flow of execution. It corresponds to a point in\n-/// between two statements:\n-///\n-///    BB[block]:\n-///                          <--- if statement == 0\n-///        STMT[0]\n-///                          <--- if statement == 1\n-///        STMT[1]\n-///        ...\n-///                          <--- if statement == n-1\n-///        STMT[n-1]\n-///                          <--- if statement == n\n-///\n-/// where the block has `n` statements.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub struct ExecutionPoint {\n-    pub block: BasicBlock,\n-    pub statement: u32,\n-}\n-\n-/// A single-entry-multiple-exit region in the graph. We build one of\n-/// these for every node-id during MIR construction. By construction\n-/// we are assured that the entry dominates all points within, and\n-/// that, for every interior point X, it is postdominated by some exit.\n-pub struct GraphExtent {\n-    pub entry: ExecutionPoint,\n-    pub exit: GraphExtentExit,\n-}\n-\n-pub enum GraphExtentExit {\n-    /// `Statement(X)`: a very common special case covering a span\n-    /// that is local to a single block. It starts at the entry point\n-    /// and extends until the start of statement `X` (non-inclusive).\n-    Statement(u32),\n-\n-    /// The more general case where the exits are a set of points.\n-    Points(Vec<ExecutionPoint>),\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // BasicBlock\n "}, {"sha": "9e7b73467229a4f98164d13ca9e68113fc6db531", "filename": "src/test/run-pass/issue-29466.rs", "status": "added", "additions": 3607, "deletions": 0, "changes": 3607, "blob_url": "https://github.com/rust-lang/rust/blob/1bb91be05f3e947364de8f6781124003ce2404ab/src%2Ftest%2Frun-pass%2Fissue-29466.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bb91be05f3e947364de8f6781124003ce2404ab/src%2Ftest%2Frun-pass%2Fissue-29466.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-29466.rs?ref=1bb91be05f3e947364de8f6781124003ce2404ab"}]}