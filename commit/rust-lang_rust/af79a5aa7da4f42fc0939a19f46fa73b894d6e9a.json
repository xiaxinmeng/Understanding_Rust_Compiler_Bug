{"sha": "af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmNzlhNWFhN2RhNGY0MmZjMDkzOWExOWY0NmZhNzNiODk0ZDZlOWE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-03-05T23:28:08Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-03-21T12:37:21Z"}, "message": "test: Make manual changes to deal with the fallout from removal of\n`~[T]` in test, libgetopts, compiletest, librustdoc, and libnum.", "tree": {"sha": "60c2e72eea83a8a4c70c76d6fe91967aeaf77632", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60c2e72eea83a8a4c70c76d6fe91967aeaf77632"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "html_url": "https://github.com/rust-lang/rust/commit/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "579eb2400b3cb5d9cf03a5c8792d63630489193a", "url": "https://api.github.com/repos/rust-lang/rust/commits/579eb2400b3cb5d9cf03a5c8792d63630489193a", "html_url": "https://github.com/rust-lang/rust/commit/579eb2400b3cb5d9cf03a5c8792d63630489193a"}], "stats": {"total": 2746, "additions": 1435, "deletions": 1311}, "files": [{"sha": "3916aa3b2af60157146d84804b10458e6a4e9b94", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -21,6 +21,7 @@ extern crate getopts;\n extern crate log;\n \n use std::os;\n+use std::vec_ng::Vec;\n use std::io;\n use std::io::fs;\n use getopts::{optopt, optflag, reqopt};\n@@ -43,15 +44,15 @@ pub mod errors;\n \n pub fn main() {\n     let args = os::args();\n-    let config = parse_config(args);\n+    let config = parse_config(args.move_iter().collect());\n     log_config(&config);\n     run_tests(&config);\n }\n \n-pub fn parse_config(args: ~[~str]) -> config {\n+pub fn parse_config(args: Vec<~str> ) -> config {\n \n-    let groups : ~[getopts::OptGroup] =\n-        ~[reqopt(\"\", \"compile-lib-path\", \"path to host shared libraries\", \"PATH\"),\n+    let groups : Vec<getopts::OptGroup> =\n+        vec!(reqopt(\"\", \"compile-lib-path\", \"path to host shared libraries\", \"PATH\"),\n           reqopt(\"\", \"run-lib-path\", \"path to target shared libraries\", \"PATH\"),\n           reqopt(\"\", \"rustc-path\", \"path to rustc to use for compiling\", \"PATH\"),\n           optopt(\"\", \"clang-path\", \"path to  executable for codegen tests\", \"PATH\"),\n@@ -79,28 +80,27 @@ pub fn parse_config(args: ~[~str]) -> config {\n           optopt(\"\", \"adb-path\", \"path to the android debugger\", \"PATH\"),\n           optopt(\"\", \"adb-test-dir\", \"path to tests for the android debugger\", \"PATH\"),\n           optopt(\"\", \"test-shard\", \"run shard A, of B shards, worth of the testsuite\", \"A.B\"),\n-          optflag(\"h\", \"help\", \"show this message\"),\n-         ];\n+          optflag(\"h\", \"help\", \"show this message\"));\n \n     assert!(!args.is_empty());\n-    let argv0 = args[0].clone();\n+    let argv0 = (*args.get(0)).clone();\n     let args_ = args.tail();\n-    if args[1] == ~\"-h\" || args[1] == ~\"--help\" {\n+    if *args.get(1) == ~\"-h\" || *args.get(1) == ~\"--help\" {\n         let message = format!(\"Usage: {} [OPTIONS] [TESTNAME...]\", argv0);\n-        println!(\"{}\", getopts::usage(message, groups));\n+        println!(\"{}\", getopts::usage(message, groups.as_slice()));\n         println!(\"\");\n         fail!()\n     }\n \n     let matches =\n-        &match getopts::getopts(args_, groups) {\n+        &match getopts::getopts(args_, groups.as_slice()) {\n           Ok(m) => m,\n           Err(f) => fail!(\"{}\", f.to_err_msg())\n         };\n \n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n         let message = format!(\"Usage: {} [OPTIONS]  [TESTNAME...]\", argv0);\n-        println!(\"{}\", getopts::usage(message, groups));\n+        println!(\"{}\", getopts::usage(message, groups.as_slice()));\n         println!(\"\");\n         fail!()\n     }\n@@ -123,7 +123,7 @@ pub fn parse_config(args: ~[~str]) -> config {\n         run_ignored: matches.opt_present(\"ignored\"),\n         filter:\n             if !matches.free.is_empty() {\n-                 Some(matches.free[0].clone())\n+                 Some((*matches.free.get(0)).clone())\n             } else {\n                 None\n             },\n@@ -239,7 +239,7 @@ pub fn run_tests(config: &config) {\n     // parallel (especially when we have lots and lots of child processes).\n     // For context, see #8904\n     io::test::raise_fd_limit();\n-    let res = test::run_tests_console(&opts, tests);\n+    let res = test::run_tests_console(&opts, tests.move_iter().collect());\n     match res {\n         Ok(true) => {}\n         Ok(false) => fail!(\"Some tests failed\"),\n@@ -263,10 +263,10 @@ pub fn test_opts(config: &config) -> test::TestOpts {\n     }\n }\n \n-pub fn make_tests(config: &config) -> ~[test::TestDescAndFn] {\n+pub fn make_tests(config: &config) -> Vec<test::TestDescAndFn> {\n     debug!(\"making tests from {}\",\n            config.src_base.display());\n-    let mut tests = ~[];\n+    let mut tests = Vec::new();\n     let dirs = fs::readdir(&config.src_base).unwrap();\n     for file in dirs.iter() {\n         let file = file.clone();\n@@ -288,10 +288,10 @@ pub fn is_test(config: &config, testfile: &Path) -> bool {\n     // Pretty-printer does not work with .rc files yet\n     let valid_extensions =\n         match config.mode {\n-          mode_pretty => ~[~\".rs\"],\n-          _ => ~[~\".rc\", ~\".rs\"]\n+          mode_pretty => vec!(~\".rs\"),\n+          _ => vec!(~\".rc\", ~\".rs\")\n         };\n-    let invalid_prefixes = ~[~\".\", ~\"#\", ~\"~\"];\n+    let invalid_prefixes = vec!(~\".\", ~\"#\", ~\"~\");\n     let name = testfile.filename_str().unwrap();\n \n     let mut valid = false;"}, {"sha": "8dfde741104a4780bf0bca2b916da7459e6a6564", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -9,13 +9,14 @@\n // except according to those terms.\n \n use std::io::{BufferedReader, File};\n+use std::vec_ng::Vec;\n \n pub struct ExpectedError { line: uint, kind: ~str, msg: ~str }\n \n // Load any test directives embedded in the file\n-pub fn load_errors(testfile: &Path) -> ~[ExpectedError] {\n+pub fn load_errors(testfile: &Path) -> Vec<ExpectedError> {\n \n-    let mut error_patterns = ~[];\n+    let mut error_patterns = Vec::new();\n     let mut rdr = BufferedReader::new(File::open(testfile).unwrap());\n     let mut line_num = 1u;\n     for ln in rdr.lines() {\n@@ -25,12 +26,12 @@ pub fn load_errors(testfile: &Path) -> ~[ExpectedError] {\n     return error_patterns;\n }\n \n-fn parse_expected(line_num: uint, line: ~str) -> ~[ExpectedError] {\n+fn parse_expected(line_num: uint, line: ~str) -> Vec<ExpectedError> {\n     let line = line.trim();\n     let error_tag = ~\"//~\";\n     let mut idx;\n     match line.find_str(error_tag) {\n-      None => return ~[],\n+      None => return Vec::new(),\n       Some(nn) => { idx = (nn as uint) + error_tag.len(); }\n     }\n \n@@ -57,6 +58,6 @@ fn parse_expected(line_num: uint, line: ~str) -> ~[ExpectedError] {\n \n     debug!(\"line={} kind={} msg={}\", line_num - adjust_line, kind, msg);\n \n-    return ~[ExpectedError{line: line_num - adjust_line, kind: kind,\n-                           msg: msg}];\n+    return vec!(ExpectedError{line: line_num - adjust_line, kind: kind,\n+                           msg: msg});\n }"}, {"sha": "a68bcb73e86639716206091c9b2839f2a9cfe239", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -12,22 +12,24 @@ use common::config;\n use common;\n use util;\n \n+use std::vec_ng::Vec;\n+\n pub struct TestProps {\n     // Lines that should be expected, in order, on standard out\n-    error_patterns: ~[~str],\n+    error_patterns: Vec<~str> ,\n     // Extra flags to pass to the compiler\n     compile_flags: Option<~str>,\n     // If present, the name of a file that this test should match when\n     // pretty-printed\n     pp_exact: Option<Path>,\n     // Modules from aux directory that should be compiled\n-    aux_builds: ~[~str],\n+    aux_builds: Vec<~str> ,\n     // Environment settings to use during execution\n-    exec_env: ~[(~str,~str)],\n+    exec_env: Vec<(~str,~str)> ,\n     // Commands to be given to the debugger, when testing debug info\n-    debugger_cmds: ~[~str],\n+    debugger_cmds: Vec<~str> ,\n     // Lines to check if they appear in the expected debugger output\n-    check_lines: ~[~str],\n+    check_lines: Vec<~str> ,\n     // Flag to force a crate to be built with the host architecture\n     force_host: bool,\n     // Check stdout for error-pattern output as well as stderr\n@@ -38,13 +40,13 @@ pub struct TestProps {\n \n // Load any test directives embedded in the file\n pub fn load_props(testfile: &Path) -> TestProps {\n-    let mut error_patterns = ~[];\n-    let mut aux_builds = ~[];\n-    let mut exec_env = ~[];\n+    let mut error_patterns = Vec::new();\n+    let mut aux_builds = Vec::new();\n+    let mut exec_env = Vec::new();\n     let mut compile_flags = None;\n     let mut pp_exact = None;\n-    let mut debugger_cmds = ~[];\n-    let mut check_lines = ~[];\n+    let mut debugger_cmds = Vec::new();\n+    let mut check_lines = Vec::new();\n     let mut force_host = false;\n     let mut check_stdout = false;\n     let mut no_prefer_dynamic = false;\n@@ -183,7 +185,7 @@ fn parse_no_prefer_dynamic(line: &str) -> bool {\n fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n     parse_name_value_directive(line, ~\"exec-env\").map(|nv| {\n         // nv is either FOO or FOO=BAR\n-        let mut strs: ~[~str] = nv.splitn('=', 1).map(|s| s.to_owned()).collect();\n+        let mut strs: Vec<~str> = nv.splitn('=', 1).map(|s| s.to_owned()).collect();\n \n         match strs.len() {\n           1u => (strs.pop().unwrap(), ~\"\"),"}, {"sha": "78ff059a67f05389b3136e4ad3e69d7e4434f1b8", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -11,9 +11,10 @@\n use std::os;\n use std::str;\n use std::io::process::{ProcessExit, Process, ProcessConfig, ProcessOutput};\n+use std::vec;\n \n #[cfg(target_os = \"win32\")]\n-fn target_env(lib_path: &str, prog: &str) -> ~[(~str,~str)] {\n+fn target_env(lib_path: &str, prog: &str) -> Vec<(~str,~str)> {\n \n     let mut env = os::env();\n \n@@ -35,11 +36,11 @@ fn target_env(lib_path: &str, prog: &str) -> ~[(~str,~str)] {\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n-fn target_env(lib_path: &str, prog: &str) -> ~[(~str,~str)] {\n+fn target_env(lib_path: &str, prog: &str) -> Vec<(~str,~str)> {\n     // Make sure we include the aux directory in the path\n     let aux_path = prog + \".libaux\";\n \n-    let mut env = os::env();\n+    let mut env: Vec<(~str,~str)> = os::env().move_iter().collect();\n     let var = if cfg!(target_os = \"macos\") {\n         \"DYLD_LIBRARY_PATH\"\n     } else {\n@@ -62,10 +63,11 @@ pub struct Result {status: ProcessExit, out: ~str, err: ~str}\n pub fn run(lib_path: &str,\n            prog: &str,\n            args: &[~str],\n-           env: ~[(~str, ~str)],\n+           env: Vec<(~str, ~str)> ,\n            input: Option<~str>) -> Option<Result> {\n \n-    let env = env + target_env(lib_path, prog);\n+    let env = vec::append(env.clone(),\n+                             target_env(lib_path, prog).as_slice());\n     let mut opt_process = Process::configure(ProcessConfig {\n         program: prog,\n         args: args,\n@@ -93,10 +95,11 @@ pub fn run(lib_path: &str,\n pub fn run_background(lib_path: &str,\n            prog: &str,\n            args: &[~str],\n-           env: ~[(~str, ~str)],\n+           env: Vec<(~str, ~str)> ,\n            input: Option<~str>) -> Option<Process> {\n \n-    let env = env + target_env(lib_path, prog);\n+    let env = vec::append(env.clone(),\n+                             target_env(lib_path, prog).as_slice());\n     let opt_process = Process::configure(ProcessConfig {\n         program: prog,\n         args: args,"}, {"sha": "77b898023689852c9a310c2609ccf32bf6d34843", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 103, "deletions": 77, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -33,6 +33,7 @@ use std::os;\n use std::str;\n use std::task;\n use std::slice;\n+use std::vec_ng;\n \n use test::MetricMap;\n \n@@ -155,12 +156,14 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n \n     let src = File::open(testfile).read_to_end().unwrap();\n     let src = str::from_utf8_owned(src).unwrap();\n-    let mut srcs = ~[src];\n+    let mut srcs = vec!(src);\n \n     let mut round = 0;\n     while round < rounds {\n         logv(config, format!(\"pretty-printing round {}\", round));\n-        let proc_res = print_source(config, testfile, srcs[round].clone());\n+        let proc_res = print_source(config,\n+                                    testfile,\n+                                    (*srcs.get(round)).clone());\n \n         if !proc_res.status.success() {\n             fatal_ProcRes(format!(\"pretty-printing failed in round {}\", round),\n@@ -178,9 +181,9 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n             let s = File::open(&filepath).read_to_end().unwrap();\n             str::from_utf8_owned(s).unwrap()\n           }\n-          None => { srcs[srcs.len() - 2u].clone() }\n+          None => { (*srcs.get(srcs.len() - 2u)).clone() }\n         };\n-    let mut actual = srcs[srcs.len() - 1u].clone();\n+    let mut actual = (*srcs.get(srcs.len() - 1u)).clone();\n \n     if props.pp_exact.is_some() {\n         // Now we have to care about line endings\n@@ -202,12 +205,12 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n \n     fn print_source(config: &config, testfile: &Path, src: ~str) -> ProcRes {\n         compose_and_run(config, testfile, make_pp_args(config, testfile),\n-                        ~[], config.compile_lib_path, Some(src))\n+                        Vec::new(), config.compile_lib_path, Some(src))\n     }\n \n     fn make_pp_args(config: &config, _testfile: &Path) -> ProcArgs {\n-        let args = ~[~\"-\", ~\"--pretty\", ~\"normal\",\n-                     ~\"--target=\" + config.target];\n+        let args = vec!(~\"-\", ~\"--pretty\", ~\"normal\",\n+                     ~\"--target=\" + config.target);\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         return ProcArgs {prog: config.rustc_path.as_str().unwrap().to_owned(), args: args};\n     }\n@@ -244,12 +247,12 @@ actual:\\n\\\n             config.target.as_slice()\n         };\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut args = ~[~\"-\",\n+        let mut args = vec!(~\"-\",\n                          ~\"--no-trans\", ~\"--crate-type=lib\",\n                          ~\"--target=\" + target,\n                          ~\"-L\", config.build_base.as_str().unwrap().to_owned(),\n                          ~\"-L\",\n-                         aux_dir.as_str().unwrap().to_owned()];\n+                         aux_dir.as_str().unwrap().to_owned());\n         args.push_all_move(split_maybe_args(&config.target_rustcflags));\n         args.push_all_move(split_maybe_args(&props.compile_flags));\n         // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -295,12 +298,12 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n             procsrv::run(\"\", config.adb_path,\n                          [~\"push\", exe_file.as_str().unwrap().to_owned(),\n                           config.adb_test_dir.clone()],\n-                         ~[(~\"\",~\"\")], Some(~\"\"))\n+                         vec!((~\"\",~\"\")), Some(~\"\"))\n                 .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n             procsrv::run(\"\", config.adb_path,\n                          [~\"forward\", ~\"tcp:5039\", ~\"tcp:5039\"],\n-                         ~[(~\"\",~\"\")], Some(~\"\"))\n+                         vec!((~\"\",~\"\")), Some(~\"\"))\n                 .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n             let adb_arg = format!(\"export LD_LIBRARY_PATH={}; gdbserver :5039 {}/{}\",\n@@ -309,7 +312,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n \n             let mut process = procsrv::run_background(\"\", config.adb_path,\n                                                       [~\"shell\",adb_arg.clone()],\n-                                                      ~[(~\"\",~\"\")], Some(~\"\"))\n+                                                      vec!((~\"\",~\"\")), Some(~\"\"))\n                 .expect(format!(\"failed to exec `{}`\", config.adb_path));\n             loop {\n                 //waiting 1 second for gdbserver start\n@@ -341,17 +344,21 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n \n             let debugger_script = make_out_name(config, testfile, \"debugger.script\");\n             // FIXME (#9639): This needs to handle non-utf8 paths\n-            let debugger_opts = ~[~\"-quiet\", ~\"-batch\", ~\"-nx\",\n-                                  \"-command=\" + debugger_script.as_str().unwrap().to_owned()];\n+            let debugger_opts = vec!(~\"-quiet\", ~\"-batch\", ~\"-nx\",\n+                                  \"-command=\" + debugger_script.as_str().unwrap().to_owned());\n \n             let gdb_path = tool_path.append(\"/bin/arm-linux-androideabi-gdb\");\n             let procsrv::Result{ out, err, status }=\n                 procsrv::run(\"\",\n                              gdb_path,\n-                             debugger_opts, ~[(~\"\",~\"\")], None)\n+                             debugger_opts.as_slice(),\n+                             vec!((~\"\",~\"\")),\n+                             None)\n                 .expect(format!(\"failed to exec `{}`\", gdb_path));\n             let cmdline = {\n-                let cmdline = make_cmdline(\"\", \"arm-linux-androideabi-gdb\", debugger_opts);\n+                let cmdline = make_cmdline(\"\",\n+                                           \"arm-linux-androideabi-gdb\",\n+                                           debugger_opts.as_slice());\n                 logv(config, format!(\"executing {}\", cmdline));\n                 cmdline\n             };\n@@ -380,11 +387,11 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n             let debugger_script = make_out_name(config, testfile, \"debugger.script\");\n \n             // FIXME (#9639): This needs to handle non-utf8 paths\n-            let debugger_opts = ~[~\"-quiet\", ~\"-batch\", ~\"-nx\",\n+            let debugger_opts = vec!(~\"-quiet\", ~\"-batch\", ~\"-nx\",\n                 \"-command=\" + debugger_script.as_str().unwrap().to_owned(),\n-                exe_file.as_str().unwrap().to_owned()];\n+                exe_file.as_str().unwrap().to_owned());\n             proc_args = ProcArgs {prog: debugger(), args: debugger_opts};\n-            proc_res = compose_and_run(config, testfile, proc_args, ~[], \"\", None);\n+            proc_res = compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None);\n         }\n     }\n \n@@ -395,19 +402,22 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n     if num_check_lines > 0 {\n         // Allow check lines to leave parts unspecified (e.g., uninitialized\n         // bits in the wrong case of an enum) with the notation \"[...]\".\n-        let check_fragments: ~[~[&str]] = check_lines.map(|s| s.split_str(\"[...]\").collect());\n+        let check_fragments: Vec<Vec<~str>> =\n+            check_lines.iter().map(|s| {\n+                s.split_str(\"[...]\").map(|x| x.to_str()).collect()\n+            }).collect();\n         // check if each line in props.check_lines appears in the\n         // output (in order)\n         let mut i = 0u;\n         for line in proc_res.stdout.lines() {\n             let mut rest = line.trim();\n             let mut first = true;\n             let mut failed = false;\n-            for &frag in check_fragments[i].iter() {\n+            for frag in check_fragments.get(i).iter() {\n                 let found = if first {\n-                    if rest.starts_with(frag) { Some(0) } else { None }\n+                    if rest.starts_with(*frag) { Some(0) } else { None }\n                 } else {\n-                    rest.find_str(frag)\n+                    rest.find_str(*frag)\n                 };\n                 match found {\n                     None => {\n@@ -430,7 +440,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n         }\n         if i != num_check_lines {\n             fatal_ProcRes(format!(\"line not found in debugger output: {}\",\n-                                  check_lines[i]), &proc_res);\n+                                  *check_lines.get(i)), &proc_res);\n         }\n     }\n \n@@ -461,7 +471,7 @@ fn check_error_patterns(props: &TestProps,\n     }\n \n     let mut next_err_idx = 0u;\n-    let mut next_err_pat = &props.error_patterns[next_err_idx];\n+    let mut next_err_pat = props.error_patterns.get(next_err_idx);\n     let mut done = false;\n     let output_to_check = if props.check_stdout {\n         proc_res.stdout + proc_res.stderr\n@@ -477,7 +487,7 @@ fn check_error_patterns(props: &TestProps,\n                 done = true;\n                 break;\n             }\n-            next_err_pat = &props.error_patterns[next_err_idx];\n+            next_err_pat = props.error_patterns.get(next_err_idx);\n         }\n     }\n     if done { return; }\n@@ -495,7 +505,7 @@ fn check_error_patterns(props: &TestProps,\n     }\n }\n \n-fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n+fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n                          testfile: &Path,\n                          proc_res: &ProcRes) {\n \n@@ -509,12 +519,12 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n \n     let prefixes = expected_errors.iter().map(|ee| {\n         format!(\"{}:{}:\", testfile.display(), ee.line)\n-    }).collect::<~[~str]>();\n+    }).collect::<Vec<~str> >();\n \n     #[cfg(target_os = \"win32\")]\n     fn to_lower( s : &str ) -> ~str {\n         let i = s.chars();\n-        let c : ~[char] = i.map( |c| {\n+        let c : Vec<char> = i.map( |c| {\n             if c.is_ascii() {\n                 c.to_ascii().to_lower().to_char()\n             } else {\n@@ -547,8 +557,8 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n         for (i, ee) in expected_errors.iter().enumerate() {\n             if !found_flags[i] {\n                 debug!(\"prefix={} ee.kind={} ee.msg={} line={}\",\n-                       prefixes[i], ee.kind, ee.msg, line);\n-                if prefix_matches(line, prefixes[i]) &&\n+                       *prefixes.get(i), ee.kind, ee.msg, line);\n+                if prefix_matches(line, *prefixes.get(i)) &&\n                     line.contains(ee.kind) &&\n                     line.contains(ee.msg) {\n                     found_flags[i] = true;\n@@ -572,7 +582,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n \n     for (i, &flag) in found_flags.iter().enumerate() {\n         if !flag {\n-            let ee = &expected_errors[i];\n+            let ee = expected_errors.get(i);\n             fatal_ProcRes(format!(\"expected {} on line {} not found: {}\",\n                                ee.kind, ee.line, ee.msg), proc_res);\n         }\n@@ -654,7 +664,7 @@ fn scan_string(haystack: &str, needle: &str, idx: &mut uint) -> bool {\n     return true;\n }\n \n-struct ProcArgs {prog: ~str, args: ~[~str]}\n+struct ProcArgs {prog: ~str, args: Vec<~str> }\n \n struct ProcRes {status: ProcessExit, stdout: ~str, stderr: ~str, cmdline: ~str}\n \n@@ -671,8 +681,10 @@ fn compile_test_(config: &config, props: &TestProps,\n                  testfile: &Path, extra_args: &[~str]) -> ProcRes {\n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let link_args = ~[~\"-L\", aux_dir.as_str().unwrap().to_owned()];\n-    let args = make_compile_args(config, props, link_args + extra_args,\n+    let link_args = vec!(~\"-L\", aux_dir.as_str().unwrap().to_owned());\n+    let args = make_compile_args(config,\n+                                 props,\n+                                 vec::append(link_args, extra_args),\n                                  |a, b| ThisFile(make_exe_name(a, b)), testfile);\n     compose_and_run_compiler(config, props, testfile, args, None)\n }\n@@ -710,23 +722,26 @@ fn compose_and_run_compiler(\n \n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let extra_link_args = ~[~\"-L\", aux_dir.as_str().unwrap().to_owned()];\n+    let extra_link_args = vec!(~\"-L\", aux_dir.as_str().unwrap().to_owned());\n \n     for rel_ab in props.aux_builds.iter() {\n         let abs_ab = config.aux_base.join(rel_ab.as_slice());\n         let aux_props = load_props(&abs_ab);\n         let crate_type = if aux_props.no_prefer_dynamic {\n-            ~[]\n+            Vec::new()\n         } else {\n-            ~[~\"--crate-type=dylib\"]\n+            vec!(~\"--crate-type=dylib\")\n         };\n         let aux_args =\n-            make_compile_args(config, &aux_props, crate_type + extra_link_args,\n+            make_compile_args(config,\n+                              &aux_props,\n+                              vec::append(crate_type,\n+                                             extra_link_args.as_slice()),\n                               |a,b| {\n                                   let f = make_lib_name(a, b, testfile);\n                                   ThisDirectory(f.dir_path())\n                               }, &abs_ab);\n-        let auxres = compose_and_run(config, &abs_ab, aux_args, ~[],\n+        let auxres = compose_and_run(config, &abs_ab, aux_args, Vec::new(),\n                                      config.compile_lib_path, None);\n         if !auxres.status.success() {\n             fatal_ProcRes(\n@@ -745,7 +760,7 @@ fn compose_and_run_compiler(\n         }\n     }\n \n-    compose_and_run(config, testfile, args, ~[],\n+    compose_and_run(config, testfile, args, Vec::new(),\n                     config.compile_lib_path, input)\n }\n \n@@ -756,7 +771,7 @@ fn ensure_dir(path: &Path) {\n \n fn compose_and_run(config: &config, testfile: &Path,\n                    ProcArgs{ args, prog }: ProcArgs,\n-                   procenv: ~[(~str, ~str)],\n+                   procenv: Vec<(~str, ~str)> ,\n                    lib_path: &str,\n                    input: Option<~str>) -> ProcRes {\n     return program_output(config, testfile, lib_path,\n@@ -770,7 +785,7 @@ enum TargetLocation {\n \n fn make_compile_args(config: &config,\n                      props: &TestProps,\n-                     extras: ~[~str],\n+                     extras: Vec<~str> ,\n                      xform: |&config, &Path| -> TargetLocation,\n                      testfile: &Path)\n                      -> ProcArgs {\n@@ -781,10 +796,10 @@ fn make_compile_args(config: &config,\n         config.target.as_slice()\n     };\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let mut args = ~[testfile.as_str().unwrap().to_owned(),\n+    let mut args = vec!(testfile.as_str().unwrap().to_owned(),\n                      ~\"-L\", config.build_base.as_str().unwrap().to_owned(),\n-                     ~\"--target=\" + target]\n-        + extras;\n+                     ~\"--target=\" + target);\n+    args.push_all(extras.as_slice());\n     if !props.no_prefer_dynamic {\n         args.push(~\"-C\");\n         args.push(~\"prefer-dynamic\");\n@@ -833,28 +848,28 @@ fn make_run_args(config: &config, _props: &TestProps, testfile: &Path) ->\n     return ProcArgs {prog: prog, args: args};\n }\n \n-fn split_maybe_args(argstr: &Option<~str>) -> ~[~str] {\n+fn split_maybe_args(argstr: &Option<~str>) -> Vec<~str> {\n     match *argstr {\n         Some(ref s) => {\n             s.split(' ')\n                 .filter_map(|s| if s.is_whitespace() {None} else {Some(s.to_owned())})\n                 .collect()\n         }\n-        None => ~[]\n+        None => Vec::new()\n     }\n }\n \n fn program_output(config: &config, testfile: &Path, lib_path: &str, prog: ~str,\n-                  args: ~[~str], env: ~[(~str, ~str)],\n+                  args: Vec<~str> , env: Vec<(~str, ~str)> ,\n                   input: Option<~str>) -> ProcRes {\n     let cmdline =\n         {\n-            let cmdline = make_cmdline(lib_path, prog, args);\n+            let cmdline = make_cmdline(lib_path, prog, args.as_slice());\n             logv(config, format!(\"executing {}\", cmdline));\n             cmdline\n         };\n     let procsrv::Result{ out, err, status } =\n-            procsrv::run(lib_path, prog, args, env, input)\n+            procsrv::run(lib_path, prog, args.as_slice(), env, input)\n             .expect(format!(\"failed to exec `{}`\", prog));\n     dump_output(config, testfile, out, err);\n     return ProcRes {status: status,\n@@ -951,19 +966,19 @@ stderr:\\n\\\n }\n \n fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n-                      testfile: &Path, env: ~[(~str, ~str)]) -> ProcRes {\n+                      testfile: &Path, env: Vec<(~str, ~str)> ) -> ProcRes {\n \n     let args = make_run_args(config, props, testfile);\n-    let cmdline = make_cmdline(\"\", args.prog, args.args);\n+    let cmdline = make_cmdline(\"\", args.prog, args.args.as_slice());\n \n     // get bare program string\n-    let mut tvec: ~[~str] = args.prog.split('/').map(|ts| ts.to_owned()).collect();\n+    let mut tvec: Vec<~str> = args.prog.split('/').map(|ts| ts.to_owned()).collect();\n     let prog_short = tvec.pop().unwrap();\n \n     // copy to target\n     let copy_result = procsrv::run(\"\", config.adb_path,\n         [~\"push\", args.prog.clone(), config.adb_test_dir.clone()],\n-        ~[(~\"\",~\"\")], Some(~\"\"))\n+        vec!((~\"\",~\"\")), Some(~\"\"))\n         .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n     if config.verbose {\n@@ -974,7 +989,7 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n \n     logv(config, format!(\"executing ({}) {}\", config.target, cmdline));\n \n-    let mut runargs = ~[];\n+    let mut runargs = Vec::new();\n \n     // run test via adb_run_wrapper\n     runargs.push(~\"shell\");\n@@ -988,17 +1003,20 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n     for tv in args.args.iter() {\n         runargs.push(tv.to_owned());\n     }\n-    procsrv::run(\"\", config.adb_path, runargs, ~[(~\"\",~\"\")], Some(~\"\"))\n+    procsrv::run(\"\",\n+                 config.adb_path,\n+                 runargs.as_slice(),\n+                 vec!((~\"\",~\"\")), Some(~\"\"))\n         .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n     // get exitcode of result\n-    runargs = ~[];\n+    runargs = Vec::new();\n     runargs.push(~\"shell\");\n     runargs.push(~\"cat\");\n     runargs.push(format!(\"{}/{}.exitcode\", config.adb_test_dir, prog_short));\n \n     let procsrv::Result{ out: exitcode_out, err: _, status: _ } =\n-        procsrv::run(\"\", config.adb_path, runargs, ~[(~\"\",~\"\")],\n+        procsrv::run(\"\", config.adb_path, runargs.as_slice(), vec!((~\"\",~\"\")),\n                      Some(~\"\"))\n         .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n@@ -1012,23 +1030,29 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n     }\n \n     // get stdout of result\n-    runargs = ~[];\n+    runargs = Vec::new();\n     runargs.push(~\"shell\");\n     runargs.push(~\"cat\");\n     runargs.push(format!(\"{}/{}.stdout\", config.adb_test_dir, prog_short));\n \n     let procsrv::Result{ out: stdout_out, err: _, status: _ } =\n-        procsrv::run(\"\", config.adb_path, runargs, ~[(~\"\",~\"\")], Some(~\"\"))\n+        procsrv::run(\"\",\n+                     config.adb_path,\n+                     runargs.as_slice(),\n+                     vec!((~\"\",~\"\")), Some(~\"\"))\n         .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n     // get stderr of result\n-    runargs = ~[];\n+    runargs = Vec::new();\n     runargs.push(~\"shell\");\n     runargs.push(~\"cat\");\n     runargs.push(format!(\"{}/{}.stderr\", config.adb_test_dir, prog_short));\n \n     let procsrv::Result{ out: stderr_out, err: _, status: _ } =\n-        procsrv::run(\"\", config.adb_path, runargs, ~[(~\"\",~\"\")], Some(~\"\"))\n+        procsrv::run(\"\",\n+                     config.adb_path,\n+                     runargs.as_slice(),\n+                     vec!((~\"\",~\"\")), Some(~\"\"))\n         .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n     dump_output(config, testfile, stdout_out, stderr_out);\n@@ -1050,7 +1074,7 @@ fn _arm_push_aux_shared_library(config: &config, testfile: &Path) {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             let copy_result = procsrv::run(\"\", config.adb_path,\n                 [~\"push\", file.as_str().unwrap().to_owned(), config.adb_test_dir.clone()],\n-                ~[(~\"\",~\"\")], Some(~\"\"))\n+                vec!((~\"\",~\"\")), Some(~\"\"))\n                 .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n             if config.verbose {\n@@ -1081,10 +1105,12 @@ fn compile_test_and_save_bitcode(config: &config, props: &TestProps,\n                                  testfile: &Path) -> ProcRes {\n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let link_args = ~[~\"-L\", aux_dir.as_str().unwrap().to_owned()];\n-    let llvm_args = ~[~\"--emit=obj\", ~\"--crate-type=lib\", ~\"-C\", ~\"save-temps\"];\n-    let args = make_compile_args(config, props,\n-                                 link_args + llvm_args,\n+    let link_args = vec!(~\"-L\", aux_dir.as_str().unwrap().to_owned());\n+    let llvm_args = vec!(~\"--emit=obj\", ~\"--crate-type=lib\", ~\"-C\", ~\"save-temps\");\n+    let args = make_compile_args(config,\n+                                 props,\n+                                 vec::append(link_args,\n+                                                llvm_args.as_slice()),\n                                  |a, b| ThisFile(make_o_name(a, b)), testfile);\n     compose_and_run_compiler(config, props, testfile, args, None)\n }\n@@ -1097,12 +1123,12 @@ fn compile_cc_with_clang_and_save_bitcode(config: &config, _props: &TestProps,\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prog: config.clang_path.get_ref().as_str().unwrap().to_owned(),\n-        args: ~[~\"-c\",\n+        args: vec!(~\"-c\",\n                 ~\"-emit-llvm\",\n                 ~\"-o\", bitcodefile.as_str().unwrap().to_owned(),\n-                testcc.as_str().unwrap().to_owned() ]\n+                testcc.as_str().unwrap().to_owned() )\n     };\n-    compose_and_run(config, testfile, proc_args, ~[], \"\", None)\n+    compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None)\n }\n \n fn extract_function_from_bitcode(config: &config, _props: &TestProps,\n@@ -1115,11 +1141,11 @@ fn extract_function_from_bitcode(config: &config, _props: &TestProps,\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prog: prog.as_str().unwrap().to_owned(),\n-        args: ~[\"-func=\" + fname,\n+        args: vec!(\"-func=\" + fname,\n                 \"-o=\" + extracted_bc.as_str().unwrap(),\n-                bitcodefile.as_str().unwrap().to_owned() ]\n+                bitcodefile.as_str().unwrap().to_owned() )\n     };\n-    compose_and_run(config, testfile, proc_args, ~[], \"\", None)\n+    compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None)\n }\n \n fn disassemble_extract(config: &config, _props: &TestProps,\n@@ -1132,10 +1158,10 @@ fn disassemble_extract(config: &config, _props: &TestProps,\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prog: prog.as_str().unwrap().to_owned(),\n-        args: ~[\"-o=\" + extracted_ll.as_str().unwrap(),\n-                extracted_bc.as_str().unwrap().to_owned() ]\n+        args: vec!(\"-o=\" + extracted_ll.as_str().unwrap(),\n+                extracted_bc.as_str().unwrap().to_owned() )\n     };\n-    compose_and_run(config, testfile, proc_args, ~[], \"\", None)\n+    compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None)\n }\n \n "}, {"sha": "a09d5a826bb99cbb630892f3d22ac62aed5c67be", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -42,14 +42,13 @@ use std::rc::Rc;\n use std::rt::global_heap;\n use std::intrinsics::{TyDesc, get_tydesc};\n use std::intrinsics;\n-use std::slice;\n \n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n // will always stay at 0.\n #[deriving(Clone, Eq)]\n struct Chunk {\n-    data: Rc<RefCell<~[u8]>>,\n+    data: Rc<RefCell<Vec<u8> >>,\n     fill: Cell<uint>,\n     is_pod: Cell<bool>,\n }\n@@ -111,7 +110,7 @@ impl Arena {\n \n fn chunk(size: uint, is_pod: bool) -> Chunk {\n     Chunk {\n-        data: Rc::new(RefCell::new(slice::with_capacity(size))),\n+        data: Rc::new(RefCell::new(Vec::with_capacity(size))),\n         fill: Cell::new(0u),\n         is_pod: Cell::new(is_pod),\n     }\n@@ -489,6 +488,9 @@ impl<T> Drop for TypedArena<T> {\n #[cfg(test)]\n mod tests {\n     extern crate test;\n+\n+    use std::vec_ng::Vec;\n+\n     use self::test::BenchHarness;\n     use super::{Arena, TypedArena};\n \n@@ -549,7 +551,7 @@ mod tests {\n \n     struct Nonpod {\n         string: ~str,\n-        array: ~[int],\n+        array: Vec<int> ,\n     }\n \n     #[test]\n@@ -558,7 +560,7 @@ mod tests {\n         for _ in range(0, 100000) {\n             arena.alloc(Nonpod {\n                 string: ~\"hello world\",\n-                array: ~[ 1, 2, 3, 4, 5 ],\n+                array: vec!( 1, 2, 3, 4, 5 ),\n             });\n         }\n     }\n@@ -569,7 +571,7 @@ mod tests {\n         bh.iter(|| {\n             arena.alloc(Nonpod {\n                 string: ~\"hello world\",\n-                array: ~[ 1, 2, 3, 4, 5 ],\n+                array: vec!( 1, 2, 3, 4, 5 ),\n             })\n         })\n     }\n@@ -579,7 +581,7 @@ mod tests {\n         bh.iter(|| {\n             ~Nonpod {\n                 string: ~\"hello world\",\n-                array: ~[ 1, 2, 3, 4, 5 ],\n+                array: vec!( 1, 2, 3, 4, 5 ),\n             }\n         })\n     }\n@@ -590,7 +592,7 @@ mod tests {\n         bh.iter(|| {\n             arena.alloc(|| Nonpod {\n                 string: ~\"hello world\",\n-                array: ~[ 1, 2, 3, 4, 5 ],\n+                array: vec!( 1, 2, 3, 4, 5 ),\n             })\n         })\n     }"}, {"sha": "6f30c7129eabba5ad9033a78ce8fd04163146641", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 189, "deletions": 184, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -67,7 +67,7 @@\n //!     }\n //!     let output = matches.opt_str(\"o\");\n //!     let input: &str = if !matches.free.is_empty() {\n-//!         matches.free[0].clone()\n+//!         (*matches.free.get(0)).clone()\n //!     } else {\n //!         print_usage(program, opts);\n //!         return;\n@@ -92,8 +92,6 @@\n use std::cmp::Eq;\n use std::result::{Err, Ok};\n use std::result;\n-use std::option::{Some, None};\n-use std::slice;\n \n /// Name of an option. Either a string or a single char.\n #[deriving(Clone, Eq)]\n@@ -138,7 +136,7 @@ pub struct Opt {\n     /// How often it can occur\n     occur: Occur,\n     /// Which options it aliases\n-    priv aliases: ~[Opt],\n+    priv aliases: Vec<Opt> ,\n }\n \n /// One group of options, e.g., both -h and --help, along with\n@@ -171,12 +169,11 @@ enum Optval {\n #[deriving(Clone, Eq)]\n pub struct Matches {\n     /// Options that matched\n-    priv opts: ~[Opt],\n+    priv opts: Vec<Opt> ,\n     /// Values of the Options that matched\n-    priv vals: ~[~[Optval]],\n+    priv vals: Vec<Vec<Optval> > ,\n     /// Free string fragments\n-    free: ~[~str]\n-}\n+    free: Vec<~str> }\n \n /// The type returned when the command line does not conform to the\n /// expected format. Call the `to_err_msg` method to retrieve the\n@@ -244,36 +241,36 @@ impl OptGroup {\n                 name: Long((long_name)),\n                 hasarg: hasarg,\n                 occur: occur,\n-                aliases: ~[]\n+                aliases: Vec::new()\n             },\n             (1,0) => Opt {\n                 name: Short(short_name.char_at(0)),\n                 hasarg: hasarg,\n                 occur: occur,\n-                aliases: ~[]\n+                aliases: Vec::new()\n             },\n             (1,_) => Opt {\n                 name: Long((long_name)),\n                 hasarg: hasarg,\n                 occur:  occur,\n-                aliases: ~[\n+                aliases: vec!(\n                     Opt {\n                         name: Short(short_name.char_at(0)),\n                         hasarg: hasarg,\n                         occur:  occur,\n-                        aliases: ~[]\n+                        aliases: Vec::new()\n                     }\n-                ]\n+                )\n             },\n             (_,_) => fail!(\"something is wrong with the long-form opt\")\n         }\n     }\n }\n \n impl Matches {\n-    fn opt_vals(&self, nm: &str) -> ~[Optval] {\n-        match find_opt(self.opts, Name::from_str(nm)) {\n-            Some(id) => self.vals[id].clone(),\n+    fn opt_vals(&self, nm: &str) -> Vec<Optval> {\n+        match find_opt(self.opts.as_slice(), Name::from_str(nm)) {\n+            Some(id) => (*self.vals.get(id)).clone(),\n             None => fail!(\"No option '{}' defined\", nm)\n         }\n     }\n@@ -283,7 +280,7 @@ impl Matches {\n         if vals.is_empty() {\n             None\n         } else {\n-            Some(vals[0].clone())\n+            Some((*vals.get(0)).clone())\n         }\n     }\n \n@@ -300,8 +297,8 @@ impl Matches {\n     /// Returns true if any of several options were matched.\n     pub fn opts_present(&self, names: &[~str]) -> bool {\n         for nm in names.iter() {\n-            match find_opt(self.opts, Name::from_str(*nm)) {\n-                Some(id) if !self.vals[id].is_empty() => return true,\n+            match find_opt(self.opts.as_slice(), Name::from_str(*nm)) {\n+                Some(id) if !self.vals.get(id).is_empty() => return true,\n                 _ => (),\n             };\n         }\n@@ -323,8 +320,8 @@ impl Matches {\n     /// option.\n     ///\n     /// Used when an option accepts multiple values.\n-    pub fn opt_strs(&self, nm: &str) -> ~[~str] {\n-        let mut acc: ~[~str] = ~[];\n+    pub fn opt_strs(&self, nm: &str) -> Vec<~str> {\n+        let mut acc: Vec<~str> = Vec::new();\n         let r = self.opt_vals(nm);\n         for v in r.iter() {\n             match *v {\n@@ -341,8 +338,8 @@ impl Matches {\n         if vals.is_empty() {\n             return None::<~str>;\n         }\n-        match vals[0] {\n-            Val(ref s) => Some((*s).clone()),\n+        match vals.get(0) {\n+            &Val(ref s) => Some((*s).clone()),\n             _ => None\n         }\n     }\n@@ -356,8 +353,8 @@ impl Matches {\n     pub fn opt_default(&self, nm: &str, def: &str) -> Option<~str> {\n         let vals = self.opt_vals(nm);\n         if vals.is_empty() { return None; }\n-        match vals[0] {\n-            Val(ref s) => Some((*s).clone()),\n+        match vals.get(0) {\n+            &Val(ref s) => Some((*s).clone()),\n             _ => Some(def.to_owned())\n         }\n     }\n@@ -522,10 +519,10 @@ pub fn getopts(args: &[~str], optgrps: &[OptGroup]) -> Result {\n     let opts = optgrps.map(|x| x.long_to_short());\n     let n_opts = opts.len();\n \n-    fn f(_x: uint) -> ~[Optval] { return ~[]; }\n+    fn f(_x: uint) -> Vec<Optval> { return Vec::new(); }\n \n-    let mut vals = slice::from_fn(n_opts, f);\n-    let mut free: ~[~str] = ~[];\n+    let mut vals = Vec::from_fn(n_opts, f);\n+    let mut free: Vec<~str> = Vec::new();\n     let l = args.len();\n     let mut i = 0;\n     while i < l {\n@@ -542,18 +539,18 @@ pub fn getopts(args: &[~str], optgrps: &[OptGroup]) -> Result {\n             let mut i_arg = None;\n             if cur[1] == '-' as u8 {\n                 let tail = cur.slice(2, curlen);\n-                let tail_eq: ~[&str] = tail.split('=').collect();\n+                let tail_eq: Vec<&str> = tail.split('=').collect();\n                 if tail_eq.len() <= 1 {\n-                    names = ~[Long(tail.to_owned())];\n+                    names = vec!(Long(tail.to_owned()));\n                 } else {\n                     names =\n-                        ~[Long(tail_eq[0].to_owned())];\n-                    i_arg = Some(tail_eq[1].to_owned());\n+                        vec!(Long((*tail_eq.get(0)).to_owned()));\n+                    i_arg = Some((*tail_eq.get(1)).to_owned());\n                 }\n             } else {\n                 let mut j = 1;\n                 let mut last_valid_opt_id = None;\n-                names = ~[];\n+                names = Vec::new();\n                 while j < curlen {\n                     let range = cur.char_range_at(j);\n                     let opt = Short(range.ch);\n@@ -600,22 +597,30 @@ pub fn getopts(args: &[~str], optgrps: &[OptGroup]) -> Result {\n                     if !i_arg.is_none() {\n                         return Err(UnexpectedArgument(nm.to_str()));\n                     }\n-                    vals[optid].push(Given);\n+                    vals.get_mut(optid).push(Given);\n                   }\n                   Maybe => {\n                     if !i_arg.is_none() {\n-                        vals[optid].push(Val((i_arg.clone()).unwrap()));\n+                        vals.get_mut(optid)\n+                            .push(Val((i_arg.clone())\n+                            .unwrap()));\n                     } else if name_pos < names.len() ||\n                                   i + 1 == l || is_arg(args[i + 1]) {\n-                        vals[optid].push(Given);\n-                    } else { i += 1; vals[optid].push(Val(args[i].clone())); }\n+                        vals.get_mut(optid).push(Given);\n+                    } else {\n+                        i += 1;\n+                        vals.get_mut(optid).push(Val(args[i].clone()));\n+                    }\n                   }\n                   Yes => {\n                     if !i_arg.is_none() {\n-                        vals[optid].push(Val(i_arg.clone().unwrap()));\n+                        vals.get_mut(optid).push(Val(i_arg.clone().unwrap()));\n                     } else if i + 1 == l {\n                         return Err(ArgumentMissing(nm.to_str()));\n-                    } else { i += 1; vals[optid].push(Val(args[i].clone())); }\n+                    } else {\n+                        i += 1;\n+                        vals.get_mut(optid).push(Val(args[i].clone()));\n+                    }\n                   }\n                 }\n             }\n@@ -624,7 +629,7 @@ pub fn getopts(args: &[~str], optgrps: &[OptGroup]) -> Result {\n     }\n     i = 0u;\n     while i < n_opts {\n-        let n = vals[i].len();\n+        let n = vals.get(i).len();\n         let occ = opts[i].occur;\n         if occ == Req {\n             if n == 0 {\n@@ -639,7 +644,7 @@ pub fn getopts(args: &[~str], optgrps: &[OptGroup]) -> Result {\n         i += 1;\n     }\n     Ok(Matches {\n-        opts: opts.to_owned(),\n+        opts: Vec::from_slice(opts),\n         vals: vals,\n         free: free\n     })\n@@ -711,7 +716,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n         }\n \n         // FIXME: #5516 should be graphemes not codepoints\n-        let mut desc_rows = ~[];\n+        let mut desc_rows = Vec::new();\n         each_split_within(desc_normalized_whitespace, 54, |substr| {\n             desc_rows.push(substr.to_owned());\n             true\n@@ -724,7 +729,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n         row\n     });\n \n-    format!(\"{}\\n\\nOptions:\\n{}\\n\", brief, rows.collect::<~[~str]>().connect(\"\\n\"))\n+    format!(\"{}\\n\\nOptions:\\n{}\\n\", brief, rows.collect::<Vec<~str> >().connect(\"\\n\"))\n }\n \n fn format_option(opt: &OptGroup) -> ~str {\n@@ -879,7 +884,7 @@ fn each_split_within<'a>(ss: &'a str, lim: uint, it: |&'a str| -> bool)\n #[test]\n fn test_split_within() {\n     fn t(s: &str, i: uint, u: &[~str]) {\n-        let mut v = ~[];\n+        let mut v = Vec::new();\n         each_split_within(s, i, |s| { v.push(s.to_owned()); true });\n         assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n     }\n@@ -898,6 +903,7 @@ mod tests {\n \n     use std::result::{Err, Ok};\n     use std::result;\n+    use std::vec_ng::Vec;\n \n     fn check_fail_type(f: Fail_, ft: FailType) {\n         match f {\n@@ -912,9 +918,9 @@ mod tests {\n     // Tests for reqopt\n     #[test]\n     fn test_reqopt() {\n-        let long_args = ~[~\"--test=20\"];\n-        let opts = ~[reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(long_args, opts);\n+        let long_args = vec!(~\"--test=20\");\n+        let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n@@ -924,8 +930,8 @@ mod tests {\n           }\n           _ => { fail!(\"test_reqopt failed (long arg)\"); }\n         }\n-        let short_args = ~[~\"-t\", ~\"20\"];\n-        match getopts(short_args, opts) {\n+        let short_args = vec!(~\"-t\", ~\"20\");\n+        match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n             assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n@@ -938,9 +944,9 @@ mod tests {\n \n     #[test]\n     fn test_reqopt_missing() {\n-        let args = ~[~\"blah\"];\n-        let opts = ~[reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(args, opts);\n+        let args = vec!(~\"blah\");\n+        let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, OptionMissing_),\n           _ => fail!()\n@@ -949,25 +955,25 @@ mod tests {\n \n     #[test]\n     fn test_reqopt_no_arg() {\n-        let long_args = ~[~\"--test\"];\n-        let opts = ~[reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(long_args, opts);\n+        let long_args = vec!(~\"--test\");\n+        let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n-        let short_args = ~[~\"-t\"];\n-        match getopts(short_args, opts) {\n+        let short_args = vec!(~\"-t\");\n+        match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_reqopt_multi() {\n-        let args = ~[~\"--test=20\", ~\"-t\", ~\"30\"];\n-        let opts = ~[reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(args, opts);\n+        let args = vec!(~\"--test=20\", ~\"-t\", ~\"30\");\n+        let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n@@ -977,9 +983,9 @@ mod tests {\n     // Tests for optopt\n     #[test]\n     fn test_optopt() {\n-        let long_args = ~[~\"--test=20\"];\n-        let opts = ~[optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(long_args, opts);\n+        let long_args = vec!(~\"--test=20\");\n+        let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n@@ -989,8 +995,8 @@ mod tests {\n           }\n           _ => fail!()\n         }\n-        let short_args = ~[~\"-t\", ~\"20\"];\n-        match getopts(short_args, opts) {\n+        let short_args = vec!(~\"-t\", ~\"20\");\n+        match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n             assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n@@ -1003,9 +1009,9 @@ mod tests {\n \n     #[test]\n     fn test_optopt_missing() {\n-        let args = ~[~\"blah\"];\n-        let opts = ~[optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(args, opts);\n+        let args = vec!(~\"blah\");\n+        let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert!(!m.opt_present(\"test\"));\n@@ -1017,25 +1023,25 @@ mod tests {\n \n     #[test]\n     fn test_optopt_no_arg() {\n-        let long_args = ~[~\"--test\"];\n-        let opts = ~[optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(long_args, opts);\n+        let long_args = vec!(~\"--test\");\n+        let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n-        let short_args = ~[~\"-t\"];\n-        match getopts(short_args, opts) {\n+        let short_args = vec!(~\"-t\");\n+        match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optopt_multi() {\n-        let args = ~[~\"--test=20\", ~\"-t\", ~\"30\"];\n-        let opts = ~[optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(args, opts);\n+        let args = vec!(~\"--test=20\", ~\"-t\", ~\"30\");\n+        let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n@@ -1045,18 +1051,18 @@ mod tests {\n     // Tests for optflag\n     #[test]\n     fn test_optflag() {\n-        let long_args = ~[~\"--test\"];\n-        let opts = ~[optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(long_args, opts);\n+        let long_args = vec!(~\"--test\");\n+        let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n+        let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n             assert!(m.opt_present(\"t\"));\n           }\n           _ => fail!()\n         }\n-        let short_args = ~[~\"-t\"];\n-        match getopts(short_args, opts) {\n+        let short_args = vec!(~\"-t\");\n+        match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n             assert!(m.opt_present(\"t\"));\n@@ -1067,9 +1073,9 @@ mod tests {\n \n     #[test]\n     fn test_optflag_missing() {\n-        let args = ~[~\"blah\"];\n-        let opts = ~[optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(args, opts);\n+        let args = vec!(~\"blah\");\n+        let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n+        let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert!(!m.opt_present(\"test\"));\n@@ -1081,9 +1087,9 @@ mod tests {\n \n     #[test]\n     fn test_optflag_long_arg() {\n-        let args = ~[~\"--test=20\"];\n-        let opts = ~[optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(args, opts);\n+        let args = vec!(~\"--test=20\");\n+        let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n+        let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => {\n             error!(\"{:?}\", f.clone().to_err_msg());\n@@ -1095,9 +1101,9 @@ mod tests {\n \n     #[test]\n     fn test_optflag_multi() {\n-        let args = ~[~\"--test\", ~\"-t\"];\n-        let opts = ~[optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(args, opts);\n+        let args = vec!(~\"--test\", ~\"-t\");\n+        let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n+        let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail!()\n@@ -1106,14 +1112,14 @@ mod tests {\n \n     #[test]\n     fn test_optflag_short_arg() {\n-        let args = ~[~\"-t\", ~\"20\"];\n-        let opts = ~[optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(args, opts);\n+        let args = vec!(~\"-t\", ~\"20\");\n+        let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n+        let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             // The next variable after the flag is just a free argument\n \n-            assert!(m.free[0] == ~\"20\");\n+            assert!(*m.free.get(0) == ~\"20\");\n           }\n           _ => fail!()\n         }\n@@ -1122,9 +1128,9 @@ mod tests {\n     // Tests for optflagmulti\n     #[test]\n     fn test_optflagmulti_short1() {\n-        let args = ~[~\"-v\"];\n-        let opts = ~[optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(args, opts);\n+        let args = vec!(~\"-v\");\n+        let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n+        let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"v\"), 1);\n@@ -1135,9 +1141,9 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_short2a() {\n-        let args = ~[~\"-v\", ~\"-v\"];\n-        let opts = ~[optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(args, opts);\n+        let args = vec!(~\"-v\", ~\"-v\");\n+        let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n+        let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"v\"), 2);\n@@ -1148,9 +1154,9 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_short2b() {\n-        let args = ~[~\"-vv\"];\n-        let opts = ~[optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(args, opts);\n+        let args = vec!(~\"-vv\");\n+        let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n+        let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"v\"), 2);\n@@ -1161,9 +1167,9 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_long1() {\n-        let args = ~[~\"--verbose\"];\n-        let opts = ~[optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(args, opts);\n+        let args = vec!(~\"--verbose\");\n+        let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n+        let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"verbose\"), 1);\n@@ -1174,9 +1180,9 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_long2() {\n-        let args = ~[~\"--verbose\", ~\"--verbose\"];\n-        let opts = ~[optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(args, opts);\n+        let args = vec!(~\"--verbose\", ~\"--verbose\");\n+        let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n+        let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"verbose\"), 2);\n@@ -1187,9 +1193,9 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_mix() {\n-        let args = ~[~\"--verbose\", ~\"-v\", ~\"-vv\", ~\"verbose\"];\n-        let opts = ~[optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(args, opts);\n+        let args = vec!(~\"--verbose\", ~\"-v\", ~\"-vv\", ~\"verbose\");\n+        let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n+        let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"verbose\"), 4);\n@@ -1202,9 +1208,9 @@ mod tests {\n     // Tests for optmulti\n     #[test]\n     fn test_optmulti() {\n-        let long_args = ~[~\"--test=20\"];\n-        let opts = ~[optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(long_args, opts);\n+        let long_args = vec!(~\"--test=20\");\n+        let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n@@ -1214,8 +1220,8 @@ mod tests {\n           }\n           _ => fail!()\n         }\n-        let short_args = ~[~\"-t\", ~\"20\"];\n-        match getopts(short_args, opts) {\n+        let short_args = vec!(~\"-t\", ~\"20\");\n+        match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n             assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n@@ -1228,9 +1234,9 @@ mod tests {\n \n     #[test]\n     fn test_optmulti_missing() {\n-        let args = ~[~\"blah\"];\n-        let opts = ~[optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(args, opts);\n+        let args = vec!(~\"blah\");\n+        let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert!(!m.opt_present(\"test\"));\n@@ -1242,50 +1248,50 @@ mod tests {\n \n     #[test]\n     fn test_optmulti_no_arg() {\n-        let long_args = ~[~\"--test\"];\n-        let opts = ~[optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(long_args, opts);\n+        let long_args = vec!(~\"--test\");\n+        let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n-        let short_args = ~[~\"-t\"];\n-        match getopts(short_args, opts) {\n+        let short_args = vec!(~\"-t\");\n+        match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optmulti_multi() {\n-        let args = ~[~\"--test=20\", ~\"-t\", ~\"30\"];\n-        let opts = ~[optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(args, opts);\n+        let args = vec!(~\"--test=20\", ~\"-t\", ~\"30\");\n+        let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n               assert!(m.opt_present(\"test\"));\n               assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n               assert!(m.opt_present(\"t\"));\n               assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n               let pair = m.opt_strs(\"test\");\n-              assert!(pair[0] == ~\"20\");\n-              assert!(pair[1] == ~\"30\");\n+              assert!(*pair.get(0) == ~\"20\");\n+              assert!(*pair.get(1) == ~\"30\");\n           }\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_unrecognized_option() {\n-        let long_args = ~[~\"--untest\"];\n-        let opts = ~[optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(long_args, opts);\n+        let long_args = vec!(~\"--untest\");\n+        let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, UnrecognizedOption_),\n           _ => fail!()\n         }\n-        let short_args = ~[~\"-u\"];\n-        match getopts(short_args, opts) {\n+        let short_args = vec!(~\"-u\");\n+        match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, UnrecognizedOption_),\n           _ => fail!()\n         }\n@@ -1294,33 +1300,33 @@ mod tests {\n     #[test]\n     fn test_combined() {\n         let args =\n-            ~[~\"prog\", ~\"free1\", ~\"-s\", ~\"20\", ~\"free2\",\n+            vec!(~\"prog\", ~\"free1\", ~\"-s\", ~\"20\", ~\"free2\",\n               ~\"--flag\", ~\"--long=30\", ~\"-f\", ~\"-m\", ~\"40\",\n-              ~\"-m\", ~\"50\", ~\"-n\", ~\"-A B\", ~\"-n\", ~\"-60 70\"];\n+              ~\"-m\", ~\"50\", ~\"-n\", ~\"-A B\", ~\"-n\", ~\"-60 70\");\n         let opts =\n-            ~[optopt(\"s\", \"something\", \"something\", \"SOMETHING\"),\n+            vec!(optopt(\"s\", \"something\", \"something\", \"SOMETHING\"),\n               optflag(\"\", \"flag\", \"a flag\"),\n               reqopt(\"\", \"long\", \"hi\", \"LONG\"),\n               optflag(\"f\", \"\", \"another flag\"),\n               optmulti(\"m\", \"\", \"mmmmmm\", \"YUM\"),\n               optmulti(\"n\", \"\", \"nothing\", \"NOTHING\"),\n-              optopt(\"\", \"notpresent\", \"nothing to see here\", \"NOPE\")];\n-        let rs = getopts(args, opts);\n+              optopt(\"\", \"notpresent\", \"nothing to see here\", \"NOPE\"));\n+        let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n-            assert!(m.free[0] == ~\"prog\");\n-            assert!(m.free[1] == ~\"free1\");\n+            assert!(*m.free.get(0) == ~\"prog\");\n+            assert!(*m.free.get(1) == ~\"free1\");\n             assert_eq!(m.opt_str(\"s\").unwrap(), ~\"20\");\n-            assert!(m.free[2] == ~\"free2\");\n+            assert!(*m.free.get(2) == ~\"free2\");\n             assert!((m.opt_present(\"flag\")));\n             assert_eq!(m.opt_str(\"long\").unwrap(), ~\"30\");\n             assert!((m.opt_present(\"f\")));\n             let pair = m.opt_strs(\"m\");\n-            assert!(pair[0] == ~\"40\");\n-            assert!(pair[1] == ~\"50\");\n+            assert!(*pair.get(0) == ~\"40\");\n+            assert!(*pair.get(1) == ~\"50\");\n             let pair = m.opt_strs(\"n\");\n-            assert!(pair[0] == ~\"-A B\");\n-            assert!(pair[1] == ~\"-60 70\");\n+            assert!(*pair.get(0) == ~\"-A B\");\n+            assert!(*pair.get(1) == ~\"-60 70\");\n             assert!((!m.opt_present(\"notpresent\")));\n           }\n           _ => fail!()\n@@ -1329,12 +1335,13 @@ mod tests {\n \n     #[test]\n     fn test_multi() {\n-        let opts = ~[optopt(\"e\", \"\", \"encrypt\", \"ENCRYPT\"),\n+        let opts = vec!(optopt(\"e\", \"\", \"encrypt\", \"ENCRYPT\"),\n                      optopt(\"\", \"encrypt\", \"encrypt\", \"ENCRYPT\"),\n-                     optopt(\"f\", \"\", \"flag\", \"FLAG\")];\n+                     optopt(\"f\", \"\", \"flag\", \"FLAG\"));\n \n-        let args_single = ~[~\"-e\", ~\"foo\"];\n-        let matches_single = &match getopts(args_single, opts) {\n+        let args_single = vec!(~\"-e\", ~\"foo\");\n+        let matches_single = &match getopts(args_single.as_slice(),\n+                                            opts.as_slice()) {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n@@ -1349,8 +1356,9 @@ mod tests {\n         assert_eq!(matches_single.opts_str([~\"e\", ~\"encrypt\"]).unwrap(), ~\"foo\");\n         assert_eq!(matches_single.opts_str([~\"encrypt\", ~\"e\"]).unwrap(), ~\"foo\");\n \n-        let args_both = ~[~\"-e\", ~\"foo\", ~\"--encrypt\", ~\"foo\"];\n-        let matches_both = &match getopts(args_both, opts) {\n+        let args_both = vec!(~\"-e\", ~\"foo\", ~\"--encrypt\", ~\"foo\");\n+        let matches_both = &match getopts(args_both.as_slice(),\n+                                          opts.as_slice()) {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n@@ -1370,10 +1378,10 @@ mod tests {\n \n     #[test]\n     fn test_nospace() {\n-        let args = ~[~\"-Lfoo\", ~\"-M.\"];\n-        let opts = ~[optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n-                     optmulti(\"M\", \"\", \"something\", \"MMMM\")];\n-        let matches = &match getopts(args, opts) {\n+        let args = vec!(~\"-Lfoo\", ~\"-M.\");\n+        let opts = vec!(optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n+                     optmulti(\"M\", \"\", \"something\", \"MMMM\"));\n+        let matches = &match getopts(args.as_slice(), opts.as_slice()) {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n@@ -1386,42 +1394,42 @@ mod tests {\n \n     #[test]\n     fn test_long_to_short() {\n-        let mut short = Opt { name: Long(~\"banana\"),\n-                              hasarg: Yes,\n-                              occur: Req,\n-                              aliases: ~[] };\n-        short.aliases = ~[Opt { name: Short('b'),\n+        let mut short = Opt {\n+            name: Long(~\"banana\"),\n+            hasarg: Yes,\n+            occur: Req,\n+            aliases: Vec::new(),\n+        };\n+        short.aliases = vec!(Opt { name: Short('b'),\n                                 hasarg: Yes,\n                                 occur: Req,\n-                                aliases: ~[] }];\n+                                aliases: Vec::new() });\n         let verbose = reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n \n         assert!(verbose.long_to_short() == short);\n     }\n \n     #[test]\n     fn test_aliases_long_and_short() {\n-        let opts = ~[\n-            optflagmulti(\"a\", \"apple\", \"Desc\"),\n-        ];\n+        let opts = vec!(\n+            optflagmulti(\"a\", \"apple\", \"Desc\"));\n \n-        let args = ~[~\"-a\", ~\"--apple\", ~\"-a\"];\n+        let args = vec!(~\"-a\", ~\"--apple\", ~\"-a\");\n \n-        let matches = getopts(args, opts).unwrap();\n+        let matches = getopts(args.as_slice(), opts.as_slice()).unwrap();\n         assert_eq!(3, matches.opt_count(\"a\"));\n         assert_eq!(3, matches.opt_count(\"apple\"));\n     }\n \n     #[test]\n     fn test_usage() {\n-        let optgroups = ~[\n+        let optgroups = vec!(\n             reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n             optopt(\"a\", \"012345678901234567890123456789\",\n                              \"Desc\", \"VAL\"),\n             optflag(\"k\", \"kiwi\", \"Desc\"),\n             optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n-            optmulti(\"l\", \"\", \"Desc\", \"VAL\"),\n-        ];\n+            optmulti(\"l\", \"\", \"Desc\", \"VAL\"));\n \n         let expected =\n ~\"Usage: fruits\n@@ -1435,7 +1443,7 @@ Options:\n     -l VAL              Desc\n \";\n \n-        let generated_usage = usage(\"Usage: fruits\", optgroups);\n+        let generated_usage = usage(\"Usage: fruits\", optgroups.as_slice());\n \n         debug!(\"expected: <<{}>>\", expected);\n         debug!(\"generated: <<{}>>\", generated_usage);\n@@ -1447,12 +1455,11 @@ Options:\n         // indentation should be 24 spaces\n         // lines wrap after 78: or rather descriptions wrap after 54\n \n-        let optgroups = ~[\n+        let optgroups = vec!(\n             optflag(\"k\", \"kiwi\",\n                 \"This is a long description which won't be wrapped..+..\"), // 54\n             optflag(\"a\", \"apple\",\n-                \"This is a long description which _will_ be wrapped..+..\"), // 55\n-        ];\n+                \"This is a long description which _will_ be wrapped..+..\"));\n \n         let expected =\n ~\"Usage: fruits\n@@ -1463,7 +1470,7 @@ Options:\n                         wrapped..+..\n \";\n \n-        let usage = usage(\"Usage: fruits\", optgroups);\n+        let usage = usage(\"Usage: fruits\", optgroups.as_slice());\n \n         debug!(\"expected: <<{}>>\", expected);\n         debug!(\"generated: <<{}>>\", usage);\n@@ -1472,13 +1479,12 @@ Options:\n \n     #[test]\n     fn test_usage_description_multibyte_handling() {\n-        let optgroups = ~[\n+        let optgroups = vec!(\n             optflag(\"k\", \"k\\u2013w\\u2013\",\n                 \"The word kiwi is normally spelled with two i's\"),\n             optflag(\"a\", \"apple\",\n                 \"This \\u201Cdescription\\u201D has some characters that could \\\n-confuse the line wrapping; an apple costs 0.51\u20ac in some parts of Europe.\"),\n-        ];\n+confuse the line wrapping; an apple costs 0.51\u20ac in some parts of Europe.\"));\n \n         let expected =\n ~\"Usage: fruits\n@@ -1490,7 +1496,7 @@ Options:\n                         some parts of Europe.\n \";\n \n-        let usage = usage(\"Usage: fruits\", optgroups);\n+        let usage = usage(\"Usage: fruits\", optgroups.as_slice());\n \n         debug!(\"expected: <<{}>>\", expected);\n         debug!(\"generated: <<{}>>\", usage);\n@@ -1499,17 +1505,16 @@ Options:\n \n     #[test]\n     fn test_short_usage() {\n-        let optgroups = ~[\n+        let optgroups = vec!(\n             reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n             optopt(\"a\", \"012345678901234567890123456789\",\n                      \"Desc\", \"VAL\"),\n             optflag(\"k\", \"kiwi\", \"Desc\"),\n             optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n-            optmulti(\"l\", \"\", \"Desc\", \"VAL\"),\n-        ];\n+            optmulti(\"l\", \"\", \"Desc\", \"VAL\"));\n \n         let expected = ~\"Usage: fruits -b VAL [-a VAL] [-k] [-p [VAL]] [-l VAL]..\";\n-        let generated_usage = short_usage(\"fruits\", optgroups);\n+        let generated_usage = short_usage(\"fruits\", optgroups.as_slice());\n \n         debug!(\"expected: <<{}>>\", expected);\n         debug!(\"generated: <<{}>>\", generated_usage);"}, {"sha": "f4591c9fc1977ca7a7e3b30384b386ea05e8fa6a", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -42,10 +42,9 @@ use std::path::is_sep;\n  */\n pub struct Paths {\n     priv root: Path,\n-    priv dir_patterns: ~[Pattern],\n+    priv dir_patterns: Vec<Pattern> ,\n     priv options: MatchOptions,\n-    priv todo: ~[(Path,uint)]\n-}\n+    priv todo: Vec<(Path,uint)> }\n \n ///\n /// Return an iterator that produces all the Paths that match the given pattern,\n@@ -103,16 +102,23 @@ pub fn glob_with(pattern: &str, options: MatchOptions) -> Paths {\n         if check_windows_verbatim(pat_root.get_ref()) {\n             // FIXME: How do we want to handle verbatim paths? I'm inclined to return nothing,\n             // since we can't very well find all UNC shares with a 1-letter server name.\n-            return Paths { root: root, dir_patterns: ~[], options: options, todo: ~[] };\n+            return Paths {\n+                root: root,\n+                dir_patterns: Vec::new(),\n+                options: options,\n+                todo: Vec::new(),\n+            };\n         }\n         root.push(pat_root.get_ref());\n     }\n \n     let root_len = pat_root.map_or(0u, |p| p.as_vec().len());\n     let dir_patterns = pattern.slice_from(cmp::min(root_len, pattern.len()))\n-                       .split_terminator(is_sep).map(|s| Pattern::new(s)).to_owned_vec();\n+                       .split_terminator(is_sep)\n+                       .map(|s| Pattern::new(s))\n+                       .collect();\n \n-    let todo = list_dir_sorted(&root).move_iter().map(|x|(x,0u)).to_owned_vec();\n+    let todo = list_dir_sorted(&root).move_iter().map(|x|(x,0u)).collect();\n \n     Paths {\n         root: root,\n@@ -131,7 +137,7 @@ impl Iterator<Path> for Paths {\n             }\n \n             let (path,idx) = self.todo.pop().unwrap();\n-            let ref pattern = self.dir_patterns[idx];\n+            let ref pattern = *self.dir_patterns.get(idx);\n \n             if pattern.matches_with(match path.filename_str() {\n                 // this ugly match needs to go here to avoid a borrowck error\n@@ -155,13 +161,13 @@ impl Iterator<Path> for Paths {\n \n }\n \n-fn list_dir_sorted(path: &Path) -> ~[Path] {\n+fn list_dir_sorted(path: &Path) -> Vec<Path> {\n     match fs::readdir(path) {\n         Ok(mut children) => {\n             children.sort_by(|p1, p2| p2.filename().cmp(&p1.filename()));\n-            children\n+            children.move_iter().collect()\n         }\n-        Err(..) => ~[]\n+        Err(..) => Vec::new()\n     }\n }\n \n@@ -170,16 +176,15 @@ fn list_dir_sorted(path: &Path) -> ~[Path] {\n  */\n #[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, Hash, Default)]\n pub struct Pattern {\n-    priv tokens: ~[PatternToken]\n-}\n+    priv tokens: Vec<PatternToken> }\n \n #[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, Hash)]\n enum PatternToken {\n     Char(char),\n     AnyChar,\n     AnySequence,\n-    AnyWithin(~[CharSpecifier]),\n-    AnyExcept(~[CharSpecifier])\n+    AnyWithin(Vec<CharSpecifier> ),\n+    AnyExcept(Vec<CharSpecifier> )\n }\n \n #[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, Hash)]\n@@ -219,7 +224,7 @@ impl Pattern {\n     pub fn new(pattern: &str) -> Pattern {\n \n         let chars = pattern.chars().to_owned_vec();\n-        let mut tokens = ~[];\n+        let mut tokens = Vec::new();\n         let mut i = 0;\n \n         while i < chars.len() {\n@@ -392,10 +397,16 @@ impl Pattern {\n                             !require_literal(c)\n                         }\n                         AnyWithin(ref specifiers) => {\n-                            !require_literal(c) && in_char_specifiers(*specifiers, c, options)\n+                            !require_literal(c) &&\n+                                in_char_specifiers(specifiers.as_slice(),\n+                                                   c,\n+                                                   options)\n                         }\n                         AnyExcept(ref specifiers) => {\n-                            !require_literal(c) && !in_char_specifiers(*specifiers, c, options)\n+                            !require_literal(c) &&\n+                                !in_char_specifiers(specifiers.as_slice(),\n+                                                    c,\n+                                                    options)\n                         }\n                         Char(c2) => {\n                             chars_eq(c, c2, options.case_sensitive)\n@@ -422,8 +433,8 @@ impl Pattern {\n \n }\n \n-fn parse_char_specifiers(s: &[char]) -> ~[CharSpecifier] {\n-    let mut cs = ~[];\n+fn parse_char_specifiers(s: &[char]) -> Vec<CharSpecifier> {\n+    let mut cs = Vec::new();\n     let mut i = 0;\n     while i < s.len() {\n         if i + 3 <= s.len() && s[i + 1] == '-' {"}, {"sha": "a71674c4122816c934520d7ea4070ea9ea4f914b", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -299,9 +299,9 @@ impl<T: FromStr + Clone + Integer + Ord>\n         if split.len() < 2 {\n             return None\n         }\n-        let a_option: Option<T> = FromStr::from_str(split.as_slice()[0]);\n+        let a_option: Option<T> = FromStr::from_str(*split.get(0));\n         a_option.and_then(|a| {\n-            let b_option: Option<T> = FromStr::from_str(split.as_slice()[1]);\n+            let b_option: Option<T> = FromStr::from_str(*split.get(1));\n             b_option.and_then(|b| {\n                 Some(Ratio::new(a.clone(), b.clone()))\n             })\n@@ -316,11 +316,12 @@ impl<T: FromStrRadix + Clone + Integer + Ord>\n         if split.len() < 2 {\n             None\n         } else {\n-            let a_option: Option<T> = FromStrRadix::from_str_radix(split.as_slice()[0],\n-                                                                   radix);\n+            let a_option: Option<T> = FromStrRadix::from_str_radix(\n+                *split.get(0),\n+                radix);\n             a_option.and_then(|a| {\n                 let b_option: Option<T> =\n-                    FromStrRadix::from_str_radix(split.as_slice()[1], radix);\n+                    FromStrRadix::from_str_radix(*split.get(1), radix);\n                 b_option.and_then(|b| {\n                     Some(Ratio::new(a.clone(), b.clone()))\n                 })"}, {"sha": "fd8b274509aef1b27edd60f94f3b3cd2ac664882", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -837,7 +837,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> session::Options {\n         let flags = vec::append(matches.opt_strs(level_short)\n                                           .move_iter()\n                                           .collect(),\n-                                   matches.opt_strs(level_name));\n+                                   matches.opt_strs(level_name).as_slice());\n         for lint_name in flags.iter() {\n             let lint_name = lint_name.replace(\"-\", \"_\");\n             match lint_dict.find_equiv(&lint_name) {"}, {"sha": "b3e40bd71f367327a23b6d9fb1a9ddc94139abae", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -243,7 +243,7 @@ pub fn run_compiler(args: &[~str]) {\n     let lint_flags = vec::append(matches.opt_strs(\"W\")\n                                            .move_iter()\n                                            .collect(),\n-                                    matches.opt_strs(\"warn\"));\n+                                    matches.opt_strs(\"warn\").as_slice());\n     if lint_flags.iter().any(|x| x == &~\"help\") {\n         describe_warnings();\n         return;\n@@ -273,7 +273,7 @@ pub fn run_compiler(args: &[~str]) {\n     let (input, input_file_path) = match matches.free.len() {\n       0u => d::early_error(\"no input filename given\"),\n       1u => {\n-        let ifile = matches.free[0].as_slice();\n+        let ifile = matches.free.get(0).as_slice();\n         if ifile == \"-\" {\n             let contents = io::stdin().read_to_end().unwrap();\n             let src = str::from_utf8_owned(contents).unwrap();"}, {"sha": "c18349d8d5aa4a19d2cd9e6cb53790be227d0bb3", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 50, "deletions": 53, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -35,12 +35,6 @@ pub trait Clean<T> {\n     fn clean(&self) -> T;\n }\n \n-impl<T: Clean<U>, U> Clean<~[U]> for ~[T] {\n-    fn clean(&self) -> ~[U] {\n-        self.iter().map(|x| x.clean()).collect()\n-    }\n-}\n-\n impl<T: Clean<U>, U> Clean<Vec<U>> for Vec<T> {\n     fn clean(&self) -> Vec<U> {\n         self.iter().map(|x| x.clean()).collect()\n@@ -75,21 +69,21 @@ impl<T: Clean<U>, U> Clean<Vec<U>> for syntax::opt_vec::OptVec<T> {\n pub struct Crate {\n     name: ~str,\n     module: Option<Item>,\n-    externs: ~[(ast::CrateNum, ExternalCrate)],\n+    externs: Vec<(ast::CrateNum, ExternalCrate)> ,\n }\n \n impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n     fn clean(&self) -> Crate {\n         use syntax::attr::find_crateid;\n         let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n \n-        let mut externs = ~[];\n+        let mut externs = Vec::new();\n         cx.sess().cstore.iter_crate_data(|n, meta| {\n             externs.push((n, meta.clean()));\n         });\n \n         Crate {\n-            name: match find_crateid(self.attrs) {\n+            name: match find_crateid(self.attrs.as_slice()) {\n                 Some(n) => n.name,\n                 None => fail!(\"rustdoc requires a `crate_id` crate attribute\"),\n             },\n@@ -102,7 +96,7 @@ impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n #[deriving(Clone, Encodable, Decodable)]\n pub struct ExternalCrate {\n     name: ~str,\n-    attrs: ~[Attribute],\n+    attrs: Vec<Attribute> ,\n }\n \n impl Clean<ExternalCrate> for cstore::crate_metadata {\n@@ -125,7 +119,7 @@ pub struct Item {\n     source: Span,\n     /// Not everything has a name. E.g., impls\n     name: Option<~str>,\n-    attrs: ~[Attribute],\n+    attrs: Vec<Attribute> ,\n     inner: ItemEnum,\n     visibility: Option<Visibility>,\n     id: ast::NodeId,\n@@ -195,7 +189,7 @@ pub enum ItemEnum {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct Module {\n-    items: ~[Item],\n+    items: Vec<Item> ,\n     is_crate: bool,\n }\n \n@@ -206,13 +200,13 @@ impl Clean<Item> for doctree::Module {\n         } else {\n             ~\"\"\n         };\n-        let mut foreigns = ~[];\n+        let mut foreigns = Vec::new();\n         for subforeigns in self.foreigns.clean().move_iter() {\n             for foreign in subforeigns.move_iter() {\n                 foreigns.push(foreign)\n             }\n         }\n-        let items: ~[~[Item]] = ~[\n+        let items: Vec<Vec<Item> > = vec!(\n             self.structs.clean().move_iter().collect(),\n             self.enums.clean().move_iter().collect(),\n             self.fns.clean().move_iter().collect(),\n@@ -224,7 +218,7 @@ impl Clean<Item> for doctree::Module {\n             self.impls.clean().move_iter().collect(),\n             self.view_items.clean().move_iter().collect(),\n             self.macros.clean().move_iter().collect()\n-        ];\n+        );\n         Item {\n             name: Some(name),\n             attrs: self.attrs.clean(),\n@@ -233,7 +227,9 @@ impl Clean<Item> for doctree::Module {\n             id: self.id,\n             inner: ModuleItem(Module {\n                is_crate: self.is_crate,\n-               items: items.concat_vec(),\n+               items: items.iter()\n+                           .flat_map(|x| x.iter().map(|x| (*x).clone()))\n+                           .collect(),\n             })\n         }\n     }\n@@ -242,7 +238,7 @@ impl Clean<Item> for doctree::Module {\n #[deriving(Clone, Encodable, Decodable)]\n pub enum Attribute {\n     Word(~str),\n-    List(~str, ~[Attribute]),\n+    List(~str, Vec<Attribute> ),\n     NameValue(~str, ~str)\n }\n \n@@ -292,8 +288,7 @@ impl<'a> attr::AttrMetaMethods for &'a Attribute {\n pub struct TyParam {\n     name: ~str,\n     id: ast::NodeId,\n-    bounds: ~[TyParamBound]\n-}\n+    bounds: Vec<TyParamBound> }\n \n impl Clean<TyParam> for ast::TyParam {\n     fn clean(&self) -> TyParam {\n@@ -340,9 +335,8 @@ impl Clean<Lifetime> for ast::Lifetime {\n // maybe use a Generic enum and use ~[Generic]?\n #[deriving(Clone, Encodable, Decodable)]\n pub struct Generics {\n-    lifetimes: ~[Lifetime],\n-    type_params: ~[TyParam]\n-}\n+    lifetimes: Vec<Lifetime> ,\n+    type_params: Vec<TyParam> }\n \n impl Clean<Generics> for ast::Generics {\n     fn clean(&self) -> Generics {\n@@ -373,7 +367,7 @@ impl Clean<Item> for ast::Method {\n             },\n             output: (self.decl.output.clean()),\n             cf: self.decl.cf.clean(),\n-            attrs: ~[]\n+            attrs: Vec::new()\n         };\n         Item {\n             name: Some(self.ident.clean()),\n@@ -411,7 +405,7 @@ impl Clean<Item> for ast::TypeMethod {\n             },\n             output: (self.decl.output.clean()),\n             cf: self.decl.cf.clean(),\n-            attrs: ~[]\n+            attrs: Vec::new()\n         };\n         Item {\n             name: Some(self.ident.clean()),\n@@ -476,12 +470,11 @@ impl Clean<Item> for doctree::Function {\n pub struct ClosureDecl {\n     sigil: ast::Sigil,\n     region: Option<Lifetime>,\n-    lifetimes: ~[Lifetime],\n+    lifetimes: Vec<Lifetime> ,\n     decl: FnDecl,\n     onceness: ast::Onceness,\n     purity: ast::Purity,\n-    bounds: ~[TyParamBound]\n-}\n+    bounds: Vec<TyParamBound> }\n \n impl Clean<ClosureDecl> for ast::ClosureTy {\n     fn clean(&self) -> ClosureDecl {\n@@ -494,7 +487,7 @@ impl Clean<ClosureDecl> for ast::ClosureTy {\n             purity: self.purity,\n             bounds: match self.bounds {\n                 Some(ref x) => x.clean().move_iter().collect(),\n-                None        => ~[]\n+                None        => Vec::new()\n             },\n         }\n     }\n@@ -505,12 +498,11 @@ pub struct FnDecl {\n     inputs: Arguments,\n     output: Type,\n     cf: RetStyle,\n-    attrs: ~[Attribute]\n-}\n+    attrs: Vec<Attribute> }\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct Arguments {\n-    values: ~[Argument],\n+    values: Vec<Argument> ,\n }\n \n impl Clean<FnDecl> for ast::FnDecl {\n@@ -521,7 +513,7 @@ impl Clean<FnDecl> for ast::FnDecl {\n             },\n             output: (self.output.clean()),\n             cf: self.cf.clean(),\n-            attrs: ~[]\n+            attrs: Vec::new()\n         }\n     }\n }\n@@ -560,9 +552,9 @@ impl Clean<RetStyle> for ast::RetStyle {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct Trait {\n-    methods: ~[TraitMethod],\n+    methods: Vec<TraitMethod> ,\n     generics: Generics,\n-    parents: ~[Type],\n+    parents: Vec<Type> ,\n }\n \n impl Clean<Item> for doctree::Trait {\n@@ -632,14 +624,14 @@ pub enum Type {\n     /// structs/enums/traits (anything that'd be an ast::TyPath)\n     ResolvedPath {\n         path: Path,\n-        typarams: Option<~[TyParamBound]>,\n+        typarams: Option<Vec<TyParamBound> >,\n         id: ast::NodeId,\n     },\n     /// Same as above, but only external variants\n     ExternalPath {\n         path: Path,\n-        typarams: Option<~[TyParamBound]>,\n-        fqn: ~[~str],\n+        typarams: Option<Vec<TyParamBound> >,\n+        fqn: Vec<~str> ,\n         kind: TypeKind,\n         krate: ast::CrateNum,\n     },\n@@ -655,7 +647,7 @@ pub enum Type {\n     Closure(~ClosureDecl),\n     /// extern \"ABI\" fn\n     BareFunction(~BareFunctionDecl),\n-    Tuple(~[Type]),\n+    Tuple(Vec<Type> ),\n     Vector(~Type),\n     FixedVector(~Type, ~str),\n     String,\n@@ -746,7 +738,7 @@ impl Clean<Option<Visibility>> for ast::Visibility {\n pub struct Struct {\n     struct_type: doctree::StructType,\n     generics: Generics,\n-    fields: ~[Item],\n+    fields: Vec<Item> ,\n     fields_stripped: bool,\n }\n \n@@ -774,7 +766,7 @@ impl Clean<Item> for doctree::Struct {\n #[deriving(Clone, Encodable, Decodable)]\n pub struct VariantStruct {\n     struct_type: doctree::StructType,\n-    fields: ~[Item],\n+    fields: Vec<Item> ,\n     fields_stripped: bool,\n }\n \n@@ -790,7 +782,7 @@ impl Clean<VariantStruct> for syntax::ast::StructDef {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct Enum {\n-    variants: ~[Item],\n+    variants: Vec<Item> ,\n     generics: Generics,\n     variants_stripped: bool,\n }\n@@ -835,7 +827,7 @@ impl Clean<Item> for doctree::Variant {\n #[deriving(Clone, Encodable, Decodable)]\n pub enum VariantKind {\n     CLikeVariant,\n-    TupleVariant(~[Type]),\n+    TupleVariant(Vec<Type> ),\n     StructVariant(VariantStruct),\n }\n \n@@ -882,7 +874,7 @@ impl Clean<Span> for syntax::codemap::Span {\n #[deriving(Clone, Encodable, Decodable)]\n pub struct Path {\n     global: bool,\n-    segments: ~[PathSegment],\n+    segments: Vec<PathSegment> ,\n }\n \n impl Clean<Path> for ast::Path {\n@@ -897,8 +889,8 @@ impl Clean<Path> for ast::Path {\n #[deriving(Clone, Encodable, Decodable)]\n pub struct PathSegment {\n     name: ~str,\n-    lifetimes: ~[Lifetime],\n-    types: ~[Type],\n+    lifetimes: Vec<Lifetime> ,\n+    types: Vec<Type> ,\n }\n \n impl Clean<PathSegment> for ast::PathSegment {\n@@ -969,7 +961,7 @@ impl Clean<BareFunctionDecl> for ast::BareFnTy {\n             purity: self.purity,\n             generics: Generics {\n                 lifetimes: self.lifetimes.clean().move_iter().collect(),\n-                type_params: ~[],\n+                type_params: Vec::new(),\n             },\n             decl: self.decl.clean(),\n             abi: self.abis.to_str(),\n@@ -1025,7 +1017,7 @@ pub struct Impl {\n     generics: Generics,\n     trait_: Option<Type>,\n     for_: Type,\n-    methods: ~[Item],\n+    methods: Vec<Item> ,\n }\n \n impl Clean<Item> for doctree::Impl {\n@@ -1069,7 +1061,7 @@ impl Clean<Item> for ast::ViewItem {\n #[deriving(Clone, Encodable, Decodable)]\n pub enum ViewItemInner {\n     ExternCrate(~str, Option<~str>, ast::NodeId),\n-    Import(~[ViewPath])\n+    Import(Vec<ViewPath>)\n }\n \n impl Clean<ViewItemInner> for ast::ViewItem_ {\n@@ -1096,7 +1088,7 @@ pub enum ViewPath {\n     // use source::*;\n     GlobImport(ImportSource),\n     // use source::{a, b, c};\n-    ImportList(ImportSource, ~[ViewListIdent]),\n+    ImportList(ImportSource, Vec<ViewListIdent> ),\n }\n \n #[deriving(Clone, Encodable, Decodable)]\n@@ -1231,7 +1223,7 @@ fn name_from_pat(p: &ast::Pat) -> ~str {\n }\n \n /// Given a Type, resolve it using the def_map\n-fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n+fn resolve_type(path: Path, tpbs: Option<Vec<TyParamBound> >,\n                 id: ast::NodeId) -> Type {\n     let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n     let tycx = match cx.maybe_typed {\n@@ -1274,9 +1266,14 @@ fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n         ResolvedPath{ path: path, typarams: tpbs, id: def_id.node }\n     } else {\n         let fqn = csearch::get_item_path(tycx, def_id);\n-        let fqn = fqn.move_iter().map(|i| i.to_str()).to_owned_vec();\n-        ExternalPath{ path: path, typarams: tpbs, fqn: fqn, kind: kind,\n-                      krate: def_id.krate }\n+        let fqn = fqn.move_iter().map(|i| i.to_str()).collect();\n+        ExternalPath {\n+            path: path,\n+            typarams: tpbs,\n+            fqn: fqn,\n+            kind: kind,\n+            krate: def_id.krate,\n+        }\n     }\n }\n "}, {"sha": "7fb40a09693edd388e668e1f4a381dc8b8b535fa", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -51,8 +51,8 @@ pub struct CrateAnalysis {\n }\n \n /// Parses, resolves, and typechecks the given crate\n-fn get_ast_and_resolve(cpath: &Path,\n-                       libs: HashSet<Path>, cfgs: ~[~str]) -> (DocContext, CrateAnalysis) {\n+fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<~str>)\n+                       -> (DocContext, CrateAnalysis) {\n     use syntax::codemap::dummy_spanned;\n     use rustc::driver::driver::{FileInput, build_configuration,\n                                 phase_1_parse_input,\n@@ -101,7 +101,8 @@ fn get_ast_and_resolve(cpath: &Path,\n     })\n }\n \n-pub fn run_core (libs: HashSet<Path>, cfgs: ~[~str], path: &Path) -> (clean::Crate, CrateAnalysis) {\n+pub fn run_core(libs: HashSet<Path>, cfgs: Vec<~str>, path: &Path)\n+                -> (clean::Crate, CrateAnalysis) {\n     let (ctxt, analysis) = get_ast_and_resolve(path, libs, cfgs);\n     let ctxt = @ctxt;\n     local_data::set(super::ctxtkey, ctxt);"}, {"sha": "2bd2e7a8e5c61d138a9ca5322d0f18009bc7a2dd", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -18,21 +18,21 @@ use syntax::ast::{Ident, NodeId};\n \n pub struct Module {\n     name: Option<Ident>,\n-    attrs: ~[ast::Attribute],\n+    attrs: Vec<ast::Attribute> ,\n     where: Span,\n-    structs: ~[Struct],\n-    enums: ~[Enum],\n-    fns: ~[Function],\n-    mods: ~[Module],\n+    structs: Vec<Struct> ,\n+    enums: Vec<Enum> ,\n+    fns: Vec<Function> ,\n+    mods: Vec<Module> ,\n     id: NodeId,\n-    typedefs: ~[Typedef],\n-    statics: ~[Static],\n-    traits: ~[Trait],\n+    typedefs: Vec<Typedef> ,\n+    statics: Vec<Static> ,\n+    traits: Vec<Trait> ,\n     vis: ast::Visibility,\n-    impls: ~[Impl],\n-    foreigns: ~[ast::ForeignMod],\n-    view_items: ~[ast::ViewItem],\n-    macros: ~[Macro],\n+    impls: Vec<Impl> ,\n+    foreigns: Vec<ast::ForeignMod> ,\n+    view_items: Vec<ast::ViewItem> ,\n+    macros: Vec<Macro> ,\n     is_crate: bool,\n }\n \n@@ -43,18 +43,18 @@ impl Module {\n             id: 0,\n             vis: ast::Private,\n             where: syntax::codemap::DUMMY_SP,\n-            attrs      : ~[],\n-            structs    : ~[],\n-            enums      : ~[],\n-            fns        : ~[],\n-            mods       : ~[],\n-            typedefs   : ~[],\n-            statics    : ~[],\n-            traits     : ~[],\n-            impls      : ~[],\n-            view_items : ~[],\n-            foreigns   : ~[],\n-            macros     : ~[],\n+            attrs      : Vec::new(),\n+            structs    : Vec::new(),\n+            enums      : Vec::new(),\n+            fns        : Vec::new(),\n+            mods       : Vec::new(),\n+            typedefs   : Vec::new(),\n+            statics    : Vec::new(),\n+            traits     : Vec::new(),\n+            impls      : Vec::new(),\n+            view_items : Vec::new(),\n+            foreigns   : Vec::new(),\n+            macros     : Vec::new(),\n             is_crate   : false,\n         }\n     }\n@@ -83,24 +83,24 @@ pub struct Struct {\n     struct_type: StructType,\n     name: Ident,\n     generics: ast::Generics,\n-    attrs: ~[ast::Attribute],\n-    fields: ~[ast::StructField],\n+    attrs: Vec<ast::Attribute> ,\n+    fields: Vec<ast::StructField> ,\n     where: Span,\n }\n \n pub struct Enum {\n     vis: ast::Visibility,\n-    variants: ~[Variant],\n+    variants: Vec<Variant> ,\n     generics: ast::Generics,\n-    attrs: ~[ast::Attribute],\n+    attrs: Vec<ast::Attribute> ,\n     id: NodeId,\n     where: Span,\n     name: Ident,\n }\n \n pub struct Variant {\n     name: Ident,\n-    attrs: ~[ast::Attribute],\n+    attrs: Vec<ast::Attribute> ,\n     kind: ast::VariantKind,\n     id: ast::NodeId,\n     vis: ast::Visibility,\n@@ -109,7 +109,7 @@ pub struct Variant {\n \n pub struct Function {\n     decl: ast::FnDecl,\n-    attrs: ~[ast::Attribute],\n+    attrs: Vec<ast::Attribute> ,\n     id: NodeId,\n     name: Ident,\n     vis: ast::Visibility,\n@@ -123,7 +123,7 @@ pub struct Typedef {\n     gen: ast::Generics,\n     name: Ident,\n     id: ast::NodeId,\n-    attrs: ~[ast::Attribute],\n+    attrs: Vec<ast::Attribute> ,\n     where: Span,\n     vis: ast::Visibility,\n }\n@@ -133,18 +133,18 @@ pub struct Static {\n     mutability: ast::Mutability,\n     expr: @ast::Expr,\n     name: Ident,\n-    attrs: ~[ast::Attribute],\n+    attrs: Vec<ast::Attribute> ,\n     vis: ast::Visibility,\n     id: ast::NodeId,\n     where: Span,\n }\n \n pub struct Trait {\n     name: Ident,\n-    methods: ~[ast::TraitMethod], //should be TraitMethod\n+    methods: Vec<ast::TraitMethod> , //should be TraitMethod\n     generics: ast::Generics,\n-    parents: ~[ast::TraitRef],\n-    attrs: ~[ast::Attribute],\n+    parents: Vec<ast::TraitRef> ,\n+    attrs: Vec<ast::Attribute> ,\n     id: ast::NodeId,\n     where: Span,\n     vis: ast::Visibility,\n@@ -154,8 +154,8 @@ pub struct Impl {\n     generics: ast::Generics,\n     trait_: Option<ast::TraitRef>,\n     for_: ast::P<ast::Ty>,\n-    methods: ~[@ast::Method],\n-    attrs: ~[ast::Attribute],\n+    methods: Vec<@ast::Method> ,\n+    attrs: Vec<ast::Attribute> ,\n     where: Span,\n     vis: ast::Visibility,\n     id: ast::NodeId,\n@@ -164,7 +164,7 @@ pub struct Impl {\n pub struct Macro {\n     name: Ident,\n     id: ast::NodeId,\n-    attrs: ~[ast::Attribute],\n+    attrs: Vec<ast::Attribute> ,\n     where: Span,\n }\n "}, {"sha": "f6b9ec329fd35df0ccee9aa94f981d10d81a0352", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -23,7 +23,7 @@ pub trait DocFolder {\n         let inner = inner;\n         let inner = match inner {\n             StructItem(mut i) => {\n-                let mut foo = ~[]; swap(&mut foo, &mut i.fields);\n+                let mut foo = Vec::new(); swap(&mut foo, &mut i.fields);\n                 let num_fields = foo.len();\n                 i.fields.extend(&mut foo.move_iter().filter_map(|x| self.fold_item(x)));\n                 i.fields_stripped |= num_fields != i.fields.len();\n@@ -33,7 +33,7 @@ pub trait DocFolder {\n                 ModuleItem(self.fold_mod(i))\n             },\n             EnumItem(mut i) => {\n-                let mut foo = ~[]; swap(&mut foo, &mut i.variants);\n+                let mut foo = Vec::new(); swap(&mut foo, &mut i.variants);\n                 let num_variants = foo.len();\n                 i.variants.extend(&mut foo.move_iter().filter_map(|x| self.fold_item(x)));\n                 i.variants_stripped |= num_variants != i.variants.len();\n@@ -56,20 +56,20 @@ pub trait DocFolder {\n                         },\n                     }\n                 }\n-                let mut foo = ~[]; swap(&mut foo, &mut i.methods);\n+                let mut foo = Vec::new(); swap(&mut foo, &mut i.methods);\n                 i.methods.extend(&mut foo.move_iter().filter_map(|x| vtrm(self, x)));\n                 TraitItem(i)\n             },\n             ImplItem(mut i) => {\n-                let mut foo = ~[]; swap(&mut foo, &mut i.methods);\n+                let mut foo = Vec::new(); swap(&mut foo, &mut i.methods);\n                 i.methods.extend(&mut foo.move_iter().filter_map(|x| self.fold_item(x)));\n                 ImplItem(i)\n             },\n             VariantItem(i) => {\n                 let i2 = i.clone(); // this clone is small\n                 match i.kind {\n                     StructVariant(mut j) => {\n-                        let mut foo = ~[]; swap(&mut foo, &mut j.fields);\n+                        let mut foo = Vec::new(); swap(&mut foo, &mut j.fields);\n                         let num_fields = foo.len();\n                         let c = |x| self.fold_item(x);\n                         j.fields.extend(&mut foo.move_iter().filter_map(c));"}, {"sha": "a8f243139d269b80febb72ff37069606754136db", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -170,7 +170,7 @@ fn external_path(w: &mut io::Writer, p: &clean::Path, print_all: bool,\n             }\n         },\n         |_cache| {\n-            Some((fqn.to_owned(), match kind {\n+            Some((Vec::from_slice(fqn), match kind {\n                 clean::TypeStruct => \"struct\",\n                 clean::TypeEnum => \"enum\",\n                 clean::TypeFunction => \"fn\",\n@@ -181,7 +181,7 @@ fn external_path(w: &mut io::Writer, p: &clean::Path, print_all: bool,\n \n fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n         root: |&render::Cache, &[~str]| -> Option<~str>,\n-        info: |&render::Cache| -> Option<(~[~str], &'static str)>)\n+        info: |&render::Cache| -> Option<(Vec<~str> , &'static str)>)\n     -> fmt::Result\n {\n     // The generics will get written to both the title and link\n@@ -210,7 +210,7 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n         local_data::get(cache_key, |cache| {\n             let cache = cache.unwrap().get();\n             let abs_root = root(cache, loc.as_slice());\n-            let rel_root = match path.segments[0].name.as_slice() {\n+            let rel_root = match path.segments.get(0).name.as_slice() {\n                 \"self\" => Some(~\"./\"),\n                 _ => None,\n             };\n@@ -279,7 +279,7 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n \n /// Helper to render type parameters\n fn typarams(w: &mut io::Writer,\n-            typarams: &Option<~[clean::TyParamBound]>) -> fmt::Result {\n+            typarams: &Option<Vec<clean::TyParamBound> >) -> fmt::Result {\n     match *typarams {\n         Some(ref params) => {\n             try!(write!(w, \"&lt;\"));\n@@ -536,11 +536,11 @@ impl fmt::Show for clean::ViewListIdent {\n             Some(did) if ast_util::is_local(did) => {\n                 let path = clean::Path {\n                     global: false,\n-                    segments: ~[clean::PathSegment {\n+                    segments: vec!(clean::PathSegment {\n                         name: self.name.clone(),\n-                        lifetimes: ~[],\n-                        types: ~[],\n-                    }]\n+                        lifetimes: Vec::new(),\n+                        types: Vec::new(),\n+                    })\n                 };\n                 resolved_path(f.buf, did.node, &path, false)\n             }"}, {"sha": "4079fafb3683789867cc9e57ca919956db53ed56", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 39, "deletions": 27, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -68,7 +68,7 @@ use html::highlight;\n pub struct Context {\n     /// Current hierarchy of components leading down to what's currently being\n     /// rendered\n-    current: ~[~str],\n+    current: Vec<~str> ,\n     /// String representation of how to get back to the root path of the 'doc/'\n     /// folder in terms of a relative URL.\n     root_path: ~str,\n@@ -83,7 +83,7 @@ pub struct Context {\n     /// functions), and the value is the list of containers belonging to this\n     /// header. This map will change depending on the surrounding context of the\n     /// page.\n-    sidebar: HashMap<~str, ~[~str]>,\n+    sidebar: HashMap<~str, Vec<~str> >,\n     /// This flag indicates whether [src] links should be generated or not. If\n     /// the source files are present in the html rendering, then this will be\n     /// `true`.\n@@ -130,14 +130,14 @@ pub struct Cache {\n     ///\n     /// The values of the map are a list of implementations and documentation\n     /// found on that implementation.\n-    impls: HashMap<ast::NodeId, ~[(clean::Impl, Option<~str>)]>,\n+    impls: HashMap<ast::NodeId, Vec<(clean::Impl, Option<~str>)> >,\n \n     /// Maintains a mapping of local crate node ids to the fully qualified name\n     /// and \"short type description\" of that node. This is used when generating\n     /// URLs when a type is being linked to. External paths are not located in\n     /// this map because the `External` type itself has all the information\n     /// necessary.\n-    paths: HashMap<ast::NodeId, (~[~str], &'static str)>,\n+    paths: HashMap<ast::NodeId, (Vec<~str> , &'static str)>,\n \n     /// This map contains information about all known traits of this crate.\n     /// Implementations of a crate should inherit the documentation of the\n@@ -148,16 +148,16 @@ pub struct Cache {\n     /// When rendering traits, it's often useful to be able to list all\n     /// implementors of the trait, and this mapping is exactly, that: a mapping\n     /// of trait ids to the list of known implementors of the trait\n-    implementors: HashMap<ast::NodeId, ~[Implementor]>,\n+    implementors: HashMap<ast::NodeId, Vec<Implementor> >,\n \n     /// Cache of where external crate documentation can be found.\n     extern_locations: HashMap<ast::CrateNum, ExternalLocation>,\n \n     // Private fields only used when initially crawling a crate to build a cache\n \n-    priv stack: ~[~str],\n-    priv parent_stack: ~[ast::NodeId],\n-    priv search_index: ~[IndexItem],\n+    priv stack: Vec<~str> ,\n+    priv parent_stack: Vec<ast::NodeId> ,\n+    priv search_index: Vec<IndexItem> ,\n     priv privmod: bool,\n     priv public_items: NodeSet,\n \n@@ -202,13 +202,13 @@ struct IndexItem {\n // TLS keys used to carry information around during rendering.\n \n local_data_key!(pub cache_key: Arc<Cache>)\n-local_data_key!(pub current_location_key: ~[~str])\n+local_data_key!(pub current_location_key: Vec<~str> )\n \n /// Generates the documentation for `crate` into the directory `dst`\n pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n     let mut cx = Context {\n         dst: dst,\n-        current: ~[],\n+        current: Vec::new(),\n         root_path: ~\"\",\n         sidebar: HashMap::new(),\n         layout: layout::Layout {\n@@ -250,9 +250,9 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n             paths: HashMap::new(),\n             traits: HashMap::new(),\n             implementors: HashMap::new(),\n-            stack: ~[],\n-            parent_stack: ~[],\n-            search_index: ~[],\n+            stack: Vec::new(),\n+            parent_stack: Vec::new(),\n+            search_index: Vec::new(),\n             extern_locations: HashMap::new(),\n             privmod: false,\n             public_items: public_items,\n@@ -563,7 +563,7 @@ impl DocFolder for Cache {\n                 match i.trait_ {\n                     Some(clean::ResolvedPath{ id, .. }) => {\n                         let v = self.implementors.find_or_insert_with(id, |_|{\n-                            ~[]\n+                            Vec::new()\n                         });\n                         match i.for_ {\n                             clean::ResolvedPath{..} => {\n@@ -694,7 +694,7 @@ impl DocFolder for Cache {\n                         match i.for_ {\n                             clean::ResolvedPath { id, .. } => {\n                                 let v = self.impls.find_or_insert_with(id, |_| {\n-                                    ~[]\n+                                    Vec::new()\n                                 });\n                                 // extract relevant documentation for this impl\n                                 match attrs.move_iter().find(|a| {\n@@ -787,7 +787,7 @@ impl Context {\n         // using a rwarc makes this parallelizable in the future\n         local_data::set(cache_key, Arc::new(cache));\n \n-        let mut work = ~[(self, item)];\n+        let mut work = vec!((self, item));\n         loop {\n             match work.pop() {\n                 Some((mut cx, item)) => try!(cx.item(item, |cx, item| {\n@@ -919,7 +919,7 @@ impl<'a> fmt::Show for Item<'a> {\n         }\n \n         if self.cx.include_sources {\n-            let mut path = ~[];\n+            let mut path = Vec::new();\n             clean_srcpath(self.item.source.filename.as_bytes(), |component| {\n                 path.push(component.to_owned());\n             });\n@@ -966,8 +966,9 @@ impl<'a> fmt::Show for Item<'a> {\n                       shortty(self.item), self.item.name.get_ref().as_slice()));\n \n         match self.item.inner {\n-            clean::ModuleItem(ref m) => item_module(fmt.buf, self.cx,\n-                                                    self.item, m.items),\n+            clean::ModuleItem(ref m) => {\n+                item_module(fmt.buf, self.cx, self.item, m.items.as_slice())\n+            }\n             clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) =>\n                 item_function(fmt.buf, self.item, f),\n             clean::TraitItem(ref t) => item_trait(fmt.buf, self.item, t),\n@@ -1319,8 +1320,14 @@ fn render_method(w: &mut Writer, meth: &clean::Item) -> fmt::Result {\n fn item_struct(w: &mut Writer, it: &clean::Item,\n                s: &clean::Struct) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust struct'>\"));\n-    try!(render_struct(w, it, Some(&s.generics), s.struct_type, s.fields,\n-                         s.fields_stripped, \"\", true));\n+    try!(render_struct(w,\n+                       it,\n+                       Some(&s.generics),\n+                       s.struct_type,\n+                       s.fields.as_slice(),\n+                       s.fields_stripped,\n+                       \"\",\n+                       true));\n     try!(write!(w, \"</pre>\"));\n \n     try!(document(w, it));\n@@ -1368,9 +1375,14 @@ fn item_enum(w: &mut Writer, it: &clean::Item, e: &clean::Enum) -> fmt::Result {\n                             try!(write!(w, \")\"));\n                         }\n                         clean::StructVariant(ref s) => {\n-                            try!(render_struct(w, v, None, s.struct_type,\n-                                                 s.fields, s.fields_stripped,\n-                                                 \"    \", false));\n+                            try!(render_struct(w,\n+                                               v,\n+                                               None,\n+                                               s.struct_type,\n+                                               s.fields.as_slice(),\n+                                               s.fields_stripped,\n+                                               \"    \",\n+                                               false));\n                         }\n                     }\n                 }\n@@ -1679,20 +1691,20 @@ impl<'a> fmt::Show for Sidebar<'a> {\n     }\n }\n \n-fn build_sidebar(m: &clean::Module) -> HashMap<~str, ~[~str]> {\n+fn build_sidebar(m: &clean::Module) -> HashMap<~str, Vec<~str> > {\n     let mut map = HashMap::new();\n     for item in m.items.iter() {\n         let short = shortty(item);\n         let myname = match item.name {\n             None => continue,\n             Some(ref s) => s.to_owned(),\n         };\n-        let v = map.find_or_insert_with(short.to_owned(), |_| ~[]);\n+        let v = map.find_or_insert_with(short.to_owned(), |_| Vec::new());\n         v.push(myname);\n     }\n \n     for (_, items) in map.mut_iter() {\n-        items.sort();\n+        items.as_mut_slice().sort();\n     }\n     return map;\n }"}, {"sha": "6fcd1f83cf41cccdb28974e6eafded61361d1702", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -80,15 +80,15 @@ static DEFAULT_PASSES: &'static [&'static str] = &[\n local_data_key!(pub ctxtkey: @core::DocContext)\n local_data_key!(pub analysiskey: core::CrateAnalysis)\n \n-type Output = (clean::Crate, ~[plugins::PluginJson]);\n+type Output = (clean::Crate, Vec<plugins::PluginJson> );\n \n pub fn main() {\n     std::os::set_exit_status(main_args(std::os::args()));\n }\n \n-pub fn opts() -> ~[getopts::OptGroup] {\n+pub fn opts() -> Vec<getopts::OptGroup> {\n     use getopts::*;\n-    ~[\n+    vec!(\n         optflag(\"h\", \"help\", \"show this help message\"),\n         optflag(\"\", \"version\", \"print rustdoc's version\"),\n         optopt(\"r\", \"input-format\", \"the input type of the specified file\",\n@@ -121,16 +121,18 @@ pub fn opts() -> ~[getopts::OptGroup] {\n         optmulti(\"\", \"markdown-after-content\",\n                  \"files to include inline between the content and </body> of a rendered \\\n                  Markdown file\",\n-                 \"FILES\"),\n-    ]\n+                 \"FILES\")\n+    )\n }\n \n pub fn usage(argv0: &str) {\n-    println!(\"{}\", getopts::usage(format!(\"{} [options] <input>\", argv0), opts()));\n+    println!(\"{}\",\n+             getopts::usage(format!(\"{} [options] <input>\", argv0),\n+                            opts().as_slice()));\n }\n \n pub fn main_args(args: &[~str]) -> int {\n-    let matches = match getopts::getopts(args.tail(), opts()) {\n+    let matches = match getopts::getopts(args.tail(), opts().as_slice()) {\n         Ok(m) => m,\n         Err(err) => {\n             println!(\"{}\", err.to_err_msg());\n@@ -152,28 +154,35 @@ pub fn main_args(args: &[~str]) -> int {\n         println!(\"only one input file may be specified\");\n         return 1;\n     }\n-    let input = matches.free[0].as_slice();\n+    let input = matches.free.get(0).as_slice();\n \n-    let libs = matches.opt_strs(\"L\").map(|s| Path::new(s.as_slice())).move_iter().collect();\n+    let libs = matches.opt_strs(\"L\").iter().map(|s| Path::new(s.as_slice())).collect();\n \n     let test_args = matches.opt_strs(\"test-args\");\n-    let test_args = test_args.iter().flat_map(|s| s.words()).map(|s| s.to_owned()).to_owned_vec();\n+    let test_args: Vec<~str> = test_args.iter()\n+                                        .flat_map(|s| s.words())\n+                                        .map(|s| s.to_owned())\n+                                        .collect();\n \n     let should_test = matches.opt_present(\"test\");\n     let markdown_input = input.ends_with(\".md\") || input.ends_with(\".markdown\");\n \n     let output = matches.opt_str(\"o\").map(|s| Path::new(s));\n \n     match (should_test, markdown_input) {\n-        (true, true) => return markdown::test(input, libs, test_args),\n+        (true, true) => {\n+            return markdown::test(input,\n+                                  libs,\n+                                  test_args.move_iter().collect())\n+        }\n         (true, false) => return test::run(input, libs, test_args),\n \n         (false, true) => return markdown::render(input, output.unwrap_or(Path::new(\"doc\")),\n                                                  &matches),\n         (false, false) => {}\n     }\n \n-    if matches.opt_strs(\"passes\") == ~[~\"list\"] {\n+    if matches.opt_strs(\"passes\").as_slice() == &[~\"list\"] {\n         println!(\"Available passes for running rustdoc:\");\n         for &(name, _, description) in PASSES.iter() {\n             println!(\"{:>20s} - {}\", name, description);\n@@ -248,13 +257,18 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n     let mut plugins = matches.opt_strs(\"plugins\");\n \n     // First, parse the crate and extract all relevant information.\n-    let libs = matches.opt_strs(\"L\").map(|s| Path::new(s.as_slice()));\n+    let libs: Vec<Path> = matches.opt_strs(\"L\")\n+                                 .iter()\n+                                 .map(|s| Path::new(s.as_slice()))\n+                                 .collect();\n     let cfgs = matches.opt_strs(\"cfg\");\n     let cr = Path::new(cratefile);\n     info!(\"starting to run rustc\");\n     let (krate, analysis) = std::task::try(proc() {\n         let cr = cr;\n-        core::run_core(libs.move_iter().collect(), cfgs, &cr)\n+        core::run_core(libs.move_iter().collect(),\n+                       cfgs.move_iter().collect(),\n+                       &cr)\n     }).unwrap();\n     info!(\"finished with rustc\");\n     local_data::set(analysiskey, analysis);\n@@ -344,7 +358,7 @@ fn json_input(input: &str) -> Result<Output, ~str> {\n             };\n             // FIXME: this should read from the \"plugins\" field, but currently\n             //      Json doesn't implement decodable...\n-            let plugin_output = ~[];\n+            let plugin_output = Vec::new();\n             Ok((krate, plugin_output))\n         }\n         Ok(..) => Err(~\"malformed json input: expected an object at the top\"),\n@@ -353,7 +367,7 @@ fn json_input(input: &str) -> Result<Output, ~str> {\n \n /// Outputs the crate/plugin json as a giant json blob at the specified\n /// destination.\n-fn json_output(krate: clean::Crate, res: ~[plugins::PluginJson],\n+fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n                dst: Path) -> io::IoResult<()> {\n     // {\n     //   \"schema\": version,"}, {"sha": "d04d39bcee5c0d26581a523727c120846e9ff642", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -86,9 +86,12 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches) -> int\n     let input_str = load_or_return!(input, 1, 2);\n \n     let (in_header, before_content, after_content) =\n-        match (load_external_files(matches.opt_strs(\"markdown-in-header\")),\n-               load_external_files(matches.opt_strs(\"markdown-before-content\")),\n-               load_external_files(matches.opt_strs(\"markdown-after-content\"))) {\n+        match (load_external_files(matches.opt_strs(\"markdown-in-header\")\n+                                          .as_slice()),\n+               load_external_files(matches.opt_strs(\"markdown-before-content\")\n+                                          .as_slice()),\n+               load_external_files(matches.opt_strs(\"markdown-after-content\")\n+                                          .as_slice())) {\n         (Some(a), Some(b), Some(c)) => (a,b,c),\n         _ => return 3\n     };"}, {"sha": "d9dd73e695647ebc60c19836c83dc63adc145d8e", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -218,7 +218,7 @@ pub fn unindent_comments(krate: clean::Crate) -> plugins::PluginResult {\n     impl fold::DocFolder for CommentCleaner {\n         fn fold_item(&mut self, i: Item) -> Option<Item> {\n             let mut i = i;\n-            let mut avec: ~[clean::Attribute] = ~[];\n+            let mut avec: Vec<clean::Attribute> = Vec::new();\n             for attr in i.attrs.iter() {\n                 match attr {\n                     &clean::NameValue(ref x, ref s) if \"doc\" == *x => avec.push(\n@@ -250,7 +250,7 @@ pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n                     _ => ()\n                 }\n             }\n-            let mut a: ~[clean::Attribute] = i.attrs.iter().filter(|&a| match a {\n+            let mut a: Vec<clean::Attribute> = i.attrs.iter().filter(|&a| match a {\n                 &clean::NameValue(ref x, _) if \"doc\" == *x => false,\n                 _ => true\n             }).map(|x| x.clone()).collect();\n@@ -267,7 +267,7 @@ pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n }\n \n pub fn unindent(s: &str) -> ~str {\n-    let lines = s.lines_any().collect::<~[&str]>();\n+    let lines = s.lines_any().collect::<Vec<&str> >();\n     let mut saw_first_line = false;\n     let mut saw_second_line = false;\n     let min_indent = lines.iter().fold(uint::MAX, |min_indent, line| {\n@@ -311,7 +311,7 @@ pub fn unindent(s: &str) -> ~str {\n     });\n \n     if lines.len() >= 1 {\n-        let mut unindented = ~[ lines[0].trim() ];\n+        let mut unindented = vec!( lines.get(0).trim() );\n         unindented.push_all(lines.tail().map(|&line| {\n             if line.is_whitespace() {\n                 line"}, {"sha": "6e0e9f8790064bdb72e22e9a8a4fbbdacd0e49c2", "filename": "src/librustdoc/plugins.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Fplugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Fplugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fplugins.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -19,8 +19,8 @@ pub type PluginCallback = fn (clean::Crate) -> PluginResult;\n \n /// Manages loading and running of plugins\n pub struct PluginManager {\n-    priv dylibs: ~[dl::DynamicLibrary],\n-    priv callbacks: ~[PluginCallback],\n+    priv dylibs: Vec<dl::DynamicLibrary> ,\n+    priv callbacks: Vec<PluginCallback> ,\n     /// The directory plugins will be loaded from\n     prefix: Path,\n }\n@@ -29,8 +29,8 @@ impl PluginManager {\n     /// Create a new plugin manager\n     pub fn new(prefix: Path) -> PluginManager {\n         PluginManager {\n-            dylibs: ~[],\n-            callbacks: ~[],\n+            dylibs: Vec::new(),\n+            callbacks: Vec::new(),\n             prefix: prefix,\n         }\n     }\n@@ -57,8 +57,8 @@ impl PluginManager {\n         self.callbacks.push(plugin);\n     }\n     /// Run all the loaded plugins over the crate, returning their results\n-    pub fn run_plugins(&self, krate: clean::Crate) -> (clean::Crate, ~[PluginJson]) {\n-        let mut out_json = ~[];\n+    pub fn run_plugins(&self, krate: clean::Crate) -> (clean::Crate, Vec<PluginJson> ) {\n+        let mut out_json = Vec::new();\n         let mut krate = krate;\n         for &callback in self.callbacks.iter() {\n             let (c, res) = callback(krate);"}, {"sha": "09a1b1fc81abd486616147e4baee05e0d1e945b6", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -33,7 +33,7 @@ use html::markdown;\n use passes;\n use visit_ast::RustdocVisitor;\n \n-pub fn run(input: &str, libs: HashSet<Path>, mut test_args: ~[~str]) -> int {\n+pub fn run(input: &str, libs: HashSet<Path>, mut test_args: Vec<~str>) -> int {\n     let input_path = Path::new(input);\n     let input = driver::FileInput(input_path.clone());\n \n@@ -71,13 +71,16 @@ pub fn run(input: &str, libs: HashSet<Path>, mut test_args: ~[~str]) -> int {\n     let (krate, _) = passes::unindent_comments(krate);\n     let (krate, _) = passes::collapse_docs(krate);\n \n-    let mut collector = Collector::new(krate.name.to_owned(), libs, false, false);\n+    let mut collector = Collector::new(krate.name.to_owned(),\n+                                       libs,\n+                                       false,\n+                                       false);\n     collector.fold_crate(krate);\n \n     test_args.unshift(~\"rustdoctest\");\n \n-    testing::test_main(test_args, collector.tests);\n-\n+    testing::test_main(test_args.as_slice(),\n+                       collector.tests.move_iter().collect());\n     0\n }\n \n@@ -187,8 +190,8 @@ fn maketest(s: &str, cratename: &str, loose_feature_gating: bool) -> ~str {\n }\n \n pub struct Collector {\n-    tests: ~[testing::TestDescAndFn],\n-    priv names: ~[~str],\n+    tests: Vec<testing::TestDescAndFn>,\n+    priv names: Vec<~str>,\n     priv libs: HashSet<Path>,\n     priv cnt: uint,\n     priv use_headers: bool,\n@@ -202,8 +205,8 @@ impl Collector {\n     pub fn new(cratename: ~str, libs: HashSet<Path>,\n                use_headers: bool, loose_feature_gating: bool) -> Collector {\n         Collector {\n-            tests: ~[],\n-            names: ~[],\n+            tests: Vec::new(),\n+            names: Vec::new(),\n             libs: libs,\n             cnt: 0,\n             use_headers: use_headers,"}, {"sha": "df533d882f775823ad35ac934bee55cb916615a2", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -22,7 +22,7 @@ use doctree::*;\n \n pub struct RustdocVisitor<'a> {\n     module: Module,\n-    attrs: ~[ast::Attribute],\n+    attrs: Vec<ast::Attribute> ,\n     cx: &'a core::DocContext,\n     analysis: Option<&'a core::CrateAnalysis>,\n }\n@@ -32,7 +32,7 @@ impl<'a> RustdocVisitor<'a> {\n                    analysis: Option<&'b core::CrateAnalysis>) -> RustdocVisitor<'b> {\n         RustdocVisitor {\n             module: Module::new(None),\n-            attrs: ~[],\n+            attrs: Vec::new(),\n             cx: cx,\n             analysis: analysis,\n         }\n@@ -72,7 +72,7 @@ impl<'a> RustdocVisitor<'a> {\n     pub fn visit_enum_def(&mut self, it: &ast::Item, def: &ast::EnumDef,\n                           params: &ast::Generics) -> Enum {\n         debug!(\"Visiting enum\");\n-        let mut vars: ~[Variant] = ~[];\n+        let mut vars: Vec<Variant> = Vec::new();\n         for x in def.variants.iter() {\n             vars.push(Variant {\n                 name: x.node.name,\n@@ -110,7 +110,7 @@ impl<'a> RustdocVisitor<'a> {\n         }\n     }\n \n-    pub fn visit_mod_contents(&mut self, span: Span, attrs: ~[ast::Attribute],\n+    pub fn visit_mod_contents(&mut self, span: Span, attrs: Vec<ast::Attribute> ,\n                               vis: ast::Visibility, id: ast::NodeId,\n                               m: &ast::Mod,\n                               name: Option<ast::Ident>) -> Module {"}, {"sha": "513ca79999730dd2fcb37a46628d7c23f3d0b4eb", "filename": "src/libsync/arc.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Farc.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -583,25 +583,26 @@ mod tests {\n     use super::{Arc, RWArc, MutexArc, CowArc};\n \n     use std::task;\n+    use std::vec_ng::Vec;\n \n     #[test]\n     fn manually_share_arc() {\n-        let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+        let v = vec!(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n         let arc_v = Arc::new(v);\n \n         let (tx, rx) = channel();\n \n         task::spawn(proc() {\n-            let arc_v: Arc<~[int]> = rx.recv();\n+            let arc_v: Arc<Vec<int>> = rx.recv();\n \n             let v = arc_v.get().clone();\n-            assert_eq!(v[3], 4);\n+            assert_eq!(*v.get(3), 4);\n         });\n \n         tx.send(arc_v.clone());\n \n-        assert_eq!(arc_v.get()[2], 3);\n-        assert_eq!(arc_v.get()[4], 5);\n+        assert_eq!(*arc_v.get().get(2), 3);\n+        assert_eq!(*arc_v.get().get(4), 5);\n \n         info!(\"{:?}\", arc_v);\n     }\n@@ -803,7 +804,7 @@ mod tests {\n         });\n \n         // Readers try to catch the writer in the act\n-        let mut children = ~[];\n+        let mut children = Vec::new();\n         for _ in range(0, 5) {\n             let arc3 = arc.clone();\n             let mut builder = task::task();\n@@ -857,7 +858,7 @@ mod tests {\n         let arc = RWArc::new(0);\n \n         // Reader tasks\n-        let mut reader_convos = ~[];\n+        let mut reader_convos = Vec::new();\n         for _ in range(0, 10) {\n             let ((tx1, rx1), (tx2, rx2)) = (channel(), channel());\n             reader_convos.push((tx1, rx2));"}, {"sha": "c50eeae18d21bf4b05b3721383a37ff97235e9d1", "filename": "src/libsync/sync/mod.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibsync%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibsync%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fsync%2Fmod.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -161,10 +161,10 @@ impl<Q:Send> Sem<Q> {\n }\n \n #[doc(hidden)]\n-impl Sem<~[WaitQueue]> {\n+impl Sem<Vec<WaitQueue> > {\n     fn new_and_signal(count: int, num_condvars: uint)\n-        -> Sem<~[WaitQueue]> {\n-        let mut queues = ~[];\n+        -> Sem<Vec<WaitQueue> > {\n+        let mut queues = Vec::new();\n         for _ in range(0, num_condvars) { queues.push(WaitQueue::new()); }\n         Sem::new(count, queues)\n     }\n@@ -182,7 +182,7 @@ enum ReacquireOrderLock<'a> {\n pub struct Condvar<'a> {\n     // The 'Sem' object associated with this condvar. This is the one that's\n     // atomically-unlocked-and-descheduled upon and reacquired during wakeup.\n-    priv sem: &'a Sem<~[WaitQueue]>,\n+    priv sem: &'a Sem<Vec<WaitQueue> >,\n     // This is (can be) an extra semaphore which is held around the reacquire\n     // operation on the first one. This is only used in cvars associated with\n     // rwlocks, and is needed to ensure that, when a downgrader is trying to\n@@ -230,7 +230,7 @@ impl<'a> Condvar<'a> {\n                     }\n                     // Create waiter nobe, and enqueue ourself to\n                     // be woken up by a signaller.\n-                    wait_end = Some(state.blocked[condvar_id].wait_end());\n+                    wait_end = Some(state.blocked.get(condvar_id).wait_end());\n                 } else {\n                     out_of_bounds = Some(state.blocked.len());\n                 }\n@@ -265,7 +265,7 @@ impl<'a> Condvar<'a> {\n             let mut result = false;\n             self.sem.with(|state| {\n                 if condvar_id < state.blocked.len() {\n-                    result = state.blocked[condvar_id].signal();\n+                    result = state.blocked.get(condvar_id).signal();\n                 } else {\n                     out_of_bounds = Some(state.blocked.len());\n                 }\n@@ -290,7 +290,7 @@ impl<'a> Condvar<'a> {\n                     // To avoid :broadcast_heavy, we make a new waitqueue,\n                     // swap it out with the old one, and broadcast on the\n                     // old one outside of the little-lock.\n-                    queue = Some(replace(&mut state.blocked[condvar_id],\n+                    queue = Some(replace(state.blocked.get_mut(condvar_id),\n                                                WaitQueue::new()));\n                 } else {\n                     out_of_bounds = Some(state.blocked.len());\n@@ -326,7 +326,7 @@ fn check_cvar_bounds<U>(\n }\n \n #[doc(hidden)]\n-impl Sem<~[WaitQueue]> {\n+impl Sem<Vec<WaitQueue> > {\n     // The only other places that condvars get built are rwlock.write_cond()\n     // and rwlock_write_mode.\n     pub fn access_cond<U>(&self, blk: |c: &Condvar| -> U) -> U {\n@@ -391,7 +391,7 @@ impl Semaphore {\n  * unwinds.\n  */\n \n-pub struct Mutex { priv sem: Sem<~[WaitQueue]> }\n+pub struct Mutex { priv sem: Sem<Vec<WaitQueue> > }\n impl Clone for Mutex {\n     /// Create a new handle to the mutex.\n     fn clone(&self) -> Mutex {\n@@ -461,7 +461,7 @@ struct RWLockInner {\n  */\n pub struct RWLock {\n     priv order_lock:  Semaphore,\n-    priv access_lock: Sem<~[WaitQueue]>,\n+    priv access_lock: Sem<Vec<WaitQueue> >,\n     priv state:       UnsafeArc<RWLockInner>,\n }\n \n@@ -765,6 +765,7 @@ mod tests {\n     use std::result;\n     use std::task;\n     use std::comm::Empty;\n+    use std::vec_ng::Vec;\n \n     /************************************************************************\n      * Semaphore tests\n@@ -931,7 +932,7 @@ mod tests {\n     #[cfg(test)]\n     fn test_mutex_cond_broadcast_helper(num_waiters: uint) {\n         let m = Mutex::new();\n-        let mut rxs = ~[];\n+        let mut rxs = vec!();\n \n         for _ in range(0, num_waiters) {\n             let mi = m.clone();\n@@ -1200,7 +1201,7 @@ mod tests {\n             }\n         }\n         let x = RWLock::new();\n-        let mut rxs = ~[];\n+        let mut rxs = vec!();\n \n         for _ in range(0, num_waiters) {\n             let xi = x.clone();"}, {"sha": "709dafd5b933ea2027105d80795c4cd8dfa4cba9", "filename": "src/libsync/task_pool.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Ftask_pool.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -14,15 +14,14 @@\n /// parallelism.\n \n use std::task;\n-use std::slice;\n \n enum Msg<T> {\n     Execute(proc(&T)),\n     Quit\n }\n \n pub struct TaskPool<T> {\n-    priv channels: ~[Sender<Msg<T>>],\n+    priv channels: Vec<Sender<Msg<T>>>,\n     priv next_index: uint,\n }\n \n@@ -46,7 +45,7 @@ impl<T> TaskPool<T> {\n                -> TaskPool<T> {\n         assert!(n_tasks >= 1);\n \n-        let channels = slice::from_fn(n_tasks, |i| {\n+        let channels = Vec::from_fn(n_tasks, |i| {\n             let (tx, rx) = channel::<Msg<T>>();\n             let init_fn = init_fn_factory();\n \n@@ -66,13 +65,16 @@ impl<T> TaskPool<T> {\n             tx\n         });\n \n-        return TaskPool { channels: channels, next_index: 0 };\n+        return TaskPool {\n+            channels: channels,\n+            next_index: 0,\n+        };\n     }\n \n     /// Executes the function `f` on a task in the pool. The function\n     /// receives a reference to the local data returned by the `init_fn`.\n     pub fn execute(&mut self, f: proc(&T)) {\n-        self.channels[self.next_index].send(Execute(f));\n+        self.channels.get(self.next_index).send(Execute(f));\n         self.next_index += 1;\n         if self.next_index == self.channels.len() { self.next_index = 0; }\n     }"}, {"sha": "3148c9233ff2d7b4ea0018ec08af84ede6e902db", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -24,8 +24,8 @@\n \n extern crate collections;\n \n-use std::os;\n use std::io;\n+use std::os;\n use terminfo::TermInfo;\n use terminfo::searcher::open;\n use terminfo::parser::compiled::{parse, msys_terminfo};\n@@ -149,10 +149,14 @@ impl<T: Writer> Terminal<T> {\n     pub fn fg(&mut self, color: color::Color) -> io::IoResult<bool> {\n         let color = self.dim_if_necessary(color);\n         if self.num_colors > color {\n-            let s = expand(*self.ti.strings.find_equiv(&(\"setaf\")).unwrap(),\n+            let s = expand(self.ti\n+                               .strings\n+                               .find_equiv(&(\"setaf\"))\n+                               .unwrap()\n+                               .as_slice(),\n                            [Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n-                try!(self.out.write(s.unwrap()));\n+                try!(self.out.write(s.unwrap().as_slice()));\n                 return Ok(true)\n             }\n         }\n@@ -168,10 +172,14 @@ impl<T: Writer> Terminal<T> {\n     pub fn bg(&mut self, color: color::Color) -> io::IoResult<bool> {\n         let color = self.dim_if_necessary(color);\n         if self.num_colors > color {\n-            let s = expand(*self.ti.strings.find_equiv(&(\"setab\")).unwrap(),\n+            let s = expand(self.ti\n+                               .strings\n+                               .find_equiv(&(\"setab\"))\n+                               .unwrap()\n+                               .as_slice(),\n                            [Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n-                try!(self.out.write(s.unwrap()));\n+                try!(self.out.write(s.unwrap().as_slice()));\n                 return Ok(true)\n             }\n         }\n@@ -189,9 +197,11 @@ impl<T: Writer> Terminal<T> {\n                 let cap = cap_for_attr(attr);\n                 let parm = self.ti.strings.find_equiv(&cap);\n                 if parm.is_some() {\n-                    let s = expand(*parm.unwrap(), [], &mut Variables::new());\n+                    let s = expand(parm.unwrap().as_slice(),\n+                                   [],\n+                                   &mut Variables::new());\n                     if s.is_ok() {\n-                        try!(self.out.write(s.unwrap()));\n+                        try!(self.out.write(s.unwrap().as_slice()));\n                         return Ok(true)\n                     }\n                 }\n@@ -225,10 +235,10 @@ impl<T: Writer> Terminal<T> {\n             }\n         }\n         let s = cap.map_or(Err(~\"can't find terminfo capability `sgr0`\"), |op| {\n-            expand(*op, [], &mut Variables::new())\n+            expand(op.as_slice(), [], &mut Variables::new())\n         });\n         if s.is_ok() {\n-            return self.out.write(s.unwrap())\n+            return self.out.write(s.unwrap().as_slice())\n         }\n         Ok(())\n     }"}, {"sha": "26a819ef2bcb8d4c5d45def641ef822b6223f476", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -15,13 +15,13 @@ use collections::HashMap;\n /// A parsed terminfo entry.\n pub struct TermInfo {\n     /// Names for the terminal\n-    priv names: ~[~str],\n+    priv names: Vec<~str> ,\n     /// Map of capability name to boolean value\n     priv bools: HashMap<~str, bool>,\n     /// Map of capability name to numeric value\n     numbers: HashMap<~str, u16>,\n     /// Map of capability name to raw (unexpanded) string\n-    strings: HashMap<~str, ~[u8]>\n+    strings: HashMap<~str, Vec<u8> >\n }\n \n pub mod searcher;"}, {"sha": "09e24a4b1e5ad3355d2ed6a5a74f0002cf451967", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 61, "deletions": 33, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,7 +10,7 @@\n \n //! Parameterized string expansion\n \n-use std::{char, slice};\n+use std::char;\n use std::mem::replace;\n \n #[deriving(Eq)]\n@@ -89,13 +89,13 @@ impl Variables {\n   multiple capabilities for the same terminal.\n   */\n pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n-    -> Result<~[u8], ~str> {\n+    -> Result<Vec<u8> , ~str> {\n     let mut state = Nothing;\n \n     // expanded cap will only rarely be larger than the cap itself\n-    let mut output = slice::with_capacity(cap.len());\n+    let mut output = Vec::with_capacity(cap.len());\n \n-    let mut stack: ~[Param] = ~[];\n+    let mut stack: Vec<Param> = Vec::new();\n \n     // Copy parameters into a local vector for mutability\n     let mut mparams = [\n@@ -248,7 +248,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         let flags = Flags::new();\n                         let res = format(stack.pop().unwrap(), FormatOp::from_char(cur), flags);\n                         if res.is_err() { return res }\n-                        output.push_all(res.unwrap())\n+                        output.push_all(res.unwrap().as_slice())\n                     } else { return Err(~\"stack is empty\") },\n                     ':'|'#'|' '|'.'|'0'..'9' => {\n                         let mut flags = Flags::new();\n@@ -343,7 +343,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     (_,'d')|(_,'o')|(_,'x')|(_,'X')|(_,'s') => if stack.len() > 0 {\n                         let res = format(stack.pop().unwrap(), FormatOp::from_char(cur), *flags);\n                         if res.is_err() { return res }\n-                        output.push_all(res.unwrap());\n+                        output.push_all(res.unwrap().as_slice());\n                         old_state = state; // will cause state to go to Nothing\n                     } else { return Err(~\"stack is empty\") },\n                     (FormatStateFlags,'#') => {\n@@ -476,19 +476,20 @@ impl FormatOp {\n     }\n }\n \n-fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n+fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,~str> {\n     let mut s = match val {\n         Number(d) => {\n-            let mut s = match (op, flags.sign) {\n+            let s = match (op, flags.sign) {\n                 (FormatDigit, true)  => format!(\"{:+d}\", d).into_bytes(),\n                 (FormatDigit, false) => format!(\"{:d}\", d).into_bytes(),\n                 (FormatOctal, _)     => format!(\"{:o}\", d).into_bytes(),\n                 (FormatHex, _)       => format!(\"{:x}\", d).into_bytes(),\n                 (FormatHEX, _)       => format!(\"{:X}\", d).into_bytes(),\n                 (FormatString, _)    => return Err(~\"non-number on stack with %s\"),\n             };\n+            let mut s: Vec<u8> = s.move_iter().collect();\n             if flags.precision > s.len() {\n-                let mut s_ = slice::with_capacity(flags.precision);\n+                let mut s_ = Vec::with_capacity(flags.precision);\n                 let n = flags.precision - s.len();\n                 s_.grow(n, &('0' as u8));\n                 s_.push_all_move(s);\n@@ -497,25 +498,31 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n             assert!(!s.is_empty(), \"string conversion produced empty result\");\n             match op {\n                 FormatDigit => {\n-                    if flags.space && !(s[0] == '-' as u8 || s[0] == '+' as u8) {\n+                    if flags.space && !(*s.get(0) == '-' as u8 ||\n+                                        *s.get(0) == '+' as u8) {\n                         s.unshift(' ' as u8);\n                     }\n                 }\n                 FormatOctal => {\n-                    if flags.alternate && s[0] != '0' as u8 {\n+                    if flags.alternate && *s.get(0) != '0' as u8 {\n                         s.unshift('0' as u8);\n                     }\n                 }\n                 FormatHex => {\n                     if flags.alternate {\n-                        let s_ = replace(&mut s, ~['0' as u8, 'x' as u8]);\n+                        let s_ = replace(&mut s, vec!('0' as u8, 'x' as u8));\n                         s.push_all_move(s_);\n                     }\n                 }\n                 FormatHEX => {\n-                    s = s.into_ascii().to_upper().into_bytes();\n+                    s = s.as_slice()\n+                         .to_ascii()\n+                         .to_upper()\n+                         .into_bytes()\n+                         .move_iter()\n+                         .collect();\n                     if flags.alternate {\n-                        let s_ = replace(&mut s, ~['0' as u8, 'X' as u8]);\n+                        let s_ = replace(&mut s, vec!('0' as u8, 'X' as u8));\n                         s.push_all_move(s_);\n                     }\n                 }\n@@ -526,7 +533,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n         String(s) => {\n             match op {\n                 FormatString => {\n-                    let mut s = s.as_bytes().to_owned();\n+                    let mut s = Vec::from_slice(s.as_bytes());\n                     if flags.precision > 0 && flags.precision < s.len() {\n                         s.truncate(flags.precision);\n                     }\n@@ -543,7 +550,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n         if flags.left {\n             s.grow(n, &(' ' as u8));\n         } else {\n-            let mut s_ = slice::with_capacity(flags.width);\n+            let mut s_ = Vec::with_capacity(flags.width);\n             s_.grow(n, &(' ' as u8));\n             s_.push_all_move(s);\n             s = s_;\n@@ -556,28 +563,29 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n mod test {\n     use super::{expand,String,Variables,Number};\n     use std::result::Ok;\n+    use std::vec_ng;\n \n     #[test]\n     fn test_basic_setabf() {\n         let s = bytes!(\"\\\\E[48;5;%p1%dm\");\n         assert_eq!(expand(s, [Number(1)], &mut Variables::new()).unwrap(),\n-                   bytes!(\"\\\\E[48;5;1m\").to_owned());\n+                   bytes!(\"\\\\E[48;5;1m\").iter().map(|x| *x).collect());\n     }\n \n     #[test]\n     fn test_multiple_int_constants() {\n         assert_eq!(expand(bytes!(\"%{1}%{2}%d%d\"), [], &mut Variables::new()).unwrap(),\n-                   bytes!(\"21\").to_owned());\n+                   bytes!(\"21\").iter().map(|x| *x).collect());\n     }\n \n     #[test]\n     fn test_op_i() {\n         let mut vars = Variables::new();\n         assert_eq!(expand(bytes!(\"%p1%d%p2%d%p3%d%i%p1%d%p2%d%p3%d\"),\n                           [Number(1),Number(2),Number(3)], &mut vars),\n-                   Ok(bytes!(\"123233\").to_owned()));\n+                   Ok(bytes!(\"123233\").iter().map(|x| *x).collect()));\n         assert_eq!(expand(bytes!(\"%p1%d%p2%d%i%p1%d%p2%d\"), [], &mut vars),\n-                   Ok(bytes!(\"0011\").to_owned()));\n+                   Ok(bytes!(\"0011\").iter().map(|x| *x).collect()));\n     }\n \n     #[test]\n@@ -590,7 +598,12 @@ mod test {\n             assert!(res.is_err(),\n                     \"Op {} succeeded incorrectly with 0 stack entries\", *cap);\n             let p = if *cap == \"%s\" || *cap == \"%l\" { String(~\"foo\") } else { Number(97) };\n-            let res = expand((bytes!(\"%p1\")).to_owned() + cap.as_bytes(), [p], vars);\n+            let res = expand(vec::append(bytes!(\"%p1\").iter()\n+                                                         .map(|x| *x)\n+                                                         .collect(),\n+                                            cap.as_bytes()).as_slice(),\n+                             [p],\n+                             vars);\n             assert!(res.is_ok(),\n                     \"Op {} failed with 1 stack entry: {}\", *cap, res.unwrap_err());\n         }\n@@ -599,10 +612,20 @@ mod test {\n             let res = expand(cap.as_bytes(), [], vars);\n             assert!(res.is_err(),\n                     \"Binop {} succeeded incorrectly with 0 stack entries\", *cap);\n-            let res = expand((bytes!(\"%{1}\")).to_owned() + cap.as_bytes(), [], vars);\n+            let res = expand(vec::append(bytes!(\"%{1}\").iter()\n+                                                          .map(|x| *x)\n+                                                          .collect(),\n+                                             cap.as_bytes()).as_slice(),\n+                              [],\n+                              vars);\n             assert!(res.is_err(),\n                     \"Binop {} succeeded incorrectly with 1 stack entry\", *cap);\n-            let res = expand((bytes!(\"%{1}%{2}\")).to_owned() + cap.as_bytes(), [], vars);\n+            let res = expand(vec::append(bytes!(\"%{1}%{2}\").iter()\n+                                                              .map(|x| *x)\n+                                                              .collect(),\n+                                            cap.as_bytes()).as_slice(),\n+                             [],\n+                             vars);\n             assert!(res.is_ok(),\n                     \"Binop {} failed with 2 stack entries: {}\", *cap, res.unwrap_err());\n         }\n@@ -620,15 +643,15 @@ mod test {\n             let s = format!(\"%\\\\{1\\\\}%\\\\{2\\\\}%{}%d\", op);\n             let res = expand(s.as_bytes(), [], &mut Variables::new());\n             assert!(res.is_ok(), res.unwrap_err());\n-            assert_eq!(res.unwrap(), ~['0' as u8 + bs[0]]);\n+            assert_eq!(res.unwrap(), vec!('0' as u8 + bs[0]));\n             let s = format!(\"%\\\\{1\\\\}%\\\\{1\\\\}%{}%d\", op);\n             let res = expand(s.as_bytes(), [], &mut Variables::new());\n             assert!(res.is_ok(), res.unwrap_err());\n-            assert_eq!(res.unwrap(), ~['0' as u8 + bs[1]]);\n+            assert_eq!(res.unwrap(), vec!('0' as u8 + bs[1]));\n             let s = format!(\"%\\\\{2\\\\}%\\\\{1\\\\}%{}%d\", op);\n             let res = expand(s.as_bytes(), [], &mut Variables::new());\n             assert!(res.is_ok(), res.unwrap_err());\n-            assert_eq!(res.unwrap(), ~['0' as u8 + bs[2]]);\n+            assert_eq!(res.unwrap(), vec!('0' as u8 + bs[2]));\n         }\n     }\n \n@@ -638,13 +661,16 @@ mod test {\n         let s = bytes!(\"\\\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m\");\n         let res = expand(s, [Number(1)], &mut vars);\n         assert!(res.is_ok(), res.unwrap_err());\n-        assert_eq!(res.unwrap(), bytes!(\"\\\\E[31m\").to_owned());\n+        assert_eq!(res.unwrap(),\n+                   bytes!(\"\\\\E[31m\").iter().map(|x| *x).collect());\n         let res = expand(s, [Number(8)], &mut vars);\n         assert!(res.is_ok(), res.unwrap_err());\n-        assert_eq!(res.unwrap(), bytes!(\"\\\\E[90m\").to_owned());\n+        assert_eq!(res.unwrap(),\n+                   bytes!(\"\\\\E[90m\").iter().map(|x| *x).collect());\n         let res = expand(s, [Number(42)], &mut vars);\n         assert!(res.is_ok(), res.unwrap_err());\n-        assert_eq!(res.unwrap(), bytes!(\"\\\\E[38;5;42m\").to_owned());\n+        assert_eq!(res.unwrap(),\n+                   bytes!(\"\\\\E[38;5;42m\").iter().map(|x| *x).collect());\n     }\n \n     #[test]\n@@ -653,13 +679,15 @@ mod test {\n         let vars = &mut varstruct;\n         assert_eq!(expand(bytes!(\"%p1%s%p2%2s%p3%2s%p4%.2s\"),\n                           [String(~\"foo\"), String(~\"foo\"), String(~\"f\"), String(~\"foo\")], vars),\n-                   Ok(bytes!(\"foofoo ffo\").to_owned()));\n+                   Ok(bytes!(\"foofoo ffo\").iter().map(|x| *x).collect()));\n         assert_eq!(expand(bytes!(\"%p1%:-4.2s\"), [String(~\"foo\")], vars),\n-                   Ok(bytes!(\"fo  \").to_owned()));\n+                   Ok(bytes!(\"fo  \").iter().map(|x| *x).collect()));\n \n         assert_eq!(expand(bytes!(\"%p1%d%p1%.3d%p1%5d%p1%:+d\"), [Number(1)], vars),\n-                   Ok(bytes!(\"1001    1+1\").to_owned()));\n+                   Ok(bytes!(\"1001    1+1\").iter().map(|x| *x).collect()));\n         assert_eq!(expand(bytes!(\"%p1%o%p1%#o%p2%6.4x%p2%#6.4X\"), [Number(15), Number(27)], vars),\n-                   Ok(bytes!(\"17017  001b0X001B\").to_owned()));\n+                   Ok(bytes!(\"17017  001b0X001B\").iter()\n+                                                 .map(|x| *x)\n+                                                 .collect()));\n     }\n }"}, {"sha": "e6a1dc70b7050558377ad02643da186773b3ad04", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -12,10 +12,9 @@\n \n /// ncurses-compatible compiled terminfo format parsing (term(5))\n \n-\n-use std::{slice, str};\n-use std::io;\n use collections::HashMap;\n+use std::io;\n+use std::str;\n use super::super::TermInfo;\n \n // These are the orders ncurses uses in its compiled format (as of 5.9). Not sure if portable.\n@@ -213,7 +212,7 @@ pub fn parse(file: &mut io::Reader,\n         Some(s) => s, None => return Err(~\"input not utf-8\"),\n     };\n \n-    let term_names: ~[~str] = names_str.split('|').map(|s| s.to_owned()).collect();\n+    let term_names: Vec<~str> = names_str.split('|').map(|s| s.to_owned()).collect();\n \n     try!(file.read_byte()); // consume NUL\n \n@@ -246,7 +245,7 @@ pub fn parse(file: &mut io::Reader,\n     let mut string_map = HashMap::new();\n \n     if string_offsets_count != 0 {\n-        let mut string_offsets = slice::with_capacity(10);\n+        let mut string_offsets = Vec::with_capacity(10);\n         for _ in range(0, string_offsets_count) {\n             string_offsets.push(try!(file.read_le_u16()));\n         }\n@@ -272,7 +271,7 @@ pub fn parse(file: &mut io::Reader,\n             if offset == 0xFFFE {\n                 // undocumented: FFFE indicates cap@, which means the capability is not present\n                 // unsure if the handling for this is correct\n-                string_map.insert(name.to_owned(), ~[]);\n+                string_map.insert(name.to_owned(), Vec::new());\n                 continue;\n             }\n \n@@ -283,8 +282,9 @@ pub fn parse(file: &mut io::Reader,\n             match nulpos {\n                 Some(len) => {\n                     string_map.insert(name.to_owned(),\n-                                      string_table.slice(offset as uint,\n-                                                         offset as uint + len).to_owned())\n+                                      Vec::from_slice(\n+                                          string_table.slice(offset as uint,\n+                                          offset as uint + len)))\n                 },\n                 None => {\n                     return Err(~\"invalid file: missing NUL in string_table\");\n@@ -300,12 +300,12 @@ pub fn parse(file: &mut io::Reader,\n /// Create a dummy TermInfo struct for msys terminals\n pub fn msys_terminfo() -> ~TermInfo {\n     let mut strings = HashMap::new();\n-    strings.insert(~\"sgr0\", bytes!(\"\\x1b[0m\").to_owned());\n-    strings.insert(~\"bold\", bytes!(\"\\x1b[1m\").to_owned());\n-    strings.insert(~\"setaf\", bytes!(\"\\x1b[3%p1%dm\").to_owned());\n-    strings.insert(~\"setab\", bytes!(\"\\x1b[4%p1%dm\").to_owned());\n+    strings.insert(~\"sgr0\", Vec::from_slice(bytes!(\"\\x1b[0m\")));\n+    strings.insert(~\"bold\", Vec::from_slice(bytes!(\"\\x1b[1m\")));\n+    strings.insert(~\"setaf\", Vec::from_slice(bytes!(\"\\x1b[3%p1%dm\")));\n+    strings.insert(~\"setab\", Vec::from_slice(bytes!(\"\\x1b[4%p1%dm\")));\n     ~TermInfo {\n-        names: ~[~\"cygwin\"], // msys is a fork of an older cygwin version\n+        names: vec!(~\"cygwin\"), // msys is a fork of an older cygwin version\n         bools: HashMap::new(),\n         numbers: HashMap::new(),\n         strings: strings"}, {"sha": "b29d7b2284e3334d1bd8a5b461c3f939c2929ca7", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -23,7 +23,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~Path> {\n \n     let homedir = os::homedir();\n \n-    let mut dirs_to_search = ~[];\n+    let mut dirs_to_search = Vec::new();\n     let first_char = term.char_at(0);\n \n     // Find search directory"}, {"sha": "27f9a2174ced37b068b24df774f955e021fd5474", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 47, "deletions": 46, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -203,7 +203,7 @@ pub type MetricDiff = TreeMap<~str,MetricChange>;\n \n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs.\n-pub fn test_main(args: &[~str], tests: ~[TestDescAndFn]) {\n+pub fn test_main(args: &[~str], tests: Vec<TestDescAndFn> ) {\n     let opts =\n         match parse_opts(args) {\n             Some(Ok(o)) => o,\n@@ -225,7 +225,7 @@ pub fn test_main(args: &[~str], tests: ~[TestDescAndFn]) {\n // semantics into parallel test runners, which in turn requires a ~[]\n // rather than a &[].\n pub fn test_main_static(args: &[~str], tests: &[TestDescAndFn]) {\n-    let owned_tests = tests.map(|t| {\n+    let owned_tests = tests.iter().map(|t| {\n         match t.testfn {\n             StaticTestFn(f) =>\n             TestDescAndFn { testfn: StaticTestFn(f), desc: t.desc.clone() },\n@@ -237,7 +237,7 @@ pub fn test_main_static(args: &[~str], tests: &[TestDescAndFn]) {\n                 fail!(\"non-static tests passed to test::test_main_static\");\n             }\n         }\n-    });\n+    }).collect();\n     test_main(args, owned_tests)\n }\n \n@@ -256,8 +256,8 @@ pub struct TestOpts {\n /// Result of parsing the options.\n pub type OptRes = Result<TestOpts, ~str>;\n \n-fn optgroups() -> ~[getopts::OptGroup] {\n-    ~[getopts::optflag(\"\", \"ignored\", \"Run ignored tests\"),\n+fn optgroups() -> Vec<getopts::OptGroup> {\n+    vec!(getopts::optflag(\"\", \"ignored\", \"Run ignored tests\"),\n       getopts::optflag(\"\", \"test\", \"Run tests and not benchmarks\"),\n       getopts::optflag(\"\", \"bench\", \"Run benchmarks instead of tests\"),\n       getopts::optflag(\"h\", \"help\", \"Display this message (longer with --help)\"),\n@@ -273,12 +273,12 @@ fn optgroups() -> ~[getopts::OptGroup] {\n       getopts::optopt(\"\", \"logfile\", \"Write logs to the specified file instead \\\n                           of stdout\", \"PATH\"),\n       getopts::optopt(\"\", \"test-shard\", \"run shard A, of B shards, worth of the testsuite\",\n-                     \"A.B\")]\n+                     \"A.B\"))\n }\n \n fn usage(binary: &str, helpstr: &str) {\n     let message = format!(\"Usage: {} [OPTIONS] [FILTER]\", binary);\n-    println!(\"{}\", getopts::usage(message, optgroups()));\n+    println!(\"{}\", getopts::usage(message, optgroups().as_slice()));\n     println!(\"\");\n     if helpstr == \"help\" {\n         println!(\"{}\", \"\\\n@@ -308,7 +308,7 @@ Test Attributes:\n pub fn parse_opts(args: &[~str]) -> Option<OptRes> {\n     let args_ = args.tail();\n     let matches =\n-        match getopts::getopts(args_, optgroups()) {\n+        match getopts::getopts(args_, optgroups().as_slice()) {\n           Ok(m) => m,\n           Err(f) => return Some(Err(f.to_err_msg()))\n         };\n@@ -318,7 +318,7 @@ pub fn parse_opts(args: &[~str]) -> Option<OptRes> {\n \n     let filter =\n         if matches.free.len() > 0 {\n-            Some((matches).free[0].clone())\n+            Some((*matches.free.get(0)).clone())\n         } else {\n             None\n         };\n@@ -408,7 +408,7 @@ struct ConsoleTestState<T> {\n     ignored: uint,\n     measured: uint,\n     metrics: MetricMap,\n-    failures: ~[(TestDesc, ~[u8])],\n+    failures: Vec<(TestDesc, Vec<u8> )> ,\n     max_name_len: uint, // number of columns to fill when aligning names\n }\n \n@@ -433,7 +433,7 @@ impl<T: Writer> ConsoleTestState<T> {\n             ignored: 0u,\n             measured: 0u,\n             metrics: MetricMap::new(),\n-            failures: ~[],\n+            failures: Vec::new(),\n             max_name_len: 0u,\n         })\n     }\n@@ -547,14 +547,14 @@ impl<T: Writer> ConsoleTestState<T> {\n \n     pub fn write_failures(&mut self) -> io::IoResult<()> {\n         try!(self.write_plain(\"\\nfailures:\\n\"));\n-        let mut failures = ~[];\n+        let mut failures = Vec::new();\n         let mut fail_out  = ~\"\";\n         for &(ref f, ref stdout) in self.failures.iter() {\n             failures.push(f.name.to_str());\n             if stdout.len() > 0 {\n                 fail_out.push_str(format!(\"---- {} stdout ----\\n\\t\",\n                                   f.name.to_str()));\n-                let output = str::from_utf8_lossy(*stdout);\n+                let output = str::from_utf8_lossy(stdout.as_slice());\n                 fail_out.push_str(output.as_slice().replace(\"\\n\", \"\\n\\t\"));\n                 fail_out.push_str(\"\\n\");\n             }\n@@ -565,7 +565,7 @@ impl<T: Writer> ConsoleTestState<T> {\n         }\n \n         try!(self.write_plain(\"\\nfailures:\\n\"));\n-        failures.sort();\n+        failures.as_mut_slice().sort();\n         for name in failures.iter() {\n             try!(self.write_plain(format!(\"    {}\\n\", name.to_str())));\n         }\n@@ -665,7 +665,7 @@ impl<T: Writer> ConsoleTestState<T> {\n \n pub fn fmt_metrics(mm: &MetricMap) -> ~str {\n     let MetricMap(ref mm) = *mm;\n-    let v : ~[~str] = mm.iter()\n+    let v : Vec<~str> = mm.iter()\n         .map(|(k,v)| format!(\"{}: {} (+/- {})\",\n                           *k,\n                           v.value as f64,\n@@ -689,7 +689,7 @@ pub fn fmt_bench_samples(bs: &BenchSamples) -> ~str {\n \n // A simple console test runner\n pub fn run_tests_console(opts: &TestOpts,\n-                         tests: ~[TestDescAndFn]) -> io::IoResult<bool> {\n+                         tests: Vec<TestDescAndFn> ) -> io::IoResult<bool> {\n     fn callback<T: Writer>(event: &TestEvent,\n                            st: &mut ConsoleTestState<T>) -> io::IoResult<()> {\n         match (*event).clone() {\n@@ -779,7 +779,7 @@ fn should_sort_failures_before_printing_them() {\n         measured: 0u,\n         max_name_len: 10u,\n         metrics: MetricMap::new(),\n-        failures: ~[(test_b, ~[]), (test_a, ~[])]\n+        failures: vec!((test_b, Vec::new()), (test_a, Vec::new()))\n     };\n \n     st.write_failures().unwrap();\n@@ -797,18 +797,20 @@ fn use_color() -> bool { return get_concurrency() == 1; }\n \n #[deriving(Clone)]\n enum TestEvent {\n-    TeFiltered(~[TestDesc]),\n+    TeFiltered(Vec<TestDesc> ),\n     TeWait(TestDesc, NamePadding),\n-    TeResult(TestDesc, TestResult, ~[u8] /* stdout */),\n+    TeResult(TestDesc, TestResult, Vec<u8> ),\n }\n \n-pub type MonitorMsg = (TestDesc, TestResult, ~[u8] /* stdout */);\n+pub type MonitorMsg = (TestDesc, TestResult, Vec<u8> );\n \n fn run_tests(opts: &TestOpts,\n-             tests: ~[TestDescAndFn],\n+             tests: Vec<TestDescAndFn> ,\n              callback: |e: TestEvent| -> io::IoResult<()>) -> io::IoResult<()> {\n     let filtered_tests = filter_tests(opts, tests);\n-    let filtered_descs = filtered_tests.map(|t| t.desc.clone());\n+    let filtered_descs = filtered_tests.iter()\n+                                       .map(|t| t.desc.clone())\n+                                       .collect();\n \n     try!(callback(TeFiltered(filtered_descs)));\n \n@@ -880,8 +882,7 @@ fn get_concurrency() -> uint {\n \n pub fn filter_tests(\n     opts: &TestOpts,\n-    tests: ~[TestDescAndFn]) -> ~[TestDescAndFn]\n-{\n+    tests: Vec<TestDescAndFn> ) -> Vec<TestDescAndFn> {\n     let mut filtered = tests;\n \n     // Remove tests that don't match the test filter\n@@ -929,11 +930,12 @@ pub fn filter_tests(\n     // Shard the remaining tests, if sharding requested.\n     match opts.test_shard {\n         None => filtered,\n-        Some((a,b)) =>\n+        Some((a,b)) => {\n             filtered.move_iter().enumerate()\n             .filter(|&(i,_)| i % b == a)\n             .map(|(_,t)| t)\n-            .to_owned_vec()\n+            .collect()\n+        }\n     }\n }\n \n@@ -944,7 +946,7 @@ pub fn run_test(force_ignore: bool,\n     let TestDescAndFn {desc, testfn} = test;\n \n     if force_ignore || desc.ignore {\n-        monitor_ch.send((desc, TrIgnored, ~[]));\n+        monitor_ch.send((desc, TrIgnored, Vec::new()));\n         return;\n     }\n \n@@ -965,7 +967,7 @@ pub fn run_test(force_ignore: bool,\n             let result_future = task.future_result();\n             task.spawn(testfn);\n \n-            let stdout = reader.read_to_end().unwrap();\n+            let stdout = reader.read_to_end().unwrap().move_iter().collect();\n             let task_result = result_future.recv();\n             let test_result = calc_result(&desc, task_result.is_ok());\n             monitor_ch.send((desc.clone(), test_result, stdout));\n@@ -975,24 +977,24 @@ pub fn run_test(force_ignore: bool,\n     match testfn {\n         DynBenchFn(bencher) => {\n             let bs = ::bench::benchmark(|harness| bencher.run(harness));\n-            monitor_ch.send((desc, TrBench(bs), ~[]));\n+            monitor_ch.send((desc, TrBench(bs), Vec::new()));\n             return;\n         }\n         StaticBenchFn(benchfn) => {\n             let bs = ::bench::benchmark(|harness| benchfn(harness));\n-            monitor_ch.send((desc, TrBench(bs), ~[]));\n+            monitor_ch.send((desc, TrBench(bs), Vec::new()));\n             return;\n         }\n         DynMetricFn(f) => {\n             let mut mm = MetricMap::new();\n             f(&mut mm);\n-            monitor_ch.send((desc, TrMetrics(mm), ~[]));\n+            monitor_ch.send((desc, TrMetrics(mm), Vec::new()));\n             return;\n         }\n         StaticMetricFn(f) => {\n             let mut mm = MetricMap::new();\n             f(&mut mm);\n-            monitor_ch.send((desc, TrMetrics(mm), ~[]));\n+            monitor_ch.send((desc, TrMetrics(mm), Vec::new()));\n             return;\n         }\n         DynTestFn(f) => run_test_inner(desc, monitor_ch, f),\n@@ -1369,8 +1371,8 @@ mod tests {\n \n     #[test]\n     fn first_free_arg_should_be_a_filter() {\n-        let args = ~[~\"progname\", ~\"filter\"];\n-        let opts = match parse_opts(args) {\n+        let args = vec!(~\"progname\", ~\"filter\");\n+        let opts = match parse_opts(args.as_slice()) {\n             Some(Ok(o)) => o,\n             _ => fail!(\"Malformed arg in first_free_arg_should_be_a_filter\")\n         };\n@@ -1379,8 +1381,8 @@ mod tests {\n \n     #[test]\n     fn parse_ignored_flag() {\n-        let args = ~[~\"progname\", ~\"filter\", ~\"--ignored\"];\n-        let opts = match parse_opts(args) {\n+        let args = vec!(~\"progname\", ~\"filter\", ~\"--ignored\");\n+        let opts = match parse_opts(args.as_slice()) {\n             Some(Ok(o)) => o,\n             _ => fail!(\"Malformed arg in parse_ignored_flag\")\n         };\n@@ -1404,7 +1406,7 @@ mod tests {\n             test_shard: None\n         };\n \n-        let tests = ~[\n+        let tests = vec!(\n             TestDescAndFn {\n                 desc: TestDesc {\n                     name: StaticTestName(\"1\"),\n@@ -1420,13 +1422,12 @@ mod tests {\n                     should_fail: false\n                 },\n                 testfn: DynTestFn(proc() {}),\n-            },\n-        ];\n+            });\n         let filtered = filter_tests(&opts, tests);\n \n         assert_eq!(filtered.len(), 1);\n-        assert_eq!(filtered[0].desc.name.to_str(), ~\"1\");\n-        assert!(filtered[0].desc.ignore == false);\n+        assert_eq!(filtered.get(0).desc.name.to_str(), ~\"1\");\n+        assert!(filtered.get(0).desc.ignore == false);\n     }\n \n     #[test]\n@@ -1444,16 +1445,16 @@ mod tests {\n         };\n \n         let names =\n-            ~[~\"sha1::test\", ~\"int::test_to_str\", ~\"int::test_pow\",\n+            vec!(~\"sha1::test\", ~\"int::test_to_str\", ~\"int::test_pow\",\n              ~\"test::do_not_run_ignored_tests\",\n              ~\"test::ignored_tests_result_in_ignored\",\n              ~\"test::first_free_arg_should_be_a_filter\",\n              ~\"test::parse_ignored_flag\", ~\"test::filter_for_ignored_option\",\n-             ~\"test::sort_tests\"];\n+             ~\"test::sort_tests\");\n         let tests =\n         {\n             fn testfn() { }\n-            let mut tests = ~[];\n+            let mut tests = Vec::new();\n             for name in names.iter() {\n                 let test = TestDescAndFn {\n                     desc: TestDesc {\n@@ -1470,13 +1471,13 @@ mod tests {\n         let filtered = filter_tests(&opts, tests);\n \n         let expected =\n-            ~[~\"int::test_pow\", ~\"int::test_to_str\", ~\"sha1::test\",\n+            vec!(~\"int::test_pow\", ~\"int::test_to_str\", ~\"sha1::test\",\n               ~\"test::do_not_run_ignored_tests\",\n               ~\"test::filter_for_ignored_option\",\n               ~\"test::first_free_arg_should_be_a_filter\",\n               ~\"test::ignored_tests_result_in_ignored\",\n               ~\"test::parse_ignored_flag\",\n-              ~\"test::sort_tests\"];\n+              ~\"test::sort_tests\");\n \n         for (a, b) in expected.iter().zip(filtered.iter()) {\n             assert!(*a == b.desc.name.to_str());"}, {"sha": "1cc2d4b8a711157fc014b45c62d6b56f29f2c999", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -1044,7 +1044,7 @@ pub fn strftime(format: &str, tm: &Tm) -> ~str {\n         }\n     }\n \n-    let mut buf = ~[];\n+    let mut buf = Vec::new();\n \n     let mut rdr = BufReader::new(format.as_bytes());\n     loop {\n@@ -1063,7 +1063,7 @@ pub fn strftime(format: &str, tm: &Tm) -> ~str {\n         }\n     }\n \n-    str::from_utf8_owned(buf).unwrap()\n+    str::from_utf8(buf.as_slice()).unwrap().to_str()\n }\n \n #[cfg(test)]"}, {"sha": "75b5a8ffed637f9d643d04df4234000127ba91c5", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -327,13 +327,13 @@ impl Uuid {\n     ///\n     /// Example: `936DA01F9ABD4d9d80C702AF85C822A8`\n     pub fn to_simple_str(&self) -> ~str {\n-        let mut s: ~[u8] = slice::from_elem(32, 0u8);\n+        let mut s: Vec<u8> = Vec::from_elem(32, 0u8);\n         for i in range(0u, 16u) {\n             let digit = format!(\"{:02x}\", self.bytes[i] as uint);\n-            s[i*2+0] = digit[0];\n-            s[i*2+1] = digit[1];\n+            *s.get_mut(i*2+0) = digit[0];\n+            *s.get_mut(i*2+1) = digit[1];\n         }\n-        str::from_utf8_owned(s).unwrap()\n+        str::from_utf8(s.as_slice()).unwrap().to_str()\n     }\n \n     /// Returns a string of hexadecimal digits, separated into groups with a hyphen.\n@@ -397,17 +397,17 @@ impl Uuid {\n         }\n \n         // Split string up by hyphens into groups\n-        let hex_groups: ~[&str] = us.split_str(\"-\").collect();\n+        let hex_groups: Vec<&str> = us.split_str(\"-\").collect();\n \n         // Get the length of each group\n-        let group_lens: ~[uint] = hex_groups.iter().map(|&v| v.len()).collect();\n+        let group_lens: Vec<uint> = hex_groups.iter().map(|&v| v.len()).collect();\n \n         // Ensure the group lengths are valid\n         match group_lens.len() {\n             // Single group, no hyphens\n             1 => {\n-                if group_lens[0] != 32 {\n-                    return Err(ErrorInvalidLength(group_lens[0]));\n+                if *group_lens.get(0) != 32 {\n+                    return Err(ErrorInvalidLength(*group_lens.get(0)));\n                 }\n             },\n             // Five groups, hyphens in between each\n@@ -538,6 +538,7 @@ mod test {\n                 Version5Sha1};\n     use std::str;\n     use std::io::MemWriter;\n+    use std::vec_ng::Vec;\n \n     #[test]\n     fn test_nil() {\n@@ -697,7 +698,10 @@ mod test {\n         let hs = uuid1.to_hyphenated_str();\n         let ss = uuid1.to_str();\n \n-        let hsn = str::from_chars(hs.chars().filter(|&c| c != '-').collect::<~[char]>());\n+        let hsn = str::from_chars(hs.chars()\n+                                    .filter(|&c| c != '-')\n+                                    .collect::<Vec<char>>()\n+                                    .as_slice());\n \n         assert!(hsn == ss);\n     }\n@@ -731,9 +735,9 @@ mod test {\n         let d1: u32 = 0xa1a2a3a4;\n         let d2: u16 = 0xb1b2;\n         let d3: u16 = 0xc1c2;\n-        let d4: ~[u8] = ~[0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8];\n+        let d4: Vec<u8> = vec!(0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8);\n \n-        let u = Uuid::from_fields(d1, d2, d3, d4);\n+        let u = Uuid::from_fields(d1, d2, d3, d4.as_slice());\n \n         let expected = ~\"a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8\";\n         let result = u.to_simple_str();\n@@ -742,10 +746,10 @@ mod test {\n \n     #[test]\n     fn test_from_bytes() {\n-        let b = ~[ 0xa1, 0xa2, 0xa3, 0xa4, 0xb1, 0xb2, 0xc1, 0xc2,\n-                   0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8 ];\n+        let b = vec!( 0xa1, 0xa2, 0xa3, 0xa4, 0xb1, 0xb2, 0xc1, 0xc2,\n+                   0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8 );\n \n-        let u = Uuid::from_bytes(b).unwrap();\n+        let u = Uuid::from_bytes(b.as_slice()).unwrap();\n         let expected = ~\"a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8\";\n \n         assert!(u.to_simple_str() == expected);"}, {"sha": "8258a668f46ef4c10eda750b50a105c16428e0c6", "filename": "src/test/auxiliary/cci_class_6.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n pub mod kitties {\n+    use std::vec_ng::Vec;\n+\n     pub struct cat<U> {\n         priv info : Vec<U> ,\n         priv meows : uint,"}, {"sha": "8386a6f78c133d22276faee5aaf25f6875aacd5c", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -11,6 +11,7 @@\n #[feature(managed_boxes)];\n \n use std::cell::RefCell;\n+use std::vec_ng::Vec;\n \n pub struct Entry<A,B> {\n     key: A,"}, {"sha": "191313263aa9b71ba9012793f366c4baebf27737", "filename": "src/test/auxiliary/cci_no_inline_lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,12 +10,14 @@\n \n #[crate_id=\"cci_no_inline_lib\"];\n \n+use std::vec_ng::Vec;\n+\n // same as cci_iter_lib, more-or-less, but not marked inline\n pub fn iter(v: Vec<uint> , f: |uint|) {\n     let mut i = 0u;\n     let n = v.len();\n     while i < n {\n-        f(v[i]);\n+        f(*v.get(i));\n         i += 1u;\n     }\n }"}, {"sha": "6bea93e953beb75b947766269da6d213c7893f9f", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -15,11 +15,12 @@\n extern crate collections;\n \n use std::cell::RefCell;\n+use std::vec_ng::Vec;\n use collections::HashMap;\n \n-pub type header_map = HashMap<~str, @RefCell<vec!(@~str)>>;\n+pub type header_map = HashMap<~str, @RefCell<Vec<@~str>>>;\n \n // the unused ty param is necessary so this gets monomorphized\n pub fn request<T>(req: &header_map) {\n-  let _x = (*((**req.get(&~\"METHOD\")).clone()).get()[0u]).clone();\n+  let _x = (**((**req.get(&~\"METHOD\")).clone()).get().get(0)).clone();\n }"}, {"sha": "57acf3a7a9141df2847f4bc998d067a2597b280b", "filename": "src/test/auxiliary/issue_2723_a.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fauxiliary%2Fissue_2723_a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fauxiliary%2Fissue_2723_a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2723_a.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n pub unsafe fn f(xs: Vec<int> ) {\n     xs.map(|_x| { unsafe fn q() { fail!(); } });\n }"}, {"sha": "d0655a43d158984afa05d96852cc27d34066d0e8", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -20,7 +20,6 @@ use rand::Rng;\n use std::mem::swap;\n use std::os;\n use std::str;\n-use std::slice;\n use std::vec;\n use std::io::File;\n \n@@ -89,11 +88,11 @@ fn vec_plus() {\n     let mut v = Vec::new();\n     let mut i = 0;\n     while i < 1500 {\n-        let rv = slice::from_elem(r.gen_range(0u, i + 1), i);\n+        let rv = Vec::from_elem(r.gen_range(0u, i + 1), i);\n         if r.gen() {\n             v.push_all_move(rv);\n         } else {\n-            v = rv + v;\n+            v = vec::append(rv.clone(), v.as_slice());\n         }\n         i += 1;\n     }\n@@ -105,12 +104,12 @@ fn vec_append() {\n     let mut v = Vec::new();\n     let mut i = 0;\n     while i < 1500 {\n-        let rv = slice::from_elem(r.gen_range(0u, i + 1), i);\n+        let rv = Vec::from_elem(r.gen_range(0u, i + 1), i);\n         if r.gen() {\n-            v = vec::append(v, rv);\n+            v = vec::append(v.clone(), rv.as_slice());\n         }\n         else {\n-            v = vec::append(rv, v);\n+            v = vec::append(rv.clone(), v.as_slice());\n         }\n         i += 1;\n     }\n@@ -121,13 +120,13 @@ fn vec_push_all() {\n \n     let mut v = Vec::new();\n     for i in range(0u, 1500) {\n-        let mut rv = slice::from_elem(r.gen_range(0u, i + 1), i);\n+        let mut rv = Vec::from_elem(r.gen_range(0u, i + 1), i);\n         if r.gen() {\n-            v.push_all(rv);\n+            v.push_all(rv.as_slice());\n         }\n         else {\n             swap(&mut v, &mut rv);\n-            v.push_all(rv);\n+            v.push_all(rv.as_slice());\n         }\n     }\n }\n@@ -136,7 +135,7 @@ fn is_utf8_ascii() {\n     let mut v : Vec<u8> = Vec::new();\n     for _ in range(0u, 20000) {\n         v.push('b' as u8);\n-        if !str::is_utf8(v) {\n+        if !str::is_utf8(v.as_slice()) {\n             fail!(\"is_utf8 failed\");\n         }\n     }\n@@ -147,7 +146,7 @@ fn is_utf8_multibyte() {\n     let mut v : Vec<u8> = Vec::new();\n     for _ in range(0u, 5000) {\n         v.push_all(s.as_bytes());\n-        if !str::is_utf8(v) {\n+        if !str::is_utf8(v.as_slice()) {\n             fail!(\"is_utf8 failed\");\n         }\n     }"}, {"sha": "f556617228732334146ca02b353e4125607584cd", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,6 +10,7 @@\n \n use std::os;\n use std::uint;\n+use std::vec_ng::Vec;\n \n fn main() {\n     let args = os::args();\n@@ -18,10 +19,10 @@ fn main() {\n     } else if args.len() <= 1u {\n         vec!(~\"\", ~\"100000\")\n     } else {\n-        args\n+        args.move_iter().collect()\n     };\n \n-    let n = from_str::<uint>(args[1]).unwrap();\n+    let n = from_str::<uint>(*args.get(1)).unwrap();\n \n     for i in range(0u, n) {\n         let x = i.to_str();"}, {"sha": "ff7ef27e1b993df207f7fa70f829c26885d4fdf9", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -24,6 +24,7 @@ use std::comm;\n use std::os;\n use std::task;\n use std::uint;\n+use std::vec_ng::Vec;\n \n fn move_out<T>(_x: T) {}\n \n@@ -100,9 +101,9 @@ fn main() {\n     } else if args.len() <= 1u {\n         vec!(~\"\", ~\"10000\", ~\"4\")\n     } else {\n-        args.clone()\n+        args.clone().move_iter().collect()\n     };\n \n     println!(\"{:?}\", args);\n-    run(args);\n+    run(args.as_slice());\n }"}, {"sha": "0f0cb9c59d53f40c6d54a82cfa65c1ce54b385a0", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -19,6 +19,7 @@ extern crate time;\n use std::os;\n use std::task;\n use std::uint;\n+use std::vec_ng::Vec;\n \n fn move_out<T>(_x: T) {}\n \n@@ -110,9 +111,9 @@ fn main() {\n     } else if args.len() <= 1u {\n         vec!(~\"\", ~\"10000\", ~\"4\")\n     } else {\n-        args.clone()\n+        args.clone().move_iter().collect()\n     };\n \n     println!(\"{:?}\", args);\n-    run(args);\n+    run(args.as_slice());\n }"}, {"sha": "a0758624042423da03a0b3959c2da2770f08f5e5", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -23,6 +23,7 @@ use sync::MutexArc;\n use sync::Future;\n use std::os;\n use std::uint;\n+use std::vec_ng::Vec;\n \n // A poor man's pipe.\n type pipe = MutexArc<Vec<uint> >;\n@@ -75,11 +76,11 @@ fn main() {\n     } else if args.len() <= 1u {\n         vec!(~\"\", ~\"10\", ~\"100\")\n     } else {\n-        args.clone()\n+        args.clone().move_iter().collect()\n     };\n \n-    let num_tasks = from_str::<uint>(args[1]).unwrap();\n-    let msg_per_task = from_str::<uint>(args[2]).unwrap();\n+    let num_tasks = from_str::<uint>(*args.get(1)).unwrap();\n+    let msg_per_task = from_str::<uint>(*args.get(2)).unwrap();\n \n     let (mut num_chan, num_port) = init();\n "}, {"sha": "de5dff89bada7fe77666e84d6564ecda68b662fe", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -22,6 +22,7 @@ use sync::RWArc;\n use sync::Future;\n use std::os;\n use std::uint;\n+use std::vec_ng::Vec;\n \n // A poor man's pipe.\n type pipe = RWArc<Vec<uint> >;\n@@ -70,11 +71,11 @@ fn main() {\n     } else if args.len() <= 1u {\n         vec!(~\"\", ~\"10\", ~\"100\")\n     } else {\n-        args.clone()\n+        args.clone().move_iter().collect()\n     };\n \n-    let num_tasks = from_str::<uint>(args[1]).unwrap();\n-    let msg_per_task = from_str::<uint>(args[2]).unwrap();\n+    let num_tasks = from_str::<uint>(*args.get(1)).unwrap();\n+    let msg_per_task = from_str::<uint>(*args.get(2)).unwrap();\n \n     let (mut num_chan, num_port) = init();\n "}, {"sha": "72df2e7b86f09fa6eb1120ae244313175dbc6649", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::os;\n+use std::vec_ng::Vec;\n \n fn ack(m: int, n: int) -> int {\n     if m == 0 {\n@@ -29,8 +30,8 @@ fn main() {\n     } else if args.len() <= 1u {\n         vec!(~\"\", ~\"8\")\n     } else {\n-        args\n+        args.move_iter().collect()\n     };\n-    let n = from_str::<int>(args[1]).unwrap();\n+    let n = from_str::<int>(*args.get(1)).unwrap();\n     println!(\"Ack(3,{}): {}\\n\", n, ack(3, n));\n }"}, {"sha": "29513d87153f74dd8d317c968009b07ff36129fc", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -13,6 +13,7 @@\n use std::option;\n use std::os;\n use std::task;\n+use std::vec_ng::Vec;\n \n fn print_complements() {\n     let all = [Blue, Red, Yellow];\n@@ -39,7 +40,7 @@ fn show_color(cc: color) -> ~str {\n     }\n }\n \n-fn show_color_list(set: vec!(color)) -> ~str {\n+fn show_color_list(set: Vec<color>) -> ~str {\n     let mut out = ~\"\";\n     for col in set.iter() {\n         out.push_char(' ');\n@@ -132,7 +133,7 @@ fn creature(\n     }\n }\n \n-fn rendezvous(nn: uint, set: vec!(color)) {\n+fn rendezvous(nn: uint, set: Vec<color>) {\n \n     // these ports will allow us to hear from the creatures\n     let (to_rendezvous, from_creatures) = channel::<CreatureInfo>();\n@@ -141,7 +142,7 @@ fn rendezvous(nn: uint, set: vec!(color)) {\n     // these channels will be passed to the creatures so they can talk to us\n \n     // these channels will allow us to talk to each creature by 'name'/index\n-    let to_creature: Vec<Sender<Option<CreatureInfo>>> =\n+    let mut to_creature: Vec<Sender<Option<CreatureInfo>>> =\n         set.iter().enumerate().map(|(ii, col)| {\n             // create each creature as a listener with a port, and\n             // give us a channel to talk to each\n@@ -164,13 +165,13 @@ fn rendezvous(nn: uint, set: vec!(color)) {\n \n     // set up meetings...\n     for _ in range(0, nn) {\n-        let fst_creature: CreatureInfo = from_creatures.recv();\n-        let snd_creature: CreatureInfo = from_creatures.recv();\n+        let mut fst_creature: CreatureInfo = from_creatures.recv();\n+        let mut snd_creature: CreatureInfo = from_creatures.recv();\n \n         creatures_met += 2;\n \n-        to_creature[fst_creature.name].send(Some(snd_creature));\n-        to_creature[snd_creature.name].send(Some(fst_creature));\n+        to_creature.get_mut(fst_creature.name).send(Some(snd_creature));\n+        to_creature.get_mut(snd_creature.name).send(Some(fst_creature));\n     }\n \n     // tell each creature to stop\n@@ -203,10 +204,10 @@ fn main() {\n     } else if args.len() <= 1u {\n         vec!(~\"\", ~\"600\")\n     } else {\n-        args\n+        args.move_iter().collect()\n     };\n \n-    let nn = from_str::<uint>(args[1]).unwrap();\n+    let nn = from_str::<uint>(*args.get(1)).unwrap();\n \n     print_complements();\n     println!(\"\");"}, {"sha": "f05f80a20d78948e0054d00a0fcd800006d7205e", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -68,7 +68,8 @@ fn sum_and_scale(a: &'static [AminoAcid]) -> Vec<AminoAcid> {\n         a_i.p = p * LOOKUP_SCALE;\n         result.push(a_i);\n     }\n-    result[result.len() - 1].p = LOOKUP_SCALE;\n+    let result_len = result.len();\n+    result.get_mut(result_len - 1).p = LOOKUP_SCALE;\n     result\n }\n \n@@ -193,12 +194,12 @@ fn main() {\n \n     out.write_line(\">TWO IUB ambiguity codes\").unwrap();\n     let iub = sum_and_scale(IUB);\n-    let mut random = RandomFasta::new(&mut out, iub);\n+    let mut random = RandomFasta::new(&mut out, iub.as_slice());\n     random.make(n * 3).unwrap();\n \n     random.out.write_line(\">THREE Homo sapiens frequency\").unwrap();\n     let homo_sapiens = sum_and_scale(HOMO_SAPIENS);\n-    random.lookup = make_lookup(homo_sapiens);\n+    random.lookup = make_lookup(homo_sapiens.as_slice());\n     random.make(n * 5).unwrap();\n \n     random.out.write_str(\"\\n\").unwrap();"}, {"sha": "017099bbafacdc6ad3a3699a671e87dea212a56b", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -18,6 +18,7 @@ use std::io;\n use std::io::{BufferedWriter, File};\n use std::cmp::min;\n use std::os;\n+use std::vec_ng::Vec;\n \n static LINE_LENGTH: uint = 60;\n static IM: u32 = 139968;"}, {"sha": "a363d19b3282f1ce1eecd1fe01baa60c18c82f0d", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::os;\n+use std::vec_ng::Vec;\n \n fn fib(n: int) -> int {\n     if n < 2 {\n@@ -25,8 +26,8 @@ fn main() {\n     } else if args.len() <= 1u {\n         vec!(~\"\", ~\"30\")\n     } else {\n-        args\n+        args.move_iter().collect()\n     };\n-    let n = from_str::<int>(args[1]).unwrap();\n+    let n = from_str::<int>(*args.get(1)).unwrap();\n     println!(\"{}\\n\", fib(n));\n }"}, {"sha": "fd5e5ca2eed53b08efda0d5abfe683b253890645", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -68,7 +68,10 @@ fn sort_and_fmt(mm: &HashMap<Vec<u8> , uint>, total: uint) -> ~str {\n    for &(ref k, v) in pairs_sorted.iter() {\n        unsafe {\n            buffer.push_str(format!(\"{} {:0.3f}\\n\",\n-                                   k.to_ascii().to_upper().into_str(), v));\n+                                   k.as_slice()\n+                                    .to_ascii()\n+                                    .to_upper()\n+                                    .into_str(), v));\n        }\n    }\n \n@@ -86,15 +89,15 @@ fn find(mm: &HashMap<Vec<u8> , uint>, key: ~str) -> uint {\n \n // given a map, increment the counter for a key\n fn update_freq(mm: &mut HashMap<Vec<u8> , uint>, key: &[u8]) {\n-    let key = key.to_owned();\n+    let key = Vec::from_slice(key);\n     let newval = match mm.pop(&key) {\n         Some(v) => v + 1,\n         None => 1\n     };\n     mm.insert(key, newval);\n }\n \n-// given a ~[u8], for each window call a function\n+// given a Vec<u8>, for each window call a function\n // i.e., for \"hello\" and windows of size four,\n // run it(\"hell\") and it(\"ello\"), then return \"llo\"\n fn windows_with_carry(bb: &[u8], nn: uint, it: |window: &[u8]|) -> Vec<u8> {\n@@ -106,7 +109,7 @@ fn windows_with_carry(bb: &[u8], nn: uint, it: |window: &[u8]|) -> Vec<u8> {\n       ii += 1u;\n    }\n \n-   return bb.slice(len - (nn - 1u), len).to_owned();\n+   return Vec::from_slice(bb.slice(len - (nn - 1u), len));\n }\n \n fn make_sequence_processor(sz: uint,\n@@ -116,14 +119,17 @@ fn make_sequence_processor(sz: uint,\n    let mut carry = Vec::new();\n    let mut total: uint = 0u;\n \n-   let mut line: Vec<u8> ;\n+   let mut line: Vec<u8>;\n \n    loop {\n \n       line = from_parent.recv();\n       if line == Vec::new() { break; }\n \n-       carry = windows_with_carry(carry + line, sz, |window| {\n+       carry = windows_with_carry(vec::append(carry,\n+                                                 line.as_slice()).as_slice(),\n+                                  sz,\n+                                  |window| {\n          update_freq(&mut freqs, window);\n          total += 1u;\n       });\n@@ -203,8 +209,8 @@ fn main() {\n                let line_bytes = line.as_bytes();\n \n                for (ii, _sz) in sizes.iter().enumerate() {\n-                   let lb = line_bytes.to_owned();\n-                   to_child[ii].send(lb);\n+                   let lb = Vec::from_slice(line_bytes);\n+                   to_child.get(ii).send(lb);\n                }\n            }\n \n@@ -215,11 +221,11 @@ fn main() {\n \n    // finish...\n    for (ii, _sz) in sizes.iter().enumerate() {\n-       to_child[ii].send(Vec::new());\n+       to_child.get(ii).send(Vec::new());\n    }\n \n    // now fetch and print result messages\n    for (ii, _sz) in sizes.iter().enumerate() {\n-       println!(\"{}\", from_child[ii].recv());\n+       println!(\"{}\", from_child.get(ii).recv());\n    }\n }"}, {"sha": "1b9d0e03431454ff32c4ebdb64b1ab27d93a39c6", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -57,7 +57,7 @@ impl Code {\n         }\n \n         result.reverse();\n-        str::from_utf8_owned(result).unwrap()\n+        str::from_utf8_owned(result.move_iter().collect()).unwrap()\n     }\n }\n \n@@ -103,7 +103,7 @@ impl Table {\n     fn new() -> Table {\n         Table {\n             count: 0,\n-            items: slice::from_fn(TABLE_SIZE, |_| None),\n+            items: Vec::from_fn(TABLE_SIZE, |_| None),\n         }\n     }\n \n@@ -133,20 +133,20 @@ impl Table {\n         let index = key.hash() % (TABLE_SIZE as u64);\n \n         {\n-            if self.items[index].is_none() {\n+            if self.items.get(index as uint).is_none() {\n                 let mut entry = ~Entry {\n                     code: key,\n                     count: 0,\n                     next: None,\n                 };\n                 c.f(entry);\n-                self.items[index] = Some(entry);\n+                *self.items.get_mut(index as uint) = Some(entry);\n                 return;\n             }\n         }\n \n         {\n-            let entry = &mut *self.items[index].get_mut_ref();\n+            let entry = &mut *self.items.get_mut(index as uint).get_mut_ref();\n             if entry.code == key {\n                 c.f(*entry);\n                 return;\n@@ -240,7 +240,7 @@ fn print_frequencies(frequencies: &Table, frame: i32) {\n     for entry in frequencies.iter() {\n         vector.push((entry.code, entry.count));\n     }\n-    vector.sort();\n+    vector.as_mut_slice().sort();\n \n     let mut total_count = 0;\n     for &(_, count) in vector.iter() {"}, {"sha": "fbe19af27fd90d2e2b6d18820c7056ddb6153a63", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -12,6 +12,8 @@\n // Utilities.\n //\n \n+use std::vec_ng::Vec;\n+\n // returns an infinite iterator of repeated applications of f to x,\n // i.e. [x, f(x), f(f(x)), ...], as haskell iterate function.\n fn iterate<'a, T>(x: T, f: 'a |&T| -> T) -> Iterate<'a, T> {\n@@ -63,16 +65,16 @@ impl<'a, T> Iterator<&'a T> for ListIterator<'a, T> {\n // corresponding mirrored piece), with, as minimum coordinates, (0,\n // 0).  If all is false, only generate half of the possibilities (used\n // to break the symetry of the board).\n-fn transform(piece: Vec<(int, int)> , all: bool) -> vec!(Vec<(int, int)> ) {\n-    let mut res =\n+fn transform(piece: Vec<(int, int)> , all: bool) -> Vec<Vec<(int, int)>> {\n+    let mut res: Vec<Vec<(int, int)>> =\n         // rotations\n         iterate(piece, |rot| rot.iter().map(|&(y, x)| (x + y, -y)).collect())\n         .take(if all {6} else {3})\n         // mirror\n         .flat_map(|cur_piece| {\n             iterate(cur_piece, |mir| mir.iter().map(|&(y, x)| (x, y)).collect())\n             .take(2)\n-        }).to_owned_vec();\n+        }).collect();\n \n     // translating to (0, 0) as minimum coordinates.\n     for cur_piece in res.mut_iter() {\n@@ -130,7 +132,7 @@ fn make_masks() -> Vec<Vec<Vec<u64> > > {\n             for dx in range(0, 5) {\n                 let masks =\n                     trans.iter()\n-                    .filter_map(|t| mask(dy, dx, id, *t))\n+                    .filter_map(|t| mask(dy, dx, id, t.as_slice()))\n                     .collect();\n                 cur_piece.push(masks);\n             }\n@@ -147,7 +149,7 @@ fn is_board_unfeasible(board: u64, masks: &[Vec<Vec<u64> > ]) -> bool {\n     for i in range(0, 50).filter(|&i| board & 1 << i == 0) {\n         for (cur_id, pos_masks) in masks.iter().enumerate() {\n             if board & 1 << (50 + cur_id) != 0 {continue;}\n-            for &cur_m in pos_masks[i].iter() {\n+            for &cur_m in pos_masks.get(i as uint).iter() {\n                 if cur_m & board == 0 {coverable |= cur_m;}\n             }\n         }\n@@ -184,10 +186,12 @@ fn to_utf8(raw_sol: &List<u64>) -> ~str {\n     for &m in raw_sol.iter() {\n         let id = get_id(m);\n         for i in range(0, 50) {\n-            if m & 1 << i != 0 {sol[i] = '0' as u8 + id;}\n+            if m & 1 << i != 0 {\n+                *sol.get_mut(i as uint) = '0' as u8 + id;\n+            }\n         }\n     }\n-    std::str::from_utf8_owned(sol).unwrap()\n+    std::str::from_utf8_owned(sol.move_iter().collect()).unwrap()\n }\n \n // Prints a solution in ~str form.\n@@ -252,7 +256,9 @@ fn search(\n     // for every unused piece\n     for id in range(0, 10).filter(|id| board & (1 << (id + 50)) == 0) {\n         // for each mask that fits on the board\n-        for &m in masks[id][i].iter().filter(|&m| board & *m == 0) {\n+        for &m in masks[id].get(i as uint)\n+                           .iter()\n+                           .filter(|&m| board & *m == 0) {\n             // This check is too costy.\n             //if is_board_unfeasible(board | m, masks) {continue;}\n             if !search(masks, board | m, i + 1, Cons(m, &cur), data) {\n@@ -271,9 +277,9 @@ fn main () {\n         from_str(args[1]).unwrap()\n     };\n     let masks = make_masks();\n-    let masks = filter_masks(masks);\n+    let masks = filter_masks(masks.as_slice());\n     let mut data = Data {stop_after: stop_after, nb: 0, min: ~\"\", max: ~\"\"};\n-    search(masks, 0, 0, Nil, &mut data);\n+    search(masks.as_slice(), 0, 0, Nil, &mut data);\n     println!(\"{} solutions found\", data.nb);\n     print_sol(data.min);\n     print_sol(data.max);"}, {"sha": "b4c96a48ded75665a1ec265b8abdd1d2ee3909ad", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::os;\n+use std::vec_ng::Vec;\n \n static PI: f64 = 3.141592653589793;\n static SOLAR_MASS: f64 = 4.0 * PI * PI;\n@@ -152,10 +153,10 @@ fn main() {\n     } else if args.len() <= 1u {\n         vec!(~\"\", ~\"1000\")\n     } else {\n-        args\n+        args.move_iter().collect()\n     };\n \n-    let n: i32 = from_str::<i32>(args[1]).unwrap();\n+    let n: i32 = from_str::<i32>(*args.get(1)).unwrap();\n     let mut bodies = BODIES;\n \n     offset_momentum(&mut bodies);"}, {"sha": "2fbc544a8a93f06650ac067e833027c9458d14e8", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -25,6 +25,7 @@ use std::os;\n use std::result::{Ok, Err};\n use std::task;\n use std::uint;\n+use std::vec_ng::Vec;\n \n fn fib(n: int) -> int {\n     fn pfib(tx: &Sender<int>, n: int) {\n@@ -56,7 +57,7 @@ fn parse_opts(argv: Vec<~str> ) -> Config {\n \n     let opt_args = argv.slice(1, argv.len());\n \n-    match getopts::getopts(opt_args, opts) {\n+    match getopts::getopts(opt_args, opts.as_slice()) {\n       Ok(ref m) => {\n           return Config {stress: m.opt_present(\"stress\")}\n       }\n@@ -95,15 +96,16 @@ fn main() {\n     } else if args.len() <= 1u {\n         vec!(~\"\", ~\"8\")\n     } else {\n-        args\n+        args.move_iter().collect()\n     };\n \n     let opts = parse_opts(args.clone());\n \n     if opts.stress {\n         stress(2);\n     } else {\n-        let max = uint::parse_bytes(args[1].as_bytes(), 10u).unwrap() as int;\n+        let max = uint::parse_bytes(args.get(1).as_bytes(), 10u).unwrap() as\n+            int;\n \n         let num_trials = 10;\n "}, {"sha": "7ee294b8e632a750654990299404f00eaa82b476", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -56,18 +56,17 @@ fn main() {\n \n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n         vec!(~\"\", ~\"2000000\", ~\"503\")\n-    }\n-    else {\n-        os::args()\n+    } else {\n+        os::args().move_iter().collect()\n     };\n     let token = if args.len() > 1u {\n-        FromStr::from_str(args[1]).unwrap()\n+        FromStr::from_str(*args.get(1)).unwrap()\n     }\n     else {\n         1000\n     };\n     let n_tasks = if args.len() > 2u {\n-        FromStr::from_str(args[2]).unwrap()\n+        FromStr::from_str(*args.get(2)).unwrap()\n     }\n     else {\n         503"}, {"sha": "7bafdd81b7cc7210cf60c13606ce0383a7eec814", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -16,6 +16,7 @@ extern crate time;\n use collections::SmallIntMap;\n use std::os;\n use std::uint;\n+use std::vec_ng::Vec;\n \n fn append_sequential(min: uint, max: uint, map: &mut SmallIntMap<uint>) {\n     for i in range(min, max) {\n@@ -36,10 +37,10 @@ fn main() {\n     } else if args.len() <= 1u {\n         vec!(~\"\", ~\"10000\", ~\"50\")\n     } else {\n-        args\n+        args.move_iter().collect()\n     };\n-    let max = from_str::<uint>(args[1]).unwrap();\n-    let rep = from_str::<uint>(args[2]).unwrap();\n+    let max = from_str::<uint>(*args.get(1)).unwrap();\n+    let rep = from_str::<uint>(*args.get(2)).unwrap();\n \n     let mut checkf = 0.0;\n     let mut appendf = 0.0;"}, {"sha": "d41a19c60a169ab52f11a5eecbe8a61ceba4c905", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -17,7 +17,6 @@ use std::io::stdio::StdReader;\n use std::io::BufferedReader;\n use std::os;\n use std::intrinsics::cttz16;\n-use std::slice;\n \n // Computes a single solution to a given 9x9 sudoku\n //\n@@ -48,16 +47,17 @@ impl Sudoku {\n     }\n \n     pub fn from_vec(vec: &[[u8, ..9], ..9]) -> Sudoku {\n-        let g = slice::from_fn(9u, |i| {\n-            slice::from_fn(9u, |j| { vec[i][j] })\n+        let g = Vec::from_fn(9u, |i| {\n+            Vec::from_fn(9u, |j| { vec[i][j] })\n         });\n         return Sudoku::new(g)\n     }\n \n     pub fn equal(&self, other: &Sudoku) -> bool {\n         for row in range(0u8, 9u8) {\n             for col in range(0u8, 9u8) {\n-                if self.grid[row][col] != other.grid[row][col] {\n+                if *self.grid.get(row as uint).get(col as uint) !=\n+                        *other.grid.get(row as uint).get(col as uint) {\n                     return false;\n                 }\n             }\n@@ -68,14 +68,15 @@ impl Sudoku {\n     pub fn read(mut reader: BufferedReader<StdReader>) -> Sudoku {\n         assert!(reader.read_line().unwrap() == ~\"9,9\"); /* assert first line is exactly \"9,9\" */\n \n-        let mut g = slice::from_fn(10u, { |_i| vec!(0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8) });\n+        let mut g = Vec::from_fn(10u, { |_i| vec!(0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8) });\n         for line in reader.lines() {\n             let comps: Vec<&str> = line.trim().split(',').collect();\n \n             if comps.len() == 3u {\n-                let row     = from_str::<uint>(comps[0]).unwrap() as u8;\n-                let col     = from_str::<uint>(comps[1]).unwrap() as u8;\n-                g[row][col] = from_str::<uint>(comps[2]).unwrap() as u8;\n+                let row     = from_str::<uint>(*comps.get(0)).unwrap() as u8;\n+                let col     = from_str::<uint>(*comps.get(1)).unwrap() as u8;\n+                *g.get_mut(row as uint).get_mut(col as uint) =\n+                    from_str::<uint>(*comps.get(2)).unwrap() as u8;\n             }\n             else {\n                 fail!(\"Invalid sudoku file\");\n@@ -86,9 +87,11 @@ impl Sudoku {\n \n     pub fn write(&self, writer: &mut io::Writer) {\n         for row in range(0u8, 9u8) {\n-            write!(writer, \"{}\", self.grid[row][0]);\n+            write!(writer, \"{}\", *self.grid.get(row as uint).get(0));\n             for col in range(1u8, 9u8) {\n-                write!(writer, \" {}\", self.grid[row][col]);\n+                write!(writer, \" {}\", *self.grid\n+                                           .get(row as uint)\n+                                           .get(col as uint));\n             }\n             write!(writer, \"\\n\");\n          }\n@@ -99,7 +102,7 @@ impl Sudoku {\n         let mut work: Vec<(u8, u8)> = Vec::new(); /* queue of uncolored fields */\n         for row in range(0u8, 9u8) {\n             for col in range(0u8, 9u8) {\n-                let color = self.grid[row][col];\n+                let color = *self.grid.get(row as uint).get(col as uint);\n                 if color == 0u8 {\n                     work.push((row, col));\n                 }\n@@ -109,9 +112,11 @@ impl Sudoku {\n         let mut ptr = 0u;\n         let end = work.len();\n         while ptr < end {\n-            let (row, col) = work[ptr];\n+            let (row, col) = *work.get(ptr);\n             // is there another color to try?\n-            if self.next_color(row, col, self.grid[row][col] + (1 as u8)) {\n+            let the_color = *self.grid.get(row as uint).get(col as uint) +\n+                                (1 as u8);\n+            if self.next_color(row, col, the_color) {\n                 //  yes: advance work list\n                 ptr = ptr + 1u;\n             } else {\n@@ -132,26 +137,32 @@ impl Sudoku {\n \n             // find first remaining color that is available\n             let next = avail.next();\n-            self.grid[row][col] = next;\n+            *self.grid.get_mut(row as uint).get_mut(col as uint) = next;\n             return 0u8 != next;\n         }\n-        self.grid[row][col] = 0u8;\n+        *self.grid.get_mut(row as uint).get_mut(col as uint) = 0u8;\n         return false;\n     }\n \n     // find colors available in neighbourhood of (row, col)\n     fn drop_colors(&mut self, avail: &mut Colors, row: u8, col: u8) {\n         for idx in range(0u8, 9u8) {\n-            avail.remove(self.grid[idx][col]); /* check same column fields */\n-            avail.remove(self.grid[row][idx]); /* check same row fields */\n+            avail.remove(*self.grid\n+                              .get(idx as uint)\n+                              .get(col as uint)); /* check same column fields */\n+            avail.remove(*self.grid\n+                              .get(row as uint)\n+                              .get(idx as uint)); /* check same row fields */\n         }\n \n         // check same block fields\n         let row0 = (row / 3u8) * 3u8;\n         let col0 = (col / 3u8) * 3u8;\n         for alt_row in range(row0, row0 + 3u8) {\n             for alt_col in range(col0, col0 + 3u8) {\n-                avail.remove(self.grid[alt_row][alt_col]);\n+                avail.remove(*self.grid\n+                                  .get(alt_row as uint)\n+                                  .get(alt_col as uint));\n             }\n         }\n     }"}, {"sha": "4c8379ee05962e6c57539a7c3c7952f5b680ad3a", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -17,6 +17,8 @@ use collections::list::{List, Cons, Nil};\n use time::precise_time_s;\n use std::os;\n use std::task;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n \n enum UniqueList {\n     ULNil, ULCons(~UniqueList)\n@@ -50,7 +52,7 @@ struct State {\n     managed: @nillist,\n     unique: ~nillist,\n     tuple: (@nillist, ~nillist),\n-    vec: vec!(@nillist),\n+    vec: Vec<@nillist>,\n     res: r\n }\n \n@@ -92,7 +94,8 @@ fn recurse_or_fail(depth: int, st: Option<State>) {\n                 unique: ~Cons((), @*st.unique),\n                 tuple: (@Cons((), st.tuple.ref0().clone()),\n                         ~Cons((), @*st.tuple.ref1().clone())),\n-                vec: st.vec + &[@Cons((), *st.vec.last().unwrap())],\n+                vec: vec::append(st.vec.clone(),\n+                     &[@Cons((), *st.vec.last().unwrap())]),\n                 res: r(@Cons((), st.res._l))\n             }\n           }"}, {"sha": "0199798273e54e8813eab6f994719710f98d9618", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -21,6 +21,7 @@ use std::comm;\n use std::os;\n use std::task;\n use std::uint;\n+use std::vec_ng::Vec;\n \n fn child_generation(gens_left: uint, tx: comm::Sender<()>) {\n     // This used to be O(n^2) in the number of generations that ever existed.\n@@ -45,11 +46,11 @@ fn main() {\n     } else if args.len() <= 1 {\n         vec!(~\"\", ~\"100\")\n     } else {\n-        args.clone()\n+        args.clone().move_iter().collect()\n     };\n \n     let (tx, rx) = channel();\n-    child_generation(from_str::<uint>(args[1]).unwrap(), tx);\n+    child_generation(from_str::<uint>(*args.get(1)).unwrap(), tx);\n     if rx.recv_opt().is_none() {\n         fail!(\"it happened when we slumbered\");\n     }"}, {"sha": "c5da4a4359364ea8389ce257c5c836e7b15d115c", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -11,6 +11,7 @@\n use std::os;\n use std::task;\n use std::uint;\n+use std::vec_ng::Vec;\n \n fn f(n: uint) {\n     let mut i = 0u;\n@@ -29,9 +30,9 @@ fn main() {\n     } else if args.len() <= 1u {\n         vec!(~\"\", ~\"10\")\n     } else {\n-        args\n+        args.move_iter().collect()\n     };\n-    let n = from_str::<uint>(args[1]).unwrap();\n+    let n = from_str::<uint>(*args.get(1)).unwrap();\n     let mut i = 0u;\n     while i < n { task::spawn(proc() f(n) ); i += 1u; }\n }"}, {"sha": "8dbf292277be9cda5eb46a2eae8579f56c848449", "filename": "src/test/compile-fail/access-mode-in-closures.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Faccess-mode-in-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Faccess-mode-in-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Faccess-mode-in-closures.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n \n struct sty(Vec<int> );\n "}, {"sha": "24a4c9863f76e6b5a8ec3f269e7a4bd1e870e90c", "filename": "src/test/compile-fail/ambig_impl_unify.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,16 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n trait foo {\n     fn foo(&self) -> int;\n }\n \n impl foo for Vec<uint> {\n-    fn foo(&self) -> int {1} //~ NOTE candidate #1 is `~[uint].foo::foo`\n+    fn foo(&self) -> int {1} //~ NOTE candidate #1 is `Vec<uint>.foo::foo`\n }\n \n impl foo for Vec<int> {\n-    fn foo(&self) -> int {2} //~ NOTE candidate #2 is `~[int].foo::foo`\n+    fn foo(&self) -> int {2} //~ NOTE candidate #2 is `Vec<int>.foo::foo`\n }\n \n fn main() {"}, {"sha": "6e73427f80f95ba38fb8f7b94f693e7eaa7cb799", "filename": "src/test/compile-fail/bad-expr-path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -12,4 +12,4 @@\n \n mod m1 {}\n \n-fn main(args: vec!(str)) { log(debug, m1::a); }\n+fn main(args: Vec<~str>) { log(debug, m1::a); }"}, {"sha": "d2b3a57868683e469c315d639e208bbbbb30c2d1", "filename": "src/test/compile-fail/bad-expr-path2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -14,4 +14,6 @@ mod m1 {\n     pub mod a {}\n }\n \n-fn main(args: vec!(str)) { log(debug, m1::a); }\n+fn main(args: Vec<~str>) {\n+    log(debug, m1::a);\n+}"}, {"sha": "143ebdaa77399d3a8cbfe2c7be13667ddb9399c5", "filename": "src/test/compile-fail/borrowck-assign-comp-idx.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -17,9 +17,9 @@ fn a() {\n     let mut p = vec!(1);\n \n     // Create an immutable pointer into p's contents:\n-    let q: &int = &p[0];\n+    let q: &int = p.get(0);\n \n-    p[0] = 5; //~ ERROR cannot assign\n+    *p.get_mut(0) = 5; //~ ERROR cannot borrow\n \n     println!(\"{}\", *q);\n }\n@@ -33,16 +33,16 @@ fn b() {\n     let mut p = vec!(1);\n \n     borrow(\n-        p,\n-        || p[0] = 5); //~ ERROR cannot borrow `p` as mutable\n+        p.as_slice(),\n+        || *p.get_mut(0) = 5); //~ ERROR cannot borrow `p` as mutable\n }\n \n fn c() {\n     // Legal because the scope of the borrow does not include the\n     // modification:\n     let mut p = vec!(1);\n-    borrow(p, ||{});\n-    p[0] = 5;\n+    borrow(p.as_slice(), ||{});\n+    *p.get_mut(0) = 5;\n }\n \n fn main() {"}, {"sha": "ef9bee80c2b2db02ddc5caf309dad4ef42e9f818", "filename": "src/test/compile-fail/borrowck-borrowed-uniq-rvalue-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -28,6 +28,7 @@ fn defer<'r>(x: &'r [&'r str]) -> defer<'r> {\n }\n \n fn main() {\n-    let x = defer(vec!(\"Goodbye\", \"world!\")); //~ ERROR borrowed value does not live long enough\n+    let x = defer(vec!(\"Goodbye\", \"world!\").as_slice());\n+    //~^ ERROR borrowed value does not live long enough\n     x.x[0];\n }"}, {"sha": "8d4cb6714bcb06d742ce2674a0f577a53248cbc4", "filename": "src/test/compile-fail/borrowck-init-op-equal.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fborrowck-init-op-equal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fborrowck-init-op-equal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-init-op-equal.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n fn test() {\n     let v: int;\n     v += 1; //~ ERROR use of possibly uninitialized variable: `v`"}, {"sha": "393b528869a940b1d2168144752865d43f835e1c", "filename": "src/test/compile-fail/borrowck-loan-vec-content.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -18,15 +18,15 @@ fn takes_imm_elt(_v: &int, f: ||) {\n \n fn has_mut_vec_and_does_not_try_to_change_it() {\n     let mut v = vec!(1, 2, 3);\n-    takes_imm_elt(&v[0], || {})\n+    takes_imm_elt(v.get(0), || {})\n }\n \n fn has_mut_vec_but_tries_to_change_it() {\n     let mut v = vec!(1, 2, 3);\n     takes_imm_elt(\n-        &v[0],\n+        v.get(0),\n         || { //~ ERROR cannot borrow `v` as mutable\n-            v[1] = 4;\n+            *v.get_mut(1) = 4;\n         })\n }\n "}, {"sha": "6724d76d0dc55f11db1787445259e84716c0dbec", "filename": "src/test/compile-fail/borrowck-move-out-of-vec-tail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -21,7 +21,7 @@ pub fn main() {\n         Foo { string: ~\"bar\" },\n         Foo { string: ~\"baz\" }\n     );\n-    let x: &[Foo] = x;\n+    let x: &[Foo] = x.as_slice();\n     match x {\n         [_, ..tail] => {\n             match tail {"}, {"sha": "283d6398e9ad38efecfa62565811972839c3c8b1", "filename": "src/test/compile-fail/borrowck-mut-slice-of-imm-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -14,5 +14,5 @@ fn write(v: &mut [int]) {\n \n fn main() {\n     let v = vec!(1, 2, 3);\n-    write(v); //~ ERROR cannot borrow\n+    write(v.as_mut_slice()); //~ ERROR cannot borrow\n }"}, {"sha": "3da284175541d730aeaf130ea1e376705f1b1d67", "filename": "src/test/compile-fail/borrowck-vec-pattern-element-loan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,7 +10,7 @@\n \n fn a() -> &[int] {\n     let vec = vec!(1, 2, 3, 4);\n-    let vec: &[int] = vec; //~ ERROR does not live long enough\n+    let vec: &[int] = vec.as_slice(); //~ ERROR does not live long enough\n     let tail = match vec {\n         [_, ..tail] => tail,\n         _ => fail!(\"a\")\n@@ -20,7 +20,7 @@ fn a() -> &[int] {\n \n fn b() -> &[int] {\n     let vec = vec!(1, 2, 3, 4);\n-    let vec: &[int] = vec; //~ ERROR does not live long enough\n+    let vec: &[int] = vec.as_slice(); //~ ERROR does not live long enough\n     let init = match vec {\n         [..init, _] => init,\n         _ => fail!(\"b\")\n@@ -30,7 +30,7 @@ fn b() -> &[int] {\n \n fn c() -> &[int] {\n     let vec = vec!(1, 2, 3, 4);\n-    let vec: &[int] = vec; //~ ERROR does not live long enough\n+    let vec: &[int] = vec.as_slice(); //~ ERROR does not live long enough\n     let slice = match vec {\n         [_, ..slice, _] => slice,\n         _ => fail!(\"c\")"}, {"sha": "393ec8b0b1b3ba9d80e8a7a44e6a2e03dbbf9a60", "filename": "src/test/compile-fail/borrowck-vec-pattern-loan-from-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,7 +10,7 @@\n \n fn a() {\n     let mut v = vec!(1, 2, 3);\n-    let vb: &mut [int] = v;\n+    let vb: &mut [int] = v.as_mut_slice();\n     match vb {\n         [_a, ..tail] => {\n             v.push(tail[0] + tail[1]); //~ ERROR cannot borrow"}, {"sha": "e96ccd2aa8b209b323a4691ae54e3fca892b2979", "filename": "src/test/compile-fail/borrowck-vec-pattern-nesting.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -19,7 +19,7 @@ fn a() {\n \n fn b() {\n     let mut vec = vec!(~1, ~2, ~3);\n-    let vec: &mut [~int] = vec;\n+    let vec: &mut [~int] = vec.as_mut_slice();\n     match vec {\n         [.._b] => {\n             vec[0] = ~4; //~ ERROR cannot assign\n@@ -29,7 +29,7 @@ fn b() {\n \n fn c() {\n     let mut vec = vec!(~1, ~2, ~3);\n-    let vec: &mut [~int] = vec;\n+    let vec: &mut [~int] = vec.as_mut_slice();\n     match vec {\n         [_a, .._b] => {\n             //~^ ERROR cannot move out\n@@ -47,7 +47,7 @@ fn c() {\n \n fn d() {\n     let mut vec = vec!(~1, ~2, ~3);\n-    let vec: &mut [~int] = vec;\n+    let vec: &mut [~int] = vec.as_mut_slice();\n     match vec {\n         [.._a, _b] => {\n             //~^ ERROR cannot move out\n@@ -59,7 +59,7 @@ fn d() {\n \n fn e() {\n     let mut vec = vec!(~1, ~2, ~3);\n-    let vec: &mut [~int] = vec;\n+    let vec: &mut [~int] = vec.as_mut_slice();\n     match vec {\n         [_a, _b, _c] => {}  //~ ERROR cannot move out\n         //~^ ERROR cannot move out"}, {"sha": "26dc853859c9256ef286c6e6396a8670fb068b80", "filename": "src/test/compile-fail/borrowck-vec-pattern-tail-element-loan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,7 +10,7 @@\n \n fn a() -> &int {\n     let vec = vec!(1, 2, 3, 4);\n-    let vec: &[int] = vec; //~ ERROR `vec[..]` does not live long enough\n+    let vec: &[int] = vec.as_slice(); //~ ERROR `vec` does not live long enough\n     let tail = match vec {\n         [_a, ..tail] => &tail[0],\n         _ => fail!(\"foo\")"}, {"sha": "09274aaa504452c655bf7fb9af3fe8f15d52f822", "filename": "src/test/compile-fail/drop-on-non-struct.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fdrop-on-non-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fdrop-on-non-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdrop-on-non-struct.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,10 +10,13 @@\n \n #[feature(managed_boxes)];\n \n-type Foo = Vec<u8> ;\n+use std::vec_ng::Vec;\n \n-impl Drop for Foo {   //~ ERROR the Drop trait may only be implemented\n+type Foo = Vec<u8>;\n+\n+impl Drop for Foo {   //~ ERROR conflicting implementations\n //~^ ERROR cannot provide an extension implementation\n+//~^^ ERROR multiple applicable methods\n     fn drop(&mut self) {\n         println!(\"kaboom\");\n     }"}, {"sha": "41cb351cdcd1cb5d1d4b7dd7c59c692df5ff653a", "filename": "src/test/compile-fail/empty-vec-trailing-comma.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Fcompile-fail%2Fempty-vec-trailing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Fcompile-fail%2Fempty-vec-trailing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-vec-trailing-comma.rs?ref=579eb2400b3cb5d9cf03a5c8792d63630489193a", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    let v = vec!(); //~ ERROR unexpected token: `,`\n-}"}, {"sha": "562a5580c00fdf02b01f3a0a7d0773d619d5b05b", "filename": "src/test/compile-fail/evec-subtyping.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Fcompile-fail%2Fevec-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Fcompile-fail%2Fevec-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fevec-subtyping.rs?ref=579eb2400b3cb5d9cf03a5c8792d63630489193a", "patch": "@@ -1,32 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-fn wants_uniq(x: Vec<uint> ) { }\n-fn wants_three(x: [uint, ..3]) { }\n-\n-fn has_uniq(x: Vec<uint> ) {\n-   wants_uniq(x);\n-   wants_three(x); //~ ERROR [] storage differs: expected `3` but found `~`\n-}\n-\n-fn has_three(x: [uint, ..3]) {\n-   wants_uniq(x); //~ ERROR [] storage differs: expected `~` but found `3`\n-   wants_three(x);\n-}\n-\n-fn has_four(x: [uint, ..4]) {\n-   wants_uniq(x); //~ ERROR [] storage differs: expected `~` but found `4`\n-   wants_three(x); //~ ERROR [] storage differs: expected `3` but found `4`\n-}\n-\n-fn main() {\n-}"}, {"sha": "35a17f7e0171b7a03887af8efb8e9522017c76cf", "filename": "src/test/compile-fail/import.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -11,7 +11,10 @@\n // error-pattern:failed to resolve import\n use zed::bar;\n use zed::baz;\n+\n+use std::vec_ng::Vec;\n+\n mod zed {\n     pub fn bar() { println!(\"bar\"); }\n }\n-fn main(args: vec!(str)) { bar(); }\n+fn main(args: Vec<~str>) { bar(); }"}, {"sha": "759e0c56f51b32fab2f687bb331b2ca882a2befa", "filename": "src/test/compile-fail/import2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport2.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -11,8 +11,10 @@\n use baz::zed::bar;  //~ ERROR unresolved import\n //~^ ERROR failed to resolve import\n \n+use std::vec_ng::Vec;\n+\n mod baz {}\n mod zed {\n     pub fn bar() { println!(\"bar3\"); }\n }\n-fn main(args: vec!(str)) { bar(); }\n+fn main(args: Vec<~str>) { bar(); }"}, {"sha": "8920349a27a9630f4cd95eb0e3a392926738b460", "filename": "src/test/compile-fail/import4.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fimport4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fimport4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport4.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,6 +10,8 @@\n \n // error-pattern: import\n \n+use std::vec_ng::Vec;\n+\n mod a { pub use b::foo; }\n mod b { pub use a::foo; }\n "}, {"sha": "c52199ecedd388b7fae9e5e3c67833cc0d6d3ba7", "filename": "src/test/compile-fail/infinite-vec-type-recursion.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,6 +10,8 @@\n \n // error-pattern: illegal recursive type\n \n-type x = vec!(x);\n+use std::vec_ng::Vec;\n+\n+type x = Vec<x>;\n \n fn main() { let b: x = Vec::new(); }"}, {"sha": "c2f40f56948860169400a61cc6d2af3c1a9221b6", "filename": "src/test/compile-fail/issue-10487.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Fcompile-fail%2Fissue-10487.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Fcompile-fail%2Fissue-10487.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10487.rs?ref=579eb2400b3cb5d9cf03a5c8792d63630489193a", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-static x: Vec<int> = vec!(123, 456); //~ ERROR: static items are not allowed to have owned pointers\n-\n-fn main() {}"}, {"sha": "29f7e344b3093ba669182bfa0deba4abc51476fe", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n trait vec_monad<A> {\n     fn bind<B>(&self, f: |A| -> Vec<B> );\n }"}, {"sha": "69dd24522fb3224a96f62825699b37e4130ac343", "filename": "src/test/compile-fail/issue-2150.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -13,6 +13,8 @@\n #[allow(dead_code)];\n #[allow(deprecated_owned_vector)];\n \n+use std::vec_ng::Vec;\n+\n fn fail_len(v: Vec<int> ) -> uint {\n     let mut i = 3;\n     fail!();"}, {"sha": "c2f48b7ca5bcd3212572f2a117a85dcaa5673fac", "filename": "src/test/compile-fail/issue-2548.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs?ref=579eb2400b3cb5d9cf03a5c8792d63630489193a", "patch": "@@ -1,47 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-// A test case for #2548.\n-\n-use std::cell::Cell;\n-\n-struct foo {\n-    x: @Cell<int>,\n-}\n-\n-#[unsafe_destructor]\n-impl Drop for foo {\n-    fn drop(&mut self) {\n-        unsafe {\n-            println!(\"Goodbye, World!\");\n-            self.x.set(self.x.get() + 1);\n-        }\n-    }\n-}\n-\n-fn foo(x: @Cell<int>) -> foo {\n-    foo { x: x }\n-}\n-\n-fn main() {\n-    let x = @Cell::new(0);\n-\n-    {\n-        let mut res = foo(x);\n-\n-        let mut v = Vec::new();\n-        v = vec!((res)) + v; //~ failed to find an implementation of trait\n-        assert_eq!(v.len(), 2);\n-    }\n-\n-    assert_eq!(x.get(), 1);\n-}"}, {"sha": "a3f2da150a3c417126dfd2fc974bf91cbfe1b814", "filename": "src/test/compile-fail/issue-2590.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n struct parser {\n     tokens: Vec<int> ,\n }"}, {"sha": "076c60152684d8b85b74f7c7fdfeebf9b12aaa4e", "filename": "src/test/compile-fail/issue-3044.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n fn main() {\n     let needlesArr: Vec<char> = vec!('a', 'f');\n     needlesArr.iter().fold(|x, y| {"}, {"sha": "633be15ef9922d85b407d2401cc5b82f761fee5d", "filename": "src/test/compile-fail/issue-7573.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n pub struct CrateId {\n     local_path: ~str,\n     junk: ~str"}, {"sha": "9d7edefbf024b05742bb8972e4061d80d6fbf36a", "filename": "src/test/compile-fail/issue-8727.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[allow(deprecated_owned_vector)];\n-\n // Verify the compiler fails with an error on infinite function\n // recursions.\n "}, {"sha": "c5977678aba11a20af026a2757d2d7ae25b94c96", "filename": "src/test/compile-fail/kindck-freeze.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fkindck-freeze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fkindck-freeze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-freeze.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,6 +10,8 @@\n \n // Test which of the builtin types are considered freezeable.\n \n+use std::vec_ng::Vec;\n+\n fn assert_freeze<T:Freeze>() { }\n trait Dummy { }\n "}, {"sha": "bc4ee14d89eb5c3a2ea8be8dbb7bf448c4cf48eb", "filename": "src/test/compile-fail/kindck-pod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fkindck-pod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fkindck-pod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-pod.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -13,6 +13,7 @@\n #[feature(managed_boxes)];\n \n use std::rc::Rc;\n+use std::vec_ng::Vec;\n \n fn assert_pod<T:Pod>() { }\n trait Dummy { }"}, {"sha": "0eb3656cea787c0e8683f6ae4d01ec06c2ba1c41", "filename": "src/test/compile-fail/kindck-send.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,6 +10,8 @@\n \n // Test which of the builtin types are considered sendable.\n \n+use std::vec_ng::Vec;\n+\n fn assert_send<T:Send>() { }\n trait Dummy { }\n "}, {"sha": "f45888010750ef9cca0fb8fae7b79ebe2b58b15a", "filename": "src/test/compile-fail/lint-heap-memory.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -25,8 +25,6 @@ fn main() {\n     @2; //~ ERROR type uses managed\n \n     ~2; //~ ERROR type uses owned\n-    vec!(1); //~ ERROR type uses owned\n-    //~^ ERROR type uses owned\n     fn g(_: ~Clone) {} //~ ERROR type uses owned\n     ~\"\"; //~ ERROR type uses owned\n     //~^ ERROR type uses owned"}, {"sha": "2adf833e4e4d4fce31fc81e9ce4b4fbb62bc8353", "filename": "src/test/compile-fail/lint-unused-mut-variables.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -16,6 +16,8 @@\n #[allow(deprecated_owned_vector)];\n #[deny(unused_mut)];\n \n+use std::vec_ng::Vec;\n+\n fn main() {\n     // negative cases\n     let mut a = 3; //~ ERROR: variable does not need to be mutable"}, {"sha": "81e8c39a28c6dae5f0df1eb6e97f397277448cb6", "filename": "src/test/compile-fail/lint-unused-unsafe.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -14,6 +14,8 @@\n #[deny(unused_unsafe)];\n #[allow(deprecated_owned_vector)];\n \n+use std::vec_ng::Vec;\n+\n mod foo {\n     extern {\n         pub fn bar();"}, {"sha": "4bfa614063b5097189c2eb174e369426f209544f", "filename": "src/test/compile-fail/liveness-issue-2163.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::slice;\n+use std::vec::Vec;\n \n fn main() {\n     let a: Vec<int> = Vec::new();"}, {"sha": "2112af7cd043f5886806eb8dc5d5b1ada0013700", "filename": "src/test/compile-fail/match-vec-unreachable.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,25 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n fn main() {\n     let x: Vec<(int, int)> = Vec::new();\n-    let x: &[(int, int)] = x;\n+    let x: &[(int, int)] = x.as_slice();\n     match x {\n         [a, (2, 3), _] => (),\n         [(1, 2), (2, 3), b] => (), //~ ERROR unreachable pattern\n         _ => ()\n     }\n \n     let x: Vec<~str> = vec!(~\"foo\", ~\"bar\", ~\"baz\");\n-    let x: &[~str] = x;\n+    let x: &[~str] = x.as_slice();\n     match x {\n         [a, _, _, ..] => { println!(\"{}\", a); }\n         [_, _, _, _, _] => { } //~ ERROR unreachable pattern\n         _ => { }\n     }\n \n     let x: Vec<char> = vec!('a', 'b', 'c');\n-    let x: &[char] = x;\n+    let x: &[char] = x.as_slice();\n     match x {\n         ['a', 'b', 'c', .._tail] => {}\n         ['a', 'b', 'c'] => {} //~ ERROR unreachable pattern"}, {"sha": "657d5ad03e8a88aa2dac04b396f354fe3fa0c263", "filename": "src/test/compile-fail/moves-based-on-type-access-to-field.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -23,8 +23,8 @@ fn f10() {\n \n fn f20() {\n     let x = vec!(~\"hi\");\n-    consume(x[0]);\n-    touch(&x[0]); //~ ERROR use of partially moved value: `x`\n+    consume(x.move_iter().next().unwrap());\n+    touch(x.get(0)); //~ ERROR use of moved value: `x`\n }\n \n fn main() {}"}, {"sha": "967612e7c50168866d4e8335bfd7eca2fa4ab6c5", "filename": "src/test/compile-fail/moves-based-on-type-exprs.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -31,7 +31,7 @@ fn f20() {\n \n fn f21() {\n     let x = vec!(1, 2, 3);\n-    let _y = (x[0], 3);\n+    let _y = (*x.get(0), 3);\n     touch(&x);\n }\n \n@@ -84,21 +84,21 @@ fn f80() {\n \n fn f100() {\n     let x = vec!(~\"hi\");\n-    let _y = x[0];\n-    touch(&x); //~ ERROR use of partially moved value: `x`\n+    let _y = x.move_iter().next().unwrap();\n+    touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f110() {\n     let x = vec!(~\"hi\");\n-    let _y = [x[0], ..1];\n-    touch(&x); //~ ERROR use of partially moved value: `x`\n+    let _y = [x.move_iter().next().unwrap(), ..1];\n+    touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f120() {\n     let mut x = vec!(~\"hi\", ~\"ho\");\n     x.swap(0, 1);\n-    touch(&x[0]);\n-    touch(&x[1]);\n+    touch(x.get(0));\n+    touch(x.get(1));\n }\n \n fn main() {}"}, {"sha": "e76c31469ea44274ce87e8ecec233f1fd4dec1f1", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -21,10 +21,10 @@ fn main() {\n \n     task::spawn(proc() {\n         let v = arc_v.get();\n-        assert_eq!(v[3], 4);\n+        assert_eq!(*v.get(3), 4);\n     });\n \n-    assert_eq!((arc_v.get())[2], 3);\n+    assert_eq!(*(arc_v.get()).get(2), 3);\n \n     println!(\"{:?}\", arc_v);\n }"}, {"sha": "29f62ff6e1b261834001465b7a193a48bb0acf48", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -19,10 +19,10 @@ fn main() {\n \n     task::spawn(proc() {\n         let v = arc_v.get();\n-        assert_eq!(v[3], 4);\n+        assert_eq!(*v.get(3), 4);\n     });\n \n-    assert_eq!((arc_v.get())[2], 3); //~ ERROR use of moved value: `arc_v`\n+    assert_eq!(*(arc_v.get()).get(2), 3); //~ ERROR use of moved value: `arc_v`\n \n     println!(\"{:?}\", arc_v); //~ ERROR use of moved value: `arc_v`\n }"}, {"sha": "fd857129c35690e0371ee8e21109fb4ed44d3024", "filename": "src/test/compile-fail/non-constant-enum-for-vec-repeat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -11,6 +11,6 @@\n enum State { ST_NULL, ST_WHITESPACE }\n \n fn main() {\n-    vec!(ST_NULL, ..(ST_WHITESPACE as uint));\n+    [ST_NULL, ..(ST_WHITESPACE as uint)];\n     //~^ ERROR expected constant integer for repeat count but found variable\n }"}, {"sha": "2b3722196c11946c9ac4e730fcafc244d723ef9c", "filename": "src/test/compile-fail/non-copyable-void.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::libc;\n+use std::vec_ng::Vec;\n \n fn main() {\n     let x : *Vec<int> = &vec!(1,2,3);"}, {"sha": "a07fec853fc52b57076040f87c86793616439478", "filename": "src/test/compile-fail/non-exhaustive-match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -36,29 +36,29 @@ fn main() {\n       (b, b) => {}\n     }\n     let vec = vec!(Some(42), None, Some(21));\n-    let vec: &[Option<int>] = vec;\n+    let vec: &[Option<int>] = vec.as_slice();\n     match vec {\n         //~^ ERROR non-exhaustive patterns: vectors of length 0 not covered\n         [Some(..), None, ..tail] => {}\n         [Some(..), Some(..), ..tail] => {}\n         [None] => {}\n     }\n     let vec = vec!(1);\n-    let vec: &[int] = vec;\n+    let vec: &[int] = vec.as_slice();\n     match vec {\n         [_, ..tail] => (),\n         [] => ()\n     }\n     let vec = vec!(0.5);\n-    let vec: &[f32] = vec;\n+    let vec: &[f32] = vec.as_slice();\n     match vec { //~ ERROR non-exhaustive patterns: vectors of length 4 not covered\n         [0.1, 0.2, 0.3] => (),\n         [0.1, 0.2] => (),\n         [0.1] => (),\n         [] => ()\n     }\n     let vec = vec!(Some(42), None, Some(21));\n-    let vec: &[Option<int>] = vec;\n+    let vec: &[Option<int>] = vec.as_slice();\n     match vec {\n         [Some(..), None, ..tail] => {}\n         [Some(..), Some(..), ..tail] => {}"}, {"sha": "38669a99b498f1964e8f7405c26ed6857335d57b", "filename": "src/test/compile-fail/pattern-tyvar-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n enum bar { t1((), Option<Vec<int>>), t2, }\n \n // n.b. my change changes this error message, but I think it's right -- tjc"}, {"sha": "692c51b5b5ff720cf16dbc25183b949faa9b89f9", "filename": "src/test/compile-fail/repeat_count.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -12,5 +12,5 @@\n \n fn main() {\n     let n = 1;\n-    let a = vec!(0, ..n); //~ ERROR expected constant integer for repeat count but found variable\n+    let a = [0, ..n]; //~ ERROR expected constant integer for repeat count but found variable\n }"}, {"sha": "59c80474c4c7738ffc4ec9fc506b71511200cc74", "filename": "src/test/compile-fail/tag-that-dare-not-speak-its-name.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -13,6 +13,8 @@\n \n #[no_implicit_prelude];\n \n+use std::vec_ng::Vec;\n+\n fn last<T>(v: Vec<&T> ) -> std::option::Option<T> {\n     fail!();\n }"}, {"sha": "a44010366c82fed58a4a445fa98387888e2cfaa5", "filename": "src/test/compile-fail/uninstantiable-fixed-length-vec.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Fcompile-fail%2Funinstantiable-fixed-length-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Fcompile-fail%2Funinstantiable-fixed-length-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funinstantiable-fixed-length-vec.rs?ref=579eb2400b3cb5d9cf03a5c8792d63630489193a", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// issue #11659, the compiler needs to know that a fixed length vector\n-// always requires instantiable contents to instantiable itself\n-// (unlike a ~[] vector which can have length zero).\n-\n-// ~ to avoid infinite size.\n-struct Uninstantiable { //~ ERROR cannot be instantiated without an instance of itself\n-    p: vec!(Uninstantiable, .. 1)\n-}\n-\n-struct Instantiable { p: vec!(Instantiable, .. 0) }\n-\n-\n-fn main() {\n-    let _ = None::<Uninstantiable>;\n-    let _ = Instantiable { p: ~([]) };\n-}"}, {"sha": "e35a0c607c8e885cbdc1209199b2d3edbe695354", "filename": "src/test/compile-fail/unique-vec-res.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -11,6 +11,7 @@\n #[feature(managed_boxes)];\n \n use std::cell::Cell;\n+use std::vec_ng::Vec;\n \n struct r {\n   i: @Cell<int>,"}, {"sha": "4dd3b26bad966cb3910d6eb851e396e52aca6389", "filename": "src/test/compile-fail/use-after-move-implicity-coerced-object.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -11,6 +11,7 @@\n // ignore-tidy-linelength\n \n use std::fmt;\n+use std::vec_ng::Vec;\n \n struct Number {\n     n: i64"}, {"sha": "985a094d5a8c2fbc03c2a307ca713b84aebf06f3", "filename": "src/test/compile-fail/vector-no-ann.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n fn main() {\n     let _foo = Vec::new(); //~ ERROR unconstrained type\n }"}, {"sha": "00d537f95bf984df0de8f5a8a2e6ef355d579c51", "filename": "src/test/compile-fail/writing-to-immutable-vec.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n fn main() {\n     let v: Vec<int> = vec!(1, 2, 3);\n-    v[1] = 4; //~ ERROR cannot assign\n+    *v.get(1) = 4; //~ ERROR cannot assign\n }"}, {"sha": "acc03831290d0fe06a289bbca51362c6bc59383f", "filename": "src/test/pretty/block-disambig.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-disambig.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -15,6 +15,7 @@\n #[feature(managed_boxes)];\n \n use std::cell::Cell;\n+use std::vec_ng::Vec;\n \n fn test1() { let val = @0; { } *val; }\n \n@@ -61,7 +62,7 @@ fn test9() {\n fn test10() -> int {\n     let regs = @vec!(0);\n     match true { true => { } _ => { } }\n-    (*regs)[0]\n+    *(*regs).get(0)\n }\n \n fn test11() -> Vec<int> { if true { } vec!(1, 2) }"}, {"sha": "5b52acdff50691628c60addf9e6babded5c1fa97", "filename": "src/test/pretty/match-naked-expr-medium.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fpretty%2Fmatch-naked-expr-medium.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fpretty%2Fmatch-naked-expr-medium.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fmatch-naked-expr-medium.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -14,7 +14,7 @@ fn main() {\n     let x = Some(3);\n     let _y =\n         match x {\n-            Some(_) => vec!(~\"some(_)\", ~\"not\", ~\"SO\", ~\"long\", ~\"string\"),\n-            None => vec!(~\"none\")\n+            Some(_) => [~\"some(_)\", ~\"not\", ~\"SO\", ~\"long\", ~\"string\"],\n+            None => [~\"none\", ~\"a\", ~\"a\", ~\"a\", ~\"a\"]\n         };\n }"}, {"sha": "dc2dae1044dac2354ef981979bce687c4384e4cd", "filename": "src/test/pretty/vec-comments.pp", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fpretty%2Fvec-comments.pp", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fpretty%2Fvec-comments.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fvec-comments.pp?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -13,27 +13,27 @@\n // pp-exact:vec-comments.pp\n fn main() {\n     let _v1 =\n-        ~[\n-          // Comment\n-          0,\n-          // Comment\n-          1,\n-          // Comment\n-          2];\n+        [\n+         // Comment\n+         0,\n+         // Comment\n+         1,\n+         // Comment\n+         2];\n     let _v2 =\n-        ~[0, // Comment\n-          1, // Comment\n-          2]; // Comment\n+        [0, // Comment\n+         1, // Comment\n+         2]; // Comment\n     let _v3 =\n-        ~[\n-          /* Comment */\n-          0,\n-          /* Comment */\n-          1,\n-          /* Comment */\n-          2];\n+        [\n+         /* Comment */\n+         0,\n+         /* Comment */\n+         1,\n+         /* Comment */\n+         2];\n     let _v4 =\n-        ~[0, /* Comment */\n-          1, /* Comment */\n-          2]; /* Comment */\n+        [0, /* Comment */\n+         1, /* Comment */\n+         2]; /* Comment */\n }"}, {"sha": "dc2dae1044dac2354ef981979bce687c4384e4cd", "filename": "src/test/pretty/vec-comments.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fpretty%2Fvec-comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Fpretty%2Fvec-comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fvec-comments.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -13,27 +13,27 @@\n // pp-exact:vec-comments.pp\n fn main() {\n     let _v1 =\n-        vec!(\n-          // Comment\n-          0,\n-          // Comment\n-          1,\n-          // Comment\n-          2);\n+        [\n+         // Comment\n+         0,\n+         // Comment\n+         1,\n+         // Comment\n+         2];\n     let _v2 =\n-        vec!(0, // Comment\n-          1, // Comment\n-          2); // Comment\n+        [0, // Comment\n+         1, // Comment\n+         2]; // Comment\n     let _v3 =\n-        vec!(\n-          /* Comment */\n-          0,\n-          /* Comment */\n-          1,\n-          /* Comment */\n-          2);\n+        [\n+         /* Comment */\n+         0,\n+         /* Comment */\n+         1,\n+         /* Comment */\n+         2];\n     let _v4 =\n-        vec!(0, /* Comment */\n-          1, /* Comment */\n-          2); /* Comment */\n+        [0, /* Comment */\n+         1, /* Comment */\n+         2]; /* Comment */\n }"}, {"sha": "d84f43d70050c4e75e6240dc94be7d83ad75883e", "filename": "src/test/pretty/vec-type.pp", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Fpretty%2Fvec-type.pp", "raw_url": "https://github.com/rust-lang/rust/raw/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Fpretty%2Fvec-type.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fvec-type.pp?ref=579eb2400b3cb5d9cf03a5c8792d63630489193a", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// pp-exact:vec-type.pp\n-\n-fn f1(_x: ~[int]) { }\n-\n-fn g1() { f1(~[1, 2, 3]); }"}, {"sha": "5e37123023c40a3330e140552f6e4247b2768d3f", "filename": "src/test/pretty/vec-type.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Fpretty%2Fvec-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Fpretty%2Fvec-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fvec-type.rs?ref=579eb2400b3cb5d9cf03a5c8792d63630489193a", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// pp-exact:vec-type.pp\n-\n-fn f1(_x: Vec<int> ) { }\n-\n-fn g1() { f1(vec!(1, 2, 3)); }"}, {"sha": "0e116bcede5499e76a7c94314377bcda262dcd5d", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -31,5 +31,5 @@ fn main() {\n            idx * mem::size_of::<uint>());\n \n     // This should fail.\n-    println!(\"ov1 0x{:x}\",  x[idx]);\n+    println!(\"ov1 0x{:x}\", *x.get(idx));\n }"}, {"sha": "365be5b75275a19204bc20b39905312630440213", "filename": "src/test/run-fail/issue-3029.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-fail%2Fissue-3029.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-fail%2Fissue-3029.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-3029.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -12,6 +12,8 @@\n #[allow(unreachable_code)];\n #[allow(unused_variable)];\n \n+use std::vec_ng::Vec;\n+\n // error-pattern:so long\n fn main() {\n     let mut x = Vec::new();"}, {"sha": "545012d93222472579eb5c2c2eebd49571529544", "filename": "src/test/run-fail/unwind-misc-1.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -15,13 +15,17 @@\n \n extern crate collections;\n \n+use std::vec_ng::Vec;\n+use std::vec_ng;\n+\n fn main() {\n     let _count = @0u;\n     let mut map = collections::HashMap::new();\n     let mut arr = Vec::new();\n     for _i in range(0u, 10u) {\n         arr.push(@~\"key stuff\");\n-        map.insert(arr.clone(), arr + &[@~\"value stuff\"]);\n+        map.insert(arr.clone(),\n+                   vec::append(arr.clone(), &[@~\"value stuff\"]));\n         if arr.len() == 5 {\n             fail!();\n         }"}, {"sha": "80e1b60ee5a9e9e2c8572f854f3b13970fa17c47", "filename": "src/test/run-fail/unwind-partial-box.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-fail%2Funwind-partial-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-fail%2Funwind-partial-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-partial-box.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -12,6 +12,8 @@\n \n #[feature(managed_boxes)];\n \n+use std::vec_ng::Vec;\n+\n fn f() -> Vec<int> { fail!(); }\n \n // Voodoo. In unwind-alt we had to do this to trigger the bug. Might"}, {"sha": "7f163a2a9e43fe3478793e0c1f25d100a101e153", "filename": "src/test/run-fail/unwind-partial-unique.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-fail%2Funwind-partial-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-fail%2Funwind-partial-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-partial-unique.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -12,6 +12,8 @@\n \n #[feature(managed_boxes)];\n \n+use std::vec_ng::Vec;\n+\n fn f() -> Vec<int> { fail!(); }\n \n // Voodoo. In unwind-alt we had to do this to trigger the bug. Might"}, {"sha": "669edb4544bd3b2863d7db0b0c4042a9e6e15c61", "filename": "src/test/run-fail/unwind-partial-vec.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-fail%2Funwind-partial-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-fail%2Funwind-partial-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-partial-vec.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -12,6 +12,8 @@\n \n #[feature(managed_boxes)];\n \n+use std::vec_ng::Vec;\n+\n fn f() -> Vec<int> { fail!(); }\n \n // Voodoo. In unwind-alt we had to do this to trigger the bug. Might"}, {"sha": "053bc0cb58c64182a06913f1bdb52b308f6e0499", "filename": "src/test/run-fail/unwind-rec.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-fail%2Funwind-rec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-fail%2Funwind-rec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-rec.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,6 +10,8 @@\n \n // error-pattern:fail\n \n+use std::vec_ng::Vec;\n+\n fn build() -> Vec<int> {\n     fail!();\n }"}, {"sha": "7b18c678be6f71bb4126c05198b8b03e74deefb9", "filename": "src/test/run-fail/unwind-rec2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-fail%2Funwind-rec2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-fail%2Funwind-rec2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-rec2.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,6 +10,8 @@\n \n // error-pattern:fail\n \n+use std::vec_ng::Vec;\n+\n fn build1() -> Vec<int> {\n     vec!(0,0,0,0,0,0,0)\n }"}, {"sha": "fd1c13a5018f682c6c690c2323944a2f288b6ef5", "filename": "src/test/run-fail/unwind-tup.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-fail%2Funwind-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-fail%2Funwind-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-tup.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,6 +10,8 @@\n \n #[feature(managed_boxes)];\n \n+use std::vec_ng::Vec;\n+\n // error-pattern:fail\n \n fn fold_local() -> @Vec<int> {"}, {"sha": "6735168e83a913e8edd6e13989f33f5e5b03dad3", "filename": "src/test/run-fail/unwind-tup2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-fail%2Funwind-tup2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-fail%2Funwind-tup2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-tup2.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,6 +10,8 @@\n \n #[feature(managed_boxes)];\n \n+use std::vec_ng::Vec;\n+\n // error-pattern:fail\n \n fn fold_local() -> @Vec<int> {"}, {"sha": "169c00182dd396857acd6d2df092f4f4c5cff848", "filename": "src/test/run-fail/vec-overrun.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-overrun.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,13 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n // error-pattern:index out of bounds: the len is 1 but the index is 2\n+\n+use std::vec_ng::Vec;\n+\n fn main() {\n     let v: Vec<int> = vec!(10);\n-    let x: int = 0;\n-    assert_eq!(v[x], 10);\n+    let x: uint = 0;\n+    assert_eq!(*v.get(x), 10);\n     // Bounds-check failure.\n \n-    assert_eq!(v[x + 2], 20);\n+    assert_eq!(*v.get(x + 2), 20);\n }"}, {"sha": "f9320f6b039238c5106df2fc68025d2bb895aa41", "filename": "src/test/run-pass/alloca-from-derived-tydesc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Falloca-from-derived-tydesc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Falloca-from-derived-tydesc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falloca-from-derived-tydesc.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n enum option<T> { some(T), none, }\n \n struct R<T> {v: Vec<option<T>> }"}, {"sha": "60a7101c8201db4ba3ce647db72c841e5cb1431b", "filename": "src/test/run-pass/assignability-trait.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-trait.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -12,6 +12,8 @@\n // making method calls, but only if there aren't any matches without\n // it.\n \n+use std::vec_ng::Vec;\n+\n trait iterable<A> {\n     fn iterate(&self, blk: |x: &A| -> bool) -> bool;\n }\n@@ -38,14 +40,14 @@ fn length<A, T: iterable<A>>(x: T) -> uint {\n }\n \n pub fn main() {\n-    let x = vec!(0,1,2,3);\n+    let x: Vec<int> = vec!(0,1,2,3);\n     // Call a method\n-    x.iterate(|y| { assert!(x[*y] == *y); true });\n+    x.iterate(|y| { assert!(*x.get(*y as uint) == *y); true });\n     // Call a parameterized function\n     assert_eq!(length(x.clone()), x.len());\n     // Call a parameterized function, with type arguments that require\n     // a borrow\n-    assert_eq!(length::<int, &[int]>(x), x.len());\n+    assert_eq!(length::<int, &[int]>(x.as_slice()), x.len());\n \n     // Now try it with a type that *needs* to be borrowed\n     let z = [0,1,2,3];"}, {"sha": "86e1b18a57416589e23af9a410c30c56857f078f", "filename": "src/test/run-pass/auto-ref-slice-plus-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -29,7 +29,7 @@ pub fn main() {\n     // NB: Associativity of ~, etc. in this context is surprising. These must be parenthesized\n \n     ([1]).test_imm();\n-    (vec!(1)).test_imm();\n+    (vec!(1)).as_slice().test_imm();\n     (&[1]).test_imm();\n     (\"test\").test_imm();\n     (~\"test\").test_imm();"}, {"sha": "82d2a58a556e605f24718b9ad43dcb4c94ca9c04", "filename": "src/test/run-pass/auto-ref-sliceable.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n trait Pushable<T> {\n     fn push_val(&mut self, t: T);\n }"}, {"sha": "db528c4fd08773ddfed725e44662de8f9a78d17a", "filename": "src/test/run-pass/autobind.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fautobind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fautobind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautobind.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f<T>(x: Vec<T> ) -> T { return x[0]; }\n+use std::vec_ng::Vec;\n+\n+fn f<T>(x: Vec<T>) -> T { return x.move_iter().next().unwrap(); }\n \n fn g(act: |Vec<int> | -> int) -> int { return act(vec!(1, 2, 3)); }\n "}, {"sha": "97ae7d8cdef1a0b2c569021e7bea07da8682a5e1", "filename": "src/test/run-pass/block-iter-1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,6 +10,8 @@\n \n // ignore-fast\n \n+use std::vec_ng::Vec;\n+\n fn iter_vec<T>(v: Vec<T> , f: |&T|) { for x in v.iter() { f(x); } }\n \n pub fn main() {"}, {"sha": "a8d65dbdeca8b6833937261c5789f6023e3e5436", "filename": "src/test/run-pass/block-iter-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,6 +10,8 @@\n \n // ignore-fast\n \n+use std::vec_ng::Vec;\n+\n fn iter_vec<T>(v: Vec<T> , f: |&T|) { for x in v.iter() { f(x); } }\n \n pub fn main() {"}, {"sha": "df334a6fcec55fdd23a01b25a1da9206b58627b8", "filename": "src/test/run-pass/borrow-by-val-method-receiver.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fborrow-by-val-method-receiver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fborrow-by-val-method-receiver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrow-by-val-method-receiver.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n trait Foo {\n     fn foo(self);\n }\n@@ -18,5 +20,5 @@ impl<'a> Foo for &'a [int] {\n \n pub fn main() {\n     let items = vec!( 3, 5, 1, 2, 4 );\n-    items.foo();\n+    items.as_slice().foo();\n }"}, {"sha": "67233c29258b1e73c08b24cd3981ca7b9582ffec", "filename": "src/test/run-pass/borrowck-binding-mutbl.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fborrowck-binding-mutbl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fborrowck-binding-mutbl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-binding-mutbl.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n struct F { f: Vec<int> }\n \n fn impure(_v: &[int]) {\n@@ -18,7 +20,7 @@ pub fn main() {\n \n     match x {\n       F {f: ref mut v} => {\n-        impure(*v);\n+        impure(v.as_slice());\n       }\n     }\n }"}, {"sha": "88230cbb1c434a2b78bf4a2ec868d6fab3880be2", "filename": "src/test/run-pass/borrowck-mut-uniq.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::mem::swap;\n+use std::vec_ng::Vec;\n \n struct Ints {sum: ~int, values: Vec<int> }\n \n@@ -22,7 +23,7 @@ fn add_int(x: &mut Ints, v: int) {\n \n fn iter_ints(x: &Ints, f: |x: &int| -> bool) -> bool {\n     let l = x.values.len();\n-    range(0u, l).advance(|i| f(&x.values[i]))\n+    range(0u, l).advance(|i| f(x.values.get(i)))\n }\n \n pub fn main() {"}, {"sha": "0b46f49ad93609172792d09ff093fd38d4fd6974", "filename": "src/test/run-pass/borrowck-mut-vec-as-imm-slice.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,14 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n fn want_slice(v: &[int]) -> int {\n     let mut sum = 0;\n     for i in v.iter() { sum += *i; }\n     sum\n }\n \n fn has_mut_vec(v: Vec<int> ) -> int {\n-    want_slice(v)\n+    want_slice(v.as_slice())\n }\n \n pub fn main() {"}, {"sha": "bb346bccd515219d146f22c18ff9f7e27a4890c2", "filename": "src/test/run-pass/borrowck-root-while-cond-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fborrowck-root-while-cond-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fborrowck-root-while-cond-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-root-while-cond-2.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,6 +10,8 @@\n \n #[feature(managed_boxes)];\n \n+use std::vec_ng::Vec;\n+\n struct F { f: @G }\n struct G { g: Vec<int> }\n "}, {"sha": "03ea9178eb90c82df23d0a71b684363ee88b97b3", "filename": "src/test/run-pass/borrowck-root-while-cond.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fborrowck-root-while-cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fborrowck-root-while-cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-root-while-cond.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,6 +10,8 @@\n \n #[feature(managed_boxes)];\n \n+use std::vec_ng::Vec;\n+\n fn borrow<'r,T>(x: &'r T) -> &'r T {x}\n \n struct Rec { f: @int }"}, {"sha": "34f6e5ab8fd83404340048db6d657430ee2d7fe0", "filename": "src/test/run-pass/call-closure-from-overloaded-op.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fcall-closure-from-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fcall-closure-from-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcall-closure-from-overloaded-op.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,10 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n fn foo() -> int { 22 }\n \n pub fn main() {\n-    let mut x: vec!(extern \"Rust\" fn() -> int) = Vec::new();\n+    let mut x: Vec<extern \"Rust\" fn() -> int> = Vec::new();\n     x.push(foo);\n-    assert_eq!((x[0])(), 22);\n+    assert_eq!((*x.get(0))(), 22);\n }"}, {"sha": "02ba8b900be728350f3f47e82935f1ae7f67e88f", "filename": "src/test/run-pass/class-poly-methods.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n struct cat<U> {\n     info : Vec<U> ,\n     meows : uint,"}, {"sha": "2911df412d817bf508d028cdab87db762966ad0e", "filename": "src/test/run-pass/cleanup-rvalue-scopes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-scopes.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -15,6 +15,7 @@\n #[feature(macro_rules)];\n \n use std::ops::Drop;\n+use std::vec_ng::Vec;\n \n static mut FLAGS: u64 = 0;\n \n@@ -116,7 +117,6 @@ pub fn main() {\n     end_of_block!(_, { { check_flags(0); &AddFlags(1) } });\n     end_of_block!(_, &((Box { f: AddFlags(1) }).f));\n     end_of_block!(_, &(([AddFlags(1)])[0]));\n-    end_of_block!(_, &((&vec!(AddFlags(1)))[0]));\n \n     // LHS does not create a ref binding, so temporary lives as long\n     // as statement, and we do not move the AddFlags out:"}, {"sha": "7bf7920fe070df21927b9c0bf4104b724d84e10c", "filename": "src/test/run-pass/cleanup-rvalue-temp-during-incomplete-alloc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-temp-during-incomplete-alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-temp-during-incomplete-alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-temp-during-incomplete-alloc.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -25,6 +25,7 @@\n // scenario worth testing.\n \n use std::task;\n+use std::vec_ng::Vec;\n \n enum Conzabble {\n     Bickwick(Foo)\n@@ -41,7 +42,7 @@ fn get_bar(x: uint) -> Vec<uint> { vec!(x * 2) }\n pub fn fails() {\n     let x = 2;\n     let mut y = Vec::new();\n-    y.push(~Bickwick(do_it(get_bar(x))));\n+    y.push(~Bickwick(do_it(get_bar(x).as_slice())));\n }\n \n pub fn main() {"}, {"sha": "937cb0f0dac84d17dc922c1b5d7cedc31f15496b", "filename": "src/test/run-pass/coerce-reborrow-imm-vec-rcvr.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,16 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n fn bar(v: &mut [uint]) -> Vec<uint> {\n-    v.to_owned()\n+    Vec::from_slice(v)\n }\n \n fn bip(v: &[uint]) -> Vec<uint> {\n-    v.to_owned()\n+    Vec::from_slice(v)\n }\n \n pub fn main() {\n     let mut the_vec = vec!(1u, 2, 3, 100);\n-    assert_eq!(the_vec.clone(), bar(the_vec));\n-    assert_eq!(the_vec.clone(), bip(the_vec));\n+    assert_eq!(the_vec.clone(), bar(the_vec.as_mut_slice()));\n+    assert_eq!(the_vec.clone(), bip(the_vec.as_slice()));\n }"}, {"sha": "be8bb861345b955ac9e0d1fda0a3ea50f6da6d11", "filename": "src/test/run-pass/coerce-reborrow-mut-vec-arg.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n fn reverse(v: &mut [uint]) {\n     v.reverse();\n }\n@@ -20,6 +22,6 @@ fn bar(v: &mut [uint]) {\n \n pub fn main() {\n     let mut the_vec = vec!(1, 2, 3, 100);\n-    bar(the_vec);\n+    bar(the_vec.as_mut_slice());\n     assert_eq!(the_vec, vec!(100, 3, 2, 1));\n }"}, {"sha": "686b8545b5ef8964a98660d87afbf2dec65da9a7", "filename": "src/test/run-pass/coerce-reborrow-mut-vec-rcvr.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n fn bar(v: &mut [uint]) {\n     v.reverse();\n     v.reverse();\n@@ -16,6 +18,6 @@ fn bar(v: &mut [uint]) {\n \n pub fn main() {\n     let mut the_vec = vec!(1, 2, 3, 100);\n-    bar(the_vec);\n+    bar(the_vec.as_mut_slice());\n     assert_eq!(the_vec, vec!(100, 3, 2, 1));\n }"}, {"sha": "5470b1d6615009b88d8799a51bd892525054e601", "filename": "src/test/run-pass/const-enum-vec-repeat.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Frun-pass%2Fconst-enum-vec-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Frun-pass%2Fconst-enum-vec-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-vec-repeat.rs?ref=579eb2400b3cb5d9cf03a5c8792d63630489193a", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-enum State { ST_NULL, ST_WHITESPACE = 1 }\n-\n-pub fn main() {\n-    vec!(ST_NULL, ..(ST_WHITESPACE as uint));\n-}"}, {"sha": "6a05dafb17cec30130ca4a53ee69eb97b1d0611b", "filename": "src/test/run-pass/deep-vector.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fdeep-vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fdeep-vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdeep-vector.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,8 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-test\n+// ignore-fast\n+//\n+// Too big for our poor macro infrastructure.\n+\n pub fn main() {\n-    let _x = ~[\n+    let _x = vec!(\n         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -2008,5 +2013,5 @@ pub fn main() {\n         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n-    ];\n+    );\n }"}, {"sha": "615e94c3f4e59fc1dc70de7319dcfbb0da0e4d71", "filename": "src/test/run-pass/deep-vector2.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fdeep-vector2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fdeep-vector2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdeep-vector2.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,8 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-test\n+// ignore-fast\n+//\n+// Too big for our poor macro infrastructure.\n+\n pub fn main() {\n-    let _x = ~[\n+    let _x = vec!(\n         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n@@ -8008,5 +8013,5 @@ pub fn main() {\n         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n-    ];\n+    );\n }"}, {"sha": "aafea1ef1ef0ea64630aad3eb11e33b3564d51f8", "filename": "src/test/run-pass/empty-mutable-vec.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fempty-mutable-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fempty-mutable-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-mutable-vec.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,4 +10,6 @@\n \n #[allow(unused_mut)];\n \n+use std::vec_ng::Vec;\n+\n pub fn main() { let mut _v: Vec<int> = Vec::new(); }"}, {"sha": "c8a207cd4bd2df4c40a60c676c798fbc0bc8c69f", "filename": "src/test/run-pass/expr-fn.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fexpr-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fexpr-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-fn.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,14 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n fn test_int() {\n     fn f() -> int { 10 }\n     assert_eq!(f(), 10);\n }\n \n fn test_vec() {\n     fn f() -> Vec<int> { vec!(10, 11) }\n-    assert_eq!(f()[1], 11);\n+    let vect = f();\n+    assert_eq!(*vect.get(1), 11);\n }\n \n fn test_generic() {"}, {"sha": "46ba63e452d5c898ac7db18ba0d7274c267f6315", "filename": "src/test/run-pass/expr-match-fail.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fexpr-match-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fexpr-match-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-fail.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,14 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n fn test_simple() {\n     let r = match true { true => { true } false => { fail!() } };\n     assert_eq!(r, true);\n }\n \n fn test_box() {\n     let r = match true { true => { vec!(10) } false => { fail!() } };\n-    assert_eq!(r[0], 10);\n+    assert_eq!(*r.get(0), 10);\n }\n \n pub fn main() { test_simple(); test_box(); }"}, {"sha": "a111a878dddcd6b0b558b9299faf653696dd5e0c", "filename": "src/test/run-pass/expr-repeat-vstore.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Frun-pass%2Fexpr-repeat-vstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Frun-pass%2Fexpr-repeat-vstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-repeat-vstore.rs?ref=579eb2400b3cb5d9cf03a5c8792d63630489193a", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-pub fn main() {\n-    let v: Vec<int> = vec!( 1, ..5 );\n-    println!(\"{}\", v[0]);\n-    println!(\"{}\", v[1]);\n-    println!(\"{}\", v[2]);\n-    println!(\"{}\", v[3]);\n-    println!(\"{}\", v[4]);\n-}"}, {"sha": "bc9f1f642d283205d1fd86464d12bd95fff1be1a", "filename": "src/test/run-pass/for-loop-fail.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Ffor-loop-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Ffor-loop-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffor-loop-fail.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,4 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n pub fn main() { let x: Vec<int> = Vec::new(); for _ in x.iter() { fail!(\"moop\"); } }"}, {"sha": "9aed300c5648cc6e995b96bcf3d20b70549913e2", "filename": "src/test/run-pass/foreach-nested.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,19 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-\n+use std::vec_ng::Vec;\n \n fn two(it: |int|) { it(0); it(1); }\n \n pub fn main() {\n     let mut a: Vec<int> = vec!(-1, -1, -1, -1);\n     let mut p: int = 0;\n     two(|i| {\n-        two(|j| { a[p] = 10 * i + j; p += 1; })\n+        two(|j| { *a.get_mut(p as uint) = 10 * i + j; p += 1; })\n     });\n-    assert_eq!(a[0], 0);\n-    assert_eq!(a[1], 1);\n-    assert_eq!(a[2], 10);\n-    assert_eq!(a[3], 11);\n+    assert_eq!(*a.get(0), 0);\n+    assert_eq!(*a.get(1), 1);\n+    assert_eq!(*a.get(2), 10);\n+    assert_eq!(*a.get(3), 11);\n }"}, {"sha": "f0dcc5e2809b07546b47e61c2f49864216624085", "filename": "src/test/run-pass/generic-static-methods.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n trait vec_utils<T> {\n     fn map_<U>(x: &Self, f: |&T| -> U) -> Vec<U> ;\n }"}, {"sha": "314d045145bb9f7d14998fa8008a5eaf564fe69c", "filename": "src/test/run-pass/getopts_ref.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -13,12 +13,13 @@\n extern crate getopts;\n \n use getopts::{optopt, getopts};\n+use std::vec_ng::Vec;\n \n pub fn main() {\n     let args = Vec::new();\n     let opts = vec!(optopt(\"b\", \"\", \"something\", \"SMTHNG\"));\n \n-    match getopts(args, opts) {\n+    match getopts(args.as_slice(), opts.as_slice()) {\n         Ok(ref m)  =>\n             assert!(!m.opt_present(\"b\")),\n         Err(ref f) => fail!(\"{:?}\", (*f).clone().to_err_msg())"}, {"sha": "c6fa702aeca4cc1a5f2d14661e0958d12bd73fcb", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -14,6 +14,8 @@\n \n extern crate collections;\n \n+use std::vec_ng::Vec;\n+\n /**\n    A somewhat reduced test case to expose some Valgrind issues.\n \n@@ -26,6 +28,7 @@ mod map_reduce {\n     use collections::HashMap;\n     use std::str;\n     use std::task;\n+    use std::vec_ng::Vec;\n \n     pub type putter<'a> = 'a |~str, ~str|;\n \n@@ -52,7 +55,7 @@ mod map_reduce {\n             }\n             let (tx, rx) = channel();\n             println!(\"sending find_reducer\");\n-            ctrl.send(find_reducer(key.as_bytes().to_owned(), tx));\n+            ctrl.send(find_reducer(Vec::from_slice(key.as_bytes()), tx));\n             println!(\"receiving\");\n             let c = rx.recv();\n             println!(\"{:?}\", c);\n@@ -83,7 +86,8 @@ mod map_reduce {\n               mapper_done => { num_mappers -= 1; }\n               find_reducer(k, cc) => {\n                 let mut c;\n-                match reducers.find(&str::from_utf8(k).unwrap().to_owned()) {\n+                match reducers.find(&str::from_utf8(k.as_slice()).unwrap()\n+                                                                 .to_owned()) {\n                   Some(&_c) => { c = _c; }\n                   None => { c = 0; }\n                 }"}, {"sha": "aadb372fa12a84aa3196a5233bab9f04bd61e6e0", "filename": "src/test/run-pass/html-literals.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fhtml-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fhtml-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhtml-literals.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -12,6 +12,8 @@\n \n #[feature(macro_rules)];\n \n+use std::vec_ng::Vec;\n+\n /*\n \n This is an HTML parser written as a macro. It's all CPS, and we have"}, {"sha": "7e9afc4de564f531b83d07c53297d5bbb4e5a2b3", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -182,7 +182,7 @@ fn test_write() {\n // can do with them just yet (to test the output)\n fn test_print() {\n     print!(\"hi\");\n-    print!(\"{:?}\", ~[0u8]);\n+    print!(\"{:?}\", vec!(0u8));\n     println!(\"hello\");\n     println!(\"this is a {}\", \"test\");\n     println!(\"{foo}\", foo=\"bar\");"}, {"sha": "aeb2fdae9020390774c07337b07d66b701023fa8", "filename": "src/test/run-pass/import-glob-crate.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -13,10 +13,12 @@\n #[feature(globs)];\n #[allow(dead_assignment)];\n \n-use std::slice::*;\n+use std::mem::*;\n \n pub fn main() {\n-    let mut v = from_elem(0u, 0);\n-    v = append(v, [4, 2]);\n-    assert_eq!(from_fn(2, |i| 2*(i+1)), vec!(2, 4));\n+    assert_eq!(size_of::<u8>(), 1);\n+    let (mut x, mut y) = (1, 2);\n+    swap(&mut x, &mut y);\n+    assert_eq!(x, 2);\n+    assert_eq!(x, 1);\n }"}, {"sha": "a3d1be5b4f12fcd76ea484ac9476dad6a5201ff0", "filename": "src/test/run-pass/infer-fn-tail-expr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Finfer-fn-tail-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Finfer-fn-tail-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finfer-fn-tail-expr.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,6 +10,8 @@\n \n // issue #680\n \n+use std::vec_ng::Vec;\n+\n fn f() -> Vec<int> { Vec::new() }\n \n pub fn main() { }"}, {"sha": "e0d0f3409eea05ae814857f2b8f1d14d8d9671c6", "filename": "src/test/run-pass/integral-indexing.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fintegral-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fintegral-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintegral-indexing.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,19 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-\n+use std::vec_ng::Vec;\n \n // This is a testcase for issue #94.\n pub fn main() {\n     let v: Vec<int> = vec!(0, 1, 2, 3, 4, 5);\n     let s: ~str = ~\"abcdef\";\n-    assert_eq!(v[3u], 3);\n-    assert_eq!(v[3u8], 3);\n-    assert_eq!(v[3i8], 3);\n-    assert_eq!(v[3u32], 3);\n-    assert_eq!(v[3i32], 3);\n-    println!(\"{}\", v[3u8]);\n+    assert_eq!(v.as_slice()[3u], 3);\n+    assert_eq!(v.as_slice()[3u8], 3);\n+    assert_eq!(v.as_slice()[3i8], 3);\n+    assert_eq!(v.as_slice()[3u32], 3);\n+    assert_eq!(v.as_slice()[3i32], 3);\n+    println!(\"{}\", v.as_slice()[3u8]);\n     assert_eq!(s[3u], 'd' as u8);\n     assert_eq!(s[3u8], 'd' as u8);\n     assert_eq!(s[3i8], 'd' as u8);"}, {"sha": "ef66a1e3a67e38606a0c89119f1ee6bafc030313", "filename": "src/test/run-pass/issue-1821.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-1821.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-1821.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1821.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -9,7 +9,10 @@\n // except according to those terms.\n \n // Issue #1821 - Don't recurse trying to typecheck this\n+\n+use std::vec_ng::Vec;\n+\n enum t {\n-    foo(vec!(t))\n+    foo(Vec<t>)\n }\n pub fn main() {}"}, {"sha": "33cac672b3933b392da9817ef5f44e62aa8bd2c4", "filename": "src/test/run-pass/issue-2502.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-2502.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-2502.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2502.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n struct font<'a> {\n     fontbuf: &'a Vec<u8> ,\n }"}, {"sha": "d5cf80d24406925480701e47bc1dbac4b1987cba", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -16,6 +16,7 @@ extern crate serialize;\n use collections::HashMap;\n use serialize::json;\n use std::option;\n+use std::vec_ng::Vec;\n \n enum object {\n     bool_value(bool),\n@@ -60,9 +61,9 @@ fn add_interfaces(store: int, managed_ip: ~str, device: HashMap<~str, json::Json\n     {\n         &json::List(ref interfaces) =>\n         {\n-          interfaces.map(|interface| {\n+          interfaces.iter().map(|interface| {\n                 add_interface(store, managed_ip.clone(), (*interface).clone())\n-          })\n+          }).collect()\n         }\n         _ =>\n         {"}, {"sha": "8093c08816562f12f0611f699e227cfebe59f341", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -16,6 +16,7 @@\n \n use std::io;\n use std::fmt;\n+use std::vec_ng::Vec;\n \n enum square {\n     bot,\n@@ -60,7 +61,8 @@ fn square_from_char(c: char) -> square {\n     }\n }\n \n-fn read_board_grid<rdr:'static + io::Reader>(mut input: rdr) -> vec!(vec!(square)) {\n+fn read_board_grid<rdr:'static + io::Reader>(mut input: rdr)\n+                   -> Vec<Vec<square>> {\n     let mut input: &mut io::Reader = &mut input;\n     let mut grid = Vec::new();\n     let mut line = [0, ..10];\n@@ -70,7 +72,7 @@ fn read_board_grid<rdr:'static + io::Reader>(mut input: rdr) -> vec!(vec!(square\n         row.push(square_from_char(*c as char))\n     }\n     grid.push(row);\n-    let width = grid[0].len();\n+    let width = grid.get(0).len();\n     for row in grid.iter() { assert!(row.len() == width) }\n     grid\n }"}, {"sha": "c88f8b42d4242fa35533f21619c40b6409508f46", "filename": "src/test/run-pass/issue-2989.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-2989.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-2989.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2989.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -24,7 +24,7 @@ fn to_bools(bitv: Storage) -> Vec<bool> {\n     Vec::from_fn(8, |i| {\n         let w = i / 64;\n         let b = i % 64;\n-        let x = 1u64 & (bitv.storage[w] >> b);\n+        let x = 1u64 & (*bitv.storage.get(w) >> b);\n         x == 1u64\n     })\n }\n@@ -36,7 +36,7 @@ pub fn main() {\n     let bools2 = to_bools(Storage{storage: vec!(0b01100100)});\n \n     for i in range(0u, 8) {\n-        println!(\"{} => {} vs {}\", i, bools[i], bools2[i]);\n+        println!(\"{} => {} vs {}\", i, *bools.get(i), *bools2.get(i));\n     }\n \n     assert_eq!(bools, bools2);"}, {"sha": "d2acf66003d7d2468d32e0ce28161fcd9d119d71", "filename": "src/test/run-pass/issue-3052.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-3052.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-3052.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3052.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n type Connection = 'static |Vec<u8> |;\n \n fn f() -> Option<Connection> {"}, {"sha": "fb4d7cedd4b0bb8e8b4c3de8bb652315f33705aa", "filename": "src/test/run-pass/issue-3389.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-3389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-3389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3389.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n struct trie_node {\n     content: Vec<~str> ,\n     children: Vec<trie_node> ,"}, {"sha": "a107670075d238b29e43bcd85e213d4753b67b52", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -19,9 +19,11 @@\n \n // Extern mod controls linkage. Use controls the visibility of names to modules that are\n // already linked in. Using WriterUtil allows us to use the write_line method.\n+\n use std::str;\n use std::slice;\n use std::fmt;\n+use std::vec_ng::Vec;\n \n // Represents a position on a canvas.\n struct Point {\n@@ -62,9 +64,10 @@ impl Drop for AsciiArt {\n fn AsciiArt(width: uint, height: uint, fill: char) -> AsciiArt {\n     // Use an anonymous function to build a vector of vectors containing\n     // blank characters for each position in our canvas.\n-    let lines = slice::build(Some(height), |push| {\n-        for _ in range(0, height) { push(slice::from_elem(width, '.')); }\n-    });\n+    let mut lines = Vec::new();\n+    for _ in range(0, height) {\n+        lines.push(Vec::from_elem(width, '.'));\n+    }\n \n     // Rust code often returns values by omitting the trailing semi-colon\n     // instead of using an explicit return statement.\n@@ -85,8 +88,8 @@ impl AsciiArt {\n                 // element is:\n                 // 1) potentially large\n                 // 2) needs to be modified\n-                let row = &mut self.lines[v];\n-                row[h] = self.fill;\n+                let row = self.lines.get_mut(v);\n+                *row.get_mut(h) = self.fill;\n             }\n         }\n     }\n@@ -97,7 +100,7 @@ impl AsciiArt {\n impl fmt::Show for AsciiArt {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // Convert each line into a string.\n-        let lines = self.lines.map(|line| str::from_chars(*line));\n+        let lines = self.lines.map(|line| str::from_chars(line.as_slice()));\n \n         // Concatenate the lines together using a new-line.\n         write!(f.buf, \"{}\", lines.connect(\"\\n\"))"}, {"sha": "d27de2ea0ca4c9c7e234f203cc6810e5ca46cf7e", "filename": "src/test/run-pass/issue-3609.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3609.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::task;\n+use std::vec_ng::Vec;\n \n type RingBuffer = Vec<f64> ;\n type SamplesFn = proc(samples: &RingBuffer);\n@@ -23,7 +24,7 @@ fn foo(name: ~str, samples_chan: Sender<Msg>) {\n         let mut samples_chan = samples_chan;\n         let callback: SamplesFn = proc(buffer) {\n             for i in range(0u, buffer.len()) {\n-                println!(\"{}: {}\", i, buffer[i])\n+                println!(\"{}: {}\", i, *buffer.get(i))\n             }\n         };\n         samples_chan.send(GetSamples(name.clone(), callback));"}, {"sha": "7fb6b4664794ae65cbf2b166c641c7aba91ddf8d", "filename": "src/test/run-pass/issue-3991.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-3991.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-3991.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3991.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,13 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n struct HasNested {\n     nest: Vec<Vec<int> > ,\n }\n \n impl HasNested {\n     fn method_push_local(&mut self) {\n-        self.nest[0].push(0);\n+        self.nest.get_mut(0).push(0);\n     }\n }\n "}, {"sha": "13285179df8ca8ca00d023e72b941b7418bbbc48", "filename": "src/test/run-pass/issue-4036.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-4036.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-4036.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4036.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -14,7 +14,9 @@\n // byproducts in vtable records.\n \n extern crate serialize;\n+\n use serialize::{json, Decodable};\n+use std::vec_ng::Vec;\n \n pub fn main() {\n     let json = json::from_str(\"[1]\").unwrap();"}, {"sha": "56461b647d87a2597694a5cec7ffb7989768b940", "filename": "src/test/run-pass/issue-5708.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-5708.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-5708.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5708.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -18,6 +18,8 @@ This does not occur with concrete types, only with references\n to traits.\n */\n \n+use std::vec_ng::Vec;\n+\n // original\n trait Inner {\n     fn print(&self);"}, {"sha": "ce87b0adde5f40d7d2c0c2a081f2bff19c33ec1e", "filename": "src/test/run-pass/issue-6153.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-6153.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-6153.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6153.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n fn swap(f: |Vec<int> | -> Vec<int> ) -> Vec<int> {\n     let x = vec!(1, 2, 3);\n     f(x)"}, {"sha": "66ddc1118d0ddccc4a9106042dadf5dbe66e828c", "filename": "src/test/run-pass/issue-8898.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8898.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -11,22 +11,19 @@\n #[feature(managed_boxes)];\n \n fn assert_repr_eq<T>(obj : T, expected : ~str) {\n-\n     assert_eq!(expected, format!(\"{:?}\", obj));\n }\n \n pub fn main() {\n     let abc = [1, 2, 3];\n     let tf = [true, false];\n     let x  = [(), ()];\n-    let y = vec!((), ());\n     let slice = x.slice(0,1);\n     let z = @x;\n \n     assert_repr_eq(abc, ~\"[1, 2, 3]\");\n     assert_repr_eq(tf, ~\"[true, false]\");\n     assert_repr_eq(x, ~\"[(), ()]\");\n-    assert_repr_eq(y, ~\"~[(), ()]\");\n     assert_repr_eq(slice, ~\"&[()]\");\n     assert_repr_eq(&x, ~\"&[(), ()]\");\n     assert_repr_eq(z, ~\"@[(), ()]\");"}, {"sha": "32ec1e674db7f9449aa9f263d600a858b1d19ad2", "filename": "src/test/run-pass/issue-9382.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-9382.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fissue-9382.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9382.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -16,6 +16,8 @@\n // from a vector to a slice. The drop glue was being invoked on\n // the temporary slice with a wrong type, triggering an LLVM assert.\n \n+use std::vec_ng::Vec;\n+\n struct Thing1<'a> {\n     baz: &'a [~int],\n     bar: ~u64,\n@@ -32,15 +34,15 @@ pub fn main() {\n         bar: ~32,\n     };\n     Thing1 {\n-        baz: Vec::new(),\n+        baz: Vec::new().as_slice(),\n         bar: ~32,\n     };\n     let _t2_fixed = Thing2 {\n         baz: &[],\n         bar: 32,\n     };\n     Thing2 {\n-        baz: Vec::new(),\n+        baz: Vec::new().as_slice(),\n         bar: 32,\n     };\n }"}, {"sha": "f215958493fb0fb7add6061b824b1f99450043a0", "filename": "src/test/run-pass/ivec-add.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Frun-pass%2Fivec-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Frun-pass%2Fivec-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-add.rs?ref=579eb2400b3cb5d9cf03a5c8792d63630489193a", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn double<T:Clone>(a: T) -> Vec<T> { return vec!(a.clone()) + vec!(a); }\n-\n-fn double_int(a: int) -> Vec<int> { return vec!(a) + vec!(a); }\n-\n-pub fn main() {\n-    let mut d = double(1);\n-    assert_eq!(d[0], 1);\n-    assert_eq!(d[1], 1);\n-\n-    d = double_int(1);\n-    assert_eq!(d[0], 1);\n-    assert_eq!(d[1], 1);\n-}"}, {"sha": "9c8dd152e25b5e0935ec6d9a3972b9107bdac1bf", "filename": "src/test/run-pass/ivec-pass-by-value.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fivec-pass-by-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fivec-pass-by-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-pass-by-value.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,5 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n fn f(_a: Vec<int> ) { }\n pub fn main() { f(vec!(1, 2, 3, 4, 5)); }"}, {"sha": "1d617de30ea723e74b73c63a209e81c9556ea318", "filename": "src/test/run-pass/ivec-tag.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-tag.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::task;\n+use std::vec_ng::Vec;\n \n fn producer(tx: &Sender<Vec<u8>>) {\n     tx.send("}, {"sha": "05941b0142c8a428259108f8740d8de9084efed9", "filename": "src/test/run-pass/lambda-infer-unresolved.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -11,6 +11,8 @@\n // This should typecheck even though the type of e is not fully\n // resolved when we finish typechecking the ||.\n \n+use std::vec_ng::Vec;\n+\n struct Refs { refs: Vec<int> , n: int }\n \n pub fn main() {"}, {"sha": "22a0c9005bafc3dbacf37501f5e7eb40ec6fde0f", "filename": "src/test/run-pass/liveness-move-in-loop.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fliveness-move-in-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fliveness-move-in-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fliveness-move-in-loop.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n fn take(x: int) -> int {x}\n \n fn the_loop() {"}, {"sha": "c912fd68a6cfe8ec62941508863d71a9ef2e39ea", "filename": "src/test/run-pass/log-str.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Frun-pass%2Flog-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Frun-pass%2Flog-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-str.rs?ref=579eb2400b3cb5d9cf03a5c8792d63630489193a", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::repr;\n-\n-pub fn main() {\n-    let act = repr::repr_to_str(&vec!(1, 2, 3));\n-    assert_eq!(~\"~[1, 2, 3]\", act);\n-\n-    let act = format!(\"{:?}/{:6?}\", vec!(1, 2, 3), ~\"hi\");\n-    assert_eq!(act, ~\"~[1, 2, 3]/~\\\"hi\\\" \");\n-}"}, {"sha": "38952fc4daad27f9578d4eda7ead27ea27e5ddef", "filename": "src/test/run-pass/match-vec-rvalue.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fmatch-vec-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fmatch-vec-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-vec-rvalue.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,13 +10,15 @@\n \n // Tests that matching rvalues with drops does not crash.\n \n+use std::vec_ng::Vec;\n+\n pub fn main() {\n     match vec!(1, 2, 3) {\n         x => {\n             assert_eq!(x.len(), 3);\n-            assert_eq!(x[0], 1);\n-            assert_eq!(x[1], 2);\n-            assert_eq!(x[2], 3);\n+            assert_eq!(*x.get(0), 1);\n+            assert_eq!(*x.get(1), 2);\n+            assert_eq!(*x.get(2), 3);\n         }\n     }\n }"}, {"sha": "182aa94700658b9aca998019f9d33d4c6260ceb1", "filename": "src/test/run-pass/monad.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fmonad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fmonad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonad.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,6 +10,8 @@\n \n // ignore-fast\n \n+use std::vec_ng::Vec;\n+\n trait vec_monad<A> {\n     fn bind<B>(&self, f: |&A| -> Vec<B> ) -> Vec<B> ;\n }"}, {"sha": "34e169f3d61a925acb39f09d0f63c7fa4232ae9f", "filename": "src/test/run-pass/move-arg-2-unique.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fmove-arg-2-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fmove-arg-2-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-arg-2-unique.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn test(foo: ~Vec<int> ) { assert!((foo[0] == 10)); }\n+use std::vec_ng::Vec;\n+\n+fn test(foo: ~Vec<int> ) { assert!((*foo.get(0) == 10)); }\n \n pub fn main() {\n     let x = ~vec!(10);"}, {"sha": "89316c37a3edaf5e3dd49334c74189b33f6e6d8a", "filename": "src/test/run-pass/move-arg-2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fmove-arg-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fmove-arg-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-arg-2.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,7 +10,9 @@\n \n #[feature(managed_boxes)];\n \n-fn test(foo: @Vec<int> ) { assert!((foo[0] == 10)); }\n+use std::vec_ng::Vec;\n+\n+fn test(foo: @Vec<int> ) { assert!((*foo.get(0) == 10)); }\n \n pub fn main() {\n     let x = @vec!(10);"}, {"sha": "28dd89edd629d79d758dc2c49bc5090342be3bc7", "filename": "src/test/run-pass/mutable-alias-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn grow(v: &mut Vec<int>) {\n+fn grow(v: &mut Vec<int> ) {\n     v.push(1);\n }\n "}, {"sha": "1f4196ef06f847b9c06bcf312ccfbcac72a2740d", "filename": "src/test/run-pass/mutable-vec-drop.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fmutable-vec-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fmutable-vec-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-vec-drop.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -11,6 +11,8 @@\n #[feature(managed_boxes)];\n #[allow(unused_mut)];\n \n+use std::vec_ng::Vec;\n+\n struct Pair { a: int, b: int}\n \n pub fn main() {"}, {"sha": "3d4639b2506a05ce0f22bdd9ae8b641959441cbc", "filename": "src/test/run-pass/newtype-polymorphic.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n #[deriving(Clone)]\n struct myvec<X>(Vec<X> );\n \n@@ -18,13 +20,15 @@ fn myvec_deref<X:Clone>(mv: myvec<X>) -> Vec<X> {\n \n fn myvec_elt<X>(mv: myvec<X>) -> X {\n     let myvec(v) = mv;\n-    return v[0];\n+    return v.move_iter().next().unwrap();\n }\n \n pub fn main() {\n     let mv = myvec(vec!(1, 2, 3));\n-    assert_eq!(myvec_deref(mv.clone())[1], 2);\n+    let mv_clone = mv.clone();\n+    let mv_clone = myvec_deref(mv_clone);\n+    assert_eq!(*mv_clone.get(1), 2);\n     assert_eq!(myvec_elt(mv.clone()), 1);\n     let myvec(v) = mv;\n-    assert_eq!(v[2], 3);\n+    assert_eq!(*v.get(2), 3);\n }"}, {"sha": "c071983fdf334333d51755e77236da28654137ce", "filename": "src/test/run-pass/nullable-pointer-iotareduction.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -11,6 +11,7 @@\n #[feature(macro_rules)];\n \n use std::{option, cast};\n+use std::vec_ng::Vec;\n \n // Iota-reduction is a rule in the Calculus of (Co-)Inductive Constructions,\n // which \"says that a destructor applied to an object built from a constructor"}, {"sha": "75a98913c971a49e26eccf90ac734dc230109427", "filename": "src/test/run-pass/nullable-pointer-size.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -11,6 +11,7 @@\n #[feature(macro_rules)];\n \n use std::mem;\n+use std::vec_ng::Vec;\n \n enum E<T> { Thing(int, T), Nothing((), ((), ()), [i8, ..0]) }\n struct S<T>(int, T);\n@@ -41,6 +42,5 @@ pub fn main() {\n     check_type!(~int);\n     check_type!(@int);\n     check_type!(~str);\n-    check_type!(Vec<int> );\n     check_type!(extern fn());\n }"}, {"sha": "ec284b24dbd1a9b70dea0b19cb569f35f96d953b", "filename": "src/test/run-pass/objects-owned-object-borrowed-method-header.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-header.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-header.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-header.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -12,6 +12,8 @@\n \n #[feature(managed_boxes)];\n \n+use std::vec_ng::Vec;\n+\n // Test invoked `&self` methods on owned objects where the values\n // closed over contain managed values. This implies that the ~ boxes\n // will have headers that must be skipped over.\n@@ -31,13 +33,13 @@ impl FooTrait for BarStruct {\n }\n \n pub fn main() {\n-    let foos: vec!( ~FooTrait: ) = vec!(\n+    let foos: Vec<~FooTrait:> = vec!(\n         ~BarStruct{ x: @0 } as ~FooTrait:,\n         ~BarStruct{ x: @1 } as ~FooTrait:,\n         ~BarStruct{ x: @2 } as ~FooTrait:\n     );\n \n     for i in range(0u, foos.len()) {\n-        assert_eq!(i, foos[i].foo());\n+        assert_eq!(i, foos.get(i).foo());\n     }\n }"}, {"sha": "13258bed80f6c1761fe79cef92e1d1f6e57cf60a", "filename": "src/test/run-pass/objects-owned-object-borrowed-method-headerless.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-headerless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-headerless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-headerless.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -12,6 +12,8 @@\n // closed over do not contain managed values, and thus the ~ boxes do\n // not have headers.\n \n+use std::vec_ng::Vec;\n+\n trait FooTrait {\n     fn foo(&self) -> uint;\n }\n@@ -27,13 +29,13 @@ impl FooTrait for BarStruct {\n }\n \n pub fn main() {\n-    let foos: vec!( ~FooTrait ) = vec!(\n+    let foos: Vec<~FooTrait> = vec!(\n         ~BarStruct{ x: 0 } as ~FooTrait,\n         ~BarStruct{ x: 1 } as ~FooTrait,\n         ~BarStruct{ x: 2 } as ~FooTrait\n     );\n \n     for i in range(0u, foos.len()) {\n-        assert_eq!(i, foos[i].foo());\n+        assert_eq!(i, foos.get(i).foo());\n     }\n }"}, {"sha": "c918202b31c1f21a1aebcdfa7226636e7a867799", "filename": "src/test/run-pass/overload-index-operator.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -12,6 +12,7 @@\n // takes its argument *by reference*.\n \n use std::ops::Index;\n+use std::vec_ng::Vec;\n \n struct AssociationList<K,V> {\n     pairs: Vec<AssociationPair<K,V>> }"}, {"sha": "43f68b42329105bbceaf85a3446822985d0947ac", "filename": "src/test/run-pass/overloaded-deref.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,6 +10,7 @@\n \n use std::cell::RefCell;\n use std::rc::Rc;\n+use std::vec_ng::Vec;\n \n #[deriving(Eq, Show)]\n struct Point {\n@@ -43,7 +44,9 @@ pub fn main() {\n     assert_eq!(*(*p).borrow(), Point {x: 3, y: 5});\n \n     let v = Rc::new(RefCell::new(vec!(1, 2, 3)));\n-    (*(*v).borrow_mut())[0] = 3;\n-    (*(*v).borrow_mut())[1] += 3;\n-    assert_eq!(((*(*v).borrow())[0], (*(*v).borrow())[1], (*(*v).borrow())[2]), (3, 5, 3));\n+    *(*(*v).borrow_mut()).get_mut(0) = 3;\n+    *(*(*v).borrow_mut()).get_mut(1) += 3;\n+    assert_eq!((*(*(*v).borrow()).get(0),\n+                *(*(*v).borrow()).get(1),\n+                *(*(*v).borrow()).get(2)), (3, 5, 3));\n }"}, {"sha": "02c030f3845c309804579347d45215228c57cdba", "filename": "src/test/run-pass/packed-struct-generic-size.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-size.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::mem;\n+use std::vec_ng::Vec;\n \n #[packed]\n struct S<T, S> {"}, {"sha": "cd5ce150bcb0d5412207f29107417be09f7c971d", "filename": "src/test/run-pass/pure-sum.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fpure-sum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fpure-sum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpure-sum.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,11 +10,13 @@\n \n // Check that functions can modify local state.\n \n+use std::vec_ng::Vec;\n+\n fn sums_to(v: Vec<int> , sum: int) -> bool {\n     let mut i = 0u;\n     let mut sum0 = 0;\n     while i < v.len() {\n-        sum0 += v[i];\n+        sum0 += *v.get(i);\n         i += 1u;\n     }\n     return sum0 == sum;\n@@ -24,7 +26,7 @@ fn sums_to_using_uniq(v: Vec<int> , sum: int) -> bool {\n     let mut i = 0u;\n     let mut sum0 = ~0;\n     while i < v.len() {\n-        *sum0 += v[i];\n+        *sum0 += *v.get(i);\n         i += 1u;\n     }\n     return *sum0 == sum;\n@@ -34,7 +36,7 @@ fn sums_to_using_rec(v: Vec<int> , sum: int) -> bool {\n     let mut i = 0u;\n     let mut sum0 = F {f: 0};\n     while i < v.len() {\n-        sum0.f += v[i];\n+        sum0.f += *v.get(i);\n         i += 1u;\n     }\n     return sum0.f == sum;\n@@ -46,7 +48,7 @@ fn sums_to_using_uniq_rec(v: Vec<int> , sum: int) -> bool {\n     let mut i = 0u;\n     let mut sum0 = F {f: ~0};\n     while i < v.len() {\n-        *sum0.f += v[i];\n+        *sum0.f += *v.get(i);\n         i += 1u;\n     }\n     return *sum0.f == sum;"}, {"sha": "9e2be5178557517abe41449a46746f2037371067", "filename": "src/test/run-pass/rcvr-borrowed-to-slice.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n trait sum {\n     fn sum_(self) -> int;\n }\n@@ -23,17 +25,17 @@ fn call_sum(x: &[int]) -> int { x.sum_() }\n \n pub fn main() {\n     let x = vec!(1, 2, 3);\n-    let y = call_sum(x);\n+    let y = call_sum(x.as_slice());\n     println!(\"y=={}\", y);\n     assert_eq!(y, 6);\n \n     let x = vec!(1, 2, 3);\n-    let y = x.sum_();\n+    let y = x..as_slice().sum_();\n     println!(\"y=={}\", y);\n     assert_eq!(y, 6);\n \n     let x = vec!(1, 2, 3);\n-    let y = x.sum_();\n+    let y = x.as_slice().sum_();\n     println!(\"y=={}\", y);\n     assert_eq!(y, 6);\n }"}, {"sha": "3b8f7c4ae610124d8f7f938d39791a935e3f60a7", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -11,6 +11,7 @@\n #[feature(managed_boxes)];\n \n use std::intrinsics::{TyDesc, get_tydesc, visit_tydesc, TyVisitor, Disr, Opaque};\n+use std::vec_ng::Vec;\n \n struct MyVisitor {\n     types: Vec<~str> ,\n@@ -151,10 +152,11 @@ pub fn main() {\n     visit_ty::<int>(&mut v);\n     visit_ty::<i8>(&mut v);\n     visit_ty::<i16>(&mut v);\n-    visit_ty::<Vec<int> >(&mut v);\n \n     for s in v.types.iter() {\n         println!(\"type: {}\", (*s).clone());\n     }\n-    assert_eq!(v.types.clone(), vec!(~\"bool\", ~\"int\", ~\"i8\", ~\"i16\", ~\"[\", ~\"int\", ~\"]\"));\n+\n+    let vec_types: Vec<~str> = v.types.clone().move_iter().collect();\n+    assert_eq!(vec_types, vec!(~\"bool\", ~\"int\", ~\"i8\", ~\"i16\"));\n }"}, {"sha": "f3f0724bd574a470e333402e32f657a979fa7da8", "filename": "src/test/run-pass/regions-borrow-evec-uniq.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fregions-borrow-evec-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fregions-borrow-evec-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-borrow-evec-uniq.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,16 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n fn foo(x: &[int]) -> int {\n     x[0]\n }\n \n pub fn main() {\n     let p = vec!(1,2,3,4,5);\n-    let r = foo(p);\n+    let r = foo(p.as_slice());\n     assert_eq!(r, 1);\n \n     let p = vec!(5,4,3,2,1);\n-    let r = foo(p);\n+    let r = foo(p.as_slice());\n     assert_eq!(r, 5);\n }"}, {"sha": "3f86f8612ed4c9983bea6078a20192afa2756ea4", "filename": "src/test/run-pass/regions-dependent-addr-of.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fregions-dependent-addr-of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fregions-dependent-addr-of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-dependent-addr-of.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -11,6 +11,8 @@\n // Test lifetimes are linked properly when we create dependent region pointers.\n // Issue #3148.\n \n+use std::vec_ng::Vec;\n+\n struct A {\n     value: B\n }\n@@ -41,7 +43,7 @@ fn get_v2<'v>(a: &'v A, i: uint) -> &'v int {\n \n fn get_v3<'v>(a: &'v A, i: uint) -> &'v int {\n     let foo = &a.value;\n-    &foo.v3[i]\n+    foo.v3.get(i)\n }\n \n fn get_v4<'v>(a: &'v A, _i: uint) -> &'v int {\n@@ -96,7 +98,7 @@ pub fn main() {\n     assert_eq!(*p, a.value.v2[1]);\n \n     let p = get_v3(&a, 1);\n-    assert_eq!(*p, a.value.v3[1]);\n+    assert_eq!(*p, *a.value.v3.get(1));\n \n     let p = get_v4(&a, 1);\n     assert_eq!(*p, a.value.v4.f);"}, {"sha": "3a472decc7c28d59fee40d96b483b042a0c75ad0", "filename": "src/test/run-pass/regions-dependent-autoslice.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fregions-dependent-autoslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fregions-dependent-autoslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-dependent-autoslice.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -11,6 +11,8 @@\n // Test lifetimes are linked properly when we autoslice a vector.\n // Issue #3148.\n \n+use std::vec_ng::Vec;\n+\n fn subslice1<'r>(v: &'r [uint]) -> &'r [uint] { v }\n \n fn both<'r>(v: &'r [uint]) -> &'r [uint] {\n@@ -19,5 +21,5 @@ fn both<'r>(v: &'r [uint]) -> &'r [uint] {\n \n pub fn main() {\n     let v = vec!(1,2,3);\n-    both(v);\n+    both(v.as_slice());\n }"}, {"sha": "b031cfea93e06e1772932ad8d27e06cbdd9acbd7", "filename": "src/test/run-pass/regions-infer-borrow-scope-view.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-view.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n fn view<'r, T>(x: &'r [T]) -> &'r [T] {x}\n \n pub fn main() {\n     let v = vec!(1, 2, 3);\n-    let x = view(v);\n-    let y = view(x);\n-    assert!((v[0] == x[0]) && (v[0] == y[0]));\n+    let x = view(v.as_slice());\n+    let y = view(x.as_slice());\n+    assert!((*v.get(0) == x[0]) && (*v.get(0) == y[0]));\n }"}, {"sha": "fa2050c69f234b2a89e6d0c5e49f45699fc74083", "filename": "src/test/run-pass/regions-mock-tcx.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -24,6 +24,7 @@ use collections::HashMap;\n use std::cast;\n use std::libc;\n use std::mem;\n+use std::vec_ng::Vec;\n \n type Type<'tcx> = &'tcx TypeStructure<'tcx>;\n "}, {"sha": "8694040269c48db832e704995c5d5cfe9ce65421", "filename": "src/test/run-pass/seq-compare.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fseq-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fseq-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fseq-compare.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use std::vec_ng::Vec;\n \n pub fn main() {\n     assert!((~\"hello\" < ~\"hellr\"));"}, {"sha": "02ea8f61938818e551d43bfda745883b19895893", "filename": "src/test/run-pass/shadow.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshadow.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n fn foo(c: Vec<int> ) {\n     let a: int = 5;\n     let mut b: Vec<int> = Vec::new();"}, {"sha": "c52a0e54279a8f6588c9158003e2348450e04c67", "filename": "src/test/run-pass/shape_intrinsic_tag_then_rec.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fshape_intrinsic_tag_then_rec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fshape_intrinsic_tag_then_rec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshape_intrinsic_tag_then_rec.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -15,6 +15,8 @@\n // interior record which is then itself interior to\n // something else, shape calculations were off.\n \n+use std::vec_ng::Vec;\n+\n #[deriving(Clone)]\n enum opt_span {\n     //hack (as opposed to option), to make `span` compile\n@@ -41,7 +43,7 @@ type ty_ = uint;\n struct Path_ {\n     global: bool,\n     idents: Vec<~str> ,\n-    types: vec!(@ty),\n+    types: Vec<@ty>,\n }\n \n type path = Spanned<Path_>;\n@@ -56,7 +58,11 @@ struct X {\n pub fn main() {\n     let sp: Span = Span {lo: 57451u, hi: 57542u, expanded_from: os_none};\n     let t: @ty = @Spanned { data: 3u, span: sp };\n-    let p_: Path_ = Path_ { global: true, idents: vec!(~\"hi\"), types: Vec<t> };\n+    let p_: Path_ = Path_ {\n+        global: true,\n+        idents: vec!(~\"hi\"),\n+        types: vec!(t),\n+    };\n     let p: path = Spanned { data: p_, span: sp };\n     let x = X { sp: sp, path: p };\n     println!(\"{:?}\", x.path.clone());"}, {"sha": "9b06e1758863f11655f539f58954a04c5fa7686b", "filename": "src/test/run-pass/size-and-align.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fsize-and-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fsize-and-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsize-and-align.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,13 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-\n+use std::vec_ng::Vec;\n \n enum clam<T> { a(T, int), b, }\n \n fn uhoh<T>(v: Vec<clam<T>> ) {\n-    match v[1] {\n+    match *v.get(1) {\n       a::<T>(ref _t, ref u) => {\n           println!(\"incorrect\");\n           println!(\"{:?}\", u);"}, {"sha": "5a5e9f7353dc6a35ba854ec10597572d78ba0efd", "filename": "src/test/run-pass/static-impl.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-impl.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,6 +10,8 @@\n \n // ignore-fast\n \n+use std::vec_ng::Vec;\n+\n pub trait plus {\n     fn plus(&self) -> int;\n }\n@@ -60,8 +62,10 @@ pub fn main() {\n     assert_eq!((~\"hi\").plus(), 200);\n \n     assert_eq!((vec!(1)).length_().str(), ~\"1\");\n-    assert_eq!((vec!(3, 4)).map_(|a| *a + 4 )[0], 7);\n-    assert_eq!((vec!(3, 4)).map_::<uint>(|a| *a as uint + 4u )[0], 7u);\n+    let vect = vec!(3, 4).map_(|a| *a + 4);\n+    assert_eq!(*vect.get(0), 7);\n+    let vect = (vec!(3, 4)).map_::<uint>(|a| *a as uint + 4u);\n+    assert_eq!(*vect.get(0), 7u);\n     let mut x = 0u;\n     10u.multi(|_n| x += 2u );\n     assert_eq!(x, 20u);"}, {"sha": "1a844061888286106f64e19fe0e529653680569d", "filename": "src/test/run-pass/swap-2.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fswap-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fswap-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fswap-2.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -9,14 +9,15 @@\n // except according to those terms.\n \n use std::mem::swap;\n+use std::vec_ng::Vec;\n \n pub fn main() {\n     let mut a: Vec<int> = vec!(0, 1, 2, 3, 4, 5, 6);\n     a.swap(2, 4);\n-    assert_eq!(a[2], 4);\n-    assert_eq!(a[4], 2);\n+    assert_eq!(*a.get(2), 4);\n+    assert_eq!(*a.get(4), 2);\n     let mut n = 42;\n-    swap(&mut n, &mut a[0]);\n-    assert_eq!(a[0], 42);\n+    swap(&mut n, a.get_mut(0));\n+    assert_eq!(*a.get(0), 42);\n     assert_eq!(n, 0);\n }"}, {"sha": "69ede9b4d0508a9788ca2f56352a12d30d37880d", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::cmp;\n+use std::vec_ng::Vec;\n \n // Tests of ports and channels on various types\n fn test_rec() {\n@@ -29,9 +30,9 @@ fn test_vec() {\n     let v0: Vec<int> = vec!(0, 1, 2);\n     tx.send(v0);\n     let v1 = rx.recv();\n-    assert_eq!(v1[0], 0);\n-    assert_eq!(v1[1], 1);\n-    assert_eq!(v1[2], 2);\n+    assert_eq!(*v1.get(0), 0);\n+    assert_eq!(*v1.get(1), 1);\n+    assert_eq!(*v1.get(2), 2);\n }\n \n fn test_str() {"}, {"sha": "471a55ee418d1b1adf26bfd4adfd8ee4e9c0cefe", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -11,6 +11,7 @@\n // ignore-fast\n \n use std::task;\n+use std::vec_ng::Vec;\n \n pub fn main() { println!(\"===== WITHOUT THREADS =====\"); test00(); }\n "}, {"sha": "40d0f4017589380a5a20f885f0619921a2dcfd74", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -19,6 +19,7 @@ extern crate sync;\n \n use sync::Arc;\n use std::task;\n+use std::vec_ng::Vec;\n \n trait Pet {\n     fn name(&self, blk: |&str|);\n@@ -90,22 +91,14 @@ fn check_legs(arc: Arc<Vec<~Pet:Share+Send>>) {\n     }\n     assert!(legs == 12);\n }\n-<<<<<<< HEAD\n-fn check_names(arc: Arc<~[~Pet:Share+Send]>) {\n-=======\n-fn check_names(arc: Arc<Vec<~Pet:Freeze+Send> >) {\n->>>>>>> test: Automatically remove all `~[T]` from tests.\n+fn check_names(arc: Arc<Vec<~Pet:Share+Send>>) {\n     for pet in arc.get().iter() {\n         pet.name(|name| {\n             assert!(name[0] == 'a' as u8 && name[1] == 'l' as u8);\n         })\n     }\n }\n-<<<<<<< HEAD\n-fn check_pedigree(arc: Arc<~[~Pet:Share+Send]>) {\n-=======\n-fn check_pedigree(arc: Arc<Vec<~Pet:Freeze+Send> >) {\n->>>>>>> test: Automatically remove all `~[T]` from tests.\n+fn check_pedigree(arc: Arc<Vec<~Pet:Share+Send>>) {\n     for pet in arc.get().iter() {\n         assert!(pet.of_good_pedigree());\n     }"}, {"sha": "5cc40f2dd37cb6f92b99d2772da6851a1c5074f2", "filename": "src/test/run-pass/trait-generic.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-generic.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,6 +10,8 @@\n \n // ignore-fast\n \n+use std::vec_ng::Vec;\n+\n trait to_str {\n     fn to_string(&self) -> ~str;\n }\n@@ -31,7 +33,7 @@ impl<T> map<T> for Vec<T> {\n         let mut r = Vec::new();\n         // FIXME: #7355 generates bad code with VecIterator\n         for i in range(0u, self.len()) {\n-            r.push(f(&self[i]));\n+            r.push(f(self.get(i)));\n         }\n         r\n     }\n@@ -48,5 +50,5 @@ pub fn main() {\n     assert_eq!(foo(vec!(1)), vec!(~\"hi\"));\n     assert_eq!(bar::<int, Vec<int> >(vec!(4, 5)), vec!(~\"4\", ~\"5\"));\n     assert_eq!(bar::<~str, Vec<~str> >(vec!(~\"x\", ~\"y\")), vec!(~\"x\", ~\"y\"));\n-    assert_eq!(bar::<(), vec!(())>(vec!(())), vec!(~\"()\"));\n+    assert_eq!(bar::<(), Vec<()>>(vec!(())), vec!(~\"()\"));\n }"}, {"sha": "fa320bba982565695b5693d6c5b68a579e75ff09", "filename": "src/test/run-pass/trait-to-str.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,6 +10,8 @@\n \n // ignore-fast\n \n+use std::vec_ng::Vec;\n+\n trait to_str {\n     fn to_string(&self) -> ~str;\n }"}, {"sha": "42ce18dccaff9e47a0e4d1efecbb8ce4ace10336", "filename": "src/test/run-pass/tydesc-name.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Ftydesc-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Ftydesc-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftydesc-name.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -19,7 +19,6 @@ struct Foo<T> {\n pub fn main() {\n     unsafe {\n         assert_eq!((*get_tydesc::<int>()).name, \"int\");\n-        assert_eq!((*get_tydesc::<Vec<int> >()).name, \"~[int]\");\n         assert_eq!((*get_tydesc::<Foo<uint>>()).name, \"Foo<uint>\");\n     }\n }"}, {"sha": "c0a22bacfd21eb4fe706daa03f5e55edf45fa03d", "filename": "src/test/run-pass/type-params-in-for-each.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n struct S<T> {\n     a: T,\n     b: uint,"}, {"sha": "87ce07c596ce5f9332a5652113656405a8772f06", "filename": "src/test/run-pass/unique-autoderef-index.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Funique-autoderef-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Funique-autoderef-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-autoderef-index.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n pub fn main() {\n     let i = ~vec!(100);\n-    assert_eq!(i[0], 100);\n+    assert_eq!(*i.get(0), 100);\n }"}, {"sha": "9e73039a0a76529f88d02206f5a91a875f8b4d9a", "filename": "src/test/run-pass/unique-in-vec-copy.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Funique-in-vec-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Funique-in-vec-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-in-vec-copy.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,16 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n+\n pub fn main() {\n     let mut a = vec!(~10);\n     let b = a.clone();\n \n-    assert_eq!(*a[0], 10);\n-    assert_eq!(*b[0], 10);\n+    assert_eq!(**a.get(0), 10);\n+    assert_eq!(**b.get(0), 10);\n \n     // This should only modify the value in a, not b\n-    *a[0] = 20;\n+    **a.get_mut(0) = 20;\n \n-    assert_eq!(*a[0], 20);\n-    assert_eq!(*b[0], 10);\n+    assert_eq!(**a.get(0), 20);\n+    assert_eq!(**b.get(0), 10);\n }"}, {"sha": "82d3a29d901ba07e7a57f5cb603ce149e1d40118", "filename": "src/test/run-pass/unique-in-vec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Funique-in-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Funique-in-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-in-vec.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -9,5 +9,6 @@\n // except according to those terms.\n \n pub fn main() {\n-    assert!((vec!(~100))[0] == ~100);\n+    let vect = vec!(~100);\n+    assert!(*vect.get(0) == ~100);\n }"}, {"sha": "f63934159558fcb523449ba5dacf5bf5493347b7", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -9,17 +9,18 @@\n // except according to those terms.\n \n use std::str;\n+use std::vec_ng::Vec;\n \n pub fn main() {\n     // Chars of 1, 2, 3, and 4 bytes\n-    let chs: ~[char] = ~['e', '\u00e9', '\u20ac', '\\U00010000'];\n-    let s: ~str = str::from_chars(chs);\n-    let schs: ~[char] = s.chars().collect();\n+    let chs: Vec<char> = vec!('e', '\u00e9', '\u20ac', '\\U00010000');\n+    let s: ~str = str::from_chars(chs.as_slice());\n+    let schs: Vec<char> = s.chars().collect();\n \n     assert!(s.len() == 10u);\n     assert!(s.char_len() == 4u);\n     assert!(schs.len() == 4u);\n-    assert!(str::from_chars(schs) == s);\n+    assert!(str::from_chars(schs.as_slice()) == s);\n     assert!(s.char_at(0u) == 'e');\n     assert!(s.char_at(1u) == '\u00e9');\n "}, {"sha": "0a9a65ac0e7550a21edca89dd2afe8355764e2c2", "filename": "src/test/run-pass/vec-concat.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fvec-concat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fvec-concat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-concat.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,12 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec;\n+\n pub fn main() {\n-    let a: ~[int] = ~[1, 2, 3, 4, 5];\n-    let b: ~[int] = ~[6, 7, 8, 9, 0];\n-    let v: ~[int] = a + b;\n+    let a: Vec<int> = vec!(1, 2, 3, 4, 5);\n+    let b: Vec<int> = vec!(6, 7, 8, 9, 0);\n+    let v: Vec<int> = vec::append(a, b.as_slice());\n     println!(\"{}\", v[9]);\n-    assert_eq!(v[0], 1);\n-    assert_eq!(v[7], 8);\n-    assert_eq!(v[9], 0);\n+    assert_eq!(*v.get(0), 1);\n+    assert_eq!(*v.get(7), 8);\n+    assert_eq!(*v.get(9), 0);\n }"}, {"sha": "675c06c257042f595c7c0a0ae160e5c4ec3d4a0c", "filename": "src/test/run-pass/vec-drop.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fvec-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fvec-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-drop.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,6 +10,8 @@\n \n #[feature(managed_boxes)];\n \n+use std::vec_ng::Vec;\n+\n struct Pair { x: int, y: int }\n \n pub fn main() {"}, {"sha": "4414da91ce7650f77321de771f91881a4bad4132", "filename": "src/test/run-pass/vec-growth.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fvec-growth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fvec-growth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-growth.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,17 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use std::vec_ng::Vec;\n \n pub fn main() {\n     let mut v = vec!(1);\n     v.push(2);\n     v.push(3);\n     v.push(4);\n     v.push(5);\n-    assert_eq!(v[0], 1);\n-    assert_eq!(v[1], 2);\n-    assert_eq!(v[2], 3);\n-    assert_eq!(v[3], 4);\n-    assert_eq!(v[4], 5);\n+    assert_eq!(*v.get(0), 1);\n+    assert_eq!(*v.get(1), 2);\n+    assert_eq!(*v.get(2), 3);\n+    assert_eq!(*v.get(3), 4);\n+    assert_eq!(*v.get(4), 5);\n }"}, {"sha": "fc9ab277aa1a63a6ddd57b1fc74f2da4eba9d72a", "filename": "src/test/run-pass/vec-ivec-deadlock.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Frun-pass%2Fvec-ivec-deadlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Frun-pass%2Fvec-ivec-deadlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-ivec-deadlock.rs?ref=579eb2400b3cb5d9cf03a5c8792d63630489193a", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(dead_assignment)];\n-\n-pub fn main() {\n-    let a = vec!(1, 2, 3, 4, 5);\n-    let mut b = vec!(a.clone(), a.clone());\n-    b = b + b; // FIXME(#3387)---can't write b += b\n-}"}, {"sha": "815235ef980b7f087150b663ab795de9f29e5064", "filename": "src/test/run-pass/vec-late-init.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fvec-late-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fvec-late-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-late-init.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use std::vec_ng::Vec;\n \n pub fn main() {\n     let mut later: Vec<int> ;\n     if true { later = vec!(1); } else { later = vec!(2); }\n-    println!(\"{}\", later[0]);\n+    println!(\"{}\", *later.get(0));\n }"}, {"sha": "683161178f2d6fa95b37e2c17e41310dad03a1c0", "filename": "src/test/run-pass/vec-trailing-comma.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Frun-pass%2Fvec-trailing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579eb2400b3cb5d9cf03a5c8792d63630489193a/src%2Ftest%2Frun-pass%2Fvec-trailing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-trailing-comma.rs?ref=579eb2400b3cb5d9cf03a5c8792d63630489193a", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Issue #2482.\n-\n-pub fn main() {\n-    let v1: Vec<int> = vec!(10, 20, 30);\n-    let v2: Vec<int> = vec!(10, 20, 30);\n-    assert_eq!(v1[2], v2[2]);\n-    let v3: Vec<int> = vec!(10);\n-    let v4: Vec<int> = vec!(10);\n-    assert_eq!(v3[0], v4[0]);\n-}"}, {"sha": "7fd3b57b0e524f9f14a7a855e39a79e51d67b9af", "filename": "src/test/run-pass/vec.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,17 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-\n+use std::vec_ng::Vec;\n \n pub fn main() {\n     let v: Vec<int> = vec!(10, 20);\n-    assert_eq!(v[0], 10);\n-    assert_eq!(v[1], 20);\n-    let mut x: int = 0;\n-    assert_eq!(v[x], 10);\n-    assert_eq!(v[x + 1], 20);\n+    assert_eq!(*v.get(0), 10);\n+    assert_eq!(*v.get(1), 20);\n+    let mut x: uint = 0;\n+    assert_eq!(*v.get(x), 10);\n+    assert_eq!(*v.get(x + 1), 20);\n     x = x + 1;\n-    assert_eq!(v[x], 20);\n-    assert_eq!(v[x - 1], 10);\n+    assert_eq!(*v.get(x), 20);\n+    assert_eq!(*v.get(x - 1), 10);\n }"}, {"sha": "56624cecdca35517b5e9d7ea8b7db5b7d7aa6354", "filename": "src/test/run-pass/vector-no-ann-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fvector-no-ann-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fvector-no-ann-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-no-ann-2.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -10,4 +10,6 @@\n \n #[feature(managed_boxes)];\n \n+use std::vec_ng::Vec;\n+\n pub fn main() { let _quux: @Vec<uint> = @Vec::new(); }"}, {"sha": "9b3baf80f8fa919f676f5d9b25a5e2eba745bb3a", "filename": "src/test/run-pass/while-with-break.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fwhile-with-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af79a5aa7da4f42fc0939a19f46fa73b894d6e9a/src%2Ftest%2Frun-pass%2Fwhile-with-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhile-with-break.rs?ref=af79a5aa7da4f42fc0939a19f46fa73b894d6e9a", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::vec_ng::Vec;\n \n pub fn main() {\n     let mut i: int = 90;"}]}