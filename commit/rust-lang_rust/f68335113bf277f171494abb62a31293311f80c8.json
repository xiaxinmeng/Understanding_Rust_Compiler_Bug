{"sha": "f68335113bf277f171494abb62a31293311f80c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ODMzNTExM2JmMjc3ZjE3MTQ5NGFiYjYyYTMxMjkzMzExZjgwYzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-19T17:14:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-19T17:14:33Z"}, "message": "auto merge of #5002 : catamorphism/rust/one-tuples, r=graydon\n\nr? @graydon - This is for greater uniformity (for example, macros that generate\r\ntuples). rustc already supported 1-tuple patterns, but there was no\r\nway to construct a 1-tuple term.\r\n\r\n@graydon , as far as your comment on #4898 - it did turn out to be solvable inside the macro (since @luqmana already fixed it using structs instead), but I still think it's a good idea to allow 1-tuples, for uniformity. I don't think anyone is likely to trip over it, and I'm not too worried that it changes the amount of ambiguity.", "tree": {"sha": "a790a66032447ff99658c7fe4525881c182170f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a790a66032447ff99658c7fe4525881c182170f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f68335113bf277f171494abb62a31293311f80c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f68335113bf277f171494abb62a31293311f80c8", "html_url": "https://github.com/rust-lang/rust/commit/f68335113bf277f171494abb62a31293311f80c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f68335113bf277f171494abb62a31293311f80c8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ec958db5ae37f193d4d632635818241b134a617", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ec958db5ae37f193d4d632635818241b134a617", "html_url": "https://github.com/rust-lang/rust/commit/2ec958db5ae37f193d4d632635818241b134a617"}, {"sha": "aa284de1fc246b55fb53783ded3e9786e04b03d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa284de1fc246b55fb53783ded3e9786e04b03d0", "html_url": "https://github.com/rust-lang/rust/commit/aa284de1fc246b55fb53783ded3e9786e04b03d0"}], "stats": {"total": 80, "additions": 69, "deletions": 11}, "files": [{"sha": "4cccc1d26382c01fb2d1a28cd19ef1b1f3af6f68", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f68335113bf277f171494abb62a31293311f80c8/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f68335113bf277f171494abb62a31293311f80c8/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=f68335113bf277f171494abb62a31293311f80c8", "patch": "@@ -43,6 +43,8 @@ impl ToStr for @str {\n     pure fn to_str(&self) -> ~str { ::str::from_slice(*self) }\n }\n \n+// FIXME #4898: impl for one-tuples\n+\n impl<A: ToStr, B: ToStr> ToStr for (A, B) {\n     #[inline(always)]\n     pure fn to_str(&self) -> ~str {"}, {"sha": "e49c1d26a06300fcaab7288339273975d42adaa9", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f68335113bf277f171494abb62a31293311f80c8/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f68335113bf277f171494abb62a31293311f80c8/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=f68335113bf277f171494abb62a31293311f80c8", "patch": "@@ -111,6 +111,8 @@ impl<A: Copy, B: Copy> ExtendedTupleOps<A,B> for (~[A], ~[B]) {\n     }\n }\n \n+// FIXME #4898: impl for one-tuples\n+\n #[cfg(notest)]\n impl<A: Eq, B: Eq> Eq for (A, B) {\n     #[inline(always)]"}, {"sha": "e5b3024d3dc4256478204faacc21ce8ec54ca547", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f68335113bf277f171494abb62a31293311f80c8/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f68335113bf277f171494abb62a31293311f80c8/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f68335113bf277f171494abb62a31293311f80c8", "patch": "@@ -576,12 +576,21 @@ pub impl Parser {\n                 self.bump();\n                 ty_nil\n             } else {\n+                // (t) is a parenthesized ty\n+                // (t,) is the type of a tuple with only one field,\n+                // of type t\n                 let mut ts = ~[self.parse_ty(false)];\n+                let mut one_tuple = false;\n                 while self.token == token::COMMA {\n                     self.bump();\n-                    ts.push(self.parse_ty(false));\n+                    if self.token != token::RPAREN {\n+                        ts.push(self.parse_ty(false));\n+                    }\n+                    else {\n+                        one_tuple = true;\n+                    }\n                 }\n-                let t = if vec::len(ts) == 1u { ts[0].node }\n+                let t = if ts.len() == 1 && !one_tuple { ts[0].node }\n                 else { ty_tup(ts) };\n                 self.expect(token::RPAREN);\n                 t\n@@ -1061,6 +1070,9 @@ pub impl Parser {\n \n         if self.token == token::LPAREN {\n             self.bump();\n+            // (e) is parenthesized e\n+            // (e,) is a tuple with only one field, e\n+            let mut one_tuple = false;\n             if self.token == token::RPAREN {\n                 hi = self.span.hi;\n                 self.bump();\n@@ -1069,12 +1081,18 @@ pub impl Parser {\n             }\n             let mut es = ~[self.parse_expr()];\n             while self.token == token::COMMA {\n-                self.bump(); es.push(self.parse_expr());\n+                self.bump();\n+                if self.token != token::RPAREN {\n+                    es.push(self.parse_expr());\n+                }\n+                else {\n+                    one_tuple = true;\n+                }\n             }\n             hi = self.span.hi;\n             self.expect(token::RPAREN);\n \n-            return if es.len() == 1 {\n+            return if es.len() == 1 && !one_tuple {\n                 self.mk_expr(lo, self.span.hi, expr_paren(es[0]))\n             }\n             else {\n@@ -2158,11 +2176,13 @@ pub impl Parser {\n                 pat = pat_lit(expr);\n             } else {\n                 let mut fields = ~[self.parse_pat(refutable)];\n-                while self.token == token::COMMA {\n-                    self.bump();\n-                    fields.push(self.parse_pat(refutable));\n+                if self.look_ahead(1) != token::RPAREN {\n+                    while self.token == token::COMMA {\n+                        self.bump();\n+                        fields.push(self.parse_pat(refutable));\n+                    }\n                 }\n-                if vec::len(fields) == 1u { self.expect(token::COMMA); }\n+                if fields.len() == 1 { self.expect(token::COMMA); }\n                 hi = self.span.hi;\n                 self.expect(token::RPAREN);\n                 pat = pat_tup(fields);"}, {"sha": "c091c43638119e4f901ea66eb4a5a530ffad1d5f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f68335113bf277f171494abb62a31293311f80c8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f68335113bf277f171494abb62a31293311f80c8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f68335113bf277f171494abb62a31293311f80c8", "patch": "@@ -414,6 +414,9 @@ pub fn print_type_ex(s: @ps, &&ty: @ast::Ty, print_colons: bool) {\n       ast::ty_tup(elts) => {\n         popen(s);\n         commasep(s, inconsistent, elts, print_type);\n+        if elts.len() == 1 {\n+            word(s.s, ~\",\");\n+        }\n         pclose(s);\n       }\n       ast::ty_bare_fn(f) => {\n@@ -1199,6 +1202,9 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n       ast::expr_tup(exprs) => {\n         popen(s);\n         commasep_exprs(s, inconsistent, exprs);\n+        if exprs.len() == 1 {\n+            word(s.s, ~\",\");\n+        }\n         pclose(s);\n       }\n       ast::expr_call(func, args, sugar) => {\n@@ -1634,6 +1640,9 @@ pub fn print_pat(s: @ps, &&pat: @ast::pat, refutable: bool) {\n       ast::pat_tup(elts) => {\n         popen(s);\n         commasep(s, inconsistent, elts, |s, p| print_pat(s, p, refutable));\n+        if elts.len() == 1 {\n+            word(s.s, ~\",\");\n+        }\n         pclose(s);\n       }\n       ast::pat_box(inner) => {"}, {"sha": "9d01fbface0dd193f7dfbddb67aa53639b79151a", "filename": "src/test/run-pass/one-tuple.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f68335113bf277f171494abb62a31293311f80c8/src%2Ftest%2Frun-pass%2Fone-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f68335113bf277f171494abb62a31293311f80c8/src%2Ftest%2Frun-pass%2Fone-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fone-tuple.rs?ref=f68335113bf277f171494abb62a31293311f80c8", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Why one-tuples? Because macros.\n+\n+fn main() {\n+    match ('c',) {\n+        (x,) => {\n+            assert x == 'c';\n+        }\n+    }\n+    // test the 1-tuple type too\n+    let x: (char,) = ('d',);\n+    let (y,) = x;\n+    assert y == 'd';\n+}\n+"}, {"sha": "3694ffdfde02f1c80babbc971152368423e2c5be", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f68335113bf277f171494abb62a31293311f80c8/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f68335113bf277f171494abb62a31293311f80c8/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=f68335113bf277f171494abb62a31293311f80c8", "patch": "@@ -636,11 +636,12 @@ struct Triple { x: int, y: int, z: int }\n \n pub fn main() {\n     unsafe {\n-        let r = (1,2,3,true,false, Triple {x:5,y:4,z:3});\n+        let r = (1,2,3,true,false, Triple {x:5,y:4,z:3}, (12,));\n         let p = ptr::addr_of(&r) as *c_void;\n         let u = my_visitor(@Stuff {mut ptr1: p,\n                              mut ptr2: p,\n-                             mut vals: ~[]});\n+                             mut vals: ~[]\n+                                  });\n         let v = ptr_visit_adaptor(Inner {inner: u});\n         let td = get_tydesc_for(r);\n         unsafe { error!(\"tydesc sz: %u, align: %u\",\n@@ -653,7 +654,7 @@ pub fn main() {\n         }\n         error!(\"%?\", copy u.vals);\n         assert u.vals == ~[\n-            ~\"1\", ~\"2\", ~\"3\", ~\"true\", ~\"false\", ~\"5\", ~\"4\", ~\"3\"\n+            ~\"1\", ~\"2\", ~\"3\", ~\"true\", ~\"false\", ~\"5\", ~\"4\", ~\"3\", ~\"12\"\n         ];\n     }\n  }"}]}