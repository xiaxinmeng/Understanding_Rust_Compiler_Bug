{"sha": "501a6c816a4a38e6ca1d204700cc0396285abd1f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwMWE2YzgxNmE0YTM4ZTZjYTFkMjA0NzAwY2MwMzk2Mjg1YWJkMWY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-27T20:11:30Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-03T22:01:56Z"}, "message": "libsyntax: De-`@mut` `StringReader::curr`", "tree": {"sha": "479ee77c11fe9af71407b20c8564cfa5065038c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/479ee77c11fe9af71407b20c8564cfa5065038c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/501a6c816a4a38e6ca1d204700cc0396285abd1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/501a6c816a4a38e6ca1d204700cc0396285abd1f", "html_url": "https://github.com/rust-lang/rust/commit/501a6c816a4a38e6ca1d204700cc0396285abd1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/501a6c816a4a38e6ca1d204700cc0396285abd1f/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa3527a1a3fca8842ded945b2951ec2a4bd8a55d", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa3527a1a3fca8842ded945b2951ec2a4bd8a55d", "html_url": "https://github.com/rust-lang/rust/commit/aa3527a1a3fca8842ded945b2951ec2a4bd8a55d"}], "stats": {"total": 156, "additions": 80, "deletions": 76}, "files": [{"sha": "b8fd39cb91042ceed8b2b96b6c0c71d80a5cec09", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/501a6c816a4a38e6ca1d204700cc0396285abd1f/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/501a6c816a4a38e6ca1d204700cc0396285abd1f/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=501a6c816a4a38e6ca1d204700cc0396285abd1f", "patch": "@@ -137,11 +137,11 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n \n fn read_to_eol(rdr: @mut StringReader) -> ~str {\n     let mut val = ~\"\";\n-    while rdr.curr != '\\n' && !is_eof(rdr) {\n-        val.push_char(rdr.curr);\n+    while rdr.curr.get() != '\\n' && !is_eof(rdr) {\n+        val.push_char(rdr.curr.get());\n         bump(rdr);\n     }\n-    if rdr.curr == '\\n' { bump(rdr); }\n+    if rdr.curr.get() == '\\n' { bump(rdr); }\n     return val;\n }\n \n@@ -153,7 +153,8 @@ fn read_one_line_comment(rdr: @mut StringReader) -> ~str {\n }\n \n fn consume_non_eol_whitespace(rdr: @mut StringReader) {\n-    while is_whitespace(rdr.curr) && rdr.curr != '\\n' && !is_eof(rdr) {\n+    while is_whitespace(rdr.curr.get()) && rdr.curr.get() != '\\n' &&\n+            !is_eof(rdr) {\n         bump(rdr);\n     }\n }\n@@ -170,8 +171,8 @@ fn push_blank_line_comment(rdr: @mut StringReader, comments: &mut ~[cmnt]) {\n \n fn consume_whitespace_counting_blank_lines(rdr: @mut StringReader,\n                                            comments: &mut ~[cmnt]) {\n-    while is_whitespace(rdr.curr) && !is_eof(rdr) {\n-        if rdr.col.get() == CharPos(0u) && rdr.curr == '\\n' {\n+    while is_whitespace(rdr.curr.get()) && !is_eof(rdr) {\n+        if rdr.col.get() == CharPos(0u) && rdr.curr.get() == '\\n' {\n             push_blank_line_comment(rdr, &mut *comments);\n         }\n         bump(rdr);\n@@ -196,7 +197,7 @@ fn read_line_comments(rdr: @mut StringReader, code_to_the_left: bool,\n     debug!(\">>> line comments\");\n     let p = rdr.last_pos.get();\n     let mut lines: ~[~str] = ~[];\n-    while rdr.curr == '/' && nextch(rdr) == '/' {\n+    while rdr.curr.get() == '/' && nextch(rdr) == '/' {\n         let line = read_one_line_comment(rdr);\n         debug!(\"{}\", line);\n         if is_doc_comment(line) { // doc-comments are not put in comments\n@@ -261,9 +262,9 @@ fn read_block_comment(rdr: @mut StringReader,\n     let mut curr_line = ~\"/*\";\n \n     // doc-comments are not really comments, they are attributes\n-    if rdr.curr == '*' || rdr.curr == '!' {\n-        while !(rdr.curr == '*' && nextch(rdr) == '/') && !is_eof(rdr) {\n-            curr_line.push_char(rdr.curr);\n+    if rdr.curr.get() == '*' || rdr.curr.get() == '!' {\n+        while !(rdr.curr.get() == '*' && nextch(rdr) == '/') && !is_eof(rdr) {\n+            curr_line.push_char(rdr.curr.get());\n             bump(rdr);\n         }\n         if !is_eof(rdr) {\n@@ -281,20 +282,20 @@ fn read_block_comment(rdr: @mut StringReader,\n             if is_eof(rdr) {\n                 (rdr as @mut reader).fatal(~\"unterminated block comment\");\n             }\n-            if rdr.curr == '\\n' {\n+            if rdr.curr.get() == '\\n' {\n                 trim_whitespace_prefix_and_push_line(&mut lines, curr_line,\n                                                      col);\n                 curr_line = ~\"\";\n                 bump(rdr);\n             } else {\n-                curr_line.push_char(rdr.curr);\n-                if rdr.curr == '/' && nextch(rdr) == '*' {\n+                curr_line.push_char(rdr.curr.get());\n+                if rdr.curr.get() == '/' && nextch(rdr) == '*' {\n                     bump(rdr);\n                     bump(rdr);\n                     curr_line.push_char('*');\n                     level += 1;\n                 } else {\n-                    if rdr.curr == '*' && nextch(rdr) == '/' {\n+                    if rdr.curr.get() == '*' && nextch(rdr) == '/' {\n                         bump(rdr);\n                         bump(rdr);\n                         curr_line.push_char('/');\n@@ -310,28 +311,28 @@ fn read_block_comment(rdr: @mut StringReader,\n \n     let mut style = if code_to_the_left { trailing } else { isolated };\n     consume_non_eol_whitespace(rdr);\n-    if !is_eof(rdr) && rdr.curr != '\\n' && lines.len() == 1u {\n+    if !is_eof(rdr) && rdr.curr.get() != '\\n' && lines.len() == 1u {\n         style = mixed;\n     }\n     debug!(\"<<< block comment\");\n     comments.push(cmnt {style: style, lines: lines, pos: p});\n }\n \n fn peeking_at_comment(rdr: @mut StringReader) -> bool {\n-    return ((rdr.curr == '/' && nextch(rdr) == '/') ||\n-         (rdr.curr == '/' && nextch(rdr) == '*')) ||\n-         (rdr.curr == '#' && nextch(rdr) == '!');\n+    return ((rdr.curr.get() == '/' && nextch(rdr) == '/') ||\n+         (rdr.curr.get() == '/' && nextch(rdr) == '*')) ||\n+         (rdr.curr.get() == '#' && nextch(rdr) == '!');\n }\n \n fn consume_comment(rdr: @mut StringReader,\n                    code_to_the_left: bool,\n                    comments: &mut ~[cmnt]) {\n     debug!(\">>> consume comment\");\n-    if rdr.curr == '/' && nextch(rdr) == '/' {\n+    if rdr.curr.get() == '/' && nextch(rdr) == '/' {\n         read_line_comments(rdr, code_to_the_left, comments);\n-    } else if rdr.curr == '/' && nextch(rdr) == '*' {\n+    } else if rdr.curr.get() == '/' && nextch(rdr) == '*' {\n         read_block_comment(rdr, code_to_the_left, comments);\n-    } else if rdr.curr == '#' && nextch(rdr) == '!' {\n+    } else if rdr.curr.get() == '#' && nextch(rdr) == '!' {\n         read_shebang_comment(rdr, code_to_the_left, comments);\n     } else { fail!(); }\n     debug!(\"<<< consume comment\");\n@@ -362,7 +363,7 @@ pub fn gather_comments_and_literals(span_diagnostic:\n         loop {\n             let mut code_to_the_left = !first_read;\n             consume_non_eol_whitespace(rdr);\n-            if rdr.curr == '\\n' {\n+            if rdr.curr.get() == '\\n' {\n                 code_to_the_left = false;\n                 consume_whitespace_counting_blank_lines(rdr, &mut comments);\n             }"}, {"sha": "68ff83085470c59e47e018b2924903ae22eb741f", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 57, "deletions": 54, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/501a6c816a4a38e6ca1d204700cc0396285abd1f/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/501a6c816a4a38e6ca1d204700cc0396285abd1f/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=501a6c816a4a38e6ca1d204700cc0396285abd1f", "patch": "@@ -50,7 +50,7 @@ pub struct StringReader {\n     // The column of the next character to read\n     col: Cell<CharPos>,\n     // The last character to be read\n-    curr: char,\n+    curr: Cell<char>,\n     filemap: @codemap::FileMap,\n     /* cached: */\n     peek_tok: token::Token,\n@@ -77,7 +77,7 @@ pub fn new_low_level_string_reader(span_diagnostic: @mut SpanHandler,\n         pos: Cell::new(filemap.start_pos),\n         last_pos: Cell::new(filemap.start_pos),\n         col: Cell::new(CharPos(0)),\n-        curr: initial_char,\n+        curr: Cell::new(initial_char),\n         filemap: filemap,\n         /* dummy values; not read */\n         peek_tok: token::EOF,\n@@ -97,7 +97,7 @@ fn dup_string_reader(r: @mut StringReader) -> @mut StringReader {\n         pos: Cell::new(r.pos.get()),\n         last_pos: Cell::new(r.last_pos.get()),\n         col: Cell::new(r.col.get()),\n-        curr: r.curr,\n+        curr: Cell::new(r.curr.get()),\n         filemap: r.filemap,\n         peek_tok: r.peek_tok.clone(),\n         peek_span: r.peek_span\n@@ -243,12 +243,14 @@ pub fn bump(rdr: &mut StringReader) {\n     rdr.last_pos.set(rdr.pos.get());\n     let current_byte_offset = byte_offset(rdr, rdr.pos.get()).to_uint();\n     if current_byte_offset < (rdr.src).len() {\n-        assert!(rdr.curr != unsafe { transmute(-1u32) }); // FIXME: #8971: unsound\n-        let last_char = rdr.curr;\n+        assert!(rdr.curr.get() != unsafe {\n+            transmute(-1u32)\n+        }); // FIXME: #8971: unsound\n+        let last_char = rdr.curr.get();\n         let next = rdr.src.char_range_at(current_byte_offset);\n         let byte_offset_diff = next.next - current_byte_offset;\n         rdr.pos.set(rdr.pos.get() + Pos::from_uint(byte_offset_diff));\n-        rdr.curr = next.ch;\n+        rdr.curr.set(next.ch);\n         rdr.col.set(rdr.col.get() + CharPos(1u));\n         if last_char == '\\n' {\n             rdr.filemap.next_line(rdr.last_pos.get());\n@@ -260,11 +262,11 @@ pub fn bump(rdr: &mut StringReader) {\n                 Pos::from_uint(current_byte_offset), byte_offset_diff);\n         }\n     } else {\n-        rdr.curr = unsafe { transmute(-1u32) }; // FIXME: #8971: unsound\n+        rdr.curr.set(unsafe { transmute(-1u32) }); // FIXME: #8971: unsound\n     }\n }\n pub fn is_eof(rdr: @mut StringReader) -> bool {\n-    rdr.curr == unsafe { transmute(-1u32) } // FIXME: #8971: unsound\n+    rdr.curr.get() == unsafe { transmute(-1u32) } // FIXME: #8971: unsound\n }\n pub fn nextch(rdr: @mut StringReader) -> char {\n     let offset = byte_offset(rdr, rdr.pos.get()).to_uint();\n@@ -299,7 +301,7 @@ fn is_hex_digit(c: char) -> bool {\n // returns a Some(sugared-doc-attr) if one exists, None otherwise.\n fn consume_whitespace_and_comments(rdr: @mut StringReader)\n                                 -> Option<TokenAndSpan> {\n-    while is_whitespace(rdr.curr) { bump(rdr); }\n+    while is_whitespace(rdr.curr.get()) { bump(rdr); }\n     return consume_any_line_comment(rdr);\n }\n \n@@ -312,15 +314,15 @@ pub fn is_line_non_doc_comment(s: &str) -> bool {\n // returns a Some(sugared-doc-attr) if one exists, None otherwise\n fn consume_any_line_comment(rdr: @mut StringReader)\n                          -> Option<TokenAndSpan> {\n-    if rdr.curr == '/' {\n+    if rdr.curr.get() == '/' {\n         match nextch(rdr) {\n           '/' => {\n             bump(rdr);\n             bump(rdr);\n             // line comments starting with \"///\" or \"//!\" are doc-comments\n-            if rdr.curr == '/' || rdr.curr == '!' {\n+            if rdr.curr.get() == '/' || rdr.curr.get() == '!' {\n                 let start_bpos = rdr.pos.get() - BytePos(3);\n-                while rdr.curr != '\\n' && !is_eof(rdr) {\n+                while rdr.curr.get() != '\\n' && !is_eof(rdr) {\n                     bump(rdr);\n                 }\n                 let ret = with_str_from(rdr, start_bpos, |string| {\n@@ -339,23 +341,23 @@ fn consume_any_line_comment(rdr: @mut StringReader)\n                     return ret;\n                 }\n             } else {\n-                while rdr.curr != '\\n' && !is_eof(rdr) { bump(rdr); }\n+                while rdr.curr.get() != '\\n' && !is_eof(rdr) { bump(rdr); }\n             }\n             // Restart whitespace munch.\n             return consume_whitespace_and_comments(rdr);\n           }\n           '*' => { bump(rdr); bump(rdr); return consume_block_comment(rdr); }\n           _ => ()\n         }\n-    } else if rdr.curr == '#' {\n+    } else if rdr.curr.get() == '#' {\n         if nextch(rdr) == '!' {\n             // I guess this is the only way to figure out if\n             // we're at the beginning of the file...\n             let cmap = @CodeMap::new();\n             (*cmap).files.push(rdr.filemap);\n             let loc = cmap.lookup_char_pos_adj(rdr.last_pos.get());\n             if loc.line == 1u && loc.col == CharPos(0u) {\n-                while rdr.curr != '\\n' && !is_eof(rdr) { bump(rdr); }\n+                while rdr.curr.get() != '\\n' && !is_eof(rdr) { bump(rdr); }\n                 return consume_whitespace_and_comments(rdr);\n             }\n         }\n@@ -371,7 +373,7 @@ pub fn is_block_non_doc_comment(s: &str) -> bool {\n fn consume_block_comment(rdr: @mut StringReader)\n                       -> Option<TokenAndSpan> {\n     // block comments starting with \"/**\" or \"/*!\" are doc-comments\n-    let is_doc_comment = rdr.curr == '*' || rdr.curr == '!';\n+    let is_doc_comment = rdr.curr.get() == '*' || rdr.curr.get() == '!';\n     let start_bpos = rdr.pos.get() - BytePos(if is_doc_comment {3} else {2});\n \n     let mut level: int = 1;\n@@ -383,11 +385,11 @@ fn consume_block_comment(rdr: @mut StringReader)\n                 ~\"unterminated block comment\"\n             };\n             fatal_span(rdr, start_bpos, rdr.last_pos.get(), msg);\n-        } else if rdr.curr == '/' && nextch(rdr) == '*' {\n+        } else if rdr.curr.get() == '/' && nextch(rdr) == '*' {\n             level += 1;\n             bump(rdr);\n             bump(rdr);\n-        } else if rdr.curr == '*' && nextch(rdr) == '/' {\n+        } else if rdr.curr.get() == '*' && nextch(rdr) == '/' {\n             level -= 1;\n             bump(rdr);\n             bump(rdr);\n@@ -417,12 +419,12 @@ fn consume_block_comment(rdr: @mut StringReader)\n }\n \n fn scan_exponent(rdr: @mut StringReader, start_bpos: BytePos) -> Option<~str> {\n-    let mut c = rdr.curr;\n+    let mut c = rdr.curr.get();\n     let mut rslt = ~\"\";\n     if c == 'e' || c == 'E' {\n         rslt.push_char(c);\n         bump(rdr);\n-        c = rdr.curr;\n+        c = rdr.curr.get();\n         if c == '-' || c == '+' {\n             rslt.push_char(c);\n             bump(rdr);\n@@ -440,7 +442,7 @@ fn scan_exponent(rdr: @mut StringReader, start_bpos: BytePos) -> Option<~str> {\n fn scan_digits(rdr: @mut StringReader, radix: uint) -> ~str {\n     let mut rslt = ~\"\";\n     loop {\n-        let c = rdr.curr;\n+        let c = rdr.curr.get();\n         if c == '_' { bump(rdr); continue; }\n         match char::to_digit(c, radix) {\n           Some(_) => {\n@@ -472,7 +474,7 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n         base = 2u;\n     }\n     num_str = scan_digits(rdr, base);\n-    c = rdr.curr;\n+    c = rdr.curr.get();\n     nextch(rdr);\n     if c == 'u' || c == 'i' {\n         enum Result { Signed(ast::int_ty), Unsigned(ast::uint_ty) }\n@@ -482,7 +484,7 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n             else { Unsigned(ast::ty_u) }\n         };\n         bump(rdr);\n-        c = rdr.curr;\n+        c = rdr.curr.get();\n         if c == '8' {\n             bump(rdr);\n             tp = if signed { Signed(ast::ty_i8) }\n@@ -521,7 +523,8 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n         }\n     }\n     let mut is_float = false;\n-    if rdr.curr == '.' && !(ident_start(nextch(rdr)) || nextch(rdr) == '.') {\n+    if rdr.curr.get() == '.' && !(ident_start(nextch(rdr)) || nextch(rdr) ==\n+                                  '.') {\n         is_float = true;\n         bump(rdr);\n         let dec_part = scan_digits(rdr, 10u);\n@@ -547,9 +550,9 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n       None => ()\n     }\n \n-    if rdr.curr == 'f' {\n+    if rdr.curr.get() == 'f' {\n         bump(rdr);\n-        c = rdr.curr;\n+        c = rdr.curr.get();\n         n = nextch(rdr);\n         if c == '3' && n == '2' {\n             bump(rdr);\n@@ -592,7 +595,7 @@ fn scan_numeric_escape(rdr: @mut StringReader, n_hex_digits: uint) -> char {\n     let mut i = n_hex_digits;\n     let start_bpos = rdr.last_pos.get();\n     while i != 0u {\n-        let n = rdr.curr;\n+        let n = rdr.curr.get();\n         if !is_hex_digit(n) {\n             fatal_span_char(rdr, rdr.last_pos.get(), rdr.pos.get(),\n                             ~\"illegal character in numeric character escape\",\n@@ -629,21 +632,21 @@ fn ident_continue(c: char) -> bool {\n // EFFECT: advances the input past that token\n // EFFECT: updates the interner\n fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n-    let c = rdr.curr;\n+    let c = rdr.curr.get();\n     if ident_start(c) && nextch(rdr) != '\"' && nextch(rdr) != '#' {\n         // Note: r as in r\" or r#\" is part of a raw string literal,\n         // not an identifier, and is handled further down.\n \n         let start = rdr.last_pos.get();\n-        while ident_continue(rdr.curr) {\n+        while ident_continue(rdr.curr.get()) {\n             bump(rdr);\n         }\n \n         return with_str_from(rdr, start, |string| {\n             if string == \"_\" {\n                 token::UNDERSCORE\n             } else {\n-                let is_mod_name = rdr.curr == ':' && nextch(rdr) == ':';\n+                let is_mod_name = rdr.curr.get() == ':' && nextch(rdr) == ':';\n \n                 // FIXME: perform NFKC normalization here. (Issue #2253)\n                 token::IDENT(str_to_ident(string), is_mod_name)\n@@ -655,7 +658,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n     }\n     fn binop(rdr: @mut StringReader, op: token::binop) -> token::Token {\n         bump(rdr);\n-        if rdr.curr == '=' {\n+        if rdr.curr.get() == '=' {\n             bump(rdr);\n             return token::BINOPEQ(op);\n         } else { return token::BINOP(op); }\n@@ -671,9 +674,9 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n       ',' => { bump(rdr); return token::COMMA; }\n       '.' => {\n           bump(rdr);\n-          return if rdr.curr == '.' {\n+          return if rdr.curr.get() == '.' {\n               bump(rdr);\n-              if rdr.curr == '.' {\n+              if rdr.curr.get() == '.' {\n                   bump(rdr);\n                   token::DOTDOTDOT\n               } else {\n@@ -694,7 +697,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n       '~' => { bump(rdr); return token::TILDE; }\n       ':' => {\n         bump(rdr);\n-        if rdr.curr == ':' {\n+        if rdr.curr.get() == ':' {\n             bump(rdr);\n             return token::MOD_SEP;\n         } else { return token::COLON; }\n@@ -709,10 +712,10 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n       // Multi-byte tokens.\n       '=' => {\n         bump(rdr);\n-        if rdr.curr == '=' {\n+        if rdr.curr.get() == '=' {\n             bump(rdr);\n             return token::EQEQ;\n-        } else if rdr.curr == '>' {\n+        } else if rdr.curr.get() == '>' {\n             bump(rdr);\n             return token::FAT_ARROW;\n         } else {\n@@ -721,19 +724,19 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n       }\n       '!' => {\n         bump(rdr);\n-        if rdr.curr == '=' {\n+        if rdr.curr.get() == '=' {\n             bump(rdr);\n             return token::NE;\n         } else { return token::NOT; }\n       }\n       '<' => {\n         bump(rdr);\n-        match rdr.curr {\n+        match rdr.curr.get() {\n           '=' => { bump(rdr); return token::LE; }\n           '<' => { return binop(rdr, token::SHL); }\n           '-' => {\n             bump(rdr);\n-            match rdr.curr {\n+            match rdr.curr.get() {\n               '>' => { bump(rdr); return token::DARROW; }\n               _ => { return token::LARROW; }\n             }\n@@ -743,7 +746,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n       }\n       '>' => {\n         bump(rdr);\n-        match rdr.curr {\n+        match rdr.curr.get() {\n           '=' => { bump(rdr); return token::GE; }\n           '>' => { return binop(rdr, token::SHR); }\n           _ => { return token::GT; }\n@@ -753,13 +756,13 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n         // Either a character constant 'a' OR a lifetime name 'abc\n         bump(rdr);\n         let start = rdr.last_pos.get();\n-        let mut c2 = rdr.curr;\n+        let mut c2 = rdr.curr.get();\n         bump(rdr);\n \n         // If the character is an ident start not followed by another single\n         // quote, then this is a lifetime name:\n-        if ident_start(c2) && rdr.curr != '\\'' {\n-            while ident_continue(rdr.curr) {\n+        if ident_start(c2) && rdr.curr.get() != '\\'' {\n+            while ident_continue(rdr.curr.get()) {\n                 bump(rdr);\n             }\n             return with_str_from(rdr, start, |lifetime_name| {\n@@ -783,7 +786,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n         match c2 {\n             '\\\\' => {\n                 // '\\X' for some X must be a character constant:\n-                let escaped = rdr.curr;\n+                let escaped = rdr.curr.get();\n                 let escaped_pos = rdr.last_pos.get();\n                 bump(rdr);\n                 match escaped {\n@@ -809,7 +812,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n             }\n             _ => {}\n         }\n-        if rdr.curr != '\\'' {\n+        if rdr.curr.get() != '\\'' {\n             fatal_span_verbose(rdr,\n                                // Byte offsetting here is okay because the\n                                // character before position `start` is an\n@@ -825,17 +828,17 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n         let mut accum_str = ~\"\";\n         let start_bpos = rdr.last_pos.get();\n         bump(rdr);\n-        while rdr.curr != '\"' {\n+        while rdr.curr.get() != '\"' {\n             if is_eof(rdr) {\n                 fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                            ~\"unterminated double quote string\");\n             }\n \n-            let ch = rdr.curr;\n+            let ch = rdr.curr.get();\n             bump(rdr);\n             match ch {\n               '\\\\' => {\n-                let escaped = rdr.curr;\n+                let escaped = rdr.curr.get();\n                 let escaped_pos = rdr.last_pos.get();\n                 bump(rdr);\n                 match escaped {\n@@ -872,15 +875,15 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n         let start_bpos = rdr.last_pos.get();\n         bump(rdr);\n         let mut hash_count = 0u;\n-        while rdr.curr == '#' {\n+        while rdr.curr.get() == '#' {\n             bump(rdr);\n             hash_count += 1;\n         }\n-        if rdr.curr != '\"' {\n+        if rdr.curr.get() != '\"' {\n             fatal_span_char(rdr, start_bpos, rdr.last_pos.get(),\n                             ~\"only `#` is allowed in raw string delimitation; \\\n                               found illegal character\",\n-                            rdr.curr);\n+                            rdr.curr.get());\n         }\n         bump(rdr);\n         let content_start_bpos = rdr.last_pos.get();\n@@ -890,11 +893,11 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n                 fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n                            ~\"unterminated raw string\");\n             }\n-            if rdr.curr == '\"' {\n+            if rdr.curr.get() == '\"' {\n                 content_end_bpos = rdr.last_pos.get();\n                 for _ in range(0, hash_count) {\n                     bump(rdr);\n-                    if rdr.curr != '#' {\n+                    if rdr.curr.get() != '#' {\n                         continue 'outer;\n                     }\n                 }\n@@ -942,7 +945,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n }\n \n fn consume_whitespace(rdr: @mut StringReader) {\n-    while is_whitespace(rdr.curr) && !is_eof(rdr) { bump(rdr); }\n+    while is_whitespace(rdr.curr.get()) && !is_eof(rdr) { bump(rdr); }\n }\n \n #[cfg(test)]"}]}