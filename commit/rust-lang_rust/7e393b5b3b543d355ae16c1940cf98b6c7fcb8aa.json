{"sha": "7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlMzkzYjViM2I1NDNkMzU1YWUxNmMxOTQwY2Y5OGI2YzdmY2I4YWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-07T21:23:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-07T21:23:19Z"}, "message": "Auto merge of #67970 - cjgillot:inherent, r=Centril\n\nMinimize dependencies on trait and infer inside librustc\n\nSplit from #67953\n\nAll commits should pass check on their own.\n\nr? @Centril", "tree": {"sha": "477d03a6fbbd67c1250254a48e3b3d8dad433d96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/477d03a6fbbd67c1250254a48e3b3d8dad433d96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "html_url": "https://github.com/rust-lang/rust/commit/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85976442558bf2d09cec3aa49c9c9ba86fb15c1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/85976442558bf2d09cec3aa49c9c9ba86fb15c1f", "html_url": "https://github.com/rust-lang/rust/commit/85976442558bf2d09cec3aa49c9c9ba86fb15c1f"}, {"sha": "700ac84eae77e95bbc6e8276a4f4ad102d6e83e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/700ac84eae77e95bbc6e8276a4f4ad102d6e83e5", "html_url": "https://github.com/rust-lang/rust/commit/700ac84eae77e95bbc6e8276a4f4ad102d6e83e5"}], "stats": {"total": 2954, "additions": 1512, "deletions": 1442}, "files": [{"sha": "f262672fdc875b92c2be93b3601febc7e009a100", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 192, "deletions": 189, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -53,6 +53,8 @@ use crate::hir::map;\n use crate::infer::opaque_types;\n use crate::infer::{self, SuppressRegionErrors};\n use crate::middle::region;\n+use crate::traits::error_reporting::report_object_safety_error;\n+use crate::traits::object_safety_violations;\n use crate::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n };\n@@ -79,212 +81,209 @@ pub use need_type_info::TypeAnnotationNeeded;\n \n pub mod nice_region_error;\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn note_and_explain_region(\n-        self,\n-        region_scope_tree: &region::ScopeTree,\n-        err: &mut DiagnosticBuilder<'_>,\n-        prefix: &str,\n-        region: ty::Region<'tcx>,\n-        suffix: &str,\n-    ) {\n-        let (description, span) = match *region {\n-            ty::ReScope(scope) => {\n-                let new_string;\n-                let unknown_scope = || {\n-                    format!(\"{}unknown scope: {:?}{}.  Please report a bug.\", prefix, scope, suffix)\n-                };\n-                let span = scope.span(self, region_scope_tree);\n-                let tag = match self.hir().find(scope.hir_id(region_scope_tree)) {\n-                    Some(Node::Block(_)) => \"block\",\n-                    Some(Node::Expr(expr)) => match expr.kind {\n-                        hir::ExprKind::Call(..) => \"call\",\n-                        hir::ExprKind::MethodCall(..) => \"method call\",\n-                        hir::ExprKind::Match(.., hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n-                        hir::ExprKind::Match(.., hir::MatchSource::WhileLetDesugar) => \"while let\",\n-                        hir::ExprKind::Match(.., hir::MatchSource::ForLoopDesugar) => \"for\",\n-                        hir::ExprKind::Match(..) => \"match\",\n-                        _ => \"expression\",\n-                    },\n-                    Some(Node::Stmt(_)) => \"statement\",\n-                    Some(Node::Item(it)) => Self::item_scope_tag(&it),\n-                    Some(Node::TraitItem(it)) => Self::trait_item_scope_tag(&it),\n-                    Some(Node::ImplItem(it)) => Self::impl_item_scope_tag(&it),\n-                    Some(_) | None => {\n-                        err.span_note(span, &unknown_scope());\n-                        return;\n-                    }\n-                };\n-                let scope_decorated_tag = match scope.data {\n-                    region::ScopeData::Node => tag,\n-                    region::ScopeData::CallSite => \"scope of call-site for function\",\n-                    region::ScopeData::Arguments => \"scope of function body\",\n-                    region::ScopeData::Destruction => {\n-                        new_string = format!(\"destruction scope surrounding {}\", tag);\n-                        &new_string[..]\n-                    }\n-                    region::ScopeData::Remainder(first_statement_index) => {\n-                        new_string = format!(\n-                            \"block suffix following statement {}\",\n-                            first_statement_index.index()\n-                        );\n-                        &new_string[..]\n-                    }\n-                };\n-                self.explain_span(scope_decorated_tag, span)\n-            }\n+pub(super) fn note_and_explain_region(\n+    tcx: TyCtxt<'tcx>,\n+    region_scope_tree: &region::ScopeTree,\n+    err: &mut DiagnosticBuilder<'_>,\n+    prefix: &str,\n+    region: ty::Region<'tcx>,\n+    suffix: &str,\n+) {\n+    let (description, span) = match *region {\n+        ty::ReScope(scope) => {\n+            let new_string;\n+            let unknown_scope =\n+                || format!(\"{}unknown scope: {:?}{}.  Please report a bug.\", prefix, scope, suffix);\n+            let span = scope.span(tcx, region_scope_tree);\n+            let tag = match tcx.hir().find(scope.hir_id(region_scope_tree)) {\n+                Some(Node::Block(_)) => \"block\",\n+                Some(Node::Expr(expr)) => match expr.kind {\n+                    hir::ExprKind::Call(..) => \"call\",\n+                    hir::ExprKind::MethodCall(..) => \"method call\",\n+                    hir::ExprKind::Match(.., hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n+                    hir::ExprKind::Match(.., hir::MatchSource::WhileLetDesugar) => \"while let\",\n+                    hir::ExprKind::Match(.., hir::MatchSource::ForLoopDesugar) => \"for\",\n+                    hir::ExprKind::Match(..) => \"match\",\n+                    _ => \"expression\",\n+                },\n+                Some(Node::Stmt(_)) => \"statement\",\n+                Some(Node::Item(it)) => item_scope_tag(&it),\n+                Some(Node::TraitItem(it)) => trait_item_scope_tag(&it),\n+                Some(Node::ImplItem(it)) => impl_item_scope_tag(&it),\n+                Some(_) | None => {\n+                    err.span_note(span, &unknown_scope());\n+                    return;\n+                }\n+            };\n+            let scope_decorated_tag = match scope.data {\n+                region::ScopeData::Node => tag,\n+                region::ScopeData::CallSite => \"scope of call-site for function\",\n+                region::ScopeData::Arguments => \"scope of function body\",\n+                region::ScopeData::Destruction => {\n+                    new_string = format!(\"destruction scope surrounding {}\", tag);\n+                    &new_string[..]\n+                }\n+                region::ScopeData::Remainder(first_statement_index) => {\n+                    new_string = format!(\n+                        \"block suffix following statement {}\",\n+                        first_statement_index.index()\n+                    );\n+                    &new_string[..]\n+                }\n+            };\n+            explain_span(tcx, scope_decorated_tag, span)\n+        }\n \n-            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic => {\n-                self.msg_span_from_free_region(region)\n-            }\n+        ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic => {\n+            msg_span_from_free_region(tcx, region)\n+        }\n \n-            ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n+        ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n \n-            ty::RePlaceholder(_) => (format!(\"any other region\"), None),\n+        ty::RePlaceholder(_) => (format!(\"any other region\"), None),\n \n-            // FIXME(#13998) RePlaceholder should probably print like\n-            // ReFree rather than dumping Debug output on the user.\n-            //\n-            // We shouldn't really be having unification failures with ReVar\n-            // and ReLateBound though.\n-            ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n-                (format!(\"lifetime {:?}\", region), None)\n-            }\n+        // FIXME(#13998) RePlaceholder should probably print like\n+        // ReFree rather than dumping Debug output on the user.\n+        //\n+        // We shouldn't really be having unification failures with ReVar\n+        // and ReLateBound though.\n+        ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n+            (format!(\"lifetime {:?}\", region), None)\n+        }\n \n-            // We shouldn't encounter an error message with ReClosureBound.\n-            ty::ReClosureBound(..) => {\n-                bug!(\"encountered unexpected ReClosureBound: {:?}\", region,);\n-            }\n-        };\n+        // We shouldn't encounter an error message with ReClosureBound.\n+        ty::ReClosureBound(..) => {\n+            bug!(\"encountered unexpected ReClosureBound: {:?}\", region,);\n+        }\n+    };\n \n-        TyCtxt::emit_msg_span(err, prefix, description, span, suffix);\n-    }\n+    emit_msg_span(err, prefix, description, span, suffix);\n+}\n \n-    pub fn note_and_explain_free_region(\n-        self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        prefix: &str,\n-        region: ty::Region<'tcx>,\n-        suffix: &str,\n-    ) {\n-        let (description, span) = self.msg_span_from_free_region(region);\n+pub(super) fn note_and_explain_free_region(\n+    tcx: TyCtxt<'tcx>,\n+    err: &mut DiagnosticBuilder<'_>,\n+    prefix: &str,\n+    region: ty::Region<'tcx>,\n+    suffix: &str,\n+) {\n+    let (description, span) = msg_span_from_free_region(tcx, region);\n \n-        TyCtxt::emit_msg_span(err, prefix, description, span, suffix);\n-    }\n+    emit_msg_span(err, prefix, description, span, suffix);\n+}\n \n-    fn msg_span_from_free_region(self, region: ty::Region<'tcx>) -> (String, Option<Span>) {\n-        match *region {\n-            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n-                self.msg_span_from_early_bound_and_free_regions(region)\n-            }\n-            ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n-            ty::ReEmpty => (\"an empty lifetime\".to_owned(), None),\n-            _ => bug!(\"{:?}\", region),\n+fn msg_span_from_free_region(\n+    tcx: TyCtxt<'tcx>,\n+    region: ty::Region<'tcx>,\n+) -> (String, Option<Span>) {\n+    match *region {\n+        ty::ReEarlyBound(_) | ty::ReFree(_) => {\n+            msg_span_from_early_bound_and_free_regions(tcx, region)\n         }\n+        ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n+        ty::ReEmpty => (\"an empty lifetime\".to_owned(), None),\n+        _ => bug!(\"{:?}\", region),\n     }\n+}\n \n-    fn msg_span_from_early_bound_and_free_regions(\n-        self,\n-        region: ty::Region<'tcx>,\n-    ) -> (String, Option<Span>) {\n-        let cm = self.sess.source_map();\n-\n-        let scope = region.free_region_binding_scope(self);\n-        let node = self.hir().as_local_hir_id(scope).unwrap_or(hir::DUMMY_HIR_ID);\n-        let tag = match self.hir().find(node) {\n-            Some(Node::Block(_)) | Some(Node::Expr(_)) => \"body\",\n-            Some(Node::Item(it)) => Self::item_scope_tag(&it),\n-            Some(Node::TraitItem(it)) => Self::trait_item_scope_tag(&it),\n-            Some(Node::ImplItem(it)) => Self::impl_item_scope_tag(&it),\n-            _ => unreachable!(),\n-        };\n-        let (prefix, span) = match *region {\n-            ty::ReEarlyBound(ref br) => {\n-                let mut sp = cm.def_span(self.hir().span(node));\n-                if let Some(param) =\n-                    self.hir().get_generics(scope).and_then(|generics| generics.get_named(br.name))\n-                {\n-                    sp = param.span;\n-                }\n-                (format!(\"the lifetime `{}` as defined on\", br.name), sp)\n-            }\n-            ty::ReFree(ty::FreeRegion {\n-                bound_region: ty::BoundRegion::BrNamed(_, name), ..\n-            }) => {\n-                let mut sp = cm.def_span(self.hir().span(node));\n-                if let Some(param) =\n-                    self.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n-                {\n-                    sp = param.span;\n-                }\n-                (format!(\"the lifetime `{}` as defined on\", name), sp)\n-            }\n-            ty::ReFree(ref fr) => match fr.bound_region {\n-                ty::BrAnon(idx) => (\n-                    format!(\"the anonymous lifetime #{} defined on\", idx + 1),\n-                    self.hir().span(node),\n-                ),\n-                _ => (\n-                    format!(\"the lifetime `{}` as defined on\", region),\n-                    cm.def_span(self.hir().span(node)),\n-                ),\n-            },\n-            _ => bug!(),\n-        };\n-        let (msg, opt_span) = self.explain_span(tag, span);\n-        (format!(\"{} {}\", prefix, msg), opt_span)\n-    }\n-\n-    fn emit_msg_span(\n-        err: &mut DiagnosticBuilder<'_>,\n-        prefix: &str,\n-        description: String,\n-        span: Option<Span>,\n-        suffix: &str,\n-    ) {\n-        let message = format!(\"{}{}{}\", prefix, description, suffix);\n-\n-        if let Some(span) = span {\n-            err.span_note(span, &message);\n-        } else {\n-            err.note(&message);\n+fn msg_span_from_early_bound_and_free_regions(\n+    tcx: TyCtxt<'tcx>,\n+    region: ty::Region<'tcx>,\n+) -> (String, Option<Span>) {\n+    let cm = tcx.sess.source_map();\n+\n+    let scope = region.free_region_binding_scope(tcx);\n+    let node = tcx.hir().as_local_hir_id(scope).unwrap_or(hir::DUMMY_HIR_ID);\n+    let tag = match tcx.hir().find(node) {\n+        Some(Node::Block(_)) | Some(Node::Expr(_)) => \"body\",\n+        Some(Node::Item(it)) => item_scope_tag(&it),\n+        Some(Node::TraitItem(it)) => trait_item_scope_tag(&it),\n+        Some(Node::ImplItem(it)) => impl_item_scope_tag(&it),\n+        _ => unreachable!(),\n+    };\n+    let (prefix, span) = match *region {\n+        ty::ReEarlyBound(ref br) => {\n+            let mut sp = cm.def_span(tcx.hir().span(node));\n+            if let Some(param) =\n+                tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(br.name))\n+            {\n+                sp = param.span;\n+            }\n+            (format!(\"the lifetime `{}` as defined on\", br.name), sp)\n         }\n-    }\n-\n-    fn item_scope_tag(item: &hir::Item<'_>) -> &'static str {\n-        match item.kind {\n-            hir::ItemKind::Impl(..) => \"impl\",\n-            hir::ItemKind::Struct(..) => \"struct\",\n-            hir::ItemKind::Union(..) => \"union\",\n-            hir::ItemKind::Enum(..) => \"enum\",\n-            hir::ItemKind::Trait(..) => \"trait\",\n-            hir::ItemKind::Fn(..) => \"function body\",\n-            _ => \"item\",\n+        ty::ReFree(ty::FreeRegion { bound_region: ty::BoundRegion::BrNamed(_, name), .. }) => {\n+            let mut sp = cm.def_span(tcx.hir().span(node));\n+            if let Some(param) =\n+                tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n+            {\n+                sp = param.span;\n+            }\n+            (format!(\"the lifetime `{}` as defined on\", name), sp)\n         }\n+        ty::ReFree(ref fr) => match fr.bound_region {\n+            ty::BrAnon(idx) => {\n+                (format!(\"the anonymous lifetime #{} defined on\", idx + 1), tcx.hir().span(node))\n+            }\n+            _ => (\n+                format!(\"the lifetime `{}` as defined on\", region),\n+                cm.def_span(tcx.hir().span(node)),\n+            ),\n+        },\n+        _ => bug!(),\n+    };\n+    let (msg, opt_span) = explain_span(tcx, tag, span);\n+    (format!(\"{} {}\", prefix, msg), opt_span)\n+}\n+\n+fn emit_msg_span(\n+    err: &mut DiagnosticBuilder<'_>,\n+    prefix: &str,\n+    description: String,\n+    span: Option<Span>,\n+    suffix: &str,\n+) {\n+    let message = format!(\"{}{}{}\", prefix, description, suffix);\n+\n+    if let Some(span) = span {\n+        err.span_note(span, &message);\n+    } else {\n+        err.note(&message);\n     }\n+}\n \n-    fn trait_item_scope_tag(item: &hir::TraitItem<'_>) -> &'static str {\n-        match item.kind {\n-            hir::TraitItemKind::Method(..) => \"method body\",\n-            hir::TraitItemKind::Const(..) | hir::TraitItemKind::Type(..) => \"associated item\",\n-        }\n+fn item_scope_tag(item: &hir::Item<'_>) -> &'static str {\n+    match item.kind {\n+        hir::ItemKind::Impl(..) => \"impl\",\n+        hir::ItemKind::Struct(..) => \"struct\",\n+        hir::ItemKind::Union(..) => \"union\",\n+        hir::ItemKind::Enum(..) => \"enum\",\n+        hir::ItemKind::Trait(..) => \"trait\",\n+        hir::ItemKind::Fn(..) => \"function body\",\n+        _ => \"item\",\n     }\n+}\n \n-    fn impl_item_scope_tag(item: &hir::ImplItem<'_>) -> &'static str {\n-        match item.kind {\n-            hir::ImplItemKind::Method(..) => \"method body\",\n-            hir::ImplItemKind::Const(..)\n-            | hir::ImplItemKind::OpaqueTy(..)\n-            | hir::ImplItemKind::TyAlias(..) => \"associated item\",\n-        }\n+fn trait_item_scope_tag(item: &hir::TraitItem<'_>) -> &'static str {\n+    match item.kind {\n+        hir::TraitItemKind::Method(..) => \"method body\",\n+        hir::TraitItemKind::Const(..) | hir::TraitItemKind::Type(..) => \"associated item\",\n     }\n+}\n \n-    fn explain_span(self, heading: &str, span: Span) -> (String, Option<Span>) {\n-        let lo = self.sess.source_map().lookup_char_pos(span.lo());\n-        (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize() + 1), Some(span))\n+fn impl_item_scope_tag(item: &hir::ImplItem<'_>) -> &'static str {\n+    match item.kind {\n+        hir::ImplItemKind::Method(..) => \"method body\",\n+        hir::ImplItemKind::Const(..)\n+        | hir::ImplItemKind::OpaqueTy(..)\n+        | hir::ImplItemKind::TyAlias(..) => \"associated item\",\n     }\n }\n \n+fn explain_span(tcx: TyCtxt<'tcx>, heading: &str, span: Span) -> (String, Option<Span>) {\n+    let lo = tcx.sess.source_map().lookup_char_pos(span.lo());\n+    (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize() + 1), Some(span))\n+}\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn report_region_errors(\n         &self,\n@@ -1489,8 +1488,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let failure_code = trace.cause.as_failure_code(terr);\n         let mut diag = match failure_code {\n             FailureCode::Error0038(did) => {\n-                let violations = self.tcx.object_safety_violations(did);\n-                self.tcx.report_object_safety_error(span, did, violations)\n+                let violations = object_safety_violations(self.tcx, did);\n+                report_object_safety_error(self.tcx, span, did, violations)\n             }\n             FailureCode::Error0317(failure_str) => {\n                 struct_span_err!(self.tcx.sess, span, E0317, \"{}\", failure_str)\n@@ -1719,7 +1718,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"consider adding an explicit lifetime bound for `{}`\",\n                     bound_kind\n                 ));\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     &format!(\"{} must be valid for \", labeled_user_string),\n@@ -1747,7 +1747,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) {\n         let mut err = self.report_inference_failure(var_origin);\n \n-        self.tcx.note_and_explain_region(\n+        note_and_explain_region(\n+            self.tcx,\n             region_scope_tree,\n             &mut err,\n             \"first, the lifetime cannot outlive \",\n@@ -1771,7 +1772,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     (self.values_str(&sup_trace.values), self.values_str(&sub_trace.values))\n                 {\n                     if sub_expected == sup_expected && sub_found == sup_found {\n-                        self.tcx.note_and_explain_region(\n+                        note_and_explain_region(\n+                            self.tcx,\n                             region_scope_tree,\n                             &mut err,\n                             \"...but the lifetime must also be valid for \",\n@@ -1794,7 +1796,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         self.note_region_origin(&mut err, &sup_origin);\n \n-        self.tcx.note_and_explain_region(\n+        note_and_explain_region(\n+            self.tcx,\n             region_scope_tree,\n             &mut err,\n             \"but, the lifetime must be valid for \","}, {"sha": "6c78e70a4444d785cb6da19cf65305568291f2e6", "filename": "src/librustc/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -1,5 +1,6 @@\n //! Error Reporting for static impl Traits.\n \n+use crate::infer::error_reporting::msg_span_from_free_region;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::ty::{BoundRegion, FreeRegion, RegionKind};\n@@ -32,7 +33,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                     );\n                     err.span_label(sup_origin.span(), \"...but this borrow...\");\n \n-                    let (lifetime, lt_sp_opt) = self.tcx().msg_span_from_free_region(sup_r);\n+                    let (lifetime, lt_sp_opt) = msg_span_from_free_region(self.tcx(), sup_r);\n                     if let Some(lifetime_sp) = lt_sp_opt {\n                         err.span_note(lifetime_sp, &format!(\"...can't outlive {}\", lifetime));\n                     }"}, {"sha": "7919274c373224678b3e058d6d9a92218a17faa2", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 70, "deletions": 35, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -1,3 +1,4 @@\n+use crate::infer::error_reporting::note_and_explain_region;\n use crate::infer::{self, InferCtxt, SubregionOrigin};\n use crate::middle::region;\n use crate::ty::error::TypeError;\n@@ -167,8 +168,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             infer::Subtype(box trace) => {\n                 let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n                 let mut err = self.report_and_explain_type_error(trace, &terr);\n-                self.tcx.note_and_explain_region(region_scope_tree, &mut err, \"\", sup, \"...\");\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(self.tcx, region_scope_tree, &mut err, \"\", sup, \"...\");\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"...does not necessarily outlive \",\n@@ -185,14 +187,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"lifetime of reference outlives lifetime of \\\n                                                 borrowed content...\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"...the reference is valid for \",\n                     sub,\n                     \"...\",\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"...but the borrowed content is only valid for \",\n@@ -211,14 +215,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                 of captured variable `{}`...\",\n                     var_name\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"...the borrowed pointer is valid for \",\n                     sub,\n                     \"...\",\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     &format!(\"...but `{}` is only valid for \", var_name),\n@@ -230,14 +236,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             infer::InfStackClosure(span) => {\n                 let mut err =\n                     struct_span_err!(self.tcx.sess, span, E0314, \"closure outlives stack frame\");\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"...the closure must be valid for \",\n                     sub,\n                     \"...\",\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"...but the closure's stack frame is only valid \\\n@@ -254,7 +262,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     E0315,\n                     \"cannot invoke closure outside of its lifetime\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the closure is only valid for \",\n@@ -270,7 +279,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     E0473,\n                     \"dereference of reference outside its lifetime\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the reference is only valid for \",\n@@ -288,14 +298,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                 enclosing closure\",\n                     self.tcx.hir().name(id)\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"captured variable is valid for \",\n                     sup,\n                     \"\",\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"closure is valid for \",\n@@ -311,7 +323,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     E0475,\n                     \"index of slice outside its lifetime\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the slice is only valid for \",\n@@ -328,14 +341,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"lifetime of the source pointer does not outlive \\\n                                                 lifetime bound of the object type\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"object type is valid for \",\n                     sub,\n                     \"\",\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"source pointer is only valid for \",\n@@ -354,14 +369,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.ty_to_string(ty)\n                 );\n                 match *sub {\n-                    ty::ReStatic => self.tcx.note_and_explain_region(\n+                    ty::ReStatic => note_and_explain_region(\n+                        self.tcx,\n                         region_scope_tree,\n                         &mut err,\n                         \"type must satisfy \",\n                         sub,\n                         \"\",\n                     ),\n-                    _ => self.tcx.note_and_explain_region(\n+                    _ => note_and_explain_region(\n+                        self.tcx,\n                         region_scope_tree,\n                         &mut err,\n                         \"type must outlive \",\n@@ -374,14 +391,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             infer::RelateRegionParamBound(span) => {\n                 let mut err =\n                     struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"lifetime parameter instantiated with \",\n                     sup,\n                     \"\",\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"but lifetime parameter must outlive \",\n@@ -399,7 +418,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                 parameter) is not valid at this point\",\n                     self.ty_to_string(ty)\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"type must outlive \",\n@@ -416,7 +436,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"lifetime of method receiver does not outlive the \\\n                                                 method call\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the receiver is only valid for \",\n@@ -433,7 +454,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"lifetime of function argument does not outlive \\\n                                                 the function call\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the function argument is only valid for \",\n@@ -450,7 +472,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"lifetime of return value does not outlive the \\\n                                                 function call\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the return value is only valid for \",\n@@ -467,7 +490,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"lifetime of operand does not outlive the \\\n                                                 operation\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the operand is only valid for \",\n@@ -483,7 +507,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     E0484,\n                     \"reference is not valid at the time of borrow\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the borrow is only valid for \",\n@@ -500,7 +525,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"automatically reference is not valid at the time \\\n                                                 of borrow\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the automatic borrow is only valid for \",\n@@ -518,7 +544,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                 not valid during the expression: `{}`\",\n                     self.ty_to_string(t)\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"type is only valid for \",\n@@ -536,14 +563,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                 called while references are dead\"\n                 );\n                 // FIXME (22171): terms \"super/subregion\" are suboptimal\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"superregion: \",\n                     sup,\n                     \"\",\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"subregion: \",\n@@ -560,7 +589,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"lifetime of variable does not enclose its \\\n                                                 declaration\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the variable is only valid for \",\n@@ -576,7 +606,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     E0489,\n                     \"type/lifetime parameter not in scope here\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the parameter is only valid for \",\n@@ -593,14 +624,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"a value of type `{}` is borrowed for too long\",\n                     self.ty_to_string(ty)\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the type is valid for \",\n                     sub,\n                     \"\",\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"but the borrow lasts for \",\n@@ -618,14 +651,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                 than the data it references\",\n                     self.ty_to_string(ty)\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the pointer is valid for \",\n                     sub,\n                     \"\",\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"but the referenced data is only valid for \","}, {"sha": "a22ed9409613267edfd4fb5ecd0876aabf11a6ba", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 73, "deletions": 5, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -1,8 +1,9 @@\n-use crate::infer::outlives::free_region_map::FreeRegionRelations;\n+use crate::infer::error_reporting::{note_and_explain_free_region, note_and_explain_region};\n use crate::infer::{self, InferCtxt, InferOk, TypeVariableOrigin, TypeVariableOriginKind};\n use crate::middle::region;\n use crate::traits::{self, PredicateObligation};\n use crate::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n+use crate::ty::free_region_map::FreeRegionRelations;\n use crate::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef};\n use crate::ty::{self, GenericParamDefKind, Ty, TyCtxt};\n use errors::DiagnosticBuilder;\n@@ -349,7 +350,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             debug!(\"constrain_opaque_type: bounds={:#?}\", bounds);\n             let opaque_type = tcx.mk_opaque(def_id, opaque_defn.substs);\n \n-            let required_region_bounds = tcx.required_region_bounds(opaque_type, bounds.predicates);\n+            let required_region_bounds =\n+                required_region_bounds(tcx, opaque_type, bounds.predicates);\n             debug_assert!(!required_region_bounds.is_empty());\n \n             for required_region in required_region_bounds {\n@@ -624,7 +626,8 @@ pub fn unexpected_hidden_region_diagnostic(\n         //\n         // (*) if not, the `tainted_by_errors` flag would be set to\n         // true in any case, so we wouldn't be here at all.\n-        tcx.note_and_explain_free_region(\n+        note_and_explain_free_region(\n+            tcx,\n             &mut err,\n             &format!(\"hidden type `{}` captures \", hidden_ty),\n             hidden_region,\n@@ -649,7 +652,8 @@ pub fn unexpected_hidden_region_diagnostic(\n             // If the `region_scope_tree` is available, this is being\n             // invoked from the \"region inferencer error\". We can at\n             // least report a really cryptic error for now.\n-            tcx.note_and_explain_region(\n+            note_and_explain_region(\n+                tcx,\n                 region_scope_tree,\n                 &mut err,\n                 &format!(\"hidden type `{}` captures \", hidden_ty),\n@@ -1130,7 +1134,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n \n         debug!(\"instantiate_opaque_types: bounds={:?}\", bounds);\n \n-        let required_region_bounds = tcx.required_region_bounds(ty, bounds.predicates.clone());\n+        let required_region_bounds = required_region_bounds(tcx, ty, bounds.predicates.clone());\n         debug!(\"instantiate_opaque_types: required_region_bounds={:?}\", required_region_bounds);\n \n         // Make sure that we are in fact defining the *entire* type\n@@ -1225,3 +1229,67 @@ pub fn may_define_opaque_type(tcx: TyCtxt<'_>, def_id: DefId, opaque_hir_id: hir\n     );\n     res\n }\n+\n+/// Given a set of predicates that apply to an object type, returns\n+/// the region bounds that the (erased) `Self` type must\n+/// outlive. Precisely *because* the `Self` type is erased, the\n+/// parameter `erased_self_ty` must be supplied to indicate what type\n+/// has been used to represent `Self` in the predicates\n+/// themselves. This should really be a unique type; `FreshTy(0)` is a\n+/// popular choice.\n+///\n+/// N.B., in some cases, particularly around higher-ranked bounds,\n+/// this function returns a kind of conservative approximation.\n+/// That is, all regions returned by this function are definitely\n+/// required, but there may be other region bounds that are not\n+/// returned, as well as requirements like `for<'a> T: 'a`.\n+///\n+/// Requires that trait definitions have been processed so that we can\n+/// elaborate predicates and walk supertraits.\n+//\n+// FIXME: callers may only have a `&[Predicate]`, not a `Vec`, so that's\n+// what this code should accept.\n+crate fn required_region_bounds(\n+    tcx: TyCtxt<'tcx>,\n+    erased_self_ty: Ty<'tcx>,\n+    predicates: Vec<ty::Predicate<'tcx>>,\n+) -> Vec<ty::Region<'tcx>> {\n+    debug!(\n+        \"required_region_bounds(erased_self_ty={:?}, predicates={:?})\",\n+        erased_self_ty, predicates\n+    );\n+\n+    assert!(!erased_self_ty.has_escaping_bound_vars());\n+\n+    traits::elaborate_predicates(tcx, predicates)\n+        .filter_map(|predicate| {\n+            match predicate {\n+                ty::Predicate::Projection(..)\n+                | ty::Predicate::Trait(..)\n+                | ty::Predicate::Subtype(..)\n+                | ty::Predicate::WellFormed(..)\n+                | ty::Predicate::ObjectSafe(..)\n+                | ty::Predicate::ClosureKind(..)\n+                | ty::Predicate::RegionOutlives(..)\n+                | ty::Predicate::ConstEvaluatable(..) => None,\n+                ty::Predicate::TypeOutlives(predicate) => {\n+                    // Search for a bound of the form `erased_self_ty\n+                    // : 'a`, but be wary of something like `for<'a>\n+                    // erased_self_ty : 'a` (we interpret a\n+                    // higher-ranked bound like that as 'static,\n+                    // though at present the code in `fulfill.rs`\n+                    // considers such bounds to be unsatisfiable, so\n+                    // it's kind of a moot point since you could never\n+                    // construct such an object, but this seems\n+                    // correct even if that code changes).\n+                    let ty::OutlivesPredicate(ref t, ref r) = predicate.skip_binder();\n+                    if t == &erased_self_ty && !r.has_escaping_bound_vars() {\n+                        Some(*r)\n+                    } else {\n+                        None\n+                    }\n+                }\n+            }\n+        })\n+        .collect()\n+}"}, {"sha": "ee2e629c2fcd269bf053bf8d0bd48c47b91a4ddc", "filename": "src/librustc/infer/outlives/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -1,6 +1,6 @@\n-use crate::infer::outlives::free_region_map::FreeRegionMap;\n use crate::infer::{GenericKind, InferCtxt};\n use crate::traits::query::outlives_bounds::{self, OutlivesBound};\n+use crate::ty::free_region_map::FreeRegionMap;\n use crate::ty::{self, Ty};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;"}, {"sha": "6fc72470c9fb7816a822e689ee5f57557fec7451", "filename": "src/librustc/infer/outlives/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -1,6 +1,5 @@\n //! Various code related to computing outlives relations.\n \n pub mod env;\n-pub mod free_region_map;\n pub mod obligations;\n pub mod verify;"}, {"sha": "355f949b8700860fdf005758da74bf50f03c7fb8", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -3,8 +3,8 @@\n //! or explicit bounds. In that case, we track the bounds using the `TransitiveRelation` type,\n //! and use that to decide when one free region outlives another, and so forth.\n \n-use crate::infer::outlives::free_region_map::{FreeRegionMap, FreeRegionRelations};\n use crate::middle::region;\n+use crate::ty::free_region_map::{FreeRegionMap, FreeRegionRelations};\n use crate::ty::{self, Region, TyCtxt};\n use rustc_hir::def_id::DefId;\n "}, {"sha": "f2474faa75e4402f8fe9c3245320bdf0968aaadf", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -245,35 +245,35 @@ pub enum EvalResult {\n     Unmarked,\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    // See issue #38412.\n-    fn skip_stability_check_due_to_privacy(self, mut def_id: DefId) -> bool {\n-        // Check if `def_id` is a trait method.\n-        match self.def_kind(def_id) {\n-            Some(DefKind::Method) | Some(DefKind::AssocTy) | Some(DefKind::AssocConst) => {\n-                if let ty::TraitContainer(trait_def_id) = self.associated_item(def_id).container {\n-                    // Trait methods do not declare visibility (even\n-                    // for visibility info in cstore). Use containing\n-                    // trait instead, so methods of `pub` traits are\n-                    // themselves considered `pub`.\n-                    def_id = trait_def_id;\n-                }\n+// See issue #38412.\n+fn skip_stability_check_due_to_privacy(tcx: TyCtxt<'_>, mut def_id: DefId) -> bool {\n+    // Check if `def_id` is a trait method.\n+    match tcx.def_kind(def_id) {\n+        Some(DefKind::Method) | Some(DefKind::AssocTy) | Some(DefKind::AssocConst) => {\n+            if let ty::TraitContainer(trait_def_id) = tcx.associated_item(def_id).container {\n+                // Trait methods do not declare visibility (even\n+                // for visibility info in cstore). Use containing\n+                // trait instead, so methods of `pub` traits are\n+                // themselves considered `pub`.\n+                def_id = trait_def_id;\n             }\n-            _ => {}\n         }\n+        _ => {}\n+    }\n \n-        let visibility = self.visibility(def_id);\n+    let visibility = tcx.visibility(def_id);\n \n-        match visibility {\n-            // Must check stability for `pub` items.\n-            ty::Visibility::Public => false,\n+    match visibility {\n+        // Must check stability for `pub` items.\n+        ty::Visibility::Public => false,\n \n-            // These are not visible outside crate; therefore\n-            // stability markers are irrelevant, if even present.\n-            ty::Visibility::Restricted(..) | ty::Visibility::Invisible => true,\n-        }\n+        // These are not visible outside crate; therefore\n+        // stability markers are irrelevant, if even present.\n+        ty::Visibility::Restricted(..) | ty::Visibility::Invisible => true,\n     }\n+}\n \n+impl<'tcx> TyCtxt<'tcx> {\n     /// Evaluates the stability of an item.\n     ///\n     /// Returns `EvalResult::Allow` if the item is stable, or unstable but the corresponding\n@@ -338,7 +338,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n \n         // Issue #38412: private items lack stability markers.\n-        if self.skip_stability_check_due_to_privacy(def_id) {\n+        if skip_stability_check_due_to_privacy(self, def_id) {\n             return EvalResult::Allow;\n         }\n \n@@ -402,9 +402,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         }\n     }\n-}\n \n-impl<'tcx> TyCtxt<'tcx> {\n     pub fn lookup_deprecation(self, id: DefId) -> Option<Deprecation> {\n         self.lookup_deprecation_entry(id).map(|depr| depr.attr)\n     }"}, {"sha": "8a264a79fb6c27cc8d82861e9cd323c640315c88", "filename": "src/librustc/traits/codegen/mod.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -8,7 +8,6 @@ use crate::traits::{\n     FulfillmentContext, Obligation, ObligationCause, SelectionContext, TraitEngine, Vtable,\n };\n use crate::ty::fold::TypeFoldable;\n-use crate::ty::subst::{Subst, SubstsRef};\n use crate::ty::{self, TyCtxt};\n \n /// Attempts to resolve an obligation to a vtable. The result is\n@@ -76,31 +75,6 @@ pub fn codegen_fulfill_obligation<'tcx>(\n     })\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    /// Monomorphizes a type from the AST by first applying the\n-    /// in-scope substitutions and then normalizing any associated\n-    /// types.\n-    pub fn subst_and_normalize_erasing_regions<T>(\n-        self,\n-        param_substs: SubstsRef<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        value: &T,\n-    ) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        debug!(\n-            \"subst_and_normalize_erasing_regions(\\\n-             param_substs={:?}, \\\n-             value={:?}, \\\n-             param_env={:?})\",\n-            param_substs, value, param_env,\n-        );\n-        let substituted = value.subst(self, param_substs);\n-        self.normalize_erasing_regions(param_env, substituted)\n-    }\n-}\n-\n // # Global Cache\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {"}, {"sha": "172330dbc7ee5e35ee5b7e1cdcd88ac4cefa86e5", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 56, "deletions": 57, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -11,6 +11,7 @@ use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{self, InferCtxt};\n use crate::mir::interpret::ErrorHandled;\n use crate::session::DiagnosticMessageId;\n+use crate::traits::object_safety_violations;\n use crate::ty::error::ExpectedFound;\n use crate::ty::fast_reject;\n use crate::ty::fold::TypeFolder;\n@@ -915,8 +916,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     }\n \n                     ty::Predicate::ObjectSafe(trait_def_id) => {\n-                        let violations = self.tcx.object_safety_violations(trait_def_id);\n-                        self.tcx.report_object_safety_error(span, trait_def_id, violations)\n+                        let violations = object_safety_violations(self.tcx, trait_def_id);\n+                        report_object_safety_error(self.tcx, span, trait_def_id, violations)\n                     }\n \n                     ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n@@ -1079,8 +1080,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n \n             TraitNotObjectSafe(did) => {\n-                let violations = self.tcx.object_safety_violations(did);\n-                self.tcx.report_object_safety_error(span, did, violations)\n+                let violations = object_safety_violations(self.tcx, did);\n+                report_object_safety_error(self.tcx, span, did, violations)\n             }\n \n             // already reported in the query\n@@ -1945,64 +1946,62 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn recursive_type_with_infinite_size_error(\n-        self,\n-        type_def_id: DefId,\n-    ) -> DiagnosticBuilder<'tcx> {\n-        assert!(type_def_id.is_local());\n-        let span = self.hir().span_if_local(type_def_id).unwrap();\n-        let span = self.sess.source_map().def_span(span);\n-        let mut err = struct_span_err!(\n-            self.sess,\n-            span,\n-            E0072,\n-            \"recursive type `{}` has infinite size\",\n-            self.def_path_str(type_def_id)\n-        );\n-        err.span_label(span, \"recursive type has infinite size\");\n-        err.help(&format!(\n-            \"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n+pub fn recursive_type_with_infinite_size_error(\n+    tcx: TyCtxt<'tcx>,\n+    type_def_id: DefId,\n+) -> DiagnosticBuilder<'tcx> {\n+    assert!(type_def_id.is_local());\n+    let span = tcx.hir().span_if_local(type_def_id).unwrap();\n+    let span = tcx.sess.source_map().def_span(span);\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0072,\n+        \"recursive type `{}` has infinite size\",\n+        tcx.def_path_str(type_def_id)\n+    );\n+    err.span_label(span, \"recursive type has infinite size\");\n+    err.help(&format!(\n+        \"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n                            at some point to make `{}` representable\",\n-            self.def_path_str(type_def_id)\n-        ));\n-        err\n-    }\n-\n-    pub fn report_object_safety_error(\n-        self,\n-        span: Span,\n-        trait_def_id: DefId,\n-        violations: Vec<ObjectSafetyViolation>,\n-    ) -> DiagnosticBuilder<'tcx> {\n-        let trait_str = self.def_path_str(trait_def_id);\n-        let span = self.sess.source_map().def_span(span);\n-        let mut err = struct_span_err!(\n-            self.sess,\n-            span,\n-            E0038,\n-            \"the trait `{}` cannot be made into an object\",\n-            trait_str\n-        );\n-        err.span_label(span, format!(\"the trait `{}` cannot be made into an object\", trait_str));\n-\n-        let mut reported_violations = FxHashSet::default();\n-        for violation in violations {\n-            if reported_violations.insert(violation.clone()) {\n-                match violation.span() {\n-                    Some(span) => err.span_label(span, violation.error_msg()),\n-                    None => err.note(&violation.error_msg()),\n-                };\n-            }\n-        }\n+        tcx.def_path_str(type_def_id)\n+    ));\n+    err\n+}\n \n-        if self.sess.trait_methods_not_found.borrow().contains(&span) {\n-            // Avoid emitting error caused by non-existing method (#58734)\n-            err.cancel();\n+pub fn report_object_safety_error(\n+    tcx: TyCtxt<'tcx>,\n+    span: Span,\n+    trait_def_id: DefId,\n+    violations: Vec<ObjectSafetyViolation>,\n+) -> DiagnosticBuilder<'tcx> {\n+    let trait_str = tcx.def_path_str(trait_def_id);\n+    let span = tcx.sess.source_map().def_span(span);\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0038,\n+        \"the trait `{}` cannot be made into an object\",\n+        trait_str\n+    );\n+    err.span_label(span, format!(\"the trait `{}` cannot be made into an object\", trait_str));\n+\n+    let mut reported_violations = FxHashSet::default();\n+    for violation in violations {\n+        if reported_violations.insert(violation.clone()) {\n+            match violation.span() {\n+                Some(span) => err.span_label(span, violation.error_msg()),\n+                None => err.note(&violation.error_msg()),\n+            };\n         }\n+    }\n \n-        err\n+    if tcx.sess.trait_methods_not_found.borrow().contains(&span) {\n+        // Avoid emitting error caused by non-existing method (#58734)\n+        err.cancel();\n     }\n+\n+    err\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {"}, {"sha": "b0b6994945c5f21a4a4df54e74567ae03057d337", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -9,6 +9,7 @@ use std::marker::PhantomData;\n use super::engine::{TraitEngine, TraitEngineExt};\n use super::project;\n use super::select::SelectionContext;\n+use super::wf;\n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n use super::CodeSelectionError;\n@@ -461,7 +462,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n             }\n \n             ty::Predicate::WellFormed(ty) => {\n-                match ty::wf::obligations(\n+                match wf::obligations(\n                     self.selcx.infcx(),\n                     obligation.param_env,\n                     obligation.cause.body_id,"}, {"sha": "08c3a77bf3aca5ff78fd5654d97770d3d68848c9", "filename": "src/librustc/traits/misc.rs", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmisc.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -0,0 +1,202 @@\n+//! Miscellaneous type-system utilities that are too small to deserve their own modules.\n+\n+use crate::middle::lang_items;\n+use crate::traits::{self, ObligationCause};\n+use crate::ty::util::NeedsDrop;\n+use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n+\n+use rustc_hir as hir;\n+use rustc_span::DUMMY_SP;\n+\n+#[derive(Clone)]\n+pub enum CopyImplementationError<'tcx> {\n+    InfrigingFields(Vec<&'tcx ty::FieldDef>),\n+    NotAnAdt,\n+    HasDestructor,\n+}\n+\n+pub fn can_type_implement_copy(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    self_type: Ty<'tcx>,\n+) -> Result<(), CopyImplementationError<'tcx>> {\n+    // FIXME: (@jroesch) float this code up\n+    tcx.infer_ctxt().enter(|infcx| {\n+        let (adt, substs) = match self_type.kind {\n+            // These types used to have a builtin impl.\n+            // Now libcore provides that impl.\n+            ty::Uint(_)\n+            | ty::Int(_)\n+            | ty::Bool\n+            | ty::Float(_)\n+            | ty::Char\n+            | ty::RawPtr(..)\n+            | ty::Never\n+            | ty::Ref(_, _, hir::Mutability::Not) => return Ok(()),\n+\n+            ty::Adt(adt, substs) => (adt, substs),\n+\n+            _ => return Err(CopyImplementationError::NotAnAdt),\n+        };\n+\n+        let mut infringing = Vec::new();\n+        for variant in &adt.variants {\n+            for field in &variant.fields {\n+                let ty = field.ty(tcx, substs);\n+                if ty.references_error() {\n+                    continue;\n+                }\n+                let span = tcx.def_span(field.did);\n+                let cause = ObligationCause { span, ..ObligationCause::dummy() };\n+                let ctx = traits::FulfillmentContext::new();\n+                match traits::fully_normalize(&infcx, ctx, cause, param_env, &ty) {\n+                    Ok(ty) => {\n+                        if !infcx.type_is_copy_modulo_regions(param_env, ty, span) {\n+                            infringing.push(field);\n+                        }\n+                    }\n+                    Err(errors) => {\n+                        infcx.report_fulfillment_errors(&errors, None, false);\n+                    }\n+                };\n+            }\n+        }\n+        if !infringing.is_empty() {\n+            return Err(CopyImplementationError::InfrigingFields(infringing));\n+        }\n+        if adt.has_dtor(tcx) {\n+            return Err(CopyImplementationError::HasDestructor);\n+        }\n+\n+        Ok(())\n+    })\n+}\n+\n+fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+    is_item_raw(tcx, query, lang_items::CopyTraitLangItem)\n+}\n+\n+fn is_sized_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+    is_item_raw(tcx, query, lang_items::SizedTraitLangItem)\n+}\n+\n+fn is_freeze_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+    is_item_raw(tcx, query, lang_items::FreezeTraitLangItem)\n+}\n+\n+fn is_item_raw<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n+    item: lang_items::LangItem,\n+) -> bool {\n+    let (param_env, ty) = query.into_parts();\n+    let trait_def_id = tcx.require_lang_item(item, None);\n+    tcx.infer_ctxt().enter(|infcx| {\n+        traits::type_known_to_meet_bound_modulo_regions(\n+            &infcx,\n+            param_env,\n+            ty,\n+            trait_def_id,\n+            DUMMY_SP,\n+        )\n+    })\n+}\n+\n+fn needs_drop_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> NeedsDrop {\n+    let (param_env, ty) = query.into_parts();\n+\n+    let needs_drop = |ty: Ty<'tcx>| -> bool { tcx.needs_drop_raw(param_env.and(ty)).0 };\n+\n+    assert!(!ty.needs_infer());\n+\n+    NeedsDrop(match ty.kind {\n+        // Fast-path for primitive types\n+        ty::Infer(ty::FreshIntTy(_))\n+        | ty::Infer(ty::FreshFloatTy(_))\n+        | ty::Bool\n+        | ty::Int(_)\n+        | ty::Uint(_)\n+        | ty::Float(_)\n+        | ty::Never\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::Char\n+        | ty::GeneratorWitness(..)\n+        | ty::RawPtr(_)\n+        | ty::Ref(..)\n+        | ty::Str => false,\n+\n+        // Foreign types can never have destructors\n+        ty::Foreign(..) => false,\n+\n+        // `ManuallyDrop` doesn't have a destructor regardless of field types.\n+        ty::Adt(def, _) if Some(def.did) == tcx.lang_items().manually_drop() => false,\n+\n+        // Issue #22536: We first query `is_copy_modulo_regions`.  It sees a\n+        // normalized version of the type, and therefore will definitely\n+        // know whether the type implements Copy (and thus needs no\n+        // cleanup/drop/zeroing) ...\n+        _ if ty.is_copy_modulo_regions(tcx, param_env, DUMMY_SP) => false,\n+\n+        // ... (issue #22536 continued) but as an optimization, still use\n+        // prior logic of asking for the structural \"may drop\".\n+\n+        // FIXME(#22815): Note that this is a conservative heuristic;\n+        // it may report that the type \"may drop\" when actual type does\n+        // not actually have a destructor associated with it. But since\n+        // the type absolutely did not have the `Copy` bound attached\n+        // (see above), it is sound to treat it as having a destructor.\n+\n+        // User destructors are the only way to have concrete drop types.\n+        ty::Adt(def, _) if def.has_dtor(tcx) => true,\n+\n+        // Can refer to a type which may drop.\n+        // FIXME(eddyb) check this against a ParamEnv.\n+        ty::Dynamic(..)\n+        | ty::Projection(..)\n+        | ty::Param(_)\n+        | ty::Bound(..)\n+        | ty::Placeholder(..)\n+        | ty::Opaque(..)\n+        | ty::Infer(_)\n+        | ty::Error => true,\n+\n+        ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n+\n+        // Zero-length arrays never contain anything to drop.\n+        ty::Array(_, len) if len.try_eval_usize(tcx, param_env) == Some(0) => false,\n+\n+        // Structural recursion.\n+        ty::Array(ty, _) | ty::Slice(ty) => needs_drop(ty),\n+\n+        ty::Closure(def_id, ref substs) => {\n+            substs.as_closure().upvar_tys(def_id, tcx).any(needs_drop)\n+        }\n+\n+        // Pessimistically assume that all generators will require destructors\n+        // as we don't know if a destructor is a noop or not until after the MIR\n+        // state transformation pass\n+        ty::Generator(..) => true,\n+\n+        ty::Tuple(..) => ty.tuple_fields().any(needs_drop),\n+\n+        // unions don't have destructors because of the child types,\n+        // only if they manually implement `Drop` (handled above).\n+        ty::Adt(def, _) if def.is_union() => false,\n+\n+        ty::Adt(def, substs) => def\n+            .variants\n+            .iter()\n+            .any(|variant| variant.fields.iter().any(|field| needs_drop(field.ty(tcx, substs)))),\n+    })\n+}\n+\n+pub fn provide(providers: &mut ty::query::Providers<'_>) {\n+    *providers = ty::query::Providers {\n+        is_copy_raw,\n+        is_sized_raw,\n+        is_freeze_raw,\n+        needs_drop_raw,\n+        ..*providers\n+    };\n+}"}, {"sha": "2d3160dc3e51a430b03bcbcad748f04f4294679a", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -10,14 +10,17 @@ mod coherence;\n mod engine;\n pub mod error_reporting;\n mod fulfill;\n+pub mod misc;\n mod object_safety;\n mod on_unimplemented;\n mod project;\n pub mod query;\n mod select;\n mod specialize;\n mod structural_impls;\n+mod structural_match;\n mod util;\n+pub mod wf;\n \n use crate::infer::outlives::env::OutlivesEnvironment;\n use crate::infer::{InferCtxt, SuppressRegionErrors};\n@@ -47,6 +50,9 @@ pub use self::coherence::{add_placeholder_note, orphan_check, overlapping_impls}\n pub use self::coherence::{OrphanCheckErr, OverlapResult};\n pub use self::engine::{TraitEngine, TraitEngineExt};\n pub use self::fulfill::{FulfillmentContext, PendingPredicateObligation};\n+pub use self::object_safety::astconv_object_safety_violations;\n+pub use self::object_safety::is_vtable_safe_method;\n+pub use self::object_safety::object_safety_violations;\n pub use self::object_safety::MethodViolationCode;\n pub use self::object_safety::ObjectSafetyViolation;\n pub use self::on_unimplemented::{OnUnimplementedDirective, OnUnimplementedNote};\n@@ -59,8 +65,15 @@ pub use self::specialize::find_associated_item;\n pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n pub use self::specialize::{specialization_graph, translate_substs, OverlapError};\n+pub use self::structural_match::search_for_structural_match_violation;\n+pub use self::structural_match::type_marked_structural;\n+pub use self::structural_match::NonStructuralMatchTy;\n pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n+pub use self::util::{\n+    get_vtable_index_of_object_method, impl_is_default, impl_item_is_final,\n+    predicate_for_trait_def, upcast_choices,\n+};\n pub use self::util::{\n     supertrait_def_ids, supertraits, transitive_bounds, SupertraitDefIds, Supertraits,\n };\n@@ -1062,7 +1075,7 @@ fn vtable_methods<'tcx>(\n             let def_id = trait_method.def_id;\n \n             // Some methods cannot be called on an object; skip those.\n-            if !tcx.is_vtable_safe_method(trait_ref.def_id(), &trait_method) {\n+            if !is_vtable_safe_method(tcx, trait_ref.def_id(), &trait_method) {\n                 debug!(\"vtable_methods: not vtable safe\");\n                 return None;\n             }\n@@ -1231,6 +1244,7 @@ impl<'tcx> TraitObligation<'tcx> {\n }\n \n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n+    misc::provide(providers);\n     *providers = ty::query::Providers {\n         is_object_safe: object_safety::is_object_safe_provider,\n         specialization_graph_of: specialize::specialization_graph_provider,"}, {"sha": "bfbcb042e7a7371230b48600c710c4b6b02d5ab0", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 551, "deletions": 546, "changes": 1097, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -108,614 +108,619 @@ pub enum MethodViolationCode {\n     UndispatchableReceiver,\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    /// Returns the object safety violations that affect\n-    /// astconv -- currently, `Self` in supertraits. This is needed\n-    /// because `object_safety_violations` can't be used during\n-    /// type collection.\n-    pub fn astconv_object_safety_violations(\n-        self,\n-        trait_def_id: DefId,\n-    ) -> Vec<ObjectSafetyViolation> {\n-        debug_assert!(self.generics_of(trait_def_id).has_self);\n-        let violations = traits::supertrait_def_ids(self, trait_def_id)\n-            .filter(|&def_id| self.predicates_reference_self(def_id, true))\n-            .map(|_| ObjectSafetyViolation::SupertraitSelf)\n-            .collect();\n+/// Returns the object safety violations that affect\n+/// astconv -- currently, `Self` in supertraits. This is needed\n+/// because `object_safety_violations` can't be used during\n+/// type collection.\n+pub fn astconv_object_safety_violations(\n+    tcx: TyCtxt<'_>,\n+    trait_def_id: DefId,\n+) -> Vec<ObjectSafetyViolation> {\n+    debug_assert!(tcx.generics_of(trait_def_id).has_self);\n+    let violations = traits::supertrait_def_ids(tcx, trait_def_id)\n+        .filter(|&def_id| predicates_reference_self(tcx, def_id, true))\n+        .map(|_| ObjectSafetyViolation::SupertraitSelf)\n+        .collect();\n+\n+    debug!(\"astconv_object_safety_violations(trait_def_id={:?}) = {:?}\", trait_def_id, violations);\n+\n+    violations\n+}\n \n-        debug!(\n-            \"astconv_object_safety_violations(trait_def_id={:?}) = {:?}\",\n-            trait_def_id, violations\n-        );\n+pub fn object_safety_violations(\n+    tcx: TyCtxt<'_>,\n+    trait_def_id: DefId,\n+) -> Vec<ObjectSafetyViolation> {\n+    debug_assert!(tcx.generics_of(trait_def_id).has_self);\n+    debug!(\"object_safety_violations: {:?}\", trait_def_id);\n \n-        violations\n-    }\n-\n-    pub fn object_safety_violations(self, trait_def_id: DefId) -> Vec<ObjectSafetyViolation> {\n-        debug_assert!(self.generics_of(trait_def_id).has_self);\n-        debug!(\"object_safety_violations: {:?}\", trait_def_id);\n+    traits::supertrait_def_ids(tcx, trait_def_id)\n+        .flat_map(|def_id| object_safety_violations_for_trait(tcx, def_id))\n+        .collect()\n+}\n \n-        traits::supertrait_def_ids(self, trait_def_id)\n-            .flat_map(|def_id| self.object_safety_violations_for_trait(def_id))\n-            .collect()\n+/// We say a method is *vtable safe* if it can be invoked on a trait\n+/// object. Note that object-safe traits can have some\n+/// non-vtable-safe methods, so long as they require `Self: Sized` or\n+/// otherwise ensure that they cannot be used when `Self = Trait`.\n+pub fn is_vtable_safe_method(tcx: TyCtxt<'_>, trait_def_id: DefId, method: &ty::AssocItem) -> bool {\n+    debug_assert!(tcx.generics_of(trait_def_id).has_self);\n+    debug!(\"is_vtable_safe_method({:?}, {:?})\", trait_def_id, method);\n+    // Any method that has a `Self: Sized` bound cannot be called.\n+    if generics_require_sized_self(tcx, method.def_id) {\n+        return false;\n     }\n \n-    /// We say a method is *vtable safe* if it can be invoked on a trait\n-    /// object. Note that object-safe traits can have some\n-    /// non-vtable-safe methods, so long as they require `Self: Sized` or\n-    /// otherwise ensure that they cannot be used when `Self = Trait`.\n-    pub fn is_vtable_safe_method(self, trait_def_id: DefId, method: &ty::AssocItem) -> bool {\n-        debug_assert!(self.generics_of(trait_def_id).has_self);\n-        debug!(\"is_vtable_safe_method({:?}, {:?})\", trait_def_id, method);\n-        // Any method that has a `Self: Sized` bound cannot be called.\n-        if self.generics_require_sized_self(method.def_id) {\n-            return false;\n-        }\n-\n-        match self.virtual_call_violation_for_method(trait_def_id, method) {\n-            None | Some(MethodViolationCode::WhereClauseReferencesSelf) => true,\n-            Some(_) => false,\n-        }\n+    match virtual_call_violation_for_method(tcx, trait_def_id, method) {\n+        None | Some(MethodViolationCode::WhereClauseReferencesSelf) => true,\n+        Some(_) => false,\n     }\n+}\n \n-    fn object_safety_violations_for_trait(self, trait_def_id: DefId) -> Vec<ObjectSafetyViolation> {\n-        // Check methods for violations.\n-        let mut violations: Vec<_> = self\n-            .associated_items(trait_def_id)\n-            .filter(|item| item.kind == ty::AssocKind::Method)\n-            .filter_map(|item| {\n-                self.object_safety_violation_for_method(trait_def_id, &item).map(|code| {\n-                    ObjectSafetyViolation::Method(item.ident.name, code, item.ident.span)\n-                })\n-            })\n-            .filter(|violation| {\n-                if let ObjectSafetyViolation::Method(\n-                    _,\n-                    MethodViolationCode::WhereClauseReferencesSelf,\n-                    span,\n-                ) = violation\n-                {\n-                    // Using `CRATE_NODE_ID` is wrong, but it's hard to get a more precise id.\n-                    // It's also hard to get a use site span, so we use the method definition span.\n-                    self.lint_node_note(\n-                        lint::builtin::WHERE_CLAUSES_OBJECT_SAFETY,\n-                        hir::CRATE_HIR_ID,\n-                        *span,\n-                        &format!(\n-                            \"the trait `{}` cannot be made into an object\",\n-                            self.def_path_str(trait_def_id)\n-                        ),\n-                        &violation.error_msg(),\n-                    );\n-                    false\n-                } else {\n-                    true\n-                }\n-            })\n-            .collect();\n-\n-        // Check the trait itself.\n-        if self.trait_has_sized_self(trait_def_id) {\n-            violations.push(ObjectSafetyViolation::SizedSelf);\n-        }\n-        if self.predicates_reference_self(trait_def_id, false) {\n-            violations.push(ObjectSafetyViolation::SupertraitSelf);\n-        }\n-\n-        violations.extend(\n-            self.associated_items(trait_def_id)\n-                .filter(|item| item.kind == ty::AssocKind::Const)\n-                .map(|item| ObjectSafetyViolation::AssocConst(item.ident.name, item.ident.span)),\n-        );\n-\n-        debug!(\n-            \"object_safety_violations_for_trait(trait_def_id={:?}) = {:?}\",\n-            trait_def_id, violations\n-        );\n+fn object_safety_violations_for_trait(\n+    tcx: TyCtxt<'_>,\n+    trait_def_id: DefId,\n+) -> Vec<ObjectSafetyViolation> {\n+    // Check methods for violations.\n+    let mut violations: Vec<_> = tcx\n+        .associated_items(trait_def_id)\n+        .filter(|item| item.kind == ty::AssocKind::Method)\n+        .filter_map(|item| {\n+            object_safety_violation_for_method(tcx, trait_def_id, &item)\n+                .map(|code| ObjectSafetyViolation::Method(item.ident.name, code, item.ident.span))\n+        })\n+        .filter(|violation| {\n+            if let ObjectSafetyViolation::Method(\n+                _,\n+                MethodViolationCode::WhereClauseReferencesSelf,\n+                span,\n+            ) = violation\n+            {\n+                // Using `CRATE_NODE_ID` is wrong, but it's hard to get a more precise id.\n+                // It's also hard to get a use site span, so we use the method definition span.\n+                tcx.lint_node_note(\n+                    lint::builtin::WHERE_CLAUSES_OBJECT_SAFETY,\n+                    hir::CRATE_HIR_ID,\n+                    *span,\n+                    &format!(\n+                        \"the trait `{}` cannot be made into an object\",\n+                        tcx.def_path_str(trait_def_id)\n+                    ),\n+                    &violation.error_msg(),\n+                );\n+                false\n+            } else {\n+                true\n+            }\n+        })\n+        .collect();\n \n-        violations\n+    // Check the trait itself.\n+    if trait_has_sized_self(tcx, trait_def_id) {\n+        violations.push(ObjectSafetyViolation::SizedSelf);\n     }\n-\n-    fn predicates_reference_self(self, trait_def_id: DefId, supertraits_only: bool) -> bool {\n-        let trait_ref = ty::Binder::dummy(ty::TraitRef::identity(self, trait_def_id));\n-        let predicates = if supertraits_only {\n-            self.super_predicates_of(trait_def_id)\n-        } else {\n-            self.predicates_of(trait_def_id)\n-        };\n-        let self_ty = self.types.self_param;\n-        let has_self_ty = |t: Ty<'tcx>| t.walk().any(|t| t == self_ty);\n-        predicates\n-            .predicates\n-            .iter()\n-            .map(|(predicate, _)| predicate.subst_supertrait(self, &trait_ref))\n-            .any(|predicate| {\n-                match predicate {\n-                    ty::Predicate::Trait(ref data) => {\n-                        // In the case of a trait predicate, we can skip the \"self\" type.\n-                        data.skip_binder().input_types().skip(1).any(has_self_ty)\n-                    }\n-                    ty::Predicate::Projection(ref data) => {\n-                        // And similarly for projections. This should be redundant with\n-                        // the previous check because any projection should have a\n-                        // matching `Trait` predicate with the same inputs, but we do\n-                        // the check to be safe.\n-                        //\n-                        // Note that we *do* allow projection *outputs* to contain\n-                        // `self` (i.e., `trait Foo: Bar<Output=Self::Result> { type Result; }`),\n-                        // we just require the user to specify *both* outputs\n-                        // in the object type (i.e., `dyn Foo<Output=(), Result=()>`).\n-                        //\n-                        // This is ALT2 in issue #56288, see that for discussion of the\n-                        // possible alternatives.\n-                        data.skip_binder()\n-                            .projection_ty\n-                            .trait_ref(self)\n-                            .input_types()\n-                            .skip(1)\n-                            .any(has_self_ty)\n-                    }\n-                    ty::Predicate::WellFormed(..)\n-                    | ty::Predicate::ObjectSafe(..)\n-                    | ty::Predicate::TypeOutlives(..)\n-                    | ty::Predicate::RegionOutlives(..)\n-                    | ty::Predicate::ClosureKind(..)\n-                    | ty::Predicate::Subtype(..)\n-                    | ty::Predicate::ConstEvaluatable(..) => false,\n-                }\n-            })\n+    if predicates_reference_self(tcx, trait_def_id, false) {\n+        violations.push(ObjectSafetyViolation::SupertraitSelf);\n     }\n \n-    fn trait_has_sized_self(self, trait_def_id: DefId) -> bool {\n-        self.generics_require_sized_self(trait_def_id)\n-    }\n+    violations.extend(\n+        tcx.associated_items(trait_def_id)\n+            .filter(|item| item.kind == ty::AssocKind::Const)\n+            .map(|item| ObjectSafetyViolation::AssocConst(item.ident.name, item.ident.span)),\n+    );\n \n-    fn generics_require_sized_self(self, def_id: DefId) -> bool {\n-        let sized_def_id = match self.lang_items().sized_trait() {\n-            Some(def_id) => def_id,\n-            None => {\n-                return false; /* No Sized trait, can't require it! */\n-            }\n-        };\n+    debug!(\n+        \"object_safety_violations_for_trait(trait_def_id={:?}) = {:?}\",\n+        trait_def_id, violations\n+    );\n \n-        // Search for a predicate like `Self : Sized` amongst the trait bounds.\n-        let predicates = self.predicates_of(def_id);\n-        let predicates = predicates.instantiate_identity(self).predicates;\n-        elaborate_predicates(self, predicates).any(|predicate| match predicate {\n-            ty::Predicate::Trait(ref trait_pred) => {\n-                trait_pred.def_id() == sized_def_id\n-                    && trait_pred.skip_binder().self_ty().is_param(0)\n+    violations\n+}\n+\n+fn predicates_reference_self(tcx: TyCtxt<'_>, trait_def_id: DefId, supertraits_only: bool) -> bool {\n+    let trait_ref = ty::Binder::dummy(ty::TraitRef::identity(tcx, trait_def_id));\n+    let predicates = if supertraits_only {\n+        tcx.super_predicates_of(trait_def_id)\n+    } else {\n+        tcx.predicates_of(trait_def_id)\n+    };\n+    let self_ty = tcx.types.self_param;\n+    let has_self_ty = |t: Ty<'_>| t.walk().any(|t| t == self_ty);\n+    predicates\n+        .predicates\n+        .iter()\n+        .map(|(predicate, _)| predicate.subst_supertrait(tcx, &trait_ref))\n+        .any(|predicate| {\n+            match predicate {\n+                ty::Predicate::Trait(ref data) => {\n+                    // In the case of a trait predicate, we can skip the \"self\" type.\n+                    data.skip_binder().input_types().skip(1).any(has_self_ty)\n+                }\n+                ty::Predicate::Projection(ref data) => {\n+                    // And similarly for projections. This should be redundant with\n+                    // the previous check because any projection should have a\n+                    // matching `Trait` predicate with the same inputs, but we do\n+                    // the check to be safe.\n+                    //\n+                    // Note that we *do* allow projection *outputs* to contain\n+                    // `self` (i.e., `trait Foo: Bar<Output=Self::Result> { type Result; }`),\n+                    // we just require the user to specify *both* outputs\n+                    // in the object type (i.e., `dyn Foo<Output=(), Result=()>`).\n+                    //\n+                    // This is ALT2 in issue #56288, see that for discussion of the\n+                    // possible alternatives.\n+                    data.skip_binder()\n+                        .projection_ty\n+                        .trait_ref(tcx)\n+                        .input_types()\n+                        .skip(1)\n+                        .any(has_self_ty)\n+                }\n+                ty::Predicate::WellFormed(..)\n+                | ty::Predicate::ObjectSafe(..)\n+                | ty::Predicate::TypeOutlives(..)\n+                | ty::Predicate::RegionOutlives(..)\n+                | ty::Predicate::ClosureKind(..)\n+                | ty::Predicate::Subtype(..)\n+                | ty::Predicate::ConstEvaluatable(..) => false,\n             }\n-            ty::Predicate::Projection(..)\n-            | ty::Predicate::Subtype(..)\n-            | ty::Predicate::RegionOutlives(..)\n-            | ty::Predicate::WellFormed(..)\n-            | ty::Predicate::ObjectSafe(..)\n-            | ty::Predicate::ClosureKind(..)\n-            | ty::Predicate::TypeOutlives(..)\n-            | ty::Predicate::ConstEvaluatable(..) => false,\n         })\n-    }\n+}\n+\n+fn trait_has_sized_self(tcx: TyCtxt<'_>, trait_def_id: DefId) -> bool {\n+    generics_require_sized_self(tcx, trait_def_id)\n+}\n \n-    /// Returns `Some(_)` if this method makes the containing trait not object safe.\n-    fn object_safety_violation_for_method(\n-        self,\n-        trait_def_id: DefId,\n-        method: &ty::AssocItem,\n-    ) -> Option<MethodViolationCode> {\n-        debug!(\"object_safety_violation_for_method({:?}, {:?})\", trait_def_id, method);\n-        // Any method that has a `Self : Sized` requisite is otherwise\n-        // exempt from the regulations.\n-        if self.generics_require_sized_self(method.def_id) {\n-            return None;\n+fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    let sized_def_id = match tcx.lang_items().sized_trait() {\n+        Some(def_id) => def_id,\n+        None => {\n+            return false; /* No Sized trait, can't require it! */\n+        }\n+    };\n+\n+    // Search for a predicate like `Self : Sized` amongst the trait bounds.\n+    let predicates = tcx.predicates_of(def_id);\n+    let predicates = predicates.instantiate_identity(tcx).predicates;\n+    elaborate_predicates(tcx, predicates).any(|predicate| match predicate {\n+        ty::Predicate::Trait(ref trait_pred) => {\n+            trait_pred.def_id() == sized_def_id && trait_pred.skip_binder().self_ty().is_param(0)\n         }\n+        ty::Predicate::Projection(..)\n+        | ty::Predicate::Subtype(..)\n+        | ty::Predicate::RegionOutlives(..)\n+        | ty::Predicate::WellFormed(..)\n+        | ty::Predicate::ObjectSafe(..)\n+        | ty::Predicate::ClosureKind(..)\n+        | ty::Predicate::TypeOutlives(..)\n+        | ty::Predicate::ConstEvaluatable(..) => false,\n+    })\n+}\n \n-        self.virtual_call_violation_for_method(trait_def_id, method)\n+/// Returns `Some(_)` if this method makes the containing trait not object safe.\n+fn object_safety_violation_for_method(\n+    tcx: TyCtxt<'_>,\n+    trait_def_id: DefId,\n+    method: &ty::AssocItem,\n+) -> Option<MethodViolationCode> {\n+    debug!(\"object_safety_violation_for_method({:?}, {:?})\", trait_def_id, method);\n+    // Any method that has a `Self : Sized` requisite is otherwise\n+    // exempt from the regulations.\n+    if generics_require_sized_self(tcx, method.def_id) {\n+        return None;\n     }\n \n-    /// Returns `Some(_)` if this method cannot be called on a trait\n-    /// object; this does not necessarily imply that the enclosing trait\n-    /// is not object safe, because the method might have a where clause\n-    /// `Self:Sized`.\n-    fn virtual_call_violation_for_method(\n-        self,\n-        trait_def_id: DefId,\n-        method: &ty::AssocItem,\n-    ) -> Option<MethodViolationCode> {\n-        // The method's first parameter must be named `self`\n-        if !method.method_has_self_argument {\n-            return Some(MethodViolationCode::StaticMethod);\n-        }\n+    virtual_call_violation_for_method(tcx, trait_def_id, method)\n+}\n \n-        let sig = self.fn_sig(method.def_id);\n+/// Returns `Some(_)` if this method cannot be called on a trait\n+/// object; this does not necessarily imply that the enclosing trait\n+/// is not object safe, because the method might have a where clause\n+/// `Self:Sized`.\n+fn virtual_call_violation_for_method<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_def_id: DefId,\n+    method: &ty::AssocItem,\n+) -> Option<MethodViolationCode> {\n+    // The method's first parameter must be named `self`\n+    if !method.method_has_self_argument {\n+        return Some(MethodViolationCode::StaticMethod);\n+    }\n \n-        for input_ty in &sig.skip_binder().inputs()[1..] {\n-            if self.contains_illegal_self_type_reference(trait_def_id, input_ty) {\n-                return Some(MethodViolationCode::ReferencesSelf);\n-            }\n-        }\n-        if self.contains_illegal_self_type_reference(trait_def_id, sig.output().skip_binder()) {\n+    let sig = tcx.fn_sig(method.def_id);\n+\n+    for input_ty in &sig.skip_binder().inputs()[1..] {\n+        if contains_illegal_self_type_reference(tcx, trait_def_id, input_ty) {\n             return Some(MethodViolationCode::ReferencesSelf);\n         }\n+    }\n+    if contains_illegal_self_type_reference(tcx, trait_def_id, sig.output().skip_binder()) {\n+        return Some(MethodViolationCode::ReferencesSelf);\n+    }\n \n-        // We can't monomorphize things like `fn foo<A>(...)`.\n-        let own_counts = self.generics_of(method.def_id).own_counts();\n-        if own_counts.types + own_counts.consts != 0 {\n-            return Some(MethodViolationCode::Generic);\n-        }\n+    // We can't monomorphize things like `fn foo<A>(...)`.\n+    let own_counts = tcx.generics_of(method.def_id).own_counts();\n+    if own_counts.types + own_counts.consts != 0 {\n+        return Some(MethodViolationCode::Generic);\n+    }\n \n-        if self\n-            .predicates_of(method.def_id)\n-            .predicates\n-            .iter()\n-            // A trait object can't claim to live more than the concrete type,\n-            // so outlives predicates will always hold.\n-            .cloned()\n-            .filter(|(p, _)| p.to_opt_type_outlives().is_none())\n-            .collect::<Vec<_>>()\n-            // Do a shallow visit so that `contains_illegal_self_type_reference`\n-            // may apply it's custom visiting.\n-            .visit_tys_shallow(|t| self.contains_illegal_self_type_reference(trait_def_id, t))\n-        {\n-            return Some(MethodViolationCode::WhereClauseReferencesSelf);\n-        }\n+    if tcx\n+        .predicates_of(method.def_id)\n+        .predicates\n+        .iter()\n+        // A trait object can't claim to live more than the concrete type,\n+        // so outlives predicates will always hold.\n+        .cloned()\n+        .filter(|(p, _)| p.to_opt_type_outlives().is_none())\n+        .collect::<Vec<_>>()\n+        // Do a shallow visit so that `contains_illegal_self_type_reference`\n+        // may apply it's custom visiting.\n+        .visit_tys_shallow(|t| contains_illegal_self_type_reference(tcx, trait_def_id, t))\n+    {\n+        return Some(MethodViolationCode::WhereClauseReferencesSelf);\n+    }\n \n-        let receiver_ty =\n-            self.liberate_late_bound_regions(method.def_id, &sig.map_bound(|sig| sig.inputs()[0]));\n+    let receiver_ty =\n+        tcx.liberate_late_bound_regions(method.def_id, &sig.map_bound(|sig| sig.inputs()[0]));\n \n-        // Until `unsized_locals` is fully implemented, `self: Self` can't be dispatched on.\n-        // However, this is already considered object-safe. We allow it as a special case here.\n-        // FIXME(mikeyhew) get rid of this `if` statement once `receiver_is_dispatchable` allows\n-        // `Receiver: Unsize<Receiver[Self => dyn Trait]>`.\n-        if receiver_ty != self.types.self_param {\n-            if !self.receiver_is_dispatchable(method, receiver_ty) {\n-                return Some(MethodViolationCode::UndispatchableReceiver);\n-            } else {\n-                // Do sanity check to make sure the receiver actually has the layout of a pointer.\n+    // Until `unsized_locals` is fully implemented, `self: Self` can't be dispatched on.\n+    // However, this is already considered object-safe. We allow it as a special case here.\n+    // FIXME(mikeyhew) get rid of this `if` statement once `receiver_is_dispatchable` allows\n+    // `Receiver: Unsize<Receiver[Self => dyn Trait]>`.\n+    if receiver_ty != tcx.types.self_param {\n+        if !receiver_is_dispatchable(tcx, method, receiver_ty) {\n+            return Some(MethodViolationCode::UndispatchableReceiver);\n+        } else {\n+            // Do sanity check to make sure the receiver actually has the layout of a pointer.\n \n-                use crate::ty::layout::Abi;\n+            use crate::ty::layout::Abi;\n \n-                let param_env = self.param_env(method.def_id);\n+            let param_env = tcx.param_env(method.def_id);\n \n-                let abi_of_ty = |ty: Ty<'tcx>| -> &Abi {\n-                    match self.layout_of(param_env.and(ty)) {\n-                        Ok(layout) => &layout.abi,\n-                        Err(err) => {\n-                            bug!(\"error: {}\\n while computing layout for type {:?}\", err, ty)\n-                        }\n-                    }\n-                };\n-\n-                // e.g., `Rc<()>`\n-                let unit_receiver_ty =\n-                    self.receiver_for_self_ty(receiver_ty, self.mk_unit(), method.def_id);\n-\n-                match abi_of_ty(unit_receiver_ty) {\n-                    &Abi::Scalar(..) => (),\n-                    abi => {\n-                        self.sess.delay_span_bug(\n-                            self.def_span(method.def_id),\n-                            &format!(\n-                                \"receiver when `Self = ()` should have a Scalar ABI; found {:?}\",\n-                                abi\n-                            ),\n-                        );\n-                    }\n+            let abi_of_ty = |ty: Ty<'tcx>| -> &Abi {\n+                match tcx.layout_of(param_env.and(ty)) {\n+                    Ok(layout) => &layout.abi,\n+                    Err(err) => bug!(\"error: {}\\n while computing layout for type {:?}\", err, ty),\n+                }\n+            };\n+\n+            // e.g., `Rc<()>`\n+            let unit_receiver_ty =\n+                receiver_for_self_ty(tcx, receiver_ty, tcx.mk_unit(), method.def_id);\n+\n+            match abi_of_ty(unit_receiver_ty) {\n+                &Abi::Scalar(..) => (),\n+                abi => {\n+                    tcx.sess.delay_span_bug(\n+                        tcx.def_span(method.def_id),\n+                        &format!(\n+                            \"receiver when `Self = ()` should have a Scalar ABI; found {:?}\",\n+                            abi\n+                        ),\n+                    );\n                 }\n+            }\n \n-                let trait_object_ty =\n-                    self.object_ty_for_trait(trait_def_id, self.mk_region(ty::ReStatic));\n+            let trait_object_ty =\n+                object_ty_for_trait(tcx, trait_def_id, tcx.mk_region(ty::ReStatic));\n \n-                // e.g., `Rc<dyn Trait>`\n-                let trait_object_receiver =\n-                    self.receiver_for_self_ty(receiver_ty, trait_object_ty, method.def_id);\n+            // e.g., `Rc<dyn Trait>`\n+            let trait_object_receiver =\n+                receiver_for_self_ty(tcx, receiver_ty, trait_object_ty, method.def_id);\n \n-                match abi_of_ty(trait_object_receiver) {\n-                    &Abi::ScalarPair(..) => (),\n-                    abi => {\n-                        self.sess.delay_span_bug(\n-                            self.def_span(method.def_id),\n-                            &format!(\n-                                \"receiver when `Self = {}` should have a ScalarPair ABI; \\\n+            match abi_of_ty(trait_object_receiver) {\n+                &Abi::ScalarPair(..) => (),\n+                abi => {\n+                    tcx.sess.delay_span_bug(\n+                        tcx.def_span(method.def_id),\n+                        &format!(\n+                            \"receiver when `Self = {}` should have a ScalarPair ABI; \\\n                                  found {:?}\",\n-                                trait_object_ty, abi\n-                            ),\n-                        );\n-                    }\n+                            trait_object_ty, abi\n+                        ),\n+                    );\n                 }\n             }\n         }\n-\n-        None\n     }\n \n-    /// Performs a type substitution to produce the version of `receiver_ty` when `Self = self_ty`.\n-    /// For example, for `receiver_ty = Rc<Self>` and `self_ty = Foo`, returns `Rc<Foo>`.\n-    fn receiver_for_self_ty(\n-        self,\n-        receiver_ty: Ty<'tcx>,\n-        self_ty: Ty<'tcx>,\n-        method_def_id: DefId,\n-    ) -> Ty<'tcx> {\n-        debug!(\"receiver_for_self_ty({:?}, {:?}, {:?})\", receiver_ty, self_ty, method_def_id);\n-        let substs = InternalSubsts::for_item(self, method_def_id, |param, _| {\n-            if param.index == 0 { self_ty.into() } else { self.mk_param_from_def(param) }\n-        });\n-\n-        let result = receiver_ty.subst(self, substs);\n-        debug!(\n-            \"receiver_for_self_ty({:?}, {:?}, {:?}) = {:?}\",\n-            receiver_ty, self_ty, method_def_id, result\n-        );\n-        result\n-    }\n+    None\n+}\n \n-    /// Creates the object type for the current trait. For example,\n-    /// if the current trait is `Deref`, then this will be\n-    /// `dyn Deref<Target = Self::Target> + 'static`.\n-    fn object_ty_for_trait(self, trait_def_id: DefId, lifetime: ty::Region<'tcx>) -> Ty<'tcx> {\n-        debug!(\"object_ty_for_trait: trait_def_id={:?}\", trait_def_id);\n-\n-        let trait_ref = ty::TraitRef::identity(self, trait_def_id);\n-\n-        let trait_predicate = ty::ExistentialPredicate::Trait(\n-            ty::ExistentialTraitRef::erase_self_ty(self, trait_ref),\n-        );\n-\n-        let mut associated_types = traits::supertraits(self, ty::Binder::dummy(trait_ref))\n-            .flat_map(|super_trait_ref| {\n-                self.associated_items(super_trait_ref.def_id())\n-                    .map(move |item| (super_trait_ref, item))\n-            })\n-            .filter(|(_, item)| item.kind == ty::AssocKind::Type)\n-            .collect::<Vec<_>>();\n-\n-        // existential predicates need to be in a specific order\n-        associated_types.sort_by_cached_key(|(_, item)| self.def_path_hash(item.def_id));\n-\n-        let projection_predicates = associated_types.into_iter().map(|(super_trait_ref, item)| {\n-            // We *can* get bound lifetimes here in cases like\n-            // `trait MyTrait: for<'s> OtherTrait<&'s T, Output=bool>`.\n-            //\n-            // binder moved to (*)...\n-            let super_trait_ref = super_trait_ref.skip_binder();\n-            ty::ExistentialPredicate::Projection(ty::ExistentialProjection {\n-                ty: self.mk_projection(item.def_id, super_trait_ref.substs),\n-                item_def_id: item.def_id,\n-                substs: super_trait_ref.substs,\n-            })\n-        });\n-\n-        let existential_predicates = self\n-            .mk_existential_predicates(iter::once(trait_predicate).chain(projection_predicates));\n-\n-        let object_ty = self.mk_dynamic(\n-            // (*) ... binder re-introduced here\n-            ty::Binder::bind(existential_predicates),\n-            lifetime,\n-        );\n-\n-        debug!(\"object_ty_for_trait: object_ty=`{}`\", object_ty);\n-\n-        object_ty\n-    }\n+/// Performs a type substitution to produce the version of `receiver_ty` when `Self = self_ty`.\n+/// For example, for `receiver_ty = Rc<Self>` and `self_ty = Foo`, returns `Rc<Foo>`.\n+fn receiver_for_self_ty<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    receiver_ty: Ty<'tcx>,\n+    self_ty: Ty<'tcx>,\n+    method_def_id: DefId,\n+) -> Ty<'tcx> {\n+    debug!(\"receiver_for_self_ty({:?}, {:?}, {:?})\", receiver_ty, self_ty, method_def_id);\n+    let substs = InternalSubsts::for_item(tcx, method_def_id, |param, _| {\n+        if param.index == 0 { self_ty.into() } else { tcx.mk_param_from_def(param) }\n+    });\n+\n+    let result = receiver_ty.subst(tcx, substs);\n+    debug!(\n+        \"receiver_for_self_ty({:?}, {:?}, {:?}) = {:?}\",\n+        receiver_ty, self_ty, method_def_id, result\n+    );\n+    result\n+}\n \n-    /// Checks the method's receiver (the `self` argument) can be dispatched on when `Self` is a\n-    /// trait object. We require that `DispatchableFromDyn` be implemented for the receiver type\n-    /// in the following way:\n-    /// - let `Receiver` be the type of the `self` argument, i.e `Self`, `&Self`, `Rc<Self>`,\n-    /// - require the following bound:\n-    ///\n-    ///   ```\n-    ///   Receiver[Self => T]: DispatchFromDyn<Receiver[Self => dyn Trait]>\n-    ///   ```\n-    ///\n-    ///   where `Foo[X => Y]` means \"the same type as `Foo`, but with `X` replaced with `Y`\"\n-    ///   (substitution notation).\n-    ///\n-    /// Some examples of receiver types and their required obligation:\n-    /// - `&'a mut self` requires `&'a mut Self: DispatchFromDyn<&'a mut dyn Trait>`,\n-    /// - `self: Rc<Self>` requires `Rc<Self>: DispatchFromDyn<Rc<dyn Trait>>`,\n-    /// - `self: Pin<Box<Self>>` requires `Pin<Box<Self>>: DispatchFromDyn<Pin<Box<dyn Trait>>>`.\n-    ///\n-    /// The only case where the receiver is not dispatchable, but is still a valid receiver\n-    /// type (just not object-safe), is when there is more than one level of pointer indirection.\n-    /// E.g., `self: &&Self`, `self: &Rc<Self>`, `self: Box<Box<Self>>`. In these cases, there\n-    /// is no way, or at least no inexpensive way, to coerce the receiver from the version where\n-    /// `Self = dyn Trait` to the version where `Self = T`, where `T` is the unknown erased type\n-    /// contained by the trait object, because the object that needs to be coerced is behind\n-    /// a pointer.\n-    ///\n-    /// In practice, we cannot use `dyn Trait` explicitly in the obligation because it would result\n-    /// in a new check that `Trait` is object safe, creating a cycle (until object_safe_for_dispatch\n-    /// is stabilized, see tracking issue https://github.com/rust-lang/rust/issues/43561).\n-    /// Instead, we fudge a little by introducing a new type parameter `U` such that\n-    /// `Self: Unsize<U>` and `U: Trait + ?Sized`, and use `U` in place of `dyn Trait`.\n-    /// Written as a chalk-style query:\n-    ///\n-    ///     forall (U: Trait + ?Sized) {\n-    ///         if (Self: Unsize<U>) {\n-    ///             Receiver: DispatchFromDyn<Receiver[Self => U]>\n-    ///         }\n-    ///     }\n-    ///\n-    /// for `self: &'a mut Self`, this means `&'a mut Self: DispatchFromDyn<&'a mut U>`\n-    /// for `self: Rc<Self>`, this means `Rc<Self>: DispatchFromDyn<Rc<U>>`\n-    /// for `self: Pin<Box<Self>>`, this means `Pin<Box<Self>>: DispatchFromDyn<Pin<Box<U>>>`\n-    //\n-    // FIXME(mikeyhew) when unsized receivers are implemented as part of unsized rvalues, add this\n-    // fallback query: `Receiver: Unsize<Receiver[Self => U]>` to support receivers like\n-    // `self: Wrapper<Self>`.\n-    #[allow(dead_code)]\n-    fn receiver_is_dispatchable(self, method: &ty::AssocItem, receiver_ty: Ty<'tcx>) -> bool {\n-        debug!(\"receiver_is_dispatchable: method = {:?}, receiver_ty = {:?}\", method, receiver_ty);\n-\n-        let traits =\n-            (self.lang_items().unsize_trait(), self.lang_items().dispatch_from_dyn_trait());\n-        let (unsize_did, dispatch_from_dyn_did) = if let (Some(u), Some(cu)) = traits {\n-            (u, cu)\n-        } else {\n-            debug!(\"receiver_is_dispatchable: Missing Unsize or DispatchFromDyn traits\");\n-            return false;\n-        };\n+/// Creates the object type for the current trait. For example,\n+/// if the current trait is `Deref`, then this will be\n+/// `dyn Deref<Target = Self::Target> + 'static`.\n+fn object_ty_for_trait<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_def_id: DefId,\n+    lifetime: ty::Region<'tcx>,\n+) -> Ty<'tcx> {\n+    debug!(\"object_ty_for_trait: trait_def_id={:?}\", trait_def_id);\n \n-        // the type `U` in the query\n-        // use a bogus type parameter to mimick a forall(U) query using u32::MAX for now.\n-        // FIXME(mikeyhew) this is a total hack. Once object_safe_for_dispatch is stabilized, we can\n-        // replace this with `dyn Trait`\n-        let unsized_self_ty: Ty<'tcx> =\n-            self.mk_ty_param(::std::u32::MAX, Symbol::intern(\"RustaceansAreAwesome\"));\n-\n-        // `Receiver[Self => U]`\n-        let unsized_receiver_ty =\n-            self.receiver_for_self_ty(receiver_ty, unsized_self_ty, method.def_id);\n-\n-        // create a modified param env, with `Self: Unsize<U>` and `U: Trait` added to caller bounds\n-        // `U: ?Sized` is already implied here\n-        let param_env = {\n-            let mut param_env = self.param_env(method.def_id);\n-\n-            // Self: Unsize<U>\n-            let unsize_predicate = ty::TraitRef {\n-                def_id: unsize_did,\n-                substs: self.mk_substs_trait(self.types.self_param, &[unsized_self_ty.into()]),\n-            }\n-            .to_predicate();\n-\n-            // U: Trait<Arg1, ..., ArgN>\n-            let trait_predicate = {\n-                let substs =\n-                    InternalSubsts::for_item(self, method.container.assert_trait(), |param, _| {\n-                        if param.index == 0 {\n-                            unsized_self_ty.into()\n-                        } else {\n-                            self.mk_param_from_def(param)\n-                        }\n-                    });\n-\n-                ty::TraitRef { def_id: unsize_did, substs }.to_predicate()\n-            };\n+    let trait_ref = ty::TraitRef::identity(tcx, trait_def_id);\n \n-            let caller_bounds: Vec<Predicate<'tcx>> = param_env\n-                .caller_bounds\n-                .iter()\n-                .cloned()\n-                .chain(iter::once(unsize_predicate))\n-                .chain(iter::once(trait_predicate))\n-                .collect();\n+    let trait_predicate =\n+        ty::ExistentialPredicate::Trait(ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref));\n \n-            param_env.caller_bounds = self.intern_predicates(&caller_bounds);\n+    let mut associated_types = traits::supertraits(tcx, ty::Binder::dummy(trait_ref))\n+        .flat_map(|super_trait_ref| {\n+            tcx.associated_items(super_trait_ref.def_id()).map(move |item| (super_trait_ref, item))\n+        })\n+        .filter(|(_, item)| item.kind == ty::AssocKind::Type)\n+        .collect::<Vec<_>>();\n \n-            param_env\n-        };\n+    // existential predicates need to be in a specific order\n+    associated_types.sort_by_cached_key(|(_, item)| tcx.def_path_hash(item.def_id));\n \n-        // Receiver: DispatchFromDyn<Receiver[Self => U]>\n-        let obligation = {\n-            let predicate = ty::TraitRef {\n-                def_id: dispatch_from_dyn_did,\n-                substs: self.mk_substs_trait(receiver_ty, &[unsized_receiver_ty.into()]),\n-            }\n-            .to_predicate();\n+    let projection_predicates = associated_types.into_iter().map(|(super_trait_ref, item)| {\n+        // We *can* get bound lifetimes here in cases like\n+        // `trait MyTrait: for<'s> OtherTrait<&'s T, Output=bool>`.\n+        //\n+        // binder moved to (*)...\n+        let super_trait_ref = super_trait_ref.skip_binder();\n+        ty::ExistentialPredicate::Projection(ty::ExistentialProjection {\n+            ty: tcx.mk_projection(item.def_id, super_trait_ref.substs),\n+            item_def_id: item.def_id,\n+            substs: super_trait_ref.substs,\n+        })\n+    });\n \n-            Obligation::new(ObligationCause::dummy(), param_env, predicate)\n-        };\n+    let existential_predicates =\n+        tcx.mk_existential_predicates(iter::once(trait_predicate).chain(projection_predicates));\n \n-        self.infer_ctxt().enter(|ref infcx| {\n-            // the receiver is dispatchable iff the obligation holds\n-            infcx.predicate_must_hold_modulo_regions(&obligation)\n-        })\n-    }\n+    let object_ty = tcx.mk_dynamic(\n+        // (*) ... binder re-introduced here\n+        ty::Binder::bind(existential_predicates),\n+        lifetime,\n+    );\n \n-    fn contains_illegal_self_type_reference(self, trait_def_id: DefId, ty: Ty<'tcx>) -> bool {\n-        // This is somewhat subtle. In general, we want to forbid\n-        // references to `Self` in the argument and return types,\n-        // since the value of `Self` is erased. However, there is one\n-        // exception: it is ok to reference `Self` in order to access\n-        // an associated type of the current trait, since we retain\n-        // the value of those associated types in the object type\n-        // itself.\n-        //\n-        // ```rust\n-        // trait SuperTrait {\n-        //     type X;\n-        // }\n-        //\n-        // trait Trait : SuperTrait {\n-        //     type Y;\n-        //     fn foo(&self, x: Self) // bad\n-        //     fn foo(&self) -> Self // bad\n-        //     fn foo(&self) -> Option<Self> // bad\n-        //     fn foo(&self) -> Self::Y // OK, desugars to next example\n-        //     fn foo(&self) -> <Self as Trait>::Y // OK\n-        //     fn foo(&self) -> Self::X // OK, desugars to next example\n-        //     fn foo(&self) -> <Self as SuperTrait>::X // OK\n-        // }\n-        // ```\n-        //\n-        // However, it is not as simple as allowing `Self` in a projected\n-        // type, because there are illegal ways to use `Self` as well:\n-        //\n-        // ```rust\n-        // trait Trait : SuperTrait {\n-        //     ...\n-        //     fn foo(&self) -> <Self as SomeOtherTrait>::X;\n-        // }\n-        // ```\n-        //\n-        // Here we will not have the type of `X` recorded in the\n-        // object type, and we cannot resolve `Self as SomeOtherTrait`\n-        // without knowing what `Self` is.\n-\n-        let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n-        let mut error = false;\n-        let self_ty = self.types.self_param;\n-        ty.maybe_walk(|ty| {\n-            match ty.kind {\n-                ty::Param(_) => {\n-                    if ty == self_ty {\n-                        error = true;\n+    debug!(\"object_ty_for_trait: object_ty=`{}`\", object_ty);\n+\n+    object_ty\n+}\n+\n+/// Checks the method's receiver (the `self` argument) can be dispatched on when `Self` is a\n+/// trait object. We require that `DispatchableFromDyn` be implemented for the receiver type\n+/// in the following way:\n+/// - let `Receiver` be the type of the `self` argument, i.e `Self`, `&Self`, `Rc<Self>`,\n+/// - require the following bound:\n+///\n+///   ```\n+///   Receiver[Self => T]: DispatchFromDyn<Receiver[Self => dyn Trait]>\n+///   ```\n+///\n+///   where `Foo[X => Y]` means \"the same type as `Foo`, but with `X` replaced with `Y`\"\n+///   (substitution notation).\n+///\n+/// Some examples of receiver types and their required obligation:\n+/// - `&'a mut self` requires `&'a mut Self: DispatchFromDyn<&'a mut dyn Trait>`,\n+/// - `self: Rc<Self>` requires `Rc<Self>: DispatchFromDyn<Rc<dyn Trait>>`,\n+/// - `self: Pin<Box<Self>>` requires `Pin<Box<Self>>: DispatchFromDyn<Pin<Box<dyn Trait>>>`.\n+///\n+/// The only case where the receiver is not dispatchable, but is still a valid receiver\n+/// type (just not object-safe), is when there is more than one level of pointer indirection.\n+/// E.g., `self: &&Self`, `self: &Rc<Self>`, `self: Box<Box<Self>>`. In these cases, there\n+/// is no way, or at least no inexpensive way, to coerce the receiver from the version where\n+/// `Self = dyn Trait` to the version where `Self = T`, where `T` is the unknown erased type\n+/// contained by the trait object, because the object that needs to be coerced is behind\n+/// a pointer.\n+///\n+/// In practice, we cannot use `dyn Trait` explicitly in the obligation because it would result\n+/// in a new check that `Trait` is object safe, creating a cycle (until object_safe_for_dispatch\n+/// is stabilized, see tracking issue https://github.com/rust-lang/rust/issues/43561).\n+/// Instead, we fudge a little by introducing a new type parameter `U` such that\n+/// `Self: Unsize<U>` and `U: Trait + ?Sized`, and use `U` in place of `dyn Trait`.\n+/// Written as a chalk-style query:\n+///\n+///     forall (U: Trait + ?Sized) {\n+///         if (Self: Unsize<U>) {\n+///             Receiver: DispatchFromDyn<Receiver[Self => U]>\n+///         }\n+///     }\n+///\n+/// for `self: &'a mut Self`, this means `&'a mut Self: DispatchFromDyn<&'a mut U>`\n+/// for `self: Rc<Self>`, this means `Rc<Self>: DispatchFromDyn<Rc<U>>`\n+/// for `self: Pin<Box<Self>>`, this means `Pin<Box<Self>>: DispatchFromDyn<Pin<Box<U>>>`\n+//\n+// FIXME(mikeyhew) when unsized receivers are implemented as part of unsized rvalues, add this\n+// fallback query: `Receiver: Unsize<Receiver[Self => U]>` to support receivers like\n+// `self: Wrapper<Self>`.\n+#[allow(dead_code)]\n+fn receiver_is_dispatchable<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    method: &ty::AssocItem,\n+    receiver_ty: Ty<'tcx>,\n+) -> bool {\n+    debug!(\"receiver_is_dispatchable: method = {:?}, receiver_ty = {:?}\", method, receiver_ty);\n+\n+    let traits = (tcx.lang_items().unsize_trait(), tcx.lang_items().dispatch_from_dyn_trait());\n+    let (unsize_did, dispatch_from_dyn_did) = if let (Some(u), Some(cu)) = traits {\n+        (u, cu)\n+    } else {\n+        debug!(\"receiver_is_dispatchable: Missing Unsize or DispatchFromDyn traits\");\n+        return false;\n+    };\n+\n+    // the type `U` in the query\n+    // use a bogus type parameter to mimick a forall(U) query using u32::MAX for now.\n+    // FIXME(mikeyhew) this is a total hack. Once object_safe_for_dispatch is stabilized, we can\n+    // replace this with `dyn Trait`\n+    let unsized_self_ty: Ty<'tcx> =\n+        tcx.mk_ty_param(::std::u32::MAX, Symbol::intern(\"RustaceansAreAwesome\"));\n+\n+    // `Receiver[Self => U]`\n+    let unsized_receiver_ty =\n+        receiver_for_self_ty(tcx, receiver_ty, unsized_self_ty, method.def_id);\n+\n+    // create a modified param env, with `Self: Unsize<U>` and `U: Trait` added to caller bounds\n+    // `U: ?Sized` is already implied here\n+    let param_env = {\n+        let mut param_env = tcx.param_env(method.def_id);\n+\n+        // Self: Unsize<U>\n+        let unsize_predicate = ty::TraitRef {\n+            def_id: unsize_did,\n+            substs: tcx.mk_substs_trait(tcx.types.self_param, &[unsized_self_ty.into()]),\n+        }\n+        .to_predicate();\n+\n+        // U: Trait<Arg1, ..., ArgN>\n+        let trait_predicate = {\n+            let substs =\n+                InternalSubsts::for_item(tcx, method.container.assert_trait(), |param, _| {\n+                    if param.index == 0 {\n+                        unsized_self_ty.into()\n+                    } else {\n+                        tcx.mk_param_from_def(param)\n                     }\n+                });\n+\n+            ty::TraitRef { def_id: unsize_did, substs }.to_predicate()\n+        };\n+\n+        let caller_bounds: Vec<Predicate<'tcx>> = param_env\n+            .caller_bounds\n+            .iter()\n+            .cloned()\n+            .chain(iter::once(unsize_predicate))\n+            .chain(iter::once(trait_predicate))\n+            .collect();\n+\n+        param_env.caller_bounds = tcx.intern_predicates(&caller_bounds);\n+\n+        param_env\n+    };\n+\n+    // Receiver: DispatchFromDyn<Receiver[Self => U]>\n+    let obligation = {\n+        let predicate = ty::TraitRef {\n+            def_id: dispatch_from_dyn_did,\n+            substs: tcx.mk_substs_trait(receiver_ty, &[unsized_receiver_ty.into()]),\n+        }\n+        .to_predicate();\n+\n+        Obligation::new(ObligationCause::dummy(), param_env, predicate)\n+    };\n \n-                    false // no contained types to walk\n+    tcx.infer_ctxt().enter(|ref infcx| {\n+        // the receiver is dispatchable iff the obligation holds\n+        infcx.predicate_must_hold_modulo_regions(&obligation)\n+    })\n+}\n+\n+fn contains_illegal_self_type_reference<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_def_id: DefId,\n+    ty: Ty<'tcx>,\n+) -> bool {\n+    // This is somewhat subtle. In general, we want to forbid\n+    // references to `Self` in the argument and return types,\n+    // since the value of `Self` is erased. However, there is one\n+    // exception: it is ok to reference `Self` in order to access\n+    // an associated type of the current trait, since we retain\n+    // the value of those associated types in the object type\n+    // itself.\n+    //\n+    // ```rust\n+    // trait SuperTrait {\n+    //     type X;\n+    // }\n+    //\n+    // trait Trait : SuperTrait {\n+    //     type Y;\n+    //     fn foo(&self, x: Self) // bad\n+    //     fn foo(&self) -> Self // bad\n+    //     fn foo(&self) -> Option<Self> // bad\n+    //     fn foo(&self) -> Self::Y // OK, desugars to next example\n+    //     fn foo(&self) -> <Self as Trait>::Y // OK\n+    //     fn foo(&self) -> Self::X // OK, desugars to next example\n+    //     fn foo(&self) -> <Self as SuperTrait>::X // OK\n+    // }\n+    // ```\n+    //\n+    // However, it is not as simple as allowing `Self` in a projected\n+    // type, because there are illegal ways to use `Self` as well:\n+    //\n+    // ```rust\n+    // trait Trait : SuperTrait {\n+    //     ...\n+    //     fn foo(&self) -> <Self as SomeOtherTrait>::X;\n+    // }\n+    // ```\n+    //\n+    // Here we will not have the type of `X` recorded in the\n+    // object type, and we cannot resolve `Self as SomeOtherTrait`\n+    // without knowing what `Self` is.\n+\n+    let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n+    let mut error = false;\n+    let self_ty = tcx.types.self_param;\n+    ty.maybe_walk(|ty| {\n+        match ty.kind {\n+            ty::Param(_) => {\n+                if ty == self_ty {\n+                    error = true;\n                 }\n \n-                ty::Projection(ref data) => {\n-                    // This is a projected type `<Foo as SomeTrait>::X`.\n+                false // no contained types to walk\n+            }\n \n-                    // Compute supertraits of current trait lazily.\n-                    if supertraits.is_none() {\n-                        let trait_ref =\n-                            ty::Binder::bind(ty::TraitRef::identity(self, trait_def_id));\n-                        supertraits = Some(traits::supertraits(self, trait_ref).collect());\n-                    }\n+            ty::Projection(ref data) => {\n+                // This is a projected type `<Foo as SomeTrait>::X`.\n \n-                    // Determine whether the trait reference `Foo as\n-                    // SomeTrait` is in fact a supertrait of the\n-                    // current trait. In that case, this type is\n-                    // legal, because the type `X` will be specified\n-                    // in the object type.  Note that we can just use\n-                    // direct equality here because all of these types\n-                    // are part of the formal parameter listing, and\n-                    // hence there should be no inference variables.\n-                    let projection_trait_ref = ty::Binder::bind(data.trait_ref(self));\n-                    let is_supertrait_of_current_trait =\n-                        supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n-\n-                    if is_supertrait_of_current_trait {\n-                        false // do not walk contained types, do not report error, do collect $200\n-                    } else {\n-                        true // DO walk contained types, POSSIBLY reporting an error\n-                    }\n+                // Compute supertraits of current trait lazily.\n+                if supertraits.is_none() {\n+                    let trait_ref = ty::Binder::bind(ty::TraitRef::identity(tcx, trait_def_id));\n+                    supertraits = Some(traits::supertraits(tcx, trait_ref).collect());\n                 }\n \n-                _ => true, // walk contained types, if any\n+                // Determine whether the trait reference `Foo as\n+                // SomeTrait` is in fact a supertrait of the\n+                // current trait. In that case, this type is\n+                // legal, because the type `X` will be specified\n+                // in the object type.  Note that we can just use\n+                // direct equality here because all of these types\n+                // are part of the formal parameter listing, and\n+                // hence there should be no inference variables.\n+                let projection_trait_ref = ty::Binder::bind(data.trait_ref(tcx));\n+                let is_supertrait_of_current_trait =\n+                    supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n+\n+                if is_supertrait_of_current_trait {\n+                    false // do not walk contained types, do not report error, do collect $200\n+                } else {\n+                    true // DO walk contained types, POSSIBLY reporting an error\n+                }\n             }\n-        });\n \n-        error\n-    }\n+            _ => true, // walk contained types, if any\n+        }\n+    });\n+\n+    error\n }\n \n pub(super) fn is_object_safe_provider(tcx: TyCtxt<'_>, trait_def_id: DefId) -> bool {\n-    tcx.object_safety_violations(trait_def_id).is_empty()\n+    object_safety_violations(tcx, trait_def_id).is_empty()\n }"}, {"sha": "79e1b6444a9b717ee7121501c96db7105d4e9a69", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -1057,7 +1057,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                     node_item.item.defaultness.has_value()\n                 } else {\n                     node_item.item.defaultness.is_default()\n-                        || selcx.tcx().impl_is_default(node_item.node.def_id())\n+                        || super::util::impl_is_default(selcx.tcx(), node_item.node.def_id())\n                 };\n \n                 // Only reveal a specializable default if we're past type-checking\n@@ -1263,26 +1263,30 @@ fn confirm_generator_candidate<'cx, 'tcx>(\n \n     let gen_def_id = tcx.lang_items().gen_trait().unwrap();\n \n-    let predicate = tcx\n-        .generator_trait_ref_and_outputs(gen_def_id, obligation.predicate.self_ty(), gen_sig)\n-        .map_bound(|(trait_ref, yield_ty, return_ty)| {\n-            let name = tcx.associated_item(obligation.predicate.item_def_id).ident.name;\n-            let ty = if name == sym::Return {\n-                return_ty\n-            } else if name == sym::Yield {\n-                yield_ty\n-            } else {\n-                bug!()\n-            };\n+    let predicate = super::util::generator_trait_ref_and_outputs(\n+        tcx,\n+        gen_def_id,\n+        obligation.predicate.self_ty(),\n+        gen_sig,\n+    )\n+    .map_bound(|(trait_ref, yield_ty, return_ty)| {\n+        let name = tcx.associated_item(obligation.predicate.item_def_id).ident.name;\n+        let ty = if name == sym::Return {\n+            return_ty\n+        } else if name == sym::Yield {\n+            yield_ty\n+        } else {\n+            bug!()\n+        };\n \n-            ty::ProjectionPredicate {\n-                projection_ty: ty::ProjectionTy {\n-                    substs: trait_ref.substs,\n-                    item_def_id: obligation.predicate.item_def_id,\n-                },\n-                ty: ty,\n-            }\n-        });\n+        ty::ProjectionPredicate {\n+            projection_ty: ty::ProjectionTy {\n+                substs: trait_ref.substs,\n+                item_def_id: obligation.predicate.item_def_id,\n+            },\n+            ty: ty,\n+        }\n+    });\n \n     confirm_param_env_candidate(selcx, obligation, predicate)\n         .with_addl_obligations(vtable.nested)\n@@ -1349,21 +1353,21 @@ fn confirm_callable_candidate<'cx, 'tcx>(\n     // the `Output` associated type is declared on `FnOnce`\n     let fn_once_def_id = tcx.lang_items().fn_once_trait().unwrap();\n \n-    let predicate = tcx\n-        .closure_trait_ref_and_return_type(\n-            fn_once_def_id,\n-            obligation.predicate.self_ty(),\n-            fn_sig,\n-            flag,\n-        )\n-        .map_bound(|(trait_ref, ret_type)| ty::ProjectionPredicate {\n-            projection_ty: ty::ProjectionTy::from_ref_and_name(\n-                tcx,\n-                trait_ref,\n-                Ident::with_dummy_span(FN_OUTPUT_NAME),\n-            ),\n-            ty: ret_type,\n-        });\n+    let predicate = super::util::closure_trait_ref_and_return_type(\n+        tcx,\n+        fn_once_def_id,\n+        obligation.predicate.self_ty(),\n+        fn_sig,\n+        flag,\n+    )\n+    .map_bound(|(trait_ref, ret_type)| ty::ProjectionPredicate {\n+        projection_ty: ty::ProjectionTy::from_ref_and_name(\n+            tcx,\n+            trait_ref,\n+            Ident::with_dummy_span(FN_OUTPUT_NAME),\n+        ),\n+        ty: ret_type,\n+    });\n \n     confirm_param_env_candidate(selcx, obligation, predicate)\n }"}, {"sha": "440268aab8fb399629903853ea01b7d7ffaaff63", "filename": "src/librustc/traits/query/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -13,7 +13,6 @@ pub mod dropck_outlives;\n pub mod evaluate_obligation;\n pub mod method_autoderef;\n pub mod normalize;\n-pub mod normalize_erasing_regions;\n pub mod outlives_bounds;\n pub mod type_op;\n "}, {"sha": "1b1cb1b36e09a5fb1646ee33cf6206f65bd584f1", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -11,6 +11,8 @@ use super::coherence::{self, Conflict};\n use super::project;\n use super::project::{normalize_with_depth, Normalized, ProjectionCacheKey};\n use super::util;\n+use super::util::{closure_trait_ref_and_return_type, predicate_for_trait_def};\n+use super::wf;\n use super::DerivedObligationCause;\n use super::Selection;\n use super::SelectionResult;\n@@ -737,7 +739,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::WellFormed(ty) => match ty::wf::obligations(\n+            ty::Predicate::WellFormed(ty) => match wf::obligations(\n                 self.infcx,\n                 obligation.param_env,\n                 obligation.cause.body_id,\n@@ -1153,7 +1155,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// to have a *lower* recursion_depth than the obligation used to create it.\n     /// Projection sub-obligations may be returned from the projection cache,\n     /// which results in obligations with an 'old' `recursion_depth`.\n-    /// Additionally, methods like `ty::wf::obligations` and\n+    /// Additionally, methods like `wf::obligations` and\n     /// `InferCtxt.subtype_predicate` produce subobligations without\n     /// taking in a 'parent' depth, causing the generated subobligations\n     /// to have a `recursion_depth` of `0`.\n@@ -2651,7 +2653,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             recursion_depth,\n                             &skol_ty,\n                         );\n-                    let skol_obligation = self.tcx().predicate_for_trait_def(\n+                    let skol_obligation = predicate_for_trait_def(\n+                        self.tcx(),\n                         param_env,\n                         cause.clone(),\n                         trait_def_id,\n@@ -2988,7 +2991,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // we pass over, we sum up the set of number of vtable\n             // entries, so that we can compute the offset for the selected\n             // trait.\n-            vtable_base = nonmatching.map(|t| tcx.count_own_vtable_entries(t)).sum();\n+            vtable_base = nonmatching.map(|t| super::util::count_own_vtable_entries(tcx, t)).sum();\n         }\n \n         VtableObjectData { upcast_trait_ref: upcast_trait_ref.unwrap(), vtable_base, nested }\n@@ -3003,15 +3006,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Okay to skip binder; it is reintroduced below.\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let sig = self_ty.fn_sig(self.tcx());\n-        let trait_ref = self\n-            .tcx()\n-            .closure_trait_ref_and_return_type(\n-                obligation.predicate.def_id(),\n-                self_ty,\n-                sig,\n-                util::TupleArgumentsFlag::Yes,\n-            )\n-            .map_bound(|(trait_ref, _)| trait_ref);\n+        let trait_ref = closure_trait_ref_and_return_type(\n+            self.tcx(),\n+            obligation.predicate.def_id(),\n+            self_ty,\n+            sig,\n+            util::TupleArgumentsFlag::Yes,\n+        )\n+        .map_bound(|(trait_ref, _)| trait_ref);\n \n         let Normalized { value: trait_ref, obligations } = project::normalize_with_depth(\n             self,\n@@ -3381,7 +3383,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 nested.extend(obligations);\n \n                 // Construct the nested `Field<T>: Unsize<Field<U>>` predicate.\n-                nested.push(tcx.predicate_for_trait_def(\n+                nested.push(predicate_for_trait_def(\n+                    tcx,\n                     obligation.param_env,\n                     obligation.cause.clone(),\n                     obligation.predicate.def_id(),\n@@ -3416,7 +3419,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 nested.extend(obligations);\n \n                 // Construct the nested `T: Unsize<U>` predicate.\n-                nested.push(tcx.predicate_for_trait_def(\n+                nested.push(predicate_for_trait_def(\n+                    tcx,\n                     obligation.param_env,\n                     obligation.cause.clone(),\n                     obligation.predicate.def_id(),\n@@ -3627,14 +3631,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // in fact unparameterized (or at least does not reference any\n         // regions bound in the obligation). Still probably some\n         // refactoring could make this nicer.\n-        self.tcx()\n-            .closure_trait_ref_and_return_type(\n-                obligation.predicate.def_id(),\n-                obligation.predicate.skip_binder().self_ty(), // (1)\n-                closure_type,\n-                util::TupleArgumentsFlag::No,\n-            )\n-            .map_bound(|(trait_ref, _)| trait_ref)\n+        closure_trait_ref_and_return_type(\n+            self.tcx(),\n+            obligation.predicate.def_id(),\n+            obligation.predicate.skip_binder().self_ty(), // (1)\n+            closure_type,\n+            util::TupleArgumentsFlag::No,\n+        )\n+        .map_bound(|(trait_ref, _)| trait_ref)\n     }\n \n     fn generator_trait_ref_unnormalized(\n@@ -3651,13 +3655,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // regions bound in the obligation). Still probably some\n         // refactoring could make this nicer.\n \n-        self.tcx()\n-            .generator_trait_ref_and_outputs(\n-                obligation.predicate.def_id(),\n-                obligation.predicate.skip_binder().self_ty(), // (1)\n-                gen_sig,\n-            )\n-            .map_bound(|(trait_ref, ..)| trait_ref)\n+        super::util::generator_trait_ref_and_outputs(\n+            self.tcx(),\n+            obligation.predicate.def_id(),\n+            obligation.predicate.skip_binder().self_ty(), // (1)\n+            gen_sig,\n+        )\n+        .map_bound(|(trait_ref, ..)| trait_ref)\n     }\n \n     /// Returns the obligations that are implied by instantiating an"}, {"sha": "b2c3c23b4e3bdd4e74282aee8854562e7eabeb15", "filename": "src/librustc/traits/structural_match.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_match.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "previous_filename": "src/librustc/ty/structural_match.rs"}, {"sha": "8355239af87a4a5d785e3a68fd11d48dfd0a7f08", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 100, "deletions": 102, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -548,123 +548,121 @@ pub fn predicate_for_trait_ref<'tcx>(\n     Obligation { cause, param_env, recursion_depth, predicate: trait_ref.to_predicate() }\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn predicate_for_trait_def(\n-        self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        cause: ObligationCause<'tcx>,\n-        trait_def_id: DefId,\n-        recursion_depth: usize,\n-        self_ty: Ty<'tcx>,\n-        params: &[GenericArg<'tcx>],\n-    ) -> PredicateObligation<'tcx> {\n-        let trait_ref =\n-            ty::TraitRef { def_id: trait_def_id, substs: self.mk_substs_trait(self_ty, params) };\n-        predicate_for_trait_ref(cause, param_env, trait_ref, recursion_depth)\n-    }\n-\n-    /// Casts a trait reference into a reference to one of its super\n-    /// traits; returns `None` if `target_trait_def_id` is not a\n-    /// supertrait.\n-    pub fn upcast_choices(\n-        self,\n-        source_trait_ref: ty::PolyTraitRef<'tcx>,\n-        target_trait_def_id: DefId,\n-    ) -> Vec<ty::PolyTraitRef<'tcx>> {\n-        if source_trait_ref.def_id() == target_trait_def_id {\n-            return vec![source_trait_ref]; // Shortcut the most common case.\n-        }\n+pub fn predicate_for_trait_def(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    trait_def_id: DefId,\n+    recursion_depth: usize,\n+    self_ty: Ty<'tcx>,\n+    params: &[GenericArg<'tcx>],\n+) -> PredicateObligation<'tcx> {\n+    let trait_ref =\n+        ty::TraitRef { def_id: trait_def_id, substs: tcx.mk_substs_trait(self_ty, params) };\n+    predicate_for_trait_ref(cause, param_env, trait_ref, recursion_depth)\n+}\n \n-        supertraits(self, source_trait_ref).filter(|r| r.def_id() == target_trait_def_id).collect()\n+/// Casts a trait reference into a reference to one of its super\n+/// traits; returns `None` if `target_trait_def_id` is not a\n+/// supertrait.\n+pub fn upcast_choices(\n+    tcx: TyCtxt<'tcx>,\n+    source_trait_ref: ty::PolyTraitRef<'tcx>,\n+    target_trait_def_id: DefId,\n+) -> Vec<ty::PolyTraitRef<'tcx>> {\n+    if source_trait_ref.def_id() == target_trait_def_id {\n+        return vec![source_trait_ref]; // Shortcut the most common case.\n     }\n \n-    /// Given a trait `trait_ref`, returns the number of vtable entries\n-    /// that come from `trait_ref`, excluding its supertraits. Used in\n-    /// computing the vtable base for an upcast trait of a trait object.\n-    pub fn count_own_vtable_entries(self, trait_ref: ty::PolyTraitRef<'tcx>) -> usize {\n-        let mut entries = 0;\n-        // Count number of methods and add them to the total offset.\n-        // Skip over associated types and constants.\n-        for trait_item in self.associated_items(trait_ref.def_id()) {\n-            if trait_item.kind == ty::AssocKind::Method {\n-                entries += 1;\n-            }\n+    supertraits(tcx, source_trait_ref).filter(|r| r.def_id() == target_trait_def_id).collect()\n+}\n+\n+/// Given a trait `trait_ref`, returns the number of vtable entries\n+/// that come from `trait_ref`, excluding its supertraits. Used in\n+/// computing the vtable base for an upcast trait of a trait object.\n+pub fn count_own_vtable_entries(tcx: TyCtxt<'tcx>, trait_ref: ty::PolyTraitRef<'tcx>) -> usize {\n+    let mut entries = 0;\n+    // Count number of methods and add them to the total offset.\n+    // Skip over associated types and constants.\n+    for trait_item in tcx.associated_items(trait_ref.def_id()) {\n+        if trait_item.kind == ty::AssocKind::Method {\n+            entries += 1;\n         }\n-        entries\n     }\n+    entries\n+}\n \n-    /// Given an upcast trait object described by `object`, returns the\n-    /// index of the method `method_def_id` (which should be part of\n-    /// `object.upcast_trait_ref`) within the vtable for `object`.\n-    pub fn get_vtable_index_of_object_method<N>(\n-        self,\n-        object: &super::VtableObjectData<'tcx, N>,\n-        method_def_id: DefId,\n-    ) -> usize {\n-        // Count number of methods preceding the one we are selecting and\n-        // add them to the total offset.\n-        // Skip over associated types and constants.\n-        let mut entries = object.vtable_base;\n-        for trait_item in self.associated_items(object.upcast_trait_ref.def_id()) {\n-            if trait_item.def_id == method_def_id {\n-                // The item with the ID we were given really ought to be a method.\n-                assert_eq!(trait_item.kind, ty::AssocKind::Method);\n-                return entries;\n-            }\n-            if trait_item.kind == ty::AssocKind::Method {\n-                entries += 1;\n-            }\n+/// Given an upcast trait object described by `object`, returns the\n+/// index of the method `method_def_id` (which should be part of\n+/// `object.upcast_trait_ref`) within the vtable for `object`.\n+pub fn get_vtable_index_of_object_method<N>(\n+    tcx: TyCtxt<'tcx>,\n+    object: &super::VtableObjectData<'tcx, N>,\n+    method_def_id: DefId,\n+) -> usize {\n+    // Count number of methods preceding the one we are selecting and\n+    // add them to the total offset.\n+    // Skip over associated types and constants.\n+    let mut entries = object.vtable_base;\n+    for trait_item in tcx.associated_items(object.upcast_trait_ref.def_id()) {\n+        if trait_item.def_id == method_def_id {\n+            // The item with the ID we were given really ought to be a method.\n+            assert_eq!(trait_item.kind, ty::AssocKind::Method);\n+            return entries;\n+        }\n+        if trait_item.kind == ty::AssocKind::Method {\n+            entries += 1;\n         }\n-\n-        bug!(\"get_vtable_index_of_object_method: {:?} was not found\", method_def_id);\n     }\n \n-    pub fn closure_trait_ref_and_return_type(\n-        self,\n-        fn_trait_def_id: DefId,\n-        self_ty: Ty<'tcx>,\n-        sig: ty::PolyFnSig<'tcx>,\n-        tuple_arguments: TupleArgumentsFlag,\n-    ) -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>)> {\n-        let arguments_tuple = match tuple_arguments {\n-            TupleArgumentsFlag::No => sig.skip_binder().inputs()[0],\n-            TupleArgumentsFlag::Yes => self.intern_tup(sig.skip_binder().inputs()),\n-        };\n-        let trait_ref = ty::TraitRef {\n-            def_id: fn_trait_def_id,\n-            substs: self.mk_substs_trait(self_ty, &[arguments_tuple.into()]),\n-        };\n-        ty::Binder::bind((trait_ref, sig.skip_binder().output()))\n-    }\n+    bug!(\"get_vtable_index_of_object_method: {:?} was not found\", method_def_id);\n+}\n \n-    pub fn generator_trait_ref_and_outputs(\n-        self,\n-        fn_trait_def_id: DefId,\n-        self_ty: Ty<'tcx>,\n-        sig: ty::PolyGenSig<'tcx>,\n-    ) -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>, Ty<'tcx>)> {\n-        let trait_ref =\n-            ty::TraitRef { def_id: fn_trait_def_id, substs: self.mk_substs_trait(self_ty, &[]) };\n-        ty::Binder::bind((trait_ref, sig.skip_binder().yield_ty, sig.skip_binder().return_ty))\n-    }\n+pub fn closure_trait_ref_and_return_type(\n+    tcx: TyCtxt<'tcx>,\n+    fn_trait_def_id: DefId,\n+    self_ty: Ty<'tcx>,\n+    sig: ty::PolyFnSig<'tcx>,\n+    tuple_arguments: TupleArgumentsFlag,\n+) -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>)> {\n+    let arguments_tuple = match tuple_arguments {\n+        TupleArgumentsFlag::No => sig.skip_binder().inputs()[0],\n+        TupleArgumentsFlag::Yes => tcx.intern_tup(sig.skip_binder().inputs()),\n+    };\n+    let trait_ref = ty::TraitRef {\n+        def_id: fn_trait_def_id,\n+        substs: tcx.mk_substs_trait(self_ty, &[arguments_tuple.into()]),\n+    };\n+    ty::Binder::bind((trait_ref, sig.skip_binder().output()))\n+}\n \n-    pub fn impl_is_default(self, node_item_def_id: DefId) -> bool {\n-        match self.hir().as_local_hir_id(node_item_def_id) {\n-            Some(hir_id) => {\n-                let item = self.hir().expect_item(hir_id);\n-                if let hir::ItemKind::Impl(_, _, defaultness, ..) = item.kind {\n-                    defaultness.is_default()\n-                } else {\n-                    false\n-                }\n+pub fn generator_trait_ref_and_outputs(\n+    tcx: TyCtxt<'tcx>,\n+    fn_trait_def_id: DefId,\n+    self_ty: Ty<'tcx>,\n+    sig: ty::PolyGenSig<'tcx>,\n+) -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>, Ty<'tcx>)> {\n+    let trait_ref =\n+        ty::TraitRef { def_id: fn_trait_def_id, substs: tcx.mk_substs_trait(self_ty, &[]) };\n+    ty::Binder::bind((trait_ref, sig.skip_binder().yield_ty, sig.skip_binder().return_ty))\n+}\n+\n+pub fn impl_is_default(tcx: TyCtxt<'_>, node_item_def_id: DefId) -> bool {\n+    match tcx.hir().as_local_hir_id(node_item_def_id) {\n+        Some(hir_id) => {\n+            let item = tcx.hir().expect_item(hir_id);\n+            if let hir::ItemKind::Impl(_, _, defaultness, ..) = item.kind {\n+                defaultness.is_default()\n+            } else {\n+                false\n             }\n-            None => self.impl_defaultness(node_item_def_id).is_default(),\n         }\n+        None => tcx.impl_defaultness(node_item_def_id).is_default(),\n     }\n+}\n \n-    pub fn impl_item_is_final(self, assoc_item: &ty::AssocItem) -> bool {\n-        assoc_item.defaultness.is_final() && !self.impl_is_default(assoc_item.container.id())\n-    }\n+pub fn impl_item_is_final(tcx: TyCtxt<'_>, assoc_item: &ty::AssocItem) -> bool {\n+    assoc_item.defaultness.is_final() && !impl_is_default(tcx, assoc_item.container.id())\n }\n \n pub enum TupleArgumentsFlag {"}, {"sha": "551f8fde12b18cf4030e7257d6fe80cbbe0f9149", "filename": "src/librustc/traits/wf.rs", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fwf.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -1,3 +1,4 @@\n+use crate::infer::opaque_types::required_region_bounds;\n use crate::infer::InferCtxt;\n use crate::middle::lang_items;\n use crate::traits::{self, AssocTypeBoundData};\n@@ -514,7 +515,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     // of whatever returned this exact `impl Trait`.\n \n                     // for named opaque `impl Trait` types we still need to check them\n-                    if super::is_impl_trait_defn(self.infcx.tcx, did).is_none() {\n+                    if ty::is_impl_trait_defn(self.infcx.tcx, did).is_none() {\n                         let obligations = self.nominal_obligations(did, substs);\n                         self.out.extend(obligations);\n                     }\n@@ -668,7 +669,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n /// from the declarations of `SomeTrait`, `Send`, and friends -- if\n /// they declare `trait SomeTrait : 'static`, for example, then\n /// `'static` would appear in the list. The hard work is done by\n-/// `ty::required_region_bounds`, see that for more information.\n+/// `infer::required_region_bounds`, see that for more information.\n pub fn object_region_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     existential_predicates: ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>,\n@@ -689,7 +690,7 @@ pub fn object_region_bounds<'tcx>(\n         })\n         .collect();\n \n-    tcx.required_region_bounds(open_ty, predicates)\n+    required_region_bounds(tcx, open_ty, predicates)\n }\n \n /// Find the span of a generic bound affecting an associated type.", "previous_filename": "src/librustc/ty/wf.rs"}, {"sha": "17f5b98ab208b9ebc4ac3f751a54bf07d9e636c2", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -8,7 +8,6 @@ use crate::hir::map as hir_map;\n use crate::hir::map::DefPathHash;\n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n-use crate::infer::outlives::free_region_map::FreeRegionMap;\n use crate::lint::{self, Lint};\n use crate::middle;\n use crate::middle::cstore::CrateStoreDyn;\n@@ -26,6 +25,7 @@ use crate::session::config::{BorrowckMode, OutputFilenames};\n use crate::session::Session;\n use crate::traits;\n use crate::traits::{Clause, Clauses, Goal, GoalKind, Goals};\n+use crate::ty::free_region_map::FreeRegionMap;\n use crate::ty::layout::{LayoutDetails, TargetDataLayout, VariantIdx};\n use crate::ty::query;\n use crate::ty::steal::Steal;"}, {"sha": "42f506606e69ae17ce280516e5e855c58e55c6c8", "filename": "src/librustc/ty/free_region_map.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Fty%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Fty%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffree_region_map.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "previous_filename": "src/librustc/infer/outlives/free_region_map.rs"}, {"sha": "144e3bc9c8bc6d16cb5e6962948ce2d01a29a3a2", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -96,15 +96,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         // ```\n         // forest.is_empty()\n         // ```\n-        self.ty_inhabitedness_forest(ty).contains(self, module)\n+        ty.uninhabited_from(self).contains(self, module)\n     }\n \n     pub fn is_ty_uninhabited_from_any_module(self, ty: Ty<'tcx>) -> bool {\n-        !self.ty_inhabitedness_forest(ty).is_empty()\n-    }\n-\n-    fn ty_inhabitedness_forest(self, ty: Ty<'tcx>) -> DefIdForest {\n-        ty.uninhabited_from(self)\n+        !ty.uninhabited_from(self).is_empty()\n     }\n }\n "}, {"sha": "9be50d19a5030e45b0e56a959ab9cff5ac1945c6", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -411,7 +411,7 @@ fn resolve_associated_item<'tcx>(\n             substs: rcvr_substs,\n         }),\n         traits::VtableObject(ref data) => {\n-            let index = tcx.get_vtable_index_of_object_method(data, def_id);\n+            let index = traits::get_vtable_index_of_object_method(tcx, data, def_id);\n             Some(Instance { def: ty::InstanceDef::Virtual(def_id, index), substs: rcvr_substs })\n         }\n         traits::VtableBuiltin(..) => {"}, {"sha": "7cca12308e65f97cf6991798e55a22ff811c17c9", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -87,10 +87,6 @@ pub use self::context::{\n \n pub use self::instance::{Instance, InstanceDef};\n \n-pub use self::structural_match::search_for_structural_match_violation;\n-pub use self::structural_match::type_marked_structural;\n-pub use self::structural_match::NonStructuralMatchTy;\n-\n pub use self::trait_def::TraitDef;\n \n pub use self::query::queries;\n@@ -107,8 +103,10 @@ pub mod error;\n pub mod fast_reject;\n pub mod flags;\n pub mod fold;\n+pub mod free_region_map;\n pub mod inhabitedness;\n pub mod layout;\n+pub mod normalize_erasing_regions;\n pub mod outlives;\n pub mod print;\n pub mod query;\n@@ -118,13 +116,11 @@ pub mod subst;\n pub mod trait_def;\n pub mod util;\n pub mod walk;\n-pub mod wf;\n \n mod context;\n mod diagnostics;\n mod instance;\n mod structural_impls;\n-mod structural_match;\n mod sty;\n \n // Data types\n@@ -3322,7 +3318,6 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     context::provide(providers);\n     erase_regions::provide(providers);\n     layout::provide(providers);\n-    util::provide(providers);\n     constness::provide(providers);\n     *providers = ty::query::Providers {\n         asyncness,"}, {"sha": "dc64482907f756a0b972161b726d0d7f03520db5", "filename": "src/librustc/ty/normalize_erasing_regions.rs", "status": "renamed", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Fty%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Fty%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fnormalize_erasing_regions.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -8,6 +8,7 @@\n //! within. (This underlying query is what is cached.)\n \n use crate::ty::fold::{TypeFoldable, TypeFolder};\n+use crate::ty::subst::{Subst, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt};\n \n impl<'tcx> TyCtxt<'tcx> {\n@@ -60,6 +61,29 @@ impl<'tcx> TyCtxt<'tcx> {\n         let value = self.erase_late_bound_regions(value);\n         self.normalize_erasing_regions(param_env, value)\n     }\n+\n+    /// Monomorphizes a type from the AST by first applying the\n+    /// in-scope substitutions and then normalizing any associated\n+    /// types.\n+    pub fn subst_and_normalize_erasing_regions<T>(\n+        self,\n+        param_substs: SubstsRef<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        value: &T,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        debug!(\n+            \"subst_and_normalize_erasing_regions(\\\n+             param_substs={:?}, \\\n+             value={:?}, \\\n+             param_env={:?})\",\n+            param_substs, value, param_env,\n+        );\n+        let substituted = value.subst(self, param_substs);\n+        self.normalize_erasing_regions(param_env, substituted)\n+    }\n }\n \n struct NormalizeAfterErasingRegionsFolder<'tcx> {", "previous_filename": "src/librustc/traits/query/normalize_erasing_regions.rs"}, {"sha": "b397a2c80d59b93f08b10e81e5b590448208f714", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -48,32 +48,29 @@ pub enum Component<'tcx> {\n impl<'tcx> TyCtxt<'tcx> {\n     /// Push onto `out` all the things that must outlive `'a` for the condition\n     /// `ty0: 'a` to hold. Note that `ty0` must be a **fully resolved type**.\n-    pub fn push_outlives_components(\n-        &self,\n-        ty0: Ty<'tcx>,\n-        out: &mut SmallVec<[Component<'tcx>; 4]>,\n-    ) {\n-        self.compute_components(ty0, out);\n+    pub fn push_outlives_components(self, ty0: Ty<'tcx>, out: &mut SmallVec<[Component<'tcx>; 4]>) {\n+        compute_components(self, ty0, out);\n         debug!(\"components({:?}) = {:?}\", ty0, out);\n     }\n+}\n \n-    fn compute_components(&self, ty: Ty<'tcx>, out: &mut SmallVec<[Component<'tcx>; 4]>) {\n-        // Descend through the types, looking for the various \"base\"\n-        // components and collecting them into `out`. This is not written\n-        // with `collect()` because of the need to sometimes skip subtrees\n-        // in the `subtys` iterator (e.g., when encountering a\n-        // projection).\n-        match ty.kind {\n+fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Component<'tcx>; 4]>) {\n+    // Descend through the types, looking for the various \"base\"\n+    // components and collecting them into `out`. This is not written\n+    // with `collect()` because of the need to sometimes skip subtrees\n+    // in the `subtys` iterator (e.g., when encountering a\n+    // projection).\n+    match ty.kind {\n             ty::Closure(def_id, ref substs) => {\n-                for upvar_ty in substs.as_closure().upvar_tys(def_id, *self) {\n-                    self.compute_components(upvar_ty, out);\n+                for upvar_ty in substs.as_closure().upvar_tys(def_id, tcx) {\n+                    compute_components(tcx, upvar_ty, out);\n                 }\n             }\n \n             ty::Generator(def_id, ref substs, _) => {\n                 // Same as the closure case\n-                for upvar_ty in substs.as_generator().upvar_tys(def_id, *self) {\n-                    self.compute_components(upvar_ty, out);\n+                for upvar_ty in substs.as_generator().upvar_tys(def_id, tcx) {\n+                    compute_components(tcx, upvar_ty, out);\n                 }\n \n                 // We ignore regions in the generator interior as we don't\n@@ -110,7 +107,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     // fallback case: hard code\n                     // OutlivesProjectionComponents.  Continue walking\n                     // through and constrain Pi.\n-                    let subcomponents = self.capture_components(ty);\n+                    let subcomponents = capture_components(tcx, ty);\n                     out.push(Component::EscapingProjection(subcomponents));\n                 }\n             }\n@@ -159,20 +156,19 @@ impl<'tcx> TyCtxt<'tcx> {\n \n                 push_region_constraints(ty, out);\n                 for subty in ty.walk_shallow() {\n-                    self.compute_components(subty, out);\n+                    compute_components(tcx, subty, out);\n                 }\n             }\n         }\n-    }\n+}\n \n-    fn capture_components(&self, ty: Ty<'tcx>) -> Vec<Component<'tcx>> {\n-        let mut temp = smallvec![];\n-        push_region_constraints(ty, &mut temp);\n-        for subty in ty.walk_shallow() {\n-            self.compute_components(subty, &mut temp);\n-        }\n-        temp.into_iter().collect()\n+fn capture_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Vec<Component<'tcx>> {\n+    let mut temp = smallvec![];\n+    push_region_constraints(ty, &mut temp);\n+    for subty in ty.walk_shallow() {\n+        compute_components(tcx, subty, &mut temp);\n     }\n+    temp.into_iter().collect()\n }\n \n fn push_region_constraints<'tcx>(ty: Ty<'tcx>, out: &mut SmallVec<[Component<'tcx>; 4]>) {"}, {"sha": "16d89343596878c0a042bec8052c3f5b57fdf33d", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -1036,34 +1036,34 @@ impl<F> FmtPrinter<'a, 'tcx, F> {\n     }\n }\n \n-impl TyCtxt<'t> {\n-    // HACK(eddyb) get rid of `def_path_str` and/or pass `Namespace` explicitly always\n-    // (but also some things just print a `DefId` generally so maybe we need this?)\n-    fn guess_def_namespace(self, def_id: DefId) -> Namespace {\n-        match self.def_key(def_id).disambiguated_data.data {\n-            DefPathData::TypeNs(..) | DefPathData::CrateRoot | DefPathData::ImplTrait => {\n-                Namespace::TypeNS\n-            }\n+// HACK(eddyb) get rid of `def_path_str` and/or pass `Namespace` explicitly always\n+// (but also some things just print a `DefId` generally so maybe we need this?)\n+fn guess_def_namespace(tcx: TyCtxt<'_>, def_id: DefId) -> Namespace {\n+    match tcx.def_key(def_id).disambiguated_data.data {\n+        DefPathData::TypeNs(..) | DefPathData::CrateRoot | DefPathData::ImplTrait => {\n+            Namespace::TypeNS\n+        }\n \n-            DefPathData::ValueNs(..)\n-            | DefPathData::AnonConst\n-            | DefPathData::ClosureExpr\n-            | DefPathData::Ctor => Namespace::ValueNS,\n+        DefPathData::ValueNs(..)\n+        | DefPathData::AnonConst\n+        | DefPathData::ClosureExpr\n+        | DefPathData::Ctor => Namespace::ValueNS,\n \n-            DefPathData::MacroNs(..) => Namespace::MacroNS,\n+        DefPathData::MacroNs(..) => Namespace::MacroNS,\n \n-            _ => Namespace::TypeNS,\n-        }\n+        _ => Namespace::TypeNS,\n     }\n+}\n \n+impl TyCtxt<'t> {\n     /// Returns a string identifying this `DefId`. This string is\n     /// suitable for user output.\n     pub fn def_path_str(self, def_id: DefId) -> String {\n         self.def_path_str_with_substs(def_id, &[])\n     }\n \n     pub fn def_path_str_with_substs(self, def_id: DefId, substs: &'t [GenericArg<'t>]) -> String {\n-        let ns = self.guess_def_namespace(def_id);\n+        let ns = guess_def_namespace(self, def_id);\n         debug!(\"def_path_str: def_id={:?}, ns={:?}\", def_id, ns);\n         let mut s = String::new();\n         let _ = FmtPrinter::new(self, &mut s, ns).print_def_path(def_id, substs);"}, {"sha": "aa93f35661a28310777f78721748e589bf743046", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 262, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -2,9 +2,7 @@\n \n use crate::hir::map::DefPathData;\n use crate::ich::NodeIdHashingMode;\n-use crate::middle::lang_items;\n use crate::mir::interpret::{sign_extend, truncate};\n-use crate::traits::{self, ObligationCause};\n use crate::ty::layout::{Integer, IntegerExt};\n use crate::ty::query::TyCtxtAt;\n use crate::ty::subst::{GenericArgKind, InternalSubsts, Subst, SubstsRef};\n@@ -18,7 +16,7 @@ use rustc_hir::def_id::DefId;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_macros::HashStable;\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::Span;\n use std::{cmp, fmt};\n use syntax::ast;\n use syntax::attr::{self, SignedInt, UnsignedInt};\n@@ -122,13 +120,6 @@ impl IntTypeExt for attr::IntType {\n     }\n }\n \n-#[derive(Clone)]\n-pub enum CopyImplementationError<'tcx> {\n-    InfrigingFields(Vec<&'tcx ty::FieldDef>),\n-    NotAnAdt,\n-    HasDestructor,\n-}\n-\n /// Describes whether a type is representable. For types that are not\n /// representable, 'SelfRecursive' and 'ContainsRecursive' are used to\n /// distinguish between types that are recursive with themselves and types that\n@@ -144,65 +135,6 @@ pub enum Representability {\n     SelfRecursive(Vec<Span>),\n }\n \n-impl<'tcx> ty::ParamEnv<'tcx> {\n-    pub fn can_type_implement_copy(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        self_type: Ty<'tcx>,\n-    ) -> Result<(), CopyImplementationError<'tcx>> {\n-        // FIXME: (@jroesch) float this code up\n-        tcx.infer_ctxt().enter(|infcx| {\n-            let (adt, substs) = match self_type.kind {\n-                // These types used to have a builtin impl.\n-                // Now libcore provides that impl.\n-                ty::Uint(_)\n-                | ty::Int(_)\n-                | ty::Bool\n-                | ty::Float(_)\n-                | ty::Char\n-                | ty::RawPtr(..)\n-                | ty::Never\n-                | ty::Ref(_, _, hir::Mutability::Not) => return Ok(()),\n-\n-                ty::Adt(adt, substs) => (adt, substs),\n-\n-                _ => return Err(CopyImplementationError::NotAnAdt),\n-            };\n-\n-            let mut infringing = Vec::new();\n-            for variant in &adt.variants {\n-                for field in &variant.fields {\n-                    let ty = field.ty(tcx, substs);\n-                    if ty.references_error() {\n-                        continue;\n-                    }\n-                    let span = tcx.def_span(field.did);\n-                    let cause = ObligationCause { span, ..ObligationCause::dummy() };\n-                    let ctx = traits::FulfillmentContext::new();\n-                    match traits::fully_normalize(&infcx, ctx, cause, self, &ty) {\n-                        Ok(ty) => {\n-                            if !infcx.type_is_copy_modulo_regions(self, ty, span) {\n-                                infringing.push(field);\n-                            }\n-                        }\n-                        Err(errors) => {\n-                            infcx.report_fulfillment_errors(&errors, None, false);\n-                        }\n-                    };\n-                }\n-            }\n-            if !infringing.is_empty() {\n-                return Err(CopyImplementationError::InfrigingFields(infringing));\n-            }\n-            if adt.has_dtor(tcx) {\n-                return Err(CopyImplementationError::HasDestructor);\n-            }\n-\n-            Ok(())\n-        })\n-    }\n-}\n-\n impl<'tcx> TyCtxt<'tcx> {\n     /// Creates a hash of the type `Ty` which will be the same no matter what crate\n     /// context it's calculated within. This is used by the `type_id` intrinsic.\n@@ -393,70 +325,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         (a, b)\n     }\n \n-    /// Given a set of predicates that apply to an object type, returns\n-    /// the region bounds that the (erased) `Self` type must\n-    /// outlive. Precisely *because* the `Self` type is erased, the\n-    /// parameter `erased_self_ty` must be supplied to indicate what type\n-    /// has been used to represent `Self` in the predicates\n-    /// themselves. This should really be a unique type; `FreshTy(0)` is a\n-    /// popular choice.\n-    ///\n-    /// N.B., in some cases, particularly around higher-ranked bounds,\n-    /// this function returns a kind of conservative approximation.\n-    /// That is, all regions returned by this function are definitely\n-    /// required, but there may be other region bounds that are not\n-    /// returned, as well as requirements like `for<'a> T: 'a`.\n-    ///\n-    /// Requires that trait definitions have been processed so that we can\n-    /// elaborate predicates and walk supertraits.\n-    //\n-    // FIXME: callers may only have a `&[Predicate]`, not a `Vec`, so that's\n-    // what this code should accept.\n-    pub fn required_region_bounds(\n-        self,\n-        erased_self_ty: Ty<'tcx>,\n-        predicates: Vec<ty::Predicate<'tcx>>,\n-    ) -> Vec<ty::Region<'tcx>> {\n-        debug!(\n-            \"required_region_bounds(erased_self_ty={:?}, predicates={:?})\",\n-            erased_self_ty, predicates\n-        );\n-\n-        assert!(!erased_self_ty.has_escaping_bound_vars());\n-\n-        traits::elaborate_predicates(self, predicates)\n-            .filter_map(|predicate| {\n-                match predicate {\n-                    ty::Predicate::Projection(..)\n-                    | ty::Predicate::Trait(..)\n-                    | ty::Predicate::Subtype(..)\n-                    | ty::Predicate::WellFormed(..)\n-                    | ty::Predicate::ObjectSafe(..)\n-                    | ty::Predicate::ClosureKind(..)\n-                    | ty::Predicate::RegionOutlives(..)\n-                    | ty::Predicate::ConstEvaluatable(..) => None,\n-                    ty::Predicate::TypeOutlives(predicate) => {\n-                        // Search for a bound of the form `erased_self_ty\n-                        // : 'a`, but be wary of something like `for<'a>\n-                        // erased_self_ty : 'a` (we interpret a\n-                        // higher-ranked bound like that as 'static,\n-                        // though at present the code in `fulfill.rs`\n-                        // considers such bounds to be unsatisfiable, so\n-                        // it's kind of a moot point since you could never\n-                        // construct such an object, but this seems\n-                        // correct even if that code changes).\n-                        let ty::OutlivesPredicate(ref t, ref r) = predicate.skip_binder();\n-                        if t == &erased_self_ty && !r.has_escaping_bound_vars() {\n-                            Some(*r)\n-                        } else {\n-                            None\n-                        }\n-                    }\n-                }\n-            })\n-            .collect()\n-    }\n-\n     /// Calculate the destructor of a given type.\n     pub fn calculate_dtor(\n         self,\n@@ -1006,128 +874,9 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n }\n \n-fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-    is_item_raw(tcx, query, lang_items::CopyTraitLangItem)\n-}\n-\n-fn is_sized_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-    is_item_raw(tcx, query, lang_items::SizedTraitLangItem)\n-}\n-\n-fn is_freeze_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-    is_item_raw(tcx, query, lang_items::FreezeTraitLangItem)\n-}\n-\n-fn is_item_raw<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    item: lang_items::LangItem,\n-) -> bool {\n-    let (param_env, ty) = query.into_parts();\n-    let trait_def_id = tcx.require_lang_item(item, None);\n-    tcx.infer_ctxt().enter(|infcx| {\n-        traits::type_known_to_meet_bound_modulo_regions(\n-            &infcx,\n-            param_env,\n-            ty,\n-            trait_def_id,\n-            DUMMY_SP,\n-        )\n-    })\n-}\n-\n #[derive(Clone, HashStable)]\n pub struct NeedsDrop(pub bool);\n \n-fn needs_drop_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> NeedsDrop {\n-    let (param_env, ty) = query.into_parts();\n-\n-    let needs_drop = |ty: Ty<'tcx>| -> bool { tcx.needs_drop_raw(param_env.and(ty)).0 };\n-\n-    assert!(!ty.needs_infer());\n-\n-    NeedsDrop(match ty.kind {\n-        // Fast-path for primitive types\n-        ty::Infer(ty::FreshIntTy(_))\n-        | ty::Infer(ty::FreshFloatTy(_))\n-        | ty::Bool\n-        | ty::Int(_)\n-        | ty::Uint(_)\n-        | ty::Float(_)\n-        | ty::Never\n-        | ty::FnDef(..)\n-        | ty::FnPtr(_)\n-        | ty::Char\n-        | ty::GeneratorWitness(..)\n-        | ty::RawPtr(_)\n-        | ty::Ref(..)\n-        | ty::Str => false,\n-\n-        // Foreign types can never have destructors\n-        ty::Foreign(..) => false,\n-\n-        // `ManuallyDrop` doesn't have a destructor regardless of field types.\n-        ty::Adt(def, _) if Some(def.did) == tcx.lang_items().manually_drop() => false,\n-\n-        // Issue #22536: We first query `is_copy_modulo_regions`.  It sees a\n-        // normalized version of the type, and therefore will definitely\n-        // know whether the type implements Copy (and thus needs no\n-        // cleanup/drop/zeroing) ...\n-        _ if ty.is_copy_modulo_regions(tcx, param_env, DUMMY_SP) => false,\n-\n-        // ... (issue #22536 continued) but as an optimization, still use\n-        // prior logic of asking for the structural \"may drop\".\n-\n-        // FIXME(#22815): Note that this is a conservative heuristic;\n-        // it may report that the type \"may drop\" when actual type does\n-        // not actually have a destructor associated with it. But since\n-        // the type absolutely did not have the `Copy` bound attached\n-        // (see above), it is sound to treat it as having a destructor.\n-\n-        // User destructors are the only way to have concrete drop types.\n-        ty::Adt(def, _) if def.has_dtor(tcx) => true,\n-\n-        // Can refer to a type which may drop.\n-        // FIXME(eddyb) check this against a ParamEnv.\n-        ty::Dynamic(..)\n-        | ty::Projection(..)\n-        | ty::Param(_)\n-        | ty::Bound(..)\n-        | ty::Placeholder(..)\n-        | ty::Opaque(..)\n-        | ty::Infer(_)\n-        | ty::Error => true,\n-\n-        ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n-\n-        // Zero-length arrays never contain anything to drop.\n-        ty::Array(_, len) if len.try_eval_usize(tcx, param_env) == Some(0) => false,\n-\n-        // Structural recursion.\n-        ty::Array(ty, _) | ty::Slice(ty) => needs_drop(ty),\n-\n-        ty::Closure(def_id, ref substs) => {\n-            substs.as_closure().upvar_tys(def_id, tcx).any(needs_drop)\n-        }\n-\n-        // Pessimistically assume that all generators will require destructors\n-        // as we don't know if a destructor is a noop or not until after the MIR\n-        // state transformation pass\n-        ty::Generator(..) => true,\n-\n-        ty::Tuple(..) => ty.tuple_fields().any(needs_drop),\n-\n-        // unions don't have destructors because of the child types,\n-        // only if they manually implement `Drop` (handled above).\n-        ty::Adt(def, _) if def.is_union() => false,\n-\n-        ty::Adt(def, substs) => def\n-            .variants\n-            .iter()\n-            .any(|variant| variant.fields.iter().any(|field| needs_drop(field.ty(tcx, substs)))),\n-    })\n-}\n-\n pub enum ExplicitSelf<'tcx> {\n     ByValue,\n     ByReference(ty::Region<'tcx>, hir::Mutability),\n@@ -1176,13 +925,3 @@ impl<'tcx> ExplicitSelf<'tcx> {\n         }\n     }\n }\n-\n-pub fn provide(providers: &mut ty::query::Providers<'_>) {\n-    *providers = ty::query::Providers {\n-        is_copy_raw,\n-        is_sized_raw,\n-        is_freeze_raw,\n-        needs_drop_raw,\n-        ..*providers\n-    };\n-}"}, {"sha": "c2e20d5cf758eb6be5d0b7fd37a819648edadac5", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -27,6 +27,7 @@ use lint::{EarlyContext, EarlyLintPass, LateLintPass, LintPass};\n use lint::{LateContext, LintArray, LintContext};\n use rustc::lint;\n use rustc::lint::FutureIncompatibleInfo;\n+use rustc::traits::misc::can_type_implement_copy;\n use rustc::ty::{self, layout::VariantIdx, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_feature::Stability;\n@@ -555,7 +556,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n         if ty.is_copy_modulo_regions(cx.tcx, param_env, item.span) {\n             return;\n         }\n-        if param_env.can_type_implement_copy(cx.tcx, ty).is_ok() {\n+        if can_type_implement_copy(cx.tcx, param_env, ty).is_ok() {\n             cx.span_lint(\n                 MISSING_COPY_IMPLEMENTATIONS,\n                 item.span,"}, {"sha": "f0dc94f417c1e23e60002c20a95b050c5ae8ef98", "filename": "src/librustc_mir/borrow_check/type_check/free_region_relations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -1,10 +1,10 @@\n use rustc::infer::canonical::QueryRegionConstraints;\n-use rustc::infer::outlives::free_region_map::FreeRegionRelations;\n use rustc::infer::region_constraints::GenericKind;\n use rustc::infer::InferCtxt;\n use rustc::mir::ConstraintCategory;\n use rustc::traits::query::outlives_bounds::{self, OutlivesBound};\n use rustc::traits::query::type_op::{self, TypeOp};\n+use rustc::ty::free_region_map::FreeRegionRelations;\n use rustc::ty::{self, RegionVid, Ty};\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n use rustc_span::DUMMY_SP;"}, {"sha": "75b25f03ca27bf2a0300ebef938e30f11ea0dfff", "filename": "src/librustc_mir/hair/pattern/const_to_pat.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fconst_to_pat.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -3,7 +3,8 @@ use crate::const_eval::const_variant_index;\n use rustc::infer::InferCtxt;\n use rustc::lint;\n use rustc::mir::Field;\n-use rustc::traits::{ObligationCause, PredicateObligation};\n+use rustc::traits::predicate_for_trait_def;\n+use rustc::traits::{self, ObligationCause, PredicateObligation};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_hir as hir;\n \n@@ -75,12 +76,12 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n     fn search_for_structural_match_violation(\n         &self,\n         ty: Ty<'tcx>,\n-    ) -> Option<ty::NonStructuralMatchTy<'tcx>> {\n-        ty::search_for_structural_match_violation(self.id, self.span, self.tcx(), ty)\n+    ) -> Option<traits::NonStructuralMatchTy<'tcx>> {\n+        traits::search_for_structural_match_violation(self.id, self.span, self.tcx(), ty)\n     }\n \n     fn type_marked_structural(&self, ty: Ty<'tcx>) -> bool {\n-        ty::type_marked_structural(self.id, self.span, &self.infcx, ty)\n+        traits::type_marked_structural(self.id, self.span, &self.infcx, ty)\n     }\n \n     fn to_pat(&mut self, cv: &'tcx ty::Const<'tcx>) -> Pat<'tcx> {\n@@ -104,8 +105,8 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n             );\n             if let Some(non_sm_ty) = structural {\n                 let adt_def = match non_sm_ty {\n-                    ty::NonStructuralMatchTy::Adt(adt_def) => adt_def,\n-                    ty::NonStructuralMatchTy::Param => {\n+                    traits::NonStructuralMatchTy::Adt(adt_def) => adt_def,\n+                    traits::NonStructuralMatchTy::Param => {\n                         bug!(\"use of constant whose type is a parameter inside a pattern\")\n                     }\n                 };\n@@ -129,7 +130,8 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // not *yet* implement `PartialEq`. So for now we leave this here.\n                 let ty_is_partial_eq: bool = {\n                     let partial_eq_trait_id = self.tcx().lang_items().eq_trait().unwrap();\n-                    let obligation: PredicateObligation<'_> = self.tcx().predicate_for_trait_def(\n+                    let obligation: PredicateObligation<'_> = predicate_for_trait_def(\n+                        self.tcx(),\n                         self.param_env,\n                         ObligationCause::misc(self.span, self.id),\n                         partial_eq_trait_id,"}, {"sha": "68e2bc532614116e3cfe3dbc899f56cf2c4909b1", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -6,6 +6,7 @@ use rustc::lint;\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability::{DeprecationEntry, Index};\n use rustc::session::Session;\n+use rustc::traits::misc::can_type_implement_copy;\n use rustc::ty::query::Providers;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -488,7 +489,7 @@ impl Visitor<'tcx> for Checker<'tcx> {\n                     .emit();\n                 } else {\n                     let param_env = self.tcx.param_env(def_id);\n-                    if !param_env.can_type_implement_copy(self.tcx, ty).is_ok() {\n+                    if !can_type_implement_copy(self.tcx, param_env, ty).is_ok() {\n                         feature_err(\n                             &self.tcx.sess.parse_sess,\n                             sym::untagged_unions,"}, {"sha": "40f821c29d366f2c215556270fb5dd5a76c87b0a", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -5,11 +5,11 @@ use rustc::infer::canonical::{self, Canonical};\n use rustc::infer::InferCtxt;\n use rustc::traits::query::outlives_bounds::OutlivesBound;\n use rustc::traits::query::{CanonicalTyGoal, Fallible, NoSolution};\n+use rustc::traits::wf;\n use rustc::traits::FulfillmentContext;\n use rustc::traits::{TraitEngine, TraitEngineExt};\n use rustc::ty::outlives::Component;\n use rustc::ty::query::Providers;\n-use rustc::ty::wf;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_hir as hir;\n use rustc_span::source_map::DUMMY_SP;"}, {"sha": "5acaede2ee02e89fb7ccb0d2dfb78191718cbd08", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -13,8 +13,10 @@ use errors::{Applicability, DiagnosticId};\n use rustc::hir::intravisit::Visitor;\n use rustc::lint::builtin::AMBIGUOUS_ASSOCIATED_ITEMS;\n use rustc::traits;\n+use rustc::traits::astconv_object_safety_violations;\n+use rustc::traits::error_reporting::report_object_safety_error;\n+use rustc::traits::wf::object_region_bounds;\n use rustc::ty::subst::{self, InternalSubsts, Subst, SubstsRef};\n-use rustc::ty::wf::object_region_bounds;\n use rustc::ty::{self, Const, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::{GenericParamDef, GenericParamDefKind};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -1452,9 +1454,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         // to avoid ICEs.\n         for item in &regular_traits {\n             let object_safety_violations =\n-                tcx.astconv_object_safety_violations(item.trait_ref().def_id());\n+                astconv_object_safety_violations(tcx, item.trait_ref().def_id());\n             if !object_safety_violations.is_empty() {\n-                tcx.report_object_safety_error(\n+                report_object_safety_error(\n+                    tcx,\n                     span,\n                     item.trait_ref().def_id(),\n                     object_safety_violations,"}, {"sha": "0be21ad58be4b2898ad700e1acb36426bb7c0190", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -37,6 +37,8 @@ use errors::{Applicability, DiagnosticBuilder};\n use rustc::middle::lang_items;\n use rustc::session::Session;\n use rustc::traits;\n+use rustc::traits::error_reporting::report_object_safety_error;\n+use rustc::traits::object_safety_violations;\n use rustc::ty::adjustment::AllowTwoPhase;\n use rustc::ty::cast::{CastKind, CastTy};\n use rustc::ty::error::TypeError;\n@@ -518,8 +520,8 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     }\n \n     fn report_object_unsafe_cast(&self, fcx: &FnCtxt<'a, 'tcx>, did: DefId) {\n-        let violations = fcx.tcx.object_safety_violations(did);\n-        let mut err = fcx.tcx.report_object_safety_error(self.cast_span, did, violations);\n+        let violations = object_safety_violations(fcx.tcx, did);\n+        let mut err = report_object_safety_error(fcx.tcx, self.cast_span, did, violations);\n         err.note(&format!(\"required by cast to type '{}'\", fcx.ty_to_string(self.cast_ty)));\n         err.emit();\n     }"}, {"sha": "36ad6ea1bc9955f834eaadc042a367335721ea5f", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -544,7 +544,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // and almost never more than 3. By using a SmallVec we avoid an\n         // allocation, at the (very small) cost of (occasionally) having to\n         // shift subsequent elements down when removing the front element.\n-        let mut queue: SmallVec<[_; 4]> = smallvec![self.tcx.predicate_for_trait_def(\n+        let mut queue: SmallVec<[_; 4]> = smallvec![traits::predicate_for_trait_def(\n+            self.tcx,\n             self.fcx.param_env,\n             cause,\n             coerce_unsized_did,"}, {"sha": "636ea5b87d6596ff64af85eda498138d588270ea", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -596,7 +596,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         target_trait_def_id: DefId,\n     ) -> ty::PolyTraitRef<'tcx> {\n         let upcast_trait_refs =\n-            self.tcx.upcast_choices(source_trait_ref.clone(), target_trait_def_id);\n+            traits::upcast_choices(self.tcx, source_trait_ref.clone(), target_trait_def_id);\n \n         // must be exactly one trait ref or we'd get an ambig error etc\n         if upcast_trait_refs.len() != 1 {"}, {"sha": "647c56112b24968e855f4106a9c9972bcfe90663", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -100,6 +100,7 @@ use rustc::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc::infer::{self, InferCtxt, InferOk, InferResult};\n use rustc::middle::region;\n use rustc::mir::interpret::ConstValue;\n+use rustc::traits::error_reporting::recursive_type_with_infinite_size_error;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n use rustc::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast,\n@@ -1900,7 +1901,7 @@ fn check_specialization_validity<'tcx>(\n         match parent_item {\n             // Parent impl exists, and contains the parent item we're trying to specialize, but\n             // doesn't mark it `default`.\n-            Some(parent_item) if tcx.impl_item_is_final(&parent_item) => {\n+            Some(parent_item) if traits::impl_item_is_final(tcx, &parent_item) => {\n                 Some(Err(parent_impl.def_id()))\n             }\n \n@@ -1911,7 +1912,7 @@ fn check_specialization_validity<'tcx>(\n             // grandparent. In that case, if parent is a `default impl`, inherited items use the\n             // \"defaultness\" from the grandparent, else they are final.\n             None => {\n-                if tcx.impl_is_default(parent_impl.def_id()) {\n+                if traits::impl_is_default(tcx, parent_impl.def_id()) {\n                     None\n                 } else {\n                     Some(Err(parent_impl.def_id()))\n@@ -2075,7 +2076,7 @@ fn check_impl_items_against_trait<'tcx>(\n             .map(|node_item| !node_item.node.is_from_trait())\n             .unwrap_or(false);\n \n-        if !is_implemented && !tcx.impl_is_default(impl_id) {\n+        if !is_implemented && !traits::impl_is_default(tcx, impl_id) {\n             if !trait_item.defaultness.has_value() {\n                 missing_items.push(trait_item);\n             } else if associated_type_overridden {\n@@ -2222,7 +2223,7 @@ fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: DefId) -> bool {\n     // caught by case 1.\n     match rty.is_representable(tcx, sp) {\n         Representability::SelfRecursive(spans) => {\n-            let mut err = tcx.recursive_type_with_infinite_size_error(item_def_id);\n+            let mut err = recursive_type_with_infinite_size_error(tcx, item_def_id);\n             for span in spans {\n                 err.span_label(span, \"recursive without indirection\");\n             }"}, {"sha": "f3a51fa33faa0174c00f4c05ef29476a54256bbf", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -417,7 +417,7 @@ fn check_impl<'tcx>(\n                 let trait_ref = fcx.tcx.impl_trait_ref(item_def_id).unwrap();\n                 let trait_ref =\n                     fcx.normalize_associated_types_in(ast_trait_ref.path.span, &trait_ref);\n-                let obligations = ty::wf::trait_obligations(\n+                let obligations = traits::wf::trait_obligations(\n                     fcx,\n                     fcx.param_env,\n                     fcx.body_id,\n@@ -596,7 +596,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n     let wf_obligations = predicates\n         .predicates\n         .iter()\n-        .flat_map(|p| ty::wf::predicate_obligations(fcx, fcx.param_env, fcx.body_id, p, span));\n+        .flat_map(|p| traits::wf::predicate_obligations(fcx, fcx.param_env, fcx.body_id, p, span));\n \n     for obligation in wf_obligations.chain(default_obligations) {\n         debug!(\"next obligation cause: {:?}\", obligation.cause);"}, {"sha": "eb1ea679040a8a3cc84a865e355c7ad07a43916b", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -7,9 +7,10 @@ use rustc::middle::lang_items::UnsizeTraitLangItem;\n use rustc::middle::region;\n \n use rustc::infer;\n+use rustc::traits::misc::{can_type_implement_copy, CopyImplementationError};\n+use rustc::traits::predicate_for_trait_def;\n use rustc::traits::{self, ObligationCause, TraitEngine};\n use rustc::ty::adjustment::CoerceUnsizedInfo;\n-use rustc::ty::util::CopyImplementationError;\n use rustc::ty::TypeFoldable;\n use rustc::ty::{self, Ty, TyCtxt};\n \n@@ -91,7 +92,7 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: DefId) {\n \n     debug!(\"visit_implementation_of_copy: self_type={:?} (free)\", self_type);\n \n-    match param_env.can_type_implement_copy(tcx, self_type) {\n+    match can_type_implement_copy(tcx, param_env, self_type) {\n         Ok(()) => {}\n         Err(CopyImplementationError::InfrigingFields(fields)) => {\n             let item = tcx.hir().expect_item(impl_hir_id);\n@@ -284,7 +285,8 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: DefId) {\n                         let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n \n                         for field in coerced_fields {\n-                            let predicate = tcx.predicate_for_trait_def(\n+                            let predicate = predicate_for_trait_def(\n+                                tcx,\n                                 param_env,\n                                 cause.clone(),\n                                 dispatch_from_dyn_trait,\n@@ -543,7 +545,8 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n \n         // Register an obligation for `A: Trait<B>`.\n         let cause = traits::ObligationCause::misc(span, impl_hir_id);\n-        let predicate = tcx.predicate_for_trait_def(\n+        let predicate = predicate_for_trait_def(\n+            tcx,\n             param_env,\n             cause,\n             trait_def_id,"}, {"sha": "fb9e4ba5ce28ea775fa805897de18274cb219cef", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7e393b5b3b543d355ae16c1940cf98b6c7fcb8aa", "patch": "@@ -23,6 +23,7 @@ use crate::middle::weak_lang_items;\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc::mir::mono::Linkage;\n+use rustc::traits;\n use rustc::ty::query::Providers;\n use rustc::ty::subst::GenericArgKind;\n use rustc::ty::subst::{InternalSubsts, Subst};\n@@ -1509,48 +1510,48 @@ fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             }\n         }\n \n-        Node::GenericParam(param) => {\n-            match &param.kind {\n-                hir::GenericParamKind::Type { default: Some(ref ty), .. } => icx.to_ty(ty),\n-                hir::GenericParamKind::Const { ty: ref hir_ty, .. } => {\n-                    let ty = icx.to_ty(hir_ty);\n-                    if !tcx.features().const_compare_raw_pointers {\n-                        let err = match ty.peel_refs().kind {\n-                            ty::FnPtr(_) => Some(\"function pointers\"),\n-                            ty::RawPtr(_) => Some(\"raw pointers\"),\n-                            _ => None,\n-                        };\n-                        if let Some(unsupported_type) = err {\n-                            feature_gate::feature_err(\n-                                &tcx.sess.parse_sess,\n-                                sym::const_compare_raw_pointers,\n-                                hir_ty.span,\n-                                &format!(\n-                                    \"using {} as const generic parameters is unstable\",\n-                                    unsupported_type\n-                                ),\n-                            )\n-                            .emit();\n-                        };\n-                    }\n-                    if ty::search_for_structural_match_violation(param.hir_id, param.span, tcx, ty)\n-                        .is_some()\n-                    {\n-                        struct_span_err!(\n+        Node::GenericParam(param) => match &param.kind {\n+            hir::GenericParamKind::Type { default: Some(ref ty), .. } => icx.to_ty(ty),\n+            hir::GenericParamKind::Const { ty: ref hir_ty, .. } => {\n+                let ty = icx.to_ty(hir_ty);\n+                if !tcx.features().const_compare_raw_pointers {\n+                    let err = match ty.peel_refs().kind {\n+                        ty::FnPtr(_) => Some(\"function pointers\"),\n+                        ty::RawPtr(_) => Some(\"raw pointers\"),\n+                        _ => None,\n+                    };\n+                    if let Some(unsupported_type) = err {\n+                        feature_gate::feature_err(\n+                            &tcx.sess.parse_sess,\n+                            sym::const_compare_raw_pointers,\n+                            hir_ty.span,\n+                            &format!(\n+                                \"using {} as const generic parameters is unstable\",\n+                                unsupported_type\n+                            ),\n+                        )\n+                        .emit();\n+                    };\n+                }\n+                if traits::search_for_structural_match_violation(param.hir_id, param.span, tcx, ty)\n+                    .is_some()\n+                {\n+                    struct_span_err!(\n                         tcx.sess,\n                         hir_ty.span,\n                         E0741,\n                         \"the types of const generic parameters must derive `PartialEq` and `Eq`\",\n-                    ).span_label(\n+                    )\n+                    .span_label(\n                         hir_ty.span,\n                         format!(\"`{}` doesn't derive both `PartialEq` and `Eq`\", ty),\n-                    ).emit();\n-                    }\n-                    ty\n+                    )\n+                    .emit();\n                 }\n-                x => bug!(\"unexpected non-type Node::GenericParam: {:?}\", x),\n+                ty\n             }\n-        }\n+            x => bug!(\"unexpected non-type Node::GenericParam: {:?}\", x),\n+        },\n \n         x => {\n             bug!(\"unexpected sort of node in type_of_def_id(): {:?}\", x);"}]}