{"sha": "14efbf148109888f939f671fbd5b60650c5f4744", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0ZWZiZjE0ODEwOTg4OGY5MzlmNjcxZmJkNWI2MDY1MGM1ZjQ3NDQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-02T21:26:41Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-07T04:19:10Z"}, "message": "mir: prepare for rvalue promotion support.", "tree": {"sha": "773051d52ccbe7f629ee2f0c61cc782de3191f2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/773051d52ccbe7f629ee2f0c61cc782de3191f2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14efbf148109888f939f671fbd5b60650c5f4744", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14efbf148109888f939f671fbd5b60650c5f4744", "html_url": "https://github.com/rust-lang/rust/commit/14efbf148109888f939f671fbd5b60650c5f4744", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14efbf148109888f939f671fbd5b60650c5f4744/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1eca0a1103afa6ba87ee3e23a921ed8faf4c130", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130", "html_url": "https://github.com/rust-lang/rust/commit/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130"}], "stats": {"total": 331, "additions": 236, "deletions": 95}, "files": [{"sha": "8378495599ce33be9b9b38cbc566dd20fd7af569", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=14efbf148109888f939f671fbd5b60650c5f4744", "patch": "@@ -64,6 +64,7 @@ pub enum DepNode<D: Clone + Debug> {\n     IntrinsicCheck(D),\n     MatchCheck(D),\n     MirMapConstruction(D),\n+    MirPass(D),\n     MirTypeck(D),\n     BorrowCheck(D),\n     RvalueCheck(D),\n@@ -186,6 +187,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             IntrinsicCheck(ref d) => op(d).map(IntrinsicCheck),\n             MatchCheck(ref d) => op(d).map(MatchCheck),\n             MirMapConstruction(ref d) => op(d).map(MirMapConstruction),\n+            MirPass(ref d) => op(d).map(MirPass),\n             MirTypeck(ref d) => op(d).map(MirTypeck),\n             BorrowCheck(ref d) => op(d).map(BorrowCheck),\n             RvalueCheck(ref d) => op(d).map(RvalueCheck),"}, {"sha": "9f8a3dbfa8f39d66ce2b6f3c13f548c1fb5aa171", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=14efbf148109888f939f671fbd5b60650c5f4744", "patch": "@@ -36,6 +36,11 @@ pub struct Mir<'tcx> {\n     /// used (eventually) for debuginfo. Indexed by a `ScopeId`.\n     pub scopes: Vec<ScopeData>,\n \n+    /// Rvalues promoted from this function, such as borrows of constants.\n+    /// Each of them is the Mir of a constant with the fn's type parameters\n+    /// in scope, but no vars or args and a separate set of temps.\n+    pub promoted: Vec<Mir<'tcx>>,\n+\n     /// Return type of the function.\n     pub return_ty: FnOutput<'tcx>,\n \n@@ -987,6 +992,10 @@ pub enum Literal<'tcx> {\n     Value {\n         value: ConstVal,\n     },\n+    Promoted {\n+        // Index into the `promoted` vector of `Mir`.\n+        index: usize\n+    },\n }\n \n impl<'tcx> Debug for Constant<'tcx> {\n@@ -1007,6 +1016,9 @@ impl<'tcx> Debug for Literal<'tcx> {\n                 write!(fmt, \"const \")?;\n                 fmt_const_val(fmt, value)\n             }\n+            Promoted { index } => {\n+                write!(fmt, \"promoted{}\", index)\n+            }\n         }\n     }\n }"}, {"sha": "520bfbddf9f0a179f18503070a5c6631da83826f", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 74, "deletions": 3, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=14efbf148109888f939f671fbd5b60650c5f4744", "patch": "@@ -8,31 +8,102 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use dep_graph::DepNode;\n+use hir;\n+use hir::map::DefPathData;\n+use hir::def_id::DefId;\n use mir::mir_map::MirMap;\n use mir::repr::Mir;\n use ty::TyCtxt;\n use syntax::ast::NodeId;\n \n+/// Where a specific Mir comes from.\n+#[derive(Copy, Clone)]\n+pub enum MirSource {\n+    /// Functions and methods.\n+    Fn(NodeId),\n+\n+    /// Constants and associated constants.\n+    Const(NodeId),\n+\n+    /// Initializer of a `static` item.\n+    Static(NodeId, hir::Mutability),\n+\n+    /// Promoted rvalues within a function.\n+    Promoted(NodeId, usize)\n+}\n+\n+impl MirSource {\n+    pub fn from_node(tcx: &TyCtxt, id: NodeId) -> MirSource {\n+        use hir::*;\n+\n+        // Handle constants in enum discriminants, types, and repeat expressions.\n+        let def_id = tcx.map.local_def_id(id);\n+        let def_key = tcx.def_key(def_id);\n+        if def_key.disambiguated_data.data == DefPathData::Initializer {\n+            return MirSource::Const(id);\n+        }\n+\n+        match tcx.map.get(id) {\n+            map::NodeItem(&Item { node: ItemConst(..), .. }) |\n+            map::NodeTraitItem(&TraitItem { node: ConstTraitItem(..), .. }) |\n+            map::NodeImplItem(&ImplItem { node: ImplItemKind::Const(..), .. }) => {\n+                MirSource::Const(id)\n+            }\n+            map::NodeItem(&Item { node: ItemStatic(_, m, _), .. }) => {\n+                MirSource::Static(id, m)\n+            }\n+            // Default to function if it's not a constant or static.\n+            _ => MirSource::Fn(id)\n+        }\n+    }\n+\n+    pub fn item_id(&self) -> NodeId {\n+        match *self {\n+            MirSource::Fn(id) |\n+            MirSource::Const(id) |\n+            MirSource::Static(id, _) |\n+            MirSource::Promoted(id, _) => id\n+        }\n+    }\n+}\n+\n /// Various information about pass.\n pub trait Pass {\n     // fn name() for printouts of various sorts?\n     // fn should_run(Session) to check if pass should run?\n+    fn dep_node(&self, def_id: DefId) -> DepNode<DefId> {\n+        DepNode::MirPass(def_id)\n+    }\n }\n \n /// A pass which inspects the whole MirMap.\n pub trait MirMapPass<'tcx>: Pass {\n-    fn run_pass(&mut self, cx: &TyCtxt<'tcx>, map: &mut MirMap<'tcx>);\n+    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, map: &mut MirMap<'tcx>);\n }\n \n /// A pass which inspects Mir of functions in isolation.\n pub trait MirPass<'tcx>: Pass {\n-    fn run_pass(&mut self, cx: &TyCtxt<'tcx>, id: NodeId, mir: &mut Mir<'tcx>);\n+    fn run_pass_on_promoted(&mut self, tcx: &TyCtxt<'tcx>,\n+                            item_id: NodeId, index: usize,\n+                            mir: &mut Mir<'tcx>) {\n+        self.run_pass(tcx, MirSource::Promoted(item_id, index), mir);\n+    }\n+    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, src: MirSource, mir: &mut Mir<'tcx>);\n }\n \n impl<'tcx, T: MirPass<'tcx>> MirMapPass<'tcx> for T {\n     fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, map: &mut MirMap<'tcx>) {\n         for (&id, mir) in &mut map.map {\n-            MirPass::run_pass(self, tcx, id, mir);\n+            let def_id = tcx.map.local_def_id(id);\n+            let _task = tcx.dep_graph.in_task(self.dep_node(def_id));\n+\n+            let src = MirSource::from_node(tcx, id);\n+            MirPass::run_pass(self, tcx, src, mir);\n+\n+            for (i, mir) in mir.promoted.iter_mut().enumerate() {\n+                self.run_pass_on_promoted(tcx, id, i, mir);\n+            }\n         }\n     }\n }"}, {"sha": "f6a241004b37beb319a084421778bc8bea57da07", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=14efbf148109888f939f671fbd5b60650c5f4744", "patch": "@@ -244,6 +244,7 @@ macro_rules! make_mir_visitor {\n                 let Mir {\n                     ref $($mutability)* basic_blocks,\n                     ref $($mutability)* scopes,\n+                    promoted: _, // Visited by passes separately.\n                     ref $($mutability)* return_ty,\n                     ref $($mutability)* var_decls,\n                     ref $($mutability)* arg_decls,\n@@ -649,10 +650,11 @@ macro_rules! make_mir_visitor {\n                                     ref $($mutability)* substs } => {\n                         self.visit_def_id(def_id);\n                         self.visit_substs(substs);\n-                    },\n+                    }\n                     Literal::Value { ref $($mutability)* value } => {\n                         self.visit_const_val(value);\n                     }\n+                    Literal::Promoted { index: _ } => {}\n                 }\n             }\n "}, {"sha": "c911b20c2aba2c94217db4c3a7f2ac03f36c6355", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=14efbf148109888f939f671fbd5b60650c5f4744", "patch": "@@ -855,6 +855,9 @@ pub fn maybe_get_item_mir<'tcx>(cdata: Cmd,\n         };\n \n         def_id_and_span_translator.visit_mir(&mut mir);\n+        for promoted in &mut mir.promoted {\n+            def_id_and_span_translator.visit_mir(promoted);\n+        }\n \n         mir\n     });"}, {"sha": "4ce77d162e07f1af886cad9122433a4621e3214c", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=14efbf148109888f939f671fbd5b60650c5f4744", "patch": "@@ -296,6 +296,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         (Mir {\n             basic_blocks: self.cfg.basic_blocks,\n             scopes: self.scope_datas,\n+            promoted: vec![],\n             var_decls: self.var_decls,\n             arg_decls: arg_decls,\n             temp_decls: self.temp_decls,"}, {"sha": "8f22f491455d014be7ba81f9daf5e40ea026f4f9", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=14efbf148109888f939f671fbd5b60650c5f4744", "patch": "@@ -19,6 +19,7 @@\n use build;\n use rustc::dep_graph::DepNode;\n use rustc::mir::repr::Mir;\n+use rustc::mir::transform::MirSource;\n use pretty;\n use hair::cx::Cx;\n \n@@ -55,20 +56,20 @@ struct BuildMir<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> BuildMir<'a, 'tcx> {\n-    fn build<F>(&mut self, id: ast::NodeId, f: F)\n+    fn build<F>(&mut self, src: MirSource, f: F)\n         where F: for<'b> FnOnce(Cx<'b, 'tcx>) -> (Mir<'tcx>, build::ScopeAuxiliaryVec)\n     {\n-        let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n+        let param_env = ty::ParameterEnvironment::for_item(self.tcx, src.item_id());\n         let infcx = infer::new_infer_ctxt(self.tcx,\n                                           &self.tcx.tables,\n                                           Some(param_env),\n                                           ProjectionMode::AnyFinal);\n \n         let (mir, scope_auxiliary) = f(Cx::new(&infcx));\n \n-        pretty::dump_mir(self.tcx, \"mir_map\", &0, id, &mir, Some(&scope_auxiliary));\n+        pretty::dump_mir(self.tcx, \"mir_map\", &0, src, &mir, Some(&scope_auxiliary));\n \n-        assert!(self.map.map.insert(id, mir).is_none())\n+        assert!(self.map.map.insert(src.item_id(), mir).is_none())\n     }\n \n     fn build_const_integer(&mut self, expr: &'tcx hir::Expr) {\n@@ -79,17 +80,25 @@ impl<'a, 'tcx> BuildMir<'a, 'tcx> {\n         if let hir::ExprClosure(..) = expr.node {\n             return;\n         }\n-        self.build(expr.id, |cx| build::construct_const(cx, expr.id, expr));\n+        self.build(MirSource::Const(expr.id), |cx| {\n+            build::construct_const(cx, expr.id, expr)\n+        });\n     }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     // Const and static items.\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n-            hir::ItemConst(_, ref expr) |\n-            hir::ItemStatic(_, _, ref expr) => {\n-                self.build(item.id, |cx| build::construct_const(cx, item.id, expr));\n+            hir::ItemConst(_, ref expr) => {\n+                self.build(MirSource::Const(item.id), |cx| {\n+                    build::construct_const(cx, item.id, expr)\n+                });\n+            }\n+            hir::ItemStatic(_, m, ref expr) => {\n+                self.build(MirSource::Static(item.id, m), |cx| {\n+                    build::construct_const(cx, item.id, expr)\n+                });\n             }\n             _ => {}\n         }\n@@ -99,15 +108,19 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     // Trait associated const defaults.\n     fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n         if let hir::ConstTraitItem(_, Some(ref expr)) = item.node {\n-            self.build(item.id, |cx| build::construct_const(cx, item.id, expr));\n+            self.build(MirSource::Const(item.id), |cx| {\n+                build::construct_const(cx, item.id, expr)\n+            });\n         }\n         intravisit::walk_trait_item(self, item);\n     }\n \n     // Impl associated const.\n     fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n         if let hir::ImplItemKind::Const(_, ref expr) = item.node {\n-            self.build(item.id, |cx| build::construct_const(cx, item.id, expr));\n+            self.build(MirSource::Const(item.id), |cx| {\n+                build::construct_const(cx, item.id, expr)\n+            });\n         }\n         intravisit::walk_impl_item(self, item);\n     }\n@@ -166,7 +179,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n                     (fn_sig.inputs[index], Some(&*arg.pat))\n                 });\n \n-        self.build(id, |cx| {\n+        self.build(MirSource::Fn(id), |cx| {\n             let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n             build::construct_fn(cx, id, arguments, fn_sig.output, body)\n         });"}, {"sha": "0e082ac262ec1ff51e01dc44c666bb1ed3c77316", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 42, "deletions": 19, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=14efbf148109888f939f671fbd5b60650c5f4744", "patch": "@@ -9,7 +9,9 @@\n // except according to those terms.\n \n use build::{Location, ScopeAuxiliaryVec};\n+use rustc::hir;\n use rustc::mir::repr::*;\n+use rustc::mir::transform::MirSource;\n use rustc::ty::{self, TyCtxt};\n use rustc_data_structures::fnv::FnvHashMap;\n use std::fmt::Display;\n@@ -37,13 +39,14 @@ const INDENT: &'static str = \"    \";\n pub fn dump_mir<'a, 'tcx>(tcx: &TyCtxt<'tcx>,\n                           pass_name: &str,\n                           disambiguator: &Display,\n-                          node_id: NodeId,\n+                          src: MirSource,\n                           mir: &Mir<'tcx>,\n                           auxiliary: Option<&ScopeAuxiliaryVec>) {\n     let filters = match tcx.sess.opts.debugging_opts.dump_mir {\n         None => return,\n         Some(ref filters) => filters,\n     };\n+    let node_id = src.item_id();\n     let node_path = tcx.item_path_str(tcx.map.local_def_id(node_id));\n     let is_matched =\n         filters.split(\"&\")\n@@ -64,7 +67,7 @@ pub fn dump_mir<'a, 'tcx>(tcx: &TyCtxt<'tcx>,\n         try!(writeln!(file, \"// pass_name = {}\", pass_name));\n         try!(writeln!(file, \"// disambiguator = {}\", disambiguator));\n         try!(writeln!(file, \"\"));\n-        try!(write_mir_fn(tcx, node_id, mir, &mut file, auxiliary));\n+        try!(write_mir_fn(tcx, src, mir, &mut file, auxiliary));\n         Ok(())\n     });\n }\n@@ -76,8 +79,13 @@ pub fn write_mir_pretty<'a, 'tcx, I>(tcx: &TyCtxt<'tcx>,\n                                      -> io::Result<()>\n     where I: Iterator<Item=(&'a NodeId, &'a Mir<'tcx>)>, 'tcx: 'a\n {\n-    for (&node_id, mir) in iter {\n-        write_mir_fn(tcx, node_id, mir, w, None)?;\n+    for (&id, mir) in iter {\n+        let src = MirSource::from_node(tcx, id);\n+        write_mir_fn(tcx, src, mir, w, None)?;\n+\n+        for (i, mir) in mir.promoted.iter().enumerate() {\n+            write_mir_fn(tcx, MirSource::Promoted(id, i), mir, w, None)?;\n+        }\n     }\n     Ok(())\n }\n@@ -88,7 +96,7 @@ enum Annotation {\n }\n \n pub fn write_mir_fn<'tcx>(tcx: &TyCtxt<'tcx>,\n-                          node_id: NodeId,\n+                          src: MirSource,\n                           mir: &Mir<'tcx>,\n                           w: &mut Write,\n                           auxiliary: Option<&ScopeAuxiliaryVec>)\n@@ -111,7 +119,7 @@ pub fn write_mir_fn<'tcx>(tcx: &TyCtxt<'tcx>,\n         }\n     }\n \n-    write_mir_intro(tcx, node_id, mir, w)?;\n+    write_mir_intro(tcx, src, mir, w)?;\n     for block in mir.all_basic_blocks() {\n         write_basic_block(tcx, block, mir, w, &annotations)?;\n     }\n@@ -214,24 +222,39 @@ fn write_scope_tree(tcx: &TyCtxt,\n \n /// Write out a human-readable textual representation of the MIR's `fn` type and the types of its\n /// local variables (both user-defined bindings and compiler temporaries).\n-fn write_mir_intro(tcx: &TyCtxt, nid: NodeId, mir: &Mir, w: &mut Write)\n+fn write_mir_intro(tcx: &TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n                    -> io::Result<()> {\n-    write!(w, \"fn {}(\", tcx.node_path_str(nid))?;\n+    match src {\n+        MirSource::Fn(_) => write!(w, \"fn\")?,\n+        MirSource::Const(_) => write!(w, \"const\")?,\n+        MirSource::Static(_, hir::MutImmutable) => write!(w, \"static\")?,\n+        MirSource::Static(_, hir::MutMutable) => write!(w, \"static mut\")?,\n+        MirSource::Promoted(_, i) => write!(w, \"promoted{} in\", i)?\n+    }\n+\n+    write!(w, \" {}\", tcx.node_path_str(src.item_id()))?;\n \n-    // fn argument types.\n-    for (i, arg) in mir.arg_decls.iter().enumerate() {\n-        if i > 0 {\n-            write!(w, \", \")?;\n+    if let MirSource::Fn(_) = src {\n+        write!(w, \"(\")?;\n+\n+        // fn argument types.\n+        for (i, arg) in mir.arg_decls.iter().enumerate() {\n+            if i > 0 {\n+                write!(w, \", \")?;\n+            }\n+            write!(w, \"{:?}: {}\", Lvalue::Arg(i as u32), arg.ty)?;\n         }\n-        write!(w, \"{:?}: {}\", Lvalue::Arg(i as u32), arg.ty)?;\n-    }\n \n-    write!(w, \") -> \")?;\n+        write!(w, \") -> \")?;\n \n-    // fn return type.\n-    match mir.return_ty {\n-        ty::FnOutput::FnConverging(ty) => write!(w, \"{}\", ty)?,\n-        ty::FnOutput::FnDiverging => write!(w, \"!\")?,\n+        // fn return type.\n+        match mir.return_ty {\n+            ty::FnOutput::FnConverging(ty) => write!(w, \"{}\", ty)?,\n+            ty::FnOutput::FnDiverging => write!(w, \"!\")?,\n+        }\n+    } else {\n+        assert!(mir.arg_decls.is_empty());\n+        write!(w, \": {} =\", mir.return_ty.unwrap())?;\n     }\n \n     writeln!(w, \" {{\")?;"}, {"sha": "ee7c9015baad666e4e74aaf40b8ea5fc98909321", "filename": "src/librustc_mir/transform/break_critical_edges.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs?ref=14efbf148109888f939f671fbd5b60650c5f4744", "patch": "@@ -10,8 +10,7 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::repr::*;\n-use rustc::mir::transform::{MirPass, Pass};\n-use syntax::ast::NodeId;\n+use rustc::mir::transform::{MirPass, MirSource, Pass};\n \n use rustc_data_structures::bitvec::BitVector;\n \n@@ -43,7 +42,7 @@ pub struct BreakCriticalEdges;\n  */\n \n impl<'tcx> MirPass<'tcx> for BreakCriticalEdges {\n-    fn run_pass(&mut self, _: &TyCtxt<'tcx>, _: NodeId, mir: &mut Mir<'tcx>) {\n+    fn run_pass(&mut self, _: &TyCtxt<'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n         break_critical_edges(mir);\n     }\n }"}, {"sha": "678d2c4614d276d166f4c0da75aae23078806fc7", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=14efbf148109888f939f671fbd5b60650c5f4744", "patch": "@@ -16,8 +16,7 @@ use rustc::ty::subst::Substs;\n use rustc::ty::{Ty, TyCtxt};\n use rustc::mir::repr::*;\n use rustc::mir::visit::MutVisitor;\n-use rustc::mir::transform::{MirPass, Pass};\n-use syntax::ast::NodeId;\n+use rustc::mir::transform::{MirPass, MirSource, Pass};\n \n struct EraseRegionsVisitor<'a, 'tcx: 'a> {\n     tcx: &'a TyCtxt<'tcx>,\n@@ -47,7 +46,7 @@ pub struct EraseRegions;\n impl Pass for EraseRegions {}\n \n impl<'tcx> MirPass<'tcx> for EraseRegions {\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, _: NodeId, mir: &mut Mir<'tcx>) {\n+    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n         EraseRegionsVisitor::new(tcx).visit_mir(mir);\n     }\n }"}, {"sha": "9c9f95e2e630ec285a9590efa66c19afe99a0faa", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=14efbf148109888f939f671fbd5b60650c5f4744", "patch": "@@ -14,8 +14,7 @@\n use rustc::ty::TyCtxt;\n use rustc::mir::repr::*;\n use rustc::mir::visit::MutVisitor;\n-use rustc::mir::transform::{Pass, MirPass};\n-use syntax::ast::NodeId;\n+use rustc::mir::transform::{Pass, MirPass, MirSource};\n \n pub struct NoLandingPads;\n \n@@ -42,7 +41,7 @@ impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n }\n \n impl<'tcx> MirPass<'tcx> for NoLandingPads {\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, _: NodeId, mir: &mut Mir<'tcx>) {\n+    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n         if tcx.sess.no_landing_pads() {\n             self.visit_mir(mir);\n         }"}, {"sha": "e0d05a17d4376ea2e73b805c03c688a3b94b9d9c", "filename": "src/librustc_mir/transform/remove_dead_blocks.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs?ref=14efbf148109888f939f671fbd5b60650c5f4744", "patch": "@@ -35,13 +35,12 @@\n use rustc_data_structures::bitvec::BitVector;\n use rustc::ty::TyCtxt;\n use rustc::mir::repr::*;\n-use rustc::mir::transform::{Pass, MirPass};\n-use syntax::ast::NodeId;\n+use rustc::mir::transform::{Pass, MirPass, MirSource};\n \n pub struct RemoveDeadBlocks;\n \n impl<'tcx> MirPass<'tcx> for RemoveDeadBlocks {\n-    fn run_pass(&mut self, _: &TyCtxt<'tcx>, _: NodeId, mir: &mut Mir<'tcx>) {\n+    fn run_pass(&mut self, _: &TyCtxt<'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n         let mut seen = BitVector::new(mir.basic_blocks.len());\n         // This block is always required.\n         seen.insert(START_BLOCK.index());"}, {"sha": "a137a812867fa6bef22689f14784edbddd5e222c", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=14efbf148109888f939f671fbd5b60650c5f4744", "patch": "@@ -11,9 +11,8 @@\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::TyCtxt;\n use rustc::mir::repr::*;\n-use rustc::mir::transform::{MirPass, Pass};\n+use rustc::mir::transform::{MirPass, MirSource, Pass};\n use pretty;\n-use syntax::ast::NodeId;\n \n use super::remove_dead_blocks::RemoveDeadBlocks;\n \n@@ -112,15 +111,15 @@ impl SimplifyCfg {\n }\n \n impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, id: NodeId, mir: &mut Mir<'tcx>) {\n+    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n         let mut counter = 0;\n         let mut changed = true;\n         while changed {\n-            pretty::dump_mir(tcx, \"simplify_cfg\", &counter, id, mir, None);\n+            pretty::dump_mir(tcx, \"simplify_cfg\", &counter, src, mir, None);\n             counter += 1;\n             changed = self.simplify_branches(mir);\n             changed |= self.remove_goto_chains(mir);\n-            RemoveDeadBlocks.run_pass(tcx, id, mir);\n+            RemoveDeadBlocks.run_pass(tcx, src, mir);\n         }\n         // FIXME: Should probably be moved into some kind of pass manager\n         mir.basic_blocks.shrink_to_fit();"}, {"sha": "18ebadf42d688953fbeb09cd0601ea1daaba841d", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=14efbf148109888f939f671fbd5b60650c5f4744", "patch": "@@ -12,16 +12,16 @@\n #![allow(unreachable_code)]\n \n use rustc::dep_graph::DepNode;\n+use rustc::hir::def_id::DefId;\n use rustc::infer::{self, InferCtxt, InferOk};\n use rustc::traits::{self, ProjectionMode};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::mir::repr::*;\n use rustc::mir::tcx::LvalueTy;\n-use rustc::mir::transform::{MirPass, Pass};\n+use rustc::mir::transform::{MirPass, MirSource, Pass};\n use rustc::mir::visit::{self, Visitor};\n use std::fmt;\n-use syntax::ast::NodeId;\n use syntax::codemap::{Span, DUMMY_SP};\n \n macro_rules! span_mirbug {\n@@ -578,15 +578,13 @@ impl TypeckMir {\n }\n \n impl<'tcx> MirPass<'tcx> for TypeckMir {\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, id: NodeId, mir: &mut Mir<'tcx>) {\n+    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n         if tcx.sess.err_count() > 0 {\n             // compiling a broken program can obviously result in a\n             // broken MIR, so try not to report duplicate errors.\n             return;\n         }\n-        let def_id = tcx.map.local_def_id(id);\n-        let _task = tcx.dep_graph.in_task(DepNode::MirTypeck(def_id));\n-        let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n+        let param_env = ty::ParameterEnvironment::for_item(tcx, src.item_id());\n         let infcx = infer::new_infer_ctxt(tcx,\n                                           &tcx.tables,\n                                           Some(param_env),\n@@ -605,4 +603,8 @@ impl<'tcx> MirPass<'tcx> for TypeckMir {\n     }\n }\n \n-impl Pass for TypeckMir {}\n+impl Pass for TypeckMir {\n+    fn dep_node(&self, def_id: DefId) -> DepNode<DefId> {\n+        DepNode::MirTypeck(def_id)\n+    }\n+}"}, {"sha": "a0311ec606627757e3b0f391c7e7ebcb6a4f631b", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=14efbf148109888f939f671fbd5b60650c5f4744", "patch": "@@ -414,6 +414,9 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n             };\n \n             visitor.visit_mir(&mir);\n+            for promoted in &mir.promoted {\n+                visitor.visit_mir(promoted);\n+            }\n         }\n     }\n "}, {"sha": "9c1dfb0fc8d216efc156e725fd125c8ef18c4efb", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 49, "deletions": 33, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=14efbf148109888f939f671fbd5b60650c5f4744", "patch": "@@ -35,7 +35,7 @@ use syntax::codemap::{Span, DUMMY_SP};\n use std::ptr;\n \n use super::operand::{OperandRef, OperandValue};\n-use super::{CachedMir, MirContext};\n+use super::MirContext;\n \n /// A sized constant rvalue.\n /// The LLVM type might not be the same for a single Rust type,\n@@ -179,7 +179,7 @@ impl<'tcx> ConstLvalue<'tcx> {\n /// FIXME(eddyb) use miri and lower its allocations to LLVM.\n struct MirConstContext<'a, 'tcx: 'a> {\n     ccx: &'a CrateContext<'a, 'tcx>,\n-    mir: CachedMir<'a, 'tcx>,\n+    mir: &'a mir::Mir<'tcx>,\n \n     /// Type parameters for const fn and associated constants.\n     substs: &'tcx Substs<'tcx>,\n@@ -200,10 +200,25 @@ struct MirConstContext<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     fn new(ccx: &'a CrateContext<'a, 'tcx>,\n-           mut instance: Instance<'tcx>,\n+           mir: &'a mir::Mir<'tcx>,\n+           substs: &'tcx Substs<'tcx>,\n            args: Vec<Const<'tcx>>)\n            -> MirConstContext<'a, 'tcx> {\n+        MirConstContext {\n+            ccx: ccx,\n+            mir: mir,\n+            substs: substs,\n+            args: args,\n+            vars: vec![None; mir.var_decls.len()],\n+            temps: vec![None; mir.temp_decls.len()],\n+            return_value: None\n+        }\n+    }\n \n+    fn trans_def(ccx: &'a CrateContext<'a, 'tcx>,\n+                 mut instance: Instance<'tcx>,\n+                 args: Vec<Const<'tcx>>)\n+                 -> Result<Const<'tcx>, ConstEvalFailure> {\n         // Try to resolve associated constants.\n         if instance.substs.self_ty().is_some() {\n             // Only trait items can have a Self parameter.\n@@ -226,15 +241,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n         let mir = ccx.get_mir(instance.def).unwrap_or_else(|| {\n             bug!(\"missing constant MIR for {}\", instance)\n         });\n-        MirConstContext {\n-            ccx: ccx,\n-            substs: instance.substs,\n-            args: args,\n-            vars: vec![None; mir.var_decls.len()],\n-            temps: vec![None; mir.temp_decls.len()],\n-            return_value: None,\n-            mir: mir\n-        }\n+        MirConstContext::new(ccx, &mir, instance.substs, args).trans()\n     }\n \n     fn monomorphize<T>(&self, value: &T) -> T\n@@ -247,10 +254,9 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n     fn trans(&mut self) -> Result<Const<'tcx>, ConstEvalFailure> {\n         let tcx = self.ccx.tcx();\n-        let mir = self.mir.clone();\n         let mut bb = mir::START_BLOCK;\n         loop {\n-            let data = mir.basic_block_data(bb);\n+            let data = self.mir.basic_block_data(bb);\n             for statement in &data.statements {\n                 match statement.kind {\n                     mir::StatementKind::Assign(ref dest, ref rvalue) => {\n@@ -284,7 +290,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 }\n \n                 mir::TerminatorKind::Call { ref func, ref args, ref destination, .. } => {\n-                    let fn_ty = mir.operand_ty(tcx, func);\n+                    let fn_ty = self.mir.operand_ty(tcx, func);\n                     let fn_ty = self.monomorphize(&fn_ty);\n                     let instance = match fn_ty.sty {\n                         ty::TyFnDef(def_id, substs, _) => {\n@@ -304,7 +310,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     let args = args.iter().map(|arg| {\n                         self.const_operand(arg, span)\n                     }).collect::<Result<Vec<_>, _>>()?;\n-                    let value = MirConstContext::new(self.ccx, instance, args).trans()?;\n+                    let value = MirConstContext::trans_def(self.ccx, instance, args)?;\n                     if let Some((ref dest, target)) = *destination {\n                         self.store(dest, value, span);\n                         target\n@@ -432,7 +438,11 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n                         let substs = self.ccx.tcx().mk_substs(self.monomorphize(substs));\n                         let instance = Instance::new(def_id, substs);\n-                        MirConstContext::new(self.ccx, instance, vec![]).trans()\n+                        MirConstContext::trans_def(self.ccx, instance, vec![])\n+                    }\n+                    mir::Literal::Promoted { index } => {\n+                        let mir = &self.mir.promoted[index];\n+                        MirConstContext::new(self.ccx, mir, self.substs, vec![]).trans()\n                     }\n                     mir::Literal::Value { value } => {\n                         Ok(Const::from_constval(self.ccx, value, ty))\n@@ -792,7 +802,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                           -> OperandRef<'tcx>\n     {\n         let ty = bcx.monomorphize(&constant.ty);\n-        let val = match constant.literal.clone() {\n+        let result = match constant.literal.clone() {\n             mir::Literal::Item { def_id, substs } => {\n                 // Shortcut for zero-sized types, including function item\n                 // types, which would not work with MirConstContext.\n@@ -806,22 +816,28 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                 let substs = bcx.tcx().mk_substs(bcx.monomorphize(substs));\n                 let instance = Instance::new(def_id, substs);\n-                match MirConstContext::new(bcx.ccx(), instance, vec![]).trans() {\n-                    Ok(v) => v,\n-                    Err(ConstEvalFailure::Compiletime(_)) => {\n-                        // We've errored, so we don't have to produce working code.\n-                        let llty = type_of::type_of(bcx.ccx(), ty);\n-                        Const::new(C_undef(llty), ty)\n-                    }\n-                    Err(ConstEvalFailure::Runtime(err)) => {\n-                        span_bug!(constant.span,\n-                                  \"MIR constant {:?} results in runtime panic: {}\",\n-                                  constant, err.description())\n-                    }\n-                }\n+                MirConstContext::trans_def(bcx.ccx(), instance, vec![])\n+            }\n+            mir::Literal::Promoted { index } => {\n+                let mir = &self.mir.promoted[index];\n+                MirConstContext::new(bcx.ccx(), mir, bcx.fcx().param_substs, vec![]).trans()\n             }\n             mir::Literal::Value { value } => {\n-                Const::from_constval(bcx.ccx(), value, ty)\n+                Ok(Const::from_constval(bcx.ccx(), value, ty))\n+            }\n+        };\n+\n+        let val = match result {\n+            Ok(v) => v,\n+            Err(ConstEvalFailure::Compiletime(_)) => {\n+                // We've errored, so we don't have to produce working code.\n+                let llty = type_of::type_of(bcx.ccx(), ty);\n+                Const::new(C_undef(llty), ty)\n+            }\n+            Err(ConstEvalFailure::Runtime(err)) => {\n+                span_bug!(constant.span,\n+                          \"MIR constant {:?} results in runtime panic: {}\",\n+                          constant, err.description())\n             }\n         };\n \n@@ -839,5 +855,5 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n pub fn trans_static_initializer(ccx: &CrateContext, def_id: DefId)\n                                 -> Result<ValueRef, ConstEvalFailure> {\n     let instance = Instance::mono(ccx.tcx(), def_id);\n-    MirConstContext::new(ccx, instance, vec![]).trans().map(|c| c.llval)\n+    MirConstContext::trans_def(ccx, instance, vec![]).map(|c| c.llval)\n }"}, {"sha": "600df1c778befad58f1caa03658cb56d98b32f94", "filename": "src/test/run-pass-fulldeps/auxiliary/dummy_mir_pass.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/14efbf148109888f939f671fbd5b60650c5f4744/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14efbf148109888f939f671fbd5b60650c5f4744/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs?ref=14efbf148109888f939f671fbd5b60650c5f4744", "patch": "@@ -18,21 +18,19 @@ extern crate rustc_plugin;\n extern crate rustc_const_math;\n extern crate syntax;\n \n-use rustc::mir::transform::{self, MirPass};\n+use rustc::mir::transform::{self, MirPass, MirSource};\n use rustc::mir::repr::{Mir, Literal};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty;\n use rustc::middle::const_val::ConstVal;\n use rustc_const_math::ConstInt;\n use rustc_plugin::Registry;\n \n-use syntax::ast::NodeId;\n-\n struct Pass;\n \n impl transform::Pass for Pass {}\n impl<'tcx> MirPass<'tcx> for Pass {\n-    fn run_pass(&mut self, _: &ty::TyCtxt<'tcx>, _: NodeId, mir: &mut Mir<'tcx>) {\n+    fn run_pass(&mut self, _: &ty::TyCtxt<'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n         Visitor.visit_mir(mir)\n     }\n }"}]}