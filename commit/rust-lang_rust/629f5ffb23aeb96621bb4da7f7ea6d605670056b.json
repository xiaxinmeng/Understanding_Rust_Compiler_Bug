{"sha": "629f5ffb23aeb96621bb4da7f7ea6d605670056b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyOWY1ZmZiMjNhZWI5NjYyMWJiNGRhN2Y3ZWE2ZDYwNTY3MDA1NmI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-11-10T14:47:00Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-11-16T18:57:47Z"}, "message": "include a Name and Span for each item in the HIR of the impl", "tree": {"sha": "cf4f6bedf5de66fb94fb13ffd4cdd995a96bb74e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf4f6bedf5de66fb94fb13ffd4cdd995a96bb74e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/629f5ffb23aeb96621bb4da7f7ea6d605670056b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/629f5ffb23aeb96621bb4da7f7ea6d605670056b", "html_url": "https://github.com/rust-lang/rust/commit/629f5ffb23aeb96621bb4da7f7ea6d605670056b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/629f5ffb23aeb96621bb4da7f7ea6d605670056b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26d1500e133d50727dfea10043d194a5b9f3761f", "url": "https://api.github.com/repos/rust-lang/rust/commits/26d1500e133d50727dfea10043d194a5b9f3761f", "html_url": "https://github.com/rust-lang/rust/commit/26d1500e133d50727dfea10043d194a5b9f3761f"}], "stats": {"total": 214, "additions": 131, "deletions": 83}, "files": [{"sha": "887b1febf65d93afa6f1f5087b50863b7fdc7e7c", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=629f5ffb23aeb96621bb4da7f7ea6d605670056b", "patch": "@@ -205,6 +205,9 @@ pub trait Visitor<'v> : Sized {\n     fn visit_impl_item(&mut self, ii: &'v ImplItem) {\n         walk_impl_item(self, ii)\n     }\n+    fn visit_impl_item_ref(&mut self, ii: &'v ImplItemRef) {\n+        walk_impl_item_ref(self, ii)\n+    }\n     fn visit_trait_ref(&mut self, t: &'v TraitRef) {\n         walk_trait_ref(self, t)\n     }\n@@ -399,13 +402,13 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_id(item.id);\n             visitor.visit_trait_ref(trait_ref)\n         }\n-        ItemImpl(.., ref type_parameters, ref opt_trait_reference, ref typ, ref impl_item_ids) => {\n+        ItemImpl(.., ref type_parameters, ref opt_trait_reference, ref typ, ref impl_item_refs) => {\n             visitor.visit_id(item.id);\n             visitor.visit_generics(type_parameters);\n             walk_list!(visitor, visit_trait_ref, opt_trait_reference);\n             visitor.visit_ty(typ);\n-            for &impl_item_id in impl_item_ids {\n-                visitor.visit_nested_impl_item(impl_item_id);\n+            for impl_item_ref in impl_item_refs {\n+                visitor.visit_impl_item_ref(impl_item_ref);\n             }\n         }\n         ItemStruct(ref struct_definition, ref generics) |\n@@ -763,6 +766,12 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n     }\n }\n \n+pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'v ImplItemRef) {\n+    visitor.visit_nested_impl_item(impl_item_ref.id);\n+    visitor.visit_name(impl_item_ref.span, impl_item_ref.name);\n+}\n+\n+\n pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V, struct_definition: &'v VariantData) {\n     visitor.visit_id(struct_definition.id());\n     walk_list!(visitor, visit_struct_field, struct_definition.fields());"}, {"sha": "d1b57586ffdb50c6a358746962cd1040bd3b28cb", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=629f5ffb23aeb96621bb4da7f7ea6d605670056b", "patch": "@@ -116,7 +116,7 @@ impl<'a> LoweringContext<'a> {\n             }\n \n             fn visit_impl_item(&mut self, item: &ImplItem) {\n-                let id = self.lctx.lower_impl_item_id(item);\n+                let id = self.lctx.lower_impl_item_ref(item).id;\n                 self.impl_items.insert(id, self.lctx.lower_impl_item(item));\n                 visit::walk_impl_item(self, item);\n             }\n@@ -641,7 +641,7 @@ impl<'a> LoweringContext<'a> {\n             }\n             ItemKind::Impl(unsafety, polarity, ref generics, ref ifce, ref ty, ref impl_items) => {\n                 let new_impl_items = impl_items.iter()\n-                                               .map(|item| self.lower_impl_item_id(item))\n+                                               .map(|item| self.lower_impl_item_ref(item))\n                                                .collect();\n                 let ifce = ifce.as_ref().map(|trait_ref| self.lower_trait_ref(trait_ref));\n                 hir::ItemImpl(self.lower_unsafety(unsafety),\n@@ -717,8 +717,24 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn lower_impl_item_id(&mut self, i: &ImplItem) -> hir::ImplItemId {\n-        hir::ImplItemId { id: i.id }\n+    fn lower_impl_item_ref(&mut self, i: &ImplItem) -> hir::ImplItemRef {\n+        hir::ImplItemRef {\n+            id: hir::ImplItemId { node_id: i.id },\n+            name: i.ident.name,\n+            span: i.span,\n+            vis: self.lower_visibility(&i.vis),\n+            defaultness: self.lower_defaultness(i.defaultness),\n+            kind: match i.node {\n+                ImplItemKind::Const(..) => hir::AssociatedItemKind::Const,\n+                ImplItemKind::Type(..) => hir::AssociatedItemKind::Type,\n+                ImplItemKind::Method(ref sig, _) => hir::AssociatedItemKind::Method {\n+                    has_self: sig.decl.get_self().is_some(),\n+                },\n+                ImplItemKind::Macro(..) => unimplemented!(),\n+            },\n+            // since `default impl` is not yet implemented, this is always true in impls\n+            has_value: true,\n+        }\n     }\n \n     fn lower_mod(&mut self, m: &Mod) -> hir::Mod {"}, {"sha": "51a378a08336e93c22a4a2d5e2a10bc4589818f8", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=629f5ffb23aeb96621bb4da7f7ea6d605670056b", "patch": "@@ -93,7 +93,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     /// deep walking so that we walk nested items in the context of\n     /// their outer items.\n \n-    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'v>> {\n+    fn nested_visit_map(&mut self) -> Option<&map::Map<'ast>> {\n         panic!(\"visit_nested_xxx must be manually implemented in this visitor\")\n     }\n "}, {"sha": "06cfc8aee8c9d382b69c04d3f2b7f197e540bce9", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=629f5ffb23aeb96621bb4da7f7ea6d605670056b", "patch": "@@ -384,7 +384,7 @@ impl<'ast> Map<'ast> {\n     }\n \n     pub fn impl_item(&self, id: ImplItemId) -> &'ast ImplItem {\n-        self.read(id.id);\n+        self.read(id.node_id);\n \n         // NB: intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here"}, {"sha": "9dac6fac1009fd5646696628fda467c48bc878fd", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=629f5ffb23aeb96621bb4da7f7ea6d605670056b", "patch": "@@ -1057,7 +1057,7 @@ pub enum TraitItem_ {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ImplItemId {\n-    pub id: NodeId,\n+    pub node_id: NodeId,\n }\n \n /// Represents anything within an `impl` block\n@@ -1546,7 +1546,7 @@ pub enum Item_ {\n              Generics,\n              Option<TraitRef>, // (optional) trait this impl implements\n              P<Ty>, // self\n-             HirVec<ImplItemId>),\n+             HirVec<ImplItemRef>),\n }\n \n impl Item_ {\n@@ -1570,6 +1570,30 @@ impl Item_ {\n     }\n }\n \n+/// A reference from an impl to one of its associated items. This\n+/// contains the item's id, naturally, but also the item's name and\n+/// some other high-level details (like whether it is an associated\n+/// type or method, and whether it is public). This allows other\n+/// passes to find the impl they want without loading the id (which\n+/// means fewer edges in the incremental compilation graph).\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct ImplItemRef {\n+    pub id: ImplItemId,\n+    pub name: Name,\n+    pub kind: AssociatedItemKind,\n+    pub span: Span,\n+    pub vis: Visibility,\n+    pub defaultness: Defaultness,\n+    pub has_value: bool,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum AssociatedItemKind {\n+    Const,\n+    Method { has_self: bool },\n+    Type,\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ForeignItem {\n     pub name: Name,"}, {"sha": "5a381a189fc129370314ffbafdad2d00f1a59585", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=629f5ffb23aeb96621bb4da7f7ea6d605670056b", "patch": "@@ -808,8 +808,8 @@ impl<'a> State<'a> {\n                 space(&mut self.s)?;\n                 self.bopen()?;\n                 self.print_inner_attributes(&item.attrs)?;\n-                for &impl_item in impl_items {\n-                    self.print_impl_item_id(impl_item)?;\n+                for impl_item in impl_items {\n+                    self.print_impl_item_ref(impl_item)?;\n                 }\n                 self.bclose(item.span)?;\n             }\n@@ -1020,10 +1020,10 @@ impl<'a> State<'a> {\n         self.ann.post(self, NodeSubItem(ti.id))\n     }\n \n-    pub fn print_impl_item_id(&mut self, item_id: hir::ImplItemId) -> io::Result<()> {\n+    pub fn print_impl_item_ref(&mut self, item_ref: &hir::ImplItemRef) -> io::Result<()> {\n         if let Some(krate) = self.krate {\n             // skip nested items if krate context was not provided\n-            let item = &krate.impl_item(item_id);\n+            let item = &krate.impl_item(item_ref.id);\n             self.print_impl_item(item)\n         } else {\n             Ok(())"}, {"sha": "991398813752f8a5991536259f804b0d1a8f0749", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=629f5ffb23aeb96621bb4da7f7ea6d605670056b", "patch": "@@ -359,12 +359,12 @@ impl<'v, 'k> ItemLikeVisitor<'v> for LifeSeeder<'k> {\n                     }\n                 }\n             }\n-            hir::ItemImpl(.., ref opt_trait, _, ref impl_item_ids) => {\n-                for &impl_item_id in impl_item_ids {\n-                    let impl_item = self.krate.impl_item(impl_item_id);\n+            hir::ItemImpl(.., ref opt_trait, _, ref impl_item_refs) => {\n+                for impl_item_ref in impl_item_refs {\n+                    let impl_item = self.krate.impl_item(impl_item_ref.id);\n                     if opt_trait.is_some() ||\n                             has_allow_dead_code_or_lang_attr(&impl_item.attrs) {\n-                        self.worklist.push(impl_item_id.id);\n+                        self.worklist.push(impl_item_ref.id.node_id);\n                     }\n                 }\n             }"}, {"sha": "ac614494355a26c37277ebc4f7e1a8aca87d1c4d", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=629f5ffb23aeb96621bb4da7f7ea6d605670056b", "patch": "@@ -328,10 +328,10 @@ struct CollectPrivateImplItemsVisitor<'a> {\n impl<'a, 'v> ItemLikeVisitor<'v> for CollectPrivateImplItemsVisitor<'a> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         // We need only trait impls here, not inherent impls, and only non-exported ones\n-        if let hir::ItemImpl(.., Some(_), _, ref impl_items) = item.node {\n+        if let hir::ItemImpl(.., Some(_), _, ref impl_item_refs) = item.node {\n             if !self.access_levels.is_reachable(item.id) {\n-                for impl_item in impl_items {\n-                    self.worklist.push(impl_item.id);\n+                for impl_item_ref in impl_item_refs {\n+                    self.worklist.push(impl_item_ref.id.node_id);\n                 }\n             }\n         }"}, {"sha": "7e4efc7ddca06382c7c25e482399dbd661f542fb", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=629f5ffb23aeb96621bb4da7f7ea6d605670056b", "patch": "@@ -525,10 +525,10 @@ pub fn check_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // For implementations of traits, check the stability of each item\n         // individually as it's possible to have a stable trait with unstable\n         // items.\n-        hir::ItemImpl(.., Some(ref t), _, ref impl_item_ids) => {\n+        hir::ItemImpl(.., Some(ref t), _, ref impl_item_refs) => {\n             let trait_did = tcx.expect_def(t.ref_id).def_id();\n-            for &impl_item_id in impl_item_ids {\n-                let impl_item = tcx.map.impl_item(impl_item_id);\n+            for impl_item_ref in impl_item_refs {\n+                let impl_item = tcx.map.impl_item(impl_item_ref.id);\n                 let item = tcx.associated_items(trait_did)\n                     .find(|item| item.name == impl_item.name).unwrap();\n                 if warn_about_defns {"}, {"sha": "4db788a92d64d70ed1148575bcaf30250905fdda", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=629f5ffb23aeb96621bb4da7f7ea6d605670056b", "patch": "@@ -2190,9 +2190,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         self.map.local_def_id(trait_item.id)\n                     }).collect())\n                 }\n-                hir::ItemImpl(.., ref impl_items) => {\n-                    Rc::new(impl_items.iter().map(|impl_item| {\n-                        self.map.local_def_id(impl_item.id)\n+                hir::ItemImpl(.., ref impl_item_refs) => {\n+                    Rc::new(impl_item_refs.iter().map(|impl_item_ref| {\n+                        self.map.local_def_id(impl_item_ref.id.node_id)\n                     }).collect())\n                 }\n                 _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\")"}, {"sha": "51ffb1ebc8e99ae1d687fa5c8cfe99e1b1198890", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=629f5ffb23aeb96621bb4da7f7ea6d605670056b", "patch": "@@ -387,16 +387,16 @@ impl LateLintPass for MissingDoc {\n                 \"a trait\"\n             }\n             hir::ItemTy(..) => \"a type alias\",\n-            hir::ItemImpl(.., Some(ref trait_ref), _, ref impl_items) => {\n+            hir::ItemImpl(.., Some(ref trait_ref), _, ref impl_item_refs) => {\n                 // If the trait is private, add the impl items to private_traits so they don't get\n                 // reported for missing docs.\n                 let real_trait = cx.tcx.expect_def(trait_ref.ref_id).def_id();\n                 if let Some(node_id) = cx.tcx.map.as_local_node_id(real_trait) {\n                     match cx.tcx.map.find(node_id) {\n                         Some(hir_map::NodeItem(item)) => {\n                             if item.vis == hir::Visibility::Inherited {\n-                                for itm in impl_items {\n-                                    self.private_traits.insert(itm.id);\n+                                for impl_item_ref in impl_item_refs {\n+                                    self.private_traits.insert(impl_item_ref.id.node_id);\n                                 }\n                             }\n                         }"}, {"sha": "4ff2beb3fdb77a519333e37ad13827572b347bb0", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=629f5ffb23aeb96621bb4da7f7ea6d605670056b", "patch": "@@ -277,12 +277,12 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                             .and_then(|impl_node_id| self.tcx.map.find(impl_node_id))\n                             .map(|node| {\n                                 if let hir_map::NodeItem(item) = node {\n-                                    if let hir::ItemImpl(_, _, _, _, _, ref impl_item_ids) = item.node {\n-                                        span = impl_item_ids.first()\n-                                                            .map(|&impl_item_id| {\n-                                                                self.tcx.map.impl_item(impl_item_id)\n-                                                                            .span\n-                                                            });\n+                                    if let hir::ItemImpl(.., ref impl_item_refs) = item.node {\n+                                        span = impl_item_refs.first()\n+                                                             .map(|iiref| {\n+                                                                 self.tcx.map.impl_item(iiref.id)\n+                                                                             .span\n+                                                             });\n                                     }\n                                 }\n                             });"}, {"sha": "b116408269e4dd10a3236b75ace6d4e961698295", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=629f5ffb23aeb96621bb4da7f7ea6d605670056b", "patch": "@@ -158,17 +158,17 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemImpl(.., None, _, ref impl_item_ids) => {\n-                for &impl_item_id in impl_item_ids {\n-                    let impl_item = self.tcx.map.impl_item(impl_item_id);\n+            hir::ItemImpl(.., None, _, ref impl_item_refs) => {\n+                for impl_item_ref in impl_item_refs {\n+                    let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                     if impl_item.vis == hir::Public {\n                         self.update(impl_item.id, item_level);\n                     }\n                 }\n             }\n-            hir::ItemImpl(.., Some(_), _, ref impl_item_ids) => {\n-                for &impl_item_id in impl_item_ids {\n-                    let impl_item = self.tcx.map.impl_item(impl_item_id);\n+            hir::ItemImpl(.., Some(_), _, ref impl_item_refs) => {\n+                for impl_item_ref in impl_item_refs {\n+                    let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                     self.update(impl_item.id, item_level);\n                 }\n             }\n@@ -251,12 +251,12 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             // The interface is empty\n             hir::ItemDefaultImpl(..) => {}\n             // Visit everything except for private impl items\n-            hir::ItemImpl(.., ref generics, None, _, ref impl_item_ids) => {\n+            hir::ItemImpl(.., ref generics, None, _, ref impl_item_refs) => {\n                 if item_level.is_some() {\n                     self.reach().visit_generics(generics);\n-                    for &impl_item_id in impl_item_ids {\n-                        if self.get(impl_item_id.id).is_some() {\n-                            let impl_item = self.tcx.map.impl_item(impl_item_id);\n+                    for impl_item_ref in impl_item_refs {\n+                        if self.get(impl_item_ref.id.node_id).is_some() {\n+                            let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                             self.reach().visit_impl_item(impl_item);\n                         }\n                     }\n@@ -656,7 +656,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             // (i.e. we could just return here to not check them at\n             // all, or some worse estimation of whether an impl is\n             // publicly visible).\n-            hir::ItemImpl(.., ref g, ref trait_ref, ref self_, ref impl_item_ids) => {\n+            hir::ItemImpl(.., ref g, ref trait_ref, ref self_, ref impl_item_refs) => {\n                 // `impl [... for] Private` is never visible.\n                 let self_contains_private;\n                 // impl [... for] Public<...>, but not `impl [... for]\n@@ -701,9 +701,9 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                 // are private (because `T` won't be visible externally).\n                 let trait_or_some_public_method =\n                     trait_ref.is_some() ||\n-                    impl_item_ids.iter()\n-                                 .any(|&impl_item_id| {\n-                                     let impl_item = self.tcx.map.impl_item(impl_item_id);\n+                    impl_item_refs.iter()\n+                                 .any(|impl_item_ref| {\n+                                     let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                                      match impl_item.node {\n                                          hir::ImplItemKind::Const(..) |\n                                          hir::ImplItemKind::Method(..) => {\n@@ -721,13 +721,13 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n \n                     match *trait_ref {\n                         None => {\n-                            for &impl_item_id in impl_item_ids {\n+                            for impl_item_ref in impl_item_refs {\n                                 // This is where we choose whether to walk down\n                                 // further into the impl to check its items. We\n                                 // should only walk into public items so that we\n                                 // don't erroneously report errors for private\n                                 // types in private items.\n-                                let impl_item = self.tcx.map.impl_item(impl_item_id);\n+                                let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                                 match impl_item.node {\n                                     hir::ImplItemKind::Const(..) |\n                                     hir::ImplItemKind::Method(..)\n@@ -759,8 +759,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                             intravisit::walk_path(self, &tr.path);\n \n                             // Those in 3. are warned with this call.\n-                            for &impl_item_id in impl_item_ids {\n-                                let impl_item = self.tcx.map.impl_item(impl_item_id);\n+                            for impl_item_ref in impl_item_refs {\n+                                let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                                 if let hir::ImplItemKind::Type(ref ty) = impl_item.node {\n                                     self.visit_ty(ty);\n                                 }\n@@ -771,8 +771,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                     // impl Public<Private> { ... }. Any public static\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n-                    for &impl_item_id in impl_item_ids {\n-                        let impl_item = self.tcx.map.impl_item(impl_item_id);\n+                    for impl_item_ref in impl_item_refs {\n+                        let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                         match impl_item.node {\n                             hir::ImplItemKind::Const(..) => {\n                                 if self.item_is_public(&impl_item.id, &impl_item.vis) {\n@@ -1099,13 +1099,13 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for PrivateItemsInPublicInterfacesVisitor\n             hir::ItemDefaultImpl(..) => {}\n             // An inherent impl is public when its type is public\n             // Subitems of inherent impls have their own publicity\n-            hir::ItemImpl(.., ref generics, None, ref ty, ref impl_item_ids) => {\n+            hir::ItemImpl(.., ref generics, None, ref ty, ref impl_item_refs) => {\n                 let ty_vis = self.ty_visibility(ty);\n                 check.required_visibility = ty_vis;\n                 check.visit_generics(generics);\n \n-                for &impl_item_id in impl_item_ids {\n-                    let impl_item = self.tcx.map.impl_item(impl_item_id);\n+                for impl_item_ref in impl_item_refs {\n+                    let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                     let impl_item_vis =\n                         ty::Visibility::from_hir(&impl_item.vis, item.id, self.tcx);\n                     check.required_visibility = min(impl_item_vis, ty_vis);\n@@ -1114,12 +1114,12 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for PrivateItemsInPublicInterfacesVisitor\n             }\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity\n-            hir::ItemImpl(.., ref generics, Some(ref trait_ref), ref ty, ref impl_item_ids) => {\n+            hir::ItemImpl(.., ref generics, Some(ref trait_ref), ref ty, ref impl_item_refs) => {\n                 let vis = min(self.ty_visibility(ty), self.trait_ref_visibility(trait_ref));\n                 check.required_visibility = vis;\n                 check.visit_generics(generics);\n-                for &impl_item_id in impl_item_ids {\n-                    let impl_item = self.tcx.map.impl_item(impl_item_id);\n+                for impl_item_ref in impl_item_refs {\n+                    let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                     check.visit_impl_item(impl_item);\n                 }\n             }"}, {"sha": "5902b0b1ce0755ec463354d90e634ef69fd4cc91", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=629f5ffb23aeb96621bb4da7f7ea6d605670056b", "patch": "@@ -1135,7 +1135,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n                       _,\n                       ref generics,\n                       ..,\n-                      ref items) => {\n+                      ref impl_item_refs) => {\n             if generics.is_type_parameterized() {\n                 return\n             }\n@@ -1148,10 +1148,9 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n             if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n                 let callee_substs = tcx.erase_regions(&trait_ref.substs);\n                 let overridden_methods: FxHashSet<_> =\n-                    items.iter()\n-                         .map(|&id| tcx.map.impl_item(id))\n-                         .map(|item| item.name)\n-                         .collect();\n+                    impl_item_refs.iter()\n+                                  .map(|iiref| iiref.name)\n+                                  .collect();\n                 for method in tcx.provided_trait_methods(trait_ref.def_id) {\n                     if overridden_methods.contains(&method.name) {\n                         continue;"}, {"sha": "7b33aa694a26e3386688ab9038a7a678f9a0c0f9", "filename": "src/librustc_typeck/check/impl_item_duplicate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc_typeck%2Fcheck%2Fimpl_item_duplicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc_typeck%2Fcheck%2Fimpl_item_duplicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fimpl_item_duplicate.rs?ref=629f5ffb23aeb96621bb4da7f7ea6d605670056b", "patch": "@@ -16,13 +16,13 @@ use CrateCtxt;\n \n /// Enforce that we do not have two items in an impl with the same name.\n pub fn enforce_impl_items_are_distinct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                                 impl_item_ids: &[hir::ImplItemId])\n+                                                 impl_item_refs: &[hir::ImplItemRef])\n {\n     let tcx = ccx.tcx;\n     let mut seen_type_items = FxHashMap();\n     let mut seen_value_items = FxHashMap();\n-    for &impl_item_id in impl_item_ids {\n-        let impl_item = tcx.map.impl_item(impl_item_id);\n+    for &impl_item_ref in impl_item_refs {\n+        let impl_item = tcx.map.impl_item(impl_item_ref.id);\n         let seen_items = match impl_item.node {\n             hir::ImplItemKind::Type(_) => &mut seen_type_items,\n             _                    => &mut seen_value_items,"}, {"sha": "650e959ba01fbc0b6178689233d94233a414ef41", "filename": "src/librustc_typeck/check/impl_parameters_used.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc_typeck%2Fcheck%2Fimpl_parameters_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc_typeck%2Fcheck%2Fimpl_parameters_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fimpl_parameters_used.rs?ref=629f5ffb23aeb96621bb4da7f7ea6d605670056b", "patch": "@@ -51,7 +51,7 @@ use CrateCtxt;\n pub fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                      impl_hir_generics: &hir::Generics,\n                                                      impl_def_id: DefId,\n-                                                     impl_item_ids: &[hir::ImplItemId])\n+                                                     impl_item_refs: &[hir::ImplItemRef])\n {\n     // Every lifetime used in an associated type must be constrained.\n     let impl_scheme = ccx.tcx.lookup_item_type(impl_def_id);\n@@ -71,8 +71,8 @@ pub fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n \n     // Disallow unconstrained lifetimes, but only if they appear in assoc types.\n-    let lifetimes_in_associated_types: FxHashSet<_> = impl_item_ids.iter()\n-        .map(|item_id|  ccx.tcx.map.local_def_id(item_id.id))\n+    let lifetimes_in_associated_types: FxHashSet<_> = impl_item_refs.iter()\n+        .map(|item_ref|  ccx.tcx.map.local_def_id(item_ref.id.node_id))\n         .filter(|&def_id| {\n             let item = ccx.tcx.associated_item(def_id);\n             item.kind == ty::AssociatedKind::Type && item.has_value"}, {"sha": "a8e38a362b561b6de49e305a33cb72c0b4b88682", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629f5ffb23aeb96621bb4da7f7ea6d605670056b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=629f5ffb23aeb96621bb4da7f7ea6d605670056b", "patch": "@@ -817,26 +817,26 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n                             it.id);\n       }\n       hir::ItemFn(..) => {} // entirely within check_item_body\n-      hir::ItemImpl(_, _, ref hir_generics, _, _, ref impl_item_ids) => {\n+      hir::ItemImpl(_, _, ref hir_generics, _, _, ref impl_item_refs) => {\n           debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n           let impl_def_id = ccx.tcx.map.local_def_id(it.id);\n           if let Some(impl_trait_ref) = ccx.tcx.impl_trait_ref(impl_def_id) {\n               check_impl_items_against_trait(ccx,\n                                              it.span,\n                                              impl_def_id,\n                                              impl_trait_ref,\n-                                             impl_item_ids);\n+                                             impl_item_refs);\n               let trait_def_id = impl_trait_ref.def_id;\n               check_on_unimplemented(ccx, trait_def_id, it);\n           }\n \n           impl_parameters_used::enforce_impl_params_are_constrained(ccx,\n                                                                     hir_generics,\n                                                                     impl_def_id,\n-                                                                    impl_item_ids);\n+                                                                    impl_item_refs);\n \n           impl_item_duplicate::enforce_impl_items_are_distinct(ccx,\n-                                                               impl_item_ids);\n+                                                               impl_item_refs);\n       }\n       hir::ItemTrait(..) => {\n         let def_id = ccx.tcx.map.local_def_id(it.id);\n@@ -895,11 +895,11 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n       hir::ItemFn(ref decl, .., ref body) => {\n         check_bare_fn(ccx, &decl, &body, it.id, it.span);\n       }\n-      hir::ItemImpl(.., ref impl_item_ids) => {\n+      hir::ItemImpl(.., ref impl_item_refs) => {\n         debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n \n-        for &impl_item_id in impl_item_ids {\n-            let impl_item = ccx.tcx.map.impl_item(impl_item_id);\n+        for impl_item_ref in impl_item_refs {\n+            let impl_item = ccx.tcx.map.impl_item(impl_item_ref.id);\n             match impl_item.node {\n                 hir::ImplItemKind::Const(_, ref expr) => {\n                     check_const(ccx, &expr, impl_item.id)\n@@ -1036,7 +1036,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             impl_span: Span,\n                                             impl_id: DefId,\n                                             impl_trait_ref: ty::TraitRef<'tcx>,\n-                                            impl_item_ids: &[hir::ImplItemId]) {\n+                                            impl_item_refs: &[hir::ImplItemRef]) {\n     // If the trait reference itself is erroneous (so the compilation is going\n     // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n     // isn't populated for such impls.\n@@ -1047,7 +1047,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let trait_def = tcx.lookup_trait_def(impl_trait_ref.def_id);\n     let mut overridden_associated_type = None;\n \n-    let impl_items = || impl_item_ids.iter().map(|&id| ccx.tcx.map.impl_item(id));\n+    let impl_items = || impl_item_refs.iter().map(|iiref| ccx.tcx.map.impl_item(iiref.id));\n \n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature"}]}