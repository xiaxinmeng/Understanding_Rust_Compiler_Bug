{"sha": "9891582897ae5f588022cec6a2f798d7a2883629", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4OTE1ODI4OTdhZTVmNTg4MDIyY2VjNmEyZjc5OGQ3YTI4ODM2Mjk=", "commit": {"author": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2021-04-20T20:39:41Z"}, "committer": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2021-04-20T20:43:04Z"}, "message": "Remove TraitRefHackInner and use the concatenating functionality instead of trait_ref_hack", "tree": {"sha": "a6f3c42e3a4c9ff8fa805f2eaeaee67a37df8977", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6f3c42e3a4c9ff8fa805f2eaeaee67a37df8977"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9891582897ae5f588022cec6a2f798d7a2883629", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9891582897ae5f588022cec6a2f798d7a2883629", "html_url": "https://github.com/rust-lang/rust/commit/9891582897ae5f588022cec6a2f798d7a2883629", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9891582897ae5f588022cec6a2f798d7a2883629/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "457c4c133a4bc83da668b5bceac75cd229ff112e", "url": "https://api.github.com/repos/rust-lang/rust/commits/457c4c133a4bc83da668b5bceac75cd229ff112e", "html_url": "https://github.com/rust-lang/rust/commit/457c4c133a4bc83da668b5bceac75cd229ff112e"}], "stats": {"total": 421, "additions": 176, "deletions": 245}, "files": [{"sha": "62cbbd8e8f7056987e3e957f3048d29b83d86909", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 176, "deletions": 245, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/9891582897ae5f588022cec6a2f798d7a2883629/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9891582897ae5f588022cec6a2f798d7a2883629/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=9891582897ae5f588022cec6a2f798d7a2883629", "patch": "@@ -165,29 +165,6 @@ crate struct LifetimeContext<'a, 'tcx> {\n     map: &'a mut NamedRegionMap,\n     scope: ScopeRef<'a>,\n \n-    /// This is slightly complicated. Our representation for poly-trait-refs contains a single\n-    /// binder and thus we only allow a single level of quantification. However,\n-    /// the syntax of Rust permits quantification in two places, e.g., `T: for <'a> Foo<'a>`\n-    /// and `for <'a, 'b> &'b T: Foo<'a>`. In order to get the De Bruijn indices\n-    /// correct when representing these constraints, we should only introduce one\n-    /// scope. However, we want to support both locations for the quantifier and\n-    /// during lifetime resolution we want precise information (so we can't\n-    /// desugar in an earlier phase). Moreso, an error here doesn't cause a bail\n-    /// from type checking, so we need to be extra careful that we don't lose\n-    /// any bound var information.\n-    ///\n-    /// So, if we encounter a quantifier at the outer scope, we set\n-    /// `trait_ref_hack` to the hir id of the bounded type (and introduce a scope).\n-    /// Then, if we encounter a quantifier at the inner scope, then we know to\n-    /// emit an error. Importantly though, we do have to track the lifetimes\n-    /// defined on the outer scope (i.e. the bounded ty), since we continue\n-    /// to type check after emitting an error; we therefore assume that the bound\n-    /// vars on the inner trait refs come from both quantifiers.\n-    ///\n-    /// If we encounter a quantifier in the inner scope `trait_ref_hack` being\n-    /// `None`, then we just introduce the scope at the inner quantifier as normal.\n-    trait_ref_hack: Option<hir::HirId>,\n-\n     /// Used to disallow the use of in-band lifetimes in `fn` or `Fn` syntax.\n     is_in_fn_syntax: bool,\n \n@@ -279,41 +256,6 @@ enum Scope<'a> {\n         s: ScopeRef<'a>,\n     },\n \n-    /// This is a particularly interesting consequence of how we handle poly\n-    /// trait refs. See `trait_ref_hack` for additional info. This bit is\n-    /// important w.r.t. querying late-bound vars.\n-    ///\n-    /// To completely understand why this is necessary, first it's important to\n-    /// realize that `T: for<'a> U + for<'a, 'b> V` is actually two separate\n-    /// trait refs: `T: for<'a> U` and `T: for<'b> V` and as such, the late\n-    /// bound vars on each needs to be tracked separately. Also, in this case,\n-    /// are *three* relevant `HirId`s: one for the entire bound and one\n-    /// for each separate one.\n-    ///\n-    /// Next, imagine three different poly trait refs:\n-    ///   1) `for<'a, 'b> T: U<'a, 'b>`\n-    ///   2) `T: for<'a, 'b> U<'a, 'b>`\n-    ///   3) `for<'a> T: for<'b> U<'a, 'b>`\n-    ///\n-    /// First, note that the third example is semantically invalid and an error,\n-    /// but we *must* handle it as valid, since type checking isn't bailed out\n-    /// of. Other than that, if ask for bound vars for each, we expect\n-    /// `['a, 'b]`. If we *didn't* allow binders before `T`, then we would\n-    /// always introduce a binder scope at the inner trait ref. This is great,\n-    /// because later on during type-checking, we will ask \"what are the late\n-    /// bound vars on this trait ref\". However, because we allow bound vars on\n-    /// the bound itself, we have to have some way of keeping track of the fact\n-    /// that we actually want to store the late bound vars as being associated\n-    /// with the trait ref; this is that.\n-    ///\n-    /// One alternative way to handle this would be to just introduce a new\n-    /// `Binder` scope, but that's semantically a bit different, since bound\n-    /// vars from both `for<...>`s *do* share the same binder level.\n-    TraitRefHackInner {\n-        hir_id: hir::HirId,\n-        s: ScopeRef<'a>,\n-    },\n-\n     /// When we have nested trait refs, we concanetate late bound vars for inner\n     /// trait refs from outer ones. But we also need to include any HRTB\n     /// lifetimes encountered when identifying the trait that an associated type\n@@ -332,9 +274,48 @@ enum Scope<'a> {\n \n #[derive(Copy, Clone, Debug)]\n enum BinderScopeType {\n-    Other,\n+    /// In a syntactic trait ref, this represents the outermost binder. So, if\n+    /// you had `T: for<'a>  Foo<Bar: for<'b> Baz<'a, 'b>>`, then the `for<'a>`\n+    /// scope uses `PolyTraitRef`.\n     PolyTraitRef,\n+    /// This is slightly complicated. Our representation for poly-trait-refs contains a single\n+    /// binder and thus we only allow a single level of quantification. However,\n+    /// the syntax of Rust permits quantification in two places in where clauses,\n+    /// e.g., `T: for <'a> Foo<'a>` and `for <'a, 'b> &'b T: Foo<'a>`. In order\n+    /// to get the De Bruijn indices correct when representing these constraints,\n+    /// we should only introduce one scope. However, we want to support both\n+    /// locations for the quantifier and during lifetime resolution we want\n+    /// precise information (so we can't desugar in an earlier phase). Moreso,\n+    /// an error here doesn't cause a bail from type checking, so we need to be\n+    /// extra careful that we don't lose any bound var information for *either*\n+    /// syntactic binder and that we track all lifetimes defined in both binders.\n+    ///\n+    /// This mechanism is similar to the concatenation done in nested poly trait\n+    /// refs, i.e. the inner syntactic binder extends upon the lifetimes on the\n+    /// outer syntactic binder. However, we require a separate variant here to\n+    /// distinguish `for<'a> T: for<'b> Foo<'a, 'b>` from\n+    /// `T: for<'a> Bar<Baz: for<'b> Foo<'a, 'b>>`. In this case, the innermost\n+    /// `: for<'b> Foo<'a, 'b>` both have a `for<'a>` scope above it. However,\n+    /// in the former case, we must emit an error because this is invalid syntax.\n+    /// Put another way: `PolyTraitRef` and `BoundedTy` behave identically except\n+    /// that `BoundedTy` is used to signal that an error should be emitted if\n+    /// another syntactic binder is found.\n+    BoundedTy,\n+    /// Within a syntactic trait ref, there may be multiple poly trait refs that\n+    /// are nested (under the `associcated_type_bounds` feature). The binders of\n+    /// the innner poly trait refs are extended from the outer poly trait refs\n+    /// and don't increase the late bound depth. If you had\n+    /// `T: for<'a>  Foo<Bar: for<'b> Baz<'a, 'b>>`, then the `for<'b>` scope\n+    /// would be `Concatenating`. This also used in trait refs in where clauses\n+    /// where we have two binders `for<> T: for<> Foo` (I've intentionally left\n+    /// out any lifetimes because they aren't needed to show the two scopes).\n+    /// See `BoundedTy` for a bit more details, but the inner `for<>` has a scope\n+    /// of `Concatenating`.\n     Concatenating,\n+    /// Any other binder scopes. These are \"normal\" in that they increase the binder\n+    /// depth, are fully syntactic, don't concatenate, and don't have special syntactical\n+    /// considerations.\n+    Other,\n }\n \n // A helper struct for debugging scopes without printing parent scopes\n@@ -372,11 +353,6 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .field(\"lifetime\", lifetime)\n                 .field(\"s\", &\"..\")\n                 .finish(),\n-            Scope::TraitRefHackInner { hir_id, s: _ } => f\n-                .debug_struct(\"TraitRefHackInner\")\n-                .field(\"hir_id\", hir_id)\n-                .field(\"s\", &\"..\")\n-                .finish(),\n             Scope::Supertrait { lifetimes, s: _ } => f\n                 .debug_struct(\"Supertrait\")\n                 .field(\"lifetimes\", lifetimes)\n@@ -499,7 +475,6 @@ fn do_resolve(\n         tcx,\n         map: &mut named_region_map,\n         scope: ROOT_SCOPE,\n-        trait_ref_hack: None,\n         is_in_fn_syntax: false,\n         is_in_const_generic: false,\n         trait_definition_only,\n@@ -1324,28 +1299,25 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 })\n                                 .unzip();\n                         this.map.late_bound_vars.insert(bounded_ty.hir_id, binders.clone());\n-                        if !lifetimes.is_empty() {\n-                            let next_early_index = this.next_early_index();\n-                            let scope = Scope::Binder {\n-                                hir_id: bounded_ty.hir_id,\n-                                lifetimes,\n-                                s: this.scope,\n-                                next_early_index,\n-                                track_lifetime_uses: true,\n-                                opaque_type_parent: false,\n-                                scope_type: BinderScopeType::PolyTraitRef,\n-                            };\n-                            this.with(scope, |old_scope, this| {\n-                                this.check_lifetime_params(old_scope, &bound_generic_params);\n-                                this.visit_ty(&bounded_ty);\n-                                this.trait_ref_hack = Some(bounded_ty.hir_id);\n-                                walk_list!(this, visit_param_bound, bounds);\n-                                this.trait_ref_hack = None;\n-                            })\n-                        } else {\n+                        let next_early_index = this.next_early_index();\n+                        // Even if there are no lifetimes defined here, we still wrap it in a binder\n+                        // scope. If there happens to be a nested poly trait ref (an error), that\n+                        // will be `Concatenating` anyways, so we don't have to worry about the depth\n+                        // being wrong.\n+                        let scope = Scope::Binder {\n+                            hir_id: bounded_ty.hir_id,\n+                            lifetimes,\n+                            s: this.scope,\n+                            next_early_index,\n+                            track_lifetime_uses: true,\n+                            opaque_type_parent: false,\n+                            scope_type: BinderScopeType::BoundedTy,\n+                        };\n+                        this.with(scope, |old_scope, this| {\n+                            this.check_lifetime_params(old_scope, &bound_generic_params);\n                             this.visit_ty(&bounded_ty);\n                             walk_list!(this, visit_param_bound, bounds);\n-                        }\n+                        })\n                     }\n                     &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n                         ref lifetime,\n@@ -1369,8 +1341,37 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_param_bound(&mut self, bound: &'tcx hir::GenericBound<'tcx>) {\n+        // FIXME(jackh726): This is pretty weird. `LangItemTrait` doesn't go\n+        // through the regular poly trait ref code, so we don't get another\n+        // chance to introduce a binder. For now, I'm keeping the existing logic\n+        // of \"if there isn't a `BoundedTy` scope above us, add one\", but I\n+        // imagine there's a better way to go about this.\n+        let mut scope = self.scope;\n+        let trait_ref_hack = loop {\n+            match scope {\n+                Scope::Body { .. } | Scope::Root => {\n+                    break false;\n+                }\n+\n+                Scope::Elision { s, .. }\n+                | Scope::ObjectLifetimeDefault { s, .. }\n+                | Scope::Supertrait { s, .. } => {\n+                    scope = s;\n+                }\n+\n+                Scope::TraitRefBoundary { .. } => {\n+                    break false;\n+                }\n+\n+                Scope::Binder { scope_type, lifetimes, .. } => {\n+                    let trait_ref_hack =\n+                        matches!(scope_type, BinderScopeType::BoundedTy) && !lifetimes.is_empty();\n+                    break trait_ref_hack;\n+                }\n+            }\n+        };\n         match bound {\n-            hir::GenericBound::LangItemTrait(_, _, hir_id, _) if self.trait_ref_hack.is_none() => {\n+            hir::GenericBound::LangItemTrait(_, _, hir_id, _) if !trait_ref_hack => {\n                 self.map.late_bound_vars.insert(*hir_id, vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: *hir_id,\n@@ -1398,15 +1399,56 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n         let should_pop_missing_lt = self.is_trait_ref_fn_scope(trait_ref);\n \n-        let trait_ref_hack = self.trait_ref_hack.take();\n         let next_early_index = self.next_early_index();\n-        // See note on `trait_ref_hack`. If `for<..>` has been defined in both\n-        // the outer and inner part of the trait ref, emit an error.\n+        let mut scope = self.scope;\n+        let mut supertrait_lifetimes = vec![];\n+        let (mut binders, trait_ref_hack, scope_type) = loop {\n+            match scope {\n+                Scope::Body { .. } | Scope::Root => {\n+                    break (vec![], false, BinderScopeType::PolyTraitRef);\n+                }\n+\n+                Scope::Elision { s, .. } | Scope::ObjectLifetimeDefault { s, .. } => {\n+                    scope = s;\n+                }\n+\n+                Scope::Supertrait { s, lifetimes } => {\n+                    supertrait_lifetimes = lifetimes.clone();\n+                    scope = s;\n+                }\n+\n+                Scope::TraitRefBoundary { .. } => {\n+                    // We should only see super trait lifetimes if there is a `Binder` above\n+                    assert!(supertrait_lifetimes.is_empty());\n+                    break (vec![], false, BinderScopeType::PolyTraitRef);\n+                }\n+\n+                Scope::Binder { hir_id, scope_type, lifetimes, .. } => {\n+                    if let BinderScopeType::Other = scope_type {\n+                        bug!(\n+                            \"Expected all syntacic poly trait refs to be surrounded by a `TraitRefBoundary`\"\n+                        )\n+                    }\n+\n+                    // Nested poly trait refs have the binders concatenated\n+                    let mut full_binders =\n+                        self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n+                    full_binders.extend(supertrait_lifetimes.into_iter());\n+                    let trait_ref_hack =\n+                        matches!(scope_type, BinderScopeType::BoundedTy) && !lifetimes.is_empty();\n+                    break (full_binders, trait_ref_hack, BinderScopeType::Concatenating);\n+                }\n+            }\n+        };\n+\n+        // See note on `BinderScopeType::BoundedTy`. If `for<..>`\n+        // has been defined in both the outer and inner part of the\n+        // trait ref, emit an error.\n         let has_lifetimes = trait_ref.bound_generic_params.iter().any(|param| match param.kind {\n             GenericParamKind::Lifetime { .. } => true,\n             _ => false,\n         });\n-        if trait_ref_hack.is_some() && has_lifetimes {\n+        if trait_ref_hack && has_lifetimes {\n             struct_span_err!(\n                 self.tcx.sess,\n                 trait_ref.span,\n@@ -1416,152 +1458,50 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             .emit();\n         }\n \n-        let (binders, lifetimes) = if let Some(hir_id) = trait_ref_hack {\n-            let mut binders = self.map.late_bound_vars.entry(hir_id).or_default().clone();\n-            let initial_bound_vars = binders.len() as u32;\n-            let mut lifetimes: FxHashMap<hir::ParamName, Region> = FxHashMap::default();\n-            let binders_iter = trait_ref\n-                .bound_generic_params\n-                .iter()\n-                .filter_map(|param| match param.kind {\n-                    GenericParamKind::Lifetime { .. } => Some(param),\n-                    _ => None,\n-                })\n-                .enumerate()\n-                .map(|(late_bound_idx, param)| {\n-                    let pair = Region::late(\n-                        initial_bound_vars + late_bound_idx as u32,\n-                        &self.tcx.hir(),\n-                        param,\n-                    );\n-                    let r = late_region_as_bound_region(self.tcx, &pair.1);\n-                    lifetimes.insert(pair.0, pair.1);\n-                    r\n-                });\n-            binders.extend(binders_iter);\n-\n-            (binders, lifetimes)\n-        } else {\n-            let mut supertrait_lifetimes = vec![];\n-            let mut scope = self.scope;\n-            let mut outer_binders = loop {\n-                match scope {\n-                    Scope::Body { .. } | Scope::Root => {\n-                        break vec![];\n-                    }\n-\n-                    Scope::Elision { s, .. } | Scope::ObjectLifetimeDefault { s, .. } => {\n-                        scope = s;\n-                    }\n-\n-                    Scope::TraitRefHackInner { hir_id, .. } => {\n-                        // Nested poly trait refs have the binders concatenated\n-                        // If we reach `TraitRefHackInner`, then there is only one more `Binder` above us,\n-                        // over all the bounds. We don't want this, since all the lifetimes we care about\n-                        // are here anyways.\n-                        let mut full_binders =\n-                            self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n-                        full_binders.extend(supertrait_lifetimes.into_iter());\n-                        break full_binders;\n-                    }\n-\n-                    Scope::Supertrait { s, lifetimes } => {\n-                        supertrait_lifetimes = lifetimes.clone();\n-                        scope = s;\n-                    }\n-\n-                    Scope::TraitRefBoundary { .. } => {\n-                        // We should only see super trait lifetimes if there is a `Binder` above\n-                        assert!(supertrait_lifetimes.is_empty());\n-                        break vec![];\n-                    }\n-\n-                    Scope::Binder { hir_id, .. } => {\n-                        // Nested poly trait refs have the binders concatenated\n-                        let mut full_binders =\n-                            self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n-                        full_binders.extend(supertrait_lifetimes.into_iter());\n-                        break full_binders;\n-                    }\n-                }\n-            };\n-            let (lifetimes, local_binders): (FxHashMap<hir::ParamName, Region>, Vec<_>) = trait_ref\n-                .bound_generic_params\n-                .iter()\n-                .filter_map(|param| match param.kind {\n-                    GenericParamKind::Lifetime { .. } => Some(param),\n-                    _ => None,\n-                })\n-                .enumerate()\n-                .map(|(late_bound_idx, param)| {\n-                    let pair = Region::late(\n-                        outer_binders.len() as u32 + late_bound_idx as u32,\n-                        &self.tcx.hir(),\n-                        param,\n-                    );\n-                    let r = late_region_as_bound_region(self.tcx, &pair.1);\n-                    (pair, r)\n-                })\n-                .unzip();\n-\n-            outer_binders.extend(local_binders.into_iter());\n-\n-            (outer_binders, lifetimes)\n-        };\n+        let initial_bound_vars = binders.len() as u32;\n+        let mut lifetimes: FxHashMap<hir::ParamName, Region> = FxHashMap::default();\n+        let binders_iter = trait_ref\n+            .bound_generic_params\n+            .iter()\n+            .filter_map(|param| match param.kind {\n+                GenericParamKind::Lifetime { .. } => Some(param),\n+                _ => None,\n+            })\n+            .enumerate()\n+            .map(|(late_bound_idx, param)| {\n+                let pair = Region::late(\n+                    initial_bound_vars + late_bound_idx as u32,\n+                    &self.tcx.hir(),\n+                    param,\n+                );\n+                let r = late_region_as_bound_region(self.tcx, &pair.1);\n+                lifetimes.insert(pair.0, pair.1);\n+                r\n+            });\n+        binders.extend(binders_iter);\n \n         debug!(?binders);\n         self.map.late_bound_vars.insert(trait_ref.trait_ref.hir_ref_id, binders);\n \n-        if trait_ref_hack.is_none() || has_lifetimes {\n-            let scope_type = {\n-                let mut scope = self.scope;\n-                loop {\n-                    match *scope {\n-                        Scope::Root | Scope::TraitRefBoundary { .. } => {\n-                            break BinderScopeType::PolyTraitRef;\n-                        }\n-\n-                        Scope::Binder { scope_type, .. } => {\n-                            if let BinderScopeType::Other = scope_type {\n-                                bug!(\n-                                    \"Expected all syntacic poly trait refs to be surrounded by a `TraitRefBoundary`\"\n-                                )\n-                            }\n-                            break BinderScopeType::Concatenating;\n-                        }\n+        // Always introduce a scope here, even if this is in a where clause and\n+        // we introduced the binders around the bounded Ty. In that case, we\n+        // just reuse the concatenation functionality also present in nested trait\n+        // refs. See `BinderScopeType::BoundedTy` for more details on that case.\n+        let scope = Scope::Binder {\n+            hir_id: trait_ref.trait_ref.hir_ref_id,\n+            lifetimes,\n+            s: self.scope,\n+            next_early_index,\n+            track_lifetime_uses: true,\n+            opaque_type_parent: false,\n+            scope_type,\n+        };\n+        self.with(scope, |old_scope, this| {\n+            this.check_lifetime_params(old_scope, &trait_ref.bound_generic_params);\n+            walk_list!(this, visit_generic_param, trait_ref.bound_generic_params);\n+            this.visit_trait_ref(&trait_ref.trait_ref);\n+        });\n \n-                        Scope::Elision { s, .. }\n-                        | Scope::ObjectLifetimeDefault { s, .. }\n-                        | Scope::TraitRefHackInner { s, .. }\n-                        | Scope::Supertrait { s, .. }\n-                        | Scope::Body { s, .. } => {\n-                            scope = s;\n-                        }\n-                    }\n-                }\n-            };\n-            let scope = Scope::Binder {\n-                hir_id: trait_ref.trait_ref.hir_ref_id,\n-                lifetimes,\n-                s: self.scope,\n-                next_early_index,\n-                track_lifetime_uses: true,\n-                opaque_type_parent: false,\n-                scope_type,\n-            };\n-            self.with(scope, |old_scope, this| {\n-                this.check_lifetime_params(old_scope, &trait_ref.bound_generic_params);\n-                walk_list!(this, visit_generic_param, trait_ref.bound_generic_params);\n-                this.visit_trait_ref(&trait_ref.trait_ref);\n-            });\n-        } else {\n-            let scope =\n-                Scope::TraitRefHackInner { hir_id: trait_ref.trait_ref.hir_ref_id, s: self.scope };\n-            self.with(scope, |_old_scope, this| {\n-                this.visit_trait_ref(&trait_ref.trait_ref);\n-            });\n-        }\n-        self.trait_ref_hack = trait_ref_hack;\n         if should_pop_missing_lt {\n             self.missing_named_lifetime_spots.pop();\n         }\n@@ -1712,7 +1652,6 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n                 Scope::Body { s, .. }\n                 | Scope::Elision { s, .. }\n                 | Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::TraitRefHackInner { s, .. }\n                 | Scope::Supertrait { s, .. }\n                 | Scope::TraitRefBoundary { s, .. } => {\n                     scope = s;\n@@ -1903,12 +1842,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let labels_in_fn = take(&mut self.labels_in_fn);\n         let xcrate_object_lifetime_defaults = take(&mut self.xcrate_object_lifetime_defaults);\n         let missing_named_lifetime_spots = take(&mut self.missing_named_lifetime_spots);\n-        let trait_ref_hack = take(&mut self.trait_ref_hack);\n         let mut this = LifetimeContext {\n             tcx: *tcx,\n             map,\n             scope: &wrap_scope,\n-            trait_ref_hack,\n             is_in_fn_syntax: self.is_in_fn_syntax,\n             is_in_const_generic: self.is_in_const_generic,\n             trait_definition_only: self.trait_definition_only,\n@@ -1928,7 +1865,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         self.labels_in_fn = this.labels_in_fn;\n         self.xcrate_object_lifetime_defaults = this.xcrate_object_lifetime_defaults;\n         self.missing_named_lifetime_spots = this.missing_named_lifetime_spots;\n-        self.trait_ref_hack = this.trait_ref_hack;\n     }\n \n     /// helper method to determine the span to remove when suggesting the\n@@ -2321,7 +2257,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 | Scope::Body { s, .. }\n                 | Scope::Elision { s, .. }\n                 | Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::TraitRefHackInner { s, .. }\n                 | Scope::Supertrait { s, .. }\n                 | Scope::TraitRefBoundary { s, .. } => scope = s,\n             }\n@@ -2384,6 +2319,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     }\n                     match scope_type {\n                         BinderScopeType::Other => late_depth += 1,\n+                        BinderScopeType::BoundedTy => late_depth += 1,\n                         BinderScopeType::PolyTraitRef => late_depth += 1,\n                         BinderScopeType::Concatenating => {}\n                     }\n@@ -2392,7 +2328,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 Scope::Elision { s, .. }\n                 | Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::TraitRefHackInner { s, .. }\n                 | Scope::Supertrait { s, .. }\n                 | Scope::TraitRefBoundary { s, .. } => {\n                     scope = s;\n@@ -2547,7 +2482,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         Scope::Binder { s, .. }\n                         | Scope::Elision { s, .. }\n                         | Scope::ObjectLifetimeDefault { s, .. }\n-                        | Scope::TraitRefHackInner { s, .. }\n                         | Scope::Supertrait { s, .. }\n                         | Scope::TraitRefBoundary { s, .. } => {\n                             scope = s;\n@@ -2746,7 +2680,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut scope = &*self.scope;\n         let hir_id = loop {\n             match scope {\n-                Scope::Binder { hir_id, .. } | Scope::TraitRefHackInner { hir_id, .. } => {\n+                Scope::Binder { hir_id, .. } => {\n                     break *hir_id;\n                 }\n                 Scope::Body { id, .. } => break id.hir_id,\n@@ -3117,6 +3051,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     }\n                     match scope_type {\n                         BinderScopeType::Other => late_depth += 1,\n+                        BinderScopeType::BoundedTy => late_depth += 1,\n                         BinderScopeType::PolyTraitRef => late_depth += 1,\n                         BinderScopeType::Concatenating => {}\n                     }\n@@ -3168,7 +3103,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n \n                 Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::TraitRefHackInner { s, .. }\n                 | Scope::Supertrait { s, .. }\n                 | Scope::TraitRefBoundary { s, .. } => {\n                     scope = s;\n@@ -3282,6 +3216,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Binder { s, scope_type, .. } => {\n                     match scope_type {\n                         BinderScopeType::Other => late_depth += 1,\n+                        BinderScopeType::BoundedTy => late_depth += 1,\n                         BinderScopeType::PolyTraitRef => late_depth += 1,\n                         BinderScopeType::Concatenating => {}\n                     }\n@@ -3294,9 +3229,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 Scope::ObjectLifetimeDefault { lifetime: Some(l), .. } => break l,\n \n-                Scope::TraitRefHackInner { s, .. }\n-                | Scope::Supertrait { s, .. }\n-                | Scope::TraitRefBoundary { s, .. } => {\n+                Scope::Supertrait { s, .. } | Scope::TraitRefBoundary { s, .. } => {\n                     scope = s;\n                 }\n             }\n@@ -3423,7 +3356,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Body { s, .. }\n                 | Scope::Elision { s, .. }\n                 | Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::TraitRefHackInner { s, .. }\n                 | Scope::Supertrait { s, .. }\n                 | Scope::TraitRefBoundary { s, .. } => {\n                     old_scope = s;\n@@ -3482,7 +3414,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 } => break false,\n \n                 Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::TraitRefHackInner { s, .. }\n                 | Scope::Supertrait { s, .. }\n                 | Scope::TraitRefBoundary { s, .. } => scope = s,\n             }"}]}