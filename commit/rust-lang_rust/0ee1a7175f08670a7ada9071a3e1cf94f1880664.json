{"sha": "0ee1a7175f08670a7ada9071a3e1cf94f1880664", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlZTFhNzE3NWYwODY3MGE3YWRhOTA3MWEzZTFjZjk0ZjE4ODA2NjQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-09T22:28:08Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-09T23:11:22Z"}, "message": "tutorial: Generics section cleanup", "tree": {"sha": "11fa5dbd65ce6ff4d197e4ea97751abb0d4bc6a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11fa5dbd65ce6ff4d197e4ea97751abb0d4bc6a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ee1a7175f08670a7ada9071a3e1cf94f1880664", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ee1a7175f08670a7ada9071a3e1cf94f1880664", "html_url": "https://github.com/rust-lang/rust/commit/0ee1a7175f08670a7ada9071a3e1cf94f1880664", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ee1a7175f08670a7ada9071a3e1cf94f1880664/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b6e90d2b579848aef8f688547a6f5d0b6d910ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b6e90d2b579848aef8f688547a6f5d0b6d910ff", "html_url": "https://github.com/rust-lang/rust/commit/9b6e90d2b579848aef8f688547a6f5d0b6d910ff"}], "stats": {"total": 68, "additions": 33, "deletions": 35}, "files": [{"sha": "972627ab5df2b6758bc899de9f6accda2a7ad2e5", "filename": "doc/tutorial.md", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0ee1a7175f08670a7ada9071a3e1cf94f1880664/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/0ee1a7175f08670a7ada9071a3e1cf94f1880664/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=0ee1a7175f08670a7ada9071a3e1cf94f1880664", "patch": "@@ -1964,35 +1964,29 @@ non-copyable types.\n \n ## Generic functions\n \n-Throughout this tutorial, we've been defining functions like `for_rev`\n+Throughout this tutorial, we've been defining functions like\n that act only on single data types. It is 2012, and we no longer\n expect to be defining such functions again and again for every type\n they apply to.  Thus, Rust allows functions and datatypes to have type\n parameters.\n \n ~~~~\n-fn for_rev<T>(vector: ~[T], action: fn(T)) {\n-    let mut i = vec::len(vector);\n-    while i > 0u {\n-        i -= 1u;\n-        action(vector[i]);\n-    }\n-}\n-\n-fn map<T, U>(vector: ~[T], function :fn(T) -> U) -> ~[U] {\n+fn map<T, U>(vector: ~[T], function: fn(T) -> U) -> ~[U] {\n     let mut accumulator = ~[];\n-    for vector.each |element| { vec::push(accumulator, function(element)); }\n+    for vector.each |element| {\n+        vec::push(accumulator, function(element));\n+    }\n     ret accumulator;\n }\n ~~~~\n \n-When defined in this way, these functions can be applied to any type\n-of vector, as long as the type of the closure's argument and the type of\n-the vector's content agree with each other.\n+When defined with type parameters, this function can be applied to any\n+type of vector, as long as the type of `function`'s argument and the\n+type of the vector's content agree with each other.\n \n-Inside a parameterized (generic) function, the names of the type\n-parameters (capitalized by convention) stand for opaque types. You\n-can't look inside them, but you can pass them around.\n+Inside a generic function, the names of the type parameters\n+(capitalized by convention) stand for opaque types. You can't look\n+inside them, but you can pass them around.\n \n ## Generic datatypes\n \n@@ -2076,18 +2070,22 @@ fn head<T: copy>(v: ~[T]) -> T { v[0] }\n \n When instantiating a generic function, you can only instantiate it\n with types that fit its kinds. So you could not apply `head` to a\n-resource type.\n-\n-Rust has three kinds: 'noncopyable', 'copyable', and 'sendable'. By\n-default, type parameters are considered to be noncopyable. You can\n-annotate them with the `copy` keyword to declare them copyable, and\n-with the `send` keyword to make them sendable.\n-\n-Sendable types are a subset of copyable types. They are types that do\n-not contain shared (reference counted) types, which are thus uniquely\n-owned by the function that owns them, and can be sent over channels to\n-other tasks. Most of the generic functions in the core `comm` module\n-take sendable types.\n+resource type. Rust has several kinds that can be used as type bounds:\n+\n+* `copy` - Copyable types. All types are copyable unless they\n+  are classes with destructors or otherwise contain\n+  classes with destructors.\n+* `send` - Sendable types. All types are sendable unless they\n+  contain shared boxes, closures, or other local-heap-allocated\n+  types.\n+* `const` - Constant types. These are types that do not contain\n+  mutable fields nor shared boxes.\n+\n+> ***Note:*** Rust type kinds are syntactically very similar to\n+> [interfaces](#interfaces) when used as type bounds, and can be\n+> conveniently thought of as built-in interfaces. In the future type\n+> kinds will actually be interfaces that the compiler has special\n+> knowledge about.\n \n ## Generic functions and argument-passing\n \n@@ -2102,12 +2100,12 @@ vec::map(~[1, 2, 3], plus1);\n \n You will get an error message about argument passing styles\n disagreeing. The reason is that generic types are always passed by\n-pointer, so `map` expects a function that takes its argument by\n-pointer. The `plus1` you defined, however, uses the default, efficient\n-way to pass integers, which is by value. To get around this issue, you\n-have to explicitly mark the arguments to a function that you want to\n-pass to a generic higher-order function as being passed by pointer,\n-using the `&&` sigil:\n+reference, so `map` expects a function that takes its argument by\n+reference. The `plus1` you defined, however, uses the default,\n+efficient way to pass integers, which is by value. To get around this\n+issue, you have to explicitly mark the arguments to a function that\n+you want to pass to a generic higher-order function as being passed by\n+pointer, using the `&&` sigil:\n \n ~~~~\n fn plus1(&&x: int) -> int { x + 1 }"}]}