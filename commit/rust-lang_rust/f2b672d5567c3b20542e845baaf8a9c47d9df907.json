{"sha": "f2b672d5567c3b20542e845baaf8a9c47d9df907", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyYjY3MmQ1NTY3YzNiMjA1NDJlODQ1YmFhZjhhOWM0N2Q5ZGY5MDc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-09-05T22:26:02Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-09-08T19:17:53Z"}, "message": "Refactor `TyStruct`/`TyEnum`/`TyUnion` into `TyAdt`", "tree": {"sha": "60e8ffd531ac9debe6281bf81442ebe0dc181e07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60e8ffd531ac9debe6281bf81442ebe0dc181e07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2b672d5567c3b20542e845baaf8a9c47d9df907", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2b672d5567c3b20542e845baaf8a9c47d9df907", "html_url": "https://github.com/rust-lang/rust/commit/f2b672d5567c3b20542e845baaf8a9c47d9df907", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2b672d5567c3b20542e845baaf8a9c47d9df907/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c615b215331d2715cc2eed31b98f41393242f39d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c615b215331d2715cc2eed31b98f41393242f39d", "html_url": "https://github.com/rust-lang/rust/commit/c615b215331d2715cc2eed31b98f41393242f39d"}], "stats": {"total": 2302, "additions": 1087, "deletions": 1215}, "files": [{"sha": "b8a3bdfcf25738ad44937886569cdf19796e04c2", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -488,10 +488,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // if they are both \"path types\", there's a chance of ambiguity\n                 // due to different versions of the same crate\n                 match (&exp_found.expected.sty, &exp_found.found.sty) {\n-                    (&ty::TyEnum(ref exp_adt, _), &ty::TyEnum(ref found_adt, _)) |\n-                    (&ty::TyStruct(ref exp_adt, _), &ty::TyStruct(ref found_adt, _)) |\n-                    (&ty::TyEnum(ref exp_adt, _), &ty::TyStruct(ref found_adt, _)) |\n-                    (&ty::TyStruct(ref exp_adt, _), &ty::TyEnum(ref found_adt, _)) => {\n+                    (&ty::TyAdt(exp_adt, _), &ty::TyAdt(found_adt, _)) => {\n                         report_path_match(err, exp_adt.did, found_adt.did);\n                     },\n                     _ => ()"}, {"sha": "eea12b7f19712867b2ddbf3d750737a9f8b459fb", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -156,7 +156,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::TyInt(..) |\n             ty::TyUint(..) |\n             ty::TyFloat(..) |\n-            ty::TyEnum(..) |\n+            ty::TyAdt(..) |\n             ty::TyBox(..) |\n             ty::TyStr |\n             ty::TyError |\n@@ -167,8 +167,6 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::TyFnDef(..) |\n             ty::TyFnPtr(_) |\n             ty::TyTrait(..) |\n-            ty::TyStruct(..) |\n-            ty::TyUnion(..) |\n             ty::TyClosure(..) |\n             ty::TyNever |\n             ty::TyTuple(..) |"}, {"sha": "9db6ac1dcefd00bb6ff70d314ca4014d53b4cbfb", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -86,20 +86,15 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn lookup_and_handle_definition(&mut self, id: ast::NodeId) {\n-        use ty::TypeVariants::{TyEnum, TyStruct, TyUnion};\n-\n         let def = self.tcx.expect_def(id);\n \n         // If `bar` is a trait item, make sure to mark Foo as alive in `Foo::bar`\n         match def {\n             Def::AssociatedTy(..) | Def::Method(_) | Def::AssociatedConst(_)\n             if self.tcx.trait_of_item(def.def_id()).is_some() => {\n                 if let Some(substs) = self.tcx.tables.borrow().item_substs.get(&id) {\n-                    match substs.substs.type_at(0).sty {\n-                        TyEnum(tyid, _) | TyStruct(tyid, _) | TyUnion(tyid, _) => {\n-                            self.check_def_id(tyid.did)\n-                        }\n-                        _ => {}\n+                    if let ty::TyAdt(tyid, _) = substs.substs.type_at(0).sty {\n+                        self.check_def_id(tyid.did);\n                     }\n                 }\n             }\n@@ -133,23 +128,27 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_access(&mut self, lhs: &hir::Expr, name: ast::Name) {\n         match self.tcx.expr_ty_adjusted(lhs).sty {\n-            ty::TyStruct(def, _) | ty::TyUnion(def, _) => {\n+            ty::TyAdt(def, _) => {\n                 self.insert_def_id(def.struct_variant().field_named(name).did);\n             }\n-            _ => span_bug!(lhs.span, \"named field access on non-struct/union\"),\n+            _ => span_bug!(lhs.span, \"named field access on non-ADT\"),\n         }\n     }\n \n     fn handle_tup_field_access(&mut self, lhs: &hir::Expr, idx: usize) {\n-        if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(lhs).sty {\n-            self.insert_def_id(def.struct_variant().fields[idx].did);\n+        match self.tcx.expr_ty_adjusted(lhs).sty {\n+            ty::TyAdt(def, _) => {\n+                self.insert_def_id(def.struct_variant().fields[idx].did);\n+            }\n+            ty::TyTuple(..) => {}\n+            _ => span_bug!(lhs.span, \"numeric field access on non-ADT\"),\n         }\n     }\n \n     fn handle_field_pattern_match(&mut self, lhs: &hir::Pat,\n                                   pats: &[codemap::Spanned<hir::FieldPat>]) {\n         let variant = match self.tcx.node_id_to_type(lhs.id).sty {\n-            ty::TyStruct(adt, _) | ty::TyUnion(adt, _) | ty::TyEnum(adt, _) => {\n+            ty::TyAdt(adt, _) => {\n                 adt.variant_of_def(self.tcx.expect_def(lhs.id))\n             }\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")"}, {"sha": "8b8d15b0b6ebf551abf4df444e651e83c327f07c", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -178,8 +178,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ExprField(ref base_expr, field) => {\n-                if let ty::TyUnion(..) = self.tcx.expr_ty_adjusted(base_expr).sty {\n-                    self.require_unsafe(field.span, \"access to union field\");\n+                if let ty::TyAdt(adt, ..) = self.tcx.expr_ty_adjusted(base_expr).sty {\n+                    if adt.is_union() {\n+                        self.require_unsafe(field.span, \"access to union field\");\n+                    }\n                 }\n             }\n             _ => {}\n@@ -190,9 +192,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n \n     fn visit_pat(&mut self, pat: &hir::Pat) {\n         if let PatKind::Struct(_, ref fields, _) = pat.node {\n-            if let ty::TyUnion(..) = self.tcx.pat_ty(pat).sty {\n-                for field in fields {\n-                    self.require_unsafe(field.span, \"matching on union field\");\n+            if let ty::TyAdt(adt, ..) = self.tcx.pat_ty(pat).sty {\n+                if adt.is_union() {\n+                    for field in fields {\n+                        self.require_unsafe(field.span, \"matching on union field\");\n+                    }\n                 }\n             }\n         }"}, {"sha": "9f05dde4e66f44221a84fc365d1c3592bdbc7708", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -671,28 +671,31 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n         // Select just those fields of the `with`\n         // expression that will actually be used\n-        if let ty::TyStruct(def, substs) = with_cmt.ty.sty {\n-            // Consume those fields of the with expression that are needed.\n-            for with_field in &def.struct_variant().fields {\n-                if !contains_field_named(with_field, fields) {\n-                    let cmt_field = self.mc.cat_field(\n-                        &*with_expr,\n-                        with_cmt.clone(),\n-                        with_field.name,\n-                        with_field.ty(self.tcx(), substs)\n-                    );\n-                    self.delegate_consume(with_expr.id, with_expr.span, cmt_field);\n+        match with_cmt.ty.sty {\n+            ty::TyAdt(adt, substs) if adt.is_struct() => {\n+                // Consume those fields of the with expression that are needed.\n+                for with_field in &adt.struct_variant().fields {\n+                    if !contains_field_named(with_field, fields) {\n+                        let cmt_field = self.mc.cat_field(\n+                            &*with_expr,\n+                            with_cmt.clone(),\n+                            with_field.name,\n+                            with_field.ty(self.tcx(), substs)\n+                        );\n+                        self.delegate_consume(with_expr.id, with_expr.span, cmt_field);\n+                    }\n                 }\n             }\n-        } else {\n-            // the base expression should always evaluate to a\n-            // struct; however, when EUV is run during typeck, it\n-            // may not. This will generate an error earlier in typeck,\n-            // so we can just ignore it.\n-            if !self.tcx().sess.has_errors() {\n-                span_bug!(\n-                    with_expr.span,\n-                    \"with expression doesn't evaluate to a struct\");\n+            _ => {\n+                // the base expression should always evaluate to a\n+                // struct; however, when EUV is run during typeck, it\n+                // may not. This will generate an error earlier in typeck,\n+                // so we can just ignore it.\n+                if !self.tcx().sess.has_errors() {\n+                    span_bug!(\n+                        with_expr.span,\n+                        \"with expression doesn't evaluate to a struct\");\n+                }\n             }\n         }\n "}, {"sha": "39d5487e8beb159151e694081cca963c77fc239e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -223,8 +223,7 @@ fn deref_kind(t: Ty, context: DerefKindContext) -> McResult<deref_kind> {\n             Ok(deref_ptr(UnsafePtr(mt.mutbl)))\n         }\n \n-        ty::TyEnum(..) |\n-        ty::TyStruct(..) => { // newtype\n+        ty::TyAdt(..) => { // newtype\n             Ok(deref_interior(InteriorField(PositionalField(0))))\n         }\n \n@@ -1154,7 +1153,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 }\n                 Def::Struct(..) => {\n                     match self.pat_ty(&pat)?.sty {\n-                        ty::TyStruct(adt_def, _) => {\n+                        ty::TyAdt(adt_def, _) => {\n                             adt_def.struct_variant().fields.len()\n                         }\n                         ref ty => {"}, {"sha": "9a56959de38bc9a6bc5dccd8fa9dd8227dae798e", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -20,7 +20,7 @@ use lint;\n use middle::cstore::LOCAL_CRATE;\n use hir::def::Def;\n use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n-use ty::{self, TyCtxt};\n+use ty::{self, TyCtxt, AdtKind};\n use middle::privacy::AccessLevels;\n use syntax::parse::token::InternedString;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -561,49 +561,48 @@ pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n         hir::ExprField(ref base_e, ref field) => {\n             span = field.span;\n             match tcx.expr_ty_adjusted(base_e).sty {\n-                ty::TyStruct(def, _) | ty::TyUnion(def, _) => {\n+                ty::TyAdt(def, _) => {\n                     def.struct_variant().field_named(field.node).did\n                 }\n                 _ => span_bug!(e.span,\n-                               \"stability::check_expr: named field access on non-struct/union\")\n+                               \"stability::check_expr: named field access on non-ADT\")\n             }\n         }\n         hir::ExprTupField(ref base_e, ref field) => {\n             span = field.span;\n             match tcx.expr_ty_adjusted(base_e).sty {\n-                ty::TyStruct(def, _) => def.struct_variant().fields[field.node].did,\n+                ty::TyAdt(def, _) => {\n+                    def.struct_variant().fields[field.node].did\n+                }\n                 ty::TyTuple(..) => return,\n                 _ => span_bug!(e.span,\n                                \"stability::check_expr: unnamed field access on \\\n                                 something other than a tuple or struct\")\n             }\n         }\n         hir::ExprStruct(_, ref expr_fields, _) => {\n-            let type_ = tcx.expr_ty(e);\n-            match type_.sty {\n-                ty::TyStruct(def, _) | ty::TyUnion(def, _) => {\n-                    // check the stability of each field that appears\n-                    // in the construction expression.\n-                    for field in expr_fields {\n-                        let did = def.struct_variant()\n-                            .field_named(field.name.node)\n-                            .did;\n-                        maybe_do_stability_check(tcx, did, field.span, cb);\n-                    }\n+            match tcx.expr_ty(e).sty {\n+                ty::TyAdt(adt, ..) => match adt.adt_kind() {\n+                    AdtKind::Struct | AdtKind::Union => {\n+                        // check the stability of each field that appears\n+                        // in the construction expression.\n+                        for field in expr_fields {\n+                            let did = adt.struct_variant().field_named(field.name.node).did;\n+                            maybe_do_stability_check(tcx, did, field.span, cb);\n+                        }\n \n-                    // we're done.\n-                    return\n-                }\n-                // we don't look at stability attributes on\n-                // struct-like enums (yet...), but it's definitely not\n-                // a bug to have construct one.\n-                ty::TyEnum(..) => return,\n-                _ => {\n-                    span_bug!(e.span,\n-                              \"stability::check_expr: struct construction \\\n-                               of non-struct/union, type {:?}\",\n-                              type_);\n-                }\n+                        // we're done.\n+                        return\n+                    }\n+                    AdtKind::Enum => {\n+                        // we don't look at stability attributes on\n+                        // struct-like enums (yet...), but it's definitely not\n+                        // a bug to have construct one.\n+                        return\n+                    }\n+                },\n+                ref ty => span_bug!(e.span, \"stability::check_expr: struct \\\n+                                         construction of non-ADT type: {:?}\", ty)\n             }\n         }\n         _ => return\n@@ -648,10 +647,9 @@ pub fn check_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &hir::Pat,\n     debug!(\"check_pat(pat = {:?})\", pat);\n     if is_internal(tcx, pat.span) { return; }\n \n-    let v = match tcx.pat_ty_opt(pat) {\n-        Some(&ty::TyS { sty: ty::TyStruct(def, _), .. }) |\n-        Some(&ty::TyS { sty: ty::TyUnion(def, _), .. }) => def.struct_variant(),\n-        Some(_) | None => return,\n+    let v = match tcx.pat_ty_opt(pat).map(|ty| &ty.sty) {\n+        Some(&ty::TyAdt(adt, _)) if !adt.is_enum() => adt.struct_variant(),\n+        _ => return,\n     };\n     match pat.node {\n         // Foo(a, b, c)"}, {"sha": "74ad6c602f6cdf47f3bd59bb96d07d29dab6a579", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -40,7 +40,7 @@ impl<'a, 'gcx, 'tcx> LvalueTy<'tcx> {\n             LvalueTy::Ty { ty } =>\n                 ty,\n             LvalueTy::Downcast { adt_def, substs, variant_index: _ } =>\n-                tcx.mk_enum(adt_def, substs),\n+                tcx.mk_adt(adt_def, substs),\n         }\n     }\n \n@@ -75,15 +75,16 @@ impl<'a, 'gcx, 'tcx> LvalueTy<'tcx> {\n             }\n             ProjectionElem::Downcast(adt_def1, index) =>\n                 match self.to_ty(tcx).sty {\n-                    ty::TyEnum(adt_def, substs) => {\n+                    ty::TyAdt(adt_def, substs) => {\n+                        assert!(adt_def.is_enum());\n                         assert!(index < adt_def.variants.len());\n                         assert_eq!(adt_def, adt_def1);\n                         LvalueTy::Downcast { adt_def: adt_def,\n                                              substs: substs,\n                                              variant_index: index }\n                     }\n                     _ => {\n-                        bug!(\"cannot downcast non-enum type: `{:?}`\", self)\n+                        bug!(\"cannot downcast non-ADT type: `{:?}`\", self)\n                     }\n                 },\n             ProjectionElem::Field(_, fty) => LvalueTy::Ty { ty: fty }"}, {"sha": "83774f0cf7ead24659c8829483cf0e98fb1a0852", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -224,7 +224,7 @@ fn fundamental_ty(tcx: TyCtxt, ty: Ty) -> bool {\n     match ty.sty {\n         ty::TyBox(..) | ty::TyRef(..) =>\n             true,\n-        ty::TyEnum(def, _) | ty::TyStruct(def, _) | ty::TyUnion(def, _) =>\n+        ty::TyAdt(def, _) =>\n             def.is_fundamental(),\n         ty::TyTrait(ref data) =>\n             tcx.has_attr(data.principal.def_id(), \"fundamental\"),\n@@ -260,9 +260,7 @@ fn ty_is_local_constructor(tcx: TyCtxt, ty: Ty, infer_is_local: InferIsLocal)->\n             infer_is_local.0\n         }\n \n-        ty::TyEnum(def, _) |\n-        ty::TyStruct(def, _) |\n-        ty::TyUnion(def, _) => {\n+        ty::TyAdt(def, _) => {\n             def.did.is_local()\n         }\n "}, {"sha": "52ddd8ab5dac01f7dad1a7efd1ff6cab1191ed6e", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -27,7 +27,7 @@ use super::{\n use fmt_macros::{Parser, Piece, Position};\n use hir::def_id::DefId;\n use infer::{self, InferCtxt, TypeOrigin};\n-use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use ty::error::ExpectedFound;\n use ty::fast_reject;\n use ty::fold::TypeFolder;\n@@ -151,32 +151,30 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 ty::TyBool => Some(0),\n                 ty::TyChar => Some(1),\n                 ty::TyStr => Some(2),\n-                ty::TyInt(..) | ty::TyUint(..) |\n-                ty::TyInfer(ty::IntVar(..)) => Some(3),\n+                ty::TyInt(..) | ty::TyUint(..) | ty::TyInfer(ty::IntVar(..)) => Some(3),\n                 ty::TyFloat(..) | ty::TyInfer(ty::FloatVar(..)) => Some(4),\n-                ty::TyEnum(..) => Some(5),\n-                ty::TyStruct(..) => Some(6),\n-                ty::TyBox(..) | ty::TyRef(..) | ty::TyRawPtr(..) => Some(7),\n-                ty::TyArray(..) | ty::TySlice(..) => Some(8),\n-                ty::TyFnDef(..) | ty::TyFnPtr(..) => Some(9),\n-                ty::TyTrait(..) => Some(10),\n-                ty::TyClosure(..) => Some(11),\n-                ty::TyTuple(..) => Some(12),\n-                ty::TyProjection(..) => Some(13),\n-                ty::TyParam(..) => Some(14),\n-                ty::TyAnon(..) => Some(15),\n-                ty::TyNever => Some(16),\n-                ty::TyUnion(..) => Some(17),\n+                ty::TyBox(..) | ty::TyRef(..) | ty::TyRawPtr(..) => Some(5),\n+                ty::TyArray(..) | ty::TySlice(..) => Some(6),\n+                ty::TyFnDef(..) | ty::TyFnPtr(..) => Some(7),\n+                ty::TyTrait(..) => Some(8),\n+                ty::TyClosure(..) => Some(9),\n+                ty::TyTuple(..) => Some(10),\n+                ty::TyProjection(..) => Some(11),\n+                ty::TyParam(..) => Some(12),\n+                ty::TyAnon(..) => Some(13),\n+                ty::TyNever => Some(14),\n+                ty::TyAdt(adt, ..) => match adt.adt_kind() {\n+                    AdtKind::Struct => Some(15),\n+                    AdtKind::Union => Some(16),\n+                    AdtKind::Enum => Some(17),\n+                },\n                 ty::TyInfer(..) | ty::TyError => None\n             }\n         }\n \n         match (type_category(a), type_category(b)) {\n             (Some(cat_a), Some(cat_b)) => match (&a.sty, &b.sty) {\n-                (&ty::TyStruct(def_a, _), &ty::TyStruct(def_b, _)) |\n-                (&ty::TyUnion(def_a, _), &ty::TyUnion(def_b, _)) |\n-                (&ty::TyEnum(def_a, _), &ty::TyEnum(def_b, _)) =>\n-                    def_a == def_b,\n+                (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => def_a == def_b,\n                 _ => cat_a == cat_b\n             },\n             // infer and error can be equated to all types"}, {"sha": "94dba7d12a8c762abd4016416b4600d3911f7cfd", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -1638,7 +1638,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             (&ty::TyArray(..), &ty::TySlice(_)) => true,\n \n             // Struct<T> -> Struct<U>.\n-            (&ty::TyStruct(def_id_a, _), &ty::TyStruct(def_id_b, _)) => {\n+            (&ty::TyAdt(def_id_a, _), &ty::TyAdt(def_id_b, _)) if def_id_a.is_struct() => {\n                 def_id_a == def_id_b\n             }\n \n@@ -1780,8 +1780,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Where(ty::Binder(tys.last().into_iter().cloned().collect()))\n             }\n \n-            ty::TyStruct(def, substs) | ty::TyUnion(def, substs) |\n-            ty::TyEnum(def, substs) => {\n+            ty::TyAdt(def, substs) => {\n                 let sized_crit = def.sized_constraint(self.tcx());\n                 // (*) binder moved here\n                 Where(ty::Binder(match sized_crit.sty {\n@@ -1837,8 +1836,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Where(ty::Binder(tys.to_vec()))\n             }\n \n-            ty::TyStruct(..) | ty::TyUnion(..) | ty::TyEnum(..) |\n-            ty::TyProjection(..) | ty::TyParam(..) | ty::TyAnon(..) => {\n+            ty::TyAdt(..) | ty::TyProjection(..) | ty::TyParam(..) | ty::TyAnon(..) => {\n                 // Fallback to whatever user-defined impls exist in this case.\n                 None\n             }\n@@ -1930,11 +1928,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             // for `PhantomData<T>`, we pass `T`\n-            ty::TyStruct(def, substs) if def.is_phantom_data() => {\n+            ty::TyAdt(def, substs) if def.is_phantom_data() => {\n                 substs.types().collect()\n             }\n \n-            ty::TyStruct(def, substs) | ty::TyUnion(def, substs) | ty::TyEnum(def, substs) => {\n+            ty::TyAdt(def, substs) => {\n                 def.all_fields()\n                     .map(|f| f.ty(self.tcx(), substs))\n                     .collect()\n@@ -2566,7 +2564,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             // Struct<T> -> Struct<U>.\n-            (&ty::TyStruct(def, substs_a), &ty::TyStruct(_, substs_b)) => {\n+            (&ty::TyAdt(def, substs_a), &ty::TyAdt(_, substs_b)) => {\n                 let fields = def\n                     .all_fields()\n                     .map(|f| f.unsubst_ty())\n@@ -2621,7 +2619,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         k\n                     }\n                 });\n-                let new_struct = tcx.mk_struct(def, Substs::new(tcx, params));\n+                let new_struct = tcx.mk_adt(def, Substs::new(tcx, params));\n                 let origin = TypeOrigin::Misc(obligation.cause.span);\n                 let InferOk { obligations, .. } =\n                     self.infcx.sub_types(false, origin, new_struct, target)"}, {"sha": "0badb85e9e0956bcdd1ee9561c4d7221f82ba135", "filename": "src/librustc/ty/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcast.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -65,7 +65,7 @@ impl<'tcx> CastTy<'tcx> {\n             ty::TyInt(_) => Some(CastTy::Int(IntTy::I)),\n             ty::TyUint(u) => Some(CastTy::Int(IntTy::U(u))),\n             ty::TyFloat(_) => Some(CastTy::Float),\n-            ty::TyEnum(d,_) if d.is_payloadfree() =>\n+            ty::TyAdt(d,_) if d.is_enum() && d.is_payloadfree() =>\n                 Some(CastTy::Int(IntTy::CEnum)),\n             ty::TyRawPtr(ref mt) => Some(CastTy::Ptr(mt)),\n             ty::TyRef(_, ref mt) => Some(CastTy::RPtr(mt)),"}, {"sha": "b499e1346e73c12afbffa50ac82be68cbce50b85", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -224,8 +224,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                                         |ty| tc_ty(tcx, *ty, cache))\n                 }\n \n-                ty::TyStruct(def, substs) | ty::TyUnion(def, substs) |\n-                ty::TyEnum(def, substs) => {\n+                ty::TyAdt(def, substs) => {\n                     let mut res =\n                         TypeContents::union(&def.variants, |v| {\n                             TypeContents::union(&v.fields, |f| {"}, {"sha": "20601493d68f3e16bf5ee5936fc6e754b2c02fa5", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -27,7 +27,7 @@ use ty::subst::Substs;\n use traits;\n use ty::{self, TraitRef, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants};\n-use ty::{AdtDef, ClosureSubsts, Region};\n+use ty::{AdtKind, AdtDef, ClosureSubsts, Region};\n use hir::FreevarMap;\n use ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, TraitObject};\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n@@ -620,7 +620,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn intern_adt_def(self,\n                           did: DefId,\n-                          kind: ty::AdtKind,\n+                          kind: AdtKind,\n                           variants: Vec<ty::VariantDefData<'gcx, 'gcx>>)\n                           -> ty::AdtDefMaster<'gcx> {\n         let def = ty::AdtDefData::new(self, did, kind, variants);\n@@ -1032,8 +1032,8 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     pub fn print_debug_stats(self) {\n         sty_debug_print!(\n             self,\n-            TyEnum, TyBox, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr, TyTrait,\n-            TyStruct, TyUnion, TyClosure, TyTuple, TyParam, TyInfer, TyProjection, TyAnon);\n+            TyAdt, TyBox, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr,\n+            TyTrait, TyClosure, TyTuple, TyParam, TyInfer, TyProjection, TyAnon);\n \n         println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());\n         println!(\"BareFnTy interner: #{}\", self.interners.bare_fn.borrow().len());\n@@ -1227,9 +1227,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_imm_ref(self.mk_region(ty::ReStatic), self.mk_str())\n     }\n \n-    pub fn mk_enum(self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_adt(self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         // take a copy of substs so that we own the vectors inside\n-        self.mk_ty(TyEnum(def, substs))\n+        self.mk_ty(TyAdt(def, substs))\n     }\n \n     pub fn mk_box(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n@@ -1316,16 +1316,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(TyProjection(inner))\n     }\n \n-    pub fn mk_struct(self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n-        // take a copy of substs so that we own the vectors inside\n-        self.mk_ty(TyStruct(def, substs))\n-    }\n-\n-    pub fn mk_union(self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n-        // take a copy of substs so that we own the vectors inside\n-        self.mk_ty(TyUnion(def, substs))\n-    }\n-\n     pub fn mk_closure(self,\n                       closure_id: DefId,\n                       substs: &'tcx Substs<'tcx>,"}, {"sha": "d820fddea3907d38a754d29cff3a620eaeeea6e1", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -216,7 +216,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::TyUint(_) | ty::TyFloat(_) | ty::TyStr | ty::TyNever => self.to_string(),\n             ty::TyTuple(ref tys) if tys.is_empty() => self.to_string(),\n \n-            ty::TyEnum(def, _) => format!(\"enum `{}`\", tcx.item_path_str(def.did)),\n+            ty::TyAdt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.item_path_str(def.did)),\n             ty::TyBox(_) => \"box\".to_string(),\n             ty::TyArray(_, n) => format!(\"array of {} elements\", n),\n             ty::TySlice(_) => \"slice\".to_string(),\n@@ -244,12 +244,6 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::TyTrait(ref inner) => {\n                 format!(\"trait {}\", tcx.item_path_str(inner.principal.def_id()))\n             }\n-            ty::TyStruct(def, _) => {\n-                format!(\"struct `{}`\", tcx.item_path_str(def.did))\n-            }\n-            ty::TyUnion(def, _) => {\n-                format!(\"union `{}`\", tcx.item_path_str(def.did))\n-            }\n             ty::TyClosure(..) => \"closure\".to_string(),\n             ty::TyTuple(_) => \"tuple\".to_string(),\n             ty::TyInfer(ty::TyVar(_)) => \"inferred type\".to_string(),"}, {"sha": "ee1544d2d996d3df5905d29c6838ec2b4439e6e5", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -22,15 +22,13 @@ pub enum SimplifiedType {\n     IntSimplifiedType(ast::IntTy),\n     UintSimplifiedType(ast::UintTy),\n     FloatSimplifiedType(ast::FloatTy),\n-    EnumSimplifiedType(DefId),\n+    AdtSimplifiedType(DefId),\n     StrSimplifiedType,\n     VecSimplifiedType,\n     PtrSimplifiedType,\n     NeverSimplifiedType,\n     TupleSimplifiedType(usize),\n     TraitSimplifiedType(DefId),\n-    StructSimplifiedType(DefId),\n-    UnionSimplifiedType(DefId),\n     ClosureSimplifiedType(DefId),\n     AnonSimplifiedType(DefId),\n     FunctionSimplifiedType(usize),\n@@ -57,19 +55,13 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::TyInt(int_type) => Some(IntSimplifiedType(int_type)),\n         ty::TyUint(uint_type) => Some(UintSimplifiedType(uint_type)),\n         ty::TyFloat(float_type) => Some(FloatSimplifiedType(float_type)),\n-        ty::TyEnum(def, _) => Some(EnumSimplifiedType(def.did)),\n+        ty::TyAdt(def, _) => Some(AdtSimplifiedType(def.did)),\n         ty::TyStr => Some(StrSimplifiedType),\n         ty::TyArray(..) | ty::TySlice(_) => Some(VecSimplifiedType),\n         ty::TyRawPtr(_) => Some(PtrSimplifiedType),\n         ty::TyTrait(ref trait_info) => {\n             Some(TraitSimplifiedType(trait_info.principal.def_id()))\n         }\n-        ty::TyStruct(def, _) => {\n-            Some(StructSimplifiedType(def.did))\n-        }\n-        ty::TyUnion(def, _) => {\n-            Some(UnionSimplifiedType(def.did))\n-        }\n         ty::TyRef(_, mt) => {\n             // since we introduce auto-refs during method lookup, we\n             // just treat &T and T as equivalent from the point of\n@@ -79,7 +71,7 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::TyBox(_) => {\n             // treat like we would treat `Box`\n             match tcx.lang_items.require_owned_box() {\n-                Ok(def_id) => Some(StructSimplifiedType(def_id)),\n+                Ok(def_id) => Some(AdtSimplifiedType(def_id)),\n                 Err(msg) => tcx.sess.fatal(&msg),\n             }\n         }"}, {"sha": "cddd59fa83c1b80ec76aa68fe88f614657d2b3f2", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -102,7 +102,7 @@ impl FlagComputation {\n                 }\n             }\n \n-            &ty::TyEnum(_, substs) | &ty::TyStruct(_, substs) | &ty::TyUnion(_, substs) => {\n+            &ty::TyAdt(_, substs) => {\n                 self.add_substs(substs);\n             }\n "}, {"sha": "b6b55fc0e33ddc32e9f97b7b217eac66ca92de52", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -262,9 +262,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // impl on `Foo`, but fallback to `<Foo>::bar` if self-type is\n         // anything other than a simple path.\n         match self_ty.sty {\n-            ty::TyStruct(adt_def, substs) |\n-            ty::TyUnion(adt_def, substs) |\n-            ty::TyEnum(adt_def, substs) => {\n+            ty::TyAdt(adt_def, substs) => {\n                 if substs.types().next().is_none() { // ignore regions\n                     self.push_item_path(buffer, adt_def.did);\n                 } else {\n@@ -320,9 +318,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n /// decisions and we may want to adjust it later.\n pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n     match ty.sty {\n-        ty::TyStruct(adt_def, _) |\n-        ty::TyUnion(adt_def, _) |\n-        ty::TyEnum(adt_def, _) => Some(adt_def.did),\n+        ty::TyAdt(adt_def, _) => Some(adt_def.did),\n \n         ty::TyTrait(ref data) => Some(data.principal.def_id()),\n "}, {"sha": "3c0aa041d2dd3a62b3c3b297186e439176e8eee5", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 214, "deletions": 212, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -15,7 +15,7 @@ pub use self::Primitive::*;\n use infer::InferCtxt;\n use session::Session;\n use traits;\n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable};\n \n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::attr;\n@@ -555,7 +555,7 @@ impl<'a, 'gcx, 'tcx> Struct {\n             }\n \n             // Is this the NonZero lang item wrapping a pointer or integer type?\n-            (&Univariant { non_zero: true, .. }, &ty::TyStruct(def, substs)) => {\n+            (&Univariant { non_zero: true, .. }, &ty::TyAdt(def, substs)) if def.is_struct() => {\n                 let fields = &def.struct_variant().fields;\n                 assert_eq!(fields.len(), 1);\n                 match *fields[0].ty(tcx, substs).layout(infcx)? {\n@@ -573,7 +573,7 @@ impl<'a, 'gcx, 'tcx> Struct {\n \n             // Perhaps one of the fields of this struct is non-zero\n             // let's recurse and find out\n-            (_, &ty::TyStruct(def, substs)) => {\n+            (_, &ty::TyAdt(def, substs)) if def.is_struct() => {\n                 Struct::non_zero_field_path(infcx, def.struct_variant().fields\n                                                       .iter().map(|field| {\n                     field.ty(tcx, substs)\n@@ -694,7 +694,7 @@ pub enum Layout {\n         non_zero: bool\n     },\n \n-    /// SIMD vectors, from TyStruct marked with #[repr(simd)].\n+    /// SIMD vectors, from structs marked with #[repr(simd)].\n     Vector {\n         element: Primitive,\n         count: u64\n@@ -715,7 +715,7 @@ pub enum Layout {\n         non_zero: bool\n     },\n \n-    // Remaining variants are all ADTs such as TyStruct, TyEnum or TyTuple.\n+    // Remaining variants are all ADTs such as structs, enums or tuples.\n \n     /// C-like enums; basically an integer.\n     CEnum {\n@@ -919,240 +919,242 @@ impl<'a, 'gcx, 'tcx> Layout {\n             }\n \n             // ADTs.\n-            ty::TyStruct(def, substs) => {\n-                if ty.is_simd() {\n-                    // SIMD vector types.\n-                    let element = ty.simd_type(tcx);\n-                    match *element.layout(infcx)? {\n-                        Scalar { value, .. } => {\n-                            return success(Vector {\n-                                element: value,\n-                                count: ty.simd_size(tcx) as u64\n-                            });\n-                        }\n-                        _ => {\n-                            tcx.sess.fatal(&format!(\"monomorphising SIMD type `{}` with \\\n-                                                     a non-machine element type `{}`\",\n-                                                    ty, element));\n+            ty::TyAdt(def, substs) => match def.adt_kind() {\n+                AdtKind::Struct => {\n+                    if ty.is_simd() {\n+                        // SIMD vector types.\n+                        let element = ty.simd_type(tcx);\n+                        match *element.layout(infcx)? {\n+                            Scalar { value, .. } => {\n+                                return success(Vector {\n+                                    element: value,\n+                                    count: ty.simd_size(tcx) as u64\n+                                });\n+                            }\n+                            _ => {\n+                                tcx.sess.fatal(&format!(\"monomorphising SIMD type `{}` with \\\n+                                                        a non-machine element type `{}`\",\n+                                                        ty, element));\n+                            }\n                         }\n                     }\n-                }\n-                let fields = def.struct_variant().fields.iter().map(|field| {\n-                    field.ty(tcx, substs).layout(infcx)\n-                });\n-                let packed = tcx.lookup_packed(def.did);\n-                let mut st = Struct::new(dl, packed);\n-                st.extend(dl, fields, ty)?;\n-\n-                Univariant {\n-                    variant: st,\n-                    non_zero: Some(def.did) == tcx.lang_items.non_zero()\n-                }\n-            }\n-            ty::TyUnion(def, substs) => {\n-                let fields = def.struct_variant().fields.iter().map(|field| {\n-                    field.ty(tcx, substs).layout(infcx)\n-                });\n-                let packed = tcx.lookup_packed(def.did);\n-                let mut un = Union::new(dl, packed);\n-                un.extend(dl, fields, ty)?;\n-                UntaggedUnion { variants: un }\n-            }\n-            ty::TyEnum(def, substs) => {\n-                let hint = *tcx.lookup_repr_hints(def.did).get(0)\n-                    .unwrap_or(&attr::ReprAny);\n-\n-                if def.variants.is_empty() {\n-                    // Uninhabitable; represent as unit\n-                    // (Typechecking will reject discriminant-sizing attrs.)\n-                    assert_eq!(hint, attr::ReprAny);\n-\n-                    return success(Univariant {\n-                        variant: Struct::new(dl, false),\n-                        non_zero: false\n-                    });\n-                }\n-\n-                if def.variants.iter().all(|v| v.fields.is_empty()) {\n-                    // All bodies empty -> intlike\n-                    let (mut min, mut max) = (i64::MAX, i64::MIN);\n-                    for v in &def.variants {\n-                        let x = v.disr_val.to_u64_unchecked() as i64;\n-                        if x < min { min = x; }\n-                        if x > max { max = x; }\n-                    }\n-\n-                    let (discr, signed) = Integer::repr_discr(tcx, hint, min, max);\n-                    return success(CEnum {\n-                        discr: discr,\n-                        signed: signed,\n-                        min: min as u64,\n-                        max: max as u64\n+                    let fields = def.struct_variant().fields.iter().map(|field| {\n+                        field.ty(tcx, substs).layout(infcx)\n                     });\n-                }\n+                    let packed = tcx.lookup_packed(def.did);\n+                    let mut st = Struct::new(dl, packed);\n+                    st.extend(dl, fields, ty)?;\n \n-                // Since there's at least one\n-                // non-empty body, explicit discriminants should have\n-                // been rejected by a checker before this point.\n-                for (i, v) in def.variants.iter().enumerate() {\n-                    if i as u64 != v.disr_val.to_u64_unchecked() {\n-                        bug!(\"non-C-like enum {} with specified discriminants\",\n-                             tcx.item_path_str(def.did));\n+                    Univariant {\n+                        variant: st,\n+                        non_zero: Some(def.did) == tcx.lang_items.non_zero()\n                     }\n                 }\n-\n-                if def.variants.len() == 1 {\n-                    // Equivalent to a struct/tuple/newtype.\n-                    // (Typechecking will reject discriminant-sizing attrs.)\n-                    assert_eq!(hint, attr::ReprAny);\n-                    let fields = def.variants[0].fields.iter().map(|field| {\n+                AdtKind::Union => {\n+                    let fields = def.struct_variant().fields.iter().map(|field| {\n                         field.ty(tcx, substs).layout(infcx)\n                     });\n-                    let mut st = Struct::new(dl, false);\n-                    st.extend(dl, fields, ty)?;\n-                    return success(Univariant { variant: st, non_zero: false });\n+                    let packed = tcx.lookup_packed(def.did);\n+                    let mut un = Union::new(dl, packed);\n+                    un.extend(dl, fields, ty)?;\n+                    UntaggedUnion { variants: un }\n                 }\n+                AdtKind::Enum => {\n+                    let hint = *tcx.lookup_repr_hints(def.did).get(0)\n+                        .unwrap_or(&attr::ReprAny);\n+\n+                    if def.variants.is_empty() {\n+                        // Uninhabitable; represent as unit\n+                        // (Typechecking will reject discriminant-sizing attrs.)\n+                        assert_eq!(hint, attr::ReprAny);\n+\n+                        return success(Univariant {\n+                            variant: Struct::new(dl, false),\n+                            non_zero: false\n+                        });\n+                    }\n \n-                // Cache the substituted and normalized variant field types.\n-                let variants = def.variants.iter().map(|v| {\n-                    v.fields.iter().map(|field| field.ty(tcx, substs)).collect::<Vec<_>>()\n-                }).collect::<Vec<_>>();\n+                    if def.variants.iter().all(|v| v.fields.is_empty()) {\n+                        // All bodies empty -> intlike\n+                        let (mut min, mut max) = (i64::MAX, i64::MIN);\n+                        for v in &def.variants {\n+                            let x = v.disr_val.to_u64_unchecked() as i64;\n+                            if x < min { min = x; }\n+                            if x > max { max = x; }\n+                        }\n \n-                if variants.len() == 2 && hint == attr::ReprAny {\n-                    // Nullable pointer optimization\n-                    for discr in 0..2 {\n-                        let other_fields = variants[1 - discr].iter().map(|ty| {\n-                            ty.layout(infcx)\n+                        let (discr, signed) = Integer::repr_discr(tcx, hint, min, max);\n+                        return success(CEnum {\n+                            discr: discr,\n+                            signed: signed,\n+                            min: min as u64,\n+                            max: max as u64\n                         });\n-                        if !Struct::would_be_zero_sized(dl, other_fields)? {\n-                            continue;\n+                    }\n+\n+                    // Since there's at least one\n+                    // non-empty body, explicit discriminants should have\n+                    // been rejected by a checker before this point.\n+                    for (i, v) in def.variants.iter().enumerate() {\n+                        if i as u64 != v.disr_val.to_u64_unchecked() {\n+                            bug!(\"non-C-like enum {} with specified discriminants\",\n+                                tcx.item_path_str(def.did));\n                         }\n-                        let path = Struct::non_zero_field_path(infcx,\n-                            variants[discr].iter().cloned())?;\n-                        let mut path = if let Some(p) = path { p } else { continue };\n-\n-                        // FIXME(eddyb) should take advantage of a newtype.\n-                        if path == &[0] && variants[discr].len() == 1 {\n-                            match *variants[discr][0].layout(infcx)? {\n-                                Scalar { value, .. } => {\n-                                    return success(RawNullablePointer {\n-                                        nndiscr: discr as u64,\n-                                        value: value\n-                                    });\n-                                }\n-                                _ => {\n-                                    bug!(\"Layout::compute: `{}`'s non-zero \\\n-                                          `{}` field not scalar?!\",\n-                                         ty, variants[discr][0])\n+                    }\n+\n+                    if def.variants.len() == 1 {\n+                        // Equivalent to a struct/tuple/newtype.\n+                        // (Typechecking will reject discriminant-sizing attrs.)\n+                        assert_eq!(hint, attr::ReprAny);\n+                        let fields = def.variants[0].fields.iter().map(|field| {\n+                            field.ty(tcx, substs).layout(infcx)\n+                        });\n+                        let mut st = Struct::new(dl, false);\n+                        st.extend(dl, fields, ty)?;\n+                        return success(Univariant { variant: st, non_zero: false });\n+                    }\n+\n+                    // Cache the substituted and normalized variant field types.\n+                    let variants = def.variants.iter().map(|v| {\n+                        v.fields.iter().map(|field| field.ty(tcx, substs)).collect::<Vec<_>>()\n+                    }).collect::<Vec<_>>();\n+\n+                    if variants.len() == 2 && hint == attr::ReprAny {\n+                        // Nullable pointer optimization\n+                        for discr in 0..2 {\n+                            let other_fields = variants[1 - discr].iter().map(|ty| {\n+                                ty.layout(infcx)\n+                            });\n+                            if !Struct::would_be_zero_sized(dl, other_fields)? {\n+                                continue;\n+                            }\n+                            let path = Struct::non_zero_field_path(infcx,\n+                                variants[discr].iter().cloned())?;\n+                            let mut path = if let Some(p) = path { p } else { continue };\n+\n+                            // FIXME(eddyb) should take advantage of a newtype.\n+                            if path == &[0] && variants[discr].len() == 1 {\n+                                match *variants[discr][0].layout(infcx)? {\n+                                    Scalar { value, .. } => {\n+                                        return success(RawNullablePointer {\n+                                            nndiscr: discr as u64,\n+                                            value: value\n+                                        });\n+                                    }\n+                                    _ => {\n+                                        bug!(\"Layout::compute: `{}`'s non-zero \\\n+                                            `{}` field not scalar?!\",\n+                                            ty, variants[discr][0])\n+                                    }\n                                 }\n                             }\n+\n+                            path.push(0); // For GEP through a pointer.\n+                            path.reverse();\n+                            let mut st = Struct::new(dl, false);\n+                            st.extend(dl, variants[discr].iter().map(|ty| ty.layout(infcx)), ty)?;\n+                            return success(StructWrappedNullablePointer {\n+                                nndiscr: discr as u64,\n+                                nonnull: st,\n+                                discrfield: path\n+                            });\n                         }\n+                    }\n \n-                        path.push(0); // For GEP through a pointer.\n-                        path.reverse();\n-                        let mut st = Struct::new(dl, false);\n-                        st.extend(dl, variants[discr].iter().map(|ty| ty.layout(infcx)), ty)?;\n-                        return success(StructWrappedNullablePointer {\n-                            nndiscr: discr as u64,\n-                            nonnull: st,\n-                            discrfield: path\n+                    // The general case.\n+                    let discr_max = (variants.len() - 1) as i64;\n+                    assert!(discr_max >= 0);\n+                    let (min_ity, _) = Integer::repr_discr(tcx, hint, 0, discr_max);\n+\n+                    let mut align = dl.aggregate_align;\n+                    let mut size = Size::from_bytes(0);\n+\n+                    // We're interested in the smallest alignment, so start large.\n+                    let mut start_align = Align::from_bytes(256, 256).unwrap();\n+\n+                    // Create the set of structs that represent each variant\n+                    // Use the minimum integer type we figured out above\n+                    let discr = Some(Scalar { value: Int(min_ity), non_zero: false });\n+                    let mut variants = variants.into_iter().map(|fields| {\n+                        let mut found_start = false;\n+                        let fields = fields.into_iter().map(|field| {\n+                            let field = field.layout(infcx)?;\n+                            if !found_start {\n+                                // Find the first field we can't move later\n+                                // to make room for a larger discriminant.\n+                                let field_align = field.align(dl);\n+                                if field.size(dl).bytes() != 0 || field_align.abi() != 1 {\n+                                    start_align = start_align.min(field_align);\n+                                    found_start = true;\n+                                }\n+                            }\n+                            Ok(field)\n                         });\n+                        let mut st = Struct::new(dl, false);\n+                        st.extend(dl, discr.iter().map(Ok).chain(fields), ty)?;\n+                        size = cmp::max(size, st.min_size());\n+                        align = align.max(st.align);\n+                        Ok(st)\n+                    }).collect::<Result<Vec<_>, _>>()?;\n+\n+                    // Align the maximum variant size to the largest alignment.\n+                    size = size.abi_align(align);\n+\n+                    if size.bytes() >= dl.obj_size_bound() {\n+                        return Err(LayoutError::SizeOverflow(ty));\n                     }\n-                }\n \n-                // The general case.\n-                let discr_max = (variants.len() - 1) as i64;\n-                assert!(discr_max >= 0);\n-                let (min_ity, _) = Integer::repr_discr(tcx, hint, 0, discr_max);\n-\n-                let mut align = dl.aggregate_align;\n-                let mut size = Size::from_bytes(0);\n-\n-                // We're interested in the smallest alignment, so start large.\n-                let mut start_align = Align::from_bytes(256, 256).unwrap();\n-\n-                // Create the set of structs that represent each variant\n-                // Use the minimum integer type we figured out above\n-                let discr = Some(Scalar { value: Int(min_ity), non_zero: false });\n-                let mut variants = variants.into_iter().map(|fields| {\n-                    let mut found_start = false;\n-                    let fields = fields.into_iter().map(|field| {\n-                        let field = field.layout(infcx)?;\n-                        if !found_start {\n-                            // Find the first field we can't move later\n-                            // to make room for a larger discriminant.\n-                            let field_align = field.align(dl);\n-                            if field.size(dl).bytes() != 0 || field_align.abi() != 1 {\n-                                start_align = start_align.min(field_align);\n-                                found_start = true;\n-                            }\n+                    // Check to see if we should use a different type for the\n+                    // discriminant. We can safely use a type with the same size\n+                    // as the alignment of the first field of each variant.\n+                    // We increase the size of the discriminant to avoid LLVM copying\n+                    // padding when it doesn't need to. This normally causes unaligned\n+                    // load/stores and excessive memcpy/memset operations. By using a\n+                    // bigger integer size, LLVM can be sure about it's contents and\n+                    // won't be so conservative.\n+\n+                    // Use the initial field alignment\n+                    let wanted = start_align.abi();\n+                    let mut ity = min_ity;\n+                    for &candidate in &[I16, I32, I64] {\n+                        let ty = Int(candidate);\n+                        if wanted == ty.align(dl).abi() && wanted == ty.size(dl).bytes() {\n+                            ity = candidate;\n+                            break;\n                         }\n-                        Ok(field)\n-                    });\n-                    let mut st = Struct::new(dl, false);\n-                    st.extend(dl, discr.iter().map(Ok).chain(fields), ty)?;\n-                    size = cmp::max(size, st.min_size());\n-                    align = align.max(st.align);\n-                    Ok(st)\n-                }).collect::<Result<Vec<_>, _>>()?;\n-\n-                // Align the maximum variant size to the largest alignment.\n-                size = size.abi_align(align);\n-\n-                if size.bytes() >= dl.obj_size_bound() {\n-                    return Err(LayoutError::SizeOverflow(ty));\n-                }\n-\n-                // Check to see if we should use a different type for the\n-                // discriminant. We can safely use a type with the same size\n-                // as the alignment of the first field of each variant.\n-                // We increase the size of the discriminant to avoid LLVM copying\n-                // padding when it doesn't need to. This normally causes unaligned\n-                // load/stores and excessive memcpy/memset operations. By using a\n-                // bigger integer size, LLVM can be sure about it's contents and\n-                // won't be so conservative.\n-\n-                // Use the initial field alignment\n-                let wanted = start_align.abi();\n-                let mut ity = min_ity;\n-                for &candidate in &[I16, I32, I64] {\n-                    let ty = Int(candidate);\n-                    if wanted == ty.align(dl).abi() && wanted == ty.size(dl).bytes() {\n-                        ity = candidate;\n-                        break;\n                     }\n-                }\n \n-                // FIXME(eddyb) conservative only to avoid diverging from trans::adt.\n-                if align.abi() != start_align.abi() {\n-                    ity = min_ity;\n-                }\n+                    // FIXME(eddyb) conservative only to avoid diverging from trans::adt.\n+                    if align.abi() != start_align.abi() {\n+                        ity = min_ity;\n+                    }\n \n-                // If the alignment is not larger than the chosen discriminant size,\n-                // don't use the alignment as the final size.\n-                if ity <= min_ity {\n-                    ity = min_ity;\n-                } else {\n-                    // Patch up the variants' first few fields.\n-                    let old_ity_size = Int(min_ity).size(dl);\n-                    let new_ity_size = Int(ity).size(dl);\n-                    for variant in &mut variants {\n-                        for offset in &mut variant.offset_after_field {\n-                            if *offset > old_ity_size {\n-                                break;\n+                    // If the alignment is not larger than the chosen discriminant size,\n+                    // don't use the alignment as the final size.\n+                    if ity <= min_ity {\n+                        ity = min_ity;\n+                    } else {\n+                        // Patch up the variants' first few fields.\n+                        let old_ity_size = Int(min_ity).size(dl);\n+                        let new_ity_size = Int(ity).size(dl);\n+                        for variant in &mut variants {\n+                            for offset in &mut variant.offset_after_field {\n+                                if *offset > old_ity_size {\n+                                    break;\n+                                }\n+                                *offset = new_ity_size;\n                             }\n-                            *offset = new_ity_size;\n                         }\n                     }\n-                }\n \n-                General {\n-                    discr: ity,\n-                    variants: variants,\n-                    size: size,\n-                    align: align\n+                    General {\n+                        discr: ity,\n+                        variants: variants,\n+                        size: size,\n+                        align: align\n+                    }\n                 }\n-            }\n+            },\n \n             // Types with no meaningful known layout.\n             ty::TyProjection(_) | ty::TyAnon(..) => {\n@@ -1317,9 +1319,9 @@ impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n                 }\n             }\n \n-            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+            ty::TyAdt(def, substs) => {\n                 // Only newtypes and enums w/ nullable pointer optimization.\n-                if def.variants.is_empty() || def.variants.len() > 2 {\n+                if def.is_union() || def.variants.is_empty() || def.variants.len() > 2 {\n                     return Err(err);\n                 }\n "}, {"sha": "91e3950745089177d53f533cc56efeb879a07322", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -952,9 +952,7 @@ impl<'tcx> TraitPredicate<'tcx> {\n             self.input_types()\n                 .flat_map(|t| t.walk())\n                 .filter_map(|t| match t.sty {\n-                    ty::TyStruct(adt_def, _) |\n-                    ty::TyUnion(adt_def, _) |\n-                    ty::TyEnum(adt_def, _) =>\n+                    ty::TyAdt(adt_def, _) =>\n                         Some(adt_def.did),\n                     _ =>\n                         None\n@@ -1573,18 +1571,49 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n         self.flags.set(self.flags.get() | AdtFlags::IS_DTORCK_VALID)\n     }\n \n+    #[inline]\n+    pub fn is_struct(&self) -> bool {\n+        !self.is_union() && !self.is_enum()\n+    }\n+\n+    #[inline]\n+    pub fn is_union(&self) -> bool {\n+        self.flags.get().intersects(AdtFlags::IS_UNION)\n+    }\n+\n+    #[inline]\n+    pub fn is_enum(&self) -> bool {\n+        self.flags.get().intersects(AdtFlags::IS_ENUM)\n+    }\n+\n     /// Returns the kind of the ADT - Struct or Enum.\n     #[inline]\n     pub fn adt_kind(&self) -> AdtKind {\n-        if self.flags.get().intersects(AdtFlags::IS_ENUM) {\n+        if self.is_enum() {\n             AdtKind::Enum\n-        } else if self.flags.get().intersects(AdtFlags::IS_UNION) {\n+        } else if self.is_union() {\n             AdtKind::Union\n         } else {\n             AdtKind::Struct\n         }\n     }\n \n+    pub fn descr(&self) -> &'static str {\n+        match self.adt_kind() {\n+            AdtKind::Struct => \"struct\",\n+            AdtKind::Union => \"union\",\n+            AdtKind::Enum => \"enum\",\n+        }\n+    }\n+\n+    pub fn variant_descr(&self) -> &'static str {\n+        match self.adt_kind() {\n+            AdtKind::Struct => \"struct\",\n+            AdtKind::Union => \"union\",\n+            AdtKind::Enum => \"variant\",\n+        }\n+    }\n+\n     /// Returns whether this is a dtorck type. If this returns\n     /// true, this type being safe for destruction requires it to be\n     /// alive; Otherwise, only the contents are required to be.\n@@ -1622,8 +1651,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n     /// Asserts this is a struct and returns the struct's unique\n     /// variant.\n     pub fn struct_variant(&self) -> &VariantDefData<'gcx, 'container> {\n-        let adt_kind = self.adt_kind();\n-        assert!(adt_kind == AdtKind::Struct || adt_kind == AdtKind::Union);\n+        assert!(!self.is_enum());\n         &self.variants[0]\n     }\n \n@@ -1832,7 +1860,7 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n                 }\n             }\n \n-            TyEnum(adt, substs) | TyStruct(adt, substs) | TyUnion(adt, substs) => {\n+            TyAdt(adt, substs) => {\n                 // recursive case\n                 let adt = tcx.lookup_adt_def_master(adt.did);\n                 adt.calculate_sized_constraint_inner(tcx, stack);"}, {"sha": "a4edd3b93c949535a38a55465093635225a7af3e", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -172,9 +172,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             ty::TyUint(..) |        // OutlivesScalar\n             ty::TyFloat(..) |       // OutlivesScalar\n             ty::TyNever |           // ...\n-            ty::TyEnum(..) |        // OutlivesNominalType\n-            ty::TyStruct(..) |      // OutlivesNominalType\n-            ty::TyUnion(..) |      // OutlivesNominalType\n+            ty::TyAdt(..) |         // OutlivesNominalType\n             ty::TyBox(..) |         // OutlivesNominalType (ish)\n             ty::TyAnon(..) |        // OutlivesNominalType (ish)\n             ty::TyStr |             // OutlivesScalar (ish)"}, {"sha": "b10c731fe27d00881faff1757c7cef9299eb2333", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -414,11 +414,11 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(a)\n         }\n \n-        (&ty::TyEnum(a_def, a_substs), &ty::TyEnum(b_def, b_substs))\n+        (&ty::TyAdt(a_def, a_substs), &ty::TyAdt(b_def, b_substs))\n             if a_def == b_def =>\n         {\n             let substs = relate_item_substs(relation, a_def.did, a_substs, b_substs)?;\n-            Ok(tcx.mk_enum(a_def, substs))\n+            Ok(tcx.mk_adt(a_def, substs))\n         }\n \n         (&ty::TyTrait(ref a_obj), &ty::TyTrait(ref b_obj)) =>\n@@ -440,20 +440,6 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             }))\n         }\n \n-        (&ty::TyStruct(a_def, a_substs), &ty::TyStruct(b_def, b_substs))\n-            if a_def == b_def =>\n-        {\n-            let substs = relate_item_substs(relation, a_def.did, a_substs, b_substs)?;\n-            Ok(tcx.mk_struct(a_def, substs))\n-        }\n-\n-        (&ty::TyUnion(a_def, a_substs), &ty::TyUnion(b_def, b_substs))\n-            if a_def == b_def =>\n-        {\n-            let substs = relate_item_substs(relation, a_def.did, a_substs, b_substs)?;\n-            Ok(tcx.mk_union(a_def, substs))\n-        }\n-\n         (&ty::TyClosure(a_id, a_substs),\n          &ty::TyClosure(b_id, b_substs))\n             if a_id == b_id =>"}, {"sha": "6c3dabfe113fe37d824bd37a353aaaeb70187809", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -482,7 +482,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyRawPtr(tm) => ty::TyRawPtr(tm.fold_with(folder)),\n             ty::TyArray(typ, sz) => ty::TyArray(typ.fold_with(folder), sz),\n             ty::TySlice(typ) => ty::TySlice(typ.fold_with(folder)),\n-            ty::TyEnum(tid, substs) => ty::TyEnum(tid, substs.fold_with(folder)),\n+            ty::TyAdt(tid, substs) => ty::TyAdt(tid, substs.fold_with(folder)),\n             ty::TyTrait(ref trait_ty) => ty::TyTrait(trait_ty.fold_with(folder)),\n             ty::TyTuple(ts) => ty::TyTuple(ts.fold_with(folder)),\n             ty::TyFnDef(def_id, substs, f) => {\n@@ -494,8 +494,6 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyRef(ref r, tm) => {\n                 ty::TyRef(r.fold_with(folder), tm.fold_with(folder))\n             }\n-            ty::TyStruct(did, substs) => ty::TyStruct(did, substs.fold_with(folder)),\n-            ty::TyUnion(did, substs) => ty::TyUnion(did, substs.fold_with(folder)),\n             ty::TyClosure(did, substs) => ty::TyClosure(did, substs.fold_with(folder)),\n             ty::TyProjection(ref data) => ty::TyProjection(data.fold_with(folder)),\n             ty::TyAnon(did, substs) => ty::TyAnon(did, substs.fold_with(folder)),\n@@ -516,16 +514,14 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyRawPtr(ref tm) => tm.visit_with(visitor),\n             ty::TyArray(typ, _sz) => typ.visit_with(visitor),\n             ty::TySlice(typ) => typ.visit_with(visitor),\n-            ty::TyEnum(_tid, ref substs) => substs.visit_with(visitor),\n+            ty::TyAdt(_, substs) => substs.visit_with(visitor),\n             ty::TyTrait(ref trait_ty) => trait_ty.visit_with(visitor),\n             ty::TyTuple(ts) => ts.visit_with(visitor),\n             ty::TyFnDef(_, substs, ref f) => {\n                 substs.visit_with(visitor) || f.visit_with(visitor)\n             }\n             ty::TyFnPtr(ref f) => f.visit_with(visitor),\n             ty::TyRef(r, ref tm) => r.visit_with(visitor) || tm.visit_with(visitor),\n-            ty::TyStruct(_did, ref substs) => substs.visit_with(visitor),\n-            ty::TyUnion(_did, ref substs) => substs.visit_with(visitor),\n             ty::TyClosure(_did, ref substs) => substs.visit_with(visitor),\n             ty::TyProjection(ref data) => data.visit_with(visitor),\n             ty::TyAnon(_, ref substs) => substs.visit_with(visitor),"}, {"sha": "a755dd056cd8483a07ca03ef0498ed690f14de11", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 13, "deletions": 30, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -106,24 +106,13 @@ pub enum TypeVariants<'tcx> {\n     /// A primitive floating-point type. For example, `f64`.\n     TyFloat(ast::FloatTy),\n \n-    /// An enumerated type, defined with `enum`.\n+    /// Structures, enumerations and unions.\n     ///\n     /// Substs here, possibly against intuition, *may* contain `TyParam`s.\n     /// That is, even after substitution it is possible that there are type\n-    /// variables. This happens when the `TyEnum` corresponds to an enum\n-    /// definition and not a concrete use of it. This is true for `TyStruct`\n-    /// and `TyUnion` as well.\n-    TyEnum(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n-\n-    /// A structure type, defined with `struct`.\n-    ///\n-    /// See warning about substitutions for enumerated types.\n-    TyStruct(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n-\n-    /// A union type, defined with `union`.\n-    ///\n-    /// See warning about substitutions for enumerated types.\n-    TyUnion(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n+    /// variables. This happens when the `TyAdt` corresponds to an ADT\n+    /// definition and not a concrete use of it.\n+    TyAdt(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n \n     /// `Box<T>`; this is nominally a struct in the documentation, but is\n     /// special-cased internally. For example, it is possible to implicitly\n@@ -922,7 +911,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         // FIXME(#24885): be smarter here, the AdtDefData::is_empty method could easily be made\n         // more complete.\n         match self.sty {\n-            TyEnum(def, _) | TyStruct(def, _) | TyUnion(def, _) => def.is_empty(),\n+            TyAdt(def, _) => def.is_empty(),\n \n             // FIXME(canndrew): There's no reason why these can't be uncommented, they're tested\n             // and they don't break anything. But I'm keeping my changes small for now.\n@@ -950,7 +939,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     }\n \n     pub fn is_phantom_data(&self) -> bool {\n-        if let TyStruct(def, _) = self.sty {\n+        if let TyAdt(def, _) = self.sty {\n             def.is_phantom_data()\n         } else {\n             false\n@@ -985,16 +974,15 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn is_structural(&self) -> bool {\n         match self.sty {\n-            TyStruct(..) | TyUnion(..) | TyTuple(..) | TyEnum(..) |\n-            TyArray(..) | TyClosure(..) => true,\n+            TyAdt(..) | TyTuple(..) | TyArray(..) | TyClosure(..) => true,\n             _ => self.is_slice() | self.is_trait()\n         }\n     }\n \n     #[inline]\n     pub fn is_simd(&self) -> bool {\n         match self.sty {\n-            TyStruct(def, _) => def.is_simd(),\n+            TyAdt(def, _) => def.is_simd(),\n             _ => false\n         }\n     }\n@@ -1009,7 +997,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn simd_type(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match self.sty {\n-            TyStruct(def, substs) => {\n+            TyAdt(def, substs) => {\n                 def.struct_variant().fields[0].ty(tcx, substs)\n             }\n             _ => bug!(\"simd_type called on invalid type\")\n@@ -1018,7 +1006,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn simd_size(&self, _cx: TyCtxt) -> usize {\n         match self.sty {\n-            TyStruct(def, _) => def.struct_variant().fields.len(),\n+            TyAdt(def, _) => def.struct_variant().fields.len(),\n             _ => bug!(\"simd_size called on invalid type\")\n         }\n     }\n@@ -1203,17 +1191,15 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     pub fn ty_to_def_id(&self) -> Option<DefId> {\n         match self.sty {\n             TyTrait(ref tt) => Some(tt.principal.def_id()),\n-            TyStruct(def, _) |\n-            TyUnion(def, _) |\n-            TyEnum(def, _) => Some(def.did),\n+            TyAdt(def, _) => Some(def.did),\n             TyClosure(id, _) => Some(id),\n             _ => None\n         }\n     }\n \n     pub fn ty_adt_def(&self) -> Option<AdtDef<'tcx>> {\n         match self.sty {\n-            TyStruct(adt, _) | TyUnion(adt, _) | TyEnum(adt, _) => Some(adt),\n+            TyAdt(adt, _) => Some(adt),\n             _ => None\n         }\n     }\n@@ -1231,10 +1217,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 v.extend(obj.principal.skip_binder().substs.regions());\n                 v\n             }\n-            TyEnum(_, substs) |\n-            TyStruct(_, substs) |\n-            TyUnion(_, substs) |\n-            TyAnon(_, substs) => {\n+            TyAdt(_, substs) | TyAnon(_, substs) => {\n                 substs.regions().collect()\n             }\n             TyClosure(_, ref substs) => {"}, {"sha": "68de8d96f33dcbfd56399869d0608c91c5237222", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 60, "deletions": 58, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -14,7 +14,7 @@ use hir::def_id::DefId;\n use infer::InferCtxt;\n use hir::pat_util;\n use traits::{self, Reveal};\n-use ty::{self, Ty, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n+use ty::{self, Ty, AdtKind, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n use ty::{Disr, ParameterEnvironment};\n use ty::fold::TypeVisitor;\n use ty::layout::{Layout, LayoutError};\n@@ -138,28 +138,30 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n         // FIXME: (@jroesch) float this code up\n         tcx.infer_ctxt(None, Some(self.clone()), Reveal::ExactMatch).enter(|infcx| {\n             let adt = match self_type.sty {\n-                ty::TyStruct(struct_def, substs) | ty::TyUnion(struct_def, substs) => {\n-                    for field in struct_def.all_fields() {\n-                        let field_ty = field.ty(tcx, substs);\n-                        if infcx.type_moves_by_default(field_ty, span) {\n-                            return Err(CopyImplementationError::InfrigingField(\n-                                field.name))\n-                        }\n-                    }\n-                    struct_def\n-                }\n-                ty::TyEnum(enum_def, substs) => {\n-                    for variant in &enum_def.variants {\n-                        for field in &variant.fields {\n+                ty::TyAdt(adt, substs) => match adt.adt_kind() {\n+                    AdtKind::Struct | AdtKind::Union => {\n+                        for field in adt.all_fields() {\n                             let field_ty = field.ty(tcx, substs);\n                             if infcx.type_moves_by_default(field_ty, span) {\n-                                return Err(CopyImplementationError::InfrigingVariant(\n-                                    variant.name))\n+                                return Err(CopyImplementationError::InfrigingField(\n+                                    field.name))\n                             }\n                         }\n+                        adt\n                     }\n-                    enum_def\n-                }\n+                    AdtKind::Enum => {\n+                        for variant in &adt.variants {\n+                            for field in &variant.fields {\n+                                let field_ty = field.ty(tcx, substs);\n+                                if infcx.type_moves_by_default(field_ty, span) {\n+                                    return Err(CopyImplementationError::InfrigingVariant(\n+                                        variant.name))\n+                                }\n+                            }\n+                        }\n+                        adt\n+                    }\n+                },\n                 _ => return Err(CopyImplementationError::NotAnAdt)\n             };\n \n@@ -183,7 +185,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn has_error_field(self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n-            ty::TyStruct(def, substs) | ty::TyUnion(def, substs) | ty::TyEnum(def, substs) => {\n+            ty::TyAdt(def, substs) => {\n                 for field in def.all_fields() {\n                     let field_ty = field.ty(self, substs);\n                     if let TyError = field_ty.sty {\n@@ -203,16 +205,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                  i: usize,\n                                  variant: Option<DefId>) -> Option<Ty<'tcx>> {\n         match (&ty.sty, variant) {\n-            (&TyStruct(def, substs), None) |\n-            (&TyUnion(def, substs), None) => {\n-                def.struct_variant().fields.get(i).map(|f| f.ty(self, substs))\n+            (&TyAdt(adt, substs), Some(vid)) => {\n+                adt.variant_with_id(vid).fields.get(i).map(|f| f.ty(self, substs))\n             }\n-            (&TyEnum(def, substs), Some(vid)) => {\n-                def.variant_with_id(vid).fields.get(i).map(|f| f.ty(self, substs))\n-            }\n-            (&TyEnum(def, substs), None) => {\n-                assert!(def.is_univariant());\n-                def.variants[0].fields.get(i).map(|f| f.ty(self, substs))\n+            (&TyAdt(adt, substs), None) => {\n+                // Don't use `struct_variant`, this may be a univariant enum.\n+                adt.variants[0].fields.get(i).map(|f| f.ty(self, substs))\n             }\n             (&TyTuple(ref v), None) => v.get(i).cloned(),\n             _ => None\n@@ -226,12 +224,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                             n: Name,\n                             variant: Option<DefId>) -> Option<Ty<'tcx>> {\n         match (&ty.sty, variant) {\n-            (&TyStruct(def, substs), None) |\n-            (&TyUnion(def, substs), None)  => {\n-                def.struct_variant().find_field_named(n).map(|f| f.ty(self, substs))\n+            (&TyAdt(adt, substs), Some(vid)) => {\n+                adt.variant_with_id(vid).find_field_named(n).map(|f| f.ty(self, substs))\n             }\n-            (&TyEnum(def, substs), Some(vid)) => {\n-                def.variant_with_id(vid).find_field_named(n).map(|f| f.ty(self, substs))\n+            (&TyAdt(adt, substs), None) => {\n+                adt.struct_variant().find_field_named(n).map(|f| f.ty(self, substs))\n             }\n             _ => return None\n         }\n@@ -256,10 +253,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// if not a structure at all. Corresponds to the only possible unsized\n     /// field, and its type can be used to determine unsizing strategy.\n     pub fn struct_tail(self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n-        while let TyStruct(def, substs) = ty.sty {\n-            match def.struct_variant().fields.last() {\n-                Some(f) => ty = f.ty(self, substs),\n-                None => break\n+        loop {\n+            match ty.sty {\n+                TyAdt(def, substs) if def.is_struct() => {\n+                    match def.struct_variant().fields.last() {\n+                        Some(f) => ty = f.ty(self, substs),\n+                        None => break\n+                    }\n+                }\n+                _ => break\n             }\n         }\n         ty\n@@ -275,15 +277,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                  target: Ty<'tcx>)\n                                  -> (Ty<'tcx>, Ty<'tcx>) {\n         let (mut a, mut b) = (source, target);\n-        while let (&TyStruct(a_def, a_substs), &TyStruct(b_def, b_substs)) = (&a.sty, &b.sty) {\n-            if a_def != b_def {\n-                break;\n-            }\n-            if let Some(f) = a_def.struct_variant().fields.last() {\n-                a = f.ty(self, a_substs);\n-                b = f.ty(self, b_substs);\n-            } else {\n-                break;\n+        loop {\n+            match (&a.sty, &b.sty) {\n+                (&TyAdt(a_def, a_substs), &TyAdt(b_def, b_substs))\n+                        if a_def == b_def && a_def.is_struct() => {\n+                    match a_def.struct_variant().fields.last() {\n+                        Some(f) => {\n+                            a = f.ty(self, a_substs);\n+                            b = f.ty(self, b_substs);\n+                        }\n+                        _ => break\n+                    }\n+                }\n+                _ => break\n             }\n         }\n         (a, b)\n@@ -431,9 +437,7 @@ impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx> {\n             TyInt(i) => self.hash(i),\n             TyUint(u) => self.hash(u),\n             TyFloat(f) => self.hash(f),\n-            TyStruct(d, _) |\n-            TyUnion(d, _) |\n-            TyEnum(d, _) => self.def_id(d.did),\n+            TyAdt(d, _) => self.def_id(d.did),\n             TyArray(_, n) => self.hash(n),\n             TyRawPtr(m) |\n             TyRef(_, m) => self.hash(m.mutbl),\n@@ -560,8 +564,8 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                 mutbl: hir::MutMutable, ..\n             }) => Some(true),\n \n-            TyArray(..) | TySlice(_) | TyTrait(..) | TyTuple(..) |\n-            TyClosure(..) | TyEnum(..) | TyStruct(..) | TyUnion(..) | TyAnon(..) |\n+            TyArray(..) | TySlice(..) | TyTrait(..) | TyTuple(..) |\n+            TyClosure(..) | TyAdt(..) | TyAnon(..) |\n             TyProjection(..) | TyParam(..) | TyInfer(..) | TyError => None\n         }.unwrap_or_else(|| !self.impls_bound(tcx, param_env, ty::BoundCopy, span));\n \n@@ -601,7 +605,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n             TyStr | TyTrait(..) | TySlice(_) => Some(false),\n \n-            TyEnum(..) | TyStruct(..) | TyUnion(..) | TyProjection(..) | TyParam(..) |\n+            TyAdt(..) | TyProjection(..) | TyParam(..) |\n             TyInfer(..) | TyAnon(..) | TyError => None\n         }.unwrap_or_else(|| self.impls_bound(tcx, param_env, ty::BoundSized, span));\n \n@@ -663,7 +667,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                 TyArray(ty, _) => {\n                     is_type_structurally_recursive(tcx, sp, seen, ty)\n                 }\n-                TyStruct(def, substs) | TyUnion(def, substs) | TyEnum(def, substs) => {\n+                TyAdt(def, substs) => {\n                     find_nonrepresentable(tcx,\n                                           sp,\n                                           seen,\n@@ -680,7 +684,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n         fn same_struct_or_enum<'tcx>(ty: Ty<'tcx>, def: ty::AdtDef<'tcx>) -> bool {\n             match ty.sty {\n-                TyStruct(ty_def, _) | TyUnion(ty_def, _) | TyEnum(ty_def, _) => {\n+                TyAdt(ty_def, _) => {\n                      ty_def == def\n                 }\n                 _ => false\n@@ -689,9 +693,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n         fn same_type<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n             match (&a.sty, &b.sty) {\n-                (&TyStruct(did_a, ref substs_a), &TyStruct(did_b, ref substs_b)) |\n-                (&TyUnion(did_a, ref substs_a), &TyUnion(did_b, ref substs_b)) |\n-                (&TyEnum(did_a, ref substs_a), &TyEnum(did_b, ref substs_b)) => {\n+                (&TyAdt(did_a, substs_a), &TyAdt(did_b, substs_b)) => {\n                     if did_a != did_b {\n                         return false;\n                     }\n@@ -713,7 +715,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             debug!(\"is_type_structurally_recursive: {:?}\", ty);\n \n             match ty.sty {\n-                TyStruct(def, _) | TyUnion(def, _) | TyEnum(def, _) => {\n+                TyAdt(def, _) => {\n                     {\n                         // Iterate through stack of previously seen types.\n                         let mut iter = seen.iter();"}, {"sha": "dd3a62f7cd2dd0d5ee4071520c037cb259a68710", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -93,10 +93,7 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n                 pred.0.ty\n             }).rev());\n         }\n-        ty::TyEnum(_, ref substs) |\n-        ty::TyStruct(_, ref substs) |\n-        ty::TyUnion(_, ref substs) |\n-        ty::TyAnon(_, ref substs) => {\n+        ty::TyAdt(_, substs) | ty::TyAnon(_, substs) => {\n             stack.extend(substs.types().rev());\n         }\n         ty::TyClosure(_, ref substs) => {"}, {"sha": "0557660e98c2f7d0a7890f6617598492c3302529", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -336,9 +336,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     self.compute_projection(data);\n                 }\n \n-                ty::TyEnum(def, substs) |\n-                ty::TyStruct(def, substs) |\n-                ty::TyUnion(def, substs) => {\n+                ty::TyAdt(def, substs) => {\n                     // WfNominalType\n                     let obligations = self.nominal_obligations(def.did, substs);\n                     self.out.extend(obligations);"}, {"sha": "3b84ff86ab9fbaa8cd20e316975713330cf19c0c", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -11,7 +11,7 @@\n use hir::def_id::DefId;\n use ty::subst::{self, Subst, Substs};\n use ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n-use ty::{TyBool, TyChar, TyStruct, TyUnion, TyEnum};\n+use ty::{TyBool, TyChar, TyAdt};\n use ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyFnDef, TyFnPtr};\n use ty::{TyParam, TyRawPtr, TyRef, TyNever, TyTuple};\n use ty::TyClosure;\n@@ -868,7 +868,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyInfer(infer_ty) => write!(f, \"{}\", infer_ty),\n             TyError => write!(f, \"[type error]\"),\n             TyParam(ref param_ty) => write!(f, \"{}\", param_ty),\n-            TyEnum(def, substs) | TyStruct(def, substs) | TyUnion(def, substs) => {\n+            TyAdt(def, substs) => {\n                 ty::tls::with(|tcx| {\n                     if def.did.is_local() &&\n                           !tcx.tcache.borrow().contains_key(&def.did) {"}, {"sha": "089733da536d8d4c602727971784e21d22546dc4", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -796,9 +796,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             }\n             LpExtend(ref lp_base, _, LpInterior(_, InteriorField(_))) => {\n                 match lp_base.to_type().sty {\n-                    ty::TyStruct(def, _) |\n-                    ty::TyUnion(def, _) |\n-                    ty::TyEnum(def, _) if def.has_dtor() => {\n+                    ty::TyAdt(def, _) if def.has_dtor() => {\n                         // In the case where the owner implements drop, then\n                         // the path must be initialized to prevent a case of\n                         // partial reinitialization"}, {"sha": "515868c460d071571639eb9395014fc1a4f5370b", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 49, "deletions": 50, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -21,7 +21,7 @@ use borrowck::LoanPathElem::{LpDeref, LpInterior};\n use borrowck::move_data::InvalidMovePathIndex;\n use borrowck::move_data::{MoveData, MovePathIndex};\n use rustc::hir::def_id::{DefId};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, AdtKind, TyCtxt};\n use rustc::middle::mem_categorization as mc;\n \n use std::mem;\n@@ -422,8 +422,8 @@ fn add_fragment_siblings_for_extension<'a, 'tcx>(this: &MoveData<'tcx>,\n             variant_did);\n     };\n \n-    match (&parent_ty.sty, enum_variant_info) {\n-        (&ty::TyTuple(ref v), None) => {\n+    match parent_ty.sty {\n+        ty::TyTuple(ref v) => {\n             let tuple_idx = match *origin_field_name {\n                 mc::PositionalField(tuple_idx) => tuple_idx,\n                 mc::NamedField(_) =>\n@@ -438,69 +438,68 @@ fn add_fragment_siblings_for_extension<'a, 'tcx>(this: &MoveData<'tcx>,\n             }\n         }\n \n-        (&ty::TyStruct(def, _), None) => {\n-            match *origin_field_name {\n-                mc::NamedField(ast_name) => {\n-                    for f in &def.struct_variant().fields {\n-                        if f.name == ast_name {\n-                            continue;\n+        ty::TyAdt(def, ..) => match def.adt_kind() {\n+            AdtKind::Struct => {\n+                match *origin_field_name {\n+                    mc::NamedField(ast_name) => {\n+                        for f in &def.struct_variant().fields {\n+                            if f.name == ast_name {\n+                                continue;\n+                            }\n+                            let field_name = mc::NamedField(f.name);\n+                            add_fragment_sibling_local(field_name, None);\n                         }\n-                        let field_name = mc::NamedField(f.name);\n-                        add_fragment_sibling_local(field_name, None);\n                     }\n-                }\n-                mc::PositionalField(tuple_idx) => {\n-                    for (i, _f) in def.struct_variant().fields.iter().enumerate() {\n-                        if i == tuple_idx {\n-                            continue\n+                    mc::PositionalField(tuple_idx) => {\n+                        for (i, _f) in def.struct_variant().fields.iter().enumerate() {\n+                            if i == tuple_idx {\n+                                continue\n+                            }\n+                            let field_name = mc::PositionalField(i);\n+                            add_fragment_sibling_local(field_name, None);\n                         }\n-                        let field_name = mc::PositionalField(i);\n-                        add_fragment_sibling_local(field_name, None);\n                     }\n                 }\n             }\n-        }\n-\n-        (&ty::TyUnion(..), None) => {\n-            // Do nothing, all union fields are moved/assigned together.\n-        }\n-\n-        (&ty::TyEnum(def, _), ref enum_variant_info) => {\n-            let variant = match *enum_variant_info {\n-                Some((vid, ref _lp2)) => def.variant_with_id(vid),\n-                None => {\n-                    assert!(def.is_univariant());\n-                    &def.variants[0]\n-                }\n-            };\n-            match *origin_field_name {\n-                mc::NamedField(ast_name) => {\n-                    for field in &variant.fields {\n-                        if field.name == ast_name {\n-                            continue;\n+            AdtKind::Union => {\n+                // Do nothing, all union fields are moved/assigned together.\n+            }\n+            AdtKind::Enum => {\n+                let variant = match enum_variant_info {\n+                    Some((vid, ref _lp2)) => def.variant_with_id(vid),\n+                    None => {\n+                        assert!(def.is_univariant());\n+                        &def.variants[0]\n+                    }\n+                };\n+                match *origin_field_name {\n+                    mc::NamedField(ast_name) => {\n+                        for field in &variant.fields {\n+                            if field.name == ast_name {\n+                                continue;\n+                            }\n+                            let field_name = mc::NamedField(field.name);\n+                            add_fragment_sibling_local(field_name, Some(variant.did));\n                         }\n-                        let field_name = mc::NamedField(field.name);\n-                        add_fragment_sibling_local(field_name, Some(variant.did));\n                     }\n-                }\n-                mc::PositionalField(tuple_idx) => {\n-                    for (i, _f) in variant.fields.iter().enumerate() {\n-                        if tuple_idx == i {\n-                            continue;\n+                    mc::PositionalField(tuple_idx) => {\n+                        for (i, _f) in variant.fields.iter().enumerate() {\n+                            if tuple_idx == i {\n+                                continue;\n+                            }\n+                            let field_name = mc::PositionalField(i);\n+                            add_fragment_sibling_local(field_name, None);\n                         }\n-                        let field_name = mc::PositionalField(i);\n-                        add_fragment_sibling_local(field_name, None);\n                     }\n                 }\n             }\n-        }\n+        },\n \n-        ref sty_and_variant_info => {\n+        ref ty => {\n             let opt_span = origin_id.and_then(|id|tcx.map.opt_span(id));\n             span_bug!(opt_span.unwrap_or(DUMMY_SP),\n                       \"type {:?} ({:?}) is not fragmentable\",\n-                      parent_ty,\n-                      sty_and_variant_info);\n+                      parent_ty, ty);\n         }\n     }\n }"}, {"sha": "3e335dacc8ed9f7a6698159cbc6ec4ef7ea9ebca", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -178,7 +178,7 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         Categorization::Interior(ref b, mc::InteriorField(_)) |\n         Categorization::Interior(ref b, mc::InteriorElement(Kind::Pattern, _)) => {\n             match b.ty.sty {\n-                ty::TyStruct(def, _) | ty::TyUnion(def, _) | ty::TyEnum(def, _) => {\n+                ty::TyAdt(def, _) => {\n                     if def.has_dtor() {\n                         Some(cmt.clone())\n                     } else {"}, {"sha": "3fa7c252b842ce886701397c0301316eb0eda71f", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -148,9 +148,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         Categorization::Downcast(ref b, _) |\n         Categorization::Interior(ref b, mc::InteriorField(_)) => {\n             match b.ty.sty {\n-                ty::TyStruct(def, _) |\n-                ty::TyUnion(def, _) |\n-                ty::TyEnum(def, _) if def.has_dtor() => {\n+                ty::TyAdt(def, _) if def.has_dtor() => {\n                     let mut err = struct_span_err!(bccx, move_from.span, E0509,\n                                                    \"cannot move out of type `{}`, \\\n                                                    which implements the `Drop` trait\","}, {"sha": "fdcefdc0d43073f4d91f0b56dff5756f0adc2116", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -103,8 +103,8 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 let base_ty = cmt_base.ty;\n                 let result = self.restrict(cmt_base);\n                 // Borrowing one union field automatically borrows all its fields.\n-                if let ty::TyUnion(ref adt_def, _) = base_ty.sty {\n-                    match result {\n+                match base_ty.sty {\n+                    ty::TyAdt(adt_def, _) if adt_def.is_union() => match result {\n                         RestrictionResult::Safe => RestrictionResult::Safe,\n                         RestrictionResult::SafeIf(base_lp, mut base_vec) => {\n                             for field in &adt_def.struct_variant().fields {\n@@ -124,9 +124,8 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                                                      LpInterior(opt_variant_id, interior)));\n                             RestrictionResult::SafeIf(lp, base_vec)\n                         }\n-                    }\n-                } else {\n-                    self.extend(result, &cmt, LpInterior(opt_variant_id, interior))\n+                    },\n+                    _ => self.extend(result, &cmt, LpInterior(opt_variant_id, interior))\n                 }\n             }\n "}, {"sha": "71274b7e0218a976c6932c9c8fda970c531dc799", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -709,7 +709,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn open_drop<'a>(&mut self, c: &DropCtxt<'a, 'tcx>) -> BasicBlock {\n         let ty = c.lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n         match ty.sty {\n-            ty::TyStruct(def, substs) | ty::TyUnion(def, substs) | ty::TyEnum(def, substs) => {\n+            ty::TyAdt(def, substs) => {\n                 self.open_drop_for_adt(c, def, substs)\n             }\n             ty::TyTuple(tys) | ty::TyClosure(_, ty::ClosureSubsts {\n@@ -893,7 +893,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let ty = c.lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n \n         match ty.sty {\n-            ty::TyStruct(def, _) | ty::TyUnion(def, _) | ty::TyEnum(def, _) => {\n+            ty::TyAdt(def, _) => {\n                 if def.has_dtor() {\n                     self.tcx.sess.span_warn(\n                         c.source_info.span,"}, {"sha": "e035e268b1c4cdb74dfbd536b9484e9ce4dd9d21", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -261,7 +261,7 @@ fn lvalue_contents_drop_state_cannot_differ<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n                    lv, ty);\n             true\n         }\n-        ty::TyStruct(def, _) | ty::TyUnion(def, _) | ty::TyEnum(def, _) if def.has_dtor() => {\n+        ty::TyAdt(def, _) if def.has_dtor() => {\n             debug!(\"lvalue_contents_drop_state_cannot_differ lv: {:?} ty: {:?} Drop => false\",\n                    lv, ty);\n             true"}, {"sha": "e9ba406389f88ae022b5512aa16518a1403a1963", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -367,20 +367,22 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                     kind: MoveKind) {\n         // Moving one union field automatically moves all its fields.\n         if let LpExtend(ref base_lp, mutbl, LpInterior(opt_variant_id, interior)) = lp.kind {\n-            if let ty::TyUnion(ref adt_def, _) = base_lp.ty.sty {\n-                for field in &adt_def.struct_variant().fields {\n-                    let field = InteriorKind::InteriorField(mc::NamedField(field.name));\n-                    let field_ty = if field == interior {\n-                        lp.ty\n-                    } else {\n-                        tcx.types.err // Doesn't matter\n-                    };\n-                    let sibling_lp_kind = LpExtend(base_lp.clone(), mutbl,\n-                                                   LpInterior(opt_variant_id, field));\n-                    let sibling_lp = Rc::new(LoanPath::new(sibling_lp_kind, field_ty));\n-                    self.add_move_helper(tcx, sibling_lp, id, kind);\n+            if let ty::TyAdt(adt_def, _) = base_lp.ty.sty {\n+                if adt_def.is_union() {\n+                    for field in &adt_def.struct_variant().fields {\n+                        let field = InteriorKind::InteriorField(mc::NamedField(field.name));\n+                        let field_ty = if field == interior {\n+                            lp.ty\n+                        } else {\n+                            tcx.types.err // Doesn't matter\n+                        };\n+                        let sibling_lp_kind = LpExtend(base_lp.clone(), mutbl,\n+                                                    LpInterior(opt_variant_id, field));\n+                        let sibling_lp = Rc::new(LoanPath::new(sibling_lp_kind, field_ty));\n+                        self.add_move_helper(tcx, sibling_lp, id, kind);\n+                    }\n+                    return;\n                 }\n-                return;\n             }\n         }\n \n@@ -422,20 +424,23 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                           mode: euv::MutateMode) {\n         // Assigning to one union field automatically assigns to all its fields.\n         if let LpExtend(ref base_lp, mutbl, LpInterior(opt_variant_id, interior)) = lp.kind {\n-            if let ty::TyUnion(ref adt_def, _) = base_lp.ty.sty {\n-                for field in &adt_def.struct_variant().fields {\n-                    let field = InteriorKind::InteriorField(mc::NamedField(field.name));\n-                    let field_ty = if field == interior {\n-                        lp.ty\n-                    } else {\n-                        tcx.types.err // Doesn't matter\n-                    };\n-                    let sibling_lp_kind = LpExtend(base_lp.clone(), mutbl,\n-                                                   LpInterior(opt_variant_id, field));\n-                    let sibling_lp = Rc::new(LoanPath::new(sibling_lp_kind, field_ty));\n-                    self.add_assignment_helper(tcx, sibling_lp, assign_id, span, assignee_id, mode);\n+            if let ty::TyAdt(adt_def, _) = base_lp.ty.sty {\n+                if adt_def.is_union() {\n+                    for field in &adt_def.struct_variant().fields {\n+                        let field = InteriorKind::InteriorField(mc::NamedField(field.name));\n+                        let field_ty = if field == interior {\n+                            lp.ty\n+                        } else {\n+                            tcx.types.err // Doesn't matter\n+                        };\n+                        let sibling_lp_kind = LpExtend(base_lp.clone(), mutbl,\n+                                                    LpInterior(opt_variant_id, field));\n+                        let sibling_lp = Rc::new(LoanPath::new(sibling_lp_kind, field_ty));\n+                        self.add_assignment_helper(tcx, sibling_lp, assign_id,\n+                                                   span, assignee_id, mode);\n+                    }\n+                    return;\n                 }\n-                return;\n             }\n         }\n "}, {"sha": "da4445ef68947c7db45d627a96eff76e0b65d0b8", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -245,21 +245,23 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n     pat.walk(|p| {\n         if let PatKind::Binding(hir::BindByValue(hir::MutImmutable), name, None) = p.node {\n             let pat_ty = cx.tcx.pat_ty(p);\n-            if let ty::TyEnum(edef, _) = pat_ty.sty {\n-                if let Def::Local(..) = cx.tcx.expect_def(p.id) {\n-                    if edef.variants.iter().any(|variant| {\n-                        variant.name == name.node && variant.kind == VariantKind::Unit\n-                    }) {\n-                        let ty_path = cx.tcx.item_path_str(edef.did);\n-                        let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n-                            \"pattern binding `{}` is named the same as one \\\n-                             of the variants of the type `{}`\",\n-                            name.node, ty_path);\n-                        help!(err,\n-                            \"if you meant to match on a variant, \\\n-                             consider making the path in the pattern qualified: `{}::{}`\",\n-                            ty_path, name.node);\n-                        err.emit();\n+            if let ty::TyAdt(edef, _) = pat_ty.sty {\n+                if edef.is_enum() {\n+                    if let Def::Local(..) = cx.tcx.expect_def(p.id) {\n+                        if edef.variants.iter().any(|variant| {\n+                            variant.name == name.node && variant.kind == VariantKind::Unit\n+                        }) {\n+                            let ty_path = cx.tcx.item_path_str(edef.did);\n+                            let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n+                                \"pattern binding `{}` is named the same as one \\\n+                                of the variants of the type `{}`\",\n+                                name.node, ty_path);\n+                            help!(err,\n+                                \"if you meant to match on a variant, \\\n+                                consider making the path in the pattern qualified: `{}::{}`\",\n+                                ty_path, name.node);\n+                            err.emit();\n+                        }\n                     }\n                 }\n             }\n@@ -566,7 +568,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n     let pat = match left_ty.sty {\n         ty::TyTuple(..) => PatKind::Tuple(pats.collect(), None),\n \n-        ty::TyEnum(adt, _) | ty::TyStruct(adt, _) | ty::TyUnion(adt, _) => {\n+        ty::TyAdt(adt, _) => {\n             let v = ctor.variant_for_adt(adt);\n             match v.kind {\n                 VariantKind::Struct => {\n@@ -659,7 +661,8 @@ fn all_constructors(_cx: &MatchCheckCtxt, left_ty: Ty,\n             [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n         ty::TySlice(_) =>\n             (0..max_slice_length+1).map(|length| Slice(length)).collect(),\n-        ty::TyEnum(def, _) => def.variants.iter().map(|v| Variant(v.did)).collect(),\n+        ty::TyAdt(def, _) if def.is_enum() =>\n+            def.variants.iter().map(|v| Variant(v.did)).collect(),\n         _ => vec![Single]\n     }\n }\n@@ -837,7 +840,7 @@ pub fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> us\n             _ => bug!()\n         },\n         ty::TyRef(..) => 1,\n-        ty::TyEnum(adt, _) | ty::TyStruct(adt, _) | ty::TyUnion(adt, _) => {\n+        ty::TyAdt(adt, _) => {\n             ctor.variant_for_adt(adt).fields.len()\n         }\n         ty::TyArray(_, n) => n,"}, {"sha": "4f4c16d3f6a61af18be6959093a5f28956a4ca36", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -257,8 +257,11 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 span,\n                 format!(\"floating point constants cannot be used in patterns\"));\n         }\n-        ty::TyEnum(adt_def, _) |\n-        ty::TyStruct(adt_def, _) => {\n+        ty::TyAdt(adt_def, _) if adt_def.is_union() => {\n+            // Matching on union fields is unsafe, we can't hide it in constants\n+            tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n+        }\n+        ty::TyAdt(adt_def, _) => {\n             if !tcx.has_attr(adt_def.did, \"structural_match\") {\n                 tcx.sess.add_lint(\n                     lint::builtin::ILLEGAL_STRUCT_OR_ENUM_CONSTANT_PATTERN,\n@@ -271,10 +274,6 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             tcx.item_path_str(adt_def.did)));\n             }\n         }\n-        ty::TyUnion(..) => {\n-            // Matching on union fields is unsafe, we can't hide it in constants\n-            tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n-        }\n         _ => { }\n     }\n     let pat = match expr.node {\n@@ -1039,7 +1038,7 @@ fn infer<'a, 'tcx>(i: ConstInt,\n         (&ty::TyInt(ity), i) => Err(TypeMismatch(ity.to_string(), i)),\n         (&ty::TyUint(ity), i) => Err(TypeMismatch(ity.to_string(), i)),\n \n-        (&ty::TyEnum(ref adt, _), i) => {\n+        (&ty::TyAdt(adt, _), i) if adt.is_enum() => {\n             let hints = tcx.lookup_repr_hints(adt.did);\n             let int_ty = tcx.enum_repr_type(hints.iter().next());\n             infer(i, tcx, &int_ty.to_ty(tcx).sty)\n@@ -1230,7 +1229,7 @@ fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n                     infer(Infer(n), tcx, &ty::TyUint(uty)).map(Integral)\n                 },\n                 None => Ok(Integral(Infer(n))),\n-                Some(&ty::TyEnum(ref adt, _)) => {\n+                Some(&ty::TyAdt(adt, _)) => {\n                     let hints = tcx.lookup_repr_hints(adt.did);\n                     let int_ty = tcx.enum_repr_type(hints.iter().next());\n                     infer(Infer(n), tcx, &int_ty.to_ty(tcx).sty).map(Integral)"}, {"sha": "b610a924a339666e264c515538af7a7a32ffc0f8", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -468,21 +468,21 @@ impl LateLintPass for MissingCopyImplementations {\n                     return;\n                 }\n                 let def = cx.tcx.lookup_adt_def(cx.tcx.map.local_def_id(item.id));\n-                (def, cx.tcx.mk_struct(def, Substs::empty(cx.tcx)))\n+                (def, cx.tcx.mk_adt(def, Substs::empty(cx.tcx)))\n             }\n             hir::ItemUnion(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n                 let def = cx.tcx.lookup_adt_def(cx.tcx.map.local_def_id(item.id));\n-                (def, cx.tcx.mk_union(def, Substs::empty(cx.tcx)))\n+                (def, cx.tcx.mk_adt(def, Substs::empty(cx.tcx)))\n             }\n             hir::ItemEnum(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n                 let def = cx.tcx.lookup_adt_def(cx.tcx.map.local_def_id(item.id));\n-                (def, cx.tcx.mk_enum(def, Substs::empty(cx.tcx)))\n+                (def, cx.tcx.mk_adt(def, Substs::empty(cx.tcx)))\n             }\n             _ => return,\n         };"}, {"sha": "a6049acdb10d431e75bf87d130915c23644c907e", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 89, "deletions": 87, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -12,7 +12,7 @@\n \n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n use rustc::ty::layout::{Layout, Primitive};\n use rustc::traits::Reveal;\n use middle::const_val::ConstVal;\n@@ -431,110 +431,112 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n \n         match ty.sty {\n-            ty::TyStruct(def, substs) => {\n-                if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n-                    return FfiUnsafe(\n-                        \"found struct without foreign-function-safe \\\n-                         representation annotation in foreign module, \\\n-                         consider adding a #[repr(C)] attribute to \\\n-                         the type\");\n-                }\n+            ty::TyAdt(def, substs) => match def.adt_kind() {\n+                AdtKind::Struct => {\n+                    if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n+                        return FfiUnsafe(\n+                            \"found struct without foreign-function-safe \\\n+                            representation annotation in foreign module, \\\n+                            consider adding a #[repr(C)] attribute to \\\n+                            the type\");\n+                    }\n \n-                // We can't completely trust repr(C) markings; make sure the\n-                // fields are actually safe.\n-                if def.struct_variant().fields.is_empty() {\n-                    return FfiUnsafe(\n-                        \"found zero-size struct in foreign module, consider \\\n-                         adding a member to this struct\");\n-                }\n+                    // We can't completely trust repr(C) markings; make sure the\n+                    // fields are actually safe.\n+                    if def.struct_variant().fields.is_empty() {\n+                        return FfiUnsafe(\n+                            \"found zero-size struct in foreign module, consider \\\n+                            adding a member to this struct\");\n+                    }\n \n-                for field in &def.struct_variant().fields {\n-                    let field_ty = cx.normalize_associated_type(&field.ty(cx, substs));\n-                    let r = self.check_type_for_ffi(cache, field_ty);\n-                    match r {\n-                        FfiSafe => {}\n-                        FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => { return r; }\n-                        FfiUnsafe(s) => { return FfiBadStruct(def.did, s); }\n+                    for field in &def.struct_variant().fields {\n+                        let field_ty = cx.normalize_associated_type(&field.ty(cx, substs));\n+                        let r = self.check_type_for_ffi(cache, field_ty);\n+                        match r {\n+                            FfiSafe => {}\n+                            FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => { return r; }\n+                            FfiUnsafe(s) => { return FfiBadStruct(def.did, s); }\n+                        }\n                     }\n+                    FfiSafe\n                 }\n-                FfiSafe\n-            }\n-            ty::TyUnion(def, substs) => {\n-                if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n-                    return FfiUnsafe(\n-                        \"found union without foreign-function-safe \\\n-                         representation annotation in foreign module, \\\n-                         consider adding a #[repr(C)] attribute to \\\n-                         the type\");\n-                }\n+                AdtKind::Union => {\n+                    if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n+                        return FfiUnsafe(\n+                            \"found union without foreign-function-safe \\\n+                            representation annotation in foreign module, \\\n+                            consider adding a #[repr(C)] attribute to \\\n+                            the type\");\n+                    }\n \n-                for field in &def.struct_variant().fields {\n-                    let field_ty = cx.normalize_associated_type(&field.ty(cx, substs));\n-                    let r = self.check_type_for_ffi(cache, field_ty);\n-                    match r {\n-                        FfiSafe => {}\n-                        FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => { return r; }\n-                        FfiUnsafe(s) => { return FfiBadUnion(def.did, s); }\n+                    for field in &def.struct_variant().fields {\n+                        let field_ty = cx.normalize_associated_type(&field.ty(cx, substs));\n+                        let r = self.check_type_for_ffi(cache, field_ty);\n+                        match r {\n+                            FfiSafe => {}\n+                            FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => { return r; }\n+                            FfiUnsafe(s) => { return FfiBadUnion(def.did, s); }\n+                        }\n                     }\n+                    FfiSafe\n                 }\n-                FfiSafe\n-            }\n-            ty::TyEnum(def, substs) => {\n-                if def.variants.is_empty() {\n-                    // Empty enums are okay... although sort of useless.\n-                    return FfiSafe\n-                }\n+                AdtKind::Enum => {\n+                    if def.variants.is_empty() {\n+                        // Empty enums are okay... although sort of useless.\n+                        return FfiSafe\n+                    }\n \n-                // Check for a repr() attribute to specify the size of the\n-                // discriminant.\n-                let repr_hints = cx.lookup_repr_hints(def.did);\n-                match &repr_hints[..] {\n-                    &[] => {\n-                        // Special-case types like `Option<extern fn()>`.\n-                        if !is_repr_nullable_ptr(cx, def, substs) {\n-                            return FfiUnsafe(\n-                                \"found enum without foreign-function-safe \\\n-                                 representation annotation in foreign module, \\\n-                                 consider adding a #[repr(...)] attribute to \\\n-                                 the type\")\n+                    // Check for a repr() attribute to specify the size of the\n+                    // discriminant.\n+                    let repr_hints = cx.lookup_repr_hints(def.did);\n+                    match &repr_hints[..] {\n+                        &[] => {\n+                            // Special-case types like `Option<extern fn()>`.\n+                            if !is_repr_nullable_ptr(cx, def, substs) {\n+                                return FfiUnsafe(\n+                                    \"found enum without foreign-function-safe \\\n+                                    representation annotation in foreign module, \\\n+                                    consider adding a #[repr(...)] attribute to \\\n+                                    the type\")\n+                            }\n                         }\n-                    }\n-                    &[ref hint] => {\n-                        if !hint.is_ffi_safe() {\n+                        &[ref hint] => {\n+                            if !hint.is_ffi_safe() {\n+                                // FIXME: This shouldn't be reachable: we should check\n+                                // this earlier.\n+                                return FfiUnsafe(\n+                                    \"enum has unexpected #[repr(...)] attribute\")\n+                            }\n+\n+                            // Enum with an explicitly sized discriminant; either\n+                            // a C-style enum or a discriminated union.\n+\n+                            // The layout of enum variants is implicitly repr(C).\n+                            // FIXME: Is that correct?\n+                        }\n+                        _ => {\n                             // FIXME: This shouldn't be reachable: we should check\n                             // this earlier.\n                             return FfiUnsafe(\n-                                \"enum has unexpected #[repr(...)] attribute\")\n+                                \"enum has too many #[repr(...)] attributes\");\n                         }\n-\n-                        // Enum with an explicitly sized discriminant; either\n-                        // a C-style enum or a discriminated union.\n-\n-                        // The layout of enum variants is implicitly repr(C).\n-                        // FIXME: Is that correct?\n-                    }\n-                    _ => {\n-                        // FIXME: This shouldn't be reachable: we should check\n-                        // this earlier.\n-                        return FfiUnsafe(\n-                            \"enum has too many #[repr(...)] attributes\");\n                     }\n-                }\n \n-                // Check the contained variants.\n-                for variant in &def.variants {\n-                    for field in &variant.fields {\n-                        let arg = cx.normalize_associated_type(&field.ty(cx, substs));\n-                        let r = self.check_type_for_ffi(cache, arg);\n-                        match r {\n-                            FfiSafe => {}\n-                            FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => { return r; }\n-                            FfiUnsafe(s) => { return FfiBadEnum(def.did, s); }\n+                    // Check the contained variants.\n+                    for variant in &def.variants {\n+                        for field in &variant.fields {\n+                            let arg = cx.normalize_associated_type(&field.ty(cx, substs));\n+                            let r = self.check_type_for_ffi(cache, arg);\n+                            match r {\n+                                FfiSafe => {}\n+                                FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => { return r; }\n+                                FfiUnsafe(s) => { return FfiBadEnum(def.did, s); }\n+                            }\n                         }\n                     }\n+                    FfiSafe\n                 }\n-                FfiSafe\n-            }\n+            },\n \n             ty::TyChar => {\n                 FfiUnsafe(\"found Rust type `char` in foreign module, while \\"}, {"sha": "d31f16df693569ed1a5270d3508901e86d859337", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -136,9 +136,7 @@ impl LateLintPass for UnusedResults {\n             ty::TyTuple(ref tys) if tys.is_empty() => return,\n             ty::TyNever => return,\n             ty::TyBool => return,\n-            ty::TyStruct(def, _) |\n-            ty::TyUnion(def, _) |\n-            ty::TyEnum(def, _) => {\n+            ty::TyAdt(def, _) => {\n                 let attrs = cx.tcx.get_attrs(def.did);\n                 check_must_use(cx, &attrs[..], s.span)\n             }"}, {"sha": "4dc06f0d024967e69983e89346c500a671955b4b", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -36,7 +36,7 @@ use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, DefIndex};\n use middle::lang_items;\n use rustc::ty::{ImplContainer, TraitContainer};\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, VariantKind};\n+use rustc::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable, VariantKind};\n \n use rustc_const_math::ConstInt;\n \n@@ -453,23 +453,19 @@ pub fn get_adt_def<'a, 'tcx>(cdata: Cmd,\n     let mut ctor_did = None;\n     let (kind, variants) = match item_family(doc) {\n         Enum => {\n-            (ty::AdtKind::Enum,\n-             get_enum_variants(cdata, doc))\n+            (AdtKind::Enum, get_enum_variants(cdata, doc))\n         }\n         Struct(..) => {\n             // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n             ctor_did = reader::maybe_get_doc(doc, tag_items_data_item_struct_ctor).map(|ctor_doc| {\n                 translated_def_id(cdata, ctor_doc)\n             });\n-            (ty::AdtKind::Struct,\n-             vec![get_struct_variant(cdata, doc, ctor_did.unwrap_or(did))])\n+            (AdtKind::Struct, vec![get_struct_variant(cdata, doc, ctor_did.unwrap_or(did))])\n         }\n         Union => {\n-            (ty::AdtKind::Union,\n-             vec![get_struct_variant(cdata, doc, did)])\n+            (AdtKind::Union, vec![get_struct_variant(cdata, doc, did)])\n         }\n-        _ => bug!(\"get_adt_def called on a non-ADT {:?} - {:?}\",\n-                  item_family(doc), did)\n+        _ => bug!(\"get_adt_def called on a non-ADT {:?} - {:?}\", item_family(doc), did)\n     };\n \n     let adt = tcx.intern_adt_def(did, kind, variants);\n@@ -481,8 +477,7 @@ pub fn get_adt_def<'a, 'tcx>(cdata: Cmd,\n     // this needs to be done *after* the variant is interned,\n     // to support recursive structures\n     for variant in &adt.variants {\n-        if variant.kind == ty::VariantKind::Tuple &&\n-            adt.adt_kind() == ty::AdtKind::Enum {\n+        if variant.kind == ty::VariantKind::Tuple && adt.is_enum() {\n             // tuple-like enum variant fields aren't real items - get the types\n             // from the ctor.\n             debug!(\"evaluating the ctor-type of {:?}\","}, {"sha": "bcaf1640bc41b0cd8a4efeb28fbce235dedcae0f", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -358,14 +358,6 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 }\n             }\n             'c' => return tcx.types.char,\n-            't' => {\n-                assert_eq!(self.next(), '[');\n-                let did = self.parse_def();\n-                let substs = self.parse_substs();\n-                assert_eq!(self.next(), ']');\n-                let def = self.tcx.lookup_adt_def(did);\n-                return tcx.mk_enum(def, substs);\n-            }\n             'x' => {\n                 assert_eq!(self.next(), '[');\n                 let trait_ref = ty::Binder(self.parse_existential_trait_ref());\n@@ -470,15 +462,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 let substs = self.parse_substs();\n                 assert_eq!(self.next(), ']');\n                 let def = self.tcx.lookup_adt_def(did);\n-                return self.tcx.mk_struct(def, substs);\n-            }\n-            'U' => {\n-                assert_eq!(self.next(), '[');\n-                let did = self.parse_def();\n-                let substs = self.parse_substs();\n-                assert_eq!(self.next(), ']');\n-                let def = self.tcx.lookup_adt_def(did);\n-                return self.tcx.mk_union(def, substs);\n+                return self.tcx.mk_adt(def, substs);\n             }\n             'k' => {\n                 assert_eq!(self.next(), '[');"}, {"sha": "8030abf6330e76a63b47f150b3b75fcb524a0868", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -97,11 +97,6 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n                 ast::FloatTy::F64 => write!(w, \"MF\"),\n             };\n         }\n-        ty::TyEnum(def, substs) => {\n-            write!(w, \"t[{}|\", (cx.ds)(cx.tcx, def.did));\n-            enc_substs(w, cx, substs);\n-            write!(w, \"]\");\n-        }\n         ty::TyTrait(ref obj) => {\n             write!(w, \"x[\");\n             enc_existential_trait_ref(w, cx, obj.principal.0);\n@@ -165,16 +160,11 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n         ty::TyParam(p) => {\n             write!(w, \"p[{}|{}]\", p.idx, p.name);\n         }\n-        ty::TyStruct(def, substs) => {\n+        ty::TyAdt(def, substs) => {\n             write!(w, \"a[{}|\", (cx.ds)(cx.tcx, def.did));\n             enc_substs(w, cx, substs);\n             write!(w, \"]\");\n         }\n-        ty::TyUnion(def, substs) => {\n-            write!(w, \"U[{}|\", (cx.ds)(cx.tcx, def.did));\n-            enc_substs(w, cx, substs);\n-            write!(w, \"]\");\n-        }\n         ty::TyClosure(def, substs) => {\n             write!(w, \"k[{}|\", (cx.ds)(cx.tcx, def));\n             enc_substs(w, cx, substs.func_substs);"}, {"sha": "a40571c5d859784125c247ea19cf785b6e8d1622", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -181,7 +181,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Adt {\n                 adt_def, variant_index, substs, fields, base\n             } => { // see (*) above\n-                let is_union = adt_def.adt_kind() == ty::AdtKind::Union;\n+                let is_union = adt_def.is_union();\n                 let active_field_index = if is_union { Some(fields[0].name.index()) } else { None };\n \n                 // first process the set of fields that were provided"}, {"sha": "4518f8cb373fab70fe023cce5e665c03d5ae77d6", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -19,7 +19,7 @@ use rustc::hir::def::Def;\n use rustc::middle::const_val::ConstVal;\n use rustc_const_eval as const_eval;\n use rustc::middle::region::CodeExtent;\n-use rustc::ty::{self, VariantDef, Ty};\n+use rustc::ty::{self, AdtKind, VariantDef, Ty};\n use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::mir::repr::*;\n use rustc::hir;\n@@ -459,48 +459,50 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprStruct(_, ref fields, ref base) => {\n             match expr_ty.sty {\n-                ty::TyStruct(adt, substs) | ty::TyUnion(adt, substs) => {\n-                    let field_refs = field_refs(&adt.variants[0], fields);\n-                    ExprKind::Adt {\n-                        adt_def: adt,\n-                        variant_index: 0,\n-                        substs: substs,\n-                        fields: field_refs,\n-                        base: base.as_ref().map(|base| {\n-                            FruInfo {\n-                                base: base.to_ref(),\n-                                field_types: cx.tcx.tables\n-                                    .borrow()\n-                                    .fru_field_types[&expr.id]\n-                                    .clone()\n-                            }\n-                        })\n+                ty::TyAdt(adt, substs) => match adt.adt_kind() {\n+                    AdtKind::Struct | AdtKind::Union => {\n+                        let field_refs = field_refs(&adt.variants[0], fields);\n+                        ExprKind::Adt {\n+                            adt_def: adt,\n+                            variant_index: 0,\n+                            substs: substs,\n+                            fields: field_refs,\n+                            base: base.as_ref().map(|base| {\n+                                FruInfo {\n+                                    base: base.to_ref(),\n+                                    field_types: cx.tcx.tables\n+                                        .borrow()\n+                                        .fru_field_types[&expr.id]\n+                                        .clone()\n+                                }\n+                            })\n+                        }\n                     }\n-                }\n-                ty::TyEnum(adt, substs) => {\n-                    match cx.tcx.expect_def(expr.id) {\n-                        Def::Variant(enum_id, variant_id) => {\n-                            debug_assert!(adt.did == enum_id);\n-                            assert!(base.is_none());\n-\n-                            let index = adt.variant_index_with_id(variant_id);\n-                            let field_refs = field_refs(&adt.variants[index], fields);\n-                            ExprKind::Adt {\n-                                adt_def: adt,\n-                                variant_index: index,\n-                                substs: substs,\n-                                fields: field_refs,\n-                                base: None\n+                    AdtKind::Enum => {\n+                        match cx.tcx.expect_def(expr.id) {\n+                            Def::Variant(enum_id, variant_id) => {\n+                                debug_assert!(adt.did == enum_id);\n+                                assert!(base.is_none());\n+\n+                                let index = adt.variant_index_with_id(variant_id);\n+                                let field_refs = field_refs(&adt.variants[index], fields);\n+                                ExprKind::Adt {\n+                                    adt_def: adt,\n+                                    variant_index: index,\n+                                    substs: substs,\n+                                    fields: field_refs,\n+                                    base: None\n+                                }\n+                            }\n+                            ref def => {\n+                                span_bug!(\n+                                    expr.span,\n+                                    \"unexpected def: {:?}\",\n+                                    def);\n                             }\n-                        }\n-                        ref def => {\n-                            span_bug!(\n-                                expr.span,\n-                                \"unexpected def: {:?}\",\n-                                def);\n                         }\n                     }\n-                }\n+                },\n                 _ => {\n                     span_bug!(\n                         expr.span,\n@@ -579,13 +581,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                              body: block::to_expr_ref(cx, body) },\n         hir::ExprField(ref source, name) => {\n             let index = match cx.tcx.expr_ty_adjusted(source).sty {\n-                ty::TyStruct(adt_def, _) | ty::TyUnion(adt_def, _) =>\n+                ty::TyAdt(adt_def, _) =>\n                     adt_def.variants[0].index_of_field_named(name.node),\n                 ref ty =>\n-                    span_bug!(\n-                        expr.span,\n-                        \"field of non-struct: {:?}\",\n-                        ty),\n+                    span_bug!(expr.span, \"field of non-ADT: {:?}\", ty),\n             };\n             let index = index.unwrap_or_else(|| {\n                 span_bug!(\n@@ -680,7 +679,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             ty::TyFnDef(..) => def_id,\n             // A unit struct which is used as a value. We return a completely different ExprKind\n             // here to account for this special case.\n-            ty::TyStruct(adt_def, substs) => return ExprKind::Adt {\n+            ty::TyAdt(adt_def, substs) => return ExprKind::Adt {\n                 adt_def: adt_def,\n                 variant_index: 0,\n                 substs: substs,\n@@ -694,7 +693,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             // expression.\n             ty::TyFnDef(..) => variant_id,\n             // A unit variant, similar special case to the struct case above.\n-            ty::TyEnum(adt_def, substs) => {\n+            ty::TyAdt(adt_def, substs) => {\n                 debug_assert!(adt_def.did == enum_id);\n                 let index = adt_def.variant_index_with_id(variant_id);\n                 return ExprKind::Adt {"}, {"sha": "3639b165eb5abb33cc09a44087acc8f7b5b4e4fb", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -198,8 +198,8 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n             PatKind::TupleStruct(_, ref subpatterns, ddpos) => {\n                 let pat_ty = self.cx.tcx.node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n-                    ty::TyStruct(adt_def, _) | ty::TyEnum(adt_def, _) => adt_def,\n-                    _ => span_bug!(pat.span, \"tuple struct pattern not applied to struct or enum\"),\n+                    ty::TyAdt(adt_def, _) => adt_def,\n+                    _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT\"),\n                 };\n                 let variant_def = adt_def.variant_of_def(self.cx.tcx.expect_def(pat.id));\n \n@@ -217,13 +217,11 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n             PatKind::Struct(_, ref fields, _) => {\n                 let pat_ty = self.cx.tcx.node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n-                    ty::TyStruct(adt_def, _) |\n-                    ty::TyUnion(adt_def, _) |\n-                    ty::TyEnum(adt_def, _) => adt_def,\n+                    ty::TyAdt(adt_def, _) => adt_def,\n                     _ => {\n                         span_bug!(\n                             pat.span,\n-                            \"struct pattern not applied to struct or enum\");\n+                            \"struct pattern not applied to an ADT\");\n                     }\n                 };\n                 let variant_def = adt_def.variant_of_def(self.cx.tcx.expect_def(pat.id));"}, {"sha": "7fda658185e0700f727c70eb0753b9c291f19828", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -218,7 +218,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             }\n             ProjectionElem::Downcast(adt_def1, index) =>\n                 match base_ty.sty {\n-                    ty::TyEnum(adt_def, substs) if adt_def == adt_def1 => {\n+                    ty::TyAdt(adt_def, substs) if adt_def.is_enum() && adt_def == adt_def1 => {\n                         if index >= adt_def.variants.len() {\n                             LvalueTy::Ty {\n                                 ty: span_mirbug_and_err!(\n@@ -281,10 +281,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 (&adt_def.variants[variant_index], substs)\n             }\n             LvalueTy::Ty { ty } => match ty.sty {\n-                ty::TyStruct(adt_def, substs) |\n-                ty::TyUnion(adt_def, substs) |\n-                ty::TyEnum(adt_def, substs)\n-                    if adt_def.is_univariant() => {\n+                ty::TyAdt(adt_def, substs) if adt_def.is_univariant() => {\n                         (&adt_def.variants[0], substs)\n                     }\n                 ty::TyTuple(tys) | ty::TyClosure(_, ty::ClosureSubsts {\n@@ -364,7 +361,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             StatementKind::SetDiscriminant{ ref lvalue, variant_index } => {\n                 let lvalue_type = lvalue.ty(mir, tcx).to_ty(tcx);\n                 let adt = match lvalue_type.sty {\n-                    TypeVariants::TyEnum(adt, _) => adt,\n+                    TypeVariants::TyAdt(adt, _) if adt.is_enum() => adt,\n                     _ => {\n                         span_bug!(stmt.source_info.span,\n                                   \"bad set discriminant ({:?} = {:?}): lhs is not an enum\",\n@@ -444,9 +441,10 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             TerminatorKind::Switch { ref discr, adt_def, ref targets } => {\n                 let discr_ty = discr.ty(mir, tcx).to_ty(tcx);\n                 match discr_ty.sty {\n-                    ty::TyEnum(def, _)\n-                        if def == adt_def && adt_def.variants.len() == targets.len()\n-                        => {},\n+                    ty::TyAdt(def, _) if def.is_enum() &&\n+                                         def == adt_def &&\n+                                         adt_def.variants.len() == targets.len()\n+                      => {},\n                     _ => {\n                         span_mirbug!(self, term, \"bad Switch ({:?} on {:?})\",\n                                      adt_def, discr_ty);"}, {"sha": "f919e42b6bd7d38d6de6f483f002192ee80ae70f", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -439,9 +439,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n /// instead of producing errors.\n fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node_ty: Ty<'tcx>) {\n     match node_ty.sty {\n-        ty::TyStruct(def, _) |\n-        ty::TyUnion(def, _) |\n-        ty::TyEnum(def, _) if def.has_dtor() => {\n+        ty::TyAdt(def, _) if def.has_dtor() => {\n             v.add_qualif(ConstQualif::NEEDS_DROP);\n         }\n         _ => {}"}, {"sha": "4012c1cb348895ef34f845594e5a65e411b6e6a7", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -384,11 +384,9 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n \n     // Checks that a field is in scope.\n     fn check_field(&mut self, span: Span, def: ty::AdtDef<'tcx>, field: ty::FieldDef<'tcx>) {\n-        if def.adt_kind() != ty::AdtKind::Enum &&\n-           !field.vis.is_accessible_from(self.curitem, &self.tcx.map) {\n-            let kind_descr = if def.adt_kind() == ty::AdtKind::Union { \"union\" } else { \"struct\" };\n+        if !def.is_enum() && !field.vis.is_accessible_from(self.curitem, &self.tcx.map) {\n             struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of {} `{}` is private\",\n-                      field.name, kind_descr, self.tcx.item_path_str(def.did))\n+                      field.name, def.variant_descr(), self.tcx.item_path_str(def.did))\n                 .span_label(span, &format!(\"field `{}` is private\", field.name))\n                 .emit();\n         }\n@@ -438,7 +436,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 // (i.e. `all_fields - fields`), just check them all,\n                 // unless the ADT is a union, then unmentioned fields\n                 // are not checked.\n-                if adt.adt_kind() == ty::AdtKind::Union {\n+                if adt.is_union() {\n                     for expr_field in expr_fields {\n                         self.check_field(expr.span, adt, variant.field_named(expr_field.name.node));\n                     }\n@@ -511,7 +509,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             }\n             PatKind::TupleStruct(_, ref fields, ddpos) => {\n                 match self.tcx.pat_ty(pattern).sty {\n-                    ty::TyStruct(def, _) => {\n+                    // enum fields have no privacy at this time\n+                    ty::TyAdt(def, _) if !def.is_enum() => {\n                         let expected_len = def.struct_variant().fields.len();\n                         for (i, field) in fields.iter().enumerate_and_adjust(expected_len, ddpos) {\n                             if let PatKind::Wild = field.node {\n@@ -520,9 +519,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                             self.check_field(field.span, def, &def.struct_variant().fields[i]);\n                         }\n                     }\n-                    ty::TyEnum(..) => {\n-                        // enum fields have no privacy at this time\n-                    }\n                     _ => {}\n                 }\n             }"}, {"sha": "27ee5765c99faab013c8861458c52b2444e6fc11", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -1338,7 +1338,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                 };\n                 let ty = &self.tcx.expr_ty_adjusted(&hir_node).sty;\n                 match *ty {\n-                    ty::TyStruct(def, _) => {\n+                    ty::TyAdt(def, _) => {\n                         let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);\n                         if !self.span.filter_generated(sub_span, ex.span) {\n                             self.dumper.variable_ref(VariableRefData {"}, {"sha": "868e3bb1f1b73e3e1de46a87c822a59ee0d806ac", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -420,7 +420,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     }\n                 };\n                 match self.tcx.expr_ty_adjusted(&hir_node).sty {\n-                    ty::TyStruct(def, _) | ty::TyUnion(def, _) => {\n+                    ty::TyAdt(def, _) if !def.is_enum() => {\n                         let f = def.struct_variant().field_named(ident.node.name);\n                         let sub_span = self.span_utils.span_for_last_ident(expr.span);\n                         filter!(self.span_utils, sub_span, expr.span, None);\n@@ -432,14 +432,14 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         }));\n                     }\n                     _ => {\n-                        debug!(\"Expected struct type, found {:?}\", ty);\n+                        debug!(\"Expected struct or union type, found {:?}\", ty);\n                         None\n                     }\n                 }\n             }\n             ast::ExprKind::Struct(ref path, ..) => {\n                 match self.tcx.expr_ty_adjusted(&hir_node).sty {\n-                    ty::TyStruct(def, _) | ty::TyUnion(def, _) => {\n+                    ty::TyAdt(def, _) if !def.is_enum() => {\n                         let sub_span = self.span_utils.span_for_last_ident(path.span);\n                         filter!(self.span_utils, sub_span, path.span, None);\n                         Some(Data::TypeRefData(TypeRefData {\n@@ -450,9 +450,9 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         }))\n                     }\n                     _ => {\n-                        // FIXME ty could legitimately be a TyEnum, but then we will fail\n+                        // FIXME ty could legitimately be an enum, but then we will fail\n                         // later if we try to look up the fields.\n-                        debug!(\"expected TyStruct, found {:?}\", ty);\n+                        debug!(\"expected struct or union, found {:?}\", ty);\n                         None\n                     }\n                 }"}, {"sha": "e8498363e45a31fe126fd0f4683f05f46bf5d501", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 151, "deletions": 149, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -49,7 +49,7 @@ use std::rc::Rc;\n \n use llvm::{ValueRef, True, IntEQ, IntNE};\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n use syntax::ast;\n use syntax::attr;\n use syntax::attr::IntType;\n@@ -179,172 +179,174 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyTuple(ref elems) => {\n             Univariant(mk_struct(cx, &elems[..], false, t))\n         }\n-        ty::TyStruct(def, substs) => {\n-            let ftys = def.struct_variant().fields.iter().map(|field| {\n-                monomorphize::field_ty(cx.tcx(), substs, field)\n-            }).collect::<Vec<_>>();\n-            let packed = cx.tcx().lookup_packed(def.did);\n-\n-            Univariant(mk_struct(cx, &ftys[..], packed, t))\n-        }\n-        ty::TyUnion(def, substs) => {\n-            let ftys = def.struct_variant().fields.iter().map(|field| {\n-                monomorphize::field_ty(cx.tcx(), substs, field)\n-            }).collect::<Vec<_>>();\n-            let packed = cx.tcx().lookup_packed(def.did);\n-            UntaggedUnion(mk_union(cx, &ftys[..], packed, t))\n-        }\n         ty::TyClosure(_, ref substs) => {\n             Univariant(mk_struct(cx, &substs.upvar_tys, false, t))\n         }\n-        ty::TyEnum(def, substs) => {\n-            let cases = get_cases(cx.tcx(), def, substs);\n-            let hint = *cx.tcx().lookup_repr_hints(def.did).get(0)\n-                .unwrap_or(&attr::ReprAny);\n-\n-            if cases.is_empty() {\n-                // Uninhabitable; represent as unit\n-                // (Typechecking will reject discriminant-sizing attrs.)\n-                assert_eq!(hint, attr::ReprAny);\n-                return Univariant(mk_struct(cx, &[], false, t));\n+        ty::TyAdt(def, substs) => match def.adt_kind() {\n+            AdtKind::Struct => {\n+                let ftys = def.struct_variant().fields.iter().map(|field| {\n+                    monomorphize::field_ty(cx.tcx(), substs, field)\n+                }).collect::<Vec<_>>();\n+                let packed = cx.tcx().lookup_packed(def.did);\n+\n+                Univariant(mk_struct(cx, &ftys[..], packed, t))\n             }\n-\n-            if cases.iter().all(|c| c.tys.is_empty()) {\n-                // All bodies empty -> intlike\n-                let discrs: Vec<_> = cases.iter().map(|c| Disr::from(c.discr)).collect();\n-                let bounds = IntBounds {\n-                    ulo: discrs.iter().min().unwrap().0,\n-                    uhi: discrs.iter().max().unwrap().0,\n-                    slo: discrs.iter().map(|n| n.0 as i64).min().unwrap(),\n-                    shi: discrs.iter().map(|n| n.0 as i64).max().unwrap()\n-                };\n-                return mk_cenum(cx, hint, &bounds);\n+            AdtKind::Union => {\n+                let ftys = def.struct_variant().fields.iter().map(|field| {\n+                    monomorphize::field_ty(cx.tcx(), substs, field)\n+                }).collect::<Vec<_>>();\n+                let packed = cx.tcx().lookup_packed(def.did);\n+                UntaggedUnion(mk_union(cx, &ftys[..], packed, t))\n             }\n+            AdtKind::Enum => {\n+                let cases = get_cases(cx.tcx(), def, substs);\n+                let hint = *cx.tcx().lookup_repr_hints(def.did).get(0)\n+                    .unwrap_or(&attr::ReprAny);\n+\n+                if cases.is_empty() {\n+                    // Uninhabitable; represent as unit\n+                    // (Typechecking will reject discriminant-sizing attrs.)\n+                    assert_eq!(hint, attr::ReprAny);\n+                    return Univariant(mk_struct(cx, &[], false, t));\n+                }\n \n-            // Since there's at least one\n-            // non-empty body, explicit discriminants should have\n-            // been rejected by a checker before this point.\n-            if !cases.iter().enumerate().all(|(i,c)| c.discr == Disr::from(i)) {\n-                bug!(\"non-C-like enum {} with specified discriminants\",\n-                     cx.tcx().item_path_str(def.did));\n-            }\n+                if cases.iter().all(|c| c.tys.is_empty()) {\n+                    // All bodies empty -> intlike\n+                    let discrs: Vec<_> = cases.iter().map(|c| Disr::from(c.discr)).collect();\n+                    let bounds = IntBounds {\n+                        ulo: discrs.iter().min().unwrap().0,\n+                        uhi: discrs.iter().max().unwrap().0,\n+                        slo: discrs.iter().map(|n| n.0 as i64).min().unwrap(),\n+                        shi: discrs.iter().map(|n| n.0 as i64).max().unwrap()\n+                    };\n+                    return mk_cenum(cx, hint, &bounds);\n+                }\n \n-            if cases.len() == 1 && hint == attr::ReprAny {\n-                // Equivalent to a struct/tuple/newtype.\n-                return Univariant(mk_struct(cx, &cases[0].tys, false, t));\n-            }\n+                // Since there's at least one\n+                // non-empty body, explicit discriminants should have\n+                // been rejected by a checker before this point.\n+                if !cases.iter().enumerate().all(|(i,c)| c.discr == Disr::from(i)) {\n+                    bug!(\"non-C-like enum {} with specified discriminants\",\n+                        cx.tcx().item_path_str(def.did));\n+                }\n \n-            if cases.len() == 2 && hint == attr::ReprAny {\n-                // Nullable pointer optimization\n-                let mut discr = 0;\n-                while discr < 2 {\n-                    if cases[1 - discr].is_zerolen(cx, t) {\n-                        let st = mk_struct(cx, &cases[discr].tys,\n-                                           false, t);\n-                        match cases[discr].find_ptr(cx) {\n-                            Some(ref df) if df.len() == 1 && st.fields.len() == 1 => {\n-                                return RawNullablePointer {\n-                                    nndiscr: Disr::from(discr),\n-                                    nnty: st.fields[0],\n-                                    nullfields: cases[1 - discr].tys.clone()\n-                                };\n-                            }\n-                            Some(mut discrfield) => {\n-                                discrfield.push(0);\n-                                discrfield.reverse();\n-                                return StructWrappedNullablePointer {\n-                                    nndiscr: Disr::from(discr),\n-                                    nonnull: st,\n-                                    discrfield: discrfield,\n-                                    nullfields: cases[1 - discr].tys.clone()\n-                                };\n+                if cases.len() == 1 && hint == attr::ReprAny {\n+                    // Equivalent to a struct/tuple/newtype.\n+                    return Univariant(mk_struct(cx, &cases[0].tys, false, t));\n+                }\n+\n+                if cases.len() == 2 && hint == attr::ReprAny {\n+                    // Nullable pointer optimization\n+                    let mut discr = 0;\n+                    while discr < 2 {\n+                        if cases[1 - discr].is_zerolen(cx, t) {\n+                            let st = mk_struct(cx, &cases[discr].tys,\n+                                            false, t);\n+                            match cases[discr].find_ptr(cx) {\n+                                Some(ref df) if df.len() == 1 && st.fields.len() == 1 => {\n+                                    return RawNullablePointer {\n+                                        nndiscr: Disr::from(discr),\n+                                        nnty: st.fields[0],\n+                                        nullfields: cases[1 - discr].tys.clone()\n+                                    };\n+                                }\n+                                Some(mut discrfield) => {\n+                                    discrfield.push(0);\n+                                    discrfield.reverse();\n+                                    return StructWrappedNullablePointer {\n+                                        nndiscr: Disr::from(discr),\n+                                        nonnull: st,\n+                                        discrfield: discrfield,\n+                                        nullfields: cases[1 - discr].tys.clone()\n+                                    };\n+                                }\n+                                None => {}\n                             }\n-                            None => {}\n                         }\n+                        discr += 1;\n                     }\n-                    discr += 1;\n                 }\n-            }\n \n-            // The general case.\n-            assert!((cases.len() - 1) as i64 >= 0);\n-            let bounds = IntBounds { ulo: 0, uhi: (cases.len() - 1) as u64,\n-                                     slo: 0, shi: (cases.len() - 1) as i64 };\n-            let min_ity = range_to_inttype(cx, hint, &bounds);\n-\n-            // Create the set of structs that represent each variant\n-            // Use the minimum integer type we figured out above\n-            let fields : Vec<_> = cases.iter().map(|c| {\n-                let mut ftys = vec!(ty_of_inttype(cx.tcx(), min_ity));\n-                ftys.extend_from_slice(&c.tys);\n-                mk_struct(cx, &ftys, false, t)\n-            }).collect();\n-\n-\n-            // Check to see if we should use a different type for the\n-            // discriminant. If the overall alignment of the type is\n-            // the same as the first field in each variant, we can safely use\n-            // an alignment-sized type.\n-            // We increase the size of the discriminant to avoid LLVM copying\n-            // padding when it doesn't need to. This normally causes unaligned\n-            // load/stores and excessive memcpy/memset operations. By using a\n-            // bigger integer size, LLVM can be sure about it's contents and\n-            // won't be so conservative.\n-            // This check is needed to avoid increasing the size of types when\n-            // the alignment of the first field is smaller than the overall\n-            // alignment of the type.\n-            let (_, align) = union_size_and_align(&fields);\n-            let mut use_align = true;\n-            for st in &fields {\n-                // Get the first non-zero-sized field\n-                let field = st.fields.iter().skip(1).filter(|ty| {\n-                    let t = type_of::sizing_type_of(cx, **ty);\n-                    machine::llsize_of_real(cx, t) != 0 ||\n-                    // This case is only relevant for zero-sized types with large alignment\n-                    machine::llalign_of_min(cx, t) != 1\n-                }).next();\n-\n-                if let Some(field) = field {\n-                    let field_align = type_of::align_of(cx, *field);\n-                    if field_align != align {\n-                        use_align = false;\n-                        break;\n+                // The general case.\n+                assert!((cases.len() - 1) as i64 >= 0);\n+                let bounds = IntBounds { ulo: 0, uhi: (cases.len() - 1) as u64,\n+                                        slo: 0, shi: (cases.len() - 1) as i64 };\n+                let min_ity = range_to_inttype(cx, hint, &bounds);\n+\n+                // Create the set of structs that represent each variant\n+                // Use the minimum integer type we figured out above\n+                let fields : Vec<_> = cases.iter().map(|c| {\n+                    let mut ftys = vec!(ty_of_inttype(cx.tcx(), min_ity));\n+                    ftys.extend_from_slice(&c.tys);\n+                    mk_struct(cx, &ftys, false, t)\n+                }).collect();\n+\n+\n+                // Check to see if we should use a different type for the\n+                // discriminant. If the overall alignment of the type is\n+                // the same as the first field in each variant, we can safely use\n+                // an alignment-sized type.\n+                // We increase the size of the discriminant to avoid LLVM copying\n+                // padding when it doesn't need to. This normally causes unaligned\n+                // load/stores and excessive memcpy/memset operations. By using a\n+                // bigger integer size, LLVM can be sure about it's contents and\n+                // won't be so conservative.\n+                // This check is needed to avoid increasing the size of types when\n+                // the alignment of the first field is smaller than the overall\n+                // alignment of the type.\n+                let (_, align) = union_size_and_align(&fields);\n+                let mut use_align = true;\n+                for st in &fields {\n+                    // Get the first non-zero-sized field\n+                    let field = st.fields.iter().skip(1).filter(|ty| {\n+                        let t = type_of::sizing_type_of(cx, **ty);\n+                        machine::llsize_of_real(cx, t) != 0 ||\n+                        // This case is only relevant for zero-sized types with large alignment\n+                        machine::llalign_of_min(cx, t) != 1\n+                    }).next();\n+\n+                    if let Some(field) = field {\n+                        let field_align = type_of::align_of(cx, *field);\n+                        if field_align != align {\n+                            use_align = false;\n+                            break;\n+                        }\n                     }\n                 }\n-            }\n \n-            // If the alignment is smaller than the chosen discriminant size, don't use the\n-            // alignment as the final size.\n-            let min_ty = ll_inttype(&cx, min_ity);\n-            let min_size = machine::llsize_of_real(cx, min_ty);\n-            if (align as u64) < min_size {\n-                use_align = false;\n-            }\n-\n-            let ity = if use_align {\n-                // Use the overall alignment\n-                match align {\n-                    1 => attr::UnsignedInt(ast::UintTy::U8),\n-                    2 => attr::UnsignedInt(ast::UintTy::U16),\n-                    4 => attr::UnsignedInt(ast::UintTy::U32),\n-                    8 if machine::llalign_of_min(cx, Type::i64(cx)) == 8 =>\n-                        attr::UnsignedInt(ast::UintTy::U64),\n-                    _ => min_ity // use min_ity as a fallback\n+                // If the alignment is smaller than the chosen discriminant size, don't use the\n+                // alignment as the final size.\n+                let min_ty = ll_inttype(&cx, min_ity);\n+                let min_size = machine::llsize_of_real(cx, min_ty);\n+                if (align as u64) < min_size {\n+                    use_align = false;\n                 }\n-            } else {\n-                min_ity\n-            };\n \n-            let fields : Vec<_> = cases.iter().map(|c| {\n-                let mut ftys = vec!(ty_of_inttype(cx.tcx(), ity));\n-                ftys.extend_from_slice(&c.tys);\n-                mk_struct(cx, &ftys[..], false, t)\n-            }).collect();\n+                let ity = if use_align {\n+                    // Use the overall alignment\n+                    match align {\n+                        1 => attr::UnsignedInt(ast::UintTy::U8),\n+                        2 => attr::UnsignedInt(ast::UintTy::U16),\n+                        4 => attr::UnsignedInt(ast::UintTy::U32),\n+                        8 if machine::llalign_of_min(cx, Type::i64(cx)) == 8 =>\n+                            attr::UnsignedInt(ast::UintTy::U64),\n+                        _ => min_ity // use min_ity as a fallback\n+                    }\n+                } else {\n+                    min_ity\n+                };\n \n-            ensure_enum_fits_in_address_space(cx, &fields[..], t);\n+                let fields : Vec<_> = cases.iter().map(|c| {\n+                    let mut ftys = vec!(ty_of_inttype(cx.tcx(), ity));\n+                    ftys.extend_from_slice(&c.tys);\n+                    mk_struct(cx, &ftys[..], false, t)\n+                }).collect();\n \n-            General(ity, fields)\n-        }\n+                ensure_enum_fits_in_address_space(cx, &fields[..], t);\n+\n+                General(ity, fields)\n+            }\n+        },\n         _ => bug!(\"adt::represent_type called on non-ADT type: {}\", t)\n     }\n }\n@@ -376,7 +378,7 @@ fn find_discr_field_candidate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ty::TyFnPtr(_) => Some(path),\n \n         // Is this the NonZero lang item wrapping a pointer or integer type?\n-        ty::TyStruct(def, substs) if Some(def.did) == tcx.lang_items.non_zero() => {\n+        ty::TyAdt(def, substs) if Some(def.did) == tcx.lang_items.non_zero() => {\n             let nonzero_fields = &def.struct_variant().fields;\n             assert_eq!(nonzero_fields.len(), 1);\n             let field_ty = monomorphize::field_ty(tcx, substs, &nonzero_fields[0]);\n@@ -395,7 +397,7 @@ fn find_discr_field_candidate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         // Perhaps one of the fields of this struct is non-zero\n         // let's recurse and find out\n-        ty::TyStruct(def, substs) => {\n+        ty::TyAdt(def, substs) if def.is_struct() => {\n             for (j, field) in def.struct_variant().fields.iter().enumerate() {\n                 let field_ty = monomorphize::field_ty(tcx, substs, field);\n                 if let Some(mut fpath) = find_discr_field_candidate(tcx, field_ty, path.clone()) {"}, {"sha": "a6581ae605b56600e26d91482b2651ca2b0b1824", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -467,8 +467,7 @@ pub fn coerce_unsized_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n \n         // This can be extended to enums and tuples in the future.\n-        // (&ty::TyEnum(def_id_a, _), &ty::TyEnum(def_id_b, _)) |\n-        (&ty::TyStruct(def_a, _), &ty::TyStruct(def_b, _)) => {\n+        (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n             let src_repr = adt::represent_type(bcx.ccx(), src_ty);"}, {"sha": "5a8ab62a2aa2d4f18d09b65b8e940996617365c4", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -743,9 +743,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     // If the type implements Drop, also add a translation item for the\n     // monomorphized Drop::drop() implementation.\n     let destructor_did = match ty.sty {\n-        ty::TyStruct(def, _) |\n-        ty::TyUnion(def, _) |\n-        ty::TyEnum(def, _)   => def.destructor(),\n+        ty::TyAdt(def, _) => def.destructor(),\n         _ => None\n     };\n \n@@ -798,9 +796,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         ty::TyTrait(_)  => {\n             /* nothing to do */\n         }\n-        ty::TyStruct(ref adt_def, substs) |\n-        ty::TyUnion(ref adt_def, substs) |\n-        ty::TyEnum(ref adt_def, substs) => {\n+        ty::TyAdt(adt_def, substs) => {\n             for field in adt_def.all_fields() {\n                 let field_type = monomorphize::apply_param_substs(scx,\n                                                                   substs,\n@@ -989,8 +985,8 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             }\n         }\n \n-        (&ty::TyStruct(source_adt_def, source_substs),\n-         &ty::TyStruct(target_adt_def, target_substs)) => {\n+        (&ty::TyAdt(source_adt_def, source_substs),\n+         &ty::TyAdt(target_adt_def, target_substs)) => {\n             assert_eq!(source_adt_def, target_adt_def);\n \n             let kind = custom_coerce_unsize_info(scx, source_ty, target_ty);"}, {"sha": "e0de04d150ca7446adba00b9ab1b5fafe4851a3d", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -88,8 +88,7 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n         return false;\n     }\n     match ty.sty {\n-        ty::TyStruct(..) | ty::TyUnion(..) | ty::TyEnum(..) |\n-        ty::TyTuple(..) | ty::TyArray(..) | ty::TyClosure(..) => {\n+        ty::TyAdt(..) | ty::TyTuple(..) | ty::TyArray(..) | ty::TyClosure(..) => {\n             let llty = sizing_type_of(ccx, ty);\n             llsize_of_alloc(ccx, llty) <= llsize_of_alloc(ccx, ccx.int_type())\n         }\n@@ -101,7 +100,7 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n pub fn type_pair_fields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n                                   -> Option<[Ty<'tcx>; 2]> {\n     match ty.sty {\n-        ty::TyEnum(adt, substs) | ty::TyStruct(adt, substs) => {\n+        ty::TyAdt(adt, substs) => {\n             assert_eq!(adt.variants.len(), 1);\n             let fields = &adt.variants[0].fields;\n             if fields.len() != 2 {\n@@ -205,7 +204,7 @@ impl<'a, 'tcx> VariantInfo<'tcx> {\n                    -> Self\n     {\n         match ty.sty {\n-            ty::TyStruct(adt, substs) | ty::TyUnion(adt, substs) | ty::TyEnum(adt, substs) => {\n+            ty::TyAdt(adt, substs) => {\n                 let variant = match opt_def {\n                     None => adt.struct_variant(),\n                     Some(def) => adt.variant_of_def(def)"}, {"sha": "b10129d1019aefc2b5ba4e6c5c75d57e4272201e", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -223,13 +223,9 @@ impl<'gcx> DepTrackingMapConfig for ProjectionCache<'gcx> {\n         let def_ids: Vec<DefId> =\n             key.walk()\n                .filter_map(|t| match t.sty {\n-                   ty::TyStruct(adt_def, _) |\n-                   ty::TyEnum(adt_def, _) =>\n-                       Some(adt_def.did),\n-                   ty::TyProjection(ref proj) =>\n-                       Some(proj.trait_ref.def_id),\n-                   _ =>\n-                       None\n+                   ty::TyAdt(adt_def, _) => Some(adt_def.did),\n+                   ty::TyProjection(ref proj) => Some(proj.trait_ref.def_id),\n+                   _ => None,\n                })\n                .collect();\n         DepNode::TraitSelect(def_ids)"}, {"sha": "31df49609cb8bf360afceb6d2594f9dc3a9a4f0d", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -30,7 +30,7 @@ use rustc::hir;\n use {type_of, adt, machine, monomorphize};\n use common::CrateContext;\n use type_::Type;\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, AdtKind, Ty};\n use session::config;\n use util::nodemap::FnvHashMap;\n use util::common::path2cstr;\n@@ -176,18 +176,10 @@ impl<'tcx> TypeMap<'tcx> {\n             ty::TyFloat(_) => {\n                 push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n             },\n-            ty::TyEnum(def, substs) => {\n-                unique_type_id.push_str(\"enum \");\n+            ty::TyAdt(def, substs) => {\n+                unique_type_id.push_str(&(String::from(def.descr()) + \" \"));\n                 from_def_id_and_substs(self, cx, def.did, substs, &mut unique_type_id);\n-            },\n-            ty::TyStruct(def, substs) => {\n-                unique_type_id.push_str(\"struct \");\n-                from_def_id_and_substs(self, cx, def.did, substs, &mut unique_type_id);\n-            },\n-            ty::TyUnion(def, substs) => {\n-                unique_type_id.push_str(\"union \");\n-                from_def_id_and_substs(self, cx, def.did, substs, &mut unique_type_id);\n-            },\n+            }\n             ty::TyTuple(component_types) if component_types.is_empty() => {\n                 push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n             },\n@@ -705,13 +697,6 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyTuple(ref elements) if elements.is_empty() => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n-        ty::TyEnum(def, _) => {\n-            prepare_enum_metadata(cx,\n-                                  t,\n-                                  def.did,\n-                                  unique_type_id,\n-                                  usage_site_span).finalize(cx)\n-        }\n         ty::TyArray(typ, len) => {\n             fixed_vec_metadata(cx, unique_type_id, typ, Some(len as u64), usage_site_span)\n         }\n@@ -779,18 +764,27 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }\n-        ty::TyStruct(..) => {\n-            prepare_struct_metadata(cx,\n+        ty::TyAdt(def, ..) => match def.adt_kind() {\n+            AdtKind::Struct => {\n+                prepare_struct_metadata(cx,\n+                                        t,\n+                                        unique_type_id,\n+                                        usage_site_span).finalize(cx)\n+            }\n+            AdtKind::Union => {\n+                prepare_union_metadata(cx,\n                                     t,\n                                     unique_type_id,\n                                     usage_site_span).finalize(cx)\n-        }\n-        ty::TyUnion(..) => {\n-            prepare_union_metadata(cx,\n-                                   t,\n-                                   unique_type_id,\n-                                   usage_site_span).finalize(cx)\n-        }\n+            }\n+            AdtKind::Enum => {\n+                prepare_enum_metadata(cx,\n+                                    t,\n+                                    def.did,\n+                                    unique_type_id,\n+                                    usage_site_span).finalize(cx)\n+            }\n+        },\n         ty::TyTuple(ref elements) => {\n             prepare_tuple_metadata(cx,\n                                    t,\n@@ -1134,8 +1128,8 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let struct_llvm_type = type_of::in_memory_type_of(cx, struct_type);\n \n     let (struct_def_id, variant, substs) = match struct_type.sty {\n-        ty::TyStruct(def, substs) => (def.did, def.struct_variant(), substs),\n-        _ => bug!(\"prepare_struct_metadata on a non-struct\")\n+        ty::TyAdt(def, substs) => (def.did, def.struct_variant(), substs),\n+        _ => bug!(\"prepare_struct_metadata on a non-ADT\")\n     };\n \n     let (containing_scope, _) = get_namespace_and_span_for_item(cx, struct_def_id);\n@@ -1250,8 +1244,8 @@ fn prepare_union_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let union_llvm_type = type_of::in_memory_type_of(cx, union_type);\n \n     let (union_def_id, variant, substs) = match union_type.sty {\n-        ty::TyUnion(def, substs) => (def.did, def.struct_variant(), substs),\n-        _ => bug!(\"prepare_union_metadata on a non-union\")\n+        ty::TyAdt(def, substs) => (def.did, def.struct_variant(), substs),\n+        _ => bug!(\"prepare_union_metadata on a non-ADT\")\n     };\n \n     let (containing_scope, _) = get_namespace_and_span_for_item(cx, union_def_id);"}, {"sha": "bcd288671bc1915370b2c35ee767960611243e21", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -421,7 +421,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 // Only \"class\" methods are generally understood by LLVM,\n                 // so avoid methods on other types (e.g. `<*mut T>::null`).\n                 match impl_self_ty.sty {\n-                    ty::TyStruct(..) | ty::TyUnion(..) | ty::TyEnum(..) => {\n+                    ty::TyAdt(..) => {\n                         Some(type_metadata(cx, impl_self_ty, syntax_pos::DUMMY_SP))\n                     }\n                     _ => None"}, {"sha": "7f021bee371990d6ce82ff13b3500318d7b89353", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -44,9 +44,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyInt(int_ty) => output.push_str(int_ty.ty_to_string()),\n         ty::TyUint(uint_ty) => output.push_str(uint_ty.ty_to_string()),\n         ty::TyFloat(float_ty) => output.push_str(float_ty.ty_to_string()),\n-        ty::TyStruct(def, substs) |\n-        ty::TyUnion(def, substs) |\n-        ty::TyEnum(def, substs) => {\n+        ty::TyAdt(def, substs) => {\n             push_item_name(cx, def.did, qualified, output);\n             push_type_params(cx, substs, output);\n         },"}, {"sha": "6c1c5ac2d10e8efcd0609e2086d1fe91188d219a", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 82, "deletions": 81, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -19,7 +19,7 @@ use llvm::{ValueRef, get_param};\n use middle::lang_items::ExchangeFreeFnLangItem;\n use rustc::ty::subst::{Substs};\n use rustc::traits;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable};\n use adt;\n use base::*;\n use build::*;\n@@ -338,7 +338,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n         return (C_undef(llty), C_undef(llty));\n     }\n     match t.sty {\n-        ty::TyStruct(def, substs) => {\n+        ty::TyAdt(def, substs) => {\n             let ccx = bcx.ccx();\n             // First get the size of all statically known fields.\n             // Don't use type_of::sizing_type_of because that expects t to be sized,\n@@ -487,16 +487,11 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueK\n                  DebugLoc::None);\n             bcx\n         }\n-        ty::TyStruct(def, _) | ty::TyEnum(def, _)\n-                if def.dtor_kind().is_present() && !skip_dtor => {\n-            trans_custom_dtor(bcx, t, v0, false)\n+        ty::TyAdt(def, ..) if def.dtor_kind().is_present() && !skip_dtor => {\n+            trans_custom_dtor(bcx, t, v0, def.is_union())\n         }\n-        ty::TyUnion(def, _) => {\n-            if def.dtor_kind().is_present() && !skip_dtor {\n-                trans_custom_dtor(bcx, t, v0, true)\n-            } else {\n-                bcx\n-            }\n+        ty::TyAdt(def, ..) if def.is_union() => {\n+            bcx\n         }\n         _ => {\n             if bcx.fcx.type_needs_drop(t) {\n@@ -544,23 +539,6 @@ fn drop_structural_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n \n     let mut cx = cx;\n     match t.sty {\n-        ty::TyStruct(..) => {\n-            let repr = adt::represent_type(cx.ccx(), t);\n-            let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.tcx(), t, None);\n-            for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n-                let llfld_a = adt::trans_field_ptr(cx, &repr, value, Disr::from(discr), i);\n-\n-                let val = if type_is_sized(cx.tcx(), field_ty) {\n-                    llfld_a\n-                } else {\n-                    let scratch = alloc_ty(cx, field_ty, \"__fat_ptr_iter\");\n-                    Store(cx, llfld_a, get_dataptr(cx, scratch));\n-                    Store(cx, value.meta, get_meta(cx, scratch));\n-                    scratch\n-                };\n-                cx = drop_ty(cx, val, field_ty, DebugLoc::None);\n-            }\n-        }\n         ty::TyClosure(_, ref substs) => {\n             let repr = adt::represent_type(cx.ccx(), t);\n             for (i, upvar_ty) in substs.upvar_tys.iter().enumerate() {\n@@ -587,63 +565,86 @@ fn drop_structural_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                 cx = drop_ty(cx, llfld_a, *arg, DebugLoc::None);\n             }\n         }\n-        ty::TyEnum(en, substs) => {\n-            let fcx = cx.fcx;\n-            let ccx = fcx.ccx;\n-\n-            let repr = adt::represent_type(ccx, t);\n-            let n_variants = en.variants.len();\n-\n-            // NB: we must hit the discriminant first so that structural\n-            // comparison know not to proceed when the discriminants differ.\n-\n-            match adt::trans_switch(cx, &repr, av, false) {\n-                (adt::BranchKind::Single, None) => {\n-                    if n_variants != 0 {\n-                        assert!(n_variants == 1);\n-                        cx = iter_variant(cx, &repr, adt::MaybeSizedValue::sized(av),\n-                                          &en.variants[0], substs);\n-                    }\n+        ty::TyAdt(adt, substs) => match adt.adt_kind() {\n+            AdtKind::Struct => {\n+                let repr = adt::represent_type(cx.ccx(), t);\n+                let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.tcx(), t, None);\n+                for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n+                    let llfld_a = adt::trans_field_ptr(cx, &repr, value, Disr::from(discr), i);\n+\n+                    let val = if type_is_sized(cx.tcx(), field_ty) {\n+                        llfld_a\n+                    } else {\n+                        let scratch = alloc_ty(cx, field_ty, \"__fat_ptr_iter\");\n+                        Store(cx, llfld_a, get_dataptr(cx, scratch));\n+                        Store(cx, value.meta, get_meta(cx, scratch));\n+                        scratch\n+                    };\n+                    cx = drop_ty(cx, val, field_ty, DebugLoc::None);\n                 }\n-                (adt::BranchKind::Switch, Some(lldiscrim_a)) => {\n-                    cx = drop_ty(cx, lldiscrim_a, cx.tcx().types.isize, DebugLoc::None);\n-\n-                    // Create a fall-through basic block for the \"else\" case of\n-                    // the switch instruction we're about to generate. Note that\n-                    // we do **not** use an Unreachable instruction here, even\n-                    // though most of the time this basic block will never be hit.\n-                    //\n-                    // When an enum is dropped it's contents are currently\n-                    // overwritten to DTOR_DONE, which means the discriminant\n-                    // could have changed value to something not within the actual\n-                    // range of the discriminant. Currently this function is only\n-                    // used for drop glue so in this case we just return quickly\n-                    // from the outer function, and any other use case will only\n-                    // call this for an already-valid enum in which case the `ret\n-                    // void` will never be hit.\n-                    let ret_void_cx = fcx.new_block(\"enum-iter-ret-void\");\n-                    RetVoid(ret_void_cx, DebugLoc::None);\n-                    let llswitch = Switch(cx, lldiscrim_a, ret_void_cx.llbb, n_variants);\n-                    let next_cx = fcx.new_block(\"enum-iter-next\");\n-\n-                    for variant in &en.variants {\n-                        let variant_cx = fcx.new_block(&format!(\"enum-iter-variant-{}\",\n-                                                                     &variant.disr_val\n-                                                                             .to_string()));\n-                        let case_val = adt::trans_case(cx, &repr, Disr::from(variant.disr_val));\n-                        AddCase(llswitch, case_val, variant_cx.llbb);\n-                        let variant_cx = iter_variant(variant_cx,\n-                                                      &repr,\n-                                                      value,\n-                                                      variant,\n-                                                      substs);\n-                        Br(variant_cx, next_cx.llbb, DebugLoc::None);\n+            }\n+            AdtKind::Union => {\n+                bug!(\"Union in `glue::drop_structural_ty`\");\n+            }\n+            AdtKind::Enum => {\n+                let fcx = cx.fcx;\n+                let ccx = fcx.ccx;\n+\n+                let repr = adt::represent_type(ccx, t);\n+                let n_variants = adt.variants.len();\n+\n+                // NB: we must hit the discriminant first so that structural\n+                // comparison know not to proceed when the discriminants differ.\n+\n+                match adt::trans_switch(cx, &repr, av, false) {\n+                    (adt::BranchKind::Single, None) => {\n+                        if n_variants != 0 {\n+                            assert!(n_variants == 1);\n+                            cx = iter_variant(cx, &repr, adt::MaybeSizedValue::sized(av),\n+                                            &adt.variants[0], substs);\n+                        }\n                     }\n-                    cx = next_cx;\n+                    (adt::BranchKind::Switch, Some(lldiscrim_a)) => {\n+                        cx = drop_ty(cx, lldiscrim_a, cx.tcx().types.isize, DebugLoc::None);\n+\n+                        // Create a fall-through basic block for the \"else\" case of\n+                        // the switch instruction we're about to generate. Note that\n+                        // we do **not** use an Unreachable instruction here, even\n+                        // though most of the time this basic block will never be hit.\n+                        //\n+                        // When an enum is dropped it's contents are currently\n+                        // overwritten to DTOR_DONE, which means the discriminant\n+                        // could have changed value to something not within the actual\n+                        // range of the discriminant. Currently this function is only\n+                        // used for drop glue so in this case we just return quickly\n+                        // from the outer function, and any other use case will only\n+                        // call this for an already-valid enum in which case the `ret\n+                        // void` will never be hit.\n+                        let ret_void_cx = fcx.new_block(\"enum-iter-ret-void\");\n+                        RetVoid(ret_void_cx, DebugLoc::None);\n+                        let llswitch = Switch(cx, lldiscrim_a, ret_void_cx.llbb, n_variants);\n+                        let next_cx = fcx.new_block(\"enum-iter-next\");\n+\n+                        for variant in &adt.variants {\n+                            let variant_cx = fcx.new_block(&format!(\"enum-iter-variant-{}\",\n+                                                                        &variant.disr_val\n+                                                                                .to_string()));\n+                            let case_val = adt::trans_case(cx, &repr, Disr::from(variant.disr_val));\n+                            AddCase(llswitch, case_val, variant_cx.llbb);\n+                            let variant_cx = iter_variant(variant_cx,\n+                                                        &repr,\n+                                                        value,\n+                                                        variant,\n+                                                        substs);\n+                            Br(variant_cx, next_cx.llbb, DebugLoc::None);\n+                        }\n+                        cx = next_cx;\n+                    }\n+                    _ => ccx.sess().unimpl(\"value from adt::trans_switch in drop_structural_ty\"),\n                 }\n-                _ => ccx.sess().unimpl(\"value from adt::trans_switch in drop_structural_ty\"),\n             }\n-        }\n+        },\n+\n         _ => {\n             cx.sess().unimpl(&format!(\"type in drop_structural_ty: {}\", t))\n         }"}, {"sha": "2049696ee4f717ba704210c6aa4ed123c77022a8", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -408,7 +408,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, \"discriminant_value\") => {\n             let val_ty = substs.type_at(0);\n             match val_ty.sty {\n-                ty::TyEnum(..) => {\n+                ty::TyAdt(adt, ..) if adt.is_enum() => {\n                     let repr = adt::represent_type(ccx, val_ty);\n                     adt::trans_get_discr(bcx, &repr, llargs[0],\n                                          Some(llret_ty), true)"}, {"sha": "44e613c4c2b043ab40539722f5a3b13ff879ed8d", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -396,9 +396,7 @@ pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ty::TyUint(ast::UintTy::U64)  => output.push_str(\"u64\"),\n         ty::TyFloat(ast::FloatTy::F32) => output.push_str(\"f32\"),\n         ty::TyFloat(ast::FloatTy::F64) => output.push_str(\"f64\"),\n-        ty::TyStruct(adt_def, substs) |\n-        ty::TyUnion(adt_def, substs) |\n-        ty::TyEnum(adt_def, substs) => {\n+        ty::TyAdt(adt_def, substs) => {\n             push_item_name(tcx, adt_def.did, output);\n             push_type_params(tcx, substs, &[], output);\n         },"}, {"sha": "3873c24a9f676971b1c9cadd5e517331ef8d45f3", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -89,7 +89,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n             Type::nil(cx)\n         }\n \n-        ty::TyStruct(..) if t.is_simd() => {\n+        ty::TyAdt(..) if t.is_simd() => {\n             let e = t.simd_type(cx.tcx());\n             if !e.is_machine() {\n                 cx.sess().fatal(&format!(\"monomorphising SIMD type `{}` with \\\n@@ -102,8 +102,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n             Type::vector(&llet, n)\n         }\n \n-        ty::TyTuple(..) | ty::TyStruct(..) | ty::TyUnion(..) |\n-        ty::TyEnum(..) | ty::TyClosure(..) => {\n+        ty::TyTuple(..) | ty::TyAdt(..) | ty::TyClosure(..) => {\n             let repr = adt::represent_type(cx, t);\n             adt::sizing_type_of(cx, &repr, false)\n         }\n@@ -294,7 +293,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           let repr = adt::represent_type(cx, t);\n           adt::type_of(cx, &repr)\n       }\n-      ty::TyStruct(..) if t.is_simd() => {\n+      ty::TyAdt(..) if t.is_simd() => {\n           let e = t.simd_type(cx.tcx());\n           if !e.is_machine() {\n               cx.sess().fatal(&format!(\"monomorphising SIMD type `{}` with \\\n@@ -306,9 +305,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           ensure_array_fits_in_address_space(cx, llet, n, t);\n           Type::vector(&llet, n)\n       }\n-      ty::TyStruct(def, ref substs) |\n-      ty::TyUnion(def, ref substs) |\n-      ty::TyEnum(def, ref substs) => {\n+      ty::TyAdt(def, substs) => {\n           // Only create the named struct, but don't fill it in. We\n           // fill it in *after* placing it into the type cache. This\n           // avoids creating more than one copy of the enum when one\n@@ -331,8 +328,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n \n     // If this was an enum or struct, fill in the type now.\n     match t.sty {\n-        ty::TyEnum(..) | ty::TyStruct(..) | ty::TyUnion(..) | ty::TyClosure(..)\n-                if !t.is_simd() => {\n+        ty::TyAdt(..) | ty::TyClosure(..) if !t.is_simd() => {\n             let repr = adt::represent_type(cx, t);\n             adt::finish_type_of(cx, &repr, &mut llty);\n         }"}, {"sha": "dd3ac6ff2d457838be93c8ebeddecd4008a1d6c7", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -617,7 +617,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if subpats.len() == variant.fields.len() ||\n                 subpats.len() < variant.fields.len() && ddpos.is_some() {\n             let substs = match pat_ty.sty {\n-                ty::TyStruct(_, substs) | ty::TyEnum(_, substs) => substs,\n+                ty::TyAdt(_, substs) => substs,\n                 ref ty => bug!(\"unexpected pattern type {:?}\", ty),\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n@@ -657,9 +657,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx;\n \n         let (substs, kind_name) = match adt_ty.sty {\n-            ty::TyEnum(_, substs) => (substs, \"variant\"),\n-            ty::TyStruct(_, substs) => (substs, \"struct\"),\n-            ty::TyUnion(_, substs) => (substs, \"union\"),\n+            ty::TyAdt(adt, substs) => (substs, adt.variant_descr()),\n             _ => span_bug!(span, \"struct pattern is not an ADT\")\n         };\n "}, {"sha": "51a9b18392dcf332f93eaca5b7fa9e632f6fcd9a", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -79,7 +79,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match t.sty {\n             ty::TySlice(_) | ty::TyStr => Some(UnsizeKind::Length),\n             ty::TyTrait(ref tty) => Some(UnsizeKind::Vtable(tty.principal.def_id())),\n-            ty::TyStruct(def, substs) => {\n+            ty::TyAdt(def, substs) if def.is_struct() => {\n                 // FIXME(arielb1): do some kind of normalization\n                 match def.struct_variant().fields.last() {\n                     None => None,"}, {"sha": "cc958fb3b2343042152e41dc98804e8192882c06", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -16,7 +16,7 @@ use middle::free_region::FreeRegionMap;\n use rustc::infer;\n use middle::region;\n use rustc::ty::subst::{Subst, Substs};\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n use rustc::traits::{self, Reveal};\n use util::nodemap::FnvHashSet;\n \n@@ -44,9 +44,7 @@ pub fn check_drop_impl(ccx: &CrateCtxt, drop_impl_did: DefId) -> Result<(), ()>\n     let dtor_self_type = ccx.tcx.lookup_item_type(drop_impl_did).ty;\n     let dtor_predicates = ccx.tcx.lookup_predicates(drop_impl_did);\n     match dtor_self_type.sty {\n-        ty::TyEnum(adt_def, self_to_impl_substs) |\n-        ty::TyUnion(adt_def, self_to_impl_substs) |\n-        ty::TyStruct(adt_def, self_to_impl_substs) => {\n+        ty::TyAdt(adt_def, self_to_impl_substs) => {\n             ensure_drop_params_and_item_params_correspond(ccx,\n                                                           drop_impl_did,\n                                                           dtor_self_type,\n@@ -301,13 +299,13 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n                 TypeContext::ADT { def_id, variant, field } => {\n                     let adt = tcx.lookup_adt_def(def_id);\n                     let variant_name = match adt.adt_kind() {\n-                        ty::AdtKind::Enum => format!(\"enum {} variant {}\",\n-                                                     tcx.item_path_str(def_id),\n-                                                     variant),\n-                        ty::AdtKind::Struct => format!(\"struct {}\",\n-                                                       tcx.item_path_str(def_id)),\n-                        ty::AdtKind::Union => format!(\"union {}\",\n-                                                       tcx.item_path_str(def_id)),\n+                        AdtKind::Enum => format!(\"enum {} variant {}\",\n+                                                 tcx.item_path_str(def_id),\n+                                                 variant),\n+                        AdtKind::Struct => format!(\"struct {}\",\n+                                                   tcx.item_path_str(def_id)),\n+                        AdtKind::Union => format!(\"union {}\",\n+                                                  tcx.item_path_str(def_id)),\n                     };\n                     span_note!(\n                         &mut err,\n@@ -435,14 +433,14 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n                 cx, context, ity, depth+1)\n         }\n \n-        ty::TyStruct(def, substs) if def.is_phantom_data() => {\n+        ty::TyAdt(def, substs) if def.is_phantom_data() => {\n             // PhantomData<T> - behaves identically to T\n             let ity = substs.type_at(0);\n             iterate_over_potentially_unsafe_regions_in_type(\n                 cx, context, ity, depth+1)\n         }\n \n-        ty::TyStruct(def, substs) | ty::TyUnion(def, substs) | ty::TyEnum(def, substs) => {\n+        ty::TyAdt(def, substs) => {\n             let did = def.did;\n             for variant in &def.variants {\n                 for field in variant.fields.iter() {\n@@ -497,7 +495,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n fn has_dtor_of_interest<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                         ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n-        ty::TyEnum(def, _) | ty::TyStruct(def, _) | ty::TyUnion(def, _) => {\n+        ty::TyAdt(def, _) => {\n             def.is_dtorck(tcx)\n         }\n         ty::TyTrait(..) | ty::TyProjection(..) | ty::TyAnon(..) => {"}, {"sha": "81e95c91e7ff94e0657b5225be12e2acdb766ace", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -292,9 +292,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 self.assemble_inherent_candidates_from_object(self_ty, data.principal);\n                 self.assemble_inherent_impl_candidates_for_type(data.principal.def_id());\n             }\n-            ty::TyEnum(def, _) |\n-            ty::TyStruct(def, _) |\n-            ty::TyUnion(def, _) => {\n+            ty::TyAdt(def, _) => {\n                 self.assemble_inherent_impl_candidates_for_type(def.did);\n             }\n             ty::TyBox(_) => {"}, {"sha": "3692d6fbf73d6a9069ebb472ad5bb8cda3cae1c4", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -165,7 +165,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if let Some(expr) = rcvr_expr {\n                     for (ty, _) in self.autoderef(span, rcvr_ty) {\n                         match ty.sty {\n-                            ty::TyStruct(def, substs) | ty::TyUnion(def, substs) => {\n+                            ty::TyAdt(def, substs) if !def.is_enum() => {\n                                 if let Some(field) = def.struct_variant().\n                                                          find_field_named(item_name) {\n                                     let snippet = tcx.sess.codemap().span_to_snippet(expr.span);\n@@ -359,9 +359,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             rcvr_expr: Option<&hir::Expr>) -> bool {\n         fn is_local(ty: Ty) -> bool {\n             match ty.sty {\n-                ty::TyEnum(def, _) | ty::TyStruct(def, _) | ty::TyUnion(def, _) => {\n-                    def.did.is_local()\n-                }\n+                ty::TyAdt(def, _) => def.did.is_local(),\n \n                 ty::TyTrait(ref tr) => tr.principal.def_id().is_local(),\n "}, {"sha": "005cd2e46b89f71b9ce4f32c6babe1c65dd88595", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -1200,7 +1200,7 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, id: ast::NodeId) {\n     let t = tcx.node_id_to_type(id);\n     match t.sty {\n-        ty::TyStruct(def, substs) => {\n+        ty::TyAdt(def, substs) if def.is_struct() => {\n             let fields = &def.struct_variant().fields;\n             if fields.is_empty() {\n                 span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\");\n@@ -2911,7 +2911,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut autoderef = self.autoderef(expr.span, expr_t);\n         while let Some((base_t, autoderefs)) = autoderef.next() {\n             match base_t.sty {\n-                ty::TyStruct(base_def, substs) | ty::TyUnion(base_def, substs) => {\n+                ty::TyAdt(base_def, substs) if !base_def.is_enum() => {\n                     debug!(\"struct named {:?}\",  base_t);\n                     if let Some(field) = base_def.struct_variant().find_field_named(field.node) {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n@@ -2957,7 +2957,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         field.node, actual)\n             }, expr_t);\n             match expr_t.sty {\n-                ty::TyStruct(def, _) | ty::TyUnion(def, _) => {\n+                ty::TyAdt(def, _) if !def.is_enum() => {\n                     if let Some(suggested_field_name) =\n                         Self::suggest_field_name(def.struct_variant(), field, vec![]) {\n                         err.span_help(field.span,\n@@ -3009,7 +3009,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut autoderef = self.autoderef(expr.span, expr_t);\n         while let Some((base_t, autoderefs)) = autoderef.next() {\n             let field = match base_t.sty {\n-                ty::TyStruct(base_def, substs) => {\n+                ty::TyAdt(base_def, substs) if base_def.is_struct() => {\n                     tuple_like = base_def.struct_variant().kind == ty::VariantKind::Tuple;\n                     if !tuple_like { continue }\n \n@@ -3074,14 +3074,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             kind_name: &str) {\n         let mut err = self.type_error_struct_with_diag(\n             field.name.span,\n-            |actual| if let ty::TyEnum(..) = ty.sty {\n-                struct_span_err!(self.tcx.sess, field.name.span, E0559,\n-                                 \"{} `{}::{}` has no field named `{}`\",\n-                                 kind_name, actual, variant.name.as_str(), field.name.node)\n-            } else {\n-                struct_span_err!(self.tcx.sess, field.name.span, E0560,\n-                                 \"{} `{}` has no field named `{}`\",\n-                                 kind_name, actual, field.name.node)\n+            |actual| match ty.sty {\n+                ty::TyAdt(adt, ..) if adt.is_enum() => {\n+                    struct_span_err!(self.tcx.sess, field.name.span, E0559,\n+                                    \"{} `{}::{}` has no field named `{}`\",\n+                                    kind_name, actual, variant.name.as_str(), field.name.node)\n+                }\n+                _ => {\n+                    struct_span_err!(self.tcx.sess, field.name.span, E0560,\n+                                    \"{} `{}` has no field named `{}`\",\n+                                    kind_name, actual, field.name.node)\n+                }\n             },\n             ty);\n         // prevent all specified fields from being suggested\n@@ -3102,9 +3105,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 check_completeness: bool) {\n         let tcx = self.tcx;\n         let (substs, kind_name) = match adt_ty.sty {\n-            ty::TyEnum(_, substs) => (substs, \"variant\"),\n-            ty::TyStruct(_, substs) => (substs, \"struct\"),\n-            ty::TyUnion(_, substs) => (substs, \"union\"),\n+            ty::TyAdt(adt, substs) => (substs, adt.variant_descr()),\n             _ => span_bug!(span, \"non-ADT passed to check_expr_struct_fields\")\n         };\n \n@@ -3199,8 +3200,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             Def::TyAlias(did) => {\n                 match self.tcx.opt_lookup_item_type(did).map(|scheme| &scheme.ty.sty) {\n-                    Some(&ty::TyStruct(adt, _)) |\n-                    Some(&ty::TyUnion(adt, _)) => Some((did, adt.struct_variant())),\n+                    Some(&ty::TyAdt(adt, _)) if !adt.is_enum() => {\n+                        Some((did, adt.struct_variant()))\n+                    }\n                     _ => None,\n                 }\n             }\n@@ -3246,7 +3248,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let &Some(ref base_expr) = base_expr {\n             self.check_expr_has_type(base_expr, struct_ty);\n             match struct_ty.sty {\n-                ty::TyStruct(adt, substs) => {\n+                ty::TyAdt(adt, substs) if adt.is_struct() => {\n                     self.tables.borrow_mut().fru_field_types.insert(\n                         expr.id,\n                         adt.struct_variant().fields.iter().map(|f| {"}, {"sha": "046ba5fb4523c86076be20eada5e2004ec230f62", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -22,9 +22,9 @@ use rustc::ty::{self, TyCtxt, TypeFoldable};\n use rustc::traits::{self, Reveal};\n use rustc::ty::{ImplOrTraitItemId, ConstTraitItemId};\n use rustc::ty::{MethodTraitItemId, TypeTraitItemId, ParameterEnvironment};\n-use rustc::ty::{Ty, TyBool, TyChar, TyEnum, TyError};\n+use rustc::ty::{Ty, TyBool, TyChar, TyError};\n use rustc::ty::{TyParam, TyRawPtr};\n-use rustc::ty::{TyRef, TyStruct, TyUnion, TyTrait, TyNever, TyTuple};\n+use rustc::ty::{TyRef, TyAdt, TyTrait, TyNever, TyTuple};\n use rustc::ty::{TyStr, TyArray, TySlice, TyFloat, TyInfer, TyInt};\n use rustc::ty::{TyUint, TyClosure, TyBox, TyFnDef, TyFnPtr};\n use rustc::ty::{TyProjection, TyAnon};\n@@ -69,9 +69,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n     // Returns the def ID of the base type, if there is one.\n     fn get_base_type_def_id(&self, span: Span, ty: Ty<'tcx>) -> Option<DefId> {\n         match ty.sty {\n-            TyEnum(def, _) |\n-            TyStruct(def, _) |\n-            TyUnion(def, _) => {\n+            TyAdt(def, _) => {\n                 Some(def.did)\n             }\n \n@@ -241,9 +239,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n \n             let self_type = tcx.lookup_item_type(impl_did);\n             match self_type.ty.sty {\n-                ty::TyEnum(type_def, _) |\n-                ty::TyStruct(type_def, _) |\n-                ty::TyUnion(type_def, _) => {\n+                ty::TyAdt(type_def, _) => {\n                     type_def.set_destructor(method_def_id.def_id());\n                 }\n                 _ => {\n@@ -426,7 +422,8 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                         check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n                     }\n \n-                    (&ty::TyStruct(def_a, substs_a), &ty::TyStruct(def_b, substs_b)) => {\n+                    (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b))\n+                            if def_a.is_struct() && def_b.is_struct() => {\n                         if def_a != def_b {\n                             let source_path = tcx.item_path_str(def_a.did);\n                             let target_path = tcx.item_path_str(def_b.did);"}, {"sha": "d1eb0f995de133b82a6d1e8a79616844c4440429", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -75,9 +75,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                        self.tcx.map.node_to_string(item.id));\n                 let self_ty = self.tcx.lookup_item_type(def_id).ty;\n                 match self_ty.sty {\n-                    ty::TyEnum(def, _) |\n-                    ty::TyStruct(def, _) |\n-                    ty::TyUnion(def, _) => {\n+                    ty::TyAdt(def, _) => {\n                         self.check_def_id(item, def.did);\n                     }\n                     ty::TyTrait(ref data) => {\n@@ -294,14 +292,9 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 {\n                     let self_ty = trait_ref.self_ty();\n                     let opt_self_def_id = match self_ty.sty {\n-                        ty::TyStruct(self_def, _) |\n-                        ty::TyUnion(self_def, _) |\n-                        ty::TyEnum(self_def, _) =>\n-                            Some(self_def.did),\n-                        ty::TyBox(..) =>\n-                            self.tcx.lang_items.owned_box(),\n-                        _ =>\n-                            None\n+                        ty::TyAdt(self_def, _) => Some(self_def.did),\n+                        ty::TyBox(..) => self.tcx.lang_items.owned_box(),\n+                        _ => None,\n                     };\n \n                     let msg = match opt_self_def_id {"}, {"sha": "082690149c9d1216c169a3bb6ba3e03bdca18be4", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -67,7 +67,7 @@ use rustc_const_eval::EvalHint::UncheckedExprHint;\n use rustc_const_eval::{eval_const_expr_partial, report_const_eval_err};\n use rustc::ty::subst::Substs;\n use rustc::ty::{ToPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n-use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeScheme};\n+use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt, TypeScheme};\n use rustc::ty::{VariantKind};\n use rustc::ty::util::IntTypeExt;\n use rscope::*;\n@@ -1062,7 +1062,7 @@ fn convert_struct_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let ctor_id = if !def.is_struct() { Some(ccx.tcx.map.local_def_id(def.id())) } else { None };\n     let variants = vec![convert_struct_variant(ccx, ctor_id.unwrap_or(did), it.name,\n                                                ConstInt::Infer(0), def)];\n-    let adt = ccx.tcx.intern_adt_def(did, ty::AdtKind::Struct, variants);\n+    let adt = ccx.tcx.intern_adt_def(did, AdtKind::Struct, variants);\n     if let Some(ctor_id) = ctor_id {\n         // Make adt definition available through constructor id as well.\n         ccx.tcx.insert_adt_def(ctor_id, adt);\n@@ -1077,7 +1077,7 @@ fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n {\n     let did = ccx.tcx.map.local_def_id(it.id);\n     let variants = vec![convert_struct_variant(ccx, did, it.name, ConstInt::Infer(0), def)];\n-    ccx.tcx.intern_adt_def(did, ty::AdtKind::Union, variants)\n+    ccx.tcx.intern_adt_def(did, AdtKind::Union, variants)\n }\n \n     fn evaluate_disr_expr(ccx: &CrateCtxt, repr_ty: attr::IntType, e: &hir::Expr)\n@@ -1157,7 +1157,7 @@ fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let did = tcx.map.local_def_id(v.node.data.id());\n         convert_struct_variant(ccx, did, v.node.name, disr, &v.node.data)\n     }).collect();\n-    tcx.intern_adt_def(tcx.map.local_def_id(it.id), ty::AdtKind::Enum, variants)\n+    tcx.intern_adt_def(tcx.map.local_def_id(it.id), AdtKind::Enum, variants)\n }\n \n /// Ensures that the super-predicates of the trait with def-id\n@@ -1581,17 +1581,17 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     ItemEnum(ref ei, ref generics) => {\n                         let def = convert_enum_def(ccx, item, ei);\n                         let substs = mk_item_substs(&ccx.icx(generics), item.span, def_id);\n-                        ccx.tcx.mk_enum(def, substs)\n+                        ccx.tcx.mk_adt(def, substs)\n                     }\n                     ItemStruct(ref si, ref generics) => {\n                         let def = convert_struct_def(ccx, item, si);\n                         let substs = mk_item_substs(&ccx.icx(generics), item.span, def_id);\n-                        ccx.tcx.mk_struct(def, substs)\n+                        ccx.tcx.mk_adt(def, substs)\n                     }\n                     ItemUnion(ref un, ref generics) => {\n                         let def = convert_union_def(ccx, item, un);\n                         let substs = mk_item_substs(&ccx.icx(generics), item.span, def_id);\n-                        ccx.tcx.mk_union(def, substs)\n+                        ccx.tcx.mk_adt(def, substs)\n                     }\n                     ItemDefaultImpl(..) |\n                     ItemTrait(..) |"}, {"sha": "b18792d894287844dab3c65854b8fee268e7b417", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -344,9 +344,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 }\n             }\n \n-            ty::TyEnum(def, substs) |\n-            ty::TyStruct(def, substs) |\n-            ty::TyUnion(def, substs) => {\n+            ty::TyAdt(def, substs) => {\n                 let item_type = self.tcx().lookup_item_type(def.did);\n \n                 // This edge is actually implied by the call to"}, {"sha": "f1b907e70d74e0324e7b8023d80405c2fe8e2190", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -238,7 +238,7 @@ fn build_type<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let t = tcx.lookup_item_type(did);\n     let predicates = tcx.lookup_predicates(did);\n     match t.ty.sty {\n-        ty::TyEnum(edef, _) if !tcx.sess.cstore.is_typedef(did) => {\n+        ty::TyAdt(edef, _) if edef.is_enum() && !tcx.sess.cstore.is_typedef(did) => {\n             return clean::EnumItem(clean::Enum {\n                 generics: (t.generics, &predicates).clean(cx),\n                 variants_stripped: false,"}, {"sha": "b9dc75cdd9f12dda6084e2e50a56df6bdfb36667", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -41,7 +41,7 @@ use rustc::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n use rustc::hir::fold::Folder;\n use rustc::hir::print as pprust;\n use rustc::ty::subst::Substs;\n-use rustc::ty;\n+use rustc::ty::{self, AdtKind};\n use rustc::middle::stability;\n use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n \n@@ -1811,14 +1811,12 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                 decl: (cx.map.local_def_id(0), &fty.sig).clean(cx),\n                 abi: fty.abi,\n             }),\n-            ty::TyStruct(def, substs) |\n-            ty::TyUnion(def, substs) |\n-            ty::TyEnum(def, substs) => {\n+            ty::TyAdt(def, substs) => {\n                 let did = def.did;\n-                let kind = match self.sty {\n-                    ty::TyStruct(..) => TypeStruct,\n-                    ty::TyUnion(..) => TypeUnion,\n-                    _ => TypeEnum,\n+                let kind = match def.adt_kind() {\n+                    AdtKind::Struct => TypeStruct,\n+                    AdtKind::Union => TypeUnion,\n+                    AdtKind::Enum => TypeEnum,\n                 };\n                 inline::record_extern_fqn(cx, did, kind);\n                 let path = external_path(cx, &cx.tcx().item_name(did).as_str(),"}, {"sha": "ca1027b11adce26a27549f0eb4f975a79ae0041d", "filename": "src/test/run-pass/auxiliary/issue13507.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue13507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b672d5567c3b20542e845baaf8a9c47d9df907/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue13507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue13507.rs?ref=f2b672d5567c3b20542e845baaf8a9c47d9df907", "patch": "@@ -75,13 +75,13 @@ pub mod testtypes {\n         fn foo_method(&self) -> usize;\n     }\n \n-    // Tests TyStruct\n+    // Tests struct\n     pub struct FooStruct {\n         pub pub_foo_field: usize,\n         foo_field: usize\n     }\n \n-    // Tests TyEnum\n+    // Tests enum\n     pub enum FooEnum {\n         VarA(usize),\n         VarB(usize, usize)"}]}