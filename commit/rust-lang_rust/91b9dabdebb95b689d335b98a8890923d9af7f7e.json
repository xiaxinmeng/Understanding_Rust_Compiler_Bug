{"sha": "91b9dabdebb95b689d335b98a8890923d9af7f7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxYjlkYWJkZWJiOTViNjg5ZDMzNWI5OGE4ODkwOTIzZDlhZjdmN2U=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-06-03T20:15:00Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-06-09T22:03:54Z"}, "message": "resolve: Rewrite resolve_pattern", "tree": {"sha": "ee5180554c7ec1904ef43176144a9d25ab1f0ad3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee5180554c7ec1904ef43176144a9d25ab1f0ad3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91b9dabdebb95b689d335b98a8890923d9af7f7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91b9dabdebb95b689d335b98a8890923d9af7f7e", "html_url": "https://github.com/rust-lang/rust/commit/91b9dabdebb95b689d335b98a8890923d9af7f7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91b9dabdebb95b689d335b98a8890923d9af7f7e/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee00760a14020d73e8ad509b2ddbd3054101db6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee00760a14020d73e8ad509b2ddbd3054101db6f", "html_url": "https://github.com/rust-lang/rust/commit/ee00760a14020d73e8ad509b2ddbd3054101db6f"}], "stats": {"total": 822, "additions": 339, "deletions": 483}, "files": [{"sha": "3b2d5ba449381d3c374d6ae4d9de843c0bd90024", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -88,6 +88,14 @@ impl PathResolution {\n             depth: depth,\n         }\n     }\n+\n+    pub fn kind_name(&self) -> &'static str {\n+        if self.depth != 0 {\n+            \"associated item\"\n+        } else {\n+            self.base_def.kind_name()\n+        }\n+    }\n }\n \n // Definition mapping\n@@ -161,8 +169,8 @@ impl Def {\n             Def::Struct(..) => \"struct\",\n             Def::Trait(..) => \"trait\",\n             Def::Method(..) => \"method\",\n-            Def::Const(..) => \"const\",\n-            Def::AssociatedConst(..) => \"associated const\",\n+            Def::Const(..) => \"constant\",\n+            Def::AssociatedConst(..) => \"associated constant\",\n             Def::TyParam(..) => \"type parameter\",\n             Def::PrimTy(..) => \"builtin type\",\n             Def::Local(..) => \"local variable\","}, {"sha": "d3e2dd2a917e5edb491c84921e312602b8421226", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 34, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -842,32 +842,6 @@ match 0 {\n ```\n \"##,\n \n-E0419: r##\"\n-An unknown enum variant, struct or const was used. Example of erroneous code:\n-\n-```compile_fail\n-match 0 {\n-    Something::Foo => {} // error: unresolved enum variant, struct\n-                         //        or const `Foo`\n-}\n-```\n-\n-Please verify you didn't misspell it and the enum variant, struct or const has\n-been declared and imported into scope. Example:\n-\n-```\n-enum Something {\n-    Foo,\n-    NotFoo,\n-}\n-\n-match Something::NotFoo {\n-    Something::Foo => {} // ok!\n-    _ => {}\n-}\n-```\n-\"##,\n-\n E0422: r##\"\n You are trying to use an identifier that is either undefined or not a struct.\n For instance:\n@@ -1247,16 +1221,11 @@ impl Foo for i32 {}\n }\n \n register_diagnostics! {\n-//  E0153, unused error code\n-//  E0157, unused error code\n     E0254, // import conflicts with imported crate in this module\n-//  E0257,\n-//  E0258,\n     E0402, // cannot use an outer type parameter in this context\n     E0406, // undeclared associated type\n-//  E0410, merged into 408\n-    E0418, // is not an enum variant, struct or const\n-    E0420, // is not an associated const\n-    E0421, // unresolved associated const\n+    E0418, // X bindings cannot shadow Ys\n+    E0419, // unresolved pattern path kind `name`\n+    E0420, // expected pattern path kind, found another pattern path kind\n     E0427, // cannot use `ref` binding mode with ...\n }"}, {"sha": "86868fc085bf725e407500ef615b2a1a3b7b03f3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 279, "deletions": 402, "changes": 681, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -31,7 +31,6 @@ extern crate arena;\n #[macro_use]\n extern crate rustc;\n \n-use self::PatternBindingMode::*;\n use self::Namespace::*;\n use self::ResolveResult::*;\n use self::FallbackSuggestion::*;\n@@ -40,7 +39,6 @@ use self::RibKind::*;\n use self::UseLexicalScopeFlag::*;\n use self::ModulePrefixResult::*;\n use self::AssocItemResolveResult::*;\n-use self::BareIdentifierPatternResolution::*;\n use self::ParentLink::*;\n \n use rustc::hir::map::Definitions;\n@@ -66,8 +64,8 @@ use syntax::visit::{self, FnKind, Visitor};\n use syntax::ast::{Arm, BindingMode, Block, Crate, Expr, ExprKind};\n use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n-use syntax::ast::{Local, Pat, PatKind, Path};\n-use syntax::ast::{PathSegment, PathParameters, TraitItemKind, TraitRef, Ty, TyKind};\n+use syntax::ast::{Local, Mutability, Pat, PatKind, Path};\n+use syntax::ast::{PathSegment, PathParameters, QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n \n use std::collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n@@ -123,24 +121,10 @@ enum ResolutionError<'a> {\n     SelfUsedOutsideImplOrTrait,\n     /// error E0412: use of undeclared\n     UseOfUndeclared(&'a str, &'a str, SuggestedCandidates),\n-    /// error E0413: cannot be named the same as an enum variant or unit-like struct in scope\n-    DeclarationShadowsEnumVariantOrUnitLikeStruct(Name),\n-    /// error E0414: only irrefutable patterns allowed here\n-    ConstantForIrrefutableBinding(Name, &'a NameBinding<'a>),\n     /// error E0415: identifier is bound more than once in this parameter list\n     IdentifierBoundMoreThanOnceInParameterList(&'a str),\n     /// error E0416: identifier is bound more than once in the same pattern\n     IdentifierBoundMoreThanOnceInSamePattern(&'a str),\n-    /// error E0417: static variables cannot be referenced in a pattern\n-    StaticVariableReference(&'a NameBinding<'a>),\n-    /// error E0418: is not an enum variant, struct or const\n-    NotAnEnumVariantStructOrConst(&'a str),\n-    /// error E0419: unresolved enum variant, struct or const\n-    UnresolvedEnumVariantStructOrConst(&'a str),\n-    /// error E0420: is not an associated const\n-    NotAnAssociatedConst(&'a str),\n-    /// error E0421: unresolved associated const\n-    UnresolvedAssociatedConst(&'a str),\n     /// error E0422: does not name a struct\n     DoesNotNameAStruct(&'a str),\n     /// error E0423: is a struct variant name, but this expression uses it like a function name\n@@ -158,8 +142,6 @@ enum ResolutionError<'a> {\n     },\n     /// error E0426: use of undeclared label\n     UndeclaredLabel(&'a str),\n-    /// error E0427: cannot use `ref` binding mode with ...\n-    CannotUseRefBindingModeWith(&'a str),\n     /// error E0429: `self` imports are only allowed within a { } list\n     SelfImportsOnlyAllowedWithin,\n     /// error E0430: `self` import can only appear once in the list\n@@ -174,6 +156,12 @@ enum ResolutionError<'a> {\n     CannotCaptureDynamicEnvironmentInFnItem,\n     /// error E0435: attempt to use a non-constant value in a constant\n     AttemptToUseNonConstantValueInConstant,\n+    /// error E0418: X bindings cannot shadow Ys\n+    BindingShadowsSomethingUnacceptable(&'a str, &'a str, Name),\n+    /// error E0419: unresolved pattern path kind `name`\n+    PatPathUnresolved(&'a str, &'a Path),\n+    /// error E0420: expected pattern path kind, found another pattern path kind\n+    PatPathUnexpected(&'a str, &'a str, &'a Path),\n }\n \n /// Context of where `ResolutionError::UnresolvedName` arose.\n@@ -306,28 +294,6 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n             err.span_label(span, &format!(\"undefined or not in scope\"));\n             err\n         }\n-        ResolutionError::DeclarationShadowsEnumVariantOrUnitLikeStruct(name) => {\n-            let mut err = struct_span_err!(resolver.session,\n-                             span,\n-                             E0413,\n-                             \"`{}` cannot be named the same as an enum variant \\\n-                              or unit-like struct in scope\",\n-                             name);\n-            err.span_label(span,\n-                &format!(\"has same name as enum variant or unit-like struct\"));\n-            err\n-        }\n-        ResolutionError::ConstantForIrrefutableBinding(name, binding) => {\n-            let mut err = struct_span_err!(resolver.session,\n-                                           span,\n-                                           E0414,\n-                                       \"let variables cannot be named the same as const variables\");\n-            err.span_label(span,\n-                           &format!(\"cannot be named the same as a const variable\"));\n-            let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n-            err.span_label(binding.span, &format!(\"a constant `{}` is {} here\", name, participle));\n-            err\n-        }\n         ResolutionError::IdentifierBoundMoreThanOnceInParameterList(identifier) => {\n             let mut err = struct_span_err!(resolver.session,\n                              span,\n@@ -346,47 +312,6 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n             err.span_label(span, &format!(\"used in a pattern more than once\"));\n             err\n         }\n-        ResolutionError::StaticVariableReference(binding) => {\n-            let mut err = struct_span_err!(resolver.session,\n-                                           span,\n-                                           E0417,\n-                                           \"static variables cannot be referenced in a \\\n-                                            pattern, use a `const` instead\");\n-            err.span_label(span, &format!(\"static variable used in pattern\"));\n-            if binding.span != codemap::DUMMY_SP {\n-                let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n-                err.span_label(binding.span, &format!(\"static variable {} here\", participle));\n-            }\n-            err\n-        }\n-        ResolutionError::NotAnEnumVariantStructOrConst(name) => {\n-            struct_span_err!(resolver.session,\n-                             span,\n-                             E0418,\n-                             \"`{}` is not an enum variant, struct or const\",\n-                             name)\n-        }\n-        ResolutionError::UnresolvedEnumVariantStructOrConst(name) => {\n-            struct_span_err!(resolver.session,\n-                             span,\n-                             E0419,\n-                             \"unresolved enum variant, struct or const `{}`\",\n-                             name)\n-        }\n-        ResolutionError::NotAnAssociatedConst(name) => {\n-            struct_span_err!(resolver.session,\n-                             span,\n-                             E0420,\n-                             \"`{}` is not an associated const\",\n-                             name)\n-        }\n-        ResolutionError::UnresolvedAssociatedConst(name) => {\n-            struct_span_err!(resolver.session,\n-                             span,\n-                             E0421,\n-                             \"unresolved associated const `{}`\",\n-                             name)\n-        }\n         ResolutionError::DoesNotNameAStruct(name) => {\n             struct_span_err!(resolver.session,\n                              span,\n@@ -455,13 +380,6 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n                              \"use of undeclared label `{}`\",\n                              name)\n         }\n-        ResolutionError::CannotUseRefBindingModeWith(descr) => {\n-            struct_span_err!(resolver.session,\n-                             span,\n-                             E0427,\n-                             \"cannot use `ref` binding mode with {}\",\n-                             descr)\n-        }\n         ResolutionError::SelfImportsOnlyAllowedWithin => {\n             struct_span_err!(resolver.session,\n                              span,\n@@ -506,6 +424,37 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n                              E0435,\n                              \"attempt to use a non-constant value in a constant\")\n         }\n+        ResolutionError::BindingShadowsSomethingUnacceptable(what_binding, shadows_what, name) => {\n+            let mut err = struct_span_err!(resolver.session,\n+                                           span,\n+                                           E0418,\n+                                           \"{}s cannot shadow {}s\", what_binding, shadows_what);\n+            err.span_label(span, &format!(\"cannot be named the same as a {}\", shadows_what));\n+            if let Some(binding) = resolver.current_module\n+                                           .resolve_name_in_lexical_scope(name, ValueNS) {\n+                let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n+                err.span_label(binding.span, &format!(\"a {} `{}` is {} here\",\n+                                                      shadows_what, name, participle));\n+            }\n+            err\n+        }\n+        ResolutionError::PatPathUnresolved(expected_what, path) => {\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0419,\n+                             \"unresolved {} `{}`\",\n+                             expected_what,\n+                             path.segments.last().unwrap().identifier)\n+        }\n+        ResolutionError::PatPathUnexpected(expected_what, found_what, path) => {\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0420,\n+                             \"expected {}, found {} `{}`\",\n+                             expected_what,\n+                             found_what,\n+                             path.segments.last().unwrap().identifier)\n+        }\n     }\n }\n \n@@ -518,11 +467,33 @@ struct BindingInfo {\n // Map from the name in a pattern to its binding mode.\n type BindingMap = HashMap<Name, BindingInfo>;\n \n-#[derive(Copy, Clone, PartialEq)]\n-enum PatternBindingMode {\n-    RefutableMode,\n-    LocalIrrefutableMode,\n-    ArgumentIrrefutableMode,\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum PatternSource {\n+    Match,\n+    IfLet,\n+    WhileLet,\n+    Let,\n+    For,\n+    FnParam,\n+}\n+\n+impl PatternSource {\n+    fn is_refutable(self) -> bool {\n+        match self {\n+            PatternSource::Match | PatternSource::IfLet | PatternSource::WhileLet => true,\n+            PatternSource::Let | PatternSource::For | PatternSource::FnParam  => false,\n+        }\n+    }\n+    fn descr(self) -> &'static str {\n+        match self {\n+            PatternSource::Match => \"match binding\",\n+            PatternSource::IfLet => \"if let binding\",\n+            PatternSource::WhileLet => \"while let binding\",\n+            PatternSource::Let => \"let binding\",\n+            PatternSource::For => \"for binding\",\n+            PatternSource::FnParam => \"function parameter\",\n+        }\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n@@ -709,13 +680,6 @@ enum AssocItemResolveResult {\n     ResolveAttempt(Option<PathResolution>),\n }\n \n-#[derive(Copy, Clone)]\n-enum BareIdentifierPatternResolution<'a> {\n-    FoundStructOrEnumVariant(Def),\n-    FoundConst(&'a NameBinding<'a>, Name),\n-    BareIdentifierPatternUnresolved,\n-}\n-\n /// One local scope.\n #[derive(Debug)]\n struct Rib<'a> {\n@@ -1814,7 +1778,7 @@ impl<'a> Resolver<'a> {\n         // Add each argument to the rib.\n         let mut bindings_list = HashMap::new();\n         for argument in &declaration.inputs {\n-            self.resolve_pattern(&argument.pat, ArgumentIrrefutableMode, &mut bindings_list);\n+            self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n \n             self.visit_ty(&argument.ty);\n \n@@ -2055,7 +2019,7 @@ impl<'a> Resolver<'a> {\n         walk_list!(self, visit_expr, &local.init);\n \n         // Resolve the pattern.\n-        self.resolve_pattern(&local.pat, LocalIrrefutableMode, &mut HashMap::new());\n+        self.resolve_pattern(&local.pat, PatternSource::Let, &mut HashMap::new());\n     }\n \n     // build a map from pattern identifiers to binding-info's.\n@@ -2124,7 +2088,7 @@ impl<'a> Resolver<'a> {\n \n         let mut bindings_list = HashMap::new();\n         for pattern in &arm.pats {\n-            self.resolve_pattern(&pattern, RefutableMode, &mut bindings_list);\n+            self.resolve_pattern(&pattern, PatternSource::Match, &mut bindings_list);\n         }\n \n         // This has to happen *after* we determine which\n@@ -2183,10 +2147,18 @@ impl<'a> Resolver<'a> {\n                 // This is a path in the type namespace. Walk through scopes\n                 // looking for it.\n                 if let Some(def) = resolution {\n-                    // Write the result into the def map.\n-                    debug!(\"(resolving type) writing resolution for `{}` (id {}) = {:?}\",\n-                           path_names_to_string(path, 0), ty.id, def);\n-                    self.record_def(ty.id, def);\n+                    match def.base_def {\n+                        Def::Mod(..) => {\n+                            self.session.span_err(path.span, \"expected type, found module\");\n+                            self.record_def(ty.id, err_path_resolution());\n+                        }\n+                        _ => {\n+                            // Write the result into the def map.\n+                            debug!(\"(resolving type) writing resolution for `{}` (id {}) = {:?}\",\n+                                   path_names_to_string(path, 0), ty.id, def);\n+                            self.record_def(ty.id, def);\n+                        }\n+                    }\n                 } else {\n                     self.record_def(ty.id, err_path_resolution());\n \n@@ -2246,312 +2218,230 @@ impl<'a> Resolver<'a> {\n         visit::walk_ty(self, ty);\n     }\n \n-    fn resolve_pattern(&mut self,\n-                       pattern: &Pat,\n-                       mode: PatternBindingMode,\n-                       // Maps idents to the node ID for the (outermost)\n-                       // pattern that binds them\n-                       bindings_list: &mut HashMap<Name, NodeId>) {\n-        let pat_id = pattern.id;\n-        pattern.walk(&mut |pattern| {\n-            match pattern.node {\n-                PatKind::Ident(binding_mode, ref path1, ref at_rhs) => {\n-                    // The meaning of PatKind::Ident with no type parameters\n-                    // depends on whether an enum variant or unit-like struct\n-                    // with that name is in scope. The probing lookup has to\n-                    // be careful not to emit spurious errors. Only matching\n-                    // patterns (match) can match nullary variants or\n-                    // unit-like structs. For binding patterns (let\n-                    // and the LHS of @-patterns), matching such a value is\n-                    // simply disallowed (since it's rarely what you want).\n-                    let const_ok = mode == RefutableMode && at_rhs.is_none();\n-\n-                    let ident = path1.node;\n-                    let renamed = mtwt::resolve(ident);\n-\n-                    match self.resolve_bare_identifier_pattern(ident, pattern.span) {\n-                        FoundStructOrEnumVariant(def) if const_ok => {\n-                            debug!(\"(resolving pattern) resolving `{}` to struct or enum variant\",\n-                                   renamed);\n-\n-                            self.enforce_default_binding_mode(pattern,\n-                                                              binding_mode,\n-                                                              \"an enum variant\");\n-                            self.record_def(pattern.id,\n-                                            PathResolution {\n-                                                base_def: def,\n-                                                depth: 0,\n-                                            });\n-                        }\n-                        FoundStructOrEnumVariant(..) => {\n-                            resolve_error(\n-                                self,\n-                                pattern.span,\n-                                ResolutionError::DeclarationShadowsEnumVariantOrUnitLikeStruct(\n-                                    renamed)\n-                            );\n-                            self.record_def(pattern.id, err_path_resolution());\n-                        }\n-                        FoundConst(binding, _) if const_ok => {\n-                            debug!(\"(resolving pattern) resolving `{}` to constant\", renamed);\n-\n-                            self.enforce_default_binding_mode(pattern, binding_mode, \"a constant\");\n-                            self.record_def(pattern.id,\n-                                            PathResolution {\n-                                                base_def: binding.def().unwrap(),\n-                                                depth: 0,\n-                                            });\n-                        }\n-                        FoundConst(binding, name) => {\n-                            resolve_error(\n-                                self,\n-                                pattern.span,\n-                                ResolutionError::ConstantForIrrefutableBinding(name, binding)\n-                            );\n-                            self.record_def(pattern.id, err_path_resolution());\n-                        }\n-                        BareIdentifierPatternUnresolved => {\n-                            debug!(\"(resolving pattern) binding `{}`\", renamed);\n-\n-                            let def_id = self.definitions.local_def_id(pattern.id);\n-                            let def = Def::Local(def_id, pattern.id);\n-\n-                            // Record the definition so that later passes\n-                            // will be able to distinguish variants from\n-                            // locals in patterns.\n-\n-                            self.record_def(pattern.id,\n-                                            PathResolution {\n-                                                base_def: def,\n-                                                depth: 0,\n-                                            });\n-\n-                            // Add the binding to the local ribs, if it\n-                            // doesn't already exist in the bindings list. (We\n-                            // must not add it if it's in the bindings list\n-                            // because that breaks the assumptions later\n-                            // passes make about or-patterns.)\n-                            if !bindings_list.contains_key(&renamed) {\n-                                let this = &mut *self;\n-                                let last_rib = this.value_ribs.last_mut().unwrap();\n-                                last_rib.bindings.insert(renamed, def);\n-                                bindings_list.insert(renamed, pat_id);\n-                            } else if mode == ArgumentIrrefutableMode &&\n-                               bindings_list.contains_key(&renamed) {\n-                                // Forbid duplicate bindings in the same\n-                                // parameter list.\n-                                resolve_error(\n-                                    self,\n-                                    pattern.span,\n-                                    ResolutionError::IdentifierBoundMoreThanOnceInParameterList(\n-                                        &ident.name.as_str())\n-                                );\n-                            } else if bindings_list.get(&renamed) == Some(&pat_id) {\n-                                // Then this is a duplicate variable in the\n-                                // same disjunction, which is an error.\n-                                resolve_error(\n-                                    self,\n-                                    pattern.span,\n-                                    ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(\n-                                        &ident.name.as_str())\n-                                );\n-                            }\n-                            // Else, not bound in the same pattern: do\n-                            // nothing.\n-                        }\n-                    }\n-                }\n+    fn fresh_binding(&mut self,\n+                     ident: &ast::SpannedIdent,\n+                     pat_id: NodeId,\n+                     outer_pat_id: NodeId,\n+                     pat_src: PatternSource,\n+                     bindings_list: &mut HashMap<Name, NodeId>)\n+                     -> PathResolution {\n+        // Add the binding to the local ribs, if it\n+        // doesn't already exist in the bindings list. (We\n+        // must not add it if it's in the bindings list\n+        // because that breaks the assumptions later\n+        // passes make about or-patterns.)\n+        let renamed = mtwt::resolve(ident.node);\n+        let def = match bindings_list.get(&renamed).cloned() {\n+            Some(id) if id == outer_pat_id => {\n+                // `Variant(a, a)`, error\n+                resolve_error(\n+                    self,\n+                    ident.span,\n+                    ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(\n+                        &ident.node.name.as_str())\n+                );\n+                Def::Err\n+            }\n+            Some(..) if pat_src == PatternSource::FnParam => {\n+                // `fn f(a: u8, a: u8)`, error\n+                resolve_error(\n+                    self,\n+                    ident.span,\n+                    ResolutionError::IdentifierBoundMoreThanOnceInParameterList(\n+                        &ident.node.name.as_str())\n+                );\n+                Def::Err\n+            }\n+            Some(..) if pat_src == PatternSource::Match => {\n+                // `Varian1(a) | Varian2(a)`, ok\n+                Def::Local(self.definitions.local_def_id(pat_id), pat_id)\n+            }\n+            Some(..) => {\n+                span_bug!(ident.span, \"two bindings with the same name from \\\n+                                       unexpected pattern source {:?}\", pat_src);\n+            }\n+            None => {\n+                // A completely fresh binding, add to the lists\n+                bindings_list.insert(renamed, outer_pat_id);\n+                let def = Def::Local(self.definitions.local_def_id(pat_id), pat_id);\n+                self.value_ribs.last_mut().unwrap().bindings.insert(renamed, def);\n+                def\n+            }\n+        };\n \n-                PatKind::TupleStruct(ref path, _, _) | PatKind::Path(ref path) => {\n-                    // This must be an enum variant, struct or const.\n-                    let resolution = match self.resolve_possibly_assoc_item(pat_id,\n-                                                                            None,\n-                                                                            path,\n-                                                                            ValueNS) {\n-                        // The below shouldn't happen because all\n-                        // qualified paths should be in PatKind::QPath.\n-                        TypecheckRequired =>\n-                            span_bug!(path.span,\n-                                      \"resolve_possibly_assoc_item claimed that a path \\\n-                                       in PatKind::Path or PatKind::TupleStruct \\\n-                                       requires typecheck to resolve, but qualified \\\n-                                       paths should be PatKind::QPath\"),\n-                        ResolveAttempt(resolution) => resolution,\n-                    };\n-                    if let Some(path_res) = resolution {\n-                        match path_res.base_def {\n-                            Def::Struct(..) if path_res.depth == 0 => {\n-                                self.record_def(pattern.id, path_res);\n-                            }\n-                            Def::Variant(..) | Def::Const(..) => {\n-                                self.record_def(pattern.id, path_res);\n-                            }\n-                            Def::Static(..) => {\n-                                let segments = &path.segments;\n-                                let binding = if path.global {\n-                                    self.resolve_crate_relative_path(path.span, segments, ValueNS)\n-                                } else {\n-                                    self.resolve_module_relative_path(path.span, segments, ValueNS)\n-                                }.unwrap();\n+        PathResolution { base_def: def, depth: 0 }\n+    }\n \n-                                let error = ResolutionError::StaticVariableReference(binding);\n-                                resolve_error(self, path.span, error);\n-                                self.record_def(pattern.id, err_path_resolution());\n-                            }\n-                            _ => {\n-                                // If anything ends up here entirely resolved,\n-                                // it's an error. If anything ends up here\n-                                // partially resolved, that's OK, because it may\n-                                // be a `T::CONST` that typeck will resolve.\n-                                if path_res.depth == 0 {\n-                                    resolve_error(\n-                                        self,\n-                                        path.span,\n-                                        ResolutionError::NotAnEnumVariantStructOrConst(\n-                                            &path.segments\n-                                                 .last()\n-                                                 .unwrap()\n-                                                 .identifier\n-                                                 .name\n-                                                 .as_str())\n-                                    );\n-                                    self.record_def(pattern.id, err_path_resolution());\n-                                } else {\n-                                    let const_name = path.segments\n-                                                         .last()\n-                                                         .unwrap()\n-                                                         .identifier\n-                                                         .name;\n-                                    let traits = self.get_traits_containing_item(const_name);\n-                                    self.trait_map.insert(pattern.id, traits);\n-                                    self.record_def(pattern.id, path_res);\n-                                }\n-                            }\n-                        }\n-                    } else {\n-                        if let Err(false) = self.resolve_path(pat_id, &path, 0, ValueNS) {\n-                            // No error has been reported, so we need to do this ourselves.\n+    fn resolve_pattern_path<ExpectedFn>(&mut self,\n+                            pat_id: NodeId,\n+                            qself: Option<&QSelf>,\n+                            path: &Path,\n+                            namespace: Namespace,\n+                            expected_fn: ExpectedFn,\n+                            expected_what: &'static str)\n+        where ExpectedFn: FnOnce(Def) -> bool\n+    {\n+        let resolution = match self.resolve_possibly_assoc_item(pat_id, qself, path, namespace) {\n+            ResolveAttempt(resolution) => {\n+                if let Some(resolution) = resolution {\n+                    if resolution.depth == 0 {\n+                        if expected_fn(resolution.base_def) {\n+                            resolution\n+                        } else {\n                             resolve_error(\n                                 self,\n                                 path.span,\n-                                ResolutionError::UnresolvedEnumVariantStructOrConst(\n-                                    &path.segments.last().unwrap().identifier.name.as_str())\n+                                ResolutionError::PatPathUnexpected(expected_what,\n+                                                                   resolution.kind_name(), path)\n                             );\n+                            err_path_resolution()\n+                        }\n+                    } else {\n+                        // Not fully resolved associated item `T::A::B::C` or\n+                        // `<T as Tr>::A::B::C`. If `C` should be resolved in value\n+                        // namespace then it needs to be added to the trait map.\n+                        if namespace == ValueNS {\n+                            let item_name = path.segments.last().unwrap().identifier.name;\n+                            let traits = self.get_traits_containing_item(item_name);\n+                            self.trait_map.insert(pat_id, traits);\n                         }\n-                        self.record_def(pattern.id, err_path_resolution());\n+                        resolution\n                     }\n-                    visit::walk_path(self, path);\n+                } else {\n+                    if let Err(false) = self.resolve_path(pat_id, path, 0, namespace) {\n+                        resolve_error(\n+                            self,\n+                            path.span,\n+                            ResolutionError::PatPathUnresolved(expected_what, path)\n+                        );\n+                    }\n+                    err_path_resolution()\n+                }\n+            }\n+            TypecheckRequired => {\n+                // `<T>::A::B::C`, resolves exclusively during typechecking.\n+                // If `C` should be resolved in value namespace then it needs\n+                // to be added to the trait map.\n+                if namespace == ValueNS {\n+                    let item_name = path.segments.last().unwrap().identifier.name;\n+                    let traits = self.get_traits_containing_item(item_name);\n+                    self.trait_map.insert(pat_id, traits);\n                 }\n+                return;\n+            }\n+        };\n \n-                PatKind::QPath(ref qself, ref path) => {\n-                    // Associated constants only.\n-                    let resolution = match self.resolve_possibly_assoc_item(pat_id,\n-                                                                            Some(qself),\n-                                                                            path,\n-                                                                            ValueNS) {\n-                        TypecheckRequired => {\n-                            // All `<T>::CONST` should end up here, and will\n-                            // require use of the trait map to resolve\n-                            // during typechecking.\n-                            let const_name = path.segments\n-                                                 .last()\n-                                                 .unwrap()\n-                                                 .identifier\n-                                                 .name;\n-                            let traits = self.get_traits_containing_item(const_name);\n-                            self.trait_map.insert(pattern.id, traits);\n-                            visit::walk_pat(self, pattern);\n-                            return true;\n-                        }\n-                        ResolveAttempt(resolution) => resolution,\n-                    };\n-                    if let Some(path_res) = resolution {\n-                        match path_res.base_def {\n-                            // All `<T as Trait>::CONST` should end up here, and\n-                            // have the trait already selected.\n-                            Def::AssociatedConst(..) => {\n-                                self.record_def(pattern.id, path_res);\n+        self.record_def(pat_id, resolution);\n+    }\n+\n+    fn resolve_pattern(&mut self,\n+                       pat: &Pat,\n+                       pat_src: PatternSource,\n+                       // Maps idents to the node ID for the\n+                       // outermost pattern that binds them.\n+                       bindings_list: &mut HashMap<Name, NodeId>) {\n+        // Visit all direct subpatterns of this pattern with the same PatternBindingMode.\n+        let outer_pat_id = pat.id;\n+        pat.walk(&mut |pat| {\n+            match pat.node {\n+                PatKind::Ident(bmode, ref ident, ref opt_pat) => {\n+                    // First try to resolve the identifier as some existing\n+                    // entity, then fall back to a fresh binding.\n+                    let resolution = if let Ok(resolution) = self.resolve_path(pat.id,\n+                                &Path::from_ident(ident.span, ident.node), 0, ValueNS) {\n+                        let always_binding = !pat_src.is_refutable() || opt_pat.is_some() ||\n+                                             bmode != BindingMode::ByValue(Mutability::Immutable);\n+                        match resolution.base_def {\n+                            // Def::Err => {\n+                            //     // Just pass it through, the error is already\n+                            //     // reported if it was necessary.\n+                            //     resolution\n+                            // }\n+                            Def::Struct(..) | Def::Variant(..) |\n+                            Def::Const(..) | Def::AssociatedConst(..) if !always_binding => {\n+                                // A constant, unit variant, etc pattern.\n+                                resolution\n                             }\n-                            _ => {\n+                            Def::Struct(..) | Def::Variant(..) |\n+                            Def::Const(..) | Def::AssociatedConst(..) | Def::Static(..) => {\n+                                // A fresh binding that shadows something unacceptable.\n                                 resolve_error(\n                                     self,\n-                                    path.span,\n-                                    ResolutionError::NotAnAssociatedConst(\n-                                        &path.segments.last().unwrap().identifier.name.as_str()\n-                                    )\n+                                    ident.span,\n+                                    ResolutionError::BindingShadowsSomethingUnacceptable(\n+                                        pat_src.descr(), resolution.kind_name(), ident.node.name)\n                                 );\n-                                self.record_def(pattern.id, err_path_resolution());\n+                                err_path_resolution()\n+                            }\n+                            Def::Local(..) | Def::Upvar(..) | Def::Fn(..) | Def::Err => {\n+                                // These entities are explicitly allowed\n+                                // to be shadowed by fresh bindings.\n+                                self.fresh_binding(ident, pat.id, outer_pat_id,\n+                                                   pat_src, bindings_list)\n+                            }\n+                            def => {\n+                                span_bug!(ident.span, \"unexpected definition for an \\\n+                                                       identifier in pattern {:?}\", def);\n                             }\n                         }\n                     } else {\n-                        resolve_error(self,\n-                                      path.span,\n-                                      ResolutionError::UnresolvedAssociatedConst(&path.segments\n-                                                                                      .last()\n-                                                                                      .unwrap()\n-                                                                                      .identifier\n-                                                                                      .name\n-                                                                                      .as_str()));\n-                        self.record_def(pattern.id, err_path_resolution());\n-                    }\n-                    visit::walk_pat(self, pattern);\n+                        // Fall back to a fresh binding.\n+                        self.fresh_binding(ident, pat.id, outer_pat_id, pat_src, bindings_list)\n+                    };\n+\n+                    self.record_def(pat.id, resolution);\n                 }\n \n-                PatKind::Struct(ref path, _, _) => {\n-                    match self.resolve_path(pat_id, path, 0, TypeNS) {\n-                        Ok(definition) => {\n-                            self.record_def(pattern.id, definition);\n+                PatKind::TupleStruct(ref path, _, _) => {\n+                    self.resolve_pattern_path(pat.id, None, path, ValueNS, |def| {\n+                        match def {\n+                            Def::Struct(..) | Def::Variant(..) | Def::Err => true,\n+                            _ => false,\n                         }\n-                        Err(true) => self.record_def(pattern.id, err_path_resolution()),\n-                        Err(false) => {\n-                            resolve_error(\n-                                self,\n-                                path.span,\n-                                ResolutionError::DoesNotNameAStruct(\n-                                    &path_names_to_string(path, 0))\n-                            );\n-                            self.record_def(pattern.id, err_path_resolution());\n+                    }, \"variant or struct\");\n+                }\n+\n+                PatKind::Path(ref path) => {\n+                    self.resolve_pattern_path(pat.id, None, path, ValueNS, |def| {\n+                        match def {\n+                            Def::Struct(..) | Def::Variant(..) |\n+                            Def::Const(..) | Def::AssociatedConst(..) | Def::Err => true,\n+                            _ => false,\n                         }\n-                    }\n-                    visit::walk_path(self, path);\n+                    }, \"variant, struct or constant\");\n                 }\n \n-                PatKind::Lit(_) | PatKind::Range(..) => {\n-                    visit::walk_pat(self, pattern);\n+                PatKind::QPath(ref qself, ref path) => {\n+                    self.resolve_pattern_path(pat.id, Some(qself), path, ValueNS, |def| {\n+                        match def {\n+                            Def::AssociatedConst(..) | Def::Err => true,\n+                            _ => false,\n+                        }\n+                    }, \"associated constant\");\n                 }\n \n-                _ => {\n-                    // Nothing to do.\n+                PatKind::Struct(ref path, _, _) => {\n+                    self.resolve_pattern_path(pat.id, None, path, TypeNS, |def| {\n+                        match def {\n+                            Def::Struct(..) | Def::Variant(..) |\n+                            Def::TyAlias(..) | Def::AssociatedTy(..) | Def::Err => true,\n+                            _ => false,\n+                        }\n+                    }, \"variant, struct or type alias\");\n                 }\n+\n+                _ => {}\n             }\n             true\n         });\n-    }\n-\n-    fn resolve_bare_identifier_pattern(&mut self, ident: ast::Ident, span: Span)\n-                                       -> BareIdentifierPatternResolution<'a> {\n-        let binding = match self.resolve_ident_in_lexical_scope(ident, ValueNS, true) {\n-            Some(LexicalScopeBinding::Item(binding)) => binding,\n-            _ => return BareIdentifierPatternUnresolved,\n-        };\n-        let def = binding.def().unwrap();\n \n-        match def {\n-            Def::Variant(..) | Def::Struct(..) => FoundStructOrEnumVariant(def),\n-            Def::Const(..) | Def::AssociatedConst(..) => FoundConst(binding, ident.name),\n-            Def::Static(..) => {\n-                let error = ResolutionError::StaticVariableReference(binding);\n-                resolve_error(self, span, error);\n-                BareIdentifierPatternUnresolved\n-            }\n-            _ => BareIdentifierPatternUnresolved,\n-        }\n+        visit::walk_pat(self, pat);\n     }\n \n     /// Handles paths that may refer to associated items\n     fn resolve_possibly_assoc_item(&mut self,\n                                    id: NodeId,\n-                                   maybe_qself: Option<&ast::QSelf>,\n+                                   maybe_qself: Option<&QSelf>,\n                                    path: &Path,\n                                    namespace: Namespace)\n                                    -> AssocItemResolveResult {\n@@ -2579,13 +2469,14 @@ impl<'a> Resolver<'a> {\n                 break;\n             }\n             self.with_no_errors(|this| {\n-                resolution = this.resolve_path(id, path, depth, TypeNS).ok();\n+                let partial_resolution = this.resolve_path(id, path, depth, TypeNS).ok();\n+                if let Some(Def::Mod(..)) = partial_resolution.map(|r| r.base_def) {\n+                    // Modules cannot have associated items\n+                } else {\n+                    resolution = partial_resolution;\n+                }\n             });\n         }\n-        if let Some(Def::Mod(_)) = resolution.map(|r| r.base_def) {\n-            // A module is not a valid type or value.\n-            resolution = None;\n-        }\n         ResolveAttempt(resolution)\n     }\n \n@@ -3171,7 +3062,7 @@ impl<'a> Resolver<'a> {\n                 self.visit_expr(subexpression);\n \n                 self.value_ribs.push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, RefutableMode, &mut HashMap::new());\n+                self.resolve_pattern(pattern, PatternSource::IfLet, &mut HashMap::new());\n                 self.visit_block(if_block);\n                 self.value_ribs.pop();\n \n@@ -3181,7 +3072,7 @@ impl<'a> Resolver<'a> {\n             ExprKind::WhileLet(ref pattern, ref subexpression, ref block, label) => {\n                 self.visit_expr(subexpression);\n                 self.value_ribs.push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, RefutableMode, &mut HashMap::new());\n+                self.resolve_pattern(pattern, PatternSource::WhileLet, &mut HashMap::new());\n \n                 self.resolve_labeled_block(label.map(|l| l.node), expr.id, block);\n \n@@ -3191,7 +3082,7 @@ impl<'a> Resolver<'a> {\n             ExprKind::ForLoop(ref pattern, ref subexpression, ref block, label) => {\n                 self.visit_expr(subexpression);\n                 self.value_ribs.push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, LocalIrrefutableMode, &mut HashMap::new());\n+                self.resolve_pattern(pattern, PatternSource::For, &mut HashMap::new());\n \n                 self.resolve_labeled_block(label.map(|l| l.node), expr.id, block);\n \n@@ -3411,20 +3302,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn enforce_default_binding_mode(&mut self,\n-                                    pat: &Pat,\n-                                    pat_binding_mode: BindingMode,\n-                                    descr: &str) {\n-        match pat_binding_mode {\n-            BindingMode::ByValue(_) => {}\n-            BindingMode::ByRef(..) => {\n-                resolve_error(self,\n-                              pat.span,\n-                              ResolutionError::CannotUseRefBindingModeWith(descr));\n-            }\n-        }\n-    }\n-\n     fn resolve_visibility(&mut self, vis: &ast::Visibility) -> ty::Visibility {\n         let (path, id) = match *vis {\n             ast::Visibility::Public => return ty::Visibility::Public,"}, {"sha": "6ebe80b5701b9dbcb090da8e330833df9f6cd88f", "filename": "src/test/compile-fail/associated-const-private-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fassociated-const-private-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fassociated-const-private-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-private-impl.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -23,5 +23,5 @@ mod bar1 {\n \n fn main() {\n     assert_eq!(1, bar1::Foo::ID);\n-    //~^ERROR associated const `ID` is private\n+    //~^ERROR associated constant `ID` is private\n }"}, {"sha": "f57727b773d635a87608b4e4e08a4233d1408c6f", "filename": "src/test/compile-fail/blind-item-block-middle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fblind-item-block-middle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fblind-item-block-middle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblind-item-block-middle.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -12,6 +12,6 @@ mod foo { pub struct bar; }\n \n fn main() {\n     let bar = 5;\n-    //~^ ERROR cannot be named the same\n+    //~^ ERROR let bindings cannot shadow structs\n     use foo::bar;\n }"}, {"sha": "75b6397f4ebd71ac5c7260acb3c93b57179aa481", "filename": "src/test/compile-fail/const-pattern-irrefutable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fconst-pattern-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fconst-pattern-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-pattern-irrefutable.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -19,10 +19,10 @@ use foo::d; //~ NOTE is imported here\n const a: u8 = 2; //~ NOTE is defined here\n \n fn main() {\n-    let a = 4; //~ ERROR let variables cannot\n-               //~^ NOTE cannot be named the same as a const variable\n-    let c = 4; //~ ERROR let variables cannot\n-               //~^ NOTE cannot be named the same as a const variable\n-    let d = 4; //~ ERROR let variables cannot\n-               //~^ NOTE cannot be named the same as a const variable\n+    let a = 4; //~ ERROR let bindings cannot shadow constants\n+               //~^ NOTE cannot be named the same as a constant\n+    let c = 4; //~ ERROR let bindings cannot shadow constants\n+               //~^ NOTE cannot be named the same as a constant\n+    let d = 4; //~ ERROR let bindings cannot shadow constants\n+               //~^ NOTE cannot be named the same as a constant\n }"}, {"sha": "0522a654a8528200a661fda6393ce0e836675e9e", "filename": "src/test/compile-fail/empty-struct-braces-pat-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-2.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -29,9 +29,9 @@ fn main() {\n     //     XEmpty1() => () // ERROR unresolved enum variant, struct or const `XEmpty1`\n     // }\n     match e1 {\n-        Empty1(..) => () //~ ERROR unresolved enum variant, struct or const `Empty1`\n+        Empty1(..) => () //~ ERROR unresolved variant or struct `Empty1`\n     }\n     match xe1 {\n-        XEmpty1(..) => () //~ ERROR unresolved enum variant, struct or const `XEmpty1`\n+        XEmpty1(..) => () //~ ERROR unresolved variant or struct `XEmpty1`\n     }\n }"}, {"sha": "e89b08a8a06510fd63a0f2adf7363f5bb0719e1e", "filename": "src/test/compile-fail/enum-in-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fenum-in-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fenum-in-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-in-scope.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -11,5 +11,5 @@\n struct hello(isize);\n \n fn main() {\n-    let hello = 0; //~ERROR cannot be named the same\n+    let hello = 0; //~ERROR let bindings cannot shadow structs\n }"}, {"sha": "c847366a707a7e9cb933460749c826e512fffdfb", "filename": "src/test/compile-fail/enums-pats-not-idents.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fenums-pats-not-idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fenums-pats-not-idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenums-pats-not-idents.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//error-pattern:unresolved enum variant\n-\n fn main() {\n-    // a bug in the parser is allowing this:\n-    let a(1) = 13;\n+    let a(1) = 13; //~ ERROR unresolved variant or struct `a`\n }"}, {"sha": "9eec8487a50874cad88672d256b0fe5dd8c33a6e", "filename": "src/test/compile-fail/issue-10200.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-10200.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-10200.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10200.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -13,7 +13,7 @@ fn foo(_: usize) -> Foo { Foo(false) }\n \n fn main() {\n     match Foo(true) {\n-        foo(x) //~ ERROR `foo` is not an enum variant, struct or const\n+        foo(x) //~ ERROR expected variant or struct, found function `foo`\n         => ()\n     }\n }"}, {"sha": "7912410f69ea1f8d90d8647f951fe8667fccd245", "filename": "src/test/compile-fail/issue-12863.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-12863.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-12863.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12863.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -12,6 +12,6 @@ mod foo { pub fn bar() {} }\n \n fn main() {\n     match () {\n-        foo::bar => {} //~ ERROR `bar` is not an enum variant, struct or const\n+        foo::bar => {} //~ ERROR expected variant, struct or constant, found function `bar`\n     }\n }"}, {"sha": "60117bd88d46ad2b6e1a2323bd536bd40a2b8638", "filename": "src/test/compile-fail/issue-16149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-16149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-16149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16149.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -15,7 +15,7 @@ extern {\n fn main() {\n     let boolValue = match 42 {\n         externalValue => true,\n-        //~^ ERROR static variables cannot be referenced in a pattern\n+        //~^ ERROR match bindings cannot shadow statics\n         _ => false\n     };\n }"}, {"sha": "db43c1cce9947fa348602ea021e5ccf204575760", "filename": "src/test/compile-fail/issue-17405.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-17405.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-17405.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17405.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -14,6 +14,7 @@ enum Foo {\n \n fn main() {\n     match Foo::Bar(1) {\n-        Foo { i } => () //~ ERROR `Foo` does not name a struct or a struct variant\n+        Foo { i } => () //~ ERROR expected variant, struct or type alias, found enum `Foo`\n+        //~^ ERROR `Foo` does not name a struct or a struct variant\n     }\n }"}, {"sha": "523a387956a32e7e93b4f6175e588c6ce0d14b08", "filename": "src/test/compile-fail/issue-17718-const-privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-privacy.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -12,10 +12,10 @@\n \n extern crate issue_17718_const_privacy as other;\n \n-use a::B; //~ ERROR: const `B` is private\n+use a::B; //~ ERROR: constant `B` is private\n use other::{\n     FOO,\n-    BAR, //~ ERROR: const `BAR` is private\n+    BAR, //~ ERROR: constant `BAR` is private\n     FOO2,\n };\n "}, {"sha": "b9f5e98b6faa97d112d935888a800e068d25f54e", "filename": "src/test/compile-fail/issue-17718-patterns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-17718-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-17718-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-patterns.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -14,8 +14,8 @@ const A3: usize = 1;\n \n fn main() {\n     match 1 {\n-        A1 => {} //~ ERROR: static variables cannot be referenced in a pattern\n-        A2 => {} //~ ERROR: static variables cannot be referenced in a pattern\n+        A1 => {} //~ ERROR: match bindings cannot shadow statics\n+        A2 => {} //~ ERROR: match bindings cannot shadow statics\n         A3 => {}\n         _ => {}\n     }"}, {"sha": "2313a3fe9c6d518190355db24b1a721b03b42654", "filename": "src/test/compile-fail/issue-17933.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-17933.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-17933.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17933.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -13,7 +13,7 @@ pub static X: usize = 1;\n fn main() {\n     match 1 {\n         self::X => { },\n-        //~^ ERROR static variables cannot be referenced in a pattern, use a `const` instead\n+        //~^ ERROR expected variant, struct or constant, found static `X`\n         _       => { },\n     }\n }"}, {"sha": "5cf80dd172a3de7538ef5a863396dd466c5e0903", "filename": "src/test/compile-fail/issue-23716.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-23716.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-23716.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23716.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -9,21 +9,21 @@\n // except according to those terms.\n \n static foo: i32 = 0;\n-//~^ NOTE static variable defined here\n+//~^ NOTE a static `foo` is defined here\n \n fn bar(foo: i32) {}\n-//~^ ERROR static variables cannot be referenced in a pattern, use a `const` instead\n-//~| static variable used in pattern\n+//~^ ERROR function parameters cannot shadow statics\n+//~| cannot be named the same as a static\n \n mod submod {\n     pub static answer: i32 = 42;\n }\n \n use self::submod::answer;\n-//~^ NOTE static variable imported here\n+//~^ NOTE a static `answer` is imported here\n \n fn question(answer: i32) {}\n-//~^ ERROR static variables cannot be referenced in a pattern, use a `const` instead\n-//~| static variable used in pattern\n+//~^ ERROR function parameters cannot shadow statics\n+//~| cannot be named the same as a static\n fn main() {\n }"}, {"sha": "6cadbef33e7f0b4f9eb555b9d7425a9f8f9a2166", "filename": "src/test/compile-fail/issue-26459.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-26459.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-26459.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26459.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -11,6 +11,7 @@\n fn main() {\n     match 'a' {\n         char{ch} => true\n-        //~^ ERROR `char` does not name a struct or a struct variant\n+        //~^ ERROR expected variant, struct or type alias, found builtin type `char`\n+        //~| ERROR `char` does not name a struct or a struct variant\n     };\n }"}, {"sha": "2a015adb498e17780c4046056e0d75c7a1925106", "filename": "src/test/compile-fail/issue-27033.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-27033.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-27033.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27033.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -10,11 +10,11 @@\n \n fn main() {\n     match Some(1) {\n-        None @ _ => {} //~ ERROR cannot be named the same\n+        None @ _ => {} //~ ERROR match bindings cannot shadow variants\n     };\n     const C: u8 = 1;\n     match 1 {\n-        C @ 2 => { //~ ERROR cannot be named the same\n+        C @ 2 => { //~ ERROR match bindings cannot shadow constant\n             println!(\"{}\", C);\n         }\n         _ => {}"}, {"sha": "d2f9abd2e316b41539d235ebaaa6599f01cb5049", "filename": "src/test/compile-fail/issue-27815.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -14,7 +14,9 @@ fn main() {\n     let u = A { x: 1 }; //~ ERROR `A` does not name a structure\n     let v = u32 { x: 1 }; //~ ERROR `u32` does not name a structure\n     match () {\n-        A { x: 1 } => {} //~ ERROR `A` does not name a struct\n-        u32 { x: 1 } => {} //~ ERROR `u32` does not name a struct\n+        A { x: 1 } => {} //~ ERROR expected variant, struct or type alias, found module `A`\n+        //~^ ERROR `A` does not name a struct or a struct variant\n+        u32 { x: 1 } => {} //~ ERROR expected variant, struct or type alias, found builtin type `u32\n+        //~^ ERROR `u32` does not name a struct or a struct variant\n     }\n }"}, {"sha": "e492d48fdaf0f041f65109bbe4d8f64f661238f1", "filename": "src/test/compile-fail/issue-28992-empty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-28992-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-28992-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28992-empty.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -21,6 +21,6 @@ impl S {\n }\n \n fn main() {\n-    if let C1(..) = 0 {} //~ ERROR `C1` does not name a tuple variant or a tuple struct\n+    if let C1(..) = 0 {} //~ ERROR expected variant or struct, found constant `C1`\n     if let S::C2(..) = 0 {} //~ ERROR `S::C2` does not name a tuple variant or a tuple struct\n }"}, {"sha": "3a8ff12429ab374fc0d36f5376a374a63b48b958", "filename": "src/test/compile-fail/issue-5927.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-5927.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fissue-5927.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5927.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -11,7 +11,7 @@\n \n fn main() {\n     let z = match 3 {\n-        x(1) => x(1) //~ ERROR unresolved enum variant\n+        x(1) => x(1) //~ ERROR unresolved variant or struct `x`\n         //~^ ERROR unresolved name `x`\n     };\n     assert!(z == 3);"}, {"sha": "1cba64ccf2cde48a7886c2c9b8a3560c5ba61414", "filename": "src/test/compile-fail/method-resolvable-path-in-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fmethod-resolvable-path-in-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fmethod-resolvable-path-in-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-resolvable-path-in-pattern.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -19,6 +19,6 @@ impl MyTrait for Foo {}\n fn main() {\n     match 0u32 {\n         <Foo as MyTrait>::trait_bar => {}\n-        //~^ ERROR `trait_bar` is not an associated const\n+        //~^ ERROR expected associated constant, found method `trait_bar`\n     }\n }"}, {"sha": "2e2d53c4d40b6400854c1bcc3c15a1296f06ffdb", "filename": "src/test/compile-fail/name-clash-nullary.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fname-clash-nullary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fname-clash-nullary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fname-clash-nullary.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:cannot be named the same\n use std::option::*;\n \n fn main() {\n-  let None: isize = 42;\n+  let None: isize = 42; //~ ERROR let bindings cannot shadow variants\n   log(debug, None);\n+  //~^ ERROR unresolved name `debug`\n+  //~| ERROR unresolved name `log`\n }"}, {"sha": "f1683e51c648d2b0b069262794984c2c0b0cab43", "filename": "src/test/compile-fail/pat-shadow-in-nested-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fpat-shadow-in-nested-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fpat-shadow-in-nested-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpat-shadow-in-nested-binding.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -11,5 +11,5 @@\n struct foo(usize);\n \n fn main() {\n-    let (foo, _) = (2, 3); //~ ERROR `foo` cannot be named the same as\n+    let (foo, _) = (2, 3); //~ ERROR let bindings cannot shadow structs\n }"}, {"sha": "86873022f0ff10b666941c3cd86cdefcac106ffa", "filename": "src/test/compile-fail/qualified-path-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -27,7 +27,7 @@ impl S {\n \n fn main() {\n     match 10 {\n-        <S as Tr>::A::f::<u8> => {} //~ ERROR `f` is not an associated const\n+        <S as Tr>::A::f::<u8> => {} //~ ERROR associated items in match patterns must be constants\n         0 ... <S as Tr>::A::f::<u8> => {} //~ ERROR only char and numeric types are allowed in range\n     }\n }"}, {"sha": "351a47fdf3923191d85505cd034f57f8eaf41ff6", "filename": "src/test/compile-fail/static-mut-not-pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-pat.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -20,7 +20,7 @@ fn main() {\n     // instead of spitting out a custom error about some identifier collisions\n     // (we should allow shadowing)\n     match 4 {\n-        a => {} //~ ERROR static variables cannot be referenced in a pattern\n+        a => {} //~ ERROR match bindings cannot shadow statics\n         _ => {}\n     }\n }\n@@ -44,7 +44,7 @@ fn mutable_statics() {\n     match (Foo { bar: Some(Direction::North), baz: NewBool(true) }) {\n         Foo { bar: None, baz: NewBool(true) } => (),\n         STATIC_MUT_FOO => (),\n-        //~^ ERROR static variables cannot be referenced in a pattern\n+        //~^ ERROR match bindings cannot shadow statics\n         Foo { bar: Some(Direction::South), .. } => (),\n         Foo { bar: Some(EAST), .. } => (),\n         Foo { bar: Some(Direction::North), baz: NewBool(true) } => (),"}, {"sha": "1fe8f6294da2118c0e9506de421aeca10f5a0579", "filename": "src/test/compile-fail/trait-impl-for-module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Ftrait-impl-for-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b9dabdebb95b689d335b98a8890923d9af7f7e/src%2Ftest%2Fcompile-fail%2Ftrait-impl-for-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-impl-for-module.rs?ref=91b9dabdebb95b689d335b98a8890923d9af7f7e", "patch": "@@ -14,7 +14,7 @@ mod a {\n trait A {\n }\n \n-impl A for a { //~ ERROR type name `a` is undefined or not in scope\n+impl A for a { //~ ERROR expected type, found module\n }\n \n fn main() {"}]}