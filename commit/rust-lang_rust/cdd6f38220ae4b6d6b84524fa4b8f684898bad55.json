{"sha": "cdd6f38220ae4b6d6b84524fa4b8f684898bad55", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkZDZmMzgyMjBhZTRiNmQ2Yjg0NTI0ZmE0YjhmNjg0ODk4YmFkNTU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-02-21T19:08:50Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-02-21T23:44:54Z"}, "message": "librustc: De-mut resolve. rs=demuting", "tree": {"sha": "adecc8840909fd06fb426968071a5474dfac4543", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adecc8840909fd06fb426968071a5474dfac4543"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdd6f38220ae4b6d6b84524fa4b8f684898bad55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdd6f38220ae4b6d6b84524fa4b8f684898bad55", "html_url": "https://github.com/rust-lang/rust/commit/cdd6f38220ae4b6d6b84524fa4b8f684898bad55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdd6f38220ae4b6d6b84524fa4b8f684898bad55/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0767bf24f7a526430472290825ebd9158cb1dcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0767bf24f7a526430472290825ebd9158cb1dcc", "html_url": "https://github.com/rust-lang/rust/commit/e0767bf24f7a526430472290825ebd9158cb1dcc"}], "stats": {"total": 396, "additions": 223, "deletions": 173}, "files": [{"sha": "9c5e4b9f0e08638f14df88dcae041499dbaef7e3", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 223, "deletions": 173, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/cdd6f38220ae4b6d6b84524fa4b8f684898bad55/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdd6f38220ae4b6d6b84524fa4b8f684898bad55/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=cdd6f38220ae4b6d6b84524fa4b8f684898bad55", "patch": "@@ -150,7 +150,7 @@ pub enum NamespaceResult {\n     UnboundResult,\n     /// Means that resolve has determined that the name is bound in the Module\n     /// argument, and specified by the NameBindings argument.\n-    BoundResult(@Module, @mut NameBindings)\n+    BoundResult(@mut Module, @mut NameBindings)\n }\n \n pub impl NamespaceResult {\n@@ -196,7 +196,7 @@ pub enum ImportDirectiveSubclass {\n \n /// The context that we thread through while building the reduced graph.\n pub enum ReducedGraphParent {\n-    ModuleReducedGraphParent(@Module)\n+    ModuleReducedGraphParent(@mut Module)\n }\n \n pub enum ResolveResult<T> {\n@@ -293,7 +293,7 @@ pub enum SearchThroughModulesFlag {\n \n pub enum ModulePrefixResult {\n     NoPrefixFound,\n-    PrefixFound(@Module, uint)\n+    PrefixFound(@mut Module, uint)\n }\n \n #[deriving_eq]\n@@ -368,11 +368,13 @@ pub fn ImportDirective(privacy: Privacy,\n \n /// The item that an import resolves to.\n pub struct Target {\n-    target_module: @Module,\n+    target_module: @mut Module,\n     bindings: @mut NameBindings,\n }\n \n-pub fn Target(target_module: @Module, bindings: @mut NameBindings) -> Target {\n+pub fn Target(target_module: @mut Module,\n+              bindings: @mut NameBindings)\n+           -> Target {\n     Target {\n         target_module: target_module,\n         bindings: bindings\n@@ -435,8 +437,8 @@ pub fn ImportState() -> ImportState {\n /// The link from a module up to its nearest parent node.\n pub enum ParentLink {\n     NoParentLink,\n-    ModuleParentLink(@Module, ident),\n-    BlockParentLink(@Module, node_id)\n+    ModuleParentLink(@mut Module, ident),\n+    BlockParentLink(@mut Module, node_id)\n }\n \n /// The type of module this is.\n@@ -450,11 +452,11 @@ pub enum ModuleKind {\n /// One node in the tree of modules.\n pub struct Module {\n     parent_link: ParentLink,\n-    mut def_id: Option<def_id>,\n+    def_id: Option<def_id>,\n     kind: ModuleKind,\n \n-    children: HashMap<ident,@mut NameBindings>,\n-    imports: DVec<@ImportDirective>,\n+    children: @HashMap<ident,@mut NameBindings>,\n+    imports: @DVec<@ImportDirective>,\n \n     // The anonymous children of this node. Anonymous children are pseudo-\n     // modules that are implicitly created around items contained within\n@@ -471,16 +473,16 @@ pub struct Module {\n     // There will be an anonymous module created around `g` with the ID of the\n     // entry block for `f`.\n \n-    anonymous_children: HashMap<node_id,@Module>,\n+    anonymous_children: @HashMap<node_id,@mut Module>,\n \n     // The status of resolving each import in this module.\n-    import_resolutions: HashMap<ident,@mut ImportResolution>,\n+    import_resolutions: @HashMap<ident,@mut ImportResolution>,\n \n     // The number of unresolved globs that this module exports.\n-    mut glob_count: uint,\n+    glob_count: uint,\n \n     // The index of the import we're resolving.\n-    mut resolved_import_count: uint,\n+    resolved_import_count: uint,\n }\n \n pub fn Module(parent_link: ParentLink,\n@@ -491,10 +493,10 @@ pub fn Module(parent_link: ParentLink,\n         parent_link: parent_link,\n         def_id: def_id,\n         kind: kind,\n-        children: HashMap(),\n-        imports: DVec(),\n-        anonymous_children: HashMap(),\n-        import_resolutions: HashMap(),\n+        children: @HashMap(),\n+        imports: @DVec(),\n+        anonymous_children: @HashMap(),\n+        import_resolutions: @HashMap(),\n         glob_count: 0,\n         resolved_import_count: 0\n     }\n@@ -519,7 +521,7 @@ pub fn unused_import_lint_level(session: Session) -> level {\n // Records a possibly-private type definition.\n pub struct TypeNsDef {\n     privacy: Privacy,\n-    module_def: Option<@Module>,\n+    module_def: Option<@mut Module>,\n     type_def: Option<def>\n }\n \n@@ -550,7 +552,7 @@ pub impl NameBindings {\n                      kind: ModuleKind,\n                      sp: span) {\n         // Merges the module with the existing type def or creates a new one.\n-        let module_ = @Module(parent_link, def_id, kind);\n+        let module_ = @mut Module(parent_link, def_id, kind);\n         match self.type_def {\n             None => {\n                 self.type_def = Some(TypeNsDef {\n@@ -599,7 +601,7 @@ pub impl NameBindings {\n     }\n \n     /// Returns the module node if applicable.\n-    fn get_module_if_available() -> Option<@Module> {\n+    fn get_module_if_available() -> Option<@mut Module> {\n         match self.type_def {\n             Some(ref type_def) => (*type_def).module_def,\n             None => None\n@@ -610,7 +612,7 @@ pub impl NameBindings {\n      * Returns the module node. Fails if this node does not have a module\n      * definition.\n      */\n-    fn get_module(@mut self) -> @Module {\n+    fn get_module(@mut self) -> @mut Module {\n         match self.get_module_if_available() {\n             None => {\n                 fail!(~\"get_module called on a node with no module \\\n@@ -759,7 +761,7 @@ pub fn Resolver(session: Session,\n     let current_module = graph_root.get_module();\n \n     let self = Resolver {\n-        session: session,\n+        session: @session,\n         lang_items: copy lang_items,\n         crate: crate,\n \n@@ -770,8 +772,8 @@ pub fn Resolver(session: Session,\n \n         unused_import_lint_level: unused_import_lint_level(session),\n \n-        trait_info: HashMap(),\n-        structs: HashMap(),\n+        trait_info: @HashMap(),\n+        structs: @HashMap(),\n \n         unresolved_imports: 0,\n \n@@ -794,8 +796,8 @@ pub fn Resolver(session: Session,\n         attr_main_fn: None,\n         main_fns: ~[],\n \n-        def_map: HashMap(),\n-        export_map2: HashMap(),\n+        def_map: @HashMap(),\n+        export_map2: @HashMap(),\n         trait_map: @HashMap(),\n \n         intr: session.intr()\n@@ -806,7 +808,7 @@ pub fn Resolver(session: Session,\n \n /// The main resolver class.\n pub struct Resolver {\n-    session: Session,\n+    session: @Session,\n     lang_items: LanguageItems,\n     crate: @crate,\n \n@@ -816,14 +818,14 @@ pub struct Resolver {\n \n     unused_import_lint_level: level,\n \n-    trait_info: HashMap<def_id,@HashMap<ident,()>>,\n-    structs: HashMap<def_id,()>,\n+    trait_info: @HashMap<def_id,@HashMap<ident,()>>,\n+    structs: @HashMap<def_id,()>,\n \n     // The number of imports that are currently unresolved.\n-    mut unresolved_imports: uint,\n+    unresolved_imports: uint,\n \n     // The module that represents the current item scope.\n-    mut current_module: @Module,\n+    current_module: @mut Module,\n \n     // The current set of local scopes, for values.\n     // FIXME #4948: Reuse ribs to avoid allocation.\n@@ -837,10 +839,10 @@ pub struct Resolver {\n \n     // Whether the current context is an X-ray context. An X-ray context is\n     // allowed to access private names of any module.\n-    mut xray_context: XrayFlag,\n+    xray_context: XrayFlag,\n \n     // The trait that the current context can refer to.\n-    mut current_trait_refs: Option<@DVec<def_id>>,\n+    current_trait_refs: Option<@DVec<def_id>>,\n \n     // The ident for the keyword \"self\".\n     self_ident: ident,\n@@ -854,19 +856,19 @@ pub struct Resolver {\n     namespaces: ~[Namespace],\n \n     // The function that has attribute named 'main'\n-    mut attr_main_fn: Option<(node_id, span)>,\n+    attr_main_fn: Option<(node_id, span)>,\n     // The functions named 'main'\n-    mut main_fns: ~[Option<(node_id, span)>],\n+    main_fns: ~[Option<(node_id, span)>],\n \n-    def_map: DefMap,\n-    export_map2: ExportMap2,\n+    def_map: @DefMap,\n+    export_map2: @ExportMap2,\n     trait_map: TraitMap,\n }\n \n pub impl Resolver {\n     /// The main name resolution procedure.\n-    fn resolve(@self, this: @Resolver) {\n-        self.build_reduced_graph(this);\n+    fn resolve(@mut self) {\n+        self.build_reduced_graph();\n         self.session.abort_if_errors();\n \n         self.resolve_imports();\n@@ -890,25 +892,25 @@ pub impl Resolver {\n     //\n \n     /// Constructs the reduced graph for the entire crate.\n-    fn build_reduced_graph(this: @Resolver) {\n+    fn build_reduced_graph(@mut self) {\n         let initial_parent =\n             ModuleReducedGraphParent(self.graph_root.get_module());\n         visit_crate(*self.crate, initial_parent, mk_vt(@Visitor {\n             visit_item: |item, context, visitor|\n-                (*this).build_reduced_graph_for_item(item, context, visitor),\n+                self.build_reduced_graph_for_item(item, context, visitor),\n \n             visit_foreign_item: |foreign_item, context, visitor|\n-                (*this).build_reduced_graph_for_foreign_item(foreign_item,\n+                self.build_reduced_graph_for_foreign_item(foreign_item,\n                                                              context,\n                                                              visitor),\n \n             visit_view_item: |view_item, context, visitor|\n-                (*this).build_reduced_graph_for_view_item(view_item,\n+                self.build_reduced_graph_for_view_item(view_item,\n                                                           context,\n                                                           visitor),\n \n             visit_block: |block, context, visitor|\n-                (*this).build_reduced_graph_for_block(block,\n+                self.build_reduced_graph_for_block(block,\n                                                       context,\n                                                       visitor),\n \n@@ -917,8 +919,9 @@ pub impl Resolver {\n     }\n \n     /// Returns the current module tracked by the reduced graph parent.\n-    fn get_module_from_parent(reduced_graph_parent: ReducedGraphParent)\n-                           -> @Module {\n+    fn get_module_from_parent(@mut self,\n+                              reduced_graph_parent: ReducedGraphParent)\n+                           -> @mut Module {\n         match reduced_graph_parent {\n             ModuleReducedGraphParent(module_) => {\n                 return module_;\n@@ -936,7 +939,8 @@ pub impl Resolver {\n      * If this node does not have a module definition and we are not inside\n      * a block, fails.\n      */\n-    fn add_child(name: ident,\n+    fn add_child(@mut self,\n+                 name: ident,\n                  reduced_graph_parent: ReducedGraphParent,\n                  duplicate_checking_mode: DuplicateCheckingMode,\n                  // For printing errors\n@@ -1023,7 +1027,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn block_needs_anonymous_module(block: blk) -> bool {\n+    fn block_needs_anonymous_module(@mut self, block: blk) -> bool {\n         // If the block has view items, we need an anonymous module.\n         if block.node.view_items.len() > 0 {\n             return true;\n@@ -1054,8 +1058,10 @@ pub impl Resolver {\n         return false;\n     }\n \n-    fn get_parent_link(parent: ReducedGraphParent,\n-                       name: ident) -> ParentLink {\n+    fn get_parent_link(@mut self,\n+                       parent: ReducedGraphParent,\n+                       name: ident)\n+                    -> ParentLink {\n         match parent {\n             ModuleReducedGraphParent(module_) => {\n                 return ModuleParentLink(module_, name);\n@@ -1064,7 +1070,8 @@ pub impl Resolver {\n     }\n \n     /// Constructs the reduced graph for one item.\n-    fn build_reduced_graph_for_item(item: @item,\n+    fn build_reduced_graph_for_item(@mut self,\n+                                    item: @item,\n                                     parent: ReducedGraphParent,\n                                     &&visitor: vt<ReducedGraphParent>) {\n         let ident = item.ident;\n@@ -1339,12 +1346,12 @@ pub impl Resolver {\n \n     // Constructs the reduced graph for one variant. Variants exist in the\n     // type and/or value namespaces.\n-    fn build_reduced_graph_for_variant(variant: variant,\n+    fn build_reduced_graph_for_variant(@mut self,\n+                                       variant: variant,\n                                        item_id: def_id,\n                                        +parent_privacy: Privacy,\n                                        parent: ReducedGraphParent,\n                                        &&visitor: vt<ReducedGraphParent>) {\n-\n         let ident = variant.node.name;\n         let (child, _) = self.add_child(ident, parent, ForbidDuplicateValues,\n                                         variant.span);\n@@ -1387,7 +1394,8 @@ pub impl Resolver {\n      * Constructs the reduced graph for one 'view item'. View items consist\n      * of imports and use directives.\n      */\n-    fn build_reduced_graph_for_view_item(view_item: @view_item,\n+    fn build_reduced_graph_for_view_item(@mut self,\n+                                         view_item: @view_item,\n                                          parent: ReducedGraphParent,\n                                          &&_visitor: vt<ReducedGraphParent>) {\n         let privacy = visibility_to_privacy(view_item.vis);\n@@ -1495,11 +1503,11 @@ pub impl Resolver {\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n-    fn build_reduced_graph_for_foreign_item(foreign_item: @foreign_item,\n+    fn build_reduced_graph_for_foreign_item(@mut self,\n+                                            foreign_item: @foreign_item,\n                                             parent: ReducedGraphParent,\n                                             &&visitor:\n                                                 vt<ReducedGraphParent>) {\n-\n         let name = foreign_item.ident;\n         let (name_bindings, new_parent) =\n             self.add_child(name, parent, ForbidDuplicateValues,\n@@ -1525,10 +1533,10 @@ pub impl Resolver {\n         }\n     }\n \n-    fn build_reduced_graph_for_block(block: blk,\n+    fn build_reduced_graph_for_block(@mut self,\n+                                     block: blk,\n                                      parent: ReducedGraphParent,\n                                      &&visitor: vt<ReducedGraphParent>) {\n-\n         let mut new_parent;\n         if self.block_needs_anonymous_module(block) {\n             let block_id = block.node.id;\n@@ -1538,9 +1546,10 @@ pub impl Resolver {\n                    block_id);\n \n             let parent_module = self.get_module_from_parent(parent);\n-            let new_module = @Module(BlockParentLink(parent_module, block_id),\n-                                     None,\n-                                     AnonymousModuleKind);\n+            let new_module = @mut Module(\n+                BlockParentLink(parent_module, block_id),\n+                None,\n+                AnonymousModuleKind);\n             parent_module.anonymous_children.insert(block_id, new_module);\n             new_parent = ModuleReducedGraphParent(new_module);\n         } else {\n@@ -1550,8 +1559,9 @@ pub impl Resolver {\n         visit_block(block, new_parent, visitor);\n     }\n \n-    fn handle_external_def(def: def,\n-                           modules: HashMap<def_id, @Module>,\n+    fn handle_external_def(@mut self,\n+                           def: def,\n+                           modules: HashMap<def_id, @mut Module>,\n                            child_name_bindings: @mut NameBindings,\n                            final_ident: &str,\n                            ident: ident,\n@@ -1671,7 +1681,7 @@ pub impl Resolver {\n      * Builds the reduced graph rooted at the 'use' directive for an external\n      * crate.\n      */\n-    fn build_reduced_graph_for_external_crate(root: @Module) {\n+    fn build_reduced_graph_for_external_crate(@mut self, root: @mut Module) {\n         let modules = HashMap();\n \n         // Create all the items reachable by paths.\n@@ -1842,8 +1852,9 @@ pub impl Resolver {\n     }\n \n     /// Creates and adds an import directive to the given module.\n-    fn build_import_directive(privacy: Privacy,\n-                              module_: @Module,\n+    fn build_import_directive(@mut self,\n+                              privacy: Privacy,\n+                              module_: @mut Module,\n                               module_path: @DVec<ident>,\n                               subclass: @ImportDirectiveSubclass,\n                               span: span,\n@@ -1908,7 +1919,7 @@ pub impl Resolver {\n      * Resolves all imports for the crate. This method performs the fixed-\n      * point iteration.\n      */\n-    fn resolve_imports() {\n+    fn resolve_imports(@mut self) {\n         let mut i = 0;\n         let mut prev_unresolved_imports = 0;\n         loop {\n@@ -1938,7 +1949,7 @@ pub impl Resolver {\n      * Attempts to resolve imports for the given module and all of its\n      * submodules.\n      */\n-    fn resolve_imports_for_module_subtree(module_: @Module) {\n+    fn resolve_imports_for_module_subtree(@mut self, module_: @mut Module) {\n         debug!(\"(resolving imports for module subtree) resolving %s\",\n                self.module_to_str(module_));\n         self.resolve_imports_for_module(module_);\n@@ -1960,7 +1971,7 @@ pub impl Resolver {\n     }\n \n     /// Attempts to resolve imports for the given module only.\n-    fn resolve_imports_for_module(module_: @Module) {\n+    fn resolve_imports_for_module(@mut self, module_: @mut Module) {\n         if (*module_).all_imports_resolved() {\n             debug!(\"(resolving imports for module) all imports resolved for \\\n                    %s\",\n@@ -1994,23 +2005,26 @@ pub impl Resolver {\n         }\n     }\n \n-    fn idents_to_str(idents: ~[ident]) -> ~str {\n+    fn idents_to_str(@mut self, idents: ~[ident]) -> ~str {\n         let ident_strs = do idents.map |ident| {\n             /*bad*/ copy *self.session.str_of(*ident)\n         };\n         str::connect(ident_strs, \"::\")\n     }\n \n-    fn import_directive_subclass_to_str(subclass: ImportDirectiveSubclass)\n-                                                                    -> @~str {\n+    fn import_directive_subclass_to_str(@mut self,\n+                                        subclass: ImportDirectiveSubclass)\n+                                     -> @~str {\n         match subclass {\n             SingleImport(_target, source, _ns) => self.session.str_of(source),\n             GlobImport => @~\"*\"\n         }\n     }\n \n-    fn import_path_to_str(idents: ~[ident], subclass: ImportDirectiveSubclass)\n-                                                                    -> @~str {\n+    fn import_path_to_str(@mut self,\n+                          idents: ~[ident],\n+                          subclass: ImportDirectiveSubclass)\n+                       -> @~str {\n         if idents.is_empty() {\n             self.import_directive_subclass_to_str(subclass)\n         } else {\n@@ -2027,10 +2041,10 @@ pub impl Resolver {\n      * currently-unresolved imports, or success if we know the name exists.\n      * If successful, the resolved bindings are written into the module.\n      */\n-    fn resolve_import_for_module(module_: @Module,\n+    fn resolve_import_for_module(@mut self,\n+                                 module_: @mut Module,\n                                  import_directive: @ImportDirective)\n                               -> ResolveResult<()> {\n-\n         let mut resolution_result;\n         let module_path = import_directive.module_path;\n \n@@ -2122,12 +2136,12 @@ pub impl Resolver {\n         return resolution_result;\n     }\n \n-    fn resolve_single_import(module_: @Module,\n-                             containing_module: @Module,\n+    fn resolve_single_import(@mut self,\n+                             module_: @mut Module,\n+                             containing_module: @mut Module,\n                              target: ident,\n                              source: ident)\n                           -> ResolveResult<()> {\n-\n         debug!(\"(resolving single import) resolving `%s` = `%s::%s` from \\\n                 `%s`\",\n                *self.session.str_of(target),\n@@ -2314,12 +2328,12 @@ pub impl Resolver {\n         return Success(());\n     }\n \n-    fn resolve_single_module_import(module_: @Module,\n-                                    containing_module: @Module,\n+    fn resolve_single_module_import(@mut self,\n+                                    module_: @mut Module,\n+                                    containing_module: @mut Module,\n                                     target: ident,\n                                     source: ident)\n                                  -> ResolveResult<()> {\n-\n         debug!(\"(resolving single module import) resolving `%s` = `%s::%s` \\\n                 from `%s`\",\n                *self.session.str_of(target),\n@@ -2443,9 +2457,10 @@ pub impl Resolver {\n      * succeeds or bails out (as importing * from an empty module or a module\n      * that exports nothing is valid).\n      */\n-    fn resolve_glob_import(privacy: Privacy,\n-                           module_: @Module,\n-                           containing_module: @Module,\n+    fn resolve_glob_import(@mut self,\n+                           privacy: Privacy,\n+                           module_: @mut Module,\n+                           containing_module: @mut Module,\n                            span: span)\n                         -> ResolveResult<()> {\n         // This function works in a highly imperative manner; it eagerly adds\n@@ -2557,11 +2572,12 @@ pub impl Resolver {\n         return Success(());\n     }\n \n-    fn resolve_module_path_from_root(module_: @Module,\n+    fn resolve_module_path_from_root(@mut self,\n+                                     module_: @mut Module,\n                                      module_path: @DVec<ident>,\n                                      index: uint,\n                                      span: span)\n-                                  -> ResolveResult<@Module> {\n+                                  -> ResolveResult<@mut Module> {\n         let mut search_module = module_;\n         let mut index = index;\n         let module_path_len = (*module_path).len();\n@@ -2629,12 +2645,12 @@ pub impl Resolver {\n      * Attempts to resolve the module part of an import directive or path\n      * rooted at the given module.\n      */\n-    fn resolve_module_path_for_import(module_: @Module,\n+    fn resolve_module_path_for_import(@mut self,\n+                                      module_: @mut Module,\n                                       module_path: @DVec<ident>,\n                                       use_lexical_scope: UseLexicalScopeFlag,\n                                       span: span)\n-                                   -> ResolveResult<@Module> {\n-\n+                                   -> ResolveResult<@mut Module> {\n         let module_path_len = (*module_path).len();\n         assert module_path_len > 0;\n \n@@ -2708,13 +2724,13 @@ pub impl Resolver {\n                                                   span);\n     }\n \n-    fn resolve_item_in_lexical_scope(module_: @Module,\n+    fn resolve_item_in_lexical_scope(@mut self,\n+                                     module_: @mut Module,\n                                      name: ident,\n                                      namespace: Namespace,\n                                      search_through_modules:\n                                         SearchThroughModulesFlag)\n                                   -> ResolveResult<Target> {\n-\n         debug!(\"(resolving item in lexical scope) resolving `%s` in \\\n                 namespace %? in `%s`\",\n                *self.session.str_of(name),\n@@ -2822,8 +2838,10 @@ pub impl Resolver {\n     }\n \n     /** Resolves a module name in the current lexical scope. */\n-    fn resolve_module_in_lexical_scope(module_: @Module, name: ident)\n-                                    -> ResolveResult<@Module> {\n+    fn resolve_module_in_lexical_scope(@mut self,\n+                                       module_: @mut Module,\n+                                       name: ident)\n+                                    -> ResolveResult<@mut Module> {\n         // If this module is an anonymous module, resolve the item in the\n         // lexical scope. Otherwise, resolve the item from the crate root.\n         let resolve_result = self.resolve_item_in_lexical_scope(\n@@ -2867,7 +2885,8 @@ pub impl Resolver {\n     /**\n      * Returns the nearest normal module parent of the given module.\n      */\n-    fn get_nearest_normal_module_parent(module_: @Module) -> Option<@Module> {\n+    fn get_nearest_normal_module_parent(@mut self, module_: @mut Module)\n+                                     -> Option<@mut Module> {\n         let mut module_ = module_;\n         loop {\n             match module_.parent_link {\n@@ -2889,7 +2908,9 @@ pub impl Resolver {\n      * Returns the nearest normal module parent of the given module, or the\n      * module itself if it is a normal module.\n      */\n-    fn get_nearest_normal_module_parent_or_self(module_: @Module) -> @Module {\n+    fn get_nearest_normal_module_parent_or_self(@mut self,\n+                                                module_: @mut Module)\n+                                             -> @mut Module {\n         match module_.kind {\n             NormalModuleKind => return module_,\n             ExternModuleKind | TraitModuleKind | AnonymousModuleKind => {\n@@ -2905,7 +2926,8 @@ pub impl Resolver {\n      * Resolves a \"module prefix\". A module prefix is one of (a) `self::`;\n      * (b) some chain of `super::`.\n      */\n-    fn resolve_module_prefix(module_: @Module,\n+    fn resolve_module_prefix(@mut self,\n+                             module_: @mut Module,\n                              module_path: @DVec<ident>)\n                           -> ResolveResult<ModulePrefixResult> {\n         let interner = self.session.parse_sess.interner;\n@@ -2951,7 +2973,8 @@ pub impl Resolver {\n      * given namespace. If successful, returns the target corresponding to\n      * the name.\n      */\n-    fn resolve_name_in_module(module_: @Module,\n+    fn resolve_name_in_module(@mut self,\n+                              module_: @mut Module,\n                               name: ident,\n                               namespace: Namespace,\n                               allow_globs: bool)\n@@ -3020,10 +3043,10 @@ pub impl Resolver {\n      * This needs special handling, as, unlike all of the other imports, it\n      * needs to look in the scope chain for modules and non-modules alike.\n      */\n-    fn resolve_one_level_renaming_import(module_: @Module,\n+    fn resolve_one_level_renaming_import(@mut self,\n+                                         module_: @mut Module,\n                                          import_directive: @ImportDirective)\n                                       -> ResolveResult<()> {\n-\n         let mut target_name;\n         let mut source_name;\n         let allowable_namespaces;\n@@ -3177,7 +3200,7 @@ pub impl Resolver {\n         return Success(());\n     }\n \n-    fn report_unresolved_imports(module_: @Module) {\n+    fn report_unresolved_imports(@mut self, module_: @mut Module) {\n         let index = module_.resolved_import_count;\n         let import_count = module_.imports.len();\n         if index != import_count {\n@@ -3211,12 +3234,12 @@ pub impl Resolver {\n     // Then this operation can simply be performed as part of item (or import)\n     // processing.\n \n-    fn record_exports() {\n+    fn record_exports(@mut self) {\n         let root_module = self.graph_root.get_module();\n         self.record_exports_for_module_subtree(root_module);\n     }\n \n-    fn record_exports_for_module_subtree(module_: @Module) {\n+    fn record_exports_for_module_subtree(@mut self, module_: @mut Module) {\n         // If this isn't a local crate, then bail out. We don't need to record\n         // exports for nonlocal crates.\n \n@@ -3258,7 +3281,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn record_exports_for_module(module_: @Module) {\n+    fn record_exports_for_module(@mut self, module_: @mut Module) {\n         let mut exports2 = ~[];\n \n         self.add_exports_for_module(&mut exports2, module_);\n@@ -3272,8 +3295,8 @@ pub impl Resolver {\n         }\n     }\n \n-\n-    fn add_exports_of_namebindings(exports2: &mut ~[Export2],\n+    fn add_exports_of_namebindings(@mut self,\n+                                   exports2: &mut ~[Export2],\n                                    ident: ident,\n                                    namebindings: @mut NameBindings,\n                                    ns: Namespace,\n@@ -3300,7 +3323,9 @@ pub impl Resolver {\n         }\n     }\n \n-    fn add_exports_for_module(exports2: &mut ~[Export2], module_: @Module) {\n+    fn add_exports_for_module(@mut self,\n+                              exports2: &mut ~[Export2],\n+                              module_: @mut Module) {\n         for module_.children.each |ident, namebindings| {\n             debug!(\"(computing exports) maybe export '%s'\",\n                    *self.session.str_of(*ident));\n@@ -3357,7 +3382,7 @@ pub impl Resolver {\n     // generate a fake \"implementation scope\" containing all the\n     // implementations thus found, for compatibility with old resolve pass.\n \n-    fn with_scope(name: Option<ident>, f: fn()) {\n+    fn with_scope(@mut self, name: Option<ident>, f: fn()) {\n         let orig_module = self.current_module;\n \n         // Move down in the graph.\n@@ -3397,10 +3422,13 @@ pub impl Resolver {\n     // Wraps the given definition in the appropriate number of `def_upvar`\n     // wrappers.\n \n-    fn upvarify(ribs: @DVec<@Rib>, rib_index: uint, def_like: def_like,\n-                span: span, allow_capturing_self: AllowCapturingSelfFlag)\n+    fn upvarify(@mut self,\n+                ribs: @DVec<@Rib>,\n+                rib_index: uint,\n+                def_like: def_like,\n+                span: span,\n+                allow_capturing_self: AllowCapturingSelfFlag)\n              -> Option<def_like> {\n-\n         let mut def;\n         let mut is_ty_param;\n \n@@ -3504,10 +3532,12 @@ pub impl Resolver {\n         return Some(dl_def(def));\n     }\n \n-    fn search_ribs(ribs: @DVec<@Rib>, name: ident, span: span,\n+    fn search_ribs(@mut self,\n+                   ribs: @DVec<@Rib>,\n+                   name: ident,\n+                   span: span,\n                    allow_capturing_self: AllowCapturingSelfFlag)\n                 -> Option<def_like> {\n-\n         // FIXME #4950: This should not use a while loop.\n         // FIXME #4950: Try caching?\n \n@@ -3529,7 +3559,7 @@ pub impl Resolver {\n         return None;\n     }\n \n-    fn resolve_crate(@self) {\n+    fn resolve_crate(@mut self) {\n         debug!(\"(resolving crate) starting\");\n \n         visit_crate(*self.crate, (), mk_vt(@Visitor {\n@@ -3549,7 +3579,7 @@ pub impl Resolver {\n         }));\n     }\n \n-    fn resolve_item(item: @item, visitor: ResolveVisitor) {\n+    fn resolve_item(@mut self, item: @item, visitor: ResolveVisitor) {\n         debug!(\"(resolving item) resolving %s\",\n                *self.session.str_of(item.ident));\n \n@@ -3777,7 +3807,9 @@ pub impl Resolver {\n         self.xray_context = orig_xray_flag;\n     }\n \n-    fn with_type_parameter_rib(type_parameters: TypeParameters, f: fn()) {\n+    fn with_type_parameter_rib(@mut self,\n+                               type_parameters: TypeParameters,\n+                               f: fn()) {\n         match type_parameters {\n             HasTypeParameters(type_parameters, node_id, initial_index,\n                               rib_kind) => {\n@@ -3818,19 +3850,20 @@ pub impl Resolver {\n         }\n     }\n \n-    fn with_label_rib(f: fn()) {\n+    fn with_label_rib(@mut self, f: fn()) {\n         (*self.label_ribs).push(@Rib(NormalRibKind));\n         f();\n         (*self.label_ribs).pop();\n     }\n-    fn with_constant_rib(f: fn()) {\n+\n+    fn with_constant_rib(@mut self, f: fn()) {\n         (*self.value_ribs).push(@Rib(ConstantItemRibKind));\n         f();\n         (*self.value_ribs).pop();\n     }\n \n-\n-    fn resolve_function(rib_kind: RibKind,\n+    fn resolve_function(@mut self,\n+                        rib_kind: RibKind,\n                         optional_declaration: Option<@fn_decl>,\n                         type_parameters: TypeParameters,\n                         block: blk,\n@@ -3906,7 +3939,8 @@ pub impl Resolver {\n         (*self.value_ribs).pop();\n     }\n \n-    fn resolve_type_parameters(type_parameters: ~[ty_param],\n+    fn resolve_type_parameters(@mut self,\n+                               type_parameters: ~[ty_param],\n                                visitor: ResolveVisitor) {\n         for type_parameters.each |type_parameter| {\n             for type_parameter.bounds.each |&bound| {\n@@ -3918,11 +3952,12 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_struct(id: node_id,\n-                     type_parameters: @~[ty_param],\n-                     fields: ~[@struct_field],\n-                     optional_destructor: Option<struct_dtor>,\n-                     visitor: ResolveVisitor) {\n+    fn resolve_struct(@mut self,\n+                      id: node_id,\n+                      type_parameters: @~[ty_param],\n+                      fields: ~[@struct_field],\n+                      optional_destructor: Option<struct_dtor>,\n+                      visitor: ResolveVisitor) {\n         // If applicable, create a rib for the type parameters.\n         let borrowed_type_parameters: &~[ty_param] = &*type_parameters;\n         do self.with_type_parameter_rib(HasTypeParameters\n@@ -3959,7 +3994,8 @@ pub impl Resolver {\n \n     // Does this really need to take a RibKind or is it always going\n     // to be NormalRibKind?\n-    fn resolve_method(rib_kind: RibKind,\n+    fn resolve_method(@mut self,\n+                      rib_kind: RibKind,\n                       method: @method,\n                       outer_type_parameter_count: uint,\n                       visitor: ResolveVisitor) {\n@@ -3984,7 +4020,8 @@ pub impl Resolver {\n                               visitor);\n     }\n \n-    fn resolve_implementation(id: node_id,\n+    fn resolve_implementation(@mut self,\n+                              id: node_id,\n                               span: span,\n                               type_parameters: ~[ty_param],\n                               opt_trait_reference: Option<@trait_ref>,\n@@ -4060,15 +4097,18 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_module(module_: _mod, span: span, _name: ident, id: node_id,\n+    fn resolve_module(@mut self,\n+                      module_: _mod,\n+                      span: span,\n+                      _name: ident,\n+                      id: node_id,\n                       visitor: ResolveVisitor) {\n-\n         // Write the implementations in scope into the module metadata.\n         debug!(\"(resolving module) resolving module ID %d\", id);\n         visit_mod(module_, span, id, (), visitor);\n     }\n \n-    fn resolve_local(local: @local, visitor: ResolveVisitor) {\n+    fn resolve_local(@mut self, local: @local, visitor: ResolveVisitor) {\n         let mutability = if local.node.is_mutbl {Mutable} else {Immutable};\n \n         // Resolve the type.\n@@ -4089,9 +4129,9 @@ pub impl Resolver {\n                              None, visitor);\n     }\n \n-    fn binding_mode_map(pat: @pat) -> BindingMap {\n+    fn binding_mode_map(@mut self, pat: @pat) -> BindingMap {\n         let result = HashMap();\n-        do pat_bindings(self.def_map, pat) |binding_mode, _id, sp, path| {\n+        do pat_bindings(*self.def_map, pat) |binding_mode, _id, sp, path| {\n             let ident = path_to_ident(path);\n             result.insert(ident,\n                           binding_info {span: sp,\n@@ -4100,7 +4140,7 @@ pub impl Resolver {\n         return result;\n     }\n \n-    fn check_consistent_bindings(arm: arm) {\n+    fn check_consistent_bindings(@mut self, arm: arm) {\n         if arm.pats.len() == 0 { return; }\n         let map_0 = self.binding_mode_map(arm.pats[0]);\n         for arm.pats.eachi() |i, p| {\n@@ -4139,7 +4179,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_arm(arm: arm, visitor: ResolveVisitor) {\n+    fn resolve_arm(@mut self, arm: arm, visitor: ResolveVisitor) {\n         (*self.value_ribs).push(@Rib(NormalRibKind));\n \n         let bindings_list = HashMap();\n@@ -4158,7 +4198,7 @@ pub impl Resolver {\n         (*self.value_ribs).pop();\n     }\n \n-    fn resolve_block(block: blk, visitor: ResolveVisitor) {\n+    fn resolve_block(@mut self, block: blk, visitor: ResolveVisitor) {\n         debug!(\"(resolving block) entering block\");\n         (*self.value_ribs).push(@Rib(NormalRibKind));\n \n@@ -4183,7 +4223,7 @@ pub impl Resolver {\n         debug!(\"(resolving block) leaving block\");\n     }\n \n-    fn resolve_type(ty: @Ty, visitor: ResolveVisitor) {\n+    fn resolve_type(@mut self, ty: @Ty, visitor: ResolveVisitor) {\n         match ty.node {\n             // Like path expressions, the interpretation of path types depends\n             // on whether the path has multiple elements in it or not.\n@@ -4256,14 +4296,14 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_pattern(pattern: @pat,\n+    fn resolve_pattern(@mut self,\n+                       pattern: @pat,\n                        mode: PatternBindingMode,\n                        mutability: Mutability,\n                        // Maps idents to the node ID for the (outermost)\n                        // pattern that binds them\n                        bindings_list: Option<HashMap<ident,node_id>>,\n                        visitor: ResolveVisitor) {\n-\n         let pat_id = pattern.id;\n         do walk_pat(pattern) |pattern| {\n             match pattern.node {\n@@ -4463,7 +4503,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_bare_identifier_pattern(name: ident)\n+    fn resolve_bare_identifier_pattern(@mut self, name: ident)\n                                     -> BareIdentifierPatternResolution {\n         match self.resolve_item_in_lexical_scope(self.current_module,\n                                                  name,\n@@ -4505,7 +4545,8 @@ pub impl Resolver {\n      * If `check_ribs` is true, checks the local definitions first; i.e.\n      * doesn't skip straight to the containing module.\n      */\n-    fn resolve_path(path: @path,\n+    fn resolve_path(@mut self,\n+                    path: @path,\n                     namespace: Namespace,\n                     check_ribs: bool,\n                     visitor: ResolveVisitor)\n@@ -4533,12 +4574,12 @@ pub impl Resolver {\n                                        path.span);\n     }\n \n-    fn resolve_identifier(identifier: ident,\n+    fn resolve_identifier(@mut self,\n+                          identifier: ident,\n                           namespace: Namespace,\n                           check_ribs: bool,\n                           span: span)\n                        -> Option<def> {\n-\n         if check_ribs {\n             match self.resolve_identifier_in_local_ribs(identifier,\n                                                       namespace,\n@@ -4557,12 +4598,12 @@ pub impl Resolver {\n     }\n \n     // FIXME #4952: Merge me with resolve_name_in_module?\n-    fn resolve_definition_of_name_in_module(containing_module: @Module,\n+    fn resolve_definition_of_name_in_module(@mut self,\n+                                            containing_module: @mut Module,\n                                             name: ident,\n                                             namespace: Namespace,\n                                             xray: XrayFlag)\n                                          -> NameDefinition {\n-\n         // First, search children.\n         match containing_module.children.find(&name) {\n             Some(child_name_bindings) => {\n@@ -4619,7 +4660,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn intern_module_part_of_path(path: @path) -> @DVec<ident> {\n+    fn intern_module_part_of_path(@mut self, path: @path) -> @DVec<ident> {\n         let module_path_idents = @DVec();\n         for path.idents.eachi |index, ident| {\n             if index == path.idents.len() - 1 {\n@@ -4632,11 +4673,11 @@ pub impl Resolver {\n         return module_path_idents;\n     }\n \n-    fn resolve_module_relative_path(path: @path,\n+    fn resolve_module_relative_path(@mut self,\n+                                    path: @path,\n                                     +xray: XrayFlag,\n                                     namespace: Namespace)\n                                  -> Option<def> {\n-\n         let module_path_idents = self.intern_module_part_of_path(path);\n \n         let mut containing_module;\n@@ -4676,11 +4717,11 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_crate_relative_path(path: @path,\n+    fn resolve_crate_relative_path(@mut self,\n+                                   path: @path,\n                                    +xray: XrayFlag,\n                                    namespace: Namespace)\n                                 -> Option<def> {\n-\n         let module_path_idents = self.intern_module_part_of_path(path);\n \n         let root_module = self.graph_root.get_module();\n@@ -4723,7 +4764,8 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_identifier_in_local_ribs(ident: ident,\n+    fn resolve_identifier_in_local_ribs(@mut self,\n+                                        ident: ident,\n                                         namespace: Namespace,\n                                         span: span)\n                                      -> Option<def> {\n@@ -4754,7 +4796,8 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_item_by_identifier_in_lexical_scope(ident: ident,\n+    fn resolve_item_by_identifier_in_lexical_scope(@mut self,\n+                                                   ident: ident,\n                                                    namespace: Namespace)\n                                                 -> Option<def> {\n         // Check the items.\n@@ -4786,7 +4829,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn name_exists_in_scope_struct(name: &str) -> bool {\n+    fn name_exists_in_scope_struct(@mut self, name: &str) -> bool {\n         let mut i = self.type_ribs.len();\n         while i != 0 {\n           i -= 1;\n@@ -4819,7 +4862,7 @@ pub impl Resolver {\n       return false;\n     }\n \n-    fn resolve_expr(expr: @expr, visitor: ResolveVisitor) {\n+    fn resolve_expr(@mut self, expr: @expr, visitor: ResolveVisitor) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n \n@@ -4928,7 +4971,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn record_candidate_traits_for_expr_if_necessary(expr: @expr) {\n+    fn record_candidate_traits_for_expr_if_necessary(@mut self, expr: @expr) {\n         match expr.node {\n             expr_field(_, ident, _) => {\n                 let traits = self.search_for_traits_containing_method(ident);\n@@ -5005,7 +5048,9 @@ pub impl Resolver {\n         }\n     }\n \n-    fn search_for_traits_containing_method(name: ident) -> @DVec<def_id> {\n+    fn search_for_traits_containing_method(@mut self,\n+                                           name: ident)\n+                                        -> @DVec<def_id> {\n         debug!(\"(searching for traits containing method) looking for '%s'\",\n                *self.session.str_of(name));\n \n@@ -5095,10 +5140,11 @@ pub impl Resolver {\n         return found_traits;\n     }\n \n-    fn add_trait_info_if_containing_method(found_traits: @DVec<def_id>,\n+    fn add_trait_info_if_containing_method(@mut self,\n+                                           found_traits: @DVec<def_id>,\n                                            trait_def_id: def_id,\n-                                           name: ident) -> bool {\n-\n+                                           name: ident)\n+                                        -> bool {\n         debug!(\"(adding trait info if containing method) trying trait %d:%d \\\n                 for method '%s'\",\n                trait_def_id.crate,\n@@ -5121,18 +5167,21 @@ pub impl Resolver {\n         }\n     }\n \n-    fn add_fixed_trait_for_expr(expr_id: node_id, +trait_id: def_id) {\n+    fn add_fixed_trait_for_expr(@mut self,\n+                                expr_id: node_id,\n+                                +trait_id: def_id) {\n         let traits = @DVec();\n         traits.push(trait_id);\n         self.trait_map.insert(expr_id, traits);\n     }\n \n-    fn record_def(node_id: node_id, def: def) {\n+    fn record_def(@mut self, node_id: node_id, def: def) {\n         debug!(\"(recording def) recording %? for %?\", def, node_id);\n         self.def_map.insert(node_id, def);\n     }\n \n-    fn enforce_default_binding_mode(pat: @pat,\n+    fn enforce_default_binding_mode(@mut self,\n+                                    pat: @pat,\n                                     pat_binding_mode: binding_mode,\n                                     descr: &str) {\n         match pat_binding_mode {\n@@ -5157,7 +5206,7 @@ pub impl Resolver {\n     //\n     // be sure that there is only one main function\n     //\n-    fn check_duplicate_main() {\n+    fn check_duplicate_main(@mut self) {\n         if self.attr_main_fn.is_none() {\n             if self.main_fns.len() >= 1u {\n                 let mut i = 1u;\n@@ -5183,7 +5232,7 @@ pub impl Resolver {\n     // resolve data structures.\n     //\n \n-    fn check_for_unused_imports_if_necessary() {\n+    fn check_for_unused_imports_if_necessary(@mut self) {\n         if self.unused_import_lint_level == allow {\n             return;\n         }\n@@ -5192,7 +5241,8 @@ pub impl Resolver {\n         self.check_for_unused_imports_in_module_subtree(root_module);\n     }\n \n-    fn check_for_unused_imports_in_module_subtree(module_: @Module) {\n+    fn check_for_unused_imports_in_module_subtree(@mut self,\n+                                                  module_: @mut Module) {\n         // If this isn't a local crate, then bail out. We don't need to check\n         // for unused imports in external crates.\n \n@@ -5231,7 +5281,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn check_for_unused_imports_in_module(module_: @Module) {\n+    fn check_for_unused_imports_in_module(@mut self, module_: @mut Module) {\n         for module_.import_resolutions.each_value |&import_resolution| {\n             // Ignore dummy spans for things like automatically injected\n             // imports for the prelude, and also don't warn about the same\n@@ -5268,7 +5318,7 @@ pub impl Resolver {\n     //\n \n     /// A somewhat inefficient routine to obtain the name of a module.\n-    fn module_to_str(module_: @Module) -> ~str {\n+    fn module_to_str(@mut self, module_: @mut Module) -> ~str {\n         let idents = DVec();\n         let mut current_module = module_;\n         loop {\n@@ -5293,7 +5343,7 @@ pub impl Resolver {\n         return self.idents_to_str(vec::reversed(idents.get()));\n     }\n \n-    fn dump_module(module_: @Module) {\n+    fn dump_module(@mut self, module_: @mut Module) {\n         debug!(\"Dump of module `%s`:\", self.module_to_str(module_));\n \n         debug!(\"Children:\");\n@@ -5338,11 +5388,11 @@ pub fn resolve_crate(session: Session,\n                      lang_items: LanguageItems,\n                      crate: @crate)\n                   -> CrateMap {\n-    let resolver = @Resolver(session, lang_items, crate);\n-    resolver.resolve(resolver);\n+    let resolver = @mut Resolver(session, lang_items, crate);\n+    resolver.resolve();\n     CrateMap {\n-        def_map: resolver.def_map,\n-        exp_map2: resolver.export_map2,\n+        def_map: *resolver.def_map,\n+        exp_map2: *resolver.export_map2,\n         trait_map: resolver.trait_map\n     }\n }"}]}