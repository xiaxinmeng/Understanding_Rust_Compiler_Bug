{"sha": "eedb95101b828c3c6295983ae8d29fd4145ec014", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlZGI5NTEwMWI4MjhjM2M2Mjk1OTgzYWU4ZDI5ZmQ0MTQ1ZWMwMTQ=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-09-28T11:26:26Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-09-28T20:06:43Z"}, "message": "Fill in some missing parts in the default AST visitor\n+ Add helper macro for walking lists (including Options)", "tree": {"sha": "6d274801529b2e3f0c980df597f6dc37590eb6ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d274801529b2e3f0c980df597f6dc37590eb6ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eedb95101b828c3c6295983ae8d29fd4145ec014", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eedb95101b828c3c6295983ae8d29fd4145ec014", "html_url": "https://github.com/rust-lang/rust/commit/eedb95101b828c3c6295983ae8d29fd4145ec014", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eedb95101b828c3c6295983ae8d29fd4145ec014/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e11845d77264c52d1066c0adca184dd0a418ac1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e11845d77264c52d1066c0adca184dd0a418ac1", "html_url": "https://github.com/rust-lang/rust/commit/9e11845d77264c52d1066c0adca184dd0a418ac1"}], "stats": {"total": 632, "additions": 275, "deletions": 357}, "files": [{"sha": "f47c709e03aa2f5ebb771d26a157ae919070fbac", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eedb95101b828c3c6295983ae8d29fd4145ec014/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb95101b828c3c6295983ae8d29fd4145ec014/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=eedb95101b828c3c6295983ae8d29fd4145ec014", "patch": "@@ -898,12 +898,8 @@ impl<'a, 'v> ast_visit::Visitor<'v> for EarlyContext<'a> {\n         });\n     }\n \n-    fn visit_opt_lifetime_ref(&mut self, sp: Span, lt: &Option<ast::Lifetime>) {\n-        run_lints!(self, check_opt_lifetime_ref, early_passes, sp, lt);\n-    }\n-\n-    fn visit_lifetime_ref(&mut self, lt: &ast::Lifetime) {\n-        run_lints!(self, check_lifetime_ref, early_passes, lt);\n+    fn visit_lifetime(&mut self, lt: &ast::Lifetime) {\n+        run_lints!(self, check_lifetime, early_passes, lt);\n     }\n \n     fn visit_lifetime_def(&mut self, lt: &ast::LifetimeDef) {"}, {"sha": "50695fb0c1702fa741ba414471d06c5b5fe0e35e", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eedb95101b828c3c6295983ae8d29fd4145ec014/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb95101b828c3c6295983ae8d29fd4145ec014/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=eedb95101b828c3c6295983ae8d29fd4145ec014", "patch": "@@ -199,11 +199,7 @@ pub trait EarlyLintPass: LintPass {\n     fn check_struct_field(&mut self, _: &EarlyContext, _: &ast::StructField) { }\n     fn check_variant(&mut self, _: &EarlyContext, _: &ast::Variant, _: &ast::Generics) { }\n     fn check_variant_post(&mut self, _: &EarlyContext, _: &ast::Variant, _: &ast::Generics) { }\n-    fn check_opt_lifetime_ref(&mut self,\n-                              _: &EarlyContext,\n-                              _: Span,\n-                              _: &Option<ast::Lifetime>) { }\n-    fn check_lifetime_ref(&mut self, _: &EarlyContext, _: &ast::Lifetime) { }\n+    fn check_lifetime(&mut self, _: &EarlyContext, _: &ast::Lifetime) { }\n     fn check_lifetime_def(&mut self, _: &EarlyContext, _: &ast::LifetimeDef) { }\n     fn check_explicit_self(&mut self, _: &EarlyContext, _: &ast::ExplicitSelf) { }\n     fn check_path(&mut self, _: &EarlyContext, _: &ast::Path, _: ast::NodeId) { }"}, {"sha": "6c53762c3ead77ff140372c67f19f9fec5b0b211", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eedb95101b828c3c6295983ae8d29fd4145ec014/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb95101b828c3c6295983ae8d29fd4145ec014/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=eedb95101b828c3c6295983ae8d29fd4145ec014", "patch": "@@ -771,7 +771,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             }\n         }\n \n-        visit::walk_expr_opt(self, base)\n+        walk_list!(self, visit_expr, base);\n     }\n \n     fn process_method_call(&mut self, ex: &ast::Expr, args: &Vec<P<ast::Expr>>) {\n@@ -785,7 +785,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         }\n \n         // walk receiver and args\n-        visit::walk_exprs(self, &args);\n+        walk_list!(self, visit_expr, args);\n     }\n \n     fn process_pat(&mut self, p: &ast::Pat) {\n@@ -1200,7 +1200,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n         for &(id, ref path, ref_kind) in &paths_to_process {\n             self.process_path(id, path, ref_kind);\n         }\n-        visit::walk_expr_opt(self, &arm.guard);\n+        walk_list!(self, visit_expr, &arm.guard);\n         self.visit_expr(&arm.body);\n     }\n \n@@ -1246,7 +1246,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n         }\n \n         // Just walk the initialiser and type (don't want to walk the pattern again).\n-        visit::walk_ty_opt(self, &l.ty);\n-        visit::walk_expr_opt(self, &l.init);\n+        walk_list!(self, visit_ty, &l.ty);\n+        walk_list!(self, visit_expr, &l.init);\n     }\n }"}, {"sha": "71261fa457fcd30e6342c7f330d4e3ca56890f8e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eedb95101b828c3c6295983ae8d29fd4145ec014/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb95101b828c3c6295983ae8d29fd4145ec014/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=eedb95101b828c3c6295983ae8d29fd4145ec014", "patch": "@@ -1613,6 +1613,13 @@ impl PathListItem_ {\n         }\n     }\n \n+    pub fn name(&self) -> Option<Ident> {\n+        match *self {\n+            PathListIdent { name, .. } => Some(name),\n+            PathListMod { .. } => None,\n+        }\n+    }\n+\n     pub fn rename(&self) -> Option<Ident> {\n         match *self {\n             PathListIdent { rename, .. } | PathListMod { rename, .. } => rename"}, {"sha": "6ab1ad863ff352eb51643da47f37aa03671c7674", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eedb95101b828c3c6295983ae8d29fd4145ec014/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb95101b828c3c6295983ae8d29fd4145ec014/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=eedb95101b828c3c6295983ae8d29fd4145ec014", "patch": "@@ -476,12 +476,12 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         visit::walk_impl_item(self, ii);\n     }\n \n-    fn visit_lifetime_ref(&mut self, lifetime: &Lifetime) {\n+    fn visit_lifetime(&mut self, lifetime: &Lifetime) {\n         self.operation.visit_id(lifetime.id);\n     }\n \n     fn visit_lifetime_def(&mut self, def: &LifetimeDef) {\n-        self.visit_lifetime_ref(&def.lifetime);\n+        self.visit_lifetime(&def.lifetime);\n     }\n \n     fn visit_trait_ref(&mut self, trait_ref: &TraitRef) {"}, {"sha": "83369689a94de077efbce2a8ce81ff6e32c4751e", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eedb95101b828c3c6295983ae8d29fd4145ec014/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb95101b828c3c6295983ae8d29fd4145ec014/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=eedb95101b828c3c6295983ae8d29fd4145ec014", "patch": "@@ -12,6 +12,7 @@ use std::default::Default;\n use std::fmt;\n use std::iter::{IntoIterator, FromIterator};\n use std::ops::Deref;\n+use std::slice;\n use std::vec;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n@@ -82,6 +83,14 @@ impl<T> FromIterator<T> for OwnedSlice<T> {\n     }\n }\n \n+impl<'a, T> IntoIterator for &'a OwnedSlice<T> {\n+    type Item = &'a T;\n+    type IntoIter = slice::Iter<'a, T>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.data.into_iter()\n+    }\n+}\n+\n impl<T: Encodable> Encodable for OwnedSlice<T> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         Encodable::encode(&**self, s)"}, {"sha": "531578c76d4be8ce35c9eaf298b68bcd466e1fe8", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 249, "deletions": 339, "changes": 588, "blob_url": "https://github.com/rust-lang/rust/blob/eedb95101b828c3c6295983ae8d29fd4145ec014/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb95101b828c3c6295983ae8d29fd4145ec014/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=eedb95101b828c3c6295983ae8d29fd4145ec014", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -25,10 +25,7 @@\n \n use abi::Abi;\n use ast::*;\n-use ast;\n use codemap::Span;\n-use ptr::P;\n-use owned_slice::OwnedSlice;\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum FnKind<'a> {\n@@ -56,7 +53,7 @@ pub trait Visitor<'v> : Sized {\n         // Nothing to do.\n     }\n     fn visit_ident(&mut self, span: Span, ident: Ident) {\n-        self.visit_name(span, ident.name);\n+        walk_ident(self, span, ident);\n     }\n     fn visit_mod(&mut self, m: &'v Mod, _s: Span, _n: NodeId) { walk_mod(self, m) }\n     fn visit_foreign_item(&mut self, i: &'v ForeignItem) { walk_foreign_item(self, i) }\n@@ -94,21 +91,8 @@ pub trait Visitor<'v> : Sized {\n \n     fn visit_variant(&mut self, v: &'v Variant, g: &'v Generics) { walk_variant(self, v, g) }\n \n-    /// Visits an optional reference to a lifetime. The `span` is the span of some surrounding\n-    /// reference should opt_lifetime be None.\n-    fn visit_opt_lifetime_ref(&mut self,\n-                              _span: Span,\n-                              opt_lifetime: &'v Option<Lifetime>) {\n-        match *opt_lifetime {\n-            Some(ref l) => self.visit_lifetime_ref(l),\n-            None => ()\n-        }\n-    }\n-    fn visit_lifetime_bound(&mut self, lifetime: &'v Lifetime) {\n-        walk_lifetime_bound(self, lifetime)\n-    }\n-    fn visit_lifetime_ref(&mut self, lifetime: &'v Lifetime) {\n-        walk_lifetime_ref(self, lifetime)\n+    fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n+        walk_lifetime(self, lifetime)\n     }\n     fn visit_lifetime_def(&mut self, lifetime: &'v LifetimeDef) {\n         walk_lifetime_def(self, lifetime)\n@@ -124,7 +108,7 @@ pub trait Visitor<'v> : Sized {\n         // definition in your trait impl:\n         // visit::walk_mac(self, _mac)\n     }\n-    fn visit_path(&mut self, path: &'v Path, _id: ast::NodeId) {\n+    fn visit_path(&mut self, path: &'v Path, _id: NodeId) {\n         walk_path(self, path)\n     }\n     fn visit_path_list_item(&mut self, prefix: &'v Path, item: &'v PathListItem) {\n@@ -140,53 +124,83 @@ pub trait Visitor<'v> : Sized {\n         walk_assoc_type_binding(self, type_binding)\n     }\n     fn visit_attribute(&mut self, _attr: &'v Attribute) {}\n+    fn visit_macro_def(&mut self, macro_def: &'v MacroDef) {\n+        walk_macro_def(self, macro_def)\n+    }\n }\n \n-pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n-    visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n-    for attr in &krate.attrs {\n-        visitor.visit_attribute(attr);\n+#[macro_export]\n+macro_rules! walk_list {\n+    ($visitor: ident, $method: ident, $list: expr) => {\n+        for elem in $list {\n+            $visitor.$method(elem)\n+        }\n     }\n }\n \n-pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod) {\n-    for item in &module.items {\n-        visitor.visit_item(&**item)\n+pub fn walk_opt_name<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_name: Option<Name>) {\n+    for name in opt_name {\n+        visitor.visit_name(span, name);\n     }\n }\n \n-pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n-    visitor.visit_pat(&*local.pat);\n-    walk_ty_opt(visitor, &local.ty);\n-    walk_expr_opt(visitor, &local.init);\n+pub fn walk_opt_ident<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_ident: Option<Ident>) {\n+    for ident in opt_ident {\n+        visitor.visit_ident(span, ident);\n+    }\n }\n \n-pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                              lifetime_def: &'v LifetimeDef) {\n-    visitor.visit_name(lifetime_def.lifetime.span, lifetime_def.lifetime.name);\n-    for bound in &lifetime_def.bounds {\n-        visitor.visit_lifetime_bound(bound);\n-    }\n+pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, ident: Ident) {\n+    visitor.visit_name(span, ident.name);\n }\n \n-pub fn walk_lifetime_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                               lifetime_ref: &'v Lifetime) {\n-    visitor.visit_lifetime_ref(lifetime_ref)\n+pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n+    visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n+    walk_list!(visitor, visit_attribute, &krate.attrs);\n+    walk_list!(visitor, visit_macro_def, &krate.exported_macros);\n+}\n+\n+pub fn walk_macro_def<'v, V: Visitor<'v>>(visitor: &mut V, macro_def: &'v MacroDef) {\n+    visitor.visit_ident(macro_def.span, macro_def.ident);\n+    walk_opt_ident(visitor, macro_def.span, macro_def.imported_from);\n+    walk_list!(visitor, visit_attribute, &macro_def.attrs);\n+}\n+\n+pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod) {\n+    walk_list!(visitor, visit_item, &module.items);\n+}\n+\n+pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n+    visitor.visit_pat(&local.pat);\n+    walk_list!(visitor, visit_ty, &local.ty);\n+    walk_list!(visitor, visit_expr, &local.init);\n }\n \n-pub fn walk_lifetime_ref<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                             lifetime_ref: &'v Lifetime) {\n-    visitor.visit_name(lifetime_ref.span, lifetime_ref.name)\n+pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n+    visitor.visit_name(lifetime.span, lifetime.name);\n+}\n+\n+pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                              lifetime_def: &'v LifetimeDef) {\n+    visitor.visit_lifetime(&lifetime_def.lifetime);\n+    walk_list!(visitor, visit_lifetime, &lifetime_def.bounds);\n }\n \n pub fn walk_explicit_self<'v, V: Visitor<'v>>(visitor: &mut V,\n                                               explicit_self: &'v ExplicitSelf) {\n     match explicit_self.node {\n-        SelfStatic | SelfValue(_) => {},\n-        SelfRegion(ref lifetime, _, _) => {\n-            visitor.visit_opt_lifetime_ref(explicit_self.span, lifetime)\n+        SelfStatic => {},\n+        SelfValue(ident) => {\n+            visitor.visit_ident(explicit_self.span, ident)\n+        }\n+        SelfRegion(ref opt_lifetime, _, ident) => {\n+            visitor.visit_ident(explicit_self.span, ident);\n+            walk_list!(visitor, visit_lifetime, opt_lifetime);\n+        }\n+        SelfExplicit(ref typ, ident) => {\n+            visitor.visit_ident(explicit_self.span, ident);\n+            visitor.visit_ty(typ)\n         }\n-        SelfExplicit(ref typ, _) => visitor.visit_ty(&**typ),\n     }\n }\n \n@@ -195,7 +209,7 @@ pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n                                   _modifier: &'v TraitBoundModifier)\n     where V: Visitor<'v>\n {\n-    walk_lifetime_decls_helper(visitor, &trait_ref.bound_lifetimes);\n+    walk_list!(visitor, visit_lifetime_def, &trait_ref.bound_lifetimes);\n     visitor.visit_trait_ref(&trait_ref.trait_ref);\n }\n \n@@ -209,10 +223,13 @@ pub fn walk_trait_ref<'v,V>(visitor: &mut V,\n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     visitor.visit_ident(item.span, item.ident);\n     match item.node {\n-        ItemExternCrate(..) => {}\n+        ItemExternCrate(opt_name) => {\n+            walk_opt_name(visitor, item.span, opt_name)\n+        }\n         ItemUse(ref vp) => {\n             match vp.node {\n-                ViewPathSimple(_ident, ref path) => {\n+                ViewPathSimple(ident, ref path) => {\n+                    visitor.visit_ident(vp.span, ident);\n                     visitor.visit_path(path, item.id);\n                 }\n                 ViewPathGlob(ref path) => {\n@@ -231,27 +248,25 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         }\n         ItemStatic(ref typ, _, ref expr) |\n         ItemConst(ref typ, ref expr) => {\n-            visitor.visit_ty(&**typ);\n-            visitor.visit_expr(&**expr);\n+            visitor.visit_ty(typ);\n+            visitor.visit_expr(expr);\n         }\n         ItemFn(ref declaration, unsafety, constness, abi, ref generics, ref body) => {\n             visitor.visit_fn(FnKind::ItemFn(item.ident, generics, unsafety,\n                                             constness, abi, item.vis),\n-                             &**declaration,\n-                             &**body,\n+                             declaration,\n+                             body,\n                              item.span,\n                              item.id)\n         }\n         ItemMod(ref module) => {\n             visitor.visit_mod(module, item.span, item.id)\n         }\n         ItemForeignMod(ref foreign_module) => {\n-            for foreign_item in &foreign_module.items {\n-                visitor.visit_foreign_item(&**foreign_item)\n-            }\n+            walk_list!(visitor, visit_foreign_item, &foreign_module.items);\n         }\n         ItemTy(ref typ, ref type_parameters) => {\n-            visitor.visit_ty(&**typ);\n+            visitor.visit_ty(typ);\n             visitor.visit_generics(type_parameters)\n         }\n         ItemEnum(ref enum_definition, ref type_parameters) => {\n@@ -263,45 +278,36 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         }\n         ItemImpl(_, _,\n                  ref type_parameters,\n-                 ref trait_reference,\n+                 ref opt_trait_reference,\n                  ref typ,\n                  ref impl_items) => {\n             visitor.visit_generics(type_parameters);\n-            match *trait_reference {\n-                Some(ref trait_reference) => visitor.visit_trait_ref(trait_reference),\n-                None => ()\n-            }\n-            visitor.visit_ty(&**typ);\n-            for impl_item in impl_items {\n-                visitor.visit_impl_item(impl_item);\n-            }\n+            walk_list!(visitor, visit_trait_ref, opt_trait_reference);\n+            visitor.visit_ty(typ);\n+            walk_list!(visitor, visit_impl_item, impl_items);\n         }\n         ItemStruct(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n-            visitor.visit_struct_def(&**struct_definition,\n+            visitor.visit_struct_def(struct_definition,\n                                      item.ident,\n                                      generics,\n                                      item.id)\n         }\n         ItemTrait(_, ref generics, ref bounds, ref methods) => {\n             visitor.visit_generics(generics);\n-            walk_ty_param_bounds_helper(visitor, bounds);\n-            for method in methods {\n-                visitor.visit_trait_item(method)\n-            }\n+            walk_list!(visitor, visit_ty_param_bound, bounds);\n+            walk_list!(visitor, visit_trait_item, methods);\n         }\n         ItemMac(ref mac) => visitor.visit_mac(mac),\n     }\n-    for attr in &item.attrs {\n-        visitor.visit_attribute(attr);\n-    }\n+    walk_list!(visitor, visit_attribute, &item.attrs);\n }\n \n pub fn walk_enum_def<'v, V: Visitor<'v>>(visitor: &mut V,\n                                          enum_definition: &'v EnumDef,\n                                          generics: &'v Generics) {\n     for variant in &enum_definition.variants {\n-        visitor.visit_variant(&**variant, generics);\n+        visitor.visit_variant(variant, generics);\n     }\n }\n \n@@ -313,79 +319,58 @@ pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n     match variant.node.kind {\n         TupleVariantKind(ref variant_arguments) => {\n             for variant_argument in variant_arguments {\n-                visitor.visit_ty(&*variant_argument.ty)\n+                visitor.visit_ty(&variant_argument.ty)\n             }\n         }\n         StructVariantKind(ref struct_definition) => {\n-            visitor.visit_struct_def(&**struct_definition,\n+            visitor.visit_struct_def(struct_definition,\n                                      variant.node.name,\n                                      generics,\n                                      variant.node.id)\n         }\n     }\n-    match variant.node.disr_expr {\n-        Some(ref expr) => visitor.visit_expr(&**expr),\n-        None => ()\n-    }\n-    for attr in &variant.node.attrs {\n-        visitor.visit_attribute(attr);\n-    }\n-}\n-\n-pub fn skip_ty<'v, V: Visitor<'v>>(_: &mut V, _: &'v Ty) {\n-    // Empty!\n-}\n-\n-pub fn walk_ty_opt<'v, V: Visitor<'v>>(visitor: &mut V, optional_type: &'v Option<P<Ty>>) {\n-    match *optional_type {\n-        Some(ref ty) => visitor.visit_ty(&**ty),\n-        None => ()\n-    }\n+    walk_list!(visitor, visit_expr, &variant.node.disr_expr);\n+    walk_list!(visitor, visit_attribute, &variant.node.attrs);\n }\n \n pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n     match typ.node {\n         TyVec(ref ty) | TyParen(ref ty) => {\n-            visitor.visit_ty(&**ty)\n+            visitor.visit_ty(ty)\n         }\n         TyPtr(ref mutable_type) => {\n-            visitor.visit_ty(&*mutable_type.ty)\n+            visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyRptr(ref lifetime, ref mutable_type) => {\n-            visitor.visit_opt_lifetime_ref(typ.span, lifetime);\n-            visitor.visit_ty(&*mutable_type.ty)\n+        TyRptr(ref opt_lifetime, ref mutable_type) => {\n+            walk_list!(visitor, visit_lifetime, opt_lifetime);\n+            visitor.visit_ty(&mutable_type.ty)\n         }\n         TyTup(ref tuple_element_types) => {\n-            for tuple_element_type in tuple_element_types {\n-                visitor.visit_ty(&**tuple_element_type)\n-            }\n+            walk_list!(visitor, visit_ty, tuple_element_types);\n         }\n         TyBareFn(ref function_declaration) => {\n-            for argument in &function_declaration.decl.inputs {\n-                visitor.visit_ty(&*argument.ty)\n-            }\n-            walk_fn_ret_ty(visitor, &function_declaration.decl.output);\n-            walk_lifetime_decls_helper(visitor, &function_declaration.lifetimes);\n+            walk_fn_decl(visitor, &function_declaration.decl);\n+            walk_list!(visitor, visit_lifetime_def, &function_declaration.lifetimes);\n         }\n         TyPath(ref maybe_qself, ref path) => {\n-            if let Some(ref qself) = *maybe_qself {\n+            for qself in maybe_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, typ.id);\n         }\n         TyObjectSum(ref ty, ref bounds) => {\n-            visitor.visit_ty(&**ty);\n-            walk_ty_param_bounds_helper(visitor, bounds);\n+            visitor.visit_ty(ty);\n+            walk_list!(visitor, visit_ty_param_bound, bounds);\n         }\n         TyFixedLengthVec(ref ty, ref expression) => {\n-            visitor.visit_ty(&**ty);\n-            visitor.visit_expr(&**expression)\n+            visitor.visit_ty(ty);\n+            visitor.visit_expr(expression)\n         }\n         TyPolyTraitRef(ref bounds) => {\n-            walk_ty_param_bounds_helper(visitor, bounds)\n+            walk_list!(visitor, visit_ty_param_bound, bounds);\n         }\n         TyTypeof(ref expression) => {\n-            visitor.visit_expr(&**expression)\n+            visitor.visit_expr(expression)\n         }\n         TyInfer => {}\n         TyMac(ref mac) => {\n@@ -394,13 +379,6 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n     }\n }\n \n-pub fn walk_lifetime_decls_helper<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                                      lifetimes: &'v Vec<LifetimeDef>) {\n-    for l in lifetimes {\n-        visitor.visit_lifetime_def(l);\n-    }\n-}\n-\n pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n     for segment in &path.segments {\n         visitor.visit_path_segment(path.span, segment);\n@@ -413,9 +391,8 @@ pub fn walk_path_list_item<'v, V: Visitor<'v>>(visitor: &mut V, prefix: &'v Path\n         visitor.visit_path_segment(prefix.span, segment);\n     }\n \n-    if let PathListIdent { name, .. } = item.node {\n-        visitor.visit_ident(item.span, name);\n-    }\n+    walk_opt_ident(visitor, item.span, item.node.name());\n+    walk_opt_ident(visitor, item.span, item.node.rename());\n }\n \n pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n@@ -429,42 +406,30 @@ pub fn walk_path_parameters<'v, V: Visitor<'v>>(visitor: &mut V,\n                                                 _path_span: Span,\n                                                 path_parameters: &'v PathParameters) {\n     match *path_parameters {\n-        ast::AngleBracketedParameters(ref data) => {\n-            for typ in data.types.iter() {\n-                visitor.visit_ty(&**typ);\n-            }\n-            for lifetime in &data.lifetimes {\n-                visitor.visit_lifetime_ref(lifetime);\n-            }\n-            for binding in data.bindings.iter() {\n-                visitor.visit_assoc_type_binding(&**binding);\n-            }\n+        AngleBracketedParameters(ref data) => {\n+            walk_list!(visitor, visit_ty, &data.types);\n+            walk_list!(visitor, visit_lifetime, &data.lifetimes);\n+            walk_list!(visitor, visit_assoc_type_binding, &data.bindings);\n         }\n-        ast::ParenthesizedParameters(ref data) => {\n-            for typ in &data.inputs {\n-                visitor.visit_ty(&**typ);\n-            }\n-            if let Some(ref typ) = data.output {\n-                visitor.visit_ty(&**typ);\n-            }\n+        ParenthesizedParameters(ref data) => {\n+            walk_list!(visitor, visit_ty, &data.inputs);\n+            walk_list!(visitor, visit_ty, &data.output);\n         }\n     }\n }\n \n pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n                                                    type_binding: &'v TypeBinding) {\n     visitor.visit_ident(type_binding.span, type_binding.ident);\n-    visitor.visit_ty(&*type_binding.ty);\n+    visitor.visit_ty(&type_binding.ty);\n }\n \n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n     match pattern.node {\n-        PatEnum(ref path, ref children) => {\n+        PatEnum(ref path, ref opt_children) => {\n             visitor.visit_path(path, pattern.id);\n-            if let Some(ref children) = *children {\n-                for child in children {\n-                    visitor.visit_pat(&*child)\n-                }\n+            for children in opt_children {\n+                walk_list!(visitor, visit_pat, children);\n             }\n         }\n         PatQPath(ref qself, ref path) => {\n@@ -474,41 +439,31 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n         PatStruct(ref path, ref fields, _) => {\n             visitor.visit_path(path, pattern.id);\n             for field in fields {\n-                visitor.visit_pat(&*field.node.pat)\n+                visitor.visit_ident(field.span, field.node.ident);\n+                visitor.visit_pat(&field.node.pat)\n             }\n         }\n         PatTup(ref tuple_elements) => {\n-            for tuple_element in tuple_elements {\n-                visitor.visit_pat(&**tuple_element)\n-            }\n+            walk_list!(visitor, visit_pat, tuple_elements);\n         }\n         PatBox(ref subpattern) |\n         PatRegion(ref subpattern, _) => {\n-            visitor.visit_pat(&**subpattern)\n+            visitor.visit_pat(subpattern)\n         }\n         PatIdent(_, ref pth1, ref optional_subpattern) => {\n             visitor.visit_ident(pth1.span, pth1.node);\n-            match *optional_subpattern {\n-                None => {}\n-                Some(ref subpattern) => visitor.visit_pat(&**subpattern),\n-            }\n+            walk_list!(visitor, visit_pat, optional_subpattern);\n         }\n-        PatLit(ref expression) => visitor.visit_expr(&**expression),\n+        PatLit(ref expression) => visitor.visit_expr(expression),\n         PatRange(ref lower_bound, ref upper_bound) => {\n-            visitor.visit_expr(&**lower_bound);\n-            visitor.visit_expr(&**upper_bound)\n+            visitor.visit_expr(lower_bound);\n+            visitor.visit_expr(upper_bound)\n         }\n         PatWild(_) => (),\n-        PatVec(ref prepattern, ref slice_pattern, ref postpatterns) => {\n-            for prepattern in prepattern {\n-                visitor.visit_pat(&**prepattern)\n-            }\n-            if let Some(ref slice_pattern) = *slice_pattern {\n-                visitor.visit_pat(&**slice_pattern)\n-            }\n-            for postpattern in postpatterns {\n-                visitor.visit_pat(&**postpattern)\n-            }\n+        PatVec(ref prepatterns, ref slice_pattern, ref postpatterns) => {\n+            walk_list!(visitor, visit_pat, prepatterns);\n+            walk_list!(visitor, visit_pat, slice_pattern);\n+            walk_list!(visitor, visit_pat, postpatterns);\n         }\n         PatMac(ref mac) => visitor.visit_mac(mac),\n     }\n@@ -520,22 +475,13 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V,\n \n     match foreign_item.node {\n         ForeignItemFn(ref function_declaration, ref generics) => {\n-            walk_fn_decl(visitor, &**function_declaration);\n+            walk_fn_decl(visitor, function_declaration);\n             visitor.visit_generics(generics)\n         }\n-        ForeignItemStatic(ref typ, _) => visitor.visit_ty(&**typ),\n-    }\n-\n-    for attr in &foreign_item.attrs {\n-        visitor.visit_attribute(attr);\n+        ForeignItemStatic(ref typ, _) => visitor.visit_ty(typ),\n     }\n-}\n \n-pub fn walk_ty_param_bounds_helper<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                                       bounds: &'v OwnedSlice<TyParamBound>) {\n-    for bound in bounds.iter() {\n-        visitor.visit_ty_param_bound(bound)\n-    }\n+    walk_list!(visitor, visit_attribute, &foreign_item.attrs);\n }\n \n pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n@@ -545,58 +491,53 @@ pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n             visitor.visit_poly_trait_ref(typ, modifier);\n         }\n         RegionTyParamBound(ref lifetime) => {\n-            visitor.visit_lifetime_bound(lifetime);\n+            visitor.visit_lifetime(lifetime);\n         }\n     }\n }\n \n pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics) {\n-    for param in generics.ty_params.iter() {\n+    for param in &generics.ty_params {\n         visitor.visit_ident(param.span, param.ident);\n-        walk_ty_param_bounds_helper(visitor, &param.bounds);\n-        walk_ty_opt(visitor, &param.default);\n+        walk_list!(visitor, visit_ty_param_bound, &param.bounds);\n+        walk_list!(visitor, visit_ty, &param.default);\n     }\n-    walk_lifetime_decls_helper(visitor, &generics.lifetimes);\n+    walk_list!(visitor, visit_lifetime_def, &generics.lifetimes);\n     for predicate in &generics.where_clause.predicates {\n         match predicate {\n-            &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ref bounded_ty,\n+            &WherePredicate::BoundPredicate(WhereBoundPredicate{ref bounded_ty,\n                                                                           ref bounds,\n+                                                                          ref bound_lifetimes,\n                                                                           ..}) => {\n-                visitor.visit_ty(&**bounded_ty);\n-                walk_ty_param_bounds_helper(visitor, bounds);\n+                visitor.visit_ty(bounded_ty);\n+                walk_list!(visitor, visit_ty_param_bound, bounds);\n+                walk_list!(visitor, visit_lifetime_def, bound_lifetimes);\n             }\n-            &ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n+            &WherePredicate::RegionPredicate(WhereRegionPredicate{ref lifetime,\n                                                                             ref bounds,\n                                                                             ..}) => {\n-                visitor.visit_lifetime_ref(lifetime);\n-\n-                for bound in bounds {\n-                    visitor.visit_lifetime_ref(bound);\n-                }\n+                visitor.visit_lifetime(lifetime);\n+                walk_list!(visitor, visit_lifetime, bounds);\n             }\n-            &ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{id,\n+            &WherePredicate::EqPredicate(WhereEqPredicate{id,\n                                                                     ref path,\n                                                                     ref ty,\n                                                                     ..}) => {\n                 visitor.visit_path(path, id);\n-                visitor.visit_ty(&**ty);\n+                visitor.visit_ty(ty);\n             }\n         }\n     }\n }\n \n-pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FunctionRetTy) {\n-    if let Return(ref output_ty) = *ret_ty {\n-        visitor.visit_ty(&**output_ty)\n-    }\n-}\n-\n pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl) {\n     for argument in &function_declaration.inputs {\n-        visitor.visit_pat(&*argument.pat);\n-        visitor.visit_ty(&*argument.ty)\n+        visitor.visit_pat(&argument.pat);\n+        visitor.visit_ty(&argument.ty)\n+    }\n+    if let Return(ref output_ty) = function_declaration.output {\n+        visitor.visit_ty(output_ty)\n     }\n-    walk_fn_ret_ty(visitor, &function_declaration.output)\n }\n \n pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n@@ -614,23 +555,19 @@ pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n             visitor.visit_generics(&sig.generics);\n             visitor.visit_explicit_self(&sig.explicit_self);\n         }\n-        FnKind::Closure(..) => {}\n+        FnKind::Closure => {}\n     }\n \n     visitor.visit_block(function_body)\n }\n \n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem) {\n     visitor.visit_ident(trait_item.span, trait_item.ident);\n-    for attr in &trait_item.attrs {\n-        visitor.visit_attribute(attr);\n-    }\n+    walk_list!(visitor, visit_attribute, &trait_item.attrs);\n     match trait_item.node {\n         ConstTraitItem(ref ty, ref default) => {\n             visitor.visit_ty(ty);\n-            if let Some(ref expr) = *default {\n-                visitor.visit_expr(expr);\n-            }\n+            walk_list!(visitor, visit_expr, default);\n         }\n         MethodTraitItem(ref sig, None) => {\n             visitor.visit_explicit_self(&sig.explicit_self);\n@@ -642,17 +579,15 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n                              body, trait_item.span, trait_item.id);\n         }\n         TypeTraitItem(ref bounds, ref default) => {\n-            walk_ty_param_bounds_helper(visitor, bounds);\n-            walk_ty_opt(visitor, default);\n+            walk_list!(visitor, visit_ty_param_bound, bounds);\n+            walk_list!(visitor, visit_ty, default);\n         }\n     }\n }\n \n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem) {\n     visitor.visit_ident(impl_item.span, impl_item.ident);\n-    for attr in &impl_item.attrs {\n-        visitor.visit_attribute(attr);\n-    }\n+    walk_list!(visitor, visit_attribute, &impl_item.attrs);\n     match impl_item.node {\n         ConstImplItem(ref ty, ref expr) => {\n             visitor.visit_ty(ty);\n@@ -673,59 +608,35 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n \n pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V,\n                                            struct_definition: &'v StructDef) {\n-    for field in &struct_definition.fields {\n-        visitor.visit_struct_field(field)\n-    }\n+    walk_list!(visitor, visit_struct_field, &struct_definition.fields);\n }\n \n pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V,\n                                              struct_field: &'v StructField) {\n-    if let NamedField(name, _) = struct_field.node.kind {\n-        visitor.visit_ident(struct_field.span, name);\n-    }\n-\n-    visitor.visit_ty(&*struct_field.node.ty);\n-\n-    for attr in &struct_field.node.attrs {\n-        visitor.visit_attribute(attr);\n-    }\n+    walk_opt_ident(visitor, struct_field.span, struct_field.node.ident());\n+    visitor.visit_ty(&struct_field.node.ty);\n+    walk_list!(visitor, visit_attribute, &struct_field.node.attrs);\n }\n \n pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block) {\n-    for statement in &block.stmts {\n-        visitor.visit_stmt(&**statement)\n-    }\n-    walk_expr_opt(visitor, &block.expr)\n+    walk_list!(visitor, visit_stmt, &block.stmts);\n+    walk_list!(visitor, visit_expr, &block.expr);\n }\n \n pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n     match statement.node {\n-        StmtDecl(ref declaration, _) => visitor.visit_decl(&**declaration),\n+        StmtDecl(ref declaration, _) => visitor.visit_decl(declaration),\n         StmtExpr(ref expression, _) | StmtSemi(ref expression, _) => {\n-            visitor.visit_expr(&**expression)\n+            visitor.visit_expr(expression)\n         }\n-        StmtMac(ref mac, _) => visitor.visit_mac(&**mac),\n+        StmtMac(ref mac, _) => visitor.visit_mac(mac),\n     }\n }\n \n pub fn walk_decl<'v, V: Visitor<'v>>(visitor: &mut V, declaration: &'v Decl) {\n     match declaration.node {\n-        DeclLocal(ref local) => visitor.visit_local(&**local),\n-        DeclItem(ref item) => visitor.visit_item(&**item),\n-    }\n-}\n-\n-pub fn walk_expr_opt<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                         optional_expression: &'v Option<P<Expr>>) {\n-    match *optional_expression {\n-        None => {}\n-        Some(ref expression) => visitor.visit_expr(&**expression),\n-    }\n-}\n-\n-pub fn walk_exprs<'v, V: Visitor<'v>>(visitor: &mut V, expressions: &'v [P<Expr>]) {\n-    for expression in expressions {\n-        visitor.visit_expr(&**expression)\n+        DeclLocal(ref local) => visitor.visit_local(local),\n+        DeclItem(ref item) => visitor.visit_item(item),\n     }\n }\n \n@@ -736,139 +647,142 @@ pub fn walk_mac<'v, V: Visitor<'v>>(_: &mut V, _: &'v Mac) {\n pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n     match expression.node {\n         ExprBox(ref subexpression) => {\n-            visitor.visit_expr(&**subexpression)\n+            visitor.visit_expr(subexpression)\n         }\n         ExprInPlace(ref place, ref subexpression) => {\n-            visitor.visit_expr(&**place);\n-            visitor.visit_expr(&**subexpression)\n+            visitor.visit_expr(place);\n+            visitor.visit_expr(subexpression)\n         }\n         ExprVec(ref subexpressions) => {\n-            walk_exprs(visitor, subexpressions)\n+            walk_list!(visitor, visit_expr, subexpressions);\n         }\n         ExprRepeat(ref element, ref count) => {\n-            visitor.visit_expr(&**element);\n-            visitor.visit_expr(&**count)\n+            visitor.visit_expr(element);\n+            visitor.visit_expr(count)\n         }\n         ExprStruct(ref path, ref fields, ref optional_base) => {\n             visitor.visit_path(path, expression.id);\n             for field in fields {\n-                visitor.visit_expr(&*field.expr)\n+                visitor.visit_ident(field.ident.span, field.ident.node);\n+                visitor.visit_expr(&field.expr)\n             }\n-            walk_expr_opt(visitor, optional_base)\n+            walk_list!(visitor, visit_expr, optional_base);\n         }\n         ExprTup(ref subexpressions) => {\n-            for subexpression in subexpressions {\n-                visitor.visit_expr(&**subexpression)\n-            }\n+            walk_list!(visitor, visit_expr, subexpressions);\n         }\n         ExprCall(ref callee_expression, ref arguments) => {\n-            for argument in arguments {\n-                visitor.visit_expr(&**argument)\n-            }\n-            visitor.visit_expr(&**callee_expression)\n+            walk_list!(visitor, visit_expr, arguments);\n+            visitor.visit_expr(callee_expression)\n         }\n-        ExprMethodCall(_, ref types, ref arguments) => {\n-            walk_exprs(visitor, arguments);\n-            for typ in types {\n-                visitor.visit_ty(&**typ)\n-            }\n+        ExprMethodCall(ref ident, ref types, ref arguments) => {\n+            visitor.visit_ident(ident.span, ident.node);\n+            walk_list!(visitor, visit_expr, arguments);\n+            walk_list!(visitor, visit_ty, types);\n         }\n         ExprBinary(_, ref left_expression, ref right_expression) => {\n-            visitor.visit_expr(&**left_expression);\n-            visitor.visit_expr(&**right_expression)\n+            visitor.visit_expr(left_expression);\n+            visitor.visit_expr(right_expression)\n         }\n         ExprAddrOf(_, ref subexpression) | ExprUnary(_, ref subexpression) => {\n-            visitor.visit_expr(&**subexpression)\n+            visitor.visit_expr(subexpression)\n         }\n         ExprLit(_) => {}\n         ExprCast(ref subexpression, ref typ) => {\n-            visitor.visit_expr(&**subexpression);\n-            visitor.visit_ty(&**typ)\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_ty(typ)\n         }\n         ExprIf(ref head_expression, ref if_block, ref optional_else) => {\n-            visitor.visit_expr(&**head_expression);\n-            visitor.visit_block(&**if_block);\n-            walk_expr_opt(visitor, optional_else)\n+            visitor.visit_expr(head_expression);\n+            visitor.visit_block(if_block);\n+            walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprWhile(ref subexpression, ref block, _) => {\n-            visitor.visit_expr(&**subexpression);\n-            visitor.visit_block(&**block)\n+        ExprWhile(ref subexpression, ref block, opt_ident) => {\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_block(block);\n+            walk_opt_ident(visitor, expression.span, opt_ident)\n         }\n         ExprIfLet(ref pattern, ref subexpression, ref if_block, ref optional_else) => {\n-            visitor.visit_pat(&**pattern);\n-            visitor.visit_expr(&**subexpression);\n-            visitor.visit_block(&**if_block);\n-            walk_expr_opt(visitor, optional_else);\n-        }\n-        ExprWhileLet(ref pattern, ref subexpression, ref block, _) => {\n-            visitor.visit_pat(&**pattern);\n-            visitor.visit_expr(&**subexpression);\n-            visitor.visit_block(&**block);\n-        }\n-        ExprForLoop(ref pattern, ref subexpression, ref block, _) => {\n-            visitor.visit_pat(&**pattern);\n-            visitor.visit_expr(&**subexpression);\n-            visitor.visit_block(&**block)\n-        }\n-        ExprLoop(ref block, _) => visitor.visit_block(&**block),\n+            visitor.visit_pat(pattern);\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_block(if_block);\n+            walk_list!(visitor, visit_expr, optional_else);\n+        }\n+        ExprWhileLet(ref pattern, ref subexpression, ref block, opt_ident) => {\n+            visitor.visit_pat(pattern);\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_block(block);\n+            walk_opt_ident(visitor, expression.span, opt_ident)\n+        }\n+        ExprForLoop(ref pattern, ref subexpression, ref block, opt_ident) => {\n+            visitor.visit_pat(pattern);\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_block(block);\n+            walk_opt_ident(visitor, expression.span, opt_ident)\n+        }\n+        ExprLoop(ref block, opt_ident) => {\n+            visitor.visit_block(block);\n+            walk_opt_ident(visitor, expression.span, opt_ident)\n+        }\n         ExprMatch(ref subexpression, ref arms, _) => {\n-            visitor.visit_expr(&**subexpression);\n-            for arm in arms {\n-                visitor.visit_arm(arm)\n-            }\n+            visitor.visit_expr(subexpression);\n+            walk_list!(visitor, visit_arm, arms);\n         }\n         ExprClosure(_, ref function_declaration, ref body) => {\n             visitor.visit_fn(FnKind::Closure,\n-                             &**function_declaration,\n-                             &**body,\n+                             function_declaration,\n+                             body,\n                              expression.span,\n                              expression.id)\n         }\n-        ExprBlock(ref block) => visitor.visit_block(&**block),\n+        ExprBlock(ref block) => visitor.visit_block(block),\n         ExprAssign(ref left_hand_expression, ref right_hand_expression) => {\n-            visitor.visit_expr(&**right_hand_expression);\n-            visitor.visit_expr(&**left_hand_expression)\n+            visitor.visit_expr(right_hand_expression);\n+            visitor.visit_expr(left_hand_expression)\n         }\n         ExprAssignOp(_, ref left_expression, ref right_expression) => {\n-            visitor.visit_expr(&**right_expression);\n-            visitor.visit_expr(&**left_expression)\n+            visitor.visit_expr(right_expression);\n+            visitor.visit_expr(left_expression)\n         }\n-        ExprField(ref subexpression, _) => {\n-            visitor.visit_expr(&**subexpression);\n+        ExprField(ref subexpression, ref ident) => {\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_ident(ident.span, ident.node);\n         }\n         ExprTupField(ref subexpression, _) => {\n-            visitor.visit_expr(&**subexpression);\n+            visitor.visit_expr(subexpression);\n         }\n         ExprIndex(ref main_expression, ref index_expression) => {\n-            visitor.visit_expr(&**main_expression);\n-            visitor.visit_expr(&**index_expression)\n+            visitor.visit_expr(main_expression);\n+            visitor.visit_expr(index_expression)\n         }\n         ExprRange(ref start, ref end) => {\n-            walk_expr_opt(visitor, start);\n-            walk_expr_opt(visitor, end)\n+            walk_list!(visitor, visit_expr, start);\n+            walk_list!(visitor, visit_expr, end);\n         }\n         ExprPath(ref maybe_qself, ref path) => {\n-            if let Some(ref qself) = *maybe_qself {\n+            for qself in maybe_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, expression.id)\n         }\n-        ExprBreak(_) | ExprAgain(_) => {}\n+        ExprBreak(ref opt_sp_ident) | ExprAgain(ref opt_sp_ident) => {\n+            for sp_ident in opt_sp_ident {\n+                visitor.visit_ident(sp_ident.span, sp_ident.node);\n+            }\n+        }\n         ExprRet(ref optional_expression) => {\n-            walk_expr_opt(visitor, optional_expression)\n+            walk_list!(visitor, visit_expr, optional_expression);\n         }\n         ExprMac(ref mac) => visitor.visit_mac(mac),\n         ExprParen(ref subexpression) => {\n-            visitor.visit_expr(&**subexpression)\n+            visitor.visit_expr(subexpression)\n         }\n         ExprInlineAsm(ref ia) => {\n-            for input in &ia.inputs {\n-                let (_, ref input) = *input;\n-                visitor.visit_expr(&**input)\n+            for &(_, ref input) in &ia.inputs {\n+                visitor.visit_expr(&input)\n             }\n-            for output in &ia.outputs {\n-                let (_, ref output, _) = *output;\n-                visitor.visit_expr(&**output)\n+            for &(_, ref output, _) in &ia.outputs {\n+                visitor.visit_expr(&output)\n             }\n         }\n     }\n@@ -877,12 +791,8 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n }\n \n pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n-    for pattern in &arm.pats {\n-        visitor.visit_pat(&**pattern)\n-    }\n-    walk_expr_opt(visitor, &arm.guard);\n-    visitor.visit_expr(&*arm.body);\n-    for attr in &arm.attrs {\n-        visitor.visit_attribute(attr);\n-    }\n+    walk_list!(visitor, visit_pat, &arm.pats);\n+    walk_list!(visitor, visit_expr, &arm.guard);\n+    visitor.visit_expr(&arm.body);\n+    walk_list!(visitor, visit_attribute, &arm.attrs);\n }"}]}