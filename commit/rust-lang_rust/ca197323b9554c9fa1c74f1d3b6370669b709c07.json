{"sha": "ca197323b9554c9fa1c74f1d3b6370669b709c07", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhMTk3MzIzYjk1NTRjOWZhMWM3NGYxZDNiNjM3MDY2OWI3MDljMDc=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-09-18T14:33:24Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-09-18T14:33:24Z"}, "message": "incr.comp.: Allow for more fine-grained testing of CGU reuse and use it to test incremental ThinLTO.", "tree": {"sha": "b6bc81426505538af4e9895b2951d5f73e288c50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6bc81426505538af4e9895b2951d5f73e288c50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca197323b9554c9fa1c74f1d3b6370669b709c07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca197323b9554c9fa1c74f1d3b6370669b709c07", "html_url": "https://github.com/rust-lang/rust/commit/ca197323b9554c9fa1c74f1d3b6370669b709c07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca197323b9554c9fa1c74f1d3b6370669b709c07/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b80cb47889e0ad9400b6708ce2b4c4b364b71982", "url": "https://api.github.com/repos/rust-lang/rust/commits/b80cb47889e0ad9400b6708ce2b4c4b364b71982", "html_url": "https://github.com/rust-lang/rust/commit/b80cb47889e0ad9400b6708ce2b4c4b364b71982"}], "stats": {"total": 453, "additions": 373, "deletions": 80}, "files": [{"sha": "2a0891787f8419758bc09510777f3274a76ad276", "filename": "src/librustc/dep_graph/cgu_reuse_tracker.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Flibrustc%2Fdep_graph%2Fcgu_reuse_tracker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Flibrustc%2Fdep_graph%2Fcgu_reuse_tracker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fcgu_reuse_tracker.rs?ref=ca197323b9554c9fa1c74f1d3b6370669b709c07", "patch": "@@ -0,0 +1,145 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Some facilities for tracking how codegen-units are reused during incremental\n+//! compilition. This is used for incremental compiliation tests and debug\n+//! output.\n+\n+use session::Session;\n+use rustc_data_structures::fx::FxHashMap;\n+use std::sync::{Arc, Mutex};\n+use syntax_pos::Span;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, PartialOrd)]\n+pub enum CguReuse {\n+    No,\n+    PreLto,\n+    PostLto,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub enum ComparisonKind {\n+    Exact,\n+    AtLeast,\n+}\n+\n+struct TrackerData {\n+    actual_reuse: FxHashMap<String, CguReuse>,\n+    expected_reuse: FxHashMap<String, (String, SendSpan, CguReuse, ComparisonKind)>,\n+}\n+\n+// Span does not implement `Send`, so we can't just store it in the shared\n+// `TrackerData` object. Instead of splitting up `TrackerData` into shared and\n+// non-shared parts (which would be complicated), we just mark the `Span` here\n+// explicitly as `Send`. That's safe because the span data here is only ever\n+// accessed from the main thread.\n+struct SendSpan(Span);\n+unsafe impl Send for SendSpan {}\n+\n+#[derive(Clone)]\n+pub struct CguReuseTracker {\n+    data: Option<Arc<Mutex<TrackerData>>>,\n+}\n+\n+impl CguReuseTracker {\n+    pub fn new() -> CguReuseTracker {\n+        let data = TrackerData {\n+            actual_reuse: FxHashMap(),\n+            expected_reuse: FxHashMap(),\n+        };\n+\n+        CguReuseTracker {\n+            data: Some(Arc::new(Mutex::new(data))),\n+        }\n+    }\n+\n+    pub fn new_disabled() -> CguReuseTracker {\n+        CguReuseTracker {\n+            data: None,\n+        }\n+    }\n+\n+    pub fn set_actual_reuse(&self, cgu_name: &str, kind: CguReuse) {\n+        if let Some(ref data) = self.data {\n+            debug!(\"set_actual_reuse({:?}, {:?})\", cgu_name, kind);\n+\n+            let prev_reuse = data.lock()\n+                                 .unwrap()\n+                                 .actual_reuse\n+                                 .insert(cgu_name.to_string(), kind);\n+\n+            if let Some(prev_reuse) = prev_reuse {\n+                // The only time it is legal to overwrite reuse state is when\n+                // we discover during ThinLTO that we can actually reuse the\n+                // post-LTO version of a CGU.\n+                assert_eq!(prev_reuse, CguReuse::PreLto);\n+            }\n+        }\n+    }\n+\n+    pub fn set_expectation(&self,\n+                           cgu_name: &str,\n+                           cgu_user_name: &str,\n+                           error_span: Span,\n+                           expected_reuse: CguReuse,\n+                           comparison_kind: ComparisonKind) {\n+        if let Some(ref data) = self.data {\n+            debug!(\"set_expectation({:?}, {:?}, {:?})\", cgu_name,\n+                                                        expected_reuse,\n+                                                        comparison_kind);\n+            let mut data = data.lock().unwrap();\n+\n+            data.expected_reuse.insert(cgu_name.to_string(),\n+                                       (cgu_user_name.to_string(),\n+                                        SendSpan(error_span),\n+                                        expected_reuse,\n+                                        comparison_kind));\n+        }\n+    }\n+\n+    pub fn check_expected_reuse(&self, sess: &Session) {\n+        if let Some(ref data) = self.data {\n+            let data = data.lock().unwrap();\n+\n+            for (cgu_name, &(ref cgu_user_name,\n+                             ref error_span,\n+                             expected_reuse,\n+                             comparison_kind)) in &data.expected_reuse {\n+                if let Some(&actual_reuse) = data.actual_reuse.get(cgu_name) {\n+                    let (error, at_least) = match comparison_kind {\n+                        ComparisonKind::Exact => {\n+                            (expected_reuse != actual_reuse, false)\n+                        }\n+                        ComparisonKind::AtLeast => {\n+                            (actual_reuse < expected_reuse, true)\n+                        }\n+                    };\n+\n+                    if error {\n+                        let at_least = if at_least { \"at least \" } else { \"\" };\n+                        let msg = format!(\"CGU-reuse for `{}` is `{:?}` but \\\n+                                           should be {}`{:?}`\",\n+                                          cgu_user_name,\n+                                          actual_reuse,\n+                                          at_least,\n+                                          expected_reuse);\n+                        sess.span_err(error_span.0, &msg);\n+                    }\n+                } else {\n+                    let msg = format!(\"CGU-reuse for `{}` (mangled: `{}`) was \\\n+                                       not recorded\",\n+                                       cgu_user_name,\n+                                       cgu_name);\n+                    sess.span_fatal(error_span.0, &msg);\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "158edc6c59e0e0a18a0d2360328626bedaf6175e", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=ca197323b9554c9fa1c74f1d3b6370669b709c07", "patch": "@@ -16,6 +16,7 @@ mod prev;\n mod query;\n mod safe;\n mod serialized;\n+pub mod cgu_reuse_tracker;\n \n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n pub use self::dep_node::{DepNode, DepKind, DepConstructor, WorkProductId, label_strs};"}, {"sha": "a23bab6226ef31480e595273e25044cec20f3927", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=ca197323b9554c9fa1c74f1d3b6370669b709c07", "patch": "@@ -30,16 +30,7 @@ pub const ATTR_IF_THIS_CHANGED: &'static str = \"rustc_if_this_changed\";\n pub const ATTR_THEN_THIS_WOULD_NEED: &'static str = \"rustc_then_this_would_need\";\n pub const ATTR_PARTITION_REUSED: &'static str = \"rustc_partition_reused\";\n pub const ATTR_PARTITION_CODEGENED: &'static str = \"rustc_partition_codegened\";\n-\n-\n-pub const DEP_GRAPH_ASSERT_ATTRS: &'static [&'static str] = &[\n-    ATTR_IF_THIS_CHANGED,\n-    ATTR_THEN_THIS_WOULD_NEED,\n-    ATTR_DIRTY,\n-    ATTR_CLEAN,\n-    ATTR_PARTITION_REUSED,\n-    ATTR_PARTITION_CODEGENED,\n-];\n+pub const ATTR_EXPECTED_CGU_REUSE: &'static str = \"rustc_expected_cgu_reuse\";\n \n pub const IGNORED_ATTRIBUTES: &'static [&'static str] = &[\n     \"cfg\",\n@@ -49,4 +40,5 @@ pub const IGNORED_ATTRIBUTES: &'static [&'static str] = &[\n     ATTR_CLEAN,\n     ATTR_PARTITION_REUSED,\n     ATTR_PARTITION_CODEGENED,\n+    ATTR_EXPECTED_CGU_REUSE,\n ];"}, {"sha": "e749d0338d023a219c2a0e4eac9ebc480f488812", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=ca197323b9554c9fa1c74f1d3b6370669b709c07", "patch": "@@ -11,6 +11,7 @@\n pub use self::code_stats::{DataTypeKind, SizeKind, FieldInfo, VariantInfo};\n use self::code_stats::CodeStats;\n \n+use dep_graph::cgu_reuse_tracker::CguReuseTracker;\n use hir::def_id::CrateNum;\n use rustc_data_structures::fingerprint::Fingerprint;\n \n@@ -124,6 +125,9 @@ pub struct Session {\n     pub imported_macro_spans: OneThread<RefCell<FxHashMap<Span, (String, Span)>>>,\n \n     incr_comp_session: OneThread<RefCell<IncrCompSession>>,\n+    /// Used for incremental compilation tests. Will only be populated if\n+    /// `-Zquery-dep-graph` is specified.\n+    pub cgu_reuse_tracker: CguReuseTracker,\n \n     /// Used by -Z profile-queries in util::common\n     pub profile_channel: Lock<Option<mpsc::Sender<ProfileQueriesMsg>>>,\n@@ -1109,6 +1113,12 @@ pub fn build_session_(\n     };\n     let working_dir = file_path_mapping.map_prefix(working_dir);\n \n+    let cgu_reuse_tracker = if sopts.debugging_opts.query_dep_graph {\n+        CguReuseTracker::new()\n+    } else {\n+        CguReuseTracker::new_disabled()\n+    };\n+\n     let sess = Session {\n         target: target_cfg,\n         host,\n@@ -1139,6 +1149,7 @@ pub fn build_session_(\n         injected_panic_runtime: Once::new(),\n         imported_macro_spans: OneThread::new(RefCell::new(FxHashMap::default())),\n         incr_comp_session: OneThread::new(RefCell::new(IncrCompSession::NotInitialized)),\n+        cgu_reuse_tracker,\n         self_profiling: Lock::new(SelfProfiler::new()),\n         profile_channel: Lock::new(None),\n         perf_stats: PerfStats {"}, {"sha": "3ac22f4eaef6550f9bb74989e16365d96baaff98", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=ca197323b9554c9fa1c74f1d3b6370669b709c07", "patch": "@@ -18,6 +18,7 @@ use llvm::{True, False};\n use llvm;\n use memmap;\n use rustc::dep_graph::WorkProduct;\n+use rustc::dep_graph::cgu_reuse_tracker::CguReuse;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::session::config::{self, Lto};\n@@ -538,6 +539,8 @@ fn thin_lto(cgcx: &CodegenContext,\n                     let work_product = green_modules[module_name].clone();\n                     copy_jobs.push(work_product);\n                     info!(\" - {}: re-used\", module_name);\n+                    cgcx.cgu_reuse_tracker.set_actual_reuse(module_name,\n+                                                            CguReuse::PostLto);\n                     continue\n                 }\n             }"}, {"sha": "447b505e79c62c55c5d1f22392915bad232b8db0", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=ca197323b9554c9fa1c74f1d3b6370669b709c07", "patch": "@@ -21,6 +21,7 @@ use memmap;\n use rustc_incremental::{copy_cgu_workproducts_to_incr_comp_cache_dir,\n                         in_incr_comp_dir, in_incr_comp_dir_sess};\n use rustc::dep_graph::{WorkProduct, WorkProductId, WorkProductFileKind};\n+use rustc::dep_graph::cgu_reuse_tracker::CguReuseTracker;\n use rustc::middle::cstore::EncodedMetadata;\n use rustc::session::config::{self, OutputFilenames, OutputType, Passes, Sanitizer, Lto};\n use rustc::session::Session;\n@@ -377,6 +378,8 @@ pub struct CodegenContext {\n     // The incremental compilation session directory, or None if we are not\n     // compiling incrementally\n     pub incr_comp_session_dir: Option<PathBuf>,\n+    // Used to update CGU re-use information during the thinlto phase.\n+    pub cgu_reuse_tracker: CguReuseTracker,\n     // Channel back to the main control thread to send messages to\n     coordinator_send: Sender<Box<dyn Any + Send>>,\n     // A reference to the TimeGraph so we can register timings. None means that\n@@ -1607,6 +1610,7 @@ fn start_executing_work(tcx: TyCtxt,\n         remark: sess.opts.cg.remark.clone(),\n         worker: 0,\n         incr_comp_session_dir: sess.incr_comp_session_dir_opt().map(|r| r.clone()),\n+        cgu_reuse_tracker: sess.cgu_reuse_tracker.clone(),\n         coordinator_send,\n         diag_emitter: shared_emitter.clone(),\n         time_graph,\n@@ -2390,6 +2394,8 @@ impl OngoingCodegen {\n             }\n         };\n \n+        sess.cgu_reuse_tracker.check_expected_reuse(sess);\n+\n         sess.abort_if_errors();\n \n         if let Some(time_graph) = self.time_graph {"}, {"sha": "55dc43ec1fbca6d3198f22d090df582af7072fe9", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=ca197323b9554c9fa1c74f1d3b6370669b709c07", "patch": "@@ -32,6 +32,7 @@ use abi;\n use back::write::{self, OngoingCodegen};\n use llvm::{self, TypeKind, get_param};\n use metadata;\n+use rustc::dep_graph::cgu_reuse_tracker::CguReuse;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::middle::lang_items::StartFnLangItem;\n use rustc::middle::weak_lang_items;\n@@ -697,25 +698,18 @@ pub fn iter_globals(llmod: &'ll llvm::Module) -> ValueIter<'ll> {\n     }\n }\n \n-#[derive(Debug)]\n-enum CguReUsable {\n-    PreLto,\n-    PostLto,\n-    No\n-}\n-\n fn determine_cgu_reuse<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  cgu: &CodegenUnit<'tcx>)\n-                                 -> CguReUsable {\n+                                 -> CguReuse {\n     if !tcx.dep_graph.is_fully_enabled() {\n-        return CguReUsable::No\n+        return CguReuse::No\n     }\n \n     let work_product_id = &cgu.work_product_id();\n     if tcx.dep_graph.previous_work_product(work_product_id).is_none() {\n         // We don't have anything cached for this CGU. This can happen\n         // if the CGU did not exist in the previous session.\n-        return CguReUsable::No\n+        return CguReuse::No\n     }\n \n     // Try to mark the CGU as green. If it we can do so, it means that nothing\n@@ -732,12 +726,12 @@ fn determine_cgu_reuse<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if tcx.dep_graph.try_mark_green(tcx, &dep_node).is_some() {\n         // We can re-use either the pre- or the post-thinlto state\n         if tcx.sess.lto() != Lto::No {\n-            CguReUsable::PreLto\n+            CguReuse::PreLto\n         } else {\n-            CguReUsable::PostLto\n+            CguReuse::PostLto\n         }\n     } else {\n-        CguReUsable::No\n+        CguReuse::No\n     }\n }\n \n@@ -894,8 +888,11 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ongoing_codegen.wait_for_signal_to_codegen_item();\n         ongoing_codegen.check_for_errors(tcx.sess);\n \n-        let loaded_from_cache = match determine_cgu_reuse(tcx, &cgu) {\n-            CguReUsable::No => {\n+        let cgu_reuse = determine_cgu_reuse(tcx, &cgu);\n+        tcx.sess.cgu_reuse_tracker.set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n+\n+        match cgu_reuse {\n+            CguReuse::No => {\n                 let _timing_guard = time_graph.as_ref().map(|time_graph| {\n                     time_graph.start(write::CODEGEN_WORKER_TIMELINE,\n                                      write::CODEGEN_WORK_PACKAGE_KIND,\n@@ -907,27 +904,21 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 total_codegen_time += start_time.elapsed();\n                 false\n             }\n-            CguReUsable::PreLto => {\n+            CguReuse::PreLto => {\n                 write::submit_pre_lto_module_to_llvm(tcx, CachedModuleCodegen {\n                     name: cgu.name().to_string(),\n                     source: cgu.work_product(tcx),\n                 });\n                 true\n             }\n-            CguReUsable::PostLto => {\n+            CguReuse::PostLto => {\n                 write::submit_post_lto_module_to_llvm(tcx, CachedModuleCodegen {\n                     name: cgu.name().to_string(),\n                     source: cgu.work_product(tcx),\n                 });\n                 true\n             }\n         };\n-\n-        if tcx.dep_graph.is_fully_enabled() {\n-            let dep_node = cgu.codegen_dep_node(tcx);\n-            let dep_node_index = tcx.dep_graph.dep_node_index_of(&dep_node);\n-            tcx.dep_graph.mark_loaded_from_cache(dep_node_index, loaded_from_cache);\n-        }\n     }\n \n     ongoing_codegen.codegen_finished(tcx);\n@@ -938,9 +929,7 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             \"codegen to LLVM IR\",\n                             total_codegen_time);\n \n-    if tcx.sess.opts.incremental.is_some() {\n-        ::rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n-    }\n+    rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n \n     symbol_names_test::report_symbol_names(tcx);\n "}, {"sha": "4ff2529b26d934cbbe4996eccb1eb11e41445579", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 59, "deletions": 44, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=ca197323b9554c9fa1c74f1d3b6370669b709c07", "patch": "@@ -26,47 +26,82 @@\n //! The reason that we use `cfg=...` and not `#[cfg_attr]` is so that\n //! the HIR doesn't change as a result of the annotations, which might\n //! perturb the reuse results.\n+//!\n+//! `#![rustc_expected_cgu_reuse(module=\"spike\", cfg=\"rpass2\", kind=\"post-lto\")]\n+//! allows for doing a more fine-grained check to see if pre- or post-lto data\n+//! was re-used.\n \n use rustc::hir::def_id::LOCAL_CRATE;\n-use rustc::dep_graph::{DepNode, DepConstructor};\n+use rustc::dep_graph::cgu_reuse_tracker::*;\n use rustc::mir::mono::CodegenUnitNameBuilder;\n use rustc::ty::TyCtxt;\n+use std::collections::BTreeSet;\n use syntax::ast;\n-use rustc::ich::{ATTR_PARTITION_REUSED, ATTR_PARTITION_CODEGENED};\n+use rustc::ich::{ATTR_PARTITION_REUSED, ATTR_PARTITION_CODEGENED,\n+                 ATTR_EXPECTED_CGU_REUSE};\n \n const MODULE: &'static str = \"module\";\n const CFG: &'static str = \"cfg\";\n-\n-#[derive(Debug, PartialEq, Clone, Copy)]\n-enum Disposition { Reused, Codegened }\n+const KIND: &'static str = \"kind\";\n \n pub fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.dep_graph.with_ignore(|| {\n         if tcx.sess.opts.incremental.is_none() {\n             return;\n         }\n \n-        let ams = AssertModuleSource { tcx };\n+        let available_cgus = tcx\n+            .collect_and_partition_mono_items(LOCAL_CRATE)\n+            .1\n+            .iter()\n+            .map(|cgu| format!(\"{}\", cgu.name()))\n+            .collect::<BTreeSet<String>>();\n+\n+        let ams = AssertModuleSource {\n+            tcx,\n+            available_cgus\n+        };\n+\n         for attr in &tcx.hir.krate().attrs {\n             ams.check_attr(attr);\n         }\n     })\n }\n \n struct AssertModuleSource<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    available_cgus: BTreeSet<String>,\n }\n \n impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n     fn check_attr(&self, attr: &ast::Attribute) {\n-        let disposition = if attr.check_name(ATTR_PARTITION_REUSED) {\n-            Disposition::Reused\n+        let (expected_reuse, comp_kind) = if attr.check_name(ATTR_PARTITION_REUSED) {\n+            (CguReuse::PreLto, ComparisonKind::AtLeast)\n         } else if attr.check_name(ATTR_PARTITION_CODEGENED) {\n-            Disposition::Codegened\n+            (CguReuse::No, ComparisonKind::Exact)\n+        } else if attr.check_name(ATTR_EXPECTED_CGU_REUSE) {\n+            match &self.field(attr, KIND).as_str()[..] {\n+                \"no\" => (CguReuse::No, ComparisonKind::Exact),\n+                \"pre-lto\" => (CguReuse::PreLto, ComparisonKind::Exact),\n+                \"post-lto\" => (CguReuse::PostLto, ComparisonKind::Exact),\n+                \"any\" => (CguReuse::PreLto, ComparisonKind::AtLeast),\n+                other => {\n+                    self.tcx.sess.span_fatal(\n+                        attr.span,\n+                        &format!(\"unknown cgu-reuse-kind `{}` specified\", other));\n+                }\n+            }\n         } else {\n             return;\n         };\n \n+        if !self.tcx.sess.opts.debugging_opts.query_dep_graph {\n+            self.tcx.sess.span_fatal(\n+                attr.span,\n+                &format!(\"found CGU-reuse attribute but `-Zquery-dep-graph` \\\n+                          was not specified\"));\n+        }\n+\n         if !self.check_config(attr) {\n             debug!(\"check_attr: config does not match, ignoring attr\");\n             return;\n@@ -101,43 +136,24 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n \n         debug!(\"mapping '{}' to cgu name '{}'\", self.field(attr, MODULE), cgu_name);\n \n-        let dep_node = DepNode::new(self.tcx,\n-                                    DepConstructor::CompileCodegenUnit(cgu_name));\n-\n-        if let Some(loaded_from_cache) = self.tcx.dep_graph.was_loaded_from_cache(&dep_node) {\n-            match (disposition, loaded_from_cache) {\n-                (Disposition::Reused, false) => {\n-                    self.tcx.sess.span_err(\n-                        attr.span,\n-                        &format!(\"expected module named `{}` to be Reused but is Codegened\",\n-                                 user_path));\n-                }\n-                (Disposition::Codegened, true) => {\n-                    self.tcx.sess.span_err(\n-                        attr.span,\n-                        &format!(\"expected module named `{}` to be Codegened but is Reused\",\n-                                 user_path));\n-                }\n-                (Disposition::Reused, true) |\n-                (Disposition::Codegened, false) => {\n-                    // These are what we would expect.\n-                }\n-            }\n-        } else {\n-            let available_cgus = self.tcx\n-                .collect_and_partition_mono_items(LOCAL_CRATE)\n-                .1\n-                .iter()\n-                .map(|cgu| format!(\"{}\", cgu.name()))\n-                .collect::<Vec<String>>()\n-                .join(\", \");\n-\n+        if !self.available_cgus.contains(&cgu_name.as_str()[..]) {\n             self.tcx.sess.span_err(attr.span,\n-                &format!(\"no module named `{}` (mangled: {}).\\nAvailable modules: {}\",\n+                &format!(\"no module named `{}` (mangled: {}). \\\n+                          Available modules: {}\",\n                     user_path,\n                     cgu_name,\n-                    available_cgus));\n+                    self.available_cgus\n+                        .iter()\n+                        .cloned()\n+                        .collect::<Vec<_>>()\n+                        .join(\", \")));\n         }\n+\n+        self.tcx.sess.cgu_reuse_tracker.set_expectation(&cgu_name.as_str(),\n+                                                        &user_path,\n+                                                        attr.span,\n+                                                        expected_reuse,\n+                                                        comp_kind);\n     }\n \n     fn field(&self, attr: &ast::Attribute, name: &str) -> ast::Name {\n@@ -171,5 +187,4 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n         debug!(\"check_config: no match found\");\n         return false;\n     }\n-\n }"}, {"sha": "0c1e57c85ebab065914c5de38a3d5ecad888a00f", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=ca197323b9554c9fa1c74f1d3b6370669b709c07", "patch": "@@ -930,6 +930,12 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                                        is just used for rustc unit tests \\\n                                                        and will never be stable\",\n                                                       cfg_fn!(rustc_attrs))),\n+    (\"rustc_expected_cgu_reuse\", Whitelisted, Gated(Stability::Unstable,\n+                                                    \"rustc_attrs\",\n+                                                    \"this attribute \\\n+                                                     is just used for rustc unit tests \\\n+                                                     and will never be stable\",\n+                                                    cfg_fn!(rustc_attrs))),\n     (\"rustc_synthetic\", Whitelisted, Gated(Stability::Unstable,\n                                                       \"rustc_attrs\",\n                                                       \"this attribute \\"}, {"sha": "68806561547bacb7a55408dc651fb5ae805ecf4b", "filename": "src/test/incremental/remove-private-item-cross-crate/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Ftest%2Fincremental%2Fremove-private-item-cross-crate%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Ftest%2Fincremental%2Fremove-private-item-cross-crate%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fremove-private-item-cross-crate%2Fmain.rs?ref=ca197323b9554c9fa1c74f1d3b6370669b709c07", "patch": "@@ -13,6 +13,7 @@\n \n // revisions:rpass1 rpass2\n // aux-build:a.rs\n+// compile-flags: -Zquery-dep-graph\n \n #![feature(rustc_attrs)]\n #![crate_type = \"bin\"]"}, {"sha": "c9e1ab89e5070f97c00b2f1a9da3cd852c89b9e4", "filename": "src/test/incremental/thinlto/cgu_invalidated_via_import.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_via_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_via_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_via_import.rs?ref=ca197323b9554c9fa1c74f1d3b6370669b709c07", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test checks that the LTO phase is re-done for CGUs that import something\n+// via ThinLTO and that imported thing changes while the definition of the CGU\n+// stays untouched.\n+\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph -O\n+// compile-pass\n+\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+#![rustc_expected_cgu_reuse(module=\"cgu_invalidated_via_import-foo\",\n+                            cfg=\"cfail2\",\n+                            kind=\"no\")]\n+#![rustc_expected_cgu_reuse(module=\"cgu_invalidated_via_import-foo\",\n+                            cfg=\"cfail3\",\n+                            kind=\"post-lto\")]\n+\n+#![rustc_expected_cgu_reuse(module=\"cgu_invalidated_via_import-bar\",\n+                            cfg=\"cfail2\",\n+                            kind=\"pre-lto\")]\n+#![rustc_expected_cgu_reuse(module=\"cgu_invalidated_via_import-bar\",\n+                            cfg=\"cfail3\",\n+                            kind=\"post-lto\")]\n+\n+mod foo {\n+\n+    // Trivial functions like this one are imported very reliably by ThinLTO.\n+    #[cfg(cfail1)]\n+    pub fn inlined_fn() -> u32 {\n+        1234\n+    }\n+\n+    #[cfg(not(cfail1))]\n+    pub fn inlined_fn() -> u32 {\n+        1234\n+    }\n+}\n+\n+pub mod bar {\n+    use foo::inlined_fn;\n+\n+    pub fn caller() -> u32 {\n+        inlined_fn()\n+    }\n+}"}, {"sha": "d0d6d6fdc24ccb2e427513480812fd655e02bcc9", "filename": "src/test/incremental/thinlto/independent_cgus_dont_affect_each_other.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Ftest%2Fincremental%2Fthinlto%2Findependent_cgus_dont_affect_each_other.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca197323b9554c9fa1c74f1d3b6370669b709c07/src%2Ftest%2Fincremental%2Fthinlto%2Findependent_cgus_dont_affect_each_other.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fthinlto%2Findependent_cgus_dont_affect_each_other.rs?ref=ca197323b9554c9fa1c74f1d3b6370669b709c07", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test checks that a change in a CGU does not invalidate an unrelated CGU\n+// during incremental ThinLTO.\n+\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph -O\n+// compile-pass\n+\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+#![rustc_expected_cgu_reuse(module=\"independent_cgus_dont_affect_each_other-foo\",\n+                            cfg=\"cfail2\",\n+                            kind=\"no\")]\n+#![rustc_expected_cgu_reuse(module=\"independent_cgus_dont_affect_each_other-foo\",\n+                            cfg=\"cfail3\",\n+                            kind=\"post-lto\")]\n+\n+#![rustc_expected_cgu_reuse(module=\"independent_cgus_dont_affect_each_other-bar\",\n+                            cfg=\"cfail2\",\n+                            kind=\"pre-lto\")]\n+#![rustc_expected_cgu_reuse(module=\"independent_cgus_dont_affect_each_other-bar\",\n+                            cfg=\"cfail3\",\n+                            kind=\"post-lto\")]\n+\n+#![rustc_expected_cgu_reuse(module=\"independent_cgus_dont_affect_each_other-baz\",\n+                            cfg=\"cfail2\",\n+                            kind=\"post-lto\")]\n+#![rustc_expected_cgu_reuse(module=\"independent_cgus_dont_affect_each_other-baz\",\n+                            cfg=\"cfail3\",\n+                            kind=\"post-lto\")]\n+mod foo {\n+\n+    #[cfg(cfail1)]\n+    pub fn inlined_fn() -> u32 {\n+        1234\n+    }\n+\n+    #[cfg(not(cfail1))]\n+    pub fn inlined_fn() -> u32 {\n+        1234\n+    }\n+}\n+\n+pub mod bar {\n+    use foo::inlined_fn;\n+\n+    pub fn caller() -> u32 {\n+        inlined_fn()\n+    }\n+}\n+\n+pub mod baz {\n+    pub fn unrelated_to_other_fns() -> u64 {\n+        0xbeef\n+    }\n+}"}]}