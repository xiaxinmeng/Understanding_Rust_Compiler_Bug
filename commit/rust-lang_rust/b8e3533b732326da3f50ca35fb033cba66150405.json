{"sha": "b8e3533b732326da3f50ca35fb033cba66150405", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4ZTM1MzNiNzMyMzI2ZGEzZjUwY2EzNWZiMDMzY2JhNjYxNTA0MDU=", "commit": {"author": {"name": "Igor Matuszewski", "email": "Xanewok@gmail.com", "date": "2019-05-13T09:42:12Z"}, "committer": {"name": "Igor Matuszewski", "email": "Xanewok@gmail.com", "date": "2019-06-08T18:05:02Z"}, "message": "Separate a `scan_raw_string` (similar `raw_byte` variant)", "tree": {"sha": "ab1732c86a9b397c120661133b2e1c1ce5d2c506", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab1732c86a9b397c120661133b2e1c1ce5d2c506"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8e3533b732326da3f50ca35fb033cba66150405", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8e3533b732326da3f50ca35fb033cba66150405", "html_url": "https://github.com/rust-lang/rust/commit/b8e3533b732326da3f50ca35fb033cba66150405", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8e3533b732326da3f50ca35fb033cba66150405/comments", "author": {"login": "Xanewok", "id": 3093213, "node_id": "MDQ6VXNlcjMwOTMyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3093213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xanewok", "html_url": "https://github.com/Xanewok", "followers_url": "https://api.github.com/users/Xanewok/followers", "following_url": "https://api.github.com/users/Xanewok/following{/other_user}", "gists_url": "https://api.github.com/users/Xanewok/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xanewok/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xanewok/subscriptions", "organizations_url": "https://api.github.com/users/Xanewok/orgs", "repos_url": "https://api.github.com/users/Xanewok/repos", "events_url": "https://api.github.com/users/Xanewok/events{/privacy}", "received_events_url": "https://api.github.com/users/Xanewok/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Xanewok", "id": 3093213, "node_id": "MDQ6VXNlcjMwOTMyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3093213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xanewok", "html_url": "https://github.com/Xanewok", "followers_url": "https://api.github.com/users/Xanewok/followers", "following_url": "https://api.github.com/users/Xanewok/following{/other_user}", "gists_url": "https://api.github.com/users/Xanewok/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xanewok/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xanewok/subscriptions", "organizations_url": "https://api.github.com/users/Xanewok/orgs", "repos_url": "https://api.github.com/users/Xanewok/repos", "events_url": "https://api.github.com/users/Xanewok/events{/privacy}", "received_events_url": "https://api.github.com/users/Xanewok/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b17a5e30a049b11f4bef644d2f65b748ce93c39", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b17a5e30a049b11f4bef644d2f65b748ce93c39", "html_url": "https://github.com/rust-lang/rust/commit/5b17a5e30a049b11f4bef644d2f65b748ce93c39"}], "stats": {"total": 159, "additions": 82, "deletions": 77}, "files": [{"sha": "c42f694f50a000942aafb708cb6137b6d3384b71", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 82, "deletions": 77, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/b8e3533b732326da3f50ca35fb033cba66150405/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8e3533b732326da3f50ca35fb033cba66150405/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=b8e3533b732326da3f50ca35fb033cba66150405", "patch": "@@ -1086,82 +1086,10 @@ impl<'a> StringReader<'a> {\n                 Ok(TokenKind::lit(token::Str, symbol, suffix))\n             }\n             'r' => {\n-                let start_bpos = self.pos;\n-                self.bump();\n-                let mut hash_count: u16 = 0;\n-                while self.ch_is('#') {\n-                    if hash_count == 65535 {\n-                        let bpos = self.next_pos;\n-                        self.fatal_span_(start_bpos,\n-                                         bpos,\n-                                         \"too many `#` symbols: raw strings may be \\\n-                                         delimited by up to 65535 `#` symbols\").raise();\n-                    }\n-                    self.bump();\n-                    hash_count += 1;\n-                }\n-\n-                if self.is_eof() {\n-                    self.fail_unterminated_raw_string(start_bpos, hash_count);\n-                } else if !self.ch_is('\"') {\n-                    let last_bpos = self.pos;\n-                    let curr_char = self.ch.unwrap();\n-                    self.fatal_span_char(start_bpos,\n-                                         last_bpos,\n-                                         \"found invalid character; only `#` is allowed \\\n-                                         in raw string delimitation\",\n-                                         curr_char).raise();\n-                }\n-                self.bump();\n-                let content_start_bpos = self.pos;\n-                let mut content_end_bpos;\n-                let mut valid = true;\n-                'outer: loop {\n-                    if self.is_eof() {\n-                        self.fail_unterminated_raw_string(start_bpos, hash_count);\n-                    }\n-                    // if self.ch_is('\"') {\n-                    // content_end_bpos = self.pos;\n-                    // for _ in 0..hash_count {\n-                    // self.bump();\n-                    // if !self.ch_is('#') {\n-                    // continue 'outer;\n-                    let c = self.ch.unwrap();\n-                    match c {\n-                        '\"' => {\n-                            content_end_bpos = self.pos;\n-                            for _ in 0..hash_count {\n-                                self.bump();\n-                                if !self.ch_is('#') {\n-                                    continue 'outer;\n-                                }\n-                            }\n-                            break;\n-                        }\n-                        '\\r' => {\n-                            if !self.nextch_is('\\n') {\n-                                let last_bpos = self.pos;\n-                                self.err_span_(start_bpos,\n-                                               last_bpos,\n-                                               \"bare CR not allowed in raw string, use \\\\r \\\n-                                                instead\");\n-                                valid = false;\n-                            }\n-                        }\n-                        _ => (),\n-                    }\n-                    self.bump();\n-                }\n-\n-                self.bump();\n-                let symbol = if valid {\n-                    self.name_from_to(content_start_bpos, content_end_bpos)\n-                } else {\n-                    Symbol::intern(\"??\")\n-                };\n+                let (kind, symbol) = self.scan_raw_string();\n                 let suffix = self.scan_optional_raw_name();\n \n-                Ok(TokenKind::lit(token::StrRaw(hash_count), symbol, suffix))\n+                Ok(TokenKind::lit(kind, symbol, suffix))\n             }\n             '-' => {\n                 if self.nextch_is('>') {\n@@ -1315,6 +1243,83 @@ impl<'a> StringReader<'a> {\n         id\n     }\n \n+    fn scan_raw_string(&mut self) -> (token::LitKind, Symbol) {\n+        let start_bpos = self.pos;\n+        self.bump();\n+        let mut hash_count: u16 = 0;\n+        while self.ch_is('#') {\n+            if hash_count == 65535 {\n+                let bpos = self.next_pos;\n+                self.fatal_span_(start_bpos,\n+                                 bpos,\n+                                 \"too many `#` symbols: raw strings may be \\\n+                                 delimited by up to 65535 `#` symbols\").raise();\n+            }\n+            self.bump();\n+            hash_count += 1;\n+        }\n+\n+        if self.is_eof() {\n+            self.fail_unterminated_raw_string(start_bpos, hash_count);\n+        } else if !self.ch_is('\"') {\n+            let last_bpos = self.pos;\n+            let curr_char = self.ch.unwrap();\n+            self.fatal_span_char(start_bpos,\n+                                 last_bpos,\n+                                 \"found invalid character; only `#` is allowed \\\n+                                 in raw string delimitation\",\n+                                 curr_char).raise();\n+        }\n+        self.bump();\n+        let content_start_bpos = self.pos;\n+        let mut content_end_bpos;\n+        let mut valid = true;\n+        'outer: loop {\n+            // if self.ch_is('\"') {\n+            // content_end_bpos = self.pos;\n+            // for _ in 0..hash_count {\n+            // self.bump();\n+            // if !self.ch_is('#') {\n+            // continue 'outer;\n+            match self.ch {\n+                None => {\n+                    self.fail_unterminated_raw_string(start_bpos, hash_count);\n+                }\n+                Some('\"') => {\n+                    content_end_bpos = self.pos;\n+                    for _ in 0..hash_count {\n+                        self.bump();\n+                        if !self.ch_is('#') {\n+                            continue 'outer;\n+                        }\n+                    }\n+                    break;\n+                }\n+                Some(c) => {\n+                    if c == '\\r' && !self.nextch_is('\\n') {\n+                        let last_bpos = self.pos;\n+                        self.err_span_(start_bpos,\n+                                        last_bpos,\n+                                        \"bare CR not allowed in raw string, use \\\\r \\\n+                                        instead\");\n+                        valid = false;\n+                    }\n+                }\n+            }\n+            self.bump();\n+        }\n+\n+        self.bump();\n+\n+        let symbol = if valid {\n+            self.name_from_to(content_start_bpos, content_end_bpos)\n+        } else {\n+            Symbol::intern(\"??\")\n+        };\n+\n+        (token::StrRaw(hash_count), symbol)\n+    }\n+\n     fn scan_raw_byte_string(&mut self) -> (token::LitKind, Symbol) {\n         let start_bpos = self.pos;\n         self.bump();\n@@ -1324,7 +1329,7 @@ impl<'a> StringReader<'a> {\n                 let bpos = self.next_pos;\n                 self.fatal_span_(start_bpos,\n                                  bpos,\n-                                 \"too many `#` symbols: raw byte strings may be \\\n+                                 \"too many `#` symbols: raw strings may be \\\n                                  delimited by up to 65535 `#` symbols\").raise();\n             }\n             self.bump();\n@@ -1334,8 +1339,8 @@ impl<'a> StringReader<'a> {\n         if self.is_eof() {\n             self.fail_unterminated_raw_string(start_bpos, hash_count);\n         } else if !self.ch_is('\"') {\n-            let pos = self.pos;\n-            let ch = self.ch.unwrap();\n+            let last_bpos = self.pos;\n+            let curr_char = self.ch.unwrap();\n             self.fatal_span_char(start_bpos,\n                                         pos,\n                                         \"found invalid character; only `#` is allowed in raw \\"}]}