{"sha": "93c2f5e0e43532a2288ed6dec378564264d1a77c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzYzJmNWUwZTQzNTMyYTIyODhlZDZkZWMzNzg1NjQyNjRkMWE3N2M=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-28T02:32:42Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-28T02:35:24Z"}, "message": "rustc: Use coherence for operator overloading.\n\nThe only use of the old-style impls is now placement new.", "tree": {"sha": "2d8d3f5d4667f7a009fa338bc34076216873b35c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d8d3f5d4667f7a009fa338bc34076216873b35c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93c2f5e0e43532a2288ed6dec378564264d1a77c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93c2f5e0e43532a2288ed6dec378564264d1a77c", "html_url": "https://github.com/rust-lang/rust/commit/93c2f5e0e43532a2288ed6dec378564264d1a77c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93c2f5e0e43532a2288ed6dec378564264d1a77c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6d2e49852873c52b872185a0ae5a8ca941ed2f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6d2e49852873c52b872185a0ae5a8ca941ed2f1", "html_url": "https://github.com/rust-lang/rust/commit/e6d2e49852873c52b872185a0ae5a8ca941ed2f1"}], "stats": {"total": 631, "additions": 342, "deletions": 289}, "files": [{"sha": "cd7252be9ec37bfe335f42f5fd112bf182a037d7", "filename": "src/libcore/core.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=93c2f5e0e43532a2288ed6dec378564264d1a77c", "patch": "@@ -31,7 +31,8 @@ import f32::num;\n import f64::num;\n import num::num;\n import ops::{const, copy, send, owned};\n-import ops::{add, sub, mul, div, modulo, neg, bitops, index};\n+import ops::{add, sub, mul, div, modulo, neg, bitand, bitor, bitxor, shl};\n+import ops::{shr, index};\n \n export path, option, some, none, unreachable;\n export extensions;"}, {"sha": "2a05aeb72c2abe339aa0beb2e205278ca26ed990", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 41, "deletions": 9, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=93c2f5e0e43532a2288ed6dec378564264d1a77c", "patch": "@@ -1,64 +1,96 @@\n // Core operators and kinds.\n \n+#[cfg(notest)]\n #[lang=\"const\"]\n trait const {\n     // Empty.\n }\n \n+#[cfg(notest)]\n #[lang=\"copy\"]\n trait copy {\n     // Empty.\n }\n \n+#[cfg(notest)]\n #[lang=\"send\"]\n trait send {\n     // Empty.\n }\n \n+#[cfg(notest)]\n #[lang=\"owned\"]\n trait owned {\n     // Empty.\n }\n \n+#[cfg(notest)]\n #[lang=\"add\"]\n trait add<RHS,Result> {\n     pure fn add(rhs: RHS) -> Result;\n }\n \n+#[cfg(notest)]\n #[lang=\"sub\"]\n trait sub<RHS,Result> {\n     pure fn sub(rhs: RHS) -> Result;\n }\n \n+#[cfg(notest)]\n #[lang=\"mul\"]\n trait mul<RHS,Result> {\n     pure fn mul(rhs: RHS) -> Result;\n }\n \n+#[cfg(notest)]\n #[lang=\"div\"]\n trait div<RHS,Result> {\n     pure fn div(rhs: RHS) -> Result;\n }\n \n+#[cfg(notest)]\n #[lang=\"modulo\"]\n trait modulo<RHS,Result> {\n     pure fn modulo(rhs: RHS) -> Result;\n }\n \n+#[cfg(notest)]\n #[lang=\"neg\"]\n-trait neg<RHS,Result> {\n-    pure fn neg(rhs: RHS) -> Result;\n+trait neg<Result> {\n+    pure fn neg() -> Result;\n }\n \n-#[lang=\"bitops\"]\n-trait bitops<RHS,BitCount,Result> {\n-    pure fn and(rhs: RHS) -> Result;\n-    pure fn or(rhs: RHS) -> Result;\n-    pure fn xor(rhs: RHS) -> Result;\n-    pure fn shl(n: BitCount) -> Result;\n-    pure fn shr(n: BitCount) -> Result;\n+#[cfg(notest)]\n+#[lang=\"bitand\"]\n+trait bitand<RHS,Result> {\n+    pure fn bitand(rhs: RHS) -> Result;\n }\n \n+#[cfg(notest)]\n+#[lang=\"bitor\"]\n+trait bitor<RHS,Result> {\n+    pure fn bitor(rhs: RHS) -> Result;\n+}\n+\n+#[cfg(notest)]\n+#[lang=\"bitxor\"]\n+trait bitxor<RHS,Result> {\n+    pure fn bitxor(rhs: RHS) -> Result;\n+}\n+\n+#[cfg(notest)]\n+#[lang=\"shl\"]\n+trait shl<RHS,Result> {\n+    pure fn shl(rhs: RHS) -> Result;\n+}\n+\n+#[cfg(notest)]\n+#[lang=\"shr\"]\n+trait shr<RHS,Result> {\n+    pure fn shr(rhs: RHS) -> Result;\n+}\n+\n+#[cfg(notest)]\n #[lang=\"index\"]\n trait index<Index,Result> {\n     pure fn index(index: Index) -> Result;"}, {"sha": "8dbb39d18312d859205f4db66d458c39fe7c11be", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=93c2f5e0e43532a2288ed6dec378564264d1a77c", "patch": "@@ -27,6 +27,8 @@ export serializer;\n export ebml_deserializer;\n export deserializer;\n export with_doc_data;\n+export get_doc;\n+export extensions;\n \n type ebml_tag = {id: uint, size: uint};\n \n@@ -40,6 +42,24 @@ type doc = {data: @~[u8], start: uint, end: uint};\n \n type tagged_doc = {tag: uint, doc: doc};\n \n+trait get_doc {\n+    fn [](tag: uint) -> doc;\n+}\n+\n+impl extensions of get_doc for doc {\n+    fn [](tag: uint) -> doc {\n+        get_doc(self, tag)\n+    }\n+}\n+\n+impl extensions of ops::index<uint,doc> for doc {\n+    pure fn index(&&tag: uint) -> doc {\n+        unchecked {\n+            get_doc(self, tag)\n+        }\n+    }\n+}\n+\n fn vuint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n     let a = data[start];\n     if a & 0x80u8 != 0u8 {"}, {"sha": "b7cb85a561057391540fa637a99a44a36236cade", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=93c2f5e0e43532a2288ed6dec378564264d1a77c", "patch": "@@ -773,6 +773,59 @@ enum inlined_item {\n     ii_dtor(class_dtor, ident, ~[ty_param], def_id /* parent id */)\n }\n \n+// Convenience functions\n+\n+pure fn simple_path(id: ident, span: span) -> @path {\n+    @{span: span,\n+      global: false,\n+      idents: ~[id],\n+      rp: none,\n+      types: ~[]}\n+}\n+\n+pure fn empty_span() -> span {\n+    {lo: 0, hi: 0, expn_info: none}\n+}\n+\n+// Convenience implementations\n+\n+// Remove after snapshot!\n+trait path_concat {\n+    pure fn +(&&id: ident) -> @path;\n+}\n+\n+// Remove after snapshot!\n+impl methods of path_concat for ident {\n+    pure fn +(&&id: ident) -> @path {\n+        simple_path(self, empty_span()) + id\n+    }\n+}\n+\n+impl methods of ops::add<ident,@path> for ident {\n+    pure fn add(&&id: ident) -> @path {\n+        simple_path(self, empty_span()) + id\n+    }\n+}\n+\n+// Remove after snapshot!\n+impl methods of path_concat for @path {\n+    pure fn +(&&id: ident) -> @path {\n+        @{\n+            idents: vec::append_one(self.idents, id)\n+            with *self\n+        }\n+    }\n+}\n+\n+impl methods of ops::add<ident,@path> for @path {\n+    pure fn add(&&id: ident) -> @path {\n+        @{\n+            idents: vec::append_one(self.idents, id)\n+            with *self\n+        }\n+    }\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "98b42ce79ae3cf6dcbc2afc97d61c2bf8281dff6", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=93c2f5e0e43532a2288ed6dec378564264d1a77c", "patch": "@@ -87,6 +87,22 @@ pure fn binop_to_str(op: binop) -> ~str {\n     }\n }\n \n+pure fn binop_to_method_name(op: binop) -> option<~str> {\n+    alt op {\n+      add { ret some(~\"add\"); }\n+      subtract { ret some(~\"sub\"); }\n+      mul { ret some(~\"mul\"); }\n+      div { ret some(~\"div\"); }\n+      rem { ret some(~\"modulo\"); }\n+      bitxor { ret some(~\"bitxor\"); }\n+      bitand { ret some(~\"bitand\"); }\n+      bitor { ret some(~\"bitor\"); }\n+      shl { ret some(~\"shl\"); }\n+      shr { ret some(~\"shr\"); }\n+      and | or | eq | lt | le | ne | ge | gt { ret none; }\n+    }\n+}\n+\n pure fn lazy_binop(b: binop) -> bool {\n     alt b { and { true } or { true } _ { false } }\n }"}, {"sha": "bb5b35233cdcd072b5e6671b7b0e1c866e2fa8d4", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=93c2f5e0e43532a2288ed6dec378564264d1a77c", "patch": "@@ -31,23 +31,6 @@ fn empty_span() -> span {\n     {lo: 0, hi: 0, expn_info: none}\n }\n \n-trait path_concat {\n-    fn +(id: ident) -> @ast::path;\n-}\n-\n-impl methods of path_concat for ident {\n-    fn +(id: ident) -> @ast::path {\n-        path(self, empty_span()) + id\n-    }\n-}\n-\n-impl methods of path_concat for @ast::path {\n-    fn +(id: ident) -> @ast::path {\n-        @{idents: vec::append_one(self.idents, id)\n-          with *self}\n-    }\n-}\n-\n trait append_types {\n     fn add_ty(ty: @ast::ty) -> @ast::path;\n     fn add_tys(+tys: ~[@ast::ty]) -> @ast::path;"}, {"sha": "c1274d12f1d0f013465ea508702bb7e6f9d8ae95", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=93c2f5e0e43532a2288ed6dec378564264d1a77c", "patch": "@@ -16,12 +16,12 @@ import ext::base::{mk_ctxt, ext_ctxt};\n import parse;\n import parse::*;\n import proto::*;\n+import ast::methods;\n \n import ast_builder::append_types;\n import ast_builder::ast_builder;\n import ast_builder::methods;\n import ast_builder::path;\n-import ast_builder::path_concat;\n \n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {"}, {"sha": "ee0f28c9a0e26f3cad33739aa7db6c54389511f2", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=93c2f5e0e43532a2288ed6dec378564264d1a77c", "patch": "@@ -170,15 +170,15 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n                              session::sess_os_to_meta_os(sess.targ_cfg.os),\n                              sess.opts.static));\n \n-    time(time_passes, ~\"language item collection\", ||\n+    let lang_items = time(time_passes, ~\"language item collection\", ||\n          middle::lang_items::collect_language_items(crate, sess));\n \n     let { def_map: def_map,\n           exp_map: exp_map,\n           impl_map: impl_map,\n           trait_map: trait_map } =\n         time(time_passes, ~\"resolution\", ||\n-             middle::resolve3::resolve_crate(sess, ast_map, crate));\n+             middle::resolve3::resolve_crate(sess, lang_items, crate));\n \n     let freevars = time(time_passes, ~\"freevar finding\", ||\n         freevars::annotate_freevars(def_map, crate));"}, {"sha": "84ada7726ab7f70e476aaad0d56d0ba51cc09d7c", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=93c2f5e0e43532a2288ed6dec378564264d1a77c", "patch": "@@ -13,6 +13,8 @@ import std::ebml;\n import std::ebml::writer;\n import std::ebml::serializer;\n import std::ebml::deserializer;\n+import std::ebml::extensions;\n+import std::ebml::get_doc;\n import std::map::hashmap;\n import std::serialization::serializer;\n import std::serialization::deserializer;\n@@ -285,7 +287,7 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n }\n \n fn decode_ast(par_doc: ebml::doc) -> ast::inlined_item {\n-    let chi_doc = par_doc[c::tag_tree];\n+    let chi_doc = par_doc[c::tag_tree as uint];\n     let d = ebml::ebml_deserializer(chi_doc);\n     ast::deserialize_inlined_item(d)\n }\n@@ -776,15 +778,11 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n \n trait doc_decoder_helpers {\n     fn as_int() -> int;\n-    fn [](tag: c::astencode_tag) -> ebml::doc;\n     fn opt_child(tag: c::astencode_tag) -> option<ebml::doc>;\n }\n \n impl decoder of doc_decoder_helpers for ebml::doc {\n     fn as_int() -> int { ebml::doc_as_u64(self) as int }\n-    fn [](tag: c::astencode_tag) -> ebml::doc {\n-        ebml::get_doc(self, tag as uint)\n-    }\n     fn opt_child(tag: c::astencode_tag) -> option<ebml::doc> {\n         ebml::maybe_get_doc(self, tag as uint)\n     }\n@@ -843,9 +841,9 @@ impl decoder of ebml_deserializer_decoder_helpers\n fn decode_side_tables(xcx: extended_decode_ctxt,\n                       ast_doc: ebml::doc) {\n     let dcx = xcx.dcx;\n-    let tbl_doc = ast_doc[c::tag_table];\n+    let tbl_doc = ast_doc[c::tag_table as uint];\n     for ebml::docs(tbl_doc) |tag, entry_doc| {\n-        let id0 = entry_doc[c::tag_table_id].as_int();\n+        let id0 = entry_doc[c::tag_table_id as uint].as_int();\n         let id = xcx.tr_id(id0);\n \n         #debug[\">> Side table document with tag 0x%x \\\n@@ -855,7 +853,7 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n         if tag == (c::tag_table_mutbl as uint) {\n             dcx.maps.mutbl_map.insert(id, ());\n         } else {\n-            let val_doc = entry_doc[c::tag_table_val];\n+            let val_doc = entry_doc[c::tag_table_val as uint];\n             let val_dsr = ebml::ebml_deserializer(val_doc);\n             if tag == (c::tag_table_def as uint) {\n                 let def = decode_def(xcx, val_doc);\n@@ -916,7 +914,7 @@ fn encode_item_ast(ebml_w: ebml::writer, item: @ast::item) {\n \n #[cfg(test)]\n fn decode_item_ast(par_doc: ebml::doc) -> @ast::item {\n-    let chi_doc = par_doc[c::tag_tree];\n+    let chi_doc = par_doc[c::tag_tree as uint];\n     let d = ebml::ebml_deserializer(chi_doc);\n     @ast::deserialize_item(d)\n }"}, {"sha": "0aaacee019a98475391f34cb1fdce79872667ec8", "filename": "src/rustc/middle/lang_items.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Frustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Frustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flang_items.rs?ref=93c2f5e0e43532a2288ed6dec378564264d1a77c", "patch": "@@ -34,7 +34,11 @@ class LanguageItems {\n     let mut div_trait: option<def_id>;\n     let mut modulo_trait: option<def_id>;\n     let mut neg_trait: option<def_id>;\n-    let mut bitops_trait: option<def_id>;\n+    let mut bitxor_trait: option<def_id>;\n+    let mut bitand_trait: option<def_id>;\n+    let mut bitor_trait: option<def_id>;\n+    let mut shl_trait: option<def_id>;\n+    let mut shr_trait: option<def_id>;\n     let mut index_trait: option<def_id>;\n \n     new() {\n@@ -49,7 +53,11 @@ class LanguageItems {\n         self.div_trait = none;\n         self.modulo_trait = none;\n         self.neg_trait = none;\n-        self.bitops_trait = none;\n+        self.bitxor_trait = none;\n+        self.bitand_trait = none;\n+        self.bitor_trait = none;\n+        self.shl_trait = none;\n+        self.shr_trait = none;\n         self.index_trait = none;\n     }\n }\n@@ -84,7 +92,11 @@ class LanguageItemCollector {\n         self.item_refs.insert(~\"div\", &mut self.items.div_trait);\n         self.item_refs.insert(~\"modulo\", &mut self.items.modulo_trait);\n         self.item_refs.insert(~\"neg\", &mut self.items.neg_trait);\n-        self.item_refs.insert(~\"bitops\", &mut self.items.bitops_trait);\n+        self.item_refs.insert(~\"bitxor\", &mut self.items.bitxor_trait);\n+        self.item_refs.insert(~\"bitand\", &mut self.items.bitand_trait);\n+        self.item_refs.insert(~\"bitor\", &mut self.items.bitor_trait);\n+        self.item_refs.insert(~\"shl\", &mut self.items.shl_trait);\n+        self.item_refs.insert(~\"shr\", &mut self.items.shr_trait);\n         self.item_refs.insert(~\"index\", &mut self.items.index_trait);\n     }\n \n@@ -125,8 +137,8 @@ class LanguageItemCollector {\n                     some(original_def_id)\n                             if original_def_id != item_def_id => {\n \n-                        self.session.warn(#fmt(\"duplicate entry for `%s`\",\n-                                               value));\n+                        self.session.err(#fmt(\"duplicate entry for `%s`\",\n+                                              value));\n                     }\n                     some(_) | none => {\n                         // OK.\n@@ -184,7 +196,7 @@ class LanguageItemCollector {\n         for self.item_refs.each |key, item_ref| {\n             alt copy *item_ref {\n                 none => {\n-                    self.session.warn(#fmt(\"no item found for `%s`\", key));\n+                    self.session.err(#fmt(\"no item found for `%s`\", key));\n                 }\n                 some(did) => {\n                     // OK."}, {"sha": "8b40d8136abfe91624f417617fad2023430a3b62", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 84, "deletions": 29, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=93c2f5e0e43532a2288ed6dec378564264d1a77c", "patch": "@@ -3,33 +3,38 @@ import metadata::csearch::{each_path, get_impls_for_mod};\n import metadata::csearch::{get_method_names_if_trait, lookup_defs};\n import metadata::cstore::find_use_stmt_cnum;\n import metadata::decoder::{def_like, dl_def, dl_field, dl_impl};\n+import middle::lang_items::LanguageItems;\n import middle::lint::{deny, allow, forbid, level, unused_imports, warn};\n-import syntax::ast::{_mod, arm, blk, bound_const, bound_copy, bound_trait};\n-import syntax::ast::{bound_owned};\n-import syntax::ast::{bound_send, capture_clause, class_ctor, class_dtor};\n-import syntax::ast::{class_member, class_method, crate, crate_num, decl_item};\n-import syntax::ast::{def, def_arg, def_binding, def_class, def_const, def_fn};\n+import syntax::ast::{_mod, add, arm, bitand, bitor, bitxor, blk, bound_const};\n+import syntax::ast::{bound_copy, bound_owned, bound_send, bound_trait};\n+import syntax::ast::{capture_clause, class_ctor, class_dtor, class_member};\n+import syntax::ast::{class_method, crate, crate_num, decl_item, def, def_arg};\n+import syntax::ast::{def_binding, def_class, def_const, def_fn};\n import syntax::ast::{def_foreign_mod, def_id, def_local, def_mod};\n import syntax::ast::{def_prim_ty, def_region, def_self, def_ty, def_ty_param,\n                      def_typaram_binder};\n import syntax::ast::{def_upvar, def_use, def_variant, expr, expr_assign_op};\n import syntax::ast::{expr_binary, expr_cast, expr_field, expr_fn};\n import syntax::ast::{expr_fn_block, expr_index, expr_new, expr_path};\n+import syntax::ast::{def_prim_ty, def_region, def_self, def_ty, def_ty_param};\n+import syntax::ast::{def_upvar, def_use, def_variant, div, eq, expr};\n+import syntax::ast::{expr_assign_op, expr_binary, expr_cast, expr_field};\n+import syntax::ast::{expr_fn, expr_fn_block, expr_index, expr_new, expr_path};\n import syntax::ast::{expr_struct, expr_unary, fn_decl, foreign_item};\n-import syntax::ast::{foreign_item_fn, ident, trait_ref, impure_fn};\n+import syntax::ast::{foreign_item_fn, ge, gt, ident, trait_ref, impure_fn};\n import syntax::ast::{instance_var, item, item_class, item_const, item_enum};\n import syntax::ast::{item_fn, item_mac, item_foreign_mod, item_impl};\n-import syntax::ast::{item_mod, item_trait, item_ty, local, local_crate};\n-import syntax::ast::{method, node_id, pat, pat_enum, pat_ident};\n-import syntax::ast::{path, prim_ty, pat_box, pat_uniq, pat_lit, pat_range};\n-import syntax::ast::{pat_rec, pat_tup, pat_wild, stmt_decl};\n-import syntax::ast::{ty, ty_bool, ty_char, ty_f, ty_f32, ty_f64};\n-import syntax::ast::{ty_float, ty_i, ty_i16, ty_i32, ty_i64, ty_i8, ty_int};\n-import syntax::ast::{ty_param, ty_path, ty_str, ty_u, ty_u16, ty_u32, ty_u64};\n-import syntax::ast::{ty_u8, ty_uint, variant, view_item, view_item_export};\n-import syntax::ast::{view_item_import, view_item_use, view_path_glob};\n-import syntax::ast::{view_path_list, view_path_simple};\n-import syntax::ast::{required, provided};\n+import syntax::ast::{item_mod, item_trait, item_ty, le, local, local_crate};\n+import syntax::ast::{lt, method, mul, ne, neg, node_id, pat, pat_enum};\n+import syntax::ast::{pat_ident, path, prim_ty, pat_box, pat_uniq, pat_lit};\n+import syntax::ast::{pat_range, pat_rec, pat_tup, pat_wild, provided};\n+import syntax::ast::{required, rem, shl, stmt_decl, subtract, ty, ty_bool};\n+import syntax::ast::{ty_char, ty_f, ty_f32, ty_f64, ty_float, ty_i, ty_i16};\n+import syntax::ast::{ty_i32, ty_i64, ty_i8, ty_int, ty_param, ty_path};\n+import syntax::ast::{ty_str, ty_u, ty_u16, ty_u32, ty_u64, ty_u8, ty_uint};\n+import syntax::ast::{variant, view_item, view_item_export, view_item_import};\n+import syntax::ast::{view_item_use, view_path_glob, view_path_list};\n+import syntax::ast::{view_path_simple};\n import syntax::ast_util::{def_id_of_def, dummy_sp, local_def, new_def_hash};\n import syntax::ast_util::{walk_pat};\n import syntax::attr::{attr_metas, contains_name};\n@@ -47,8 +52,7 @@ import str::{connect, split_str};\n import vec::pop;\n \n import std::list::{cons, list, nil};\n-import std::map::{hashmap, int_hash};\n-import ASTMap = syntax::ast_map::map;\n+import std::map::{hashmap, int_hash, str_hash};\n import str_eq = str::eq;\n \n // Definition mapping\n@@ -608,7 +612,7 @@ class PrimitiveTypeTable {\n /// The main resolver class.\n class Resolver {\n     let session: session;\n-    let ast_map: ASTMap;\n+    let lang_items: LanguageItems;\n     let crate: @crate;\n \n     let atom_table: @AtomTable;\n@@ -655,9 +659,9 @@ class Resolver {\n     let export_map: ExportMap;\n     let trait_map: TraitMap;\n \n-    new(session: session, ast_map: ASTMap, crate: @crate) {\n+    new(session: session, lang_items: LanguageItems, crate: @crate) {\n         self.session = session;\n-        self.ast_map = ast_map;\n+        self.lang_items = copy lang_items;\n         self.crate = crate;\n \n         self.atom_table = @AtomTable();\n@@ -4312,16 +4316,61 @@ class Resolver {\n \n     fn record_candidate_traits_for_expr_if_necessary(expr: @expr) {\n         alt expr.node {\n-            expr_field(_, ident, _) {\n+            expr_field(_, ident, _) => {\n                 let atom = (*self.atom_table).intern(ident);\n                 let traits = self.search_for_traits_containing_method(atom);\n                 self.trait_map.insert(expr.id, traits);\n             }\n-            _ {\n+            expr_binary(add, _, _) | expr_assign_op(add, _, _) => {\n+                self.add_fixed_trait_for_expr(expr.id,\n+                                              self.lang_items.add_trait);\n+            }\n+            expr_binary(subtract, _, _) | expr_assign_op(subtract, _, _) => {\n+                self.add_fixed_trait_for_expr(expr.id,\n+                                              self.lang_items.sub_trait);\n+            }\n+            expr_binary(mul, _, _) | expr_assign_op(mul, _, _) => {\n+                self.add_fixed_trait_for_expr(expr.id,\n+                                              self.lang_items.mul_trait);\n+            }\n+            expr_binary(div, _, _) | expr_assign_op(div, _, _) => {\n+                self.add_fixed_trait_for_expr(expr.id,\n+                                              self.lang_items.div_trait);\n+            }\n+            expr_binary(rem, _, _) | expr_assign_op(rem, _, _) => {\n+                self.add_fixed_trait_for_expr(expr.id,\n+                                              self.lang_items.modulo_trait);\n+            }\n+            expr_binary(bitxor, _, _) | expr_assign_op(bitxor, _, _) => {\n+                self.add_fixed_trait_for_expr(expr.id,\n+                                              self.lang_items.bitxor_trait);\n+            }\n+            expr_binary(bitand, _, _) | expr_assign_op(bitand, _, _) => {\n+                self.add_fixed_trait_for_expr(expr.id,\n+                                              self.lang_items.bitand_trait);\n+            }\n+            expr_binary(bitor, _, _) | expr_assign_op(bitor, _, _) => {\n+                self.add_fixed_trait_for_expr(expr.id,\n+                                              self.lang_items.bitor_trait);\n+            }\n+            expr_binary(shl, _, _) | expr_assign_op(shl, _, _) => {\n+                self.add_fixed_trait_for_expr(expr.id,\n+                                              self.lang_items.shl_trait);\n+            }\n+            expr_binary(shr, _, _) | expr_assign_op(shr, _, _) => {\n+                self.add_fixed_trait_for_expr(expr.id,\n+                                              self.lang_items.shr_trait);\n+            }\n+            expr_unary(neg, _) => {\n+                self.add_fixed_trait_for_expr(expr.id,\n+                                              self.lang_items.neg_trait);\n+            }\n+            expr_index(*) {\n+                self.add_fixed_trait_for_expr(expr.id,\n+                                              self.lang_items.index_trait);\n+            }\n+            _ => {\n                 // Nothing to do.\n-                //\n-                // XXX: Handle more here... operator overloading, placement\n-                // new, etc.\n             }\n         }\n     }\n@@ -4414,6 +4463,12 @@ class Resolver {\n         }\n     }\n \n+    fn add_fixed_trait_for_expr(expr_id: node_id, +trait_id: option<def_id>) {\n+        let traits = @dvec();\n+        traits.push(trait_id.get());\n+        self.trait_map.insert(expr_id, traits);\n+    }\n+\n     fn record_def(node_id: node_id, def: def) {\n         #debug(\"(recording def) recording %? for %?\", def, node_id);\n         self.def_map.insert(node_id, def);\n@@ -4622,13 +4677,13 @@ class Resolver {\n }\n \n /// Entry point to crate resolution.\n-fn resolve_crate(session: session, ast_map: ASTMap, crate: @crate)\n+fn resolve_crate(session: session, lang_items: LanguageItems, crate: @crate)\n               -> { def_map: DefMap,\n                    exp_map: ExportMap,\n                    impl_map: ImplMap,\n                    trait_map: TraitMap } {\n \n-    let resolver = @Resolver(session, ast_map, crate);\n+    let resolver = @Resolver(session, lang_items, crate);\n     (*resolver).resolve(resolver);\n     ret {\n         def_map: resolver.def_map,"}, {"sha": "891bbca5d19a683663c92debc5fe04c80843f50f", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=93c2f5e0e43532a2288ed6dec378564264d1a77c", "patch": "@@ -1472,6 +1472,30 @@ impl operators for kind {\n     }\n }\n \n+impl operators of ops::bitand<kind,kind> for kind {\n+    pure fn bitand(other: kind) -> kind {\n+        unchecked {\n+            lower_kind(self, other)\n+        }\n+    }\n+}\n+\n+impl operators of ops::bitor<kind,kind> for kind {\n+    pure fn bitor(other: kind) -> kind {\n+        unchecked {\n+            raise_kind(self, other)\n+        }\n+    }\n+}\n+\n+impl operators of ops::sub<kind,kind> for kind {\n+    pure fn sub(other: kind) -> kind {\n+        unchecked {\n+            kind_(*self & !*other)\n+        }\n+    }\n+}\n+\n // Using these query functions is preferable to direct comparison or matching\n // against the kind constants, as we may modify the kind hierarchy in the\n // future."}, {"sha": "d472991d85fd63e8a9a374716c650f65537764c6", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=93c2f5e0e43532a2288ed6dec378564264d1a77c", "patch": "@@ -961,14 +961,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         ret if_bot;\n     }\n \n-    fn binop_method(op: ast::binop) -> option<~str> {\n-        alt op {\n-          ast::add | ast::subtract | ast::mul | ast::div | ast::rem |\n-          ast::bitxor | ast::bitand | ast::bitor | ast::shl | ast::shr\n-          { some(ast_util::binop_to_str(op)) }\n-          _ { none }\n-        }\n-    }\n     fn lookup_op_method(fcx: @fn_ctxt, op_ex: @ast::expr,\n                         self_ex: @ast::expr, self_t: ty::t,\n                         opname: ~str, args: ~[@ast::expr])\n@@ -1041,7 +1033,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                         lhs_expr: @ast::expr, lhs_resolved_t: ty::t,\n                         op: ast::binop, rhs: @ast::expr) -> (ty::t, bool) {\n         let tcx = fcx.ccx.tcx;\n-        alt binop_method(op) {\n+        alt ast_util::binop_to_method_name(op) {\n           some(name) {\n             alt lookup_op_method(fcx, ex,\n                                  lhs_expr, lhs_resolved_t,\n@@ -1365,15 +1357,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             oprnd_t = structurally_resolved_type(fcx, oprnd.span, oprnd_t);\n             if !(ty::type_is_integral(oprnd_t) ||\n                  ty::get(oprnd_t).struct == ty::ty_bool) {\n-                oprnd_t = check_user_unop(fcx, ~\"!\", ~\"!\", expr,\n+                oprnd_t = check_user_unop(fcx, ~\"!\", ~\"not\", expr,\n                                          oprnd, oprnd_t);\n             }\n           }\n           ast::neg {\n             oprnd_t = structurally_resolved_type(fcx, oprnd.span, oprnd_t);\n             if !(ty::type_is_integral(oprnd_t) ||\n                  ty::type_is_fp(oprnd_t)) {\n-                oprnd_t = check_user_unop(fcx, ~\"-\", ~\"unary-\", expr,\n+                oprnd_t = check_user_unop(fcx, ~\"-\", ~\"neg\", expr,\n                                          oprnd, oprnd_t);\n             }\n           }\n@@ -1831,7 +1823,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           none {\n             let resolved = structurally_resolved_type(fcx, expr.span,\n                                                       raw_base_t);\n-            alt lookup_op_method(fcx, expr, base, resolved, ~\"[]\",\n+            alt lookup_op_method(fcx, expr, base, resolved, ~\"index\",\n                                  ~[idx]) {\n               some((ret_ty, _)) { fcx.write_ty(id, ret_ty); }\n               _ {"}, {"sha": "a9ecf5e092e1039f33754ff6f9807025b58cc978", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=93c2f5e0e43532a2288ed6dec378564264d1a77c", "patch": "@@ -447,8 +447,7 @@ class lookup {\n         // Add trait methods.\n         alt self.fcx.ccx.trait_map.find(self.expr.id) {\n             none {\n-                // XXX: This particular operation is not yet trait-ified;\n-                // leave it alone for now.\n+                // Should only happen for placement new right now.\n             }\n             some(trait_ids) {\n                 for (*trait_ids).each |trait_id| {"}, {"sha": "8a3a9371adb1e1136ead29d5b7948525b514b08a", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=93c2f5e0e43532a2288ed6dec378564264d1a77c", "patch": "@@ -16,32 +16,39 @@ use std;\n import io::writer_util;\n import std::map::hashmap;\n \n-type cmplx = {re: f64, im: f64};\n-type line = {i: uint, b: ~[u8]};\n-\n-trait times_and_plus {\n-    fn *(x: cmplx) -> cmplx;\n-    fn +(x: cmplx) -> cmplx;\n+struct cmplx {\n+    re: f64;\n+    im: f64;\n }\n \n-impl arith of times_and_plus for cmplx {\n-    fn *(x: cmplx) -> cmplx {\n-        {re: self.re*x.re - self.im*x.im, im: self.re*x.im + self.im*x.re}\n+impl cmplx : ops::mul<cmplx,cmplx> {\n+    pure fn mul(x: cmplx) -> cmplx {\n+        cmplx {\n+            re: self.re*x.re - self.im*x.im,\n+            im: self.re*x.im + self.im*x.re\n+        }\n     }\n+}\n \n-    fn +(x: cmplx) -> cmplx {\n-        {re: self.re + x.re, im: self.im + x.im}\n+impl cmplx : ops::add<cmplx,cmplx> {\n+    pure fn add(x: cmplx) -> cmplx {\n+        cmplx {\n+            re: self.re + x.re,\n+            im: self.im + x.im\n+        }\n     }\n }\n \n+type line = {i: uint, b: ~[u8]};\n+\n pure fn cabs(x: cmplx) -> f64\n {\n     x.re*x.re + x.im*x.im\n }\n \n fn mb(x: cmplx) -> bool\n {\n-    let mut z = {re: 0f64, im: 0f64};\n+    let mut z = cmplx {re: 0f64, im: 0f64};\n     let mut i = 0;\n     let mut in = true;\n     while i < 50 {\n@@ -59,7 +66,7 @@ fn fillbyte(x: cmplx, incr: f64) -> u8 {\n     let mut rv = 0_u8;\n     let mut i = 0_u8;\n     while i < 8_u8 {\n-        let z = {re: x.re + (i as f64)*incr, im: x.im};\n+        let z = cmplx {re: x.re + (i as f64)*incr, im: x.im};\n         if mb(z) {\n             rv += 1_u8 << (7_u8 - i);\n         }\n@@ -75,7 +82,7 @@ fn chanmb(i: uint, size: uint, ch: comm::chan<line>) -> ()\n     let y = incr*(i as f64) - 1f64;\n     let xincr = 8f64*incr;\n     for uint::range(0_u, size/8_u) |j| {\n-        let x = {re: xincr*(j as f64) - 1.5f64, im: y};\n+        let x = cmplx {re: xincr*(j as f64) - 1.5f64, im: y};\n         vec::push(crv, fillbyte(x, incr));\n     };\n     comm::send(ch, {i:i, b:crv});"}, {"sha": "00ce2485b68c1def9264b0798760f96b4d723599", "filename": "src/test/compile-fail/borrowck-loan-rcvr-overloaded-op.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs?ref=93c2f5e0e43532a2288ed6dec378564264d1a77c", "patch": "@@ -1,46 +1,51 @@\n-type point = { x: int, y: int };\n+struct Point { \n+    x: int;\n+    y: int;\n+}\n \n-trait add_and_times {\n-    pure fn +(z: int) -> int;\n-    fn *(z: int) -> int;\n+impl Point : ops::add<int,int> {\n+    pure fn add(&&z: int) -> int {\n+        self.x + self.y + z\n+    }\n }\n \n-impl foo of add_and_times for point {\n-    pure fn +(z: int) -> int { self.x + self.y + z }\n-    fn *(z: int) -> int { self.x * self.y * z }\n+impl Point {\n+    fn times(z: int) -> int {\n+        self.x * self.y * z\n+    }\n }\n \n fn a() {\n-    let mut p = {x: 3, y: 4};\n+    let mut p = Point {x: 3, y: 4};\n \n     // ok (we can loan out rcvr)\n     p + 3;\n-    p * 3;\n+    p.times(3);\n }\n \n fn b() {\n-    let mut p = {x: 3, y: 4};\n+    let mut p = Point {x: 3, y: 4};\n \n     // Here I create an outstanding loan and check that we get conflicts:\n \n     &mut p; //~ NOTE prior loan as mutable granted here\n     //~^ NOTE prior loan as mutable granted here\n \n     p + 3; //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n-    p * 3; //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n+    p.times(3); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n }\n \n fn c() {\n     // Here the receiver is in aliased memory and hence we cannot\n     // consider it immutable:\n-    let q = @mut {x: 3, y: 4};\n+    let q = @mut Point {x: 3, y: 4};\n \n     // ...this is ok for pure fns\n     *q + 3;\n \n \n     // ...but not impure fns\n-    *q * 3; //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n+    (*q).times(3); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n     //~^ NOTE impure due to access to impure function\n }\n "}, {"sha": "7ed010476cdac2c980463033c6e6084844c1e470", "filename": "src/test/compile-fail/no-core-attribute.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2e49852873c52b872185a0ae5a8ca941ed2f1/src%2Ftest%2Fcompile-fail%2Fno-core-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2e49852873c52b872185a0ae5a8ca941ed2f1/src%2Ftest%2Fcompile-fail%2Fno-core-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-core-attribute.rs?ref=e6d2e49852873c52b872185a0ae5a8ca941ed2f1", "patch": "@@ -1,6 +0,0 @@\n-// error-pattern:unresolved name: debug\n-#[no_core];\n-\n-fn main() {\n-    log(debug, 0);\n-}\n\\ No newline at end of file"}, {"sha": "c07512e20f50e150e64334c60e9102cc38dbc254", "filename": "src/test/compile-fail/pure-overloaded-op.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2e49852873c52b872185a0ae5a8ca941ed2f1/src%2Ftest%2Fcompile-fail%2Fpure-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2e49852873c52b872185a0ae5a8ca941ed2f1/src%2Ftest%2Fcompile-fail%2Fpure-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpure-overloaded-op.rs?ref=e6d2e49852873c52b872185a0ae5a8ca941ed2f1", "patch": "@@ -1,33 +0,0 @@\n-type point = { x: int, y: int };\n-\n-trait operators {\n-    pure fn +(z: int) -> int;\n-    fn *(z: int) -> int;\n-    fn [](z: int) -> int;\n-    fn unary-() -> int;\n-}\n-\n-impl foo of operators for point {\n-    // expr_binary\n-    pure fn +(z: int) -> int { self.x + self.y + z }\n-    fn *(z: int) -> int { self.x * self.y * z }\n-\n-    // expr_index\n-    fn [](z: int) -> int { self.x * self.y * z }\n-\n-    // expr_unary\n-    fn unary-() -> int { -(self.x * self.y) }\n-}\n-\n-pure fn a(p: point) -> int { p + 3 }\n-\n-pure fn b(p: point) -> int { p * 3 }\n-//~^ ERROR access to impure function prohibited in pure context\n-\n-pure fn c(p: point) -> int { p[3] }\n-//~^ ERROR access to impure function prohibited in pure context\n-\n-pure fn d(p: point) -> int { -p }\n-//~^ ERROR access to impure function prohibited in pure context\n-\n-fn main() {}"}, {"sha": "df7f8cd6cad38a72ebefe24f96a61970870b7058", "filename": "src/test/compile-fail/selftype-astparam.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Ftest%2Fcompile-fail%2Fselftype-astparam.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Ftest%2Fcompile-fail%2Fselftype-astparam.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fselftype-astparam.rs?ref=93c2f5e0e43532a2288ed6dec378564264d1a77c", "patch": "@@ -1,12 +1,12 @@\n iface add {\n-    fn +(++x: self) -> self;\n+    fn plus(++x: self) -> self;\n }\n \n impl of add for int {\n-    fn +(++x: int) -> int { self + x }\n+    fn plus(++x: int) -> int { self + x }\n }\n \n-fn do_add<A:add>(x: A, y: A) -> A { x + y }\n+fn do_add<A:add>(x: A, y: A) -> A { x.plus(y) }\n \n fn main() {\n     let x = 3 as add;"}, {"sha": "a4bd394d529e3e80dcc14ceaab0d26e22d47919b", "filename": "src/test/compile-fail/selftype-ifacetype.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Ftest%2Fcompile-fail%2Fselftype-ifacetype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Ftest%2Fcompile-fail%2Fselftype-ifacetype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fselftype-ifacetype.rs?ref=93c2f5e0e43532a2288ed6dec378564264d1a77c", "patch": "@@ -1,9 +1,9 @@\n iface add {\n-    fn +(x: self) -> self;\n+    fn plus(x: self) -> self;\n }\n \n fn do_add(x: add, y: add) -> add {\n-    x + y //~ ERROR can not call a method that contains a self type through a boxed iface\n+    x.plus(y) //~ ERROR can not call a method that contains a self type through a boxed iface\n }\n \n fn main() {}"}, {"sha": "c3a0dcec7dfdf350207e2ecb0e46efaf60d82617", "filename": "src/test/run-pass/operator-overloading-leaks.rs", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2e49852873c52b872185a0ae5a8ca941ed2f1/src%2Ftest%2Frun-pass%2Foperator-overloading-leaks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2e49852873c52b872185a0ae5a8ca941ed2f1/src%2Ftest%2Frun-pass%2Foperator-overloading-leaks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-overloading-leaks.rs?ref=e6d2e49852873c52b872185a0ae5a8ca941ed2f1", "patch": "@@ -1,91 +0,0 @@\n-// The cases commented as \"Leaks\" need to not leak. Issue #2581\n-\n-trait minus_and_foo<T> {\n-    fn -(x: &[T]) -> ~[T];\n-    fn foo(x: &[T]) -> ~[T];\n-}\n-\n-impl methods<T: copy> of minus_and_foo<T> for ~[T] {\n-    fn -(x: &[T]) -> ~[T] {\n-        ~[x[0], x[0], x[0]]\n-    }\n-\n-    fn foo(x: &[T]) -> ~[T] {\n-        ~[x[0], x[0], x[0]]\n-    }\n-}\n-\n-trait plus_uniq<T> {\n-    fn +(rhs: ~T) -> ~T;\n-}\n-\n-impl methods<T: copy> of plus_uniq<T> for ~T {\n-    fn +(rhs: ~T) -> ~T {\n-        rhs\n-    }\n-}\n-\n-trait minus {\n-    fn -(rhs: ~int) -> ~int;\n-}\n-\n-impl methods of minus for ~int {\n-    fn -(rhs: ~int) -> ~int {\n-        ~(*self - *rhs)\n-    }\n-}\n-\n-trait plus_boxed {\n-    fn +(rhs: @int) -> @int;\n-}\n-\n-impl methods of plus_boxed for @int {\n-    fn +(rhs: @int) -> @int {\n-        @(*self + *rhs)\n-    }\n-}\n-\n-fn main() {\n-    // leaks\n-    let mut bar = ~[1, 2, 3];\n-    bar -= ~[3, 2, 1];\n-    bar -= ~[4, 5, 6];\n-    \n-    io::println(#fmt(\"%?\", bar));\n-\n-    // okay\n-    let mut bar = ~[1, 2, 3];\n-    bar = bar.foo(~[3, 2, 1]);\n-    bar = bar.foo(~[4, 5, 6]);\n-\n-    io::println(#fmt(\"%?\", bar));\n-\n-    // okay\n-    let mut bar = ~[1, 2, 3];\n-    bar = bar - ~[3, 2, 1];\n-    bar = bar - ~[4, 5, 6];\n-\n-    io::println(#fmt(\"%?\", bar));\n-\n-    // Leaks\n-    let mut bar = ~1;\n-    bar += ~2;\n-    bar += ~3;\n-    \n-    io:: println(#fmt(\"%?\", bar));\n-\n-    // Leaks\n-    let mut bar = ~1;\n-    bar -= ~2;\n-    bar -= ~3;\n-    \n-    io:: println(#fmt(\"%?\", bar));\n-\n-    // Leaks\n-    let mut bar = @1;\n-    bar += @2;\n-    bar += @3;\n-    \n-    io:: println(#fmt(\"%?\", bar));\n-\n-}"}, {"sha": "1404ee54331dda35145a2733a532c70987731ae3", "filename": "src/test/run-pass/operator-overloading.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2f5e0e43532a2288ed6dec378564264d1a77c/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-overloading.rs?ref=93c2f5e0e43532a2288ed6dec378564264d1a77c", "patch": "@@ -1,33 +1,38 @@\n-type point = {x: int, y: int};\n-\n-trait ops {\n-    fn +(other: point) -> point;\n-    fn -(other: point) -> point;\n-    fn unary-() -> point;\n-    fn [](x: bool) -> int;\n+struct Point {\n+    x: int;\n+    y: int;\n }\n \n-impl point_ops of ops for point {\n-    fn +(other: point) -> point {\n-        {x: self.x + other.x, y: self.y + other.y}\n+impl Point : ops::add<Point,Point> {\n+    pure fn add(other: Point) -> Point {\n+        Point {x: self.x + other.x, y: self.y + other.y}\n     }\n-    fn -(other: point) -> point {\n-        {x: self.x - other.x, y: self.y - other.y}\n+}\n+\n+impl Point : ops::sub<Point,Point> {\n+    pure fn sub(other: Point) -> Point {\n+        Point {x: self.x - other.x, y: self.y - other.y}\n     }\n-    fn unary-() -> point {\n-        {x: -self.x, y: -self.y}\n+}\n+\n+impl Point : ops::neg<Point> {\n+    pure fn neg() -> Point {\n+        Point {x: -self.x, y: -self.y}\n     }\n-    fn [](x: bool) -> int {\n+}\n+\n+impl Point : ops::index<bool,int> {\n+    pure fn index(&&x: bool) -> int {\n         if x { self.x } else { self.y }\n     }\n }\n \n fn main() {\n-    let mut p = {x: 10, y: 20};\n-    p += {x: 101, y: 102};\n-    p -= {x: 100, y: 100};\n-    assert p + {x: 5, y: 5} == {x: 16, y: 27};\n-    assert -p == {x: -11, y: -22};\n+    let mut p = Point {x: 10, y: 20};\n+    p += Point {x: 101, y: 102};\n+    p -= Point {x: 100, y: 100};\n+    assert p + Point {x: 5, y: 5} == Point {x: 16, y: 27};\n+    assert -p == Point {x: -11, y: -22};\n     assert p[true] == 11;\n     assert p[false] == 22;\n     // Issue #1733"}, {"sha": "64aae3d15441dd57dd8a69ad38460265031eadc2", "filename": "src/test/run-pass/selftype-add-ints.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e6d2e49852873c52b872185a0ae5a8ca941ed2f1/src%2Ftest%2Frun-pass%2Fselftype-add-ints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d2e49852873c52b872185a0ae5a8ca941ed2f1/src%2Ftest%2Frun-pass%2Fselftype-add-ints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fselftype-add-ints.rs?ref=e6d2e49852873c52b872185a0ae5a8ca941ed2f1", "patch": "@@ -1,19 +0,0 @@\n-iface add {\n-    fn +(++x: self) -> self;\n-}\n-\n-impl of add for int {\n-    fn +(x: int) -> int { self + x }\n-}\n-\n-impl of add for @const int {\n-    fn +(x: @const int) -> @const int { @(*self + *x) }\n-}\n-\n-fn do_add<A:add>(+x: A, +y: A) -> A { x + y }\n-\n-fn main() {\n-    assert do_add(3, 4) == 7;\n-    assert do_add(@3, @4) == @7;\n-    assert do_add(@mut 3, @mut 4) == @mut 7;\n-}"}]}