{"sha": "afee62e476f10a26bcc5986ff26bdf6f38bc768f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmZWU2MmU0NzZmMTBhMjZiY2M1OTg2ZmYyNmJkZjZmMzhiYzc2OGY=", "commit": {"author": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-09-27T10:00:57Z"}, "committer": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-09-27T10:00:57Z"}, "message": "Merge pull request #370 from marcusklaas/match-arm-delining\n\nImprove heuristics for match arm body placement", "tree": {"sha": "c359c295ed15b6f5b4d611fe6330ed6da9c05b3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c359c295ed15b6f5b4d611fe6330ed6da9c05b3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afee62e476f10a26bcc5986ff26bdf6f38bc768f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afee62e476f10a26bcc5986ff26bdf6f38bc768f", "html_url": "https://github.com/rust-lang/rust/commit/afee62e476f10a26bcc5986ff26bdf6f38bc768f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afee62e476f10a26bcc5986ff26bdf6f38bc768f/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dad46265170d76ab2800b43c6bfd44dfbc4d2b6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/dad46265170d76ab2800b43c6bfd44dfbc4d2b6d", "html_url": "https://github.com/rust-lang/rust/commit/dad46265170d76ab2800b43c6bfd44dfbc4d2b6d"}, {"sha": "2eb67827a7a34c9bb221710763f6d16fb4555a24", "url": "https://api.github.com/repos/rust-lang/rust/commits/2eb67827a7a34c9bb221710763f6d16fb4555a24", "html_url": "https://github.com/rust-lang/rust/commit/2eb67827a7a34c9bb221710763f6d16fb4555a24"}], "stats": {"total": 696, "additions": 418, "deletions": 278}, "files": [{"sha": "4076298cec8fb324650af1aef87aecdc4f4a9aab", "filename": "src/expr.rs", "status": "modified", "additions": 56, "deletions": 31, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/afee62e476f10a26bcc5986ff26bdf6f38bc768f/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afee62e476f10a26bcc5986ff26bdf6f38bc768f/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=afee62e476f10a26bcc5986ff26bdf6f38bc768f", "patch": "@@ -15,7 +15,7 @@ use Indent;\n use rewrite::{Rewrite, RewriteContext};\n use lists::{write_list, itemize_list, ListFormatting, SeparatorTactic, ListTactic};\n use string::{StringFormat, rewrite_string};\n-use utils::{span_after, extra_offset, first_line_width, last_line_width, wrap_str, binary_search};\n+use utils::{span_after, extra_offset, last_line_width, wrap_str, binary_search};\n use visitor::FmtVisitor;\n use config::{StructLitStyle, MultilineStyle};\n use comment::{FindUncommented, rewrite_comment, contains_comment};\n@@ -155,11 +155,14 @@ impl Rewrite for ast::Expr {\n                 rewrite_chain(self, context, width, offset)\n             }\n             ast::Expr_::ExprMac(ref mac) => {\n-                // Failure to rewrite a marco should not imply failure to rewrite the Expr\n-                rewrite_macro(mac, context, width, offset).or(wrap_str(context.snippet(self.span),\n-                                                                       context.config.max_width,\n-                                                                       width,\n-                                                                       offset))\n+                // Failure to rewrite a marco should not imply failure to\n+                // rewrite the expression.\n+                rewrite_macro(mac, context, width, offset).or_else(|| {\n+                    wrap_str(context.snippet(self.span),\n+                             context.config.max_width,\n+                             width,\n+                             offset)\n+                })\n             }\n             ast::Expr_::ExprRet(None) => {\n                 wrap_str(\"return\".to_owned(),\n@@ -168,10 +171,10 @@ impl Rewrite for ast::Expr {\n                          offset)\n             }\n             ast::Expr_::ExprRet(Some(ref expr)) => {\n-                rewrite_unary_prefix(context, \"return \", &expr, width, offset)\n+                rewrite_unary_prefix(context, \"return \", expr, width, offset)\n             }\n             ast::Expr_::ExprBox(ref expr) => {\n-                rewrite_unary_prefix(context, \"box \", &expr, width, offset)\n+                rewrite_unary_prefix(context, \"box \", expr, width, offset)\n             }\n             ast::Expr_::ExprAddrOf(mutability, ref expr) => {\n                 rewrite_expr_addrof(context, mutability, &expr, width, offset)\n@@ -352,9 +355,9 @@ fn rewrite_closure(capture: ast::CaptureClause,\n     Some(format!(\"{} {}\", prefix, try_opt!(body_rewrite)))\n }\n \n-fn nop_block_collapse(block_str: Option<String>) -> Option<String> {\n+fn nop_block_collapse(block_str: Option<String>, budget: usize) -> Option<String> {\n     block_str.map(|block_str| {\n-        if block_str.starts_with(\"{\") &&\n+        if block_str.starts_with(\"{\") && budget >= 2 &&\n            (block_str[1..].find(|c: char| !c.is_whitespace()).unwrap() == block_str.len() - 2) {\n             \"{}\".to_owned()\n         } else {\n@@ -872,15 +875,10 @@ impl Rewrite for ast::Arm {\n         let pats_str = format!(\"{}{}\", pats_str, guard_str);\n         // Where the next text can start.\n         let mut line_start = last_line_width(&pats_str);\n-        if pats_str.find('\\n').is_none() {\n+        if !pats_str.contains('\\n') {\n             line_start += offset.width();\n         }\n \n-        let mut line_indent = offset + pats_width;\n-        if vertical {\n-            line_indent = line_indent.block_indent(context.config);\n-        }\n-\n         let comma = if let ast::ExprBlock(_) = body.node {\n             \"\"\n         } else {\n@@ -889,39 +887,66 @@ impl Rewrite for ast::Arm {\n \n         // Let's try and get the arm body on the same line as the condition.\n         // 4 = ` => `.len()\n-        if context.config.max_width > line_start + comma.len() + 4 {\n+        let same_line_body = if context.config.max_width > line_start + comma.len() + 4 {\n             let budget = context.config.max_width - line_start - comma.len() - 4;\n-            if let Some(ref body_str) = nop_block_collapse(body.rewrite(context,\n-                                                                        budget,\n-                                                                        line_indent + 4)) {\n-                if first_line_width(body_str) <= budget {\n+            let offset = Indent::new(offset.block_indent,\n+                                     line_start + 4 - offset.block_indent);\n+            let rewrite = nop_block_collapse(body.rewrite(context, budget, offset), budget);\n+\n+            match rewrite {\n+                Some(ref body_str) if body_str.len() <= budget || comma.is_empty() =>\n                     return Some(format!(\"{}{} => {}{}\",\n                                         attr_str.trim_left(),\n                                         pats_str,\n                                         body_str,\n-                                        comma));\n-                }\n+                                        comma)),\n+                _ => rewrite,\n             }\n-        }\n+        } else {\n+            None\n+        };\n \n-        // We have to push the body to the next line.\n-        if comma.is_empty() {\n+        if let ast::ExprBlock(_) = body.node {\n             // We're trying to fit a block in, but it still failed, give up.\n             return None;\n         }\n \n         let body_budget = try_opt!(width.checked_sub(context.config.tab_spaces));\n-        let body_str = try_opt!(nop_block_collapse(body.rewrite(context,\n-                                                                body_budget,\n-                                                                context.block_indent)));\n-        Some(format!(\"{}{} =>\\n{}{},\",\n+        let next_line_body = nop_block_collapse(body.rewrite(context,\n+                                                             body_budget,\n+                                                             context.block_indent\n+                                                                    .block_indent(context.config)),\n+                                                body_budget);\n+\n+        let body_str = try_opt!(match_arm_heuristic(same_line_body.as_ref().map(|x| &x[..]),\n+                                                    next_line_body.as_ref().map(|x| &x[..])));\n+\n+        let spacer = match same_line_body {\n+            Some(ref body) if body == body_str => \" \".to_owned(),\n+            _ => format!(\"\\n{}\",\n+                         offset.block_indent(context.config).to_string(context.config)),\n+        };\n+\n+        Some(format!(\"{}{} =>{}{},\",\n                      attr_str.trim_left(),\n                      pats_str,\n-                     offset.block_indent(context.config).to_string(context.config),\n+                     spacer,\n                      body_str))\n     }\n }\n \n+// Takes two possible rewrites for the match arm body and chooses the \"nicest\".\n+fn match_arm_heuristic<'a>(former: Option<&'a str>, latter: Option<&'a str>) -> Option<&'a str> {\n+    match (former, latter) {\n+        (f @ Some(..), None) => f,\n+        (Some(f), Some(l)) if f.chars().filter(|&c| c == '\\n').count() <=\n+                              l.chars().filter(|&c| c == '\\n').count() => {\n+            Some(f)\n+        }\n+        (_, l) => l,\n+    }\n+}\n+\n // The `if ...` guard on a match arm.\n fn rewrite_guard(context: &RewriteContext,\n                  guard: &Option<ptr::P<ast::Expr>>,"}, {"sha": "ec79040f59cae02d4221baf3d29c58f14b33e5be", "filename": "src/items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afee62e476f10a26bcc5986ff26bdf6f38bc768f/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afee62e476f10a26bcc5986ff26bdf6f38bc768f/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=afee62e476f10a26bcc5986ff26bdf6f38bc768f", "patch": "@@ -969,8 +969,8 @@ impl<'a> FmtVisitor<'a> {\n \n         let extra_indent = match self.config.where_indent {\n             BlockIndentStyle::Inherit => Indent::empty(),\n-            BlockIndentStyle::Tabbed | BlockIndentStyle::Visual => Indent::new(config.tab_spaces,\n-                                                                               0),\n+            BlockIndentStyle::Tabbed | BlockIndentStyle::Visual =>\n+                Indent::new(config.tab_spaces, 0),\n         };\n \n         let context = self.get_context();"}, {"sha": "fdf08c001a3f568286abd8473a60d327bd1d244c", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afee62e476f10a26bcc5986ff26bdf6f38bc768f/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afee62e476f10a26bcc5986ff26bdf6f38bc768f/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=afee62e476f10a26bcc5986ff26bdf6f38bc768f", "patch": "@@ -85,9 +85,9 @@ const SKIP_ANNOTATION: &'static str = \"rustfmt_skip\";\n pub struct Indent {\n     // Width of the block indent, in characters. Must be a multiple of\n     // Config::tab_spaces.\n-    block_indent: usize,\n+    pub block_indent: usize,\n     // Alignment in characters.\n-    alignment: usize,\n+    pub alignment: usize,\n }\n \n impl Indent {"}, {"sha": "96ad42cd77df276ef9c78bde6160f79a1e774c57", "filename": "tests/source/expr.rs", "status": "modified", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/afee62e476f10a26bcc5986ff26bdf6f38bc768f/tests%2Fsource%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afee62e476f10a26bcc5986ff26bdf6f38bc768f/tests%2Fsource%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fexpr.rs?ref=afee62e476f10a26bcc5986ff26bdf6f38bc768f", "patch": "@@ -130,125 +130,6 @@ fn issue184(source: &str) {\n     }\n }\n \n-fn matches() {\n-    match 1 {\n-        1 => 1, // foo\n-        2 => 2,\n-        // bar\n-        3 => 3,\n-        _ => 0 // baz\n-    }\n-}\n-\n-fn issue339() {\n-    match a {\n-        b => {}\n-        c => { }\n-        d => {\n-        }\n-        e => {\n-\n-\n-\n-        }\n-        // collapsing here is safe\n-        ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff => {\n-        }\n-        // collapsing here exceeds line length\n-        ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffg => {\n-        }\n-        h => { // comment above block\n-        }\n-        i => {\n-        } // comment below block\n-        j => {\n-            // comment inside block\n-        }\n-        j2 => {\n-            // comments inside...\n-        } // ... and after\n-        // TODO uncomment when vertical whitespace is handled better\n-        // k => {\n-        //\n-        //     // comment with WS above\n-        // }\n-        // l => {\n-        //     // comment with ws below\n-        //     \n-        // }\n-        m => {\n-        } n => { } o =>\n-        {\n-\n-        }\n-        p => { // Dont collapse me\n-        } q => { } r =>\n-        {\n-\n-        }\n-        s => 0, // s comment\n-        // t comment\n-        t => 1,\n-        u => 2,\n-        // TODO uncomment when block-support exists\n-        // v => {\n-        // } /* funky block\n-        //    * comment */\n-        // final comment\n-    }\n-}\n-\n-fn issue355() {\n-    match mac {\n-        a => println!(\"a\", b),\n-        b => vec!(1, 2),\n-        c => vec!(3; 4),\n-        d => {\n-            println!(\"a\", b)\n-        }\n-        e => {\n-            vec!(1, 2)\n-        }\n-        f => {\n-            vec!(3; 4)\n-        }\n-        h => println!(\"a\", b), // h comment\n-        i => vec!(1, 2), // i comment\n-        j => vec!(3; 4), // j comment\n-        // k comment\n-        k => println!(\"a\", b),\n-        // l comment\n-        l => vec!(1, 2),\n-        // m comment\n-        m => vec!(3; 4),\n-        // Rewrite splits macro\n-        nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn => println!(\"a\", b),\n-        // Rewrite splits macro\n-        oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo => vec!(1, 2),\n-        // Macro support fails to recognise this macro as splitable\n-        // We push the whole expr to a new line, TODO split this macro as well\n-        pppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp => vec!(3; 4),\n-        // q, r and s: Rewrite splits match arm\n-        qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq => println!(\"a\", b),\n-        rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr => vec!(1, 2),\n-        ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss => vec!(3; 4),\n-        // Funky bracketing styles\n-        t =>      println!{\"a\", b},\n-        u => vec!{1, 2},\n-        v => vec!{3; 4},\n-        w => println![\"a\", b],\n-        x =>      vec![1, 2],\n-        y =>vec![3; 4],\n-        // Brackets with comments\n-        tc => println!{\"a\", b}, // comment\n-        uc => vec!{1, 2}, // comment\n-        vc =>vec!{3; 4}, // comment\n-        wc =>println![\"a\", b], // comment\n-        xc => vec![1,2], // comment\n-        yc =>        vec![3; 4], // comment\n-    }\n-}\n-\n fn arrays() {\n     let x = [0,\n          1,"}, {"sha": "49e66e4c0df32d0be53d4d335037afbed5419443", "filename": "tests/source/match.rs", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/afee62e476f10a26bcc5986ff26bdf6f38bc768f/tests%2Fsource%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afee62e476f10a26bcc5986ff26bdf6f38bc768f/tests%2Fsource%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fmatch.rs?ref=afee62e476f10a26bcc5986ff26bdf6f38bc768f", "patch": "@@ -0,0 +1,223 @@\n+// Match expressions.\n+\n+fn foo() {\n+    // A match expression.\n+    match x {\n+        // Some comment.\n+        a => foo(),\n+        b if 0 < 42 => foo(),\n+        c => { // Another comment.\n+            // Comment.\n+            an_expression;\n+            foo()\n+        }\n+        // Perhaps this should introduce braces?\n+        Foo(ref bar) =>\n+            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+        Pattern1 | Pattern2 | Pattern3 => false,\n+        Paternnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn |\n+        Paternnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn => {\n+            blah\n+        }\n+        Patternnnnnnnnnnnnnnnnnnn |\n+        Patternnnnnnnnnnnnnnnnnnn |\n+        Patternnnnnnnnnnnnnnnnnnn |\n+        Patternnnnnnnnnnnnnnnnnnn => meh,\n+\n+        Patternnnnnnnnnnnnnnnnnnn |\n+        Patternnnnnnnnnnnnnnnnnnn if looooooooooooooooooong_guard => meh,\n+\n+        Patternnnnnnnnnnnnnnnnnnnnnnnnn |\n+        Patternnnnnnnnnnnnnnnnnnnnnnnnn if looooooooooooooooooooooooooooooooooooooooong_guard =>\n+            meh,\n+\n+        // Test that earlier patterns can take the guard space\n+        (aaaa, bbbbb, ccccccc, aaaaa, bbbbbbbb, cccccc, aaaa, bbbbbbbb, cccccc, dddddd) |\n+        Patternnnnnnnnnnnnnnnnnnnnnnnnn if loooooooooooooooooooooooooooooooooooooooooong_guard => {}\n+\n+        _ => {}\n+        ast::PathParameters::AngleBracketedParameters(ref data) if data.lifetimes.len() > 0 ||\n+                                                                   data.types.len() > 0 ||\n+                                                                   data.bindings.len() > 0 => {}\n+    }\n+\n+    let whatever = match something {\n+        /// DOC COMMENT!\n+        Some(_) => 42,\n+        // Comment on an attribute.\n+        #[an_attribute]\n+        // Comment after an attribute.\n+        None => 0,\n+        #[rustfmt_skip]\n+        Blurb     =>     {                  }\n+    };\n+}\n+\n+// Test that a match on an overflow line is laid out properly.\n+fn main() {\n+    let sub_span =\n+        match xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx {\n+            Some(sub_span) => Some(sub_span),\n+            None => sub_span,\n+        };\n+}\n+\n+// Test that one-line bodies align.\n+fn main() {\n+    match r {\n+        Variableeeeeeeeeeeeeeeeee => (    \"variable\",\n+                                      vec!(\"id\", \"name\", \"qualname\",\n+                                           \"value\", \"type\", \"scopeid\"),\n+                                      true,\n+                                      true),\n+        Enummmmmmmmmmmmmmmmmmmmm => (\"enum\",\n+                                     vec!(\"id\",\"qualname\",\"scopeid\",\"value\"),\n+                                     true,\n+                                     true),\n+        Variantttttttttttttttttttttttt => (\"variant\",\n+                                           vec!(\"id\",\n+                                                \"name\",\n+                                                \"qualname\",\n+                                                \"type\",\n+                                                \"value\",\n+                                                \"scopeid\"),\n+                                           true,\n+                                           true),\n+    }\n+}\n+\n+fn matches() {\n+    match 1 {\n+        1 => 1, // foo\n+        2 => 2,\n+        // bar\n+        3 => 3,\n+        _ => 0 // baz\n+    }\n+}\n+\n+fn issue339() {\n+    match a {\n+        b => {}\n+        c => { }\n+        d => {\n+        }\n+        e => {\n+\n+\n+\n+        }\n+        // collapsing here is safe\n+        ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff => {\n+        }\n+        // collapsing here exceeds line length\n+        ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffg => {\n+        }\n+        h => { // comment above block\n+        }\n+        i => {\n+        } // comment below block\n+        j => {\n+            // comment inside block\n+        }\n+        j2 => {\n+            // comments inside...\n+        } // ... and after\n+        // TODO uncomment when vertical whitespace is handled better\n+        // k => {\n+        //\n+        //     // comment with WS above\n+        // }\n+        // l => {\n+        //     // comment with ws below\n+        //     \n+        // }\n+        m => {\n+        } n => { } o =>\n+        {\n+\n+        }\n+        p => { // Dont collapse me\n+        } q => { } r =>\n+        {\n+\n+        }\n+        s => 0, // s comment\n+        // t comment\n+        t => 1,\n+        u => 2,\n+        // TODO uncomment when block-support exists\n+        // v => {\n+        // } /* funky block\n+        //    * comment */\n+        // final comment\n+    }\n+}\n+\n+fn issue355() {\n+    match mac {\n+        a => println!(\"a\", b),\n+        b => vec!(1, 2),\n+        c => vec!(3; 4),\n+        d => {\n+            println!(\"a\", b)\n+        }\n+        e => {\n+            vec!(1, 2)\n+        }\n+        f => {\n+            vec!(3; 4)\n+        }\n+        h => println!(\"a\", b), // h comment\n+        i => vec!(1, 2), // i comment\n+        j => vec!(3; 4), // j comment\n+        // k comment\n+        k => println!(\"a\", b),\n+        // l comment\n+        l => vec!(1, 2),\n+        // m comment\n+        m => vec!(3; 4),\n+        // Rewrite splits macro\n+        nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn => println!(\"a\", b),\n+        // Rewrite splits macro\n+        oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo => vec!(1, 2),\n+        // Macro support fails to recognise this macro as splitable\n+        // We push the whole expr to a new line, TODO split this macro as well\n+        pppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp => vec!(3; 4),\n+        // q, r and s: Rewrite splits match arm\n+        qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq => println!(\"a\", b),\n+        rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr => vec!(1, 2),\n+        ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss => vec!(3; 4),\n+        // Funky bracketing styles\n+        t =>      println!{\"a\", b},\n+        u => vec!{1, 2},\n+        v => vec!{3; 4},\n+        w => println![\"a\", b],\n+        x =>      vec![1, 2],\n+        y =>vec![3; 4],\n+        // Brackets with comments\n+        tc => println!{\"a\", b}, // comment\n+        uc => vec!{1, 2}, // comment\n+        vc =>vec!{3; 4}, // comment\n+        wc =>println![\"a\", b], // comment\n+        xc => vec![1,2], // comment\n+        yc =>        vec![3; 4], // comment\n+        yd =>\n+            looooooooooooooooooooooooooooooooooooooooooooooooooooooooong_func(aaaaaaaaaa,\n+                                                                              bbbbbbbbbb,\n+                                                                              cccccccccc,\n+                                                                              dddddddddd),\n+    }\n+}\n+\n+fn issue280() {\n+    {\n+        match x {\n+            CompressionMode::DiscardNewline | CompressionMode::CompressWhitespaceNewline => ch ==\n+                                                                                            '\\n',\n+            ast::ItemConst(ref typ, ref expr) => self.process_static_or_const_item(item,\n+                                                                                   &typ,\n+                                                                                   &expr),\n+        }\n+    }\n+}"}, {"sha": "f31f27f59d40246ffc1856cb613eb667a138dcfa", "filename": "tests/target/expr.rs", "status": "modified", "additions": 0, "deletions": 115, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/afee62e476f10a26bcc5986ff26bdf6f38bc768f/tests%2Ftarget%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afee62e476f10a26bcc5986ff26bdf6f38bc768f/tests%2Ftarget%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr.rs?ref=afee62e476f10a26bcc5986ff26bdf6f38bc768f", "patch": "@@ -167,121 +167,6 @@ fn issue184(source: &str) {\n     }\n }\n \n-fn matches() {\n-    match 1 {\n-        1 => 1, // foo\n-        2 => 2,\n-        // bar\n-        3 => 3,\n-        _ => 0, // baz\n-    }\n-}\n-\n-fn issue339() {\n-    match a {\n-        b => {}\n-        c => {}\n-        d => {}\n-        e => {}\n-        // collapsing here is safe\n-        ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff => {}\n-        // collapsing here exceeds line length\n-        ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffg => {\n-        }\n-        h => { // comment above block\n-        }\n-        i => {} // comment below block\n-        j => {\n-            // comment inside block\n-        }\n-        j2 => {\n-            // comments inside...\n-        } // ... and after\n-        // TODO uncomment when vertical whitespace is handled better\n-        // k => {\n-        //\n-        //     // comment with WS above\n-        // }\n-        // l => {\n-        //     // comment with ws below\n-        //\n-        // }\n-        m => {}\n-        n => {}\n-        o => {}\n-        p => { // Dont collapse me\n-        }\n-        q => {}\n-        r => {}\n-        s => 0, // s comment\n-        // t comment\n-        t => 1,\n-        u => 2,\n-        // TODO uncomment when block-support exists\n-        // v => {\n-        // } /* funky block\n-        //    * comment */\n-        // final comment\n-    }\n-}\n-\n-fn issue355() {\n-    match mac {\n-        a => println!(\"a\", b),\n-        b => vec!(1, 2),\n-        c => vec!(3; 4),\n-        d => {\n-            println!(\"a\", b)\n-        }\n-        e => {\n-            vec!(1, 2)\n-        }\n-        f => {\n-            vec!(3; 4)\n-        }\n-        h => println!(\"a\", b), // h comment\n-        i => vec!(1, 2), // i comment\n-        j => vec!(3; 4), // j comment\n-        // k comment\n-        k => println!(\"a\", b),\n-        // l comment\n-        l => vec!(1, 2),\n-        // m comment\n-        m => vec!(3; 4),\n-        // Rewrite splits macro\n-        nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn => println!(\"a\",\n-                                                                                             b),\n-        // Rewrite splits macro\n-        oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo => vec!(1,\n-                                                                                               2),\n-        // Macro support fails to recognise this macro as splitable\n-        // We push the whole expr to a new line, TODO split this macro as well\n-        pppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp =>\n-            vec!(3; 4),\n-        // q, r and s: Rewrite splits match arm\n-        qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq =>\n-            println!(\"a\", b),\n-        rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr =>\n-            vec!(1, 2),\n-        ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss =>\n-            vec!(3; 4),\n-        // Funky bracketing styles\n-        t => println!{\"a\", b},\n-        u => vec!{1, 2},\n-        v => vec!{3; 4},\n-        w => println![\"a\", b],\n-        x => vec![1, 2],\n-        y => vec![3; 4],\n-        // Brackets with comments\n-        tc => println!{\"a\", b}, // comment\n-        uc => vec!{1, 2}, // comment\n-        vc => vec!{3; 4}, // comment\n-        wc => println![\"a\", b], // comment\n-        xc => vec![1, 2], // comment\n-        yc => vec![3; 4], // comment\n-    }\n-}\n-\n fn arrays() {\n     let x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 7, 8, 9, 0, 1, 2, 3, 4,\n              5, 6, 7, 8, 9, 0];"}, {"sha": "6e330505a9b8af75dd8adba46ec380034284d4d3", "filename": "tests/target/match.rs", "status": "modified", "additions": 135, "deletions": 9, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/afee62e476f10a26bcc5986ff26bdf6f38bc768f/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afee62e476f10a26bcc5986ff26bdf6f38bc768f/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=afee62e476f10a26bcc5986ff26bdf6f38bc768f", "patch": "@@ -73,14 +73,140 @@ fn main() {\n                                      vec!(\"id\", \"qualname\", \"scopeid\", \"value\"),\n                                      true,\n                                      true),\n-        Variantttttttttttttttttttttttt => (\"variant\",\n-                                           vec!(\"id\",\n-                                                \"name\",\n-                                                \"qualname\",\n-                                                \"type\",\n-                                                \"value\",\n-                                                \"scopeid\"),\n-                                           true,\n-                                           true),\n+        Variantttttttttttttttttttttttt =>\n+            (\"variant\",\n+             vec!(\"id\", \"name\", \"qualname\", \"type\", \"value\", \"scopeid\"),\n+             true,\n+             true),\n+    }\n+}\n+\n+fn matches() {\n+    match 1 {\n+        1 => 1, // foo\n+        2 => 2,\n+        // bar\n+        3 => 3,\n+        _ => 0, // baz\n+    }\n+}\n+\n+fn issue339() {\n+    match a {\n+        b => {}\n+        c => {}\n+        d => {}\n+        e => {}\n+        // collapsing here is safe\n+        ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff => {}\n+        // collapsing here exceeds line length\n+        ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffg => {\n+        }\n+        h => { // comment above block\n+        }\n+        i => {} // comment below block\n+        j => {\n+            // comment inside block\n+        }\n+        j2 => {\n+            // comments inside...\n+        } // ... and after\n+        // TODO uncomment when vertical whitespace is handled better\n+        // k => {\n+        //\n+        //     // comment with WS above\n+        // }\n+        // l => {\n+        //     // comment with ws below\n+        //\n+        // }\n+        m => {}\n+        n => {}\n+        o => {}\n+        p => { // Dont collapse me\n+        }\n+        q => {}\n+        r => {}\n+        s => 0, // s comment\n+        // t comment\n+        t => 1,\n+        u => 2,\n+        // TODO uncomment when block-support exists\n+        // v => {\n+        // } /* funky block\n+        //    * comment */\n+        // final comment\n+    }\n+}\n+\n+fn issue355() {\n+    match mac {\n+        a => println!(\"a\", b),\n+        b => vec!(1, 2),\n+        c => vec!(3; 4),\n+        d => {\n+            println!(\"a\", b)\n+        }\n+        e => {\n+            vec!(1, 2)\n+        }\n+        f => {\n+            vec!(3; 4)\n+        }\n+        h => println!(\"a\", b), // h comment\n+        i => vec!(1, 2), // i comment\n+        j => vec!(3; 4), // j comment\n+        // k comment\n+        k => println!(\"a\", b),\n+        // l comment\n+        l => vec!(1, 2),\n+        // m comment\n+        m => vec!(3; 4),\n+        // Rewrite splits macro\n+        nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn =>\n+            println!(\"a\", b),\n+        // Rewrite splits macro\n+        oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo =>\n+            vec!(1, 2),\n+        // Macro support fails to recognise this macro as splitable\n+        // We push the whole expr to a new line, TODO split this macro as well\n+        pppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp =>\n+            vec!(3; 4),\n+        // q, r and s: Rewrite splits match arm\n+        qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq =>\n+            println!(\"a\", b),\n+        rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr =>\n+            vec!(1, 2),\n+        ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss =>\n+            vec!(3; 4),\n+        // Funky bracketing styles\n+        t => println!{\"a\", b},\n+        u => vec!{1, 2},\n+        v => vec!{3; 4},\n+        w => println![\"a\", b],\n+        x => vec![1, 2],\n+        y => vec![3; 4],\n+        // Brackets with comments\n+        tc => println!{\"a\", b}, // comment\n+        uc => vec!{1, 2}, // comment\n+        vc => vec!{3; 4}, // comment\n+        wc => println![\"a\", b], // comment\n+        xc => vec![1, 2], // comment\n+        yc => vec![3; 4], // comment\n+        yd => looooooooooooooooooooooooooooooooooooooooooooooooooooooooong_func(aaaaaaaaaa,\n+                                                                                bbbbbbbbbb,\n+                                                                                cccccccccc,\n+                                                                                dddddddddd),\n+    }\n+}\n+\n+fn issue280() {\n+    {\n+        match x {\n+            CompressionMode::DiscardNewline | CompressionMode::CompressWhitespaceNewline =>\n+                ch == '\\n',\n+            ast::ItemConst(ref typ, ref expr) =>\n+                self.process_static_or_const_item(item, &typ, &expr),\n+        }\n     }\n }"}]}