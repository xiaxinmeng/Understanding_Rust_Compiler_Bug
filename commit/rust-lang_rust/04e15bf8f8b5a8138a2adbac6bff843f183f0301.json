{"sha": "04e15bf8f8b5a8138a2adbac6bff843f183f0301", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0ZTE1YmY4ZjhiNWE4MTM4YTJhZGJhYzZiZmY4NDNmMTgzZjAzMDE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-13T04:02:49Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-13T04:02:49Z"}, "message": "rustc: Typecheck \"alt\" expressions and patterns", "tree": {"sha": "1f94d2cde96dfce87943c907d91c68f230663837", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f94d2cde96dfce87943c907d91c68f230663837"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04e15bf8f8b5a8138a2adbac6bff843f183f0301", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04e15bf8f8b5a8138a2adbac6bff843f183f0301", "html_url": "https://github.com/rust-lang/rust/commit/04e15bf8f8b5a8138a2adbac6bff843f183f0301", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04e15bf8f8b5a8138a2adbac6bff843f183f0301/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d0734bb96f96644921965abd06f2b7bb32d3bb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d0734bb96f96644921965abd06f2b7bb32d3bb8", "html_url": "https://github.com/rust-lang/rust/commit/7d0734bb96f96644921965abd06f2b7bb32d3bb8"}], "stats": {"total": 175, "additions": 175, "deletions": 0}, "files": [{"sha": "346e40ab20b0ac5c3fc6c2b9e256175ada90fa36", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/04e15bf8f8b5a8138a2adbac6bff843f183f0301/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04e15bf8f8b5a8138a2adbac6bff843f183f0301/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=04e15bf8f8b5a8138a2adbac6bff843f183f0301", "patch": "@@ -759,6 +759,15 @@ fn block_ty(&ast.block b) -> @ty {\n     }\n }\n \n+fn pat_ty(@ast.pat pat) -> @ty {\n+    alt (pat.node) {\n+        case (ast.pat_wild(?ann))           { ret ann_to_type(ann); }\n+        case (ast.pat_bind(_, _, ?ann))     { ret ann_to_type(ann); }\n+        case (ast.pat_tag(_, _, _, ?ann))   { ret ann_to_type(ann); }\n+    }\n+    fail;   // not reached\n+}\n+\n fn expr_ty(@ast.expr expr) -> @ty {\n     alt (expr.node) {\n         case (ast.expr_vec(_, ?ann))          { ret ann_to_type(ann); }\n@@ -772,6 +781,7 @@ fn expr_ty(@ast.expr expr) -> @ty {\n         case (ast.expr_if(_, _, _, ?ann))     { ret ann_to_type(ann); }\n         case (ast.expr_while(_, _, ?ann))     { ret ann_to_type(ann); }\n         case (ast.expr_do_while(_, _, ?ann))  { ret ann_to_type(ann); }\n+        case (ast.expr_alt(_, _, ?ann))       { ret ann_to_type(ann); }\n         case (ast.expr_block(_, ?ann))        { ret ann_to_type(ann); }\n         case (ast.expr_assign(_, _, ?ann))    { ret ann_to_type(ann); }\n         case (ast.expr_assign_op(_, _, _, ?ann))\n@@ -847,6 +857,20 @@ fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n             case (ty_char)       { ret struct_cmp(expected, actual); }\n             case (ty_str)        { ret struct_cmp(expected, actual); }\n \n+            case (ty_tag(?expected_id)) {\n+                alt (actual.struct) {\n+                    case (ty_tag(?actual_id)) {\n+                        if (expected_id._0 == actual_id._0 &&\n+                                expected_id._1 == actual_id._1) {\n+                            ret ures_ok(expected);\n+                        }\n+                    }\n+                    case (_) { /* fall through */ }\n+                }\n+\n+                ret ures_err(terr_mismatch, expected, actual);\n+            }\n+\n             case (ty_box(?expected_sub)) {\n                 alt (actual.struct) {\n                     case (ty_box(?actual_sub)) {\n@@ -1147,6 +1171,64 @@ fn are_compatible(&fn_ctxt fcx, @ty expected, @ty actual) -> bool {\n     }\n }\n \n+// Type unification over typed patterns. Note that the pattern that you pass\n+// to this function must have been passed to check_pat() first.\n+//\n+// TODO: enforce this via a predicate.\n+\n+fn demand_pat(&fn_ctxt fcx, @ty expected, @ast.pat pat) -> @ast.pat {\n+    auto p_1 = ast.pat_wild(ast.ann_none);  // FIXME: typestate botch\n+\n+    alt (pat.node) {\n+        case (ast.pat_wild(?ann)) {\n+            auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n+            p_1 = ast.pat_wild(ast.ann_type(t));\n+        }\n+        case (ast.pat_bind(?id, ?did, ?ann)) {\n+            auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n+            p_1 = ast.pat_bind(id, did, ast.ann_type(t));\n+        }\n+        case (ast.pat_tag(?id, ?subpats, ?vdef_opt, ?ann)) {\n+            auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n+\n+            // The type of the tag isn't enough; we also have to get the type\n+            // of the variant, which is either a tag type in the case of\n+            // nullary variants or a function type in the case of n-ary\n+            // variants.\n+            //\n+            // TODO: When we have type-parametric tags, this will get a little\n+            // trickier. Basically, we have to instantiate the variant type we\n+            // acquire here with the type parameters provided to us by\n+            // \"expected\".\n+\n+            auto vdef = option.get[ast.variant_def](vdef_opt);\n+            auto variant_ty = fcx.ccx.item_types.get(vdef._1);\n+\n+            auto subpats_len = _vec.len[@ast.pat](subpats);\n+            alt (variant_ty.struct) {\n+                case (ty_tag(_)) {\n+                    // Nullary tag variant.\n+                    check (subpats_len == 0u);\n+                    p_1 = ast.pat_tag(id, subpats, vdef_opt, ast.ann_type(t));\n+                }\n+                case (ty_fn(?args, ?tag_ty)) {\n+                    let vec[@ast.pat] new_subpats = vec();\n+                    auto i = 0u;\n+                    for (arg a in args) {\n+                        auto new_subpat = demand_pat(fcx, a.ty, subpats.(i));\n+                        new_subpats += vec(new_subpat);\n+                        i += 1u;\n+                    }\n+                    p_1 = ast.pat_tag(id, new_subpats, vdef_opt,\n+                                      ast.ann_type(tag_ty));\n+                }\n+            }\n+        }\n+    }\n+\n+    ret @fold.respan[ast.pat_](pat.span, p_1);\n+}\n+\n // Type unification over typed expressions. Note that the expression that you\n // pass to this function must have been passed to check_expr() first.\n //\n@@ -1351,6 +1433,68 @@ fn check_lit(@ast.lit lit) -> @ty {\n     ret plain_ty(sty);\n }\n \n+fn check_pat(&fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n+    auto new_pat;\n+    alt (pat.node) {\n+        case (ast.pat_wild(_)) {\n+            new_pat = ast.pat_wild(ast.ann_type(next_ty_var(fcx)));\n+        }\n+        case (ast.pat_bind(?id, ?def_id, _)) {\n+            auto ann = ast.ann_type(next_ty_var(fcx));\n+            new_pat = ast.pat_bind(id, def_id, ann);\n+        }\n+        case (ast.pat_tag(?id, ?subpats, ?vdef_opt, _)) {\n+            auto vdef = option.get[ast.variant_def](vdef_opt);\n+            auto t = fcx.ccx.item_types.get(vdef._1); \n+            alt (t.struct) {\n+                // N-ary variants have function types.\n+                case (ty_fn(?args, ?tag_ty)) {\n+                    auto arg_len = _vec.len[arg](args);\n+                    auto subpats_len = _vec.len[@ast.pat](subpats);\n+                    if (arg_len != subpats_len) {\n+                        // TODO: pluralize properly\n+                        auto err_msg = \"tag type \" + id + \" has \" +\n+                                       _uint.to_str(subpats_len, 10u) +\n+                                       \" fields, but this pattern has \" +\n+                                       _uint.to_str(arg_len, 10u) + \" fields\";\n+\n+                        fcx.ccx.sess.span_err(pat.span, err_msg);\n+                        fail;   // TODO: recover\n+                    }\n+\n+                    let vec[@ast.pat] new_subpats = vec();\n+                    for (@ast.pat subpat in subpats) {\n+                        new_subpats += vec(check_pat(fcx, subpat));\n+                    }\n+\n+                    auto ann = ast.ann_type(tag_ty);\n+                    new_pat = ast.pat_tag(id, new_subpats, vdef_opt, ann);\n+                }\n+\n+                // Nullary variants have tag types.\n+                case (ty_tag(?tid)) {\n+                    auto subpats_len = _vec.len[@ast.pat](subpats);\n+                    if (subpats_len > 0u) {\n+                        // TODO: pluralize properly\n+                        auto err_msg = \"tag type \" + id + \" has no fields,\" +\n+                                       \" but this pattern has \" +\n+                                       _uint.to_str(subpats_len, 10u) +\n+                                       \" fields\";\n+\n+                        fcx.ccx.sess.span_err(pat.span, err_msg);\n+                        fail;   // TODO: recover\n+                    }\n+\n+                    auto ann = ast.ann_type(plain_ty(ty_tag(tid)));\n+                    new_pat = ast.pat_tag(id, subpats, vdef_opt, ann);\n+                }\n+            }\n+        }\n+    }\n+\n+    ret @fold.respan[ast.pat_](pat.span, new_pat);\n+}\n+\n fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n     alt (expr.node) {\n         case (ast.expr_lit(?lit, _)) {\n@@ -1528,6 +1672,37 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                                           ann));\n         }\n \n+        case (ast.expr_alt(?expr, ?arms, _)) {\n+            auto expr_0 = check_expr(fcx, expr);\n+            auto pattern_ty = expr_ty(expr_0);\n+            auto result_ty = next_ty_var(fcx);\n+\n+            let vec[ast.arm] arms_0 = vec();\n+            for (ast.arm arm in arms) {\n+                auto pat_0 = check_pat(fcx, arm.pat);\n+                pattern_ty = demand(fcx, pat_0.span, pattern_ty,\n+                                    pat_ty(pat_0));\n+                auto block_0 = check_block(fcx, arm.block);\n+                result_ty = demand(fcx, block_0.span, result_ty,\n+                                   block_ty(block_0));\n+                arms_0 += vec(rec(pat=pat_0, block=block_0, index=arm.index));\n+            }\n+\n+            auto expr_1 = demand_expr(fcx, pattern_ty, expr);\n+\n+            let vec[ast.arm] arms_1 = vec();\n+            for (ast.arm arm_0 in arms_0) {\n+                auto pat_1 = demand_pat(fcx, pattern_ty, arm_0.pat);\n+                auto block_1 = demand_block(fcx, result_ty, arm_0.block);\n+                auto arm_1 = rec(pat=pat_1, block=block_1, index=arm_0.index);\n+                arms_1 += vec(arm_1);\n+            }\n+\n+            auto ann = ast.ann_type(result_ty);\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_alt(expr_1, arms_1, ann));\n+        }\n+\n         case (ast.expr_call(?f, ?args, _)) {\n             // Check the function.\n             auto f_0 = check_expr(fcx, f);"}]}