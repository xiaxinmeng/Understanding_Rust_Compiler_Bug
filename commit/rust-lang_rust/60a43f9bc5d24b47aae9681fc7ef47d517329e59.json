{"sha": "60a43f9bc5d24b47aae9681fc7ef47d517329e59", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwYTQzZjliYzVkMjRiNDdhYWU5NjgxZmM3ZWY0N2Q1MTczMjllNTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-31T04:21:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-31T04:21:39Z"}, "message": "auto merge of #14534 : alexcrichton/rust/snapshots, r=sfackler\n\nThis is part 2 of the saga of renaming the Partial/Total equality and comparison traits.", "tree": {"sha": "c0e46f35c6d6482996e6b10eaf635201b51e82d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0e46f35c6d6482996e6b10eaf635201b51e82d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60a43f9bc5d24b47aae9681fc7ef47d517329e59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60a43f9bc5d24b47aae9681fc7ef47d517329e59", "html_url": "https://github.com/rust-lang/rust/commit/60a43f9bc5d24b47aae9681fc7ef47d517329e59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60a43f9bc5d24b47aae9681fc7ef47d517329e59/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc4513202d6f9c6896054ebaa1d99230b06e9f10", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc4513202d6f9c6896054ebaa1d99230b06e9f10", "html_url": "https://github.com/rust-lang/rust/commit/cc4513202d6f9c6896054ebaa1d99230b06e9f10"}, {"sha": "bb96ee6123082908dba86cb22344f0c23915bf06", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb96ee6123082908dba86cb22344f0c23915bf06", "html_url": "https://github.com/rust-lang/rust/commit/bb96ee6123082908dba86cb22344f0c23915bf06"}], "stats": {"total": 2960, "additions": 858, "deletions": 2102}, "files": [{"sha": "3df46fde59ae85563a8a77d696f21b529d9879bf", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -12,7 +12,7 @@ use std::from_str::FromStr;\n use std::fmt;\n use regex::Regex;\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub enum Mode {\n     CompileFail,\n     RunFail,"}, {"sha": "ee37cd2126c501c4cb36d991dbec5316d1a47c1a", "filename": "src/doc/rust.md", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -1436,7 +1436,7 @@ trait Circle : Shape { fn radius() -> f64; }\n ~~~~\n \n the syntax `Circle : Shape` means that types that implement `Circle` must also have an implementation for `Shape`.\n-Multiple supertraits are separated by `+`, `trait Circle : Shape + Eq { }`.\n+Multiple supertraits are separated by `+`, `trait Circle : Shape + PartialEq { }`.\n In an implementation of `Circle` for a given type `T`, methods can refer to `Shape` methods,\n since the typechecker checks that any type with an implementation of `Circle` also has an implementation of `Shape`.\n \n@@ -2159,23 +2159,23 @@ There are three different types of inline attributes:\n \n The `deriving` attribute allows certain traits to be automatically\n implemented for data structures. For example, the following will\n-create an `impl` for the `Eq` and `Clone` traits for `Foo`, the type\n-parameter `T` will be given the `Eq` or `Clone` constraints for the\n+create an `impl` for the `PartialEq` and `Clone` traits for `Foo`, the type\n+parameter `T` will be given the `PartialEq` or `Clone` constraints for the\n appropriate `impl`:\n \n ~~~~\n-#[deriving(Eq, Clone)]\n+#[deriving(PartialEq, Clone)]\n struct Foo<T> {\n     a: int,\n     b: T\n }\n ~~~~\n \n-The generated `impl` for `Eq` is equivalent to\n+The generated `impl` for `PartialEq` is equivalent to\n \n ~~~~\n # struct Foo<T> { a: int, b: T }\n-impl<T: Eq> Eq for Foo<T> {\n+impl<T: PartialEq> PartialEq for Foo<T> {\n     fn eq(&self, other: &Foo<T>) -> bool {\n         self.a == other.a && self.b == other.b\n     }\n@@ -2188,7 +2188,7 @@ impl<T: Eq> Eq for Foo<T> {\n \n Supported traits for `deriving` are:\n \n-* Comparison traits: `Eq`, `TotalEq`, `Ord`, `TotalOrd`.\n+* Comparison traits: `PartialEq`, `TotalEq`, `PartialOrd`, `TotalOrd`.\n * Serialization: `Encodable`, `Decodable`. These require `serialize`.\n * `Clone`, to create `T` from `&T` via a copy.\n * `Hash`, to iterate over the bytes in a data type.\n@@ -2734,22 +2734,22 @@ The default meaning of the operators on standard types is given here.\n \n * `==`\n   : Equal to.\n-    Calls the `eq` method on the `std::cmp::Eq` trait.\n+    Calls the `eq` method on the `std::cmp::PartialEq` trait.\n * `!=`\n   : Unequal to.\n-    Calls the `ne` method on the `std::cmp::Eq` trait.\n+    Calls the `ne` method on the `std::cmp::PartialEq` trait.\n * `<`\n   : Less than.\n-    Calls the `lt` method on the `std::cmp::Ord` trait.\n+    Calls the `lt` method on the `std::cmp::PartialOrd` trait.\n * `>`\n   : Greater than.\n-    Calls the `gt` method on the `std::cmp::Ord` trait.\n+    Calls the `gt` method on the `std::cmp::PartialOrd` trait.\n * `<=`\n   : Less than or equal.\n-    Calls the `le` method on the `std::cmp::Ord` trait.\n+    Calls the `le` method on the `std::cmp::PartialOrd` trait.\n * `>=`\n   : Greater than or equal.\n-    Calls the `ge` method on the `std::cmp::Ord` trait.\n+    Calls the `ge` method on the `std::cmp::PartialOrd` trait.\n \n #### Type cast expressions\n "}, {"sha": "a4c89436d50aff3bfa36a715b2341e0e826f3b51", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -61,16 +61,16 @@ There are two ways to install the Rust compiler: by building from source or\n by downloading prebuilt binaries or installers for your platform. The\n [install page][rust-install] contains links to download binaries for both\n the nightly build and the most current Rust major release. For Windows and\n-OS X, the install page provides links to native installers. \n+OS X, the install page provides links to native installers.\n \n > *Note:* Windows users should read the detailed\n > [Getting started][wiki-start] notes on the wiki. Even when using\n > the binary installer, the Windows build requires a MinGW installation,\n > the precise details of which are not discussed here.\n \n For Linux and OS X, the install page provides links to binary tarballs.\n-To install the Rust compiler from the from a binary tarball, download \n-the binary package, extract it, and execute the `install.sh` script in \n+To install the Rust compiler from the from a binary tarball, download\n+the binary package, extract it, and execute the `install.sh` script in\n the root directory of the package.\n \n To build the Rust compiler from source, you will need to obtain the source through\n@@ -1303,15 +1303,15 @@ be specified up-front. Our previous definition of list equality relied on the el\n the `==` operator available, and took advantage of the lack of a destructor on `u32` to copy it\n without a move of ownership.\n \n-We can add a *trait bound* on the `Eq` trait to require that the type implement the `==` operator.\n+We can add a *trait bound* on the `PartialEq` trait to require that the type implement the `==` operator.\n Two more `ref` annotations need to be added to avoid attempting to move out the element types:\n \n ~~~\n # enum List<T> {\n #     Cons(T, Box<List<T>>),\n #     Nil\n # }\n-fn eq<T: Eq>(xs: &List<T>, ys: &List<T>) -> bool {\n+fn eq<T: PartialEq>(xs: &List<T>, ys: &List<T>) -> bool {\n     // Match on the next node in both lists.\n     match (xs, ys) {\n         // If we have reached the end of both lists, they are equal.\n@@ -1329,8 +1329,8 @@ let ys = Cons('c', box Cons('a', box Cons('t', box Nil)));\n assert!(eq(&xs, &ys));\n ~~~\n \n-This would be a good opportunity to implement the `Eq` trait for our list type, making the `==` and\n-`!=` operators available. We'll need to provide an `impl` for the `Eq` trait and a definition of the\n+This would be a good opportunity to implement the `PartialEq` trait for our list type, making the `==` and\n+`!=` operators available. We'll need to provide an `impl` for the `PartialEq` trait and a definition of the\n `eq` method. In a method, the `self` parameter refers to an instance of the type we're implementing\n on.\n \n@@ -1339,7 +1339,7 @@ on.\n #     Cons(T, Box<List<T>>),\n #     Nil\n # }\n-impl<T: Eq> Eq for List<T> {\n+impl<T: PartialEq> PartialEq for List<T> {\n     fn eq(&self, ys: &List<T>) -> bool {\n         // Match on the next node in both lists.\n         match (self, ys) {\n@@ -1356,12 +1356,12 @@ impl<T: Eq> Eq for List<T> {\n \n let xs = Cons(5, box Cons(10, box Nil));\n let ys = Cons(5, box Cons(10, box Nil));\n-// The methods below are part of the Eq trait,\n+// The methods below are part of the PartialEq trait,\n // which we implemented on our linked list.\n assert!(xs.eq(&ys));\n assert!(!xs.ne(&ys));\n \n-// The Eq trait also allows us to use the shorthand infix operators.\n+// The PartialEq trait also allows us to use the shorthand infix operators.\n assert!(xs == ys);    // `xs == ys` is short for `xs.eq(&ys)`\n assert!(!(xs != ys)); // `xs != ys` is short for `xs.ne(&ys)`\n ~~~\n@@ -2345,12 +2345,12 @@ trait describes types that support an equality operation:\n ~~~~\n // In a trait, `self` refers to the self argument.\n // `Self` refers to the type implementing the trait.\n-trait Eq {\n+trait PartialEq {\n     fn equals(&self, other: &Self) -> bool;\n }\n \n // In an impl, `self` refers just to the value of the receiver\n-impl Eq for int {\n+impl PartialEq for int {\n     fn equals(&self, other: &int) -> bool { *other == *self }\n }\n ~~~~\n@@ -2600,13 +2600,13 @@ A small number of traits in `std` and `extra` can have implementations\n that can be automatically derived. These instances are specified by\n placing the `deriving` attribute on a data type declaration. For\n example, the following will mean that `Circle` has an implementation\n-for `Eq` and can be used with the equality operators, and that a value\n+for `PartialEq` and can be used with the equality operators, and that a value\n of type `ABC` can be randomly generated and converted to a string:\n \n ~~~\n extern crate rand;\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n struct Circle { radius: f64 }\n \n #[deriving(Rand, Show)]\n@@ -2618,7 +2618,7 @@ fn main() {\n }\n ~~~\n \n-The full list of derivable traits is `Eq`, `TotalEq`, `Ord`,\n+The full list of derivable traits is `PartialEq`, `TotalEq`, `Ord`,\n `TotalOrd`, `Encodable`, `Decodable`, `Clone`,\n `Hash`, `Rand`, `Default`, `Zero`, `FromPrimitive` and `Show`.\n "}, {"sha": "7e6bfcdd4ec64e9e09926c971aecd0a17bd729e6", "filename": "src/etc/generate-deriving-span-tests.py", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Fetc%2Fgenerate-deriving-span-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Fetc%2Fgenerate-deriving-span-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-deriving-span-tests.py?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -35,7 +35,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;\n@@ -117,8 +117,10 @@ def write_file(name, string):\n \n for (trait, supers, errs) in [('Rand', [], 1),\n                               ('Clone', [], 1),\n-                              ('Eq', [], 2), ('Ord', [], 8),\n-                              ('TotalEq', [], 1), ('TotalOrd', ['TotalEq'], 1),\n+                              ('PartialEq', [], 2),\n+                              ('PartialOrd', ['PartialEq'], 8),\n+                              ('TotalEq', ['PartialEq'], 1),\n+                              ('TotalOrd', ['TotalEq', 'PartialOrd', 'PartialEq'], 1),\n                               ('Show', [], 1),\n                               ('Hash', [], 1)]:\n     traits[trait] = (ALL, supers, errs)"}, {"sha": "ba3180cefd665fc68dfb92155c84944f8ffb18ef", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -133,14 +133,7 @@ unsafe fn exchange_malloc(size: uint, align: uint) -> *mut u8 {\n     }\n }\n \n-#[cfg(not(test), stage0)]\n-#[lang=\"exchange_free\"]\n-#[inline]\n-unsafe fn exchange_free(ptr: *mut u8) {\n-    deallocate(ptr, 0, 8);\n-}\n-\n-#[cfg(not(test), not(stage0))]\n+#[cfg(not(test))]\n #[lang=\"exchange_free\"]\n #[inline]\n unsafe fn exchange_free(ptr: *mut u8, size: uint, align: uint) {"}, {"sha": "61fff41374bfb462ca40541d8eb53967ca07b588", "filename": "src/liballoc/owned.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Fliballoc%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Fliballoc%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fowned.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -12,7 +12,7 @@\n \n use core::any::{Any, AnyRefExt};\n use core::clone::Clone;\n-use core::cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering};\n+use core::cmp::{PartialEq, PartialOrd, TotalEq, TotalOrd, Ordering};\n use core::default::Default;\n use core::fmt;\n use core::intrinsics;\n@@ -51,13 +51,13 @@ impl<T: Clone> Clone for Box<T> {\n }\n \n // box pointers\n-impl<T:Eq> Eq for Box<T> {\n+impl<T:PartialEq> PartialEq for Box<T> {\n     #[inline]\n     fn eq(&self, other: &Box<T>) -> bool { *(*self) == *(*other) }\n     #[inline]\n     fn ne(&self, other: &Box<T>) -> bool { *(*self) != *(*other) }\n }\n-impl<T:Ord> Ord for Box<T> {\n+impl<T:PartialOrd> PartialOrd for Box<T> {\n     #[inline]\n     fn lt(&self, other: &Box<T>) -> bool { *(*self) < *(*other) }\n     #[inline]"}, {"sha": "8bf7f64a719b662f08ab3b2523d09ceedd386187", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -26,7 +26,7 @@ pointers, and then storing the parent pointers as `Weak` pointers.\n use core::mem::transmute;\n use core::cell::Cell;\n use core::clone::Clone;\n-use core::cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering};\n+use core::cmp::{PartialEq, PartialOrd, TotalEq, TotalOrd, Ordering};\n use core::kinds::marker;\n use core::ops::{Deref, Drop};\n use core::option::{Option, Some, None};\n@@ -150,7 +150,7 @@ impl<T> Clone for Rc<T> {\n     }\n }\n \n-impl<T: Eq> Eq for Rc<T> {\n+impl<T: PartialEq> PartialEq for Rc<T> {\n     #[inline(always)]\n     fn eq(&self, other: &Rc<T>) -> bool { **self == **other }\n     #[inline(always)]\n@@ -159,7 +159,7 @@ impl<T: Eq> Eq for Rc<T> {\n \n impl<T: TotalEq> TotalEq for Rc<T> {}\n \n-impl<T: Ord> Ord for Rc<T> {\n+impl<T: PartialOrd> PartialOrd for Rc<T> {\n     #[inline(always)]\n     fn lt(&self, other: &Rc<T>) -> bool { **self < **other }\n "}, {"sha": "7acef128016cf87e5d146e7014b6d2061a6bac62", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -43,7 +43,7 @@ use std::rt::heap::allocate;\n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n // will always stay at 0.\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n struct Chunk {\n     data: Rc<RefCell<Vec<u8> >>,\n     fill: Cell<uint>,"}, {"sha": "c91a5289faa130b3082e7ddccb336ee89bf50a03", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -796,7 +796,7 @@ impl BitvSet {\n     }\n }\n \n-impl cmp::Eq for BitvSet {\n+impl cmp::PartialEq for BitvSet {\n     fn eq(&self, other: &BitvSet) -> bool {\n         if self.size != other.size {\n             return false;"}, {"sha": "e0bb8658c13e9a79b18ac6c1b5f584100fed7dc9", "filename": "src/libcollections/btree.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcollections%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcollections%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -92,15 +92,15 @@ impl<K: Clone + TotalOrd, V: Clone> Clone for BTree<K, V> {\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> Eq for BTree<K, V> {\n+impl<K: TotalOrd, V: TotalEq> PartialEq for BTree<K, V> {\n     fn eq(&self, other: &BTree<K, V>) -> bool {\n         self.root.cmp(&other.root) == Equal\n     }\n }\n \n impl<K: TotalOrd, V: TotalEq> TotalEq for BTree<K, V> {}\n \n-impl<K: TotalOrd, V: TotalEq> Ord for BTree<K, V> {\n+impl<K: TotalOrd, V: TotalEq> PartialOrd for BTree<K, V> {\n     fn lt(&self, other: &BTree<K, V>) -> bool {\n         self.cmp(other) == Less\n     }\n@@ -198,7 +198,7 @@ impl<K: Clone + TotalOrd, V: Clone> Clone for Node<K, V> {\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> Eq for Node<K, V> {\n+impl<K: TotalOrd, V: TotalEq> PartialEq for Node<K, V> {\n     fn eq(&self, other: &Node<K, V>) -> bool {\n         match *self{\n             BranchNode(ref branch) => {\n@@ -222,7 +222,7 @@ impl<K: TotalOrd, V: TotalEq> Eq for Node<K, V> {\n \n impl<K: TotalOrd, V: TotalEq> TotalEq for Node<K, V> {}\n \n-impl<K: TotalOrd, V: TotalEq> Ord for Node<K, V> {\n+impl<K: TotalOrd, V: TotalEq> PartialOrd for Node<K, V> {\n     fn lt(&self, other: &Node<K, V>) -> bool {\n         self.cmp(other) == Less\n     }\n@@ -393,15 +393,15 @@ impl<K: Clone + TotalOrd, V: Clone> Clone for Leaf<K, V> {\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> Eq for Leaf<K, V> {\n+impl<K: TotalOrd, V: TotalEq> PartialEq for Leaf<K, V> {\n     fn eq(&self, other: &Leaf<K, V>) -> bool {\n         self.elts == other.elts\n     }\n }\n \n impl<K: TotalOrd, V: TotalEq> TotalEq for Leaf<K, V> {}\n \n-impl<K: TotalOrd, V: TotalEq> Ord for Leaf<K, V> {\n+impl<K: TotalOrd, V: TotalEq> PartialOrd for Leaf<K, V> {\n     fn lt(&self, other: &Leaf<K, V>) -> bool {\n         self.cmp(other) == Less\n     }\n@@ -623,15 +623,15 @@ impl<K: Clone + TotalOrd, V: Clone> Clone for Branch<K, V> {\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> Eq for Branch<K, V> {\n+impl<K: TotalOrd, V: TotalEq> PartialEq for Branch<K, V> {\n     fn eq(&self, other: &Branch<K, V>) -> bool {\n         self.elts == other.elts\n     }\n }\n \n impl<K: TotalOrd, V: TotalEq> TotalEq for Branch<K, V> {}\n \n-impl<K: TotalOrd, V: TotalEq> Ord for Branch<K, V> {\n+impl<K: TotalOrd, V: TotalEq> PartialOrd for Branch<K, V> {\n     fn lt(&self, other: &Branch<K, V>) -> bool {\n         self.cmp(other) == Less\n     }\n@@ -691,15 +691,15 @@ impl<K: Clone + TotalOrd, V: Clone> Clone for LeafElt<K, V> {\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> Eq for LeafElt<K, V> {\n+impl<K: TotalOrd, V: TotalEq> PartialEq for LeafElt<K, V> {\n     fn eq(&self, other: &LeafElt<K, V>) -> bool {\n         self.key == other.key && self.value == other.value\n     }\n }\n \n impl<K: TotalOrd, V: TotalEq> TotalEq for LeafElt<K, V> {}\n \n-impl<K: TotalOrd, V: TotalEq> Ord for LeafElt<K, V> {\n+impl<K: TotalOrd, V: TotalEq> PartialOrd for LeafElt<K, V> {\n     fn lt(&self, other: &LeafElt<K, V>) -> bool {\n         self.cmp(other) == Less\n     }\n@@ -740,15 +740,15 @@ impl<K: Clone + TotalOrd, V: Clone> Clone for BranchElt<K, V> {\n     }\n }\n \n-impl<K: TotalOrd, V: TotalEq> Eq for BranchElt<K, V>{\n+impl<K: TotalOrd, V: TotalEq> PartialEq for BranchElt<K, V>{\n     fn eq(&self, other: &BranchElt<K, V>) -> bool {\n         self.key == other.key && self.value == other.value\n     }\n }\n \n impl<K: TotalOrd, V: TotalEq> TotalEq for BranchElt<K, V>{}\n \n-impl<K: TotalOrd, V: TotalEq> Ord for BranchElt<K, V> {\n+impl<K: TotalOrd, V: TotalEq> PartialOrd for BranchElt<K, V> {\n     fn lt(&self, other: &BranchElt<K, V>) -> bool {\n         self.cmp(other) == Less\n     }"}, {"sha": "d99474cf5f842584fafcef5258f670d78b9411ff", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -572,7 +572,7 @@ impl<A> Extendable<A> for DList<A> {\n     }\n }\n \n-impl<A: Eq> Eq for DList<A> {\n+impl<A: PartialEq> PartialEq for DList<A> {\n     fn eq(&self, other: &DList<A>) -> bool {\n         self.len() == other.len() &&\n             iter::order::eq(self.iter(), other.iter())\n@@ -584,7 +584,7 @@ impl<A: Eq> Eq for DList<A> {\n     }\n }\n \n-impl<A: Ord> Ord for DList<A> {\n+impl<A: PartialOrd> PartialOrd for DList<A> {\n     fn lt(&self, other: &DList<A>) -> bool {\n         iter::order::lt(self.iter(), other.iter())\n     }"}, {"sha": "797fbbcebf764304461eaf46123215b1721b4b74", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -15,7 +15,7 @@\n \n use std::num::Bitwise;\n \n-#[deriving(Clone, Eq, TotalEq, Hash, Show)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash, Show)]\n /// A specialized Set implementation to use enum types.\n pub struct EnumSet<E> {\n     // We must maintain the invariant that no bits are set\n@@ -141,7 +141,7 @@ mod test {\n \n     use enum_set::{EnumSet, CLike};\n \n-    #[deriving(Eq, Show)]\n+    #[deriving(PartialEq, Show)]\n     #[repr(uint)]\n     enum Foo {\n         A, B, C"}, {"sha": "f535e87de5c23851bb776d7068630f6543665ec0", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -12,7 +12,7 @@\n \n use std::container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n use std::clone::Clone;\n-use std::cmp::{Eq, TotalEq, Equiv, max};\n+use std::cmp::{PartialEq, TotalEq, Equiv, max};\n use std::default::Default;\n use std::fmt;\n use std::fmt::Show;\n@@ -32,7 +32,7 @@ use std::slice::ImmutableVector;\n mod table {\n     use std::clone::Clone;\n     use std::cmp;\n-    use std::cmp::Eq;\n+    use std::cmp::PartialEq;\n     use std::hash::{Hash, Hasher};\n     use std::kinds::marker;\n     use std::num::{CheckedMul, is_power_of_two};\n@@ -145,7 +145,7 @@ mod table {\n \n     /// A hash that is not zero, since we use a hash of zero to represent empty\n     /// buckets.\n-    #[deriving(Eq)]\n+    #[deriving(PartialEq)]\n     pub struct SafeHash {\n         hash: u64,\n     }\n@@ -661,8 +661,8 @@ static INITIAL_LOAD_FACTOR: Fraction = (9, 10);\n /// denial-of-service attacks (Hash DoS). This behaviour can be\n /// overridden with one of the constructors.\n ///\n-/// It is required that the keys implement the `Eq` and `Hash` traits, although\n-/// this can frequently be achieved by using `#[deriving(Eq, Hash)]`.\n+/// It is required that the keys implement the `PartialEq` and `Hash` traits, although\n+/// this can frequently be achieved by using `#[deriving(PartialEq, Hash)]`.\n ///\n /// Relevant papers/articles:\n ///\n@@ -1402,7 +1402,7 @@ impl<K: TotalEq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n }\n \n-impl<K: TotalEq + Hash<S>, V: Eq, S, H: Hasher<S>> Eq for HashMap<K, V, H> {\n+impl<K: TotalEq + Hash<S>, V: PartialEq, S, H: Hasher<S>> PartialEq for HashMap<K, V, H> {\n     fn eq(&self, other: &HashMap<K, V, H>) -> bool {\n         if self.len() != other.len() { return false; }\n \n@@ -1480,13 +1480,13 @@ pub type SetMoveItems<K> =\n \n /// An implementation of a hash set using the underlying representation of a\n /// HashMap where the value is (). As with the `HashMap` type, a `HashSet`\n-/// requires that the elements implement the `Eq` and `Hash` traits.\n+/// requires that the elements implement the `PartialEq` and `Hash` traits.\n #[deriving(Clone)]\n pub struct HashSet<T, H = sip::SipHasher> {\n     map: HashMap<T, (), H>\n }\n \n-impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> Eq for HashSet<T, H> {\n+impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> PartialEq for HashSet<T, H> {\n     fn eq(&self, other: &HashSet<T, H>) -> bool {\n         if self.len() != other.len() { return false; }\n \n@@ -1691,7 +1691,7 @@ mod test_map {\n \n     local_data_key!(drop_vector: RefCell<Vec<int>>)\n \n-    #[deriving(Hash, Eq, TotalEq)]\n+    #[deriving(Hash, PartialEq, TotalEq)]\n     struct Dropable {\n         k: uint\n     }"}, {"sha": "7c8513bac329356e2f4b4f10443fc1ec941578fc", "filename": "src/libcollections/lru_cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flru_cache.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -67,7 +67,7 @@ impl<S, K: Hash<S>> Hash<S> for KeyRef<K> {\n     }\n }\n \n-impl<K: Eq> Eq for KeyRef<K> {\n+impl<K: PartialEq> PartialEq for KeyRef<K> {\n     fn eq(&self, other: &KeyRef<K>) -> bool {\n         unsafe{ (*self.k).eq(&*other.k) }\n     }\n@@ -253,7 +253,7 @@ impl<K, V> Drop for LruCache<K, V> {\n mod tests {\n     use super::LruCache;\n \n-    fn assert_opt_eq<V: Eq>(opt: Option<&V>, v: V) {\n+    fn assert_opt_eq<V: PartialEq>(opt: Option<&V>, v: V) {\n         assert!(opt.is_some());\n         assert!(opt.unwrap() == &v);\n     }"}, {"sha": "0ca4177b7aa824873df26a3ddab2fcc72d092435", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -364,7 +364,7 @@ fn raw_index(lo: uint, len: uint, index: uint) -> uint {\n     }\n }\n \n-impl<A: Eq> Eq for RingBuf<A> {\n+impl<A: PartialEq> PartialEq for RingBuf<A> {\n     fn eq(&self, other: &RingBuf<A>) -> bool {\n         self.nelts == other.nelts &&\n             self.iter().zip(other.iter()).all(|(a, b)| a.eq(b))\n@@ -397,7 +397,7 @@ mod tests {\n     use self::test::Bencher;\n     use deque::Deque;\n     use std::clone::Clone;\n-    use std::cmp::Eq;\n+    use std::cmp::PartialEq;\n     use std::fmt::Show;\n     use super::RingBuf;\n \n@@ -483,7 +483,7 @@ mod tests {\n     }\n \n     #[cfg(test)]\n-    fn test_parameterized<T:Clone + Eq + Show>(a: T, b: T, c: T, d: T) {\n+    fn test_parameterized<T:Clone + PartialEq + Show>(a: T, b: T, c: T, d: T) {\n         let mut deq = RingBuf::new();\n         assert_eq!(deq.len(), 0);\n         deq.push_front(a.clone());\n@@ -568,21 +568,21 @@ mod tests {\n         })\n     }\n \n-    #[deriving(Clone, Eq, Show)]\n+    #[deriving(Clone, PartialEq, Show)]\n     enum Taggy {\n         One(int),\n         Two(int, int),\n         Three(int, int, int),\n     }\n \n-    #[deriving(Clone, Eq, Show)]\n+    #[deriving(Clone, PartialEq, Show)]\n     enum Taggypar<T> {\n         Onepar(int),\n         Twopar(int, int),\n         Threepar(int, int, int),\n     }\n \n-    #[deriving(Clone, Eq, Show)]\n+    #[deriving(Clone, PartialEq, Show)]\n     struct RecCy {\n         x: int,\n         y: int,"}, {"sha": "98816003a3768e47420e2815040b7e1076f3e49d", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -43,15 +43,15 @@ pub struct TreeMap<K, V> {\n     length: uint\n }\n \n-impl<K: Eq + TotalOrd, V: Eq> Eq for TreeMap<K, V> {\n+impl<K: PartialEq + TotalOrd, V: PartialEq> PartialEq for TreeMap<K, V> {\n     fn eq(&self, other: &TreeMap<K, V>) -> bool {\n         self.len() == other.len() &&\n             self.iter().zip(other.iter()).all(|(a, b)| a == b)\n     }\n }\n \n // Lexicographical comparison\n-fn lt<K: Ord + TotalOrd, V: Ord>(a: &TreeMap<K, V>,\n+fn lt<K: PartialOrd + TotalOrd, V: PartialOrd>(a: &TreeMap<K, V>,\n                                  b: &TreeMap<K, V>) -> bool {\n     // the Zip iterator is as long as the shortest of a and b.\n     for ((key_a, value_a), (key_b, value_b)) in a.iter().zip(b.iter()) {\n@@ -64,7 +64,7 @@ fn lt<K: Ord + TotalOrd, V: Ord>(a: &TreeMap<K, V>,\n     a.len() < b.len()\n }\n \n-impl<K: Ord + TotalOrd, V: Ord> Ord for TreeMap<K, V> {\n+impl<K: PartialOrd + TotalOrd, V: PartialOrd> PartialOrd for TreeMap<K, V> {\n     #[inline]\n     fn lt(&self, other: &TreeMap<K, V>) -> bool { lt(self, other) }\n }\n@@ -552,12 +552,12 @@ pub struct TreeSet<T> {\n     map: TreeMap<T, ()>\n }\n \n-impl<T: Eq + TotalOrd> Eq for TreeSet<T> {\n+impl<T: PartialEq + TotalOrd> PartialEq for TreeSet<T> {\n     #[inline]\n     fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n }\n \n-impl<T: Ord + TotalOrd> Ord for TreeSet<T> {\n+impl<T: PartialOrd + TotalOrd> PartialOrd for TreeSet<T> {\n     #[inline]\n     fn lt(&self, other: &TreeSet<T>) -> bool { self.map < other.map }\n }\n@@ -1070,7 +1070,7 @@ mod test_treemap {\n         assert_eq!(m.find(&k1), Some(&v1));\n     }\n \n-    fn check_equal<K: Eq + TotalOrd, V: Eq>(ctrl: &[(K, V)],\n+    fn check_equal<K: PartialEq + TotalOrd, V: PartialEq>(ctrl: &[(K, V)],\n                                             map: &TreeMap<K, V>) {\n         assert_eq!(ctrl.is_empty(), map.is_empty());\n         for x in ctrl.iter() {"}, {"sha": "2a03eacf13cb306bf3c1bceccfbd7d9642a40fca", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -121,7 +121,7 @@ mod tests {\n     use realstd::owned::{Box, AnyOwnExt};\n     use realstd::str::Str;\n \n-    #[deriving(Eq, Show)]\n+    #[deriving(PartialEq, Show)]\n     struct Test;\n \n     static TEST: &'static str = \"Test\";"}, {"sha": "f6c438698b488a43f2b847d422477e9ec71836c3", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -160,7 +160,7 @@\n // FIXME: Relationship to Atomic types and RWLock\n \n use clone::Clone;\n-use cmp::Eq;\n+use cmp::PartialEq;\n use kinds::{marker, Copy};\n use ops::{Deref, DerefMut, Drop};\n use option::{None, Option, Some};\n@@ -202,7 +202,7 @@ impl<T:Copy> Clone for Cell<T> {\n     }\n }\n \n-impl<T:Eq + Copy> Eq for Cell<T> {\n+impl<T:PartialEq + Copy> PartialEq for Cell<T> {\n     fn eq(&self, other: &Cell<T>) -> bool {\n         self.get() == other.get()\n     }\n@@ -308,7 +308,7 @@ impl<T: Clone> Clone for RefCell<T> {\n     }\n }\n \n-impl<T: Eq> Eq for RefCell<T> {\n+impl<T: PartialEq> PartialEq for RefCell<T> {\n     fn eq(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() == *other.borrow()\n     }"}, {"sha": "80bc4f31a130e1436ee78c6e0c73c3e157c359ae", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Defines the `Ord` and `Eq` comparison traits.\n+//! Defines the `PartialOrd` and `PartialEq` comparison traits.\n //!\n-//! This module defines both `Ord` and `Eq` traits which are used by the\n+//! This module defines both `PartialOrd` and `PartialEq` traits which are used by the\n //! compiler to implement comparison operators. Rust programs may implement\n-//!`Ord` to overload the `<`, `<=`, `>`, and `>=` operators, and may implement\n-//! `Eq` to overload the `==` and `!=` operators.\n+//!`PartialOrd` to overload the `<`, `<=`, `>`, and `>=` operators, and may implement\n+//! `PartialEq` to overload the `==` and `!=` operators.\n //!\n-//! For example, to define a type with a customized definition for the Eq\n+//! For example, to define a type with a customized definition for the PartialEq\n //! operators, you could do the following:\n //!\n //! ```rust\n@@ -24,8 +24,8 @@\n //!     num : int\n //! }\n //!\n-//! // Our implementation of `Eq` to support `==` and `!=`.\n-//! impl Eq for SketchyNum {\n+//! // Our implementation of `PartialEq` to support `==` and `!=`.\n+//! impl PartialEq for SketchyNum {\n //!     // Our custom eq allows numbers which are near each other to be equal! :D\n //!     fn eq(&self, other: &SketchyNum) -> bool {\n //!         (self.num - other.num).abs() < 5\n@@ -37,8 +37,8 @@\n //! assert!(SketchyNum {num: 25} != SketchyNum {num: 57});\n //! ```\n \n-pub use PartialEq = cmp::Eq;\n-pub use PartialOrd = cmp::Ord;\n+pub use Eq = self::TotalEq;\n+pub use Ord = self::TotalOrd;\n \n /// Trait for values that can be compared for equality and inequality.\n ///\n@@ -47,13 +47,13 @@ pub use PartialOrd = cmp::Ord;\n /// types `a == b` and `a != b` will both evaluate to false if either `a` or\n /// `b` is NaN (cf. IEEE 754-2008 section 5.11).\n ///\n-/// Eq only requires the `eq` method to be implemented; `ne` is its negation by\n+/// PartialEq only requires the `eq` method to be implemented; `ne` is its negation by\n /// default.\n ///\n /// Eventually, this will be implemented by default for types that implement\n /// `TotalEq`.\n #[lang=\"eq\"]\n-pub trait Eq {\n+pub trait PartialEq {\n     /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n     fn eq(&self, other: &Self) -> bool;\n \n@@ -71,7 +71,7 @@ pub trait Eq {\n /// - reflexive: `a == a`;\n /// - symmetric: `a == b` implies `b == a`; and\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n-pub trait TotalEq: Eq {\n+pub trait TotalEq: PartialEq {\n     // FIXME #13101: this method is used solely by #[deriving] to\n     // assert that every component of a type implements #[deriving]\n     // itself, the current deriving infrastructure means doing this\n@@ -85,7 +85,7 @@ pub trait TotalEq: Eq {\n }\n \n /// An ordering is, e.g, a result of a comparison between two values.\n-#[deriving(Clone, Eq, Show)]\n+#[deriving(Clone, PartialEq, Show)]\n pub enum Ordering {\n    /// An ordering where a compared value is less [than another].\n    Less = -1,\n@@ -104,7 +104,7 @@ pub enum Ordering {\n ///   true; and\n /// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for\n ///   both `==` and `>`.\n-pub trait TotalOrd: TotalEq + Ord {\n+pub trait TotalOrd: TotalEq + PartialOrd {\n     /// This method returns an ordering between `self` and `other` values.\n     ///\n     /// By convention, `self.cmp(&other)` returns the ordering matching\n@@ -127,7 +127,7 @@ impl TotalOrd for Ordering {\n     }\n }\n \n-impl Ord for Ordering {\n+impl PartialOrd for Ordering {\n     #[inline]\n     fn lt(&self, other: &Ordering) -> bool { (*self as int) < (*other as int) }\n }\n@@ -147,14 +147,14 @@ pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n \n /// Trait for values that can be compared for a sort-order.\n ///\n-/// Ord only requires implementation of the `lt` method,\n+/// PartialOrd only requires implementation of the `lt` method,\n /// with the others generated from default implementations.\n ///\n /// However it remains possible to implement the others separately,\n /// for compatibility with floating-point NaN semantics\n /// (cf. IEEE 754-2008 section 5.11).\n #[lang=\"ord\"]\n-pub trait Ord: Eq {\n+pub trait PartialOrd: PartialEq {\n     /// This method tests less than (for `self` and `other`) and is used by the `<` operator.\n     fn lt(&self, other: &Self) -> bool;\n \n@@ -192,14 +192,15 @@ pub fn max<T: TotalOrd>(v1: T, v2: T) -> T {\n     if v1 > v2 { v1 } else { v2 }\n }\n \n-// Implementation of Eq, TotalEq, Ord and TotalOrd for primitive types\n+// Implementation of PartialEq, TotalEq, PartialOrd and TotalOrd for primitive types\n #[cfg(not(test))]\n mod impls {\n-    use cmp::{Ord, TotalOrd, Eq, TotalEq, Ordering, Less, Greater, Equal};\n+    use cmp::{PartialOrd, TotalOrd, PartialEq, TotalEq, Ordering,\n+              Less, Greater, Equal};\n \n     macro_rules! eq_impl(\n         ($($t:ty)*) => ($(\n-            impl Eq for $t {\n+            impl PartialEq for $t {\n                 #[inline]\n                 fn eq(&self, other: &$t) -> bool { (*self) == (*other) }\n                 #[inline]\n@@ -208,7 +209,7 @@ mod impls {\n         )*)\n     )\n \n-    impl Eq for () {\n+    impl PartialEq for () {\n         #[inline]\n         fn eq(&self, _other: &()) -> bool { true }\n         #[inline]\n@@ -227,7 +228,7 @@ mod impls {\n \n     macro_rules! ord_impl(\n         ($($t:ty)*) => ($(\n-            impl Ord for $t {\n+            impl PartialOrd for $t {\n                 #[inline]\n                 fn lt(&self, other: &$t) -> bool { (*self) < (*other) }\n                 #[inline]\n@@ -240,12 +241,12 @@ mod impls {\n         )*)\n     )\n \n-    impl Ord for () {\n+    impl PartialOrd for () {\n         #[inline]\n         fn lt(&self, _other: &()) -> bool { false }\n     }\n \n-    impl Ord for bool {\n+    impl PartialOrd for bool {\n         #[inline]\n         fn lt(&self, other: &bool) -> bool {\n             (*self as u8) < (*other as u8)\n@@ -282,13 +283,13 @@ mod impls {\n     totalord_impl!(char uint u8 u16 u32 u64 int i8 i16 i32 i64)\n \n     // & pointers\n-    impl<'a, T: Eq> Eq for &'a T {\n+    impl<'a, T: PartialEq> PartialEq for &'a T {\n         #[inline]\n         fn eq(&self, other: & &'a T) -> bool { *(*self) == *(*other) }\n         #[inline]\n         fn ne(&self, other: & &'a T) -> bool { *(*self) != *(*other) }\n     }\n-    impl<'a, T: Ord> Ord for &'a T {\n+    impl<'a, T: PartialOrd> PartialOrd for &'a T {\n         #[inline]\n         fn lt(&self, other: & &'a T) -> bool { *(*self) < *(*other) }\n         #[inline]\n@@ -305,13 +306,13 @@ mod impls {\n     impl<'a, T: TotalEq> TotalEq for &'a T {}\n \n     // &mut pointers\n-    impl<'a, T: Eq> Eq for &'a mut T {\n+    impl<'a, T: PartialEq> PartialEq for &'a mut T {\n         #[inline]\n         fn eq(&self, other: &&'a mut T) -> bool { **self == *(*other) }\n         #[inline]\n         fn ne(&self, other: &&'a mut T) -> bool { **self != *(*other) }\n     }\n-    impl<'a, T: Ord> Ord for &'a mut T {\n+    impl<'a, T: PartialOrd> PartialOrd for &'a mut T {\n         #[inline]\n         fn lt(&self, other: &&'a mut T) -> bool { **self < **other }\n         #[inline]\n@@ -328,13 +329,13 @@ mod impls {\n     impl<'a, T: TotalEq> TotalEq for &'a mut T {}\n \n     // @ pointers\n-    impl<T:Eq> Eq for @T {\n+    impl<T:PartialEq> PartialEq for @T {\n         #[inline]\n         fn eq(&self, other: &@T) -> bool { *(*self) == *(*other) }\n         #[inline]\n         fn ne(&self, other: &@T) -> bool { *(*self) != *(*other) }\n     }\n-    impl<T:Ord> Ord for @T {\n+    impl<T:PartialOrd> PartialOrd for @T {\n         #[inline]\n         fn lt(&self, other: &@T) -> bool { *(*self) < *(*other) }\n         #[inline]\n@@ -400,8 +401,8 @@ mod test {\n             num : int\n         }\n \n-        // Our implementation of `Eq` to support `==` and `!=`.\n-        impl Eq for SketchyNum {\n+        // Our implementation of `PartialEq` to support `==` and `!=`.\n+        impl PartialEq for SketchyNum {\n             // Our custom eq allows numbers which are near each other to be equal! :D\n             fn eq(&self, other: &SketchyNum) -> bool {\n                 (self.num - other.num).abs() < 5"}, {"sha": "d4571eb3a43511ca61d4b1ca9dafa414addc6130", "filename": "src/libcore/failure.rs", "status": "modified", "additions": 2, "deletions": 38, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffailure.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -30,12 +30,10 @@\n \n use fmt;\n use intrinsics;\n-#[cfg(not(test), stage0)]\n-use str::raw::c_str_to_static_slice;\n \n #[cold] #[inline(never)] // this is the slow path, always\n #[lang=\"fail_\"]\n-#[cfg(not(test), not(stage0))]\n+#[cfg(not(test))]\n fn fail_(expr: &'static str, file: &'static str, line: uint) -> ! {\n     format_args!(|args| -> () {\n         begin_unwind(args, file, line);\n@@ -44,24 +42,9 @@ fn fail_(expr: &'static str, file: &'static str, line: uint) -> ! {\n     unsafe { intrinsics::abort() }\n }\n \n-#[cold] #[inline(never)] // this is the slow path, always\n-#[lang=\"fail_\"]\n-#[cfg(not(test), stage0)]\n-fn fail_(expr: *u8, file: *u8, line: uint) -> ! {\n-    unsafe {\n-        let expr = c_str_to_static_slice(expr as *i8);\n-        let file = c_str_to_static_slice(file as *i8);\n-        format_args!(|args| -> () {\n-            begin_unwind(args, file, line);\n-        }, \"{}\", expr);\n-\n-        intrinsics::abort()\n-    }\n-}\n-\n #[cold]\n #[lang=\"fail_bounds_check\"]\n-#[cfg(not(test), not(stage0))]\n+#[cfg(not(test))]\n fn fail_bounds_check(file: &'static str, line: uint,\n                      index: uint, len: uint) -> ! {\n     format_args!(|args| -> () {\n@@ -70,28 +53,9 @@ fn fail_bounds_check(file: &'static str, line: uint,\n     unsafe { intrinsics::abort() }\n }\n \n-#[cold]\n-#[lang=\"fail_bounds_check\"]\n-#[cfg(not(test), stage0)]\n-fn fail_bounds_check(file: *u8, line: uint, index: uint, len: uint) -> ! {\n-    let file = unsafe { c_str_to_static_slice(file as *i8) };\n-    format_args!(|args| -> () {\n-        begin_unwind(args, file, line);\n-    }, \"index out of bounds: the len is {} but the index is {}\", len, index);\n-    unsafe { intrinsics::abort() }\n-}\n-\n #[cold]\n pub fn begin_unwind(fmt: &fmt::Arguments, file: &'static str, line: uint) -> ! {\n     #[allow(ctypes)]\n-    #[cfg(stage0)]\n-    extern {\n-        #[link_name = \"rust_begin_unwind\"]\n-        fn begin_unwind(fmt: &fmt::Arguments, file: &'static str,\n-                        line: uint) -> !;\n-    }\n-    #[allow(ctypes)]\n-    #[cfg(not(stage0))]\n     extern {\n         #[lang = \"begin_unwind\"]\n         fn begin_unwind(fmt: &fmt::Arguments, file: &'static str,"}, {"sha": "890733dc229afccb033c5759aaed1e8fc290a518", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -65,23 +65,23 @@ trait GenericRadix {\n }\n \n /// A binary (base 2) radix\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n struct Binary;\n \n /// An octal (base 8) radix\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n struct Octal;\n \n /// A decimal (base 10) radix\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n struct Decimal;\n \n /// A hexadecimal (base 16) radix, formatted with lower-case characters\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n struct LowerHex;\n \n /// A hexadecimal (base 16) radix, formatted with upper-case characters\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub struct UpperHex;\n \n macro_rules! radix {\n@@ -108,7 +108,7 @@ radix!(UpperHex, 16, \"0x\", x @  0 .. 9 => '0' as u8 + x,\n                            x @ 10 ..15 => 'A' as u8 + (x - 10))\n \n /// A radix with in the range of `2..36`.\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub struct Radix {\n     base: u8,\n }"}, {"sha": "f2e1476cc1c3a399e214433c289cfc8976f33180", "filename": "src/libcore/fmt/rt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -40,7 +40,7 @@ pub struct FormatSpec {\n     pub width: Count,\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum Alignment {\n     AlignLeft,\n     AlignRight,"}, {"sha": "b36735713af700750ebdd388c07ac6db52a10a5e", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -550,7 +550,7 @@ extern \"rust-intrinsic\" {\n /// `TypeId` represents a globally unique identifier for a type\n #[lang=\"type_id\"] // This needs to be kept in lockstep with the code in trans/intrinsic.rs and\n                   // middle/lang_items.rs\n-#[deriving(Eq, TotalEq, Show)]\n+#[deriving(PartialEq, TotalEq, Show)]\n #[cfg(not(test))]\n pub struct TypeId {\n     t: u64,"}, {"sha": "4438b6ec980cd6432ca6d91010aefa3822b58e33", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -68,7 +68,7 @@ use cmp;\n use num::{Zero, One, CheckedAdd, CheckedSub, Saturating, ToPrimitive, Int};\n use option::{Option, Some, None};\n use ops::{Add, Mul, Sub};\n-use cmp::{Eq, Ord, TotalOrd};\n+use cmp::{PartialEq, PartialOrd, TotalOrd};\n use clone::Clone;\n use uint;\n use mem;\n@@ -847,7 +847,7 @@ impl<A: Mul<A, A> + One, T: Iterator<A>> MultiplicativeIterator<A> for T {\n }\n \n /// A trait for iterators over elements which can be compared to one another.\n-/// The type of each element must ascribe to the `Ord` trait.\n+/// The type of each element must ascribe to the `PartialOrd` trait.\n pub trait OrdIterator<A> {\n     /// Consumes the entire iterator to return the maximum element.\n     ///\n@@ -971,7 +971,7 @@ impl<A: TotalOrd, T: Iterator<A>> OrdIterator<A> for T {\n }\n \n /// `MinMaxResult` is an enum returned by `min_max`. See `OrdIterator::min_max` for more detail.\n-#[deriving(Clone, Eq, Show)]\n+#[deriving(Clone, PartialEq, Show)]\n pub enum MinMaxResult<T> {\n     /// Empty iterator\n     NoElements,\n@@ -1945,12 +1945,12 @@ pub struct Range<A> {\n \n /// Return an iterator over the range [start, stop)\n #[inline]\n-pub fn range<A: Add<A, A> + Ord + Clone + One>(start: A, stop: A) -> Range<A> {\n+pub fn range<A: Add<A, A> + PartialOrd + Clone + One>(start: A, stop: A) -> Range<A> {\n     Range{state: start, stop: stop, one: One::one()}\n }\n \n // FIXME: #10414: Unfortunate type bound\n-impl<A: Add<A, A> + Ord + Clone + ToPrimitive> Iterator<A> for Range<A> {\n+impl<A: Add<A, A> + PartialOrd + Clone + ToPrimitive> Iterator<A> for Range<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if self.state < self.stop {\n@@ -1997,7 +1997,7 @@ impl<A: Add<A, A> + Ord + Clone + ToPrimitive> Iterator<A> for Range<A> {\n \n /// `Int` is required to ensure the range will be the same regardless of\n /// the direction it is consumed.\n-impl<A: Int + Ord + Clone + ToPrimitive> DoubleEndedIterator<A> for Range<A> {\n+impl<A: Int + PartialOrd + Clone + ToPrimitive> DoubleEndedIterator<A> for Range<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         if self.stop > self.state {\n@@ -2018,12 +2018,12 @@ pub struct RangeInclusive<A> {\n \n /// Return an iterator over the range [start, stop]\n #[inline]\n-pub fn range_inclusive<A: Add<A, A> + Ord + Clone + One>(start: A, stop: A)\n+pub fn range_inclusive<A: Add<A, A> + PartialOrd + Clone + One>(start: A, stop: A)\n     -> RangeInclusive<A> {\n     RangeInclusive{range: range(start, stop), done: false}\n }\n \n-impl<A: Add<A, A> + Ord + Clone + ToPrimitive> Iterator<A> for RangeInclusive<A> {\n+impl<A: Add<A, A> + PartialOrd + Clone + ToPrimitive> Iterator<A> for RangeInclusive<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         match self.range.next() {\n@@ -2055,7 +2055,7 @@ impl<A: Add<A, A> + Ord + Clone + ToPrimitive> Iterator<A> for RangeInclusive<A>\n     }\n }\n \n-impl<A: Sub<A, A> + Int + Ord + Clone + ToPrimitive> DoubleEndedIterator<A>\n+impl<A: Sub<A, A> + Int + PartialOrd + Clone + ToPrimitive> DoubleEndedIterator<A>\n     for RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n@@ -2083,12 +2083,13 @@ pub struct RangeStep<A> {\n \n /// Return an iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n #[inline]\n-pub fn range_step<A: CheckedAdd + Ord + Clone + Zero>(start: A, stop: A, step: A) -> RangeStep<A> {\n+pub fn range_step<A: CheckedAdd + PartialOrd +\n+                  Clone + Zero>(start: A, stop: A, step: A) -> RangeStep<A> {\n     let rev = step < Zero::zero();\n     RangeStep{state: start, stop: stop, step: step, rev: rev}\n }\n \n-impl<A: CheckedAdd + Ord + Clone> Iterator<A> for RangeStep<A> {\n+impl<A: CheckedAdd + PartialOrd + Clone> Iterator<A> for RangeStep<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if (self.rev && self.state > self.stop) || (!self.rev && self.state < self.stop) {\n@@ -2116,13 +2117,13 @@ pub struct RangeStepInclusive<A> {\n \n /// Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n #[inline]\n-pub fn range_step_inclusive<A: CheckedAdd + Ord + Clone + Zero>(start: A, stop: A,\n+pub fn range_step_inclusive<A: CheckedAdd + PartialOrd + Clone + Zero>(start: A, stop: A,\n                                                                 step: A) -> RangeStepInclusive<A> {\n     let rev = step < Zero::zero();\n     RangeStepInclusive{state: start, stop: stop, step: step, rev: rev, done: false}\n }\n \n-impl<A: CheckedAdd + Ord + Clone + Eq> Iterator<A> for RangeStepInclusive<A> {\n+impl<A: CheckedAdd + PartialOrd + Clone + PartialEq> Iterator<A> for RangeStepInclusive<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if !self.done && ((self.rev && self.state >= self.stop) ||\n@@ -2175,13 +2176,13 @@ impl<A: Clone> RandomAccessIterator<A> for Repeat<A> {\n /// Functions for lexicographical ordering of sequences.\n ///\n /// Lexicographical ordering through `<`, `<=`, `>=`, `>` requires\n-/// that the elements implement both `Eq` and `Ord`.\n+/// that the elements implement both `PartialEq` and `PartialOrd`.\n ///\n /// If two sequences are equal up until the point where one ends,\n /// the shorter sequence compares less.\n pub mod order {\n     use cmp;\n-    use cmp::{TotalEq, TotalOrd, Ord, Eq};\n+    use cmp::{TotalEq, TotalOrd, PartialOrd, PartialEq};\n     use option::{Some, None};\n     use super::Iterator;\n \n@@ -2211,8 +2212,8 @@ pub mod order {\n         }\n     }\n \n-    /// Compare `a` and `b` for equality (Using partial equality, `Eq`)\n-    pub fn eq<A: Eq, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n+    /// Compare `a` and `b` for equality (Using partial equality, `PartialEq`)\n+    pub fn eq<A: PartialEq, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return true,\n@@ -2222,8 +2223,8 @@ pub mod order {\n         }\n     }\n \n-    /// Compare `a` and `b` for nonequality (Using partial equality, `Eq`)\n-    pub fn ne<A: Eq, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n+    /// Compare `a` and `b` for nonequality (Using partial equality, `PartialEq`)\n+    pub fn ne<A: PartialEq, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return false,\n@@ -2233,8 +2234,8 @@ pub mod order {\n         }\n     }\n \n-    /// Return `a` < `b` lexicographically (Using partial order, `Ord`)\n-    pub fn lt<A: Ord, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n+    /// Return `a` < `b` lexicographically (Using partial order, `PartialOrd`)\n+    pub fn lt<A: PartialOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return false,\n@@ -2245,8 +2246,8 @@ pub mod order {\n         }\n     }\n \n-    /// Return `a` <= `b` lexicographically (Using partial order, `Ord`)\n-    pub fn le<A: Ord, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n+    /// Return `a` <= `b` lexicographically (Using partial order, `PartialOrd`)\n+    pub fn le<A: PartialOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return true,\n@@ -2257,8 +2258,8 @@ pub mod order {\n         }\n     }\n \n-    /// Return `a` > `b` lexicographically (Using partial order, `Ord`)\n-    pub fn gt<A: Ord, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n+    /// Return `a` > `b` lexicographically (Using partial order, `PartialOrd`)\n+    pub fn gt<A: PartialOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return false,\n@@ -2269,8 +2270,8 @@ pub mod order {\n         }\n     }\n \n-    /// Return `a` >= `b` lexicographically (Using partial order, `Ord`)\n-    pub fn ge<A: Ord, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n+    /// Return `a` >= `b` lexicographically (Using partial order, `PartialOrd`)\n+    pub fn ge<A: PartialOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return true,\n@@ -2849,7 +2850,7 @@ mod tests {\n \n \n     #[cfg(test)]\n-    fn check_randacc_iter<A: Eq, T: Clone + RandomAccessIterator<A>>(a: T, len: uint)\n+    fn check_randacc_iter<A: PartialEq, T: Clone + RandomAccessIterator<A>>(a: T, len: uint)\n     {\n         let mut b = a.clone();\n         assert_eq!(len, b.indexable());\n@@ -3009,13 +3010,13 @@ mod tests {\n             }\n         }\n \n-        impl Eq for Foo {\n+        impl PartialEq for Foo {\n             fn eq(&self, _: &Foo) -> bool {\n                 true\n             }\n         }\n \n-        impl Ord for Foo {\n+        impl PartialOrd for Foo {\n             fn lt(&self, _: &Foo) -> bool {\n                 false\n             }"}, {"sha": "40b716181e6fc5ec897a3c829f42c7b91abb5759", "filename": "src/libcore/kinds.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fkinds.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -133,7 +133,7 @@ pub mod marker {\n     /// (for example, `S<&'static int>` is a subtype of `S<&'a int>`\n     /// for some lifetime `'a`, but not the other way around).\n     #[lang=\"covariant_type\"]\n-    #[deriving(Eq,Clone)]\n+    #[deriving(PartialEq,Clone)]\n     pub struct CovariantType<T>;\n \n     /// A marker type whose type parameter `T` is considered to be\n@@ -176,7 +176,7 @@ pub mod marker {\n     /// function requires arguments of type `T`, it must also accept\n     /// arguments of type `U`, hence such a conversion is safe.\n     #[lang=\"contravariant_type\"]\n-    #[deriving(Eq,Clone)]\n+    #[deriving(PartialEq,Clone)]\n     pub struct ContravariantType<T>;\n \n     /// A marker type whose type parameter `T` is considered to be\n@@ -201,7 +201,7 @@ pub mod marker {\n     /// never written, but in fact `Cell` uses unsafe code to achieve\n     /// interior mutability.\n     #[lang=\"invariant_type\"]\n-    #[deriving(Eq,Clone)]\n+    #[deriving(PartialEq,Clone)]\n     pub struct InvariantType<T>;\n \n     /// As `CovariantType`, but for lifetime parameters. Using\n@@ -221,7 +221,7 @@ pub mod marker {\n     /// For more information about variance, refer to this Wikipedia\n     /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n     #[lang=\"covariant_lifetime\"]\n-    #[deriving(Eq,Clone)]\n+    #[deriving(PartialEq,Clone)]\n     pub struct CovariantLifetime<'a>;\n \n     /// As `ContravariantType`, but for lifetime parameters. Using\n@@ -237,7 +237,7 @@ pub mod marker {\n     /// For more information about variance, refer to this Wikipedia\n     /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n     #[lang=\"contravariant_lifetime\"]\n-    #[deriving(Eq,Clone)]\n+    #[deriving(PartialEq,Clone)]\n     pub struct ContravariantLifetime<'a>;\n \n     /// As `InvariantType`, but for lifetime parameters. Using\n@@ -248,34 +248,34 @@ pub mod marker {\n     /// and this pointer is itself stored in an inherently mutable\n     /// location (such as a `Cell`).\n     #[lang=\"invariant_lifetime\"]\n-    #[deriving(Eq,Clone)]\n+    #[deriving(PartialEq,Clone)]\n     pub struct InvariantLifetime<'a>;\n \n     /// A type which is considered \"not sendable\", meaning that it cannot\n     /// be safely sent between tasks, even if it is owned. This is\n     /// typically embedded in other types, such as `Gc`, to ensure that\n     /// their instances remain thread-local.\n     #[lang=\"no_send_bound\"]\n-    #[deriving(Eq,Clone)]\n+    #[deriving(PartialEq,Clone)]\n     pub struct NoSend;\n \n     /// A type which is considered \"not POD\", meaning that it is not\n     /// implicitly copyable. This is typically embedded in other types to\n     /// ensure that they are never copied, even if they lack a destructor.\n     #[lang=\"no_copy_bound\"]\n-    #[deriving(Eq,Clone)]\n+    #[deriving(PartialEq,Clone)]\n     pub struct NoCopy;\n \n     /// A type which is considered \"not shareable\", meaning that\n     /// its contents are not threadsafe, hence they cannot be\n     /// shared between tasks.\n     #[lang=\"no_share_bound\"]\n-    #[deriving(Eq,Clone)]\n+    #[deriving(PartialEq,Clone)]\n     pub struct NoShare;\n \n     /// A type which is considered managed by the GC. This is typically\n     /// embedded in other types.\n     #[lang=\"managed_bound\"]\n-    #[deriving(Eq,Clone)]\n+    #[deriving(PartialEq,Clone)]\n     pub struct Managed;\n }"}, {"sha": "a80b20775de4b4317fca9779fa70e4d3c1097270", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -17,15 +17,15 @@ use {int, i8, i16, i32, i64};\n use {uint, u8, u16, u32, u64};\n use {f32, f64};\n use clone::Clone;\n-use cmp::{Eq, Ord};\n+use cmp::{PartialEq, PartialOrd};\n use kinds::Copy;\n use mem::size_of;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n use option::{Option, Some, None};\n \n /// The base trait for numeric types\n-pub trait Num: Eq + Zero + One\n+pub trait Num: PartialEq + Zero + One\n              + Neg<Self>\n              + Add<Self,Self>\n              + Sub<Self,Self>\n@@ -495,7 +495,7 @@ pub trait Primitive: Copy\n                    + Clone\n                    + Num\n                    + NumCast\n-                   + Ord\n+                   + PartialOrd\n                    + Bounded {}\n \n trait_impl!(Primitive for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n@@ -1043,7 +1043,7 @@ pub trait Saturating {\n     fn saturating_sub(self, v: Self) -> Self;\n }\n \n-impl<T: CheckedAdd + CheckedSub + Zero + Ord + Bounded> Saturating for T {\n+impl<T: CheckedAdd + CheckedSub + Zero + PartialOrd + Bounded> Saturating for T {\n     #[inline]\n     fn saturating_add(self, v: T) -> T {\n         match self.checked_add(&v) {\n@@ -1238,7 +1238,7 @@ pub fn test_num<T:Num + NumCast + ::std::fmt::Show>(ten: T, two: T) {\n }\n \n /// Used for representing the classification of floating point numbers\n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n pub enum FPCategory {\n     /// \"Not a Number\", often obtained by dividing by zero\n     FPNaN,"}, {"sha": "379d14a6e6a753aacc2298442cb9e152980a4e49", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -141,14 +141,14 @@\n //! }\n //! ```\n \n-use cmp::{Eq, TotalEq, TotalOrd};\n+use cmp::{PartialEq, TotalEq, TotalOrd};\n use default::Default;\n use iter::{Iterator, DoubleEndedIterator, FromIterator, ExactSize};\n use mem;\n use slice;\n \n /// The `Option`\n-#[deriving(Clone, Eq, Ord, TotalEq, TotalOrd, Show)]\n+#[deriving(Clone, PartialEq, PartialOrd, TotalEq, TotalOrd, Show)]\n pub enum Option<T> {\n     /// No value\n     None,"}, {"sha": "466f981c926c3465de8b82ce19fbe4868a3669e6", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -45,7 +45,8 @@ pub use mem::drop;\n \n pub use char::Char;\n pub use clone::Clone;\n-pub use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater, Equiv};\n+pub use cmp::{PartialEq, PartialOrd, TotalEq, TotalOrd};\n+pub use cmp::{Ordering, Less, Equal, Greater, Equiv};\n pub use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n pub use iter::{FromIterator, Extendable};\n pub use iter::{Iterator, DoubleEndedIterator, RandomAccessIterator, CloneableIterator};"}, {"sha": "442838b3d08e668b6331c363a2fb32cf363c0b4e", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -93,7 +93,7 @@ use intrinsics;\n use iter::{range, Iterator};\n use option::{Some, None, Option};\n \n-#[cfg(not(test))] use cmp::{Eq, TotalEq, Ord, Equiv};\n+#[cfg(not(test))] use cmp::{PartialEq, TotalEq, PartialOrd, Equiv};\n \n /// Return the offset of the first null pointer in `buf`.\n #[inline]\n@@ -386,7 +386,7 @@ impl<T> RawPtr<T> for *mut T {\n \n // Equality for pointers\n #[cfg(not(test))]\n-impl<T> Eq for *T {\n+impl<T> PartialEq for *T {\n     #[inline]\n     fn eq(&self, other: &*T) -> bool {\n         *self == *other\n@@ -399,7 +399,7 @@ impl<T> Eq for *T {\n impl<T> TotalEq for *T {}\n \n #[cfg(not(test))]\n-impl<T> Eq for *mut T {\n+impl<T> PartialEq for *mut T {\n     #[inline]\n     fn eq(&self, other: &*mut T) -> bool {\n         *self == *other\n@@ -430,9 +430,9 @@ impl<T> Equiv<*T> for *mut T {\n #[cfg(not(test))]\n mod externfnpointers {\n     use mem;\n-    use cmp::Eq;\n+    use cmp::PartialEq;\n \n-    impl<_R> Eq for extern \"C\" fn() -> _R {\n+    impl<_R> PartialEq for extern \"C\" fn() -> _R {\n         #[inline]\n         fn eq(&self, other: &extern \"C\" fn() -> _R) -> bool {\n             let self_: *() = unsafe { mem::transmute(*self) };\n@@ -442,7 +442,7 @@ mod externfnpointers {\n     }\n     macro_rules! fnptreq(\n         ($($p:ident),*) => {\n-            impl<_R,$($p),*> Eq for extern \"C\" fn($($p),*) -> _R {\n+            impl<_R,$($p),*> PartialEq for extern \"C\" fn($($p),*) -> _R {\n                 #[inline]\n                 fn eq(&self, other: &extern \"C\" fn($($p),*) -> _R) -> bool {\n                     let self_: *() = unsafe { mem::transmute(*self) };\n@@ -461,13 +461,13 @@ mod externfnpointers {\n \n // Comparison for pointers\n #[cfg(not(test))]\n-impl<T> Ord for *T {\n+impl<T> PartialOrd for *T {\n     #[inline]\n     fn lt(&self, other: &*T) -> bool { *self < *other }\n }\n \n #[cfg(not(test))]\n-impl<T> Ord for *mut T {\n+impl<T> PartialOrd for *mut T {\n     #[inline]\n     fn lt(&self, other: &*mut T) -> bool { *self < *other }\n }"}, {"sha": "f3ec95d9582475643aba6e0d097c3d09fa790aee", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -275,15 +275,15 @@\n //! will not resume after failure, that failure is catastrophic.\n \n use clone::Clone;\n-use cmp::Eq;\n+use cmp::PartialEq;\n use std::fmt::Show;\n use iter::{Iterator, FromIterator};\n use option::{None, Option, Some};\n \n /// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n ///\n /// See the [`std::result`](index.html) module documentation for details.\n-#[deriving(Clone, Eq, Ord, TotalEq, TotalOrd, Show)]\n+#[deriving(Clone, PartialEq, PartialOrd, TotalEq, TotalOrd, Show)]\n #[must_use]\n pub enum Result<T, E> {\n     /// Contains the success value"}, {"sha": "9771d766e65fe76edd3d74e3d26166ec45ab3b17", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -15,7 +15,7 @@\n use mem::transmute;\n use clone::Clone;\n use container::Container;\n-use cmp::{Eq, TotalOrd, Ordering, Less, Equal, Greater};\n+use cmp::{PartialEq, TotalOrd, Ordering, Less, Equal, Greater};\n use cmp;\n use default::Default;\n use iter::*;\n@@ -249,11 +249,11 @@ impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n pub mod traits {\n     use super::*;\n \n-    use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Equiv};\n+    use cmp::{PartialEq, PartialOrd, TotalEq, TotalOrd, Ordering, Equiv};\n     use iter::{order, Iterator};\n     use container::Container;\n \n-    impl<'a,T:Eq> Eq for &'a [T] {\n+    impl<'a,T:PartialEq> PartialEq for &'a [T] {\n         fn eq(&self, other: & &'a [T]) -> bool {\n             self.len() == other.len() &&\n                 order::eq(self.iter(), other.iter())\n@@ -264,7 +264,7 @@ pub mod traits {\n         }\n     }\n \n-    impl<T:Eq> Eq for ~[T] {\n+    impl<T:PartialEq> PartialEq for ~[T] {\n         #[inline]\n         fn eq(&self, other: &~[T]) -> bool { self.as_slice() == *other }\n         #[inline]\n@@ -275,12 +275,12 @@ pub mod traits {\n \n     impl<T:TotalEq> TotalEq for ~[T] {}\n \n-    impl<'a,T:Eq, V: Vector<T>> Equiv<V> for &'a [T] {\n+    impl<'a,T:PartialEq, V: Vector<T>> Equiv<V> for &'a [T] {\n         #[inline]\n         fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n     }\n \n-    impl<'a,T:Eq, V: Vector<T>> Equiv<V> for ~[T] {\n+    impl<'a,T:PartialEq, V: Vector<T>> Equiv<V> for ~[T] {\n         #[inline]\n         fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n     }\n@@ -296,7 +296,7 @@ pub mod traits {\n         fn cmp(&self, other: &~[T]) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n     }\n \n-    impl<'a, T: Ord> Ord for &'a [T] {\n+    impl<'a, T: PartialOrd> PartialOrd for &'a [T] {\n         fn lt(&self, other: & &'a [T]) -> bool {\n             order::lt(self.iter(), other.iter())\n         }\n@@ -314,7 +314,7 @@ pub mod traits {\n         }\n     }\n \n-    impl<T: Ord> Ord for ~[T] {\n+    impl<T: PartialOrd> PartialOrd for ~[T] {\n         #[inline]\n         fn lt(&self, other: &~[T]) -> bool { self.as_slice() < other.as_slice() }\n         #[inline]\n@@ -692,8 +692,8 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     }\n }\n \n-/// Extension methods for vectors contain `Eq` elements.\n-pub trait ImmutableEqVector<T:Eq> {\n+/// Extension methods for vectors contain `PartialEq` elements.\n+pub trait ImmutableEqVector<T:PartialEq> {\n     /// Find the first index containing a matching value\n     fn position_elem(&self, t: &T) -> Option<uint>;\n \n@@ -710,7 +710,7 @@ pub trait ImmutableEqVector<T:Eq> {\n     fn ends_with(&self, needle: &[T]) -> bool;\n }\n \n-impl<'a,T:Eq> ImmutableEqVector<T> for &'a [T] {\n+impl<'a,T:PartialEq> ImmutableEqVector<T> for &'a [T] {\n     #[inline]\n     fn position_elem(&self, x: &T) -> Option<uint> {\n         self.iter().position(|y| *x == *y)"}, {"sha": "a19e720446b440527e3d2b89df951ecd3c464066", "filename": "src/libcore/str.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -16,7 +16,7 @@ use mem;\n use char;\n use clone::Clone;\n use cmp;\n-use cmp::{Eq, TotalEq};\n+use cmp::{PartialEq, TotalEq};\n use container::Container;\n use default::Default;\n use iter::{Filter, Map, Iterator};\n@@ -696,7 +696,7 @@ pub struct Utf16Items<'a> {\n     iter: slice::Items<'a, u16>\n }\n /// The possibilities for values decoded from a `u16` stream.\n-#[deriving(Eq, TotalEq, Clone, Show)]\n+#[deriving(PartialEq, TotalEq, Clone, Show)]\n pub enum Utf16Item {\n     /// A valid codepoint.\n     ScalarValue(char),\n@@ -930,7 +930,7 @@ Section: Trait implementations\n #[allow(missing_doc)]\n pub mod traits {\n     use container::Container;\n-    use cmp::{TotalOrd, Ordering, Less, Equal, Greater, Eq, Ord, Equiv, TotalEq};\n+    use cmp::{TotalOrd, Ordering, Less, Equal, Greater, PartialEq, PartialOrd, Equiv, TotalEq};\n     use iter::Iterator;\n     use option::{Some, None};\n     use str::{Str, StrSlice, eq_slice};\n@@ -950,7 +950,7 @@ pub mod traits {\n         }\n     }\n \n-    impl<'a> Eq for &'a str {\n+    impl<'a> PartialEq for &'a str {\n         #[inline]\n         fn eq(&self, other: & &'a str) -> bool {\n             eq_slice((*self), (*other))\n@@ -961,7 +961,7 @@ pub mod traits {\n \n     impl<'a> TotalEq for &'a str {}\n \n-    impl<'a> Ord for &'a str {\n+    impl<'a> PartialOrd for &'a str {\n         #[inline]\n         fn lt(&self, other: & &'a str) -> bool { self.cmp(other) == Less }\n     }"}, {"sha": "7639700eac9aa157751ea2e1ec9bac7ecb2a3f60", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -27,9 +27,9 @@\n //! traits, then a tuple itself also implements it.\n //!\n //! * `Clone`\n-//! * `Eq`\n+//! * `PartialEq`\n //! * `TotalEq`\n-//! * `Ord`\n+//! * `PartialOrd`\n //! * `TotalOrd`\n //! * `Default`\n //!\n@@ -109,7 +109,7 @@ macro_rules! tuple_impls {\n             }\n \n             #[cfg(not(test))]\n-            impl<$($T:Eq),+> Eq for ($($T,)+) {\n+            impl<$($T:PartialEq),+> PartialEq for ($($T,)+) {\n                 #[inline]\n                 fn eq(&self, other: &($($T,)+)) -> bool {\n                     $(*self.$refN() == *other.$refN())&&+\n@@ -124,7 +124,7 @@ macro_rules! tuple_impls {\n             impl<$($T:TotalEq),+> TotalEq for ($($T,)+) {}\n \n             #[cfg(not(test))]\n-            impl<$($T:Ord + Eq),+> Ord for ($($T,)+) {\n+            impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+) {\n                 #[inline]\n                 fn lt(&self, other: &($($T,)+)) -> bool {\n                     lexical_ord!(lt, $(self.$refN(), other.$refN()),+)\n@@ -335,13 +335,13 @@ mod tests {\n \n         let nan = 0.0/0.0;\n \n-        // Eq\n+        // PartialEq\n         assert_eq!(small, small);\n         assert_eq!(big, big);\n         assert!(small != big);\n         assert!(big != small);\n \n-        // Ord\n+        // PartialOrd\n         assert!(small < big);\n         assert!(!(small < small));\n         assert!(!(big < small));"}, {"sha": "bcdeb2bf329dd48e55ae260169784ab2ef8da000", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -26,7 +26,7 @@ use std::str;\n \n /// A piece is a portion of the format string which represents the next part\n /// to emit. These are emitted as a stream by the `Parser` class.\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum Piece<'a> {\n     /// A literal string which should directly be emitted\n     String(&'a str),\n@@ -39,7 +39,7 @@ pub enum Piece<'a> {\n }\n \n /// Representation of an argument specification.\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub struct Argument<'a> {\n     /// Where to find this argument\n     pub position: Position<'a>,\n@@ -50,7 +50,7 @@ pub struct Argument<'a> {\n }\n \n /// Specification for the formatting of an argument in the format string.\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub struct FormatSpec<'a> {\n     /// Optionally specified character to fill alignment with\n     pub fill: Option<char>,\n@@ -69,7 +69,7 @@ pub struct FormatSpec<'a> {\n }\n \n /// Enum describing where an argument for a format can be located.\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum Position<'a> {\n     /// The argument will be in the next position. This is the default.\n     ArgumentNext,\n@@ -80,7 +80,7 @@ pub enum Position<'a> {\n }\n \n /// Enum of alignments which are supported.\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum Alignment {\n     /// The value will be aligned to the left.\n     AlignLeft,\n@@ -92,7 +92,7 @@ pub enum Alignment {\n \n /// Various flags which can be applied to format strings. The meaning of these\n /// flags is defined by the formatters themselves.\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum Flag {\n     /// A `+` will be used to denote positive numbers.\n     FlagSignPlus,\n@@ -108,7 +108,7 @@ pub enum Flag {\n \n /// A count is used for the precision and width parameters of an integer, and\n /// can reference either an argument or a literal integer.\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum Count<'a> {\n     /// The count is specified explicitly.\n     CountIs(uint),\n@@ -124,7 +124,7 @@ pub enum Count<'a> {\n \n /// Enum describing all of the possible methods which the formatting language\n /// currently supports.\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum Method<'a> {\n     /// A plural method selects on an integer over a list of either integer or\n     /// keyword-defined clauses. The meaning of the keywords is defined by the\n@@ -146,7 +146,7 @@ pub enum Method<'a> {\n }\n \n /// A selector for what pluralization a plural method should take\n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(PartialEq, TotalEq, Hash)]\n pub enum PluralSelector {\n     /// One of the plural keywords should be used\n     Keyword(PluralKeyword),\n@@ -155,7 +155,7 @@ pub enum PluralSelector {\n }\n \n /// Structure representing one \"arm\" of the `plural` function.\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub struct PluralArm<'a> {\n     /// A selector can either be specified by a keyword or with an integer\n     /// literal.\n@@ -168,7 +168,7 @@ pub struct PluralArm<'a> {\n /// is specially placed in the `Plural` variant of `Method`.\n ///\n /// http://www.icu-project.org/apiref/icu4c/classicu_1_1PluralRules.html\n-#[deriving(Eq, TotalEq, Hash, Show)]\n+#[deriving(PartialEq, TotalEq, Hash, Show)]\n #[allow(missing_doc)]\n pub enum PluralKeyword {\n     /// The plural form for zero objects.\n@@ -184,7 +184,7 @@ pub enum PluralKeyword {\n }\n \n /// Structure representing one \"arm\" of the `select` function.\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub struct SelectArm<'a> {\n     /// String selector which guards this arm\n     pub selector: &'a str,"}, {"sha": "0311c3339241a5a2a9505126e2e5f7de3a2198ca", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -92,13 +92,13 @@\n #[cfg(test)] extern crate debug;\n #[cfg(test)] #[phase(syntax, link)] extern crate log;\n \n-use std::cmp::Eq;\n+use std::cmp::PartialEq;\n use std::result::{Err, Ok};\n use std::result;\n use std::string::String;\n \n /// Name of an option. Either a string or a single char.\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub enum Name {\n     /// A string representing the long name of an option.\n     /// For example: \"help\"\n@@ -109,7 +109,7 @@ pub enum Name {\n }\n \n /// Describes whether an option has an argument.\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub enum HasArg {\n     /// The option requires an argument.\n     Yes,\n@@ -120,7 +120,7 @@ pub enum HasArg {\n }\n \n /// Describes how often an option may occur.\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub enum Occur {\n     /// The option occurs once.\n     Req,\n@@ -131,7 +131,7 @@ pub enum Occur {\n }\n \n /// A description of a possible option.\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub struct Opt {\n     /// Name of the option\n     pub name: Name,\n@@ -145,7 +145,7 @@ pub struct Opt {\n \n /// One group of options, e.g., both -h and --help, along with\n /// their shared description and properties.\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub struct OptGroup {\n     /// Short Name of the `OptGroup`\n     pub short_name: String,\n@@ -162,15 +162,15 @@ pub struct OptGroup {\n }\n \n /// Describes wether an option is given at all or has a value.\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n enum Optval {\n     Val(String),\n     Given,\n }\n \n /// The result of checking command line arguments. Contains a vector\n /// of matches and a vector of free strings.\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub struct Matches {\n     /// Options that matched\n     opts: Vec<Opt> ,\n@@ -183,7 +183,7 @@ pub struct Matches {\n /// The type returned when the command line does not conform to the\n /// expected format. Call the `to_err_msg` method to retrieve the\n /// error as a string.\n-#[deriving(Clone, Eq, Show)]\n+#[deriving(Clone, PartialEq, Show)]\n pub enum Fail_ {\n     /// The option requires an argument but none was passed.\n     ArgumentMissing(String),\n@@ -198,7 +198,7 @@ pub enum Fail_ {\n }\n \n /// The type of failure that occurred.\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n #[allow(missing_doc)]\n pub enum FailType {\n     ArgumentMissing_,"}, {"sha": "8db8f0dac10229230017d72e1626a0625c0d8762", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -198,12 +198,12 @@ fn list_dir_sorted(path: &Path) -> Option<Vec<Path>> {\n /**\n  * A compiled Unix shell style pattern.\n  */\n-#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, Hash, Default)]\n+#[deriving(Clone, PartialEq, TotalEq, PartialOrd, TotalOrd, Hash, Default)]\n pub struct Pattern {\n     tokens: Vec<PatternToken>,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, PartialOrd, TotalOrd, Hash)]\n enum PatternToken {\n     Char(char),\n     AnyChar,\n@@ -212,13 +212,13 @@ enum PatternToken {\n     AnyExcept(Vec<CharSpecifier> )\n }\n \n-#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, PartialOrd, TotalOrd, Hash)]\n enum CharSpecifier {\n     SingleChar(char),\n     CharRange(char, char)\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n enum MatchResult {\n     Match,\n     SubPatternDoesntMatch,\n@@ -596,7 +596,7 @@ fn chars_eq(a: char, b: char, case_sensitive: bool) -> bool {\n /**\n  * Configuration options to modify the behaviour of `Pattern::matches_with(..)`\n  */\n-#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, Hash, Default)]\n+#[deriving(Clone, PartialEq, TotalEq, PartialOrd, TotalOrd, Hash, Default)]\n pub struct MatchOptions {\n \n     /**"}, {"sha": "e410d2719b14781635435501f7771b5fd438b431", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -105,7 +105,7 @@ pub struct Scheduler {\n \n /// An indication of how hard to work on a given operation, the difference\n /// mainly being whether memory is synchronized or not\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n enum EffortLevel {\n     DontTryTooHard,\n     GiveItYourBest"}, {"sha": "11df847122b3fd41e2de032714aedc8dce04d8c6", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -172,7 +172,7 @@ struct DefaultLogger {\n }\n \n /// Wraps the log level with fmt implementations.\n-#[deriving(Eq, Ord)]\n+#[deriving(PartialEq, PartialOrd)]\n pub struct LogLevel(pub u32);\n \n impl fmt::Show for LogLevel {"}, {"sha": "9264cb541a9b25af61be74f2c7740d2b5d83ed2c", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -83,15 +83,15 @@ pub struct BigUint {\n     data: Vec<BigDigit>\n }\n \n-impl Eq for BigUint {\n+impl PartialEq for BigUint {\n     #[inline]\n     fn eq(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Equal => true, _ => false }\n     }\n }\n impl TotalEq for BigUint {}\n \n-impl Ord for BigUint {\n+impl PartialOrd for BigUint {\n     #[inline]\n     fn lt(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Less => true, _ => false}\n@@ -786,7 +786,7 @@ fn get_radix_base(radix: uint) -> (DoubleBigDigit, uint) {\n }\n \n /// A Sign is a `BigInt`'s composing element.\n-#[deriving(Eq, Ord, TotalEq, TotalOrd, Clone, Show)]\n+#[deriving(PartialEq, PartialOrd, TotalEq, TotalOrd, Clone, Show)]\n pub enum Sign { Minus, Zero, Plus }\n \n impl Neg<Sign> for Sign {\n@@ -808,7 +808,7 @@ pub struct BigInt {\n     data: BigUint\n }\n \n-impl Eq for BigInt {\n+impl PartialEq for BigInt {\n     #[inline]\n     fn eq(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Equal => true, _ => false }\n@@ -817,7 +817,7 @@ impl Eq for BigInt {\n \n impl TotalEq for BigInt {}\n \n-impl Ord for BigInt {\n+impl PartialOrd for BigInt {\n     #[inline]\n     fn lt(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Less => true, _ => false}"}, {"sha": "7febeb2661658571d0d46decd4a4b85e8241a29e", "filename": "src/libnum/complex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fcomplex.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -18,7 +18,7 @@ use std::num::{Zero,One,ToStrRadix};\n // probably doesn't map to C's _Complex correctly.\n \n /// A complex number in Cartesian form.\n-#[deriving(Eq,Clone)]\n+#[deriving(PartialEq,Clone)]\n pub struct Complex<T> {\n     /// Real portion of the complex number\n     pub re: T,\n@@ -164,7 +164,7 @@ impl<T: Clone + Num> One for Complex<T> {\n }\n \n /* string conversions */\n-impl<T: fmt::Show + Num + Ord> fmt::Show for Complex<T> {\n+impl<T: fmt::Show + Num + PartialOrd> fmt::Show for Complex<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.im < Zero::zero() {\n             write!(f, \"{}-{}i\", self.re, -self.im)\n@@ -174,7 +174,7 @@ impl<T: fmt::Show + Num + Ord> fmt::Show for Complex<T> {\n     }\n }\n \n-impl<T: ToStrRadix + Num + Ord> ToStrRadix for Complex<T> {\n+impl<T: ToStrRadix + Num + PartialOrd> ToStrRadix for Complex<T> {\n     fn to_str_radix(&self, radix: uint) -> String {\n         if self.im < Zero::zero() {\n             format!(\"{}-{}i\","}, {"sha": "29cf769ffc9d829fb5bfd908e6ac6afd73da85b3", "filename": "src/libnum/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibnum%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibnum%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Flib.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -60,7 +60,7 @@ pub mod bigint;\n pub mod rational;\n pub mod complex;\n \n-pub trait Integer: Num + Ord\n+pub trait Integer: Num + PartialOrd\n                  + Div<Self, Self>\n                  + Rem<Self, Self> {\n     /// Simultaneous truncated integer division and modulus"}, {"sha": "71a23a23a26790304d1f3d12be5edbaf1070f820", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -34,7 +34,7 @@ pub type Rational64 = Ratio<i64>;\n /// Alias for arbitrary precision rationals.\n pub type BigRational = Ratio<BigInt>;\n \n-impl<T: Clone + Integer + Ord>\n+impl<T: Clone + Integer + PartialOrd>\n     Ratio<T> {\n     /// Create a ratio representing the integer `t`.\n     #[inline]\n@@ -192,14 +192,14 @@ macro_rules! cmp_impl {\n         }\n     };\n }\n-cmp_impl!(impl Eq, eq, ne)\n-cmp_impl!(impl Ord, lt, gt, le, ge)\n+cmp_impl!(impl PartialEq, eq, ne)\n+cmp_impl!(impl PartialOrd, lt, gt, le, ge)\n cmp_impl!(impl TotalEq, )\n cmp_impl!(impl TotalOrd, cmp -> cmp::Ordering)\n \n /* Arithmetic */\n // a/b * c/d = (a*c)/(b*d)\n-impl<T: Clone + Integer + Ord>\n+impl<T: Clone + Integer + PartialOrd>\n     Mul<Ratio<T>,Ratio<T>> for Ratio<T> {\n     #[inline]\n     fn mul(&self, rhs: &Ratio<T>) -> Ratio<T> {\n@@ -208,7 +208,7 @@ impl<T: Clone + Integer + Ord>\n }\n \n // (a/b) / (c/d) = (a*d)/(b*c)\n-impl<T: Clone + Integer + Ord>\n+impl<T: Clone + Integer + PartialOrd>\n     Div<Ratio<T>,Ratio<T>> for Ratio<T> {\n     #[inline]\n     fn div(&self, rhs: &Ratio<T>) -> Ratio<T> {\n@@ -219,7 +219,7 @@ impl<T: Clone + Integer + Ord>\n // Abstracts the a/b `op` c/d = (a*d `op` b*d) / (b*d) pattern\n macro_rules! arith_impl {\n     (impl $imp:ident, $method:ident) => {\n-        impl<T: Clone + Integer + Ord>\n+        impl<T: Clone + Integer + PartialOrd>\n             $imp<Ratio<T>,Ratio<T>> for Ratio<T> {\n             #[inline]\n             fn $method(&self, rhs: &Ratio<T>) -> Ratio<T> {\n@@ -239,7 +239,7 @@ arith_impl!(impl Sub, sub)\n // a/b % c/d = (a*d % b*c)/(b*d)\n arith_impl!(impl Rem, rem)\n \n-impl<T: Clone + Integer + Ord>\n+impl<T: Clone + Integer + PartialOrd>\n     Neg<Ratio<T>> for Ratio<T> {\n     #[inline]\n     fn neg(&self) -> Ratio<T> {\n@@ -248,7 +248,7 @@ impl<T: Clone + Integer + Ord>\n }\n \n /* Constants */\n-impl<T: Clone + Integer + Ord>\n+impl<T: Clone + Integer + PartialOrd>\n     Zero for Ratio<T> {\n     #[inline]\n     fn zero() -> Ratio<T> {\n@@ -261,15 +261,15 @@ impl<T: Clone + Integer + Ord>\n     }\n }\n \n-impl<T: Clone + Integer + Ord>\n+impl<T: Clone + Integer + PartialOrd>\n     One for Ratio<T> {\n     #[inline]\n     fn one() -> Ratio<T> {\n         Ratio::new_raw(One::one(), One::one())\n     }\n }\n \n-impl<T: Clone + Integer + Ord>\n+impl<T: Clone + Integer + PartialOrd>\n     Num for Ratio<T> {}\n \n /* String conversions */\n@@ -288,7 +288,7 @@ impl<T: ToStrRadix> ToStrRadix for Ratio<T> {\n     }\n }\n \n-impl<T: FromStr + Clone + Integer + Ord>\n+impl<T: FromStr + Clone + Integer + PartialOrd>\n     FromStr for Ratio<T> {\n     /// Parses `numer/denom`.\n     fn from_str(s: &str) -> Option<Ratio<T>> {\n@@ -305,7 +305,7 @@ impl<T: FromStr + Clone + Integer + Ord>\n         })\n     }\n }\n-impl<T: FromStrRadix + Clone + Integer + Ord>\n+impl<T: FromStrRadix + Clone + Integer + PartialOrd>\n     FromStrRadix for Ratio<T> {\n     /// Parses `numer/denom` where the numbers are in base `radix`.\n     fn from_str_radix(s: &str, radix: uint) -> Option<Ratio<T>> {"}, {"sha": "2e3c0394747535a1c7fd66562e90cef69cb9d230", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -260,7 +260,7 @@ mod tests {\n     use {Rng, Rand};\n     use super::{RandSample, WeightedChoice, Weighted, Sample, IndependentSample};\n \n-    #[deriving(Eq, Show)]\n+    #[deriving(PartialEq, Show)]\n     struct ConstRand(uint);\n     impl Rand for ConstRand {\n         fn rand<R: Rng>(_: &mut R) -> ConstRand {"}, {"sha": "13f6d2e81c0644d829fa8811070d972cb5a641ec", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -54,7 +54,7 @@ pub struct Range<X> {\n     accept_zone: X\n }\n \n-impl<X: SampleRange + Ord> Range<X> {\n+impl<X: SampleRange + PartialOrd> Range<X> {\n     /// Create a new `Range` instance that samples uniformly from\n     /// `[low, high)`. Fails if `low >= high`.\n     pub fn new(low: X, high: X) -> Range<X> {"}, {"sha": "3ed086e9b13ccc0d9207a94e234b2a6c120c825a", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -182,7 +182,7 @@ pub trait Rng {\n     /// let m: f64 = rng.gen_range(-40.0, 1.3e5);\n     /// println!(\"{}\", m);\n     /// ```\n-    fn gen_range<T: Ord + SampleRange>(&mut self, low: T, high: T) -> T {\n+    fn gen_range<T: PartialOrd + SampleRange>(&mut self, low: T, high: T) -> T {\n         assert!(low < high, \"Rng.gen_range called with low >= high\");\n         Range::new(low, high).ind_sample(self)\n     }"}, {"sha": "bd2e454a9f811b78d634a364a9e032e8b1584283", "filename": "src/libregex/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibregex%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibregex%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse%2Fmod.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -67,7 +67,7 @@ pub enum Ast {\n     Rep(Box<Ast>, Repeater, Greed),\n }\n \n-#[deriving(Show, Eq, Clone)]\n+#[deriving(Show, PartialEq, Clone)]\n pub enum Repeater {\n     ZeroOne,\n     ZeroMore,"}, {"sha": "95c08d6a41ec60274ea685833cf9c3e544672ff3", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -45,7 +45,7 @@ use syntax::attr::AttrMetaMethods;\n use syntax::crateid::CrateId;\n use syntax::parse::token;\n \n-#[deriving(Clone, Eq, Ord, TotalOrd, TotalEq)]\n+#[deriving(Clone, PartialEq, PartialOrd, TotalOrd, TotalEq)]\n pub enum OutputType {\n     OutputTypeBitcode,\n     OutputTypeAssembly,"}, {"sha": "1fce6eaf8e1b075062abc8ba765daf4ce218feda", "filename": "src/librustc/back/svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fback%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fback%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fsvh.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -53,7 +53,7 @@ use std::iter::range_step;\n use syntax::ast;\n use syntax::visit;\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub struct Svh {\n     hash: String,\n }"}, {"sha": "db934c7a4045f0decbc5f2437772ea8ead546ad0", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -46,15 +46,15 @@ pub struct Config {\n     pub uint_type: UintTy,\n }\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub enum OptLevel {\n     No, // -O0\n     Less, // -O1\n     Default, // -O2\n     Aggressive // -O3\n }\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub enum DebugInfoLevel {\n     NoDebugInfo,\n     LimitedDebugInfo,\n@@ -125,14 +125,14 @@ pub fn basic_options() -> Options {\n // users can have their own entry\n // functions that don't start a\n // scheduler\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum EntryFnType {\n     EntryMain,\n     EntryStart,\n     EntryNone,\n }\n \n-#[deriving(Eq, Ord, Clone, TotalOrd, TotalEq, Hash)]\n+#[deriving(PartialEq, PartialOrd, Clone, TotalOrd, TotalEq, Hash)]\n pub enum CrateType {\n     CrateTypeExecutable,\n     CrateTypeDylib,"}, {"sha": "a6c2d75dc0d4f2f3ef5d3221a5f4c82b01691187", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -29,7 +29,7 @@ pub static False: Bool = 0 as Bool;\n \n // Consts for the LLVM CallConv type, pre-cast to uint.\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum CallConv {\n     CCallConv = 0,\n     FastCallConv = 8,\n@@ -156,7 +156,7 @@ pub enum RealPredicate {\n \n // The LLVM TypeKind type - must stay in sync with the def of\n // LLVMTypeKind in llvm/include/llvm-c/Core.h\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n #[repr(C)]\n pub enum TypeKind {\n     Void      = 0,\n@@ -226,7 +226,7 @@ pub enum AsmDialect {\n     AD_Intel = 1\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n #[repr(C)]\n pub enum CodeGenOptLevel {\n     CodeGenLevelNone = 0,"}, {"sha": "8aeef3dca98677434e4cd92cb94a532c8006f766", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -114,7 +114,7 @@ pub static tag_items_data_item_reexport_def_id: uint = 0x39;\n pub static tag_items_data_item_reexport_name: uint = 0x3a;\n \n // used to encode crate_ctxt side tables\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n #[repr(uint)]\n pub enum astencode_tag { // Reserves 0x40 -- 0x5f\n     tag_ast = 0x40,"}, {"sha": "b355ede72c6ee5c9a6a021199ff7ff74f27e0a39", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -45,13 +45,13 @@ pub struct crate_metadata {\n     pub span: Span,\n }\n \n-#[deriving(Show, Eq, Clone)]\n+#[deriving(Show, PartialEq, Clone)]\n pub enum LinkagePreference {\n     RequireDynamic,\n     RequireStatic,\n }\n \n-#[deriving(Eq, FromPrimitive)]\n+#[deriving(PartialEq, FromPrimitive)]\n pub enum NativeLibaryKind {\n     NativeStatic,    // native static library (.a archive)\n     NativeFramework, // OSX-specific\n@@ -60,7 +60,7 @@ pub enum NativeLibaryKind {\n \n // Where a crate came from on the local filesystem. One of these two options\n // must be non-None.\n-#[deriving(Eq, Clone)]\n+#[deriving(PartialEq, Clone)]\n pub struct CrateSource {\n     pub dylib: Option<Path>,\n     pub rlib: Option<Path>,"}, {"sha": "30b40369c105aae70f8a4624c8ddf2847510c453", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -103,7 +103,7 @@ fn lookup_item<'a>(item_id: ast::NodeId, data: &'a [u8]) -> ebml::Doc<'a> {\n     find_item(item_id, items)\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n enum Family {\n     ImmStatic,             // c\n     MutStatic,             // b"}, {"sha": "140bfcd684ad14c879c267a2f1405a2d6979248e", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -82,7 +82,7 @@ pub fn check_loans(bccx: &BorrowckCtxt,\n     clcx.visit_block(body, ());\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n enum MoveError {\n     MoveOk,\n     MoveWhileBorrowed(/*loan*/Rc<LoanPath>, /*loan*/Span)"}, {"sha": "c1f8ea4d00cb705ca593e96d252e8aef6a63b055", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -166,7 +166,7 @@ pub struct BorrowStats {\n \n pub type BckResult<T> = Result<T, BckError>;\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum PartialTotal {\n     Partial,   // Loan affects some portion\n     Total      // Loan affects entire path\n@@ -188,13 +188,13 @@ pub struct Loan {\n     cause: euv::LoanCause,\n }\n \n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(PartialEq, TotalEq, Hash)]\n pub enum LoanPath {\n     LpVar(ast::NodeId),               // `x` in doc.rs\n     LpExtend(Rc<LoanPath>, mc::MutabilityCategory, LoanPathElem)\n }\n \n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(PartialEq, TotalEq, Hash)]\n pub enum LoanPathElem {\n     LpDeref(mc::PointerKind),    // `*LV` in doc.rs\n     LpInterior(mc::InteriorKind) // `LV.f` in doc.rs\n@@ -267,7 +267,7 @@ pub struct Restriction {\n     set: RestrictionSet\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub struct RestrictionSet {\n     bits: u32\n }\n@@ -305,7 +305,7 @@ impl Repr for RestrictionSet {\n // Errors\n \n // Errors that can occur\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum bckerr_code {\n     err_mutbl,\n     err_out_of_scope(ty::Region, ty::Region), // superscope, subscope\n@@ -315,7 +315,7 @@ pub enum bckerr_code {\n \n // Combination of an error code and the categorization of the expression\n // that caused it\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub struct BckError {\n     span: Span,\n     cause: euv::LoanCause,"}, {"sha": "5a95343c6228b862eeafd5b50d9ac81bfce4ba15", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -65,7 +65,7 @@ pub struct FlowedMoveData<'a> {\n }\n \n /// Index into `MoveData.paths`, used like a pointer\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub struct MovePathIndex(uint);\n \n impl MovePathIndex {\n@@ -84,7 +84,7 @@ static InvalidMovePathIndex: MovePathIndex =\n     MovePathIndex(uint::MAX);\n \n /// Index into `MoveData.moves`, used like a pointer\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub struct MoveIndex(uint);\n \n impl MoveIndex {"}, {"sha": "0c677f164d42455538914339dbcc81b1201b05c1", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -15,7 +15,7 @@ use syntax::codemap::Span;\n use syntax::visit::Visitor;\n use syntax::visit;\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n enum Context {\n     Normal, Loop, Closure\n }"}, {"sha": "2053f7dd01b2655f4c0bc28836574de0ea00f9a5", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -215,7 +215,7 @@ enum useful {\n     not_useful,\n }\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n enum ctor {\n     single,\n     variant(DefId),"}, {"sha": "e7ad08d4eb2a5c4c7e7d2a894187a3e18dad55d6", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -288,7 +288,7 @@ pub fn process_crate(krate: &ast::Crate,\n \n // FIXME (#33): this doesn't handle big integer/float literals correctly\n // (nor does the rest of our literal handling).\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub enum const_val {\n     const_float(f64),\n     const_int(i64),\n@@ -514,7 +514,7 @@ pub fn lit_to_const(lit: &Lit) -> const_val {\n     }\n }\n \n-fn compare_vals<T: Ord>(a: T, b: T) -> Option<int> {\n+fn compare_vals<T: PartialOrd>(a: T, b: T) -> Option<int> {\n     Some(if a == b { 0 } else if a < b { -1 } else { 1 })\n }\n pub fn compare_const_vals(a: &const_val, b: &const_val) -> Option<int> {"}, {"sha": "bc9a1c9b5fc653934b3daeea5c41ae81b93312cb", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -20,7 +20,7 @@ use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n enum UnsafeContext {\n     SafeContext,\n     UnsafeFn,"}, {"sha": "467cd726a65afb6c723858e67fe8d043a3a65a71", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -68,7 +68,7 @@ pub trait Delegate {\n               mode: MutateMode);\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum LoanCause {\n     ClosureCapture(Span),\n     AddrOf,\n@@ -78,13 +78,13 @@ pub enum LoanCause {\n     ClosureInvocation\n }\n \n-#[deriving(Eq,Show)]\n+#[deriving(PartialEq,Show)]\n pub enum ConsumeMode {\n     Copy,    // reference to x where x has a type that copies\n     Move,    // reference to x where x has a type that moves\n }\n \n-#[deriving(Eq,Show)]\n+#[deriving(PartialEq,Show)]\n pub enum MutateMode {\n     JustWrite,    // x = y\n     WriteAndRead, // x += y"}, {"sha": "cd6010127084b42e739fbe1b6c2ddeb0298209d2", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -55,11 +55,11 @@ pub struct Edge<E> {\n     pub data: E,\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub struct NodeIndex(pub uint);\n pub static InvalidNodeIndex: NodeIndex = NodeIndex(uint::MAX);\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub struct EdgeIndex(pub uint);\n pub static InvalidEdgeIndex: EdgeIndex = EdgeIndex(uint::MAX);\n \n@@ -356,7 +356,7 @@ mod test {\n         });\n     }\n \n-    fn test_adjacent_edges<N:Eq,E:Eq>(graph: &Graph<N,E>,\n+    fn test_adjacent_edges<N:PartialEq,E:PartialEq>(graph: &Graph<N,E>,\n                                       start_index: NodeIndex,\n                                       start_data: N,\n                                       expected_incoming: &[(E,N)],"}, {"sha": "d5bd44fd27ce38042732f98d092c9e26db4d17e3", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -42,7 +42,7 @@ macro_rules! lets_do_this {\n         $( $variant:ident, $name:expr, $method:ident; )*\n     ) => {\n \n-#[deriving(FromPrimitive, Eq, TotalEq, Hash)]\n+#[deriving(FromPrimitive, PartialEq, TotalEq, Hash)]\n pub enum LangItem {\n     $($variant),*\n }"}, {"sha": "6cffd15487d435ee0bfba4a40535bfc1aacf76fd", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -72,7 +72,7 @@ use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::{ast, ast_util, visit};\n \n-#[deriving(Clone, Show, Eq, Ord, TotalEq, TotalOrd, Hash)]\n+#[deriving(Clone, Show, PartialEq, PartialOrd, TotalEq, TotalOrd, Hash)]\n pub enum Lint {\n     CTypes,\n     UnusedImports,\n@@ -135,12 +135,12 @@ pub fn level_to_str(lv: Level) -> &'static str {\n     }\n }\n \n-#[deriving(Clone, Eq, Ord, TotalEq, TotalOrd)]\n+#[deriving(Clone, PartialEq, PartialOrd, TotalEq, TotalOrd)]\n pub enum Level {\n     Allow, Warn, Deny, Forbid\n }\n \n-#[deriving(Clone, Eq, Ord, TotalEq, TotalOrd)]\n+#[deriving(Clone, PartialEq, PartialOrd, TotalEq, TotalOrd)]\n pub struct LintSpec {\n     pub default: Level,\n     pub lint: Lint,\n@@ -150,7 +150,7 @@ pub struct LintSpec {\n pub type LintDict = HashMap<&'static str, LintSpec>;\n \n // this is public for the lints that run in trans\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum LintSource {\n     Node(Span),\n     Default,\n@@ -836,7 +836,7 @@ fn check_type_limits(cx: &Context, e: &ast::Expr) {\n         _ => ()\n     };\n \n-    fn is_valid<T:cmp::Ord>(binop: ast::BinOp, v: T,\n+    fn is_valid<T:cmp::PartialOrd>(binop: ast::BinOp, v: T,\n                             min: T, max: T) -> bool {\n         match binop {\n             ast::BiLt => v >  min && v <= max,\n@@ -1650,7 +1650,7 @@ fn check_missing_doc_item(cx: &Context, it: &ast::Item) {\n                             desc);\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n enum MethodContext {\n     TraitDefaultImpl,\n     TraitImpl,"}, {"sha": "ce02243403ff2ea4306e1d182da1345d5c5e4c52", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -123,9 +123,9 @@ use syntax::print::pprust::{expr_to_str, block_to_str};\n use syntax::{visit, ast_util};\n use syntax::visit::{Visitor, FnKind};\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n struct Variable(uint);\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n struct LiveNode(uint);\n \n impl Variable {\n@@ -142,7 +142,7 @@ impl Clone for LiveNode {\n     }\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n enum LiveNodeKind {\n     FreeVarNode(Span),\n     ExprNode(Span),"}, {"sha": "c8cad58a1912d506e35631a54f53ee4ac4e5f08a", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -76,7 +76,7 @@ use syntax::parse::token;\n use std::cell::RefCell;\n use std::rc::Rc;\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub enum categorization {\n     cat_rvalue(ty::Region),            // temporary val, argument is its scope\n     cat_static_item,\n@@ -92,14 +92,14 @@ pub enum categorization {\n     // (*1) downcast is only required if the enum has more than one variant\n }\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub struct CopiedUpvar {\n     pub upvar_id: ast::NodeId,\n     pub onceness: ast::Onceness,\n }\n \n // different kinds of pointers:\n-#[deriving(Clone, Eq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash)]\n pub enum PointerKind {\n     OwnedPtr,\n     GcPtr,\n@@ -109,26 +109,26 @@ pub enum PointerKind {\n \n // We use the term \"interior\" to mean \"something reachable from the\n // base without a pointer dereference\", e.g. a field\n-#[deriving(Clone, Eq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash)]\n pub enum InteriorKind {\n     InteriorField(FieldName),\n     InteriorElement(ElementKind),\n }\n \n-#[deriving(Clone, Eq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash)]\n pub enum FieldName {\n     NamedField(ast::Name),\n     PositionalField(uint)\n }\n \n-#[deriving(Clone, Eq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash)]\n pub enum ElementKind {\n     VecElement,\n     StrElement,\n     OtherElement,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Hash, Show)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash, Show)]\n pub enum MutabilityCategory {\n     McImmutable, // Immutable.\n     McDeclared,  // Directly declared as mutable.\n@@ -149,7 +149,7 @@ pub enum MutabilityCategory {\n // dereference, but its type is the type *before* the dereference\n // (`@T`). So use `cmt.type` to find the type of the value in a consistent\n // fashion. For more details, see the method `cat_pattern`\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub struct cmt_ {\n     pub id: ast::NodeId,          // id of expr/pat producing this value\n     pub span: Span,                // span of same expr/pat"}, {"sha": "4db791ddf7bf9d29a39433dad72a26f65d466f5f", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -87,7 +87,7 @@ pub enum PrivateDep {\n }\n \n // How an import is used.\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum ImportUse {\n     Unused,       // The import is not used.\n     Used,         // The import is used.\n@@ -102,20 +102,20 @@ impl LastPrivate {\n     }\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n enum PatternBindingMode {\n     RefutableMode,\n     LocalIrrefutableMode,\n     ArgumentIrrefutableMode,\n }\n \n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(PartialEq, TotalEq, Hash)]\n enum Namespace {\n     TypeNS,\n     ValueNS\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n enum NamespaceError {\n     NoError,\n     ModuleError,\n@@ -288,7 +288,7 @@ enum ModulePrefixResult {\n     PrefixFound(Rc<Module>, uint)\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n enum NameSearchType {\n     /// We're doing a name search in order to resolve a `use` directive.\n     ImportSearch,\n@@ -306,7 +306,7 @@ enum BareIdentifierPatternResolution {\n \n // Specifies how duplicates should be handled when adding a child item if\n // another item exists with the same name in some namespace.\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n enum DuplicateCheckingMode {\n     ForbidDuplicateModules,\n     ForbidDuplicateTypes,\n@@ -435,7 +435,7 @@ enum ParentLink {\n }\n \n /// The type of module this is.\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n enum ModuleKind {\n     NormalModuleKind,\n     ExternModuleKind,\n@@ -4900,7 +4900,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn find_fallback_in_self_type(&mut self, name: Name) -> FallbackSuggestion {\n-        #[deriving(Eq)]\n+        #[deriving(PartialEq)]\n         enum FallbackChecks {\n             Everything,\n             OnlyTraitAndStatics"}, {"sha": "ddd41072c8d699e8a5365a2b86a60ccfa6afc35c", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -240,7 +240,7 @@ enum Lit {\n     ConstLit(ast::DefId),              // the def ID of the constant\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum VecLenOpt {\n     vec_len_eq,\n     vec_len_ge(/* length of prefix */uint)\n@@ -1215,7 +1215,7 @@ fn pick_col(m: &[Match]) -> uint {\n     return best_col;\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum branch_kind { no_branch, single, switch, compare, compare_vec_len, }\n \n // Compiles a comparison between two things."}, {"sha": "02671b1186631d606f6be3c9b96d43022d9748e6", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -18,7 +18,7 @@ use middle::trans::cabi_mips;\n use middle::trans::type_::Type;\n use syntax::abi::{X86, X86_64, Arm, Mips};\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub enum ArgKind {\n     /// Pass the argument directly using the normal converted\n     /// LLVM type or by coercing to another specified type"}, {"sha": "9f98cf57c09b581de1df33fa28d8c529ff66a771", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -22,7 +22,7 @@ use middle::trans::type_::Type;\n \n use std::cmp;\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n enum RegClass {\n     NoClass,\n     Int,"}, {"sha": "b28db3d378be7dcfd574ce6c7c21ea83bdfb95f1", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -55,7 +55,7 @@ pub enum CleanupScopeKind<'a> {\n     LoopScopeKind(ast::NodeId, [&'a Block<'a>, ..EXIT_MAX])\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum EarlyExitLabel {\n     UnwindExit,\n     ReturnExit,"}, {"sha": "5c24a62d2d51e8a2950e3a2f715ee6d7dfddea1b", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -722,7 +722,7 @@ pub fn expr_ty_adjusted(bcx: &Block, ex: &ast::Expr) -> ty::t {\n }\n \n // Key used to lookup values supplied for type parameters in an expr.\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum ExprOrMethodCall {\n     // Type parameters for a path like `None::<int>`\n     ExprId(ast::NodeId),"}, {"sha": "1ea25665c1c9a83ae3926150cecaeb93ff24135b", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -82,7 +82,7 @@ impl Drop for Rvalue {\n     fn drop(&mut self) { }\n }\n \n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(PartialEq, TotalEq, Hash)]\n pub enum RvalueMode {\n     /// `val` is a pointer to the actual value (and thus has type *T)\n     ByRef,"}, {"sha": "110dc3a18848892fb56684c83f812f15f8102eaf", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -2403,7 +2403,7 @@ fn type_metadata(cx: &CrateContext,\n     type_metadata\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n enum DebugLocation {\n     KnownLocation { scope: DIScope, line: uint, col: uint },\n     UnknownLocation"}, {"sha": "6241c1222f9c3f611820620e39875202b46ab0ef", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -79,7 +79,7 @@ use syntax::print::pprust::{expr_to_str};\n // These are passed around by the code generating functions to track the\n // destination of a computation's value.\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum Dest {\n     SaveIn(ValueRef),\n     Ignore,\n@@ -1497,7 +1497,7 @@ fn float_cast(bcx: &Block,\n     } else { llsrc };\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum cast_kind {\n     cast_pointer,\n     cast_integral,"}, {"sha": "683fb39c9e9071cfd7acba45c54879149bc50a55", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -312,14 +312,14 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n }\n \n // Used to identify cached monomorphized functions and vtables\n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(PartialEq, TotalEq, Hash)]\n pub struct MonoParamId {\n     pub subst: ty::t,\n     // Do we really need the vtables to be hashed? Isn't the type enough?\n     pub vtables: Vec<MonoId>\n }\n \n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(PartialEq, TotalEq, Hash)]\n pub struct MonoId {\n     pub def: ast::DefId,\n     pub params: Vec<MonoParamId>"}, {"sha": "dfe06f9ca4c89a9b87bac7fde066c03b127e1827", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -23,7 +23,7 @@ use std::mem;\n \n use libc::{c_uint};\n \n-#[deriving(Clone, Eq, Show)]\n+#[deriving(Clone, PartialEq, Show)]\n pub struct Type {\n     rf: TypeRef\n }"}, {"sha": "7d3c4beb6740fb5cc74ef095c41559d77ea04e71", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -65,7 +65,7 @@ pub static INITIAL_DISCRIMINANT_VALUE: Disr = 0;\n \n // Data types\n \n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(PartialEq, TotalEq, Hash)]\n pub struct field {\n     pub ident: ast::Ident,\n     pub mt: mt\n@@ -121,13 +121,13 @@ impl Method {\n     }\n }\n \n-#[deriving(Clone, Eq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash)]\n pub struct mt {\n     pub ty: t,\n     pub mutbl: ast::Mutability,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash, Encodable, Decodable, Show)]\n pub enum TraitStore {\n     /// Box<Trait>\n     UniqTraitStore,\n@@ -145,7 +145,7 @@ pub struct field_ty {\n \n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(PartialEq, TotalEq, Hash)]\n pub struct creader_cache_key {\n     pub cnum: CrateNum,\n     pub pos: uint,\n@@ -158,10 +158,10 @@ pub struct intern_key {\n     sty: *sty,\n }\n \n-// NB: Do not replace this with #[deriving(Eq)]. The automatically-derived\n+// NB: Do not replace this with #[deriving(PartialEq)]. The automatically-derived\n // implementation will not recurse through sty and you will get stack\n // exhaustion.\n-impl cmp::Eq for intern_key {\n+impl cmp::PartialEq for intern_key {\n     fn eq(&self, other: &intern_key) -> bool {\n         unsafe {\n             *self.sty == *other.sty\n@@ -185,14 +185,14 @@ pub enum ast_ty_to_ty_cache_entry {\n     atttce_resolved(t)  /* resolved to a type, irrespective of region */\n }\n \n-#[deriving(Clone, Eq, Decodable, Encodable)]\n+#[deriving(Clone, PartialEq, Decodable, Encodable)]\n pub struct ItemVariances {\n     pub self_param: Option<Variance>,\n     pub type_params: OwnedSlice<Variance>,\n     pub region_params: OwnedSlice<Variance>\n }\n \n-#[deriving(Clone, Eq, Decodable, Encodable, Show)]\n+#[deriving(Clone, PartialEq, Decodable, Encodable, Show)]\n pub enum Variance {\n     Covariant,      // T<A> <: T<B> iff A <: B -- e.g., function return type\n     Invariant,      // T<A> <: T<B> iff B == A -- e.g., type of mutable cell\n@@ -216,7 +216,7 @@ pub struct AutoDerefRef {\n     pub autoref: Option<AutoRef>\n }\n \n-#[deriving(Clone, Decodable, Encodable, Eq, Show)]\n+#[deriving(Clone, Decodable, Encodable, PartialEq, Show)]\n pub enum AutoRef {\n     /// Convert from T to &T\n     AutoPtr(Region, ast::Mutability),\n@@ -387,7 +387,7 @@ pub struct t_box_ {\n enum t_opaque {}\n \n #[allow(raw_pointer_deriving)]\n-#[deriving(Clone, Eq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash)]\n pub struct t { inner: *t_opaque }\n \n impl fmt::Show for t {\n@@ -415,14 +415,14 @@ pub fn type_needs_infer(t: t) -> bool {\n }\n pub fn type_id(t: t) -> uint { get(t).id }\n \n-#[deriving(Clone, Eq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash)]\n pub struct BareFnTy {\n     pub fn_style: ast::FnStyle,\n     pub abi: abi::Abi,\n     pub sig: FnSig,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash)]\n pub struct ClosureTy {\n     pub fn_style: ast::FnStyle,\n     pub onceness: ast::Onceness,\n@@ -443,22 +443,22 @@ pub struct ClosureTy {\n  * - `output` is the return type.\n  * - `variadic` indicates whether this is a varidic function. (only true for foreign fns)\n  */\n-#[deriving(Clone, Eq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash)]\n pub struct FnSig {\n     pub binder_id: ast::NodeId,\n     pub inputs: Vec<t>,\n     pub output: t,\n     pub variadic: bool\n }\n \n-#[deriving(Clone, Eq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash)]\n pub struct param_ty {\n     pub idx: uint,\n     pub def_id: DefId\n }\n \n /// Representation of regions:\n-#[deriving(Clone, Eq, TotalEq, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash, Encodable, Decodable, Show)]\n pub enum Region {\n     // Region bound in a type or fn declaration which will be\n     // substituted 'early' -- that is, at the same time when type\n@@ -499,13 +499,13 @@ pub enum Region {\n  * the original var id (that is, the root variable that is referenced\n  * by the upvar) and the id of the closure expression.\n  */\n-#[deriving(Clone, Eq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash)]\n pub struct UpvarId {\n     pub var_id: ast::NodeId,\n     pub closure_expr_id: ast::NodeId,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Hash, Show)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash, Show)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     ImmBorrow,\n@@ -600,7 +600,7 @@ pub enum BorrowKind {\n  *   the closure, so sometimes it is necessary for them to be larger\n  *   than the closure lifetime itself.\n  */\n-#[deriving(Eq, Clone)]\n+#[deriving(PartialEq, Clone)]\n pub struct UpvarBorrow {\n     pub kind: BorrowKind,\n     pub region: ty::Region,\n@@ -618,13 +618,13 @@ impl Region {\n     }\n }\n \n-#[deriving(Clone, Eq, Ord, TotalEq, TotalOrd, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, PartialEq, PartialOrd, TotalEq, TotalOrd, Hash, Encodable, Decodable, Show)]\n pub struct FreeRegion {\n     pub scope_id: NodeId,\n     pub bound_region: BoundRegion\n }\n \n-#[deriving(Clone, Eq, Ord, TotalEq, TotalOrd, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, PartialEq, PartialOrd, TotalEq, TotalOrd, Hash, Encodable, Decodable, Show)]\n pub enum BoundRegion {\n     /// An anonymous region parameter for a given fn (&T)\n     BrAnon(uint),\n@@ -643,7 +643,7 @@ pub enum BoundRegion {\n  * Represents the values to use when substituting lifetime parameters.\n  * If the value is `ErasedRegions`, then this subst is occurring during\n  * trans, and all region parameters will be replaced with `ty::ReStatic`. */\n-#[deriving(Clone, Eq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash)]\n pub enum RegionSubsts {\n     ErasedRegions,\n     NonerasedRegions(OwnedSlice<ty::Region>)\n@@ -666,7 +666,7 @@ pub enum RegionSubsts {\n  * - `self_ty` is the type to which `self` should be remapped, if any.  The\n  *   `self` type is rather funny in that it can only appear on traits and is\n  *   always substituted away to the implementing type for a trait. */\n-#[deriving(Clone, Eq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash)]\n pub struct substs {\n     pub self_ty: Option<ty::t>,\n     pub tps: Vec<t>,\n@@ -722,7 +722,7 @@ mod primitives {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n-#[deriving(Clone, Eq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash)]\n pub enum sty {\n     ty_nil,\n     ty_bot,\n@@ -754,21 +754,21 @@ pub enum sty {\n             // on non-useful type error messages)\n }\n \n-#[deriving(Clone, Eq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash)]\n pub struct TyTrait {\n     pub def_id: DefId,\n     pub substs: substs,\n     pub store: TraitStore,\n     pub bounds: BuiltinBounds\n }\n \n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(PartialEq, TotalEq, Hash)]\n pub struct TraitRef {\n     pub def_id: DefId,\n     pub substs: substs\n }\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub enum IntVarValue {\n     IntType(ast::IntTy),\n     UintType(ast::UintTy),\n@@ -822,15 +822,15 @@ pub enum type_err {\n     terr_variadic_mismatch(expected_found<bool>)\n }\n \n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(PartialEq, TotalEq, Hash)]\n pub struct ParamBounds {\n     pub builtin_bounds: BuiltinBounds,\n     pub trait_bounds: Vec<Rc<TraitRef>>\n }\n \n pub type BuiltinBounds = EnumSet<BuiltinBound>;\n \n-#[deriving(Clone, Encodable, Eq, TotalEq, Decodable, Hash, Show)]\n+#[deriving(Clone, Encodable, PartialEq, TotalEq, Decodable, Hash, Show)]\n #[repr(uint)]\n pub enum BuiltinBound {\n     BoundStatic,\n@@ -862,21 +862,21 @@ impl CLike for BuiltinBound {\n     }\n }\n \n-#[deriving(Clone, Eq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash)]\n pub struct TyVid(pub uint);\n \n-#[deriving(Clone, Eq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash)]\n pub struct IntVid(pub uint);\n \n-#[deriving(Clone, Eq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash)]\n pub struct FloatVid(pub uint);\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct RegionVid {\n     pub id: uint\n }\n \n-#[deriving(Clone, Eq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash)]\n pub enum InferTy {\n     TyVar(TyVid),\n     IntVar(IntVid),\n@@ -889,7 +889,7 @@ pub enum InferRegion {\n     ReSkolemized(uint, BoundRegion)\n }\n \n-impl cmp::Eq for InferRegion {\n+impl cmp::PartialEq for InferRegion {\n     fn eq(&self, other: &InferRegion) -> bool {\n         match ((*self), *other) {\n             (ReVar(rva), ReVar(rvb)) => {\n@@ -2402,7 +2402,7 @@ pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n /// distinguish between types that are recursive with themselves and types that\n /// contain a different recursive type. These cases can therefore be treated\n /// differently when reporting errors.\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum Representability {\n     Representable,\n     SelfRecursive,"}, {"sha": "072b4ea7fe12672a4aecf7190d50db84318635dc", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -758,7 +758,7 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n     }\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum PointerKind {\n     Send,\n     Borrowed,"}, {"sha": "8cea03c59e78a28ba3bf63d459c91296e58dee12", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -106,19 +106,19 @@ use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::owned_slice::OwnedSlice;\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum CheckTraitsFlag {\n     CheckTraitsOnly,\n     CheckTraitsAndInherentMethods,\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum AutoderefReceiverFlag {\n     AutoderefReceiver,\n     DontAutoderefReceiver,\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum StaticMethodsFlag {\n     ReportStaticMethods,\n     IgnoreStaticMethods,"}, {"sha": "70d8deaf03ce7d99db610460586e466fbcf777b4", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -213,7 +213,7 @@ impl FnStyleState {\n /// Whether `check_binop` is part of an assignment or not.\n /// Used to know wether we allow user overloads and to print\n /// better messages on error.\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n enum IsBinopAssignment{\n     SimpleBinop,\n     BinopAssignment,"}, {"sha": "6737a638dd8d24636e61387e864db6500d771667", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -72,19 +72,19 @@ impl LatticeValue for ty::t {\n \n pub trait CombineFieldsLatticeMethods {\n     fn var_sub_var<T:Clone + InferStr + LatticeValue,\n-                   V:Clone + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(&self,\n+                   V:Clone + PartialEq + ToStr + Vid + UnifyVid<Bounds<T>>>(&self,\n                                                                      a_id: V,\n                                                                      b_id: V)\n                                                                      -> ures;\n     /// make variable a subtype of T\n     fn var_sub_t<T:Clone + InferStr + LatticeValue,\n-                 V:Clone + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+                 V:Clone + PartialEq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n                  &self,\n                  a_id: V,\n                  b: T)\n                  -> ures;\n     fn t_sub_var<T:Clone + InferStr + LatticeValue,\n-                 V:Clone + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+                 V:Clone + PartialEq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n                  &self,\n                  a: T,\n                  b_id: V)\n@@ -96,7 +96,7 @@ pub trait CombineFieldsLatticeMethods {\n                  lattice_op: LatticeOp<T>)\n                  -> cres<Bound<T>>;\n     fn set_var_to_merged_bounds<T:Clone + InferStr + LatticeValue,\n-                                V:Clone+Eq+ToStr+Vid+UnifyVid<Bounds<T>>>(\n+                                V:Clone+PartialEq+ToStr+Vid+UnifyVid<Bounds<T>>>(\n                                 &self,\n                                 v_id: V,\n                                 a: &Bounds<T>,\n@@ -112,7 +112,7 @@ pub trait CombineFieldsLatticeMethods {\n \n impl<'f> CombineFieldsLatticeMethods for CombineFields<'f> {\n     fn var_sub_var<T:Clone + InferStr + LatticeValue,\n-                   V:Clone + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+                   V:Clone + PartialEq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n                    &self,\n                    a_id: V,\n                    b_id: V)\n@@ -165,7 +165,7 @@ impl<'f> CombineFieldsLatticeMethods for CombineFields<'f> {\n \n     /// make variable a subtype of T\n     fn var_sub_t<T:Clone + InferStr + LatticeValue,\n-                 V:Clone + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+                 V:Clone + PartialEq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n                  &self,\n                  a_id: V,\n                  b: T)\n@@ -189,7 +189,7 @@ impl<'f> CombineFieldsLatticeMethods for CombineFields<'f> {\n     }\n \n     fn t_sub_var<T:Clone + InferStr + LatticeValue,\n-                 V:Clone + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+                 V:Clone + PartialEq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n                  &self,\n                  a: T,\n                  b_id: V)\n@@ -238,7 +238,7 @@ impl<'f> CombineFieldsLatticeMethods for CombineFields<'f> {\n     }\n \n     fn set_var_to_merged_bounds<T:Clone + InferStr + LatticeValue,\n-                                V:Clone+Eq+ToStr+Vid+UnifyVid<Bounds<T>>>(\n+                                V:Clone+PartialEq+ToStr+Vid+UnifyVid<Bounds<T>>>(\n                                 &self,\n                                 v_id: V,\n                                 a: &Bounds<T>,\n@@ -432,7 +432,7 @@ pub enum LatticeVarResult<V,T> {\n  *   return. */\n pub fn lattice_vars<L:LatticeDir + Combine,\n                     T:Clone + InferStr + LatticeValue,\n-                    V:Clone + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+                    V:Clone + PartialEq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n     this: &L,                           // defines whether we want LUB or GLB\n     a_vid: V,                          // first variable\n     b_vid: V,                          // second variable\n@@ -478,7 +478,7 @@ pub fn lattice_vars<L:LatticeDir + Combine,\n \n pub fn lattice_var_and_t<L:LatticeDir + Combine,\n                          T:Clone + InferStr + LatticeValue,\n-                         V:Clone + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+                         V:Clone + PartialEq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n     this: &L,\n     a_id: V,\n     b: &T,"}, {"sha": "fa52ef5dab6841f4d2f8de91aff5a1cceb5e6e16", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -456,7 +456,7 @@ trait CresCompare<T> {\n     fn compare(&self, t: T, f: || -> ty::type_err) -> cres<T>;\n }\n \n-impl<T:Clone + Eq> CresCompare<T> for cres<T> {\n+impl<T:Clone + PartialEq> CresCompare<T> for cres<T> {\n     fn compare(&self, t: T, f: || -> ty::type_err) -> cres<T> {\n         (*self).clone().and_then(|s| {\n             if s == t {"}, {"sha": "8ec4b52ffd19d388c1d71827c51fef09d7c45438", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -31,15 +31,15 @@ use syntax::ast;\n \n mod doc;\n \n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(PartialEq, TotalEq, Hash)]\n pub enum Constraint {\n     ConstrainVarSubVar(RegionVid, RegionVid),\n     ConstrainRegSubVar(Region, RegionVid),\n     ConstrainVarSubReg(RegionVid, Region),\n     ConstrainRegSubReg(Region, Region),\n }\n \n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(PartialEq, TotalEq, Hash)]\n pub struct TwoRegions {\n     a: Region,\n     b: Region,\n@@ -759,7 +759,7 @@ impl<'a> RegionVarBindings<'a> {\n \n // ______________________________________________________________________\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n enum Classification { Expanding, Contracting }\n \n pub enum VarValue { NoValue, Value(Region), ErrorValue }"}, {"sha": "653624bf8eeda0c542329c631fa0697923cb32c9", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -52,7 +52,7 @@ pub trait UnifyVid<T> {\n \n pub trait UnifyInferCtxtMethods {\n     fn get<T:Clone,\n-           V:Clone + Eq + Vid + UnifyVid<T>>(\n+           V:Clone + PartialEq + Vid + UnifyVid<T>>(\n            &self,\n            vid: V)\n            -> Node<V, T>;\n@@ -71,7 +71,7 @@ pub trait UnifyInferCtxtMethods {\n \n impl<'a> UnifyInferCtxtMethods for InferCtxt<'a> {\n     fn get<T:Clone,\n-           V:Clone + Eq + Vid + UnifyVid<T>>(\n+           V:Clone + PartialEq + Vid + UnifyVid<T>>(\n            &self,\n            vid: V)\n            -> Node<V, T> {\n@@ -86,7 +86,7 @@ impl<'a> UnifyInferCtxtMethods for InferCtxt<'a> {\n         let vb = UnifyVid::appropriate_vals_and_bindings(self);\n         return helper(tcx, &mut *vb.borrow_mut(), vid);\n \n-        fn helper<T:Clone, V:Clone+Eq+Vid>(\n+        fn helper<T:Clone, V:Clone+PartialEq+Vid>(\n             tcx: &ty::ctxt,\n             vb: &mut ValsAndBindings<V,T>,\n             vid: V) -> Node<V, T>\n@@ -191,15 +191,15 @@ pub fn mk_err<T:SimplyUnifiable>(a_is_expected: bool,\n }\n \n pub trait InferCtxtMethods {\n-    fn simple_vars<T:Clone + Eq + InferStr + SimplyUnifiable,\n-                   V:Clone + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n+    fn simple_vars<T:Clone + PartialEq + InferStr + SimplyUnifiable,\n+                   V:Clone + PartialEq + Vid + ToStr + UnifyVid<Option<T>>>(\n                    &self,\n                    a_is_expected: bool,\n                    a_id: V,\n                    b_id: V)\n                    -> ures;\n-    fn simple_var_t<T:Clone + Eq + InferStr + SimplyUnifiable,\n-                    V:Clone + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n+    fn simple_var_t<T:Clone + PartialEq + InferStr + SimplyUnifiable,\n+                    V:Clone + PartialEq + Vid + ToStr + UnifyVid<Option<T>>>(\n                     &self,\n                     a_is_expected: bool,\n                     a_id: V,\n@@ -208,8 +208,8 @@ pub trait InferCtxtMethods {\n }\n \n impl<'a> InferCtxtMethods for InferCtxt<'a> {\n-    fn simple_vars<T:Clone + Eq + InferStr + SimplyUnifiable,\n-                   V:Clone + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n+    fn simple_vars<T:Clone + PartialEq + InferStr + SimplyUnifiable,\n+                   V:Clone + PartialEq + Vid + ToStr + UnifyVid<Option<T>>>(\n                    &self,\n                    a_is_expected: bool,\n                    a_id: V,\n@@ -248,8 +248,8 @@ impl<'a> InferCtxtMethods for InferCtxt<'a> {\n         return uok();\n     }\n \n-    fn simple_var_t<T:Clone + Eq + InferStr + SimplyUnifiable,\n-                    V:Clone + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n+    fn simple_var_t<T:Clone + PartialEq + InferStr + SimplyUnifiable,\n+                    V:Clone + PartialEq + Vid + ToStr + UnifyVid<Option<T>>>(\n                     &self,\n                     a_is_expected: bool,\n                     a_id: V,"}, {"sha": "156479dc7a33d3ab4f32bd81ef976a5ab4b8ff31", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -84,7 +84,7 @@ pub mod collect;\n pub mod coherence;\n pub mod variance;\n \n-#[deriving(Clone, Encodable, Decodable, Eq, Ord)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq, PartialOrd)]\n pub enum param_index {\n     param_numbered(uint),\n     param_self\n@@ -147,7 +147,7 @@ pub struct MethodCallee {\n     pub substs: ty::substs\n }\n \n-#[deriving(Clone, Eq, TotalEq, Hash, Show)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash, Show)]\n pub struct MethodCall {\n     pub expr_id: ast::NodeId,\n     pub autoderef: u32"}, {"sha": "5deadc8867267863b23920c81fe1cd8151b6ae81", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -490,7 +490,7 @@ impl Clean<Option<Vec<TyParamBound>>> for ty::substs {\n     }\n }\n \n-#[deriving(Clone, Encodable, Decodable, Eq)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub struct Lifetime(String);\n \n impl Lifetime {\n@@ -631,7 +631,7 @@ impl Clean<Item> for ast::TypeMethod {\n     }\n }\n \n-#[deriving(Clone, Encodable, Decodable, Eq)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub enum SelfTy {\n     SelfStatic,\n     SelfValue,\n@@ -1458,7 +1458,7 @@ impl Clean<Item> for doctree::Static {\n     }\n }\n \n-#[deriving(Show, Clone, Encodable, Decodable, Eq)]\n+#[deriving(Show, Clone, Encodable, Decodable, PartialEq)]\n pub enum Mutability {\n     Mutable,\n     Immutable,"}, {"sha": "0f000f4e5aea11b8eddc3a98f0043f67bcacf5ba", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -19,7 +19,7 @@ use clean;\n /// discriminants. JavaScript then is used to decode them into the original value.\n /// Consequently, every change to this type should be synchronized to\n /// the `itemTypes` mapping table in `static/main.js`.\n-#[deriving(Eq, Clone)]\n+#[deriving(PartialEq, Clone)]\n pub enum ItemType {\n     Module          = 0,\n     Struct          = 1,"}, {"sha": "2356d4c754fa9032afe6a858e16a93a463199a66", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -14,7 +14,7 @@ use std::fmt;\n use std::string::String;\n \n /// A (recursive) table of contents\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub struct Toc {\n     /// The levels are strictly decreasing, i.e.\n     ///\n@@ -36,7 +36,7 @@ impl Toc {\n     }\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub struct TocEntry {\n     level: u32,\n     sec_number: String,\n@@ -46,7 +46,7 @@ pub struct TocEntry {\n }\n \n /// Progressive construction of a table of contents.\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub struct TocBuilder {\n     top_level: Toc,\n     /// The current heirachy of parent headings, the levels are"}, {"sha": "15add60b59c4829e7d25853cc094c520a24a14a8", "filename": "src/librustuv/timeout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustuv%2Ftimeout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustuv%2Ftimeout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimeout.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -34,14 +34,14 @@ pub struct Guard<'a> {\n     pub can_timeout: bool,\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n enum TimeoutState {\n     NoTimeout,\n     TimeoutPending(ClientState),\n     TimedOut,\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n enum ClientState {\n     NoWaiter,\n     AccessPending,"}, {"sha": "91c6814725144552b67c74b08e1fef3160740f2a", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -254,7 +254,7 @@ pub type uv_shutdown_cb = extern \"C\" fn(req: *uv_shutdown_t, status: c_int);\n #[cfg(windows)] pub type uv_gid_t = libc::c_uchar;\n \n #[repr(C)]\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum uv_handle_type {\n     UV_UNKNOWN_HANDLE,\n     UV_ASYNC,\n@@ -279,7 +279,7 @@ pub enum uv_handle_type {\n \n #[repr(C)]\n #[cfg(unix)]\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum uv_req_type {\n     UV_UNKNOWN_REQ,\n     UV_REQ,\n@@ -297,7 +297,7 @@ pub enum uv_req_type {\n // See UV_REQ_TYPE_PRIVATE at libuv/include/uv-win.h\n #[repr(C)]\n #[cfg(windows)]\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum uv_req_type {\n     UV_UNKNOWN_REQ,\n     UV_REQ,\n@@ -320,7 +320,7 @@ pub enum uv_req_type {\n }\n \n #[repr(C)]\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum uv_membership {\n     UV_LEAVE_GROUP,\n     UV_JOIN_GROUP"}, {"sha": "dbde1a7486d09c9fef49838e71ddabc05f61da07", "filename": "src/libsemver/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsemver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsemver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsemver%2Flib.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -46,14 +46,14 @@ use std::string::String;\n \n /// An identifier in the pre-release or build metadata. If the identifier can\n /// be parsed as a decimal value, it will be represented with `Numeric`.\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n #[allow(missing_doc)]\n pub enum Identifier {\n     Numeric(uint),\n     AlphaNumeric(String)\n }\n \n-impl cmp::Ord for Identifier {\n+impl cmp::PartialOrd for Identifier {\n     #[inline]\n     fn lt(&self, other: &Identifier) -> bool {\n         match (self, other) {\n@@ -115,7 +115,7 @@ impl fmt::Show for Version {\n     }\n }\n \n-impl cmp::Eq for Version {\n+impl cmp::PartialEq for Version {\n     #[inline]\n     fn eq(&self, other: &Version) -> bool {\n         // We should ignore build metadata here, otherwise versions v1 and v2\n@@ -128,7 +128,7 @@ impl cmp::Eq for Version {\n     }\n }\n \n-impl cmp::Ord for Version {\n+impl cmp::PartialOrd for Version {\n     #[inline]\n     fn lt(&self, other: &Version) -> bool {\n "}, {"sha": "7ca0f372891b6055db457d0de47648bc150b0830", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -76,8 +76,8 @@ impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for RingBuf<T> {\n impl<\n     E,\n     S: Encoder<E>,\n-    K: Encodable<S, E> + Eq + TotalOrd,\n-    V: Encodable<S, E> + Eq\n+    K: Encodable<S, E> + PartialEq + TotalOrd,\n+    V: Encodable<S, E> + PartialEq\n > Encodable<S, E> for TreeMap<K, V> {\n     fn encode(&self, e: &mut S) -> Result<(), E> {\n         e.emit_map(self.len(), |e| {\n@@ -95,8 +95,8 @@ impl<\n impl<\n     E,\n     D: Decoder<E>,\n-    K: Decodable<D, E> + Eq + TotalOrd,\n-    V: Decodable<D, E> + Eq\n+    K: Decodable<D, E> + PartialEq + TotalOrd,\n+    V: Decodable<D, E> + PartialEq\n > Decodable<D, E> for TreeMap<K, V> {\n     fn decode(d: &mut D) -> Result<TreeMap<K, V>, E> {\n         d.read_map(|d, len| {\n@@ -114,7 +114,7 @@ impl<\n impl<\n     E,\n     S: Encoder<E>,\n-    T: Encodable<S, E> + Eq + TotalOrd\n+    T: Encodable<S, E> + PartialEq + TotalOrd\n > Encodable<S, E> for TreeSet<T> {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_seq(self.len(), |s| {\n@@ -131,7 +131,7 @@ impl<\n impl<\n     E,\n     D: Decoder<E>,\n-    T: Decodable<D, E> + Eq + TotalOrd\n+    T: Decodable<D, E> + PartialEq + TotalOrd\n > Decodable<D, E> for TreeSet<T> {\n     fn decode(d: &mut D) -> Result<TreeSet<T>, E> {\n         d.read_seq(|d, len| {"}, {"sha": "5e23c9c34511260a0c379ee1c35c7093957a7c00", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -249,7 +249,7 @@ use Encodable;\n use collections::{HashMap, TreeMap};\n \n /// Represents a json value\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub enum Json {\n     Number(f64),\n     String(String),\n@@ -263,7 +263,7 @@ pub type List = Vec<Json>;\n pub type Object = TreeMap<String, Json>;\n \n /// The errors that can arise while parsing a JSON stream.\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub enum ErrorCode {\n     InvalidSyntax,\n     InvalidNumber,\n@@ -283,7 +283,7 @@ pub enum ErrorCode {\n     NotUtf8,\n }\n \n-#[deriving(Clone, Eq, Show)]\n+#[deriving(Clone, PartialEq, Show)]\n pub enum ParserError {\n     /// msg, line, col\n     SyntaxError(ErrorCode, uint, uint),\n@@ -293,7 +293,7 @@ pub enum ParserError {\n // Builder and Parser have the same errors.\n pub type BuilderError = ParserError;\n \n-#[deriving(Clone, Eq, Show)]\n+#[deriving(Clone, PartialEq, Show)]\n pub enum DecoderError {\n     ParseError(ParserError),\n     ExpectedError(String, String),\n@@ -975,7 +975,7 @@ impl Json {\n }\n \n /// The output of the streaming parser.\n-#[deriving(Eq, Clone, Show)]\n+#[deriving(PartialEq, Clone, Show)]\n pub enum JsonEvent {\n     ObjectStart,\n     ObjectEnd,\n@@ -988,7 +988,7 @@ pub enum JsonEvent {\n     Error(ParserError),\n }\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n enum ParserState {\n     // Parse a value in a list, true means first element.\n     ParseList(bool),\n@@ -1017,15 +1017,15 @@ pub struct Stack {\n /// StackElements compose a Stack.\n /// For example, Key(\"foo\"), Key(\"bar\"), Index(3) and Key(\"x\") are the\n /// StackElements compositing the stack that represents foo.bar[3].x\n-#[deriving(Eq, Clone, Show)]\n+#[deriving(PartialEq, Clone, Show)]\n pub enum StackElement<'l> {\n     Index(u32),\n     Key(&'l str),\n }\n \n // Internally, Key elements are stored as indices in a buffer to avoid\n // allocating a string for every member of an object.\n-#[deriving(Eq, Clone, Show)]\n+#[deriving(PartialEq, Clone, Show)]\n enum InternalStackElement {\n     InternalIndex(u32),\n     InternalKey(u16, u16), // start, size\n@@ -2082,7 +2082,7 @@ impl ::Decoder<DecoderError> for Decoder {\n }\n \n /// Test if two json values are less than one another\n-impl Ord for Json {\n+impl PartialOrd for Json {\n     fn lt(&self, other: &Json) -> bool {\n         match *self {\n             Number(f0) => {\n@@ -2288,20 +2288,20 @@ mod tests {\n     use std::io;\n     use collections::TreeMap;\n \n-    #[deriving(Eq, Encodable, Decodable, Show)]\n+    #[deriving(PartialEq, Encodable, Decodable, Show)]\n     enum Animal {\n         Dog,\n         Frog(String, int)\n     }\n \n-    #[deriving(Eq, Encodable, Decodable, Show)]\n+    #[deriving(PartialEq, Encodable, Decodable, Show)]\n     struct Inner {\n         a: (),\n         b: uint,\n         c: Vec<String>,\n     }\n \n-    #[deriving(Eq, Encodable, Decodable, Show)]\n+    #[deriving(PartialEq, Encodable, Decodable, Show)]\n     struct Outer {\n         inner: Vec<Inner>,\n     }"}, {"sha": "222297aaf0ef2d9e734fce36b945536bf03eed27", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -23,7 +23,7 @@ use to_str::{IntoStr};\n use vec::Vec;\n \n /// Datatype to hold one ascii character. It wraps a `u8`, with the highest bit always zero.\n-#[deriving(Clone, Eq, Ord, TotalOrd, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, PartialOrd, TotalOrd, TotalEq, Hash)]\n pub struct Ascii { chr: u8 }\n \n impl Ascii {"}, {"sha": "eb8c7e7d2832449c5ab25eea9db0bd6ee9353ef0", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -78,7 +78,7 @@\n //!\n //! # Derived traits\n //!\n-//! The `Eq` and `Clone` traits are automatically derived for the `struct` using\n+//! The `PartialEq` and `Clone` traits are automatically derived for the `struct` using\n //! the `deriving` attribute. Additional traits can be derived by providing an\n //! explicit `deriving` attribute on `flags`.\n //!\n@@ -112,7 +112,7 @@ macro_rules! bitflags(\n     ($(#[$attr:meta])* flags $BitFlags:ident: $T:ty {\n         $($(#[$Flag_attr:meta])* static $Flag:ident = $value:expr),+\n     }) => (\n-        #[deriving(Eq, TotalEq, Clone)]\n+        #[deriving(PartialEq, TotalEq, Clone)]\n         $(#[$attr])*\n         pub struct $BitFlags {\n             bits: $T,"}, {"sha": "4e39518deb48c792a8b99a2b447ee7dc32410f74", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -66,7 +66,7 @@ fn main() {\n */\n \n use clone::Clone;\n-use cmp::Eq;\n+use cmp::PartialEq;\n use container::Container;\n use iter::{Iterator, range};\n use kinds::marker;\n@@ -109,7 +109,7 @@ impl Clone for CString {\n     }\n }\n \n-impl Eq for CString {\n+impl PartialEq for CString {\n     fn eq(&self, other: &CString) -> bool {\n         if self.buf as uint == other.buf as uint {\n             true"}, {"sha": "170618e276b2c8f4ac58a42e56e834a51870063b", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -360,7 +360,7 @@ pub struct SyncSender<T> {\n \n /// This enumeration is the list of the possible reasons that try_recv could not\n /// return data when called.\n-#[deriving(Eq, Clone, Show)]\n+#[deriving(PartialEq, Clone, Show)]\n pub enum TryRecvError {\n     /// This channel is currently empty, but the sender(s) have not yet\n     /// disconnected, so data may yet become available.\n@@ -372,7 +372,7 @@ pub enum TryRecvError {\n \n /// This enumeration is the list of the possible error outcomes for the\n /// `SyncSender::try_send` method.\n-#[deriving(Eq, Clone, Show)]\n+#[deriving(PartialEq, Clone, Show)]\n pub enum TrySendError<T> {\n     /// The data could not be sent on the channel because it would require that\n     /// the callee block to send the data."}, {"sha": "8dc2dd4bdb6e1e760373b1145fe661be6bb44e60", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -492,10 +492,6 @@ will look like `\"\\\\{\"`.\n \n use io::Writer;\n use io;\n-#[cfg(stage0)]\n-use option::None;\n-#[cfg(stage0)]\n-use repr;\n use result::{Ok, Err};\n use str::{Str, StrAllocating};\n use str;\n@@ -524,21 +520,6 @@ pub use core::fmt::{secret_float, secret_upper_exp, secret_lower_exp};\n #[doc(hidden)]\n pub use core::fmt::{secret_pointer};\n \n-#[doc(hidden)]\n-#[cfg(stage0)]\n-pub fn secret_poly<T: Poly>(x: &T, fmt: &mut Formatter) -> Result {\n-    // FIXME #11938 - UFCS would make us able call the this method\n-    //                directly Poly::fmt(x, fmt).\n-    x.fmt(fmt)\n-}\n-\n-/// Format trait for the `?` character\n-#[cfg(stage0)]\n-pub trait Poly {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n /// The format function takes a precompiled format string and a list of\n /// arguments, to return the resulting formatted string.\n ///\n@@ -562,27 +543,6 @@ pub fn format(args: &Arguments) -> string::String{\n     str::from_utf8(output.unwrap().as_slice()).unwrap().into_string()\n }\n \n-#[cfg(stage0)]\n-impl<T> Poly for T {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        match (f.width, f.precision) {\n-            (None, None) => {\n-                match repr::write_repr(f, self) {\n-                    Ok(()) => Ok(()),\n-                    Err(..) => Err(WriteError),\n-                }\n-            }\n-\n-            // If we have a specified width for formatting, then we have to make\n-            // this allocation of a new string\n-            _ => {\n-                let s = repr::repr_to_str(self);\n-                f.pad(s.as_slice())\n-            }\n-        }\n-    }\n-}\n-\n impl<'a> Writer for Formatter<'a> {\n     fn write(&mut self, b: &[u8]) -> io::IoResult<()> {\n         match (*self).write(b) {"}, {"sha": "0d4217601624f760a7a562d5f39e7c258eb4f7a1", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -378,7 +378,7 @@ mod test {\n     /// A type, free to create, primarily intended for benchmarking creation of\n     /// wrappers that, just for construction, don't need a Reader/Writer that\n     /// does anything useful. Is equivalent to `/dev/null` in semantics.\n-    #[deriving(Clone,Eq,Ord)]\n+    #[deriving(Clone,PartialEq,PartialOrd)]\n     pub struct NullStream;\n \n     impl Reader for NullStream {"}, {"sha": "78700d353afd8fd65f3c64e396c1215964ad154a", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -285,7 +285,7 @@ pub type IoResult<T> = Result<T, IoError>;\n /// # FIXME\n ///\n /// Is something like this sufficient? It's kind of archaic\n-#[deriving(Eq, Clone)]\n+#[deriving(PartialEq, Clone)]\n pub struct IoError {\n     /// An enumeration which can be matched against for determining the flavor\n     /// of error.\n@@ -395,7 +395,7 @@ impl fmt::Show for IoError {\n }\n \n /// A list specifying general categories of I/O error.\n-#[deriving(Eq, Clone, Show)]\n+#[deriving(PartialEq, Clone, Show)]\n pub enum IoErrorKind {\n     /// Any I/O error not part of this list.\n     OtherIoError,\n@@ -1582,7 +1582,7 @@ pub enum FileAccess {\n }\n \n /// Different kinds of files which can be identified by a call to stat\n-#[deriving(Eq, Show, Hash)]\n+#[deriving(PartialEq, Show, Hash)]\n pub enum FileType {\n     /// This is a normal file, corresponding to `S_IFREG`\n     TypeFile,\n@@ -1726,7 +1726,7 @@ mod tests {\n     use prelude::*;\n     use uint;\n \n-    #[deriving(Clone, Eq, Show)]\n+    #[deriving(Clone, PartialEq, Show)]\n     enum BadReaderBehavior {\n         GoodBehavior(uint),\n         BadBehavior(uint)"}, {"sha": "4d0e5e7f72d6d0e1e6426df89d823bf99ecca41f", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -25,7 +25,7 @@ use slice::{MutableCloneableVector, ImmutableVector, MutableVector};\n \n pub type Port = u16;\n \n-#[deriving(Eq, TotalEq, Clone, Hash)]\n+#[deriving(PartialEq, TotalEq, Clone, Hash)]\n pub enum IpAddr {\n     Ipv4Addr(u8, u8, u8, u8),\n     Ipv6Addr(u16, u16, u16, u16, u16, u16, u16, u16)\n@@ -56,7 +56,7 @@ impl fmt::Show for IpAddr {\n     }\n }\n \n-#[deriving(Eq, TotalEq, Clone, Hash)]\n+#[deriving(PartialEq, TotalEq, Clone, Hash)]\n pub struct SocketAddr {\n     pub ip: IpAddr,\n     pub port: Port,"}, {"sha": "8325ee4ccd9089c8bbd82487edab862eadefcf57", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -317,7 +317,7 @@ impl fmt::Show for Command {\n }\n \n /// The output of a finished process.\n-#[deriving(Eq, TotalEq, Clone)]\n+#[deriving(PartialEq, TotalEq, Clone)]\n pub struct ProcessOutput {\n     /// The status (exit code) of the process.\n     pub status: ProcessExit,\n@@ -348,7 +348,7 @@ pub enum StdioContainer {\n \n /// Describes the result of a process after it has terminated.\n /// Note that Windows have no signals, so the result is usually ExitStatus.\n-#[deriving(Eq, TotalEq, Clone)]\n+#[deriving(PartialEq, TotalEq, Clone)]\n pub enum ProcessExit {\n     /// Normal termination with an exit status.\n     ExitStatus(int),"}, {"sha": "05392baff04c30363b5f8a88e66ff03a79db5632", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -34,7 +34,7 @@ use vec::Vec;\n \n /// Signals that can be sent and received\n #[repr(int)]\n-#[deriving(Eq, Hash, Show)]\n+#[deriving(PartialEq, Hash, Show)]\n pub enum Signum {\n     /// Equivalent to SIGBREAK, delivered when the user presses Ctrl-Break.\n     Break = 21i,"}, {"sha": "a67ed1c0b7919bf59584e7b5f8cf132f5ee3001b", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -241,13 +241,6 @@ pub mod path;\n pub mod fmt;\n pub mod cleanup;\n \n-/* Unsupported interfaces */\n-\n-#[unstable]\n-pub mod repr;\n-#[unstable]\n-pub mod reflect;\n-\n // Private APIs\n #[unstable]\n pub mod unstable;"}, {"sha": "602a2240f39084a5438f3a3bfb6b8e60e236dc5d", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -702,7 +702,7 @@ mod tests {\n     test_checked_next_power_of_two!(test_checked_next_power_of_two_u64, u64)\n     test_checked_next_power_of_two!(test_checked_next_power_of_two_uint, uint)\n \n-    #[deriving(Eq, Show)]\n+    #[deriving(PartialEq, Show)]\n     struct Value { x: int }\n \n     impl ToPrimitive for Value {"}, {"sha": "54ca5797804902d95b9975293af0a98b39a213f4", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -20,7 +20,7 @@ use num;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use option::{None, Option, Some};\n use slice::{ImmutableVector, MutableVector};\n-use std::cmp::{Ord, Eq};\n+use std::cmp::{PartialOrd, PartialEq};\n use str::StrSlice;\n use string::String;\n use vec::Vec;\n@@ -259,7 +259,7 @@ pub fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f:\n  *   between digit and exponent sign `'p'`.\n  */\n #[allow(deprecated)]\n-pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+\n+pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n                                   Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n         num: T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_upper: bool\n@@ -492,7 +492,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+\n  * `to_str_bytes_common()`, for details see there.\n  */\n #[inline]\n-pub fn float_to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Float+\n+pub fn float_to_str_common<T:NumCast+Zero+One+PartialEq+PartialOrd+NumStrConv+Float+\n                              Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n         num: T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_capital: bool\n@@ -547,7 +547,7 @@ static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n  * - Fails if `radix` > 18 and `special == true` due to conflict\n  *   between digit and lowest first character in `inf` and `NaN`, the `'i'`.\n  */\n-pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+\n+pub fn from_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+\n                                     Mul<T,T>+Sub<T,T>+Neg<T>+Add<T,T>+\n                                     NumStrConv+Clone>(\n         buf: &[u8], radix: uint, negative: bool, fractional: bool,\n@@ -754,7 +754,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+\n  * `from_str_bytes_common()`, for details see there.\n  */\n #[inline]\n-pub fn from_str_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+Mul<T,T>+\n+pub fn from_str_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+Mul<T,T>+\n                               Sub<T,T>+Neg<T>+Add<T,T>+NumStrConv+Clone>(\n         buf: &str, radix: uint, negative: bool, fractional: bool,\n         special: bool, exponent: ExponentFormat, empty_zero: bool,"}, {"sha": "fbecbd7665b50c6f2b3412c8ae05db67a2a6a13f", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -13,7 +13,7 @@\n use container::Container;\n use c_str::{CString, ToCStr};\n use clone::Clone;\n-use cmp::{Eq, TotalEq};\n+use cmp::{PartialEq, TotalEq};\n use from_str::FromStr;\n use io::Writer;\n use iter::{DoubleEndedIterator, AdditiveIterator, Extendable, Iterator, Map};\n@@ -58,7 +58,7 @@ pub fn is_sep(c: char) -> bool {\n     c == SEP\n }\n \n-impl Eq for Path {\n+impl PartialEq for Path {\n     #[inline]\n     fn eq(&self, other: &Path) -> bool {\n         self.repr == other.repr"}, {"sha": "d46a373de4d61e342ab727a0ae10007dd7d61d3f", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -13,7 +13,7 @@\n use ascii::AsciiCast;\n use c_str::{CString, ToCStr};\n use clone::Clone;\n-use cmp::{Eq, TotalEq};\n+use cmp::{PartialEq, TotalEq};\n use container::Container;\n use from_str::FromStr;\n use io::Writer;\n@@ -79,7 +79,7 @@ pub struct Path {\n     sepidx: Option<uint> // index of the final separator in the non-prefix portion of repr\n }\n \n-impl Eq for Path {\n+impl PartialEq for Path {\n     #[inline]\n     fn eq(&self, other: &Path) -> bool {\n         self.repr == other.repr\n@@ -956,7 +956,7 @@ pub fn is_sep_byte_verbatim(u: &u8) -> bool {\n }\n \n /// Prefix types for Path\n-#[deriving(Eq, Clone)]\n+#[deriving(PartialEq, Clone)]\n pub enum PathPrefix {\n     /// Prefix `\\\\?\\`, uint is the length of the following component\n     VerbatimPrefix(uint),"}, {"sha": "ac1aaa2c6ca9e457486ead2690009f5511591782", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -58,7 +58,7 @@\n #[doc(no_inline)] pub use c_str::ToCStr;\n #[doc(no_inline)] pub use char::Char;\n #[doc(no_inline)] pub use clone::Clone;\n-#[doc(no_inline)] pub use cmp::{Eq, Ord, TotalEq, TotalOrd};\n+#[doc(no_inline)] pub use cmp::{PartialEq, PartialOrd, TotalEq, TotalOrd};\n #[doc(no_inline)] pub use cmp::{Ordering, Less, Equal, Greater, Equiv};\n #[doc(no_inline)] pub use container::{Container, Mutable, Map, MutableMap};\n #[doc(no_inline)] pub use container::{Set, MutableSet};"}, {"sha": "f21dcdf2a469006afbf91457166dfb79049ab2d0", "filename": "src/libstd/reflect.rs", "status": "removed", "additions": 0, "deletions": 439, "changes": 439, "blob_url": "https://github.com/rust-lang/rust/blob/cc4513202d6f9c6896054ebaa1d99230b06e9f10/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc4513202d6f9c6896054ebaa1d99230b06e9f10/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=cc4513202d6f9c6896054ebaa1d99230b06e9f10", "patch": "@@ -1,439 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Runtime type reflection\n-\n-*/\n-\n-#![allow(missing_doc)]\n-\n-use intrinsics::{Disr, Opaque, TyDesc, TyVisitor};\n-use mem;\n-use owned::Box;\n-\n-/**\n- * Trait for visitor that wishes to reflect on data. To use this, create a\n- * struct that encapsulates the set of pointers you wish to walk through a\n- * data structure, and implement both `MovePtr` for it as well as `TyVisitor`;\n- * then build a MovePtrAdaptor wrapped around your struct.\n- */\n-pub trait MovePtr {\n-    fn move_ptr(&mut self, adjustment: |*u8| -> *u8);\n-    fn push_ptr(&mut self);\n-    fn pop_ptr(&mut self);\n-}\n-\n-/// Helper function for alignment calculation.\n-#[inline]\n-pub fn align(size: uint, align: uint) -> uint {\n-    ((size + align) - 1u) & !(align - 1u)\n-}\n-\n-/// Adaptor to wrap around visitors implementing MovePtr.\n-pub struct MovePtrAdaptor<V> {\n-    inner: V\n-}\n-\n-impl<V:TyVisitor + MovePtr> MovePtrAdaptor<V> {\n-    pub fn new(v: V) -> MovePtrAdaptor<V> {\n-        MovePtrAdaptor { inner: v }\n-    }\n-\n-    #[inline]\n-    pub fn bump(&mut self, sz: uint) {\n-        self.inner.move_ptr(|p| ((p as uint) + sz) as *u8)\n-    }\n-\n-    #[inline]\n-    pub fn align(&mut self, a: uint) {\n-        self.inner.move_ptr(|p| align(p as uint, a) as *u8)\n-    }\n-\n-    #[inline]\n-    pub fn align_to<T>(&mut self) {\n-        self.align(mem::min_align_of::<T>());\n-    }\n-\n-    #[inline]\n-    pub fn bump_past<T>(&mut self) {\n-        self.bump(mem::size_of::<T>());\n-    }\n-\n-    pub fn unwrap(self) -> V { self.inner }\n-}\n-\n-/// Abstract type-directed pointer-movement using the MovePtr trait\n-impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n-    fn visit_bot(&mut self) -> bool {\n-        self.align_to::<()>();\n-        if ! self.inner.visit_bot() { return false; }\n-        self.bump_past::<()>();\n-        true\n-    }\n-\n-    fn visit_nil(&mut self) -> bool {\n-        self.align_to::<()>();\n-        if ! self.inner.visit_nil() { return false; }\n-        self.bump_past::<()>();\n-        true\n-    }\n-\n-    fn visit_bool(&mut self) -> bool {\n-        self.align_to::<bool>();\n-        if ! self.inner.visit_bool() { return false; }\n-        self.bump_past::<bool>();\n-        true\n-    }\n-\n-    fn visit_int(&mut self) -> bool {\n-        self.align_to::<int>();\n-        if ! self.inner.visit_int() { return false; }\n-        self.bump_past::<int>();\n-        true\n-    }\n-\n-    fn visit_i8(&mut self) -> bool {\n-        self.align_to::<i8>();\n-        if ! self.inner.visit_i8() { return false; }\n-        self.bump_past::<i8>();\n-        true\n-    }\n-\n-    fn visit_i16(&mut self) -> bool {\n-        self.align_to::<i16>();\n-        if ! self.inner.visit_i16() { return false; }\n-        self.bump_past::<i16>();\n-        true\n-    }\n-\n-    fn visit_i32(&mut self) -> bool {\n-        self.align_to::<i32>();\n-        if ! self.inner.visit_i32() { return false; }\n-        self.bump_past::<i32>();\n-        true\n-    }\n-\n-    fn visit_i64(&mut self) -> bool {\n-        self.align_to::<i64>();\n-        if ! self.inner.visit_i64() { return false; }\n-        self.bump_past::<i64>();\n-        true\n-    }\n-\n-    fn visit_uint(&mut self) -> bool {\n-        self.align_to::<uint>();\n-        if ! self.inner.visit_uint() { return false; }\n-        self.bump_past::<uint>();\n-        true\n-    }\n-\n-    fn visit_u8(&mut self) -> bool {\n-        self.align_to::<u8>();\n-        if ! self.inner.visit_u8() { return false; }\n-        self.bump_past::<u8>();\n-        true\n-    }\n-\n-    fn visit_u16(&mut self) -> bool {\n-        self.align_to::<u16>();\n-        if ! self.inner.visit_u16() { return false; }\n-        self.bump_past::<u16>();\n-        true\n-    }\n-\n-    fn visit_u32(&mut self) -> bool {\n-        self.align_to::<u32>();\n-        if ! self.inner.visit_u32() { return false; }\n-        self.bump_past::<u32>();\n-        true\n-    }\n-\n-    fn visit_u64(&mut self) -> bool {\n-        self.align_to::<u64>();\n-        if ! self.inner.visit_u64() { return false; }\n-        self.bump_past::<u64>();\n-        true\n-    }\n-\n-    fn visit_f32(&mut self) -> bool {\n-        self.align_to::<f32>();\n-        if ! self.inner.visit_f32() { return false; }\n-        self.bump_past::<f32>();\n-        true\n-    }\n-\n-    fn visit_f64(&mut self) -> bool {\n-        self.align_to::<f64>();\n-        if ! self.inner.visit_f64() { return false; }\n-        self.bump_past::<f64>();\n-        true\n-    }\n-\n-    fn visit_f128(&mut self) -> bool {\n-        self.align_to::<f128>();\n-        if ! self.inner.visit_f128() { return false; }\n-        self.bump_past::<f128>();\n-        true\n-    }\n-\n-    fn visit_char(&mut self) -> bool {\n-        self.align_to::<char>();\n-        if ! self.inner.visit_char() { return false; }\n-        self.bump_past::<char>();\n-        true\n-    }\n-\n-    fn visit_estr_box(&mut self) -> bool {\n-        true\n-    }\n-\n-    fn visit_estr_uniq(&mut self) -> bool {\n-        self.align_to::<~str>();\n-        if ! self.inner.visit_estr_uniq() { return false; }\n-        self.bump_past::<~str>();\n-        true\n-    }\n-\n-    fn visit_estr_slice(&mut self) -> bool {\n-        self.align_to::<&'static str>();\n-        if ! self.inner.visit_estr_slice() { return false; }\n-        self.bump_past::<&'static str>();\n-        true\n-    }\n-\n-    fn visit_estr_fixed(&mut self, n: uint,\n-                        sz: uint,\n-                        align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_estr_fixed(n, sz, align) { return false; }\n-        self.bump(sz);\n-        true\n-    }\n-\n-    fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<@u8>();\n-        if ! self.inner.visit_box(mtbl, inner) { return false; }\n-        self.bump_past::<@u8>();\n-        true\n-    }\n-\n-    fn visit_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<Box<u8>>();\n-        if ! self.inner.visit_uniq(mtbl, inner) { return false; }\n-        self.bump_past::<Box<u8>>();\n-        true\n-    }\n-\n-    fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<*u8>();\n-        if ! self.inner.visit_ptr(mtbl, inner) { return false; }\n-        self.bump_past::<*u8>();\n-        true\n-    }\n-\n-    fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<&'static u8>();\n-        if ! self.inner.visit_rptr(mtbl, inner) { return false; }\n-        self.bump_past::<&'static u8>();\n-        true\n-    }\n-\n-    fn visit_evec_box(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool {\n-        true\n-    }\n-\n-    fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~[u8]>();\n-        if ! self.inner.visit_evec_uniq(mtbl, inner) { return false; }\n-        self.bump_past::<~[u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<&'static [u8]>();\n-        if ! self.inner.visit_evec_slice(mtbl, inner) { return false; }\n-        self.bump_past::<&'static [u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n-                        mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_evec_fixed(n, sz, align, mtbl, inner) {\n-            return false;\n-        }\n-        self.bump(sz);\n-        true\n-    }\n-\n-    fn visit_enter_rec(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_rec(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_rec_field(&mut self, i: uint, name: &str,\n-                       mtbl: uint, inner: *TyDesc) -> bool {\n-        unsafe { self.align((*inner).align); }\n-        if ! self.inner.visit_rec_field(i, name, mtbl, inner) {\n-            return false;\n-        }\n-        unsafe { self.bump((*inner).size); }\n-        true\n-    }\n-\n-    fn visit_leave_rec(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        if ! self.inner.visit_leave_rec(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_enter_class(&mut self, name: &str, named_fields: bool, n_fields: uint, sz: uint,\n-                         align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_class(name, named_fields, n_fields, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_class_field(&mut self, i: uint, name: &str, named: bool, mtbl: uint,\n-                         inner: *TyDesc) -> bool {\n-        unsafe { self.align((*inner).align); }\n-        if ! self.inner.visit_class_field(i, name, named, mtbl, inner) {\n-            return false;\n-        }\n-        unsafe { self.bump((*inner).size); }\n-        true\n-    }\n-\n-    fn visit_leave_class(&mut self, name: &str, named_fields: bool, n_fields: uint, sz: uint,\n-                         align: uint) -> bool {\n-        if ! self.inner.visit_leave_class(name, named_fields, n_fields, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_tup(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_tup(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool {\n-        unsafe { self.align((*inner).align); }\n-        if ! self.inner.visit_tup_field(i, inner) { return false; }\n-        unsafe { self.bump((*inner).size); }\n-        true\n-    }\n-\n-    fn visit_leave_tup(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        if ! self.inner.visit_leave_tup(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_enter_fn(&mut self, purity: uint, proto: uint,\n-                      n_inputs: uint, retstyle: uint) -> bool {\n-        if ! self.inner.visit_enter_fn(purity, proto, n_inputs, retstyle) {\n-            return false\n-        }\n-        true\n-    }\n-\n-    fn visit_fn_input(&mut self, i: uint, mode: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner.visit_fn_input(i, mode, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_fn_output(&mut self, retstyle: uint, variadic: bool, inner: *TyDesc) -> bool {\n-        if ! self.inner.visit_fn_output(retstyle, variadic, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_leave_fn(&mut self, purity: uint, proto: uint,\n-                      n_inputs: uint, retstyle: uint) -> bool {\n-        if ! self.inner.visit_leave_fn(purity, proto, n_inputs, retstyle) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_enum(&mut self, n_variants: uint,\n-                        get_disr: unsafe extern fn(ptr: *Opaque) -> Disr,\n-                        sz: uint, align: uint)\n-                     -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_enum(n_variants, get_disr, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_enum_variant(&mut self, variant: uint,\n-                                disr_val: Disr,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        if ! self.inner.visit_enter_enum_variant(variant, disr_val,\n-                                                 n_fields, name) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enum_variant_field(&mut self, i: uint, offset: uint, inner: *TyDesc) -> bool {\n-        self.inner.push_ptr();\n-        self.bump(offset);\n-        if ! self.inner.visit_enum_variant_field(i, offset, inner) { return false; }\n-        self.inner.pop_ptr();\n-        true\n-    }\n-\n-    fn visit_leave_enum_variant(&mut self, variant: uint,\n-                                disr_val: Disr,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        if ! self.inner.visit_leave_enum_variant(variant, disr_val,\n-                                                 n_fields, name) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_leave_enum(&mut self, n_variants: uint,\n-                        get_disr: unsafe extern fn(ptr: *Opaque) -> Disr,\n-                        sz: uint, align: uint) -> bool {\n-        if ! self.inner.visit_leave_enum(n_variants, get_disr, sz, align) {\n-            return false;\n-        }\n-        self.bump(sz);\n-        true\n-    }\n-\n-    fn visit_trait(&mut self, name: &str) -> bool {\n-        self.align_to::<Box<TyVisitor>>();\n-        if ! self.inner.visit_trait(name) { return false; }\n-        self.bump_past::<Box<TyVisitor>>();\n-        true\n-    }\n-\n-    fn visit_param(&mut self, i: uint) -> bool {\n-        if ! self.inner.visit_param(i) { return false; }\n-        true\n-    }\n-\n-    fn visit_self(&mut self) -> bool {\n-        self.align_to::<&'static u8>();\n-        if ! self.inner.visit_self() { return false; }\n-        self.align_to::<&'static u8>();\n-        true\n-    }\n-}"}, {"sha": "0621cbf35fe22e78181b2287e2dd41f4caf094c2", "filename": "src/libstd/repr.rs", "status": "removed", "additions": 0, "deletions": 663, "changes": 663, "blob_url": "https://github.com/rust-lang/rust/blob/cc4513202d6f9c6896054ebaa1d99230b06e9f10/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc4513202d6f9c6896054ebaa1d99230b06e9f10/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=cc4513202d6f9c6896054ebaa1d99230b06e9f10", "patch": "@@ -1,663 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-More runtime type reflection\n-\n-*/\n-\n-#![allow(missing_doc)]\n-\n-use char;\n-use container::Container;\n-use intrinsics::{Disr, Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n-use io;\n-use iter::Iterator;\n-use mem::transmute;\n-use option::{Some, None, Option};\n-use ptr::RawPtr;\n-use raw;\n-use reflect::{MovePtr, align};\n-use reflect;\n-use result::{Ok, Err};\n-use slice::Vector;\n-use str::{Str, StrSlice};\n-use string::String;\n-use to_str::ToStr;\n-use vec::Vec;\n-\n-macro_rules! try( ($me:expr, $e:expr) => (\n-    match $e {\n-        Ok(()) => {},\n-        Err(e) => { $me.last_err = Some(e); return false; }\n-    }\n-) )\n-\n-/// Representations\n-\n-trait Repr {\n-    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()>;\n-}\n-\n-impl Repr for () {\n-    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n-        writer.write(\"()\".as_bytes())\n-    }\n-}\n-\n-impl Repr for bool {\n-    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n-        let s = if *self { \"true\" } else { \"false\" };\n-        writer.write(s.as_bytes())\n-    }\n-}\n-\n-impl Repr for int {\n-    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n-        write!(writer, \"{}\", *self)\n-    }\n-}\n-\n-macro_rules! int_repr(($ty:ident, $suffix:expr) => (impl Repr for $ty {\n-    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n-        write!(writer, \"{}{}\", *self, $suffix)\n-    }\n-}))\n-\n-int_repr!(i8, \"i8\")\n-int_repr!(i16, \"i16\")\n-int_repr!(i32, \"i32\")\n-int_repr!(i64, \"i64\")\n-int_repr!(uint, \"u\")\n-int_repr!(u8, \"u8\")\n-int_repr!(u16, \"u16\")\n-int_repr!(u32, \"u32\")\n-int_repr!(u64, \"u64\")\n-\n-macro_rules! num_repr(($ty:ident, $suffix:expr) => (impl Repr for $ty {\n-    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n-        let s = self.to_str();\n-        writer.write(s.as_bytes()).and_then(|()| {\n-            writer.write(bytes!($suffix))\n-        })\n-    }\n-}))\n-\n-num_repr!(f32, \"f32\")\n-num_repr!(f64, \"f64\")\n-\n-// New implementation using reflect::MovePtr\n-\n-enum VariantState {\n-    SearchingFor(Disr),\n-    Matched,\n-    AlreadyFound\n-}\n-\n-pub struct ReprVisitor<'a> {\n-    ptr: *u8,\n-    ptr_stk: Vec<*u8>,\n-    var_stk: Vec<VariantState>,\n-    writer: &'a mut io::Writer,\n-    last_err: Option<io::IoError>,\n-}\n-\n-impl<'a> MovePtr for ReprVisitor<'a> {\n-    #[inline]\n-    fn move_ptr(&mut self, adjustment: |*u8| -> *u8) {\n-        self.ptr = adjustment(self.ptr);\n-    }\n-    fn push_ptr(&mut self) {\n-        self.ptr_stk.push(self.ptr);\n-    }\n-    fn pop_ptr(&mut self) {\n-        self.ptr = self.ptr_stk.pop().unwrap();\n-    }\n-}\n-\n-impl<'a> ReprVisitor<'a> {\n-    // Various helpers for the TyVisitor impl\n-    pub fn new(ptr: *u8, writer: &'a mut io::Writer) -> ReprVisitor<'a> {\n-        ReprVisitor {\n-            ptr: ptr,\n-            ptr_stk: vec!(),\n-            var_stk: vec!(),\n-            writer: writer,\n-            last_err: None,\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn get<T>(&mut self, f: |&mut ReprVisitor, &T| -> bool) -> bool {\n-        unsafe {\n-            f(self, transmute::<*u8,&T>(self.ptr))\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn visit_inner(&mut self, inner: *TyDesc) -> bool {\n-        self.visit_ptr_inner(self.ptr, inner)\n-    }\n-\n-    #[inline]\n-    pub fn visit_ptr_inner(&mut self, ptr: *u8, inner: *TyDesc) -> bool {\n-        unsafe {\n-            let u = ReprVisitor::new(ptr, ::mem::transmute_copy(&self.writer));\n-            let mut v = reflect::MovePtrAdaptor::new(u);\n-            // Obviously this should not be a thing, but blame #8401 for now\n-            visit_tydesc(inner, &mut v as &mut TyVisitor);\n-            match v.unwrap().last_err {\n-                Some(e) => {\n-                    self.last_err = Some(e);\n-                    false\n-                }\n-                None => true,\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn write<T:Repr>(&mut self) -> bool {\n-        self.get(|this, v:&T| {\n-            try!(this, v.write_repr(this.writer));\n-            true\n-        })\n-    }\n-\n-    pub fn write_escaped_slice(&mut self, slice: &str) -> bool {\n-        try!(self, self.writer.write(['\"' as u8]));\n-        for ch in slice.chars() {\n-            if !self.write_escaped_char(ch, true) { return false }\n-        }\n-        try!(self, self.writer.write(['\"' as u8]));\n-        true\n-    }\n-\n-    pub fn write_mut_qualifier(&mut self, mtbl: uint) -> bool {\n-        if mtbl == 0 {\n-            try!(self, self.writer.write(\"mut \".as_bytes()));\n-        } else if mtbl == 1 {\n-            // skip, this is ast::m_imm\n-        } else {\n-            fail!(\"invalid mutability value\");\n-        }\n-        true\n-    }\n-\n-    pub fn write_vec_range(&mut self, ptr: *(), len: uint, inner: *TyDesc) -> bool {\n-        let mut p = ptr as *u8;\n-        let (sz, al) = unsafe { ((*inner).size, (*inner).align) };\n-        try!(self, self.writer.write(['[' as u8]));\n-        let mut first = true;\n-        let mut left = len;\n-        // unit structs have 0 size, and don't loop forever.\n-        let dec = if sz == 0 {1} else {sz};\n-        while left > 0 {\n-            if first {\n-                first = false;\n-            } else {\n-                try!(self, self.writer.write(\", \".as_bytes()));\n-            }\n-            self.visit_ptr_inner(p as *u8, inner);\n-            p = align(unsafe { p.offset(sz as int) as uint }, al) as *u8;\n-            left -= dec;\n-        }\n-        try!(self, self.writer.write([']' as u8]));\n-        true\n-    }\n-\n-    pub fn write_unboxed_vec_repr(&mut self, _: uint, v: &raw::Vec<()>, inner: *TyDesc) -> bool {\n-        self.write_vec_range(&v.data, v.fill, inner)\n-    }\n-\n-    fn write_escaped_char(&mut self, ch: char, is_str: bool) -> bool {\n-        try!(self, match ch {\n-            '\\t' => self.writer.write(\"\\\\t\".as_bytes()),\n-            '\\r' => self.writer.write(\"\\\\r\".as_bytes()),\n-            '\\n' => self.writer.write(\"\\\\n\".as_bytes()),\n-            '\\\\' => self.writer.write(\"\\\\\\\\\".as_bytes()),\n-            '\\'' => {\n-                if is_str {\n-                    self.writer.write(\"'\".as_bytes())\n-                } else {\n-                    self.writer.write(\"\\\\'\".as_bytes())\n-                }\n-            }\n-            '\"' => {\n-                if is_str {\n-                    self.writer.write(\"\\\\\\\"\".as_bytes())\n-                } else {\n-                    self.writer.write(\"\\\"\".as_bytes())\n-                }\n-            }\n-            '\\x20'..'\\x7e' => self.writer.write([ch as u8]),\n-            _ => {\n-                char::escape_unicode(ch, |c| {\n-                    let _ = self.writer.write([c as u8]);\n-                });\n-                Ok(())\n-            }\n-        });\n-        return true;\n-    }\n-}\n-\n-impl<'a> TyVisitor for ReprVisitor<'a> {\n-    fn visit_bot(&mut self) -> bool {\n-        try!(self, self.writer.write(\"!\".as_bytes()));\n-        true\n-    }\n-    fn visit_nil(&mut self) -> bool { self.write::<()>() }\n-    fn visit_bool(&mut self) -> bool { self.write::<bool>() }\n-    fn visit_int(&mut self) -> bool { self.write::<int>() }\n-    fn visit_i8(&mut self) -> bool { self.write::<i8>() }\n-    fn visit_i16(&mut self) -> bool { self.write::<i16>() }\n-    fn visit_i32(&mut self) -> bool { self.write::<i32>()  }\n-    fn visit_i64(&mut self) -> bool { self.write::<i64>() }\n-\n-    fn visit_uint(&mut self) -> bool { self.write::<uint>() }\n-    fn visit_u8(&mut self) -> bool { self.write::<u8>() }\n-    fn visit_u16(&mut self) -> bool { self.write::<u16>() }\n-    fn visit_u32(&mut self) -> bool { self.write::<u32>() }\n-    fn visit_u64(&mut self) -> bool { self.write::<u64>() }\n-\n-    fn visit_f32(&mut self) -> bool { self.write::<f32>() }\n-    fn visit_f64(&mut self) -> bool { self.write::<f64>() }\n-    fn visit_f128(&mut self) -> bool { fail!(\"not implemented\") }\n-\n-    fn visit_char(&mut self) -> bool {\n-        self.get::<char>(|this, &ch| {\n-            try!(this, this.writer.write(['\\'' as u8]));\n-            if !this.write_escaped_char(ch, false) { return false }\n-            try!(this, this.writer.write(['\\'' as u8]));\n-            true\n-        })\n-    }\n-\n-    fn visit_estr_box(&mut self) -> bool {\n-        true\n-    }\n-\n-    fn visit_estr_uniq(&mut self) -> bool {\n-        true\n-    }\n-\n-    fn visit_estr_slice(&mut self) -> bool {\n-        self.get::<&str>(|this, s| this.write_escaped_slice(*s))\n-    }\n-\n-    // Type no longer exists, vestigial function.\n-    fn visit_estr_fixed(&mut self, _n: uint, _sz: uint,\n-                        _align: uint) -> bool { fail!(); }\n-\n-    fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        try!(self, self.writer.write(['@' as u8]));\n-        self.write_mut_qualifier(mtbl);\n-        self.get::<&raw::Box<()>>(|this, b| {\n-            let p = &b.data as *() as *u8;\n-            this.visit_ptr_inner(p, inner)\n-        })\n-    }\n-\n-    fn visit_uniq(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n-        try!(self, self.writer.write(\"box \".as_bytes()));\n-        self.get::<*u8>(|this, b| {\n-            this.visit_ptr_inner(*b, inner)\n-        })\n-    }\n-\n-    fn visit_ptr(&mut self, mtbl: uint, _inner: *TyDesc) -> bool {\n-        self.get::<*u8>(|this, p| {\n-            try!(this, write!(this.writer, \"({} as *\", *p));\n-            this.write_mut_qualifier(mtbl);\n-            try!(this, this.writer.write(\"())\".as_bytes()));\n-            true\n-        })\n-    }\n-\n-    fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        try!(self, self.writer.write(['&' as u8]));\n-        self.write_mut_qualifier(mtbl);\n-        self.get::<*u8>(|this, p| {\n-            this.visit_ptr_inner(*p, inner)\n-        })\n-    }\n-\n-    fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.get::<&raw::Box<raw::Vec<()>>>(|this, b| {\n-            try!(this, this.writer.write(['@' as u8]));\n-            this.write_mut_qualifier(mtbl);\n-            this.write_unboxed_vec_repr(mtbl, &b.data, inner)\n-        })\n-    }\n-\n-    fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.get::<&raw::Vec<()>>(|this, b| {\n-            try!(this, this.writer.write(\"box \".as_bytes()));\n-            this.write_unboxed_vec_repr(mtbl, *b, inner)\n-        })\n-    }\n-\n-    fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.get::<raw::Slice<()>>(|this, s| {\n-            try!(this, this.writer.write(['&' as u8]));\n-            this.write_mut_qualifier(mtbl);\n-            let size = unsafe {\n-                if (*inner).size == 0 { 1 } else { (*inner).size }\n-            };\n-            this.write_vec_range(s.data, s.len * size, inner)\n-        })\n-    }\n-\n-    fn visit_evec_fixed(&mut self, n: uint, sz: uint, _align: uint,\n-                        _: uint, inner: *TyDesc) -> bool {\n-        let assumed_size = if sz == 0 { n } else { sz };\n-        self.get::<()>(|this, b| {\n-            this.write_vec_range(b, assumed_size, inner)\n-        })\n-    }\n-\n-    fn visit_enter_rec(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        try!(self, self.writer.write(['{' as u8]));\n-        true\n-    }\n-\n-    fn visit_rec_field(&mut self, i: uint, name: &str,\n-                       mtbl: uint, inner: *TyDesc) -> bool {\n-        if i != 0 {\n-            try!(self, self.writer.write(\", \".as_bytes()));\n-        }\n-        self.write_mut_qualifier(mtbl);\n-        try!(self, self.writer.write(name.as_bytes()));\n-        try!(self, self.writer.write(\": \".as_bytes()));\n-        self.visit_inner(inner);\n-        true\n-    }\n-\n-    fn visit_leave_rec(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        try!(self, self.writer.write(['}' as u8]));\n-        true\n-    }\n-\n-    fn visit_enter_class(&mut self, name: &str, named_fields: bool, n_fields: uint,\n-                         _sz: uint, _align: uint) -> bool {\n-        try!(self, self.writer.write(name.as_bytes()));\n-        if n_fields != 0 {\n-            if named_fields {\n-                try!(self, self.writer.write(['{' as u8]));\n-            } else {\n-                try!(self, self.writer.write(['(' as u8]));\n-            }\n-        }\n-        true\n-    }\n-\n-    fn visit_class_field(&mut self, i: uint, name: &str, named: bool,\n-                         _mtbl: uint, inner: *TyDesc) -> bool {\n-        if i != 0 {\n-            try!(self, self.writer.write(\", \".as_bytes()));\n-        }\n-        if named {\n-            try!(self, self.writer.write(name.as_bytes()));\n-            try!(self, self.writer.write(\": \".as_bytes()));\n-        }\n-        self.visit_inner(inner);\n-        true\n-    }\n-\n-    fn visit_leave_class(&mut self, _name: &str, named_fields: bool, n_fields: uint,\n-                         _sz: uint, _align: uint) -> bool {\n-        if n_fields != 0 {\n-            if named_fields {\n-                try!(self, self.writer.write(['}' as u8]));\n-            } else {\n-                try!(self, self.writer.write([')' as u8]));\n-            }\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_tup(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        try!(self, self.writer.write(['(' as u8]));\n-        true\n-    }\n-\n-    fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool {\n-        if i != 0 {\n-            try!(self, self.writer.write(\", \".as_bytes()));\n-        }\n-        self.visit_inner(inner);\n-        true\n-    }\n-\n-    fn visit_leave_tup(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        if _n_fields == 1 {\n-            try!(self, self.writer.write([',' as u8]));\n-        }\n-        try!(self, self.writer.write([')' as u8]));\n-        true\n-    }\n-\n-    fn visit_enter_enum(&mut self,\n-                        _n_variants: uint,\n-                        get_disr: unsafe extern fn(ptr: *Opaque) -> Disr,\n-                        _sz: uint,\n-                        _align: uint) -> bool {\n-        let disr = unsafe {\n-            get_disr(transmute(self.ptr))\n-        };\n-        self.var_stk.push(SearchingFor(disr));\n-        true\n-    }\n-\n-    fn visit_enter_enum_variant(&mut self, _variant: uint,\n-                                disr_val: Disr,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        let mut write = false;\n-        match self.var_stk.pop().unwrap() {\n-            SearchingFor(sought) => {\n-                if disr_val == sought {\n-                    self.var_stk.push(Matched);\n-                    write = true;\n-                } else {\n-                    self.var_stk.push(SearchingFor(sought));\n-                }\n-            }\n-            Matched | AlreadyFound => {\n-                self.var_stk.push(AlreadyFound);\n-            }\n-        }\n-\n-        if write {\n-            try!(self, self.writer.write(name.as_bytes()));\n-            if n_fields > 0 {\n-                try!(self, self.writer.write(['(' as u8]));\n-            }\n-        }\n-        true\n-    }\n-\n-    fn visit_enum_variant_field(&mut self,\n-                                i: uint,\n-                                _offset: uint,\n-                                inner: *TyDesc)\n-                                -> bool {\n-        match *self.var_stk.get(self.var_stk.len() - 1) {\n-            Matched => {\n-                if i != 0 {\n-                    try!(self, self.writer.write(\", \".as_bytes()));\n-                }\n-                if ! self.visit_inner(inner) {\n-                    return false;\n-                }\n-            }\n-            _ => ()\n-        }\n-        true\n-    }\n-\n-    fn visit_leave_enum_variant(&mut self, _variant: uint,\n-                                _disr_val: Disr,\n-                                n_fields: uint,\n-                                _name: &str) -> bool {\n-        match *self.var_stk.get(self.var_stk.len() - 1) {\n-            Matched => {\n-                if n_fields > 0 {\n-                    try!(self, self.writer.write([')' as u8]));\n-                }\n-            }\n-            _ => ()\n-        }\n-        true\n-    }\n-\n-    fn visit_leave_enum(&mut self,\n-                        _n_variants: uint,\n-                        _get_disr: unsafe extern fn(ptr: *Opaque) -> Disr,\n-                        _sz: uint,\n-                        _align: uint)\n-                        -> bool {\n-        match self.var_stk.pop().unwrap() {\n-            SearchingFor(..) => fail!(\"enum value matched no variant\"),\n-            _ => true\n-        }\n-    }\n-\n-    fn visit_enter_fn(&mut self, _purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool {\n-        try!(self, self.writer.write(\"fn(\".as_bytes()));\n-        true\n-    }\n-\n-    fn visit_fn_input(&mut self, i: uint, _mode: uint, inner: *TyDesc) -> bool {\n-        if i != 0 {\n-            try!(self, self.writer.write(\", \".as_bytes()));\n-        }\n-        let name = unsafe { (*inner).name };\n-        try!(self, self.writer.write(name.as_bytes()));\n-        true\n-    }\n-\n-    fn visit_fn_output(&mut self, _retstyle: uint, variadic: bool,\n-                       inner: *TyDesc) -> bool {\n-        if variadic {\n-            try!(self, self.writer.write(\", ...\".as_bytes()));\n-        }\n-        try!(self, self.writer.write(\")\".as_bytes()));\n-        let name = unsafe { (*inner).name };\n-        if name != \"()\" {\n-            try!(self, self.writer.write(\" -> \".as_bytes()));\n-            try!(self, self.writer.write(name.as_bytes()));\n-        }\n-        true\n-    }\n-\n-    fn visit_leave_fn(&mut self, _purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n-\n-\n-    fn visit_trait(&mut self, name: &str) -> bool {\n-        try!(self, self.writer.write(name.as_bytes()));\n-        true\n-    }\n-\n-    fn visit_param(&mut self, _i: uint) -> bool { true }\n-    fn visit_self(&mut self) -> bool { true }\n-}\n-\n-pub fn write_repr<T>(writer: &mut io::Writer, object: &T) -> io::IoResult<()> {\n-    unsafe {\n-        let ptr = object as *T as *u8;\n-        let tydesc = get_tydesc::<T>();\n-        let u = ReprVisitor::new(ptr, writer);\n-        let mut v = reflect::MovePtrAdaptor::new(u);\n-        visit_tydesc(tydesc, &mut v as &mut TyVisitor);\n-        match v.unwrap().last_err {\n-            Some(e) => Err(e),\n-            None => Ok(()),\n-        }\n-    }\n-}\n-\n-pub fn repr_to_str<T>(t: &T) -> String {\n-    use str;\n-    use str::StrAllocating;\n-    use io;\n-\n-    let mut result = io::MemWriter::new();\n-    write_repr(&mut result as &mut io::Writer, t).unwrap();\n-    str::from_utf8(result.unwrap().as_slice()).unwrap().to_string()\n-}\n-\n-#[cfg(test)]\n-struct P {a: int, b: f64}\n-\n-#[test]\n-fn test_repr() {\n-    use prelude::*;\n-    use str;\n-    use str::Str;\n-    use io::stdio::println;\n-    use char::is_alphabetic;\n-    use mem::swap;\n-\n-    fn exact_test<T>(t: &T, e:&str) {\n-        let mut m = io::MemWriter::new();\n-        write_repr(&mut m as &mut io::Writer, t).unwrap();\n-        let s = str::from_utf8(m.unwrap().as_slice()).unwrap().to_owned();\n-        assert_eq!(s.as_slice(), e);\n-    }\n-\n-    exact_test(&10, \"10\");\n-    exact_test(&true, \"true\");\n-    exact_test(&false, \"false\");\n-    exact_test(&1.234, \"1.234f64\");\n-    exact_test(&(\"hello\"), \"\\\"hello\\\"\");\n-\n-    exact_test(&(@10), \"@10\");\n-    exact_test(&(box 10), \"box 10\");\n-    exact_test(&(&10), \"&10\");\n-    let mut x = 10;\n-    exact_test(&(&mut x), \"&mut 10\");\n-\n-    exact_test(&(0 as *()), \"(0x0 as *())\");\n-    exact_test(&(0 as *mut ()), \"(0x0 as *mut ())\");\n-\n-    exact_test(&(1,), \"(1,)\");\n-    exact_test(&(&[\"hi\", \"there\"]),\n-               \"&[\\\"hi\\\", \\\"there\\\"]\");\n-    exact_test(&(P{a:10, b:1.234}),\n-               \"repr::P{a: 10, b: 1.234f64}\");\n-    exact_test(&(@P{a:10, b:1.234}),\n-               \"@repr::P{a: 10, b: 1.234f64}\");\n-    exact_test(&(box P{a:10, b:1.234}),\n-               \"box repr::P{a: 10, b: 1.234f64}\");\n-\n-    exact_test(&(&[1, 2]), \"&[1, 2]\");\n-    exact_test(&(&mut [1, 2]), \"&mut [1, 2]\");\n-\n-    exact_test(&'\\'', \"'\\\\''\");\n-    exact_test(&'\"', \"'\\\"'\");\n-    exact_test(&(\"'\"), \"\\\"'\\\"\");\n-    exact_test(&(\"\\\"\"), \"\\\"\\\\\\\"\\\"\");\n-\n-    exact_test(&println, \"fn(&str)\");\n-    exact_test(&swap::<int>, \"fn(&mut int, &mut int)\");\n-    exact_test(&is_alphabetic, \"fn(char) -> bool\");\n-\n-    struct Bar(int, int);\n-    exact_test(&(Bar(2, 2)), \"repr::test_repr::Bar(2, 2)\");\n-}"}, {"sha": "dc6ab494d643ebaa2cf122ac56d2de8312313c58", "filename": "src/libstd/rt/stack.rs", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fstack.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -30,7 +30,7 @@ pub static RED_ZONE: uint = 20 * 1024;\n /// stacks are currently not enabled as segmented stacks, but rather one giant\n /// stack segment. This means that whenever we run out of stack, we want to\n /// truly consider it to be stack overflow rather than allocating a new stack.\n-#[cfg(not(test), not(stage0))] // in testing, use the original libstd's version\n+#[cfg(not(test))] // in testing, use the original libstd's version\n #[lang = \"stack_exhausted\"]\n extern fn stack_exhausted() {\n     use option::{Option, None, Some};\n@@ -103,35 +103,6 @@ extern fn stack_exhausted() {\n     }\n }\n \n-#[no_mangle]      // - this is called from C code\n-#[no_split_stack] // - it would be sad for this function to trigger __morestack\n-#[doc(hidden)]    // - Function must be `pub` to get exported, but it's\n-                  //   irrelevant for documentation purposes.\n-#[cfg(stage0, not(test))] // in testing, use the original libstd's version\n-pub extern \"C\" fn rust_stack_exhausted() {\n-    use option::{Option, None, Some};\n-    use owned::Box;\n-    use rt::local::Local;\n-    use rt::task::Task;\n-    use str::Str;\n-    use intrinsics;\n-\n-    unsafe {\n-        let limit = get_sp_limit();\n-        record_sp_limit(limit - RED_ZONE / 2);\n-        let task: Option<Box<Task>> = Local::try_take();\n-        let name = match task {\n-            Some(ref task) => {\n-                task.name.as_ref().map(|n| n.as_slice())\n-            }\n-            None => None\n-        };\n-        let name = name.unwrap_or(\"<unknown>\");\n-        rterrln!(\"task '{}' has overflowed its stack\", name);\n-        intrinsics::abort();\n-    }\n-}\n-\n #[inline(always)]\n pub unsafe fn record_stack_bounds(stack_lo: uint, stack_hi: uint) {\n     // When the old runtime had segmented stacks, it used a calculation that was"}, {"sha": "dc2646102d208ea6111c2751f115c6857dcc3321", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 1, "deletions": 40, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -213,7 +213,6 @@ pub mod eabi {\n     }\n \n     #[lang=\"eh_personality\"]\n-    #[cfg(not(stage0))]\n     extern fn eh_personality(\n         version: c_int,\n         actions: uw::_Unwind_Action,\n@@ -227,22 +226,6 @@ pub mod eabi {\n                                  context)\n         }\n     }\n-    #[lang=\"eh_personality\"]\n-    #[no_mangle] // so we can reference it by name from middle/trans/base.rs\n-    #[cfg(stage0)]\n-    pub extern \"C\" fn rust_eh_personality(\n-        version: c_int,\n-        actions: uw::_Unwind_Action,\n-        exception_class: uw::_Unwind_Exception_Class,\n-        ue_header: *uw::_Unwind_Exception,\n-        context: *uw::_Unwind_Context\n-    ) -> uw::_Unwind_Reason_Code\n-    {\n-        unsafe {\n-            __gcc_personality_v0(version, actions, exception_class, ue_header,\n-                                 context)\n-        }\n-    }\n \n     #[no_mangle] // referenced from rust_try.ll\n     pub extern \"C\" fn rust_eh_personality_catch(\n@@ -281,7 +264,6 @@ pub mod eabi {\n     }\n \n     #[lang=\"eh_personality\"]\n-    #[cfg(not(stage0))]\n     extern \"C\" fn eh_personality(\n         state: uw::_Unwind_State,\n         ue_header: *uw::_Unwind_Exception,\n@@ -293,20 +275,6 @@ pub mod eabi {\n         }\n     }\n \n-    #[lang=\"eh_personality\"]\n-    #[no_mangle] // so we can reference it by name from middle/trans/base.rs\n-    #[cfg(stage0)]\n-    pub extern \"C\" fn rust_eh_personality(\n-        state: uw::_Unwind_State,\n-        ue_header: *uw::_Unwind_Exception,\n-        context: *uw::_Unwind_Context\n-    ) -> uw::_Unwind_Reason_Code\n-    {\n-        unsafe {\n-            __gcc_personality_v0(state, ue_header, context)\n-        }\n-    }\n-\n     #[no_mangle] // referenced from rust_try.ll\n     pub extern \"C\" fn rust_eh_personality_catch(\n         state: uw::_Unwind_State,\n@@ -327,20 +295,13 @@ pub mod eabi {\n }\n \n // Entry point of failure from the libcore crate\n-#[cfg(not(test), not(stage0))]\n+#[cfg(not(test))]\n #[lang = \"begin_unwind\"]\n pub extern fn rust_begin_unwind(msg: &fmt::Arguments,\n                                 file: &'static str, line: uint) -> ! {\n     begin_unwind_fmt(msg, file, line)\n }\n \n-#[no_mangle]\n-#[cfg(not(test), stage0)]\n-pub extern fn rust_begin_unwind(msg: &fmt::Arguments,\n-                                file: &'static str, line: uint) -> ! {\n-    begin_unwind_fmt(msg, file, line)\n-}\n-\n /// The entry point for unwinding with a formatted message.\n ///\n /// This is designed to reduce the amount of code required at the call"}, {"sha": "1433270346e76cfead4d1c93c4602941873f5714", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -1916,7 +1916,7 @@ mod tests {\n         assert!(values == [2, 3, 5, 6, 7]);\n     }\n \n-    #[deriving(Clone, Eq)]\n+    #[deriving(Clone, PartialEq)]\n     struct Foo;\n \n     #[test]"}, {"sha": "a35b4e7a151a0d86f28a35473310f4af04712a7e", "filename": "src/libstd/str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -68,7 +68,7 @@ is the same as `&[u8]`.\n use char::Char;\n use char;\n use clone::Clone;\n-use cmp::{Eq, TotalEq, Ord, TotalOrd, Equiv, Ordering};\n+use cmp::{PartialEq, TotalEq, PartialOrd, TotalOrd, Equiv, Ordering};\n use container::Container;\n use default::Default;\n use fmt;\n@@ -566,7 +566,7 @@ impl<'a> IntoMaybeOwned<'a> for MaybeOwned<'a> {\n     fn into_maybe_owned(self) -> MaybeOwned<'a> { self }\n }\n \n-impl<'a> Eq for MaybeOwned<'a> {\n+impl<'a> PartialEq for MaybeOwned<'a> {\n     #[inline]\n     fn eq(&self, other: &MaybeOwned) -> bool {\n         self.as_slice() == other.as_slice()\n@@ -575,7 +575,7 @@ impl<'a> Eq for MaybeOwned<'a> {\n \n impl<'a> TotalEq for MaybeOwned<'a> {}\n \n-impl<'a> Ord for MaybeOwned<'a> {\n+impl<'a> PartialOrd for MaybeOwned<'a> {\n     #[inline]\n     fn lt(&self, other: &MaybeOwned) -> bool {\n         self.as_slice().lt(&other.as_slice())"}, {"sha": "29d3c7186823e626c9f66967065c838352727dd9", "filename": "src/libstd/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstring.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -30,7 +30,7 @@ use str;\n use vec::Vec;\n \n /// A growable string stored as a UTF-8 encoded buffer.\n-#[deriving(Clone, Eq, Ord, TotalEq, TotalOrd)]\n+#[deriving(Clone, PartialEq, PartialOrd, TotalEq, TotalOrd)]\n pub struct String {\n     vec: Vec<u8>,\n }"}, {"sha": "ea4c12f44019876141480bff73ba5cc760f0ccec", "filename": "src/libstd/sync/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -102,7 +102,7 @@ pub struct Stealer<T> {\n }\n \n /// When stealing some data, this is an enumeration of the possible outcomes.\n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n pub enum Stolen<T> {\n     /// The deque was empty at the time of stealing\n     Empty,"}, {"sha": "3cac6fadb9433d7e6175edfe402a74fe63ecadf2", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -12,7 +12,7 @@\n \n use RawVec = raw::Vec;\n use clone::Clone;\n-use cmp::{Ord, Eq, Ordering, TotalEq, TotalOrd, max};\n+use cmp::{PartialOrd, PartialEq, Ordering, TotalEq, TotalOrd, max};\n use container::{Container, Mutable};\n use default::Default;\n use fmt;\n@@ -374,14 +374,14 @@ impl<T> Extendable<T> for Vec<T> {\n     }\n }\n \n-impl<T: Eq> Eq for Vec<T> {\n+impl<T: PartialEq> PartialEq for Vec<T> {\n     #[inline]\n     fn eq(&self, other: &Vec<T>) -> bool {\n         self.as_slice() == other.as_slice()\n     }\n }\n \n-impl<T: Ord> Ord for Vec<T> {\n+impl<T: PartialOrd> PartialOrd for Vec<T> {\n     #[inline]\n     fn lt(&self, other: &Vec<T>) -> bool {\n         self.as_slice() < other.as_slice()\n@@ -1288,7 +1288,7 @@ impl<T> Mutable for Vec<T> {\n     }\n }\n \n-impl<T:Eq> Vec<T> {\n+impl<T:PartialEq> Vec<T> {\n     /// Return true if a vector contains an element with the given value\n     ///\n     /// # Example\n@@ -1315,7 +1315,7 @@ impl<T:Eq> Vec<T> {\n     pub fn dedup(&mut self) {\n         unsafe {\n             // Although we have a mutable reference to `self`, we cannot make\n-            // *arbitrary* changes. The `Eq` comparisons could fail, so we\n+            // *arbitrary* changes. The `PartialEq` comparisons could fail, so we\n             // must ensure that the vector is in a valid state at all time.\n             //\n             // The way that we handle this is by using swaps; we iterate"}, {"sha": "ee7fa525e79f56d8c5aeb32fe6cf003f1cc90c2b", "filename": "src/libsync/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmutex.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -97,7 +97,7 @@ pub struct Mutex {\n     lock: StaticMutex,\n }\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n enum Flavor {\n     Unlocked,\n     TryLockAcquisition,"}, {"sha": "e61c1c24c2f89b47432a2ca24081b0a03d0b6533", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -10,10 +10,10 @@\n \n use std::fmt;\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum Os { OsWin32, OsMacos, OsLinux, OsAndroid, OsFreebsd, }\n \n-#[deriving(Eq, TotalEq, Hash, Encodable, Decodable, Clone)]\n+#[deriving(PartialEq, TotalEq, Hash, Encodable, Decodable, Clone)]\n pub enum Abi {\n     // NB: This ordering MUST match the AbiDatas array below.\n     // (This is ensured by the test indices_are_correct().)\n@@ -33,7 +33,7 @@ pub enum Abi {\n }\n \n #[allow(non_camel_case_types)]\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum Architecture {\n     // NB. You cannot change the ordering of these\n     // constants without adjusting IntelBits below."}, {"sha": "5eb9308e443382f886b8dce4536b99231b14f41f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 85, "deletions": 85, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -39,7 +39,7 @@ pub fn P<T: 'static>(value: T) -> P<T> {\n // table) and a SyntaxContext to track renaming and\n // macro expansion per Flatt et al., \"Macros\n // That Work Together\"\n-#[deriving(Clone, Hash, Ord, TotalEq, TotalOrd, Show)]\n+#[deriving(Clone, Hash, PartialOrd, TotalEq, TotalOrd, Show)]\n pub struct Ident {\n     pub name: Name,\n     pub ctxt: SyntaxContext\n@@ -50,7 +50,7 @@ impl Ident {\n     pub fn new(name: Name) -> Ident { Ident {name: name, ctxt: EMPTY_CTXT}}\n }\n \n-impl Eq for Ident {\n+impl PartialEq for Ident {\n     fn eq(&self, other: &Ident) -> bool {\n         if self.ctxt == other.ctxt {\n             self.name == other.name\n@@ -114,18 +114,18 @@ impl<D:Decoder<E>, E> Decodable<D, E> for Ident {\n /// Function name (not all functions have names)\n pub type FnIdent = Option<Ident>;\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Lifetime {\n     pub id: NodeId,\n     pub span: Span,\n     pub name: Name\n }\n \n // a \"Path\" is essentially Rust's notion of a name;\n-// for instance: std::cmp::Eq  .  It's represented\n+// for instance: std::cmp::PartialEq  .  It's represented\n // as a sequence of identifiers, along with a bunch\n // of supporting information.\n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Path {\n     pub span: Span,\n     /// A `::foo` path, is relative to the crate root rather than current\n@@ -137,7 +137,7 @@ pub struct Path {\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     pub identifier: Ident,\n@@ -151,7 +151,7 @@ pub type CrateNum = u32;\n \n pub type NodeId = u32;\n \n-#[deriving(Clone, TotalEq, TotalOrd, Ord, Eq, Encodable, Decodable, Hash, Show)]\n+#[deriving(Clone, TotalEq, TotalOrd, PartialOrd, PartialEq, Encodable, Decodable, Hash, Show)]\n pub struct DefId {\n     pub krate: CrateNum,\n     pub node: NodeId,\n@@ -171,14 +171,14 @@ pub static DUMMY_NODE_ID: NodeId = -1;\n // typeck::collect::compute_bounds matches these against\n // the \"special\" built-in traits (see middle::lang_items) and\n // detects Copy, Send and Share.\n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum TyParamBound {\n     TraitTyParamBound(TraitRef),\n     StaticRegionTyParamBound,\n     OtherRegionTyParamBound(Span) // FIXME -- just here until work for #5723 lands\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct TyParam {\n     pub ident: Ident,\n     pub id: NodeId,\n@@ -188,7 +188,7 @@ pub struct TyParam {\n     pub span: Span\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Generics {\n     pub lifetimes: Vec<Lifetime>,\n     pub ty_params: OwnedSlice<TyParam>,\n@@ -206,13 +206,13 @@ impl Generics {\n     }\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum MethodProvenance {\n     FromTrait(DefId),\n     FromImpl(DefId),\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Def {\n     DefFn(DefId, FnStyle),\n     DefStaticMethod(/* method */ DefId, MethodProvenance, FnStyle),\n@@ -249,7 +249,7 @@ pub enum Def {\n     DefMethod(DefId /* method */, Option<DefId> /* trait */),\n }\n \n-#[deriving(Clone, Eq, TotalEq, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash, Encodable, Decodable, Show)]\n pub enum DefRegion {\n     DefStaticRegion,\n     DefEarlyBoundRegion(/* index */ uint, /* lifetime decl */ NodeId),\n@@ -261,7 +261,7 @@ pub enum DefRegion {\n // used to drive conditional compilation\n pub type CrateConfig = Vec<@MetaItem> ;\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Crate {\n     pub module: Mod,\n     pub attrs: Vec<Attribute>,\n@@ -279,7 +279,7 @@ pub enum MetaItem_ {\n }\n \n // can't be derived because the MetaList requires an unordered comparison\n-impl Eq for MetaItem_ {\n+impl PartialEq for MetaItem_ {\n     fn eq(&self, other: &MetaItem_) -> bool {\n         match *self {\n             MetaWord(ref ns) => match *other {\n@@ -303,7 +303,7 @@ impl Eq for MetaItem_ {\n     }\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Block {\n     pub view_items: Vec<ViewItem>,\n     pub stmts: Vec<@Stmt>,\n@@ -313,26 +313,26 @@ pub struct Block {\n     pub span: Span,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Pat {\n     pub id: NodeId,\n     pub node: Pat_,\n     pub span: Span,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct FieldPat {\n     pub ident: Ident,\n     pub pat: @Pat,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum BindingMode {\n     BindByRef(Mutability),\n     BindByValue(Mutability),\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Pat_ {\n     PatWild,\n     PatWildMulti,\n@@ -358,20 +358,20 @@ pub enum Pat_ {\n     PatMac(Mac),\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash, Show)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash, Show)]\n pub enum Mutability {\n     MutMutable,\n     MutImmutable,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum ExprVstore {\n     ExprVstoreUniq,                 // ~[1,2,3,4]\n     ExprVstoreSlice,                // &[1,2,3,4]\n     ExprVstoreMutSlice,             // &mut [1,2,3,4]\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum BinOp {\n     BiAdd,\n     BiSub,\n@@ -393,7 +393,7 @@ pub enum BinOp {\n     BiGt,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum UnOp {\n     UnBox,\n     UnUniq,\n@@ -404,7 +404,7 @@ pub enum UnOp {\n \n pub type Stmt = Spanned<Stmt_>;\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Stmt_ {\n     // could be an item or a local (let) binding:\n     StmtDecl(@Decl, NodeId),\n@@ -421,7 +421,7 @@ pub enum Stmt_ {\n \n /// Where a local declaration came from: either a true `let ... =\n /// ...;`, or one desugared from the pattern of a for loop.\n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum LocalSource {\n     LocalLet,\n     LocalFor,\n@@ -430,7 +430,7 @@ pub enum LocalSource {\n // FIXME (pending discussion of #1697, #2178...): local should really be\n // a refinement on pat.\n /// Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`\n-#[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Local {\n     pub ty: P<Ty>,\n     pub pat: @Pat,\n@@ -442,23 +442,23 @@ pub struct Local {\n \n pub type Decl = Spanned<Decl_>;\n \n-#[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Decl_ {\n     // a local (let) binding:\n     DeclLocal(@Local),\n     // an item binding:\n     DeclItem(@Item),\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Arm {\n     pub attrs: Vec<Attribute>,\n     pub pats: Vec<@Pat>,\n     pub guard: Option<@Expr>,\n     pub body: @Expr,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Field {\n     pub ident: SpannedIdent,\n     pub expr: @Expr,\n@@ -467,26 +467,26 @@ pub struct Field {\n \n pub type SpannedIdent = Spanned<Ident>;\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum BlockCheckMode {\n     DefaultBlock,\n     UnsafeBlock(UnsafeSource),\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum UnsafeSource {\n     CompilerGenerated,\n     UserProvided,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Expr {\n     pub id: NodeId,\n     pub node: Expr_,\n     pub span: Span,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Expr_ {\n     ExprVstore(@Expr, ExprVstore),\n     // First expr is the place; second expr is the value.\n@@ -555,7 +555,7 @@ pub enum Expr_ {\n // else knows what to do with them, so you'll probably get a syntax\n // error.\n //\n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n pub enum TokenTree {\n     // a single token\n@@ -631,7 +631,7 @@ pub enum TokenTree {\n //\n pub type Matcher = Spanned<Matcher_>;\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Matcher_ {\n     // match one token\n     MatchTok(::parse::token::Token),\n@@ -648,20 +648,20 @@ pub type Mac = Spanned<Mac_>;\n // is being invoked, and the vector of token-trees contains the source\n // of the macro invocation.\n // There's only one flavor, now, so this could presumably be simplified.\n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Mac_ {\n     MacInvocTT(Path, Vec<TokenTree> , SyntaxContext),   // new macro-invocation\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum StrStyle {\n     CookedStr,\n     RawStr(uint)\n }\n \n pub type Lit = Spanned<Lit_>;\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Lit_ {\n     LitStr(InternedString, StrStyle),\n     LitBinary(Rc<Vec<u8> >),\n@@ -677,20 +677,20 @@ pub enum Lit_ {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct MutTy {\n     pub ty: P<Ty>,\n     pub mutbl: Mutability,\n }\n \n-#[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct TypeField {\n     pub ident: Ident,\n     pub mt: MutTy,\n     pub span: Span,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct TypeMethod {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -706,13 +706,13 @@ pub struct TypeMethod {\n // A trait method is either required (meaning it doesn't have an\n // implementation, just a signature) or provided (meaning it has a default\n // implementation).\n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum TraitMethod {\n     Required(TypeMethod),\n     Provided(@Method),\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum IntTy {\n     TyI,\n     TyI8,\n@@ -728,7 +728,7 @@ impl fmt::Show for IntTy {\n     }\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum UintTy {\n     TyU,\n     TyU8,\n@@ -744,7 +744,7 @@ impl fmt::Show for UintTy {\n     }\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum FloatTy {\n     TyF32,\n     TyF64,\n@@ -757,16 +757,16 @@ impl fmt::Show for FloatTy {\n     }\n }\n \n-// NB Eq method appears below.\n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+// NB PartialEq method appears below.\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Ty {\n     pub id: NodeId,\n     pub node: Ty_,\n     pub span: Span,\n }\n \n // Not represented directly in the AST, referred to by name through a ty_path.\n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum PrimTy {\n     TyInt(IntTy),\n     TyUint(UintTy),\n@@ -776,7 +776,7 @@ pub enum PrimTy {\n     TyChar\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Onceness {\n     Once,\n     Many\n@@ -791,7 +791,7 @@ impl fmt::Show for Onceness {\n     }\n }\n \n-#[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct ClosureTy {\n     pub lifetimes: Vec<Lifetime>,\n     pub fn_style: FnStyle,\n@@ -804,15 +804,15 @@ pub struct ClosureTy {\n     pub bounds: Option<OwnedSlice<TyParamBound>>,\n }\n \n-#[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct BareFnTy {\n     pub fn_style: FnStyle,\n     pub abi: Abi,\n     pub lifetimes: Vec<Lifetime>,\n     pub decl: P<FnDecl>\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Ty_ {\n     TyNil,\n     TyBot, /* bottom type */\n@@ -833,13 +833,13 @@ pub enum Ty_ {\n     TyInfer,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum AsmDialect {\n     AsmAtt,\n     AsmIntel\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct InlineAsm {\n     pub asm: InternedString,\n     pub asm_str_style: StrStyle,\n@@ -851,7 +851,7 @@ pub struct InlineAsm {\n     pub dialect: AsmDialect\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Arg {\n     pub ty: P<Ty>,\n     pub pat: @Pat,\n@@ -878,15 +878,15 @@ impl Arg {\n     }\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct FnDecl {\n     pub inputs: Vec<Arg>,\n     pub output: P<Ty>,\n     pub cf: RetStyle,\n     pub variadic: bool\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum FnStyle {\n     UnsafeFn, // declared with \"unsafe fn\"\n     NormalFn, // declared with \"fn\"\n@@ -901,14 +901,14 @@ impl fmt::Show for FnStyle {\n     }\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum RetStyle {\n     NoReturn, // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n     Return, // everything else\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum ExplicitSelf_ {\n     SelfStatic,                                // no self\n     SelfValue,                                 // `self`\n@@ -918,7 +918,7 @@ pub enum ExplicitSelf_ {\n \n pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n \n-#[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Method {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -932,7 +932,7 @@ pub struct Method {\n     pub vis: Visibility,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Mod {\n     /// A span from the first token past `{` to the last token until `}`.\n     /// For `mod foo;`, the inner span ranges from the first token\n@@ -942,31 +942,31 @@ pub struct Mod {\n     pub items: Vec<@Item>,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct ForeignMod {\n     pub abi: Abi,\n     pub view_items: Vec<ViewItem>,\n     pub items: Vec<@ForeignItem>,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct VariantArg {\n     pub ty: P<Ty>,\n     pub id: NodeId,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum VariantKind {\n     TupleVariantKind(Vec<VariantArg>),\n     StructVariantKind(@StructDef),\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct EnumDef {\n     pub variants: Vec<P<Variant>>,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Variant_ {\n     pub name: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -978,7 +978,7 @@ pub struct Variant_ {\n \n pub type Variant = Spanned<Variant_>;\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct PathListIdent_ {\n     pub name: Ident,\n     pub id: NodeId,\n@@ -988,7 +988,7 @@ pub type PathListIdent = Spanned<PathListIdent_>;\n \n pub type ViewPath = Spanned<ViewPath_>;\n \n-#[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum ViewPath_ {\n \n     // quux = foo::bar::baz\n@@ -1005,15 +1005,15 @@ pub enum ViewPath_ {\n     ViewPathList(Path, Vec<PathListIdent> , NodeId)\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct ViewItem {\n     pub node: ViewItem_,\n     pub attrs: Vec<Attribute>,\n     pub vis: Visibility,\n     pub span: Span,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum ViewItem_ {\n     // ident: name used to refer to this crate in the code\n     // optional (InternedString,StrStyle): if present, this is a location\n@@ -1029,17 +1029,17 @@ pub type Attribute = Spanned<Attribute_>;\n // Distinguishes between Attributes that decorate items and Attributes that\n // are contained as statements within items. These two cases need to be\n // distinguished for pretty-printing.\n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum AttrStyle {\n     AttrOuter,\n     AttrInner,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct AttrId(pub uint);\n \n // doc-comments are promoted to attributes that have is_sugared_doc = true\n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Attribute_ {\n     pub id: AttrId,\n     pub style: AttrStyle,\n@@ -1054,13 +1054,13 @@ pub struct Attribute_ {\n   If this impl is an ItemImpl, the impl_id is redundant (it could be the\n   same as the impl's node id).\n  */\n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct TraitRef {\n     pub path: Path,\n     pub ref_id: NodeId,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Visibility {\n     Public,\n     Inherited,\n@@ -1075,13 +1075,13 @@ impl Visibility {\n     }\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Sized {\n     DynSize,\n     StaticSize,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct StructField_ {\n     pub kind: StructFieldKind,\n     pub id: NodeId,\n@@ -1091,7 +1091,7 @@ pub struct StructField_ {\n \n pub type StructField = Spanned<StructField_>;\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum StructFieldKind {\n     NamedField(Ident, Visibility),\n     UnnamedField(Visibility), // element of a tuple-like struct\n@@ -1106,7 +1106,7 @@ impl StructFieldKind {\n     }\n }\n \n-#[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct StructDef {\n     pub fields: Vec<StructField>, /* fields, not including ctor */\n     /* ID of the constructor. This is only used for tuple- or enum-like\n@@ -1120,7 +1120,7 @@ pub struct StructDef {\n   FIXME (#3300): Should allow items to be anonymous. Right now\n   we just use dummy names for anon items.\n  */\n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Item {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -1130,7 +1130,7 @@ pub struct Item {\n     pub span: Span,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Item_ {\n     ItemStatic(P<Ty>, Mutability, @Expr),\n     ItemFn(P<FnDecl>, FnStyle, Abi, Generics, P<Block>),\n@@ -1148,7 +1148,7 @@ pub enum Item_ {\n     ItemMac(Mac),\n }\n \n-#[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct ForeignItem {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -1158,7 +1158,7 @@ pub struct ForeignItem {\n     pub vis: Visibility,\n }\n \n-#[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum ForeignItem_ {\n     ForeignItemFn(P<FnDecl>, Generics),\n     ForeignItemStatic(P<Ty>, /* is_mutbl */ bool),\n@@ -1167,7 +1167,7 @@ pub enum ForeignItem_ {\n // The data we save and restore about an inlined item or method.  This is not\n // part of the AST that we parse from a file, but it becomes part of the tree\n // that we trans.\n-#[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub enum InlinedItem {\n     IIItem(@Item),\n     IIMethod(DefId /* impl id */, bool /* is provided */, @Method),"}, {"sha": "9a7b4f7d9497aac25657170d3a0914c808726d5a", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -24,7 +24,7 @@ use std::iter;\n use std::slice;\n use std::string::String;\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub enum PathElem {\n     PathMod(Name),\n     PathName(Name)"}, {"sha": "4a38835f86bec661c6644e97af0a832325a9abd6", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -307,7 +307,7 @@ pub fn find_crateid(attrs: &[Attribute]) -> Option<CrateId> {\n     }\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum InlineAttr {\n     InlineNone,\n     InlineHint,\n@@ -396,7 +396,7 @@ pub struct Stability {\n }\n \n /// The available stability levels.\n-#[deriving(Eq,Ord,Clone,Show)]\n+#[deriving(PartialEq,PartialOrd,Clone,Show)]\n pub enum StabilityLevel {\n     Deprecated,\n     Experimental,\n@@ -522,7 +522,7 @@ fn int_type_of_word(s: &str) -> Option<IntType> {\n     }\n }\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n pub enum ReprAttr {\n     ReprAny,\n     ReprInt(Span, IntType),\n@@ -539,7 +539,7 @@ impl ReprAttr {\n     }\n }\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n pub enum IntType {\n     SignedInt(ast::IntTy),\n     UnsignedInt(ast::UintTy)"}, {"sha": "59bf9608a097d847d219e4ff6eaebc849a9614e3", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -33,13 +33,13 @@ pub trait Pos {\n \n /// A byte offset. Keep this small (currently 32-bits), as AST contains\n /// a lot of them.\n-#[deriving(Clone, Eq, TotalEq, Hash, Ord, Show)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash, PartialOrd, Show)]\n pub struct BytePos(pub u32);\n \n /// A character offset. Because of multibyte utf8 characters, a byte offset\n /// is not equivalent to a character offset. The CodeMap will convert BytePos\n /// values to CharPos values as necessary.\n-#[deriving(Eq, Hash, Ord, Show)]\n+#[deriving(PartialEq, Hash, PartialOrd, Show)]\n pub struct CharPos(pub uint);\n \n // FIXME: Lots of boilerplate in these impls, but so far my attempts to fix\n@@ -96,13 +96,13 @@ pub struct Span {\n \n pub static DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_info: None };\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Spanned<T> {\n     pub node: T,\n     pub span: Span,\n }\n \n-impl Eq for Span {\n+impl PartialEq for Span {\n     fn eq(&self, other: &Span) -> bool {\n         return (*self).lo == (*other).lo && (*self).hi == (*other).hi;\n     }"}, {"sha": "3f74598d2e57796ed06f82ffac9d50627e7be67e", "filename": "src/libsyntax/crateid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fcrateid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fcrateid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcrateid.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -20,7 +20,7 @@ use std::fmt;\n \n use std::from_str::FromStr;\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub struct CrateId {\n     /// A path which represents the codes origin. By convention this is the\n     /// URL, without `http://` or `https://` prefix, to the crate's repository"}, {"sha": "ee06efbec134376164aee599b294e190408b3ef8", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -194,7 +194,7 @@ pub fn mk_handler(e: Box<Emitter:Send>) -> Handler {\n     }\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum Level {\n     Bug,\n     Fatal,"}, {"sha": "a8124493acbceef69a468173c162784f6587d994", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -28,7 +28,7 @@ pub fn expand_deriving_totaleq(cx: &mut ExtCtxt,\n             let block = cx.block(span, stmts, None);\n             cx.expr_block(block)\n         },\n-                       |cx, sp, _, _| cx.span_bug(sp, \"non matching enums in deriving(TotalEq)?\"),\n+                       |cx, sp, _, _| cx.span_bug(sp, \"non matching enums in deriving(Eq)?\"),\n                        cx,\n                        span,\n                        substr)\n@@ -42,7 +42,7 @@ pub fn expand_deriving_totaleq(cx: &mut ExtCtxt,\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n-        path: Path::new(vec!(\"std\", \"cmp\", \"TotalEq\")),\n+        path: Path::new(vec!(\"std\", \"cmp\", \"Eq\")),\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         methods: vec!("}, {"sha": "c4611a552f5d0aceba9b11ed4f870a6777ecca3f", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -28,7 +28,7 @@ pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n-        path: Path::new(vec!(\"std\", \"cmp\", \"TotalOrd\")),\n+        path: Path::new(vec!(\"std\", \"cmp\", \"Ord\")),\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         methods: vec!(\n@@ -117,7 +117,7 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n                     let order = ordering_const(cx, span, self_var.cmp(&other_var));\n                     cx.expr_path(order)\n                 }\n-                _ => cx.span_bug(span, \"not exactly 2 arguments in `deriving(TotalOrd)`\")\n+                _ => cx.span_bug(span, \"not exactly 2 arguments in `deriving(Ord)`\")\n             }\n         },\n         cx, span, substr)"}, {"sha": "e2290129dc8b4070ae3bffe6477eb185a70234d1", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -24,7 +24,7 @@ Supported features (fairly exhaustive):\n   current trait as a bound. (This includes separate type parameters\n   and lifetimes for methods.)\n - Additional bounds on the type parameters, e.g. the `Ord` instance\n-  requires an explicit `Eq` bound at the\n+  requires an explicit `PartialEq` bound at the\n   moment. (`TraitDef.additional_bounds`)\n \n Unsupported: FIXME #6257: calling methods on reference fields,\n@@ -82,21 +82,21 @@ variants, it is represented as a count of 0.\n \n # Examples\n \n-The following simplified `Eq` is used for in-code examples:\n+The following simplified `PartialEq` is used for in-code examples:\n \n ```rust\n-trait Eq {\n+trait PartialEq {\n     fn eq(&self, other: &Self);\n }\n-impl Eq for int {\n+impl PartialEq for int {\n     fn eq(&self, other: &int) -> bool {\n         *self == *other\n     }\n }\n ```\n \n Some examples of the values of `SubstructureFields` follow, using the\n-above `Eq`, `A`, `B` and `C`.\n+above `PartialEq`, `A`, `B` and `C`.\n \n ## Structs\n \n@@ -645,11 +645,11 @@ impl<'a> MethodDef<'a> {\n \n     /**\n    ~~~\n-    #[deriving(Eq)]\n+    #[deriving(PartialEq)]\n     struct A { x: int, y: int }\n \n     // equivalent to:\n-    impl Eq for A {\n+    impl PartialEq for A {\n         fn eq(&self, __arg_1: &A) -> bool {\n             match *self {\n                 A {x: ref __self_0_0, y: ref __self_0_1} => {\n@@ -750,15 +750,15 @@ impl<'a> MethodDef<'a> {\n \n     /**\n    ~~~\n-    #[deriving(Eq)]\n+    #[deriving(PartialEq)]\n     enum A {\n         A1\n         A2(int)\n     }\n \n     // is equivalent to (with const_nonmatching == false)\n \n-    impl Eq for A {\n+    impl PartialEq for A {\n         fn eq(&self, __arg_1: &A) {\n             match *self {\n                 A1 => match *__arg_1 {\n@@ -994,7 +994,7 @@ impl<'a> MethodDef<'a> {\n     }\n }\n \n-#[deriving(Eq)] // dogfooding!\n+#[deriving(PartialEq)] // dogfooding!\n enum StructType {\n     Unknown, Record, Tuple\n }"}, {"sha": "1d8081e2ae3c2a5be3f7974b32fe43080d500fac", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -77,11 +77,11 @@ pub fn expand_meta_deriving(cx: &mut ExtCtxt,\n                             \"Encodable\" => expand!(encodable::expand_deriving_encodable),\n                             \"Decodable\" => expand!(decodable::expand_deriving_decodable),\n \n-                            // NOTE this needs treatment after a stage0 snap\n-                            \"PartialEq\" | \"Eq\" => expand!(eq::expand_deriving_eq),\n-                            \"TotalEq\" => expand!(totaleq::expand_deriving_totaleq),\n-                            \"PartialOrd\" | \"Ord\" => expand!(ord::expand_deriving_ord),\n-                            \"TotalOrd\" => expand!(totalord::expand_deriving_totalord),\n+                            // NOTE: after a stage0 snap this needs treatment\n+                            \"PartialEq\" => expand!(eq::expand_deriving_eq),\n+                            \"Eq\" | \"TotalEq\" => expand!(totaleq::expand_deriving_totaleq),\n+                            \"PartialOrd\" => expand!(ord::expand_deriving_ord),\n+                            \"Ord\" | \"TotalOrd\" => expand!(totalord::expand_deriving_totalord),\n \n                             \"Rand\" => expand!(rand::expand_deriving_rand),\n "}, {"sha": "0d228a1146d32bbeb4969e496feeb36dcb17d16b", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -21,7 +21,7 @@ use rsparse = parse;\n use parse = fmt_macros;\n use collections::{HashMap, HashSet};\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n enum ArgumentType {\n     Known(String),\n     Unsigned,"}, {"sha": "12e314781aeb54e699e43771cb09267620434d4a", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -37,7 +37,7 @@ pub struct SCTable {\n     rename_memo: RefCell<HashMap<(SyntaxContext,Ident,Name),SyntaxContext>>,\n }\n \n-#[deriving(Eq, Encodable, Decodable, Hash)]\n+#[deriving(PartialEq, Encodable, Decodable, Hash)]\n pub enum SyntaxContext_ {\n     EmptyCtxt,\n     Mark (Mrk,SyntaxContext),\n@@ -294,7 +294,7 @@ mod tests {\n \n     // because of the SCTable, I now need a tidy way of\n     // creating syntax objects. Sigh.\n-    #[deriving(Clone, Eq, Show)]\n+    #[deriving(Clone, PartialEq, Show)]\n     enum TestSC {\n         M(Mrk),\n         R(Ident,Name)"}, {"sha": "c04c10e0d7217de4ee3a0f2e473847d77b71878e", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -113,7 +113,7 @@ impl<S: Writer, T: Hash<S>> Hash<S> for OwnedSlice<T> {\n     }\n }\n \n-impl<T: Eq> Eq for OwnedSlice<T> {\n+impl<T: PartialEq> PartialEq for OwnedSlice<T> {\n     fn eq(&self, other: &OwnedSlice<T>) -> bool {\n         self.as_slice() == other.as_slice()\n     }"}, {"sha": "622ed6b9801d1994ad4b0003b4e4a1832c8f61ec", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -22,7 +22,7 @@ use std::str;\n use std::string::String;\n use std::uint;\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub enum CommentStyle {\n     Isolated, // No code on either side of each line of the comment\n     Trailing, // Code exists to the left of the comment"}, {"sha": "f5386b43d5127deb164fb335ef8fa4f9903a97be", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -34,7 +34,7 @@ pub trait Reader {\n     fn peek(&self) -> TokenAndSpan;\n }\n \n-#[deriving(Clone, Eq, Show)]\n+#[deriving(Clone, PartialEq, Show)]\n pub struct TokenAndSpan {\n     pub tok: token::Token,\n     pub sp: Span,"}, {"sha": "b7121c6b32c5661b9eb51f86b1e0cbad5faa2865", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -23,7 +23,7 @@ use parse::parser;\n use parse::token;\n \n /// The specific types of unsupported syntax\n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(PartialEq, TotalEq, Hash)]\n pub enum ObsoleteSyntax {\n     ObsoleteOwnedType,\n     ObsoleteOwnedExpr,"}, {"sha": "6c09fa20510e5ccf3aa1fd3f3278b3cd65b08c33", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -82,7 +82,7 @@ use std::rc::Rc;\n use std::string::String;\n \n #[allow(non_camel_case_types)]\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum restriction {\n     UNRESTRICTED,\n     RESTRICT_STMT_EXPR,\n@@ -94,7 +94,7 @@ type ItemInfo = (Ident, Item_, Option<Vec<Attribute> >);\n \n /// How to parse a path. There are four different kinds of paths, all of which\n /// are parsed somewhat differently.\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum PathParsingMode {\n     /// A path with no type parameters; e.g. `foo::bar::Baz`\n     NoTypesAllowed,"}, {"sha": "192adfe7829180c12104fc7670a7e916bb2d0073", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -24,7 +24,7 @@ use std::rc::Rc;\n use std::string::String;\n \n #[allow(non_camel_case_types)]\n-#[deriving(Clone, Encodable, Decodable, Eq, TotalEq, Hash, Show)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq, TotalEq, Hash, Show)]\n pub enum BinOp {\n     PLUS,\n     MINUS,\n@@ -39,7 +39,7 @@ pub enum BinOp {\n }\n \n #[allow(non_camel_case_types)]\n-#[deriving(Clone, Encodable, Decodable, Eq, TotalEq, Hash, Show)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq, TotalEq, Hash, Show)]\n pub enum Token {\n     /* Expression-operator symbols. */\n     EQ,\n@@ -102,7 +102,7 @@ pub enum Token {\n     EOF,\n }\n \n-#[deriving(Clone, Encodable, Decodable, Eq, TotalEq, Hash)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq, TotalEq, Hash)]\n /// For interpolation during macro expansion.\n pub enum Nonterminal {\n     NtItem(@ast::Item),\n@@ -552,7 +552,7 @@ pub fn get_ident_interner() -> Rc<IdentInterner> {\n /// destroyed. In particular, they must not access string contents. This can\n /// be fixed in the future by just leaking all strings until task death\n /// somehow.\n-#[deriving(Clone, Eq, Hash, Ord, TotalEq, TotalOrd)]\n+#[deriving(Clone, PartialEq, Hash, PartialOrd, TotalEq, TotalOrd)]\n pub struct InternedString {\n     string: RcStr,\n }"}, {"sha": "ec9ca65506458901793191a5d17b42bb787cc0f4", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -64,7 +64,7 @@\n use std::io;\n use std::string::String;\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub enum Breaks {\n     Consistent,\n     Inconsistent,"}, {"sha": "d2361810a2421bb8f48e25b513619974fa0b5ab5", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -90,7 +90,7 @@ impl<T: TotalEq + Hash + Clone + 'static> Interner<T> {\n     }\n }\n \n-#[deriving(Clone, Eq, Hash, Ord)]\n+#[deriving(Clone, PartialEq, Hash, PartialOrd)]\n pub struct RcStr {\n     string: Rc<String>,\n }"}, {"sha": "6795b10f4c7a1eb29fab3e4c706aea4f0b820ed4", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -13,7 +13,7 @@\n use std::char;\n use std::mem::replace;\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n enum States {\n     Nothing,\n     Percent,\n@@ -30,7 +30,7 @@ enum States {\n     SeekIfEndPercent(int)\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n enum FormatState {\n     FormatStateFlags,\n     FormatStateWidth,\n@@ -434,7 +434,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n     Ok(output)\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n struct Flags {\n     width: uint,\n     precision: uint,"}, {"sha": "bc69dc442dc654d792cf3780268ef474e1f776cd", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -83,7 +83,7 @@ pub mod stats;\n // colons. This way if some test runner wants to arrange the tests\n // hierarchically it may.\n \n-#[deriving(Clone, Eq, TotalEq, Hash)]\n+#[deriving(Clone, PartialEq, TotalEq, Hash)]\n pub enum TestName {\n     StaticTestName(&'static str),\n     DynTestName(String)\n@@ -183,7 +183,7 @@ pub struct Bencher {\n \n // The definition of a single test. A test runner will run a list of\n // these.\n-#[deriving(Clone, Show, Eq, TotalEq, Hash)]\n+#[deriving(Clone, Show, PartialEq, TotalEq, Hash)]\n pub struct TestDesc {\n     pub name: TestName,\n     pub ignore: bool,\n@@ -196,7 +196,7 @@ pub struct TestDescAndFn {\n     pub testfn: TestFn,\n }\n \n-#[deriving(Clone, Encodable, Decodable, Eq, Show)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq, Show)]\n pub struct Metric {\n     value: f64,\n     noise: f64\n@@ -208,7 +208,7 @@ impl Metric {\n     }\n }\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub struct MetricMap(TreeMap<String,Metric>);\n \n impl Clone for MetricMap {\n@@ -219,7 +219,7 @@ impl Clone for MetricMap {\n }\n \n /// Analysis of a single change in metric\n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n pub enum MetricChange {\n     LikelyNoise,\n     MetricAdded,\n@@ -444,13 +444,13 @@ pub fn opt_shard(maybestr: Option<String>) -> Option<(uint,uint)> {\n }\n \n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub struct BenchSamples {\n     ns_iter_summ: stats::Summary<f64>,\n     mb_s: uint,\n }\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub enum TestResult {\n     TrOk,\n     TrFailed,"}, {"sha": "16a96d9f606c4eac283027ff2746036909a03270", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -126,7 +126,7 @@ pub trait Stats <T: FloatMath + FromPrimitive>{\n }\n \n /// Extracted collection of all the summary statistics of a sample set.\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n #[allow(missing_doc)]\n pub struct Summary<T> {\n     pub sum: T,"}, {"sha": "91e608360bc4af19107d1aee18b1d9f7dc3ceda2", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -74,7 +74,7 @@ mod imp {\n }\n \n /// A record specifying a time value in seconds and nanoseconds.\n-#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, Encodable, Decodable, Show)]\n+#[deriving(Clone, PartialEq, TotalEq, PartialOrd, TotalOrd, Encodable, Decodable, Show)]\n pub struct Timespec { pub sec: i64, pub nsec: i32 }\n /*\n  * Timespec assumes that pre-epoch Timespecs have negative sec and positive\n@@ -202,7 +202,7 @@ pub fn tzset() {\n \n /// Holds a calendar date and time broken down into its components (year, month, day, and so on),\n /// also called a broken-down time value.\n-#[deriving(Clone, Eq, Show)]\n+#[deriving(Clone, PartialEq, Show)]\n pub struct Tm {\n     /// Seconds after the minute \u2013 [0, 60]\n     pub tm_sec: i32,"}, {"sha": "2120bc10dab84e429a881d165e8525eeb6c1b4af", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -22,7 +22,7 @@\n extern crate collections;\n \n use collections::HashMap;\n-use std::cmp::Eq;\n+use std::cmp::PartialEq;\n use std::fmt;\n use std::from_str::FromStr;\n use std::hash::Hash;\n@@ -48,7 +48,7 @@ use std::uint;\n ///                 fragment: Some(\"quz\".to_string()) };\n /// // https://username@example.com:8080/foo/bar?baz=qux#quz\n /// ```\n-#[deriving(Clone, Eq, TotalEq)]\n+#[deriving(Clone, PartialEq, TotalEq)]\n pub struct Url {\n     /// The scheme part of a URL, such as `https` in the above example.\n     pub scheme: String,\n@@ -68,7 +68,7 @@ pub struct Url {\n     pub fragment: Option<String>\n }\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n pub struct Path {\n     /// The path component of a URL, for example `/foo/bar`.\n     pub path: String,\n@@ -81,7 +81,7 @@ pub struct Path {\n }\n \n /// An optional subcomponent of a URI authority component.\n-#[deriving(Clone, Eq, TotalEq)]\n+#[deriving(Clone, PartialEq, TotalEq)]\n pub struct UserInfo {\n     /// The user name.\n     pub user: String,\n@@ -515,7 +515,7 @@ pub fn get_scheme(rawurl: &str) -> Result<(String, String), String> {\n     return Err(\"url: Scheme must be terminated with a colon.\".to_string());\n }\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, PartialEq)]\n enum Input {\n     Digit, // all digits\n     Hex, // digits and letters a-f"}, {"sha": "a5b28b73023bc71e8613cdb605659a344e48211d", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -87,7 +87,7 @@ use serialize::{Encoder, Encodable, Decoder, Decodable};\n pub type UuidBytes = [u8, ..16];\n \n /// The version of the UUID, denoting the generating algorithm\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum UuidVersion {\n     /// Version 1: MAC address\n     Version1Mac    = 1,\n@@ -102,7 +102,7 @@ pub enum UuidVersion {\n }\n \n /// The reserved variants of UUIDs\n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum UuidVariant {\n     /// Reserved by the NCS for backward compatibility\n     VariantNCS,\n@@ -481,7 +481,7 @@ impl fmt::Show for Uuid {\n /// Test two UUIDs for equality\n ///\n /// UUIDs are equal only when they are byte-for-byte identical\n-impl Eq for Uuid {\n+impl PartialEq for Uuid {\n     fn eq(&self, other: &Uuid) -> bool {\n         self.bytes == other.bytes\n     }"}, {"sha": "7c3fc18dd04123db0482fb0c0921837d0253d845", "filename": "src/libworkcache/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibworkcache%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Flibworkcache%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibworkcache%2Flib.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -99,7 +99,7 @@ use std::str;\n use std::io;\n use std::io::{File, MemWriter};\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Ord, TotalOrd, TotalEq)]\n+#[deriving(Clone, PartialEq, Encodable, Decodable, PartialOrd, TotalOrd, TotalEq)]\n struct WorkKey {\n     kind: String,\n     name: String\n@@ -116,10 +116,10 @@ impl WorkKey {\n \n // FIXME #8883: The key should be a WorkKey and not a String.\n // This is working around some JSON weirdness.\n-#[deriving(Clone, Eq, Encodable, Decodable)]\n+#[deriving(Clone, PartialEq, Encodable, Decodable)]\n struct WorkMap(TreeMap<String, KindMap>);\n \n-#[deriving(Clone, Eq, Encodable, Decodable)]\n+#[deriving(Clone, PartialEq, Encodable, Decodable)]\n struct KindMap(TreeMap<String, String>);\n \n impl WorkMap {"}, {"sha": "15c1405c4ce4781fd40c4a12fe46d23e3d81dfdd", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -1,3 +1,11 @@\n+S 2014-05-29 50b8528\n+  freebsd-x86_64 cfa0dcc98a57f03a53bb53df6fd5db02143e2bee\n+  linux-i386 baf7c6ab5792f3d560a0f2adc94d7ff96d0cab3d\n+  linux-x86_64 ed97bc90842b96b95e860b9d21fe1ade3f682fd3\n+  macos-i386 2d0e27f72e34be53b1f16d704e9a3b8bedbdbd31\n+  macos-x86_64 f8912b07014c234ae2d625d6da84c752508a2b04\n+  winnt-i386 0af7b426f57015d8392e00ee9a9d1f2f5eb10761\n+\n S 2014-05-16 5327218\n   freebsd-x86_64 e91e235c808eb7e8a1e82f7e00c874de9b1df345\n   linux-i386 3a3b7d68ed42a144fa06c9a49c63966da9adeef2"}, {"sha": "de48981ed3ede5bac3c49ce31bac2d5d6e95de76", "filename": "src/test/auxiliary/crateresolve5-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -26,7 +26,7 @@ pub fn nominal() -> e { e_val }\n \n pub fn nominal_eq(_e1: e, _e2: e) -> bool { true }\n \n-impl Eq for e {\n+impl PartialEq for e {\n     fn eq(&self, other: &e) -> bool { nominal_eq(*self, *other) }\n     fn ne(&self, other: &e) -> bool { !nominal_eq(*self, *other) }\n }"}, {"sha": "f8727605c3db91341bc8bbbeb0f815a7e22d2830", "filename": "src/test/auxiliary/crateresolve5-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -21,7 +21,7 @@ pub enum e {\n     e_val\n }\n \n-impl Eq for e {\n+impl PartialEq for e {\n     fn eq(&self, other: &e) -> bool { !nominal_neq(*self, *other) }\n     fn ne(&self, other: &e) -> bool { nominal_neq(*self, *other) }\n }"}, {"sha": "4d4b1bcc4cbf036ee5178dacc8e3dbdcec4820f7", "filename": "src/test/auxiliary/impl_privacy_xc_2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fauxiliary%2Fimpl_privacy_xc_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fauxiliary%2Fimpl_privacy_xc_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fimpl_privacy_xc_2.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -16,7 +16,7 @@ pub struct Fish {\n \n mod unexported {\n     use super::Fish;\n-    impl Eq for Fish {\n+    impl PartialEq for Fish {\n         fn eq(&self, _: &Fish) -> bool { true }\n         fn ne(&self, _: &Fish) -> bool { false }\n     }"}, {"sha": "dbb978a0b4ed907e262ff73ae027ae1d750fcf1b", "filename": "src/test/auxiliary/overloaded_autoderef_xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -31,7 +31,7 @@ impl<T, H: Helper<T>> Deref<T> for DerefWithHelper<H, T> {\n }\n \n // Test cross-crate autoderef + vtable.\n-pub fn check<T: Eq>(x: T, y: T) -> bool {\n+pub fn check<T: PartialEq>(x: T, y: T) -> bool {\n     let d: DerefWithHelper<Option<T>, T> = DerefWithHelper { helper: Some(x) };\n     d.eq(&y)\n }"}, {"sha": "95bdecd77605f03e1eb5976d819595f8ec813f44", "filename": "src/test/auxiliary/trait_inheritance_overloading_xc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cmp::Eq;\n+use std::cmp::PartialEq;\n \n-pub trait MyNum : Add<Self,Self> + Sub<Self,Self> + Mul<Self,Self> + Eq {\n+pub trait MyNum : Add<Self,Self> + Sub<Self,Self> + Mul<Self,Self> + PartialEq {\n }\n \n #[deriving(Show)]\n@@ -30,7 +30,7 @@ impl Mul<MyInt, MyInt> for MyInt {\n     fn mul(&self, other: &MyInt) -> MyInt { mi(self.val * other.val) }\n }\n \n-impl Eq for MyInt {\n+impl PartialEq for MyInt {\n     fn eq(&self, other: &MyInt) -> bool { self.val == other.val }\n \n     fn ne(&self, other: &MyInt) -> bool { !self.eq(other) }"}, {"sha": "45cd93188b2ac48e54876f53a80c20cef1445d7d", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -30,7 +30,7 @@ static OCCURRENCES: [&'static str, ..5] = [\n \n // Code implementation\n \n-#[deriving(Eq, Ord, TotalOrd, TotalEq)]\n+#[deriving(PartialEq, PartialOrd, TotalOrd, TotalEq)]\n struct Code(u64);\n \n impl Code {"}, {"sha": "58593869d747b0616063592e6c78b8f5b2c97c8f", "filename": "src/test/compile-fail/deriving-no-inner-impl-error-message.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-no-inner-impl-error-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-no-inner-impl-error-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-no-inner-impl-error-message.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -10,7 +10,7 @@\n \n struct NoCloneOrEq;\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n struct E {\n     x: NoCloneOrEq //~ ERROR does not implement any method in scope named `eq`\n          //~^ ERROR does not implement any method in scope named `ne`"}, {"sha": "58a9c72b8b166cdd186cddfb9e32e96b1e4c5b61", "filename": "src/test/compile-fail/deriving-span-Clone-enum-struct-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-enum-struct-variant.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;"}, {"sha": "cf8345dbe7b46d9579f95e2e5980516c6f6472ff", "filename": "src/test/compile-fail/deriving-span-Clone-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-enum.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;"}, {"sha": "cd53f5a1e8f3cec125c60326512983b4da9b0093", "filename": "src/test/compile-fail/deriving-span-Clone-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;"}, {"sha": "95798af49b2e07e64495e838845eec762a581aab", "filename": "src/test/compile-fail/deriving-span-Clone-tuple-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-tuple-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;"}, {"sha": "90d567bfd5da9197f5ab0e7da562275a773795b2", "filename": "src/test/compile-fail/deriving-span-Default-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Default-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Default-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Default-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;"}, {"sha": "cf0d9fb744337b43543455297c68384a0e5a9ed3", "filename": "src/test/compile-fail/deriving-span-Default-tuple-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Default-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Default-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Default-tuple-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;"}, {"sha": "49b4840ff8ea1c4c8711db94d7a5d72073b5d650", "filename": "src/test/compile-fail/deriving-span-Hash-enum-struct-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-enum-struct-variant.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;"}, {"sha": "653dabfbc133fa901ac9ee66f5151b92f7a4670e", "filename": "src/test/compile-fail/deriving-span-Hash-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-enum.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;"}, {"sha": "46234f6e724081e48d2125c2ca8fc6fb9f999357", "filename": "src/test/compile-fail/deriving-span-Hash-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;"}, {"sha": "5dbf4a0376a1277def1d6e653a4f5ac523e6301b", "filename": "src/test/compile-fail/deriving-span-Hash-tuple-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Hash-tuple-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;"}, {"sha": "566585aa0656753634a8d26166de06abc1b549ad", "filename": "src/test/compile-fail/deriving-span-PartialEq-enum-struct-variant.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialEq-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialEq-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialEq-enum-struct-variant.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;\n \n \n struct Error;\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n enum Enum {\n    A {\n      x: Error //~ ERROR", "previous_filename": "src/test/compile-fail/deriving-span-Eq-enum-struct-variant.rs"}, {"sha": "8a9771a05093914c8accac31e43392f402beabe0", "filename": "src/test/compile-fail/deriving-span-PartialEq-enum.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialEq-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialEq-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialEq-enum.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;\n \n \n struct Error;\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n enum Enum {\n    A(\n      Error //~ ERROR", "previous_filename": "src/test/compile-fail/deriving-span-Eq-enum.rs"}, {"sha": "de39e9bacd529b49c097cdb85badce3cbed09517", "filename": "src/test/compile-fail/deriving-span-PartialEq-struct.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialEq-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialEq-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialEq-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;\n \n \n struct Error;\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n struct Struct {\n     x: Error //~ ERROR\n //~^ ERROR", "previous_filename": "src/test/compile-fail/deriving-span-Eq-struct.rs"}, {"sha": "101461e39b718fd0d0488db9227b76ec52dd8595", "filename": "src/test/compile-fail/deriving-span-PartialEq-tuple-struct.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialEq-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialEq-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialEq-tuple-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;\n \n \n struct Error;\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n struct Struct(\n     Error //~ ERROR\n //~^ ERROR", "previous_filename": "src/test/compile-fail/deriving-span-Eq-tuple-struct.rs"}, {"sha": "077286eef499b7ec867c3bc6a21492a8d0592359", "filename": "src/test/compile-fail/deriving-span-PartialOrd-enum-struct-variant.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-enum-struct-variant.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n struct Error;\n \n-#[deriving(Eq, Ord)]\n+#[deriving(PartialOrd,PartialEq)]\n enum Enum {\n    A {\n      x: Error //~ ERROR", "previous_filename": "src/test/compile-fail/deriving-span-Ord-enum-struct-variant.rs"}, {"sha": "8fd4ba6053e22b63b1c671a3e321b66f95603ed8", "filename": "src/test/compile-fail/deriving-span-PartialOrd-enum.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-enum.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n struct Error;\n \n-#[deriving(Eq, Ord)]\n+#[deriving(PartialOrd,PartialEq)]\n enum Enum {\n    A(\n      Error //~ ERROR", "previous_filename": "src/test/compile-fail/deriving-span-Ord-enum.rs"}, {"sha": "3a198a542e4ad15d0ba4c342ee9332b02ba5a645", "filename": "src/test/compile-fail/deriving-span-PartialOrd-struct.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n struct Error;\n \n-#[deriving(Eq, Ord)]\n+#[deriving(PartialOrd,PartialEq)]\n struct Struct {\n     x: Error //~ ERROR\n //~^ ERROR", "previous_filename": "src/test/compile-fail/deriving-span-Ord-struct.rs"}, {"sha": "2de3c18425b5775670d07cb4ea5875d3fb1591cd", "filename": "src/test/compile-fail/deriving-span-PartialOrd-tuple-struct.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-tuple-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n struct Error;\n \n-#[deriving(Eq, Ord)]\n+#[deriving(PartialOrd,PartialEq)]\n struct Struct(\n     Error //~ ERROR\n //~^ ERROR", "previous_filename": "src/test/compile-fail/deriving-span-Ord-tuple-struct.rs"}, {"sha": "79c38dcb4ccac457eb5ed80ea75c29293aca8bb7", "filename": "src/test/compile-fail/deriving-span-Rand-enum-struct-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-enum-struct-variant.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;"}, {"sha": "1e153a772c7e14c9da552dde2576ba1e8d8dbb44", "filename": "src/test/compile-fail/deriving-span-Rand-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-enum.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;"}, {"sha": "2c223918773d8f65711aea29719153aad9fe71bd", "filename": "src/test/compile-fail/deriving-span-Rand-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;"}, {"sha": "5d5a1372c13a22188a3e3cdbcff079fc88bef09a", "filename": "src/test/compile-fail/deriving-span-Rand-tuple-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-tuple-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;"}, {"sha": "93f53dc73f76b4a880dc472a5876975882072418", "filename": "src/test/compile-fail/deriving-span-Show-enum-struct-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-enum-struct-variant.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;"}, {"sha": "e61a62c2f6da390cfbda4cee23dbdf3ea40c3892", "filename": "src/test/compile-fail/deriving-span-Show-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-enum.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;"}, {"sha": "3a48b3334b7ab723b0dd67f4d44d0dcc6ee48785", "filename": "src/test/compile-fail/deriving-span-Show-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;"}, {"sha": "54806f322b38387000a341b7684c532be2c5d746", "filename": "src/test/compile-fail/deriving-span-Show-tuple-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-tuple-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;"}, {"sha": "07fc3d5c5d9713d191a601843bded8a287a6efd3", "filename": "src/test/compile-fail/deriving-span-TotalEq-enum-struct-variant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-enum-struct-variant.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n struct Error;\n \n-#[deriving(Eq, TotalEq)]\n+#[deriving(TotalEq,PartialEq)]\n enum Enum {\n    A {\n      x: Error //~ ERROR"}, {"sha": "e25ebaf7f1b802f95ce034b8dc8f8d39eb143938", "filename": "src/test/compile-fail/deriving-span-TotalEq-enum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-enum.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n struct Error;\n \n-#[deriving(Eq, TotalEq)]\n+#[deriving(TotalEq,PartialEq)]\n enum Enum {\n    A(\n      Error //~ ERROR"}, {"sha": "b9b50e5d60b654dd9264f3ff81c86c5206ce9ea9", "filename": "src/test/compile-fail/deriving-span-TotalEq-struct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n struct Error;\n \n-#[deriving(Eq, TotalEq)]\n+#[deriving(TotalEq,PartialEq)]\n struct Struct {\n     x: Error //~ ERROR\n }"}, {"sha": "b6123df4506f507cf65893e3b3b70217b91b25b4", "filename": "src/test/compile-fail/deriving-span-TotalEq-tuple-struct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-tuple-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n struct Error;\n \n-#[deriving(Eq, TotalEq)]\n+#[deriving(TotalEq,PartialEq)]\n struct Struct(\n     Error //~ ERROR\n );"}, {"sha": "a8116a817a87f2308e22a544da0afd4daa24d5cf", "filename": "src/test/compile-fail/deriving-span-TotalOrd-enum-struct-variant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-enum-struct-variant.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;\n \n-#[deriving(Eq, Ord, TotalEq)]\n+#[deriving(TotalEq,PartialOrd,PartialEq)]\n struct Error;\n \n-#[deriving(Eq, Ord, TotalOrd,TotalEq)]\n+#[deriving(TotalOrd,TotalEq,PartialOrd,PartialEq)]\n enum Enum {\n    A {\n      x: Error //~ ERROR"}, {"sha": "0e1dc003fbb080be7c42e33676ae616264e1b9d6", "filename": "src/test/compile-fail/deriving-span-TotalOrd-enum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-enum.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;\n \n-#[deriving(Eq, Ord, TotalEq)]\n+#[deriving(TotalEq,PartialOrd,PartialEq)]\n struct Error;\n \n-#[deriving(Eq, Ord, TotalOrd,TotalEq)]\n+#[deriving(TotalOrd,TotalEq,PartialOrd,PartialEq)]\n enum Enum {\n    A(\n      Error //~ ERROR"}, {"sha": "af6f09c4a2cf2b2295ed0d1f8efdd56af4e52882", "filename": "src/test/compile-fail/deriving-span-TotalOrd-struct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;\n \n-#[deriving(Eq, Ord, TotalEq)]\n+#[deriving(TotalEq,PartialOrd,PartialEq)]\n struct Error;\n \n-#[deriving(Eq, Ord, TotalOrd,TotalEq)]\n+#[deriving(TotalOrd,TotalEq,PartialOrd,PartialEq)]\n struct Struct {\n     x: Error //~ ERROR\n }"}, {"sha": "b58dc56a261d77f36d66727aab9dac65be32ab62", "filename": "src/test/compile-fail/deriving-span-TotalOrd-tuple-struct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-tuple-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;\n \n-#[deriving(Eq, Ord, TotalEq)]\n+#[deriving(TotalEq,PartialOrd,PartialEq)]\n struct Error;\n \n-#[deriving(Eq, Ord, TotalOrd,TotalEq)]\n+#[deriving(TotalOrd,TotalEq,PartialOrd,PartialEq)]\n struct Struct(\n     Error //~ ERROR\n );"}, {"sha": "ee3a82f7f6d687bf00f4218c6b1a79fb1c8182d6", "filename": "src/test/compile-fail/deriving-span-Zero-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;"}, {"sha": "21dc0cabdc809f1295d74d6b75e13457a4c66e25", "filename": "src/test/compile-fail/deriving-span-Zero-tuple-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-tuple-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n #![feature(struct_variant)]\n extern crate rand;"}, {"sha": "d6fe83a77032bd80b1e31a2f60c4b55d9586f4ef", "filename": "src/test/compile-fail/issue-3344.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n struct thing(uint);\n-impl Ord for thing { //~ ERROR not all trait methods implemented, missing: `lt`\n+impl PartialOrd for thing { //~ ERROR not all trait methods implemented, missing: `lt`\n     fn le(&self, other: &thing) -> bool { true }\n     fn ge(&self, other: &thing) -> bool { true }\n }"}, {"sha": "4484a00425140403814326de16b20c44e2a09e3e", "filename": "src/test/compile-fail/issue-3953.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,23 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cmp::Eq;\n+// ignore-tidy-linelength\n \n-trait Hahaha: Eq + Eq + Eq + Eq + Eq + //~ ERROR duplicate supertrait\n-              Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq +\n-              Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq +\n-              Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq +\n-              Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq +\n-              Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq +\n-              Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq +\n-              Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq +\n-              Eq {}\n+use std::cmp::PartialEq;\n+\n+trait Hahaha: PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + //~ ERROR duplicate supertrait\n+              PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq +\n+              PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq +\n+              PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq +\n+              PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq +\n+              PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq +\n+              PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq +\n+              PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq + PartialEq +\n+              PartialEq {}\n \n struct Lol(int);\n \n impl Hahaha for Lol { }\n \n-impl Eq for Lol {\n+impl PartialEq for Lol {\n     fn eq(&self, other: &Lol) -> bool { **self != **other }\n     fn ne(&self, other: &Lol) -> bool { **self == **other }\n }"}, {"sha": "cb05c2833345c0d2fec11866bf5eb56247d1186c", "filename": "src/test/compile-fail/lint-unused-imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -51,7 +51,7 @@ mod foo {\n \n mod bar {\n     // Don't ignore on 'pub use' because we're not sure if it's used or not\n-    pub use std::cmp::Eq;\n+    pub use std::cmp::PartialEq;\n \n     pub mod c {\n         use foo::Point;\n@@ -61,7 +61,7 @@ mod bar {\n \n     #[allow(unused_imports)]\n     mod foo {\n-        use std::cmp::Eq;\n+        use std::cmp::PartialEq;\n     }\n }\n "}, {"sha": "26546cef0f06194c77f50f81d7614d577c343bca", "filename": "src/test/run-make/rustdoc-hidden-line/foo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2Ffoo.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -16,10 +16,10 @@\n /// ```rust\n /// mod to_make_deriving_work { // FIXME #4913\n ///\n-/// # #[deriving(Eq)] // invisible\n+/// # #[deriving(PartialEq)] // invisible\n /// # struct Foo; // invisible\n ///\n-/// #[deriving(Eq)] // Bar\n+/// #[deriving(PartialEq)] // Bar\n /// struct Bar(Foo);\n ///\n /// fn test() {"}, {"sha": "3c620c5e5720935d6b42a24aad289c5a144fcfc7", "filename": "src/test/run-pass-fulldeps/macro-crate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -17,7 +17,7 @@\n extern crate macro_crate_test;\n \n #[into_foo]\n-#[deriving(Eq, Clone, Show)]\n+#[deriving(PartialEq, Clone, Show)]\n fn foo() -> AFakeTypeThatHadBetterGoAway {}\n \n pub fn main() {\n@@ -28,4 +28,4 @@ pub fn main() {\n     test(None::<Foo>);\n }\n \n-fn test<T: Eq+Clone>(_: Option<T>) {}\n+fn test<T: PartialEq+Clone>(_: Option<T>) {}"}, {"sha": "34f7bf6f0e780dc82ad9f8cdb2bb57fce13f5caf", "filename": "src/test/run-pass/assert-eq-macro-success.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fassert-eq-macro-success.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fassert-eq-macro-success.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassert-eq-macro-success.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(managed_boxes)]\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n struct Point { x : int }\n \n pub fn main() {"}, {"sha": "3ac3ac2b4f1b4d9bb539231a5bb5e97dcb88fa60", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -65,7 +65,7 @@ fn test_ptr() {\n     }\n }\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n struct p {\n   x: int,\n   y: int,"}, {"sha": "d52da21240064cd3264d6e8e864532e2ce7b6988", "filename": "src/test/run-pass/builtin-superkinds-capabilities-xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -17,7 +17,7 @@\n extern crate trait_superkinds_in_metadata;\n use trait_superkinds_in_metadata::{RequiresRequiresShareAndSend, RequiresShare};\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n struct X<T>(T);\n \n impl <T: Share> RequiresShare for X<T> { }"}, {"sha": "865984844c0b54314766c68be80ade3cd3a59017", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -14,7 +14,7 @@ use std::cmp;\n #[deriving(Show)]\n enum cat_type { tuxedo, tabby, tortoiseshell }\n \n-impl cmp::Eq for cat_type {\n+impl cmp::PartialEq for cat_type {\n     fn eq(&self, other: &cat_type) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }"}, {"sha": "7805a2bb49e80e9d7af00dd695c5532268c910db", "filename": "src/test/run-pass/cmp-default.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fcmp-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fcmp-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcmp-default.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test default methods in Ord and Eq\n+// Test default methods in PartialOrd and PartialEq\n //\n struct Fool(bool);\n \n-impl Eq for Fool {\n+impl PartialEq for Fool {\n     fn eq(&self, other: &Fool) -> bool {\n         let Fool(this) = *self;\n         let Fool(other) = *other;\n@@ -22,15 +22,15 @@ impl Eq for Fool {\n \n struct Int(int);\n \n-impl Eq for Int {\n+impl PartialEq for Int {\n     fn eq(&self, other: &Int) -> bool {\n         let Int(this) = *self;\n         let Int(other) = *other;\n         this == other\n     }\n }\n \n-impl Ord for Int {\n+impl PartialOrd for Int {\n     fn lt(&self, other: &Int) -> bool {\n         let Int(this) = *self;\n         let Int(other) = *other;\n@@ -40,15 +40,15 @@ impl Ord for Int {\n \n struct RevInt(int);\n \n-impl Eq for RevInt {\n+impl PartialEq for RevInt {\n     fn eq(&self, other: &RevInt) -> bool {\n         let RevInt(this) = *self;\n         let RevInt(other) = *other;\n         this == other\n     }\n }\n \n-impl Ord for RevInt {\n+impl PartialOrd for RevInt {\n     fn lt(&self, other: &RevInt) -> bool {\n         let RevInt(this) = *self;\n         let RevInt(other) = *other;"}, {"sha": "15870b627b20919e9062259e19d31ce6b6dd4f86", "filename": "src/test/run-pass/coerce-to-closure-and-proc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fcoerce-to-closure-and-proc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fcoerce-to-closure-and-proc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-to-closure-and-proc.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -12,10 +12,10 @@ fn id<T>(x: T) -> T {\n     x\n }\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n struct Foo<T>(T);\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n enum Bar<T> {\n     Bar(T)\n }"}, {"sha": "51cd62677ca1ca9a68af0ac48bfb4628008ee6d2", "filename": "src/test/run-pass/coherence-impl-in-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fcoherence-impl-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fcoherence-impl-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoherence-impl-in-fn.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -10,7 +10,7 @@\n \n pub fn main() {\n     enum x { foo }\n-    impl ::std::cmp::Eq for x {\n+    impl ::std::cmp::PartialEq for x {\n         fn eq(&self, other: &x) -> bool {\n             (*self) as int == (*other) as int\n         }"}, {"sha": "0a83d007a06a14b9e0bcb20e765bf46033f5a1ad", "filename": "src/test/run-pass/const-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fconst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fconst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -13,7 +13,7 @@ use std::cmp;\n #[deriving(Show)]\n struct foo { a: int, b: int, c: int }\n \n-impl cmp::Eq for foo {\n+impl cmp::PartialEq for foo {\n     fn eq(&self, other: &foo) -> bool {\n         (*self).a == (*other).a &&\n         (*self).b == (*other).b &&"}, {"sha": "e280da10990cb96e33d4a6cb2061af1a9b83e4be", "filename": "src/test/run-pass/deriving-cmp-generic-enum.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq, TotalEq, Ord, TotalOrd)]\n+#[deriving(PartialEq, TotalEq, PartialOrd, TotalOrd)]\n enum E<T> {\n     E0,\n     E1(T),\n@@ -22,7 +22,7 @@ pub fn main() {\n     let e21 = E2(1, 1);\n     let e22 = E2(1, 2);\n \n-    // in order for both Ord and TotalOrd\n+    // in order for both PartialOrd and TotalOrd\n     let es = [e0, e11, e12, e21, e22];\n \n     for (i, e1) in es.iter().enumerate() {\n@@ -35,11 +35,11 @@ pub fn main() {\n             let gt = i > j;\n             let ge = i >= j;\n \n-            // Eq\n+            // PartialEq\n             assert_eq!(*e1 == *e2, eq);\n             assert_eq!(*e1 != *e2, !eq);\n \n-            // Ord\n+            // PartialOrd\n             assert_eq!(*e1 < *e2, lt);\n             assert_eq!(*e1 > *e2, gt);\n "}, {"sha": "a6040049a2f7d9e8ad3515af618bd822999562ce", "filename": "src/test/run-pass/deriving-cmp-generic-struct-enum.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(struct_variant)]\n \n-#[deriving(Eq, TotalEq, Ord, TotalOrd)]\n+#[deriving(PartialEq, TotalEq, PartialOrd, TotalOrd)]\n enum ES<T> {\n     ES1 { x: T },\n     ES2 { x: T, y: T }\n@@ -20,7 +20,7 @@ enum ES<T> {\n pub fn main() {\n     let (es11, es12, es21, es22) = (ES1 {x: 1}, ES1 {x: 2}, ES2 {x: 1, y: 1}, ES2 {x: 1, y: 2});\n \n-    // in order for both Ord and TotalOrd\n+    // in order for both PartialOrd and TotalOrd\n     let ess = [es11, es12, es21, es22];\n \n     for (i, es1) in ess.iter().enumerate() {\n@@ -31,11 +31,11 @@ pub fn main() {\n             let (lt, le) = (i < j, i <= j);\n             let (gt, ge) = (i > j, i >= j);\n \n-            // Eq\n+            // PartialEq\n             assert_eq!(*es1 == *es2, eq);\n             assert_eq!(*es1 != *es2, !eq);\n \n-            // Ord\n+            // PartialOrd\n             assert_eq!(*es1 < *es2, lt);\n             assert_eq!(*es1 > *es2, gt);\n "}, {"sha": "36ec0e834baa37a951822859ed36b53a4d9ddfee", "filename": "src/test/run-pass/deriving-cmp-generic-struct.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq, TotalEq, Ord, TotalOrd)]\n+#[deriving(PartialEq, TotalEq, PartialOrd, TotalOrd)]\n struct S<T> {\n     x: T,\n     y: T\n@@ -18,7 +18,7 @@ pub fn main() {\n     let s1 = S {x: 1, y: 1};\n     let s2 = S {x: 1, y: 2};\n \n-    // in order for both Ord and TotalOrd\n+    // in order for both PartialOrd and TotalOrd\n     let ss = [s1, s2];\n \n     for (i, s1) in ss.iter().enumerate() {\n@@ -31,11 +31,11 @@ pub fn main() {\n             let gt = i > j;\n             let ge = i >= j;\n \n-            // Eq\n+            // PartialEq\n             assert_eq!(*s1 == *s2, eq);\n             assert_eq!(*s1 != *s2, !eq);\n \n-            // Ord\n+            // PartialOrd\n             assert_eq!(*s1 < *s2, lt);\n             assert_eq!(*s1 > *s2, gt);\n "}, {"sha": "b67da8940ff7d68e8f52a6693d3024948c8685b0", "filename": "src/test/run-pass/deriving-cmp-generic-tuple-struct.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq, TotalEq, Ord, TotalOrd)]\n+#[deriving(PartialEq, TotalEq, PartialOrd, TotalOrd)]\n struct TS<T>(T,T);\n \n \n pub fn main() {\n     let ts1 = TS(1, 1);\n     let ts2 = TS(1, 2);\n \n-    // in order for both Ord and TotalOrd\n+    // in order for both PartialOrd and TotalOrd\n     let tss = [ts1, ts2];\n \n     for (i, ts1) in tss.iter().enumerate() {\n@@ -29,11 +29,11 @@ pub fn main() {\n             let gt = i > j;\n             let ge = i >= j;\n \n-            // Eq\n+            // PartialEq\n             assert_eq!(*ts1 == *ts2, eq);\n             assert_eq!(*ts1 != *ts2, !eq);\n \n-            // Ord\n+            // PartialOrd\n             assert_eq!(*ts1 < *ts2, lt);\n             assert_eq!(*ts1 > *ts2, gt);\n "}, {"sha": "45beda9684ddd0afca0ad0da09a274e8f8b87ec1", "filename": "src/test/run-pass/deriving-cmp-shortcircuit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-cmp-shortcircuit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-cmp-shortcircuit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-shortcircuit.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -13,11 +13,11 @@\n // second element, so this passes iff the instances shortcircuit.\n \n pub struct FailCmp;\n-impl Eq for FailCmp {\n+impl PartialEq for FailCmp {\n     fn eq(&self, _: &FailCmp) -> bool { fail!(\"eq\") }\n }\n \n-impl Ord for FailCmp {\n+impl PartialOrd for FailCmp {\n     fn lt(&self, _: &FailCmp) -> bool { fail!(\"lt\") }\n }\n \n@@ -27,7 +27,7 @@ impl TotalOrd for FailCmp {\n     fn cmp(&self, _: &FailCmp) -> Ordering { fail!(\"cmp\") }\n }\n \n-#[deriving(Eq,Ord,TotalEq,TotalOrd)]\n+#[deriving(PartialEq,PartialOrd,TotalEq,TotalOrd)]\n struct ShortCircuit {\n     x: int,\n     y: FailCmp"}, {"sha": "fc03763a3b7a859029db7a2c6679d1b941ca0bc0", "filename": "src/test/run-pass/deriving-enum-single-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-enum-single-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-enum-single-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-enum-single-variant.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -10,7 +10,7 @@\n \n type task_id = int;\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n pub enum Task {\n     TaskHandle(task_id)\n }"}, {"sha": "1f9a5cab3b7da03605e7668f1c5c0e6be61bb00d", "filename": "src/test/run-pass/deriving-global.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-global.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-global.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-global.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -15,21 +15,21 @@ mod submod {\n     // if any of these are implemented without global calls for any\n     // function calls, then being in a submodule will (correctly)\n     // cause errors about unrecognised module `std` (or `extra`)\n-    #[deriving(Eq, Ord, TotalEq, TotalOrd,\n+    #[deriving(PartialEq, PartialOrd, TotalEq, TotalOrd,\n                Hash,\n                Clone,\n                Show, Rand,\n                Encodable, Decodable)]\n     enum A { A1(uint), A2(int) }\n \n-    #[deriving(Eq, Ord, TotalEq, TotalOrd,\n+    #[deriving(PartialEq, PartialOrd, TotalEq, TotalOrd,\n                Hash,\n                Clone,\n                Show, Rand,\n                Encodable, Decodable)]\n     struct B { x: uint, y: int }\n \n-    #[deriving(Eq, Ord, TotalEq, TotalOrd,\n+    #[deriving(PartialEq, PartialOrd, TotalEq, TotalOrd,\n                Hash,\n                Clone,\n                Show, Rand,"}, {"sha": "218216e3a34ea7dd70df4e45291ab408be0a8a39", "filename": "src/test/run-pass/deriving-in-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-in-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-in-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-in-macro.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -13,7 +13,7 @@\n macro_rules! define_vec (\n     () => (\n         mod foo {\n-            #[deriving(Eq)]\n+            #[deriving(PartialEq)]\n             pub struct bar;\n         }\n     )"}, {"sha": "61df7bf508860eec4858d355736e82ecde3317be", "filename": "src/test/run-pass/deriving-meta-multiple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-meta-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-meta-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-meta-multiple.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -11,7 +11,7 @@\n \n use std::hash::hash;\n \n-#[deriving(Eq, Clone, Hash)]\n+#[deriving(PartialEq, Clone, Hash)]\n struct Foo {\n     bar: uint,\n     baz: int\n@@ -20,7 +20,7 @@ struct Foo {\n pub fn main() {\n     let a = Foo {bar: 4, baz: -3};\n \n-    a == a;    // check for Eq impl w/o testing its correctness\n+    a == a;    // check for PartialEq impl w/o testing its correctness\n     a.clone(); // check for Clone impl w/o testing its correctness\n     hash(&a);  // check for Hash impl w/o testing its correctness\n }"}, {"sha": "61df7bf508860eec4858d355736e82ecde3317be", "filename": "src/test/run-pass/deriving-meta.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-meta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-meta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-meta.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -11,7 +11,7 @@\n \n use std::hash::hash;\n \n-#[deriving(Eq, Clone, Hash)]\n+#[deriving(PartialEq, Clone, Hash)]\n struct Foo {\n     bar: uint,\n     baz: int\n@@ -20,7 +20,7 @@ struct Foo {\n pub fn main() {\n     let a = Foo {bar: 4, baz: -3};\n \n-    a == a;    // check for Eq impl w/o testing its correctness\n+    a == a;    // check for PartialEq impl w/o testing its correctness\n     a.clone(); // check for Clone impl w/o testing its correctness\n     hash(&a);  // check for Hash impl w/o testing its correctness\n }"}, {"sha": "22d40f30dc8fc0eda5d48768028134aac144e765", "filename": "src/test/run-pass/deriving-primitive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -11,7 +11,7 @@\n use std::num::FromPrimitive;\n use std::int;\n \n-#[deriving(Eq, FromPrimitive, Show)]\n+#[deriving(PartialEq, FromPrimitive, Show)]\n enum A {\n     Foo = int::MAX,\n     Bar = 1,"}, {"sha": "3665a0a79fa06edc328c2aa9298d870baabf6a8b", "filename": "src/test/run-pass/deriving-via-extension-c-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-via-extension-c-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-via-extension-c-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-c-enum.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n enum Foo {\n     Bar,\n     Baz,"}, {"sha": "d34b17923c58753b213ff7fd66dd4623e1d36757", "filename": "src/test/run-pass/deriving-via-extension-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-via-extension-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-via-extension-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-enum.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n enum Foo {\n     Bar(int, int),\n     Baz(f64, f64)"}, {"sha": "ab1a67f7e1234db9b76eed222c152efd4c6926d2", "filename": "src/test/run-pass/deriving-via-extension-struct-empty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-empty.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n struct Foo;\n \n pub fn main() {"}, {"sha": "b8cc6ccb69c2446d9e76f488294a1604506071e5", "filename": "src/test/run-pass/deriving-via-extension-struct-like-enum-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-like-enum-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-like-enum-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-like-enum-variant.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(struct_variant)]\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n enum S {\n     X { x: int, y: int },\n     Y"}, {"sha": "8a6aa0fad9342ca7c55ceb60c81c4e933c06a1e2", "filename": "src/test/run-pass/deriving-via-extension-struct-tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n struct Foo(int, int, String);\n \n pub fn main() {"}, {"sha": "18d207d75d471c13cdb15233d005e9cdbb4fc784", "filename": "src/test/run-pass/deriving-via-extension-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n struct Foo {\n     x: int,\n     y: int,"}, {"sha": "1af39da5202c09279dc152d4beeef3fb293f966a", "filename": "src/test/run-pass/deriving-via-extension-type-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -9,7 +9,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq, Hash, Show)]\n+#[deriving(PartialEq, Hash, Show)]\n struct Foo<T> {\n     x: int,\n     y: T,"}, {"sha": "64571be341802c2097fd7b847d930f41d1d440d6", "filename": "src/test/run-pass/empty-tag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fempty-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fempty-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-tag.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -11,7 +11,7 @@\n #[deriving(Show)]\n enum chan { chan_t, }\n \n-impl Eq for chan {\n+impl PartialEq for chan {\n     fn eq(&self, other: &chan) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }"}, {"sha": "49709fa72c669aab5e54b121848e44dda180e54e", "filename": "src/test/run-pass/export-unexported-dep.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -15,7 +15,7 @@ mod foo {\n     // not exported\n     enum t { t1, t2, }\n \n-    impl Eq for t {\n+    impl PartialEq for t {\n         fn eq(&self, other: &t) -> bool {\n             ((*self) as uint) == ((*other) as uint)\n         }"}, {"sha": "b0cc991f667e6520bfc6c7b99fbf8858141f702e", "filename": "src/test/run-pass/expr-if-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -24,7 +24,7 @@ fn test_rec() {\n #[deriving(Show)]\n enum mood { happy, sad, }\n \n-impl Eq for mood {\n+impl PartialEq for mood {\n     fn eq(&self, other: &mood) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }"}, {"sha": "3d01c6653a7a002bc082e5dbaf22c50dfd89af0e", "filename": "src/test/run-pass/expr-match-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fexpr-match-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fexpr-match-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-struct.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -23,7 +23,7 @@ fn test_rec() {\n #[deriving(Show)]\n enum mood { happy, sad, }\n \n-impl Eq for mood {\n+impl PartialEq for mood {\n     fn eq(&self, other: &mood) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }"}, {"sha": "aace680bea0a614b4f6951e7cb0b90d85d8a319a", "filename": "src/test/run-pass/extern-pass-TwoU16s.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU16s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU16s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU16s.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -11,7 +11,7 @@\n // Test a foreign function that accepts and returns a struct\n // by value.\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n struct TwoU16s {\n     one: u16, two: u16\n }"}, {"sha": "fb2188fb6df0b100107c1f9dfa214a2a62df0d30", "filename": "src/test/run-pass/extern-pass-TwoU32s.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -11,7 +11,7 @@\n // Test a foreign function that accepts and returns a struct\n // by value.\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n struct TwoU32s {\n     one: u32, two: u32\n }"}, {"sha": "a6cb44b9c103ed16bac5d64edd66ad8903207d25", "filename": "src/test/run-pass/extern-pass-TwoU64s.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -13,7 +13,7 @@\n \n // ignore-win32 #9205\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n struct TwoU64s {\n     one: u64, two: u64\n }"}, {"sha": "0d5b1b789c6087600c22f1e6fd6f7f6620f02bfd", "filename": "src/test/run-pass/extern-pass-TwoU8s.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU8s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU8s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU8s.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -11,7 +11,7 @@\n // Test a foreign function that accepts and returns a struct\n // by value.\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n struct TwoU8s {\n     one: u8, two: u8\n }"}, {"sha": "62cfd10dbfb468c6a1a298e23f2cc07e24e8dd13", "filename": "src/test/run-pass/fixed_length_vec_glue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ffixed_length_vec_glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ffixed_length_vec_glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffixed_length_vec_glue.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+extern crate debug;\n \n-use std::repr;\n+use debug::repr;\n \n struct Struc { a: u8, b: [int, ..3], c: int }\n "}, {"sha": "b7706088b620234444affb573734813ffcbbe158", "filename": "src/test/run-pass/generic-default-type-params.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fgeneric-default-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fgeneric-default-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-default-type-params.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -49,10 +49,10 @@ fn default_foo(x: Foo) {\n     assert_eq!(x.baz(), (1, 'a'));\n }\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n struct BazHelper<T>(T);\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n // Ensure that we can use previous type parameters in defaults.\n struct Baz<T, U = BazHelper<T>, V = Option<U>>(T, U, V);\n "}, {"sha": "863245d42f0d7359fc1dc3a4852b193239080d44", "filename": "src/test/run-pass/issue-12860.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fissue-12860.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fissue-12860.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12860.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -13,7 +13,7 @@ extern crate collections;\n \n use collections::HashSet;\n \n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(PartialEq, TotalEq, Hash)]\n struct XYZ {\n     x: int,\n     y: int,"}, {"sha": "5f180f13ffa2adb41f1081b143c45035444679dc", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -25,7 +25,7 @@ pub mod pipes {\n         payload: Option<T>\n     }\n \n-    #[deriving(Eq, Show)]\n+    #[deriving(PartialEq, Show)]\n     #[repr(int)]\n     pub enum state {\n         empty,"}, {"sha": "e616c784f4d3874b5b9e0405862e8037a30fc03b", "filename": "src/test/run-pass/issue-3935.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fissue-3935.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fissue-3935.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3935.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n struct Bike {\n     name: String,\n }"}, {"sha": "9151fb2b764730a93a9bb53a3b38f01e9319eb4b", "filename": "src/test/run-pass/issue-5554.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fissue-5554.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fissue-5554.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5554.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -17,7 +17,7 @@ pub struct X<T> {\n }\n \n // reordering these bounds stops the ICE\n-impl<T: Default + Eq + Default> Default for X<T> {\n+impl<T: Default + PartialEq + Default> Default for X<T> {\n     fn default() -> X<T> {\n         X { a: Default::default() }\n     }"}, {"sha": "4e57ed94991cba315f4a00c69348fc6bf1f20b7b", "filename": "src/test/run-pass/issue-5572.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fissue-5572.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fissue-5572.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5572.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo<T: ::std::cmp::Eq>(_t: T) { }\n+fn foo<T: ::std::cmp::PartialEq>(_t: T) { }\n \n pub fn main() { }"}, {"sha": "e82448a44200cb4869bbf64e720702991275d206", "filename": "src/test/run-pass/issue-6341.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fissue-6341.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fissue-6341.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6341.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n struct A { x: uint }\n \n impl Drop for A {"}, {"sha": "2233a5c3ea77456c10dea61dd062855b390678f5", "filename": "src/test/run-pass/monomorphize-abi-alignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fmonomorphize-abi-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fmonomorphize-abi-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonomorphize-abi-alignment.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -20,9 +20,9 @@\n \n struct S<T> { i:u8, t:T }\n impl<T> S<T> { fn unwrap(self) -> T { self.t } }\n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n struct A((u32, u32));\n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n struct B(u64);\n \n pub fn main() {"}, {"sha": "7ce1afb52a274dec37491d016c8100f733af8e17", "filename": "src/test/run-pass/multiple-trait-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fmultiple-trait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fmultiple-trait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmultiple-trait-bounds.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f<T:Eq + Ord>(_: T) {\n+fn f<T:PartialEq + PartialOrd>(_: T) {\n }\n \n pub fn main() {"}, {"sha": "b38bc9b6946a3a08de31a27d90969849974ed6ec", "filename": "src/test/run-pass/newtype-temporary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fnewtype-temporary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fnewtype-temporary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-temporary.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n struct Foo(uint);\n \n fn foo() -> Foo {"}, {"sha": "00e19b8481f217e2a0414f5b14cd63eb631a2a3c", "filename": "src/test/run-pass/operator-overloading.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-overloading.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -48,7 +48,7 @@ impl ops::Index<bool,int> for Point {\n     }\n }\n \n-impl cmp::Eq for Point {\n+impl cmp::PartialEq for Point {\n     fn eq(&self, other: &Point) -> bool {\n         (*self).x == (*other).x && (*self).y == (*other).y\n     }"}, {"sha": "6ac079f461609af04808f631c03ddaf76b4ddbae", "filename": "src/test/run-pass/overload-index-operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -30,7 +30,7 @@ impl<K,V> AssociationList<K,V> {\n     }\n }\n \n-impl<K:Eq,V:Clone> Index<K,V> for AssociationList<K,V> {\n+impl<K:PartialEq,V:Clone> Index<K,V> for AssociationList<K,V> {\n     fn index(&self, index: &K) -> V {\n         for pair in self.pairs.iter() {\n             if pair.key == *index {"}, {"sha": "6fdbd17c21b38f98ab0fc61a590142aa18514610", "filename": "src/test/run-pass/overloaded-autoderef-count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-count.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -11,7 +11,7 @@\n use std::cell::Cell;\n use std::ops::{Deref, DerefMut};\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n struct DerefCounter<T> {\n     count_imm: Cell<uint>,\n     count_mut: uint,\n@@ -46,7 +46,7 @@ impl<T> DerefMut<T> for DerefCounter<T> {\n     }\n }\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n struct Point {\n     x: int,\n     y: int"}, {"sha": "782cea2979f2702966cdd65bf942fcfa83bfe17c", "filename": "src/test/run-pass/overloaded-autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -12,7 +12,7 @@ use std::cell::RefCell;\n use std::rc::Rc;\n use std::string::String;\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n struct Point {\n     x: int,\n     y: int"}, {"sha": "17cd9f8ef0535ce63f2ea73293fd60e2bd7d7292", "filename": "src/test/run-pass/overloaded-deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -12,7 +12,7 @@ use std::cell::RefCell;\n use std::rc::Rc;\n use std::string::String;\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n struct Point {\n     x: int,\n     y: int"}, {"sha": "8309e95820cf17245921fef47cde7b2b7fdfbf9a", "filename": "src/test/run-pass/packed-struct-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -13,7 +13,7 @@\n use std::mem;\n \n #[packed]\n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n struct Foo {\n     bar: u8,\n     baz: u64"}, {"sha": "d61d7089d89e6d002fc806fb5432e54139c485af", "filename": "src/test/run-pass/regions-lifetime-static-items-enclosing-scopes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fregions-lifetime-static-items-enclosing-scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fregions-lifetime-static-items-enclosing-scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-lifetime-static-items-enclosing-scopes.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -11,9 +11,9 @@\n // This test verifies that temporary lifetime is correctly computed\n // for static objects in enclosing scopes.\n \n-use std::cmp::Eq;\n+use std::cmp::PartialEq;\n \n-fn f<T:Eq>(o: &mut Option<T>) {\n+fn f<T:PartialEq>(o: &mut Option<T>) {\n     assert!(*o == None);\n }\n "}, {"sha": "1d7521b74506dc4c77a940d35cfa42a80e4f3eef", "filename": "src/test/run-pass/regions-mock-tcx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -30,7 +30,7 @@ enum TypeStructure<'tcx> {\n     TypeInt,\n     TypeFunction(Type<'tcx>, Type<'tcx>),\n }\n-impl<'tcx> Eq for TypeStructure<'tcx> {\n+impl<'tcx> PartialEq for TypeStructure<'tcx> {\n     fn eq(&self, other: &TypeStructure<'tcx>) -> bool {\n         match (*self, *other) {\n             (TypeInt, TypeInt) => true,\n@@ -86,7 +86,7 @@ impl<'tcx,'ast> TypeContext<'tcx, 'ast> {\n     }\n }\n \n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(PartialEq, TotalEq, Hash)]\n struct NodeId {\n     id: uint\n }"}, {"sha": "7cc6725a509a6958cef6a807b728166cc36b4563", "filename": "src/test/run-pass/small-enums-with-fields.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fsmall-enums-with-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fsmall-enums-with-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmall-enums-with-fields.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -14,7 +14,7 @@ extern crate debug;\n \n use std::mem::size_of;\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n enum Either<T, U> { Left(T), Right(U) }\n \n macro_rules! check {"}, {"sha": "9212a72e5d41735bdb149fb4f734137e8592ed6c", "filename": "src/test/run-pass/struct-lit-functional-no-fields.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fstruct-lit-functional-no-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fstruct-lit-functional-no-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-lit-functional-no-fields.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Show,Eq,Clone)]\n+#[deriving(Show,PartialEq,Clone)]\n struct Foo<T> {\n     bar: T,\n     baz: T"}, {"sha": "f6b5531770bed57dd82278f8113e820212c15e8e", "filename": "src/test/run-pass/structured-compare.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fstructured-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fstructured-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructured-compare.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -13,7 +13,7 @@\n #[deriving(Show)]\n enum foo { large, small, }\n \n-impl Eq for foo {\n+impl PartialEq for foo {\n     fn eq(&self, other: &foo) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }"}, {"sha": "191a6a9c7e2ec70e2fdb821c25b08daac5115c42", "filename": "src/test/run-pass/tag-variant-disr-val.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -19,7 +19,7 @@ enum color {\n     orange = 8 >> 1\n }\n \n-impl Eq for color {\n+impl PartialEq for color {\n     fn eq(&self, other: &color) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }"}, {"sha": "91c8b433b4e6b5d5f19a19462acf9e81866b4b4b", "filename": "src/test/run-pass/tag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ftag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ftag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -11,7 +11,7 @@\n \n enum colour { red(int, int), green, }\n \n-impl Eq for colour {\n+impl PartialEq for colour {\n     fn eq(&self, other: &colour) -> bool {\n         match *self {\n             red(a0, b0) => {"}, {"sha": "9263cd1d485422e2dcfed162c1e5d5e4f96172b1", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -52,7 +52,7 @@ enum t {\n     tag3(int, u8, char)\n }\n \n-impl cmp::Eq for t {\n+impl cmp::PartialEq for t {\n     fn eq(&self, other: &t) -> bool {\n         match *self {\n             tag1 => {"}, {"sha": "8cf83fdf2d0d7b0ecc0edd68b159c2f2ace0101b", "filename": "src/test/run-pass/trait-inheritance-num.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -9,10 +9,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cmp::{Eq, Ord};\n+use std::cmp::{PartialEq, PartialOrd};\n use std::num::NumCast;\n \n-pub trait NumExt: Num + NumCast + Eq + Ord {}\n+pub trait NumExt: Num + NumCast + PartialEq + PartialOrd {}\n \n pub trait FloatExt: NumExt {}\n "}, {"sha": "379acf26c1955f8633d8cd274e856ea67e2bfbf3", "filename": "src/test/run-pass/trait-inheritance-num1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cmp::Ord;\n+use std::cmp::PartialOrd;\n use std::num::NumCast;\n \n-pub trait NumExt: Num + NumCast + Ord { }\n+pub trait NumExt: Num + NumCast + PartialOrd { }\n \n fn greater_than_one<T:NumExt>(n: &T) -> bool {\n     *n > NumCast::from(1).unwrap()"}, {"sha": "b3f769798b32a8cfb2a694e64c48d73066519941", "filename": "src/test/run-pass/trait-inheritance-num2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -11,7 +11,7 @@\n \n // A more complex example of numeric extensions\n \n-use std::cmp::{Eq, Ord};\n+use std::cmp::{PartialEq, PartialOrd};\n \n pub trait TypeExt {}\n \n@@ -32,7 +32,7 @@ impl TypeExt for f32 {}\n impl TypeExt for f64 {}\n \n \n-pub trait NumExt: TypeExt + Eq + Ord + Num + NumCast {}\n+pub trait NumExt: TypeExt + PartialEq + PartialOrd + Num + NumCast {}\n \n impl NumExt for u8 {}\n impl NumExt for u16 {}"}, {"sha": "fc17aa113408eaf67ada363f838e8377bf4e211f", "filename": "src/test/run-pass/trait-inheritance-num3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cmp::{Eq, Ord};\n+use std::cmp::{PartialEq, PartialOrd};\n use std::num::NumCast;\n \n-pub trait NumExt: Eq + Ord + Num + NumCast {}\n+pub trait NumExt: PartialEq + PartialOrd + Num + NumCast {}\n \n impl NumExt for f32 {}\n "}, {"sha": "3a0605302a256a21edfadf19ca93c9c679212341", "filename": "src/test/run-pass/trait-inheritance-num5.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cmp::Eq;\n+use std::cmp::PartialEq;\n use std::num::NumCast;\n \n-pub trait NumExt: Eq + Num + NumCast {}\n+pub trait NumExt: PartialEq + Num + NumCast {}\n \n impl NumExt for f32 {}\n impl NumExt for int {}"}, {"sha": "bd9bc9e9b8875a8e01f114d755977384f6965a6d", "filename": "src/test/run-pass/trait-inheritance-overloading-simple.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-simple.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cmp::Eq;\n+use std::cmp::PartialEq;\n \n-trait MyNum : Eq { }\n+trait MyNum : PartialEq { }\n \n #[deriving(Show)]\n struct MyInt { val: int }\n \n-impl Eq for MyInt {\n+impl PartialEq for MyInt {\n     fn eq(&self, other: &MyInt) -> bool { self.val == other.val }\n     fn ne(&self, other: &MyInt) -> bool { !self.eq(other) }\n }"}, {"sha": "b13ea7ae0baef4602b0de80b4bc989142b4c1f9e", "filename": "src/test/run-pass/trait-inheritance-overloading.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cmp::Eq;\n+use std::cmp::PartialEq;\n \n-trait MyNum : Add<Self,Self> + Sub<Self,Self> + Mul<Self,Self> + Eq { }\n+trait MyNum : Add<Self,Self> + Sub<Self,Self> + Mul<Self,Self> + PartialEq { }\n \n #[deriving(Show)]\n struct MyInt { val: int }\n@@ -27,7 +27,7 @@ impl Mul<MyInt, MyInt> for MyInt {\n     fn mul(&self, other: &MyInt) -> MyInt { mi(self.val * other.val) }\n }\n \n-impl Eq for MyInt {\n+impl PartialEq for MyInt {\n     fn eq(&self, other: &MyInt) -> bool { self.val == other.val }\n     fn ne(&self, other: &MyInt) -> bool { !self.eq(other) }\n }"}, {"sha": "281ea39084f594de82d9088f73d01d1a4ca910a9", "filename": "src/test/run-pass/tuple-struct-constructor-pointer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ftuple-struct-constructor-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Ftuple-struct-constructor-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftuple-struct-constructor-pointer.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n struct Foo(int);\n-#[deriving(Eq, Show)]\n+#[deriving(PartialEq, Show)]\n struct Bar(int, int);\n \n pub fn main() {"}, {"sha": "65a8314fe8eba116b5a66faf50280ed7630230b8", "filename": "src/test/run-pass/unique-kinds.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Funique-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Funique-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-kinds.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cmp::Eq;\n+use std::cmp::PartialEq;\n \n fn sendable() {\n \n-    fn f<T:Send + Eq>(i: T, j: T) {\n+    fn f<T:Send + PartialEq>(i: T, j: T) {\n         assert!(i == j);\n     }\n \n-    fn g<T:Send + Eq>(i: T, j: T) {\n+    fn g<T:Send + PartialEq>(i: T, j: T) {\n         assert!(i != j);\n     }\n \n@@ -30,11 +30,11 @@ fn sendable() {\n \n fn copyable() {\n \n-    fn f<T:Eq>(i: T, j: T) {\n+    fn f<T:PartialEq>(i: T, j: T) {\n         assert!(i == j);\n     }\n \n-    fn g<T:Eq>(i: T, j: T) {\n+    fn g<T:PartialEq>(i: T, j: T) {\n         assert!(i != j);\n     }\n \n@@ -48,11 +48,11 @@ fn copyable() {\n \n fn noncopyable() {\n \n-    fn f<T:Eq>(i: T, j: T) {\n+    fn f<T:PartialEq>(i: T, j: T) {\n         assert!(i == j);\n     }\n \n-    fn g<T:Eq>(i: T, j: T) {\n+    fn g<T:PartialEq>(i: T, j: T) {\n         assert!(i != j);\n     }\n "}, {"sha": "e4e419e4988c17923f92ed81564dca08e95006af", "filename": "src/test/run-pass/vector-sort-failure-safe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -15,7 +15,7 @@ static MAX_LEN: uint = 20;\n static mut drop_counts: [uint, .. MAX_LEN] = [0, .. MAX_LEN];\n static mut clone_count: uint = 0;\n \n-#[deriving(Rand, Eq, Ord, TotalEq, TotalOrd)]\n+#[deriving(Rand, PartialEq, PartialOrd, TotalEq, TotalOrd)]\n struct DropCounter { x: uint, clone_num: uint }\n \n impl Clone for DropCounter {"}, {"sha": "28fbab41d95e0b6f3265374fedbe6d550f0c1256", "filename": "src/test/run-pass/while-prelude-drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a43f9bc5d24b47aae9681fc7ef47d517329e59/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs?ref=60a43f9bc5d24b47aae9681fc7ef47d517329e59", "patch": "@@ -10,7 +10,7 @@\n \n use std::string::String;\n \n-#[deriving(Eq)]\n+#[deriving(PartialEq)]\n enum t { a, b(String), }\n \n fn make(i: int) -> t {"}]}