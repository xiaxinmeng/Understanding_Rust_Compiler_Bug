{"sha": "bf1ba83292e767365be925c132027c67ec40fe68", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmMWJhODMyOTJlNzY3MzY1YmU5MjVjMTMyMDI3YzY3ZWM0MGZlNjg=", "commit": {"author": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-28T11:40:51Z"}, "committer": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-28T11:57:30Z"}, "message": "doc: Monty Hall simulation for std::rand\n\nA larger example for std::rand", "tree": {"sha": "a59567985c1120930e7c89add0fdc0b57587e04b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a59567985c1120930e7c89add0fdc0b57587e04b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf1ba83292e767365be925c132027c67ec40fe68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf1ba83292e767365be925c132027c67ec40fe68", "html_url": "https://github.com/rust-lang/rust/commit/bf1ba83292e767365be925c132027c67ec40fe68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf1ba83292e767365be925c132027c67ec40fe68/comments", "author": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d114ddac030d6ed63b3076ccc0e7db081c0a9409", "url": "https://api.github.com/repos/rust-lang/rust/commits/d114ddac030d6ed63b3076ccc0e7db081c0a9409", "html_url": "https://github.com/rust-lang/rust/commit/d114ddac030d6ed63b3076ccc0e7db081c0a9409"}], "stats": {"total": 103, "additions": 103, "deletions": 0}, "files": [{"sha": "273b1d7f34300a8535b6e37db19848506d14627c", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/bf1ba83292e767365be925c132027c67ec40fe68/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1ba83292e767365be925c132027c67ec40fe68/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=bf1ba83292e767365be925c132027c67ec40fe68", "patch": "@@ -71,6 +71,109 @@ use std::rand;\n let tuple = rand::random::<(f64, char)>();\n println!(\"{}\", tuple)\n ```\n+\n+This is a simulation of the [Monty Hall Problem][]:\n+\n+> Suppose you're on a game show, and you're given the choice of three doors:\n+> Behind one door is a car; behind the others, goats. You pick a door, say No. 1,\n+> and the host, who knows what's behind the doors, opens another door, say No. 3,\n+> which has a goat. He then says to you, \"Do you want to pick door No. 2?\"\n+> Is it to your advantage to switch your choice?\n+\n+The rather unintuitive answer is that you will have a 2/3 chance of winning if\n+you switch and a 1/3 chance of winning of you don't, so it's better to switch.\n+\n+This program will simulate the game show and with large enough simulation steps\n+it will indeed confirm that it is better to switch.\n+\n+[Monty Hall Problem]: http://en.wikipedia.org/wiki/Monty_Hall_problem\n+\n+```\n+use std::rand;\n+use std::rand::Rng;\n+use std::rand::distributions::{IndependentSample, Range};\n+\n+struct SimulationResult {\n+    win: bool,\n+    switch: bool\n+}\n+\n+// Run a single simulation of the Monty Hall problem.\n+fn simulate<R: Rng>(rng: &mut R) -> SimulationResult {\n+    let random_door = Range::new(0u, 3);\n+    let car = random_door.ind_sample(rng);\n+\n+    // This is our initial choice\n+    let mut choice = random_door.ind_sample(rng);\n+\n+    // The game host opens a door\n+    let open = game_host_open(car, choice, rng);\n+\n+    // Shall we switch?\n+    let switch = rng.gen();\n+    if switch {\n+        choice = switch_door(choice, open);\n+    }\n+\n+    SimulationResult { win: choice == car, switch: switch }\n+}\n+\n+// Returns the door the game host opens given our choice and knowledge of\n+// where the car is. The game host will never open the door with the car.\n+fn game_host_open<R: Rng>(car: uint, choice: uint, rng: &mut R) -> uint {\n+    let choices = free_doors(vec![car, choice]);\n+    rand::sample(rng, choices.move_iter(), 1)[0]\n+}\n+\n+// Returns the door we switch to, given our current choice and\n+// the open door. There will only be one valid door.\n+fn switch_door(choice: uint, open: uint) -> uint {\n+    free_doors(vec![choice, open])[0]\n+}\n+\n+fn free_doors(blocked: Vec<uint>) -> Vec<uint> {\n+    range(0u, 3).filter(|x| !blocked.contains(x)).collect()\n+}\n+\n+fn main() {\n+    // The estimation will be more accuraty with more simulations\n+    let num_simulations = 10000u;\n+\n+    let mut rng = rand::task_rng();\n+\n+    let (mut switch_wins, mut switch_losses) = (0u, 0u);\n+    let (mut keep_wins, mut keep_losses) = (0u, 0u);\n+\n+    println!(\"Running {} simulations...\", num_simulations);\n+    for _ in range(0, num_simulations) {\n+        let result = simulate(&mut rng);\n+\n+        match (result.win, result.switch) {\n+            (true, true) => switch_wins += 1,\n+            (true, false) => keep_wins += 1,\n+            (false, true) => switch_losses += 1,\n+            (false, false) => keep_losses += 1,\n+        }\n+    }\n+\n+    let total_switches = switch_wins + switch_losses;\n+    let total_keeps = keep_wins + keep_losses;\n+\n+    println!(\"Switched door {} times with {} wins and {} losses\",\n+             total_switches, switch_wins, switch_losses);\n+\n+    println!(\"Kept our choice {} times with {} wins and {} losses\",\n+             total_keeps, keep_wins, keep_losses);\n+\n+    // With a large number of simulations, the values should converge to\n+    // 0.667 and 0.333 respectively.\n+    println!(\"Estimated chance to win if we switch: {}\",\n+             switch_wins as f32 / total_switches as f32);\n+    println!(\"Estimated chance to win if we don't: {}\",\n+             keep_wins as f32 / total_keeps as f32);\n+}\n+```\n+\n */\n \n #![experimental]"}]}