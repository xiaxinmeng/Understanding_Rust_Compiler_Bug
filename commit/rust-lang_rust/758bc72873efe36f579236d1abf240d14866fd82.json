{"sha": "758bc72873efe36f579236d1abf240d14866fd82", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1OGJjNzI4NzNlZmUzNmY1NzkyMzZkMWFiZjI0MGQxNDg2NmZkODI=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-23T22:08:41Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-02-01T21:17:48Z"}, "message": "Implement methods to build a resolver", "tree": {"sha": "a8c416c5c2c3dfb834bf29ed2ca4fae666048a59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8c416c5c2c3dfb834bf29ed2ca4fae666048a59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/758bc72873efe36f579236d1abf240d14866fd82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/758bc72873efe36f579236d1abf240d14866fd82", "html_url": "https://github.com/rust-lang/rust/commit/758bc72873efe36f579236d1abf240d14866fd82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/758bc72873efe36f579236d1abf240d14866fd82/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5208c2aa930ae452e062dcdc2563c1bbb67d2e4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5208c2aa930ae452e062dcdc2563c1bbb67d2e4a", "html_url": "https://github.com/rust-lang/rust/commit/5208c2aa930ae452e062dcdc2563c1bbb67d2e4a"}], "stats": {"total": 239, "additions": 166, "deletions": 73}, "files": [{"sha": "b8ca04c5ca6a29c15b3cfc482772f9b66c55abd4", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/758bc72873efe36f579236d1abf240d14866fd82/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bc72873efe36f579236d1abf240d14866fd82/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=758bc72873efe36f579236d1abf240d14866fd82", "patch": "@@ -184,9 +184,9 @@ impl Module {\n         self.problems_impl(db)\n     }\n \n-    #[allow(unused_variables)]\n     pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n-        unimplemented!()\n+        let item_map = db.item_map(self.krate);\n+        Resolver::default().push_module_scope(item_map, self.module_id)\n     }\n }\n \n@@ -480,6 +480,24 @@ impl Function {\n     pub fn generic_params(&self, db: &impl PersistentHirDatabase) -> Arc<GenericParams> {\n         db.generic_params((*self).into())\n     }\n+\n+    // TODO move to a more general type for 'body-having' items\n+    /// Builds a resolver for code inside this item.\n+    pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+        // take the outer scope...\n+        let r = self\n+            .impl_block(db)\n+            .map(|ib| ib.resolver(db))\n+            .unwrap_or_else(|| self.module(db).resolver(db));\n+        // ...and add generic params, if present\n+        let p = self.generic_params(db);\n+        let r = if !p.params.is_empty() {\n+            r.push_generic_params_scope(p)\n+        } else {\n+            r\n+        };\n+        r\n+    }\n }\n \n impl Docs for Function {"}, {"sha": "c09d3fbf9d6a229f15307645dfbc0963041fb8a9", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 77, "deletions": 52, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/758bc72873efe36f579236d1abf240d14866fd82/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bc72873efe36f579236d1abf240d14866fd82/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=758bc72873efe36f579236d1abf240d14866fd82", "patch": "@@ -27,6 +27,9 @@ impl_arena_id!(ExprId);\n /// The body of an item (function, const etc.).\n #[derive(Debug, Eq, PartialEq)]\n pub struct Body {\n+    // TODO: this should be more general, consts & statics also have bodies\n+    /// The Function of the item this body belongs to\n+    owner: Function,\n     exprs: Arena<ExprId, Expr>,\n     pats: Arena<PatId, Pat>,\n     /// The patterns for the function's parameters. While the parameter types are\n@@ -63,12 +66,26 @@ impl Body {\n         self.body_expr\n     }\n \n-    #[allow(unused_variables)]\n-    pub fn resolver_for_expr(&self, expr_id: ExprId) -> Resolver {\n-        unimplemented!()\n+    pub fn owner(&self) -> Function {\n+        self.owner\n     }\n }\n \n+// needs arbitrary_self_types to be a method... or maybe move to the def?\n+#[allow(dead_code)]\n+pub fn resolver_for_expr(body: Arc<Body>, db: &impl HirDatabase, expr_id: ExprId) -> Resolver {\n+    let mut r = body.owner.resolver(db);\n+    if !body.params.is_empty() {\n+        r = r.push_function_params(Arc::clone(&body));\n+    }\n+    let scopes = db.expr_scopes(body.owner);\n+    let scope_chain = scopes.scope_chain_for(expr_id).collect::<Vec<_>>();\n+    for scope in scope_chain.into_iter().rev() {\n+        r = r.push_expr_scope(Arc::clone(&scopes), scope);\n+    }\n+    r\n+}\n+\n impl Index<ExprId> for Body {\n     type Output = Expr;\n \n@@ -453,23 +470,29 @@ pub(crate) fn body_hir(db: &impl HirDatabase, func: Function) -> Arc<Body> {\n }\n \n struct ExprCollector {\n+    owner: Function,\n     exprs: Arena<ExprId, Expr>,\n     pats: Arena<PatId, Pat>,\n     expr_syntax_mapping: FxHashMap<SyntaxNodePtr, ExprId>,\n     expr_syntax_mapping_back: ArenaMap<ExprId, SyntaxNodePtr>,\n     pat_syntax_mapping: FxHashMap<SyntaxNodePtr, PatId>,\n     pat_syntax_mapping_back: ArenaMap<PatId, SyntaxNodePtr>,\n+    params: Vec<PatId>,\n+    body_expr: Option<ExprId>,\n }\n \n impl ExprCollector {\n-    fn new() -> Self {\n+    fn new(owner: Function) -> Self {\n         ExprCollector {\n+            owner,\n             exprs: Arena::default(),\n             pats: Arena::default(),\n             expr_syntax_mapping: FxHashMap::default(),\n             expr_syntax_mapping_back: ArenaMap::default(),\n             pat_syntax_mapping: FxHashMap::default(),\n             pat_syntax_mapping_back: ArenaMap::default(),\n+            params: Vec::new(),\n+            body_expr: None,\n         }\n     }\n \n@@ -907,10 +930,7 @@ impl ExprCollector {\n                 });\n                 fields.extend(iter);\n \n-                Pat::Struct {\n-                    path: path,\n-                    args: fields,\n-                }\n+                Pat::Struct { path, args: fields }\n             }\n \n             // TODO: implement\n@@ -928,12 +948,48 @@ impl ExprCollector {\n         }\n     }\n \n-    fn into_body_syntax_mapping(self, params: Vec<PatId>, body_expr: ExprId) -> BodySyntaxMapping {\n+    fn collect_fn_body(&mut self, node: &ast::FnDef) {\n+        if let Some(param_list) = node.param_list() {\n+            if let Some(self_param) = param_list.self_param() {\n+                let self_param = SyntaxNodePtr::new(\n+                    self_param\n+                        .self_kw()\n+                        .expect(\"self param without self keyword\")\n+                        .syntax(),\n+                );\n+                let param_pat = self.alloc_pat(\n+                    Pat::Bind {\n+                        name: Name::self_param(),\n+                        mode: BindingAnnotation::Unannotated,\n+                        subpat: None,\n+                    },\n+                    self_param,\n+                );\n+                self.params.push(param_pat);\n+            }\n+\n+            for param in param_list.params() {\n+                let pat = if let Some(pat) = param.pat() {\n+                    pat\n+                } else {\n+                    continue;\n+                };\n+                let param_pat = self.collect_pat(pat);\n+                self.params.push(param_pat);\n+            }\n+        };\n+\n+        let body = self.collect_block_opt(node.body());\n+        self.body_expr = Some(body);\n+    }\n+\n+    fn into_body_syntax_mapping(self) -> BodySyntaxMapping {\n         let body = Body {\n+            owner: self.owner,\n             exprs: self.exprs,\n             pats: self.pats,\n-            params,\n-            body_expr,\n+            params: self.params,\n+            body_expr: self.body_expr.expect(\"A body should have been collected\"),\n         };\n         BodySyntaxMapping {\n             body: Arc::new(body),\n@@ -945,49 +1001,18 @@ impl ExprCollector {\n     }\n }\n \n-pub(crate) fn collect_fn_body_syntax(node: &ast::FnDef) -> BodySyntaxMapping {\n-    let mut collector = ExprCollector::new();\n-\n-    let params = if let Some(param_list) = node.param_list() {\n-        let mut params = Vec::new();\n-\n-        if let Some(self_param) = param_list.self_param() {\n-            let self_param = SyntaxNodePtr::new(\n-                self_param\n-                    .self_kw()\n-                    .expect(\"self param without self keyword\")\n-                    .syntax(),\n-            );\n-            let param = collector.alloc_pat(\n-                Pat::Bind {\n-                    name: Name::self_param(),\n-                    mode: BindingAnnotation::Unannotated,\n-                    subpat: None,\n-                },\n-                self_param,\n-            );\n-            params.push(param);\n-        }\n+pub(crate) fn body_syntax_mapping(db: &impl HirDatabase, func: Function) -> Arc<BodySyntaxMapping> {\n+    let mut collector = ExprCollector::new(func);\n \n-        for param in param_list.params() {\n-            let pat = if let Some(pat) = param.pat() {\n-                pat\n-            } else {\n-                continue;\n-            };\n-            params.push(collector.collect_pat(pat));\n-        }\n-        params\n-    } else {\n-        Vec::new()\n-    };\n+    // TODO: consts, etc.\n+    collector.collect_fn_body(&func.source(db).1);\n \n-    let body = collector.collect_block_opt(node.body());\n-    collector.into_body_syntax_mapping(params, body)\n+    Arc::new(collector.into_body_syntax_mapping())\n }\n \n-pub(crate) fn body_syntax_mapping(db: &impl HirDatabase, func: Function) -> Arc<BodySyntaxMapping> {\n-    let (_, fn_def) = func.source(db);\n-    let body_syntax_mapping = collect_fn_body_syntax(&fn_def);\n-    Arc::new(body_syntax_mapping)\n+#[cfg(test)]\n+pub(crate) fn collect_fn_body_syntax(function: Function, node: &ast::FnDef) -> BodySyntaxMapping {\n+    let mut collector = ExprCollector::new(function);\n+    collector.collect_fn_body(node);\n+    collector.into_body_syntax_mapping()\n }"}, {"sha": "887ad8dd8b9247da798d9b396af96b47cb03ca50", "filename": "crates/ra_hir/src/expr/scope.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/758bc72873efe36f579236d1abf240d14866fd82/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bc72873efe36f579236d1abf240d14866fd82/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs?ref=758bc72873efe36f579236d1abf240d14866fd82", "patch": "@@ -338,6 +338,7 @@ pub struct ReferenceDescriptor {\n mod tests {\n     use ra_syntax::{SourceFile, algo::find_node_at_offset};\n     use test_utils::{extract_offset, assert_eq_text};\n+    use ra_arena::ArenaId;\n \n     use crate::expr;\n \n@@ -356,7 +357,10 @@ mod tests {\n         let file = SourceFile::parse(&code);\n         let marker: &ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n         let fn_def: &ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n-        let body_hir = expr::collect_fn_body_syntax(fn_def);\n+        let irrelevant_function = Function {\n+            id: crate::ids::FunctionId::from_raw(0.into()),\n+        };\n+        let body_hir = expr::collect_fn_body_syntax(irrelevant_function, fn_def);\n         let scopes = ExprScopes::new(Arc::clone(body_hir.body()));\n         let scopes = ScopesWithSyntaxMapping {\n             scopes: Arc::new(scopes),\n@@ -456,7 +460,10 @@ mod tests {\n         let fn_def: &ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n         let name_ref: &ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n \n-        let body_hir = expr::collect_fn_body_syntax(fn_def);\n+        let irrelevant_function = Function {\n+            id: crate::ids::FunctionId::from_raw(0.into()),\n+        };\n+        let body_hir = expr::collect_fn_body_syntax(irrelevant_function, fn_def);\n         let scopes = ExprScopes::new(Arc::clone(body_hir.body()));\n         let scopes = ScopesWithSyntaxMapping {\n             scopes: Arc::new(scopes),"}, {"sha": "5fa49d456206eea4d23f8464ca540cc5bae4e532", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/758bc72873efe36f579236d1abf240d14866fd82/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bc72873efe36f579236d1abf240d14866fd82/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=758bc72873efe36f579236d1abf240d14866fd82", "patch": "@@ -9,9 +9,11 @@ ast::{self, AstNode}};\n use crate::{\n     Const, Type,\n     Function, HirFileId,\n+    HirDatabase,\n     PersistentHirDatabase,\n     type_ref::TypeRef,\n     ids::LocationCtx,\n+    resolve::Resolver,\n };\n \n use crate::code_model_api::{Module, ModuleSource};\n@@ -69,6 +71,10 @@ impl ImplBlock {\n         &self.module_impl_blocks.impls[self.impl_id]\n     }\n \n+    pub fn module(&self) -> Module {\n+        self.module_impl_blocks.module.clone()\n+    }\n+\n     pub fn target_trait(&self) -> Option<&TypeRef> {\n         self.impl_data().target_trait()\n     }\n@@ -80,6 +86,13 @@ impl ImplBlock {\n     pub fn items(&self) -> &[ImplItem] {\n         self.impl_data().items()\n     }\n+\n+    pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+        let r = self.module().resolver(db);\n+        // FIXME: add generics\n+        let r = r.push_impl_block_scope(self.clone());\n+        r\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -162,25 +175,24 @@ impl_arena_id!(ImplId);\n /// we don't need to do the second step again.\n #[derive(Debug, PartialEq, Eq)]\n pub struct ModuleImplBlocks {\n+    module: Module,\n     pub(crate) impls: Arena<ImplId, ImplData>,\n     impls_by_def: FxHashMap<ImplItem, ImplId>,\n }\n \n impl ModuleImplBlocks {\n-    fn new() -> Self {\n-        ModuleImplBlocks {\n-            impls: Arena::default(),\n-            impls_by_def: FxHashMap::default(),\n-        }\n-    }\n-\n     fn collect(\n-        &mut self,\n         db: &impl PersistentHirDatabase,\n         module: Module,\n         source_map: &mut ImplSourceMap,\n-    ) {\n-        let (file_id, module_source) = module.definition_source(db);\n+    ) -> Self {\n+        let mut m = ModuleImplBlocks {\n+            module,\n+            impls: Arena::default(),\n+            impls_by_def: FxHashMap::default(),\n+        };\n+\n+        let (file_id, module_source) = m.module.definition_source(db);\n         let file_id: HirFileId = file_id.into();\n         let node = match &module_source {\n             ModuleSource::SourceFile(node) => node.syntax(),\n@@ -191,14 +203,16 @@ impl ModuleImplBlocks {\n         };\n \n         for impl_block_ast in node.children().filter_map(ast::ImplBlock::cast) {\n-            let impl_block = ImplData::from_ast(db, file_id, module, impl_block_ast);\n-            let id = self.impls.alloc(impl_block);\n-            for &impl_item in &self.impls[id].items {\n-                self.impls_by_def.insert(impl_item, id);\n+            let impl_block = ImplData::from_ast(db, file_id, m.module, impl_block_ast);\n+            let id = m.impls.alloc(impl_block);\n+            for &impl_item in &m.impls[id].items {\n+                m.impls_by_def.insert(impl_item, id);\n             }\n \n             source_map.insert(id, impl_block_ast);\n         }\n+\n+        m\n     }\n }\n \n@@ -208,8 +222,7 @@ pub(crate) fn impls_in_module_with_source_map_query(\n ) -> (Arc<ModuleImplBlocks>, Arc<ImplSourceMap>) {\n     let mut source_map = ImplSourceMap::default();\n \n-    let mut result = ModuleImplBlocks::new();\n-    result.collect(db, module, &mut source_map);\n+    let result = ModuleImplBlocks::collect(db, module, &mut source_map);\n \n     (Arc::new(result), Arc::new(source_map))\n }"}, {"sha": "b7fbf6df29fe1007b7d96a929cd0a0aad5f00fba", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/758bc72873efe36f579236d1abf240d14866fd82/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bc72873efe36f579236d1abf240d14866fd82/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=758bc72873efe36f579236d1abf240d14866fd82", "patch": "@@ -15,7 +15,7 @@ use crate::{\n     path::Path,\n };\n \n-#[derive(Debug, Clone)]\n+#[derive(Debug, Clone, Default)]\n pub struct Resolver {\n     scopes: Vec<Scope>, // maybe a 'linked list' of scopes? or allow linking a Resolver to a parent Resolver? that's an optimization that might not be necessary, though\n }\n@@ -87,6 +87,36 @@ impl Resolver {\n         self\n     }\n \n+    pub(crate) fn push_generic_params_scope(self, params: Arc<GenericParams>) -> Resolver {\n+        self.push_scope(Scope::GenericParams(params))\n+    }\n+\n+    pub(crate) fn push_impl_block_scope(self, impl_block: ImplBlock) -> Resolver {\n+        self.push_scope(Scope::ImplBlockScope(impl_block))\n+    }\n+\n+    pub(crate) fn push_module_scope(self, item_map: Arc<ItemMap>, module_id: ModuleId) -> Resolver {\n+        self.push_scope(Scope::ModuleScope(ModuleItemMap {\n+            item_map,\n+            module_id,\n+        }))\n+    }\n+\n+    pub(crate) fn push_expr_scope(\n+        self,\n+        expr_scopes: Arc<ExprScopes>,\n+        scope_id: ScopeId,\n+    ) -> Resolver {\n+        self.push_scope(Scope::ExprScope(ExprScope {\n+            expr_scopes,\n+            scope_id,\n+        }))\n+    }\n+\n+    pub(crate) fn push_function_params(self, body: Arc<Body>) -> Resolver {\n+        self.push_scope(Scope::FunctionParams(body))\n+    }\n+\n     pub(crate) fn pop_scope(mut self) -> Resolver {\n         self.scopes.pop();\n         self"}]}