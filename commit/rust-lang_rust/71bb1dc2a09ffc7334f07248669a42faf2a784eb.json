{"sha": "71bb1dc2a09ffc7334f07248669a42faf2a784eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxYmIxZGMyYTA5ZmZjNzMzNGYwNzI0ODY2OWE0MmZhZjJhNzg0ZWI=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-07T18:38:25Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-16T04:19:00Z"}, "message": "Take sys/vxworks/{fd,fs,io} from sys/unix instead.", "tree": {"sha": "ea4277d856966bc2b24710e6572cdbd241b2b5fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea4277d856966bc2b24710e6572cdbd241b2b5fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71bb1dc2a09ffc7334f07248669a42faf2a784eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71bb1dc2a09ffc7334f07248669a42faf2a784eb", "html_url": "https://github.com/rust-lang/rust/commit/71bb1dc2a09ffc7334f07248669a42faf2a784eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71bb1dc2a09ffc7334f07248669a42faf2a784eb/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f196dc137c378e727c6626e5a38b37e15fbbf70", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f196dc137c378e727c6626e5a38b37e15fbbf70", "html_url": "https://github.com/rust-lang/rust/commit/3f196dc137c378e727c6626e5a38b37e15fbbf70"}], "stats": {"total": 990, "additions": 81, "deletions": 909}, "files": [{"sha": "77e6238ca1f528dd11420ae35724608ce9e4cbdf", "filename": "library/std/src/os/vxworks/fs.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/71bb1dc2a09ffc7334f07248669a42faf2a784eb/library%2Fstd%2Fsrc%2Fos%2Fvxworks%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bb1dc2a09ffc7334f07248669a42faf2a784eb/library%2Fstd%2Fsrc%2Fos%2Fvxworks%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fvxworks%2Ffs.rs?ref=71bb1dc2a09ffc7334f07248669a42faf2a784eb", "patch": "@@ -26,10 +26,16 @@ pub trait MetadataExt {\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n     fn st_atime(&self) -> i64;\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_atime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n     fn st_mtime(&self) -> i64;\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mtime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n     fn st_ctime(&self) -> i64;\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ctime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n     fn st_blksize(&self) -> u64;\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n     fn st_blocks(&self) -> u64;\n@@ -66,12 +72,21 @@ impl MetadataExt for Metadata {\n     fn st_atime(&self) -> i64 {\n         self.as_inner().as_inner().st_atime as i64\n     }\n+    fn st_atime_nsec(&self) -> i64 {\n+        0\n+    }\n     fn st_mtime(&self) -> i64 {\n         self.as_inner().as_inner().st_mtime as i64\n     }\n+    fn st_mtime_nsec(&self) -> i64 {\n+        0\n+    }\n     fn st_ctime(&self) -> i64 {\n         self.as_inner().as_inner().st_ctime as i64\n     }\n+    fn st_ctime_nsec(&self) -> i64 {\n+        0\n+    }\n     fn st_blksize(&self) -> u64 {\n         self.as_inner().as_inner().st_blksize as u64\n     }"}, {"sha": "cb41ddfe2a9bf4d916441ec8632da981d3b933bf", "filename": "library/std/src/os/vxworks/raw.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/71bb1dc2a09ffc7334f07248669a42faf2a784eb/library%2Fstd%2Fsrc%2Fos%2Fvxworks%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bb1dc2a09ffc7334f07248669a42faf2a784eb/library%2Fstd%2Fsrc%2Fos%2Fvxworks%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fvxworks%2Fraw.rs?ref=71bb1dc2a09ffc7334f07248669a42faf2a784eb", "patch": "@@ -5,3 +5,6 @@ use crate::os::raw::c_ulong;\n \n #[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n pub type pthread_t = c_ulong;\n+\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub use libc::{blkcnt_t, blksize_t, dev_t, ino_t, mode_t, nlink_t, off_t, time_t};"}, {"sha": "66bbc1c585413906067b8372804ffd948f978829", "filename": "library/std/src/sys/unix/ext/fs.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/71bb1dc2a09ffc7334f07248669a42faf2a784eb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bb1dc2a09ffc7334f07248669a42faf2a784eb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Ffs.rs?ref=71bb1dc2a09ffc7334f07248669a42faf2a784eb", "patch": "@@ -650,6 +650,9 @@ pub trait MetadataExt {\n     /// ```\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n     fn blocks(&self) -> u64;\n+    #[cfg(target_os = \"vxworks\")]\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn attrib(&self) -> u8;\n }\n \n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n@@ -702,6 +705,10 @@ impl MetadataExt for fs::Metadata {\n     fn blocks(&self) -> u64 {\n         self.st_blocks()\n     }\n+    #[cfg(target_os = \"vxworks\")]\n+    fn attrib(&self) -> u8 {\n+        self.st_attrib()\n+    }\n }\n \n /// Unix-specific extensions for [`fs::FileType`]."}, {"sha": "d3a279a23553ee551d7812a86094cad051c441e1", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71bb1dc2a09ffc7334f07248669a42faf2a784eb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bb1dc2a09ffc7334f07248669a42faf2a784eb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=71bb1dc2a09ffc7334f07248669a42faf2a784eb", "patch": "@@ -200,7 +200,8 @@ impl FileDesc {\n         target_os = \"l4re\",\n         target_os = \"linux\",\n         target_os = \"haiku\",\n-        target_os = \"redox\"\n+        target_os = \"redox\",\n+        target_os = \"vxworks\"\n     )))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {\n@@ -217,7 +218,8 @@ impl FileDesc {\n         target_os = \"l4re\",\n         target_os = \"linux\",\n         target_os = \"haiku\",\n-        target_os = \"redox\"\n+        target_os = \"redox\",\n+        target_os = \"vxworks\"\n     ))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {"}, {"sha": "819e8ef18415b3d1fb1aa6934f165153b468dae9", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 49, "deletions": 7, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/71bb1dc2a09ffc7334f07248669a42faf2a784eb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bb1dc2a09ffc7334f07248669a42faf2a784eb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=71bb1dc2a09ffc7334f07248669a42faf2a784eb", "patch": "@@ -297,20 +297,38 @@ impl FileAttr {\n \n #[cfg(not(target_os = \"netbsd\"))]\n impl FileAttr {\n+    #[cfg(not(target_os = \"vxworks\"))]\n     pub fn modified(&self) -> io::Result<SystemTime> {\n         Ok(SystemTime::from(libc::timespec {\n             tv_sec: self.stat.st_mtime as libc::time_t,\n             tv_nsec: self.stat.st_mtime_nsec as _,\n         }))\n     }\n \n+    #[cfg(target_os = \"vxworks\")]\n+    pub fn modified(&self) -> io::Result<SystemTime> {\n+        Ok(SystemTime::from(libc::timespec {\n+            tv_sec: self.stat.st_mtime as libc::time_t,\n+            tv_nsec: 0,\n+        }))\n+    }\n+\n+    #[cfg(not(target_os = \"vxworks\"))]\n     pub fn accessed(&self) -> io::Result<SystemTime> {\n         Ok(SystemTime::from(libc::timespec {\n             tv_sec: self.stat.st_atime as libc::time_t,\n             tv_nsec: self.stat.st_atime_nsec as _,\n         }))\n     }\n \n+    #[cfg(target_os = \"vxworks\")]\n+    pub fn accessed(&self) -> io::Result<SystemTime> {\n+        Ok(SystemTime::from(libc::timespec {\n+            tv_sec: self.stat.st_atime as libc::time_t,\n+            tv_nsec: 0,\n+        }))\n+    }\n+\n     #[cfg(any(\n         target_os = \"freebsd\",\n         target_os = \"openbsd\",\n@@ -535,12 +553,22 @@ impl DirEntry {\n         lstat(&self.path())\n     }\n \n-    #[cfg(any(target_os = \"solaris\", target_os = \"illumos\", target_os = \"haiku\"))]\n+    #[cfg(any(\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"haiku\",\n+        target_os = \"vxworks\"\n+    ))]\n     pub fn file_type(&self) -> io::Result<FileType> {\n         lstat(&self.path()).map(|m| m.file_type())\n     }\n \n-    #[cfg(not(any(target_os = \"solaris\", target_os = \"illumos\", target_os = \"haiku\")))]\n+    #[cfg(not(any(\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"haiku\",\n+        target_os = \"vxworks\"\n+    )))]\n     pub fn file_type(&self) -> io::Result<FileType> {\n         match self.entry.d_type {\n             libc::DT_CHR => Ok(FileType { mode: libc::S_IFCHR }),\n@@ -565,7 +593,8 @@ impl DirEntry {\n         target_os = \"haiku\",\n         target_os = \"l4re\",\n         target_os = \"fuchsia\",\n-        target_os = \"redox\"\n+        target_os = \"redox\",\n+        target_os = \"vxworks\"\n     ))]\n     pub fn ino(&self) -> u64 {\n         self.entry.d_ino as u64\n@@ -603,7 +632,8 @@ impl DirEntry {\n         target_os = \"linux\",\n         target_os = \"emscripten\",\n         target_os = \"l4re\",\n-        target_os = \"haiku\"\n+        target_os = \"haiku\",\n+        target_os = \"vxworks\"\n     ))]\n     fn name_bytes(&self) -> &[u8] {\n         unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()).to_bytes() }\n@@ -901,13 +931,25 @@ impl fmt::Debug for File {\n             Some(PathBuf::from(OsString::from_vec(buf)))\n         }\n \n-        #[cfg(not(any(target_os = \"linux\", target_os = \"macos\")))]\n+        #[cfg(target_os = \"vxworks\")]\n+        fn get_path(fd: c_int) -> Option<PathBuf> {\n+            let mut buf = vec![0; libc::PATH_MAX as usize];\n+            let n = unsafe { libc::ioctl(fd, libc::FIOGETNAME, buf.as_ptr()) };\n+            if n == -1 {\n+                return None;\n+            }\n+            let l = buf.iter().position(|&c| c == 0).unwrap();\n+            buf.truncate(l as usize);\n+            Some(PathBuf::from(OsString::from_vec(buf)))\n+        }\n+\n+        #[cfg(not(any(target_os = \"linux\", target_os = \"macos\", target_os = \"vxworks\")))]\n         fn get_path(_fd: c_int) -> Option<PathBuf> {\n             // FIXME(#24570): implement this for other Unix platforms\n             None\n         }\n \n-        #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n+        #[cfg(any(target_os = \"linux\", target_os = \"macos\", target_os = \"vxworks\"))]\n         fn get_mode(fd: c_int) -> Option<(bool, bool)> {\n             let mode = unsafe { libc::fcntl(fd, libc::F_GETFL) };\n             if mode == -1 {\n@@ -921,7 +963,7 @@ impl fmt::Debug for File {\n             }\n         }\n \n-        #[cfg(not(any(target_os = \"linux\", target_os = \"macos\")))]\n+        #[cfg(not(any(target_os = \"linux\", target_os = \"macos\", target_os = \"vxworks\")))]\n         fn get_mode(_fd: c_int) -> Option<(bool, bool)> {\n             // FIXME(#24570): implement this for other Unix platforms\n             None"}, {"sha": "d58468ad539ff92ca0a9d4d96fd260c01d7329b2", "filename": "library/std/src/sys/vxworks/fd.rs", "status": "removed", "additions": 0, "deletions": 201, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/3f196dc137c378e727c6626e5a38b37e15fbbf70/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f196dc137c378e727c6626e5a38b37e15fbbf70/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Ffd.rs?ref=3f196dc137c378e727c6626e5a38b37e15fbbf70", "patch": "@@ -1,201 +0,0 @@\n-#![unstable(reason = \"not public\", issue = \"none\", feature = \"fd\")]\n-\n-use crate::cmp;\n-use crate::io::{self, Initializer, IoSlice, IoSliceMut, Read};\n-use crate::mem;\n-use crate::sys::cvt;\n-use crate::sys_common::AsInner;\n-\n-use libc::{self, c_int, c_void, ssize_t};\n-\n-#[derive(Debug)]\n-pub struct FileDesc {\n-    fd: c_int,\n-}\n-\n-// The maximum read limit on most POSIX-like systems is `SSIZE_MAX`,\n-// with the man page quoting that if the count of bytes to read is\n-// greater than `SSIZE_MAX` the result is \"unspecified\".\n-const READ_LIMIT: usize = ssize_t::MAX as usize;\n-\n-impl FileDesc {\n-    pub fn new(fd: c_int) -> FileDesc {\n-        FileDesc { fd: fd }\n-    }\n-\n-    pub fn raw(&self) -> c_int {\n-        self.fd\n-    }\n-\n-    /// Extracts the actual file descriptor without closing it.\n-    pub fn into_raw(self) -> c_int {\n-        let fd = self.fd;\n-        mem::forget(self);\n-        fd\n-    }\n-\n-    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        let ret = cvt(unsafe {\n-            libc::read(self.fd, buf.as_mut_ptr() as *mut c_void, cmp::min(buf.len(), READ_LIMIT))\n-        })?;\n-        Ok(ret as usize)\n-    }\n-\n-    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        let ret = cvt(unsafe {\n-            libc::readv(\n-                self.fd,\n-                bufs.as_ptr() as *const libc::iovec,\n-                cmp::min(bufs.len(), c_int::MAX as usize) as c_int,\n-            )\n-        })?;\n-        Ok(ret as usize)\n-    }\n-\n-    #[inline]\n-    pub fn is_read_vectored(&self) -> bool {\n-        true\n-    }\n-\n-    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n-        let mut me = self;\n-        (&mut me).read_to_end(buf)\n-    }\n-\n-    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n-        unsafe fn cvt_pread(\n-            fd: c_int,\n-            buf: *mut c_void,\n-            count: usize,\n-            offset: i64,\n-        ) -> io::Result<isize> {\n-            use libc::pread;\n-            cvt(pread(fd, buf, count, offset))\n-        }\n-\n-        unsafe {\n-            cvt_pread(\n-                self.fd,\n-                buf.as_mut_ptr() as *mut c_void,\n-                cmp::min(buf.len(), READ_LIMIT),\n-                offset as i64,\n-            )\n-            .map(|n| n as usize)\n-        }\n-    }\n-\n-    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        let ret = cvt(unsafe {\n-            libc::write(self.fd, buf.as_ptr() as *const c_void, cmp::min(buf.len(), READ_LIMIT))\n-        })?;\n-        Ok(ret as usize)\n-    }\n-\n-    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        let ret = cvt(unsafe {\n-            libc::writev(\n-                self.fd,\n-                bufs.as_ptr() as *const libc::iovec,\n-                cmp::min(bufs.len(), c_int::MAX as usize) as c_int,\n-            )\n-        })?;\n-        Ok(ret as usize)\n-    }\n-\n-    #[inline]\n-    pub fn is_write_vectored(&self) -> bool {\n-        true\n-    }\n-\n-    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n-        unsafe fn cvt_pwrite(\n-            fd: c_int,\n-            buf: *const c_void,\n-            count: usize,\n-            offset: i64,\n-        ) -> io::Result<isize> {\n-            use libc::pwrite;\n-            cvt(pwrite(fd, buf, count, offset))\n-        }\n-\n-        unsafe {\n-            cvt_pwrite(\n-                self.fd,\n-                buf.as_ptr() as *const c_void,\n-                cmp::min(buf.len(), READ_LIMIT),\n-                offset as i64,\n-            )\n-            .map(|n| n as usize)\n-        }\n-    }\n-\n-    pub fn get_cloexec(&self) -> io::Result<bool> {\n-        unsafe { Ok((cvt(libc::fcntl(self.fd, libc::F_GETFD))? & libc::FD_CLOEXEC) != 0) }\n-    }\n-\n-    pub fn set_cloexec(&self) -> io::Result<()> {\n-        unsafe {\n-            let previous = cvt(libc::fcntl(self.fd, libc::F_GETFD))?;\n-            let new = previous | libc::FD_CLOEXEC;\n-            if new != previous {\n-                cvt(libc::fcntl(self.fd, libc::F_SETFD, new))?;\n-            }\n-            Ok(())\n-        }\n-    }\n-\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        unsafe {\n-            let v = nonblocking as c_int;\n-            cvt(libc::ioctl(self.fd, libc::FIONBIO, &v))?;\n-            Ok(())\n-        }\n-    }\n-\n-    // refer to pxPipeDrv library documentation.\n-    // VxWorks uses fcntl to set O_NONBLOCK to the pipes\n-    pub fn set_nonblocking_pipe(&self, nonblocking: bool) -> io::Result<()> {\n-        unsafe {\n-            let mut flags = cvt(libc::fcntl(self.fd, libc::F_GETFL, 0))?;\n-            flags = if nonblocking { flags | libc::O_NONBLOCK } else { flags & !libc::O_NONBLOCK };\n-            cvt(libc::fcntl(self.fd, libc::F_SETFL, flags))?;\n-            Ok(())\n-        }\n-    }\n-\n-    pub fn duplicate(&self) -> io::Result<FileDesc> {\n-        let fd = self.raw();\n-        match cvt(unsafe { libc::fcntl(fd, libc::F_DUPFD_CLOEXEC, 0) }) {\n-            Ok(newfd) => Ok(FileDesc::new(newfd)),\n-            Err(e) => return Err(e),\n-        }\n-    }\n-}\n-\n-impl<'a> Read for &'a FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        (**self).read(buf)\n-    }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n-}\n-\n-impl AsInner<c_int> for FileDesc {\n-    fn as_inner(&self) -> &c_int {\n-        &self.fd\n-    }\n-}\n-\n-impl Drop for FileDesc {\n-    fn drop(&mut self) {\n-        // Note that errors are ignored when closing a file descriptor. The\n-        // reason for this is that if an error occurs we don't actually know if\n-        // the file descriptor was closed or not, and if we retried (for\n-        // something like EINTR), we might close another valid file descriptor\n-        // (opened after we closed ours.\n-        let _ = unsafe { libc::close(self.fd) };\n-    }\n-}"}, {"sha": "cb761af1a25c2d4ea123d3c2f73b35b4d1637927", "filename": "library/std/src/sys/vxworks/fs.rs", "status": "removed", "additions": 0, "deletions": 624, "changes": 624, "blob_url": "https://github.com/rust-lang/rust/blob/3f196dc137c378e727c6626e5a38b37e15fbbf70/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f196dc137c378e727c6626e5a38b37e15fbbf70/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Ffs.rs?ref=3f196dc137c378e727c6626e5a38b37e15fbbf70", "patch": "@@ -1,624 +0,0 @@\n-// copies from linuxx\n-use crate::ffi::{CStr, CString, OsStr, OsString};\n-use crate::fmt;\n-use crate::io::{self, Error, ErrorKind, IoSlice, IoSliceMut, SeekFrom};\n-use crate::mem;\n-use crate::path::{Path, PathBuf};\n-use crate::ptr;\n-use crate::sync::Arc;\n-use crate::sys::fd::FileDesc;\n-use crate::sys::time::SystemTime;\n-use crate::sys::vxworks::ext::ffi::OsStrExt;\n-use crate::sys::vxworks::ext::ffi::OsStringExt;\n-use crate::sys::{cvt, cvt_r};\n-use crate::sys_common::{AsInner, FromInner};\n-use libc::{self, c_int, mode_t, off_t, stat64};\n-use libc::{dirent, ftruncate, lseek, open, readdir_r as readdir64_r};\n-pub struct File(FileDesc);\n-\n-#[derive(Clone)]\n-pub struct FileAttr {\n-    stat: stat64,\n-}\n-\n-// all DirEntry's will have a reference to this struct\n-struct InnerReadDir {\n-    dirp: Dir,\n-    root: PathBuf,\n-}\n-\n-pub struct ReadDir {\n-    inner: Arc<InnerReadDir>,\n-    end_of_stream: bool,\n-}\n-\n-struct Dir(*mut libc::DIR);\n-\n-unsafe impl Send for Dir {}\n-unsafe impl Sync for Dir {}\n-\n-pub struct DirEntry {\n-    entry: dirent,\n-    dir: Arc<InnerReadDir>,\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct OpenOptions {\n-    // generic\n-    read: bool,\n-    write: bool,\n-    append: bool,\n-    truncate: bool,\n-    create: bool,\n-    create_new: bool,\n-    // system-specific\n-    custom_flags: i32,\n-    mode: mode_t,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct FilePermissions {\n-    mode: mode_t,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub struct FileType {\n-    mode: mode_t,\n-}\n-\n-#[derive(Debug)]\n-pub struct DirBuilder {\n-    mode: mode_t,\n-}\n-\n-impl FileAttr {\n-    pub fn size(&self) -> u64 {\n-        self.stat.st_size as u64\n-    }\n-    pub fn perm(&self) -> FilePermissions {\n-        FilePermissions { mode: (self.stat.st_mode as mode_t) }\n-    }\n-\n-    pub fn file_type(&self) -> FileType {\n-        FileType { mode: self.stat.st_mode as mode_t }\n-    }\n-\n-    pub fn modified(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from(libc::timespec {\n-            tv_sec: self.stat.st_mtime as libc::time_t,\n-            tv_nsec: 0, // hack 2.0;\n-        }))\n-    }\n-\n-    pub fn accessed(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from(libc::timespec {\n-            tv_sec: self.stat.st_atime as libc::time_t,\n-            tv_nsec: 0, // hack - a proper fix would be better\n-        }))\n-    }\n-\n-    pub fn created(&self) -> io::Result<SystemTime> {\n-        Err(io::Error::new(\n-            io::ErrorKind::Other,\n-            \"creation time is not available on this platform currently\",\n-        ))\n-    }\n-}\n-\n-impl AsInner<stat64> for FileAttr {\n-    fn as_inner(&self) -> &stat64 {\n-        &self.stat\n-    }\n-}\n-\n-impl FilePermissions {\n-    pub fn readonly(&self) -> bool {\n-        // check if any class (owner, group, others) has write permission\n-        self.mode & 0o222 == 0\n-    }\n-\n-    pub fn set_readonly(&mut self, readonly: bool) {\n-        if readonly {\n-            // remove write permission for all classes; equivalent to `chmod a-w <file>`\n-            self.mode &= !0o222;\n-        } else {\n-            // add write permission for all classes; equivalent to `chmod a+w <file>`\n-            self.mode |= 0o222;\n-        }\n-    }\n-    pub fn mode(&self) -> u32 {\n-        self.mode as u32\n-    }\n-}\n-\n-impl FileType {\n-    pub fn is_dir(&self) -> bool {\n-        self.is(libc::S_IFDIR)\n-    }\n-    pub fn is_file(&self) -> bool {\n-        self.is(libc::S_IFREG)\n-    }\n-    pub fn is_symlink(&self) -> bool {\n-        self.is(libc::S_IFLNK)\n-    }\n-\n-    pub fn is(&self, mode: mode_t) -> bool {\n-        self.mode & libc::S_IFMT == mode\n-    }\n-}\n-\n-impl FromInner<u32> for FilePermissions {\n-    fn from_inner(mode: u32) -> FilePermissions {\n-        FilePermissions { mode: mode as mode_t }\n-    }\n-}\n-\n-impl fmt::Debug for ReadDir {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // This will only be called from std::fs::ReadDir, which will add a \"ReadDir()\" frame.\n-        // Thus the result will be e g 'ReadDir(\"/home\")'\n-        fmt::Debug::fmt(&*self.inner.root, f)\n-    }\n-}\n-\n-impl Iterator for ReadDir {\n-    type Item = io::Result<DirEntry>;\n-    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n-        if self.end_of_stream {\n-            return None;\n-        }\n-\n-        unsafe {\n-            let mut ret = DirEntry { entry: mem::zeroed(), dir: Arc::clone(&self.inner) };\n-            let mut entry_ptr = ptr::null_mut();\n-            loop {\n-                if readdir64_r(self.inner.dirp.0, &mut ret.entry, &mut entry_ptr) != 0 {\n-                    if entry_ptr.is_null() {\n-                        // We encountered an error (which will be returned in this iteration), but\n-                        // we also reached the end of the directory stream. The `end_of_stream`\n-                        // flag is enabled to make sure that we return `None` in the next iteration\n-                        // (instead of looping forever)\n-                        self.end_of_stream = true;\n-                    }\n-                    return Some(Err(Error::last_os_error()));\n-                }\n-                if entry_ptr.is_null() {\n-                    return None;\n-                }\n-                if ret.name_bytes() != b\".\" && ret.name_bytes() != b\"..\" {\n-                    return Some(Ok(ret));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl Drop for Dir {\n-    fn drop(&mut self) {\n-        let r = unsafe { libc::closedir(self.0) };\n-        debug_assert_eq!(r, 0);\n-    }\n-}\n-\n-impl DirEntry {\n-    pub fn path(&self) -> PathBuf {\n-        use crate::sys::vxworks::ext::ffi::OsStrExt;\n-        self.dir.root.join(OsStr::from_bytes(self.name_bytes()))\n-    }\n-\n-    pub fn file_name(&self) -> OsString {\n-        OsStr::from_bytes(self.name_bytes()).to_os_string()\n-    }\n-\n-    pub fn metadata(&self) -> io::Result<FileAttr> {\n-        lstat(&self.path())\n-    }\n-\n-    pub fn file_type(&self) -> io::Result<FileType> {\n-        lstat(&self.path()).map(|m| m.file_type())\n-    }\n-\n-    pub fn ino(&self) -> u64 {\n-        self.entry.d_ino as u64\n-    }\n-\n-    fn name_bytes(&self) -> &[u8] {\n-        unsafe {\n-            //&*self.name\n-            CStr::from_ptr(self.entry.d_name.as_ptr()).to_bytes()\n-        }\n-    }\n-}\n-\n-impl OpenOptions {\n-    pub fn new() -> OpenOptions {\n-        OpenOptions {\n-            // generic\n-            read: false,\n-            write: false,\n-            append: false,\n-            truncate: false,\n-            create: false,\n-            create_new: false,\n-            // system-specific\n-            custom_flags: 0,\n-            mode: 0o666,\n-        }\n-    }\n-\n-    pub fn read(&mut self, read: bool) {\n-        self.read = read;\n-    }\n-    pub fn write(&mut self, write: bool) {\n-        self.write = write;\n-    }\n-    pub fn append(&mut self, append: bool) {\n-        self.append = append;\n-    }\n-    pub fn truncate(&mut self, truncate: bool) {\n-        self.truncate = truncate;\n-    }\n-    pub fn create(&mut self, create: bool) {\n-        self.create = create;\n-    }\n-    pub fn create_new(&mut self, create_new: bool) {\n-        self.create_new = create_new;\n-    }\n-    pub fn mode(&mut self, mode: u32) {\n-        self.mode = mode as mode_t;\n-    }\n-\n-    fn get_access_mode(&self) -> io::Result<c_int> {\n-        match (self.read, self.write, self.append) {\n-            (true, false, false) => Ok(libc::O_RDONLY),\n-            (false, true, false) => Ok(libc::O_WRONLY),\n-            (true, true, false) => Ok(libc::O_RDWR),\n-            (false, _, true) => Ok(libc::O_WRONLY | libc::O_APPEND),\n-            (true, _, true) => Ok(libc::O_RDWR | libc::O_APPEND),\n-            (false, false, false) => Err(Error::from_raw_os_error(libc::EINVAL)),\n-        }\n-    }\n-\n-    fn get_creation_mode(&self) -> io::Result<c_int> {\n-        match (self.write, self.append) {\n-            (true, false) => {}\n-            (false, false) => {\n-                if self.truncate || self.create || self.create_new {\n-                    return Err(Error::from_raw_os_error(libc::EINVAL));\n-                }\n-            }\n-            (_, true) => {\n-                if self.truncate && !self.create_new {\n-                    return Err(Error::from_raw_os_error(libc::EINVAL));\n-                }\n-            }\n-        }\n-\n-        Ok(match (self.create, self.truncate, self.create_new) {\n-            (false, false, false) => 0,\n-            (true, false, false) => libc::O_CREAT,\n-            (false, true, false) => libc::O_TRUNC,\n-            (true, true, false) => libc::O_CREAT | libc::O_TRUNC,\n-            (_, _, true) => libc::O_CREAT | libc::O_EXCL,\n-        })\n-    }\n-}\n-\n-impl File {\n-    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n-        let path = cstr(path)?;\n-        File::open_c(&path, opts)\n-    }\n-\n-    pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {\n-        let flags = libc::O_CLOEXEC\n-            | opts.get_access_mode()?\n-            | opts.get_creation_mode()?\n-            | (opts.custom_flags as c_int & !libc::O_ACCMODE);\n-        let fd = cvt_r(|| unsafe { open(path.as_ptr(), flags, opts.mode as c_int) })?;\n-        Ok(File(FileDesc::new(fd)))\n-    }\n-\n-    pub fn file_attr(&self) -> io::Result<FileAttr> {\n-        let mut stat: stat64 = unsafe { mem::zeroed() };\n-        cvt(unsafe { ::libc::fstat(self.0.raw(), &mut stat) })?;\n-        Ok(FileAttr { stat: stat })\n-    }\n-\n-    pub fn fsync(&self) -> io::Result<()> {\n-        cvt_r(|| unsafe { libc::fsync(self.0.raw()) })?;\n-        Ok(())\n-    }\n-\n-    pub fn datasync(&self) -> io::Result<()> {\n-        cvt_r(|| unsafe { os_datasync(self.0.raw()) })?;\n-        return Ok(());\n-        unsafe fn os_datasync(fd: c_int) -> c_int {\n-            libc::fsync(fd)\n-        } //not supported\n-    }\n-\n-    pub fn truncate(&self, size: u64) -> io::Result<()> {\n-        return cvt_r(|| unsafe { ftruncate(self.0.raw(), size as off_t) }).map(drop);\n-    }\n-\n-    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        self.0.read_vectored(bufs)\n-    }\n-\n-    #[inline]\n-    pub fn is_read_vectored(&self) -> bool {\n-        self.0.is_read_vectored()\n-    }\n-\n-    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n-        self.0.read_at(buf, offset)\n-    }\n-\n-    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        self.0.write_vectored(bufs)\n-    }\n-\n-    #[inline]\n-    pub fn is_write_vectored(&self) -> bool {\n-        self.0.is_write_vectored()\n-    }\n-\n-    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n-        self.0.write_at(buf, offset)\n-    }\n-\n-    pub fn flush(&self) -> io::Result<()> {\n-        Ok(())\n-    }\n-\n-    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n-        let (whence, pos) = match pos {\n-            // Casting to `i64` is fine, too large values will end up as\n-            // negative which will cause an error in `\"lseek64\"`.\n-            SeekFrom::Start(off) => (libc::SEEK_SET, off as i64),\n-            SeekFrom::End(off) => (libc::SEEK_END, off),\n-            SeekFrom::Current(off) => (libc::SEEK_CUR, off),\n-        };\n-        let n = cvt(unsafe { lseek(self.0.raw(), pos, whence) })?;\n-        Ok(n as u64)\n-    }\n-\n-    pub fn duplicate(&self) -> io::Result<File> {\n-        self.0.duplicate().map(File)\n-    }\n-\n-    pub fn fd(&self) -> &FileDesc {\n-        &self.0\n-    }\n-\n-    pub fn into_fd(self) -> FileDesc {\n-        self.0\n-    }\n-\n-    pub fn set_permissions(&self, perm: FilePermissions) -> io::Result<()> {\n-        cvt_r(|| unsafe { libc::fchmod(self.0.raw(), perm.mode) })?;\n-        Ok(())\n-    }\n-\n-    pub fn diverge(&self) -> ! {\n-        panic!()\n-    }\n-}\n-\n-impl DirBuilder {\n-    pub fn new() -> DirBuilder {\n-        DirBuilder { mode: 0o777 }\n-    }\n-\n-    pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n-        let p = cstr(p)?;\n-        cvt(unsafe { libc::mkdir(p.as_ptr(), self.mode) })?;\n-        Ok(())\n-    }\n-\n-    pub fn set_mode(&mut self, mode: u32) {\n-        self.mode = mode as mode_t;\n-    }\n-}\n-\n-fn cstr(path: &Path) -> io::Result<CString> {\n-    use crate::sys::vxworks::ext::ffi::OsStrExt;\n-    Ok(CString::new(path.as_os_str().as_bytes())?)\n-}\n-\n-impl FromInner<c_int> for File {\n-    fn from_inner(fd: c_int) -> File {\n-        File(FileDesc::new(fd))\n-    }\n-}\n-\n-impl fmt::Debug for File {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fn get_path(fd: c_int) -> Option<PathBuf> {\n-            let mut buf = vec![0; libc::PATH_MAX as usize];\n-            let n = unsafe { libc::ioctl(fd, libc::FIOGETNAME, buf.as_ptr()) };\n-            if n == -1 {\n-                return None;\n-            }\n-            let l = buf.iter().position(|&c| c == 0).unwrap();\n-            buf.truncate(l as usize);\n-            Some(PathBuf::from(OsString::from_vec(buf)))\n-        }\n-        fn get_mode(fd: c_int) -> Option<(bool, bool)> {\n-            let mode = unsafe { libc::fcntl(fd, libc::F_GETFL) };\n-            if mode == -1 {\n-                return None;\n-            }\n-            match mode & libc::O_ACCMODE {\n-                libc::O_RDONLY => Some((true, false)),\n-                libc::O_RDWR => Some((true, true)),\n-                libc::O_WRONLY => Some((false, true)),\n-                _ => None,\n-            }\n-        }\n-\n-        let fd = self.0.raw();\n-        let mut b = f.debug_struct(\"File\");\n-        b.field(\"fd\", &fd);\n-        if let Some(path) = get_path(fd) {\n-            b.field(\"path\", &path);\n-        }\n-        if let Some((read, write)) = get_mode(fd) {\n-            b.field(\"read\", &read).field(\"write\", &write);\n-        }\n-        b.finish()\n-    }\n-}\n-\n-pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n-    let root = p.to_path_buf();\n-    let p = cstr(p)?;\n-    unsafe {\n-        let ptr = libc::opendir(p.as_ptr());\n-        if ptr.is_null() {\n-            Err(Error::last_os_error())\n-        } else {\n-            let inner = InnerReadDir { dirp: Dir(ptr), root };\n-            Ok(ReadDir { inner: Arc::new(inner), end_of_stream: false })\n-        }\n-    }\n-}\n-\n-pub fn unlink(p: &Path) -> io::Result<()> {\n-    let p = cstr(p)?;\n-    cvt(unsafe { libc::unlink(p.as_ptr()) })?;\n-    Ok(())\n-}\n-\n-pub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n-    let old = cstr(old)?;\n-    let new = cstr(new)?;\n-    cvt(unsafe { libc::rename(old.as_ptr(), new.as_ptr()) })?;\n-    Ok(())\n-}\n-\n-pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {\n-    let p = cstr(p)?;\n-    cvt_r(|| unsafe { libc::chmod(p.as_ptr(), perm.mode) })?;\n-    Ok(())\n-}\n-\n-pub fn rmdir(p: &Path) -> io::Result<()> {\n-    let p = cstr(p)?;\n-    cvt(unsafe { libc::rmdir(p.as_ptr()) })?;\n-    Ok(())\n-}\n-\n-pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n-    let filetype = lstat(path)?.file_type();\n-    if filetype.is_symlink() { unlink(path) } else { remove_dir_all_recursive(path) }\n-}\n-\n-fn remove_dir_all_recursive(path: &Path) -> io::Result<()> {\n-    for child in readdir(path)? {\n-        let child = child?;\n-        if child.file_type()?.is_dir() {\n-            remove_dir_all_recursive(&child.path())?;\n-        } else {\n-            unlink(&child.path())?;\n-        }\n-    }\n-    rmdir(path)\n-}\n-\n-pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n-    let c_path = cstr(p)?;\n-    let p = c_path.as_ptr();\n-\n-    let mut buf = Vec::with_capacity(256);\n-\n-    loop {\n-        let buf_read =\n-            cvt(unsafe { libc::readlink(p, buf.as_mut_ptr() as *mut _, buf.capacity()) })? as usize;\n-\n-        unsafe {\n-            buf.set_len(buf_read);\n-        }\n-\n-        if buf_read != buf.capacity() {\n-            buf.shrink_to_fit();\n-\n-            return Ok(PathBuf::from(OsString::from_vec(buf)));\n-        }\n-\n-        // Trigger the internal buffer resizing logic of `Vec` by requiring\n-        // more space than the current capacity. The length is guaranteed to be\n-        // the same as the capacity due to the if statement above.\n-        buf.reserve(1);\n-    }\n-}\n-\n-pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n-    let src = cstr(src)?;\n-    let dst = cstr(dst)?;\n-    cvt(unsafe { libc::symlink(src.as_ptr(), dst.as_ptr()) })?;\n-    Ok(())\n-}\n-\n-pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n-    let src = cstr(src)?;\n-    let dst = cstr(dst)?;\n-    cvt(unsafe { libc::link(src.as_ptr(), dst.as_ptr()) })?;\n-    Ok(())\n-}\n-\n-pub fn stat(p: &Path) -> io::Result<FileAttr> {\n-    let p = cstr(p)?;\n-    let mut stat: stat64 = unsafe { mem::zeroed() };\n-    cvt(unsafe { libc::stat(p.as_ptr(), &mut stat as *mut _ as *mut _) })?;\n-    Ok(FileAttr { stat })\n-}\n-\n-pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n-    let p = cstr(p)?;\n-    let mut stat: stat64 = unsafe { mem::zeroed() };\n-    cvt(unsafe { ::libc::lstat(p.as_ptr(), &mut stat as *mut _ as *mut _) })?;\n-    Ok(FileAttr { stat })\n-}\n-\n-pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n-    use crate::sys::vxworks::ext::ffi::OsStrExt;\n-    let path = CString::new(p.as_os_str().as_bytes())?;\n-    let buf;\n-    unsafe {\n-        let r = libc::realpath(path.as_ptr(), ptr::null_mut());\n-        if r.is_null() {\n-            return Err(io::Error::last_os_error());\n-        }\n-        buf = CStr::from_ptr(r).to_bytes().to_vec();\n-        libc::free(r as *mut _);\n-    }\n-    Ok(PathBuf::from(OsString::from_vec(buf)))\n-}\n-\n-pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n-    use crate::fs::File;\n-    if !from.is_file() {\n-        return Err(Error::new(\n-            ErrorKind::InvalidInput,\n-            \"the source path is not an existing regular file\",\n-        ));\n-    }\n-\n-    let mut reader = File::open(from)?;\n-    let mut writer = File::create(to)?;\n-    let perm = reader.metadata()?.permissions();\n-\n-    let ret = io::copy(&mut reader, &mut writer)?;\n-    writer.set_permissions(perm)?;\n-    Ok(ret)\n-}"}, {"sha": "0f68ebf8da9cc43577482eb6f62dad433e701007", "filename": "library/std/src/sys/vxworks/io.rs", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/3f196dc137c378e727c6626e5a38b37e15fbbf70/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f196dc137c378e727c6626e5a38b37e15fbbf70/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fio.rs?ref=3f196dc137c378e727c6626e5a38b37e15fbbf70", "patch": "@@ -1,75 +0,0 @@\n-use crate::marker::PhantomData;\n-use crate::slice;\n-\n-use libc::{c_void, iovec};\n-\n-#[derive(Copy, Clone)]\n-#[repr(transparent)]\n-pub struct IoSlice<'a> {\n-    vec: iovec,\n-    _p: PhantomData<&'a [u8]>,\n-}\n-\n-impl<'a> IoSlice<'a> {\n-    #[inline]\n-    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n-        IoSlice {\n-            vec: iovec { iov_base: buf.as_ptr() as *mut u8 as *mut c_void, iov_len: buf.len() },\n-            _p: PhantomData,\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn advance(&mut self, n: usize) {\n-        if self.vec.iov_len < n {\n-            panic!(\"advancing IoSlice beyond its length\");\n-        }\n-\n-        unsafe {\n-            self.vec.iov_len -= n;\n-            self.vec.iov_base = self.vec.iov_base.add(n);\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn as_slice(&self) -> &[u8] {\n-        unsafe { slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n-    }\n-}\n-\n-pub struct IoSliceMut<'a> {\n-    vec: iovec,\n-    _p: PhantomData<&'a mut [u8]>,\n-}\n-\n-impl<'a> IoSliceMut<'a> {\n-    #[inline]\n-    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n-        IoSliceMut {\n-            vec: iovec { iov_base: buf.as_mut_ptr() as *mut c_void, iov_len: buf.len() },\n-            _p: PhantomData,\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn advance(&mut self, n: usize) {\n-        if self.vec.iov_len < n {\n-            panic!(\"advancing IoSliceMut beyond its length\");\n-        }\n-\n-        unsafe {\n-            self.vec.iov_len -= n;\n-            self.vec.iov_base = self.vec.iov_base.add(n);\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn as_slice(&self) -> &[u8] {\n-        unsafe { slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n-    }\n-\n-    #[inline]\n-    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n-        unsafe { slice::from_raw_parts_mut(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n-    }\n-}"}, {"sha": "fb90f4b0c1acbc570450777277f9400297f826ea", "filename": "library/std/src/sys/vxworks/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/71bb1dc2a09ffc7334f07248669a42faf2a784eb/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bb1dc2a09ffc7334f07248669a42faf2a784eb/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs?ref=71bb1dc2a09ffc7334f07248669a42faf2a784eb", "patch": "@@ -22,8 +22,11 @@ pub mod condvar;\n pub mod env;\n #[path = \"../unix/ext/mod.rs\"]\n pub mod ext;\n+#[path = \"../unix/fd.rs\"]\n pub mod fd;\n+#[path = \"../unix/fs.rs\"]\n pub mod fs;\n+#[path = \"../unix/io.rs\"]\n pub mod io;\n #[path = \"../unix/memchr.rs\"]\n pub mod memchr;"}]}