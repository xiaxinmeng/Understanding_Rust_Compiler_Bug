{"sha": "0204b9535731cbaba1689b6d6ef44a93aef2dae3", "node_id": "C_kwDOAAsO6NoAKDAyMDRiOTUzNTczMWNiYWJhMTY4OWI2ZDZlZjQ0YTkzYWVmMmRhZTM", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-01-29T14:36:46Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-28T16:48:26Z"}, "message": "Lint `explicit_auto_deref` immediately after `needless_borrow`", "tree": {"sha": "caeed18fae243acf517b880bf042b6f367f5eb36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/caeed18fae243acf517b880bf042b6f367f5eb36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0204b9535731cbaba1689b6d6ef44a93aef2dae3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0204b9535731cbaba1689b6d6ef44a93aef2dae3", "html_url": "https://github.com/rust-lang/rust/commit/0204b9535731cbaba1689b6d6ef44a93aef2dae3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0204b9535731cbaba1689b6d6ef44a93aef2dae3/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65bc6cb8bf1f1005ae02a0044f0f3027c702a807", "url": "https://api.github.com/repos/rust-lang/rust/commits/65bc6cb8bf1f1005ae02a0044f0f3027c702a807", "html_url": "https://github.com/rust-lang/rust/commit/65bc6cb8bf1f1005ae02a0044f0f3027c702a807"}], "stats": {"total": 108, "additions": 73, "deletions": 35}, "files": [{"sha": "cac99c21e9e459f731b8d9b2130e5d877ece52ff", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 54, "deletions": 34, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/0204b9535731cbaba1689b6d6ef44a93aef2dae3/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0204b9535731cbaba1689b6d6ef44a93aef2dae3/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=0204b9535731cbaba1689b6d6ef44a93aef2dae3", "patch": "@@ -163,6 +163,14 @@ struct StateData {\n     hir_id: HirId,\n }\n \n+struct DerefedBorrow {\n+    count: usize,\n+    required_precedence: i8,\n+    msg: &'static str,\n+    stability: AutoDerefStability,\n+    position: Position,\n+}\n+\n enum State {\n     // Any number of deref method calls.\n     DerefMethod {\n@@ -172,11 +180,7 @@ enum State {\n         /// The required mutability\n         target_mut: Mutability,\n     },\n-    DerefedBorrow {\n-        count: usize,\n-        required_precedence: i8,\n-        msg: &'static str,\n-    },\n+    DerefedBorrow(DerefedBorrow),\n     ExplicitDeref {\n         deref_span: Span,\n         deref_hir_id: HirId,\n@@ -344,17 +348,16 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n \n                         if deref_count >= required_refs {\n                             self.state = Some((\n-                                State::DerefedBorrow {\n+                                State::DerefedBorrow(DerefedBorrow {\n                                     // One of the required refs is for the current borrow expression, the remaining ones\n                                     // can't be removed without breaking the code. See earlier comment.\n                                     count: deref_count - required_refs,\n                                     required_precedence,\n                                     msg,\n-                                },\n-                                StateData {\n-                                    span: expr.span,\n-                                    hir_id: expr.hir_id,\n-                                },\n+                                    stability,\n+                                    position,\n+                                }),\n+                                StateData { span: expr.span, hir_id: expr.hir_id },\n                             ));\n                         } else if stability.is_deref_stable() {\n                             self.state = Some((\n@@ -393,26 +396,47 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                     data,\n                 ));\n             },\n-            (\n-                Some((\n-                    State::DerefedBorrow {\n-                        count,\n-                        required_precedence,\n-                        msg,\n-                    },\n-                    data,\n-                )),\n-                RefOp::AddrOf,\n-            ) if count != 0 => {\n+            (Some((State::DerefedBorrow(state), data)), RefOp::AddrOf) if state.count != 0 => {\n                 self.state = Some((\n-                    State::DerefedBorrow {\n-                        count: count - 1,\n-                        required_precedence,\n-                        msg,\n-                    },\n+                    State::DerefedBorrow(DerefedBorrow {\n+                        count: state.count - 1,\n+                        ..state\n+                    }),\n                     data,\n                 ));\n             },\n+            (Some((State::DerefedBorrow(state), data)), RefOp::AddrOf) => {\n+                let stability = state.stability;\n+                report(cx, expr, State::DerefedBorrow(state), data);\n+                if stability.is_deref_stable() {\n+                    self.state = Some((\n+                        State::Borrow,\n+                        StateData {\n+                            span: expr.span,\n+                            hir_id: expr.hir_id,\n+                        },\n+                    ));\n+                }\n+            },\n+            (Some((State::DerefedBorrow(state), data)), RefOp::Deref) => {\n+                let stability = state.stability;\n+                let position = state.position;\n+                report(cx, expr, State::DerefedBorrow(state), data);\n+                if let Position::FieldAccess(name) = position\n+                    && !ty_contains_field(typeck.expr_ty(sub_expr), name)\n+                {\n+                    self.state = Some((\n+                        State::ExplicitDerefField { name },\n+                        StateData { span: expr.span, hir_id: expr.hir_id },\n+                    ));\n+                } else if stability.is_deref_stable() {\n+                    self.state = Some((\n+                        State::ExplicitDeref { deref_span: expr.span, deref_hir_id: expr.hir_id },\n+                        StateData { span: expr.span, hir_id: expr.hir_id },\n+                    ));\n+                }\n+            },\n+\n             (Some((State::Borrow, data)), RefOp::Deref) => {\n                 if typeck.expr_ty(sub_expr).is_ref() {\n                     self.state = Some((\n@@ -942,15 +966,11 @@ fn report<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data\n                 app,\n             );\n         },\n-        State::DerefedBorrow {\n-            required_precedence,\n-            msg,\n-            ..\n-        } => {\n+        State::DerefedBorrow(state) => {\n             let mut app = Applicability::MachineApplicable;\n             let snip = snippet_with_context(cx, expr.span, data.span.ctxt(), \"..\", &mut app).0;\n-            span_lint_hir_and_then(cx, NEEDLESS_BORROW, data.hir_id, data.span, msg, |diag| {\n-                let sugg = if required_precedence > expr.precedence().order() && !has_enclosing_paren(&snip) {\n+            span_lint_hir_and_then(cx, NEEDLESS_BORROW, data.hir_id, data.span, state.msg, |diag| {\n+                let sugg = if state.required_precedence > expr.precedence().order() && !has_enclosing_paren(&snip) {\n                     format!(\"({})\", snip)\n                 } else {\n                     snip.into()"}, {"sha": "f534714bc659ae6d9f51bc3a5e5ee11f2edfa4b0", "filename": "tests/ui/explicit_auto_deref.fixed", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0204b9535731cbaba1689b6d6ef44a93aef2dae3/tests%2Fui%2Fexplicit_auto_deref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/0204b9535731cbaba1689b6d6ef44a93aef2dae3/tests%2Fui%2Fexplicit_auto_deref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.fixed?ref=0204b9535731cbaba1689b6d6ef44a93aef2dae3", "patch": "@@ -198,4 +198,7 @@ fn main() {\n             return *x;\n         }\n     }\n+\n+    f_str(&&ref_str); // `needless_borrow` will suggest removing both references\n+    f_str(&ref_str); // `needless_borrow` will suggest removing only one reference\n }"}, {"sha": "4781962882bcb7c091bdb9ac158c7d93ad0e2c44", "filename": "tests/ui/explicit_auto_deref.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0204b9535731cbaba1689b6d6ef44a93aef2dae3/tests%2Fui%2Fexplicit_auto_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0204b9535731cbaba1689b6d6ef44a93aef2dae3/tests%2Fui%2Fexplicit_auto_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.rs?ref=0204b9535731cbaba1689b6d6ef44a93aef2dae3", "patch": "@@ -198,4 +198,7 @@ fn main() {\n             return *x;\n         }\n     }\n+\n+    f_str(&&*ref_str); // `needless_borrow` will suggest removing both references\n+    f_str(&&**ref_str); // `needless_borrow` will suggest removing only one reference\n }"}, {"sha": "26357ffd96a0fdfbc5d174816875ac9226ce6586", "filename": "tests/ui/explicit_auto_deref.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0204b9535731cbaba1689b6d6ef44a93aef2dae3/tests%2Fui%2Fexplicit_auto_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0204b9535731cbaba1689b6d6ef44a93aef2dae3/tests%2Fui%2Fexplicit_auto_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.stderr?ref=0204b9535731cbaba1689b6d6ef44a93aef2dae3", "patch": "@@ -180,5 +180,17 @@ error: deref which would be done by auto-deref\n LL |     let _ = f_str(**ref_ref_str);\n    |                   ^^^^^^^^^^^^^ help: try this: `ref_ref_str`\n \n-error: aborting due to 30 previous errors\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:201:13\n+   |\n+LL |     f_str(&&*ref_str); // `needless_borrow` will suggest removing both references\n+   |             ^^^^^^^^ help: try this: `ref_str`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:202:12\n+   |\n+LL |     f_str(&&**ref_str); // `needless_borrow` will suggest removing only one reference\n+   |            ^^^^^^^^^^ help: try this: `ref_str`\n+\n+error: aborting due to 32 previous errors\n "}]}