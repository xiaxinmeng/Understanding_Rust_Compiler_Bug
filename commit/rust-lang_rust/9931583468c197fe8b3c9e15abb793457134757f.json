{"sha": "9931583468c197fe8b3c9e15abb793457134757f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5MzE1ODM0NjhjMTk3ZmU4YjNjOWUxNWFiYjc5MzQ1NzEzNDc1N2Y=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-02-11T21:08:32Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2018-02-12T02:53:30Z"}, "message": "Make primitive types docs relevant", "tree": {"sha": "954eede764fff969c8b98d77e26858fcf02d581f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/954eede764fff969c8b98d77e26858fcf02d581f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9931583468c197fe8b3c9e15abb793457134757f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9931583468c197fe8b3c9e15abb793457134757f", "html_url": "https://github.com/rust-lang/rust/commit/9931583468c197fe8b3c9e15abb793457134757f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9931583468c197fe8b3c9e15abb793457134757f/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0196b20f6943963fd7598c0486ce3f58189c04d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0196b20f6943963fd7598c0486ce3f58189c04d1", "html_url": "https://github.com/rust-lang/rust/commit/0196b20f6943963fd7598c0486ce3f58189c04d1"}], "stats": {"total": 2003, "additions": 1017, "deletions": 986}, "files": [{"sha": "3ad52370526566ed6c297a67c59734ab6c0f0d91", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1017, "deletions": 938, "changes": 1955, "blob_url": "https://github.com/rust-lang/rust/blob/9931583468c197fe8b3c9e15abb793457134757f/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9931583468c197fe8b3c9e15abb793457134757f/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=9931583468c197fe8b3c9e15abb793457134757f", "patch": "@@ -96,132 +96,151 @@ pub mod dec2flt;\n pub mod bignum;\n pub mod diy_float;\n \n+macro_rules! doc_comment {\n+    ($x:expr, $($tt:tt)*) => {\n+        #[doc = $x]\n+        $($tt)*\n+    };\n+}\n+\n // `Int` + `SignedInt` implemented for signed integers\n macro_rules! int_impl {\n-    ($SelfT:ty, $ActualT:ident, $UnsignedT:ty, $BITS:expr) => {\n-        /// Returns the smallest value that can be represented by this integer type.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(i8::min_value(), -128);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub const fn min_value() -> Self {\n-            !0 ^ ((!0 as $UnsignedT) >> 1) as Self\n+    ($SelfT:ty, $ActualT:ident, $UnsignedT:ty, $BITS:expr, $Min:expr, $Max:expr) => {\n+        doc_comment! {\n+            concat!(\"Returns the smallest value that can be represented by this integer type.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(\", stringify!($SelfT), \"::min_value(), \", stringify!($Min), \");\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub const fn min_value() -> Self {\n+                !0 ^ ((!0 as $UnsignedT) >> 1) as Self\n+            }\n         }\n \n-        /// Returns the largest value that can be represented by this integer type.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(i8::max_value(), 127);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub const fn max_value() -> Self {\n-            !Self::min_value()\n+        doc_comment! {\n+            concat!(\"Returns the largest value that can be represented by this integer type.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(\", stringify!($SelfT), \"::max_value(), \", stringify!($Max), \");\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub const fn max_value() -> Self {\n+                !Self::min_value()\n+            }\n         }\n \n-        /// Converts a string slice in a given base to an integer.\n-        ///\n-        /// The string is expected to be an optional `+` or `-` sign\n-        /// followed by digits.\n-        /// Leading and trailing whitespace represent an error.\n-        /// Digits are a subset of these characters, depending on `radix`:\n-        ///\n-        /// * `0-9`\n-        /// * `a-z`\n-        /// * `A-Z`\n-        ///\n-        /// # Panics\n-        ///\n-        /// This function panics if `radix` is not in the range from 2 to 36.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(i32::from_str_radix(\"A\", 16), Ok(10));\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n-            from_str_radix(src, radix)\n+        doc_comment! {\n+            concat!(\"Converts a string slice in a given base to an integer.\n+\n+The string is expected to be an optional `+` or `-` sign followed by digits.\n+Leading and trailing whitespace represent an error. Digits are a subset of these characters,\n+depending on `radix`:\n+\n+ * `0-9`\n+ * `a-z`\n+ * `a-z`\n+\n+# Panics\n+\n+This function panics if `radix` is not in the range from 2 to 36.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(\", stringify!($SelfT), \"::from_str_radix(\\\"A\\\", 16), Ok(10));\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n+                from_str_radix(src, radix)\n+            }\n         }\n \n-        /// Returns the number of ones in the binary representation of `self`.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// let n = -0b1000_0000i8;\n-        ///\n-        /// assert_eq!(n.count_ones(), 1);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n+        doc_comment! {\n+            concat!(\"Returns the number of ones in the binary representation of `self`.\n \n-        /// Returns the number of zeros in the binary representation of `self`.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// let n = -0b1000_0000i8;\n-        ///\n-        /// assert_eq!(n.count_zeros(), 7);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn count_zeros(self) -> u32 {\n-            (!self).count_ones()\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = -0b1000_0000\", stringify!($SelfT), \";\n+\n+assert_eq!(n.count_ones(), 1);\n+```\n+\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n         }\n \n-        /// Returns the number of leading zeros in the binary representation\n-        /// of `self`.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// let n = -1i16;\n-        ///\n-        /// assert_eq!(n.leading_zeros(), 0);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn leading_zeros(self) -> u32 {\n-            (self as $UnsignedT).leading_zeros()\n+        doc_comment! {\n+            concat!(\"Returns the number of zeros in the binary representation of `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = -0b1000_0000\", stringify!($SelfT), \";\n+\n+assert_eq!(n.count_zeros(), 7);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn count_zeros(self) -> u32 {\n+                (!self).count_ones()\n+            }\n         }\n \n-        /// Returns the number of trailing zeros in the binary representation\n-        /// of `self`.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// let n = -4i8;\n-        ///\n-        /// assert_eq!(n.trailing_zeros(), 2);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn trailing_zeros(self) -> u32 {\n-            (self as $UnsignedT).trailing_zeros()\n+        doc_comment! {\n+            concat!(\"Returns the number of leading zeros in the binary representation of `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = -1\", stringify!($SelfT), \";\n+\n+assert_eq!(n.leading_zeros(), 0);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn leading_zeros(self) -> u32 {\n+                (self as $UnsignedT).leading_zeros()\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns the number of trailing zeros in the binary representation of `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = -4\", stringify!($SelfT), \";\n+\n+assert_eq!(n.trailing_zeros(), 2);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn trailing_zeros(self) -> u32 {\n+                (self as $UnsignedT).trailing_zeros()\n+            }\n         }\n \n         /// Shifts the bits to the left by a specified amount, `n`,\n@@ -288,947 +307,1007 @@ macro_rules! int_impl {\n             (self as $UnsignedT).swap_bytes() as Self\n         }\n \n-        /// Converts an integer from big endian to the target's endianness.\n-        ///\n-        /// On big endian this is a no-op. On little endian the bytes are\n-        /// swapped.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// let n = 0x0123456789ABCDEFi64;\n-        ///\n-        /// if cfg!(target_endian = \"big\") {\n-        ///     assert_eq!(i64::from_be(n), n)\n-        /// } else {\n-        ///     assert_eq!(i64::from_be(n), n.swap_bytes())\n-        /// }\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn from_be(x: Self) -> Self {\n-            if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n+        doc_comment! {\n+            concat!(\"Converts an integer from big endian to the target's endianness.\n+\n+On big endian this is a no-op. On little endian the bytes are swapped.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = 0xA1\", stringify!($SelfT), \";\n+\n+if cfg!(target_endian = \\\"big\\\") {\n+    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\n+} else {\n+    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\n+}\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn from_be(x: Self) -> Self {\n+                if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n+            }\n         }\n \n-        /// Converts an integer from little endian to the target's endianness.\n-        ///\n-        /// On little endian this is a no-op. On big endian the bytes are\n-        /// swapped.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// let n = 0x0123456789ABCDEFi64;\n-        ///\n-        /// if cfg!(target_endian = \"little\") {\n-        ///     assert_eq!(i64::from_le(n), n)\n-        /// } else {\n-        ///     assert_eq!(i64::from_le(n), n.swap_bytes())\n-        /// }\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn from_le(x: Self) -> Self {\n-            if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n+        doc_comment! {\n+            concat!(\"Converts an integer from little endian to the target's endianness.\n+\n+On little endian this is a no-op. On big endian the bytes are swapped.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = 0xA1\", stringify!($SelfT), \";\n+\n+if cfg!(target_endian = \\\"little\\\") {\n+    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\n+} else {\n+    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\n+}\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn from_le(x: Self) -> Self {\n+                if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n+            }\n         }\n \n-        /// Converts `self` to big endian from the target's endianness.\n-        ///\n-        /// On big endian this is a no-op. On little endian the bytes are\n-        /// swapped.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// let n = 0x0123456789ABCDEFi64;\n-        ///\n-        /// if cfg!(target_endian = \"big\") {\n-        ///     assert_eq!(n.to_be(), n)\n-        /// } else {\n-        ///     assert_eq!(n.to_be(), n.swap_bytes())\n-        /// }\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn to_be(self) -> Self { // or not to be?\n-            if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n+        doc_comment! {\n+            concat!(\"Converts `self` to big endian from the target's endianness.\n+\n+On big endian this is a no-op. On little endian the bytes are swapped.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = 0xA1\", stringify!($SelfT), \";\n+\n+if cfg!(target_endian = \\\"big\\\") {\n+    assert_eq!(n.to_be(), n)\n+} else {\n+    assert_eq!(n.to_be(), n.swap_bytes())\n+}\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn to_be(self) -> Self { // or not to be?\n+                if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n+            }\n         }\n \n-        /// Converts `self` to little endian from the target's endianness.\n-        ///\n-        /// On little endian this is a no-op. On big endian the bytes are\n-        /// swapped.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// let n = 0x0123456789ABCDEFi64;\n-        ///\n-        /// if cfg!(target_endian = \"little\") {\n-        ///     assert_eq!(n.to_le(), n)\n-        /// } else {\n-        ///     assert_eq!(n.to_le(), n.swap_bytes())\n-        /// }\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn to_le(self) -> Self {\n-            if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n+        doc_comment! {\n+            concat!(\"Converts `self` to little endian from the target's endianness.\n+\n+On little endian this is a no-op. On big endian the bytes are swapped.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = 0xA1\", stringify!($SelfT), \";\n+\n+if cfg!(target_endian = \\\"little\\\") {\n+    assert_eq!(n.to_le(), n)\n+} else {\n+    assert_eq!(n.to_le(), n.swap_bytes())\n+}\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn to_le(self) -> Self {\n+                if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n+            }\n         }\n \n-        /// Checked integer addition. Computes `self + rhs`, returning `None`\n-        /// if overflow occurred.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(7i16.checked_add(32760), Some(32767));\n-        /// assert_eq!(8i16.checked_add(32760), None);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn checked_add(self, rhs: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_add(rhs);\n-            if b {None} else {Some(a)}\n-        }\n+        doc_comment! {\n+            concat!(\"Checked integer addition. Computes `self + rhs`, returning `None`\n+if overflow occurred.\n \n-        /// Checked integer subtraction. Computes `self - rhs`, returning\n-        /// `None` if overflow occurred.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n-        /// assert_eq!((-128i8).checked_sub(1), None);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn checked_sub(self, rhs: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_sub(rhs);\n-            if b {None} else {Some(a)}\n-        }\n+# Examples\n \n-        /// Checked integer multiplication. Computes `self * rhs`, returning\n-        /// `None` if overflow occurred.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(6i8.checked_mul(21), Some(126));\n-        /// assert_eq!(6i8.checked_mul(22), None);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn checked_mul(self, rhs: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_mul(rhs);\n-            if b {None} else {Some(a)}\n-        }\n+Basic usage:\n \n-        /// Checked integer division. Computes `self / rhs`, returning `None`\n-        /// if `rhs == 0` or the division results in overflow.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!((-127i8).checked_div(-1), Some(127));\n-        /// assert_eq!((-128i8).checked_div(-1), None);\n-        /// assert_eq!((1i8).checked_div(0), None);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn checked_div(self, rhs: Self) -> Option<Self> {\n-            if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n-                None\n-            } else {\n-                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n+```\n+assert_eq!((\", stringify!($SelfT), \"::max_value() - 2).checked_add(1), Some(\",\n+stringify!($SelfT), \"::max_value() - 1));\n+assert_eq!((\", stringify!($SelfT), \"::max_value() - 2).checked_add(3), None);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn checked_add(self, rhs: Self) -> Option<Self> {\n+                let (a, b) = self.overflowing_add(rhs);\n+                if b {None} else {Some(a)}\n             }\n         }\n \n-        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n-        /// if `rhs == 0` or the division results in overflow.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// use std::i32;\n-        ///\n-        /// assert_eq!(5i32.checked_rem(2), Some(1));\n-        /// assert_eq!(5i32.checked_rem(0), None);\n-        /// assert_eq!(i32::MIN.checked_rem(-1), None);\n-        /// ```\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        #[inline]\n-        pub fn checked_rem(self, rhs: Self) -> Option<Self> {\n-            if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n-                None\n-            } else {\n-                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n+        doc_comment! {\n+            concat!(\"Checked integer subtraction. Computes `self - rhs`, returning `None` if\n+overflow occurred.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!((\", stringify!($SelfT), \"::min_value() + 2).checked_sub(1), Some(\",\n+stringify!($SelfT), \"::min_value() + 1));\n+assert_eq!((\", stringify!($SelfT), \"::min_value() + 2).checked_sub(3), None);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn checked_sub(self, rhs: Self) -> Option<Self> {\n+                let (a, b) = self.overflowing_sub(rhs);\n+                if b {None} else {Some(a)}\n             }\n         }\n \n-        /// Checked negation. Computes `-self`, returning `None` if `self ==\n-        /// MIN`.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// use std::i32;\n-        ///\n-        /// assert_eq!(5i32.checked_neg(), Some(-5));\n-        /// assert_eq!(i32::MIN.checked_neg(), None);\n-        /// ```\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        #[inline]\n-        pub fn checked_neg(self) -> Option<Self> {\n-            let (a, b) = self.overflowing_neg();\n-            if b {None} else {Some(a)}\n+        doc_comment! {\n+            concat!(\"Checked integer multiplication. Computes `self * rhs`, returning `None` if\n+overflow occurred.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(\", stringify!($SelfT), \"::max_value().checked_mul(1), Some(\", stringify!($SelfT),\n+\"::max_value()));\n+assert_eq!(\", stringify!($SelfT), \"::max_value().checked_mul(2), None);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn checked_mul(self, rhs: Self) -> Option<Self> {\n+                let (a, b) = self.overflowing_mul(rhs);\n+                if b {None} else {Some(a)}\n+            }\n         }\n \n-        /// Checked shift left. Computes `self << rhs`, returning `None`\n-        /// if `rhs` is larger than or equal to the number of bits in `self`.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(0x10i32.checked_shl(4), Some(0x100));\n-        /// assert_eq!(0x10i32.checked_shl(33), None);\n-        /// ```\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        #[inline]\n-        pub fn checked_shl(self, rhs: u32) -> Option<Self> {\n-            let (a, b) = self.overflowing_shl(rhs);\n-            if b {None} else {Some(a)}\n+        doc_comment! {\n+            concat!(\"Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`\n+or the division results in overflow.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!((\", stringify!($SelfT), \"::min_value() + 1).checked_div(-1), Some(\",\n+stringify!($Max), \"));\n+assert_eq!(\", stringify!($SelfT), \"::min_value().checked_div(-1), None);\n+assert_eq!((1\", stringify!($SelfT), \").checked_div(0), None);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn checked_div(self, rhs: Self) -> Option<Self> {\n+                if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n+                    None\n+                } else {\n+                    Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n+                }\n+            }\n         }\n \n-        /// Checked shift right. Computes `self >> rhs`, returning `None`\n-        /// if `rhs` is larger than or equal to the number of bits in `self`.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(0x10i32.checked_shr(4), Some(0x1));\n-        /// assert_eq!(0x10i32.checked_shr(33), None);\n-        /// ```\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        #[inline]\n-        pub fn checked_shr(self, rhs: u32) -> Option<Self> {\n-            let (a, b) = self.overflowing_shr(rhs);\n-            if b {None} else {Some(a)}\n+        doc_comment! {\n+            concat!(\"Checked integer remainder. Computes `self % rhs`, returning `None` if\n+`rhs == 0` or the division results in overflow.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+use std::\", stringify!($SelfT), \";\n+\n+assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\n+assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem(-1), None);\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[inline]\n+            pub fn checked_rem(self, rhs: Self) -> Option<Self> {\n+                if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n+                    None\n+                } else {\n+                    Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n+                }\n+            }\n         }\n \n-        /// Checked absolute value. Computes `self.abs()`, returning `None` if\n-        /// `self == MIN`.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// use std::i32;\n-        ///\n-        /// assert_eq!((-5i32).checked_abs(), Some(5));\n-        /// assert_eq!(i32::MIN.checked_abs(), None);\n-        /// ```\n-        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n-        #[inline]\n-        pub fn checked_abs(self) -> Option<Self> {\n-            if self.is_negative() {\n-                self.checked_neg()\n-            } else {\n-                Some(self)\n+        doc_comment! {\n+            concat!(\"Checked negation. Computes `-self`, returning `None` if `self == MIN`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+use std::\", stringify!($SelfT), \";\n+\n+assert_eq!(5\", stringify!($SelfT), \".checked_neg(), Some(-5));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.checked_neg(), None);\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[inline]\n+            pub fn checked_neg(self) -> Option<Self> {\n+                let (a, b) = self.overflowing_neg();\n+                if b {None} else {Some(a)}\n             }\n         }\n \n-        /// Saturating integer addition. Computes `self + rhs`, saturating at\n-        /// the numeric bounds instead of overflowing.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(100i8.saturating_add(1), 101);\n-        /// assert_eq!(100i8.saturating_add(127), 127);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn saturating_add(self, rhs: Self) -> Self {\n-            match self.checked_add(rhs) {\n-                Some(x) => x,\n-                None if rhs >= 0 => Self::max_value(),\n-                None => Self::min_value(),\n+        doc_comment! {\n+            concat!(\"Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger\n+than or equal to the number of bits in `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\n+assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(70), None);\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[inline]\n+            pub fn checked_shl(self, rhs: u32) -> Option<Self> {\n+                let (a, b) = self.overflowing_shl(rhs);\n+                if b {None} else {Some(a)}\n             }\n         }\n \n-        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n-        /// at the numeric bounds instead of overflowing.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(100i8.saturating_sub(127), -27);\n-        /// assert_eq!((-100i8).saturating_sub(127), -128);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn saturating_sub(self, rhs: Self) -> Self {\n-            match self.checked_sub(rhs) {\n-                Some(x) => x,\n-                None if rhs >= 0 => Self::min_value(),\n-                None => Self::max_value(),\n+        doc_comment! {\n+            concat!(\"Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is\n+larger than or equal to the number of bits in `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\n+assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(70), None);\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[inline]\n+            pub fn checked_shr(self, rhs: u32) -> Option<Self> {\n+                let (a, b) = self.overflowing_shr(rhs);\n+                if b {None} else {Some(a)}\n             }\n         }\n \n-        /// Saturating integer multiplication. Computes `self * rhs`,\n-        /// saturating at the numeric bounds instead of overflowing.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// use std::i32;\n-        ///\n-        /// assert_eq!(100i32.saturating_mul(127), 12700);\n-        /// assert_eq!((1i32 << 23).saturating_mul(1 << 23), i32::MAX);\n-        /// assert_eq!((-1i32 << 23).saturating_mul(1 << 23), i32::MIN);\n-        /// ```\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        #[inline]\n-        pub fn saturating_mul(self, rhs: Self) -> Self {\n-            self.checked_mul(rhs).unwrap_or_else(|| {\n-                if (self < 0 && rhs < 0) || (self > 0 && rhs > 0) {\n-                    Self::max_value()\n+        doc_comment! {\n+            concat!(\"Checked absolute value. Computes `self.abs()`, returning `None` if\n+`self == MIN`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+use std::\", stringify!($SelfT), \";\n+\n+assert_eq!((-5\", stringify!($SelfT), \").checked_abs(), Some(5));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.checked_abs(), None);\n+```\"),\n+            #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n+            #[inline]\n+            pub fn checked_abs(self) -> Option<Self> {\n+                if self.is_negative() {\n+                    self.checked_neg()\n                 } else {\n-                    Self::min_value()\n+                    Some(self)\n                 }\n-            })\n+            }\n         }\n \n-        /// Wrapping (modular) addition. Computes `self + rhs`,\n-        /// wrapping around at the boundary of the type.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(100i8.wrapping_add(27), 127);\n-        /// assert_eq!(100i8.wrapping_add(127), -29);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn wrapping_add(self, rhs: Self) -> Self {\n-            unsafe {\n-                intrinsics::overflowing_add(self, rhs)\n+        doc_comment! {\n+            concat!(\"Saturating integer addition. Computes `self + rhs`, saturating at the numeric\n+bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\n+assert_eq!(\", stringify!($SelfT), \"::max_value().saturating_add(100), \", stringify!($SelfT),\n+\"::max_value());\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn saturating_add(self, rhs: Self) -> Self {\n+                match self.checked_add(rhs) {\n+                    Some(x) => x,\n+                    None if rhs >= 0 => Self::max_value(),\n+                    None => Self::min_value(),\n+                }\n             }\n         }\n \n-        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n-        /// wrapping around at the boundary of the type.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(0i8.wrapping_sub(127), -127);\n-        /// assert_eq!((-2i8).wrapping_sub(127), 127);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn wrapping_sub(self, rhs: Self) -> Self {\n-            unsafe {\n-                intrinsics::overflowing_sub(self, rhs)\n+        doc_comment! {\n+            concat!(\"Saturating integer subtraction. Computes `self - rhs`, saturating at the\n+numeric bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(100\", stringify!($SelfT), \".saturating_sub(127), -27);\n+assert_eq!(\", stringify!($SelfT), \"::min_value().saturating_sub(100), \", stringify!($SelfT),\n+\"::min_value());\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn saturating_sub(self, rhs: Self) -> Self {\n+                match self.checked_sub(rhs) {\n+                    Some(x) => x,\n+                    None if rhs >= 0 => Self::min_value(),\n+                    None => Self::max_value(),\n+                }\n             }\n         }\n \n-        /// Wrapping (modular) multiplication. Computes `self *\n-        /// rhs`, wrapping around at the boundary of the type.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(10i8.wrapping_mul(12), 120);\n-        /// assert_eq!(11i8.wrapping_mul(12), -124);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn wrapping_mul(self, rhs: Self) -> Self {\n-            unsafe {\n-                intrinsics::overflowing_mul(self, rhs)\n+        doc_comment! {\n+            concat!(\"Saturating integer multiplication. Computes `self * rhs`, saturating at the\n+numeric bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+use std::\", stringify!($SelfT), \";\n+\n+assert_eq!(10\", stringify!($SelfT), \".saturating_mul(12), 120);\n+assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_mul(11 << 23), \", stringify!($SelfT), \"::MAX);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_mul(1 << 23), \", stringify!($SelfT), \"::MIN);\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[inline]\n+            pub fn saturating_mul(self, rhs: Self) -> Self {\n+                self.checked_mul(rhs).unwrap_or_else(|| {\n+                    if (self < 0 && rhs < 0) || (self > 0 && rhs > 0) {\n+                        Self::max_value()\n+                    } else {\n+                        Self::min_value()\n+                    }\n+                })\n             }\n         }\n \n-        /// Wrapping (modular) division. Computes `self / rhs`,\n-        /// wrapping around at the boundary of the type.\n-        ///\n-        /// The only case where such wrapping can occur is when one\n-        /// divides `MIN / -1` on a signed type (where `MIN` is the\n-        /// negative minimal value for the type); this is equivalent\n-        /// to `-MIN`, a positive value that is too large to represent\n-        /// in the type. In such a case, this function returns `MIN`\n-        /// itself.\n-        ///\n-        /// # Panics\n-        ///\n-        /// This function will panic if `rhs` is 0.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(100u8.wrapping_div(10), 10);\n-        /// assert_eq!((-128i8).wrapping_div(-1), -128);\n-        /// ```\n-        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[inline]\n-        pub fn wrapping_div(self, rhs: Self) -> Self {\n-            self.overflowing_div(rhs).0\n-        }\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) addition. Computes `self + rhs`, wrapping around at the\n+boundary of the type.\n \n-        /// Wrapping (modular) remainder. Computes `self % rhs`,\n-        /// wrapping around at the boundary of the type.\n-        ///\n-        /// Such wrap-around never actually occurs mathematically;\n-        /// implementation artifacts make `x % y` invalid for `MIN /\n-        /// -1` on a signed type (where `MIN` is the negative\n-        /// minimal value). In such a case, this function returns `0`.\n-        ///\n-        /// # Panics\n-        ///\n-        /// This function will panic if `rhs` is 0.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(100i8.wrapping_rem(10), 0);\n-        /// assert_eq!((-128i8).wrapping_rem(-1), 0);\n-        /// ```\n-        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[inline]\n-        pub fn wrapping_rem(self, rhs: Self) -> Self {\n-            self.overflowing_rem(rhs).0\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_add(27), 127);\n+assert_eq!(\", stringify!($SelfT), \"::max_value().wrapping_add(2), \", stringify!($SelfT),\n+\"::min_value() + 1);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn wrapping_add(self, rhs: Self) -> Self {\n+                unsafe {\n+                    intrinsics::overflowing_add(self, rhs)\n+                }\n+            }\n         }\n \n-        /// Wrapping (modular) negation. Computes `-self`,\n-        /// wrapping around at the boundary of the type.\n-        ///\n-        /// The only case where such wrapping can occur is when one\n-        /// negates `MIN` on a signed type (where `MIN` is the\n-        /// negative minimal value for the type); this is a positive\n-        /// value that is too large to represent in the type. In such\n-        /// a case, this function returns `MIN` itself.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(100i8.wrapping_neg(), -100);\n-        /// assert_eq!((-128i8).wrapping_neg(), -128);\n-        /// ```\n-        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[inline]\n-        pub fn wrapping_neg(self) -> Self {\n-            self.overflowing_neg().0\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) subtraction. Computes `self - rhs`, wrapping around at the\n+boundary of the type.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(0\", stringify!($SelfT), \".wrapping_sub(127), -127);\n+assert_eq!((-2i8).wrapping_sub(\", stringify!($SelfT), \"::max_value()), \",\n+stringify!($SelfT), \"::max_value());\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn wrapping_sub(self, rhs: Self) -> Self {\n+                unsafe {\n+                    intrinsics::overflowing_sub(self, rhs)\n+                }\n+            }\n         }\n \n-        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n-        /// where `mask` removes any high-order bits of `rhs` that\n-        /// would cause the shift to exceed the bitwidth of the type.\n-        ///\n-        /// Note that this is *not* the same as a rotate-left; the\n-        /// RHS of a wrapping shift-left is restricted to the range\n-        /// of the type, rather than the bits shifted out of the LHS\n-        /// being returned to the other end. The primitive integer\n-        /// types all implement a `rotate_left` function, which may\n-        /// be what you want instead.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!((-1i8).wrapping_shl(7), -128);\n-        /// assert_eq!((-1i8).wrapping_shl(8), -1);\n-        /// ```\n-        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[inline]\n-        pub fn wrapping_shl(self, rhs: u32) -> Self {\n-            unsafe {\n-                intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) multiplication. Computes `self * rhs`, wrapping around at\n+the boundary of the type.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(10\", stringify!($SelfT), \".wrapping_mul(12), 120);\n+assert_eq!(11i8.wrapping_mul(12), -124);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn wrapping_mul(self, rhs: Self) -> Self {\n+                unsafe {\n+                    intrinsics::overflowing_mul(self, rhs)\n+                }\n             }\n         }\n \n-        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n-        /// where `mask` removes any high-order bits of `rhs` that\n-        /// would cause the shift to exceed the bitwidth of the type.\n-        ///\n-        /// Note that this is *not* the same as a rotate-right; the\n-        /// RHS of a wrapping shift-right is restricted to the range\n-        /// of the type, rather than the bits shifted out of the LHS\n-        /// being returned to the other end. The primitive integer\n-        /// types all implement a `rotate_right` function, which may\n-        /// be what you want instead.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!((-128i8).wrapping_shr(7), -1);\n-        /// assert_eq!((-128i8).wrapping_shr(8), -128);\n-        /// ```\n-        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[inline]\n-        pub fn wrapping_shr(self, rhs: u32) -> Self {\n-            unsafe {\n-                intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) division. Computes `self / rhs`, wrapping around at the\n+boundary of the type.\n+\n+The only case where such wrapping can occur is when one divides `MIN / -1` on a signed type (where\n+`MIN` is the negative minimal value for the type); this is equivalent to `-MIN`, a positive value\n+that is too large to represent in the type. In such a case, this function returns `MIN` itself.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\n+assert_eq!((-128i8).wrapping_div(-1), -128);\n+```\"),\n+            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[inline]\n+            pub fn wrapping_div(self, rhs: Self) -> Self {\n+                self.overflowing_div(rhs).0\n             }\n         }\n \n-        /// Wrapping (modular) absolute value. Computes `self.abs()`,\n-        /// wrapping around at the boundary of the type.\n-        ///\n-        /// The only case where such wrapping can occur is when one takes\n-        /// the absolute value of the negative minimal value for the type\n-        /// this is a positive value that is too large to represent in the\n-        /// type. In such a case, this function returns `MIN` itself.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(100i8.wrapping_abs(), 100);\n-        /// assert_eq!((-100i8).wrapping_abs(), 100);\n-        /// assert_eq!((-128i8).wrapping_abs(), -128);\n-        /// assert_eq!((-128i8).wrapping_abs() as u8, 128);\n-        /// ```\n-        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n-        #[inline]\n-        pub fn wrapping_abs(self) -> Self {\n-            if self.is_negative() {\n-                self.wrapping_neg()\n-            } else {\n-                self\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) remainder. Computes `self % rhs`, wrapping around at the\n+boundary of the type.\n+\n+Such wrap-around never actually occurs mathematically; implementation artifacts make `x % y`\n+invalid for `MIN / -1` on a signed type (where `MIN` is the negative minimal value). In such a case,\n+this function returns `0`.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\n+assert_eq!((-128i8).wrapping_rem(-1), 0);\n+```\"),\n+            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[inline]\n+            pub fn wrapping_rem(self, rhs: Self) -> Self {\n+                self.overflowing_rem(rhs).0\n             }\n         }\n \n-        /// Calculates `self` + `rhs`\n-        ///\n-        /// Returns a tuple of the addition along with a boolean indicating\n-        /// whether an arithmetic overflow would occur. If an overflow would\n-        /// have occurred then the wrapped value is returned.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage\n-        ///\n-        /// ```\n-        /// use std::i32;\n-        ///\n-        /// assert_eq!(5i32.overflowing_add(2), (7, false));\n-        /// assert_eq!(i32::MAX.overflowing_add(1), (i32::MIN, true));\n-        /// ```\n-        #[inline]\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        pub fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n-            let (a, b) = unsafe {\n-                intrinsics::add_with_overflow(self as $ActualT,\n-                                              rhs as $ActualT)\n-            };\n-            (a as Self, b)\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) negation. Computes `-self`, wrapping around at the boundary\n+of the type.\n+\n+The only case where such wrapping can occur is when one negates `MIN` on a signed type (where `MIN`\n+is the negative minimal value for the type); this is a positive value that is too large to represent\n+in the type. In such a case, this function returns `MIN` itself.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_neg(), -100);\n+assert_eq!(\", stringify!($SelfT), \"::min_value().wrapping_neg(), \", stringify!($SelfT),\n+\"::min_value());\n+```\"),\n+            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[inline]\n+            pub fn wrapping_neg(self) -> Self {\n+                self.overflowing_neg().0\n+            }\n         }\n \n-        /// Calculates `self` - `rhs`\n-        ///\n-        /// Returns a tuple of the subtraction along with a boolean indicating\n-        /// whether an arithmetic overflow would occur. If an overflow would\n-        /// have occurred then the wrapped value is returned.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage\n-        ///\n-        /// ```\n-        /// use std::i32;\n-        ///\n-        /// assert_eq!(5i32.overflowing_sub(2), (3, false));\n-        /// assert_eq!(i32::MIN.overflowing_sub(1), (i32::MAX, true));\n-        /// ```\n-        #[inline]\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        pub fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n-            let (a, b) = unsafe {\n-                intrinsics::sub_with_overflow(self as $ActualT,\n-                                              rhs as $ActualT)\n-            };\n-            (a as Self, b)\n+        doc_comment! {\n+            concat!(\"Panic-free bitwise shift-left; yields `self << mask(rhs)`, where `mask` removes\n+any high-order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.\n+\n+Note that this is *not* the same as a rotate-left; the RHS of a wrapping shift-left is restricted to\n+the range of the type, rather than the bits shifted out of the LHS being returned to the other end.\n+The primitive integer types all implement a `rotate_left` function, which may be what you want\n+instead.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(7), -128);\n+assert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(64), -1);\n+```\"),\n+            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[inline]\n+            pub fn wrapping_shl(self, rhs: u32) -> Self {\n+                unsafe {\n+                    intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n+                }\n+            }\n         }\n \n-        /// Calculates the multiplication of `self` and `rhs`.\n-        ///\n-        /// Returns a tuple of the multiplication along with a boolean\n-        /// indicating whether an arithmetic overflow would occur. If an\n-        /// overflow would have occurred then the wrapped value is returned.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage\n-        ///\n-        /// ```\n-        /// assert_eq!(5i32.overflowing_mul(2), (10, false));\n-        /// assert_eq!(1_000_000_000i32.overflowing_mul(10), (1410065408, true));\n-        /// ```\n-        #[inline]\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        pub fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n-            let (a, b) = unsafe {\n-                intrinsics::mul_with_overflow(self as $ActualT,\n-                                              rhs as $ActualT)\n-            };\n-            (a as Self, b)\n+        doc_comment! {\n+            concat!(\"Panic-free bitwise shift-right; yields `self >> mask(rhs)`, where `mask`\n+removes any high-order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.\n+\n+Note that this is *not* the same as a rotate-right; the RHS of a wrapping shift-right is restricted\n+to the range of the type, rather than the bits shifted out of the LHS being returned to the other\n+end. The primitive integer types all implement a `rotate_right` function, which may be what you want\n+instead.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!((-128\", stringify!($SelfT), \").wrapping_shr(7), -1);\n+assert_eq!((-128\", stringify!($SelfT), \").wrapping_shr(64), -128);\n+```\"),\n+            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[inline]\n+            pub fn wrapping_shr(self, rhs: u32) -> Self {\n+                unsafe {\n+                    intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n+                }\n+            }\n         }\n \n-        /// Calculates the divisor when `self` is divided by `rhs`.\n-        ///\n-        /// Returns a tuple of the divisor along with a boolean indicating\n-        /// whether an arithmetic overflow would occur. If an overflow would\n-        /// occur then self is returned.\n-        ///\n-        /// # Panics\n-        ///\n-        /// This function will panic if `rhs` is 0.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage\n-        ///\n-        /// ```\n-        /// use std::i32;\n-        ///\n-        /// assert_eq!(5i32.overflowing_div(2), (2, false));\n-        /// assert_eq!(i32::MIN.overflowing_div(-1), (i32::MIN, true));\n-        /// ```\n-        #[inline]\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n-            if self == Self::min_value() && rhs == -1 {\n-                (self, true)\n-            } else {\n-                (self / rhs, false)\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) absolute value. Computes `self.abs()`, wrapping around at\n+the boundary of the type.\n+\n+The only case where such wrapping can occur is when one takes the absolute value of the negative\n+minimal value for the type this is a positive value that is too large to represent in the type. In\n+such a case, this function returns `MIN` itself.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_abs(), 100);\n+assert_eq!((-100\", stringify!($SelfT), \").wrapping_abs(), 100);\n+assert_eq!(\", stringify!($SelfT), \"::min_value().wrapping_abs(), \", stringify!($SelfT),\n+\"::min_value());\n+assert_eq!((-128i8).wrapping_abs() as u8, 128);\n+```\"),\n+            #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n+            #[inline]\n+            pub fn wrapping_abs(self) -> Self {\n+                if self.is_negative() {\n+                    self.wrapping_neg()\n+                } else {\n+                    self\n+                }\n             }\n         }\n \n-        /// Calculates the remainder when `self` is divided by `rhs`.\n-        ///\n-        /// Returns a tuple of the remainder after dividing along with a boolean\n-        /// indicating whether an arithmetic overflow would occur. If an\n-        /// overflow would occur then 0 is returned.\n-        ///\n-        /// # Panics\n-        ///\n-        /// This function will panic if `rhs` is 0.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage\n-        ///\n-        /// ```\n-        /// use std::i32;\n-        ///\n-        /// assert_eq!(5i32.overflowing_rem(2), (1, false));\n-        /// assert_eq!(i32::MIN.overflowing_rem(-1), (0, true));\n-        /// ```\n-        #[inline]\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n-            if self == Self::min_value() && rhs == -1 {\n-                (0, true)\n-            } else {\n-                (self % rhs, false)\n+        doc_comment! {\n+            concat!(\"Calculates `self` + `rhs`\n+\n+Returns a tuple of the addition along with a boolean indicating whether an arithmetic overflow would\n+occur. If an overflow would have occurred then the wrapped value is returned.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+use std::\", stringify!($SelfT), \";\n+\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\n+assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (\", stringify!($SelfT), \"::MIN, true));\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            pub fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n+                let (a, b) = unsafe {\n+                    intrinsics::add_with_overflow(self as $ActualT,\n+                                                  rhs as $ActualT)\n+                };\n+                (a as Self, b)\n             }\n         }\n \n-        /// Negates self, overflowing if this is equal to the minimum value.\n-        ///\n-        /// Returns a tuple of the negated version of self along with a boolean\n-        /// indicating whether an overflow happened. If `self` is the minimum\n-        /// value (e.g. `i32::MIN` for values of type `i32`), then the minimum\n-        /// value will be returned again and `true` will be returned for an\n-        /// overflow happening.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage\n-        ///\n-        /// ```\n-        /// use std::i32;\n-        ///\n-        /// assert_eq!(2i32.overflowing_neg(), (-2, false));\n-        /// assert_eq!(i32::MIN.overflowing_neg(), (i32::MIN, true));\n-        /// ```\n-        #[inline]\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        pub fn overflowing_neg(self) -> (Self, bool) {\n-            if self == Self::min_value() {\n-                (Self::min_value(), true)\n-            } else {\n-                (-self, false)\n+        doc_comment! {\n+            concat!(\"Calculates `self` - `rhs`\n+\n+Returns a tuple of the subtraction along with a boolean indicating whether an arithmetic overflow\n+would occur. If an overflow would have occurred then the wrapped value is returned.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+use std::\", stringify!($SelfT), \";\n+\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            pub fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n+                let (a, b) = unsafe {\n+                    intrinsics::sub_with_overflow(self as $ActualT,\n+                                                  rhs as $ActualT)\n+                };\n+                (a as Self, b)\n             }\n         }\n \n-        /// Shifts self left by `rhs` bits.\n-        ///\n-        /// Returns a tuple of the shifted version of self along with a boolean\n-        /// indicating whether the shift value was larger than or equal to the\n-        /// number of bits. If the shift value is too large, then value is\n-        /// masked (N-1) where N is the number of bits, and this value is then\n-        /// used to perform the shift.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage\n-        ///\n-        /// ```\n-        /// assert_eq!(0x10i32.overflowing_shl(4), (0x100, false));\n-        /// assert_eq!(0x10i32.overflowing_shl(36), (0x100, true));\n-        /// ```\n-        #[inline]\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n-            (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n+        doc_comment! {\n+            concat!(\"Calculates the multiplication of `self` and `rhs`.\n+\n+Returns a tuple of the multiplication along with a boolean indicating whether an arithmetic overflow\n+would occur. If an overflow would have occurred then the wrapped value is returned.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_mul(2), (10, false));\n+assert_eq!(1_000_000_000i32.overflowing_mul(10), (1410065408, true));\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            pub fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n+                let (a, b) = unsafe {\n+                    intrinsics::mul_with_overflow(self as $ActualT,\n+                                                  rhs as $ActualT)\n+                };\n+                (a as Self, b)\n+            }\n         }\n \n-        /// Shifts self right by `rhs` bits.\n-        ///\n-        /// Returns a tuple of the shifted version of self along with a boolean\n-        /// indicating whether the shift value was larger than or equal to the\n-        /// number of bits. If the shift value is too large, then value is\n-        /// masked (N-1) where N is the number of bits, and this value is then\n-        /// used to perform the shift.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage\n-        ///\n-        /// ```\n-        /// assert_eq!(0x10i32.overflowing_shr(4), (0x1, false));\n-        /// assert_eq!(0x10i32.overflowing_shr(36), (0x1, true));\n-        /// ```\n-        #[inline]\n-        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n-            (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n+        doc_comment! {\n+            concat!(\"Calculates the divisor when `self` is divided by `rhs`.\n+\n+Returns a tuple of the divisor along with a boolean indicating whether an arithmetic overflow would\n+occur. If an overflow would occur then self is returned.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+use std::\", stringify!($SelfT), \";\n+\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\n+assert_eq!(i\", stringify!($SelfT), \"::MIN.overflowing_div(-1), (\", stringify!($SelfT),\n+\"::MIN, true));\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n+                if self == Self::min_value() && rhs == -1 {\n+                    (self, true)\n+                } else {\n+                    (self / rhs, false)\n+                }\n+            }\n         }\n \n-        /// Computes the absolute value of `self`.\n-        ///\n-        /// Returns a tuple of the absolute version of self along with a\n-        /// boolean indicating whether an overflow happened. If self is the\n-        /// minimum value (e.g. i32::MIN for values of type i32), then the\n-        /// minimum value will be returned again and true will be returned for\n-        /// an overflow happening.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(10i8.overflowing_abs(), (10,false));\n-        /// assert_eq!((-10i8).overflowing_abs(), (10,false));\n-        /// assert_eq!((-128i8).overflowing_abs(), (-128,true));\n-        /// ```\n-        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n-        #[inline]\n-        pub fn overflowing_abs(self) -> (Self, bool) {\n-            if self.is_negative() {\n-                self.overflowing_neg()\n-            } else {\n-                (self, false)\n+        doc_comment! {\n+            concat!(\"Calculates the remainder when `self` is divided by `rhs`.\n+\n+Returns a tuple of the remainder after dividing along with a boolean indicating whether an\n+arithmetic overflow would occur. If an overflow would occur then 0 is returned.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+use std::\", stringify!($SelfT), \";\n+\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem(-1), (0, true));\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n+                if self == Self::min_value() && rhs == -1 {\n+                    (0, true)\n+                } else {\n+                    (self % rhs, false)\n+                }\n             }\n         }\n \n-        /// Raises self to the power of `exp`, using exponentiation by squaring.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// let x: i32 = 2; // or any other integer type\n-        ///\n-        /// assert_eq!(x.pow(4), 16);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        #[rustc_inherit_overflow_checks]\n-        pub fn pow(self, mut exp: u32) -> Self {\n-            let mut base = self;\n-            let mut acc = 1;\n+        doc_comment! {\n+            concat!(\"Negates self, overflowing if this is equal to the minimum value.\n \n-            while exp > 1 {\n-                if (exp & 1) == 1 {\n-                    acc = acc * base;\n+Returns a tuple of the negated version of self along with a boolean indicating whether an overflow\n+happened. If `self` is the minimum value (e.g. `i32::MIN` for values of type `i32`), then the\n+minimum value will be returned again and `true` will be returned for an overflow happening.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+use std::\", stringify!($SelfT), \";\n+\n+assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2, false));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_neg(), (\", stringify!($SelfT), \"::MIN, true));\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            pub fn overflowing_neg(self) -> (Self, bool) {\n+                if self == Self::min_value() {\n+                    (Self::min_value(), true)\n+                } else {\n+                    (-self, false)\n                 }\n-                exp /= 2;\n-                base = base * base;\n             }\n+        }\n \n-            // Deal with the final bit of the exponent separately, since\n-            // squaring the base afterwards is not necessary and may cause a\n-            // needless overflow.\n-            if exp == 1 {\n-                acc = acc * base;\n+        doc_comment! {\n+            concat!(\"Shifts self left by `rhs` bits.\n+\n+Returns a tuple of the shifted version of self along with a boolean indicating whether the shift\n+value was larger than or equal to the number of bits. If the shift value is too large, then value is\n+masked (N-1) where N is the number of bits, and this value is then used to perform the shift.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(4), (0x100, false));\n+assert_eq!(0x10i32.overflowing_shl(36), (0x100, true));\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n+                (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n             }\n+        }\n \n-            acc\n+        doc_comment! {\n+            concat!(\"Shifts self right by `rhs` bits.\n+\n+Returns a tuple of the shifted version of self along with a boolean indicating whether the shift\n+value was larger than or equal to the number of bits. If the shift value is too large, then value is\n+masked (N-1) where N is the number of bits, and this value is then used to perform the shift.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\n+assert_eq!(0x10i32.overflowing_shr(36), (0x1, true));\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n+                (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n+            }\n         }\n \n-        /// Computes the absolute value of `self`.\n-        ///\n-        /// # Overflow behavior\n-        ///\n-        /// The absolute value of `i32::min_value()` cannot be represented as an\n-        /// `i32`, and attempting to calculate it will cause an overflow. This\n-        /// means that code in debug mode will trigger a panic on this case and\n-        /// optimized code will return `i32::min_value()` without a panic.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(10i8.abs(), 10);\n-        /// assert_eq!((-10i8).abs(), 10);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        #[rustc_inherit_overflow_checks]\n-        pub fn abs(self) -> Self {\n-            if self.is_negative() {\n-                // Note that the #[inline] above means that the overflow\n-                // semantics of this negation depend on the crate we're being\n-                // inlined into.\n-                -self\n-            } else {\n-                self\n+        doc_comment! {\n+            concat!(\"Computes the absolute value of `self`.\n+\n+Returns a tuple of the absolute version of self along with a boolean indicating whether an overflow\n+happened. If self is the minimum value (e.g. \", stringify!($SelfT), \"::MIN for values of type \n+\", stringify!($SelfT), \"), then the minimum value will be returned again and true will be returned\n+for an overflow happening.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(10\", stringify!($SelfT), \".overflowing_abs(), (10, false));\n+assert_eq!((-10\", stringify!($SelfT), \").overflowing_abs(), (10, false));\n+assert_eq!((\", stringify!($SelfT), \"::min_value()).overflowing_abs(), (-\", stringify!($SelfT),\n+\"::min_value(), true));\n+```\"),\n+            #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n+            #[inline]\n+            pub fn overflowing_abs(self) -> (Self, bool) {\n+                if self.is_negative() {\n+                    self.overflowing_neg()\n+                } else {\n+                    (self, false)\n+                }\n             }\n         }\n \n-        /// Returns a number representing sign of `self`.\n-        ///\n-        /// - `0` if the number is zero\n-        /// - `1` if the number is positive\n-        /// - `-1` if the number is negative\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert_eq!(10i8.signum(), 1);\n-        /// assert_eq!(0i8.signum(), 0);\n-        /// assert_eq!((-10i8).signum(), -1);\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn signum(self) -> Self {\n-            match self {\n-                n if n > 0 =>  1,\n-                0          =>  0,\n-                _          => -1,\n+        doc_comment! {\n+            concat!(\"Raises self to the power of `exp`, using exponentiation by squaring.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let x: \", stringify!($SelfT), \" = 2; // or any other integer type\n+\n+assert_eq!(x.pow(4), 16);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            pub fn pow(self, mut exp: u32) -> Self {\n+                let mut base = self;\n+                let mut acc = 1;\n+\n+                while exp > 1 {\n+                    if (exp & 1) == 1 {\n+                        acc = acc * base;\n+                    }\n+                    exp /= 2;\n+                    base = base * base;\n+                }\n+\n+                // Deal with the final bit of the exponent separately, since\n+                // squaring the base afterwards is not necessary and may cause a\n+                // needless overflow.\n+                if exp == 1 {\n+                    acc = acc * base;\n+                }\n+\n+                acc\n             }\n         }\n \n-        /// Returns `true` if `self` is positive and `false` if the number\n-        /// is zero or negative.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert!(10i8.is_positive());\n-        /// assert!(!(-10i8).is_positive());\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn is_positive(self) -> bool { self > 0 }\n+        doc_comment! {\n+            concat!(\"Computes the absolute value of `self`.\n \n-        /// Returns `true` if `self` is negative and `false` if the number\n-        /// is zero or positive.\n-        ///\n-        /// # Examples\n-        ///\n-        /// Basic usage:\n-        ///\n-        /// ```\n-        /// assert!((-10i8).is_negative());\n-        /// assert!(!10i8.is_negative());\n-        /// ```\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[inline]\n-        pub fn is_negative(self) -> bool { self < 0 }\n+# Overflow behavior\n+\n+The absolute value of `\", stringify!($SelfT), \"::min_value()` cannot be represented as an\n+`\", stringify!($SelfT), \"`, and attempting to calculate it will cause an overflow. This means that\n+code in debug mode will trigger a panic on this case and optimized code will return `\",\n+stringify!($SelfT), \"::min_value()` without a panic.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(10\", stringify!($SelfT), \".abs(), 10);\n+assert_eq!((-10\", stringify!($SelfT), \").abs(), 10);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            pub fn abs(self) -> Self {\n+                if self.is_negative() {\n+                    // Note that the #[inline] above means that the overflow\n+                    // semantics of this negation depend on the crate we're being\n+                    // inlined into.\n+                    -self\n+                } else {\n+                    self\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns a number representing sign of `self`.\n+\n+ - `0` if the number is zero\n+ - `1` if the number is positive\n+ - `-1` if the number is negative\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(10\", stringify!($SelfT), \".signum(), 1);\n+assert_eq!(0\", stringify!($SelfT), \".signum(), 0);\n+assert_eq!((-10\", stringify!($SelfT), \").signum(), -1);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn signum(self) -> Self {\n+                match self {\n+                    n if n > 0 =>  1,\n+                    0          =>  0,\n+                    _          => -1,\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns `true` if `self` is positive and `false` if the number is zero or\n+negative.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert!(10\", stringify!($SelfT), \".is_positive());\n+assert!(!(-10\", stringify!($SelfT), \").is_positive());\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn is_positive(self) -> bool { self > 0 }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns `true` if `self` is negative and `false` if the number is zero or\n+positive.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert!((-10\", stringify!($SelfT), \").is_negative());\n+assert!(!10\", stringify!($SelfT), \".is_negative());\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn is_negative(self) -> bool { self < 0 }\n+        }\n     }\n }\n \n #[lang = \"i8\"]\n impl i8 {\n-    int_impl! { i8, i8, u8, 8 }\n+    int_impl! { i8, i8, u8, 8, -128, 127 }\n }\n \n #[lang = \"i16\"]\n impl i16 {\n-    int_impl! { i16, i16, u16, 16 }\n+    int_impl! { i16, i16, u16, 16, -32768, 32767 }\n }\n \n #[lang = \"i32\"]\n impl i32 {\n-    int_impl! { i32, i32, u32, 32 }\n+    int_impl! { i32, i32, u32, 32, -2147483648, 2147483647 }\n }\n \n #[lang = \"i64\"]\n impl i64 {\n-    int_impl! { i64, i64, u64, 64 }\n+    int_impl! { i64, i64, u64, 64, -9223372036854775808, 9223372036854775807 }\n }\n \n #[lang = \"i128\"]\n impl i128 {\n-    int_impl! { i128, i128, u128, 128 }\n+    int_impl! { i128, i128, u128, 128, -170141183460469231731687303715884105728, 170141183460469231731687303715884105727 }\n }\n \n #[cfg(target_pointer_width = \"16\")]\n@@ -1246,7 +1325,7 @@ impl isize {\n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { isize, i64, u64, 64 }\n+    int_impl! { isize, i64, u64, 64, -9223372036854775808, 9223372036854775807 }\n }\n \n // `Int` + `UnsignedInt` implemented for unsigned integers"}, {"sha": "358aa2c37dfb4cc855cb0c546ecefa7ab048c6e7", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9931583468c197fe8b3c9e15abb793457134757f/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9931583468c197fe8b3c9e15abb793457134757f/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=9931583468c197fe8b3c9e15abb793457134757f", "patch": "@@ -720,10 +720,6 @@ mod prim_f64 { }\n /// The 8-bit signed integer type.\n ///\n /// *[See also the `std::i8` module](i8/index.html).*\n-///\n-/// However, please note that examples are shared between primitive integer\n-/// types. So it's normal if you see usage of types like `i64` in there.\n-///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_i8 { }\n \n@@ -732,10 +728,6 @@ mod prim_i8 { }\n /// The 16-bit signed integer type.\n ///\n /// *[See also the `std::i16` module](i16/index.html).*\n-///\n-/// However, please note that examples are shared between primitive integer\n-/// types. So it's normal if you see usage of types like `i32` in there.\n-///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_i16 { }\n \n@@ -744,10 +736,6 @@ mod prim_i16 { }\n /// The 32-bit signed integer type.\n ///\n /// *[See also the `std::i32` module](i32/index.html).*\n-///\n-/// However, please note that examples are shared between primitive integer\n-/// types. So it's normal if you see usage of types like `i16` in there.\n-///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_i32 { }\n \n@@ -756,10 +744,6 @@ mod prim_i32 { }\n /// The 64-bit signed integer type.\n ///\n /// *[See also the `std::i64` module](i64/index.html).*\n-///\n-/// However, please note that examples are shared between primitive integer\n-/// types. So it's normal if you see usage of types like `i8` in there.\n-///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_i64 { }\n \n@@ -768,10 +752,6 @@ mod prim_i64 { }\n /// The 128-bit signed integer type.\n ///\n /// *[See also the `std::i128` module](i128/index.html).*\n-///\n-/// However, please note that examples are shared between primitive integer\n-/// types. So it's normal if you see usage of types like `i8` in there.\n-///\n #[unstable(feature = \"i128\", issue=\"35118\")]\n mod prim_i128 { }\n \n@@ -780,10 +760,6 @@ mod prim_i128 { }\n /// The 8-bit unsigned integer type.\n ///\n /// *[See also the `std::u8` module](u8/index.html).*\n-///\n-/// However, please note that examples are shared between primitive integer\n-/// types. So it's normal if you see usage of types like `u64` in there.\n-///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_u8 { }\n \n@@ -792,10 +768,6 @@ mod prim_u8 { }\n /// The 16-bit unsigned integer type.\n ///\n /// *[See also the `std::u16` module](u16/index.html).*\n-///\n-/// However, please note that examples are shared between primitive integer\n-/// types. So it's normal if you see usage of types like `u32` in there.\n-///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_u16 { }\n \n@@ -804,10 +776,6 @@ mod prim_u16 { }\n /// The 32-bit unsigned integer type.\n ///\n /// *[See also the `std::u32` module](u32/index.html).*\n-///\n-/// However, please note that examples are shared between primitive integer\n-/// types. So it's normal if you see usage of types like `u16` in there.\n-///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_u32 { }\n \n@@ -816,10 +784,6 @@ mod prim_u32 { }\n /// The 64-bit unsigned integer type.\n ///\n /// *[See also the `std::u64` module](u64/index.html).*\n-///\n-/// However, please note that examples are shared between primitive integer\n-/// types. So it's normal if you see usage of types like `u8` in there.\n-///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_u64 { }\n \n@@ -828,10 +792,6 @@ mod prim_u64 { }\n /// The 128-bit unsigned integer type.\n ///\n /// *[See also the `std::u128` module](u128/index.html).*\n-///\n-/// However, please note that examples are shared between primitive integer\n-/// types. So it's normal if you see usage of types like `u8` in there.\n-///\n #[unstable(feature = \"i128\", issue=\"35118\")]\n mod prim_u128 { }\n \n@@ -844,10 +804,6 @@ mod prim_u128 { }\n /// and on a 64 bit target, this is 8 bytes.\n ///\n /// *[See also the `std::isize` module](isize/index.html).*\n-///\n-/// However, please note that examples are shared between primitive integer\n-/// types. So it's normal if you see usage of types like `usize` in there.\n-///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_isize { }\n \n@@ -860,10 +816,6 @@ mod prim_isize { }\n /// and on a 64 bit target, this is 8 bytes.\n ///\n /// *[See also the `std::usize` module](usize/index.html).*\n-///\n-/// However, please note that examples are shared between primitive integer\n-/// types. So it's normal if you see usage of types like `isize` in there.\n-///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_usize { }\n "}]}