{"sha": "7f798c2b216db0bb7ebeb9dd863fbdf7668094c5", "node_id": "C_kwDOAAsO6NoAKDdmNzk4YzJiMjE2ZGIwYmI3ZWJlYjlkZDg2M2ZiZGY3NjY4MDk0YzU", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-02-15T05:11:27Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-02-18T19:47:34Z"}, "message": "Emit the right types for vtable pointers when dropping dyn*", "tree": {"sha": "8e52bf332c85bbd823b3b2650a3f1e4e747c0790", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e52bf332c85bbd823b3b2650a3f1e4e747c0790"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f798c2b216db0bb7ebeb9dd863fbdf7668094c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f798c2b216db0bb7ebeb9dd863fbdf7668094c5", "html_url": "https://github.com/rust-lang/rust/commit/7f798c2b216db0bb7ebeb9dd863fbdf7668094c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f798c2b216db0bb7ebeb9dd863fbdf7668094c5/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e82cc656c822af7f1905b757a27cac5823fbc301", "url": "https://api.github.com/repos/rust-lang/rust/commits/e82cc656c822af7f1905b757a27cac5823fbc301", "html_url": "https://github.com/rust-lang/rust/commit/e82cc656c822af7f1905b757a27cac5823fbc301"}], "stats": {"total": 158, "additions": 78, "deletions": 80}, "files": [{"sha": "daaa4de1a7c8eb0e00a5d0f8248984d6bccdc31e", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 78, "deletions": 80, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/7f798c2b216db0bb7ebeb9dd863fbdf7668094c5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f798c2b216db0bb7ebeb9dd863fbdf7668094c5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=7f798c2b216db0bb7ebeb9dd863fbdf7668094c5", "patch": "@@ -452,86 +452,84 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             args1 = [place.llval];\n             &args1[..]\n         };\n-        let (drop_fn, fn_abi) = match ty.kind() {\n-            // FIXME(eddyb) perhaps move some of this logic into\n-            // `Instance::resolve_drop_in_place`?\n-            ty::Dynamic(_, _, ty::Dyn) => {\n-                // IN THIS ARM, WE HAVE:\n-                // ty = *mut (dyn Trait)\n-                // which is: exists<T> ( *mut T,    Vtable<T: Trait> )\n-                //                       args[0]    args[1]\n-                //\n-                // args = ( Data, Vtable )\n-                //                  |\n-                //                  v\n-                //                /-------\\\n-                //                | ...   |\n-                //                \\-------/\n-                //\n-                let virtual_drop = Instance {\n-                    def: ty::InstanceDef::Virtual(drop_fn.def_id(), 0),\n-                    substs: drop_fn.substs,\n-                };\n-                debug!(\"ty = {:?}\", ty);\n-                debug!(\"drop_fn = {:?}\", drop_fn);\n-                debug!(\"args = {:?}\", args);\n-                let fn_abi = bx.fn_abi_of_instance(virtual_drop, ty::List::empty());\n-                let vtable = args[1];\n-                // Truncate vtable off of args list\n-                args = &args[..1];\n-                (\n-                    meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_DROPINPLACE)\n-                        .get_fn(bx, vtable, ty, &fn_abi),\n-                    fn_abi,\n-                )\n-            }\n-            ty::Dynamic(_, _, ty::DynStar) => {\n-                // IN THIS ARM, WE HAVE:\n-                // ty = *mut (dyn* Trait)\n-                // which is: *mut exists<T: sizeof(T) == sizeof(usize)> (T, Vtable<T: Trait>)\n-                //\n-                // args = [ * ]\n-                //          |\n-                //          v\n-                //      ( Data, Vtable )\n-                //                |\n-                //                v\n-                //              /-------\\\n-                //              | ...   |\n-                //              \\-------/\n-                //\n-                //\n-                // WE CAN CONVERT THIS INTO THE ABOVE LOGIC BY DOING\n-                //\n-                // data = &(*args[0]).0    // gives a pointer to Data above (really the same pointer)\n-                // vtable = (*args[0]).1   // loads the vtable out\n-                // (data, vtable)          // an equivalent Rust `*mut dyn Trait`\n-                //\n-                // SO THEN WE CAN USE THE ABOVE CODE.\n-                let virtual_drop = Instance {\n-                    def: ty::InstanceDef::Virtual(drop_fn.def_id(), 0),\n-                    substs: drop_fn.substs,\n-                };\n-                debug!(\"ty = {:?}\", ty);\n-                debug!(\"drop_fn = {:?}\", drop_fn);\n-                debug!(\"args = {:?}\", args);\n-                let fn_abi = bx.fn_abi_of_instance(virtual_drop, ty::List::empty());\n-                let data = args[0];\n-                let data_ty = bx.cx().backend_type(place.layout);\n-                let vtable_ptr =\n-                    bx.gep(data_ty, data, &[bx.cx().const_i32(0), bx.cx().const_i32(1)]);\n-                let vtable = bx.load(bx.type_i8p(), vtable_ptr, abi::Align::ONE);\n-                // Truncate vtable off of args list\n-                args = &args[..1];\n-                debug!(\"args' = {:?}\", args);\n-                (\n-                    meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_DROPINPLACE)\n-                        .get_fn(bx, vtable, ty, &fn_abi),\n-                    fn_abi,\n-                )\n-            }\n-            _ => (bx.get_fn_addr(drop_fn), bx.fn_abi_of_instance(drop_fn, ty::List::empty())),\n-        };\n+        let (drop_fn, fn_abi) =\n+            match ty.kind() {\n+                // FIXME(eddyb) perhaps move some of this logic into\n+                // `Instance::resolve_drop_in_place`?\n+                ty::Dynamic(_, _, ty::Dyn) => {\n+                    // IN THIS ARM, WE HAVE:\n+                    // ty = *mut (dyn Trait)\n+                    // which is: exists<T> ( *mut T,    Vtable<T: Trait> )\n+                    //                       args[0]    args[1]\n+                    //\n+                    // args = ( Data, Vtable )\n+                    //                  |\n+                    //                  v\n+                    //                /-------\\\n+                    //                | ...   |\n+                    //                \\-------/\n+                    //\n+                    let virtual_drop = Instance {\n+                        def: ty::InstanceDef::Virtual(drop_fn.def_id(), 0),\n+                        substs: drop_fn.substs,\n+                    };\n+                    debug!(\"ty = {:?}\", ty);\n+                    debug!(\"drop_fn = {:?}\", drop_fn);\n+                    debug!(\"args = {:?}\", args);\n+                    let fn_abi = bx.fn_abi_of_instance(virtual_drop, ty::List::empty());\n+                    let vtable = args[1];\n+                    // Truncate vtable off of args list\n+                    args = &args[..1];\n+                    (\n+                        meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_DROPINPLACE)\n+                            .get_fn(bx, vtable, ty, &fn_abi),\n+                        fn_abi,\n+                    )\n+                }\n+                ty::Dynamic(_, _, ty::DynStar) => {\n+                    // IN THIS ARM, WE HAVE:\n+                    // ty = *mut (dyn* Trait)\n+                    // which is: *mut exists<T: sizeof(T) == sizeof(usize)> (T, Vtable<T: Trait>)\n+                    //\n+                    // args = [ * ]\n+                    //          |\n+                    //          v\n+                    //      ( Data, Vtable )\n+                    //                |\n+                    //                v\n+                    //              /-------\\\n+                    //              | ...   |\n+                    //              \\-------/\n+                    //\n+                    //\n+                    // WE CAN CONVERT THIS INTO THE ABOVE LOGIC BY DOING\n+                    //\n+                    // data = &(*args[0]).0    // gives a pointer to Data above (really the same pointer)\n+                    // vtable = (*args[0]).1   // loads the vtable out\n+                    // (data, vtable)          // an equivalent Rust `*mut dyn Trait`\n+                    //\n+                    // SO THEN WE CAN USE THE ABOVE CODE.\n+                    let virtual_drop = Instance {\n+                        def: ty::InstanceDef::Virtual(drop_fn.def_id(), 0),\n+                        substs: drop_fn.substs,\n+                    };\n+                    debug!(\"ty = {:?}\", ty);\n+                    debug!(\"drop_fn = {:?}\", drop_fn);\n+                    debug!(\"args = {:?}\", args);\n+                    let fn_abi = bx.fn_abi_of_instance(virtual_drop, ty::List::empty());\n+                    let meta_ptr = place.project_field(bx, 1);\n+                    let meta = bx.load_operand(meta_ptr);\n+                    // Truncate vtable off of args list\n+                    args = &args[..1];\n+                    debug!(\"args' = {:?}\", args);\n+                    (\n+                        meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_DROPINPLACE)\n+                            .get_fn(bx, meta.immediate(), ty, &fn_abi),\n+                        fn_abi,\n+                    )\n+                }\n+                _ => (bx.get_fn_addr(drop_fn), bx.fn_abi_of_instance(drop_fn, ty::List::empty())),\n+            };\n         helper.do_call(\n             self,\n             bx,"}]}