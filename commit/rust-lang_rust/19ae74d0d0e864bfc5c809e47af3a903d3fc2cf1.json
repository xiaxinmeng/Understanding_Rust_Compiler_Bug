{"sha": "19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5YWU3NGQwZDBlODY0YmZjNWM4MDllNDdhZjNhOTAzZDNmYzJjZjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-02T00:21:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-02T00:21:39Z"}, "message": "Auto merge of #71776 - Dylan-DPC:rollup-k1iuuow, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #71018 (handle ConstValue::ByRef in relate)\n - #71758 (Remove leftover chalk types)\n - #71760 (Document unsafety for `*const T` and `*mut T`)\n - #71761 (doc: reference does not exist, probably a typo)\n - #71762 (doc: this resulted in a link pointing to a non-existent target)\n\nFailed merges:\n\n - #71726 (Suggest deref when coercing `ty::Ref` to `ty::RawPtr` with arbitrary mutability)\n\nr? @ghost", "tree": {"sha": "af132f2126a042b46fd94246bc0245eadec2456e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af132f2126a042b46fd94246bc0245eadec2456e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "html_url": "https://github.com/rust-lang/rust/commit/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dba944a6b79caf0056ddd282de01de70a0ff8a36", "url": "https://api.github.com/repos/rust-lang/rust/commits/dba944a6b79caf0056ddd282de01de70a0ff8a36", "html_url": "https://github.com/rust-lang/rust/commit/dba944a6b79caf0056ddd282de01de70a0ff8a36"}, {"sha": "f2fddd35af266483bb493f130ce2e0559f6593af", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2fddd35af266483bb493f130ce2e0559f6593af", "html_url": "https://github.com/rust-lang/rust/commit/f2fddd35af266483bb493f130ce2e0559f6593af"}], "stats": {"total": 1882, "additions": 105, "deletions": 1777}, "files": [{"sha": "94ad77d1ec683defe1a130aa400fc63df2ea6118", "filename": "src/libcore/ptr/const_ptr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fconst_ptr.rs?ref=19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "patch": "@@ -3,8 +3,6 @@ use crate::cmp::Ordering::{self, Equal, Greater, Less};\n use crate::intrinsics;\n use crate::mem;\n \n-// ignore-tidy-undocumented-unsafe\n-\n #[lang = \"const_ptr\"]\n impl<T: ?Sized> *const T {\n     /// Returns `true` if the pointer is null.\n@@ -215,6 +213,7 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n+        // SAFETY: the `arith_offset` intrinsic has no prerequisites to be called.\n         unsafe { intrinsics::arith_offset(self, count) }\n     }\n \n@@ -702,6 +701,7 @@ impl<T: ?Sized> *const T {\n         if !align.is_power_of_two() {\n             panic!(\"align_offset: align is not a power-of-two\");\n         }\n+        // SAFETY: `align` has been checked to be a power of 2 above\n         unsafe { align_offset(self, align) }\n     }\n }\n@@ -729,6 +729,8 @@ impl<T> *const [T] {\n     #[unstable(feature = \"slice_ptr_len\", issue = \"71146\")]\n     #[rustc_const_unstable(feature = \"const_slice_ptr_len\", issue = \"71146\")]\n     pub const fn len(self) -> usize {\n+        // SAFETY: this is safe because `*const [T]` and `FatPtr<T>` have the same layout.\n+        // Only `std` can make this guarantee.\n         unsafe { Repr { rust: self }.raw }.len\n     }\n }"}, {"sha": "cf9e20aa56941a6f27a331610c3a59b94e645d60", "filename": "src/libcore/ptr/mut_ptr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmut_ptr.rs?ref=19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "patch": "@@ -2,8 +2,6 @@ use super::*;\n use crate::cmp::Ordering::{self, Equal, Greater, Less};\n use crate::intrinsics;\n \n-// ignore-tidy-undocumented-unsafe\n-\n #[lang = \"mut_ptr\"]\n impl<T: ?Sized> *mut T {\n     /// Returns `true` if the pointer is null.\n@@ -208,6 +206,7 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n+        // SAFETY: the `arith_offset` intrinsic has no prerequisites to be called.\n         unsafe { intrinsics::arith_offset(self, count) as *mut T }\n     }\n \n@@ -890,6 +889,7 @@ impl<T: ?Sized> *mut T {\n         if !align.is_power_of_two() {\n             panic!(\"align_offset: align is not a power-of-two\");\n         }\n+        // SAFETY: `align` has been checked to be a power of 2 above\n         unsafe { align_offset(self, align) }\n     }\n }\n@@ -917,6 +917,8 @@ impl<T> *mut [T] {\n     #[unstable(feature = \"slice_ptr_len\", issue = \"71146\")]\n     #[rustc_const_unstable(feature = \"const_slice_ptr_len\", issue = \"71146\")]\n     pub const fn len(self) -> usize {\n+        // SAFETY: this is safe because `*const [T]` and `FatPtr<T>` have the same layout.\n+        // Only `std` can make this guarantee.\n         unsafe { Repr { rust_mut: self }.raw }.len\n     }\n }"}, {"sha": "c63bbd53a3148da4763795452ead496640124392", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "patch": "@@ -14,9 +14,9 @@\n //! - [`Generics`], [`GenericParam`], [`WhereClause`]: Metadata associated with generic parameters.\n //! - [`EnumDef`] and [`Variant`]: Enum declaration.\n //! - [`Lit`] and [`LitKind`]: Literal expressions.\n-//! - [`MacroDef`], [`MacStmtStyle`], [`MacCall`], [`MacDelimeter`]: Macro definition and invocation.\n+//! - [`MacroDef`], [`MacStmtStyle`], [`MacCall`], [`MacDelimiter`]: Macro definition and invocation.\n //! - [`Attribute`]: Metadata associated with item.\n-//! - [`UnOp`], [`UnOpKind`], [`BinOp`], [`BinOpKind`]: Unary and binary operators.\n+//! - [`UnOp`], [`BinOp`], and [`BinOpKind`]: Unary and binary operators.\n \n pub use crate::util::parser::ExprPrecedence;\n pub use GenericArgs::*;"}, {"sha": "d44b8f554143c3f70fa7d7f842fcd2d32947f636", "filename": "src/librustc_infer/infer/at.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_infer%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_infer%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fat.rs?ref=19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "patch": "@@ -186,7 +186,6 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n impl<'a, 'tcx> Trace<'a, 'tcx> {\n     /// Makes `a <: b` where `a` may or may not be expected (if\n     /// `a_is_expected` is true, then `a` is expected).\n-    /// Makes `expected <: actual`.\n     pub fn sub<T>(self, a: &T, b: &T) -> InferResult<'tcx, ()>\n     where\n         T: Relate<'tcx>,"}, {"sha": "9fe7ebf58b3431c08908cf4ab0d566f6dd677731", "filename": "src/librustc_infer/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs?ref=19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "patch": "@@ -16,7 +16,7 @@ use crate::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelating\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n use crate::infer::{InferCtxt, InferOk, InferResult, NLLRegionVariableOrigin};\n use crate::traits::query::{Fallible, NoSolution};\n-use crate::traits::{DomainGoal, TraitEngine};\n+use crate::traits::TraitEngine;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n@@ -671,10 +671,6 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         });\n     }\n \n-    fn push_domain_goal(&mut self, _: DomainGoal<'tcx>) {\n-        bug!(\"should never be invoked with eager normalization\")\n-    }\n-\n     fn normalization() -> NormalizationStrategy {\n         NormalizationStrategy::Eager\n     }"}, {"sha": "0fb926d94166abe3154b03dc3da0adb518b44e39", "filename": "src/librustc_infer/infer/nll_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs?ref=19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "patch": "@@ -23,7 +23,6 @@\n \n use crate::infer::InferCtxt;\n use crate::infer::{ConstVarValue, ConstVariableValue};\n-use crate::traits::DomainGoal;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::{TypeFoldable, TypeVisitor};\n@@ -78,10 +77,6 @@ pub trait TypeRelatingDelegate<'tcx> {\n     /// delegate.\n     fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>);\n \n-    /// Push a domain goal that will need to be proved for the two types to\n-    /// be related. Used for lazy normalization.\n-    fn push_domain_goal(&mut self, domain_goal: DomainGoal<'tcx>);\n-\n     /// Creates a new universe index. Used when instantiating placeholders.\n     fn create_next_universe(&mut self) -> ty::UniverseIndex;\n \n@@ -265,7 +260,6 @@ where\n         value_ty: Ty<'tcx>,\n     ) -> Ty<'tcx> {\n         use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-        use crate::traits::WhereClause;\n         use rustc_span::DUMMY_SP;\n \n         match value_ty.kind {\n@@ -279,12 +273,7 @@ where\n                 var\n             }\n \n-            _ => {\n-                let projection = ty::ProjectionPredicate { projection_ty, ty: value_ty };\n-                self.delegate\n-                    .push_domain_goal(DomainGoal::Holds(WhereClause::ProjectionEq(projection)));\n-                value_ty\n-            }\n+            _ => bug!(\"should never be invoked with eager normalization\"),\n         }\n     }\n "}, {"sha": "7b96d8df12da193ad70050af5f10729299a292ce", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "patch": "@@ -838,10 +838,6 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n         tcx.par_body_owners(|def_id| tcx.ensure().mir_borrowck(def_id));\n     });\n \n-    sess.time(\"dumping_chalk_like_clauses\", || {\n-        rustc_traits::lowering::dump_program_clauses(tcx);\n-    });\n-\n     sess.time(\"MIR_effect_checking\", || {\n         for def_id in tcx.body_owners() {\n             mir::transform::check_unsafety::check_unsafety(tcx, def_id.to_def_id())"}, {"sha": "19b85aa3c519e8fa1ecb42d92a2b6713a388755e", "filename": "src/librustc_middle/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs?ref=19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "patch": "@@ -51,7 +51,6 @@\n \n use crate::mir;\n use crate::mir::interpret::{GlobalId, LitToConstInput};\n-use crate::traits;\n use crate::traits::query::{\n     CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,\n     CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpNormalizeGoal,"}, {"sha": "b0c442381484c11f244206e628856ecd234bad7b", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "patch": "@@ -1,7 +1,6 @@\n use crate::dep_graph::SerializedDepNodeIndex;\n use crate::mir;\n use crate::mir::interpret::{GlobalId, LitToConstInput};\n-use crate::traits;\n use crate::traits::query::{\n     CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,\n     CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpNormalizeGoal,\n@@ -224,19 +223,6 @@ rustc_queries! {\n             anon\n             desc { \"erasing regions from `{:?}`\", ty }\n         }\n-\n-        query program_clauses_for(_: DefId) -> Clauses<'tcx> {\n-            desc { \"generating chalk-style clauses\" }\n-        }\n-\n-        query program_clauses_for_env(_: traits::Environment<'tcx>) -> Clauses<'tcx> {\n-            desc { \"generating chalk-style clauses for environment\" }\n-        }\n-\n-        // Get the chalk-style environment of the given item.\n-        query environment(_: DefId) -> traits::Environment<'tcx> {\n-            desc { \"return a chalk-style environment\" }\n-        }\n     }\n \n     Linking {"}, {"sha": "d6989fd8e4e57378750d872e92f968563480b1f3", "filename": "src/librustc_middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 157, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fmod.rs?ref=19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "patch": "@@ -9,7 +9,7 @@ mod structural_impls;\n \n use crate::mir::interpret::ErrorHandled;\n use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, AdtKind, List, Ty, TyCtxt};\n+use crate::ty::{self, AdtKind, Ty, TyCtxt};\n \n use rustc_ast::ast;\n use rustc_hir as hir;\n@@ -307,162 +307,6 @@ pub struct DerivedObligationCause<'tcx> {\n     pub parent_code: Rc<ObligationCauseCode<'tcx>>,\n }\n \n-/// The following types:\n-/// * `WhereClause`,\n-/// * `WellFormed`,\n-/// * `FromEnv`,\n-/// * `DomainGoal`,\n-/// * `Goal`,\n-/// * `Clause`,\n-/// * `Environment`,\n-/// * `InEnvironment`,\n-/// are used for representing the trait system in the form of\n-/// logic programming clauses. They are part of the interface\n-/// for the chalk SLG solver.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum WhereClause<'tcx> {\n-    Implemented(ty::TraitPredicate<'tcx>),\n-    ProjectionEq(ty::ProjectionPredicate<'tcx>),\n-    RegionOutlives(ty::RegionOutlivesPredicate<'tcx>),\n-    TypeOutlives(ty::TypeOutlivesPredicate<'tcx>),\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum WellFormed<'tcx> {\n-    Trait(ty::TraitPredicate<'tcx>),\n-    Ty(Ty<'tcx>),\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum FromEnv<'tcx> {\n-    Trait(ty::TraitPredicate<'tcx>),\n-    Ty(Ty<'tcx>),\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum DomainGoal<'tcx> {\n-    Holds(WhereClause<'tcx>),\n-    WellFormed(WellFormed<'tcx>),\n-    FromEnv(FromEnv<'tcx>),\n-    Normalize(ty::ProjectionPredicate<'tcx>),\n-}\n-\n-pub type PolyDomainGoal<'tcx> = ty::Binder<DomainGoal<'tcx>>;\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n-pub enum QuantifierKind {\n-    Universal,\n-    Existential,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum GoalKind<'tcx> {\n-    Implies(Clauses<'tcx>, Goal<'tcx>),\n-    And(Goal<'tcx>, Goal<'tcx>),\n-    Not(Goal<'tcx>),\n-    DomainGoal(DomainGoal<'tcx>),\n-    Quantified(QuantifierKind, ty::Binder<Goal<'tcx>>),\n-    Subtype(Ty<'tcx>, Ty<'tcx>),\n-    CannotProve,\n-}\n-\n-pub type Goal<'tcx> = &'tcx GoalKind<'tcx>;\n-\n-pub type Goals<'tcx> = &'tcx List<Goal<'tcx>>;\n-\n-impl<'tcx> DomainGoal<'tcx> {\n-    pub fn into_goal(self) -> GoalKind<'tcx> {\n-        GoalKind::DomainGoal(self)\n-    }\n-\n-    pub fn into_program_clause(self) -> ProgramClause<'tcx> {\n-        ProgramClause {\n-            goal: self,\n-            hypotheses: ty::List::empty(),\n-            category: ProgramClauseCategory::Other,\n-        }\n-    }\n-}\n-\n-impl<'tcx> GoalKind<'tcx> {\n-    pub fn from_poly_domain_goal(\n-        domain_goal: PolyDomainGoal<'tcx>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> GoalKind<'tcx> {\n-        match domain_goal.no_bound_vars() {\n-            Some(p) => p.into_goal(),\n-            None => GoalKind::Quantified(\n-                QuantifierKind::Universal,\n-                domain_goal.map_bound(|p| tcx.mk_goal(p.into_goal())),\n-            ),\n-        }\n-    }\n-}\n-\n-/// This matches the definition from Page 7 of \"A Proof Procedure for the Logic of Hereditary\n-/// Harrop Formulas\".\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n-pub enum Clause<'tcx> {\n-    Implies(ProgramClause<'tcx>),\n-    ForAll(ty::Binder<ProgramClause<'tcx>>),\n-}\n-\n-impl Clause<'tcx> {\n-    pub fn category(self) -> ProgramClauseCategory {\n-        match self {\n-            Clause::Implies(clause) => clause.category,\n-            Clause::ForAll(clause) => clause.skip_binder().category,\n-        }\n-    }\n-}\n-\n-/// Multiple clauses.\n-pub type Clauses<'tcx> = &'tcx List<Clause<'tcx>>;\n-\n-/// A \"program clause\" has the form `D :- G1, ..., Gn`. It is saying\n-/// that the domain goal `D` is true if `G1...Gn` are provable. This\n-/// is equivalent to the implication `G1..Gn => D`; we usually write\n-/// it with the reverse implication operator `:-` to emphasize the way\n-/// that programs are actually solved (via backchaining, which starts\n-/// with the goal to solve and proceeds from there).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n-pub struct ProgramClause<'tcx> {\n-    /// This goal will be considered true ...\n-    pub goal: DomainGoal<'tcx>,\n-\n-    /// ... if we can prove these hypotheses (there may be no hypotheses at all):\n-    pub hypotheses: Goals<'tcx>,\n-\n-    /// Useful for filtering clauses.\n-    pub category: ProgramClauseCategory,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n-pub enum ProgramClauseCategory {\n-    ImpliedBound,\n-    WellFormed,\n-    Other,\n-}\n-\n-/// A set of clauses that we assume to be true.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n-pub struct Environment<'tcx> {\n-    pub clauses: Clauses<'tcx>,\n-}\n-\n-impl Environment<'tcx> {\n-    pub fn with<G>(self, goal: G) -> InEnvironment<'tcx, G> {\n-        InEnvironment { environment: self, goal }\n-    }\n-}\n-\n-/// Something (usually a goal), along with an environment.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n-pub struct InEnvironment<'tcx, G> {\n-    pub environment: Environment<'tcx>,\n-    pub goal: G,\n-}\n-\n #[derive(Clone, Debug, TypeFoldable)]\n pub enum SelectionError<'tcx> {\n     Unimplemented,"}, {"sha": "69a5213d3e4a5c62804edbad7f8492e10f4d0674", "filename": "src/librustc_middle/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 354, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs?ref=19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "patch": "@@ -1,10 +1,6 @@\n use crate::traits;\n-use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use crate::ty::{self, Lift, Ty, TyCtxt};\n-use rustc_span::symbol::Symbol;\n-use smallvec::SmallVec;\n+use crate::ty::{Lift, TyCtxt};\n \n-use std::collections::{BTreeMap, BTreeSet};\n use std::fmt;\n use std::rc::Rc;\n \n@@ -106,295 +102,6 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableTraitAliasData<'tcx, N> {\n     }\n }\n \n-impl<'tcx> fmt::Display for traits::WhereClause<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::WhereClause::*;\n-\n-        // Bypass `ty::print` because it does not print out anonymous regions.\n-        // FIXME(eddyb) implement a custom `PrettyPrinter`, or move this to `ty::print`.\n-        fn write_region_name<'tcx>(\n-            r: ty::Region<'tcx>,\n-            fmt: &mut fmt::Formatter<'_>,\n-        ) -> fmt::Result {\n-            match r {\n-                ty::ReLateBound(index, br) => match br {\n-                    ty::BoundRegion::BrNamed(_, name) => write!(fmt, \"{}\", name),\n-                    ty::BoundRegion::BrAnon(var) => {\n-                        if *index == ty::INNERMOST {\n-                            write!(fmt, \"'^{}\", var)\n-                        } else {\n-                            write!(fmt, \"'^{}_{}\", index.index(), var)\n-                        }\n-                    }\n-                    _ => write!(fmt, \"'_\"),\n-                },\n-\n-                _ => write!(fmt, \"{}\", r),\n-            }\n-        }\n-\n-        match self {\n-            Implemented(trait_ref) => write!(fmt, \"Implemented({})\", trait_ref),\n-            ProjectionEq(projection) => write!(fmt, \"ProjectionEq({})\", projection),\n-            RegionOutlives(predicate) => {\n-                write!(fmt, \"RegionOutlives({}: \", predicate.0)?;\n-                write_region_name(predicate.1, fmt)?;\n-                write!(fmt, \")\")\n-            }\n-            TypeOutlives(predicate) => {\n-                write!(fmt, \"TypeOutlives({}: \", predicate.0)?;\n-                write_region_name(predicate.1, fmt)?;\n-                write!(fmt, \")\")\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::WellFormed<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::WellFormed::*;\n-\n-        match self {\n-            Trait(trait_ref) => write!(fmt, \"WellFormed({})\", trait_ref),\n-            Ty(ty) => write!(fmt, \"WellFormed({})\", ty),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::FromEnv<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::FromEnv::*;\n-\n-        match self {\n-            Trait(trait_ref) => write!(fmt, \"FromEnv({})\", trait_ref),\n-            Ty(ty) => write!(fmt, \"FromEnv({})\", ty),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::DomainGoal<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::DomainGoal::*;\n-\n-        match self {\n-            Holds(wc) => write!(fmt, \"{}\", wc),\n-            WellFormed(wf) => write!(fmt, \"{}\", wf),\n-            FromEnv(from_env) => write!(fmt, \"{}\", from_env),\n-            Normalize(projection) => {\n-                write!(fmt, \"Normalize({} -> {})\", projection.projection_ty, projection.ty)\n-            }\n-        }\n-    }\n-}\n-\n-impl fmt::Display for traits::QuantifierKind {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::QuantifierKind::*;\n-\n-        match self {\n-            Universal => write!(fmt, \"forall\"),\n-            Existential => write!(fmt, \"exists\"),\n-        }\n-    }\n-}\n-\n-/// Collect names for regions / types bound by a quantified goal / clause.\n-/// This collector does not try to do anything clever like in `ty::print`, it's just used\n-/// for debug output in tests anyway.\n-struct BoundNamesCollector {\n-    // Just sort by name because `BoundRegion::BrNamed` does not have a `BoundVar` index anyway.\n-    regions: BTreeSet<Symbol>,\n-\n-    // Sort by `BoundVar` index, so usually this should be equivalent to the order given\n-    // by the list of type parameters.\n-    types: BTreeMap<u32, Symbol>,\n-\n-    binder_index: ty::DebruijnIndex,\n-}\n-\n-impl BoundNamesCollector {\n-    fn new() -> Self {\n-        BoundNamesCollector {\n-            regions: BTreeSet::new(),\n-            types: BTreeMap::new(),\n-            binder_index: ty::INNERMOST,\n-        }\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.regions.is_empty() && self.types.is_empty()\n-    }\n-\n-    fn write_names(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut start = true;\n-        for r in &self.regions {\n-            if !start {\n-                write!(fmt, \", \")?;\n-            }\n-            start = false;\n-            write!(fmt, \"{}\", r)?;\n-        }\n-        for t in self.types.values() {\n-            if !start {\n-                write!(fmt, \", \")?;\n-            }\n-            start = false;\n-            write!(fmt, \"{}\", t)?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl<'tcx> TypeVisitor<'tcx> for BoundNamesCollector {\n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n-        self.binder_index.shift_in(1);\n-        let result = t.super_visit_with(self);\n-        self.binder_index.shift_out(1);\n-        result\n-    }\n-\n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n-        match t.kind {\n-            ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n-                self.types.insert(\n-                    bound_ty.var.as_u32(),\n-                    match bound_ty.kind {\n-                        ty::BoundTyKind::Param(name) => name,\n-                        ty::BoundTyKind::Anon => {\n-                            Symbol::intern(&format!(\"^{}\", bound_ty.var.as_u32()))\n-                        }\n-                    },\n-                );\n-            }\n-\n-            _ => (),\n-        };\n-\n-        t.super_visit_with(self)\n-    }\n-\n-    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n-        match c.val {\n-            ty::ConstKind::Bound(debruijn, bound_var) if debruijn == self.binder_index => {\n-                self.types.insert(\n-                    bound_var.as_u32(),\n-                    Symbol::intern(&format!(\"^{}\", bound_var.as_u32())),\n-                );\n-            }\n-            _ => (),\n-        }\n-\n-        c.super_visit_with(self)\n-    }\n-\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n-        match r {\n-            ty::ReLateBound(index, br) if *index == self.binder_index => match br {\n-                ty::BoundRegion::BrNamed(_, name) => {\n-                    self.regions.insert(*name);\n-                }\n-\n-                ty::BoundRegion::BrAnon(var) => {\n-                    self.regions.insert(Symbol::intern(&format!(\"'^{}\", var)));\n-                }\n-\n-                _ => (),\n-            },\n-\n-            _ => (),\n-        };\n-\n-        r.super_visit_with(self)\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::Goal<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::GoalKind::*;\n-\n-        match self {\n-            Implies(hypotheses, goal) => {\n-                write!(fmt, \"if (\")?;\n-                for (index, hyp) in hypotheses.iter().enumerate() {\n-                    if index > 0 {\n-                        write!(fmt, \", \")?;\n-                    }\n-                    write!(fmt, \"{}\", hyp)?;\n-                }\n-                write!(fmt, \") {{ {} }}\", goal)\n-            }\n-            And(goal1, goal2) => write!(fmt, \"({} && {})\", goal1, goal2),\n-            Not(goal) => write!(fmt, \"not {{ {} }}\", goal),\n-            DomainGoal(goal) => write!(fmt, \"{}\", goal),\n-            Quantified(qkind, goal) => {\n-                let mut collector = BoundNamesCollector::new();\n-                goal.skip_binder().visit_with(&mut collector);\n-\n-                if !collector.is_empty() {\n-                    write!(fmt, \"{}<\", qkind)?;\n-                    collector.write_names(fmt)?;\n-                    write!(fmt, \"> {{ \")?;\n-                }\n-\n-                write!(fmt, \"{}\", goal.skip_binder())?;\n-\n-                if !collector.is_empty() {\n-                    write!(fmt, \" }}\")?;\n-                }\n-\n-                Ok(())\n-            }\n-            Subtype(a, b) => write!(fmt, \"{} <: {}\", a, b),\n-            CannotProve => write!(fmt, \"CannotProve\"),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::ProgramClause<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let traits::ProgramClause { goal, hypotheses, .. } = self;\n-        write!(fmt, \"{}\", goal)?;\n-        if !hypotheses.is_empty() {\n-            write!(fmt, \" :- \")?;\n-            for (index, condition) in hypotheses.iter().enumerate() {\n-                if index > 0 {\n-                    write!(fmt, \", \")?;\n-                }\n-                write!(fmt, \"{}\", condition)?;\n-            }\n-        }\n-        write!(fmt, \".\")\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::Clause<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::Clause::*;\n-\n-        match self {\n-            Implies(clause) => write!(fmt, \"{}\", clause),\n-            ForAll(clause) => {\n-                let mut collector = BoundNamesCollector::new();\n-                clause.skip_binder().visit_with(&mut collector);\n-\n-                if !collector.is_empty() {\n-                    write!(fmt, \"forall<\")?;\n-                    collector.write_names(fmt)?;\n-                    write!(fmt, \"> {{ \")?;\n-                }\n-\n-                write!(fmt, \"{}\", clause.skip_binder())?;\n-\n-                if !collector.is_empty() {\n-                    write!(fmt, \" }}\")?;\n-                }\n-\n-                Ok(())\n-            }\n-        }\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Lift implementations\n \n@@ -592,63 +299,3 @@ impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n         }\n     }\n }\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::Environment<'a> {\n-    type Lifted = traits::Environment<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.clauses).map(|clauses| traits::Environment { clauses })\n-    }\n-}\n-\n-impl<'a, 'tcx, G: Lift<'tcx>> Lift<'tcx> for traits::InEnvironment<'a, G> {\n-    type Lifted = traits::InEnvironment<'tcx, G::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.environment).and_then(|environment| {\n-            tcx.lift(&self.goal).map(|goal| traits::InEnvironment { environment, goal })\n-        })\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// TypeFoldable implementations.\n-\n-CloneTypeFoldableAndLiftImpls! {\n-    traits::QuantifierKind,\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<traits::Goal<'tcx>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n-        folder.tcx().intern_goals(&v)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for traits::Goal<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = (**self).fold_with(folder);\n-        folder.tcx().mk_goal(v)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        (**self).visit_with(visitor)\n-    }\n-}\n-\n-CloneTypeFoldableAndLiftImpls! {\n-    traits::ProgramClauseCategory,\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for traits::Clauses<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n-        folder.tcx().intern_clauses(&v)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n-    }\n-}"}, {"sha": "1999a32b3c65b8b083d170bfbf9ea84453deb6c2", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 1, "deletions": 51, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "patch": "@@ -16,7 +16,6 @@ use crate::middle::stability;\n use crate::mir::interpret::{Allocation, ConstValue, Scalar};\n use crate::mir::{interpret, Body, Field, Local, Place, PlaceElem, ProjectionKind, Promoted};\n use crate::traits;\n-use crate::traits::{Clause, Clauses, Goal, GoalKind, Goals};\n use crate::ty::query;\n use crate::ty::steal::Steal;\n use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n@@ -92,9 +91,6 @@ pub struct CtxtInterners<'tcx> {\n     region: InternedSet<'tcx, RegionKind>,\n     existential_predicates: InternedSet<'tcx, List<ExistentialPredicate<'tcx>>>,\n     predicates: InternedSet<'tcx, List<Predicate<'tcx>>>,\n-    clauses: InternedSet<'tcx, List<Clause<'tcx>>>,\n-    goal: InternedSet<'tcx, GoalKind<'tcx>>,\n-    goal_list: InternedSet<'tcx, List<Goal<'tcx>>>,\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n     place_elems: InternedSet<'tcx, List<PlaceElem<'tcx>>>,\n     const_: InternedSet<'tcx, Const<'tcx>>,\n@@ -111,9 +107,6 @@ impl<'tcx> CtxtInterners<'tcx> {\n             existential_predicates: Default::default(),\n             canonical_var_infos: Default::default(),\n             predicates: Default::default(),\n-            clauses: Default::default(),\n-            goal: Default::default(),\n-            goal_list: Default::default(),\n             projs: Default::default(),\n             place_elems: Default::default(),\n             const_: Default::default(),\n@@ -1573,11 +1566,8 @@ macro_rules! nop_list_lift {\n \n nop_lift! {type_; Ty<'a> => Ty<'tcx>}\n nop_lift! {region; Region<'a> => Region<'tcx>}\n-nop_lift! {goal; Goal<'a> => Goal<'tcx>}\n nop_lift! {const_; &'a Const<'a> => &'tcx Const<'tcx>}\n \n-nop_list_lift! {goal_list; Goal<'a> => Goal<'tcx>}\n-nop_list_lift! {clauses; Clause<'a> => Clause<'tcx>}\n nop_list_lift! {type_list; Ty<'a> => Ty<'tcx>}\n nop_list_lift! {existential_predicates; ExistentialPredicate<'a> => ExistentialPredicate<'tcx>}\n nop_list_lift! {predicates; Predicate<'a> => Predicate<'tcx>}\n@@ -1988,12 +1978,6 @@ impl<'tcx> Borrow<RegionKind> for Interned<'tcx, RegionKind> {\n     }\n }\n \n-impl<'tcx> Borrow<GoalKind<'tcx>> for Interned<'tcx, GoalKind<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a GoalKind<'tcx> {\n-        &self.0\n-    }\n-}\n-\n impl<'tcx> Borrow<[ExistentialPredicate<'tcx>]>\n     for Interned<'tcx, List<ExistentialPredicate<'tcx>>>\n {\n@@ -2014,18 +1998,6 @@ impl<'tcx> Borrow<Const<'tcx>> for Interned<'tcx, Const<'tcx>> {\n     }\n }\n \n-impl<'tcx> Borrow<[Clause<'tcx>]> for Interned<'tcx, List<Clause<'tcx>>> {\n-    fn borrow<'a>(&'a self) -> &'a [Clause<'tcx>] {\n-        &self.0[..]\n-    }\n-}\n-\n-impl<'tcx> Borrow<[Goal<'tcx>]> for Interned<'tcx, List<Goal<'tcx>>> {\n-    fn borrow<'a>(&'a self) -> &'a [Goal<'tcx>] {\n-        &self.0[..]\n-    }\n-}\n-\n macro_rules! direct_interners {\n     ($($name:ident: $method:ident($ty:ty)),+) => {\n         $(impl<'tcx> PartialEq for Interned<'tcx, $ty> {\n@@ -2052,11 +2024,7 @@ macro_rules! direct_interners {\n     }\n }\n \n-direct_interners!(\n-    region: mk_region(RegionKind),\n-    goal: mk_goal(GoalKind<'tcx>),\n-    const_: mk_const(Const<'tcx>)\n-);\n+direct_interners!(region: mk_region(RegionKind), const_: mk_const(Const<'tcx>));\n \n macro_rules! slice_interners {\n     ($($field:ident: $method:ident($ty:ty)),+) => (\n@@ -2076,8 +2044,6 @@ slice_interners!(\n     canonical_var_infos: _intern_canonical_var_infos(CanonicalVarInfo),\n     existential_predicates: _intern_existential_predicates(ExistentialPredicate<'tcx>),\n     predicates: _intern_predicates(Predicate<'tcx>),\n-    clauses: _intern_clauses(Clause<'tcx>),\n-    goal_list: _intern_goals(Goal<'tcx>),\n     projs: _intern_projs(ProjectionKind),\n     place_elems: _intern_place_elems(PlaceElem<'tcx>)\n );\n@@ -2465,14 +2431,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         if ts.is_empty() { List::empty() } else { self._intern_canonical_var_infos(ts) }\n     }\n \n-    pub fn intern_clauses(self, ts: &[Clause<'tcx>]) -> Clauses<'tcx> {\n-        if ts.is_empty() { List::empty() } else { self._intern_clauses(ts) }\n-    }\n-\n-    pub fn intern_goals(self, ts: &[Goal<'tcx>]) -> Goals<'tcx> {\n-        if ts.is_empty() { List::empty() } else { self._intern_goals(ts) }\n-    }\n-\n     pub fn mk_fn_sig<I>(\n         self,\n         inputs: I,\n@@ -2530,14 +2488,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_substs(iter::once(self_ty.into()).chain(rest.iter().cloned()))\n     }\n \n-    pub fn mk_clauses<I: InternAs<[Clause<'tcx>], Clauses<'tcx>>>(self, iter: I) -> I::Output {\n-        iter.intern_with(|xs| self.intern_clauses(xs))\n-    }\n-\n-    pub fn mk_goals<I: InternAs<[Goal<'tcx>], Goals<'tcx>>>(self, iter: I) -> I::Output {\n-        iter.intern_with(|xs| self.intern_goals(xs))\n-    }\n-\n     /// Walks upwards from `id` to find a node which might change lint levels with attributes.\n     /// It stops at `bound` and just returns it if reached.\n     pub fn maybe_lint_level_root_bounded(self, mut id: HirId, bound: HirId) -> HirId {"}, {"sha": "239691dbd17ac9de54f704d9511c758c6170fa6f", "filename": "src/librustc_middle/ty/query/keys.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_middle%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_middle%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fkeys.rs?ref=19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "patch": "@@ -2,7 +2,6 @@\n \n use crate::infer::canonical::Canonical;\n use crate::mir;\n-use crate::traits;\n use crate::ty::fast_reject::SimplifiedType;\n use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt};\n@@ -260,17 +259,6 @@ impl<'tcx, T: Key> Key for ty::ParamEnvAnd<'tcx, T> {\n     }\n }\n \n-impl<'tcx> Key for traits::Environment<'tcx> {\n-    type CacheSelector = DefaultCacheSelector;\n-\n-    fn query_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n-    }\n-    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n-        DUMMY_SP\n-    }\n-}\n-\n impl Key for Symbol {\n     type CacheSelector = DefaultCacheSelector;\n "}, {"sha": "e1a5a766ca15adc581a77389519dcad3a04f59fe", "filename": "src/librustc_middle/ty/query/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs?ref=19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "patch": "@@ -27,7 +27,6 @@ use crate::traits::query::{\n     OutlivesBound,\n };\n use crate::traits::specialization_graph;\n-use crate::traits::Clauses;\n use crate::traits::{self, Vtable};\n use crate::ty::steal::Steal;\n use crate::ty::subst::{GenericArg, SubstsRef};"}, {"sha": "faa74f81e818baf1e582129c9a304a841bc190ab", "filename": "src/librustc_middle/ty/relate.rs", "status": "modified", "additions": 34, "deletions": 226, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_middle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_middle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Frelate.rs?ref=19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "patch": "@@ -5,12 +5,12 @@\n //! subtyping, type equality, etc.\n \n use crate::mir::interpret::{get_slice_bytes, ConstValue};\n-use crate::traits;\n use crate::ty::error::{ExpectedFound, TypeError};\n use crate::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_hir as ast;\n use rustc_hir::def_id::DefId;\n+use rustc_span::DUMMY_SP;\n use rustc_target::spec::abi;\n use std::iter;\n use std::rc::Rc;\n@@ -507,6 +507,7 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n     a: &'tcx ty::Const<'tcx>,\n     b: &'tcx ty::Const<'tcx>,\n ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+    debug!(\"{}.super_relate_consts(a = {:?}, b = {:?})\", relation.tag(), a, b);\n     let tcx = relation.tcx();\n \n     let eagerly_eval = |x: &'tcx ty::Const<'tcx>| {\n@@ -561,7 +562,7 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n                     }\n                 }\n \n-                (a_val @ ConstValue::Slice { .. }, b_val @ ConstValue::Slice { .. }) => {\n+                (ConstValue::Slice { .. }, ConstValue::Slice { .. }) => {\n                     let a_bytes = get_slice_bytes(&tcx, a_val);\n                     let b_bytes = get_slice_bytes(&tcx, b_val);\n                     if a_bytes == b_bytes {\n@@ -571,7 +572,37 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n                     }\n                 }\n \n-                // FIXME(const_generics): handle `ConstValue::ByRef`.\n+                (ConstValue::ByRef { .. }, ConstValue::ByRef { .. }) => {\n+                    match a.ty.kind {\n+                        ty::Array(..) | ty::Adt(..) | ty::Tuple(..) => {\n+                            let a_destructured = tcx.destructure_const(relation.param_env().and(a));\n+                            let b_destructured = tcx.destructure_const(relation.param_env().and(b));\n+\n+                            // Both the variant and each field have to be equal.\n+                            if a_destructured.variant == b_destructured.variant {\n+                                for (a_field, b_field) in\n+                                    a_destructured.fields.iter().zip(b_destructured.fields.iter())\n+                                {\n+                                    relation.consts(a_field, b_field)?;\n+                                }\n+\n+                                Ok(a_val)\n+                            } else {\n+                                Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n+                            }\n+                        }\n+                        // FIXME(const_generics): There are probably some `TyKind`s\n+                        // which should be handled here.\n+                        _ => {\n+                            tcx.sess.delay_span_bug(\n+                                DUMMY_SP,\n+                                &format!(\"unexpected consts: a: {:?}, b: {:?}\", a, b),\n+                            );\n+                            Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n+                        }\n+                    }\n+                }\n+\n                 _ => Err(TypeError::ConstMismatch(expected_found(relation, &a, &b))),\n             };\n \n@@ -754,229 +785,6 @@ impl<'tcx> Relate<'tcx> for ty::ProjectionPredicate<'tcx> {\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for traits::WhereClause<'tcx> {\n-    fn relate<R: TypeRelation<'tcx>>(\n-        relation: &mut R,\n-        a: &traits::WhereClause<'tcx>,\n-        b: &traits::WhereClause<'tcx>,\n-    ) -> RelateResult<'tcx, traits::WhereClause<'tcx>> {\n-        use crate::traits::WhereClause::*;\n-        match (a, b) {\n-            (Implemented(a_pred), Implemented(b_pred)) => {\n-                Ok(Implemented(relation.relate(a_pred, b_pred)?))\n-            }\n-\n-            (ProjectionEq(a_pred), ProjectionEq(b_pred)) => {\n-                Ok(ProjectionEq(relation.relate(a_pred, b_pred)?))\n-            }\n-\n-            (RegionOutlives(a_pred), RegionOutlives(b_pred)) => {\n-                Ok(RegionOutlives(ty::OutlivesPredicate(\n-                    relation.relate(&a_pred.0, &b_pred.0)?,\n-                    relation.relate(&a_pred.1, &b_pred.1)?,\n-                )))\n-            }\n-\n-            (TypeOutlives(a_pred), TypeOutlives(b_pred)) => {\n-                Ok(TypeOutlives(ty::OutlivesPredicate(\n-                    relation.relate(&a_pred.0, &b_pred.0)?,\n-                    relation.relate(&a_pred.1, &b_pred.1)?,\n-                )))\n-            }\n-\n-            _ => Err(TypeError::Mismatch),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Relate<'tcx> for traits::WellFormed<'tcx> {\n-    fn relate<R: TypeRelation<'tcx>>(\n-        relation: &mut R,\n-        a: &traits::WellFormed<'tcx>,\n-        b: &traits::WellFormed<'tcx>,\n-    ) -> RelateResult<'tcx, traits::WellFormed<'tcx>> {\n-        use crate::traits::WellFormed::*;\n-        match (a, b) {\n-            (Trait(a_pred), Trait(b_pred)) => Ok(Trait(relation.relate(a_pred, b_pred)?)),\n-            (Ty(a_ty), Ty(b_ty)) => Ok(Ty(relation.relate(a_ty, b_ty)?)),\n-            _ => Err(TypeError::Mismatch),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Relate<'tcx> for traits::FromEnv<'tcx> {\n-    fn relate<R: TypeRelation<'tcx>>(\n-        relation: &mut R,\n-        a: &traits::FromEnv<'tcx>,\n-        b: &traits::FromEnv<'tcx>,\n-    ) -> RelateResult<'tcx, traits::FromEnv<'tcx>> {\n-        use crate::traits::FromEnv::*;\n-        match (a, b) {\n-            (Trait(a_pred), Trait(b_pred)) => Ok(Trait(relation.relate(a_pred, b_pred)?)),\n-            (Ty(a_ty), Ty(b_ty)) => Ok(Ty(relation.relate(a_ty, b_ty)?)),\n-            _ => Err(TypeError::Mismatch),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Relate<'tcx> for traits::DomainGoal<'tcx> {\n-    fn relate<R: TypeRelation<'tcx>>(\n-        relation: &mut R,\n-        a: &traits::DomainGoal<'tcx>,\n-        b: &traits::DomainGoal<'tcx>,\n-    ) -> RelateResult<'tcx, traits::DomainGoal<'tcx>> {\n-        use crate::traits::DomainGoal::*;\n-        match (a, b) {\n-            (Holds(a_wc), Holds(b_wc)) => Ok(Holds(relation.relate(a_wc, b_wc)?)),\n-            (WellFormed(a_wf), WellFormed(b_wf)) => Ok(WellFormed(relation.relate(a_wf, b_wf)?)),\n-            (FromEnv(a_fe), FromEnv(b_fe)) => Ok(FromEnv(relation.relate(a_fe, b_fe)?)),\n-\n-            (Normalize(a_pred), Normalize(b_pred)) => {\n-                Ok(Normalize(relation.relate(a_pred, b_pred)?))\n-            }\n-\n-            _ => Err(TypeError::Mismatch),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Relate<'tcx> for traits::Goal<'tcx> {\n-    fn relate<R: TypeRelation<'tcx>>(\n-        relation: &mut R,\n-        a: &traits::Goal<'tcx>,\n-        b: &traits::Goal<'tcx>,\n-    ) -> RelateResult<'tcx, traits::Goal<'tcx>> {\n-        use crate::traits::GoalKind::*;\n-        match (a, b) {\n-            (Implies(a_clauses, a_goal), Implies(b_clauses, b_goal)) => {\n-                let clauses = relation.relate(a_clauses, b_clauses)?;\n-                let goal = relation.relate(a_goal, b_goal)?;\n-                Ok(relation.tcx().mk_goal(Implies(clauses, goal)))\n-            }\n-\n-            (And(a_left, a_right), And(b_left, b_right)) => {\n-                let left = relation.relate(a_left, b_left)?;\n-                let right = relation.relate(a_right, b_right)?;\n-                Ok(relation.tcx().mk_goal(And(left, right)))\n-            }\n-\n-            (Not(a_goal), Not(b_goal)) => {\n-                let goal = relation.relate(a_goal, b_goal)?;\n-                Ok(relation.tcx().mk_goal(Not(goal)))\n-            }\n-\n-            (DomainGoal(a_goal), DomainGoal(b_goal)) => {\n-                let goal = relation.relate(a_goal, b_goal)?;\n-                Ok(relation.tcx().mk_goal(DomainGoal(goal)))\n-            }\n-\n-            (Quantified(a_qkind, a_goal), Quantified(b_qkind, b_goal)) if a_qkind == b_qkind => {\n-                let goal = relation.relate(a_goal, b_goal)?;\n-                Ok(relation.tcx().mk_goal(Quantified(*a_qkind, goal)))\n-            }\n-\n-            (CannotProve, CannotProve) => Ok(*a),\n-\n-            _ => Err(TypeError::Mismatch),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Relate<'tcx> for traits::Goals<'tcx> {\n-    fn relate<R: TypeRelation<'tcx>>(\n-        relation: &mut R,\n-        a: &traits::Goals<'tcx>,\n-        b: &traits::Goals<'tcx>,\n-    ) -> RelateResult<'tcx, traits::Goals<'tcx>> {\n-        if a.len() != b.len() {\n-            return Err(TypeError::Mismatch);\n-        }\n-\n-        let tcx = relation.tcx();\n-        let goals = a.iter().zip(b.iter()).map(|(a, b)| relation.relate(a, b));\n-        Ok(tcx.mk_goals(goals)?)\n-    }\n-}\n-\n-impl<'tcx> Relate<'tcx> for traits::Clause<'tcx> {\n-    fn relate<R: TypeRelation<'tcx>>(\n-        relation: &mut R,\n-        a: &traits::Clause<'tcx>,\n-        b: &traits::Clause<'tcx>,\n-    ) -> RelateResult<'tcx, traits::Clause<'tcx>> {\n-        use crate::traits::Clause::*;\n-        match (a, b) {\n-            (Implies(a_clause), Implies(b_clause)) => {\n-                let clause = relation.relate(a_clause, b_clause)?;\n-                Ok(Implies(clause))\n-            }\n-\n-            (ForAll(a_clause), ForAll(b_clause)) => {\n-                let clause = relation.relate(a_clause, b_clause)?;\n-                Ok(ForAll(clause))\n-            }\n-\n-            _ => Err(TypeError::Mismatch),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Relate<'tcx> for traits::Clauses<'tcx> {\n-    fn relate<R: TypeRelation<'tcx>>(\n-        relation: &mut R,\n-        a: &traits::Clauses<'tcx>,\n-        b: &traits::Clauses<'tcx>,\n-    ) -> RelateResult<'tcx, traits::Clauses<'tcx>> {\n-        if a.len() != b.len() {\n-            return Err(TypeError::Mismatch);\n-        }\n-\n-        let tcx = relation.tcx();\n-        let clauses = a.iter().zip(b.iter()).map(|(a, b)| relation.relate(a, b));\n-        Ok(tcx.mk_clauses(clauses)?)\n-    }\n-}\n-\n-impl<'tcx> Relate<'tcx> for traits::ProgramClause<'tcx> {\n-    fn relate<R: TypeRelation<'tcx>>(\n-        relation: &mut R,\n-        a: &traits::ProgramClause<'tcx>,\n-        b: &traits::ProgramClause<'tcx>,\n-    ) -> RelateResult<'tcx, traits::ProgramClause<'tcx>> {\n-        Ok(traits::ProgramClause {\n-            goal: relation.relate(&a.goal, &b.goal)?,\n-            hypotheses: relation.relate(&a.hypotheses, &b.hypotheses)?,\n-            category: traits::ProgramClauseCategory::Other,\n-        })\n-    }\n-}\n-\n-impl<'tcx> Relate<'tcx> for traits::Environment<'tcx> {\n-    fn relate<R: TypeRelation<'tcx>>(\n-        relation: &mut R,\n-        a: &traits::Environment<'tcx>,\n-        b: &traits::Environment<'tcx>,\n-    ) -> RelateResult<'tcx, traits::Environment<'tcx>> {\n-        Ok(traits::Environment { clauses: relation.relate(&a.clauses, &b.clauses)? })\n-    }\n-}\n-\n-impl<'tcx, G> Relate<'tcx> for traits::InEnvironment<'tcx, G>\n-where\n-    G: Relate<'tcx>,\n-{\n-    fn relate<R: TypeRelation<'tcx>>(\n-        relation: &mut R,\n-        a: &traits::InEnvironment<'tcx, G>,\n-        b: &traits::InEnvironment<'tcx, G>,\n-    ) -> RelateResult<'tcx, traits::InEnvironment<'tcx, G>> {\n-        Ok(traits::InEnvironment {\n-            environment: relation.relate(&a.environment, &b.environment)?,\n-            goal: relation.relate(&a.goal, &b.goal)?,\n-        })\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Error handling\n "}, {"sha": "4d73f8f91ad2e374ecc21ed4f542601875a122b3", "filename": "src/librustc_middle/ty/subst.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_middle%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_middle%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsubst.rs?ref=19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "patch": "@@ -207,38 +207,6 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n         Self::for_item(tcx, def_id, |param, _| tcx.mk_param_from_def(param))\n     }\n \n-    /// Creates a `InternalSubsts` that maps each generic parameter to a higher-ranked\n-    /// var bound at index `0`. For types, we use a `BoundVar` index equal to\n-    /// the type parameter index. For regions, we use the `BoundRegion::BrNamed`\n-    /// variant (which has a `DefId`).\n-    pub fn bound_vars_for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> SubstsRef<'tcx> {\n-        Self::for_item(tcx, def_id, |param, _| match param.kind {\n-            ty::GenericParamDefKind::Type { .. } => tcx\n-                .mk_ty(ty::Bound(\n-                    ty::INNERMOST,\n-                    ty::BoundTy {\n-                        var: ty::BoundVar::from(param.index),\n-                        kind: ty::BoundTyKind::Param(param.name),\n-                    },\n-                ))\n-                .into(),\n-\n-            ty::GenericParamDefKind::Lifetime => tcx\n-                .mk_region(ty::RegionKind::ReLateBound(\n-                    ty::INNERMOST,\n-                    ty::BoundRegion::BrNamed(param.def_id, param.name),\n-                ))\n-                .into(),\n-\n-            ty::GenericParamDefKind::Const => tcx\n-                .mk_const(ty::Const {\n-                    val: ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from(param.index)),\n-                    ty: tcx.type_of(param.def_id),\n-                })\n-                .into(),\n-        })\n-    }\n-\n     /// Creates a `InternalSubsts` for generic parameter definitions,\n     /// by calling closures to obtain each kind.\n     /// The closures get to observe the `InternalSubsts` as they're"}, {"sha": "96ae534c3963f16531812375b83fe9f7058a6d32", "filename": "src/librustc_mir/borrow_check/type_check/relate_tys.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs?ref=19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "patch": "@@ -4,7 +4,6 @@ use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::{self, Ty};\n use rustc_trait_selection::traits::query::Fallible;\n-use rustc_trait_selection::traits::DomainGoal;\n \n use crate::borrow_check::constraints::OutlivesConstraint;\n use crate::borrow_check::type_check::{BorrowCheckContext, Locations};\n@@ -100,10 +99,6 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n         }\n     }\n \n-    fn push_domain_goal(&mut self, _: DomainGoal<'tcx>) {\n-        bug!(\"should never be invoked with eager normalization\")\n-    }\n-\n     fn normalization() -> NormalizationStrategy {\n         NormalizationStrategy::Eager\n     }"}, {"sha": "e0533b11ecf005e6c4fcc3f48e0878565b648f96", "filename": "src/librustc_traits/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "patch": "@@ -15,7 +15,6 @@ extern crate rustc_middle;\n mod dropck_outlives;\n mod evaluate_obligation;\n mod implied_outlives_bounds;\n-pub mod lowering;\n mod normalize_erasing_regions;\n mod normalize_projection_ty;\n mod type_op;\n@@ -26,7 +25,6 @@ pub fn provide(p: &mut Providers<'_>) {\n     dropck_outlives::provide(p);\n     evaluate_obligation::provide(p);\n     implied_outlives_bounds::provide(p);\n-    lowering::provide(p);\n     normalize_projection_ty::provide(p);\n     normalize_erasing_regions::provide(p);\n     type_op::provide(p);"}, {"sha": "e7fa245fd4055fb55373bd98916f7b534ed75b2a", "filename": "src/librustc_traits/lowering/environment.rs", "status": "removed", "additions": 0, "deletions": 267, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=dba944a6b79caf0056ddd282de01de70a0ff8a36", "patch": "@@ -1,267 +0,0 @@\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_hir::def_id::DefId;\n-use rustc_middle::traits::{\n-    Clause, Clauses, DomainGoal, Environment, FromEnv, ProgramClause, ProgramClauseCategory,\n-};\n-use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n-\n-struct ClauseVisitor<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    round: &'a mut FxHashSet<Clause<'tcx>>,\n-}\n-\n-impl ClauseVisitor<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>, round: &'a mut FxHashSet<Clause<'tcx>>) -> Self {\n-        ClauseVisitor { tcx, round }\n-    }\n-\n-    fn visit_ty(&mut self, ty: Ty<'tcx>) {\n-        match ty.kind {\n-            ty::Projection(data) => {\n-                self.round.extend(\n-                    self.tcx\n-                        .program_clauses_for(data.item_def_id)\n-                        .iter()\n-                        .filter(|c| c.category() == ProgramClauseCategory::ImpliedBound)\n-                        .cloned(),\n-                );\n-            }\n-\n-            ty::Dynamic(..) => {\n-                // FIXME: trait object rules are not yet implemented\n-            }\n-\n-            ty::Adt(def, ..) => {\n-                self.round.extend(\n-                    self.tcx\n-                        .program_clauses_for(def.did)\n-                        .iter()\n-                        .filter(|c| c.category() == ProgramClauseCategory::ImpliedBound)\n-                        .cloned(),\n-                );\n-            }\n-\n-            ty::Foreign(def_id)\n-            | ty::FnDef(def_id, ..)\n-            | ty::Closure(def_id, ..)\n-            | ty::Generator(def_id, ..)\n-            | ty::Opaque(def_id, ..) => {\n-                self.round.extend(\n-                    self.tcx\n-                        .program_clauses_for(def_id)\n-                        .iter()\n-                        .filter(|c| c.category() == ProgramClauseCategory::ImpliedBound)\n-                        .cloned(),\n-                );\n-            }\n-\n-            ty::Bool\n-            | ty::Char\n-            | ty::Int(..)\n-            | ty::Uint(..)\n-            | ty::Float(..)\n-            | ty::Str\n-            | ty::Array(..)\n-            | ty::Slice(..)\n-            | ty::RawPtr(..)\n-            | ty::FnPtr(..)\n-            | ty::Tuple(..)\n-            | ty::Ref(..)\n-            | ty::Never\n-            | ty::Infer(..)\n-            | ty::Placeholder(..)\n-            | ty::Param(..)\n-            | ty::Bound(..) => (),\n-\n-            ty::GeneratorWitness(..) | ty::UnnormalizedProjection(..) | ty::Error => {\n-                bug!(\"unexpected type {:?}\", ty);\n-            }\n-        }\n-    }\n-\n-    fn visit_from_env(&mut self, from_env: FromEnv<'tcx>) {\n-        match from_env {\n-            FromEnv::Trait(predicate) => {\n-                self.round.extend(\n-                    self.tcx\n-                        .program_clauses_for(predicate.def_id())\n-                        .iter()\n-                        .filter(|c| c.category() == ProgramClauseCategory::ImpliedBound)\n-                        .cloned(),\n-                );\n-            }\n-\n-            FromEnv::Ty(ty) => self.visit_ty(ty),\n-        }\n-    }\n-\n-    fn visit_domain_goal(&mut self, domain_goal: DomainGoal<'tcx>) {\n-        // The only domain goals we can find in an environment are:\n-        // * `DomainGoal::Holds(..)`\n-        // * `DomainGoal::FromEnv(..)`\n-        // The former do not lead to any implied bounds. So we only need\n-        // to visit the latter.\n-        if let DomainGoal::FromEnv(from_env) = domain_goal {\n-            self.visit_from_env(from_env);\n-        }\n-    }\n-\n-    fn visit_program_clause(&mut self, clause: ProgramClause<'tcx>) {\n-        self.visit_domain_goal(clause.goal);\n-        // No need to visit `clause.hypotheses`: they are always of the form\n-        // `FromEnv(...)` and were visited at a previous round.\n-    }\n-\n-    fn visit_clause(&mut self, clause: Clause<'tcx>) {\n-        match clause {\n-            Clause::Implies(clause) => self.visit_program_clause(clause),\n-            Clause::ForAll(clause) => self.visit_program_clause(*clause.skip_binder()),\n-        }\n-    }\n-}\n-\n-crate fn program_clauses_for_env<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    environment: Environment<'tcx>,\n-) -> Clauses<'tcx> {\n-    debug!(\"program_clauses_for_env(environment={:?})\", environment);\n-\n-    let mut last_round = FxHashSet::default();\n-    {\n-        let mut visitor = ClauseVisitor::new(tcx, &mut last_round);\n-        for &clause in environment.clauses {\n-            visitor.visit_clause(clause);\n-        }\n-    }\n-\n-    let mut closure = last_round.clone();\n-    let mut next_round = FxHashSet::default();\n-    while !last_round.is_empty() {\n-        let mut visitor = ClauseVisitor::new(tcx, &mut next_round);\n-        for clause in last_round.drain() {\n-            visitor.visit_clause(clause);\n-        }\n-        last_round.extend(next_round.drain().filter(|&clause| closure.insert(clause)));\n-    }\n-\n-    debug!(\"program_clauses_for_env: closure = {:#?}\", closure);\n-\n-    tcx.mk_clauses(closure.into_iter())\n-}\n-\n-crate fn environment(tcx: TyCtxt<'_>, def_id: DefId) -> Environment<'_> {\n-    use super::{IntoFromEnvGoal, Lower};\n-    use rustc_hir::{ForeignItemKind, ImplItemKind, ItemKind, Node, TraitItemKind};\n-\n-    debug!(\"environment(def_id = {:?})\", def_id);\n-\n-    // The environment of an impl Trait type is its defining function's environment.\n-    if let Some(parent) = ty::is_impl_trait_defn(tcx, def_id) {\n-        return environment(tcx, parent);\n-    }\n-\n-    // Compute the bounds on `Self` and the type parameters.\n-    let ty::InstantiatedPredicates { predicates, .. } =\n-        tcx.predicates_of(def_id).instantiate_identity(tcx);\n-\n-    let clauses = predicates\n-        .into_iter()\n-        .map(|predicate| predicate.lower())\n-        .map(|domain_goal| domain_goal.map_bound(|bound| bound.into_from_env_goal()))\n-        .map(|domain_goal| domain_goal.map_bound(|bound| bound.into_program_clause()))\n-        // `ForAll` because each `domain_goal` is a `PolyDomainGoal` and\n-        // could bound lifetimes.\n-        .map(Clause::ForAll);\n-\n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n-    let node = tcx.hir().get(hir_id);\n-\n-    enum NodeKind {\n-        TraitImpl,\n-        InherentImpl,\n-        Fn,\n-        Other,\n-    };\n-\n-    let node_kind = match node {\n-        Node::TraitItem(item) => match item.kind {\n-            TraitItemKind::Fn(..) => NodeKind::Fn,\n-            _ => NodeKind::Other,\n-        },\n-\n-        Node::ImplItem(item) => match item.kind {\n-            ImplItemKind::Fn(..) => NodeKind::Fn,\n-            _ => NodeKind::Other,\n-        },\n-\n-        Node::Item(item) => match item.kind {\n-            ItemKind::Impl { of_trait: Some(_), .. } => NodeKind::TraitImpl,\n-            ItemKind::Impl { of_trait: None, .. } => NodeKind::InherentImpl,\n-            ItemKind::Fn(..) => NodeKind::Fn,\n-            _ => NodeKind::Other,\n-        },\n-\n-        Node::ForeignItem(item) => match item.kind {\n-            ForeignItemKind::Fn(..) => NodeKind::Fn,\n-            _ => NodeKind::Other,\n-        },\n-\n-        // FIXME: closures?\n-        _ => NodeKind::Other,\n-    };\n-\n-    // FIXME(eddyb) isn't the unordered nature of this a hazard?\n-    let mut inputs = FxHashSet::default();\n-\n-    match node_kind {\n-        // In a trait impl, we assume that the header trait ref and all its\n-        // constituents are well-formed.\n-        NodeKind::TraitImpl => {\n-            let trait_ref = tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n-\n-            inputs.extend(trait_ref.substs.iter().flat_map(|&arg| arg.walk()));\n-        }\n-\n-        // In an inherent impl, we assume that the receiver type and all its\n-        // constituents are well-formed.\n-        NodeKind::InherentImpl => {\n-            let self_ty = tcx.type_of(def_id);\n-            inputs.extend(self_ty.walk());\n-        }\n-\n-        // In an fn, we assume that the arguments and all their constituents are\n-        // well-formed.\n-        NodeKind::Fn => {\n-            let fn_sig = tcx.fn_sig(def_id);\n-            let fn_sig = tcx.liberate_late_bound_regions(def_id, &fn_sig);\n-\n-            inputs.extend(fn_sig.inputs().iter().flat_map(|ty| ty.walk()));\n-        }\n-\n-        NodeKind::Other => (),\n-    }\n-\n-    let clauses = clauses.chain(\n-        inputs\n-            .into_iter()\n-            .filter_map(|arg| {\n-                match arg.unpack() {\n-                    GenericArgKind::Type(ty) => Some(FromEnv::Ty(ty)),\n-\n-                    // FIXME(eddyb) no WF conditions from lifetimes?\n-                    GenericArgKind::Lifetime(_) => None,\n-\n-                    // FIXME(eddyb) support const generics in Chalk\n-                    GenericArgKind::Const(_) => None,\n-                }\n-            })\n-            .map(DomainGoal::FromEnv)\n-            .map(|domain_goal| domain_goal.into_program_clause())\n-            .map(Clause::Implies),\n-    );\n-\n-    debug!(\"environment: clauses = {:?}\", clauses);\n-\n-    Environment { clauses: tcx.mk_clauses(clauses) }\n-}"}, {"sha": "19765c36ae26a7166a4233b292a65803df84cbba", "filename": "src/librustc_traits/lowering/mod.rs", "status": "removed", "additions": 0, "deletions": 627, "changes": 627, "blob_url": "https://github.com/rust-lang/rust/blob/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba944a6b79caf0056ddd282de01de70a0ff8a36/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=dba944a6b79caf0056ddd282de01de70a0ff8a36", "patch": "@@ -1,627 +0,0 @@\n-mod environment;\n-\n-use rustc_ast::ast;\n-use rustc_hir as hir;\n-use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::definitions::DefPathData;\n-use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc_middle::hir::map::Map;\n-use rustc_middle::traits::{\n-    Clause, Clauses, DomainGoal, FromEnv, GoalKind, PolyDomainGoal, ProgramClause,\n-    ProgramClauseCategory, WellFormed, WhereClause,\n-};\n-use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::subst::{InternalSubsts, Subst};\n-use rustc_middle::ty::{self, List, TyCtxt};\n-use rustc_span::symbol::sym;\n-\n-use std::iter;\n-\n-crate fn provide(p: &mut Providers<'_>) {\n-    *p = Providers {\n-        program_clauses_for,\n-        program_clauses_for_env: environment::program_clauses_for_env,\n-        environment: environment::environment,\n-        ..*p\n-    };\n-}\n-\n-crate trait Lower<T> {\n-    /// Lower a rustc construct (e.g., `ty::TraitPredicate`) to a chalk-like type.\n-    fn lower(&self) -> T;\n-}\n-\n-impl<T, U> Lower<Vec<U>> for Vec<T>\n-where\n-    T: Lower<U>,\n-{\n-    fn lower(&self) -> Vec<U> {\n-        self.iter().map(|item| item.lower()).collect()\n-    }\n-}\n-\n-impl<'tcx> Lower<WhereClause<'tcx>> for ty::TraitPredicate<'tcx> {\n-    fn lower(&self) -> WhereClause<'tcx> {\n-        WhereClause::Implemented(*self)\n-    }\n-}\n-\n-impl<'tcx> Lower<WhereClause<'tcx>> for ty::ProjectionPredicate<'tcx> {\n-    fn lower(&self) -> WhereClause<'tcx> {\n-        WhereClause::ProjectionEq(*self)\n-    }\n-}\n-\n-impl<'tcx> Lower<WhereClause<'tcx>> for ty::RegionOutlivesPredicate<'tcx> {\n-    fn lower(&self) -> WhereClause<'tcx> {\n-        WhereClause::RegionOutlives(*self)\n-    }\n-}\n-\n-impl<'tcx> Lower<WhereClause<'tcx>> for ty::TypeOutlivesPredicate<'tcx> {\n-    fn lower(&self) -> WhereClause<'tcx> {\n-        WhereClause::TypeOutlives(*self)\n-    }\n-}\n-\n-impl<'tcx, T> Lower<DomainGoal<'tcx>> for T\n-where\n-    T: Lower<WhereClause<'tcx>>,\n-{\n-    fn lower(&self) -> DomainGoal<'tcx> {\n-        DomainGoal::Holds(self.lower())\n-    }\n-}\n-\n-/// `ty::Binder` is used for wrapping a rustc construction possibly containing generic\n-/// lifetimes, e.g., `for<'a> T: Fn(&'a i32)`. Instead of representing higher-ranked things\n-/// in that leaf-form (i.e., `Holds(Implemented(Binder<TraitPredicate>))` in the previous\n-/// example), we model them with quantified domain goals, e.g., as for the previous example:\n-/// `forall<'a> { T: Fn(&'a i32) }` which corresponds to something like\n-/// `Binder<Holds(Implemented(TraitPredicate))>`.\n-impl<'tcx, T> Lower<PolyDomainGoal<'tcx>> for ty::Binder<T>\n-where\n-    T: Lower<DomainGoal<'tcx>> + ty::fold::TypeFoldable<'tcx>,\n-{\n-    fn lower(&self) -> PolyDomainGoal<'tcx> {\n-        self.map_bound_ref(|p| p.lower())\n-    }\n-}\n-\n-impl<'tcx> Lower<PolyDomainGoal<'tcx>> for ty::Predicate<'tcx> {\n-    fn lower(&self) -> PolyDomainGoal<'tcx> {\n-        use rustc_middle::ty::Predicate;\n-\n-        match self {\n-            Predicate::Trait(predicate, _) => predicate.lower(),\n-            Predicate::RegionOutlives(predicate) => predicate.lower(),\n-            Predicate::TypeOutlives(predicate) => predicate.lower(),\n-            Predicate::Projection(predicate) => predicate.lower(),\n-\n-            Predicate::WellFormed(..)\n-            | Predicate::ObjectSafe(..)\n-            | Predicate::ClosureKind(..)\n-            | Predicate::Subtype(..)\n-            | Predicate::ConstEvaluatable(..) => bug!(\"unexpected predicate {}\", self),\n-        }\n-    }\n-}\n-\n-/// Used for implied bounds related rules (see rustc dev guide).\n-trait IntoFromEnvGoal {\n-    /// Transforms an existing goal into a `FromEnv` goal.\n-    fn into_from_env_goal(self) -> Self;\n-}\n-\n-/// Used for well-formedness related rules (see rustc dev guide).\n-trait IntoWellFormedGoal {\n-    /// Transforms an existing goal into a `WellFormed` goal.\n-    fn into_well_formed_goal(self) -> Self;\n-}\n-\n-impl<'tcx> IntoFromEnvGoal for DomainGoal<'tcx> {\n-    fn into_from_env_goal(self) -> DomainGoal<'tcx> {\n-        use self::WhereClause::*;\n-\n-        match self {\n-            DomainGoal::Holds(Implemented(trait_ref)) => {\n-                DomainGoal::FromEnv(FromEnv::Trait(trait_ref))\n-            }\n-            other => other,\n-        }\n-    }\n-}\n-\n-impl<'tcx> IntoWellFormedGoal for DomainGoal<'tcx> {\n-    fn into_well_formed_goal(self) -> DomainGoal<'tcx> {\n-        use self::WhereClause::*;\n-\n-        match self {\n-            DomainGoal::Holds(Implemented(trait_ref)) => {\n-                DomainGoal::WellFormed(WellFormed::Trait(trait_ref))\n-            }\n-            other => other,\n-        }\n-    }\n-}\n-\n-crate fn program_clauses_for(tcx: TyCtxt<'_>, def_id: DefId) -> Clauses<'_> {\n-    // FIXME(eddyb) this should only be using `def_kind`.\n-    match tcx.def_key(def_id).disambiguated_data.data {\n-        DefPathData::TypeNs(..) => match tcx.def_kind(def_id) {\n-            DefKind::Trait | DefKind::TraitAlias => program_clauses_for_trait(tcx, def_id),\n-            // FIXME(eddyb) deduplicate this `associated_item` call with\n-            // `program_clauses_for_associated_type_{value,def}`.\n-            DefKind::AssocTy => match tcx.associated_item(def_id).container {\n-                ty::AssocItemContainer::ImplContainer(_) => {\n-                    program_clauses_for_associated_type_value(tcx, def_id)\n-                }\n-                ty::AssocItemContainer::TraitContainer(_) => {\n-                    program_clauses_for_associated_type_def(tcx, def_id)\n-                }\n-            },\n-            DefKind::Struct\n-            | DefKind::Enum\n-            | DefKind::TyAlias\n-            | DefKind::Union\n-            | DefKind::OpaqueTy => program_clauses_for_type_def(tcx, def_id),\n-            _ => List::empty(),\n-        },\n-        DefPathData::Impl => program_clauses_for_impl(tcx, def_id),\n-        _ => List::empty(),\n-    }\n-}\n-\n-fn program_clauses_for_trait(tcx: TyCtxt<'_>, def_id: DefId) -> Clauses<'_> {\n-    // `trait Trait<P1..Pn> where WC { .. } // P0 == Self`\n-\n-    // Rule Implemented-From-Env (see rustc dev guide)\n-    //\n-    // ```\n-    // forall<Self, P1..Pn> {\n-    //   Implemented(Self: Trait<P1..Pn>) :- FromEnv(Self: Trait<P1..Pn>)\n-    // }\n-    // ```\n-\n-    let bound_vars = InternalSubsts::bound_vars_for_item(tcx, def_id);\n-\n-    // `Self: Trait<P1..Pn>`\n-    let trait_pred = ty::TraitPredicate { trait_ref: ty::TraitRef { def_id, substs: bound_vars } };\n-\n-    // `Implemented(Self: Trait<P1..Pn>)`\n-    let impl_trait: DomainGoal<'_> = trait_pred.lower();\n-\n-    // `FromEnv(Self: Trait<P1..Pn>)`\n-    let from_env_goal = tcx.mk_goal(impl_trait.into_from_env_goal().into_goal());\n-    let hypotheses = tcx.intern_goals(&[from_env_goal]);\n-\n-    // `Implemented(Self: Trait<P1..Pn>) :- FromEnv(Self: Trait<P1..Pn>)`\n-    let implemented_from_env = ProgramClause {\n-        goal: impl_trait,\n-        hypotheses,\n-        category: ProgramClauseCategory::ImpliedBound,\n-    };\n-\n-    let implemented_from_env = Clause::ForAll(ty::Binder::bind(implemented_from_env));\n-\n-    let predicates = tcx.predicates_defined_on(def_id).predicates;\n-\n-    // Warning: these where clauses are not substituted for bound vars yet,\n-    // so that we don't need to adjust binders in the `FromEnv` rules below\n-    // (see the FIXME).\n-    let where_clauses = &predicates.iter().map(|(wc, _)| wc.lower()).collect::<Vec<_>>();\n-\n-    // Rule Implied-Bound-From-Trait\n-    //\n-    // For each where clause WC:\n-    // ```\n-    // forall<Self, P1..Pn> {\n-    //   FromEnv(WC) :- FromEnv(Self: Trait<P1..Pn)\n-    // }\n-    // ```\n-\n-    // `FromEnv(WC) :- FromEnv(Self: Trait<P1..Pn>)`, for each where clause WC\n-    let implied_bound_clauses = where_clauses\n-        .iter()\n-        .cloned()\n-        // `FromEnv(WC) :- FromEnv(Self: Trait<P1..Pn>)`\n-        .map(|wc| {\n-            // we move binders to the left\n-            wc.map_bound(|goal| ProgramClause {\n-                // FIXME: As where clauses can only bind lifetimes for now, and that named\n-                // bound regions have a def-id, it is safe to just inject `bound_vars` and\n-                // `hypotheses` (which contain named vars bound at index `0`) into this\n-                // binding level. This may change if we ever allow where clauses to bind\n-                // types (e.g. for GATs things), because bound types only use a `BoundVar`\n-                // index (no def-id).\n-                goal: goal.subst(tcx, bound_vars).into_from_env_goal(),\n-                hypotheses,\n-\n-                category: ProgramClauseCategory::ImpliedBound,\n-            })\n-        })\n-        .map(Clause::ForAll);\n-\n-    // Rule WellFormed-TraitRef\n-    //\n-    // Here `WC` denotes the set of all where clauses:\n-    // ```\n-    // forall<Self, P1..Pn> {\n-    //   WellFormed(Self: Trait<P1..Pn>) :- Implemented(Self: Trait<P1..Pn>) && WellFormed(WC)\n-    // }\n-    // ```\n-\n-    // `WellFormed(WC)`\n-    let wf_conditions = where_clauses\n-        .iter()\n-        .map(|wc| wc.subst(tcx, bound_vars))\n-        .map(|wc| wc.map_bound(|goal| goal.into_well_formed_goal()));\n-\n-    // `WellFormed(Self: Trait<P1..Pn>) :- Implemented(Self: Trait<P1..Pn>) && WellFormed(WC)`\n-    let wf_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Trait(trait_pred)),\n-        hypotheses: tcx.mk_goals(\n-            iter::once(tcx.mk_goal(GoalKind::DomainGoal(impl_trait))).chain(\n-                wf_conditions.map(|wc| tcx.mk_goal(GoalKind::from_poly_domain_goal(wc, tcx))),\n-            ),\n-        ),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n-\n-    tcx.mk_clauses(\n-        iter::once(implemented_from_env).chain(implied_bound_clauses).chain(iter::once(wf_clause)),\n-    )\n-}\n-\n-fn program_clauses_for_impl(tcx: TyCtxt<'tcx>, def_id: DefId) -> Clauses<'tcx> {\n-    if let ty::ImplPolarity::Negative = tcx.impl_polarity(def_id) {\n-        return List::empty();\n-    }\n-\n-    // Rule Implemented-From-Impl (see rustc dev guide)\n-    //\n-    // `impl<P0..Pn> Trait<A1..An> for A0 where WC { .. }`\n-    //\n-    // ```\n-    // forall<P0..Pn> {\n-    //   Implemented(A0: Trait<A1..An>) :- WC\n-    // }\n-    // ```\n-\n-    let bound_vars = InternalSubsts::bound_vars_for_item(tcx, def_id);\n-\n-    let trait_ref = tcx.impl_trait_ref(def_id).expect(\"not an impl\").subst(tcx, bound_vars);\n-\n-    // `Implemented(A0: Trait<A1..An>)`\n-    let trait_pred = ty::TraitPredicate { trait_ref }.lower();\n-\n-    // `WC`\n-    let predicates = tcx.predicates_of(def_id).predicates;\n-    let where_clauses =\n-        predicates.iter().map(|(wc, _)| wc.lower()).map(|wc| wc.subst(tcx, bound_vars));\n-\n-    // `Implemented(A0: Trait<A1..An>) :- WC`\n-    let clause = ProgramClause {\n-        goal: trait_pred,\n-        hypotheses: tcx.mk_goals(\n-            where_clauses.map(|wc| tcx.mk_goal(GoalKind::from_poly_domain_goal(wc, tcx))),\n-        ),\n-        category: ProgramClauseCategory::Other,\n-    };\n-    tcx.mk_clauses(iter::once(Clause::ForAll(ty::Binder::bind(clause))))\n-}\n-\n-pub fn program_clauses_for_type_def(tcx: TyCtxt<'_>, def_id: DefId) -> Clauses<'_> {\n-    // Rule WellFormed-Type\n-    //\n-    // `struct Ty<P1..Pn> where WC1, ..., WCm`\n-    //\n-    // ```\n-    // forall<P1..Pn> {\n-    //   WellFormed(Ty<...>) :- WellFormed(WC1), ..., WellFormed(WCm)`\n-    // }\n-    // ```\n-\n-    let bound_vars = InternalSubsts::bound_vars_for_item(tcx, def_id);\n-\n-    // `Ty<...>`\n-    let ty = tcx.type_of(def_id).subst(tcx, bound_vars);\n-\n-    // Warning: these where clauses are not substituted for bound vars yet,\n-    // so that we don't need to adjust binders in the `FromEnv` rules below\n-    // (see the FIXME).\n-    let where_clauses =\n-        tcx.predicates_of(def_id).predicates.iter().map(|(wc, _)| wc.lower()).collect::<Vec<_>>();\n-\n-    // `WellFormed(Ty<...>) :- WellFormed(WC1), ..., WellFormed(WCm)`\n-    let well_formed_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Ty(ty)),\n-        hypotheses: tcx.mk_goals(\n-            where_clauses\n-                .iter()\n-                .map(|wc| wc.subst(tcx, bound_vars))\n-                .map(|wc| wc.map_bound(|bound| bound.into_well_formed_goal()))\n-                .map(|wc| tcx.mk_goal(GoalKind::from_poly_domain_goal(wc, tcx))),\n-        ),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let well_formed_clause = Clause::ForAll(ty::Binder::bind(well_formed_clause));\n-\n-    // Rule Implied-Bound-From-Type\n-    //\n-    // For each where clause `WC`:\n-    // ```\n-    // forall<P1..Pn> {\n-    //   FromEnv(WC) :- FromEnv(Ty<...>)\n-    // }\n-    // ```\n-\n-    // `FromEnv(Ty<...>)`\n-    let from_env_goal = tcx.mk_goal(DomainGoal::FromEnv(FromEnv::Ty(ty)).into_goal());\n-    let hypotheses = tcx.intern_goals(&[from_env_goal]);\n-\n-    // For each where clause `WC`:\n-    let from_env_clauses = where_clauses\n-        .into_iter()\n-        // `FromEnv(WC) :- FromEnv(Ty<...>)`\n-        .map(|wc| {\n-            // move the binders to the left\n-            wc.map_bound(|goal| ProgramClause {\n-                // FIXME: we inject `bound_vars` and `hypotheses` into this binding\n-                // level, which may be incorrect in the future: see the FIXME in\n-                // `program_clauses_for_trait`.\n-                goal: goal.subst(tcx, bound_vars).into_from_env_goal(),\n-                hypotheses,\n-\n-                category: ProgramClauseCategory::ImpliedBound,\n-            })\n-        })\n-        .map(Clause::ForAll);\n-\n-    tcx.mk_clauses(iter::once(well_formed_clause).chain(from_env_clauses))\n-}\n-\n-pub fn program_clauses_for_associated_type_def(tcx: TyCtxt<'_>, item_id: DefId) -> Clauses<'_> {\n-    // Rule ProjectionEq-Placeholder\n-    //\n-    // ```\n-    // trait Trait<P1..Pn> {\n-    //     type AssocType<Pn+1..Pm>;\n-    // }\n-    // ```\n-    //\n-    // `ProjectionEq` can succeed by skolemizing, see \"associated type\"\n-    // chapter for more:\n-    // ```\n-    // forall<Self, P1..Pn, Pn+1..Pm> {\n-    //     ProjectionEq(\n-    //         <Self as Trait<P1..Pn>>::AssocType<Pn+1..Pm> =\n-    //         (Trait::AssocType)<Self, P1..Pn, Pn+1..Pm>\n-    //     )\n-    // }\n-    // ```\n-\n-    let item = tcx.associated_item(item_id);\n-    debug_assert_eq!(item.kind, ty::AssocKind::Type);\n-    let trait_id = match item.container {\n-        ty::AssocItemContainer::TraitContainer(trait_id) => trait_id,\n-        _ => bug!(\"not an trait container\"),\n-    };\n-\n-    let trait_bound_vars = InternalSubsts::bound_vars_for_item(tcx, trait_id);\n-    let trait_ref = ty::TraitRef { def_id: trait_id, substs: trait_bound_vars };\n-\n-    let projection_ty = ty::ProjectionTy::from_ref_and_name(tcx, trait_ref, item.ident);\n-    let placeholder_ty = tcx.mk_ty(ty::UnnormalizedProjection(projection_ty));\n-    let projection_eq =\n-        WhereClause::ProjectionEq(ty::ProjectionPredicate { projection_ty, ty: placeholder_ty });\n-\n-    let projection_eq_clause = ProgramClause {\n-        goal: DomainGoal::Holds(projection_eq),\n-        hypotheses: ty::List::empty(),\n-        category: ProgramClauseCategory::Other,\n-    };\n-    let projection_eq_clause = Clause::ForAll(ty::Binder::bind(projection_eq_clause));\n-\n-    // Rule WellFormed-AssocTy\n-    // ```\n-    // forall<Self, P1..Pn, Pn+1..Pm> {\n-    //     WellFormed((Trait::AssocType)<Self, P1..Pn, Pn+1..Pm>)\n-    //         :- WellFormed(Self: Trait<P1..Pn>)\n-    // }\n-    // ```\n-\n-    let trait_predicate = ty::TraitPredicate { trait_ref };\n-    let hypothesis =\n-        tcx.mk_goal(DomainGoal::WellFormed(WellFormed::Trait(trait_predicate)).into_goal());\n-\n-    let wf_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Ty(placeholder_ty)),\n-        hypotheses: tcx.mk_goals(iter::once(hypothesis)),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n-\n-    // Rule Implied-Trait-From-AssocTy\n-    // ```\n-    // forall<Self, P1..Pn, Pn+1..Pm> {\n-    //     FromEnv(Self: Trait<P1..Pn>)\n-    //         :- FromEnv((Trait::AssocType)<Self, P1..Pn, Pn+1..Pm>)\n-    // }\n-    // ```\n-\n-    let hypothesis = tcx.mk_goal(DomainGoal::FromEnv(FromEnv::Ty(placeholder_ty)).into_goal());\n-\n-    let from_env_clause = ProgramClause {\n-        goal: DomainGoal::FromEnv(FromEnv::Trait(trait_predicate)),\n-        hypotheses: tcx.mk_goals(iter::once(hypothesis)),\n-        category: ProgramClauseCategory::ImpliedBound,\n-    };\n-    let from_env_clause = Clause::ForAll(ty::Binder::bind(from_env_clause));\n-\n-    // Rule ProjectionEq-Normalize\n-    //\n-    // ProjectionEq can succeed by normalizing:\n-    // ```\n-    // forall<Self, P1..Pn, Pn+1..Pm, U> {\n-    //   ProjectionEq(<Self as Trait<P1..Pn>>::AssocType<Pn+1..Pm> = U) :-\n-    //       Normalize(<Self as Trait<P1..Pn>>::AssocType<Pn+1..Pm> -> U)\n-    // }\n-    // ```\n-\n-    let offset = tcx.generics_of(trait_id).params.iter().map(|p| p.index).max().unwrap_or(0);\n-    // Add a new type param after the existing ones (`U` in the comment above).\n-    let ty_var = ty::Bound(ty::INNERMOST, ty::BoundVar::from_u32(offset + 1).into());\n-\n-    // `ProjectionEq(<Self as Trait<P1..Pn>>::AssocType<Pn+1..Pm> = U)`\n-    let projection = ty::ProjectionPredicate { projection_ty, ty: tcx.mk_ty(ty_var) };\n-\n-    // `Normalize(<A0 as Trait<A1..An>>::AssocType<Pn+1..Pm> -> U)`\n-    let hypothesis = tcx.mk_goal(DomainGoal::Normalize(projection).into_goal());\n-\n-    //  ProjectionEq(<Self as Trait<P1..Pn>>::AssocType<Pn+1..Pm> = U) :-\n-    //      Normalize(<Self as Trait<P1..Pn>>::AssocType<Pn+1..Pm> -> U)\n-    let normalize_clause = ProgramClause {\n-        goal: DomainGoal::Holds(WhereClause::ProjectionEq(projection)),\n-        hypotheses: tcx.mk_goals(iter::once(hypothesis)),\n-        category: ProgramClauseCategory::Other,\n-    };\n-    let normalize_clause = Clause::ForAll(ty::Binder::bind(normalize_clause));\n-\n-    let clauses = iter::once(projection_eq_clause)\n-        .chain(iter::once(wf_clause))\n-        .chain(iter::once(from_env_clause))\n-        .chain(iter::once(normalize_clause));\n-\n-    tcx.mk_clauses(clauses)\n-}\n-\n-pub fn program_clauses_for_associated_type_value(tcx: TyCtxt<'_>, item_id: DefId) -> Clauses<'_> {\n-    // Rule Normalize-From-Impl (see rustc dev guide)\n-    //\n-    // ```\n-    // impl<P0..Pn> Trait<A1..An> for A0 {\n-    //     type AssocType<Pn+1..Pm> = T;\n-    // }\n-    // ```\n-    //\n-    // FIXME: For the moment, we don't account for where clauses written on the associated\n-    // ty definition (i.e., in the trait def, as in `type AssocType<T> where T: Sized`).\n-    // ```\n-    // forall<P0..Pm> {\n-    //   forall<Pn+1..Pm> {\n-    //     Normalize(<A0 as Trait<A1..An>>::AssocType<Pn+1..Pm> -> T) :-\n-    //       Implemented(A0: Trait<A1..An>)\n-    //   }\n-    // }\n-    // ```\n-\n-    let item = tcx.associated_item(item_id);\n-    debug_assert_eq!(item.kind, ty::AssocKind::Type);\n-    let impl_id = match item.container {\n-        ty::AssocItemContainer::ImplContainer(impl_id) => impl_id,\n-        _ => bug!(\"not an impl container\"),\n-    };\n-\n-    let impl_bound_vars = InternalSubsts::bound_vars_for_item(tcx, impl_id);\n-\n-    // `A0 as Trait<A1..An>`\n-    let trait_ref = tcx.impl_trait_ref(impl_id).unwrap().subst(tcx, impl_bound_vars);\n-\n-    // `T`\n-    let ty = tcx.type_of(item_id);\n-\n-    // `Implemented(A0: Trait<A1..An>)`\n-    let trait_implemented: DomainGoal<'_> = ty::TraitPredicate { trait_ref }.lower();\n-\n-    // `<A0 as Trait<A1..An>>::AssocType<Pn+1..Pm>`\n-    let projection_ty = ty::ProjectionTy::from_ref_and_name(tcx, trait_ref, item.ident);\n-\n-    // `Normalize(<A0 as Trait<A1..An>>::AssocType<Pn+1..Pm> -> T)`\n-    let normalize_goal = DomainGoal::Normalize(ty::ProjectionPredicate { projection_ty, ty });\n-\n-    // `Normalize(... -> T) :- ...`\n-    let normalize_clause = ProgramClause {\n-        goal: normalize_goal,\n-        hypotheses: tcx.mk_goals(iter::once(tcx.mk_goal(GoalKind::DomainGoal(trait_implemented)))),\n-        category: ProgramClauseCategory::Other,\n-    };\n-    let normalize_clause = Clause::ForAll(ty::Binder::bind(normalize_clause));\n-\n-    tcx.mk_clauses(iter::once(normalize_clause))\n-}\n-\n-pub fn dump_program_clauses(tcx: TyCtxt<'_>) {\n-    if !tcx.features().rustc_attrs {\n-        return;\n-    }\n-\n-    let mut visitor = ClauseDumper { tcx };\n-    tcx.hir().krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n-}\n-\n-struct ClauseDumper<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-}\n-\n-impl ClauseDumper<'tcx> {\n-    fn process_attrs(&mut self, hir_id: hir::HirId, attrs: &[ast::Attribute]) {\n-        let def_id = self.tcx.hir().local_def_id(hir_id);\n-        for attr in attrs {\n-            let mut clauses = None;\n-\n-            if attr.check_name(sym::rustc_dump_program_clauses) {\n-                clauses = Some(self.tcx.program_clauses_for(def_id));\n-            }\n-\n-            if attr.check_name(sym::rustc_dump_env_program_clauses) {\n-                let environment = self.tcx.environment(def_id);\n-                clauses = Some(self.tcx.program_clauses_for_env(environment));\n-            }\n-\n-            if let Some(clauses) = clauses {\n-                let mut err = self.tcx.sess.struct_span_err(attr.span, \"program clause dump\");\n-\n-                let mut strings: Vec<_> = clauses.iter().map(|clause| clause.to_string()).collect();\n-\n-                strings.sort();\n-\n-                for string in strings {\n-                    err.note(&string);\n-                }\n-\n-                err.emit();\n-            }\n-        }\n-    }\n-}\n-\n-impl Visitor<'tcx> for ClauseDumper<'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::OnlyBodies(self.tcx.hir())\n-    }\n-\n-    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        self.process_attrs(item.hir_id, &item.attrs);\n-        intravisit::walk_item(self, item);\n-    }\n-\n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n-        self.process_attrs(trait_item.hir_id, &trait_item.attrs);\n-        intravisit::walk_trait_item(self, trait_item);\n-    }\n-\n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n-        self.process_attrs(impl_item.hir_id, &impl_item.attrs);\n-        intravisit::walk_impl_item(self, impl_item);\n-    }\n-\n-    fn visit_struct_field(&mut self, s: &'tcx hir::StructField<'tcx>) {\n-        self.process_attrs(s.hir_id, &s.attrs);\n-        intravisit::walk_struct_field(self, s);\n-    }\n-}"}, {"sha": "e3b16eaaef2a2c013644333e9ca8086c1b4a58e7", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "patch": "@@ -107,6 +107,7 @@ fn coerce_mutbls<'tcx>(\n     }\n }\n \n+/// Do not require any adjustments, i.e. coerce `x -> x`.\n fn identity(_: Ty<'_>) -> Vec<Adjustment<'_>> {\n     vec![]\n }\n@@ -115,6 +116,7 @@ fn simple(kind: Adjust<'tcx>) -> impl FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>\n     move |target| vec![Adjustment { kind, target }]\n }\n \n+/// This always returns `Ok(...)`.\n fn success<'tcx>(\n     adj: Vec<Adjustment<'tcx>>,\n     target: Ty<'tcx>,\n@@ -133,6 +135,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n \n     pub fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n+        debug!(\"unify(a: {:?}, b: {:?}, use_lub: {})\", a, b, self.use_lub);\n         self.commit_if_ok(|_| {\n             if self.use_lub {\n                 self.at(&self.cause, self.fcx.param_env).lub(b, a)"}, {"sha": "c52a5b8061dbff49346d4f722044dfa27a89bc82", "filename": "src/test/ui/const-generics/different_byref.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_byref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_byref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_byref.rs?ref=19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "patch": "@@ -0,0 +1,11 @@\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+struct Const<const V: [usize; 1]> {}\n+\n+fn main() {\n+    let mut x = Const::<{ [3] }> {};\n+    x = Const::<{ [4] }> {};\n+    //~^ ERROR mismatched types\n+\n+}"}, {"sha": "9ea2aace89aaed5267bafea4c7725764479bf071", "filename": "src/test/ui/const-generics/different_byref.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_byref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_byref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_byref.stderr?ref=19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "patch": "@@ -0,0 +1,20 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/different_byref.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0308]: mismatched types\n+  --> $DIR/different_byref.rs:8:9\n+   |\n+LL |     x = Const::<{ [4] }> {};\n+   |         ^^^^^^^^^^^^^^^^^^^ expected `3usize`, found `4usize`\n+   |\n+   = note: expected struct `Const<[3usize]>`\n+              found struct `Const<[4usize]>`\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "140bb28ec5a4f17d6c9ff6db032fa046fab33455", "filename": "src/test/ui/const-generics/issues/issue-68615-adt.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68615-adt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68615-adt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68615-adt.rs?ref=19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+#![feature(const_generics)]\n+#![allow(incomplete_features)]\n+\n+struct Const<const V: [usize; 0]> {}\n+type MyConst = Const<{ [] }>;\n+\n+fn main() {\n+    let _x = Const::<{ [] }> {};\n+    let _y = MyConst {};\n+}"}, {"sha": "c384bc1e36d023f81cba9a067bacaa52b7e5618e", "filename": "src/test/ui/const-generics/issues/issue-68615-array.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68615-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68615-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68615-array.rs?ref=19ae74d0d0e864bfc5c809e47af3a903d3fc2cf1", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+#![feature(const_generics)]\n+#![allow(incomplete_features)]\n+\n+struct Foo<const V: [usize; 0] > {}\n+\n+type MyFoo = Foo<{ [] }>;\n+\n+fn main() {\n+    let _ = Foo::<{ [] }> {};\n+}"}]}