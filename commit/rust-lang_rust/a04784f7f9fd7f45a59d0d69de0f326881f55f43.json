{"sha": "a04784f7f9fd7f45a59d0d69de0f326881f55f43", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwNDc4NGY3ZjlmZDdmNDVhNTlkMGQ2OWRlMGYzMjY4ODFmNTVmNDM=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2015-07-02T16:18:22Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2015-07-02T16:34:58Z"}, "message": "Directly construct lvalue datums for function arguments\n\nThe current split between create_datums_for_fn_args,\ncopy_args_to_allocas and store_arg involves a detour via rvalue datums\nwhich cause additional work in form of insertvalue/extractvalue pairs\nfor fat pointer arguments, and an extra alloca and memcpy for tupled\nargs in rust-call functions.\n\nBy merging those three functions into just one that actually covers the\nwhole process of creating the final argument datums, we can skip all\nthat. Also, this allows to easily merge in the handling of rust-call\nfunctions, allowing to make create_datum_for_fn_args_under_call_abi\nobsolete.\n\ncc #26600 -- The insertvalue instructions kicked us off of fast-isel.", "tree": {"sha": "3db2d55d0e0dfaa1fd35c8dad921a783c1617fc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3db2d55d0e0dfaa1fd35c8dad921a783c1617fc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a04784f7f9fd7f45a59d0d69de0f326881f55f43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a04784f7f9fd7f45a59d0d69de0f326881f55f43", "html_url": "https://github.com/rust-lang/rust/commit/a04784f7f9fd7f45a59d0d69de0f326881f55f43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a04784f7f9fd7f45a59d0d69de0f326881f55f43/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b5edd24f54041b0bb1acafbcf3ccb77868be816", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b5edd24f54041b0bb1acafbcf3ccb77868be816", "html_url": "https://github.com/rust-lang/rust/commit/6b5edd24f54041b0bb1acafbcf3ccb77868be816"}], "stats": {"total": 263, "additions": 101, "deletions": 162}, "files": [{"sha": "c2397ec31cffab8abaa9adf1d79e6b71d594ad8b", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 50, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a04784f7f9fd7f45a59d0d69de0f326881f55f43/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04784f7f9fd7f45a59d0d69de0f326881f55f43/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=a04784f7f9fd7f45a59d0d69de0f326881f55f43", "patch": "@@ -215,7 +215,7 @@ use trans::monomorphize;\n use trans::tvec;\n use trans::type_of;\n use middle::ty::{self, Ty};\n-use session::config::{NoDebugInfo, FullDebugInfo};\n+use session::config::NoDebugInfo;\n use util::common::indenter;\n use util::nodemap::FnvHashMap;\n use util::ppaux;\n@@ -1600,54 +1600,6 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-/// Generates code for argument patterns like `fn foo(<pat>: T)`.\n-/// Creates entries in the `lllocals` map for each of the bindings\n-/// in `pat`.\n-///\n-/// # Arguments\n-///\n-/// - `pat` is the argument pattern\n-/// - `llval` is a pointer to the argument value (in other words,\n-///   if the argument type is `T`, then `llval` is a `T*`). In some\n-///   cases, this code may zero out the memory `llval` points at.\n-pub fn store_arg<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                             pat: &ast::Pat,\n-                             arg: Datum<'tcx, Rvalue>,\n-                             arg_scope: cleanup::ScopeId)\n-                             -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"match::store_arg\");\n-\n-    match simple_identifier(&*pat) {\n-        Some(ident) => {\n-            // Generate nicer LLVM for the common case of fn a pattern\n-            // like `x: T`\n-            let arg_ty = node_id_type(bcx, pat.id);\n-            if type_of::arg_is_indirect(bcx.ccx(), arg_ty)\n-                && bcx.sess().opts.debuginfo != FullDebugInfo {\n-                // Don't copy an indirect argument to an alloca, the caller\n-                // already put it in a temporary alloca and gave it up, unless\n-                // we emit extra-debug-info, which requires local allocas :(.\n-                let arg_val = arg.add_clean(bcx.fcx, arg_scope);\n-                bcx.fcx.lllocals.borrow_mut()\n-                   .insert(pat.id, Datum::new(arg_val, arg_ty, Lvalue));\n-                bcx\n-            } else {\n-                mk_binding_alloca(\n-                    bcx, pat.id, ident.name, arg_scope, arg,\n-                    |arg, bcx, llval, _| arg.store_to(bcx, llval))\n-            }\n-        }\n-\n-        None => {\n-            // General path. Copy out the values that are used in the\n-            // pattern.\n-            let arg = unpack_datum!(\n-                bcx, arg.to_lvalue_datum_in_scope(bcx, \"__arg\", arg_scope));\n-            bind_irrefutable_pat(bcx, pat, arg.val, arg_scope)\n-        }\n-    }\n-}\n-\n fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n                                        p_id: ast::NodeId,\n                                        name: ast::Name,\n@@ -1687,7 +1639,7 @@ fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n /// - bcx: starting basic block context\n /// - pat: the irrefutable pattern being matched.\n /// - val: the value being matched -- must be an lvalue (by ref, with cleanup)\n-fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     pat: &ast::Pat,\n                                     val: ValueRef,\n                                     cleanup_scope: cleanup::ScopeId)"}, {"sha": "edb61b0d3cf384cfb8aaf882a05e452c8e65c290", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 99, "deletions": 109, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/a04784f7f9fd7f45a59d0d69de0f326881f55f43/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04784f7f9fd7f45a59d0d69de0f326881f55f43/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=a04784f7f9fd7f45a59d0d69de0f326881f55f43", "patch": "@@ -40,10 +40,11 @@ use middle::cfg;\n use middle::infer;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::weak_lang_items;\n+use middle::pat_util::simple_identifier;\n use middle::subst::Substs;\n use middle::ty::{self, Ty, HasTypeFlags};\n use rustc::ast_map;\n-use session::config::{self, NoDebugInfo};\n+use session::config::{self, NoDebugInfo, FullDebugInfo};\n use session::Session;\n use trans::_match;\n use trans::adt;\n@@ -1035,6 +1036,13 @@ pub fn alloca_no_lifetime(cx: Block, ty: Type, name: &str) -> ValueRef {\n     Alloca(cx, ty, name)\n }\n \n+pub fn set_value_name(val: ValueRef, name: &str) {\n+    unsafe {\n+        let name = CString::new(name).unwrap();\n+        llvm::LLVMSetValueName(val, name.as_ptr());\n+    }\n+}\n+\n // Creates the alloca slot which holds the pointer to the slot for the final return value\n pub fn make_return_slot_pointer<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n                                           output_type: Ty<'tcx>) -> ValueRef {\n@@ -1297,78 +1305,70 @@ pub fn arg_kind<'a, 'tcx>(cx: &FunctionContext<'a, 'tcx>, t: Ty<'tcx>)\n     }\n }\n \n-// work around bizarre resolve errors\n-pub type RvalueDatum<'tcx> = datum::Datum<'tcx, datum::Rvalue>;\n-\n-// create_datums_for_fn_args: creates rvalue datums for each of the\n-// incoming function arguments. These will later be stored into\n-// appropriate lvalue datums.\n-pub fn create_datums_for_fn_args<'a, 'tcx>(bcx: Block<'a, 'tcx>,\n-                                           arg_tys: &[Ty<'tcx>])\n-                                           -> Vec<RvalueDatum<'tcx>> {\n+// create_datums_for_fn_args: creates lvalue datums for each of the\n+// incoming function arguments.\n+pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n+                                           args: &[ast::Arg],\n+                                           arg_tys: &[Ty<'tcx>],\n+                                           has_tupled_arg: bool,\n+                                           arg_scope: cleanup::CustomScopeIndex)\n+                                           -> Block<'a, 'tcx> {\n     let _icx = push_ctxt(\"create_datums_for_fn_args\");\n     let fcx = bcx.fcx;\n+    let arg_scope_id = cleanup::CustomScope(arg_scope);\n \n     // Return an array wrapping the ValueRefs that we get from `get_param` for\n     // each argument into datums.\n-    let mut i = fcx.arg_offset() as c_uint;\n-    arg_tys.iter().map(|&arg_ty| {\n-        if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n-            let llty = type_of::type_of(bcx.ccx(), arg_ty);\n-            let data = get_param(fcx.llfn, i);\n-            let extra = get_param(fcx.llfn, i + 1);\n-            let fat_ptr = expr::make_fat_ptr(bcx, llty, data, extra);\n-            i += 2;\n-            datum::Datum::new(fat_ptr, arg_ty, datum::Rvalue { mode: datum::ByValue })\n-        } else {\n-            let llarg = get_param(fcx.llfn, i);\n-            i += 1;\n-            datum::Datum::new(llarg, arg_ty, arg_kind(fcx, arg_ty))\n-        }\n-    }).collect()\n-}\n-\n-/// Creates rvalue datums for each of the incoming function arguments and\n-/// tuples the arguments. These will later be stored into appropriate lvalue\n-/// datums.\n-///\n-/// FIXME(pcwalton): Reduce the amount of code bloat this is responsible for.\n-fn create_datums_for_fn_args_under_call_abi<'blk, 'tcx>(\n-        mut bcx: Block<'blk, 'tcx>,\n-        arg_scope: cleanup::CustomScopeIndex,\n-        arg_tys: &[Ty<'tcx>])\n-        -> Vec<RvalueDatum<'tcx>> {\n-    let mut result = Vec::new();\n-    let mut idx = bcx.fcx.arg_offset() as c_uint;\n+    //\n+    // For certain mode/type combinations, the raw llarg values are passed\n+    // by value.  However, within the fn body itself, we want to always\n+    // have all locals and arguments be by-ref so that we can cancel the\n+    // cleanup and for better interaction with LLVM's debug info.  So, if\n+    // the argument would be passed by value, we store it into an alloca.\n+    // This alloca should be optimized away by LLVM's mem-to-reg pass in\n+    // the event it's not truly needed.\n+    let mut idx = fcx.arg_offset() as c_uint;\n     for (i, &arg_ty) in arg_tys.iter().enumerate() {\n-        if i < arg_tys.len() - 1 {\n-            // Regular argument.\n-            result.push(if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n-                let llty = type_of::type_of(bcx.ccx(), arg_ty);\n-                let data = get_param(bcx.fcx.llfn, idx);\n-                let extra = get_param(bcx.fcx.llfn, idx + 1);\n+        let arg_datum = if !has_tupled_arg || i < arg_tys.len() - 1 {\n+            if type_of::arg_is_indirect(bcx.ccx(), arg_ty)\n+                    && bcx.sess().opts.debuginfo != FullDebugInfo {\n+                // Don't copy an indirect argument to an alloca, the caller\n+                // already put it in a temporary alloca and gave it up, unless\n+                // we emit extra-debug-info, which requires local allocas :(.\n+                let llarg = get_param(fcx.llfn, idx);\n+                idx += 1;\n+                bcx.fcx.schedule_lifetime_end(arg_scope_id, llarg);\n+                bcx.fcx.schedule_drop_mem(arg_scope_id, llarg, arg_ty);\n+\n+                datum::Datum::new(llarg, arg_ty, datum::Lvalue)\n+            } else if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n+                let data = get_param(fcx.llfn, idx);\n+                let extra = get_param(fcx.llfn, idx + 1);\n                 idx += 2;\n-                let fat_ptr = expr::make_fat_ptr(bcx, llty, data, extra);\n-                datum::Datum::new(fat_ptr, arg_ty, datum::Rvalue { mode: datum::ByValue })\n+                unpack_datum!(bcx, datum::lvalue_scratch_datum(bcx, arg_ty, \"\",\n+                                                        arg_scope_id, (data, extra),\n+                                                        |(data, extra), bcx, dst| {\n+                    Store(bcx, data, expr::get_dataptr(bcx, dst));\n+                    Store(bcx, extra, expr::get_len(bcx, dst));\n+                    bcx\n+                }))\n             } else {\n-                let val = get_param(bcx.fcx.llfn, idx);\n+                let llarg = get_param(fcx.llfn, idx);\n                 idx += 1;\n-                datum::Datum::new(val, arg_ty, arg_kind(bcx.fcx, arg_ty))\n-            });\n-\n-            continue\n-        }\n-\n-        // This is the last argument. Tuple it.\n-        match arg_ty.sty {\n-            ty::TyTuple(ref tupled_arg_tys) => {\n-                let tuple_args_scope_id = cleanup::CustomScope(arg_scope);\n-                let tuple =\n+                let tmp = datum::Datum::new(llarg, arg_ty, arg_kind(fcx, arg_ty));\n+                unpack_datum!(bcx, datum::lvalue_scratch_datum(bcx, arg_ty, \"\",\n+                                                           arg_scope_id, tmp,\n+                                                           |tmp, bcx, dst| tmp.store_to(bcx, dst)))\n+            }\n+        } else {\n+            // FIXME(pcwalton): Reduce the amount of code bloat this is responsible for.\n+            match arg_ty.sty {\n+                ty::TyTuple(ref tupled_arg_tys) => {\n                     unpack_datum!(bcx,\n                                   datum::lvalue_scratch_datum(bcx,\n                                                               arg_ty,\n                                                               \"tupled_args\",\n-                                                              tuple_args_scope_id,\n+                                                              arg_scope_id,\n                                                               (),\n                                                               |(),\n                                                                mut bcx,\n@@ -1392,46 +1392,27 @@ fn create_datums_for_fn_args_under_call_abi<'blk, 'tcx>(\n                             };\n                         }\n                         bcx\n-                    }));\n-                let tuple = unpack_datum!(bcx,\n-                                          tuple.to_expr_datum()\n-                                               .to_rvalue_datum(bcx,\n-                                                                \"argtuple\"));\n-                result.push(tuple);\n-            }\n-            _ => {\n-                bcx.tcx().sess.bug(\"last argument of a function with \\\n-                                    `rust-call` ABI isn't a tuple?!\")\n+                    }))\n+                }\n+                _ => {\n+                    bcx.tcx().sess.bug(\"last argument of a function with \\\n+                                        `rust-call` ABI isn't a tuple?!\")\n+                }\n             }\n         };\n \n-    }\n-\n-    result\n-}\n-\n-fn copy_args_to_allocas<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    arg_scope: cleanup::CustomScopeIndex,\n-                                    args: &[ast::Arg],\n-                                    arg_datums: Vec<RvalueDatum<'tcx>>)\n-                                    -> Block<'blk, 'tcx> {\n-    debug!(\"copy_args_to_allocas\");\n-\n-    let _icx = push_ctxt(\"copy_args_to_allocas\");\n-    let mut bcx = bcx;\n-\n-    let arg_scope_id = cleanup::CustomScope(arg_scope);\n-\n-    for (i, arg_datum) in arg_datums.into_iter().enumerate() {\n-        // For certain mode/type combinations, the raw llarg values are passed\n-        // by value.  However, within the fn body itself, we want to always\n-        // have all locals and arguments be by-ref so that we can cancel the\n-        // cleanup and for better interaction with LLVM's debug info.  So, if\n-        // the argument would be passed by value, we store it into an alloca.\n-        // This alloca should be optimized away by LLVM's mem-to-reg pass in\n-        // the event it's not truly needed.\n-\n-        bcx = _match::store_arg(bcx, &*args[i].pat, arg_datum, arg_scope_id);\n+        let pat = &*args[i].pat;\n+        bcx = if let Some(ident) = simple_identifier(&*pat) {\n+            // Generate nicer LLVM for the common case of fn a pattern\n+            // like `x: T`\n+            set_value_name(arg_datum.val, &bcx.name(ident.name));\n+            bcx.fcx.lllocals.borrow_mut().insert(pat.id, arg_datum);\n+            bcx\n+        } else {\n+            // General path. Copy out the values that are used in the\n+            // pattern.\n+            _match::bind_irrefutable_pat(bcx, pat, arg_datum.val, arg_scope_id)\n+        };\n         debuginfo::create_argument_metadata(bcx, &args[i]);\n     }\n \n@@ -1585,16 +1566,13 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"trans_closure: function lltype: {}\",\n            bcx.fcx.ccx.tn().val_to_string(bcx.fcx.llfn));\n \n-    let arg_datums = match closure_env {\n-        closure::ClosureEnv::NotClosure if abi == RustCall => {\n-            create_datums_for_fn_args_under_call_abi(bcx, arg_scope, &monomorphized_arg_types[..])\n-        }\n-        _ => {\n-            create_datums_for_fn_args(bcx, &monomorphized_arg_types)\n-        }\n+    let has_tupled_arg = match closure_env {\n+        closure::ClosureEnv::NotClosure => abi == RustCall,\n+        _ => false\n     };\n \n-    bcx = copy_args_to_allocas(bcx, arg_scope, &decl.inputs, arg_datums);\n+    bcx = create_datums_for_fn_args(bcx, &decl.inputs, &monomorphized_arg_types,\n+                                    has_tupled_arg, arg_scope);\n \n     bcx = closure_env.load(bcx, cleanup::CustomScope(arg_scope));\n \n@@ -1795,18 +1773,30 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n \n     let arg_tys = ccx.tcx().erase_late_bound_regions(&ctor_ty.fn_args());\n \n-    let arg_datums = create_datums_for_fn_args(bcx, &arg_tys[..]);\n-\n     if !type_is_zero_size(fcx.ccx, result_ty.unwrap()) {\n         let dest = fcx.get_ret_slot(bcx, result_ty, \"eret_slot\");\n         let repr = adt::represent_type(ccx, result_ty.unwrap());\n-        for (i, arg_datum) in arg_datums.into_iter().enumerate() {\n+        let mut llarg_idx = fcx.arg_offset() as c_uint;\n+        for (i, arg_ty) in arg_tys.into_iter().enumerate() {\n             let lldestptr = adt::trans_field_ptr(bcx,\n                                                  &*repr,\n                                                  dest,\n                                                  disr,\n                                                  i);\n-            arg_datum.store_to(bcx, lldestptr);\n+            if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n+                Store(bcx, get_param(fcx.llfn, llarg_idx), expr::get_dataptr(bcx, lldestptr));\n+                Store(bcx, get_param(fcx.llfn, llarg_idx + 1), expr::get_len(bcx, lldestptr));\n+                llarg_idx += 2;\n+            } else {\n+                let arg = get_param(fcx.llfn, llarg_idx);\n+                llarg_idx += 1;\n+\n+                if arg_is_indirect(ccx, arg_ty) {\n+                    memcpy_ty(bcx, lldestptr, arg, arg_ty);\n+                } else {\n+                    store_ty(bcx, arg, lldestptr, arg_ty);\n+                }\n+            }\n         }\n         adt::trans_set_discr(bcx, &*repr, dest, disr);\n     }"}, {"sha": "d7ce50082f1d3fea0f9d4d833899ff46592b9507", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a04784f7f9fd7f45a59d0d69de0f326881f55f43/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04784f7f9fd7f45a59d0d69de0f326881f55f43/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=a04784f7f9fd7f45a59d0d69de0f326881f55f43", "patch": "@@ -291,9 +291,6 @@ pub fn get_dataptr(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n     GEPi(bcx, fat_ptr, &[0, abi::FAT_PTR_ADDR])\n }\n \n-pub fn make_fat_ptr(bcx: Block, ty: Type, data: ValueRef, extra: ValueRef) -> ValueRef {\n-    InsertValue(bcx, InsertValue(bcx, C_undef(ty), data, 0), extra, 1)\n-}\n pub fn copy_fat_ptr(bcx: Block, src_ptr: ValueRef, dst_ptr: ValueRef) {\n     Store(bcx, Load(bcx, get_dataptr(bcx, src_ptr)), get_dataptr(bcx, dst_ptr));\n     Store(bcx, Load(bcx, get_len(bcx, src_ptr)), get_len(bcx, dst_ptr));"}]}