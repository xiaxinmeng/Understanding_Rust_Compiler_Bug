{"sha": "1cc43ab7f4a4e1c4d3400302566a5d6c86532d32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjYzQzYWI3ZjRhNGUxYzRkMzQwMDMwMjU2NmE1ZDZjODY1MzJkMzI=", "commit": {"author": {"name": "Ryan Levick", "email": "me@ryanlevick.com", "date": "2021-08-13T09:44:29Z"}, "committer": {"name": "Ryan Levick", "email": "me@ryanlevick.com", "date": "2021-08-13T09:46:08Z"}, "message": "Add documentation on how whether a generated return type should be focused or not", "tree": {"sha": "ffd7da268969f75a21685545cf9a0c2d37ec3c17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffd7da268969f75a21685545cf9a0c2d37ec3c17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cc43ab7f4a4e1c4d3400302566a5d6c86532d32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cc43ab7f4a4e1c4d3400302566a5d6c86532d32", "html_url": "https://github.com/rust-lang/rust/commit/1cc43ab7f4a4e1c4d3400302566a5d6c86532d32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cc43ab7f4a4e1c4d3400302566a5d6c86532d32/comments", "author": {"login": "rylev", "id": 1327285, "node_id": "MDQ6VXNlcjEzMjcyODU=", "avatar_url": "https://avatars.githubusercontent.com/u/1327285?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rylev", "html_url": "https://github.com/rylev", "followers_url": "https://api.github.com/users/rylev/followers", "following_url": "https://api.github.com/users/rylev/following{/other_user}", "gists_url": "https://api.github.com/users/rylev/gists{/gist_id}", "starred_url": "https://api.github.com/users/rylev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rylev/subscriptions", "organizations_url": "https://api.github.com/users/rylev/orgs", "repos_url": "https://api.github.com/users/rylev/repos", "events_url": "https://api.github.com/users/rylev/events{/privacy}", "received_events_url": "https://api.github.com/users/rylev/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rylev", "id": 1327285, "node_id": "MDQ6VXNlcjEzMjcyODU=", "avatar_url": "https://avatars.githubusercontent.com/u/1327285?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rylev", "html_url": "https://github.com/rylev", "followers_url": "https://api.github.com/users/rylev/followers", "following_url": "https://api.github.com/users/rylev/following{/other_user}", "gists_url": "https://api.github.com/users/rylev/gists{/gist_id}", "starred_url": "https://api.github.com/users/rylev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rylev/subscriptions", "organizations_url": "https://api.github.com/users/rylev/orgs", "repos_url": "https://api.github.com/users/rylev/repos", "events_url": "https://api.github.com/users/rylev/events{/privacy}", "received_events_url": "https://api.github.com/users/rylev/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5c46e5a88a5f26d96406d43eaaa58acf646a5b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5c46e5a88a5f26d96406d43eaaa58acf646a5b6", "html_url": "https://github.com/rust-lang/rust/commit/a5c46e5a88a5f26d96406d43eaaa58acf646a5b6"}], "stats": {"total": 33, "additions": 21, "deletions": 12}, "files": [{"sha": "f1dd892dbf401cc65981b9c2d270327750782836", "filename": "crates/ide_assists/src/handlers/generate_function.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1cc43ab7f4a4e1c4d3400302566a5d6c86532d32/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc43ab7f4a4e1c4d3400302566a5d6c86532d32/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=1cc43ab7f4a4e1c4d3400302566a5d6c86532d32", "patch": "@@ -172,7 +172,7 @@ struct FunctionTemplate {\n     leading_ws: String,\n     fn_def: ast::Fn,\n     ret_type: Option<ast::RetType>,\n-    should_focus_tail_expr: bool,\n+    should_focus_return_type: bool,\n     trailing_ws: String,\n     file: FileId,\n     tail_expr: ast::Expr,\n@@ -182,7 +182,8 @@ impl FunctionTemplate {\n     fn to_string(&self, cap: Option<SnippetCap>) -> String {\n         let f = match cap {\n             Some(cap) => {\n-                let cursor = if self.should_focus_tail_expr {\n+                let cursor = if self.should_focus_return_type {\n+                    // Focus the return type if there is one\n                     if let Some(ref ret_type) = self.ret_type {\n                         ret_type.syntax()\n                     } else {\n@@ -206,7 +207,7 @@ struct FunctionBuilder {\n     type_params: Option<ast::GenericParamList>,\n     params: ast::ParamList,\n     ret_type: Option<ast::RetType>,\n-    should_focus_tail_expr: bool,\n+    should_focus_return_type: bool,\n     file: FileId,\n     needs_pub: bool,\n     is_async: bool,\n@@ -239,7 +240,7 @@ impl FunctionBuilder {\n         let await_expr = call.syntax().parent().and_then(ast::AwaitExpr::cast);\n         let is_async = await_expr.is_some();\n \n-        let (ret_type, should_focus_tail_expr) =\n+        let (ret_type, should_focus_return_type) =\n             make_return_type(ctx, &ast::Expr::CallExpr(call.clone()), target_module);\n \n         Some(Self {\n@@ -248,7 +249,7 @@ impl FunctionBuilder {\n             type_params,\n             params,\n             ret_type,\n-            should_focus_tail_expr,\n+            should_focus_return_type,\n             file,\n             needs_pub,\n             is_async,\n@@ -284,7 +285,7 @@ impl FunctionBuilder {\n         let await_expr = call.syntax().parent().and_then(ast::AwaitExpr::cast);\n         let is_async = await_expr.is_some();\n \n-        let (ret_type, should_focus_tail_expr) =\n+        let (ret_type, should_focus_return_type) =\n             make_return_type(ctx, &ast::Expr::MethodCallExpr(call.clone()), target_module);\n \n         Some(Self {\n@@ -293,7 +294,7 @@ impl FunctionBuilder {\n             type_params,\n             params,\n             ret_type,\n-            should_focus_tail_expr,\n+            should_focus_return_type,\n             file,\n             needs_pub,\n             is_async,\n@@ -336,28 +337,36 @@ impl FunctionBuilder {\n         FunctionTemplate {\n             insert_offset,\n             leading_ws,\n-            // PANIC: we guarantee we always create a function with a return type\n             ret_type: fn_def.ret_type(),\n             // PANIC: we guarantee we always create a function body with a tail expr\n             tail_expr: fn_def.body().unwrap().tail_expr().unwrap(),\n-            should_focus_tail_expr: self.should_focus_tail_expr,\n+            should_focus_return_type: self.should_focus_return_type,\n             fn_def,\n             trailing_ws,\n             file: self.file,\n         }\n     }\n }\n \n+/// Makes an optional return type along with whether the return type should be focused by the cursor.\n+/// If we cannot infer what the return type should be, we create unit as a placeholder.\n+///\n+/// The rule for whether we focus a return type or not (and thus focus the function body),\n+/// is rather simple:\n+/// * If we could *not* infer what the return type should be, focus it (so the user can fill-in\n+/// the correct return type).\n+/// * If we could infer the return type, don't focus it (and thus focus the function body) so the\n+/// user can change the `todo!` function body.\n fn make_return_type(\n     ctx: &AssistContext,\n     call: &ast::Expr,\n     target_module: Module,\n ) -> (Option<ast::RetType>, bool) {\n-    let (ret_ty, should_focus_tail_expr) = {\n+    let (ret_ty, should_focus_return_type) = {\n         match ctx.sema.type_of_expr(call).map(TypeInfo::original) {\n-            Some(ty) if ty.is_unit() => (None, false),\n             Some(ty) if ty.is_unknown() => (Some(make::ty_unit()), true),\n             None => (Some(make::ty_unit()), true),\n+            Some(ty) if ty.is_unit() => (None, false),\n             Some(ty) => {\n                 let rendered = ty.display_source_code(ctx.db(), target_module.into());\n                 match rendered {\n@@ -368,7 +377,7 @@ fn make_return_type(\n         }\n     };\n     let ret_type = ret_ty.map(|rt| make::ret_type(rt));\n-    (ret_type, should_focus_tail_expr)\n+    (ret_type, should_focus_return_type)\n }\n \n enum GeneratedFunctionTarget {"}]}