{"sha": "2f3e36f51a7055da3b55253edad7df594b0711d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmM2UzNmY1MWE3MDU1ZGEzYjU1MjUzZWRhZDdkZjU5NGIwNzExZDc=", "commit": {"author": {"name": "lqd", "email": "remy.rakic+github@gmail.com", "date": "2019-07-16T15:30:41Z"}, "committer": {"name": "lqd", "email": "remy.rakic+github@gmail.com", "date": "2019-07-22T10:46:53Z"}, "message": "Polonius: generate `killed` facts for assignments to projections", "tree": {"sha": "32360e427c73ce31ea6a8651d2dedfc46ff2d769", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32360e427c73ce31ea6a8651d2dedfc46ff2d769"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f3e36f51a7055da3b55253edad7df594b0711d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f3e36f51a7055da3b55253edad7df594b0711d7", "html_url": "https://github.com/rust-lang/rust/commit/2f3e36f51a7055da3b55253edad7df594b0711d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f3e36f51a7055da3b55253edad7df594b0711d7/comments", "author": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "823ab42e66cc966098030616e36e4aa7417dcf7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/823ab42e66cc966098030616e36e4aa7417dcf7f", "html_url": "https://github.com/rust-lang/rust/commit/823ab42e66cc966098030616e36e4aa7417dcf7f"}], "stats": {"total": 89, "additions": 75, "deletions": 14}, "files": [{"sha": "95c3299693b68eabbf5ffa4e96bf2427f11b4158", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 75, "deletions": 14, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/2f3e36f51a7055da3b55253edad7df594b0711d7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f3e36f51a7055da3b55253edad7df594b0711d7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=2f3e36f51a7055da3b55253edad7df594b0711d7", "patch": "@@ -3,12 +3,15 @@ use crate::borrow_check::location::LocationTable;\n use crate::borrow_check::nll::ToRegionVid;\n use crate::borrow_check::nll::facts::AllFacts;\n use crate::borrow_check::nll::region_infer::values::LivenessValues;\n+use crate::borrow_check::places_conflict;\n use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n-use rustc::mir::{BasicBlock, BasicBlockData, Location, Body, Place, PlaceBase, Rvalue, TerminatorKind};\n-use rustc::mir::{Local, SourceInfo, Statement, StatementKind, Terminator};\n-use rustc::mir::UserTypeProjection;\n+use rustc::mir::{\n+    BasicBlock, BasicBlockData, Body, Local, Location, Place, PlaceBase, Projection,\n+    ProjectionElem, Rvalue, SourceInfo, Statement, StatementKind, Terminator, TerminatorKind,\n+    UserTypeProjection,\n+};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, RegionVid, Ty};\n use rustc::ty::subst::SubstsRef;\n@@ -27,6 +30,7 @@ pub(super) fn generate_constraints<'cx, 'tcx>(\n         liveness_constraints,\n         location_table,\n         all_facts,\n+        body,\n     };\n \n     for (bb, data) in body.basic_blocks().iter_enumerated() {\n@@ -41,6 +45,7 @@ struct ConstraintGeneration<'cg, 'cx, 'tcx> {\n     location_table: &'cg LocationTable,\n     liveness_constraints: &'cg mut LivenessValues<RegionVid>,\n     borrow_set: &'cg BorrowSet<'tcx>,\n+    body: &'cg Body<'tcx>,\n }\n \n impl<'cg, 'cx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'tcx> {\n@@ -212,17 +217,73 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n     /// as `killed`. For example, when assigning to a local, or on a call's return destination.\n     fn record_killed_borrows_for_place(&mut self, place: &Place<'tcx>, location: Location) {\n         if let Some(all_facts) = self.all_facts {\n-            if let Place {\n-                base: PlaceBase::Local(local),\n-                projection: None,\n-            } = place {\n-                record_killed_borrows_for_local(\n-                    all_facts,\n-                    self.borrow_set,\n-                    self.location_table,\n-                    local,\n-                    location,\n-                );\n+            // Depending on the `Place` we're killing:\n+            // - if it's a local, or a single deref of a local,\n+            //   we kill all the borrows on the local.\n+            // - if it's a deeper projection, we have to filter which\n+            //   of the borrows are killed: the ones whose `borrowed_place`\n+            //   conflicts with the `place`.\n+            match place {\n+                Place {\n+                    base: PlaceBase::Local(local),\n+                    projection: None,\n+                } |\n+                Place {\n+                    base: PlaceBase::Local(local),\n+                    projection: Some(box Projection {\n+                        base: None,\n+                        elem: ProjectionElem::Deref,\n+                    }),\n+                } => {\n+                    debug!(\n+                        \"Recording `killed` facts for borrows of local={:?} at location={:?}\",\n+                        local, location\n+                    );\n+\n+                    record_killed_borrows_for_local(\n+                        all_facts,\n+                        self.borrow_set,\n+                        self.location_table,\n+                        local,\n+                        location,\n+                    );\n+                }\n+\n+                Place {\n+                    base: PlaceBase::Static(_),\n+                    ..\n+                } => {\n+                    // Ignore kills of static or static mut variables.\n+                }\n+\n+                Place {\n+                    base: PlaceBase::Local(local),\n+                    projection: Some(_),\n+                } => {\n+                    // Kill conflicting borrows of the innermost local.\n+                    debug!(\n+                        \"Recording `killed` facts for borrows of \\\n+                            innermost projected local={:?} at location={:?}\",\n+                        local, location\n+                    );\n+\n+                    if let Some(borrow_indices) = self.borrow_set.local_map.get(local) {\n+                        for &borrow_index in borrow_indices {\n+                            let places_conflict = places_conflict::places_conflict(\n+                                self.infcx.tcx,\n+                                self.body,\n+                                &self.borrow_set.borrows[borrow_index].borrowed_place,\n+                                place,\n+                                places_conflict::PlaceConflictBias::NoOverlap,\n+                            );\n+\n+                            if places_conflict {\n+                                let location_index = self.location_table.mid_index(location);\n+                                all_facts.killed.push((borrow_index, location_index));\n+                            }\n+                        }\n+                    }\n+                }\n             }\n         }\n     }"}]}