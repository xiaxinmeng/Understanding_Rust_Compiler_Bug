{"sha": "77e9bf9b5fdcd4262e2d9badb42b912f5728d90b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3ZTliZjliNWZkY2Q0MjYyZTJkOWJhZGI0MmI5MTJmNTcyOGQ5MGI=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-10-11T15:43:34Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-10-11T15:43:34Z"}, "message": "Merge #116\n\n116: Collapse comments upon join r=matklad a=aochagavia\n\nTodo:\r\n\r\n- [x] Write tests\r\n- [x] Resolve fixmes\r\n- [x] Implement `comment_start_length` using the parser\r\n\r\nI left a bunch of questions as fixmes. Can someone take a look at them? Also, I would love to use the parser to calculate the length of the leading characters in a comment (`//`, `///`, `//!`, `/*`), so any hints are greatly appreciated.\n\nCo-authored-by: Adolfo Ochagav\u00eda <aochagavia92@gmail.com>\nCo-authored-by: Adolfo Ochagav\u00eda <github@adolfo.ochagavia.xyz>", "tree": {"sha": "3f318ed358723e229dc6101404d7b607bbeabd51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f318ed358723e229dc6101404d7b607bbeabd51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77e9bf9b5fdcd4262e2d9badb42b912f5728d90b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77e9bf9b5fdcd4262e2d9badb42b912f5728d90b", "html_url": "https://github.com/rust-lang/rust/commit/77e9bf9b5fdcd4262e2d9badb42b912f5728d90b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77e9bf9b5fdcd4262e2d9badb42b912f5728d90b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "9b155c89764b8413df6b32edfde94fce1d9c15ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b155c89764b8413df6b32edfde94fce1d9c15ec", "html_url": "https://github.com/rust-lang/rust/commit/9b155c89764b8413df6b32edfde94fce1d9c15ec"}, {"sha": "6fe77db41307da8ead8a0b0355488221b61c0349", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fe77db41307da8ead8a0b0355488221b61c0349", "html_url": "https://github.com/rust-lang/rust/commit/6fe77db41307da8ead8a0b0355488221b61c0349"}], "stats": {"total": 257, "additions": 199, "deletions": 58}, "files": [{"sha": "1dc658f9b0947476266ef7d47965ba1b63b0a296", "filename": "crates/ra_editor/src/typing.rs", "status": "modified", "additions": 137, "deletions": 58, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/77e9bf9b5fdcd4262e2d9badb42b912f5728d90b/crates%2Fra_editor%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77e9bf9b5fdcd4262e2d9badb42b912f5728d90b/crates%2Fra_editor%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Ftyping.rs?ref=77e9bf9b5fdcd4262e2d9badb42b912f5728d90b", "patch": "@@ -30,6 +30,7 @@ pub fn join_lines(file: &File, range: TextRange) -> LocalEdit {\n     } else {\n         range\n     };\n+\n     let node = find_covering_node(file.syntax(), range);\n     let mut edit = EditBuilder::new();\n     for node in node.descendants() {\n@@ -57,14 +58,19 @@ pub fn join_lines(file: &File, range: TextRange) -> LocalEdit {\n }\n \n pub fn on_enter(file: &File, offset: TextUnit) -> Option<LocalEdit> {\n-    let comment = find_leaf_at_offset(file.syntax(), offset).left_biased().filter(|it| it.kind() == COMMENT)?;\n-    let prefix = comment_preffix(comment)?;\n-    if offset < comment.range().start() + TextUnit::of_str(prefix) {\n+    let comment = find_leaf_at_offset(file.syntax(), offset).left_biased().and_then(|it| ast::Comment::cast(it))?;\n+\n+    if let ast::CommentFlavor::Multiline = comment.flavor() {\n+        return None;\n+    }\n+\n+    let prefix = comment.prefix();\n+    if offset < comment.syntax().range().start() + TextUnit::of_str(prefix) + TextUnit::from(1) {\n         return None;\n     }\n \n-    let indent = node_indent(file, comment)?;\n-    let inserted = format!(\"\\n{}{}\", indent, prefix);\n+    let indent = node_indent(file, comment.syntax())?;\n+    let inserted = format!(\"\\n{}{} \", indent, prefix);\n     let cursor_position = offset + TextUnit::of_str(&inserted);\n     let mut edit = EditBuilder::new();\n     edit.insert(offset, inserted);\n@@ -74,20 +80,6 @@ pub fn on_enter(file: &File, offset: TextUnit) -> Option<LocalEdit> {\n     })\n }\n \n-fn comment_preffix(comment: SyntaxNodeRef) -> Option<&'static str> {\n-    let text = comment.leaf_text().unwrap();\n-    let res = if text.starts_with(\"///\") {\n-        \"/// \"\n-    } else if text.starts_with(\"//!\") {\n-        \"//! \"\n-    } else if text.starts_with(\"//\") {\n-        \"// \"\n-    } else {\n-        return None;\n-    };\n-    Some(res)\n-}\n-\n fn node_indent<'a>(file: &'a File, node: SyntaxNodeRef) -> Option<&'a str> {\n     let ws = match find_leaf_at_offset(file.syntax(), node.range().start()) {\n         LeafAtOffset::Between(l, r) => {\n@@ -139,41 +131,60 @@ fn remove_newline(\n     node_text: &str,\n     offset: TextUnit,\n ) {\n-    if node.kind() == WHITESPACE && node_text.bytes().filter(|&b| b == b'\\n').count() == 1 {\n-        if join_single_expr_block(edit, node).is_some() {\n-            return\n-        }\n-        match (node.prev_sibling(), node.next_sibling()) {\n-            (Some(prev), Some(next)) => {\n-                let range = TextRange::from_to(prev.range().start(), node.range().end());\n-                if is_trailing_comma(prev.kind(), next.kind()) {\n-                    edit.delete(range);\n-                } else if no_space_required(prev.kind(), next.kind()) {\n-                    edit.delete(node.range());\n-                } else if prev.kind() == COMMA && next.kind() == R_CURLY {\n-                    edit.replace(range, \" \".to_string());\n-                } else {\n-                    edit.replace(\n-                        node.range(),\n-                        compute_ws(prev, next).to_string(),\n-                    );\n-                }\n-                return;\n-            }\n-            _ => (),\n-        }\n+    if node.kind() != WHITESPACE || node_text.bytes().filter(|&b| b == b'\\n').count() != 1 {\n+        // The node is either the first or the last in the file\n+        let suff = &node_text[TextRange::from_to(\n+            offset - node.range().start() + TextUnit::of_char('\\n'),\n+            TextUnit::of_str(node_text),\n+        )];\n+        let spaces = suff.bytes().take_while(|&b| b == b' ').count();\n+\n+        edit.replace(\n+            TextRange::offset_len(offset, ((spaces + 1) as u32).into()),\n+            \" \".to_string(),\n+        );\n+        return;\n     }\n \n-    let suff = &node_text[TextRange::from_to(\n-        offset - node.range().start() + TextUnit::of_char('\\n'),\n-        TextUnit::of_str(node_text),\n-    )];\n-    let spaces = suff.bytes().take_while(|&b| b == b' ').count();\n+    // Special case that turns something like:\n+    //\n+    // ```\n+    // my_function({<|>\n+    //    <some-expr>\n+    // })\n+    // ```\n+    //\n+    // into `my_function(<some-expr>)`\n+    if join_single_expr_block(edit, node).is_some() {\n+        return\n+    }\n \n-    edit.replace(\n-        TextRange::offset_len(offset, ((spaces + 1) as u32).into()),\n-        \" \".to_string(),\n-    );\n+    // The node is between two other nodes\n+    let prev = node.prev_sibling().unwrap();\n+    let next = node.next_sibling().unwrap();\n+    if is_trailing_comma(prev.kind(), next.kind()) {\n+        // Removes: trailing comma, newline (incl. surrounding whitespace)\n+        edit.delete(TextRange::from_to(prev.range().start(), node.range().end()));\n+    } else if prev.kind() == COMMA && next.kind() == R_CURLY {\n+        // Removes: comma, newline (incl. surrounding whitespace)\n+        // Adds: a single whitespace\n+        edit.replace(\n+            TextRange::from_to(prev.range().start(), node.range().end()),\n+            \" \".to_string()\n+        );\n+    } else if let (Some(_), Some(next)) = (ast::Comment::cast(prev), ast::Comment::cast(next)) {\n+        // Removes: newline (incl. surrounding whitespace), start of the next comment\n+        edit.delete(TextRange::from_to(\n+            node.range().start(),\n+            next.syntax().range().start() + TextUnit::of_str(next.prefix())\n+        ));\n+    } else {\n+        // Remove newline but add a computed amount of whitespace characters\n+        edit.replace(\n+            node.range(),\n+            compute_ws(prev, next).to_string(),\n+        );\n+    }\n }\n \n fn is_trailing_comma(left: SyntaxKind, right: SyntaxKind) -> bool {\n@@ -183,13 +194,6 @@ fn is_trailing_comma(left: SyntaxKind, right: SyntaxKind) -> bool {\n     }\n }\n \n-fn no_space_required(left: SyntaxKind, right: SyntaxKind) -> bool {\n-    match (left, right) {\n-       (_, DOT) => true,\n-        _ => false\n-    }\n-}\n-\n fn join_single_expr_block(\n     edit: &mut EditBuilder,\n     node: SyntaxNodeRef,\n@@ -231,6 +235,7 @@ fn compute_ws(left: SyntaxNodeRef, right: SyntaxNodeRef) -> &'static str {\n     }\n     match right.kind() {\n         R_PAREN | R_BRACK => return \"\",\n+        DOT => return \"\",\n         _ => (),\n     }\n     \" \"\n@@ -291,6 +296,80 @@ fn foo() {\n }\");\n     }\n \n+    #[test]\n+    fn test_join_lines_normal_comments() {\n+        check_join_lines(r\"\n+fn foo() {\n+    // Hello<|>\n+    // world!\n+}\n+\", r\"\n+fn foo() {\n+    // Hello<|> world!\n+}\n+\");\n+    }\n+\n+    #[test]\n+    fn test_join_lines_doc_comments() {\n+        check_join_lines(r\"\n+fn foo() {\n+    /// Hello<|>\n+    /// world!\n+}\n+\", r\"\n+fn foo() {\n+    /// Hello<|> world!\n+}\n+\");\n+    }\n+\n+    #[test]\n+    fn test_join_lines_mod_comments() {\n+        check_join_lines(r\"\n+fn foo() {\n+    //! Hello<|>\n+    //! world!\n+}\n+\", r\"\n+fn foo() {\n+    //! Hello<|> world!\n+}\n+\");\n+    }\n+\n+    #[test]\n+    fn test_join_lines_multiline_comments_1() {\n+        check_join_lines(r\"\n+fn foo() {\n+    // Hello<|>\n+    /* world! */\n+}\n+\", r\"\n+fn foo() {\n+    // Hello<|> world! */\n+}\n+\");\n+    }\n+\n+    #[test]\n+    fn test_join_lines_multiline_comments_2() {\n+        check_join_lines(r\"\n+fn foo() {\n+    // The<|>\n+    /* quick\n+    brown\n+    fox! */\n+}\n+\", r\"\n+fn foo() {\n+    // The<|> quick\n+    brown\n+    fox! */\n+}\n+\");\n+    }\n+\n     fn check_join_lines_sel(before: &str, after: &str) {\n         let (sel, before) = extract_range(before);\n         let file = File::parse(&before);"}, {"sha": "ef7b5b1a1f035e9c0edef3a605f0609f16faa576", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/77e9bf9b5fdcd4262e2d9badb42b912f5728d90b/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77e9bf9b5fdcd4262e2d9badb42b912f5728d90b/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=77e9bf9b5fdcd4262e2d9badb42b912f5728d90b", "patch": "@@ -231,6 +231,24 @@ impl<'a> AstNode<'a> for CastExpr<'a> {\n \n impl<'a> CastExpr<'a> {}\n \n+// Comment\n+#[derive(Debug, Clone, Copy)]\n+pub struct Comment<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for Comment<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            COMMENT => Some(Comment { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> Comment<'a> {}\n+\n // Condition\n #[derive(Debug, Clone, Copy)]\n pub struct Condition<'a> {"}, {"sha": "10dac72e5fac5cd00b1b7c47aaa8284b47ed6555", "filename": "crates/ra_syntax/src/ast/mod.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/77e9bf9b5fdcd4262e2d9badb42b912f5728d90b/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77e9bf9b5fdcd4262e2d9badb42b912f5728d90b/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs?ref=77e9bf9b5fdcd4262e2d9badb42b912f5728d90b", "patch": "@@ -99,6 +99,49 @@ impl<'a> Lifetime<'a> {\n     }\n }\n \n+impl<'a> Comment<'a> {\n+    pub fn text(&self) -> SmolStr {\n+        self.syntax().leaf_text().unwrap().clone()\n+    }\n+\n+    pub fn flavor(&self) -> CommentFlavor {\n+        let text = self.text();\n+        if text.starts_with(\"///\") {\n+            CommentFlavor::Doc\n+        } else if text.starts_with(\"//!\") {\n+            CommentFlavor::ModuleDoc\n+        } else if text.starts_with(\"//\") {\n+            CommentFlavor::Line\n+        } else {\n+            CommentFlavor::Multiline\n+        }\n+    }\n+\n+    pub fn prefix(&self) -> &'static str {\n+        self.flavor().prefix()\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub enum CommentFlavor {\n+    Line,\n+    Doc,\n+    ModuleDoc,\n+    Multiline\n+}\n+\n+impl CommentFlavor {\n+    pub fn prefix(&self) -> &'static str {\n+        use self::CommentFlavor::*;\n+        match *self {\n+            Line => \"//\",\n+            Doc => \"///\",\n+            ModuleDoc => \"//!\",\n+            Multiline => \"/*\"\n+        }\n+    }\n+}\n+\n impl<'a> Name<'a> {\n     pub fn text(&self) -> SmolStr {\n         let ident = self.syntax().first_child()"}, {"sha": "9da0c2c13fd9bc9d9ce7741d7805df4bab47e9bd", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/77e9bf9b5fdcd4262e2d9badb42b912f5728d90b/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/77e9bf9b5fdcd4262e2d9badb42b912f5728d90b/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=77e9bf9b5fdcd4262e2d9badb42b912f5728d90b", "patch": "@@ -537,5 +537,6 @@ Grammar(\n         \"PathSegment\": (\n             options: [ \"NameRef\" ]\n         ),\n+        \"Comment\": (),\n     },\n )"}]}