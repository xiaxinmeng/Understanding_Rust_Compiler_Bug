{"sha": "e313d8b290ddd129f35ce0a6ae319bbd2c19a73a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMTNkOGIyOTBkZGQxMjlmMzVjZTBhNmFlMzE5YmJkMmMxOWE3M2E=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-09-25T23:53:26Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-10-26T19:41:17Z"}, "message": "change match checking to use HAIR\n\nno intended functional changes", "tree": {"sha": "168d81ce0777f9e69b14bee6b05a59d117da4746", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/168d81ce0777f9e69b14bee6b05a59d117da4746"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e313d8b290ddd129f35ce0a6ae319bbd2c19a73a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e313d8b290ddd129f35ce0a6ae319bbd2c19a73a", "html_url": "https://github.com/rust-lang/rust/commit/e313d8b290ddd129f35ce0a6ae319bbd2c19a73a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e313d8b290ddd129f35ce0a6ae319bbd2c19a73a/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04a92a1f567ec39558235d0c8ecf12de5d297139", "url": "https://api.github.com/repos/rust-lang/rust/commits/04a92a1f567ec39558235d0c8ecf12de5d297139", "html_url": "https://github.com/rust-lang/rust/commit/04a92a1f567ec39558235d0c8ecf12de5d297139"}], "stats": {"total": 643, "additions": 383, "deletions": 260}, "files": [{"sha": "683ba90adf94ab6bb54b03ab0e3bb1794aace828", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e313d8b290ddd129f35ce0a6ae319bbd2c19a73a/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e313d8b290ddd129f35ce0a6ae319bbd2c19a73a/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=e313d8b290ddd129f35ce0a6ae319bbd2c19a73a", "patch": "@@ -330,6 +330,7 @@ dependencies = [\n name = \"rustc_const_eval\"\n version = \"0.0.0\"\n dependencies = [\n+ \"arena 0.0.0\",\n  \"graphviz 0.0.0\",\n  \"log 0.0.0\",\n  \"rustc 0.0.0\","}, {"sha": "0e5cbce8639bede34939199f10ccd95a9b66ee42", "filename": "src/librustc_const_eval/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e313d8b290ddd129f35ce0a6ae319bbd2c19a73a/src%2Flibrustc_const_eval%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e313d8b290ddd129f35ce0a6ae319bbd2c19a73a/src%2Flibrustc_const_eval%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2FCargo.toml?ref=e313d8b290ddd129f35ce0a6ae319bbd2c19a73a", "patch": "@@ -9,6 +9,7 @@ path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n+arena = { path = \"../libarena\" }\n log = { path = \"../liblog\" }\n serialize = { path = \"../libserialize\" }\n rustc = { path = \"../librustc\" }"}, {"sha": "ab2a7b01bb240fe3cd19bfb311cffa24ce21d9c2", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 199, "deletions": 240, "changes": 439, "blob_url": "https://github.com/rust-lang/rust/blob/e313d8b290ddd129f35ce0a6ae319bbd2c19a73a/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e313d8b290ddd129f35ce0a6ae319bbd2c19a73a/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=e313d8b290ddd129f35ce0a6ae319bbd2c19a73a", "patch": "@@ -13,74 +13,90 @@ use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n use rustc::middle::const_val::ConstVal;\n-use eval::{eval_const_expr, compare_const_vals};\n+use eval::{compare_const_vals};\n+\n+use rustc_data_structures::indexed_vec::Idx;\n+\n+use pattern::{FieldPattern, Pattern, PatternKind};\n+use pattern::{PatternFoldable, PatternFolder};\n \n-use rustc::hir::def::*;\n use rustc::hir::def_id::{DefId};\n use rustc::hir::pat_util::def_to_path;\n-use rustc::ty::{self, Ty, TyCtxt};\n-\n-use std::cmp::Ordering;\n-use std::fmt;\n-use std::iter::{FromIterator, IntoIterator, repeat};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n use rustc::hir;\n+use rustc::hir::def::CtorKind;\n use rustc::hir::{Pat, PatKind};\n-use rustc::hir::print::pat_to_string;\n use rustc::util::common::ErrorReported;\n \n use syntax::ast::{self, DUMMY_NODE_ID};\n use syntax::codemap::Spanned;\n use syntax::ptr::P;\n use syntax_pos::{Span, DUMMY_SP};\n \n-pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n-    id: DUMMY_NODE_ID,\n-    node: PatKind::Wild,\n-    span: DUMMY_SP\n-};\n+use arena::TypedArena;\n \n-pub const DUMMY_WILD_PATTERN : Pattern<'static, 'static> = Pattern {\n-    pat: DUMMY_WILD_PAT,\n-    pattern_ty: None\n-};\n+use std::cmp::Ordering;\n+use std::fmt;\n+use std::iter::{FromIterator, IntoIterator, repeat};\n \n-#[derive(Copy, Clone)]\n-pub struct Pattern<'a, 'tcx> {\n-    pat: &'a Pat,\n-    pattern_ty: Option<Ty<'tcx>>\n+pub fn lower_pat<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: &Pat)\n+                           -> &'a Pattern<'tcx>\n+{\n+    cx.pattern_arena.alloc(\n+        LiteralExpander.fold_pattern(&Pattern::from_hir(cx.tcx, pat))\n+    )\n }\n \n-impl<'a, 'tcx> Pattern<'a, 'tcx> {\n-    fn as_raw(self) -> &'a Pat {\n-        let mut pat = self.pat;\n-\n-        while let PatKind::Binding(.., Some(ref s)) = pat.node {\n-            pat = s;\n+struct LiteralExpander;\n+impl<'tcx> PatternFolder<'tcx> for LiteralExpander {\n+    fn fold_pattern(&mut self, pat: &Pattern<'tcx>) -> Pattern<'tcx> {\n+        match (&pat.ty.sty, &*pat.kind) {\n+            (&ty::TyRef(_, mt), &PatternKind::Constant { ref value }) => {\n+                Pattern {\n+                    ty: pat.ty,\n+                    span: pat.span,\n+                    kind: box PatternKind::Deref {\n+                        subpattern: Pattern {\n+                            ty: mt.ty,\n+                            span: pat.span,\n+                            kind: box PatternKind::Constant { value: value.clone() },\n+                        }\n+                    }\n+                }\n+            }\n+            (_, &PatternKind::Binding { subpattern: Some(ref s), .. }) => {\n+                s.fold_with(self)\n+            }\n+            _ => pat.super_fold_with(self)\n         }\n-\n-        return pat;\n-    }\n-\n-    pub fn span(self) -> Span {\n-        self.pat.span\n     }\n }\n \n-impl<'a, 'tcx> fmt::Debug for Pattern<'a, 'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}: {:?}\", pat_to_string(self.pat), self.pattern_ty)\n+pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n+    id: DUMMY_NODE_ID,\n+    node: PatKind::Wild,\n+    span: DUMMY_SP\n+};\n+\n+impl<'tcx> Pattern<'tcx> {\n+    fn is_wildcard(&self) -> bool {\n+        match *self.kind {\n+            PatternKind::Binding { subpattern: None, .. } | PatternKind::Wild =>\n+                true,\n+            _ => false\n+        }\n     }\n }\n \n-pub struct Matrix<'a, 'tcx>(Vec<Vec<Pattern<'a, 'tcx>>>);\n+pub struct Matrix<'a, 'tcx: 'a>(Vec<Vec<&'a Pattern<'tcx>>>);\n \n impl<'a, 'tcx> Matrix<'a, 'tcx> {\n     pub fn empty() -> Self {\n         Matrix(vec![])\n     }\n \n-    pub fn push(&mut self, row: Vec<Pattern<'a, 'tcx>>) {\n+    pub fn push(&mut self, row: Vec<&'a Pattern<'tcx>>) {\n         self.0.push(row)\n     }\n }\n@@ -129,8 +145,8 @@ impl<'a, 'tcx> fmt::Debug for Matrix<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> FromIterator<Vec<Pattern<'a, 'tcx>>> for Matrix<'a, 'tcx> {\n-    fn from_iter<T: IntoIterator<Item=Vec<Pattern<'a, 'tcx>>>>(iter: T) -> Self\n+impl<'a, 'tcx> FromIterator<Vec<&'a Pattern<'tcx>>> for Matrix<'a, 'tcx> {\n+    fn from_iter<T: IntoIterator<Item=Vec<&'a Pattern<'tcx>>>>(iter: T) -> Self\n     {\n         Matrix(iter.into_iter().collect())\n     }\n@@ -140,6 +156,34 @@ impl<'a, 'tcx> FromIterator<Vec<Pattern<'a, 'tcx>>> for Matrix<'a, 'tcx> {\n pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub param_env: ty::ParameterEnvironment<'tcx>,\n+    /// A wild pattern with an error type - it exists to avoid having to normalize\n+    /// associated types to get field types.\n+    pub wild_pattern: &'a Pattern<'tcx>,\n+    pub pattern_arena: &'a TypedArena<Pattern<'tcx>>,\n+}\n+\n+impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n+    pub fn create_and_enter<F, R>(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        param_env: ty::ParameterEnvironment<'tcx>,\n+        f: F) -> R\n+        where F: for<'b> FnOnce(MatchCheckCtxt<'b, 'tcx>) -> R\n+    {\n+        let wild_pattern = Pattern {\n+            ty: tcx.types.err,\n+            span: DUMMY_SP,\n+            kind: box PatternKind::Wild\n+        };\n+\n+        let pattern_arena = TypedArena::new();\n+\n+        f(MatchCheckCtxt {\n+            tcx: tcx,\n+            param_env: param_env,\n+            wild_pattern: &wild_pattern,\n+            pattern_arena: &pattern_arena,\n+        })\n+    }\n }\n \n #[derive(Clone, Debug, PartialEq)]\n@@ -163,7 +207,11 @@ impl Constructor {\n                                              -> &'a ty::VariantDefData<'tcx, 'container> {\n         match self {\n             &Variant(vid) => adt.variant_with_id(vid),\n-            _ => adt.struct_variant()\n+            &Single => {\n+                assert_eq!(adt.variants.len(), 1);\n+                &adt.variants[0]\n+            }\n+            _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt)\n         }\n     }\n }\n@@ -320,6 +368,7 @@ fn missing_constructors(cx: &MatchCheckCtxt, matrix: &Matrix,\n         matrix.0.iter()\n         .flat_map(|row| pat_constructors(cx, row[0], pcx).unwrap_or(vec![]))\n         .collect();\n+    debug!(\"used_constructors = {:?}\", used_constructors);\n     all_constructors(cx, pcx).into_iter()\n         .filter(|c| !used_constructors.contains(c))\n         .collect()\n@@ -335,28 +384,28 @@ fn all_constructors(_cx: &MatchCheckCtxt, pcx: PatternContext) -> Vec<Constructo\n             [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n         ty::TySlice(_) =>\n             (0..pcx.max_slice_length+1).map(|length| Slice(length)).collect(),\n-        ty::TyAdt(def, _) if def.is_enum() =>\n+        ty::TyAdt(def, _) if def.is_enum() && def.variants.len() > 1 =>\n             def.variants.iter().map(|v| Variant(v.did)).collect(),\n         _ => vec![Single]\n     }\n }\n \n-// Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n-//\n-// Whether a vector `v` of patterns is 'useful' in relation to a set of such\n-// vectors `m` is defined as there being a set of inputs that will match `v`\n-// but not any of the sets in `m`.\n-//\n-// This is used both for reachability checking (if a pattern isn't useful in\n-// relation to preceding patterns, it is not reachable) and exhaustiveness\n-// checking (if a wildcard pattern is useful in relation to a matrix, the\n-// matrix isn't exhaustive).\n-\n-// Note: is_useful doesn't work on empty types, as the paper notes.\n-// So it assumes that v is non-empty.\n+/// Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n+///\n+/// Whether a vector `v` of patterns is 'useful' in relation to a set of such\n+/// vectors `m` is defined as there being a set of inputs that will match `v`\n+/// but not any of the sets in `m`.\n+///\n+/// This is used both for reachability checking (if a pattern isn't useful in\n+/// relation to preceding patterns, it is not reachable) and exhaustiveness\n+/// checking (if a wildcard pattern is useful in relation to a matrix, the\n+/// matrix isn't exhaustive).\n+///\n+/// Note: is_useful doesn't work on empty types, as the paper notes.\n+/// So it assumes that v is non-empty.\n pub fn is_useful<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n                            matrix: &Matrix<'a, 'tcx>,\n-                           v: &[Pattern<'a, 'tcx>],\n+                           v: &[&'a Pattern<'tcx>],\n                            witness: WitnessPreference)\n                            -> Usefulness {\n     let &Matrix(ref rows) = matrix;\n@@ -375,17 +424,11 @@ pub fn is_useful<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n     assert!(rows.iter().all(|r| r.len() == v.len()));\n \n     let pcx = PatternContext {\n-        ty: match rows.iter().filter_map(|r| r[0].pattern_ty).next()\n-            .or_else(|| v[0].pattern_ty)\n-        {\n-            Some(ty) => ty,\n-            None => {\n-                // all patterns are wildcards - we can pick any type we want\n-                cx.tcx.types.bool\n-            }\n-        },\n-        max_slice_length: rows.iter().filter_map(|row| match row[0].pat.node {\n-            PatKind::Slice(ref before, _, ref after) => Some(before.len() + after.len()),\n+        ty: rows.iter().map(|r| r[0].ty).find(|ty| !ty.references_error())\n+            .unwrap_or(v[0].ty),\n+        max_slice_length: rows.iter().filter_map(|row| match *row[0].kind {\n+            PatternKind::Slice { ref prefix, slice: _, ref suffix } =>\n+                Some(prefix.len() + suffix.len()),\n             _ => None\n         }).max().map_or(0, |v| v + 1)\n     };\n@@ -407,9 +450,10 @@ pub fn is_useful<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n             }).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n         } else {\n             let matrix = rows.iter().filter_map(|r| {\n-                match r[0].as_raw().node {\n-                    PatKind::Binding(..) | PatKind::Wild => Some(r[1..].to_vec()),\n-                    _ => None,\n+                if r[0].is_wildcard() {\n+                    Some(r[1..].to_vec())\n+                } else {\n+                    None\n                 }\n             }).collect();\n             match is_useful(cx, &matrix, &v[1..], witness) {\n@@ -429,7 +473,7 @@ pub fn is_useful<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n fn is_useful_specialized<'a, 'tcx>(\n     cx: &MatchCheckCtxt<'a, 'tcx>,\n     &Matrix(ref m): &Matrix<'a, 'tcx>,\n-    v: &[Pattern<'a, 'tcx>],\n+    v: &[&'a Pattern<'tcx>],\n     ctor: Constructor,\n     lty: Ty<'tcx>,\n     witness: WitnessPreference) -> Usefulness\n@@ -459,42 +503,30 @@ fn is_useful_specialized<'a, 'tcx>(\n /// `[a, b, ..tail]` can match a slice of length 2, 3, 4 and so on.\n ///\n /// Returns None in case of a catch-all, which can't be specialized.\n-fn pat_constructors(cx: &MatchCheckCtxt,\n-                    p: Pattern,\n+fn pat_constructors(_cx: &MatchCheckCtxt,\n+                    pat: &Pattern,\n                     pcx: PatternContext)\n                     -> Option<Vec<Constructor>>\n {\n-    let pat = p.as_raw();\n-    match pat.node {\n-        PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) =>\n-            match cx.tcx.expect_def(pat.id) {\n-                Def::Variant(id) | Def::VariantCtor(id, _) => Some(vec![Variant(id)]),\n-                Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n-                Def::TyAlias(..) | Def::AssociatedTy(..) => Some(vec![Single]),\n-                Def::Const(..) | Def::AssociatedConst(..) =>\n-                    span_bug!(p.span(), \"const pattern should've been rewritten\"),\n-                def => span_bug!(p.span(), \"pat_constructors: unexpected definition {:?}\", def),\n-            },\n-        PatKind::Lit(ref expr) =>\n-            Some(vec![ConstantValue(eval_const_expr(cx.tcx, &expr))]),\n-        PatKind::Range(ref lo, ref hi) =>\n-            Some(vec![ConstantRange(eval_const_expr(cx.tcx, &lo), eval_const_expr(cx.tcx, &hi))]),\n-        PatKind::Slice(ref before, ref slice, ref after) =>\n-            match pcx.ty.sty {\n-                ty::TyArray(..) => Some(vec![Single]),\n-                ty::TySlice(_) if slice.is_some() => {\n-                    Some((before.len() + after.len()..pcx.max_slice_length+1)\n-                         .map(|length| Slice(length))\n-                         .collect())\n-                }\n-                ty::TySlice(_) => Some(vec!(Slice(before.len() + after.len()))),\n-                _ => span_bug!(pat.span, \"pat_constructors: unexpected \\\n-                                          slice pattern type {:?}\", pcx.ty)\n-            },\n-        PatKind::Box(..) | PatKind::Tuple(..) | PatKind::Ref(..) =>\n-            Some(vec![Single]),\n-        PatKind::Binding(..) | PatKind::Wild =>\n+    match *pat.kind {\n+        PatternKind::Binding { .. } | PatternKind::Wild =>\n             None,\n+        PatternKind::Leaf { .. } | PatternKind::Deref { .. } | PatternKind::Array { .. } =>\n+            Some(vec![Single]),\n+        PatternKind::Variant { adt_def, variant_index, .. } =>\n+            Some(vec![Variant(adt_def.variants[variant_index].did)]),\n+        PatternKind::Constant { ref value } =>\n+            Some(vec![ConstantValue(value.clone())]),\n+        PatternKind::Range { ref lo, ref hi } =>\n+            Some(vec![ConstantRange(lo.clone(), hi.clone())]),\n+        PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n+            let pat_len = prefix.len() + suffix.len();\n+            if slice.is_some() {\n+                Some((pat_len..pcx.max_slice_length+1).map(Slice).collect())\n+            } else {\n+                Some(vec![Slice(pat_len)])\n+            }\n+        }\n     }\n }\n \n@@ -540,20 +572,20 @@ fn range_covered_by_constructor(tcx: TyCtxt, span: Span,\n     Ok(cmp_from != Ordering::Less && cmp_to != Ordering::Greater)\n }\n \n-pub fn wrap_pat<'a, 'b, 'tcx>(cx: &MatchCheckCtxt<'b, 'tcx>,\n-                              pat: &'a Pat)\n-                              -> Pattern<'a, 'tcx>\n+fn patterns_for_variant<'a, 'tcx>(\n+    cx: &MatchCheckCtxt<'a, 'tcx>,\n+    subpatterns: &'a [FieldPattern<'tcx>],\n+    arity: usize)\n+    -> Vec<&'a Pattern<'tcx>>\n {\n-    let pat_ty = cx.tcx.pat_ty(pat);\n-    Pattern {\n-        pat: pat,\n-        pattern_ty: Some(match pat.node {\n-            PatKind::Binding(hir::BindByRef(..), ..) => {\n-                pat_ty.builtin_deref(false, ty::NoPreference).unwrap().ty\n-            }\n-            _ => pat_ty\n-        })\n+    let mut result = vec![cx.wild_pattern; arity];\n+\n+    for subpat in subpatterns {\n+        result[subpat.field.index()] = &subpat.pattern;\n     }\n+\n+    debug!(\"patterns_for_variant({:?}, {:?}) = {:?}\", subpatterns, arity, result);\n+    result\n }\n \n /// This is the main specialization step. It expands the first pattern in the given row\n@@ -564,150 +596,74 @@ pub fn wrap_pat<'a, 'b, 'tcx>(cx: &MatchCheckCtxt<'b, 'tcx>,\n /// different patterns.\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n-fn specialize<'a, 'b, 'tcx>(\n-    cx: &MatchCheckCtxt<'b, 'tcx>,\n-    r: &[Pattern<'a, 'tcx>],\n+fn specialize<'a, 'tcx>(\n+    cx: &MatchCheckCtxt<'a, 'tcx>,\n+    r: &[&'a Pattern<'tcx>],\n     constructor: &Constructor, col: usize, arity: usize)\n-    -> Option<Vec<Pattern<'a, 'tcx>>>\n+    -> Option<Vec<&'a Pattern<'tcx>>>\n {\n-    let pat = r[col].as_raw();\n-    let &Pat {\n-        id: pat_id, ref node, span: pat_span\n-    } = pat;\n-    let wpat = |pat: &'a Pat| wrap_pat(cx, pat);\n-\n-    let head: Option<Vec<Pattern>> = match *node {\n-        PatKind::Binding(..) | PatKind::Wild =>\n-            Some(vec![DUMMY_WILD_PATTERN; arity]),\n-\n-        PatKind::Path(..) => {\n-            match cx.tcx.expect_def(pat_id) {\n-                Def::Const(..) | Def::AssociatedConst(..) =>\n-                    span_bug!(pat_span, \"const pattern should've \\\n-                                         been rewritten\"),\n-                Def::VariantCtor(id, CtorKind::Const) if *constructor != Variant(id) => None,\n-                Def::VariantCtor(_, CtorKind::Const) |\n-                Def::StructCtor(_, CtorKind::Const) => Some(Vec::new()),\n-                def => span_bug!(pat_span, \"specialize: unexpected \\\n-                                          definition {:?}\", def),\n-            }\n-        }\n+    let pat = &r[col];\n \n-        PatKind::TupleStruct(_, ref args, ddpos) => {\n-            match cx.tcx.expect_def(pat_id) {\n-                Def::Const(..) | Def::AssociatedConst(..) =>\n-                    span_bug!(pat_span, \"const pattern should've \\\n-                                         been rewritten\"),\n-                Def::VariantCtor(id, CtorKind::Fn) if *constructor != Variant(id) => None,\n-                Def::VariantCtor(_, CtorKind::Fn) |\n-                Def::StructCtor(_, CtorKind::Fn) => {\n-                    match ddpos {\n-                        Some(ddpos) => {\n-                            let mut pats: Vec<_> = args[..ddpos].iter().map(|p| {\n-                                wpat(p)\n-                            }).collect();\n-                            pats.extend(repeat(DUMMY_WILD_PATTERN).take(arity - args.len()));\n-                            pats.extend(args[ddpos..].iter().map(|p| wpat(p)));\n-                            Some(pats)\n-                        }\n-                        None => Some(args.iter().map(|p| wpat(p)).collect())\n-                    }\n-                }\n-                def => span_bug!(pat_span, \"specialize: unexpected definition: {:?}\", def)\n-            }\n-        }\n+    let head: Option<Vec<&Pattern>> = match *pat.kind {\n+        PatternKind::Binding { .. } | PatternKind::Wild =>\n+            Some(vec![cx.wild_pattern; arity]),\n \n-        PatKind::Struct(_, ref pattern_fields, _) => {\n-            let adt = cx.tcx.node_id_to_type(pat_id).ty_adt_def().unwrap();\n-            let variant = constructor.variant_for_adt(adt);\n-            let def_variant = adt.variant_of_def(cx.tcx.expect_def(pat_id));\n-            if variant.did == def_variant.did {\n-                Some(variant.fields.iter().map(|sf| {\n-                    match pattern_fields.iter().find(|f| f.node.name == sf.name) {\n-                        Some(ref f) => wpat(&f.node.pat),\n-                        _ => DUMMY_WILD_PATTERN\n-                    }\n-                }).collect())\n+        PatternKind::Variant { adt_def, variant_index, ref subpatterns } => {\n+            let ref variant = adt_def.variants[variant_index];\n+            if *constructor == Variant(variant.did) {\n+                Some(patterns_for_variant(cx, subpatterns, arity))\n             } else {\n                 None\n             }\n         }\n \n-        PatKind::Tuple(ref args, Some(ddpos)) => {\n-            let mut pats: Vec<_> = args[..ddpos].iter().map(|p| wpat(p)).collect();\n-            pats.extend(repeat(DUMMY_WILD_PATTERN).take(arity - args.len()));\n-            pats.extend(args[ddpos..].iter().map(|p| wpat(p)));\n-            Some(pats)\n-        }\n-        PatKind::Tuple(ref args, None) =>\n-            Some(args.iter().map(|p| wpat(&**p)).collect()),\n-\n-        PatKind::Box(ref inner) | PatKind::Ref(ref inner, _) =>\n-            Some(vec![wpat(&**inner)]),\n-\n-        PatKind::Lit(ref expr) => {\n-            match r[col].pattern_ty {\n-                Some(&ty::TyS { sty: ty::TyRef(_, mt), .. }) => {\n-                    // HACK: handle string literals. A string literal pattern\n-                    // serves both as an unary reference pattern and as a\n-                    // nullary value pattern, depending on the type.\n-                    Some(vec![Pattern {\n-                        pat: pat,\n-                        pattern_ty: Some(mt.ty)\n-                    }])\n-                }\n-                Some(ty) => {\n-                    assert_eq!(constructor_arity(cx, constructor, ty), 0);\n-                    let expr_value = eval_const_expr(cx.tcx, &expr);\n-                    match range_covered_by_constructor(\n-                        cx.tcx, expr.span, constructor, &expr_value, &expr_value\n-                            ) {\n-                        Ok(true) => Some(vec![]),\n-                        Ok(false) => None,\n-                        Err(ErrorReported) => None,\n-                    }\n-                }\n-                None => span_bug!(pat.span, \"literal pattern {:?} has no type\", pat)\n+        PatternKind::Leaf { ref subpatterns } => Some(patterns_for_variant(cx, subpatterns, arity)),\n+        PatternKind::Deref { ref subpattern } => Some(vec![subpattern]),\n+\n+        PatternKind::Constant { ref value } => {\n+            assert_eq!(constructor_arity(cx, constructor, pat.ty), 0);\n+            match range_covered_by_constructor(\n+                cx.tcx, pat.span, constructor, value, value\n+            ) {\n+                Ok(true) => Some(vec![]),\n+                Ok(false) => None,\n+                Err(ErrorReported) => None,\n             }\n         }\n \n-        PatKind::Range(ref from, ref to) => {\n-            let from_value = eval_const_expr(cx.tcx, &from);\n-            let to_value = eval_const_expr(cx.tcx, &to);\n+        PatternKind::Range { ref lo, ref hi } => {\n             match range_covered_by_constructor(\n-                cx.tcx, pat_span, constructor, &from_value, &to_value\n+                cx.tcx, pat.span, constructor, lo, hi\n             ) {\n                 Ok(true) => Some(vec![]),\n                 Ok(false) => None,\n                 Err(ErrorReported) => None,\n             }\n         }\n \n-        PatKind::Slice(ref before, ref slice, ref after) => {\n-            let pat_len = before.len() + after.len();\n-            match *constructor {\n-                Single => {\n-                    // Fixed-length vectors.\n-                    Some(\n-                        before.iter().map(|p| wpat(p)).chain(\n-                        repeat(DUMMY_WILD_PATTERN).take(arity - pat_len).chain(\n-                        after.iter().map(|p| wpat(p))\n-                    )).collect())\n-                },\n-                Slice(length) if pat_len <= length && slice.is_some() => {\n+        PatternKind::Array { ref prefix, slice: _, ref suffix } => {\n+            let pat_len = prefix.len() + suffix.len();\n+            Some(\n+                prefix.iter().chain(\n+                repeat(cx.wild_pattern).take(arity - pat_len).chain(\n+                suffix.iter()\n+            )).collect())\n+        }\n+\n+        PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n+            let pat_len = prefix.len() + suffix.len();\n+            if let Some(slice_count) = arity.checked_sub(pat_len) {\n+                if slice_count == 0 || slice.is_some() {\n                     Some(\n-                        before.iter().map(|p| wpat(p)).chain(\n-                        repeat(DUMMY_WILD_PATTERN).take(arity - pat_len).chain(\n-                        after.iter().map(|p| wpat(p))\n+                        prefix.iter().chain(\n+                        repeat(cx.wild_pattern).take(slice_count).chain(\n+                        suffix.iter()\n                     )).collect())\n+                } else {\n+                    None\n                 }\n-                Slice(length) if pat_len == length => {\n-                    Some(\n-                        before.iter().map(|p| wpat(p)).chain(\n-                        after.iter().map(|p| wpat(p))\n-                    ).collect())\n-                }\n-                _ => None\n+            } else {\n+                None\n             }\n         }\n     };\n@@ -720,12 +676,15 @@ fn specialize<'a, 'b, 'tcx>(\n     })\n }\n \n-pub fn is_refutable<A, F>(cx: &MatchCheckCtxt, pat: &Pat, refutable: F)\n-                          -> Option<A> where\n+pub fn is_refutable<'a, 'tcx, A, F>(\n+    cx: &MatchCheckCtxt<'a, 'tcx>,\n+    pat: &'a Pattern<'tcx>,\n+    refutable: F)\n+    -> Option<A> where\n     F: FnOnce(&Witness) -> A,\n {\n-    let pats = Matrix(vec!(vec!(wrap_pat(cx, pat))));\n-    match is_useful(cx, &pats, &[DUMMY_WILD_PATTERN], ConstructWitness) {\n+    let pats = Matrix(vec![vec![pat]]);\n+    match is_useful(cx, &pats, &[cx.wild_pattern], ConstructWitness) {\n         UsefulWithWitness(pats) => Some(refutable(&pats[0])),\n         NotUseful => None,\n         Useful => bug!()"}, {"sha": "0ae13d31a569dc338f9f5816aa547f8d6db63b18", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e313d8b290ddd129f35ce0a6ae319bbd2c19a73a/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e313d8b290ddd129f35ce0a6ae319bbd2c19a73a/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=e313d8b290ddd129f35ce0a6ae319bbd2c19a73a", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use _match::{MatchCheckCtxt, Matrix, wrap_pat, is_refutable, is_useful};\n-use _match::{DUMMY_WILD_PATTERN, DUMMY_WILD_PAT};\n+use _match::{MatchCheckCtxt, Matrix, lower_pat, is_refutable, is_useful};\n+use _match::{DUMMY_WILD_PAT};\n use _match::Usefulness::*;\n use _match::WitnessPreference::*;\n \n@@ -58,9 +58,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MatchCheckCtxt<'a, 'tcx> {\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.visit_all_items_in_krate(DepNode::MatchCheck, &mut MatchCheckCtxt {\n-        tcx: tcx,\n-        param_env: tcx.empty_parameter_environment(),\n+    MatchCheckCtxt::create_and_enter(tcx, tcx.empty_parameter_environment(), |mut cx| {\n+        tcx.visit_all_items_in_krate(DepNode::MatchCheck, &mut cx);\n     });\n     tcx.sess.abort_if_errors();\n }\n@@ -138,7 +137,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n                 .iter()\n                 .filter(|&&(_, guard)| guard.is_none())\n                 .flat_map(|arm| &arm.0)\n-                .map(|pat| vec![wrap_pat(cx, &pat)])\n+                .map(|pat| vec![lower_pat(cx, &pat)])\n                 .collect();\n             check_exhaustive(cx, scrut.span, &matrix, source);\n         },\n@@ -218,7 +217,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n     let mut printed_if_let_err = false;\n     for &(ref pats, guard) in arms {\n         for pat in pats {\n-            let v = vec![wrap_pat(cx, &pat)];\n+            let v = vec![lower_pat(cx, &pat)];\n \n             match is_useful(cx, &seen, &v[..], LeaveOutWitness) {\n                 NotUseful => {\n@@ -292,7 +291,7 @@ fn check_exhaustive<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n                               sp: Span,\n                               matrix: &Matrix<'a, 'tcx>,\n                               source: hir::MatchSource) {\n-    match is_useful(cx, matrix, &[DUMMY_WILD_PATTERN], ConstructWitness) {\n+    match is_useful(cx, matrix, &[cx.wild_pattern], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             let witnesses = if pats.is_empty() {\n                 vec![DUMMY_WILD_PAT]\n@@ -483,7 +482,7 @@ fn check_irrefutable(cx: &MatchCheckCtxt, pat: &Pat, is_fn_arg: bool) {\n         \"local binding\"\n     };\n \n-    is_refutable(cx, pat, |uncovered_pat| {\n+    is_refutable(cx, &lower_pat(cx, pat), |uncovered_pat| {\n         let pattern_string = pat_to_string(uncovered_pat.single_pattern());\n         struct_span_err!(cx.tcx.sess, pat.span, E0005,\n             \"refutable pattern in {}: `{}` not covered\","}, {"sha": "1a07ece044ff21bea29ffa9cf456a24483f6018b", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e313d8b290ddd129f35ce0a6ae319bbd2c19a73a/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e313d8b290ddd129f35ce0a6ae319bbd2c19a73a/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=e313d8b290ddd129f35ce0a6ae319bbd2c19a73a", "patch": "@@ -31,6 +31,7 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n \n+extern crate arena;\n #[macro_use] extern crate syntax;\n #[macro_use] extern crate log;\n #[macro_use] extern crate rustc;"}, {"sha": "715659f5885b5b15e45c260028fecbb228a418d8", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 167, "deletions": 5, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/e313d8b290ddd129f35ce0a6ae319bbd2c19a73a/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e313d8b290ddd129f35ce0a6ae319bbd2c19a73a/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=e313d8b290ddd129f35ce0a6ae319bbd2c19a73a", "patch": "@@ -11,7 +11,7 @@\n use eval;\n \n use rustc::middle::const_val::ConstVal;\n-use rustc::mir::repr::{Field, Literal, BorrowKind, Mutability};\n+use rustc::mir::repr::{Field, BorrowKind, Mutability};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n use rustc::hir::{self, PatKind};\n use rustc::hir::def::Def;\n@@ -78,8 +78,8 @@ pub enum PatternKind<'tcx> {\n     },\n \n     Range {\n-        lo: Literal<'tcx>,\n-        hi: Literal<'tcx>,\n+        lo: ConstVal,\n+        hi: ConstVal,\n     },\n \n     /// matches against a slice, checking the length and extracting elements\n@@ -111,9 +111,7 @@ impl<'a, 'gcx, 'tcx> Pattern<'tcx> {\n \n             PatKind::Range(ref lo, ref hi) => {\n                 let lo = eval::eval_const_expr(tcx.global_tcx(), lo);\n-                let lo = Literal::Value { value: lo };\n                 let hi = eval::eval_const_expr(tcx.global_tcx(), hi);\n-                let hi = Literal::Value { value: hi };\n                 PatternKind::Range { lo: lo, hi: hi }\n             },\n \n@@ -375,3 +373,167 @@ impl<'a, 'gcx, 'tcx> PatternKind<'tcx> {\n         }\n     }\n }\n+\n+pub trait PatternFoldable<'tcx> : Sized {\n+    fn fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        self.super_fold_with(folder)\n+    }\n+\n+    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self;\n+}\n+\n+pub trait PatternFolder<'tcx> : Sized {\n+    fn fold_pattern(&mut self, pattern: &Pattern<'tcx>) -> Pattern<'tcx> {\n+        pattern.super_fold_with(self)\n+    }\n+\n+    fn fold_pattern_kind(&mut self, kind: &PatternKind<'tcx>) -> PatternKind<'tcx> {\n+        kind.super_fold_with(self)\n+    }\n+}\n+\n+\n+impl<'tcx, T: PatternFoldable<'tcx>> PatternFoldable<'tcx> for Box<T> {\n+    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let content: T = (**self).fold_with(folder);\n+        box content\n+    }\n+}\n+\n+impl<'tcx, T: PatternFoldable<'tcx>> PatternFoldable<'tcx> for Vec<T> {\n+    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        self.iter().map(|t| t.fold_with(folder)).collect()\n+    }\n+}\n+\n+impl<'tcx, T: PatternFoldable<'tcx>> PatternFoldable<'tcx> for Option<T> {\n+    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self{\n+        self.as_ref().map(|t| t.fold_with(folder))\n+    }\n+}\n+\n+macro_rules! CopyImpls {\n+    ($($ty:ty),+) => {\n+        $(\n+            impl<'tcx> PatternFoldable<'tcx> for $ty {\n+                fn super_fold_with<F: PatternFolder<'tcx>>(&self, _: &mut F) -> Self {\n+                    self.clone()\n+                }\n+            }\n+            )+\n+    }\n+}\n+\n+macro_rules! TcxCopyImpls {\n+    ($($ty:ident),+) => {\n+        $(\n+            impl<'tcx> PatternFoldable<'tcx> for $ty<'tcx> {\n+                fn super_fold_with<F: PatternFolder<'tcx>>(&self, _: &mut F) -> Self {\n+                    *self\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+CopyImpls!{ Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal }\n+TcxCopyImpls!{ Ty, BindingMode, AdtDef }\n+\n+impl<'tcx> PatternFoldable<'tcx> for FieldPattern<'tcx> {\n+    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        FieldPattern {\n+            field: self.field.fold_with(folder),\n+            pattern: self.pattern.fold_with(folder)\n+        }\n+    }\n+}\n+\n+impl<'tcx> PatternFoldable<'tcx> for Pattern<'tcx> {\n+    fn fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        folder.fold_pattern(self)\n+    }\n+\n+    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        Pattern {\n+            ty: self.ty.fold_with(folder),\n+            span: self.span.fold_with(folder),\n+            kind: self.kind.fold_with(folder)\n+        }\n+    }\n+}\n+\n+impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n+    fn fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        folder.fold_pattern_kind(self)\n+    }\n+\n+    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        match *self {\n+            PatternKind::Wild => PatternKind::Wild,\n+            PatternKind::Binding {\n+                mutability,\n+                name,\n+                mode,\n+                var,\n+                ty,\n+                ref subpattern,\n+            } => PatternKind::Binding {\n+                mutability: mutability.fold_with(folder),\n+                name: name.fold_with(folder),\n+                mode: mode.fold_with(folder),\n+                var: var.fold_with(folder),\n+                ty: ty.fold_with(folder),\n+                subpattern: subpattern.fold_with(folder),\n+            },\n+            PatternKind::Variant {\n+                adt_def,\n+                variant_index,\n+                ref subpatterns,\n+            } => PatternKind::Variant {\n+                adt_def: adt_def.fold_with(folder),\n+                variant_index: variant_index.fold_with(folder),\n+                subpatterns: subpatterns.fold_with(folder)\n+            },\n+            PatternKind::Leaf {\n+                ref subpatterns,\n+            } => PatternKind::Leaf {\n+                subpatterns: subpatterns.fold_with(folder),\n+            },\n+            PatternKind::Deref {\n+                ref subpattern,\n+            } => PatternKind::Deref {\n+                subpattern: subpattern.fold_with(folder),\n+            },\n+            PatternKind::Constant {\n+                ref value\n+            } => PatternKind::Constant {\n+                value: value.fold_with(folder)\n+            },\n+            PatternKind::Range {\n+                ref lo,\n+                ref hi\n+            } => PatternKind::Range {\n+                lo: lo.fold_with(folder),\n+                hi: hi.fold_with(folder)\n+            },\n+            PatternKind::Slice {\n+                ref prefix,\n+                ref slice,\n+                ref suffix,\n+            } => PatternKind::Slice {\n+                prefix: prefix.fold_with(folder),\n+                slice: slice.fold_with(folder),\n+                suffix: suffix.fold_with(folder)\n+            },\n+            PatternKind::Array {\n+                ref prefix,\n+                ref slice,\n+                ref suffix\n+            } => PatternKind::Array {\n+                prefix: prefix.fold_with(folder),\n+                slice: slice.fold_with(folder),\n+                suffix: suffix.fold_with(folder)\n+            },\n+        }\n+    }\n+}"}, {"sha": "78a1604a5cbbac69df0e1159d07a8608f5fe1ad3", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e313d8b290ddd129f35ce0a6ae319bbd2c19a73a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e313d8b290ddd129f35ce0a6ae319bbd2c19a73a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=e313d8b290ddd129f35ce0a6ae319bbd2c19a73a", "patch": "@@ -73,8 +73,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Range {\n-                        lo: lo.clone(),\n-                        hi: hi.clone(),\n+                        lo: Literal::Value { value: lo.clone() },\n+                        hi: Literal::Value { value: hi.clone() },\n                         ty: match_pair.pattern.ty.clone(),\n                     },\n                 }"}, {"sha": "3f6f38f9a18e111beda3a77bf0e972c13bb809af", "filename": "src/test/compile-fail/const-pattern-not-const-evaluable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e313d8b290ddd129f35ce0a6ae319bbd2c19a73a/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e313d8b290ddd129f35ce0a6ae319bbd2c19a73a/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs?ref=e313d8b290ddd129f35ce0a6ae319bbd2c19a73a", "patch": "@@ -19,19 +19,19 @@ use Cake::*;\n const BOO: (Cake, Cake) = (Marmor, BlackForest);\n //~^ ERROR: constant evaluation error [E0080]\n //~| unimplemented constant expression: enum variants\n-const FOO: Cake = BOO.1;\n+//~^^^ ERROR: constant evaluation error [E0080]\n+//~| unimplemented constant expression: enum variants\n+const FOO: Cake = BOO.1; //~ NOTE for expression here\n \n const fn foo() -> Cake {\n     Marmor\n         //~^ ERROR: constant evaluation error [E0080]\n         //~| unimplemented constant expression: enum variants\n-        //~^^^ ERROR: constant evaluation error [E0080]\n-        //~| unimplemented constant expression: enum variants\n }\n \n const WORKS: Cake = Marmor;\n \n-const GOO: Cake = foo(); //~ NOTE for expression here\n+const GOO: Cake = foo();\n \n fn main() {\n     match BlackForest {"}]}