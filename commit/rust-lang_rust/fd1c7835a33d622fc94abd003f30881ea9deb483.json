{"sha": "fd1c7835a33d622fc94abd003f30881ea9deb483", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkMWM3ODM1YTMzZDYyMmZjOTRhYmQwMDNmMzA4ODFlYTlkZWI0ODM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-06-20T02:43:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-20T02:43:09Z"}, "message": "Rollup merge of #73458 - tmiasko:arena-layout, r=matthewjasper\n\nUse alloc::Layout in DroplessArena API", "tree": {"sha": "28ad3fef9b04ae7483692648b623a3f882629760", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28ad3fef9b04ae7483692648b623a3f882629760"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd1c7835a33d622fc94abd003f30881ea9deb483", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe7Xe+CRBK7hj4Ov3rIwAAdHIIAIPUYsTPkZCTXC1878fwU/Yq\n4VMVoYHowyE/K5RN7VK1mb6ymy5rYmJy6z1eoA/VjVaBeQ5ZGMC4TNDqzc35eQJY\nujNEK1mIOB4EWG5W6mvKRzLh5BX6gr/yR2xQa8bK8q0tG699i4N0Fhw9F2MEsDXU\niDAHcRF1WIchglKO6ncIsgnFuqgBtTOacdeIhn0kXou7mdfgH3Iv8cpeVDSwKRk2\ngdqZKMv7IMImOv4S4Vb85ut/uR0D0J+Byk8/wU21zoNKvu9m6uLjuiNkzMS8U2UD\n+G2s/c/VZ/1UbzCkSMMzcPYBX9CpAFnOiLK22A6XynMahTAyYXJAn+O9FTDevQI=\n=DL6V\n-----END PGP SIGNATURE-----\n", "payload": "tree 28ad3fef9b04ae7483692648b623a3f882629760\nparent 61f8c3ef27c367558d050122d33674a9a5062584\nparent f488dfc2b6b6a0c48a1897c1768ba790e5761a8f\nauthor Manish Goregaokar <manishsmail@gmail.com> 1592620989 -0700\ncommitter GitHub <noreply@github.com> 1592620989 -0700\n\nRollup merge of #73458 - tmiasko:arena-layout, r=matthewjasper\n\nUse alloc::Layout in DroplessArena API\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd1c7835a33d622fc94abd003f30881ea9deb483", "html_url": "https://github.com/rust-lang/rust/commit/fd1c7835a33d622fc94abd003f30881ea9deb483", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd1c7835a33d622fc94abd003f30881ea9deb483/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61f8c3ef27c367558d050122d33674a9a5062584", "url": "https://api.github.com/repos/rust-lang/rust/commits/61f8c3ef27c367558d050122d33674a9a5062584", "html_url": "https://github.com/rust-lang/rust/commit/61f8c3ef27c367558d050122d33674a9a5062584"}, {"sha": "f488dfc2b6b6a0c48a1897c1768ba790e5761a8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f488dfc2b6b6a0c48a1897c1768ba790e5761a8f", "html_url": "https://github.com/rust-lang/rust/commit/f488dfc2b6b6a0c48a1897c1768ba790e5761a8f"}], "stats": {"total": 56, "additions": 24, "deletions": 32}, "files": [{"sha": "6cf2db3e2da49df40aaf317466053901d8099b38", "filename": "src/librustc_arena/lib.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fd1c7835a33d622fc94abd003f30881ea9deb483/src%2Flibrustc_arena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd1c7835a33d622fc94abd003f30881ea9deb483/src%2Flibrustc_arena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_arena%2Flib.rs?ref=fd1c7835a33d622fc94abd003f30881ea9deb483", "patch": "@@ -22,6 +22,7 @@ extern crate alloc;\n use rustc_data_structures::cold_path;\n use smallvec::SmallVec;\n \n+use std::alloc::Layout;\n use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::intrinsics;\n@@ -363,13 +364,15 @@ impl DroplessArena {\n         }\n     }\n \n-    /// Allocates a byte slice with specified size and alignment from the\n-    /// current memory chunk. Returns `None` if there is no free space left to\n-    /// satisfy the request.\n+    /// Allocates a byte slice with specified layout from the current memory\n+    /// chunk. Returns `None` if there is no free space left to satisfy the\n+    /// request.\n     #[inline]\n-    fn alloc_raw_without_grow(&self, bytes: usize, align: usize) -> Option<*mut u8> {\n+    fn alloc_raw_without_grow(&self, layout: Layout) -> Option<*mut u8> {\n         let ptr = self.ptr.get() as usize;\n         let end = self.end.get() as usize;\n+        let align = layout.align();\n+        let bytes = layout.size();\n         // The allocation request fits into the current chunk iff:\n         //\n         // let aligned = align_to(ptr, align);\n@@ -390,23 +393,23 @@ impl DroplessArena {\n     }\n \n     #[inline]\n-    pub fn alloc_raw(&self, bytes: usize, align: usize) -> *mut u8 {\n-        assert!(bytes != 0);\n+    pub fn alloc_raw(&self, layout: Layout) -> *mut u8 {\n+        assert!(layout.size() != 0);\n         loop {\n-            if let Some(a) = self.alloc_raw_without_grow(bytes, align) {\n+            if let Some(a) = self.alloc_raw_without_grow(layout) {\n                 break a;\n             }\n             // No free space left. Allocate a new chunk to satisfy the request.\n             // On failure the grow will panic or abort.\n-            self.grow(bytes);\n+            self.grow(layout.size());\n         }\n     }\n \n     #[inline]\n     pub fn alloc<T>(&self, object: T) -> &mut T {\n         assert!(!mem::needs_drop::<T>());\n \n-        let mem = self.alloc_raw(mem::size_of::<T>(), mem::align_of::<T>()) as *mut T;\n+        let mem = self.alloc_raw(Layout::for_value::<T>(&object)) as *mut T;\n \n         unsafe {\n             // Write into uninitialized memory.\n@@ -431,7 +434,7 @@ impl DroplessArena {\n         assert!(mem::size_of::<T>() != 0);\n         assert!(!slice.is_empty());\n \n-        let mem = self.alloc_raw(slice.len() * mem::size_of::<T>(), mem::align_of::<T>()) as *mut T;\n+        let mem = self.alloc_raw(Layout::for_value::<[T]>(slice)) as *mut T;\n \n         unsafe {\n             mem.copy_from_nonoverlapping(slice.as_ptr(), slice.len());\n@@ -477,8 +480,8 @@ impl DroplessArena {\n                 if len == 0 {\n                     return &mut [];\n                 }\n-                let size = len.checked_mul(mem::size_of::<T>()).unwrap();\n-                let mem = self.alloc_raw(size, mem::align_of::<T>()) as *mut T;\n+\n+                let mem = self.alloc_raw(Layout::array::<T>(len).unwrap()) as *mut T;\n                 unsafe { self.write_from_iter(iter, len, mem) }\n             }\n             (_, _) => {\n@@ -491,9 +494,8 @@ impl DroplessArena {\n                     // the content of the SmallVec\n                     unsafe {\n                         let len = vec.len();\n-                        let start_ptr = self\n-                            .alloc_raw(len * mem::size_of::<T>(), mem::align_of::<T>())\n-                            as *mut T;\n+                        let start_ptr =\n+                            self.alloc_raw(Layout::for_value::<[T]>(vec.as_slice())) as *mut T;\n                         vec.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n                         vec.set_len(0);\n                         slice::from_raw_parts_mut(start_ptr, len)\n@@ -537,7 +539,7 @@ pub struct DropArena {\n impl DropArena {\n     #[inline]\n     pub unsafe fn alloc<T>(&self, object: T) -> &mut T {\n-        let mem = self.arena.alloc_raw(mem::size_of::<T>(), mem::align_of::<T>()) as *mut T;\n+        let mem = self.arena.alloc_raw(Layout::new::<T>()) as *mut T;\n         // Write into uninitialized memory.\n         ptr::write(mem, object);\n         let result = &mut *mem;\n@@ -557,10 +559,7 @@ impl DropArena {\n         }\n         let len = vec.len();\n \n-        let start_ptr = self\n-            .arena\n-            .alloc_raw(len.checked_mul(mem::size_of::<T>()).unwrap(), mem::align_of::<T>())\n-            as *mut T;\n+        let start_ptr = self.arena.alloc_raw(Layout::array::<T>(len).unwrap()) as *mut T;\n \n         let mut destructors = self.destructors.borrow_mut();\n         // Reserve space for the destructors so we can't panic while adding them"}, {"sha": "92d6dbb5f90f557fb59ab4d2959a193a0112572c", "filename": "src/librustc_middle/ty/list.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fd1c7835a33d622fc94abd003f30881ea9deb483/src%2Flibrustc_middle%2Fty%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd1c7835a33d622fc94abd003f30881ea9deb483/src%2Flibrustc_middle%2Fty%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flist.rs?ref=fd1c7835a33d622fc94abd003f30881ea9deb483", "patch": "@@ -2,7 +2,8 @@ use crate::arena::Arena;\n \n use rustc_serialize::{Encodable, Encoder};\n \n-use std::cmp::{self, Ordering};\n+use std::alloc::Layout;\n+use std::cmp::Ordering;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::iter;\n@@ -43,17 +44,9 @@ impl<T: Copy> List<T> {\n         assert!(mem::size_of::<T>() != 0);\n         assert!(!slice.is_empty());\n \n-        // Align up the size of the len (usize) field\n-        let align = mem::align_of::<T>();\n-        let align_mask = align - 1;\n-        let offset = mem::size_of::<usize>();\n-        let offset = (offset + align_mask) & !align_mask;\n-\n-        let size = offset + slice.len() * mem::size_of::<T>();\n-\n-        let mem = arena\n-            .dropless\n-            .alloc_raw(size, cmp::max(mem::align_of::<T>(), mem::align_of::<usize>()));\n+        let (layout, _offset) =\n+            Layout::new::<usize>().extend(Layout::for_value::<[T]>(slice)).unwrap();\n+        let mem = arena.dropless.alloc_raw(layout);\n         unsafe {\n             let result = &mut *(mem as *mut List<T>);\n             // Write the length"}]}