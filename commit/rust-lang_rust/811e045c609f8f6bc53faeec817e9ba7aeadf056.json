{"sha": "811e045c609f8f6bc53faeec817e9ba7aeadf056", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxMWUwNDVjNjA5ZjhmNmJjNTNmYWVlYzgxN2U5YmE3YWVhZGYwNTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-28T12:28:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-28T12:28:32Z"}, "message": "auto merge of #7426 : thestinger/rust/zero-size-noncopyable, r=catamorphism\n\n4885918 r=huonw\r\n42a63fc r=thestinger\r\n7ec5a08 r=catamorphism\r\nfb1e5f1 r=thestinger\r\n659cd55 r=cmr", "tree": {"sha": "2e11e915a59d73825ea43122162cfdd5070f9d82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e11e915a59d73825ea43122162cfdd5070f9d82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/811e045c609f8f6bc53faeec817e9ba7aeadf056", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/811e045c609f8f6bc53faeec817e9ba7aeadf056", "html_url": "https://github.com/rust-lang/rust/commit/811e045c609f8f6bc53faeec817e9ba7aeadf056", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/811e045c609f8f6bc53faeec817e9ba7aeadf056/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "887ae82382ff4fad401a6539356245d2a05d6b4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/887ae82382ff4fad401a6539356245d2a05d6b4f", "html_url": "https://github.com/rust-lang/rust/commit/887ae82382ff4fad401a6539356245d2a05d6b4f"}, {"sha": "3fbea161075aa21a217bd794e3f5cac7085e94ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fbea161075aa21a217bd794e3f5cac7085e94ec", "html_url": "https://github.com/rust-lang/rust/commit/3fbea161075aa21a217bd794e3f5cac7085e94ec"}], "stats": {"total": 497, "additions": 302, "deletions": 195}, "files": [{"sha": "9ac4d650b43f1e95a92e2957d74244582c12399a", "filename": "RELEASES.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/811e045c609f8f6bc53faeec817e9ba7aeadf056/RELEASES.txt", "raw_url": "https://github.com/rust-lang/rust/raw/811e045c609f8f6bc53faeec817e9ba7aeadf056/RELEASES.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.txt?ref=811e045c609f8f6bc53faeec817e9ba7aeadf056", "patch": "@@ -101,6 +101,7 @@ Version 0.7 (July 2013)\n         dynamic borrowcheck failures for debugging.\n       * rustdoc has a nicer stylesheet.\n       * Various improvements to rustdoc.\n+      * Improvements to rustpkg (see the detailed release notes)\n \n    * Other\n       * More and improved library documentation."}, {"sha": "506fc2ad15a8cdc4545e233ac2a21850017835b9", "filename": "doc/rustpkg.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/811e045c609f8f6bc53faeec817e9ba7aeadf056/doc%2Frustpkg.md", "raw_url": "https://github.com/rust-lang/rust/raw/811e045c609f8f6bc53faeec817e9ba7aeadf056/doc%2Frustpkg.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frustpkg.md?ref=811e045c609f8f6bc53faeec817e9ba7aeadf056", "patch": "@@ -95,12 +95,22 @@ When building a package that is in a `git` repository,\n When building a package that is not under version control,\n or that has no tags, `rustpkg` assumes the intended version is 0.1.\n \n+# Dependencies\n+\n+rustpkg infers dependencies from `extern mod` directives.\n+Thus, there should be no need to pass a `-L` flag to rustpkg to tell it where to find a library.\n+(In the future, it will also be possible to write an `extern mod` directive referring to a remote package.)\n+\n # Custom build scripts\n \n A file called `pkg.rs` at the root level in a workspace is called a *package script*.\n If a package script exists, rustpkg executes it to build the package\n rather than inferring crates as described previously.\n \n+Inside `pkg.rs`, it's possible to call back into rustpkg to finish up the build.\n+`rustpkg::api` contains functions to build, install, or clean libraries and executables\n+in the way rustpkg normally would without custom build logic.\n+\n # Command reference\n \n ## build"}, {"sha": "66bd0b9c1319f4cda407a9c42cdd08a9488adab1", "filename": "doc/tutorial-container.md", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/811e045c609f8f6bc53faeec817e9ba7aeadf056/doc%2Ftutorial-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/811e045c609f8f6bc53faeec817e9ba7aeadf056/doc%2Ftutorial-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-container.md?ref=811e045c609f8f6bc53faeec817e9ba7aeadf056", "patch": "@@ -0,0 +1,207 @@\n+% Containers and iterators\n+\n+# Containers\n+\n+The container traits are defined in the `std::container` module.\n+\n+## Unique and managed vectors\n+\n+Vectors have `O(1)` indexing and removal from the end, along with `O(1)`\n+amortized insertion. Vectors are the most common container in Rust, and are\n+flexible enough to fit many use cases.\n+\n+Vectors can also be sorted and used as efficient lookup tables with the\n+`std::vec::bsearch` function, if all the elements are inserted at one time and\n+deletions are unnecessary.\n+\n+## Maps and sets\n+\n+Maps are collections of unique keys with corresponding values, and sets are\n+just unique keys without a corresponding value. The `Map` and `Set` traits in\n+`std::container` define the basic interface.\n+\n+The standard library provides three owned map/set types:\n+\n+* `std::hashmap::HashMap` and `std::hashmap::HashSet`, requiring the keys to\n+  implement `Eq` and `Hash`\n+* `std::trie::TrieMap` and `std::trie::TrieSet`, requiring the keys to be `uint`\n+* `extra::treemap::TreeMap` and `extra::treemap::TreeSet`, requiring the keys\n+  to implement `TotalOrd`\n+\n+These maps do not use managed pointers so they can be sent between tasks as\n+long as the key and value types are sendable. Neither the key or value type has\n+to be copyable.\n+\n+The `TrieMap` and `TreeMap` maps are ordered, while `HashMap` uses an arbitrary\n+order.\n+\n+Each `HashMap` instance has a random 128-bit key to use with a keyed hash,\n+making the order of a set of keys in a given hash table randomized. Rust\n+provides a [SipHash](https://131002.net/siphash/) implementation for any type\n+implementing the `IterBytes` trait.\n+\n+## Double-ended queues\n+\n+The `extra::deque` module implements a double-ended queue with `O(1)` amortized\n+inserts and removals from both ends of the container. It also has `O(1)`\n+indexing like a vector. The contained elements are not required to be copyable,\n+and the queue will be sendable if the contained type is sendable.\n+\n+## Priority queues\n+\n+The `extra::priority_queue` module implements a queue ordered by a key.  The\n+contained elements are not required to be copyable, and the queue will be\n+sendable if the contained type is sendable.\n+\n+Insertions have `O(log n)` time complexity and checking or popping the largest\n+element is `O(1)`. Converting a vector to a priority queue can be done\n+in-place, and has `O(n)` complexity. A priority queue can also be converted to\n+a sorted vector in-place, allowing it to be used for an `O(n log n)` in-place\n+heapsort.\n+\n+# Iterators\n+\n+## Iteration protocol\n+\n+The iteration protocol is defined by the `Iterator` trait in the\n+`std::iterator` module. The minimal implementation of the trait is a `next`\n+method, yielding the next element from an iterator object:\n+\n+~~~\n+/// An infinite stream of zeroes\n+struct ZeroStream;\n+\n+impl Iterator<int> for ZeroStream {\n+    fn next(&mut self) -> Option<int> {\n+        Some(0)\n+    }\n+}\n+~~~~\n+\n+Reaching the end of the iterator is signalled by returning `None` instead of\n+`Some(item)`:\n+\n+~~~\n+/// A stream of N zeroes\n+struct ZeroStream {\n+    priv remaining: uint\n+}\n+\n+impl ZeroStream {\n+    fn new(n: uint) -> ZeroStream {\n+        ZeroStream { remaining: n }\n+    }\n+}\n+\n+impl Iterator<int> for ZeroStream {\n+    fn next(&mut self) -> Option<int> {\n+        if self.remaining == 0 {\n+            None\n+        } else {\n+            self.remaining -= 1;\n+            Some(0)\n+        }\n+    }\n+}\n+~~~\n+\n+## Container iterators\n+\n+Containers implement iteration over the contained elements by returning an\n+iterator object. For example, vectors have four iterators available:\n+\n+* `vector.iter()`, for immutable references to the elements\n+* `vector.mut_iter()`, for mutable references to the elements\n+* `vector.rev_iter()`, for immutable references to the elements in reverse order\n+* `vector.mut_rev_iter()`, for mutable references to the elements in reverse order\n+\n+### Freezing\n+\n+Unlike most other languages with external iterators, Rust has no *iterator\n+invalidation*. As long an iterator is still in scope, the compiler will prevent\n+modification of the container through another handle.\n+\n+~~~\n+let mut xs = [1, 2, 3];\n+{\n+    let _it = xs.iter();\n+\n+    // the vector is frozen for this scope, the compiler will statically\n+    // prevent modification\n+}\n+// the vector becomes unfrozen again at the end of the scope\n+~~~\n+\n+These semantics are due to most container iterators being implemented with `&`\n+and `&mut`.\n+\n+## Iterator adaptors\n+\n+The `IteratorUtil` trait implements common algorithms as methods extending\n+every `Iterator` implementation. For example, the `fold` method will accumulate\n+the items yielded by an `Iterator` into a single value:\n+\n+~~~\n+let xs = [1, 9, 2, 3, 14, 12];\n+let result = xs.iter().fold(0, |accumulator, item| accumulator - *item);\n+assert_eq!(result, -41);\n+~~~\n+\n+Some adaptors return an adaptor object implementing the `Iterator` trait itself:\n+\n+~~~\n+let xs = [1, 9, 2, 3, 14, 12];\n+let ys = [5, 2, 1, 8];\n+let sum = xs.iter().chain_(ys.iter()).fold(0, |a, b| a + *b);\n+assert_eq!(sum, 57);\n+~~~\n+\n+Note that some adaptors like the `chain_` method above use a trailing\n+underscore to work around an issue with method resolve. The underscores will be\n+dropped when they become unnecessary.\n+\n+## For loops\n+\n+The `for` loop syntax is currently in transition, and will switch from the old\n+closure-based iteration protocol to iterator objects. For now, the `advance`\n+adaptor is required as a compatibility shim to use iterators with for loops.\n+\n+~~~\n+let xs = [2, 3, 5, 7, 11, 13, 17];\n+\n+// print out all the elements in the vector\n+for xs.iter().advance |x| {\n+    println(x.to_str())\n+}\n+\n+// print out all but the first 3 elements in the vector\n+for xs.iter().skip(3).advance |x| {\n+    println(x.to_str())\n+}\n+~~~\n+\n+For loops are *often* used with a temporary iterator object, as above. They can\n+also advance the state of an iterator in a mutable location:\n+\n+~~~\n+let xs = [1, 2, 3, 4, 5];\n+let ys = [\"foo\", \"bar\", \"baz\", \"foobar\"];\n+\n+// create an iterator yielding tuples of elements from both vectors\n+let mut it = xs.iter().zip(ys.iter());\n+\n+// print out the pairs of elements up to (&3, &\"baz\")\n+for it.advance |(x, y)| {\n+    println(fmt!(\"%d %s\", *x, *y));\n+\n+    if *x == 3 {\n+        break;\n+    }\n+}\n+\n+// yield and print the last pair from the iterator\n+println(fmt!(\"last: %?\", it.next()));\n+\n+// the iterator is now fully consumed\n+assert!(it.next().is_none());\n+~~~"}, {"sha": "fc0f7b74a7af87e44b23020de53bada9fb3da741", "filename": "doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 126, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/811e045c609f8f6bc53faeec817e9ba7aeadf056/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/811e045c609f8f6bc53faeec817e9ba7aeadf056/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=811e045c609f8f6bc53faeec817e9ba7aeadf056", "patch": "@@ -1607,132 +1607,6 @@ do spawn {\n If you want to see the output of `debug!` statements, you will need to turn on `debug!` logging.\n To enable `debug!` logging, set the RUST_LOG environment variable to the name of your crate, which, for a file named `foo.rs`, will be `foo` (e.g., with bash, `export RUST_LOG=foo`).\n \n-## For loops\n-\n-> ***Note:*** The closure-based protocol used `for` loop is on the way out. The `for` loop will\n-> use iterator objects in the future instead.\n-\n-The most common way to express iteration in Rust is with a `for`\n-loop. Like `do`, `for` is a nice syntax for describing control flow\n-with closures.  Additionally, within a `for` loop, `break`, `loop`,\n-and `return` work just as they do with `while` and `loop`.\n-\n-Consider again our `each` function, this time improved to return\n-immediately when the iteratee returns `false`:\n-\n-~~~~\n-fn each(v: &[int], op: &fn(v: &int) -> bool) -> bool {\n-   let mut n = 0;\n-   while n < v.len() {\n-       if !op(&v[n]) {\n-           return false;\n-       }\n-       n += 1;\n-   }\n-   return true;\n-}\n-~~~~\n-\n-And using this function to iterate over a vector:\n-\n-~~~~\n-# fn each(v: &[int], op: &fn(v: &int) -> bool) -> bool {\n-#    let mut n = 0;\n-#    while n < v.len() {\n-#        if !op(&v[n]) {\n-#            return false;\n-#        }\n-#        n += 1;\n-#    }\n-#    return true;\n-# }\n-each([2, 4, 8, 5, 16], |n| {\n-    if *n % 2 != 0 {\n-        println(\"found odd number!\");\n-        false\n-    } else { true }\n-});\n-~~~~\n-\n-With `for`, functions like `each` can be treated more\n-like built-in looping structures. When calling `each`\n-in a `for` loop, instead of returning `false` to break\n-out of the loop, you just write `break`. To skip ahead\n-to the next iteration, write `loop`.\n-\n-~~~~\n-# fn each(v: &[int], op: &fn(v: &int) -> bool) -> bool {\n-#    let mut n = 0;\n-#    while n < v.len() {\n-#        if !op(&v[n]) {\n-#            return false;\n-#        }\n-#        n += 1;\n-#    }\n-#    return true;\n-# }\n-for each([2, 4, 8, 5, 16]) |n| {\n-    if *n % 2 != 0 {\n-        println(\"found odd number!\");\n-        break;\n-    }\n-}\n-~~~~\n-\n-As an added bonus, you can use the `return` keyword, which is not\n-normally allowed in closures, in a block that appears as the body of a\n-`for` loop: the meaning of `return` in such a block is to return from\n-the enclosing function, not just the loop body.\n-\n-~~~~\n-# fn each(v: &[int], op: &fn(v: &int) -> bool) -> bool {\n-#    let mut n = 0;\n-#    while n < v.len() {\n-#        if !op(&v[n]) {\n-#            return false;\n-#        }\n-#        n += 1;\n-#    }\n-#    return true;\n-# }\n-fn contains(v: &[int], elt: int) -> bool {\n-    for each(v) |x| {\n-        if (*x == elt) { return true; }\n-    }\n-    false\n-}\n-~~~~\n-\n-Notice that, because `each` passes each value by borrowed pointer,\n-the iteratee needs to dereference it before using it.\n-In these situations it can be convenient to lean on Rust's\n-argument patterns to bind `x` to the actual value, not the pointer.\n-\n-~~~~\n-# fn each(v: &[int], op: &fn(v: &int) -> bool) -> bool {\n-#    let mut n = 0;\n-#    while n < v.len() {\n-#        if !op(&v[n]) {\n-#            return false;\n-#        }\n-#        n += 1;\n-#    }\n-#    return true;\n-# }\n-# fn contains(v: &[int], elt: int) -> bool {\n-    for each(v) |&x| {\n-        if (x == elt) { return true; }\n-    }\n-#    false\n-# }\n-~~~~\n-\n-`for` syntax only works with stack closures.\n-\n-> ***Note:*** This is, essentially, a special loop protocol:\n-> the keywords `break`, `loop`, and `return` work, in varying degree,\n-> with `while`, `loop`, `do`, and `for` constructs.\n-\n # Methods\n \n Methods are like functions except that they always begin with a special argument,\n@@ -2653,6 +2527,7 @@ tutorials on individual topics.\n * [Tasks and communication][tasks]\n * [Macros][macros]\n * [The foreign function interface][ffi]\n+* [Containers and iterators](tutorial-container.html)\n \n There is further documentation on the [wiki].\n "}, {"sha": "4e76749f707ee3a29f667a734a21a4022dd57b72", "filename": "man/rustc.1", "status": "modified", "additions": 18, "deletions": 51, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/811e045c609f8f6bc53faeec817e9ba7aeadf056/man%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/811e045c609f8f6bc53faeec817e9ba7aeadf056/man%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustc.1?ref=811e045c609f8f6bc53faeec817e9ba7aeadf056", "patch": "@@ -1,4 +1,4 @@\n-.TH RUSTC \"1\" \"February 2013\" \"rustc 0.6\" \"User Commands\"\n+.TH RUSTC \"1\" \"July 2013\" \"rustc 0.7\" \"User Commands\"\n .SH NAME\n rustc \\- rust compiler\n .SH SYNOPSIS\n@@ -33,6 +33,12 @@ Add a directory to the library search path\n \\fB\\-\\-lib\\fR\n Compile a library crate\n .TP\n+\\fB\\-\\-linker\\fR LINKER\n+Program to use for linking instead of the default\n+.TP\n+\\fB\\-\\-link-args\\fR FLAGS\n+A space-separated list of flags passed to the linker\n+.TP\n \\fB\\-\\-ls\\fR\n List the symbols defined by a library crate\n .TP\n@@ -48,6 +54,11 @@ Write output to <filename>\n \\fB\\-\\-opt\\-level\\fR LEVEL\n Optimize with possible levels 0-3\n .TP\n+\\fB\\-\\-passes\\fR NAMES\n+Comma- or space-separated list of optimization passes. Overrides\n+the default passes for the optimization level. A value of 'list'\n+will list the available passes.\n+.TP\n \\fB\\-\\-out\\-dir\\fR DIR\n Write output to compiler-chosen filename in <dir>\n .TP\n@@ -77,6 +88,12 @@ Target triple cpu-manufacturer-kernel[-os] to compile for (see\n http://sources.redhat.com/autobook/autobook/autobook_17.html\n for detail)\n .TP\n+\\fB\\-\\-target-feature\\fR TRIPLE\n+Target-specific attributes (see llc -mattr=help for detail)\n+.TP\n+\\fB\\-\\-android-cross-path\\fR PATH\n+The path to the Android NDK\n+.TP\n \\fB\\-W\\fR help\n Print 'lint' options and default settings\n .TP\n@@ -94,56 +111,6 @@ Set lint forbidden\n .TP\n \\fB\\-Z\\fR FLAG\n Set internal debugging options. Use \"-Z help\" to print available options.\n-\n-Available debug flags are:\n-.RS\n-.IP \\[bu]\n-\\fBverbose\\fR - in general, enable more debug printouts\n-.IP \\[bu]\n-\\fBtime\\-passes\\fR - measure time of each rustc pass\n-.IP \\[bu]\n-\\fBcount\\-llvm\\-insns\\fR - count where LLVM instrs originate\n-.IP \\[bu]\n-\\fBtime\\-llvm\\-passes\\fR - measure time of each LLVM pass\n-.IP \\[bu]\n-\\fBtrans\\-stats\\fR - gather trans statistics\n-.IP \\[bu]\n-\\fBno\\-asm\\-comments\\fR - omit comments when using \\fI\\-S\\fR\n-.IP \\[bu]\n-\\fBno\\-verify\\fR - skip LLVM verification\n-.IP \\[bu]\n-\\fBtrace\\fR - emit trace logs\n-.IP \\[bu]\n-\\fBcoherence\\fR - perform coherence checking\n-.IP \\[bu]\n-\\fBborrowck\\-stats\\fR - gather borrowck statistics\n-.IP \\[bu]\n-\\fBborrowck\\-note\\-pure\\fR - note where purity is req'd\n-.IP \\[bu]\n-\\fBborrowck\\-note\\-loan\\fR - note where loans are req'd\n-.IP \\[bu]\n-\\fBno\\-landing\\-pads\\fR - omit landing pads for unwinding\n-.IP \\[bu]\n-\\fBdebug\\-llvm\\fR - enable debug output from LLVM\n-.IP \\[bu]\n-\\fBcount\\-type\\-sizes\\fR - count the sizes of aggregate types\n-.IP \\[bu]\n-\\fBmeta\\-stats\\fR - gather metadata statistics\n-.IP \\[bu]\n-\\fBno\\-opt\\fR - do not optimize, even if \\fI\\-O\\fR is passed\n-.IP \\[bu]\n-\\fBno\\-monomorphic\\-collapse\\fR - do not collapse template instantiations\n-.IP \\[bu]\n-\\fBgc\\fR - Garbage collect shared data (experimental)\n-.IP \\[bu]\n-\\fBjit\\fR - Execute using JIT (experimental)\n-.IP \\[bu]\n-\\fBextra\\-debug\\-info\\fR - Extra debugging info (experimental)\n-.IP \\[bu]\n-\\fBdebug\\-info\\fR - Produce debug info (experimental)\n-.IP \\[bu]\n-\\fBstatic\\fR - Use or produce static libraries or binaries (experimental)\n-.RE\n .TP\n \\fB\\-v\\fR, \\fB\\-\\-version\\fR\n Print version info and exit"}, {"sha": "f11a3d24b8d2559f0e3dba340e0a888c7c96ef41", "filename": "mk/docs.mk", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/811e045c609f8f6bc53faeec817e9ba7aeadf056/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/811e045c609f8f6bc53faeec817e9ba7aeadf056/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=811e045c609f8f6bc53faeec817e9ba7aeadf056", "patch": "@@ -99,6 +99,16 @@ doc/tutorial-macros.html: tutorial-macros.md doc/version_info.html \\\n \t   --include-before-body=doc/version_info.html \\\n            --output=$@\n \n+DOCS += doc/tutorial-container.html\n+doc/tutorial-container.html: tutorial-container.md doc/version_info.html doc/rust.css\n+\t@$(call E, pandoc: $@)\n+\t$(Q)$(CFG_NODE) $(S)doc/prep.js --highlight $< | \\\n+          $(CFG_PANDOC) --standalone --toc \\\n+           --section-divs --number-sections \\\n+           --from=markdown --to=html --css=rust.css \\\n+\t   --include-before-body=doc/version_info.html \\\n+           --output=$@\n+\n DOCS += doc/tutorial-ffi.html\n doc/tutorial-ffi.html: tutorial-ffi.md doc/version_info.html doc/rust.css\n \t@$(call E, pandoc: $@)"}, {"sha": "dd3ba639c054ce4f534a648f768f0790334d1cf1", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/811e045c609f8f6bc53faeec817e9ba7aeadf056/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/811e045c609f8f6bc53faeec817e9ba7aeadf056/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=811e045c609f8f6bc53faeec817e9ba7aeadf056", "patch": "@@ -82,8 +82,14 @@ pub mod reader {\n     use core::cast::transmute;\n     use core::int;\n     use core::io;\n-    use core::ptr::offset;\n     use core::str;\n+\n+    #[cfg(target_arch = \"x86\")]\n+    #[cfg(target_arch = \"x86_64\")]\n+    use core::ptr::offset;\n+\n+    #[cfg(target_arch = \"x86\")]\n+    #[cfg(target_arch = \"x86_64\")]\n     use core::unstable::intrinsics::bswap32;\n \n     // ebml reading"}, {"sha": "5b1451387e7adfdcdf09d548cec27a7250adfe69", "filename": "src/libextra/rc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/811e045c609f8f6bc53faeec817e9ba7aeadf056/src%2Flibextra%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/811e045c609f8f6bc53faeec817e9ba7aeadf056/src%2Flibextra%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frc.rs?ref=811e045c609f8f6bc53faeec817e9ba7aeadf056", "patch": "@@ -36,6 +36,7 @@ struct RcBox<T> {\n \n /// Immutable reference counted pointer type\n #[non_owned]\n+#[unsafe_no_drop_flag]\n pub struct Rc<T> {\n     priv ptr: *mut RcBox<T>,\n }\n@@ -168,6 +169,7 @@ struct RcMutBox<T> {\n /// Mutable reference counted pointer type\n #[non_owned]\n #[mutable]\n+#[unsafe_no_drop_flag]\n pub struct RcMut<T> {\n     priv ptr: *mut RcMutBox<T>,\n }"}, {"sha": "29d81f37da7d4331b410f9cee2c83cd93d6dac63", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/811e045c609f8f6bc53faeec817e9ba7aeadf056/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/811e045c609f8f6bc53faeec817e9ba7aeadf056/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=811e045c609f8f6bc53faeec817e9ba7aeadf056", "patch": "@@ -3904,7 +3904,7 @@ impl DtorKind {\n pub fn ty_dtor(cx: ctxt, struct_id: def_id) -> DtorKind {\n     match cx.destructor_for_type.find(&struct_id) {\n         Some(&method_def_id) => {\n-            let flag = !has_attr(cx, struct_id, \"no_drop_flag\");\n+            let flag = !has_attr(cx, struct_id, \"unsafe_no_drop_flag\");\n \n             TraitDtor(method_def_id, flag)\n         }"}, {"sha": "41b78afded1a8c3d483fc1256944e8eef2e1b694", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/811e045c609f8f6bc53faeec817e9ba7aeadf056/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/811e045c609f8f6bc53faeec817e9ba7aeadf056/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=811e045c609f8f6bc53faeec817e9ba7aeadf056", "patch": "@@ -349,7 +349,6 @@ pub mod types {\n                 use libc::types::os::arch::c95::{c_uchar, c_uint, c_ulong, time_t};\n                 use libc::types::os::arch::c99::{c_longlong, c_ulonglong};\n                 use libc::types::os::arch::posix88::{uid_t, gid_t, ino_t};\n-                use libc::types::os::arch::posix88::{uid_t};\n \n                 pub type nlink_t = u16;\n                 pub type blksize_t = u32;"}, {"sha": "12ae2abd4a1f0cd3a85a35775b73bea7c7c3235e", "filename": "src/libstd/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/811e045c609f8f6bc53faeec817e9ba7aeadf056/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/811e045c609f8f6bc53faeec817e9ba7aeadf056/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=811e045c609f8f6bc53faeec817e9ba7aeadf056", "patch": "@@ -447,7 +447,7 @@ fn test_option_dance() {\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_option_too_much_dance() {\n-    let mut y = Some(util::NonCopyable::new());\n+    let mut y = Some(util::NonCopyable);\n     let _y2 = y.swap_unwrap();\n     let _y3 = y.swap_unwrap();\n }"}, {"sha": "1e5ac305df37ec818ca03b7f383d1116a859a85b", "filename": "src/libstd/unstable/atomics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/811e045c609f8f6bc53faeec817e9ba7aeadf056/src%2Flibstd%2Funstable%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/811e045c609f8f6bc53faeec817e9ba7aeadf056/src%2Flibstd%2Funstable%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fatomics.rs?ref=811e045c609f8f6bc53faeec817e9ba7aeadf056", "patch": "@@ -62,7 +62,7 @@ pub struct AtomicPtr<T> {\n /**\n  * An owned atomic pointer. Ensures that only a single reference to the data is held at any time.\n  */\n-#[no_drop_flag]\n+#[unsafe_no_drop_flag]\n pub struct AtomicOption<T> {\n     priv p: *mut c_void\n }"}, {"sha": "fd29d7dc14bd7d947d9ad78f403841ccc19b94c9", "filename": "src/libstd/util.rs", "status": "modified", "additions": 42, "deletions": 12, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/811e045c609f8f6bc53faeec817e9ba7aeadf056/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/811e045c609f8f6bc53faeec817e9ba7aeadf056/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=811e045c609f8f6bc53faeec817e9ba7aeadf056", "patch": "@@ -75,18 +75,14 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n }\n \n /// A non-copyable dummy type.\n+#[deriving(Eq, TotalEq, Ord, TotalOrd)]\n+#[unsafe_no_drop_flag]\n pub struct NonCopyable;\n \n-impl NonCopyable {\n-    /// Creates a dummy non-copyable structure and returns it for use.\n-    pub fn new() -> NonCopyable { NonCopyable }\n-}\n-\n impl Drop for NonCopyable {\n     fn drop(&self) { }\n }\n \n-\n /// A type with no inhabitants\n pub enum Void { }\n \n@@ -130,39 +126,73 @@ pub fn unreachable() -> ! {\n \n #[cfg(test)]\n mod tests {\n+    use super::*;\n     use option::{None, Some};\n-    use util::{Void, NonCopyable, id, replace, swap};\n     use either::{Either, Left, Right};\n+    use sys::size_of;\n+    use kinds::Drop;\n \n     #[test]\n-    pub fn identity_crisis() {\n+    fn identity_crisis() {\n         // Writing a test for the identity function. How did it come to this?\n         let x = ~[(5, false)];\n         //FIXME #3387 assert!(x.eq(id(copy x)));\n         let y = copy x;\n         assert!(x.eq(&id(y)));\n     }\n+\n     #[test]\n-    pub fn test_swap() {\n+    fn test_swap() {\n         let mut x = 31337;\n         let mut y = 42;\n         swap(&mut x, &mut y);\n         assert_eq!(x, 42);\n         assert_eq!(y, 31337);\n     }\n+\n     #[test]\n-    pub fn test_replace() {\n-        let mut x = Some(NonCopyable::new());\n+    fn test_replace() {\n+        let mut x = Some(NonCopyable);\n         let y = replace(&mut x, None);\n         assert!(x.is_none());\n         assert!(y.is_some());\n     }\n+\n     #[test]\n-    pub fn test_uninhabited() {\n+    fn test_uninhabited() {\n         let could_only_be_coin : Either <Void, ()> = Right (());\n         match could_only_be_coin {\n             Right (coin) => coin,\n             Left (is_void) => is_void.uninhabited ()\n         }\n     }\n+\n+    #[test]\n+    fn test_noncopyable() {\n+        assert_eq!(size_of::<NonCopyable>(), 0);\n+\n+        // verify that `#[unsafe_no_drop_flag]` works as intended on a zero-size struct\n+\n+        // NOTE: uncomment after snapshot, will not parse yet\n+        //static mut did_run: bool = false;\n+\n+        struct Foo { five: int }\n+\n+        impl Drop for Foo {\n+            fn drop(&self) {\n+                assert_eq!(self.five, 5);\n+                // NOTE: uncomment after snapshot, will not parse yet\n+                //unsafe {\n+                    //did_run = true;\n+                //}\n+            }\n+        }\n+\n+        {\n+            let _a = (NonCopyable, Foo { five: 5 }, NonCopyable);\n+        }\n+\n+        // NOTE: uncomment after snapshot, will not parse yet\n+        //unsafe { assert_eq!(did_run, true); }\n+    }\n }"}, {"sha": "87c476d781e7eb409b93d12cc7a93402d7caf004", "filename": "src/test/run-pass/attr-no-drop-flag-size.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/811e045c609f8f6bc53faeec817e9ba7aeadf056/src%2Ftest%2Frun-pass%2Fattr-no-drop-flag-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/811e045c609f8f6bc53faeec817e9ba7aeadf056/src%2Ftest%2Frun-pass%2Fattr-no-drop-flag-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fattr-no-drop-flag-size.rs?ref=811e045c609f8f6bc53faeec817e9ba7aeadf056", "patch": "@@ -10,7 +10,7 @@\n \n use std::sys::size_of;\n \n-#[no_drop_flag]\n+#[unsafe_no_drop_flag]\n struct Test<T> {\n     a: T\n }"}]}