{"sha": "7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b", "node_id": "C_kwDOAAsO6NoAKDdkYzhmMzg5NTZmNGFkNjY1MDAzMmZlMGZiY2Y0ZmNiYmU1YTZjMmI", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-08-19T10:03:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-19T10:03:43Z"}, "message": "Merge pull request #1266 from bjorn3/parallel_comp_refactor2\n\nRefactorings for enabling parallel compilation (part 2)", "tree": {"sha": "d5c5cd8e0259269b46c42ff6c8c85b8ac253b22c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5c5cd8e0259269b46c42ff6c8c85b8ac253b22c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi/1//CRBK7hj4Ov3rIwAAYGUIAJe4e/KcO+mlpIlfojtBqRl9\nDWZFNSuEDALrMmMzHrM0mQ93Ae0ixiQ+gIKRxZuEE8NqEYdNKmpnGVysJFVJN599\n9nCuqHqpr2hP34DgtTH/L/ZzZcguqCfskYQxRvMUmCRAs1i1BFkRx3RD9o7hz+M9\nkcaxqYrQQ5/33FBEh4tb4Ya2YlNhfGFQtrpLHgZB0K8JdUxwa8/+kCDy2KljbVBc\nOOdAEDNy9OD4sD/6/g1mjibdA4mc81fdexUOK0aTEAwptVEnxc/70i565Ks8iLCX\nK5Qo7xCeHZ1IguryKc/mnkMeUb77JjVxQYJRm2dH2U+ArINP7G+cPS/nfeRJ1Mg=\n=L3Gm\n-----END PGP SIGNATURE-----\n", "payload": "tree d5c5cd8e0259269b46c42ff6c8c85b8ac253b22c\nparent 4dac65fcbd50d2900a22e9f1a7f99b15f6e016c5\nparent 535c6ddc8bf66d8997c9a89ce457974e2c2c11ec\nauthor bjorn3 <17426603+bjorn3@users.noreply.github.com> 1660903423 +0200\ncommitter GitHub <noreply@github.com> 1660903423 +0200\n\nMerge pull request #1266 from bjorn3/parallel_comp_refactor2\n\nRefactorings for enabling parallel compilation (part 2)"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b", "html_url": "https://github.com/rust-lang/rust/commit/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4dac65fcbd50d2900a22e9f1a7f99b15f6e016c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/4dac65fcbd50d2900a22e9f1a7f99b15f6e016c5", "html_url": "https://github.com/rust-lang/rust/commit/4dac65fcbd50d2900a22e9f1a7f99b15f6e016c5"}, {"sha": "535c6ddc8bf66d8997c9a89ce457974e2c2c11ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/535c6ddc8bf66d8997c9a89ce457974e2c2c11ec", "html_url": "https://github.com/rust-lang/rust/commit/535c6ddc8bf66d8997c9a89ce457974e2c2c11ec"}], "stats": {"total": 792, "additions": 283, "deletions": 509}, "files": [{"sha": "5f6d9f374fddfa3b23a1316cf65d01427f109476", "filename": "src/base.rs", "status": "modified", "additions": 51, "deletions": 71, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b", "patch": "@@ -7,48 +7,44 @@ use rustc_middle::ty::layout::FnAbiOf;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::SymbolName;\n \n-use indexmap::IndexSet;\n-\n use crate::constant::ConstantCx;\n+use crate::debuginfo::FunctionDebugContext;\n use crate::prelude::*;\n use crate::pretty_clif::CommentWriter;\n \n struct CodegenedFunction<'tcx> {\n-    instance: Instance<'tcx>,\n     symbol_name: SymbolName<'tcx>,\n     func_id: FuncId,\n     func: Function,\n     clif_comments: CommentWriter,\n-    source_info_set: IndexSet<SourceInfo>,\n-    local_map: IndexVec<mir::Local, CPlace<'tcx>>,\n+    func_debug_cx: Option<FunctionDebugContext>,\n }\n \n pub(crate) fn codegen_and_compile_fn<'tcx>(\n-    cx: &mut crate::CodegenCx<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    cx: &mut crate::CodegenCx,\n     cached_context: &mut Context,\n     module: &mut dyn Module,\n     instance: Instance<'tcx>,\n ) {\n-    let tcx = cx.tcx;\n     let _inst_guard =\n         crate::PrintOnPanic(|| format!(\"{:?} {}\", instance, tcx.symbol_name(instance).name));\n \n     let cached_func = std::mem::replace(&mut cached_context.func, Function::new());\n-    let codegened_func = codegen_fn(cx, cached_func, module, instance);\n+    let codegened_func = codegen_fn(tcx, cx, cached_func, module, instance);\n \n     compile_fn(cx, cached_context, module, codegened_func);\n }\n \n fn codegen_fn<'tcx>(\n-    cx: &mut crate::CodegenCx<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    cx: &mut crate::CodegenCx,\n     cached_func: Function,\n     module: &mut dyn Module,\n     instance: Instance<'tcx>,\n ) -> CodegenedFunction<'tcx> {\n     debug_assert!(!instance.substs.needs_infer());\n \n-    let tcx = cx.tcx;\n-\n     let mir = tcx.instance_mir(instance.def);\n     let _mir_guard = crate::PrintOnPanic(|| {\n         let mut buf = Vec::new();\n@@ -84,13 +80,20 @@ fn codegen_fn<'tcx>(\n     let pointer_type = target_config.pointer_type();\n     let clif_comments = crate::pretty_clif::CommentWriter::new(tcx, instance);\n \n+    let func_debug_cx = if let Some(debug_context) = &mut cx.debug_context {\n+        Some(debug_context.define_function(tcx, symbol_name.name, mir.span))\n+    } else {\n+        None\n+    };\n+\n     let mut fx = FunctionCx {\n         cx,\n         module,\n         tcx,\n         target_config,\n         pointer_type,\n         constants_cx: ConstantCx::new(),\n+        func_debug_cx,\n \n         instance,\n         symbol_name,\n@@ -103,52 +106,42 @@ fn codegen_fn<'tcx>(\n         caller_location: None, // set by `codegen_fn_prelude`\n \n         clif_comments,\n-        source_info_set: indexmap::IndexSet::new(),\n+        last_source_file: None,\n         next_ssa_var: 0,\n     };\n \n     tcx.sess.time(\"codegen clif ir\", || codegen_fn_body(&mut fx, start_block));\n \n     // Recover all necessary data from fx, before accessing func will prevent future access to it.\n-    let instance = fx.instance;\n     let clif_comments = fx.clif_comments;\n-    let source_info_set = fx.source_info_set;\n-    let local_map = fx.local_map;\n+    let func_debug_cx = fx.func_debug_cx;\n \n     fx.constants_cx.finalize(fx.tcx, &mut *fx.module);\n \n-    crate::pretty_clif::write_clif_file(\n-        tcx,\n-        \"unopt\",\n-        module.isa(),\n-        instance,\n-        &func,\n-        &clif_comments,\n-    );\n+    if cx.should_write_ir {\n+        crate::pretty_clif::write_clif_file(\n+            tcx.output_filenames(()),\n+            symbol_name.name,\n+            \"unopt\",\n+            module.isa(),\n+            &func,\n+            &clif_comments,\n+        );\n+    }\n \n     // Verify function\n     verify_func(tcx, &clif_comments, &func);\n \n-    CodegenedFunction {\n-        instance,\n-        symbol_name,\n-        func_id,\n-        func,\n-        clif_comments,\n-        source_info_set,\n-        local_map,\n-    }\n+    CodegenedFunction { symbol_name, func_id, func, clif_comments, func_debug_cx }\n }\n \n fn compile_fn<'tcx>(\n-    cx: &mut crate::CodegenCx<'tcx>,\n+    cx: &mut crate::CodegenCx,\n     cached_context: &mut Context,\n     module: &mut dyn Module,\n     codegened_func: CodegenedFunction<'tcx>,\n ) {\n-    let tcx = cx.tcx;\n-\n-    let mut clif_comments = codegened_func.clif_comments;\n+    let clif_comments = codegened_func.clif_comments;\n \n     // Store function in context\n     let context = cached_context;\n@@ -165,17 +158,6 @@ fn compile_fn<'tcx>(\n     // invalidate it when it would change.\n     context.domtree.clear();\n \n-    // Perform rust specific optimizations\n-    tcx.sess.time(\"optimize clif ir\", || {\n-        crate::optimize::optimize_function(\n-            tcx,\n-            module.isa(),\n-            codegened_func.instance,\n-            context,\n-            &mut clif_comments,\n-        );\n-    });\n-\n     #[cfg(any())] // This is never true\n     let _clif_guard = {\n         use std::fmt::Write;\n@@ -204,43 +186,41 @@ fn compile_fn<'tcx>(\n     };\n \n     // Define function\n-    tcx.sess.time(\"define function\", || {\n-        context.want_disasm = crate::pretty_clif::should_write_ir(tcx);\n+    cx.profiler.verbose_generic_activity(\"define function\").run(|| {\n+        context.want_disasm = cx.should_write_ir;\n         module.define_function(codegened_func.func_id, context).unwrap();\n     });\n \n-    // Write optimized function to file for debugging\n-    crate::pretty_clif::write_clif_file(\n-        tcx,\n-        \"opt\",\n-        module.isa(),\n-        codegened_func.instance,\n-        &context.func,\n-        &clif_comments,\n-    );\n+    if cx.should_write_ir {\n+        // Write optimized function to file for debugging\n+        crate::pretty_clif::write_clif_file(\n+            &cx.output_filenames,\n+            codegened_func.symbol_name.name,\n+            \"opt\",\n+            module.isa(),\n+            &context.func,\n+            &clif_comments,\n+        );\n \n-    if let Some(disasm) = &context.mach_compile_result.as_ref().unwrap().disasm {\n-        crate::pretty_clif::write_ir_file(\n-            tcx,\n-            || format!(\"{}.vcode\", tcx.symbol_name(codegened_func.instance).name),\n-            |file| file.write_all(disasm.as_bytes()),\n-        )\n+        if let Some(disasm) = &context.mach_compile_result.as_ref().unwrap().disasm {\n+            crate::pretty_clif::write_ir_file(\n+                &cx.output_filenames,\n+                &format!(\"{}.vcode\", codegened_func.symbol_name.name),\n+                |file| file.write_all(disasm.as_bytes()),\n+            )\n+        }\n     }\n \n     // Define debuginfo for function\n     let isa = module.isa();\n     let debug_context = &mut cx.debug_context;\n     let unwind_context = &mut cx.unwind_context;\n-    tcx.sess.time(\"generate debug info\", || {\n+    cx.profiler.verbose_generic_activity(\"generate debug info\").run(|| {\n         if let Some(debug_context) = debug_context {\n-            debug_context.define_function(\n-                codegened_func.instance,\n+            codegened_func.func_debug_cx.unwrap().finalize(\n+                debug_context,\n                 codegened_func.func_id,\n-                codegened_func.symbol_name.name,\n-                isa,\n                 context,\n-                &codegened_func.source_info_set,\n-                codegened_func.local_map,\n             );\n         }\n         unwind_context.add_function(codegened_func.func_id, &context, isa);"}, {"sha": "4a80b79a9dc1b04c91e90d4f1eaacdddc55b020e", "filename": "src/common.rs", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b", "patch": "@@ -1,14 +1,19 @@\n use cranelift_codegen::isa::TargetFrontendConfig;\n+use gimli::write::FileId;\n+\n+use rustc_data_structures::sync::Lrc;\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::layout::{\n     FnAbiError, FnAbiOfHelpers, FnAbiRequest, LayoutError, LayoutOfHelpers,\n };\n use rustc_middle::ty::SymbolName;\n+use rustc_span::SourceFile;\n use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::{Integer, Primitive};\n use rustc_target::spec::{HasTargetSpec, Target};\n \n use crate::constant::ConstantCx;\n+use crate::debuginfo::FunctionDebugContext;\n use crate::prelude::*;\n \n pub(crate) fn pointer_ty(tcx: TyCtxt<'_>) -> types::Type {\n@@ -232,12 +237,13 @@ pub(crate) fn type_sign(ty: Ty<'_>) -> bool {\n }\n \n pub(crate) struct FunctionCx<'m, 'clif, 'tcx: 'm> {\n-    pub(crate) cx: &'clif mut crate::CodegenCx<'tcx>,\n+    pub(crate) cx: &'clif mut crate::CodegenCx,\n     pub(crate) module: &'m mut dyn Module,\n     pub(crate) tcx: TyCtxt<'tcx>,\n     pub(crate) target_config: TargetFrontendConfig, // Cached from module\n     pub(crate) pointer_type: Type,                  // Cached from module\n     pub(crate) constants_cx: ConstantCx,\n+    pub(crate) func_debug_cx: Option<FunctionDebugContext>,\n \n     pub(crate) instance: Instance<'tcx>,\n     pub(crate) symbol_name: SymbolName<'tcx>,\n@@ -252,7 +258,11 @@ pub(crate) struct FunctionCx<'m, 'clif, 'tcx: 'm> {\n     pub(crate) caller_location: Option<CValue<'tcx>>,\n \n     pub(crate) clif_comments: crate::pretty_clif::CommentWriter,\n-    pub(crate) source_info_set: indexmap::IndexSet<SourceInfo>,\n+\n+    /// Last accessed source file and it's debuginfo file id.\n+    ///\n+    /// For optimization purposes only\n+    pub(crate) last_source_file: Option<(Lrc<SourceFile>, FileId)>,\n \n     /// This should only be accessed by `CPlace::new_var`.\n     pub(crate) next_ssa_var: u32,\n@@ -336,8 +346,31 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n     }\n \n     pub(crate) fn set_debug_loc(&mut self, source_info: mir::SourceInfo) {\n-        let (index, _) = self.source_info_set.insert_full(source_info);\n-        self.bcx.set_srcloc(SourceLoc::new(index as u32));\n+        if let Some(debug_context) = &mut self.cx.debug_context {\n+            let (file, line, column) =\n+                DebugContext::get_span_loc(self.tcx, self.mir.span, source_info.span);\n+\n+            // add_source_file is very slow.\n+            // Optimize for the common case of the current file not being changed.\n+            let mut cached_file_id = None;\n+            if let Some((ref last_source_file, last_file_id)) = self.last_source_file {\n+                // If the allocations are not equal, the files may still be equal, but that\n+                // doesn't matter, as this is just an optimization.\n+                if rustc_data_structures::sync::Lrc::ptr_eq(last_source_file, &file) {\n+                    cached_file_id = Some(last_file_id);\n+                }\n+            }\n+\n+            let file_id = if let Some(file_id) = cached_file_id {\n+                file_id\n+            } else {\n+                debug_context.add_source_file(&file)\n+            };\n+\n+            let source_loc =\n+                self.func_debug_cx.as_mut().unwrap().add_dbg_loc(file_id, line, column);\n+            self.bcx.set_srcloc(source_loc);\n+        }\n     }\n \n     // Note: must be kept in sync with get_caller_location from cg_ssa"}, {"sha": "9583cd2ec60f8a5bcf3bb3d4b0b74ea806f97614", "filename": "src/debuginfo/emit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b/src%2Fdebuginfo%2Femit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b/src%2Fdebuginfo%2Femit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Femit.rs?ref=7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b", "patch": "@@ -9,7 +9,7 @@ use gimli::{RunTimeEndian, SectionId};\n use super::object::WriteDebugInfo;\n use super::DebugContext;\n \n-impl DebugContext<'_> {\n+impl DebugContext {\n     pub(crate) fn emit(&mut self, product: &mut ObjectProduct) {\n         let unit_range_list_id = self.dwarf.unit.ranges.add(self.unit_range_list.clone());\n         let root = self.dwarf.unit.root();"}, {"sha": "ff6a21eef0d12a2380e190949329c5b46871b9fd", "filename": "src/debuginfo/line_info.rs", "status": "modified", "additions": 92, "deletions": 119, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b/src%2Fdebuginfo%2Fline_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b/src%2Fdebuginfo%2Fline_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fline_info.rs?ref=7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b", "patch": "@@ -3,8 +3,10 @@\n use std::ffi::OsStr;\n use std::path::{Component, Path};\n \n+use crate::debuginfo::FunctionDebugContext;\n use crate::prelude::*;\n \n+use rustc_data_structures::sync::Lrc;\n use rustc_span::{\n     FileName, Pos, SourceFile, SourceFileAndLine, SourceFileHash, SourceFileHashAlgorithm,\n };\n@@ -14,7 +16,6 @@ use cranelift_codegen::MachSrcLoc;\n \n use gimli::write::{\n     Address, AttributeValue, FileId, FileInfo, LineProgram, LineString, LineStringTable,\n-    UnitEntryId,\n };\n \n // OPTIMIZATION: It is cheaper to do this in one pass than using `.parent()` and `.file_name()`.\n@@ -47,9 +48,9 @@ fn osstr_as_utf8_bytes(path: &OsStr) -> &[u8] {\n     }\n }\n \n-pub(crate) const MD5_LEN: usize = 16;\n+const MD5_LEN: usize = 16;\n \n-pub(crate) fn make_file_info(hash: SourceFileHash) -> Option<FileInfo> {\n+fn make_file_info(hash: SourceFileHash) -> Option<FileInfo> {\n     if hash.kind == SourceFileHashAlgorithm::Md5 {\n         let mut buf = [0u8; MD5_LEN];\n         buf.copy_from_slice(hash.hash_bytes());\n@@ -59,160 +60,132 @@ pub(crate) fn make_file_info(hash: SourceFileHash) -> Option<FileInfo> {\n     }\n }\n \n-fn line_program_add_file(\n-    line_program: &mut LineProgram,\n-    line_strings: &mut LineStringTable,\n-    file: &SourceFile,\n-) -> FileId {\n-    match &file.name {\n-        FileName::Real(path) => {\n-            let (dir_path, file_name) = split_path_dir_and_file(path.remapped_path_if_available());\n-            let dir_name = osstr_as_utf8_bytes(dir_path.as_os_str());\n-            let file_name = osstr_as_utf8_bytes(file_name);\n-\n-            let dir_id = if !dir_name.is_empty() {\n-                let dir_name = LineString::new(dir_name, line_program.encoding(), line_strings);\n-                line_program.add_directory(dir_name)\n-            } else {\n-                line_program.default_directory()\n-            };\n-            let file_name = LineString::new(file_name, line_program.encoding(), line_strings);\n+impl DebugContext {\n+    pub(crate) fn get_span_loc(\n+        tcx: TyCtxt<'_>,\n+        function_span: Span,\n+        span: Span,\n+    ) -> (Lrc<SourceFile>, u64, u64) {\n+        // Based on https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src/librustc_codegen_ssa/mir/mod.rs#L116-L131\n+        // In order to have a good line stepping behavior in debugger, we overwrite debug\n+        // locations of macro expansions with that of the outermost expansion site\n+        // (unless the crate is being compiled with `-Z debug-macros`).\n+        let span = if !span.from_expansion() || tcx.sess.opts.unstable_opts.debug_macros {\n+            span\n+        } else {\n+            // Walk up the macro expansion chain until we reach a non-expanded span.\n+            // We also stop at the function body level because no line stepping can occur\n+            // at the level above that.\n+            rustc_span::hygiene::walk_chain(span, function_span.ctxt())\n+        };\n \n-            let info = make_file_info(file.src_hash);\n+        match tcx.sess.source_map().lookup_line(span.lo()) {\n+            Ok(SourceFileAndLine { sf: file, line }) => {\n+                let line_pos = file.line_begin_pos(span.lo());\n \n-            line_program.file_has_md5 &= info.is_some();\n-            line_program.add_file(file_name, dir_id, info)\n+                (\n+                    file,\n+                    u64::try_from(line).unwrap() + 1,\n+                    u64::from((span.lo() - line_pos).to_u32()) + 1,\n+                )\n+            }\n+            Err(file) => (file, 0, 0),\n         }\n-        // FIXME give more appropriate file names\n-        filename => {\n-            let dir_id = line_program.default_directory();\n-            let dummy_file_name = LineString::new(\n-                filename.prefer_remapped().to_string().into_bytes(),\n-                line_program.encoding(),\n-                line_strings,\n-            );\n-            line_program.add_file(dummy_file_name, dir_id, None)\n+    }\n+\n+    pub(crate) fn add_source_file(&mut self, source_file: &SourceFile) -> FileId {\n+        let line_program: &mut LineProgram = &mut self.dwarf.unit.line_program;\n+        let line_strings: &mut LineStringTable = &mut self.dwarf.line_strings;\n+\n+        match &source_file.name {\n+            FileName::Real(path) => {\n+                let (dir_path, file_name) =\n+                    split_path_dir_and_file(path.remapped_path_if_available());\n+                let dir_name = osstr_as_utf8_bytes(dir_path.as_os_str());\n+                let file_name = osstr_as_utf8_bytes(file_name);\n+\n+                let dir_id = if !dir_name.is_empty() {\n+                    let dir_name = LineString::new(dir_name, line_program.encoding(), line_strings);\n+                    line_program.add_directory(dir_name)\n+                } else {\n+                    line_program.default_directory()\n+                };\n+                let file_name = LineString::new(file_name, line_program.encoding(), line_strings);\n+\n+                let info = make_file_info(source_file.src_hash);\n+\n+                line_program.file_has_md5 &= info.is_some();\n+                line_program.add_file(file_name, dir_id, info)\n+            }\n+            // FIXME give more appropriate file names\n+            filename => {\n+                let dir_id = line_program.default_directory();\n+                let dummy_file_name = LineString::new(\n+                    filename.prefer_remapped().to_string().into_bytes(),\n+                    line_program.encoding(),\n+                    line_strings,\n+                );\n+                line_program.add_file(dummy_file_name, dir_id, None)\n+            }\n         }\n     }\n }\n \n-impl<'tcx> DebugContext<'tcx> {\n-    pub(super) fn emit_location(&mut self, entry_id: UnitEntryId, span: Span) {\n-        let loc = self.tcx.sess.source_map().lookup_char_pos(span.lo());\n-\n-        let file_id = line_program_add_file(\n-            &mut self.dwarf.unit.line_program,\n-            &mut self.dwarf.line_strings,\n-            &loc.file,\n-        );\n-\n-        let entry = self.dwarf.unit.get_mut(entry_id);\n-\n-        entry.set(gimli::DW_AT_decl_file, AttributeValue::FileIndex(Some(file_id)));\n-        entry.set(gimli::DW_AT_decl_line, AttributeValue::Udata(loc.line as u64));\n-        entry.set(gimli::DW_AT_decl_column, AttributeValue::Udata(loc.col.to_usize() as u64));\n+impl FunctionDebugContext {\n+    pub(crate) fn add_dbg_loc(&mut self, file_id: FileId, line: u64, column: u64) -> SourceLoc {\n+        let (index, _) = self.source_loc_set.insert_full((file_id, line, column));\n+        SourceLoc::new(u32::try_from(index).unwrap())\n     }\n \n     pub(super) fn create_debug_lines(\n         &mut self,\n+        debug_context: &mut DebugContext,\n         symbol: usize,\n-        entry_id: UnitEntryId,\n         context: &Context,\n-        function_span: Span,\n-        source_info_set: &indexmap::IndexSet<SourceInfo>,\n     ) -> CodeOffset {\n-        let tcx = self.tcx;\n-        let line_program = &mut self.dwarf.unit.line_program;\n-\n-        let line_strings = &mut self.dwarf.line_strings;\n-        let mut last_span = None;\n-        let mut last_file = None;\n-        let mut create_row_for_span = |line_program: &mut LineProgram, span: Span| {\n-            if let Some(last_span) = last_span {\n-                if span == last_span {\n-                    line_program.generate_row();\n-                    return;\n-                }\n-            }\n-            last_span = Some(span);\n-\n-            // Based on https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src/librustc_codegen_ssa/mir/mod.rs#L116-L131\n-            // In order to have a good line stepping behavior in debugger, we overwrite debug\n-            // locations of macro expansions with that of the outermost expansion site\n-            // (unless the crate is being compiled with `-Z debug-macros`).\n-            let span = if !span.from_expansion() || tcx.sess.opts.unstable_opts.debug_macros {\n-                span\n-            } else {\n-                // Walk up the macro expansion chain until we reach a non-expanded span.\n-                // We also stop at the function body level because no line stepping can occur\n-                // at the level above that.\n-                rustc_span::hygiene::walk_chain(span, function_span.ctxt())\n+        let create_row_for_span =\n+            |debug_context: &mut DebugContext, source_loc: (FileId, u64, u64)| {\n+                let (file_id, line, col) = source_loc;\n+\n+                debug_context.dwarf.unit.line_program.row().file = file_id;\n+                debug_context.dwarf.unit.line_program.row().line = line;\n+                debug_context.dwarf.unit.line_program.row().column = col;\n+                debug_context.dwarf.unit.line_program.generate_row();\n             };\n \n-            let (file, line, col) = match tcx.sess.source_map().lookup_line(span.lo()) {\n-                Ok(SourceFileAndLine { sf: file, line }) => {\n-                    let line_pos = file.line_begin_pos(span.lo());\n-\n-                    (\n-                        file,\n-                        u64::try_from(line).unwrap() + 1,\n-                        u64::from((span.lo() - line_pos).to_u32()) + 1,\n-                    )\n-                }\n-                Err(file) => (file, 0, 0),\n-            };\n-\n-            // line_program_add_file is very slow.\n-            // Optimize for the common case of the current file not being changed.\n-            let current_file_changed = if let Some(last_file) = &last_file {\n-                // If the allocations are not equal, then the files may still be equal, but that\n-                // is not a problem, as this is just an optimization.\n-                !rustc_data_structures::sync::Lrc::ptr_eq(last_file, &file)\n-            } else {\n-                true\n-            };\n-            if current_file_changed {\n-                let file_id = line_program_add_file(line_program, line_strings, &file);\n-                line_program.row().file = file_id;\n-                last_file = Some(file);\n-            }\n-\n-            line_program.row().line = line;\n-            line_program.row().column = col;\n-            line_program.generate_row();\n-        };\n-\n-        line_program.begin_sequence(Some(Address::Symbol { symbol, addend: 0 }));\n+        debug_context\n+            .dwarf\n+            .unit\n+            .line_program\n+            .begin_sequence(Some(Address::Symbol { symbol, addend: 0 }));\n \n         let mut func_end = 0;\n \n         let mcr = context.mach_compile_result.as_ref().unwrap();\n         for &MachSrcLoc { start, end, loc } in mcr.buffer.get_srclocs_sorted() {\n-            line_program.row().address_offset = u64::from(start);\n+            debug_context.dwarf.unit.line_program.row().address_offset = u64::from(start);\n             if !loc.is_default() {\n-                let source_info = *source_info_set.get_index(loc.bits() as usize).unwrap();\n-                create_row_for_span(line_program, source_info.span);\n+                let source_loc = *self.source_loc_set.get_index(loc.bits() as usize).unwrap();\n+                create_row_for_span(debug_context, source_loc);\n             } else {\n-                create_row_for_span(line_program, function_span);\n+                create_row_for_span(debug_context, self.function_source_loc);\n             }\n             func_end = end;\n         }\n \n-        line_program.end_sequence(u64::from(func_end));\n+        debug_context.dwarf.unit.line_program.end_sequence(u64::from(func_end));\n \n         let func_end = mcr.buffer.total_size();\n \n         assert_ne!(func_end, 0);\n \n-        let entry = self.dwarf.unit.get_mut(entry_id);\n+        let entry = debug_context.dwarf.unit.get_mut(self.entry_id);\n         entry.set(\n             gimli::DW_AT_low_pc,\n             AttributeValue::Address(Address::Symbol { symbol, addend: 0 }),\n         );\n         entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(u64::from(func_end)));\n \n-        self.emit_location(entry_id, function_span);\n-\n         func_end\n     }\n }"}, {"sha": "c55db2017ee68c31c53b0a59e12c82b6b72c6c7e", "filename": "src/debuginfo/mod.rs", "status": "modified", "additions": 44, "deletions": 238, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b/src%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b/src%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fmod.rs?ref=7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b", "patch": "@@ -7,35 +7,34 @@ mod unwind;\n \n use crate::prelude::*;\n \n-use rustc_index::vec::IndexVec;\n-\n-use cranelift_codegen::entity::EntityRef;\n-use cranelift_codegen::ir::{Endianness, LabelValueLoc, ValueLabel};\n+use cranelift_codegen::ir::Endianness;\n use cranelift_codegen::isa::TargetIsa;\n-use cranelift_codegen::ValueLocRange;\n \n use gimli::write::{\n-    Address, AttributeValue, DwarfUnit, Expression, LineProgram, LineString, Location,\n-    LocationList, Range, RangeList, UnitEntryId,\n+    Address, AttributeValue, DwarfUnit, FileId, LineProgram, LineString, Range, RangeList,\n+    UnitEntryId,\n };\n-use gimli::{Encoding, Format, LineEncoding, RunTimeEndian, X86_64};\n+use gimli::{Encoding, Format, LineEncoding, RunTimeEndian};\n+use indexmap::IndexSet;\n \n pub(crate) use emit::{DebugReloc, DebugRelocName};\n pub(crate) use unwind::UnwindContext;\n \n-pub(crate) struct DebugContext<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-\n+pub(crate) struct DebugContext {\n     endian: RunTimeEndian,\n \n     dwarf: DwarfUnit,\n     unit_range_list: RangeList,\n+}\n \n-    types: FxHashMap<Ty<'tcx>, UnitEntryId>,\n+pub(crate) struct FunctionDebugContext {\n+    entry_id: UnitEntryId,\n+    function_source_loc: (FileId, u64, u64),\n+    source_loc_set: indexmap::IndexSet<(FileId, u64, u64)>,\n }\n \n-impl<'tcx> DebugContext<'tcx> {\n-    pub(crate) fn new(tcx: TyCtxt<'tcx>, isa: &dyn TargetIsa) -> Self {\n+impl DebugContext {\n+    pub(crate) fn new(tcx: TyCtxt<'_>, isa: &dyn TargetIsa) -> Self {\n         let encoding = Encoding {\n             format: Format::Dwarf32,\n             // FIXME this should be configurable\n@@ -101,127 +100,18 @@ impl<'tcx> DebugContext<'tcx> {\n             root.set(gimli::DW_AT_low_pc, AttributeValue::Address(Address::Constant(0)));\n         }\n \n-        DebugContext {\n-            tcx,\n-\n-            endian,\n-\n-            dwarf,\n-            unit_range_list: RangeList(Vec::new()),\n-\n-            types: FxHashMap::default(),\n-        }\n-    }\n-\n-    fn dwarf_ty(&mut self, ty: Ty<'tcx>) -> UnitEntryId {\n-        if let Some(type_id) = self.types.get(&ty) {\n-            return *type_id;\n-        }\n-\n-        let new_entry = |dwarf: &mut DwarfUnit, tag| dwarf.unit.add(dwarf.unit.root(), tag);\n-\n-        let primitive = |dwarf: &mut DwarfUnit, ate| {\n-            let type_id = new_entry(dwarf, gimli::DW_TAG_base_type);\n-            let type_entry = dwarf.unit.get_mut(type_id);\n-            type_entry.set(gimli::DW_AT_encoding, AttributeValue::Encoding(ate));\n-            type_id\n-        };\n-\n-        let name = format!(\"{}\", ty);\n-        let layout = self.tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n-\n-        let type_id = match ty.kind() {\n-            ty::Bool => primitive(&mut self.dwarf, gimli::DW_ATE_boolean),\n-            ty::Char => primitive(&mut self.dwarf, gimli::DW_ATE_UTF),\n-            ty::Uint(_) => primitive(&mut self.dwarf, gimli::DW_ATE_unsigned),\n-            ty::Int(_) => primitive(&mut self.dwarf, gimli::DW_ATE_signed),\n-            ty::Float(_) => primitive(&mut self.dwarf, gimli::DW_ATE_float),\n-            ty::Ref(_, pointee_ty, _mutbl)\n-            | ty::RawPtr(ty::TypeAndMut { ty: pointee_ty, mutbl: _mutbl }) => {\n-                let type_id = new_entry(&mut self.dwarf, gimli::DW_TAG_pointer_type);\n-\n-                // Ensure that type is inserted before recursing to avoid duplicates\n-                self.types.insert(ty, type_id);\n-\n-                let pointee = self.dwarf_ty(*pointee_ty);\n-\n-                let type_entry = self.dwarf.unit.get_mut(type_id);\n-\n-                //type_entry.set(gimli::DW_AT_mutable, AttributeValue::Flag(mutbl == rustc_hir::Mutability::Mut));\n-                type_entry.set(gimli::DW_AT_type, AttributeValue::UnitRef(pointee));\n-\n-                type_id\n-            }\n-            ty::Adt(adt_def, _substs) if adt_def.is_struct() && !layout.is_unsized() => {\n-                let type_id = new_entry(&mut self.dwarf, gimli::DW_TAG_structure_type);\n-\n-                // Ensure that type is inserted before recursing to avoid duplicates\n-                self.types.insert(ty, type_id);\n-\n-                let variant = adt_def.non_enum_variant();\n-\n-                for (field_idx, field_def) in variant.fields.iter().enumerate() {\n-                    let field_offset = layout.fields.offset(field_idx);\n-                    let field_layout = layout.field(\n-                        &layout::LayoutCx { tcx: self.tcx, param_env: ParamEnv::reveal_all() },\n-                        field_idx,\n-                    );\n-\n-                    let field_type = self.dwarf_ty(field_layout.ty);\n-\n-                    let field_id = self.dwarf.unit.add(type_id, gimli::DW_TAG_member);\n-                    let field_entry = self.dwarf.unit.get_mut(field_id);\n-\n-                    field_entry.set(\n-                        gimli::DW_AT_name,\n-                        AttributeValue::String(field_def.name.as_str().to_string().into_bytes()),\n-                    );\n-                    field_entry.set(\n-                        gimli::DW_AT_data_member_location,\n-                        AttributeValue::Udata(field_offset.bytes()),\n-                    );\n-                    field_entry.set(gimli::DW_AT_type, AttributeValue::UnitRef(field_type));\n-                }\n-\n-                type_id\n-            }\n-            _ => new_entry(&mut self.dwarf, gimli::DW_TAG_structure_type),\n-        };\n-\n-        let type_entry = self.dwarf.unit.get_mut(type_id);\n-\n-        type_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n-        type_entry.set(gimli::DW_AT_byte_size, AttributeValue::Udata(layout.size.bytes()));\n-\n-        self.types.insert(ty, type_id);\n-\n-        type_id\n-    }\n-\n-    fn define_local(&mut self, scope: UnitEntryId, name: String, ty: Ty<'tcx>) -> UnitEntryId {\n-        let dw_ty = self.dwarf_ty(ty);\n-\n-        let var_id = self.dwarf.unit.add(scope, gimli::DW_TAG_variable);\n-        let var_entry = self.dwarf.unit.get_mut(var_id);\n-\n-        var_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n-        var_entry.set(gimli::DW_AT_type, AttributeValue::UnitRef(dw_ty));\n-\n-        var_id\n+        DebugContext { endian, dwarf, unit_range_list: RangeList(Vec::new()) }\n     }\n \n     pub(crate) fn define_function(\n         &mut self,\n-        instance: Instance<'tcx>,\n-        func_id: FuncId,\n+        tcx: TyCtxt<'_>,\n         name: &str,\n-        isa: &dyn TargetIsa,\n-        context: &Context,\n-        source_info_set: &indexmap::IndexSet<SourceInfo>,\n-        local_map: IndexVec<mir::Local, CPlace<'tcx>>,\n-    ) {\n-        let symbol = func_id.as_u32() as usize;\n-        let mir = self.tcx.instance_mir(instance.def);\n+        function_span: Span,\n+    ) -> FunctionDebugContext {\n+        let (file, line, column) = DebugContext::get_span_loc(tcx, function_span, function_span);\n+\n+        let file_id = self.add_source_file(&file);\n \n         // FIXME: add to appropriate scope instead of root\n         let scope = self.dwarf.unit.root();\n@@ -233,125 +123,41 @@ impl<'tcx> DebugContext<'tcx> {\n         entry.set(gimli::DW_AT_name, AttributeValue::StringRef(name_id));\n         entry.set(gimli::DW_AT_linkage_name, AttributeValue::StringRef(name_id));\n \n-        let end = self.create_debug_lines(symbol, entry_id, context, mir.span, source_info_set);\n+        entry.set(gimli::DW_AT_decl_file, AttributeValue::FileIndex(Some(file_id)));\n+        entry.set(gimli::DW_AT_decl_line, AttributeValue::Udata(line));\n+        entry.set(gimli::DW_AT_decl_column, AttributeValue::Udata(column));\n \n-        self.unit_range_list.0.push(Range::StartLength {\n+        FunctionDebugContext {\n+            entry_id,\n+            function_source_loc: (file_id, line, column),\n+            source_loc_set: IndexSet::new(),\n+        }\n+    }\n+}\n+\n+impl FunctionDebugContext {\n+    pub(crate) fn finalize(\n+        mut self,\n+        debug_context: &mut DebugContext,\n+        func_id: FuncId,\n+        context: &Context,\n+    ) {\n+        let symbol = func_id.as_u32() as usize;\n+\n+        let end = self.create_debug_lines(debug_context, symbol, context);\n+\n+        debug_context.unit_range_list.0.push(Range::StartLength {\n             begin: Address::Symbol { symbol, addend: 0 },\n             length: u64::from(end),\n         });\n \n-        let func_entry = self.dwarf.unit.get_mut(entry_id);\n+        let func_entry = debug_context.dwarf.unit.get_mut(self.entry_id);\n         // Gdb requires both DW_AT_low_pc and DW_AT_high_pc. Otherwise the DW_TAG_subprogram is skipped.\n         func_entry.set(\n             gimli::DW_AT_low_pc,\n             AttributeValue::Address(Address::Symbol { symbol, addend: 0 }),\n         );\n         // Using Udata for DW_AT_high_pc requires at least DWARF4\n         func_entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(u64::from(end)));\n-\n-        // FIXME make it more reliable and implement scopes before re-enabling this.\n-        if false {\n-            let value_labels_ranges = std::collections::HashMap::new(); // FIXME\n-\n-            for (local, _local_decl) in mir.local_decls.iter_enumerated() {\n-                let ty = self.tcx.subst_and_normalize_erasing_regions(\n-                    instance.substs,\n-                    ty::ParamEnv::reveal_all(),\n-                    mir.local_decls[local].ty,\n-                );\n-                let var_id = self.define_local(entry_id, format!(\"{:?}\", local), ty);\n-\n-                let location = place_location(\n-                    self,\n-                    isa,\n-                    symbol,\n-                    &local_map,\n-                    &value_labels_ranges,\n-                    Place { local, projection: ty::List::empty() },\n-                );\n-\n-                let var_entry = self.dwarf.unit.get_mut(var_id);\n-                var_entry.set(gimli::DW_AT_location, location);\n-            }\n-        }\n-\n-        // FIXME create locals for all entries in mir.var_debug_info\n-    }\n-}\n-\n-fn place_location<'tcx>(\n-    debug_context: &mut DebugContext<'tcx>,\n-    isa: &dyn TargetIsa,\n-    symbol: usize,\n-    local_map: &IndexVec<mir::Local, CPlace<'tcx>>,\n-    #[allow(rustc::default_hash_types)] value_labels_ranges: &std::collections::HashMap<\n-        ValueLabel,\n-        Vec<ValueLocRange>,\n-    >,\n-    place: Place<'tcx>,\n-) -> AttributeValue {\n-    assert!(place.projection.is_empty()); // FIXME implement them\n-\n-    match local_map[place.local].inner() {\n-        CPlaceInner::Var(_local, var) => {\n-            let value_label = cranelift_codegen::ir::ValueLabel::new(var.index());\n-            if let Some(value_loc_ranges) = value_labels_ranges.get(&value_label) {\n-                let loc_list = LocationList(\n-                    value_loc_ranges\n-                        .iter()\n-                        .map(|value_loc_range| Location::StartEnd {\n-                            begin: Address::Symbol {\n-                                symbol,\n-                                addend: i64::from(value_loc_range.start),\n-                            },\n-                            end: Address::Symbol { symbol, addend: i64::from(value_loc_range.end) },\n-                            data: translate_loc(isa, value_loc_range.loc).unwrap(),\n-                        })\n-                        .collect(),\n-                );\n-                let loc_list_id = debug_context.dwarf.unit.locations.add(loc_list);\n-\n-                AttributeValue::LocationListRef(loc_list_id)\n-            } else {\n-                // FIXME set value labels for unused locals\n-\n-                AttributeValue::Exprloc(Expression::new())\n-            }\n-        }\n-        CPlaceInner::VarPair(_, _, _) => {\n-            // FIXME implement this\n-\n-            AttributeValue::Exprloc(Expression::new())\n-        }\n-        CPlaceInner::VarLane(_, _, _) => {\n-            // FIXME implement this\n-\n-            AttributeValue::Exprloc(Expression::new())\n-        }\n-        CPlaceInner::Addr(_, _) => {\n-            // FIXME implement this (used by arguments and returns)\n-\n-            AttributeValue::Exprloc(Expression::new())\n-\n-            // For PointerBase::Stack:\n-            //AttributeValue::Exprloc(translate_loc(ValueLoc::Stack(*stack_slot)).unwrap())\n-        }\n-    }\n-}\n-\n-// Adapted from https://github.com/CraneStation/wasmtime/blob/5a1845b4caf7a5dba8eda1fef05213a532ed4259/crates/debug/src/transform/expression.rs#L59-L137\n-fn translate_loc(isa: &dyn TargetIsa, loc: LabelValueLoc) -> Option<Expression> {\n-    match loc {\n-        LabelValueLoc::Reg(reg) => {\n-            let machine_reg = isa.map_regalloc_reg_to_dwarf(reg).unwrap();\n-            let mut expr = Expression::new();\n-            expr.op_reg(gimli::Register(machine_reg));\n-            Some(expr)\n-        }\n-        LabelValueLoc::SPOffset(offset) => {\n-            let mut expr = Expression::new();\n-            expr.op_breg(X86_64::RSP, offset);\n-            Some(expr)\n-        }\n     }\n }"}, {"sha": "3220d16f725390e048352b3412f1786ed5a2b7d9", "filename": "src/driver/aot.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b/src%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b/src%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Faot.rs?ref=7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b", "patch": "@@ -120,7 +120,7 @@ fn emit_cgu(\n     prof: &SelfProfilerRef,\n     name: String,\n     module: ObjectModule,\n-    debug: Option<DebugContext<'_>>,\n+    debug: Option<DebugContext>,\n     unwind_context: UnwindContext,\n     global_asm_object_file: Option<PathBuf>,\n ) -> Result<ModuleCodegenResult, String> {\n@@ -256,8 +256,9 @@ fn module_codegen(\n     for (mono_item, _) in mono_items {\n         match mono_item {\n             MonoItem::Fn(inst) => {\n-                cx.tcx.sess.time(\"codegen fn\", || {\n+                tcx.sess.time(\"codegen fn\", || {\n                     crate::base::codegen_and_compile_fn(\n+                        tcx,\n                         &mut cx,\n                         &mut cached_context,\n                         &mut module,\n@@ -279,25 +280,20 @@ fn module_codegen(\n         cgu.is_primary(),\n     );\n \n-    let global_asm_object_file = match crate::global_asm::compile_global_asm(\n+    let global_asm_object_file = crate::global_asm::compile_global_asm(\n         &global_asm_config,\n         cgu.name().as_str(),\n         &cx.global_asm,\n-    ) {\n-        Ok(global_asm_object_file) => global_asm_object_file,\n-        Err(err) => tcx.sess.fatal(&err),\n-    };\n+    )?;\n \n-    let debug_context = cx.debug_context;\n-    let unwind_context = cx.unwind_context;\n     tcx.sess.time(\"write object file\", || {\n         emit_cgu(\n             &global_asm_config.output_filenames,\n-            &tcx.sess.prof,\n+            &cx.profiler,\n             cgu.name().as_str().to_string(),\n             module,\n-            debug_context,\n-            unwind_context,\n+            cx.debug_context,\n+            cx.unwind_context,\n             global_asm_object_file,\n         )\n     })"}, {"sha": "0e77e4004c0bb5d0ef4c814c9003fa114c1b51d1", "filename": "src/driver/jit.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b/src%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b/src%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fjit.rs?ref=7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b", "patch": "@@ -61,11 +61,11 @@ impl UnsafeMessage {\n     }\n }\n \n-fn create_jit_module<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn create_jit_module(\n+    tcx: TyCtxt<'_>,\n     backend_config: &BackendConfig,\n     hotswap: bool,\n-) -> (JITModule, CodegenCx<'tcx>) {\n+) -> (JITModule, CodegenCx) {\n     let crate_info = CrateInfo::new(tcx, \"dummy_target_cpu\".to_string());\n     let imported_symbols = load_imported_symbols_for_jit(tcx.sess, crate_info);\n \n@@ -129,8 +129,9 @@ pub(crate) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n                 MonoItem::Fn(inst) => match backend_config.codegen_mode {\n                     CodegenMode::Aot => unreachable!(),\n                     CodegenMode::Jit => {\n-                        cx.tcx.sess.time(\"codegen fn\", || {\n+                        tcx.sess.time(\"codegen fn\", || {\n                             crate::base::codegen_and_compile_fn(\n+                                tcx,\n                                 &mut cx,\n                                 &mut cached_context,\n                                 &mut jit_module,\n@@ -139,7 +140,7 @@ pub(crate) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n                         });\n                     }\n                     CodegenMode::JitLazy => {\n-                        codegen_shim(&mut cx, &mut cached_context, &mut jit_module, inst)\n+                        codegen_shim(tcx, &mut cx, &mut cached_context, &mut jit_module, inst)\n                     }\n                 },\n                 MonoItem::Static(def_id) => {\n@@ -269,6 +270,7 @@ fn jit_fn(instance_ptr: *const Instance<'static>, trampoline_ptr: *const u8) ->\n             );\n             tcx.sess.time(\"codegen fn\", || {\n                 crate::base::codegen_and_compile_fn(\n+                    tcx,\n                     &mut cx,\n                     &mut Context::new(),\n                     jit_module,\n@@ -350,13 +352,12 @@ fn load_imported_symbols_for_jit(\n }\n \n fn codegen_shim<'tcx>(\n-    cx: &mut CodegenCx<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    cx: &mut CodegenCx,\n     cached_context: &mut Context,\n     module: &mut JITModule,\n     inst: Instance<'tcx>,\n ) {\n-    let tcx = cx.tcx;\n-\n     let pointer_type = module.target_config().pointer_type();\n \n     let name = tcx.symbol_name(inst).name;\n@@ -403,4 +404,5 @@ fn codegen_shim<'tcx>(\n     trampoline_builder.ins().return_(&ret_vals);\n \n     module.define_function(func_id, context).unwrap();\n+    cx.unwind_context.add_function(func_id, context, module.isa());\n }"}, {"sha": "40dab58523c201da80a228cf687367168c88733d", "filename": "src/lib.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b", "patch": "@@ -26,9 +26,11 @@ extern crate rustc_driver;\n \n use std::any::Any;\n use std::cell::{Cell, RefCell};\n+use std::sync::Arc;\n \n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_codegen_ssa::CodegenResults;\n+use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_errors::ErrorGuaranteed;\n use rustc_metadata::EncodedMetadata;\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n@@ -120,18 +122,20 @@ impl<F: Fn() -> String> Drop for PrintOnPanic<F> {\n \n /// The codegen context holds any information shared between the codegen of individual functions\n /// inside a single codegen unit with the exception of the Cranelift [`Module`](cranelift_module::Module).\n-struct CodegenCx<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n+struct CodegenCx {\n+    profiler: SelfProfilerRef,\n+    output_filenames: Arc<OutputFilenames>,\n+    should_write_ir: bool,\n     global_asm: String,\n     inline_asm_index: Cell<usize>,\n-    debug_context: Option<DebugContext<'tcx>>,\n+    debug_context: Option<DebugContext>,\n     unwind_context: UnwindContext,\n     cgu_name: Symbol,\n }\n \n-impl<'tcx> CodegenCx<'tcx> {\n+impl CodegenCx {\n     fn new(\n-        tcx: TyCtxt<'tcx>,\n+        tcx: TyCtxt<'_>,\n         backend_config: BackendConfig,\n         isa: &dyn TargetIsa,\n         debug_info: bool,\n@@ -147,7 +151,9 @@ impl<'tcx> CodegenCx<'tcx> {\n             None\n         };\n         CodegenCx {\n-            tcx,\n+            profiler: tcx.prof.clone(),\n+            output_filenames: tcx.output_filenames(()).clone(),\n+            should_write_ir: crate::pretty_clif::should_write_ir(tcx),\n             global_asm: String::new(),\n             inline_asm_index: Cell::new(0),\n             debug_context,"}, {"sha": "0df7e82294bd23521b72225d3746116488cac4d3", "filename": "src/optimize/mod.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b/src%2Foptimize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b/src%2Foptimize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foptimize%2Fmod.rs?ref=7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b", "patch": "@@ -1,20 +1,3 @@\n //! Various optimizations specific to cg_clif\n \n-use cranelift_codegen::isa::TargetIsa;\n-\n-use crate::prelude::*;\n-\n pub(crate) mod peephole;\n-\n-pub(crate) fn optimize_function<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    isa: &dyn TargetIsa,\n-    instance: Instance<'tcx>,\n-    ctx: &mut Context,\n-    clif_comments: &mut crate::pretty_clif::CommentWriter,\n-) {\n-    // FIXME classify optimizations over opt levels once we have more\n-\n-    crate::pretty_clif::write_clif_file(tcx, \"preopt\", isa, instance, &ctx.func, &*clif_comments);\n-    crate::base::verify_func(tcx, &*clif_comments, &ctx.func);\n-}"}, {"sha": "a7af162687c34c5cd0fa4ffbea65459779231eb7", "filename": "src/pretty_clif.rs", "status": "modified", "additions": 28, "deletions": 33, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b/src%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b/src%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpretty_clif.rs?ref=7dc8f38956f4ad6650032fe0fbcf4fcbbe5a6c2b", "patch": "@@ -62,7 +62,7 @@ use cranelift_codegen::{\n };\n \n use rustc_middle::ty::layout::FnAbiOf;\n-use rustc_session::config::OutputType;\n+use rustc_session::config::{OutputFilenames, OutputType};\n \n use crate::prelude::*;\n \n@@ -205,60 +205,55 @@ pub(crate) fn should_write_ir(tcx: TyCtxt<'_>) -> bool {\n }\n \n pub(crate) fn write_ir_file(\n-    tcx: TyCtxt<'_>,\n-    name: impl FnOnce() -> String,\n+    output_filenames: &OutputFilenames,\n+    name: &str,\n     write: impl FnOnce(&mut dyn Write) -> std::io::Result<()>,\n ) {\n-    if !should_write_ir(tcx) {\n-        return;\n-    }\n-\n-    let clif_output_dir = tcx.output_filenames(()).with_extension(\"clif\");\n+    let clif_output_dir = output_filenames.with_extension(\"clif\");\n \n     match std::fs::create_dir(&clif_output_dir) {\n         Ok(()) => {}\n         Err(err) if err.kind() == std::io::ErrorKind::AlreadyExists => {}\n         res @ Err(_) => res.unwrap(),\n     }\n \n-    let clif_file_name = clif_output_dir.join(name());\n+    let clif_file_name = clif_output_dir.join(name);\n \n     let res = std::fs::File::create(clif_file_name).and_then(|mut file| write(&mut file));\n     if let Err(err) = res {\n-        tcx.sess.warn(&format!(\"error writing ir file: {}\", err));\n+        // Using early_warn as no Session is available here\n+        rustc_session::early_warn(\n+            rustc_session::config::ErrorOutputType::default(),\n+            &format!(\"error writing ir file: {}\", err),\n+        );\n     }\n }\n \n-pub(crate) fn write_clif_file<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+pub(crate) fn write_clif_file(\n+    output_filenames: &OutputFilenames,\n+    symbol_name: &str,\n     postfix: &str,\n     isa: &dyn cranelift_codegen::isa::TargetIsa,\n-    instance: Instance<'tcx>,\n     func: &cranelift_codegen::ir::Function,\n     mut clif_comments: &CommentWriter,\n ) {\n     // FIXME work around filename too long errors\n-    write_ir_file(\n-        tcx,\n-        || format!(\"{}.{}.clif\", tcx.symbol_name(instance).name, postfix),\n-        |file| {\n-            let mut clif = String::new();\n-            cranelift_codegen::write::decorate_function(&mut clif_comments, &mut clif, func)\n-                .unwrap();\n+    write_ir_file(output_filenames, &format!(\"{}.{}.clif\", symbol_name, postfix), |file| {\n+        let mut clif = String::new();\n+        cranelift_codegen::write::decorate_function(&mut clif_comments, &mut clif, func).unwrap();\n \n-            for flag in isa.flags().iter() {\n-                writeln!(file, \"set {}\", flag)?;\n-            }\n-            write!(file, \"target {}\", isa.triple().architecture.to_string())?;\n-            for isa_flag in isa.isa_flags().iter() {\n-                write!(file, \" {}\", isa_flag)?;\n-            }\n-            writeln!(file, \"\\n\")?;\n-            writeln!(file)?;\n-            file.write_all(clif.as_bytes())?;\n-            Ok(())\n-        },\n-    );\n+        for flag in isa.flags().iter() {\n+            writeln!(file, \"set {}\", flag)?;\n+        }\n+        write!(file, \"target {}\", isa.triple().architecture.to_string())?;\n+        for isa_flag in isa.isa_flags().iter() {\n+            write!(file, \" {}\", isa_flag)?;\n+        }\n+        writeln!(file, \"\\n\")?;\n+        writeln!(file)?;\n+        file.write_all(clif.as_bytes())?;\n+        Ok(())\n+    });\n }\n \n impl fmt::Debug for FunctionCx<'_, '_, '_> {"}]}