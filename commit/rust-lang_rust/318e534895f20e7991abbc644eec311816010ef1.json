{"sha": "318e534895f20e7991abbc644eec311816010ef1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxOGU1MzQ4OTVmMjBlNzk5MWFiYmM2NDRlZWMzMTE4MTYwMTBlZjE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-15T02:59:30Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-19T23:33:11Z"}, "message": "rustc: Implement explicit self for Eq and Ord. r=graydon", "tree": {"sha": "764ce1ae3e9efbecd4fdc057663beb522b10bda9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/764ce1ae3e9efbecd4fdc057663beb522b10bda9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/318e534895f20e7991abbc644eec311816010ef1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/318e534895f20e7991abbc644eec311816010ef1", "html_url": "https://github.com/rust-lang/rust/commit/318e534895f20e7991abbc644eec311816010ef1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/318e534895f20e7991abbc644eec311816010ef1/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4101587a88d719659d2e30feaad8437c55af9150", "url": "https://api.github.com/repos/rust-lang/rust/commits/4101587a88d719659d2e30feaad8437c55af9150", "html_url": "https://github.com/rust-lang/rust/commit/4101587a88d719659d2e30feaad8437c55af9150"}], "stats": {"total": 4267, "additions": 4175, "deletions": 92}, "files": [{"sha": "b951c9fc3c1785484b07a902a49bb3293316717d", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -1,11 +1,20 @@\n enum mode { mode_compile_fail, mode_run_fail, mode_run_pass, mode_pretty, }\n \n+#[cfg(stage0)]\n impl mode : cmp::Eq {\n     pure fn eq(other: &mode) -> bool {\n         (*other) as int == self as int\n     }\n     pure fn ne(other: &mode) -> bool { !self.eq(other) }\n }\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl mode : cmp::Eq {\n+    pure fn eq(&self, other: &mode) -> bool {\n+        (*other) as int == (*self) as int\n+    }\n+    pure fn ne(&self, other: &mode) -> bool { !(*self).eq(other) }\n+}\n \n type config = {\n     // The library paths required for running the compiler"}, {"sha": "f05ccfffa8a80e00cf8bdf24f0520815eaf83a65", "filename": "src/libcargo/cargo.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -30,6 +30,7 @@ struct Package {\n }\n \n impl Package : cmp::Ord {\n+    #[cfg(stage0)]\n     pure fn lt(other: &Package) -> bool {\n         if self.name.lt(&(*other).name) { return true; }\n         if (*other).name.lt(&self.name) { return false; }\n@@ -46,9 +47,39 @@ impl Package : cmp::Ord {\n         if self.versions.lt(&(*other).versions) { return true; }\n         return false;\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn lt(&self, other: &Package) -> bool {\n+        if (*self).name.lt(&(*other).name) { return true; }\n+        if (*other).name.lt(&(*self).name) { return false; }\n+        if (*self).uuid.lt(&(*other).uuid) { return true; }\n+        if (*other).uuid.lt(&(*self).uuid) { return false; }\n+        if (*self).url.lt(&(*other).url) { return true; }\n+        if (*other).url.lt(&(*self).url) { return false; }\n+        if (*self).method.lt(&(*other).method) { return true; }\n+        if (*other).method.lt(&(*self).method) { return false; }\n+        if (*self).description.lt(&(*other).description) { return true; }\n+        if (*other).description.lt(&(*self).description) { return false; }\n+        if (*self).tags.lt(&(*other).tags) { return true; }\n+        if (*other).tags.lt(&(*self).tags) { return false; }\n+        if (*self).versions.lt(&(*other).versions) { return true; }\n+        return false;\n+    }\n+    #[cfg(stage0)]\n     pure fn le(other: &Package) -> bool { !(*other).lt(&self) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn le(&self, other: &Package) -> bool { !(*other).lt(&(*self)) }\n+    #[cfg(stage0)]\n     pure fn ge(other: &Package) -> bool { !self.lt(other)     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ge(&self, other: &Package) -> bool { !(*self).lt(other)     }\n+    #[cfg(stage0)]\n     pure fn gt(other: &Package) -> bool { (*other).lt(&self)  }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn gt(&self, other: &Package) -> bool { (*other).lt(&(*self))  }\n }\n \n struct Source {\n@@ -94,10 +125,20 @@ struct Options {\n enum Mode { SystemMode, UserMode, LocalMode }\n \n impl Mode : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Mode) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Mode) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Mode) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Mode) -> bool { !(*self).eq(other) }\n }\n \n fn opts() -> ~[getopts::Opt] {"}, {"sha": "60aa3d48fb3bd2e6e494d7a6e15983ff240497b0", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -66,8 +66,16 @@ pub fn all_values(blk: fn(v: bool)) {\n pub pure fn to_bit(v: bool) -> u8 { if v { 1u8 } else { 0u8 } }\n \n impl bool : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &bool) -> bool { self == (*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &bool) -> bool { (*self) == (*other) }\n+    #[cfg(stage0)]\n     pure fn ne(other: &bool) -> bool { self != (*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &bool) -> bool { (*self) != (*other) }\n }\n \n #[test]"}, {"sha": "4c32e58f56ed0cb7e5fa53ad5c481b08b5894809", "filename": "src/libcore/box.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbox.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -28,15 +28,39 @@ pub pure fn ptr_eq<T>(a: @T, b: @T) -> bool {\n }\n \n impl<T:Eq> @const T : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &@const T) -> bool { *self == *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &@const T) -> bool { *(*self) == *(*other) }\n+    #[cfg(stage0)]\n     pure fn ne(other: &@const T) -> bool { *self != *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &@const T) -> bool { *(*self) != *(*other) }\n }\n \n impl<T:Ord> @const T : Ord {\n+    #[cfg(stage0)]\n     pure fn lt(other: &@const T) -> bool { *self < *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn lt(&self, other: &@const T) -> bool { *(*self) < *(*other) }\n+    #[cfg(stage0)]\n     pure fn le(other: &@const T) -> bool { *self <= *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn le(&self, other: &@const T) -> bool { *(*self) <= *(*other) }\n+    #[cfg(stage0)]\n     pure fn ge(other: &@const T) -> bool { *self >= *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ge(&self, other: &@const T) -> bool { *(*self) >= *(*other) }\n+    #[cfg(stage0)]\n     pure fn gt(other: &@const T) -> bool { *self > *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn gt(&self, other: &@const T) -> bool { *(*self) > *(*other) }\n }\n \n #[test]"}, {"sha": "0a775ca1ac3dae7f593922038e7f3a70873ce966", "filename": "src/libcore/char.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -181,8 +181,16 @@ pub pure fn cmp(a: char, b: char) -> int {\n }\n \n impl char : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &char) -> bool { self == (*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &char) -> bool { (*self) == (*other) }\n+    #[cfg(stage0)]\n     pure fn ne(other: &char) -> bool { self != (*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &char) -> bool { (*self) != (*other) }\n }\n \n #[test]"}, {"sha": "c71111fb9e31bf27a5f82ab4e746b23e1c3952a4", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -30,13 +30,24 @@ mod nounittest {\n      * default implementations.\n      */\n     #[lang=\"ord\"]\n+    #[cfg(stage0)]\n     pub trait Ord {\n         pure fn lt(other: &self) -> bool;\n         pure fn le(other: &self) -> bool;\n         pure fn ge(other: &self) -> bool;\n         pure fn gt(other: &self) -> bool;\n     }\n \n+    #[lang=\"ord\"]\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pub trait Ord {\n+        pure fn lt(&self, other: &self) -> bool;\n+        pure fn le(&self, other: &self) -> bool;\n+        pure fn ge(&self, other: &self) -> bool;\n+        pure fn gt(&self, other: &self) -> bool;\n+    }\n+\n     #[lang=\"eq\"]\n     /**\n      * Trait for values that can be compared for equality\n@@ -47,10 +58,19 @@ mod nounittest {\n      * a default implementation.\n      */\n     #[lang=\"eq\"]\n+    #[cfg(stage0)]\n     pub trait Eq {\n         pure fn eq(other: &self) -> bool;\n         pure fn ne(other: &self) -> bool;\n     }\n+\n+    #[lang=\"eq\"]\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pub trait Eq {\n+        pure fn eq(&self, other: &self) -> bool;\n+        pure fn ne(&self, other: &self) -> bool;\n+    }\n }\n \n #[cfg(test)]\n@@ -60,17 +80,36 @@ mod nounittest {\n #[cfg(test)]\n mod unittest {\n     #[legacy_exports];\n+\n+    #[cfg(stage0)]\n     pub trait Ord {\n         pure fn lt(other: &self) -> bool;\n         pure fn le(other: &self) -> bool;\n         pure fn ge(other: &self) -> bool;\n         pure fn gt(other: &self) -> bool;\n     }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pub trait Ord {\n+        pure fn lt(&self, other: &self) -> bool;\n+        pure fn le(&self, other: &self) -> bool;\n+        pure fn ge(&self, other: &self) -> bool;\n+        pure fn gt(&self, other: &self) -> bool;\n+    }\n+\n+    #[cfg(stage0)]\n     pub trait Eq {\n         pure fn eq(other: &self) -> bool;\n         pure fn ne(other: &self) -> bool;\n     }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pub trait Eq {\n+        pure fn eq(&self, other: &self) -> bool;\n+        pure fn ne(&self, other: &self) -> bool;\n+    }\n }\n \n #[cfg(notest)]"}, {"sha": "5e3cbe45ef2fe46931496d87fb6ede9bcb8a5eee", "filename": "src/libcore/either.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -132,6 +132,7 @@ pub pure fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n }\n \n impl<T:Eq,U:Eq> Either<T,U> : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Either<T,U>) -> bool {\n         match self {\n             Left(ref a) => {\n@@ -148,7 +149,29 @@ impl<T:Eq,U:Eq> Either<T,U> : Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Either<T,U>) -> bool {\n+        match (*self) {\n+            Left(ref a) => {\n+                match (*other) {\n+                    Left(ref b) => (*a).eq(b),\n+                    Right(_) => false\n+                }\n+            }\n+            Right(ref a) => {\n+                match (*other) {\n+                    Left(_) => false,\n+                    Right(ref b) => (*a).eq(b)\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Either<T,U>) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Either<T,U>) -> bool { !(*self).eq(other) }\n }\n \n #[test]"}, {"sha": "aa3f4dac440d2c5b93fc8f7b68fd2faa382572c5", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -394,6 +394,7 @@ pub mod rt {\n     pub enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n \n     pub impl PadMode : Eq {\n+        #[cfg(stage0)]\n         pure fn eq(other: &PadMode) -> bool {\n             match (self, (*other)) {\n                 (PadSigned, PadSigned) => true,\n@@ -406,7 +407,25 @@ pub mod rt {\n                 (PadFloat, _) => false\n             }\n         }\n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        pure fn eq(&self, other: &PadMode) -> bool {\n+            match ((*self), (*other)) {\n+                (PadSigned, PadSigned) => true,\n+                (PadUnsigned, PadUnsigned) => true,\n+                (PadNozero, PadNozero) => true,\n+                (PadFloat, PadFloat) => true,\n+                (PadSigned, _) => false,\n+                (PadUnsigned, _) => false,\n+                (PadNozero, _) => false,\n+                (PadFloat, _) => false\n+            }\n+        }\n+        #[cfg(stage0)]\n         pure fn ne(other: &PadMode) -> bool { !self.eq(other) }\n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        pure fn ne(&self, other: &PadMode) -> bool { !(*self).eq(other) }\n     }\n \n     pub fn pad(cv: Conv, s: ~str, mode: PadMode) -> ~str {"}, {"sha": "cfddfaa00e2eb6d55e9f1aae24a18741542ad524", "filename": "src/libcore/float.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -400,15 +400,39 @@ pub pure fn cos(x: float) -> float { f64::cos(x as f64) as float }\n pub pure fn tan(x: float) -> float { f64::tan(x as f64) as float }\n \n impl float : Eq {\n+    #[cfg(stage0)]\n     pub pure fn eq(other: &float) -> bool { self == (*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &float) -> bool { (*self) == (*other) }\n+    #[cfg(stage0)]\n     pub pure fn ne(other: &float) -> bool { self != (*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &float) -> bool { (*self) != (*other) }\n }\n \n impl float : Ord {\n+    #[cfg(stage0)]\n     pub pure fn lt(other: &float) -> bool { self < (*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn lt(&self, other: &float) -> bool { (*self) < (*other) }\n+    #[cfg(stage0)]\n     pub pure fn le(other: &float) -> bool { self <= (*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn le(&self, other: &float) -> bool { (*self) <= (*other) }\n+    #[cfg(stage0)]\n     pub pure fn ge(other: &float) -> bool { self >= (*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ge(&self, other: &float) -> bool { (*self) >= (*other) }\n+    #[cfg(stage0)]\n     pub pure fn gt(other: &float) -> bool { self > (*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn gt(&self, other: &float) -> bool { (*self) > (*other) }\n }\n \n impl float: num::Num {"}, {"sha": "78f85fce3ec6b9f7717dae3801bb43622998caad", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -55,15 +55,39 @@ pub pure fn abs(i: T) -> T {\n }\n \n impl T : Ord {\n+    #[cfg(stage0)]\n     pure fn lt(other: &T) -> bool { return self < (*other); }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn lt(&self, other: &T) -> bool { return (*self) < (*other); }\n+    #[cfg(stage0)]\n     pure fn le(other: &T) -> bool { return self <= (*other); }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn le(&self, other: &T) -> bool { return (*self) <= (*other); }\n+    #[cfg(stage0)]\n     pure fn ge(other: &T) -> bool { return self >= (*other); }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ge(&self, other: &T) -> bool { return (*self) >= (*other); }\n+    #[cfg(stage0)]\n     pure fn gt(other: &T) -> bool { return self > (*other); }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn gt(&self, other: &T) -> bool { return (*self) > (*other); }\n }\n \n impl T : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &T) -> bool { return self == (*other); }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &T) -> bool { return (*self) == (*other); }\n+    #[cfg(stage0)]\n     pure fn ne(other: &T) -> bool { return self != (*other); }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &T) -> bool { return (*self) != (*other); }\n }\n \n impl T: num::Num {"}, {"sha": "2c92e70c7d99b09629ce008f801851a2605c5814", "filename": "src/libcore/io.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -523,13 +523,26 @@ pub enum FileFlag { Append, Create, Truncate, NoFlag, }\n pub enum WriterType { Screen, File }\n \n pub impl WriterType : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &WriterType) -> bool {\n         match (self, (*other)) {\n             (Screen, Screen) | (File, File) => true,\n             (Screen, _) | (File, _) => false\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &WriterType) -> bool {\n+        match ((*self), (*other)) {\n+            (Screen, Screen) | (File, File) => true,\n+            (Screen, _) | (File, _) => false\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &WriterType) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &WriterType) -> bool { !(*self).eq(other) }\n }\n \n // FIXME (#2004): Seekable really should be orthogonal."}, {"sha": "1c47bc7f1ba4dc35f698343ba7c2b86de7daad08", "filename": "src/libcore/option.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -301,6 +301,7 @@ impl<T: Copy> Option<T> {\n }\n \n impl<T: Eq> Option<T> : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Option<T>) -> bool {\n         match self {\n             None => {\n@@ -318,7 +319,30 @@ impl<T: Eq> Option<T> : Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Option<T>) -> bool {\n+        match (*self) {\n+            None => {\n+                match (*other) {\n+                    None => true,\n+                    Some(_) => false\n+                }\n+            }\n+            Some(ref self_contents) => {\n+                match (*other) {\n+                    None => false,\n+                    Some(ref other_contents) =>\n+                        (*self_contents).eq(other_contents)\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Option<T>) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Option<T>) -> bool { !(*self).eq(other) }\n }\n \n #[test]"}, {"sha": "62fffde7f169f66b63e00a449920705ed5427fe1", "filename": "src/libcore/owned.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fowned.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -7,14 +7,38 @@\n use cmp::{Eq, Ord};\n \n impl<T:Eq> ~const T : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &~const T) -> bool { *self == *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &~const T) -> bool { *(*self) == *(*other) }\n+    #[cfg(stage0)]\n     pure fn ne(other: &~const T) -> bool { *self != *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &~const T) -> bool { *(*self) != *(*other) }\n }\n \n impl<T:Ord> ~const T : Ord {\n+    #[cfg(stage0)]\n     pure fn lt(other: &~const T) -> bool { *self < *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn lt(&self, other: &~const T) -> bool { *(*self) < *(*other) }\n+    #[cfg(stage0)]\n     pure fn le(other: &~const T) -> bool { *self <= *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn le(&self, other: &~const T) -> bool { *(*self) <= *(*other) }\n+    #[cfg(stage0)]\n     pure fn ge(other: &~const T) -> bool { *self >= *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ge(&self, other: &~const T) -> bool { *(*self) >= *(*other) }\n+    #[cfg(stage0)]\n     pure fn gt(other: &~const T) -> bool { *self > *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn gt(&self, other: &~const T) -> bool { *(*self) > *(*other) }\n }\n "}, {"sha": "5f570ed434ec62af3b6bbb7c31c14d97388fe4f1", "filename": "src/libcore/path.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -71,21 +71,45 @@ impl PosixPath : ToStr {\n }\n \n impl PosixPath : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &PosixPath) -> bool {\n         return self.is_absolute == (*other).is_absolute &&\n             self.components == (*other).components;\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &PosixPath) -> bool {\n+        return (*self).is_absolute == (*other).is_absolute &&\n+            (*self).components == (*other).components;\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &PosixPath) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &PosixPath) -> bool { !(*self).eq(other) }\n }\n \n impl WindowsPath : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &WindowsPath) -> bool {\n         return self.host == (*other).host &&\n             self.device == (*other).device &&\n             self.is_absolute == (*other).is_absolute &&\n             self.components == (*other).components;\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &WindowsPath) -> bool {\n+        return (*self).host == (*other).host &&\n+            (*self).device == (*other).device &&\n+            (*self).is_absolute == (*other).is_absolute &&\n+            (*self).components == (*other).components;\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &WindowsPath) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &WindowsPath) -> bool { !(*self).eq(other) }\n }\n \n // FIXME (#3227): when default methods in traits are working, de-duplicate"}, {"sha": "8b05f63752f5bdd71d75bc5172c5046004dc816e", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -98,10 +98,20 @@ enum State {\n }\n \n impl State : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &State) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &State) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &State) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &State) -> bool { !(*self).eq(other) }\n }\n \n pub struct BufferHeader {"}, {"sha": "7cba022e7c377aa1cd2818eaaf13a276537f53ec", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -208,50 +208,130 @@ impl<T> *mut T: Ptr<T> {\n \n // Equality for pointers\n impl<T> *const T : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &*const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&self);\n         let b: uint = cast::reinterpret_cast(&(*other));\n         return a == b;\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &*const T) -> bool unsafe {\n+        let a: uint = cast::reinterpret_cast(&(*self));\n+        let b: uint = cast::reinterpret_cast(&(*other));\n+        return a == b;\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &*const T) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &*const T) -> bool { !(*self).eq(other) }\n }\n \n // Comparison for pointers\n impl<T> *const T : Ord {\n+    #[cfg(stage0)]\n     pure fn lt(other: &*const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&self);\n         let b: uint = cast::reinterpret_cast(&(*other));\n         return a < b;\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn lt(&self, other: &*const T) -> bool unsafe {\n+        let a: uint = cast::reinterpret_cast(&(*self));\n+        let b: uint = cast::reinterpret_cast(&(*other));\n+        return a < b;\n+    }\n+    #[cfg(stage0)]\n     pure fn le(other: &*const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&self);\n         let b: uint = cast::reinterpret_cast(&(*other));\n         return a <= b;\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn le(&self, other: &*const T) -> bool unsafe {\n+        let a: uint = cast::reinterpret_cast(&(*self));\n+        let b: uint = cast::reinterpret_cast(&(*other));\n+        return a <= b;\n+    }\n+    #[cfg(stage0)]\n     pure fn ge(other: &*const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&self);\n         let b: uint = cast::reinterpret_cast(&(*other));\n         return a >= b;\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ge(&self, other: &*const T) -> bool unsafe {\n+        let a: uint = cast::reinterpret_cast(&(*self));\n+        let b: uint = cast::reinterpret_cast(&(*other));\n+        return a >= b;\n+    }\n+    #[cfg(stage0)]\n     pure fn gt(other: &*const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&self);\n         let b: uint = cast::reinterpret_cast(&(*other));\n         return a > b;\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn gt(&self, other: &*const T) -> bool unsafe {\n+        let a: uint = cast::reinterpret_cast(&(*self));\n+        let b: uint = cast::reinterpret_cast(&(*other));\n+        return a > b;\n+    }\n }\n \n // Equality for region pointers\n impl<T:Eq> &const T : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: & &self/const T) -> bool { return *self == *(*other); }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: & &self/const T) -> bool {\n+        return *(*self) == *(*other);\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: & &self/const T) -> bool { return *self != *(*other); }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: & &self/const T) -> bool {\n+        return *(*self) != *(*other);\n+    }\n }\n \n // Comparison for region pointers\n impl<T:Ord> &const T : Ord {\n+    #[cfg(stage0)]\n     pure fn lt(other: & &self/const T) -> bool { *self < *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn lt(&self, other: & &self/const T) -> bool {\n+        *(*self) < *(*other)\n+    }\n+    #[cfg(stage0)]\n     pure fn le(other: & &self/const T) -> bool { *self <= *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn le(&self, other: & &self/const T) -> bool {\n+        *(*self) <= *(*other)\n+    }\n+    #[cfg(stage0)]\n     pure fn ge(other: & &self/const T) -> bool { *self >= *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ge(&self, other: & &self/const T) -> bool {\n+        *(*self) >= *(*other)\n+    }\n+    #[cfg(stage0)]\n     pure fn gt(other: & &self/const T) -> bool { *self > *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn gt(&self, other: & &self/const T) -> bool {\n+        *(*self) > *(*other)\n+    }\n }\n \n #[test]"}, {"sha": "6a4923eb0477a4aa9e45cc3e2ff5afae4f5a1712", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -516,10 +516,20 @@ enum EnumVisitState {\n }\n \n impl EnumVisitState : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &EnumVisitState) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &EnumVisitState) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &EnumVisitState) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &EnumVisitState) -> bool { !(*self).eq(other) }\n }\n \n struct EnumState {"}, {"sha": "31d813dad92c6bb40a3623ca911b7ff084d990a8", "filename": "src/libcore/result.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -365,6 +365,7 @@ pub fn unwrap_err<T, U>(res: Result<T, U>) -> U {\n }\n \n impl<T:Eq,U:Eq> Result<T,U> : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Result<T,U>) -> bool {\n         match self {\n             Ok(ref e0a) => {\n@@ -381,7 +382,29 @@ impl<T:Eq,U:Eq> Result<T,U> : Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Result<T,U>) -> bool {\n+        match (*self) {\n+            Ok(ref e0a) => {\n+                match (*other) {\n+                    Ok(ref e0b) => *e0a == *e0b,\n+                    _ => false\n+                }\n+            }\n+            Err(ref e0a) => {\n+                match (*other) {\n+                    Err(ref e0b) => *e0a == *e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Result<T,U>) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Result<T,U>) -> bool { !(*self).eq(other) }\n }\n \n #[cfg(test)]"}, {"sha": "971eaf5c857eb0eccdf1be9ab9f07d15836e382b", "filename": "src/libcore/str.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -737,62 +737,140 @@ pure fn gt(a: &str, b: &str) -> bool {\n \n impl &str : Eq {\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn eq(other: & &self/str) -> bool {\n         eq_slice(self, (*other))\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: & &self/str) -> bool {\n+        eq_slice((*self), (*other))\n+    }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn ne(other: & &self/str) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: & &self/str) -> bool { !(*self).eq(other) }\n }\n \n impl ~str : Eq {\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn eq(other: &~str) -> bool {\n         eq_slice(self, (*other))\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &~str) -> bool {\n+        eq_slice((*self), (*other))\n+    }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn ne(other: &~str) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &~str) -> bool { !(*self).eq(other) }\n }\n \n impl @str : Eq {\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn eq(other: &@str) -> bool {\n         eq_slice(self, (*other))\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &@str) -> bool {\n+        eq_slice((*self), (*other))\n+    }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn ne(other: &@str) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &@str) -> bool { !(*self).eq(other) }\n }\n \n impl ~str : Ord {\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn lt(other: &~str) -> bool { lt(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn lt(&self, other: &~str) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn le(other: &~str) -> bool { le(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn le(&self, other: &~str) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn ge(other: &~str) -> bool { ge(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ge(&self, other: &~str) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn gt(other: &~str) -> bool { gt(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn gt(&self, other: &~str) -> bool { gt((*self), (*other)) }\n }\n \n impl &str : Ord {\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn lt(other: & &self/str) -> bool { lt(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn lt(&self, other: & &self/str) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn le(other: & &self/str) -> bool { le(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn le(&self, other: & &self/str) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn ge(other: & &self/str) -> bool { ge(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ge(&self, other: & &self/str) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn gt(other: & &self/str) -> bool { gt(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn gt(&self, other: & &self/str) -> bool { gt((*self), (*other)) }\n }\n \n impl @str : Ord {\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn lt(other: &@str) -> bool { lt(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn lt(&self, other: &@str) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn le(other: &@str) -> bool { le(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn le(&self, other: &@str) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn ge(other: &@str) -> bool { ge(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ge(&self, other: &@str) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn gt(other: &@str) -> bool { gt(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn gt(&self, other: &@str) -> bool { gt((*self), (*other)) }\n }\n \n /*"}, {"sha": "3a6fa2d3931d95f0a0706f9dad5fe6e5a4b94b75", "filename": "src/libcore/task.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -43,8 +43,16 @@ pub enum Task {\n }\n \n impl Task : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Task) -> bool { *self == *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Task) -> bool { *(*self) == *(*other) }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Task) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Task) -> bool { !(*self).eq(other) }\n }\n \n /**\n@@ -64,13 +72,26 @@ pub enum TaskResult {\n }\n \n impl TaskResult : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &TaskResult) -> bool {\n         match (self, (*other)) {\n             (Success, Success) | (Failure, Failure) => true,\n             (Success, _) | (Failure, _) => false\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &TaskResult) -> bool {\n+        match ((*self), (*other)) {\n+            (Success, Success) | (Failure, Failure) => true,\n+            (Success, _) | (Failure, _) => false\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &TaskResult) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &TaskResult) -> bool { !(*self).eq(other) }\n }\n \n /// Scheduler modes\n@@ -93,6 +114,7 @@ pub enum SchedMode {\n }\n \n impl SchedMode : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &SchedMode) -> bool {\n         match self {\n             SingleThreaded => {\n@@ -127,9 +149,51 @@ impl SchedMode : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &SchedMode) -> bool {\n+        match (*self) {\n+            SingleThreaded => {\n+                match (*other) {\n+                    SingleThreaded => true,\n+                    _ => false\n+                }\n+            }\n+            ThreadPerCore => {\n+                match (*other) {\n+                    ThreadPerCore => true,\n+                    _ => false\n+                }\n+            }\n+            ThreadPerTask => {\n+                match (*other) {\n+                    ThreadPerTask => true,\n+                    _ => false\n+                }\n+            }\n+            ManualThreads(e0a) => {\n+                match (*other) {\n+                    ManualThreads(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            PlatformThread => {\n+                match (*other) {\n+                    PlatformThread => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &SchedMode) -> bool {\n         !self.eq(other)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &SchedMode) -> bool {\n+        !(*self).eq(other)\n+    }\n }\n \n /**"}, {"sha": "02550f3470f5bc6a3c6d4ac00621c638914cc167", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -7,12 +7,24 @@ pub trait LocalData { }\n impl<T: Owned> @T: LocalData { }\n \n impl LocalData: Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &@LocalData) -> bool unsafe {\n         let ptr_a: (uint, uint) = cast::reinterpret_cast(&self);\n         let ptr_b: (uint, uint) = cast::reinterpret_cast(other);\n         return ptr_a == ptr_b;\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &@LocalData) -> bool unsafe {\n+        let ptr_a: (uint, uint) = cast::reinterpret_cast(&(*self));\n+        let ptr_b: (uint, uint) = cast::reinterpret_cast(other);\n+        return ptr_a == ptr_b;\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &@LocalData) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &@LocalData) -> bool { !(*self).eq(other) }\n }\n \n // We use dvec because it's the best data structure in core. If TLS is used"}, {"sha": "33ad2cc903b48b8658a1a65a9a7400dedfd1ecb3", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -95,6 +95,7 @@ impl<A: Copy, B: Copy> (~[A], ~[B]): ExtendedTupleOps<A,B> {\n }\n \n impl<A: Eq, B: Eq> (A, B) : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &(A, B)) -> bool {\n         match self {\n             (ref self_a, ref self_b) => match other {\n@@ -104,10 +105,26 @@ impl<A: Eq, B: Eq> (A, B) : Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &(A, B)) -> bool {\n+        match (*self) {\n+            (ref self_a, ref self_b) => match other {\n+                &(ref other_a, ref other_b) => {\n+                    (*self_a).eq(other_a) && (*self_b).eq(other_b)\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &(A, B)) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &(A, B)) -> bool { !(*self).eq(other) }\n }\n \n impl<A: Ord, B: Ord> (A, B) : Ord {\n+    #[cfg(stage0)]\n     pure fn lt(other: &(A, B)) -> bool {\n         match self {\n             (ref self_a, ref self_b) => {\n@@ -122,12 +139,41 @@ impl<A: Ord, B: Ord> (A, B) : Ord {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn lt(&self, other: &(A, B)) -> bool {\n+        match (*self) {\n+            (ref self_a, ref self_b) => {\n+                match (*other) {\n+                    (ref other_a, ref other_b) => {\n+                        if (*self_a).lt(other_a) { return true; }\n+                        if (*other_a).lt(self_a) { return false; }\n+                        if (*self_b).lt(other_b) { return true; }\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn le(other: &(A, B)) -> bool { !(*other).lt(&self) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn le(&self, other: &(A, B)) -> bool { !(*other).lt(&(*self)) }\n+    #[cfg(stage0)]\n     pure fn ge(other: &(A, B)) -> bool { !self.lt(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ge(&self, other: &(A, B)) -> bool { !(*self).lt(other) }\n+    #[cfg(stage0)]\n     pure fn gt(other: &(A, B)) -> bool { (*other).lt(&self)  }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn gt(&self, other: &(A, B)) -> bool { (*other).lt(&(*self))  }\n }\n \n impl<A: Eq, B: Eq, C: Eq> (A, B, C) : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &(A, B, C)) -> bool {\n         match self {\n             (ref self_a, ref self_b, ref self_c) => match other {\n@@ -138,10 +184,27 @@ impl<A: Eq, B: Eq, C: Eq> (A, B, C) : Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &(A, B, C)) -> bool {\n+        match (*self) {\n+            (ref self_a, ref self_b, ref self_c) => match other {\n+                &(ref other_a, ref other_b, ref other_c) => {\n+                    (*self_a).eq(other_a) && (*self_b).eq(other_b)\n+                        && (*self_c).eq(other_c)\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &(A, B, C)) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &(A, B, C)) -> bool { !(*self).eq(other) }\n }\n \n impl<A: Ord, B: Ord, C: Ord> (A, B, C) : Ord {\n+    #[cfg(stage0)]\n     pure fn lt(other: &(A, B, C)) -> bool {\n         match self {\n             (ref self_a, ref self_b, ref self_c) => {\n@@ -158,9 +221,39 @@ impl<A: Ord, B: Ord, C: Ord> (A, B, C) : Ord {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn lt(&self, other: &(A, B, C)) -> bool {\n+        match (*self) {\n+            (ref self_a, ref self_b, ref self_c) => {\n+                match (*other) {\n+                    (ref other_a, ref other_b, ref other_c) => {\n+                        if (*self_a).lt(other_a) { return true; }\n+                        if (*other_a).lt(self_a) { return false; }\n+                        if (*self_b).lt(other_b) { return true; }\n+                        if (*other_b).lt(self_b) { return false; }\n+                        if (*self_c).lt(other_c) { return true; }\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn le(other: &(A, B, C)) -> bool { !(*other).lt(&self) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn le(&self, other: &(A, B, C)) -> bool { !(*other).lt(&(*self)) }\n+    #[cfg(stage0)]\n     pure fn ge(other: &(A, B, C)) -> bool { !self.lt(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ge(&self, other: &(A, B, C)) -> bool { !(*self).lt(other) }\n+    #[cfg(stage0)]\n     pure fn gt(other: &(A, B, C)) -> bool { (*other).lt(&self)  }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn gt(&self, other: &(A, B, C)) -> bool { (*other).lt(&(*self))  }\n }\n \n #[test]"}, {"sha": "4f84f9acb7e2da7975b976f60a63ccd1d78b7dad", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -49,15 +49,39 @@ pub pure fn compl(i: T) -> T {\n }\n \n impl T : Ord {\n+    #[cfg(stage0)]\n     pure fn lt(other: &T) -> bool { self < (*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn lt(&self, other: &T) -> bool { (*self) < (*other) }\n+    #[cfg(stage0)]\n     pure fn le(other: &T) -> bool { self <= (*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn le(&self, other: &T) -> bool { (*self) <= (*other) }\n+    #[cfg(stage0)]\n     pure fn ge(other: &T) -> bool { self >= (*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ge(&self, other: &T) -> bool { (*self) >= (*other) }\n+    #[cfg(stage0)]\n     pure fn gt(other: &T) -> bool { self > (*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn gt(&self, other: &T) -> bool { (*self) > (*other) }\n }\n \n impl T : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &T) -> bool { return self == (*other); }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &T) -> bool { return (*self) == (*other); }\n+    #[cfg(stage0)]\n     pure fn ne(other: &T) -> bool { return self != (*other); }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &T) -> bool { return (*self) != (*other); }\n }\n \n impl T: num::Num {"}, {"sha": "27960a09b2460a3e8aab45c14f40ccd005249559", "filename": "src/libcore/unit.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funit.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -11,14 +11,38 @@ Functions for the unit type.\n use cmp::{Eq, Ord};\n \n impl () : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(_other: &()) -> bool { true }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, _other: &()) -> bool { true }\n+    #[cfg(stage0)]\n     pure fn ne(_other: &()) -> bool { false }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, _other: &()) -> bool { false }\n }\n \n impl () : Ord {\n+    #[cfg(stage0)]\n     pure fn lt(_other: &()) -> bool { false }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn lt(&self, _other: &()) -> bool { false }\n+    #[cfg(stage0)]\n     pure fn le(_other: &()) -> bool { true }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn le(&self, _other: &()) -> bool { true }\n+    #[cfg(stage0)]\n     pure fn ge(_other: &()) -> bool { true }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ge(&self, _other: &()) -> bool { true }\n+    #[cfg(stage0)]\n     pure fn gt(_other: &()) -> bool { false }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn gt(&self, _other: &()) -> bool { false }\n }\n "}, {"sha": "e7821c1246cd6306875918c73da018b23ffed32b", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -1319,24 +1319,48 @@ pure fn eq<T: Eq>(a: &[T], b: &[T]) -> bool {\n \n impl<T: Eq> &[T] : Eq {\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn eq(other: & &self/[T]) -> bool { eq(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: & &self/[T]) -> bool { eq((*self), (*other)) }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn ne(other: & &self/[T]) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: & &self/[T]) -> bool { !(*self).eq(other) }\n }\n \n \n impl<T: Eq> ~[T] : Eq {\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn eq(other: &~[T]) -> bool { eq(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &~[T]) -> bool { eq((*self), (*other)) }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn ne(other: &~[T]) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &~[T]) -> bool { !(*self).eq(other) }\n }\n \n impl<T: Eq> @[T] : Eq {\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn eq(other: &@[T]) -> bool { eq(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &@[T]) -> bool { eq((*self), (*other)) }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn ne(other: &@[T]) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &@[T]) -> bool { !(*self).eq(other) }\n }\n \n // Lexicographical comparison\n@@ -1362,35 +1386,83 @@ pure fn gt<T: Ord>(a: &[T], b: &[T]) -> bool { lt(b, a)  }\n \n impl<T: Ord> &[T] : Ord {\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn lt(other: & &self/[T]) -> bool { lt(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn lt(&self, other: & &self/[T]) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn le(other: & &self/[T]) -> bool { le(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn le(&self, other: & &self/[T]) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn ge(other: & &self/[T]) -> bool { ge(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ge(&self, other: & &self/[T]) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn gt(other: & &self/[T]) -> bool { gt(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn gt(&self, other: & &self/[T]) -> bool { gt((*self), (*other)) }\n }\n \n impl<T: Ord> ~[T] : Ord {\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn lt(other: &~[T]) -> bool { lt(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn lt(&self, other: &~[T]) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn le(other: &~[T]) -> bool { le(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn le(&self, other: &~[T]) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn ge(other: &~[T]) -> bool { ge(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ge(&self, other: &~[T]) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn gt(other: &~[T]) -> bool { gt(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn gt(&self, other: &~[T]) -> bool { gt((*self), (*other)) }\n }\n \n impl<T: Ord> @[T] : Ord {\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn lt(other: &@[T]) -> bool { lt(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn lt(&self, other: &@[T]) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn le(other: &@[T]) -> bool { le(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn le(&self, other: &@[T]) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn ge(other: &@[T]) -> bool { ge(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ge(&self, other: &@[T]) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pure fn gt(other: &@[T]) -> bool { gt(self, (*other)) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn gt(&self, other: &@[T]) -> bool { gt((*self), (*other)) }\n }\n \n #[cfg(notest)]"}, {"sha": "652837909b14acc2dce98e2e837f0c2a771c43ac", "filename": "src/libfuzzer/fuzzer.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibfuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibfuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -10,13 +10,23 @@ use syntax::diagnostic;\n enum test_mode { tm_converge, tm_run, }\n type context = { mode: test_mode }; // + rng\n \n+#[cfg(stage0)]\n impl test_mode : cmp::Eq {\n     pure fn eq(other: &test_mode) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n     pure fn ne(other: &test_mode) -> bool { !self.eq(other) }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl test_mode : cmp::Eq {\n+    pure fn eq(&self, other: &test_mode) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(&self, other: &test_mode) -> bool { !(*self).eq(other) }\n+}\n+\n fn write_file(filename: &Path, content: ~str) {\n     result::get(\n         &io::file_writer(filename, ~[io::Create, io::Truncate]))"}, {"sha": "a33ca6f8f391e4a3b5adf3e31d36f90dea619cab", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -27,10 +27,20 @@ enum output_type {\n }\n \n impl output_type : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &output_type) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &output_type) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &output_type) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &output_type) -> bool { !(*self).eq(other) }\n }\n \n fn llvm_err(sess: Session, msg: ~str) -> ! unsafe {"}, {"sha": "ff6cf9fd3b41c630f4b244606ed39dd98854bde5", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -141,10 +141,20 @@ enum compile_upto {\n }\n \n impl compile_upto : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &compile_upto) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &compile_upto) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &compile_upto) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &compile_upto) -> bool { !(*self).eq(other) }\n }\n \n fn compile_upto(sess: Session, cfg: ast::crate_cfg,"}, {"sha": "d1ec992bc535dcfd2a58c3def0d1589d4f5afa02", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -13,19 +13,39 @@ use middle::lint;\n enum os { os_win32, os_macos, os_linux, os_freebsd, }\n \n impl os : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &os) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &os) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &os) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &os) -> bool { !(*self).eq(other) }\n }\n \n enum arch { arch_x86, arch_x86_64, arch_arm, }\n \n impl arch : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &arch) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &arch) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &arch) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &arch) -> bool { !(*self).eq(other) }\n }\n \n enum crate_type { bin_crate, lib_crate, unknown_crate, }\n@@ -91,10 +111,20 @@ enum OptLevel {\n }\n \n impl OptLevel : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &OptLevel) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &OptLevel) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &OptLevel) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &OptLevel) -> bool { !(*self).eq(other) }\n }\n \n type options ="}, {"sha": "4da3d41dee6f1685c7cd5a99ca9a97db056ef6ae", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -131,6 +131,7 @@ enum TypeKind {\n }\n \n impl TypeKind : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &TypeKind) -> bool {\n         match (self, (*other)) {\n             (Void, Void) => true,\n@@ -167,7 +168,49 @@ impl TypeKind : cmp::Eq {\n             (X86_MMX, _) => false,\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &TypeKind) -> bool {\n+        match ((*self), (*other)) {\n+            (Void, Void) => true,\n+            (Half, Half) => true,\n+            (Float, Float) => true,\n+            (Double, Double) => true,\n+            (X86_FP80, X86_FP80) => true,\n+            (FP128, FP128) => true,\n+            (PPC_FP128, PPC_FP128) => true,\n+            (Label, Label) => true,\n+            (Integer, Integer) => true,\n+            (Function, Function) => true,\n+            (Struct, Struct) => true,\n+            (Array, Array) => true,\n+            (Pointer, Pointer) => true,\n+            (Vector, Vector) => true,\n+            (Metadata, Metadata) => true,\n+            (X86_MMX, X86_MMX) => true,\n+            (Void, _) => false,\n+            (Half, _) => false,\n+            (Float, _) => false,\n+            (Double, _) => false,\n+            (X86_FP80, _) => false,\n+            (FP128, _) => false,\n+            (PPC_FP128, _) => false,\n+            (Label, _) => false,\n+            (Integer, _) => false,\n+            (Function, _) => false,\n+            (Struct, _) => false,\n+            (Array, _) => false,\n+            (Pointer, _) => false,\n+            (Vector, _) => false,\n+            (Metadata, _) => false,\n+            (X86_MMX, _) => false,\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &TypeKind) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &TypeKind) -> bool { !(*self).eq(other) }\n }\n \n enum AtomicBinOp {"}, {"sha": "f079406325e2923be2041e403e9e2d94d140e945", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -139,10 +139,20 @@ enum Family {\n }\n \n impl Family : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Family) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Family) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Family) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Family) -> bool { !(*self).eq(other) }\n }\n \n fn item_family(item: ebml::Doc) -> Family {"}, {"sha": "25e184c2c02c3617fa5d03fe56b7f587bfbc2440", "filename": "src/librustc/middle/borrowck.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -323,6 +323,7 @@ enum bckerr_code {\n }\n \n impl bckerr_code : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &bckerr_code) -> bool {\n         match self {\n             err_mut_uniq => {\n@@ -364,18 +365,75 @@ impl bckerr_code : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &bckerr_code) -> bool {\n+        match (*self) {\n+            err_mut_uniq => {\n+                match (*other) {\n+                    err_mut_uniq => true,\n+                    _ => false\n+                }\n+            }\n+            err_mut_variant => {\n+                match (*other) {\n+                    err_mut_variant => true,\n+                    _ => false\n+                }\n+            }\n+            err_root_not_permitted => {\n+                match (*other) {\n+                    err_root_not_permitted => true,\n+                    _ => false\n+                }\n+            }\n+            err_mutbl(e0a) => {\n+                match (*other) {\n+                    err_mutbl(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            err_out_of_root_scope(e0a, e1a) => {\n+                match (*other) {\n+                    err_out_of_root_scope(e0b, e1b) =>\n+                        e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            err_out_of_scope(e0a, e1a) => {\n+                match (*other) {\n+                    err_out_of_scope(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &bckerr_code) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &bckerr_code) -> bool { !(*self).eq(other) }\n }\n \n // Combination of an error code and the categorization of the expression\n // that caused it\n type bckerr = {cmt: cmt, code: bckerr_code};\n \n impl bckerr : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &bckerr) -> bool {\n         self.cmt == (*other).cmt && self.code == (*other).code\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &bckerr) -> bool {\n+        (*self).cmt == (*other).cmt && (*self).code == (*other).code\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &bckerr) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &bckerr) -> bool { !(*self).eq(other) }\n }\n \n // shorthand for something that fails with `bckerr` or succeeds with `T`\n@@ -405,12 +463,24 @@ fn save_and_restore<T:Copy,U>(save_and_restore_t: &mut T, f: fn() -> U) -> U {\n /// Creates and returns a new root_map\n \n impl root_map_key : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &root_map_key) -> bool {\n         self.id == (*other).id && self.derefs == (*other).derefs\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &root_map_key) -> bool {\n+        (*self).id == (*other).id && (*self).derefs == (*other).derefs\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &root_map_key) -> bool {\n         ! (self == (*other))\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &root_map_key) -> bool {\n+        ! ((*self) == (*other))\n+    }\n }\n \n impl root_map_key : to_bytes::IterBytes {"}, {"sha": "366dd7e7e8504f711f5f43657f3e9165c019976d", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -33,6 +33,7 @@ enum purity_cause {\n }\n \n impl purity_cause : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &purity_cause) -> bool {\n         match self {\n             pc_pure_fn => {\n@@ -49,7 +50,29 @@ impl purity_cause : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &purity_cause) -> bool {\n+        match (*self) {\n+            pc_pure_fn => {\n+                match (*other) {\n+                    pc_pure_fn => true,\n+                    _ => false\n+                }\n+            }\n+            pc_cmt(e0a) => {\n+                match (*other) {\n+                    pc_cmt(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &purity_cause) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &purity_cause) -> bool { !(*self).eq(other) }\n }\n \n fn check_loans(bccx: borrowck_ctxt,\n@@ -74,10 +97,20 @@ enum assignment_type {\n }\n \n impl assignment_type : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &assignment_type) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &assignment_type) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &assignment_type) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &assignment_type) -> bool { !(*self).eq(other) }\n }\n \n impl assignment_type {"}, {"sha": "6de4e6760ed9ab429663fae5061d7db3c8846f49", "filename": "src/librustc/middle/check_alt.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -126,6 +126,7 @@ enum ctor {\n }\n \n impl ctor : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &ctor) -> bool {\n         match (self, (*other)) {\n             (single, single) => true,\n@@ -139,7 +140,26 @@ impl ctor : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &ctor) -> bool {\n+        match ((*self), (*other)) {\n+            (single, single) => true,\n+            (variant(did_self), variant(did_other)) => did_self == did_other,\n+            (val(cv_self), val(cv_other)) => cv_self == cv_other,\n+            (range(cv0_self, cv1_self), range(cv0_other, cv1_other)) => {\n+                cv0_self == cv0_other && cv1_self == cv1_other\n+            }\n+            (single, _) | (variant(_), _) | (val(_), _) | (range(*), _) => {\n+                false\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &ctor) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &ctor) -> bool { !(*self).eq(other) }\n }\n \n // Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html"}, {"sha": "68e40c75da845929003d56e10f4e011d618f8d7e", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -206,6 +206,7 @@ enum const_val {\n }\n \n impl const_val : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &const_val) -> bool {\n         match (self, (*other)) {\n             (const_float(a), const_float(b)) => a == b,\n@@ -217,7 +218,24 @@ impl const_val : cmp::Eq {\n             (const_str(_), _) | (const_bool(_), _) => false\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &const_val) -> bool {\n+        match ((*self), (*other)) {\n+            (const_float(a), const_float(b)) => a == b,\n+            (const_int(a), const_int(b)) => a == b,\n+            (const_uint(a), const_uint(b)) => a == b,\n+            (const_str(a), const_str(b)) => a == b,\n+            (const_bool(a), const_bool(b)) => a == b,\n+            (const_float(_), _) | (const_int(_), _) | (const_uint(_), _) |\n+            (const_str(_), _) | (const_bool(_), _) => false\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &const_val) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &const_val) -> bool { !(*self).eq(other) }\n }\n \n fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {"}, {"sha": "15b9e31af1bacac7a130ae937f2255eb814b9d3b", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -68,10 +68,20 @@ enum lint {\n }\n \n impl lint : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &lint) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &lint) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &lint) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &lint) -> bool { !(*self).eq(other) }\n }\n \n fn level_to_str(lv: level) -> ~str {\n@@ -88,10 +98,20 @@ enum level {\n }\n \n impl level : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &level) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &level) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &level) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &level) -> bool { !(*self).eq(other) }\n }\n \n type lint_spec = @{lint: lint,"}, {"sha": "f55985aba13c5c49b6aa5bdf4f1acc5c682cbcb3", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -119,13 +119,29 @@ enum Variable = uint;\n enum LiveNode = uint;\n \n impl Variable : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Variable) -> bool { *self == *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Variable) -> bool { *(*self) == *(*other) }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Variable) -> bool { *self != *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Variable) -> bool { *(*self) != *(*other) }\n }\n \n impl LiveNode : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &LiveNode) -> bool { *self == *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &LiveNode) -> bool { *(*self) == *(*other) }\n+    #[cfg(stage0)]\n     pure fn ne(other: &LiveNode) -> bool { *self != *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &LiveNode) -> bool { *(*self) != *(*other) }\n }\n \n enum LiveNodeKind {\n@@ -136,6 +152,7 @@ enum LiveNodeKind {\n }\n \n impl LiveNodeKind : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &LiveNodeKind) -> bool {\n         match self {\n             FreeVarNode(e0a) => {\n@@ -164,7 +181,41 @@ impl LiveNodeKind : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &LiveNodeKind) -> bool {\n+        match (*self) {\n+            FreeVarNode(e0a) => {\n+                match (*other) {\n+                    FreeVarNode(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ExprNode(e0a) => {\n+                match (*other) {\n+                    ExprNode(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            VarDefNode(e0a) => {\n+                match (*other) {\n+                    VarDefNode(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ExitNode => {\n+                match (*other) {\n+                    ExitNode => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &LiveNodeKind) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &LiveNodeKind) -> bool { !(*self).eq(other) }\n }\n \n fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {"}, {"sha": "ebc06435c64e6f6d98a5b018265975c432e59514", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -56,6 +56,7 @@ enum categorization {\n }\n \n impl categorization : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &categorization) -> bool {\n         match self {\n             cat_rvalue => {\n@@ -115,7 +116,72 @@ impl categorization : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &categorization) -> bool {\n+        match (*self) {\n+            cat_rvalue => {\n+                match (*other) {\n+                    cat_rvalue => true,\n+                    _ => false\n+                }\n+            }\n+            cat_special(e0a) => {\n+                match (*other) {\n+                    cat_special(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            cat_local(e0a) => {\n+                match (*other) {\n+                    cat_local(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            cat_binding(e0a) => {\n+                match (*other) {\n+                    cat_binding(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            cat_arg(e0a) => {\n+                match (*other) {\n+                    cat_arg(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            cat_stack_upvar(e0a) => {\n+                match (*other) {\n+                    cat_stack_upvar(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            cat_deref(e0a, e1a, e2a) => {\n+                match (*other) {\n+                    cat_deref(e0b, e1b, e2b) =>\n+                        e0a == e0b && e1a == e1b && e2a == e2b,\n+                    _ => false\n+                }\n+            }\n+            cat_comp(e0a, e1a) => {\n+                match (*other) {\n+                    cat_comp(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            cat_discr(e0a, e1a) => {\n+                match (*other) {\n+                    cat_discr(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &categorization) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &categorization) -> bool { !(*self).eq(other) }\n }\n \n // different kinds of pointers:\n@@ -127,6 +193,7 @@ enum ptr_kind {\n }\n \n impl ptr_kind : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &ptr_kind) -> bool {\n         match self {\n             uniq_ptr => {\n@@ -155,7 +222,41 @@ impl ptr_kind : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &ptr_kind) -> bool {\n+        match (*self) {\n+            uniq_ptr => {\n+                match (*other) {\n+                    uniq_ptr => true,\n+                    _ => false\n+                }\n+            }\n+            gc_ptr => {\n+                match (*other) {\n+                    gc_ptr => true,\n+                    _ => false\n+                }\n+            }\n+            region_ptr(e0a) => {\n+                match (*other) {\n+                    region_ptr(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            unsafe_ptr => {\n+                match (*other) {\n+                    unsafe_ptr => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &ptr_kind) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &ptr_kind) -> bool { !(*self).eq(other) }\n }\n \n // I am coining the term \"components\" to mean \"pieces of a data\n@@ -172,6 +273,7 @@ enum comp_kind {\n }\n \n impl comp_kind : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &comp_kind) -> bool {\n         match self {\n             comp_tuple => {\n@@ -206,7 +308,47 @@ impl comp_kind : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &comp_kind) -> bool {\n+        match (*self) {\n+            comp_tuple => {\n+                match (*other) {\n+                    comp_tuple => true,\n+                    _ => false\n+                }\n+            }\n+            comp_anon_field => {\n+                match (*other) {\n+                    comp_anon_field => true,\n+                    _ => false\n+                }\n+            }\n+            comp_variant(e0a) => {\n+                match (*other) {\n+                    comp_variant(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            comp_field(e0a, e1a) => {\n+                match (*other) {\n+                    comp_field(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            comp_index(e0a, e1a) => {\n+                match (*other) {\n+                    comp_index(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &comp_kind) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &comp_kind) -> bool { !(*self).eq(other) }\n }\n \n // different kinds of expressions we might evaluate\n@@ -218,10 +360,20 @@ enum special_kind {\n }\n \n impl special_kind : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &special_kind) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &special_kind) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &special_kind) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &special_kind) -> bool { !(*self).eq(other) }\n }\n \n // a complete categorization of a value indicating where it originated\n@@ -237,6 +389,7 @@ type cmt_ = {id: ast::node_id,        // id of expr/pat producing this value\n type cmt = @cmt_;\n \n impl cmt_ : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &cmt_) -> bool {\n         self.id == (*other).id &&\n         self.span == (*other).span &&\n@@ -245,7 +398,21 @@ impl cmt_ : cmp::Eq {\n         self.mutbl == (*other).mutbl &&\n         self.ty == (*other).ty\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &cmt_) -> bool {\n+        (*self).id == (*other).id &&\n+        (*self).span == (*other).span &&\n+        (*self).cat == (*other).cat &&\n+        (*self).lp == (*other).lp &&\n+        (*self).mutbl == (*other).mutbl &&\n+        (*self).ty == (*other).ty\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &cmt_) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &cmt_) -> bool { !(*self).eq(other) }\n }\n \n // a loan path is like a category, but it exists only when the data is\n@@ -259,6 +426,7 @@ enum loan_path {\n }\n \n impl loan_path : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &loan_path) -> bool {\n         match self {\n             lp_local(e0a) => {\n@@ -287,7 +455,41 @@ impl loan_path : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &loan_path) -> bool {\n+        match (*self) {\n+            lp_local(e0a) => {\n+                match (*other) {\n+                    lp_local(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            lp_arg(e0a) => {\n+                match (*other) {\n+                    lp_arg(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            lp_deref(e0a, e1a) => {\n+                match (*other) {\n+                    lp_deref(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            lp_comp(e0a, e1a) => {\n+                match (*other) {\n+                    lp_comp(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &loan_path) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &loan_path) -> bool { !(*self).eq(other) }\n }\n \n // We pun on *T to mean both actual deref of a ptr as well"}, {"sha": "e2bb63da487d1ad25dbf73e1bde87a26781f828c", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -374,11 +374,22 @@ type region_dep = {ambient_variance: region_variance, id: ast::node_id};\n type dep_map = HashMap<ast::node_id, @DVec<region_dep>>;\n \n impl region_dep : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &region_dep) -> bool {\n         self.ambient_variance == (*other).ambient_variance &&\n         self.id == (*other).id\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &region_dep) -> bool {\n+        (*self).ambient_variance == (*other).ambient_variance &&\n+        (*self).id == (*other).id\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &region_dep) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &region_dep) -> bool { !(*self).eq(other) }\n }\n \n type determine_rp_ctxt_ = {"}, {"sha": "828a88b5c02bc96e9305ff9e871bb194c5911b5d", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -108,6 +108,7 @@ enum PatternBindingMode {\n }\n \n impl PatternBindingMode : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &PatternBindingMode) -> bool {\n         match self {\n             RefutableMode => {\n@@ -130,7 +131,37 @@ impl PatternBindingMode : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &PatternBindingMode) -> bool {\n+        match (*self) {\n+            RefutableMode => {\n+                match *other {\n+                    RefutableMode => true,\n+                    _ => false\n+                }\n+            }\n+            LocalIrrefutableMode => {\n+                match *other {\n+                    LocalIrrefutableMode => true,\n+                    _ => false\n+                }\n+            }\n+            ArgumentIrrefutableMode(mode_a) => {\n+                match *other {\n+                    ArgumentIrrefutableMode(mode_b) => mode_a == mode_b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &PatternBindingMode) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &PatternBindingMode) -> bool {\n+        !(*self).eq(other)\n+    }\n }\n \n \n@@ -167,10 +198,20 @@ enum Mutability {\n }\n \n impl Mutability : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Mutability) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Mutability) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Mutability) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Mutability) -> bool { !(*self).eq(other) }\n }\n \n enum SelfBinding {\n@@ -191,10 +232,22 @@ enum ImportDirectiveNS {\n }\n \n impl ImportDirectiveNS : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &ImportDirectiveNS) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &ImportDirectiveNS) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &ImportDirectiveNS) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &ImportDirectiveNS) -> bool {\n+        !(*self).eq(other)\n+    }\n }\n \n /// Contains data for specific types of import directives.\n@@ -290,10 +343,20 @@ enum XrayFlag {\n }\n \n impl XrayFlag : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &XrayFlag) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &XrayFlag) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &XrayFlag) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &XrayFlag) -> bool { !(*self).eq(other) }\n }\n \n enum AllowCapturingSelfFlag {\n@@ -302,10 +365,22 @@ enum AllowCapturingSelfFlag {\n }\n \n impl AllowCapturingSelfFlag : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &AllowCapturingSelfFlag) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &AllowCapturingSelfFlag) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &AllowCapturingSelfFlag) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &AllowCapturingSelfFlag) -> bool {\n+        !(*self).eq(other)\n+    }\n }\n \n enum BareIdentifierPatternResolution {\n@@ -325,10 +400,22 @@ enum DuplicateCheckingMode {\n }\n \n impl DuplicateCheckingMode : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &DuplicateCheckingMode) -> bool {\n         (self as uint) == (*other as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &DuplicateCheckingMode) -> bool {\n+        ((*self) as uint) == (*other as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &DuplicateCheckingMode) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &DuplicateCheckingMode) -> bool {\n+        !(*self).eq(other)\n+    }\n }\n \n // Returns the namespace associated with the given duplicate checking mode,\n@@ -532,10 +619,20 @@ enum Privacy {\n }\n \n impl Privacy : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Privacy) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Privacy) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Privacy) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Privacy) -> bool { !(*self).eq(other) }\n }\n \n // Records a possibly-private type definition."}, {"sha": "49db8613366ca34f6e27e8a82b11076e30339771", "filename": "src/librustc/middle/trans/alt.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -907,10 +907,20 @@ fn pick_col(m: &[@Match]) -> uint {\n enum branch_kind { no_branch, single, switch, compare, }\n \n impl branch_kind : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &branch_kind) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &branch_kind) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &branch_kind) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &branch_kind) -> bool { !(*self).eq(other) }\n }\n \n // Compiles a comparison between two things."}, {"sha": "1000aec9d182c0b1443179fdbb8a282bcdd519d4", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -296,6 +296,7 @@ enum cleanup {\n }\n \n impl cleantype : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &cleantype) -> bool {\n         match self {\n             normal_exit_only => {\n@@ -312,7 +313,29 @@ impl cleantype : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &cleantype) -> bool {\n+        match (*self) {\n+            normal_exit_only => {\n+                match (*other) {\n+                    normal_exit_only => true,\n+                    _ => false\n+                }\n+            }\n+            normal_exit_and_unwind => {\n+                match (*other) {\n+                    normal_exit_and_unwind => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &cleantype) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &cleantype) -> bool { !(*self).eq(other) }\n }\n \n // Used to remember and reuse existing cleanup paths\n@@ -1144,6 +1167,7 @@ type mono_id_ = {\n type mono_id = @mono_id_;\n \n impl mono_param_id : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &mono_param_id) -> bool {\n         match (self, (*other)) {\n             (mono_precise(ty_a, ids_a), mono_precise(ty_b, ids_b)) => {\n@@ -1160,14 +1184,46 @@ impl mono_param_id : cmp::Eq {\n             (mono_repr(*), _) => false\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &mono_param_id) -> bool {\n+        match ((*self), (*other)) {\n+            (mono_precise(ty_a, ids_a), mono_precise(ty_b, ids_b)) => {\n+                ty_a == ty_b && ids_a == ids_b\n+            }\n+            (mono_any, mono_any) => true,\n+            (mono_repr(size_a, align_a, is_float_a, mode_a),\n+             mono_repr(size_b, align_b, is_float_b, mode_b)) => {\n+                size_a == size_b && align_a == align_b &&\n+                    is_float_a == is_float_b && mode_a == mode_b\n+            }\n+            (mono_precise(*), _) => false,\n+            (mono_any, _) => false,\n+            (mono_repr(*), _) => false\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &mono_param_id) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &mono_param_id) -> bool { !(*self).eq(other) }\n }\n \n impl mono_id_ : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &mono_id_) -> bool {\n-        return self.def == (*other).def && self.params == (*other).params;\n+        self.def == (*other).def && self.params == (*other).params\n+    }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &mono_id_) -> bool {\n+        (*self).def == (*other).def && (*self).params == (*other).params\n     }\n+    #[cfg(stage0)]\n     pure fn ne(other: &mono_id_) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &mono_id_) -> bool { !(*self).eq(other) }\n }\n \n impl mono_param_id : to_bytes::IterBytes {"}, {"sha": "126ab65053e8131725da98fdccd4b4daa702a6ae", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -139,10 +139,20 @@ impl DatumMode {\n }\n \n impl DatumMode: cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &DatumMode) -> bool {\n         self as uint == (*other as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &DatumMode) -> bool {\n+        (*self) as uint == (*other as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &DatumMode) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &DatumMode) -> bool { !(*self).eq(other) }\n }\n \n impl DatumMode: to_bytes::IterBytes {\n@@ -799,6 +809,7 @@ impl DatumBlock {\n }\n \n impl CopyAction : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &CopyAction) -> bool {\n         match (self, (*other)) {\n             (INIT, INIT) => true,\n@@ -807,5 +818,19 @@ impl CopyAction : cmp::Eq {\n             (DROP_EXISTING, _) => false,\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &CopyAction) -> bool {\n+        match ((*self), (*other)) {\n+            (INIT, INIT) => true,\n+            (DROP_EXISTING, DROP_EXISTING) => true,\n+            (INIT, _) => false,\n+            (DROP_EXISTING, _) => false,\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &CopyAction) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &CopyAction) -> bool { !(*self).eq(other) }\n }"}, {"sha": "c6b5b9fbfe0fa0d8212e2eb97070c502aa371620", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -148,6 +148,7 @@ impl Dest {\n }\n \n impl Dest : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Dest) -> bool {\n         match (self, (*other)) {\n             (SaveIn(e0a), SaveIn(e0b)) => e0a == e0b,\n@@ -156,7 +157,21 @@ impl Dest : cmp::Eq {\n             (Ignore, _) => false,\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Dest) -> bool {\n+        match ((*self), (*other)) {\n+            (SaveIn(e0a), SaveIn(e0b)) => e0a == e0b,\n+            (Ignore, Ignore) => true,\n+            (SaveIn(*), _) => false,\n+            (Ignore, _) => false,\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Dest) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Dest) -> bool { !(*self).eq(other) }\n }\n \n fn drop_and_cancel_clean(bcx: block, dat: Datum) -> block {\n@@ -1429,6 +1444,7 @@ enum cast_kind {\n }\n \n impl cast_kind : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &cast_kind) -> bool {\n         match (self, (*other)) {\n             (cast_pointer, cast_pointer) => true,\n@@ -1443,7 +1459,27 @@ impl cast_kind : cmp::Eq {\n             (cast_other, _) => false,\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &cast_kind) -> bool {\n+        match ((*self), (*other)) {\n+            (cast_pointer, cast_pointer) => true,\n+            (cast_integral, cast_integral) => true,\n+            (cast_float, cast_float) => true,\n+            (cast_enum, cast_enum) => true,\n+            (cast_other, cast_other) => true,\n+            (cast_pointer, _) => false,\n+            (cast_integral, _) => false,\n+            (cast_float, _) => false,\n+            (cast_enum, _) => false,\n+            (cast_other, _) => false,\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &cast_kind) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &cast_kind) -> bool { !(*self).eq(other) }\n }\n \n fn cast_type_kind(t: ty::t) -> cast_kind {"}, {"sha": "cac60a4abe2c30ee0c59d771526e5ef6ca2d11e8", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -41,10 +41,20 @@ enum x86_64_reg_class {\n }\n \n impl x86_64_reg_class : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &x86_64_reg_class) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &x86_64_reg_class) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &x86_64_reg_class) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &x86_64_reg_class) -> bool { !(*self).eq(other) }\n }\n \n fn is_sse(++c: x86_64_reg_class) -> bool {"}, {"sha": "fe8df3e2ada6711fdf5b64e269317e84e43aaa75", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 519, "deletions": 0, "changes": 519, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -243,14 +243,28 @@ type creader_cache_key = {cnum: int, pos: uint, len: uint};\n type creader_cache = HashMap<creader_cache_key, t>;\n \n impl creader_cache_key : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &creader_cache_key) -> bool {\n         self.cnum == (*other).cnum &&\n             self.pos == (*other).pos &&\n             self.len == (*other).len\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &creader_cache_key) -> bool {\n+        (*self).cnum == (*other).cnum &&\n+            (*self).pos == (*other).pos &&\n+            (*self).len == (*other).len\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &creader_cache_key) -> bool {\n         !(self == (*other))\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &creader_cache_key) -> bool {\n+        !((*self) == (*other))\n+    }\n }\n \n impl creader_cache_key : to_bytes::IterBytes {\n@@ -262,10 +276,20 @@ impl creader_cache_key : to_bytes::IterBytes {\n type intern_key = {sty: sty, o_def_id: Option<ast::def_id>};\n \n impl intern_key : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &intern_key) -> bool {\n         self.sty == (*other).sty && self.o_def_id == (*other).o_def_id\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &intern_key) -> bool {\n+        (*self).sty == (*other).sty && (*self).o_def_id == (*other).o_def_id\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &intern_key) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &intern_key) -> bool { !(*self).eq(other) }\n }\n \n impl intern_key : to_bytes::IterBytes {\n@@ -286,6 +310,7 @@ type opt_region_variance = Option<region_variance>;\n enum region_variance { rv_covariant, rv_invariant, rv_contravariant }\n \n impl region_variance : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &region_variance) -> bool {\n         match (self, (*other)) {\n             (rv_covariant, rv_covariant) => true,\n@@ -296,7 +321,23 @@ impl region_variance : cmp::Eq {\n             (rv_contravariant, _) => false\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &region_variance) -> bool {\n+        match ((*self), (*other)) {\n+            (rv_covariant, rv_covariant) => true,\n+            (rv_invariant, rv_invariant) => true,\n+            (rv_contravariant, rv_contravariant) => true,\n+            (rv_covariant, _) => false,\n+            (rv_invariant, _) => false,\n+            (rv_contravariant, _) => false\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &region_variance) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &region_variance) -> bool { !(*self).eq(other) }\n }\n \n #[auto_serialize]\n@@ -504,10 +545,20 @@ type FnTy = FnTyBase<FnMeta>;\n type param_ty = {idx: uint, def_id: def_id};\n \n impl param_ty : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &param_ty) -> bool {\n         self.idx == (*other).idx && self.def_id == (*other).def_id\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &param_ty) -> bool {\n+        (*self).idx == (*other).idx && (*self).def_id == (*other).def_id\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &param_ty) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &param_ty) -> bool { !(*self).eq(other) }\n }\n \n impl param_ty : to_bytes::IterBytes {\n@@ -720,6 +771,7 @@ impl InferRegion : to_bytes::IterBytes {\n }\n \n impl InferRegion : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &InferRegion) -> bool {\n         match (self, *other) {\n             (ReVar(rva), ReVar(rvb)) => {\n@@ -731,9 +783,28 @@ impl InferRegion : cmp::Eq {\n             _ => false\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &InferRegion) -> bool {\n+        match ((*self), *other) {\n+            (ReVar(rva), ReVar(rvb)) => {\n+                rva == rvb\n+            }\n+            (ReSkolemized(rva, _), ReSkolemized(rvb, _)) => {\n+                rva == rvb\n+            }\n+            _ => false\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &InferRegion) -> bool {\n         !(self == (*other))\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &InferRegion) -> bool {\n+        !((*self) == (*other))\n+    }\n }\n \n impl param_bound : to_bytes::IterBytes {\n@@ -4172,27 +4243,58 @@ pure fn determine_inherited_purity(parent_purity: ast::purity,\n }\n \n impl mt : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &mt) -> bool {\n         self.ty == (*other).ty && self.mutbl == (*other).mutbl\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &mt) -> bool {\n+        (*self).ty == (*other).ty && (*self).mutbl == (*other).mutbl\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &mt) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &mt) -> bool { !(*self).eq(other) }\n }\n \n impl arg : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &arg) -> bool {\n         self.mode == (*other).mode && self.ty == (*other).ty\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &arg) -> bool {\n+        (*self).mode == (*other).mode && (*self).ty == (*other).ty\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &arg) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &arg) -> bool { !(*self).eq(other) }\n }\n \n impl field : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &field) -> bool {\n         self.ident == (*other).ident && self.mt == (*other).mt\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &field) -> bool {\n+        (*self).ident == (*other).ident && (*self).mt == (*other).mt\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &field) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &field) -> bool { !(*self).eq(other) }\n }\n \n impl vstore : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &vstore) -> bool {\n         match self {\n             vstore_fixed(e0a) => {\n@@ -4221,60 +4323,169 @@ impl vstore : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &vstore) -> bool {\n+        match (*self) {\n+            vstore_fixed(e0a) => {\n+                match (*other) {\n+                    vstore_fixed(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            vstore_uniq => {\n+                match (*other) {\n+                    vstore_uniq => true,\n+                    _ => false\n+                }\n+            }\n+            vstore_box => {\n+                match (*other) {\n+                    vstore_box => true,\n+                    _ => false\n+                }\n+            }\n+            vstore_slice(e0a) => {\n+                match (*other) {\n+                    vstore_slice(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &vstore) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &vstore) -> bool { !(*self).eq(other) }\n }\n \n impl FnMeta : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &FnMeta) -> bool {\n         self.purity == (*other).purity &&\n         self.proto == (*other).proto &&\n         self.bounds == (*other).bounds &&\n         self.ret_style == (*other).ret_style\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &FnMeta) -> bool {\n+        (*self).purity == (*other).purity &&\n+        (*self).proto == (*other).proto &&\n+        (*self).bounds == (*other).bounds &&\n+        (*self).ret_style == (*other).ret_style\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &FnMeta) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &FnMeta) -> bool { !(*self).eq(other) }\n }\n \n impl FnSig : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &FnSig) -> bool {\n         self.inputs == (*other).inputs &&\n         self.output == (*other).output\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &FnSig) -> bool {\n+        (*self).inputs == (*other).inputs &&\n+        (*self).output == (*other).output\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &FnSig) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &FnSig) -> bool { !(*self).eq(other) }\n }\n \n impl<M: cmp::Eq> FnTyBase<M> : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &FnTyBase<M>) -> bool {\n         self.meta == (*other).meta && self.sig == (*other).sig\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &FnTyBase<M>) -> bool {\n+        (*self).meta == (*other).meta && (*self).sig == (*other).sig\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &FnTyBase<M>) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &FnTyBase<M>) -> bool { !(*self).eq(other) }\n }\n \n impl TyVid : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &TyVid) -> bool { *self == *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &TyVid) -> bool { *(*self) == *(*other) }\n+    #[cfg(stage0)]\n     pure fn ne(other: &TyVid) -> bool { *self != *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &TyVid) -> bool { *(*self) != *(*other) }\n }\n \n impl IntVid : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &IntVid) -> bool { *self == *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &IntVid) -> bool { *(*self) == *(*other) }\n+    #[cfg(stage0)]\n     pure fn ne(other: &IntVid) -> bool { *self != *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &IntVid) -> bool { *(*self) != *(*other) }\n }\n \n impl FloatVid : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &FloatVid) -> bool { *self == *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &FloatVid) -> bool { *(*self) == *(*other) }\n+    #[cfg(stage0)]\n     pure fn ne(other: &FloatVid) -> bool { *self != *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &FloatVid) -> bool { *(*self) != *(*other) }\n }\n \n impl FnVid : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &FnVid) -> bool { *self == *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &FnVid) -> bool { *(*self) == *(*other) }\n+    #[cfg(stage0)]\n     pure fn ne(other: &FnVid) -> bool { *self != *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &FnVid) -> bool { *(*self) != *(*other) }\n }\n \n impl RegionVid : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &RegionVid) -> bool { *self == *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &RegionVid) -> bool { *(*self) == *(*other) }\n+    #[cfg(stage0)]\n     pure fn ne(other: &RegionVid) -> bool { *self != *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &RegionVid) -> bool { *(*self) != *(*other) }\n }\n \n impl Region : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Region) -> bool {\n         match self {\n             re_bound(e0a) => {\n@@ -4309,10 +4520,51 @@ impl Region : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Region) -> bool {\n+        match (*self) {\n+            re_bound(e0a) => {\n+                match (*other) {\n+                    re_bound(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            re_free(e0a, e1a) => {\n+                match (*other) {\n+                    re_free(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            re_scope(e0a) => {\n+                match (*other) {\n+                    re_scope(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            re_static => {\n+                match (*other) {\n+                    re_static => true,\n+                    _ => false\n+                }\n+            }\n+            re_infer(e0a) => {\n+                match (*other) {\n+                    re_infer(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Region) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Region) -> bool { !(*self).eq(other) }\n }\n \n impl bound_region : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &bound_region) -> bool {\n         match self {\n             br_self => {\n@@ -4341,26 +4593,83 @@ impl bound_region : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &bound_region) -> bool {\n+        match (*self) {\n+            br_self => {\n+                match (*other) {\n+                    br_self => true,\n+                    _ => false\n+                }\n+            }\n+            br_anon(e0a) => {\n+                match (*other) {\n+                    br_anon(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            br_named(e0a) => {\n+                match (*other) {\n+                    br_named(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            br_cap_avoid(e0a, e1a) => {\n+                match (*other) {\n+                    br_cap_avoid(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &bound_region) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &bound_region) -> bool { !(*self).eq(other) }\n }\n \n impl substs : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &substs) -> bool {\n         self.self_r == (*other).self_r &&\n         self.self_ty == (*other).self_ty &&\n         self.tps == (*other).tps\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &substs) -> bool {\n+        (*self).self_r == (*other).self_r &&\n+        (*self).self_ty == (*other).self_ty &&\n+        (*self).tps == (*other).tps\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &substs) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &substs) -> bool { !(*self).eq(other) }\n }\n \n impl InferTy : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &InferTy) -> bool {\n         self.to_hash() == (*other).to_hash()\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &InferTy) -> bool {\n+        (*self).to_hash() == (*other).to_hash()\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &InferTy) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &InferTy) -> bool { !(*self).eq(other) }\n }\n \n impl sty : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &sty) -> bool {\n         match self {\n             ty_nil => {\n@@ -4516,10 +4825,172 @@ impl sty : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &sty) -> bool {\n+        match (*self) {\n+            ty_nil => {\n+                match (*other) {\n+                    ty_nil => true,\n+                    _ => false\n+                }\n+            }\n+            ty_bot => {\n+                match (*other) {\n+                    ty_bot => true,\n+                    _ => false\n+                }\n+            }\n+            ty_bool => {\n+                match (*other) {\n+                    ty_bool => true,\n+                    _ => false\n+                }\n+            }\n+            ty_int(e0a) => {\n+                match (*other) {\n+                    ty_int(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_uint(e0a) => {\n+                match (*other) {\n+                    ty_uint(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_float(e0a) => {\n+                match (*other) {\n+                    ty_float(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_estr(e0a) => {\n+                match (*other) {\n+                    ty_estr(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_enum(e0a, e1a) => {\n+                match (*other) {\n+                    ty_enum(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            ty_box(e0a) => {\n+                match (*other) {\n+                    ty_box(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_uniq(e0a) => {\n+                match (*other) {\n+                    ty_uniq(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_evec(e0a, e1a) => {\n+                match (*other) {\n+                    ty_evec(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            ty_ptr(e0a) => {\n+                match (*other) {\n+                    ty_ptr(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_rptr(e0a, e1a) => {\n+                match (*other) {\n+                    ty_rptr(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            ty_rec(e0a) => {\n+                match (*other) {\n+                    ty_rec(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_fn(e0a) => {\n+                match (*other) {\n+                    ty_fn(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_trait(e0a, e1a, e2a) => {\n+                match (*other) {\n+                    ty_trait(e0b, e1b, e2b) =>\n+                        e0a == e0b && e1a == e1b && e2a == e2b,\n+                    _ => false\n+                }\n+            }\n+            ty_class(e0a, e1a) => {\n+                match (*other) {\n+                    ty_class(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            ty_tup(e0a) => {\n+                match (*other) {\n+                    ty_tup(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_infer(e0a) => {\n+                match (*other) {\n+                    ty_infer(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_param(e0a) => {\n+                match (*other) {\n+                    ty_param(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_self => {\n+                match (*other) {\n+                    ty_self => true,\n+                    _ => false\n+                }\n+            }\n+            ty_type => {\n+                match (*other) {\n+                    ty_type => true,\n+                    _ => false\n+                }\n+            }\n+            ty_opaque_box => {\n+                match (*other) {\n+                    ty_opaque_box => true,\n+                    _ => false\n+                }\n+            }\n+            ty_opaque_closure_ptr(e0a) => {\n+                match (*other) {\n+                    ty_opaque_closure_ptr(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_unboxed_vec(e0a) => {\n+                match (*other) {\n+                    ty_unboxed_vec(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &sty) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &sty) -> bool { !(*self).eq(other) }\n }\n \n impl param_bound : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &param_bound) -> bool {\n         match self {\n             bound_copy => {\n@@ -4554,12 +5025,60 @@ impl param_bound : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &param_bound) -> bool {\n+        match (*self) {\n+            bound_copy => {\n+                match (*other) {\n+                    bound_copy => true,\n+                    _ => false\n+                }\n+            }\n+            bound_owned => {\n+                match (*other) {\n+                    bound_owned => true,\n+                    _ => false\n+                }\n+            }\n+            bound_send => {\n+                match (*other) {\n+                    bound_send => true,\n+                    _ => false\n+                }\n+            }\n+            bound_const => {\n+                match (*other) {\n+                    bound_const => true,\n+                    _ => false\n+                }\n+            }\n+            bound_trait(e0a) => {\n+                match (*other) {\n+                    bound_trait(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &param_bound) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &param_bound) -> bool { !(*self).eq(other) }\n }\n \n impl Kind : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Kind) -> bool { *self == *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Kind) -> bool { *(*self) == *(*other) }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Kind) -> bool { *self != *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Kind) -> bool { *(*self) != *(*other) }\n }\n \n "}, {"sha": "a733d8e6de958ce628a5545ac3bc70b6357e3fd8", "filename": "src/librustc/middle/typeck/check.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -956,7 +956,7 @@ fn lookup_field_ty(tcx: ty::ctxt,\n \n // Controls whether the arguments are automatically referenced. This is useful\n // for overloaded binary and unary operators.\n-enum DerefArgs {\n+pub enum DerefArgs {\n     DontDerefArgs,\n     DoDerefArgs\n }\n@@ -1182,7 +1182,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         -> Option<(ty::t, bool)>\n     {\n         match method::lookup(fcx, op_ex, self_ex,\n-                             op_ex.callee_id, opname, self_t, ~[]) {\n+                             op_ex.callee_id, opname, self_t, ~[],\n+                             deref_args) {\n           Some(origin) => {\n             let {fty: method_ty, bot: bot} = {\n                 let method_ty = fcx.node_ty(op_ex.callee_id);\n@@ -1439,7 +1440,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let tps = vec::map(tys, |ty| fcx.to_ty(*ty));\n \n         match method::lookup(fcx, expr, base, expr.id,\n-                             field, expr_t, tps) {\n+                             field, expr_t, tps, DontDerefArgs) {\n             Some(entry) => {\n                 fcx.ccx.method_map.insert(expr.id, entry);\n "}, {"sha": "fdcbf8a53e390fa99a952b74cbfb621ee1ef7a6f", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -89,7 +89,8 @@ fn lookup(\n     callee_id: node_id, // Where to store the type of `a.b`\n     m_name: ast::ident,      // The ident `b`.\n     self_ty: ty::t,          // The type of `a`.\n-    supplied_tps: &[ty::t])  // The list of types X, Y, ... .\n+    supplied_tps: &[ty::t],  // The list of types X, Y, ... .\n+    deref_args: check::DerefArgs)   // Whether we autopointer first.\n     -> Option<method_map_entry>\n {\n     let lcx = LookupContext {\n@@ -101,7 +102,8 @@ fn lookup(\n         supplied_tps: supplied_tps,\n         impl_dups: HashMap(),\n         inherent_candidates: DVec(),\n-        extension_candidates: DVec()\n+        extension_candidates: DVec(),\n+        deref_args: deref_args,\n     };\n     let mme = lcx.do_lookup(self_ty);\n     debug!(\"method lookup for %s yielded %?\",\n@@ -118,7 +120,8 @@ struct LookupContext {\n     supplied_tps: &[ty::t],\n     impl_dups: HashMap<def_id, ()>,\n     inherent_candidates: DVec<Candidate>,\n-    extension_candidates: DVec<Candidate>\n+    extension_candidates: DVec<Candidate>,\n+    deref_args: check::DerefArgs,\n }\n \n /**\n@@ -155,14 +158,33 @@ impl LookupContext {\n             debug!(\"loop: self_ty=%s autoderefs=%u\",\n                    self.ty_to_str(self_ty), autoderefs);\n \n-            match self.search_for_autoderefd_method(self_ty, autoderefs) {\n-                Some(move mme) => { return Some(mme); }\n-                None => {}\n-            }\n+            match self.deref_args {\n+                check::DontDerefArgs => {\n+                    match self.search_for_autoderefd_method(self_ty,\n+                                                            autoderefs) {\n+                        Some(move mme) => { return Some(mme); }\n+                        None => {}\n+                    }\n \n-            match self.search_for_autoptrd_method(self_ty, autoderefs) {\n-                Some(move mme) => { return Some(move mme); }\n-                None => {}\n+                    match self.search_for_autoptrd_method(self_ty,\n+                                                          autoderefs) {\n+                        Some(move mme) => { return Some(move mme); }\n+                        None => {}\n+                    }\n+                }\n+                check::DoDerefArgs => {\n+                    match self.search_for_autoptrd_method(self_ty,\n+                                                          autoderefs) {\n+                        Some(move mme) => { return Some(move mme); }\n+                        None => {}\n+                    }\n+\n+                    match self.search_for_autoderefd_method(self_ty,\n+                                                            autoderefs) {\n+                        Some(move mme) => { return Some(mme); }\n+                        None => {}\n+                    }\n+                }\n             }\n \n             match self.deref(self_ty, &enum_dids) {"}, {"sha": "f0f9c97720e2c2c5975e69cf71972c4e92ce3bbf", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -351,6 +351,7 @@ enum Constraint {\n }\n \n impl Constraint : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Constraint) -> bool {\n         match (self, (*other)) {\n             (ConstrainVarSubVar(v0a, v1a), ConstrainVarSubVar(v0b, v1b)) => {\n@@ -367,7 +368,29 @@ impl Constraint : cmp::Eq {\n             (ConstrainVarSubReg(*), _) => false\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Constraint) -> bool {\n+        match ((*self), (*other)) {\n+            (ConstrainVarSubVar(v0a, v1a), ConstrainVarSubVar(v0b, v1b)) => {\n+                v0a == v0b && v1a == v1b\n+            }\n+            (ConstrainRegSubVar(ra, va), ConstrainRegSubVar(rb, vb)) => {\n+                ra == rb && va == vb\n+            }\n+            (ConstrainVarSubReg(va, ra), ConstrainVarSubReg(vb, rb)) => {\n+                va == vb && ra == rb\n+            }\n+            (ConstrainVarSubVar(*), _) => false,\n+            (ConstrainRegSubVar(*), _) => false,\n+            (ConstrainVarSubReg(*), _) => false\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Constraint) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Constraint) -> bool { !(*self).eq(other) }\n }\n \n impl Constraint : to_bytes::IterBytes {\n@@ -391,10 +414,20 @@ struct TwoRegions {\n }\n \n impl TwoRegions : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &TwoRegions) -> bool {\n         self.a == (*other).a && self.b == (*other).b\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &TwoRegions) -> bool {\n+        (*self).a == (*other).a && (*self).b == (*other).b\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &TwoRegions) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &TwoRegions) -> bool { !(*self).eq(other) }\n }\n \n impl TwoRegions : to_bytes::IterBytes {\n@@ -891,19 +924,39 @@ priv impl RegionVarBindings {\n enum Direction { Incoming = 0, Outgoing = 1 }\n \n impl Direction : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Direction) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Direction) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Direction) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Direction) -> bool { !(*self).eq(other) }\n }\n \n enum Classification { Expanding, Contracting }\n \n impl Classification : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Classification) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Classification) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Classification) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Classification) -> bool { !(*self).eq(other) }\n }\n \n enum GraphNodeValue { NoValue, Value(Region), ErrorValue }"}, {"sha": "c03464e33583a7ef394e6cd263d5e2cb6ddbcb84", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -167,10 +167,20 @@ enum monitor_msg {\n }\n \n impl monitor_msg : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &monitor_msg) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &monitor_msg) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &monitor_msg) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &monitor_msg) -> bool { !(*self).eq(other) }\n }\n \n /*"}, {"sha": "b40ce26839840b7a37e5214b3649c524ec5e9df1", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -19,10 +19,20 @@ enum OutputFormat {\n }\n \n impl OutputFormat : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &OutputFormat) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &OutputFormat) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &OutputFormat) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &OutputFormat) -> bool { !(*self).eq(other) }\n }\n \n /// How to organize the output\n@@ -34,10 +44,20 @@ enum OutputStyle {\n }\n \n impl OutputStyle : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &OutputStyle) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &OutputStyle) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &OutputStyle) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &OutputStyle) -> bool { !(*self).eq(other) }\n }\n \n /// The configuration for a rustdoc session"}, {"sha": "9a44e63ebb32de0876bbb3a7e92cde29c5bb15ea", "filename": "src/librustdoc/doc.rs", "status": "modified", "additions": 289, "deletions": 0, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -7,19 +7,37 @@ type Doc_ = {\n };\n \n impl Doc_ : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Doc_) -> bool {\n         self.pages == (*other).pages\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Doc_) -> bool {\n+        (*self).pages == (*other).pages\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Doc_) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Doc_) -> bool { !(*self).eq(other) }\n }\n \n enum Doc {\n     Doc_(Doc_)\n }\n \n impl Doc : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Doc) -> bool { *self == *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Doc) -> bool { *(*self) == *(*other) }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Doc) -> bool { *self != *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Doc) -> bool { *(*self) != *(*other) }\n }\n \n enum Page {\n@@ -28,6 +46,7 @@ enum Page {\n }\n \n impl Page : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Page) -> bool {\n         match self {\n             CratePage(e0a) => {\n@@ -44,7 +63,29 @@ impl Page : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Page) -> bool {\n+        match (*self) {\n+            CratePage(e0a) => {\n+                match (*other) {\n+                    CratePage(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ItemPage(e0a) => {\n+                match (*other) {\n+                    ItemPage(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Page) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Page) -> bool { !(*self).eq(other) }\n }\n \n enum Implementation {\n@@ -53,10 +94,20 @@ enum Implementation {\n }\n \n impl Implementation : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Implementation) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Implementation) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Implementation) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Implementation) -> bool { !(*self).eq(other) }\n }\n \n \n@@ -70,10 +121,20 @@ type Section = {\n };\n \n impl Section : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Section) -> bool {\n         self.header == (*other).header && self.body == (*other).body\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Section) -> bool {\n+        (*self).header == (*other).header && (*self).body == (*other).body\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Section) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Section) -> bool { !(*self).eq(other) }\n }\n \n // FIXME (#2596): We currently give topmod the name of the crate.  There\n@@ -84,10 +145,20 @@ type CrateDoc = {\n };\n \n impl CrateDoc : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &CrateDoc) -> bool {\n         self.topmod == (*other).topmod\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &CrateDoc) -> bool {\n+        (*self).topmod == (*other).topmod\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &CrateDoc) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &CrateDoc) -> bool { !(*self).eq(other) }\n }\n \n enum ItemTag {\n@@ -103,6 +174,7 @@ enum ItemTag {\n }\n \n impl ItemTag : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &ItemTag) -> bool {\n         match self {\n             ModTag(e0a) => {\n@@ -161,7 +233,71 @@ impl ItemTag : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &ItemTag) -> bool {\n+        match (*self) {\n+            ModTag(e0a) => {\n+                match (*other) {\n+                    ModTag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            NmodTag(e0a) => {\n+                match (*other) {\n+                    NmodTag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ConstTag(e0a) => {\n+                match (*other) {\n+                    ConstTag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            FnTag(e0a) => {\n+                match (*other) {\n+                    FnTag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            EnumTag(e0a) => {\n+                match (*other) {\n+                    EnumTag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            TraitTag(e0a) => {\n+                match (*other) {\n+                    TraitTag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ImplTag(e0a) => {\n+                match (*other) {\n+                    ImplTag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            TyTag(e0a) => {\n+                match (*other) {\n+                    TyTag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            StructTag(e0a) => {\n+                match (*other) {\n+                    StructTag(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &ItemTag) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &ItemTag) -> bool { !(*self).eq(other) }\n }\n \n type ItemDoc = {\n@@ -176,6 +312,7 @@ type ItemDoc = {\n };\n \n impl ItemDoc : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &ItemDoc) -> bool {\n         self.id == (*other).id &&\n         self.name == (*other).name &&\n@@ -185,7 +322,22 @@ impl ItemDoc : cmp::Eq {\n         self.sections == (*other).sections &&\n         self.reexport == (*other).reexport\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &ItemDoc) -> bool {\n+        (*self).id == (*other).id &&\n+        (*self).name == (*other).name &&\n+        (*self).path == (*other).path &&\n+        (*self).brief == (*other).brief &&\n+        (*self).desc == (*other).desc &&\n+        (*self).sections == (*other).sections &&\n+        (*self).reexport == (*other).reexport\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &ItemDoc) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &ItemDoc) -> bool { !(*self).eq(other) }\n }\n \n type SimpleItemDoc = {\n@@ -194,10 +346,20 @@ type SimpleItemDoc = {\n };\n \n impl SimpleItemDoc : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &SimpleItemDoc) -> bool {\n         self.item == (*other).item && self.sig == (*other).sig\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &SimpleItemDoc) -> bool {\n+        (*self).item == (*other).item && (*self).sig == (*other).sig\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &SimpleItemDoc) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &SimpleItemDoc) -> bool { !(*self).eq(other) }\n }\n \n type ModDoc_ = {\n@@ -207,21 +369,41 @@ type ModDoc_ = {\n };\n \n impl ModDoc_ : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &ModDoc_) -> bool {\n         self.item == (*other).item &&\n         self.items == (*other).items &&\n         self.index == (*other).index\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &ModDoc_) -> bool {\n+        (*self).item == (*other).item &&\n+        (*self).items == (*other).items &&\n+        (*self).index == (*other).index\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &ModDoc_) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &ModDoc_) -> bool { !(*self).eq(other) }\n }\n \n enum ModDoc {\n     ModDoc_(ModDoc_)\n }\n \n impl ModDoc : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &ModDoc) -> bool { *self == *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &ModDoc) -> bool { *(*self) == *(*other) }\n+    #[cfg(stage0)]\n     pure fn ne(other: &ModDoc) -> bool { *self != *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &ModDoc) -> bool { *(*self) != *(*other) }\n }\n \n type NmodDoc = {\n@@ -231,12 +413,24 @@ type NmodDoc = {\n };\n \n impl NmodDoc : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &NmodDoc) -> bool {\n         self.item == (*other).item &&\n         self.fns == (*other).fns &&\n         self.index == (*other).index\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &NmodDoc) -> bool {\n+        (*self).item == (*other).item &&\n+        (*self).fns == (*other).fns &&\n+        (*self).index == (*other).index\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &NmodDoc) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &NmodDoc) -> bool { !(*self).eq(other) }\n }\n \n type ConstDoc = SimpleItemDoc;\n@@ -249,10 +443,20 @@ type EnumDoc = {\n };\n \n impl EnumDoc : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &EnumDoc) -> bool {\n         self.item == (*other).item && self.variants == (*other).variants\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &EnumDoc) -> bool {\n+        (*self).item == (*other).item && (*self).variants == (*other).variants\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &EnumDoc) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &EnumDoc) -> bool { !(*self).eq(other) }\n }\n \n type VariantDoc = {\n@@ -262,12 +466,24 @@ type VariantDoc = {\n };\n \n impl VariantDoc : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &VariantDoc) -> bool {\n         self.name == (*other).name &&\n         self.desc == (*other).desc &&\n         self.sig == (*other).sig\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &VariantDoc) -> bool {\n+        (*self).name == (*other).name &&\n+        (*self).desc == (*other).desc &&\n+        (*self).sig == (*other).sig\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &VariantDoc) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &VariantDoc) -> bool { !(*self).eq(other) }\n }\n \n type TraitDoc = {\n@@ -276,10 +492,20 @@ type TraitDoc = {\n };\n \n impl TraitDoc : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &TraitDoc) -> bool {\n         self.item == (*other).item && self.methods == (*other).methods\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &TraitDoc) -> bool {\n+        (*self).item == (*other).item && (*self).methods == (*other).methods\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &TraitDoc) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &TraitDoc) -> bool { !(*self).eq(other) }\n }\n \n type MethodDoc = {\n@@ -292,6 +518,7 @@ type MethodDoc = {\n };\n \n impl MethodDoc : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &MethodDoc) -> bool {\n         self.name == (*other).name &&\n         self.brief == (*other).brief &&\n@@ -300,7 +527,21 @@ impl MethodDoc : cmp::Eq {\n         self.sig == (*other).sig &&\n         self.implementation == (*other).implementation\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &MethodDoc) -> bool {\n+        (*self).name == (*other).name &&\n+        (*self).brief == (*other).brief &&\n+        (*self).desc == (*other).desc &&\n+        (*self).sections == (*other).sections &&\n+        (*self).sig == (*other).sig &&\n+        (*self).implementation == (*other).implementation\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &MethodDoc) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &MethodDoc) -> bool { !(*self).eq(other) }\n }\n \n type ImplDoc = {\n@@ -311,13 +552,26 @@ type ImplDoc = {\n };\n \n impl ImplDoc : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &ImplDoc) -> bool {\n         self.item == (*other).item &&\n         self.trait_types == (*other).trait_types &&\n         self.self_ty == (*other).self_ty &&\n         self.methods == (*other).methods\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &ImplDoc) -> bool {\n+        (*self).item == (*other).item &&\n+        (*self).trait_types == (*other).trait_types &&\n+        (*self).self_ty == (*other).self_ty &&\n+        (*self).methods == (*other).methods\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &ImplDoc) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &ImplDoc) -> bool { !(*self).eq(other) }\n }\n \n type TyDoc = SimpleItemDoc;\n@@ -329,23 +583,45 @@ type StructDoc = {\n };\n \n impl StructDoc : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &StructDoc) -> bool {\n         return self.item == other.item\n             && self.fields == other.fields\n             && self.sig == other.sig;\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &StructDoc) -> bool {\n+        return (*self).item == other.item\n+            && (*self).fields == other.fields\n+            && (*self).sig == other.sig;\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &StructDoc) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &StructDoc) -> bool { !(*self).eq(other) }\n }\n \n type Index = {\n     entries: ~[IndexEntry]\n };\n \n impl Index : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Index) -> bool {\n         self.entries == (*other).entries\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Index) -> bool {\n+        (*self).entries == (*other).entries\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Index) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Index) -> bool { !(*self).eq(other) }\n }\n \n /**\n@@ -366,13 +642,26 @@ type IndexEntry = {\n };\n \n impl IndexEntry : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &IndexEntry) -> bool {\n         self.kind == (*other).kind &&\n         self.name == (*other).name &&\n         self.brief == (*other).brief &&\n         self.link == (*other).link\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &IndexEntry) -> bool {\n+        (*self).kind == (*other).kind &&\n+        (*self).name == (*other).name &&\n+        (*self).brief == (*other).brief &&\n+        (*self).link == (*other).link\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &IndexEntry) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &IndexEntry) -> bool { !(*self).eq(other) }\n }\n \n impl Doc {"}, {"sha": "44ddb307019fdbde70855e6c295de08e58ec94d4", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 64, "deletions": 1, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -239,6 +239,7 @@ mod tests {\n     type RecCy = {x: int, y: int, t: Taggy};\n \n     impl Taggy : Eq {\n+        #[cfg(stage0)]\n         pure fn eq(other: &Taggy) -> bool {\n             match self {\n               One(a1) => match (*other) {\n@@ -255,11 +256,34 @@ mod tests {\n               }\n             }\n         }\n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        pure fn eq(&self, other: &Taggy) -> bool {\n+            match (*self) {\n+              One(a1) => match (*other) {\n+                One(b1) => return a1 == b1,\n+                _ => return false\n+              },\n+              Two(a1, a2) => match (*other) {\n+                Two(b1, b2) => return a1 == b1 && a2 == b2,\n+                _ => return false\n+              },\n+              Three(a1, a2, a3) => match (*other) {\n+                Three(b1, b2, b3) => return a1 == b1 && a2 == b2 && a3 == b3,\n+                _ => return false\n+              }\n+            }\n+        }\n+        #[cfg(stage0)]\n         pure fn ne(other: &Taggy) -> bool { !self.eq(other) }\n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        pure fn ne(&self, other: &Taggy) -> bool { !(*self).eq(other) }\n     }\n \n     impl Taggypar<int> : Eq {\n         //let eq4: EqFn<Taggypar<int>> = |x,y| taggypareq::<int>(x, y);\n+        #[cfg(stage0)]\n         pure fn eq(other: &Taggypar<int>) -> bool {\n                   match self {\n                     Onepar::<int>(a1) => match (*other) {\n@@ -278,15 +302,54 @@ mod tests {\n                     }\n                   }\n         }\n-        pure fn ne(other: &Taggypar<int>) -> bool { !self.eq(other) }\n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        pure fn eq(&self, other: &Taggypar<int>) -> bool {\n+                  match (*self) {\n+                    Onepar::<int>(a1) => match (*other) {\n+                      Onepar::<int>(b1) => return a1 == b1,\n+                      _ => return false\n+                    },\n+                    Twopar::<int>(a1, a2) => match (*other) {\n+                      Twopar::<int>(b1, b2) => return a1 == b1 && a2 == b2,\n+                      _ => return false\n+                    },\n+                    Threepar::<int>(a1, a2, a3) => match (*other) {\n+                      Threepar::<int>(b1, b2, b3) => {\n+                          return a1 == b1 && a2 == b2 && a3 == b3\n+                      }\n+                      _ => return false\n+                    }\n+                  }\n+        }\n+        #[cfg(stage0)]\n+        pure fn ne(other: &Taggypar<int>) -> bool {\n+            !self.eq(other)\n+        }\n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        pure fn ne(&self, other: &Taggypar<int>) -> bool {\n+            !(*self).eq(other)\n+        }\n     }\n \n     impl RecCy : Eq {\n+        #[cfg(stage0)]\n         pure fn eq(other: &RecCy) -> bool {\n           return self.x == (*other).x && self.y == (*other).y &&\n                  self.t == (*other).t;\n         }\n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        pure fn eq(&self, other: &RecCy) -> bool {\n+          return (*self).x == (*other).x && (*self).y == (*other).y &&\n+                 (*self).t == (*other).t;\n+        }\n+        #[cfg(stage0)]\n         pure fn ne(other: &RecCy) -> bool { !self.eq(other) }\n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        pure fn ne(&self, other: &RecCy) -> bool { !(*self).eq(other) }\n     }\n \n     #[test]"}, {"sha": "cd7823b9747f61af9d0c244695e157963508ea54", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -88,6 +88,7 @@ fn mkname(nm: &str) -> Name {\n }\n \n impl Name : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Name) -> bool {\n         match self {\n             Long(ref e0a) => {\n@@ -104,30 +105,84 @@ impl Name : Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Name) -> bool {\n+        match (*self) {\n+            Long(ref e0a) => {\n+                match (*other) {\n+                    Long(ref e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            Short(e0a) => {\n+                match (*other) {\n+                    Short(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Name) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Name) -> bool { !(*self).eq(other) }\n }\n \n impl Occur : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Occur) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Occur) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Occur) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Occur) -> bool { !(*self).eq(other) }\n }\n \n impl HasArg : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &HasArg) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &HasArg) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &HasArg) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &HasArg) -> bool { !(*self).eq(other) }\n }\n \n impl Opt : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Opt) -> bool {\n         self.name   == (*other).name   &&\n         self.hasarg == (*other).hasarg &&\n         self.occur  == (*other).occur\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Opt) -> bool {\n+        (*self).name   == (*other).name   &&\n+        (*self).hasarg == (*other).hasarg &&\n+        (*self).occur  == (*other).occur\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Opt) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Opt) -> bool { !(*self).eq(other) }\n }\n \n /// Create an option that is required and takes an argument\n@@ -172,6 +227,7 @@ enum Optval { Val(~str), Given, }\n pub type Matches = {opts: ~[Opt], vals: ~[~[Optval]], free: ~[~str]};\n \n impl Optval : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Optval) -> bool {\n         match self {\n             Val(ref s) => match *other { Val (ref os) => s == os,\n@@ -180,16 +236,42 @@ impl Optval : Eq {\n                                           Given => true }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Optval) -> bool {\n+        match (*self) {\n+            Val(ref s) => match *other { Val (ref os) => s == os,\n+                                          Given => false },\n+            Given       => match *other { Val(_) => false,\n+                                          Given => true }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Optval) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Optval) -> bool { !(*self).eq(other) }\n }\n \n impl Matches : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Matches) -> bool {\n         self.opts == (*other).opts &&\n         self.vals == (*other).vals &&\n         self.free == (*other).free\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Matches) -> bool {\n+        (*self).opts == (*other).opts &&\n+        (*self).vals == (*other).vals &&\n+        (*self).free == (*other).free\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Matches) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Matches) -> bool { !(*self).eq(other) }\n }\n \n fn is_arg(arg: &str) -> bool {\n@@ -221,6 +303,7 @@ pub enum Fail_ {\n \n impl Fail_ : Eq {\n     // this whole thing should be easy to infer...\n+    #[cfg(stage0)]\n     pure fn eq(other: &Fail_) -> bool {\n         match self {\n             ArgumentMissing(ref s) => {\n@@ -245,7 +328,37 @@ impl Fail_ : Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Fail_) -> bool {\n+        match (*self) {\n+            ArgumentMissing(ref s) => {\n+                match *other { ArgumentMissing(ref so)    => s == so,\n+                               _                          => false }\n+            }\n+            UnrecognizedOption(ref s) => {\n+                match *other { UnrecognizedOption(ref so) => s == so,\n+                               _                          => false }\n+            }\n+            OptionMissing(ref s) => {\n+                match *other { OptionMissing(ref so)      => s == so,\n+                               _                          => false }\n+            }\n+            OptionDuplicated(ref s) => {\n+                match *other { OptionDuplicated(ref so)   => s == so,\n+                               _                          => false }\n+            }\n+            UnexpectedArgument(ref s) => {\n+                match *other { UnexpectedArgument(ref so) => s == so,\n+                               _                          => false }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Fail_) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Fail_) -> bool { !(*self).eq(other) }\n }\n \n /// Convert a `fail_` enum into an error string\n@@ -514,10 +627,20 @@ enum FailType {\n }\n \n impl FailType : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &FailType) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &FailType) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &FailType) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &FailType) -> bool { !(*self).eq(other) }\n }\n \n /** A module which provides a way to specify descriptions and\n@@ -538,6 +661,7 @@ pub mod groups {\n     };\n \n     impl OptGroup : Eq {\n+        #[cfg(stage0)]\n         pure fn eq(other: &OptGroup) -> bool {\n             self.short_name == (*other).short_name &&\n             self.long_name  == (*other).long_name  &&\n@@ -546,7 +670,21 @@ pub mod groups {\n             self.hasarg     == (*other).hasarg     &&\n             self.occur      == (*other).occur\n         }\n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        pure fn eq(&self, other: &OptGroup) -> bool {\n+            (*self).short_name == (*other).short_name &&\n+            (*self).long_name  == (*other).long_name  &&\n+            (*self).hint       == (*other).hint       &&\n+            (*self).desc       == (*other).desc       &&\n+            (*self).hasarg     == (*other).hasarg     &&\n+            (*self).occur      == (*other).occur\n+        }\n+        #[cfg(stage0)]\n         pure fn ne(other: &OptGroup) -> bool { !self.eq(other) }\n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        pure fn ne(&self, other: &OptGroup) -> bool { !(*self).eq(other) }\n     }\n \n     /// Create a long option that is required and takes an argument"}, {"sha": "d65a8d816e1ca8e79a6a81b7837fe2735baa8828", "filename": "src/libstd/json.rs", "status": "modified", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -911,6 +911,7 @@ pub impl Deserializer: serialization::Deserializer {\n }\n \n impl Json : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Json) -> bool {\n         // XXX: This is ugly because matching on references is broken, and\n         // we can't match on dereferenced tuples without a copy.\n@@ -946,11 +947,53 @@ impl Json : Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Json) -> bool {\n+        // XXX: This is ugly because matching on references is broken, and\n+        // we can't match on dereferenced tuples without a copy.\n+        match (*self) {\n+            Number(f0) =>\n+                match *other { Number(f1) => f0 == f1, _ => false },\n+            String(ref s0) =>\n+                match *other { String(ref s1) => s0 == s1, _ => false },\n+            Boolean(b0) =>\n+                match *other { Boolean(b1) => b0 == b1, _ => false },\n+            Null =>\n+                match *other { Null => true, _ => false },\n+            List(v0) =>\n+                match *other { List(v1) => v0 == v1, _ => false },\n+            Object(ref d0) => {\n+                match *other {\n+                    Object(ref d1) => {\n+                        if d0.len() == d1.len() {\n+                            let mut equal = true;\n+                            for d0.each |k, v0| {\n+                                match d1.find_ref(k) {\n+                                    Some(v1) if v0 == v1 => { },\n+                                    _ => { equal = false; break }\n+                                }\n+                            };\n+                            equal\n+                        } else {\n+                            false\n+                        }\n+                    }\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Json) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Json) -> bool { !(*self).eq(other) }\n }\n \n /// Test if two json values are less than one another\n impl Json : Ord {\n+    #[cfg(stage0)]\n     pure fn lt(other: &Json) -> bool {\n         match self {\n             Number(f0) => {\n@@ -1021,18 +1064,114 @@ impl Json : Ord {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn lt(&self, other: &Json) -> bool {\n+        match (*self) {\n+            Number(f0) => {\n+                match *other {\n+                    Number(f1) => f0 < f1,\n+                    String(_) | Boolean(_) | List(_) | Object(_) |\n+                    Null => true\n+                }\n+            }\n+\n+            String(ref s0) => {\n+                match *other {\n+                    Number(_) => false,\n+                    String(ref s1) => s0 < s1,\n+                    Boolean(_) | List(_) | Object(_) | Null => true\n+                }\n+            }\n+\n+            Boolean(b0) => {\n+                match *other {\n+                    Number(_) | String(_) => false,\n+                    Boolean(b1) => b0 < b1,\n+                    List(_) | Object(_) | Null => true\n+                }\n+            }\n+\n+            List(l0) => {\n+                match *other {\n+                    Number(_) | String(_) | Boolean(_) => false,\n+                    List(l1) => l0 < l1,\n+                    Object(_) | Null => true\n+                }\n+            }\n+\n+            Object(ref d0) => {\n+                match *other {\n+                    Number(_) | String(_) | Boolean(_) | List(_) => false,\n+                    Object(ref d1) => {\n+                        unsafe {\n+                            let mut d0_flat = ~[];\n+                            let mut d1_flat = ~[];\n+\n+                            // XXX: this is horribly inefficient...\n+                            for d0.each |k, v| {\n+                                 d0_flat.push((@copy *k, @copy *v));\n+                            }\n+                            d0_flat.qsort();\n+\n+                            for d1.each |k, v| {\n+                                d1_flat.push((@copy *k, @copy *v));\n+                            }\n+                            d1_flat.qsort();\n+\n+                            d0_flat < d1_flat\n+                        }\n+                    }\n+                    Null => true\n+                }\n+            }\n+\n+            Null => {\n+                match *other {\n+                    Number(_) | String(_) | Boolean(_) | List(_) |\n+                    Object(_) =>\n+                        false,\n+                    Null => true\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn le(other: &Json) -> bool { !(*other).lt(&self) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn le(&self, other: &Json) -> bool { !(*other).lt(&(*self)) }\n+    #[cfg(stage0)]\n     pure fn ge(other: &Json) -> bool { !self.lt(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ge(&self, other: &Json) -> bool { !(*self).lt(other) }\n+    #[cfg(stage0)]\n     pure fn gt(other: &Json) -> bool { (*other).lt(&self)  }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn gt(&self, other: &Json) -> bool { (*other).lt(&(*self))  }\n }\n \n impl Error : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Error) -> bool {\n         self.line == other.line &&\n         self.col == other.col &&\n         self.msg == other.msg\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Error) -> bool {\n+        (*self).line == other.line &&\n+        (*self).col == other.col &&\n+        (*self).msg == other.msg\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Error) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Error) -> bool { !(*self).eq(other) }\n }\n \n trait ToJson { fn to_json() -> Json; }"}, {"sha": "d30bc853f718fb84aedf1ea93994ee24e8765b19", "filename": "src/libstd/list.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -148,6 +148,7 @@ pub fn each<T>(l: @List<T>, f: fn((&T)) -> bool) {\n }\n \n impl<T:Eq> List<T> : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &List<T>) -> bool {\n         match self {\n             Cons(ref e0a, e1a) => {\n@@ -164,7 +165,29 @@ impl<T:Eq> List<T> : Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &List<T>) -> bool {\n+        match (*self) {\n+            Cons(ref e0a, e1a) => {\n+                match (*other) {\n+                    Cons(ref e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            Nil => {\n+                match (*other) {\n+                    Nil => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &List<T>) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &List<T>) -> bool { !(*self).eq(other) }\n }\n \n #[cfg(test)]"}, {"sha": "ec9aa60de54f93e59115237953798aceda51211a", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -315,10 +315,20 @@ pure fn userinfo_to_str(userinfo: UserInfo) -> ~str {\n }\n \n impl UserInfo : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &UserInfo) -> bool {\n         self.user == (*other).user && self.pass == (*other).pass\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &UserInfo) -> bool {\n+        (*self).user == (*other).user && (*self).pass == (*other).pass\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &UserInfo) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &UserInfo) -> bool { !(*self).eq(other) }\n }\n \n pure fn query_from_str(rawquery: &str) -> Query {\n@@ -379,6 +389,7 @@ enum Input {\n }\n \n impl Input : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Input) -> bool {\n         match (self, (*other)) {\n             (Digit, Digit) => true,\n@@ -389,7 +400,23 @@ impl Input : Eq {\n             (Unreserved, _) => false\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Input) -> bool {\n+        match ((*self), (*other)) {\n+            (Digit, Digit) => true,\n+            (Hex, Hex) => true,\n+            (Unreserved, Unreserved) => true,\n+            (Digit, _) => false,\n+            (Hex, _) => false,\n+            (Unreserved, _) => false\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Input) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Input) -> bool { !(*self).eq(other) }\n }\n \n // returns userinfo, host, port, and unparsed part, or an error\n@@ -722,6 +749,7 @@ impl Url: to_str::ToStr {\n }\n \n impl Url : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Url) -> bool {\n         self.scheme == (*other).scheme\n             && self.user == (*other).user\n@@ -731,10 +759,27 @@ impl Url : Eq {\n             && self.query == (*other).query\n             && self.fragment == (*other).fragment\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Url) -> bool {\n+        (*self).scheme == (*other).scheme\n+            && (*self).user == (*other).user\n+            && (*self).host == (*other).host\n+            && (*self).port == (*other).port\n+            && (*self).path == (*other).path\n+            && (*self).query == (*other).query\n+            && (*self).fragment == (*other).fragment\n+    }\n \n+    #[cfg(stage0)]\n     pure fn ne(other: &Url) -> bool {\n         !self.eq(other)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Url) -> bool {\n+        !(*self).eq(other)\n+    }\n }\n \n impl Url: IterBytes {"}, {"sha": "1d4476c2a2ae0316e04e5f74a148fec221657b07", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 69, "deletions": 4, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -871,16 +871,38 @@ mod test_tim_sort {\n     }\n \n     impl CVal: Ord {\n+        #[cfg(stage0)]\n         pure fn lt(other: &CVal) -> bool {\n             unsafe {\n                 let rng = rand::Rng();\n                 if rng.gen_float() > 0.995 { fail ~\"It's happening!!!\"; }\n             }\n             self.val < other.val\n         }\n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        pure fn lt(&self, other: &CVal) -> bool {\n+            unsafe {\n+                let rng = rand::Rng();\n+                if rng.gen_float() > 0.995 { fail ~\"It's happening!!!\"; }\n+            }\n+            (*self).val < other.val\n+        }\n+        #[cfg(stage0)]\n         pure fn le(other: &CVal) -> bool { self.val <= other.val }\n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        pure fn le(&self, other: &CVal) -> bool { (*self).val <= other.val }\n+        #[cfg(stage0)]\n         pure fn gt(other: &CVal) -> bool { self.val > other.val }\n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        pure fn gt(&self, other: &CVal) -> bool { (*self).val > other.val }\n+        #[cfg(stage0)]\n         pure fn ge(other: &CVal) -> bool { self.val >= other.val }\n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        pure fn ge(&self, other: &CVal) -> bool { (*self).val >= other.val }\n     }\n \n     fn check_sort(v1: &[mut int], v2: &[mut int]) {\n@@ -934,13 +956,24 @@ mod test_tim_sort {\n     }\n \n     struct DVal { val: ~uint }\n+\n+    #[cfg(stage0)]\n     impl DVal: Ord {\n         pure fn lt(_x: &DVal) -> bool { true }\n         pure fn le(_x: &DVal) -> bool { true }\n         pure fn gt(_x: &DVal) -> bool { true }\n         pure fn ge(_x: &DVal) -> bool { true }\n     }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    impl DVal: Ord {\n+        pure fn lt(&self, _x: &DVal) -> bool { true }\n+        pure fn le(&self, _x: &DVal) -> bool { true }\n+        pure fn gt(&self, _x: &DVal) -> bool { true }\n+        pure fn ge(&self, _x: &DVal) -> bool { true }\n+    }\n+\n     #[test]\n     fn test_bad_Ord_impl() {\n         let rng = rand::Rng();\n@@ -1150,10 +1183,42 @@ mod big_tests {\n     }\n \n     impl LVal: Ord {\n-        pure fn lt(other: &a/LVal/&self) -> bool { self.val < other.val }\n-        pure fn le(other: &a/LVal/&self) -> bool { self.val <= other.val }\n-        pure fn gt(other: &a/LVal/&self) -> bool { self.val > other.val }\n-        pure fn ge(other: &a/LVal/&self) -> bool { self.val >= other.val }\n+        #[cfg(stage0)]\n+        pure fn lt(other: &a/LVal/&self) -> bool {\n+            self.val < other.val\n+        }\n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        pure fn lt(&self, other: &a/LVal/&self) -> bool {\n+            (*self).val < other.val\n+        }\n+        #[cfg(stage0)]\n+        pure fn le(other: &a/LVal/&self) -> bool {\n+            self.val <= other.val\n+        }\n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        pure fn le(&self, other: &a/LVal/&self) -> bool {\n+            (*self).val <= other.val\n+        }\n+        #[cfg(stage0)]\n+        pure fn gt(other: &a/LVal/&self) -> bool {\n+            self.val > other.val\n+        }\n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        pure fn gt(&self, other: &a/LVal/&self) -> bool {\n+            (*self).val > other.val\n+        }\n+        #[cfg(stage0)]\n+        pure fn ge(other: &a/LVal/&self) -> bool {\n+            self.val >= other.val\n+        }\n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        pure fn ge(&self, other: &a/LVal/&self) -> bool {\n+            (*self).val >= other.val\n+        }\n     }\n }\n "}, {"sha": "54f011d246c7ee47ebed3726a69f69653d25327d", "filename": "src/libstd/test.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -85,10 +85,20 @@ fn parse_opts(args: &[~str]) -> OptRes {\n pub enum TestResult { TrOk, TrFailed, TrIgnored, }\n \n impl TestResult : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &TestResult) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &TestResult) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &TestResult) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &TestResult) -> bool { !(*self).eq(other) }\n }\n \n type ConsoleTestState ="}, {"sha": "405d1d7abadeaf5a3cdc71a9b288b6e8212d1303", "filename": "src/libstd/time.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -24,10 +24,20 @@ extern mod rustrt {\n pub type Timespec = {sec: i64, nsec: i32};\n \n impl Timespec : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Timespec) -> bool {\n         self.sec == (*other).sec && self.nsec == (*other).nsec\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Timespec) -> bool {\n+        (*self).sec == (*other).sec && (*self).nsec == (*other).nsec\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Timespec) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Timespec) -> bool { !(*self).eq(other) }\n }\n \n /**\n@@ -81,6 +91,7 @@ type Tm_ = {\n };\n \n impl Tm_ : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Tm_) -> bool {\n         self.tm_sec == (*other).tm_sec &&\n         self.tm_min == (*other).tm_min &&\n@@ -95,16 +106,44 @@ impl Tm_ : Eq {\n         self.tm_zone == (*other).tm_zone &&\n         self.tm_nsec == (*other).tm_nsec\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Tm_) -> bool {\n+        (*self).tm_sec == (*other).tm_sec &&\n+        (*self).tm_min == (*other).tm_min &&\n+        (*self).tm_hour == (*other).tm_hour &&\n+        (*self).tm_mday == (*other).tm_mday &&\n+        (*self).tm_mon == (*other).tm_mon &&\n+        (*self).tm_year == (*other).tm_year &&\n+        (*self).tm_wday == (*other).tm_wday &&\n+        (*self).tm_yday == (*other).tm_yday &&\n+        (*self).tm_isdst == (*other).tm_isdst &&\n+        (*self).tm_gmtoff == (*other).tm_gmtoff &&\n+        (*self).tm_zone == (*other).tm_zone &&\n+        (*self).tm_nsec == (*other).tm_nsec\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Tm_) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Tm_) -> bool { !(*self).eq(other) }\n }\n \n pub enum Tm {\n     Tm_(Tm_)\n }\n \n impl Tm : Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Tm) -> bool { *self == *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Tm) -> bool { *(*self) == *(*other) }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Tm) -> bool { *self != *(*other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Tm) -> bool { *(*self) != *(*other) }\n }\n \n pub pure fn empty_tm() -> Tm {"}, {"sha": "da28e349a563d0ce1a403174a8270b9d1b49f3b3", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 643, "deletions": 1, "changes": 644, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -50,8 +50,16 @@ impl<D: Deserializer> ident: Deserializable<D> {\n }\n \n impl ident: cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &ident) -> bool { self.repr == other.repr }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &ident) -> bool { (*self).repr == other.repr }\n+    #[cfg(stage0)]\n     pure fn ne(other: &ident) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &ident) -> bool { !(*self).eq(other) }\n }\n \n impl ident: to_bytes::IterBytes {\n@@ -80,10 +88,20 @@ type node_id = int;\n type def_id = {crate: crate_num, node: node_id};\n \n impl def_id : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &def_id) -> bool {\n         self.crate == (*other).crate && self.node == (*other).node\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &def_id) -> bool {\n+        (*self).crate == (*other).crate && (*self).node == (*other).node\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &def_id) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &def_id) -> bool { !(*self).eq(other) }\n }\n \n const local_crate: crate_num = 0;\n@@ -131,6 +149,7 @@ enum def {\n }\n \n impl def : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &def) -> bool {\n         match self {\n             def_fn(e0a, e1a) => {\n@@ -251,7 +270,133 @@ impl def : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &def) -> bool {\n+        match (*self) {\n+            def_fn(e0a, e1a) => {\n+                match (*other) {\n+                    def_fn(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            def_static_method(e0a, e1a, e2a) => {\n+                match (*other) {\n+                    def_static_method(e0b, e1b, e2b) =>\n+                    e0a == e0b && e1a == e1b && e2a == e2b,\n+                    _ => false\n+                }\n+            }\n+            def_self(e0a) => {\n+                match (*other) {\n+                    def_self(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_mod(e0a) => {\n+                match (*other) {\n+                    def_mod(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_foreign_mod(e0a) => {\n+                match (*other) {\n+                    def_foreign_mod(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_const(e0a) => {\n+                match (*other) {\n+                    def_const(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_arg(e0a, e1a) => {\n+                match (*other) {\n+                    def_arg(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            def_local(e0a, e1a) => {\n+                match (*other) {\n+                    def_local(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            def_variant(e0a, e1a) => {\n+                match (*other) {\n+                    def_variant(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            def_ty(e0a) => {\n+                match (*other) {\n+                    def_ty(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_prim_ty(e0a) => {\n+                match (*other) {\n+                    def_prim_ty(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_ty_param(e0a, e1a) => {\n+                match (*other) {\n+                    def_ty_param(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            def_binding(e0a, e1a) => {\n+                match (*other) {\n+                    def_binding(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            def_use(e0a) => {\n+                match (*other) {\n+                    def_use(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_upvar(e0a, e1a, e2a, e3a) => {\n+                match (*other) {\n+                    def_upvar(e0b, e1b, e2b, e3b) =>\n+                        e0a == e0b && e1a == e1b && e2a == e2b && e3a == e3b,\n+                    _ => false\n+                }\n+            }\n+            def_class(e0a) => {\n+                match (*other) {\n+                    def_class(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_typaram_binder(e0a) => {\n+                match (*other) {\n+                    def_typaram_binder(e1a) => e0a == e1a,\n+                    _ => false\n+                }\n+            }\n+            def_region(e0a) => {\n+                match (*other) {\n+                    def_region(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            def_label(e0a) => {\n+                match (*other) {\n+                    def_label(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &def) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &def) -> bool { !(*self).eq(other) }\n }\n \n // The set of meta_items that define the compilation environment of the crate,\n@@ -334,6 +479,7 @@ impl binding_mode : to_bytes::IterBytes {\n }\n \n impl binding_mode : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &binding_mode) -> bool {\n         match self {\n             bind_by_value => {\n@@ -362,7 +508,41 @@ impl binding_mode : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &binding_mode) -> bool {\n+        match (*self) {\n+            bind_by_value => {\n+                match (*other) {\n+                    bind_by_value => true,\n+                    _ => false\n+                }\n+            }\n+            bind_by_move => {\n+                match (*other) {\n+                    bind_by_move => true,\n+                    _ => false\n+                }\n+            }\n+            bind_by_ref(e0a) => {\n+                match (*other) {\n+                    bind_by_ref(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            bind_by_implicit_ref => {\n+                match (*other) {\n+                    bind_by_implicit_ref => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &binding_mode) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &binding_mode) -> bool { !(*self).eq(other) }\n }\n \n #[auto_serialize]\n@@ -400,10 +580,20 @@ impl mutability : to_bytes::IterBytes {\n }\n \n impl mutability : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &mutability) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &mutability) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &mutability) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &mutability) -> bool { !(*self).eq(other) }\n }\n \n #[auto_serialize]\n@@ -416,10 +606,20 @@ pub enum Proto {\n }\n \n impl Proto : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Proto) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Proto) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Proto) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Proto) -> bool { !(*self).eq(other) }\n }\n \n impl Proto : to_bytes::IterBytes {\n@@ -479,10 +679,20 @@ enum binop {\n }\n \n impl binop : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &binop) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &binop) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &binop) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &binop) -> bool { !(*self).eq(other) }\n }\n \n #[auto_serialize]\n@@ -496,6 +706,7 @@ enum unop {\n }\n \n impl unop : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &unop) -> bool {\n         match self {\n             box(e0a) => {\n@@ -530,9 +741,51 @@ impl unop : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &unop) -> bool {\n+        match (*self) {\n+            box(e0a) => {\n+                match (*other) {\n+                    box(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            uniq(e0a) => {\n+                match (*other) {\n+                    uniq(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            deref => {\n+                match (*other) {\n+                    deref => true,\n+                    _ => false\n+                }\n+            }\n+            not => {\n+                match (*other) {\n+                    not => true,\n+                    _ => false\n+                }\n+            }\n+            neg => {\n+                match (*other) {\n+                    neg => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &unop) -> bool {\n         !self.eq(other)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &unop) -> bool {\n+        !(*self).eq(other)\n+    }\n }\n \n // Generally, after typeck you can get the inferred value\n@@ -557,6 +810,7 @@ impl<T: to_bytes::IterBytes> inferable<T> : to_bytes::IterBytes {\n }\n \n impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &inferable<T>) -> bool {\n         match self {\n             expl(e0a) => {\n@@ -573,7 +827,29 @@ impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &inferable<T>) -> bool {\n+        match (*self) {\n+            expl(e0a) => {\n+                match (*other) {\n+                    expl(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            infer(e0a) => {\n+                match (*other) {\n+                    infer(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &inferable<T>) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &inferable<T>) -> bool { !(*self).eq(other) }\n }\n \n // \"resolved\" mode: the real modes.\n@@ -589,10 +865,20 @@ impl rmode : to_bytes::IterBytes {\n \n \n impl rmode : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &rmode) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &rmode) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &rmode) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &rmode) -> bool { !(*self).eq(other) }\n }\n \n // inferable mode.\n@@ -642,6 +928,7 @@ type field = spanned<field_>;\n enum blk_check_mode { default_blk, unsafe_blk, }\n \n impl blk_check_mode : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &blk_check_mode) -> bool {\n         match (self, (*other)) {\n             (default_blk, default_blk) => true,\n@@ -650,7 +937,21 @@ impl blk_check_mode : cmp::Eq {\n             (unsafe_blk, _) => false,\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &blk_check_mode) -> bool {\n+        match ((*self), (*other)) {\n+            (default_blk, default_blk) => true,\n+            (unsafe_blk, unsafe_blk) => true,\n+            (default_blk, _) => false,\n+            (unsafe_blk, _) => false,\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &blk_check_mode) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &blk_check_mode) -> bool { !(*self).eq(other) }\n }\n \n #[auto_serialize]\n@@ -866,6 +1167,7 @@ enum lit_ {\n }\n \n impl ast::lit_: cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &ast::lit_) -> bool {\n         match (self, *other) {\n             (lit_str(a), lit_str(b)) => a == b,\n@@ -892,7 +1194,39 @@ impl ast::lit_: cmp::Eq {\n             (lit_bool(_), _) => false\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &ast::lit_) -> bool {\n+        match ((*self), *other) {\n+            (lit_str(a), lit_str(b)) => a == b,\n+            (lit_int(val_a, ty_a), lit_int(val_b, ty_b)) => {\n+                val_a == val_b && ty_a == ty_b\n+            }\n+            (lit_uint(val_a, ty_a), lit_uint(val_b, ty_b)) => {\n+                val_a == val_b && ty_a == ty_b\n+            }\n+            (lit_int_unsuffixed(a), lit_int_unsuffixed(b)) => a == b,\n+            (lit_float(val_a, ty_a), lit_float(val_b, ty_b)) => {\n+                val_a == val_b && ty_a == ty_b\n+            }\n+            (lit_float_unsuffixed(a), lit_float_unsuffixed(b)) => a == b,\n+            (lit_nil, lit_nil) => true,\n+            (lit_bool(a), lit_bool(b)) => a == b,\n+            (lit_str(_), _) => false,\n+            (lit_int(*), _) => false,\n+            (lit_uint(*), _) => false,\n+            (lit_int_unsuffixed(*), _) => false,\n+            (lit_float(*), _) => false,\n+            (lit_float_unsuffixed(*), _) => false,\n+            (lit_nil, _) => false,\n+            (lit_bool(_), _) => false\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &ast::lit_) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &ast::lit_) -> bool { !(*self).eq(other) }\n }\n \n // NB: If you change this, you'll probably want to change the corresponding\n@@ -934,6 +1268,7 @@ impl int_ty : to_bytes::IterBytes {\n }\n \n impl int_ty : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &int_ty) -> bool {\n         match (self, (*other)) {\n             (ty_i, ty_i) => true,\n@@ -950,7 +1285,29 @@ impl int_ty : cmp::Eq {\n             (ty_i64, _) => false,\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &int_ty) -> bool {\n+        match ((*self), (*other)) {\n+            (ty_i, ty_i) => true,\n+            (ty_char, ty_char) => true,\n+            (ty_i8, ty_i8) => true,\n+            (ty_i16, ty_i16) => true,\n+            (ty_i32, ty_i32) => true,\n+            (ty_i64, ty_i64) => true,\n+            (ty_i, _) => false,\n+            (ty_char, _) => false,\n+            (ty_i8, _) => false,\n+            (ty_i16, _) => false,\n+            (ty_i32, _) => false,\n+            (ty_i64, _) => false,\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &int_ty) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &int_ty) -> bool { !(*self).eq(other) }\n }\n \n #[auto_serialize]\n@@ -964,6 +1321,7 @@ impl uint_ty : to_bytes::IterBytes {\n }\n \n impl uint_ty : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &uint_ty) -> bool {\n         match (self, (*other)) {\n             (ty_u, ty_u) => true,\n@@ -978,7 +1336,27 @@ impl uint_ty : cmp::Eq {\n             (ty_u64, _) => false\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &uint_ty) -> bool {\n+        match ((*self), (*other)) {\n+            (ty_u, ty_u) => true,\n+            (ty_u8, ty_u8) => true,\n+            (ty_u16, ty_u16) => true,\n+            (ty_u32, ty_u32) => true,\n+            (ty_u64, ty_u64) => true,\n+            (ty_u, _) => false,\n+            (ty_u8, _) => false,\n+            (ty_u16, _) => false,\n+            (ty_u32, _) => false,\n+            (ty_u64, _) => false\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &uint_ty) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &uint_ty) -> bool { !(*self).eq(other) }\n }\n \n #[auto_serialize]\n@@ -991,13 +1369,26 @@ impl float_ty : to_bytes::IterBytes {\n     }\n }\n impl float_ty : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &float_ty) -> bool {\n         match (self, (*other)) {\n             (ty_f, ty_f) | (ty_f32, ty_f32) | (ty_f64, ty_f64) => true,\n             (ty_f, _) | (ty_f32, _) | (ty_f64, _) => false\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &float_ty) -> bool {\n+        match ((*self), (*other)) {\n+            (ty_f, ty_f) | (ty_f32, ty_f32) | (ty_f64, ty_f64) => true,\n+            (ty_f, _) | (ty_f32, _) | (ty_f64, _) => false\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &float_ty) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &float_ty) -> bool { !(*self).eq(other) }\n }\n \n #[auto_serialize]\n@@ -1016,6 +1407,7 @@ enum prim_ty {\n }\n \n impl prim_ty : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &prim_ty) -> bool {\n         match self {\n             ty_int(e0a) => {\n@@ -1050,7 +1442,47 @@ impl prim_ty : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &prim_ty) -> bool {\n+        match (*self) {\n+            ty_int(e0a) => {\n+                match (*other) {\n+                    ty_int(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_uint(e0a) => {\n+                match (*other) {\n+                    ty_uint(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_float(e0a) => {\n+                match (*other) {\n+                    ty_float(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            ty_str => {\n+                match (*other) {\n+                    ty_str => true,\n+                    _ => false\n+                }\n+            }\n+            ty_bool => {\n+                match (*other) {\n+                    ty_bool => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &prim_ty) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &prim_ty) -> bool { !(*self).eq(other) }\n }\n \n #[auto_serialize]\n@@ -1074,15 +1506,30 @@ enum Onceness {\n }\n \n impl Onceness : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Onceness) -> bool {\n         match (self, *other) {\n             (Once, Once) | (Many, Many) => true,\n             _ => false\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Onceness) -> bool {\n+        match ((*self), *other) {\n+            (Once, Once) | (Many, Many) => true,\n+            _ => false\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Onceness) -> bool {\n         !self.eq(other)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Onceness) -> bool {\n+        !(*self).eq(other)\n+    }\n }\n \n #[auto_serialize]\n@@ -1121,12 +1568,24 @@ enum ty_ {\n // Equality and byte-iter (hashing) can be quite approximate for AST types.\n // since we only care about this for normalizing them to \"real\" types.\n impl Ty : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Ty) -> bool {\n         ptr::addr_of(&self) == ptr::addr_of(&(*other))\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Ty) -> bool {\n+        ptr::addr_of(&(*self)) == ptr::addr_of(&(*other))\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Ty) -> bool {\n         ptr::addr_of(&self) != ptr::addr_of(&(*other))\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Ty) -> bool {\n+        ptr::addr_of(&(*self)) != ptr::addr_of(&(*other))\n+    }\n }\n \n impl Ty : to_bytes::IterBytes {\n@@ -1163,10 +1622,20 @@ impl purity : to_bytes::IterBytes {\n }\n \n impl purity : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &purity) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &purity) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &purity) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &purity) -> bool { !(*self).eq(other) }\n }\n \n #[auto_serialize]\n@@ -1184,6 +1653,7 @@ impl ret_style : to_bytes::IterBytes {\n }\n \n impl ret_style : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &ret_style) -> bool {\n         match (self, (*other)) {\n             (noreturn, noreturn) => true,\n@@ -1192,7 +1662,21 @@ impl ret_style : cmp::Eq {\n             (return_val, _) => false,\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &ret_style) -> bool {\n+        match ((*self), (*other)) {\n+            (noreturn, noreturn) => true,\n+            (return_val, return_val) => true,\n+            (noreturn, _) => false,\n+            (return_val, _) => false,\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &ret_style) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &ret_style) -> bool { !(*self).eq(other) }\n }\n \n #[auto_serialize]\n@@ -1207,6 +1691,7 @@ enum self_ty_ {\n }\n \n impl self_ty_ : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &self_ty_) -> bool {\n         match self {\n             sty_static => {\n@@ -1247,7 +1732,53 @@ impl self_ty_ : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &self_ty_) -> bool {\n+        match (*self) {\n+            sty_static => {\n+                match (*other) {\n+                    sty_static => true,\n+                    _ => false\n+                }\n+            }\n+            sty_by_ref => {\n+                match (*other) {\n+                    sty_by_ref => true,\n+                    _ => false\n+                }\n+            }\n+            sty_value => {\n+                match (*other) {\n+                    sty_value => true,\n+                    _ => false\n+                }\n+            }\n+            sty_region(e0a) => {\n+                match (*other) {\n+                    sty_region(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            sty_box(e0a) => {\n+                match (*other) {\n+                    sty_box(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            sty_uniq(e0a) => {\n+                match (*other) {\n+                    sty_uniq(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &self_ty_) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &self_ty_) -> bool { !(*self).eq(other) }\n }\n \n type self_ty = spanned<self_ty_>;\n@@ -1278,13 +1809,24 @@ enum foreign_abi {\n enum foreign_mod_sort { named, anonymous }\n \n impl foreign_mod_sort : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &foreign_mod_sort) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &foreign_mod_sort) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &foreign_mod_sort) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &foreign_mod_sort) -> bool { !(*self).eq(other) }\n }\n \n impl foreign_abi : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &foreign_abi) -> bool {\n         match (self, (*other)) {\n             (foreign_abi_rust_intrinsic, foreign_abi_rust_intrinsic) => true,\n@@ -1295,7 +1837,23 @@ impl foreign_abi : cmp::Eq {\n             (foreign_abi_stdcall, _) => false,\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &foreign_abi) -> bool {\n+        match ((*self), (*other)) {\n+            (foreign_abi_rust_intrinsic, foreign_abi_rust_intrinsic) => true,\n+            (foreign_abi_cdecl, foreign_abi_cdecl) => true,\n+            (foreign_abi_stdcall, foreign_abi_stdcall) => true,\n+            (foreign_abi_rust_intrinsic, _) => false,\n+            (foreign_abi_cdecl, _) => false,\n+            (foreign_abi_stdcall, _) => false,\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &foreign_abi) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &foreign_abi) -> bool { !(*self).eq(other) }\n }\n \n #[auto_serialize]\n@@ -1343,10 +1901,20 @@ type path_list_ident = spanned<path_list_ident_>;\n enum namespace { module_ns, type_value_ns }\n \n impl namespace : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &namespace) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &namespace) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &namespace) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &namespace) -> bool { !(*self).eq(other) }\n }\n \n type view_path = spanned<view_path_>;\n@@ -1393,10 +1961,20 @@ type attribute = spanned<attribute_>;\n enum attr_style { attr_outer, attr_inner, }\n \n impl attr_style : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &attr_style) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &attr_style) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &attr_style) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &attr_style) -> bool { !(*self).eq(other) }\n }\n \n // doc-comments are promoted to attributes that have is_sugared_doc = true\n@@ -1422,6 +2000,7 @@ type trait_ref = {path: @path, ref_id: node_id, impl_id: node_id};\n enum visibility { public, private, inherited }\n \n impl visibility : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &visibility) -> bool {\n         match (self, (*other)) {\n             (public, public) => true,\n@@ -1432,7 +2011,23 @@ impl visibility : cmp::Eq {\n             (inherited, _) => false,\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &visibility) -> bool {\n+        match ((*self), (*other)) {\n+            (public, public) => true,\n+            (private, private) => true,\n+            (inherited, inherited) => true,\n+            (public, _) => false,\n+            (private, _) => false,\n+            (inherited, _) => false,\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &visibility) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &visibility) -> bool { !(*self).eq(other) }\n }\n \n #[auto_serialize]\n@@ -1453,6 +2048,7 @@ enum struct_field_kind {\n }\n \n impl struct_field_kind : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &struct_field_kind) -> bool {\n         match self {\n             named_field(ident_a, class_mutability_a, visibility_a) => {\n@@ -1474,7 +2070,38 @@ impl struct_field_kind : cmp::Eq {\n             }\n         }\n     }\n-    pure fn ne(other: &struct_field_kind) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &struct_field_kind) -> bool {\n+        match (*self) {\n+            named_field(ident_a, class_mutability_a, visibility_a) => {\n+                match *other {\n+                    named_field(ident_b, class_mutability_b, visibility_b)\n+                            => {\n+                        ident_a == ident_b &&\n+                        class_mutability_a == class_mutability_b &&\n+                        visibility_a == visibility_b\n+                    }\n+                    unnamed_field => false\n+                }\n+            }\n+            unnamed_field => {\n+                match *other {\n+                    named_field(*) => false,\n+                    unnamed_field => true\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n+    pure fn ne(other: &struct_field_kind) -> bool {\n+        !self.eq(other)\n+    }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &struct_field_kind) -> bool {\n+        !(*self).eq(other)\n+    }\n }\n \n #[auto_serialize]\n@@ -1530,6 +2157,7 @@ impl class_mutability : to_bytes::IterBytes {\n }\n \n impl class_mutability : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &class_mutability) -> bool {\n         match (self, (*other)) {\n             (class_mutable, class_mutable) => true,\n@@ -1538,7 +2166,21 @@ impl class_mutability : cmp::Eq {\n             (class_immutable, _) => false,\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &class_mutability) -> bool {\n+        match ((*self), (*other)) {\n+            (class_mutable, class_mutable) => true,\n+            (class_immutable, class_immutable) => true,\n+            (class_mutable, _) => false,\n+            (class_immutable, _) => false,\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &class_mutability) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &class_mutability) -> bool { !(*self).eq(other) }\n }\n \n type class_ctor = spanned<class_ctor_>;"}, {"sha": "859f5f1d5026aab8b389116faa15fdada1faa686", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -12,6 +12,7 @@ enum path_elt {\n }\n \n impl path_elt : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &path_elt) -> bool {\n         match self {\n             path_mod(e0a) => {\n@@ -28,7 +29,29 @@ impl path_elt : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &path_elt) -> bool {\n+        match (*self) {\n+            path_mod(e0a) => {\n+                match (*other) {\n+                    path_mod(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            path_name(e0a) => {\n+                match (*other) {\n+                    path_name(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &path_elt) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &path_elt) -> bool { !(*self).eq(other) }\n }\n \n type path = ~[path_elt];"}, {"sha": "94d78d0c55fc30b8d4bb2743709247bea5834c40", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -338,10 +338,20 @@ enum inline_attr {\n }\n \n impl inline_attr : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &inline_attr) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &inline_attr) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &inline_attr) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &inline_attr) -> bool { !(*self).eq(other) }\n }\n \n /// True if something like #[inline] is found in the list of attrs."}, {"sha": "fafcd09e3dc5897dd27126336d7f02f6c4f14138", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 48, "deletions": 6, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -37,20 +37,36 @@ impl BytePos: Pos {\n     pure fn to_uint(&self) -> uint { **self }\n }\n \n+#[cfg(stage0)]\n impl BytePos: cmp::Eq {\n-    pure fn eq(other: &BytePos) -> bool {\n-        *self == **other\n-    }\n+    pure fn eq(other: &BytePos) -> bool { *self == **other }\n     pure fn ne(other: &BytePos) -> bool { !self.eq(other) }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl BytePos: cmp::Eq {\n+    pure fn eq(&self, other: &BytePos) -> bool { **self == **other }\n+    pure fn ne(&self, other: &BytePos) -> bool { !(*self).eq(other) }\n+}\n+\n+#[cfg(stage0)]\n impl BytePos: cmp::Ord {\n     pure fn lt(other: &BytePos) -> bool { *self < **other }\n     pure fn le(other: &BytePos) -> bool { *self <= **other }\n     pure fn ge(other: &BytePos) -> bool { *self >= **other }\n     pure fn gt(other: &BytePos) -> bool { *self > **other }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl BytePos: cmp::Ord {\n+    pure fn lt(&self, other: &BytePos) -> bool { **self < **other }\n+    pure fn le(&self, other: &BytePos) -> bool { **self <= **other }\n+    pure fn ge(&self, other: &BytePos) -> bool { **self >= **other }\n+    pure fn gt(&self, other: &BytePos) -> bool { **self > **other }\n+}\n+\n impl BytePos: Num {\n     pure fn add(other: &BytePos) -> BytePos {\n         BytePos(*self + **other)\n@@ -85,20 +101,36 @@ impl CharPos: Pos {\n     pure fn to_uint(&self) -> uint { **self }\n }\n \n+#[cfg(stage0)]\n impl CharPos: cmp::Eq {\n-    pure fn eq(other: &CharPos) -> bool {\n-        *self == **other\n-    }\n+    pure fn eq(other: &CharPos) -> bool { *self == **other }\n     pure fn ne(other: &CharPos) -> bool { !self.eq(other) }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl CharPos: cmp::Eq {\n+    pure fn eq(&self, other: &CharPos) -> bool { **self == **other }\n+    pure fn ne(&self, other: &CharPos) -> bool { !(*self).eq(other) }\n+}\n+\n+#[cfg(stage0)]\n impl CharPos: cmp::Ord {\n     pure fn lt(other: &CharPos) -> bool { *self < **other }\n     pure fn le(other: &CharPos) -> bool { *self <= **other }\n     pure fn ge(other: &CharPos) -> bool { *self >= **other }\n     pure fn gt(other: &CharPos) -> bool { *self > **other }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl CharPos: cmp::Ord {\n+    pure fn lt(&self, other: &CharPos) -> bool { **self < **other }\n+    pure fn le(&self, other: &CharPos) -> bool { **self <= **other }\n+    pure fn ge(&self, other: &CharPos) -> bool { **self >= **other }\n+    pure fn gt(&self, other: &CharPos) -> bool { **self > **other }\n+}\n+\n impl CharPos: Num {\n     pure fn add(other: &CharPos) -> CharPos {\n         CharPos(*self + **other)\n@@ -141,10 +173,20 @@ pub struct span {\n }\n \n impl span : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &span) -> bool {\n         return self.lo == (*other).lo && self.hi == (*other).hi;\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &span) -> bool {\n+        return (*self).lo == (*other).lo && (*self).hi == (*other).hi;\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &span) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &span) -> bool { !(*self).eq(other) }\n }\n \n impl<S: Serializer> span: Serializable<S> {"}, {"sha": "a362c766c772dc01261dbfc0f4e3f58d35bc5096", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -149,10 +149,20 @@ enum level {\n }\n \n impl level : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &level) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &level) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &level) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &level) -> bool { !(*self).eq(other) }\n }\n \n fn diagnosticstr(lvl: level) -> ~str {"}, {"sha": "23e184785361d96a5a4f470afce88bc59c67bbbe", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -6,6 +6,7 @@ use ast_builder::{path, append_types};\n enum direction { send, recv }\n \n impl direction : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &direction) -> bool {\n         match (self, (*other)) {\n             (send, send) => true,\n@@ -14,7 +15,21 @@ impl direction : cmp::Eq {\n             (recv, _) => false,\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &direction) -> bool {\n+        match ((*self), (*other)) {\n+            (send, send) => true,\n+            (recv, recv) => true,\n+            (send, _) => false,\n+            (recv, _) => false,\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &direction) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &direction) -> bool { !(*self).eq(other) }\n }\n \n impl direction: ToStr {"}, {"sha": "3cb6b08d976b8ddb5e55b65850796fcdf335925c", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -20,12 +20,24 @@ enum cmnt_style {\n }\n \n impl cmnt_style : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &cmnt_style) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &cmnt_style) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &cmnt_style) -> bool {\n         (self as uint) != ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &cmnt_style) -> bool {\n+        ((*self) as uint) != ((*other) as uint)\n+    }\n }\n \n type cmnt = {style: cmnt_style, lines: ~[~str], pos: BytePos};"}, {"sha": "40df4d5f7d4497b45dbc2f6977995d8cfa2cb6ca", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -29,12 +29,24 @@ pub enum ObsoleteSyntax {\n }\n \n impl ObsoleteSyntax : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &ObsoleteSyntax) -> bool {\n         self as uint == (*other) as uint\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &ObsoleteSyntax) -> bool {\n+        (*self) as uint == (*other) as uint\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &ObsoleteSyntax) -> bool {\n         !self.eq(other)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &ObsoleteSyntax) -> bool {\n+        !(*self).eq(other)\n+    }\n }\n \n impl ObsoleteSyntax: to_bytes::IterBytes {"}, {"sha": "0df61a7f044e92e4a86a7232f6d6d8065b1d7189", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -3743,10 +3743,20 @@ impl Parser {\n }\n \n impl restriction : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &restriction) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &restriction) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &restriction) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &restriction) -> bool { !(*self).eq(other) }\n }\n \n //"}, {"sha": "2e59d2fa45fcc43c786435cd824b78d19409a400", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -463,13 +463,24 @@ fn reserved_keyword_table() -> HashMap<~str, ()> {\n }\n \n impl binop : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &binop) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &binop) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &binop) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &binop) -> bool { !(*self).eq(other) }\n }\n \n impl Token : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &Token) -> bool {\n         match self {\n             EQ => {\n@@ -738,7 +749,281 @@ impl Token : cmp::Eq {\n             }\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &Token) -> bool {\n+        match (*self) {\n+            EQ => {\n+                match (*other) {\n+                    EQ => true,\n+                    _ => false\n+                }\n+            }\n+            LT => {\n+                match (*other) {\n+                    LT => true,\n+                    _ => false\n+                }\n+            }\n+            LE => {\n+                match (*other) {\n+                    LE => true,\n+                    _ => false\n+                }\n+            }\n+            EQEQ => {\n+                match (*other) {\n+                    EQEQ => true,\n+                    _ => false\n+                }\n+            }\n+            NE => {\n+                match (*other) {\n+                    NE => true,\n+                    _ => false\n+                }\n+            }\n+            GE => {\n+                match (*other) {\n+                    GE => true,\n+                    _ => false\n+                }\n+            }\n+            GT => {\n+                match (*other) {\n+                    GT => true,\n+                    _ => false\n+                }\n+            }\n+            ANDAND => {\n+                match (*other) {\n+                    ANDAND => true,\n+                    _ => false\n+                }\n+            }\n+            OROR => {\n+                match (*other) {\n+                    OROR => true,\n+                    _ => false\n+                }\n+            }\n+            NOT => {\n+                match (*other) {\n+                    NOT => true,\n+                    _ => false\n+                }\n+            }\n+            TILDE => {\n+                match (*other) {\n+                    TILDE => true,\n+                    _ => false\n+                }\n+            }\n+            BINOP(e0a) => {\n+                match (*other) {\n+                    BINOP(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            BINOPEQ(e0a) => {\n+                match (*other) {\n+                    BINOPEQ(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            AT => {\n+                match (*other) {\n+                    AT => true,\n+                    _ => false\n+                }\n+            }\n+            DOT => {\n+                match (*other) {\n+                    DOT => true,\n+                    _ => false\n+                }\n+            }\n+            DOTDOT => {\n+                match (*other) {\n+                    DOTDOT => true,\n+                    _ => false\n+                }\n+            }\n+            ELLIPSIS => {\n+                match (*other) {\n+                    ELLIPSIS => true,\n+                    _ => false\n+                }\n+            }\n+            COMMA => {\n+                match (*other) {\n+                    COMMA => true,\n+                    _ => false\n+                }\n+            }\n+            SEMI => {\n+                match (*other) {\n+                    SEMI => true,\n+                    _ => false\n+                }\n+            }\n+            COLON => {\n+                match (*other) {\n+                    COLON => true,\n+                    _ => false\n+                }\n+            }\n+            MOD_SEP => {\n+                match (*other) {\n+                    MOD_SEP => true,\n+                    _ => false\n+                }\n+            }\n+            RARROW => {\n+                match (*other) {\n+                    RARROW => true,\n+                    _ => false\n+                }\n+            }\n+            LARROW => {\n+                match (*other) {\n+                    LARROW => true,\n+                    _ => false\n+                }\n+            }\n+            DARROW => {\n+                match (*other) {\n+                    DARROW => true,\n+                    _ => false\n+                }\n+            }\n+            FAT_ARROW => {\n+                match (*other) {\n+                    FAT_ARROW => true,\n+                    _ => false\n+                }\n+            }\n+            LPAREN => {\n+                match (*other) {\n+                    LPAREN => true,\n+                    _ => false\n+                }\n+            }\n+            RPAREN => {\n+                match (*other) {\n+                    RPAREN => true,\n+                    _ => false\n+                }\n+            }\n+            LBRACKET => {\n+                match (*other) {\n+                    LBRACKET => true,\n+                    _ => false\n+                }\n+            }\n+            RBRACKET => {\n+                match (*other) {\n+                    RBRACKET => true,\n+                    _ => false\n+                }\n+            }\n+            LBRACE => {\n+                match (*other) {\n+                    LBRACE => true,\n+                    _ => false\n+                }\n+            }\n+            RBRACE => {\n+                match (*other) {\n+                    RBRACE => true,\n+                    _ => false\n+                }\n+            }\n+            POUND => {\n+                match (*other) {\n+                    POUND => true,\n+                    _ => false\n+                }\n+            }\n+            DOLLAR => {\n+                match (*other) {\n+                    DOLLAR => true,\n+                    _ => false\n+                }\n+            }\n+            LIT_INT(e0a, e1a) => {\n+                match (*other) {\n+                    LIT_INT(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            LIT_UINT(e0a, e1a) => {\n+                match (*other) {\n+                    LIT_UINT(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            LIT_INT_UNSUFFIXED(e0a) => {\n+                match (*other) {\n+                    LIT_INT_UNSUFFIXED(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            LIT_FLOAT(e0a, e1a) => {\n+                match (*other) {\n+                    LIT_FLOAT(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            LIT_FLOAT_UNSUFFIXED(e0a) => {\n+                match (*other) {\n+                    LIT_FLOAT_UNSUFFIXED(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            LIT_STR(e0a) => {\n+                match (*other) {\n+                    LIT_STR(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            IDENT(e0a, e1a) => {\n+                match (*other) {\n+                    IDENT(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            UNDERSCORE => {\n+                match (*other) {\n+                    UNDERSCORE => true,\n+                    _ => false\n+                }\n+            }\n+            INTERPOLATED(_) => {\n+                match (*other) {\n+                    INTERPOLATED(_) => true,\n+                    _ => false\n+                }\n+            }\n+            DOC_COMMENT(e0a) => {\n+                match (*other) {\n+                    DOC_COMMENT(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            EOF => {\n+                match (*other) {\n+                    EOF => true,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &Token) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &Token) -> bool { !(*self).eq(other) }\n }\n \n // Local Variables:"}, {"sha": "e4bd3e92cc4e872eb53b66ddab64a50685ee668b", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -56,6 +56,7 @@ use dvec::DVec;\n enum breaks { consistent, inconsistent, }\n \n impl breaks : cmp::Eq {\n+    #[cfg(stage0)]\n     pure fn eq(other: &breaks) -> bool {\n         match (self, (*other)) {\n             (consistent, consistent) => true,\n@@ -64,7 +65,21 @@ impl breaks : cmp::Eq {\n             (inconsistent, _) => false,\n         }\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn eq(&self, other: &breaks) -> bool {\n+        match ((*self), (*other)) {\n+            (consistent, consistent) => true,\n+            (inconsistent, inconsistent) => true,\n+            (consistent, _) => false,\n+            (inconsistent, _) => false,\n+        }\n+    }\n+    #[cfg(stage0)]\n     pure fn ne(other: &breaks) -> bool { !self.eq(other) }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pure fn ne(&self, other: &breaks) -> bool { !(*self).eq(other) }\n }\n \n type break_t = {offset: int, blank_space: int};"}, {"sha": "280358e995ec892f5fa13a9837e6967dc3dd1f18", "filename": "src/test/compile-fail/fn-compare-mismatch.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Fcompile-fail%2Ffn-compare-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Fcompile-fail%2Ffn-compare-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-compare-mismatch.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -2,6 +2,5 @@ fn main() {\n     fn f() { }\n     fn g() { }\n     let x = f == g;\n-    //~^ ERROR mismatched types\n-    //~^^ ERROR failed to find an implementation of trait\n+    //~^ ERROR binary operation == cannot be applied\n }"}, {"sha": "fd139b64816d48a3ec609b24da0ddcfe8ea6b6f9", "filename": "src/test/compile-fail/issue-3344.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -1,7 +1,7 @@\n enum thing = uint;\n impl thing : cmp::Ord { //~ ERROR missing method `gt`\n-    pure fn lt(other: &thing) -> bool { *self < **other }\n-    pure fn le(other: &thing) -> bool { *self < **other }\n-    pure fn ge(other: &thing) -> bool { *self < **other }\n+    pure fn lt(&self, other: &thing) -> bool { **self < **other }\n+    pure fn le(&self, other: &thing) -> bool { **self < **other }\n+    pure fn ge(&self, other: &thing) -> bool { **self < **other }\n }\n fn main() {}"}, {"sha": "4f70835cb6de6a892496feb8feffcbc7b75a715c", "filename": "src/test/run-pass/auto_serialize.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -43,8 +43,8 @@ enum Expr {\n }\n \n impl Expr : cmp::Eq {\n-    pure fn eq(other: &Expr) -> bool {\n-        match self {\n+    pure fn eq(&self, other: &Expr) -> bool {\n+        match *self {\n             Val(e0a) => {\n                 match *other {\n                     Val(e0b) => e0a == e0b,\n@@ -65,26 +65,26 @@ impl Expr : cmp::Eq {\n             }\n         }\n     }\n-    pure fn ne(other: &Expr) -> bool { !self.eq(other) }\n+    pure fn ne(&self, other: &Expr) -> bool { !(*self).eq(other) }\n }\n \n impl AnEnum : cmp::Eq {\n-    pure fn eq(other: &AnEnum) -> bool {\n-        self.v == other.v\n+    pure fn eq(&self, other: &AnEnum) -> bool {\n+        (*self).v == other.v\n     }\n-    pure fn ne(other: &AnEnum) -> bool { !self.eq(other) }\n+    pure fn ne(&self, other: &AnEnum) -> bool { !(*self).eq(other) }\n }\n \n impl Point : cmp::Eq {\n-    pure fn eq(other: &Point) -> bool {\n+    pure fn eq(&self, other: &Point) -> bool {\n         self.x == other.x && self.y == other.y\n     }\n-    pure fn ne(other: &Point) -> bool { !self.eq(other) }\n+    pure fn ne(&self, other: &Point) -> bool { !(*self).eq(other) }\n }\n \n impl<T:cmp::Eq> Quark<T> : cmp::Eq {\n-    pure fn eq(other: &Quark<T>) -> bool {\n-        match self {\n+    pure fn eq(&self, other: &Quark<T>) -> bool {\n+        match *self {\n             Top(ref q) => {\n                 match *other {\n                     Top(ref r) => q == r,\n@@ -99,25 +99,27 @@ impl<T:cmp::Eq> Quark<T> : cmp::Eq {\n             },\n         }\n     }\n-    pure fn ne(other: &Quark<T>) -> bool { !self.eq(other) }\n+    pure fn ne(&self, other: &Quark<T>) -> bool { !(*self).eq(other) }\n }\n \n impl CLike : cmp::Eq {\n-    pure fn eq(other: &CLike) -> bool {\n-        self as int == *other as int\n+    pure fn eq(&self, other: &CLike) -> bool {\n+        (*self) as int == *other as int\n     }\n-    pure fn ne(other: &CLike) -> bool { !self.eq(other) }\n+    pure fn ne(&self, other: &CLike) -> bool { !(*self).eq(other) }\n }\n \n #[auto_serialize]\n #[auto_deserialize]\n type Spanned<T> = {lo: uint, hi: uint, node: T};\n \n impl<T:cmp::Eq> Spanned<T> : cmp::Eq {\n-    pure fn eq(other: &Spanned<T>) -> bool {\n-        self.lo == other.lo && self.hi == other.hi && self.node == other.node\n+    pure fn eq(&self, other: &Spanned<T>) -> bool {\n+        (*self).lo == other.lo &&\n+        (*self).hi == other.hi &&\n+        (*self).node == other.node\n     }\n-    pure fn ne(other: &Spanned<T>) -> bool { !self.eq(other) }\n+    pure fn ne(&self, other: &Spanned<T>) -> bool { !(*self).eq(other) }\n }\n \n #[auto_serialize]"}, {"sha": "d0d2cb4ba95fc56e5d99cd1fce6e994c9ae1f9f0", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -91,10 +91,10 @@ fn p(x: int, y: int) -> p {\n }\n \n impl p : cmp::Eq {\n-    pure fn eq(other: &p) -> bool {\n-        self.x == (*other).x && self.y == (*other).y\n+    pure fn eq(&self, other: &p) -> bool {\n+        (*self).x == (*other).x && (*self).y == (*other).y\n     }\n-    pure fn ne(other: &p) -> bool { !self.eq(other) }\n+    pure fn ne(&self, other: &p) -> bool { !(*self).eq(other) }\n }\n \n fn test_class() {"}, {"sha": "c11e41eb57f469086cc23a8ca5b31741f5e8bc07", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -7,10 +7,10 @@ use std::map::*;\n enum cat_type { tuxedo, tabby, tortoiseshell }\n \n impl cat_type : cmp::Eq {\n-    pure fn eq(other: &cat_type) -> bool {\n-        (self as uint) == ((*other) as uint)\n+    pure fn eq(&self, other: &cat_type) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n     }\n-    pure fn ne(other: &cat_type) -> bool { !self.eq(other) }\n+    pure fn ne(&self, other: &cat_type) -> bool { !(*self).eq(other) }\n }\n \n // Very silly -- this just returns the value of the name field"}, {"sha": "ac27c614436c031d2755c6a3df125c894d2c8d1c", "filename": "src/test/run-pass/coherence-impl-in-fn.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fcoherence-impl-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fcoherence-impl-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoherence-impl-in-fn.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -1,7 +1,9 @@\n fn main() {\n     enum x { foo }\n     impl x : core::cmp::Eq {\n-        pure fn eq(other: &x) -> bool { self as int == (*other) as int }\n-        pure fn ne(other: &x) -> bool { !self.eq(other) }\n+        pure fn eq(&self, other: &x) -> bool {\n+            (*self) as int == (*other) as int\n+        }\n+        pure fn ne(&self, other: &x) -> bool { !(*self).eq(other) }\n     }\n }"}, {"sha": "3e292a4528d39453716e0e0f8b9642e40b50b0b7", "filename": "src/test/run-pass/const-struct.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fconst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fconst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-struct.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -2,10 +2,12 @@\n struct foo { a: int, b: int, c: int }\n \n impl foo : cmp::Eq {\n-    pure fn eq(other: &foo) -> bool {\n-        self.a == (*other).a && self.b == (*other).b && self.c == (*other).c\n+    pure fn eq(&self, other: &foo) -> bool {\n+        (*self).a == (*other).a &&\n+        (*self).b == (*other).b &&\n+        (*self).c == (*other).c\n     }\n-    pure fn ne(other: &foo) -> bool { !self.eq(other) }\n+    pure fn ne(&self, other: &foo) -> bool { !(*self).eq(other) }\n }\n \n const x : foo = foo { a:1, b:2, c: 3 };"}, {"sha": "be9cd25d9d416da716f06d4c47a1c7caeb71dee5", "filename": "src/test/run-pass/empty-tag.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fempty-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fempty-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-tag.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -1,10 +1,10 @@\n enum chan { chan_t, }\n \n impl chan : cmp::Eq {\n-    pure fn eq(other: &chan) -> bool {\n-        (self as uint) == ((*other) as uint)\n+    pure fn eq(&self, other: &chan) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n     }\n-    pure fn ne(other: &chan) -> bool { !self.eq(other) }\n+    pure fn ne(&self, other: &chan) -> bool { !(*self).eq(other) }\n }\n \n fn wrapper3(i: chan) {"}, {"sha": "11351c8ae9705078a185cc634f15e9bb12a27372", "filename": "src/test/run-pass/export-unexported-dep.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-unexported-dep.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -10,10 +10,10 @@ mod foo {\n     enum t { t1, t2, }\n \n     impl t : cmp::Eq {\n-        pure fn eq(other: &t) -> bool {\n-            (self as uint) == ((*other) as uint)\n+        pure fn eq(&self, other: &t) -> bool {\n+            ((*self) as uint) == ((*other) as uint)\n         }\n-        pure fn ne(other: &t) -> bool { !self.eq(other) }\n+        pure fn ne(&self, other: &t) -> bool { !(*self).eq(other) }\n     }\n \n     fn f() -> t { return t1; }"}, {"sha": "52c4c56d9b92ce2521ffc335d4eb81b8777f5dd0", "filename": "src/test/run-pass/expr-alt-struct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -12,10 +12,10 @@ fn test_rec() {\n enum mood { happy, sad, }\n \n impl mood : cmp::Eq {\n-    pure fn eq(other: &mood) -> bool {\n-        (self as uint) == ((*other) as uint)\n+    pure fn eq(&self, other: &mood) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n     }\n-    pure fn ne(other: &mood) -> bool { !self.eq(other) }\n+    pure fn ne(&self, other: &mood) -> bool { !(*self).eq(other) }\n }\n \n fn test_tag() {"}, {"sha": "52bf8cd3123a7f097c478c1ebe9e44be7b664e04", "filename": "src/test/run-pass/expr-if-struct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -12,10 +12,10 @@ fn test_rec() {\n enum mood { happy, sad, }\n \n impl mood : cmp::Eq {\n-    pure fn eq(other: &mood) -> bool {\n-        (self as uint) == ((*other) as uint)\n+    pure fn eq(&self, other: &mood) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n     }\n-    pure fn ne(other: &mood) -> bool { !self.eq(other) }\n+    pure fn ne(&self, other: &mood) -> bool { !(*self).eq(other) }\n }\n \n fn test_tag() {"}, {"sha": "3148c68fe113fcb2c50959439d509e8e380c89c7", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -11,10 +11,10 @@ mod pipes {\n     }\n \n     impl state : cmp::Eq {\n-        pure fn eq(other: &state) -> bool {\n-            (self as uint) == ((*other) as uint)\n+        pure fn eq(&self, other: &state) -> bool {\n+            ((*self) as uint) == ((*other) as uint)\n         }\n-        pure fn ne(other: &state) -> bool { !self.eq(other) }\n+        pure fn ne(&self, other: &state) -> bool { !(*self).eq(other) }\n     }\n \n     type packet<T: Send> = {"}, {"sha": "a89e21bc04b4816d001105423b0bbdf9db760f35", "filename": "src/test/run-pass/operator-overloading.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-overloading.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -31,10 +31,10 @@ impl Point : ops::Index<bool,int> {\n }\n \n impl Point : cmp::Eq {\n-    pure fn eq(other: &Point) -> bool {\n-        self.x == (*other).x && self.y == (*other).y\n+    pure fn eq(&self, other: &Point) -> bool {\n+        (*self).x == (*other).x && (*self).y == (*other).y\n     }\n-    pure fn ne(other: &Point) -> bool { !self.eq(other) }\n+    pure fn ne(&self, other: &Point) -> bool { !(*self).eq(other) }\n }\n \n fn main() {"}, {"sha": "52097b593e723086d5d3734dc4526d10269fa26a", "filename": "src/test/run-pass/structured-compare.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fstructured-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fstructured-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructured-compare.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -3,10 +3,10 @@\n enum foo { large, small, }\n \n impl foo : cmp::Eq {\n-    pure fn eq(other: &foo) -> bool {\n-        (self as uint) == ((*other) as uint)\n+    pure fn eq(&self, other: &foo) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n     }\n-    pure fn ne(other: &foo) -> bool { !self.eq(other) }\n+    pure fn ne(&self, other: &foo) -> bool { !(*self).eq(other) }\n }\n \n fn main() {"}, {"sha": "0590bd2f681f789b9899ffd4c2c76819a7c60e89", "filename": "src/test/run-pass/tag-variant-disr-val.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -10,10 +10,10 @@ enum color {\n }\n \n impl color : cmp::Eq {\n-    pure fn eq(other: &color) -> bool {\n-        (self as uint) == ((*other) as uint)\n+    pure fn eq(&self, other: &color) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n     }\n-    pure fn ne(other: &color) -> bool { !self.eq(other) }\n+    pure fn ne(&self, other: &color) -> bool { !(*self).eq(other) }\n }\n \n fn main() {"}, {"sha": "ec3e97009e67c43b9e0d4faf5d0f2698591201b4", "filename": "src/test/run-pass/tag.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Ftag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Ftag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -5,8 +5,8 @@\n enum colour { red(int, int), green, }\n \n impl colour : cmp::Eq {\n-    pure fn eq(other: &colour) -> bool {\n-        match self {\n+    pure fn eq(&self, other: &colour) -> bool {\n+        match *self {\n             red(a0, b0) => {\n                 match (*other) {\n                     red(a1, b1) => a0 == a1 && b0 == b1,\n@@ -21,7 +21,7 @@ impl colour : cmp::Eq {\n             }\n         }\n     }\n-    pure fn ne(other: &colour) -> bool { !self.eq(other) }\n+    pure fn ne(&self, other: &colour) -> bool { !(*self).eq(other) }\n }\n \n fn f() { let x = red(1, 2); let y = green; assert (x != y); }"}, {"sha": "9ea9c746b6e42cc0468a0a69f57b475de27a28f6", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -48,8 +48,8 @@ enum t {\n }\n \n impl t : cmp::Eq {\n-    pure fn eq(other: &t) -> bool {\n-        match self {\n+    pure fn eq(&self, other: &t) -> bool {\n+        match *self {\n             tag1 => {\n                 match (*other) {\n                     tag1 => true,\n@@ -71,7 +71,7 @@ impl t : cmp::Eq {\n             }\n         }\n     }\n-    pure fn ne(other: &t) -> bool { !self.eq(other) }\n+    pure fn ne(&self, other: &t) -> bool { !(*self).eq(other) }\n }\n \n fn test_tag() {"}, {"sha": "f74d67258368b247e258199f941d7b2b016cf4e3", "filename": "src/test/run-pass/while-prelude-drop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/318e534895f20e7991abbc644eec311816010ef1/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs?ref=318e534895f20e7991abbc644eec311816010ef1", "patch": "@@ -2,8 +2,8 @@\n enum t { a, b(~str), }\n \n impl t : cmp::Eq {\n-    pure fn eq(other: &t) -> bool {\n-        match self {\n+    pure fn eq(&self, other: &t) -> bool {\n+        match *self {\n             a => {\n                 match (*other) {\n                     a => true,\n@@ -18,7 +18,7 @@ impl t : cmp::Eq {\n             }\n         }\n     }\n-    pure fn ne(other: &t) -> bool { !self.eq(other) }\n+    pure fn ne(&self, other: &t) -> bool { !(*self).eq(other) }\n }\n \n fn make(i: int) -> t {"}]}