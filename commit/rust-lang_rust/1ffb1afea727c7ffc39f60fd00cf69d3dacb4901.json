{"sha": "1ffb1afea727c7ffc39f60fd00cf69d3dacb4901", "node_id": "C_kwDOAAsO6NoAKDFmZmIxYWZlYTcyN2M3ZmZjMzlmNjBmZDAwY2Y2OWQzZGFjYjQ5MDE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-30T19:42:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-30T19:42:18Z"}, "message": "Rollup merge of #109679 - compiler-errors:normalizes-to-hack-2, r=lcnr,BoxyUwU\n\nFreshen normalizes-to hack goal RHS in the evaluate loop\n\nEnsure that we repeatedly equate the unconstrained RHS of the normalizes-to hack goal with the *actual* RHS of the goal, even if the normalizes-to goal loops several times and thus we replace the unconstrained RHS var repeatedly.\n\nAlternative to #109583.", "tree": {"sha": "9e0e4a9fc7d2922f859d1835e53c44b0f13717f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e0e4a9fc7d2922f859d1835e53c44b0f13717f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ffb1afea727c7ffc39f60fd00cf69d3dacb4901", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkJeYaCRBK7hj4Ov3rIwAAaGoIAK4E0fvE54XpyeXYDIH40YTX\noVjPfo67DGv+PeU+ViOLosuKWkGnL4o+fHTneVpwsc13P9kMkUCAPb2xfG7XAlj0\nAMBfzqfKBmDYPSksLwYA9ZJPi/+i0O95oNvofUI4BJGquE+9Ikigak5FJ2WOAhLv\njCczLzHCwLkga9Bcja0f3aXcEMcqmHsE7Z93jUsgKW+eSX/SSxq7d2NEBIV20g1a\nxW3HCylzghr0pSDyEsE25FF9T2CUVCuUYI+DH26vUJyyONH/97fHgO1Z7RmHTTQC\nT7n5ZYhYIyWhFG9olWYVsafhcVeHMlQX/qnzlij1SUF1tiB7xvON7Maq/UjGsiU=\n=5FuB\n-----END PGP SIGNATURE-----\n", "payload": "tree 9e0e4a9fc7d2922f859d1835e53c44b0f13717f3\nparent bc7976eee562546d6eff72d4227cea15a17afe01\nparent 0542b0d04d1af7990d1268046b32a9cf0259728d\nauthor Michael Goulet <michael@errs.io> 1680205338 -0700\ncommitter GitHub <noreply@github.com> 1680205338 -0700\n\nRollup merge of #109679 - compiler-errors:normalizes-to-hack-2, r=lcnr,BoxyUwU\n\nFreshen normalizes-to hack goal RHS in the evaluate loop\n\nEnsure that we repeatedly equate the unconstrained RHS of the normalizes-to hack goal with the *actual* RHS of the goal, even if the normalizes-to goal loops several times and thus we replace the unconstrained RHS var repeatedly.\n\nAlternative to #109583.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ffb1afea727c7ffc39f60fd00cf69d3dacb4901", "html_url": "https://github.com/rust-lang/rust/commit/1ffb1afea727c7ffc39f60fd00cf69d3dacb4901", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ffb1afea727c7ffc39f60fd00cf69d3dacb4901/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc7976eee562546d6eff72d4227cea15a17afe01", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc7976eee562546d6eff72d4227cea15a17afe01", "html_url": "https://github.com/rust-lang/rust/commit/bc7976eee562546d6eff72d4227cea15a17afe01"}, {"sha": "0542b0d04d1af7990d1268046b32a9cf0259728d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0542b0d04d1af7990d1268046b32a9cf0259728d", "html_url": "https://github.com/rust-lang/rust/commit/0542b0d04d1af7990d1268046b32a9cf0259728d"}], "stats": {"total": 113, "additions": 70, "deletions": 43}, "files": [{"sha": "705e79aebd8c1ffbfa998bb664e15a481f6ae6e8", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 69, "deletions": 33, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/1ffb1afea727c7ffc39f60fd00cf69d3dacb4901/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ffb1afea727c7ffc39f60fd00cf69d3dacb4901/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=1ffb1afea727c7ffc39f60fd00cf69d3dacb4901", "patch": "@@ -67,7 +67,20 @@ pub(super) enum IsNormalizesToHack {\n \n #[derive(Debug, Clone)]\n pub(super) struct NestedGoals<'tcx> {\n+    /// This normalizes-to goal that is treated specially during the evaluation\n+    /// loop. In each iteration we take the RHS of the projection, replace it with\n+    /// a fresh inference variable, and only after evaluating that goal do we\n+    /// equate the fresh inference variable with the actual RHS of the predicate.\n+    ///\n+    /// This is both to improve caching, and to avoid using the RHS of the\n+    /// projection predicate to influence the normalizes-to candidate we select.\n+    ///\n+    /// This is not a 'real' nested goal. We must not forget to replace the RHS\n+    /// with a fresh inference variable when we evaluate this goal. That can result\n+    /// in a trait solver cycle. This would currently result in overflow but can be\n+    /// can be unsound with more powerful coinduction in the future.\n     pub(super) normalizes_to_hack_goal: Option<Goal<'tcx, ty::ProjectionPredicate<'tcx>>>,\n+    /// The rest of the goals which have not yet processed or remain ambiguous.\n     pub(super) goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n }\n \n@@ -182,6 +195,10 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             canonical_response,\n         )?;\n \n+        if !has_changed && !nested_goals.is_empty() {\n+            bug!(\"an unchanged goal shouldn't have any side-effects on instantiation\");\n+        }\n+\n         // Check that rerunning this query with its inference constraints applied\n         // doesn't result in new inference constraints and has the same result.\n         //\n@@ -199,9 +216,17 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             let canonical_response =\n                 EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n             if !canonical_response.value.var_values.is_identity() {\n-                bug!(\"unstable result: {goal:?} {canonical_goal:?} {canonical_response:?}\");\n+                bug!(\n+                    \"unstable result: re-canonicalized goal={canonical_goal:#?} \\\n+                     response={canonical_response:#?}\"\n+                );\n+            }\n+            if certainty != canonical_response.value.certainty {\n+                bug!(\n+                    \"unstable certainty: {certainty:#?} re-canonicalized goal={canonical_goal:#?} \\\n+                     response={canonical_response:#?}\"\n+                );\n             }\n-            assert_eq!(certainty, canonical_response.value.certainty);\n         }\n \n         Ok((has_changed, certainty, nested_goals))\n@@ -281,15 +306,44 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 let mut has_changed = Err(Certainty::Yes);\n \n                 if let Some(goal) = goals.normalizes_to_hack_goal.take() {\n-                    let (_, certainty, nested_goals) = match this.evaluate_goal(\n-                        IsNormalizesToHack::Yes,\n-                        goal.with(this.tcx(), ty::Binder::dummy(goal.predicate)),\n+                    // Replace the goal with an unconstrained infer var, so the\n+                    // RHS does not affect projection candidate assembly.\n+                    let unconstrained_rhs = this.next_term_infer_of_kind(goal.predicate.term);\n+                    let unconstrained_goal = goal.with(\n+                        this.tcx(),\n+                        ty::Binder::dummy(ty::ProjectionPredicate {\n+                            projection_ty: goal.predicate.projection_ty,\n+                            term: unconstrained_rhs,\n+                        }),\n+                    );\n+\n+                    let (_, certainty, instantiate_goals) =\n+                        match this.evaluate_goal(IsNormalizesToHack::Yes, unconstrained_goal) {\n+                            Ok(r) => r,\n+                            Err(NoSolution) => return Some(Err(NoSolution)),\n+                        };\n+                    new_goals.goals.extend(instantiate_goals);\n+\n+                    // Finally, equate the goal's RHS with the unconstrained var.\n+                    // We put the nested goals from this into goals instead of\n+                    // next_goals to avoid needing to process the loop one extra\n+                    // time if this goal returns something -- I don't think this\n+                    // matters in practice, though.\n+                    match this.eq_and_get_goals(\n+                        goal.param_env,\n+                        goal.predicate.term,\n+                        unconstrained_rhs,\n                     ) {\n-                        Ok(r) => r,\n+                        Ok(eq_goals) => {\n+                            goals.goals.extend(eq_goals);\n+                        }\n                         Err(NoSolution) => return Some(Err(NoSolution)),\n                     };\n-                    new_goals.goals.extend(nested_goals);\n \n+                    // We only look at the `projection_ty` part here rather than\n+                    // looking at the \"has changed\" return from evaluate_goal,\n+                    // because we expect the `unconstrained_rhs` part of the predicate\n+                    // to have changed -- that means we actually normalized successfully!\n                     if goal.predicate.projection_ty\n                         != this.resolve_vars_if_possible(goal.predicate.projection_ty)\n                     {\n@@ -299,40 +353,22 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                     match certainty {\n                         Certainty::Yes => {}\n                         Certainty::Maybe(_) => {\n-                            let goal = this.resolve_vars_if_possible(goal);\n-\n-                            // The rhs of this `normalizes-to` must always be an unconstrained infer var as it is\n-                            // the hack used by `normalizes-to` to ensure that every `normalizes-to` behaves the same\n-                            // regardless of the rhs.\n-                            //\n-                            // However it is important not to unconditionally replace the rhs with a new infer var\n-                            // as otherwise we may replace the original unconstrained infer var with a new infer var\n-                            // and never propagate any constraints on the new var back to the original var.\n-                            let term = this\n-                                .term_is_fully_unconstrained(goal)\n-                                .then_some(goal.predicate.term)\n-                                .unwrap_or_else(|| {\n-                                    this.next_term_infer_of_kind(goal.predicate.term)\n-                                });\n-                            let projection_pred = ty::ProjectionPredicate {\n-                                term,\n-                                projection_ty: goal.predicate.projection_ty,\n-                            };\n+                            // We need to resolve vars here so that we correctly\n+                            // deal with `has_changed` in the next iteration.\n                             new_goals.normalizes_to_hack_goal =\n-                                Some(goal.with(this.tcx(), projection_pred));\n-\n+                                Some(this.resolve_vars_if_possible(goal));\n                             has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n                         }\n                     }\n                 }\n \n-                for nested_goal in goals.goals.drain(..) {\n-                    let (changed, certainty, nested_goals) =\n-                        match this.evaluate_goal(IsNormalizesToHack::No, nested_goal) {\n+                for goal in goals.goals.drain(..) {\n+                    let (changed, certainty, instantiate_goals) =\n+                        match this.evaluate_goal(IsNormalizesToHack::No, goal) {\n                             Ok(result) => result,\n                             Err(NoSolution) => return Some(Err(NoSolution)),\n                         };\n-                    new_goals.goals.extend(nested_goals);\n+                    new_goals.goals.extend(instantiate_goals);\n \n                     if changed {\n                         has_changed = Ok(());\n@@ -341,7 +377,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                     match certainty {\n                         Certainty::Yes => {}\n                         Certainty::Maybe(_) => {\n-                            new_goals.goals.push(nested_goal);\n+                            new_goals.goals.push(goal);\n                             has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n                         }\n                     }"}, {"sha": "da713268f1123ddd54756662327db540ba825046", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1ffb1afea727c7ffc39f60fd00cf69d3dacb4901/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ffb1afea727c7ffc39f60fd00cf69d3dacb4901/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=1ffb1afea727c7ffc39f60fd00cf69d3dacb4901", "patch": "@@ -34,16 +34,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             let candidates = self.assemble_and_evaluate_candidates(goal);\n             self.merge_candidates(candidates)\n         } else {\n-            let predicate = goal.predicate;\n-            let unconstrained_rhs = self.next_term_infer_of_kind(predicate.term);\n-            let unconstrained_predicate = ProjectionPredicate {\n-                projection_ty: goal.predicate.projection_ty,\n-                term: unconstrained_rhs,\n-            };\n-\n-            self.set_normalizes_to_hack_goal(goal.with(self.tcx(), unconstrained_predicate));\n-            self.try_evaluate_added_goals()?;\n-            self.eq(goal.param_env, unconstrained_rhs, predicate.term)?;\n+            self.set_normalizes_to_hack_goal(goal);\n             self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         }\n     }"}]}