{"sha": "7c13b145f47e36158c252e0359a8374f1aff3e5e", "node_id": "C_kwDOAAsO6NoAKDdjMTNiMTQ1ZjQ3ZTM2MTU4YzI1MmUwMzU5YTgzNzRmMWFmZjNlNWU", "commit": {"author": {"name": "Markus Everling", "email": "markuseverling@gmail.com", "date": "2022-12-29T01:22:40Z"}, "committer": {"name": "Markus Everling", "email": "markuseverling@gmail.com", "date": "2022-12-29T02:00:11Z"}, "message": "Implement more methods for `vec_deque::IntoIter`", "tree": {"sha": "47d8482c5b8a473150ef33907a039f995d342383", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47d8482c5b8a473150ef33907a039f995d342383"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c13b145f47e36158c252e0359a8374f1aff3e5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c13b145f47e36158c252e0359a8374f1aff3e5e", "html_url": "https://github.com/rust-lang/rust/commit/7c13b145f47e36158c252e0359a8374f1aff3e5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c13b145f47e36158c252e0359a8374f1aff3e5e/comments", "author": {"login": "Sp00ph", "id": 61327188, "node_id": "MDQ6VXNlcjYxMzI3MTg4", "avatar_url": "https://avatars.githubusercontent.com/u/61327188?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Sp00ph", "html_url": "https://github.com/Sp00ph", "followers_url": "https://api.github.com/users/Sp00ph/followers", "following_url": "https://api.github.com/users/Sp00ph/following{/other_user}", "gists_url": "https://api.github.com/users/Sp00ph/gists{/gist_id}", "starred_url": "https://api.github.com/users/Sp00ph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Sp00ph/subscriptions", "organizations_url": "https://api.github.com/users/Sp00ph/orgs", "repos_url": "https://api.github.com/users/Sp00ph/repos", "events_url": "https://api.github.com/users/Sp00ph/events{/privacy}", "received_events_url": "https://api.github.com/users/Sp00ph/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Sp00ph", "id": 61327188, "node_id": "MDQ6VXNlcjYxMzI3MTg4", "avatar_url": "https://avatars.githubusercontent.com/u/61327188?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Sp00ph", "html_url": "https://github.com/Sp00ph", "followers_url": "https://api.github.com/users/Sp00ph/followers", "following_url": "https://api.github.com/users/Sp00ph/following{/other_user}", "gists_url": "https://api.github.com/users/Sp00ph/gists{/gist_id}", "starred_url": "https://api.github.com/users/Sp00ph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Sp00ph/subscriptions", "organizations_url": "https://api.github.com/users/Sp00ph/orgs", "repos_url": "https://api.github.com/users/Sp00ph/repos", "events_url": "https://api.github.com/users/Sp00ph/events{/privacy}", "received_events_url": "https://api.github.com/users/Sp00ph/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83a28ef095ba4179a63196f16eadd97f110d6cb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/83a28ef095ba4179a63196f16eadd97f110d6cb3", "html_url": "https://github.com/rust-lang/rust/commit/83a28ef095ba4179a63196f16eadd97f110d6cb3"}], "stats": {"total": 185, "additions": 184, "deletions": 1}, "files": [{"sha": "34bc0ce9177c402723a1ab6cd2eb02e1a4d439b4", "filename": "library/alloc/src/collections/vec_deque/into_iter.rs", "status": "modified", "additions": 184, "deletions": 1, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/7c13b145f47e36158c252e0359a8374f1aff3e5e/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c13b145f47e36158c252e0359a8374f1aff3e5e/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs?ref=7c13b145f47e36158c252e0359a8374f1aff3e5e", "patch": "@@ -1,5 +1,5 @@\n-use core::fmt;\n use core::iter::{FusedIterator, TrustedLen};\n+use core::{array, fmt, mem::MaybeUninit, ops::Try, ptr};\n \n use crate::alloc::{Allocator, Global};\n \n@@ -52,6 +52,126 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n         let len = self.inner.len();\n         (len, Some(len))\n     }\n+\n+    #[inline]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        if self.inner.len < n {\n+            let len = self.inner.len;\n+            self.inner.clear();\n+            Err(len)\n+        } else {\n+            self.inner.drain(..n);\n+            Ok(())\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.inner.len\n+    }\n+\n+    fn try_fold<B, F, R>(&mut self, mut init: B, mut f: F) -> R\n+    where\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Output = B>,\n+    {\n+        struct Guard<'a, T, A: Allocator> {\n+            deque: &'a mut VecDeque<T, A>,\n+            // `consumed <= deque.len` always holds.\n+            consumed: usize,\n+        }\n+\n+        impl<'a, T, A: Allocator> Drop for Guard<'a, T, A> {\n+            fn drop(&mut self) {\n+                self.deque.len -= self.consumed;\n+                self.deque.head = self.deque.to_physical_idx(self.consumed);\n+            }\n+        }\n+\n+        let mut guard = Guard { deque: &mut self.inner, consumed: 0 };\n+\n+        let (head, tail) = guard.deque.as_slices();\n+\n+        init = head\n+            .iter()\n+            .map(|elem| {\n+                guard.consumed += 1;\n+                // SAFETY: Because we incremented `guard.consumed`, the\n+                // deque effectively forgot the element, so we can take\n+                // ownership\n+                unsafe { ptr::read(elem) }\n+            })\n+            .try_fold(init, &mut f)?;\n+\n+        tail.iter()\n+            .map(|elem| {\n+                guard.consumed += 1;\n+                // SAFETY: Same as above.\n+                unsafe { ptr::read(elem) }\n+            })\n+            .try_fold(init, &mut f)\n+    }\n+\n+    #[inline]\n+    fn fold<B, F>(mut self, init: B, mut f: F) -> B\n+    where\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        match self.try_fold(init, |b, item| Ok::<B, !>(f(b, item))) {\n+            Ok(b) => b,\n+            Err(e) => match e {},\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.inner.pop_back()\n+    }\n+\n+    fn next_chunk<const N: usize>(\n+        &mut self,\n+    ) -> Result<[Self::Item; N], array::IntoIter<Self::Item, N>> {\n+        let mut raw_arr = MaybeUninit::uninit_array();\n+        let raw_arr_ptr = raw_arr.as_mut_ptr().cast();\n+        let (head, tail) = self.inner.as_slices();\n+\n+        if head.len() >= N {\n+            // SAFETY: By manually adjusting the head and length of the deque, we effectively\n+            // make it forget the first `N` elements, so taking ownership of them is safe.\n+            unsafe { ptr::copy_nonoverlapping(head.as_ptr(), raw_arr_ptr, N) };\n+            self.inner.head = self.inner.to_physical_idx(N);\n+            self.inner.len -= N;\n+            // SAFETY: We initialized the entire array with items from `head`\n+            return Ok(unsafe { raw_arr.transpose().assume_init() });\n+        }\n+\n+        // SAFETY: Same argument as above.\n+        unsafe { ptr::copy_nonoverlapping(head.as_ptr(), raw_arr_ptr, head.len()) };\n+        let remaining = N - head.len();\n+\n+        if tail.len() >= remaining {\n+            // SAFETY: Same argument as above.\n+            unsafe {\n+                ptr::copy_nonoverlapping(tail.as_ptr(), raw_arr_ptr.add(head.len()), remaining)\n+            };\n+            self.inner.head = self.inner.to_physical_idx(N);\n+            self.inner.len -= N;\n+            // SAFETY: We initialized the entire array with items from `head` and `tail`\n+            Ok(unsafe { raw_arr.transpose().assume_init() })\n+        } else {\n+            // SAFETY: Same argument as above.\n+            unsafe {\n+                ptr::copy_nonoverlapping(tail.as_ptr(), raw_arr_ptr.add(head.len()), tail.len())\n+            };\n+            let init = head.len() + tail.len();\n+            // We completely drained all the deques elements.\n+            self.inner.head = 0;\n+            self.inner.len = 0;\n+            // SAFETY: We copied all elements from both slices to the beginning of the array, so\n+            // the given range is initialized.\n+            Err(unsafe { array::IntoIter::new_unchecked(raw_arr, 0..init) })\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -60,10 +180,73 @@ impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n     fn next_back(&mut self) -> Option<T> {\n         self.inner.pop_back()\n     }\n+\n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        let len = self.inner.len;\n+        if len >= n {\n+            self.inner.truncate(len - n);\n+            Ok(())\n+        } else {\n+            self.inner.clear();\n+            Err(len)\n+        }\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, mut init: B, mut f: F) -> R\n+    where\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Output = B>,\n+    {\n+        struct Guard<'a, T, A: Allocator> {\n+            deque: &'a mut VecDeque<T, A>,\n+            // `consumed <= deque.len` always holds.\n+            consumed: usize,\n+        }\n+\n+        impl<'a, T, A: Allocator> Drop for Guard<'a, T, A> {\n+            fn drop(&mut self) {\n+                self.deque.len -= self.consumed;\n+            }\n+        }\n+\n+        let mut guard = Guard { deque: &mut self.inner, consumed: 0 };\n+\n+        let (head, tail) = guard.deque.as_slices();\n+\n+        init = tail\n+            .iter()\n+            .map(|elem| {\n+                guard.consumed += 1;\n+                // SAFETY: See `try_fold`'s safety comment.\n+                unsafe { ptr::read(elem) }\n+            })\n+            .try_rfold(init, &mut f)?;\n+\n+        head.iter()\n+            .map(|elem| {\n+                guard.consumed += 1;\n+                // SAFETY: Same as above.\n+                unsafe { ptr::read(elem) }\n+            })\n+            .try_rfold(init, &mut f)\n+    }\n+\n+    #[inline]\n+    fn rfold<B, F>(mut self, init: B, mut f: F) -> B\n+    where\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        match self.try_rfold(init, |b, item| Ok::<B, !>(f(b, item))) {\n+            Ok(b) => b,\n+            Err(e) => match e {},\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, A: Allocator> ExactSizeIterator for IntoIter<T, A> {\n+    #[inline]\n     fn is_empty(&self) -> bool {\n         self.inner.is_empty()\n     }"}]}