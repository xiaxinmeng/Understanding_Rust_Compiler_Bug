{"sha": "074f4c2c91035dab745d197de8b2639fa05bdf40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3NGY0YzJjOTEwMzVkYWI3NDVkMTk3ZGU4YjI2MzlmYTA1YmRmNDA=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-23T06:27:43Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-28T08:43:34Z"}, "message": "Fix spans of generated `#[derive_*]` attributes", "tree": {"sha": "b70c556e4d742eba4e019453fa4457b08ee83949", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b70c556e4d742eba4e019453fa4457b08ee83949"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/074f4c2c91035dab745d197de8b2639fa05bdf40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/074f4c2c91035dab745d197de8b2639fa05bdf40", "html_url": "https://github.com/rust-lang/rust/commit/074f4c2c91035dab745d197de8b2639fa05bdf40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/074f4c2c91035dab745d197de8b2639fa05bdf40/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f89c0c2f4b3af99202940fd975f04bc77c90270f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f89c0c2f4b3af99202940fd975f04bc77c90270f", "html_url": "https://github.com/rust-lang/rust/commit/f89c0c2f4b3af99202940fd975f04bc77c90270f"}], "stats": {"total": 89, "additions": 44, "deletions": 45}, "files": [{"sha": "b5dc5f8da3545376fde37d8e62cd639dbad437a2", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/074f4c2c91035dab745d197de8b2639fa05bdf40/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074f4c2c91035dab745d197de8b2639fa05bdf40/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=074f4c2c91035dab745d197de8b2639fa05bdf40", "patch": "@@ -201,7 +201,7 @@ use syntax::codemap::{self, respan, DUMMY_SP};\n use syntax::codemap::Span;\n use syntax::errors::Handler;\n use syntax::util::move_map::MoveMap;\n-use syntax::parse::token::{intern, keywords, InternedString};\n+use syntax::parse::token::{keywords, InternedString};\n use syntax::ptr::P;\n \n use self::ty::{LifetimeBounds, Path, Ptr, PtrTy, Self_, Ty};\n@@ -1421,20 +1421,9 @@ impl<'a> MethodDef<'a> {\n // general helper methods.\n impl<'a> TraitDef<'a> {\n     fn set_expn_info(&self,\n-                     cx: &mut ExtCtxt,\n+                     _cx: &mut ExtCtxt,\n                      mut to_set: Span) -> Span {\n-        let trait_name = match self.path.path.last() {\n-            None => cx.span_bug(self.span, \"trait with empty path in generic `derive`\"),\n-            Some(name) => *name\n-        };\n-        to_set.expn_id = cx.codemap().record_expansion(codemap::ExpnInfo {\n-            call_site: to_set,\n-            callee: codemap::NameAndSpan {\n-                format: codemap::MacroAttribute(intern(&format!(\"derive({})\", trait_name))),\n-                span: Some(self.span),\n-                allow_internal_unstable: false,\n-            }\n-        });\n+        to_set.expn_id = self.span.expn_id;\n         to_set\n     }\n "}, {"sha": "c75a1e1eae19ecd29ac1d33467a04402b021e59c", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 41, "deletions": 31, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/074f4c2c91035dab745d197de8b2639fa05bdf40/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074f4c2c91035dab745d197de8b2639fa05bdf40/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=074f4c2c91035dab745d197de8b2639fa05bdf40", "patch": "@@ -16,7 +16,7 @@ use syntax::ext::base::{ExtCtxt, SyntaxEnv, Annotatable};\n use syntax::ext::base::{MultiDecorator, MultiItemDecorator, MultiModifier};\n use syntax::ext::build::AstBuilder;\n use syntax::feature_gate;\n-use syntax::codemap::Span;\n+use syntax::codemap::{self, Span};\n use syntax::parse::token::{intern, intern_and_get_ident};\n use syntax::ptr::P;\n \n@@ -96,36 +96,6 @@ fn expand_derive(cx: &mut ExtCtxt,\n             let mut found_partial_eq = false;\n             let mut found_eq = false;\n \n-            // This span is **very** sensitive and crucial to\n-            // getting the stability behavior we want. What we are\n-            // doing is marking the generated `#[derive_*]` with the\n-            // span of the `#[deriving(...)]` attribute (the\n-            // entire attribute, not just the `PartialEq` or `Eq`\n-            // part), but with the current backtrace. The current\n-            // backtrace will contain a topmost entry that IS this\n-            // `#[deriving(...)]` attribute and with the\n-            // \"allow-unstable\" flag set to true.\n-            //\n-            // Note that we do NOT use the span of the `Eq`\n-            // text itself. You might think this is\n-            // equivalent, because the `Eq` appears within the\n-            // `#[deriving(Eq)]` attribute, and hence we would\n-            // inherit the \"allows unstable\" from the\n-            // backtrace.  But in fact this is not always the\n-            // case. The actual source text that led to\n-            // deriving can be `#[$attr]`, for example, where\n-            // `$attr == deriving(Eq)`. In that case, the\n-            // \"#[derive_*]\" would be considered to\n-            // originate not from the deriving call but from\n-            // text outside the deriving call, and hence would\n-            // be forbidden from using unstable\n-            // content.\n-            //\n-            // See tests src/run-pass/rfc1445 for\n-            // examples. --nmatsakis\n-            let span = Span { expn_id: cx.backtrace(), .. span };\n-            assert!(cx.parse_sess.codemap().span_allows_unstable(span));\n-\n             for titem in traits.iter().rev() {\n                 let tname = match titem.node {\n                     MetaItemKind::Word(ref tname) => tname,\n@@ -150,6 +120,17 @@ fn expand_derive(cx: &mut ExtCtxt,\n                     found_partial_eq = true;\n                 }\n \n+                let span = Span {\n+                    expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n+                        call_site: titem.span,\n+                        callee: codemap::NameAndSpan {\n+                            format: codemap::MacroAttribute(intern(&format!(\"derive({})\", tname))),\n+                            span: Some(titem.span),\n+                            allow_internal_unstable: true,\n+                        },\n+                    }), ..titem.span\n+                };\n+\n                 // #[derive(Foo, Bar)] expands to #[derive_Foo] #[derive_Bar]\n                 item.attrs.push(cx.attribute(span, cx.meta_word(titem.span,\n                     intern_and_get_ident(&format!(\"derive_{}\", tname)))));\n@@ -158,6 +139,35 @@ fn expand_derive(cx: &mut ExtCtxt,\n             // RFC #1445. `#[derive(PartialEq, Eq)]` adds a (trusted)\n             // `#[structural_match]` attribute.\n             if found_partial_eq && found_eq {\n+                // This span is **very** sensitive and crucial to\n+                // getting the stability behavior we want. What we are\n+                // doing is marking `#[structural_match]` with the\n+                // span of the `#[deriving(...)]` attribute (the\n+                // entire attribute, not just the `PartialEq` or `Eq`\n+                // part), but with the current backtrace. The current\n+                // backtrace will contain a topmost entry that IS this\n+                // `#[deriving(...)]` attribute and with the\n+                // \"allow-unstable\" flag set to true.\n+                //\n+                // Note that we do NOT use the span of the `Eq`\n+                // text itself. You might think this is\n+                // equivalent, because the `Eq` appears within the\n+                // `#[deriving(Eq)]` attribute, and hence we would\n+                // inherit the \"allows unstable\" from the\n+                // backtrace.  But in fact this is not always the\n+                // case. The actual source text that led to\n+                // deriving can be `#[$attr]`, for example, where\n+                // `$attr == deriving(Eq)`. In that case, the\n+                // \"#[structural_match]\" would be considered to\n+                // originate not from the deriving call but from\n+                // text outside the deriving call, and hence would\n+                // be forbidden from using unstable\n+                // content.\n+                //\n+                // See tests src/run-pass/rfc1445 for\n+                // examples. --nmatsakis\n+                let span = Span { expn_id: cx.backtrace(), .. span };\n+                assert!(cx.parse_sess.codemap().span_allows_unstable(span));\n                 debug!(\"inserting structural_match with span {:?}\", span);\n                 let structural_match = intern_and_get_ident(\"structural_match\");\n                 item.attrs.push(cx.attribute(span,"}]}