{"sha": "92da3f9464085bcf73221291bed20d410dee4a32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZGEzZjk0NjQwODViY2Y3MzIyMTI5MWJlZDIwZDQxMGRlZTRhMzI=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-10-07T11:17:12Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-10-08T12:43:07Z"}, "message": "review comment: reduce the `is_adt_dtorck` method to just a check for the attribute.", "tree": {"sha": "b9717aff66109e855638d9ee0384bfa6b82bc258", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9717aff66109e855638d9ee0384bfa6b82bc258"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92da3f9464085bcf73221291bed20d410dee4a32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92da3f9464085bcf73221291bed20d410dee4a32", "html_url": "https://github.com/rust-lang/rust/commit/92da3f9464085bcf73221291bed20d410dee4a32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92da3f9464085bcf73221291bed20d410dee4a32/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a4743fab02ae9e1cb8523f91997b3f6d8d02518", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a4743fab02ae9e1cb8523f91997b3f6d8d02518", "html_url": "https://github.com/rust-lang/rust/commit/7a4743fab02ae9e1cb8523f91997b3f6d8d02518"}], "stats": {"total": 95, "additions": 9, "deletions": 86}, "files": [{"sha": "3d1eb66287f43d07463e01c0e47f2a6330fc8ddc", "filename": "src/librustc/middle/ty/util.rs", "status": "modified", "additions": 9, "deletions": 86, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/92da3f9464085bcf73221291bed20d410dee4a32/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92da3f9464085bcf73221291bed20d410dee4a32/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs?ref=92da3f9464085bcf73221291bed20d410dee4a32", "patch": "@@ -566,102 +566,25 @@ impl<'tcx> ty::ctxt<'tcx> {\n         }\n     }\n \n-    /// Returns true if this ADT is a dtorck type, i.e. whether it being\n-    /// safe for destruction requires it to be alive\n+    /// Returns true if this ADT is a dtorck type, i.e. whether it\n+    /// being safe for destruction requires all borrowed pointers\n+    /// reachable by it to have lifetimes strictly greater than self.\n     pub fn is_adt_dtorck(&self, adt: ty::AdtDef<'tcx>) -> bool {\n         let dtor_method = match adt.destructor() {\n             Some(dtor) => dtor,\n             None => return false\n         };\n-        let impl_did = self.impl_of_method(dtor_method).unwrap_or_else(|| {\n-            self.sess.bug(&format!(\"no Drop impl for the dtor of `{:?}`\", adt))\n-        });\n-        let generics = adt.type_scheme(self).generics;\n \n         // RFC 1238: if the destructor method is tagged with the\n         // attribute `unsafe_destructor_blind_to_params`, then the\n         // compiler is being instructed to *assume* that the\n-        // destructor will not access borrowed data via a type\n-        // parameter, even if such data is otherwise reachable.\n-        if self.has_attr(dtor_method, \"unsafe_destructor_blind_to_params\") {\n-            debug!(\"typ: {:?} assumed blind and thus is dtorck-safe\", adt);\n-            return false;\n-        }\n-\n-        // In `impl<'a> Drop ...`, we automatically assume\n-        // `'a` is meaningful and thus represents a bound\n-        // through which we could reach borrowed data.\n+        // destructor will not access borrowed data,\n+        // even if such data is otherwise reachable.\n         //\n-        // FIXME (pnkfelix): In the future it would be good to\n-        // extend the language to allow the user to express,\n-        // in the impl signature, that a lifetime is not\n-        // actually used (something like `where 'a: ?Live`).\n-        if generics.has_region_params(subst::TypeSpace) {\n-            debug!(\"typ: {:?} has interesting dtor due to region params\",\n-                   adt);\n-            return true;\n-        }\n-\n-        // RFC 1238: *any* type parameter at all makes this a dtor of\n-        // interest (i.e. cannot-assume-parametricity from RFC 1238.)\n-        if generics.has_type_params(subst::TypeSpace) {\n-            debug!(\"typ: {:?} has interesting dtor due to type params\",\n-                   adt);\n-            return true;\n-        }\n-\n-        let mut seen_items = Vec::new();\n-        let mut items_to_inspect = vec![impl_did];\n-        while let Some(item_def_id) = items_to_inspect.pop() {\n-            if seen_items.contains(&item_def_id) {\n-                continue;\n-            }\n-\n-            for pred in self.lookup_predicates(item_def_id).predicates {\n-                let result = match pred {\n-                    ty::Predicate::Equate(..) |\n-                    ty::Predicate::RegionOutlives(..) |\n-                    ty::Predicate::TypeOutlives(..) |\n-                    ty::Predicate::WellFormed(..) |\n-                    ty::Predicate::ObjectSafe(..) |\n-                    ty::Predicate::Projection(..) => {\n-                        // For now, assume all these where-clauses\n-                        // may give drop implementation capabilty\n-                        // to access borrowed data.\n-                        true\n-                    }\n-\n-                    ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n-                        let def_id = t_pred.trait_ref.def_id;\n-                        if self.trait_items(def_id).len() != 0 {\n-                            // If trait has items, assume it adds\n-                            // capability to access borrowed data.\n-                            true\n-                        } else {\n-                            // Trait without items is itself\n-                            // uninteresting from POV of dropck.\n-                            //\n-                            // However, may have parent w/ items;\n-                            // so schedule checking of predicates,\n-                            items_to_inspect.push(def_id);\n-                            // and say \"no capability found\" for now.\n-                            false\n-                        }\n-                    }\n-                };\n-\n-                if result {\n-                    debug!(\"typ: {:?} has interesting dtor due to generic preds, e.g. {:?}\",\n-                           adt, pred);\n-                    return true;\n-                }\n-            }\n-\n-            seen_items.push(item_def_id);\n-        }\n-\n-        debug!(\"typ: {:?} is dtorck-safe\", adt);\n-        false\n+        // Such access can be in plain sight (e.g. dereferencing\n+        // `*foo.0` of `Foo<'a>(&'a u32)`) or indirectly hidden\n+        // (e.g. calling `foo.0.clone()` of `Foo<T:Clone>`).\n+        return !self.has_attr(dtor_method, \"unsafe_destructor_blind_to_params\");\n     }\n }\n "}]}