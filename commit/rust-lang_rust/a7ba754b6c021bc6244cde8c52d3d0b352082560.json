{"sha": "a7ba754b6c021bc6244cde8c52d3d0b352082560", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3YmE3NTRiNmMwMjFiYzYyNDRjZGU4YzUyZDNkMGIzNTIwODI1NjA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-03T01:39:46Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-07T04:01:38Z"}, "message": "syntax: unify and simplify fn signature parsing.", "tree": {"sha": "1b20f13b3812d9c28563458d27b7857904f43af2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b20f13b3812d9c28563458d27b7857904f43af2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7ba754b6c021bc6244cde8c52d3d0b352082560", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7ba754b6c021bc6244cde8c52d3d0b352082560", "html_url": "https://github.com/rust-lang/rust/commit/a7ba754b6c021bc6244cde8c52d3d0b352082560", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7ba754b6c021bc6244cde8c52d3d0b352082560/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f9638d5d4b0b0f4ad592c135e155cdef1ddfb72", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f9638d5d4b0b0f4ad592c135e155cdef1ddfb72", "html_url": "https://github.com/rust-lang/rust/commit/7f9638d5d4b0b0f4ad592c135e155cdef1ddfb72"}], "stats": {"total": 180, "additions": 88, "deletions": 92}, "files": [{"sha": "4a457f5a43caa651dd34e0bab0ccf7ffc8dc4b38", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 38, "deletions": 58, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/a7ba754b6c021bc6244cde8c52d3d0b352082560/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7ba754b6c021bc6244cde8c52d3d0b352082560/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a7ba754b6c021bc6244cde8c52d3d0b352082560", "patch": "@@ -11,7 +11,7 @@ mod stmt;\n mod generics;\n \n use crate::ast::{\n-    self, DUMMY_NODE_ID, AttrStyle, Attribute, BindingMode, CrateSugar, FnDecl, Ident,\n+    self, DUMMY_NODE_ID, AttrStyle, Attribute, BindingMode, CrateSugar, Ident,\n     IsAsync, MacDelimiter, Mutability, Param, StrStyle, SelfKind, TyKind, Visibility,\n     VisibilityKind, Unsafety,\n };\n@@ -56,6 +56,17 @@ crate enum BlockMode {\n     Ignore,\n }\n \n+/// The parsing configuration used to parse a parameter list (see `parse_fn_params`).\n+struct ParamCfg {\n+    /// Is `self` is allowed as the first parameter?\n+    is_self_allowed: bool,\n+    /// Is `...` allowed as the tail of the parameter list?\n+    allow_c_variadic: bool,\n+    /// `is_name_required` decides if, per-parameter,\n+    /// the parameter must have a pattern or just a type.\n+    is_name_required: fn(&token::Token) -> bool,\n+}\n+\n /// Like `maybe_whole_expr`, but for things other than expressions.\n #[macro_export]\n macro_rules! maybe_whole {\n@@ -1094,26 +1105,18 @@ impl<'a> Parser<'a> {\n         res\n     }\n \n-    fn parse_fn_params(\n-        &mut self,\n-        named_params: bool,\n-        allow_c_variadic: bool,\n-    ) -> PResult<'a, Vec<Param>> {\n+    /// Parses the parameter list of a function, including the `(` and `)` delimiters.\n+    fn parse_fn_params(&mut self, mut cfg: ParamCfg) -> PResult<'a, Vec<Param>> {\n         let sp = self.token.span;\n-        let do_not_enforce_named_params_for_c_variadic = |token: &token::Token| {\n-            match token.kind {\n-                token::DotDotDot => false,\n-                _ => named_params,\n-            }\n-        };\n+        let is_trait_item = cfg.is_self_allowed;\n         let mut c_variadic = false;\n+        // Parse the arguments, starting out with `self` being possibly allowed...\n         let (params, _) = self.parse_paren_comma_seq(|p| {\n-            match p.parse_param_general(\n-                false,\n-                false,\n-                allow_c_variadic,\n-                do_not_enforce_named_params_for_c_variadic,\n-            ) {\n+            let param = p.parse_param_general(&cfg, is_trait_item);\n+            // ...now that we've parsed the first argument, `self` is no longer allowed.\n+            cfg.is_self_allowed = false;\n+\n+            match param {\n                 Ok(param) => Ok(\n                     if let TyKind::CVarArgs = param.ty.kind {\n                         c_variadic = true;\n@@ -1144,7 +1147,10 @@ impl<'a> Parser<'a> {\n             }\n         })?;\n \n-        let params: Vec<_> = params.into_iter().filter_map(|x| x).collect();\n+        let mut params: Vec<_> = params.into_iter().filter_map(|x| x).collect();\n+\n+        // Replace duplicated recovered params with `_` pattern to avoid unecessary errors.\n+        self.deduplicate_recovered_params_names(&mut params);\n \n         if c_variadic && params.len() <= 1 {\n             self.span_err(\n@@ -1156,79 +1162,53 @@ impl<'a> Parser<'a> {\n         Ok(params)\n     }\n \n-    /// Parses the parameter list and result type of a function that may have a `self` parameter.\n-    fn parse_fn_decl_with_self(\n-        &mut self,\n-        is_name_required: impl Copy + Fn(&token::Token) -> bool,\n-    ) -> PResult<'a, P<FnDecl>> {\n-        // Parse the arguments, starting out with `self` being allowed...\n-        let mut is_self_allowed = true;\n-        let (mut inputs, _): (Vec<_>, _) = self.parse_paren_comma_seq(|p| {\n-            let res = p.parse_param_general(is_self_allowed, true, false, is_name_required);\n-            // ...but now that we've parsed the first argument, `self` is no longer allowed.\n-            is_self_allowed = false;\n-            res\n-        })?;\n-\n-        // Replace duplicated recovered params with `_` pattern to avoid unecessary errors.\n-        self.deduplicate_recovered_params_names(&mut inputs);\n-\n-        Ok(P(FnDecl {\n-            inputs,\n-            output: self.parse_ret_ty(true)?,\n-        }))\n-    }\n-\n     /// Skips unexpected attributes and doc comments in this position and emits an appropriate\n     /// error.\n     /// This version of parse param doesn't necessarily require identifier names.\n-    fn parse_param_general(\n-        &mut self,\n-        is_self_allowed: bool,\n-        is_trait_item: bool,\n-        allow_c_variadic: bool,\n-        is_name_required: impl Fn(&token::Token) -> bool,\n-    ) -> PResult<'a, Param> {\n+    fn parse_param_general(&mut self, cfg: &ParamCfg, is_trait_item: bool) -> PResult<'a, Param> {\n         let lo = self.token.span;\n         let attrs = self.parse_outer_attributes()?;\n \n         // Possibly parse `self`. Recover if we parsed it and it wasn't allowed here.\n         if let Some(mut param) = self.parse_self_param()? {\n             param.attrs = attrs.into();\n-            return if is_self_allowed {\n+            return if cfg.is_self_allowed {\n                 Ok(param)\n             } else {\n                 self.recover_bad_self_param(param, is_trait_item)\n             };\n         }\n \n-        let is_name_required = is_name_required(&self.token);\n+        let is_name_required = match self.token.kind {\n+            token::DotDotDot => false,\n+            _ => (cfg.is_name_required)(&self.token),\n+        };\n         let (pat, ty) = if is_name_required || self.is_named_param() {\n             debug!(\"parse_param_general parse_pat (is_name_required:{})\", is_name_required);\n \n             let pat = self.parse_fn_param_pat()?;\n             if let Err(mut err) = self.expect(&token::Colon) {\n-                if let Some(ident) = self.parameter_without_type(\n+                return if let Some(ident) = self.parameter_without_type(\n                     &mut err,\n                     pat,\n                     is_name_required,\n-                    is_self_allowed,\n+                    cfg.is_self_allowed,\n                     is_trait_item,\n                 ) {\n                     err.emit();\n-                    return Ok(dummy_arg(ident));\n+                    Ok(dummy_arg(ident))\n                 } else {\n-                    return Err(err);\n-                }\n+                    Err(err)\n+                };\n             }\n \n             self.eat_incorrect_doc_comment_for_param_type();\n-            (pat, self.parse_ty_common(true, true, allow_c_variadic)?)\n+            (pat, self.parse_ty_common(true, true, cfg.allow_c_variadic)?)\n         } else {\n             debug!(\"parse_param_general ident_to_pat\");\n             let parser_snapshot_before_ty = self.clone();\n             self.eat_incorrect_doc_comment_for_param_type();\n-            let mut ty = self.parse_ty_common(true, true, allow_c_variadic);\n+            let mut ty = self.parse_ty_common(true, true, cfg.allow_c_variadic);\n             if ty.is_ok() && self.token != token::Comma &&\n                self.token != token::CloseDelim(token::Paren) {\n                 // This wasn't actually a type, but a pattern looking like a type,"}, {"sha": "d2ea0829595c03841e49ea5b04dcc7b9a2710eae", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a7ba754b6c021bc6244cde8c52d3d0b352082560/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7ba754b6c021bc6244cde8c52d3d0b352082560/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=a7ba754b6c021bc6244cde8c52d3d0b352082560", "patch": "@@ -1,4 +1,4 @@\n-use super::{Parser, PResult, PathStyle, SemiColonMode, BlockMode};\n+use super::{Parser, PResult, PathStyle, SemiColonMode, BlockMode, ParamCfg};\n \n use crate::maybe_whole;\n use crate::ptr::P;\n@@ -805,14 +805,15 @@ impl<'a> Parser<'a> {\n     /// of a method. The body is not parsed as that differs between `trait`s and `impl`s.\n     fn parse_method_sig(\n         &mut self,\n-        is_name_required: impl Copy + Fn(&token::Token) -> bool,\n+        is_name_required: fn(&token::Token) -> bool,\n     ) -> PResult<'a, (Ident, MethodSig, Generics)> {\n         let header = self.parse_fn_front_matter()?;\n-        let (ident, mut generics) = self.parse_fn_header()?;\n-        let decl = self.parse_fn_decl_with_self(is_name_required)?;\n-        let sig = MethodSig { header, decl };\n-        generics.where_clause = self.parse_where_clause()?;\n-        Ok((ident, sig, generics))\n+        let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n+            is_self_allowed: true,\n+            allow_c_variadic: false,\n+            is_name_required,\n+        })?;\n+        Ok((ident, MethodSig { header, decl }, generics))\n     }\n \n     /// Parses all the \"front matter\" for a `fn` declaration, up to\n@@ -1200,36 +1201,34 @@ impl<'a> Parser<'a> {\n         attrs: Vec<Attribute>,\n         header: FnHeader,\n     ) -> PResult<'a, Option<P<Item>>> {\n-        let allow_c_variadic = header.abi == Abi::C && header.unsafety == Unsafety::Unsafe;\n-        let (ident, decl, generics) = self.parse_fn_sig(allow_c_variadic)?;\n+        let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n+            is_self_allowed: false,\n+            allow_c_variadic: header.abi == Abi::C && header.unsafety == Unsafety::Unsafe,\n+            is_name_required: |_| true,\n+        })?;\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n         let kind = ItemKind::Fn(decl, header, generics, body);\n         self.mk_item_with_info(attrs, lo, vis, (ident, kind, Some(inner_attrs)))\n     }\n \n     /// Parse the \"signature\", including the identifier, parameters, and generics of a function.\n-    fn parse_fn_sig(\n-        &mut self,\n-        allow_c_variadic: bool,\n-    ) -> PResult<'a, (Ident, P<FnDecl>, Generics)> {\n-        let (ident, mut generics) = self.parse_fn_header()?;\n-        let decl = self.parse_fn_decl(allow_c_variadic)?;\n+    fn parse_fn_sig(&mut self, cfg: ParamCfg) -> PResult<'a, (Ident, P<FnDecl>, Generics)> {\n+        let ident = self.parse_ident()?;\n+        let mut generics = self.parse_generics()?;\n+        let decl = self.parse_fn_decl(cfg, true)?;\n         generics.where_clause = self.parse_where_clause()?;\n         Ok((ident, decl, generics))\n     }\n \n-    /// Parses the name and optional generic types of a function header.\n-    fn parse_fn_header(&mut self) -> PResult<'a, (Ident, Generics)> {\n-        let id = self.parse_ident()?;\n-        let generics = self.parse_generics()?;\n-        Ok((id, generics))\n-    }\n-\n     /// Parses the parameter list and result type of a function declaration.\n-    fn parse_fn_decl(&mut self, allow_c_variadic: bool) -> PResult<'a, P<FnDecl>> {\n+    pub(super) fn parse_fn_decl(\n+        &mut self,\n+        cfg: ParamCfg,\n+        ret_allow_plus: bool,\n+    ) -> PResult<'a, P<FnDecl>> {\n         Ok(P(FnDecl {\n-            inputs: self.parse_fn_params(true, allow_c_variadic)?,\n-            output: self.parse_ret_ty(true)?,\n+            inputs: self.parse_fn_params(cfg)?,\n+            output: self.parse_ret_ty(ret_allow_plus)?,\n         }))\n     }\n \n@@ -1353,7 +1352,11 @@ impl<'a> Parser<'a> {\n         extern_sp: Span,\n     ) -> PResult<'a, ForeignItem> {\n         self.expect_keyword(kw::Fn)?;\n-        let (ident, decl, generics) = self.parse_fn_sig(true)?;\n+        let (ident, decl, generics) = self.parse_fn_sig(super::ParamCfg {\n+            is_self_allowed: false,\n+            allow_c_variadic: true,\n+            is_name_required: |_| true,\n+        })?;\n         let span = lo.to(self.token.span);\n         self.parse_semi_or_incorrect_foreign_fn_body(&ident, extern_sp)?;\n         Ok(ast::ForeignItem {"}, {"sha": "c9446a880b0b6d39c3d719e64c1f8818b88b038c", "filename": "src/libsyntax/parse/parser/ty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a7ba754b6c021bc6244cde8c52d3d0b352082560/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7ba754b6c021bc6244cde8c52d3d0b352082560/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs?ref=a7ba754b6c021bc6244cde8c52d3d0b352082560", "patch": "@@ -4,7 +4,7 @@ use crate::{maybe_whole, maybe_recover_from_interpolated_ty_qpath};\n use crate::ptr::P;\n use crate::ast::{self, Ty, TyKind, MutTy, BareFnTy, FunctionRetTy, GenericParam, Lifetime, Ident};\n use crate::ast::{TraitBoundModifier, TraitObjectSyntax, GenericBound, GenericBounds, PolyTraitRef};\n-use crate::ast::{Mutability, AnonConst, FnDecl, Mac};\n+use crate::ast::{Mutability, AnonConst, Mac};\n use crate::parse::token::{self, Token};\n use crate::source_map::Span;\n use crate::symbol::{kw};\n@@ -288,12 +288,12 @@ impl<'a> Parser<'a> {\n         };\n \n         self.expect_keyword(kw::Fn)?;\n-        let inputs = self.parse_fn_params(false, true)?;\n-        let ret_ty = self.parse_ret_ty(false)?;\n-        let decl = P(FnDecl {\n-            inputs,\n-            output: ret_ty,\n-        });\n+        let cfg = super::ParamCfg {\n+            is_self_allowed: false,\n+            allow_c_variadic: true,\n+            is_name_required: |_| false,\n+        };\n+        let decl = self.parse_fn_decl(cfg, false)?;\n         Ok(TyKind::BareFn(P(BareFnTy {\n             abi,\n             unsafety,"}, {"sha": "7291732cebe4a3751062346c6920758f349d38c5", "filename": "src/test/ui/parser/issue-33413.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7ba754b6c021bc6244cde8c52d3d0b352082560/src%2Ftest%2Fui%2Fparser%2Fissue-33413.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7ba754b6c021bc6244cde8c52d3d0b352082560/src%2Ftest%2Fui%2Fparser%2Fissue-33413.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-33413.rs?ref=a7ba754b6c021bc6244cde8c52d3d0b352082560", "patch": "@@ -3,6 +3,7 @@ struct S;\n impl S {\n     fn f(*, a: u8) -> u8 {}\n     //~^ ERROR expected parameter name, found `*`\n+    //~| ERROR mismatched types\n }\n \n fn main() {}"}, {"sha": "7e5c348e36ceac5073e18730a04b066186b5f148", "filename": "src/test/ui/parser/issue-33413.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a7ba754b6c021bc6244cde8c52d3d0b352082560/src%2Ftest%2Fui%2Fparser%2Fissue-33413.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a7ba754b6c021bc6244cde8c52d3d0b352082560/src%2Ftest%2Fui%2Fparser%2Fissue-33413.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-33413.stderr?ref=a7ba754b6c021bc6244cde8c52d3d0b352082560", "patch": "@@ -4,5 +4,17 @@ error: expected parameter name, found `*`\n LL |     fn f(*, a: u8) -> u8 {}\n    |          ^ expected parameter name\n \n-error: aborting due to previous error\n+error[E0308]: mismatched types\n+  --> $DIR/issue-33413.rs:4:23\n+   |\n+LL |     fn f(*, a: u8) -> u8 {}\n+   |        -              ^^ expected u8, found ()\n+   |        |\n+   |        implicitly returns `()` as its body has no tail or `return` expression\n+   |\n+   = note: expected type `u8`\n+              found type `()`\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}]}