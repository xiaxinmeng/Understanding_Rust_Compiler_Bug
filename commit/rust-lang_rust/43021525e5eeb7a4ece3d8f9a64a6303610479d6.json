{"sha": "43021525e5eeb7a4ece3d8f9a64a6303610479d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzMDIxNTI1ZTVlZWI3YTRlY2UzZDhmOWE2NGE2MzAzNjEwNDc5ZDY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-24T09:26:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-24T09:26:52Z"}, "message": "Merge #9994\n\n9994: add static method generation assist r=matklad a=mahdi-frms\n\nAdds feature: #9948\r\n\r\nWill soon send a GIF for the changelog.\n\nCo-authored-by: mahdi-frms <mahdif1380@outlook.com>", "tree": {"sha": "e5285d4034dd32a349ac54c738f8b081e9a07203", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5285d4034dd32a349ac54c738f8b081e9a07203"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43021525e5eeb7a4ece3d8f9a64a6303610479d6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhJLtcCRBK7hj4Ov3rIwAAZ9gIAG6OOWJgw5J+hXGc2oXPi/jH\nVTlDdrotnHg0s/TIDPoVJ/J5Dxb8tUAYo1sUt5IcwICd9Y8N+ilv00d/rTNFa7Mq\ngZm23FI+s2cXCUihm6465n6YxpgASHnJgBbK9fCAfoJ5M9LYx+0fWWmn/c+Fofb3\n3KE+vZnyQKS/KNQ519RnLxRimSMJmQpIyp5DoLwkm22msDkxdRfj2tPauWELRRNv\nWwiFqV1Ne6772DYLR8BpRocv3j8dS/blMeTiO4kYxGiuiQf2SD1CPIB5TE8CW44l\nkz2UvRBBFP/VW4hkb+xaoKxuXUSalyq8M7kajfACE0vLR9OL4abKl5Mb2jiXF1w=\n=vyrr\n-----END PGP SIGNATURE-----\n", "payload": "tree e5285d4034dd32a349ac54c738f8b081e9a07203\nparent fa6a4a0c930051f91919291727f4ded1fc7a419c\nparent cf5f1c102c750af81fea85aecec5c4fc1bfaf198\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1629797212 +0000\ncommitter GitHub <noreply@github.com> 1629797212 +0000\n\nMerge #9994\n\n9994: add static method generation assist r=matklad a=mahdi-frms\n\nAdds feature: #9948\r\n\r\nWill soon send a GIF for the changelog.\n\nCo-authored-by: mahdi-frms <mahdif1380@outlook.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43021525e5eeb7a4ece3d8f9a64a6303610479d6", "html_url": "https://github.com/rust-lang/rust/commit/43021525e5eeb7a4ece3d8f9a64a6303610479d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43021525e5eeb7a4ece3d8f9a64a6303610479d6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa6a4a0c930051f91919291727f4ded1fc7a419c", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa6a4a0c930051f91919291727f4ded1fc7a419c", "html_url": "https://github.com/rust-lang/rust/commit/fa6a4a0c930051f91919291727f4ded1fc7a419c"}, {"sha": "cf5f1c102c750af81fea85aecec5c4fc1bfaf198", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf5f1c102c750af81fea85aecec5c4fc1bfaf198", "html_url": "https://github.com/rust-lang/rust/commit/cf5f1c102c750af81fea85aecec5c4fc1bfaf198"}], "stats": {"total": 163, "additions": 146, "deletions": 17}, "files": [{"sha": "ad98aa16d85e19b93f2ab035510af7105f48d834", "filename": "crates/ide_assists/src/handlers/generate_function.rs", "status": "modified", "additions": 146, "deletions": 17, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/43021525e5eeb7a4ece3d8f9a64a6303610479d6/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43021525e5eeb7a4ece3d8f9a64a6303610479d6/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=43021525e5eeb7a4ece3d8f9a64a6303610479d6", "patch": "@@ -70,26 +70,56 @@ impl FuncExpr {\n fn gen_fn(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let path_expr: ast::PathExpr = ctx.find_node_at_offset()?;\n     let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n-\n     let path = path_expr.path()?;\n+    let fn_name = fn_name(&path)?;\n     if ctx.sema.resolve_path(&path).is_some() {\n         // The function call already resolves, no need to add a function\n         return None;\n     }\n \n-    let target_module = match path.qualifier() {\n+    let target_module;\n+    let mut adt_name = None;\n+\n+    let (target, file, insert_offset) = match path.qualifier() {\n         Some(qualifier) => match ctx.sema.resolve_path(&qualifier) {\n-            Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) => Some(module),\n-            _ => return None,\n+            Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) => {\n+                target_module = Some(module);\n+                get_fn_target(ctx, &target_module, call.clone())?\n+            }\n+            Some(hir::PathResolution::Def(hir::ModuleDef::Adt(adt))) => {\n+                let current_module = current_module(call.syntax(), ctx)?;\n+                let module = adt.module(ctx.sema.db);\n+                target_module = if current_module == module { None } else { Some(module) };\n+                if current_module.krate() != module.krate() {\n+                    return None;\n+                }\n+                let (impl_, file) = get_adt_source(ctx, &adt, fn_name.text().as_str())?;\n+                let (target, insert_offset) = get_method_target(ctx, &module, &impl_)?;\n+                adt_name = if impl_.is_none() { Some(adt.name(ctx.sema.db)) } else { None };\n+                (target, file, insert_offset)\n+            }\n+            _ => {\n+                return None;\n+            }\n         },\n-        None => None,\n+        _ => {\n+            target_module = None;\n+            get_fn_target(ctx, &target_module, call.clone())?\n+        }\n     };\n-\n-    let (target, file, insert_offset) = get_fn_target(ctx, &target_module, call.clone())?;\n     let function_builder = FunctionBuilder::from_call(ctx, &call, &path, target_module, target)?;\n-    let target = call.syntax().text_range();\n+    let text_range = call.syntax().text_range();\n     let label = format!(\"Generate {} function\", function_builder.fn_name.clone());\n-    add_func_to_accumulator(acc, ctx, target, function_builder, insert_offset, file, None, label)\n+    add_func_to_accumulator(\n+        acc,\n+        ctx,\n+        text_range,\n+        function_builder,\n+        insert_offset,\n+        file,\n+        adt_name,\n+        label,\n+    )\n }\n \n fn gen_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n@@ -103,13 +133,7 @@ fn gen_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     if current_module.krate() != target_module.krate() {\n         return None;\n     }\n-\n-    let range = adt.source(ctx.sema.db)?.syntax().original_file_range(ctx.sema.db);\n-    let file = ctx.sema.parse(range.file_id);\n-    let adt_source =\n-        ctx.sema.find_node_at_offset_with_macros(file.syntax(), range.range.start())?;\n-    let impl_ = find_struct_impl(ctx, &adt_source, fn_name.text().as_str())?;\n-\n+    let (impl_, file) = get_adt_source(ctx, &adt, fn_name.text().as_str())?;\n     let (target, insert_offset) = get_method_target(ctx, &target_module, &impl_)?;\n     let function_builder =\n         FunctionBuilder::from_method_call(ctx, &call, &fn_name, target_module, target)?;\n@@ -122,7 +146,7 @@ fn gen_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n         text_range,\n         function_builder,\n         insert_offset,\n-        range.file_id,\n+        file,\n         adt_name,\n         label,\n     )\n@@ -156,6 +180,18 @@ fn current_module(current_node: &SyntaxNode, ctx: &AssistContext) -> Option<Modu\n     ctx.sema.scope(current_node).module()\n }\n \n+fn get_adt_source(\n+    ctx: &AssistContext,\n+    adt: &hir::Adt,\n+    fn_name: &str,\n+) -> Option<(Option<ast::Impl>, FileId)> {\n+    let range = adt.source(ctx.sema.db)?.syntax().original_file_range(ctx.sema.db);\n+    let file = ctx.sema.parse(range.file_id);\n+    let adt_source =\n+        ctx.sema.find_node_at_offset_with_macros(file.syntax(), range.range.start())?;\n+    find_struct_impl(ctx, &adt_source, fn_name).map(|impl_| (impl_, range.file_id))\n+}\n+\n struct FunctionTemplate {\n     leading_ws: String,\n     fn_def: ast::Fn,\n@@ -1514,6 +1550,99 @@ fn bar(&self) ${0:-> ()} {\n     todo!()\n }\n }\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn create_static_method() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+struct S;\n+fn foo() {S::bar$0();}\n+\",\n+            r\"\n+struct S;\n+fn foo() {S::bar();}\n+impl S {\n+\n+\n+fn bar() ${0:-> ()} {\n+    todo!()\n+}\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn create_static_method_within_an_impl() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+struct S;\n+fn foo() {S::bar$0();}\n+impl S {}\n+\n+\",\n+            r\"\n+struct S;\n+fn foo() {S::bar();}\n+impl S {\n+    fn bar() ${0:-> ()} {\n+        todo!()\n+    }\n+}\n+\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn create_static_method_from_different_module() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+mod s {\n+    pub struct S;\n+}\n+fn foo() {s::S::bar$0();}\n+\",\n+            r\"\n+mod s {\n+    pub struct S;\n+impl S {\n+\n+\n+    pub(crate) fn bar() ${0:-> ()} {\n+        todo!()\n+    }\n+}\n+}\n+fn foo() {s::S::bar();}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn create_static_method_with_cursor_anywhere_on_call_expresion() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+struct S;\n+fn foo() {$0S::bar();}\n+\",\n+            r\"\n+struct S;\n+fn foo() {S::bar();}\n+impl S {\n+\n+\n+fn bar() ${0:-> ()} {\n+    todo!()\n+}\n+}\n \",\n         )\n     }"}]}