{"sha": "fcde9904dbe7c4426a72b39a49b892eadb5a8940", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjZGU5OTA0ZGJlN2M0NDI2YTcyYjM5YTQ5Yjg5MmVhZGI1YTg5NDA=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2016-11-10T00:05:32Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2016-11-12T22:33:35Z"}, "message": "use msp430-as to emit object files from the assembly that LLVM emits", "tree": {"sha": "32317f818f065150e192c8e538daea39b6e66c1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32317f818f065150e192c8e538daea39b6e66c1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fcde9904dbe7c4426a72b39a49b892eadb5a8940", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fcde9904dbe7c4426a72b39a49b892eadb5a8940", "html_url": "https://github.com/rust-lang/rust/commit/fcde9904dbe7c4426a72b39a49b892eadb5a8940", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fcde9904dbe7c4426a72b39a49b892eadb5a8940/comments", "author": null, "committer": null, "parents": [{"sha": "7b559368699c1d4c0df1e3d813c8a84dba3118aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b559368699c1d4c0df1e3d813c8a84dba3118aa", "html_url": "https://github.com/rust-lang/rust/commit/7b559368699c1d4c0df1e3d813c8a84dba3118aa"}], "stats": {"total": 90, "additions": 83, "deletions": 7}, "files": [{"sha": "f6a0946dd5b8e542e09911216fd0f7595d7e0194", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fcde9904dbe7c4426a72b39a49b892eadb5a8940/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcde9904dbe7c4426a72b39a49b892eadb5a8940/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=fcde9904dbe7c4426a72b39a49b892eadb5a8940", "patch": "@@ -359,6 +359,10 @@ pub struct TargetOptions {\n     // will 'just work'.\n     pub obj_is_bitcode: bool,\n \n+    // LLVM can't produce object files for MSP430. Instead, we'll make LLVM emit\n+    // assembly and then use `msp430-as` to turn that assembly into an object file\n+    pub obj_needs_as: bool,\n+\n     /// Don't use this field; instead use the `.max_atomic_width()` method.\n     pub max_atomic_width: Option<u64>,\n \n@@ -416,6 +420,7 @@ impl Default for TargetOptions {\n             allow_asm: true,\n             has_elf_tls: false,\n             obj_is_bitcode: false,\n+            obj_needs_as: false,\n             max_atomic_width: None,\n             panic_strategy: PanicStrategy::Unwind,\n             abi_blacklist: vec![],\n@@ -576,6 +581,7 @@ impl Target {\n         key!(exe_allocation_crate);\n         key!(has_elf_tls, bool);\n         key!(obj_is_bitcode, bool);\n+        key!(obj_needs_as, bool);\n         key!(max_atomic_width, Option<u64>);\n         try!(key!(panic_strategy, PanicStrategy));\n \n@@ -735,6 +741,7 @@ impl ToJson for Target {\n         target_option_val!(exe_allocation_crate);\n         target_option_val!(has_elf_tls);\n         target_option_val!(obj_is_bitcode);\n+        target_option_val!(obj_needs_as);\n         target_option_val!(max_atomic_width);\n         target_option_val!(panic_strategy);\n "}, {"sha": "0af7c66ccd42a65040ff3cda10a4284c895b6677", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 76, "deletions": 7, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/fcde9904dbe7c4426a72b39a49b892eadb5a8940/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcde9904dbe7c4426a72b39a49b892eadb5a8940/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=fcde9904dbe7c4426a72b39a49b892eadb5a8940", "patch": "@@ -26,6 +26,9 @@ use errors::emitter::Emitter;\n use syntax_pos::MultiSpan;\n use context::{is_pie_binary, get_reloc_model};\n \n+use std::ascii;\n+use std::char;\n+use std::process::Command;\n use std::ffi::{CStr, CString};\n use std::fs;\n use std::path::{Path, PathBuf};\n@@ -262,6 +265,9 @@ pub struct ModuleConfig {\n     // make the object file bitcode. Provides easy compatibility with\n     // emscripten's ecc compiler, when used as the linker.\n     obj_is_bitcode: bool,\n+    // LLVM can't produce object files for MSP430. Instead, we'll make LLVM emit\n+    // assembly and then use `msp430-as` to turn that assembly into an object file\n+    obj_needs_as: bool,\n }\n \n unsafe impl Send for ModuleConfig { }\n@@ -281,6 +287,7 @@ impl ModuleConfig {\n             emit_asm: false,\n             emit_obj: false,\n             obj_is_bitcode: false,\n+            obj_needs_as: false,\n \n             no_verify: false,\n             no_prepopulate_passes: false,\n@@ -300,6 +307,7 @@ impl ModuleConfig {\n         self.time_passes = sess.time_passes();\n         self.inline_threshold = sess.opts.cg.inline_threshold;\n         self.obj_is_bitcode = sess.target.target.options.obj_is_bitcode;\n+        self.obj_needs_as = sess.target.target.options.obj_needs_as;\n \n         // Copy what clang does by turning on loop vectorization at O2 and\n         // slp vectorization at O3. Otherwise configure other optimization aspects\n@@ -557,10 +565,13 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     // machine code, instead copy the .o file from the .bc\n     let write_bc = config.emit_bc || config.obj_is_bitcode;\n     let rm_bc = !config.emit_bc && config.obj_is_bitcode;\n+    let write_asm = config.emit_asm || config.obj_needs_as;\n+    let rm_asm = !config.emit_obj && config.obj_needs_as;\n     let write_obj = config.emit_obj && !config.obj_is_bitcode;\n     let copy_bc_to_obj = config.emit_obj && config.obj_is_bitcode;\n \n     let bc_out = output_names.temp_path(OutputType::Bitcode, module_name);\n+    let asm_out = output_names.temp_path(OutputType::Assembly, module_name);\n     let obj_out = output_names.temp_path(OutputType::Object, module_name);\n \n     if write_bc {\n@@ -578,27 +589,25 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n             })\n         }\n \n-        if config.emit_asm {\n-            let path = output_names.temp_path(OutputType::Assembly, module_name);\n-\n+        if write_asm {\n             // We can't use the same module for asm and binary output, because that triggers\n             // various errors like invalid IR or broken binaries, so we might have to clone the\n             // module to produce the asm output\n-            let llmod = if config.emit_obj {\n+            let llmod = if config.emit_obj && !config.obj_needs_as {\n                 llvm::LLVMCloneModule(llmod)\n             } else {\n                 llmod\n             };\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                write_output_file(cgcx.handler, tm, cpm, llmod, &path,\n+                write_output_file(cgcx.handler, tm, cpm, llmod, &asm_out,\n                                   llvm::FileType::AssemblyFile);\n             });\n-            if config.emit_obj {\n+            if config.emit_obj && !config.obj_needs_as {\n                 llvm::LLVMDisposeModule(llmod);\n             }\n         }\n \n-        if write_obj {\n+        if write_obj && !config.obj_needs_as {\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &obj_out,\n                                   llvm::FileType::ObjectFile);\n@@ -613,13 +622,73 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         }\n     }\n \n+    if config.obj_needs_as {\n+        // XXX most of the logic here has been copied from the link_natively\n+        // function (src/librustc_trans/back/link.rs)\n+        // TODO don't hardcode, maybe expose as a `as` field in the target\n+        // specification\n+        // TODO how to properly access `sess` here?\n+        let mut cmd = Command::new(\"msp430-as\");\n+        cmd.arg(\"-o\");\n+        cmd.arg(obj_out);\n+        cmd.arg(&asm_out);\n+\n+        info!(\"{:?}\", &cmd);\n+        // let prog = time(sess.time_passes(), \"running assembler\",\n+        //                 || cmd.output());\n+        let prog = cmd.output();\n+        match prog {\n+            Ok(prog) => {\n+                fn escape_string(s: &[u8]) -> String {\n+                    str::from_utf8(s).map(|s| s.to_owned())\n+                        .unwrap_or_else(|_| {\n+                            let mut x = \"Non-UTF-8 output: \".to_string();\n+                            x.extend(s.iter()\n+                                     .flat_map(|&b| ascii::escape_default(b))\n+                                     .map(|b| char::from_u32(b as u32).unwrap()));\n+                            x\n+                        })\n+                }\n+                if !prog.status.success() {\n+                    let mut output = prog.stderr.clone();\n+                    output.extend_from_slice(&prog.stdout);\n+                    // sess.struct_err(&format!(\"assembling with `msp430-as` failed: {}\",\n+                    //                          prog.status))\n+                    //     .note(&format!(\"{:?}\", &cmd))\n+                    //     .note(&escape_string(&output[..]))\n+                    //     .emit();\n+                    // sess.abort_if_errors();\n+                }\n+                info!(\"linker stderr:\\n{}\", escape_string(&prog.stderr[..]));\n+                info!(\"linker stdout:\\n{}\", escape_string(&prog.stdout[..]));\n+            },\n+            Err(_) => {\n+                // sess.struct_err(&format!(\"could not exec the assembler `msp430-as`: {}\", e))\n+                //     .note(&format!(\"{:?}\", &cmd))\n+                //     .emit();\n+                // if e.kind() == io::ErrorKind::NotFound {\n+                //     sess.note_without_error(\"MSP430 targets depend on the MSP430 assembler \\\n+                //                              but `msp430-as` was not found\");\n+                // }\n+                // sess.abort_if_errors();\n+            },\n+        }\n+    }\n+\n     if rm_bc {\n         debug!(\"removing_bitcode {:?}\", bc_out);\n         if let Err(e) = fs::remove_file(&bc_out) {\n             cgcx.handler.err(&format!(\"failed to remove bitcode: {}\", e));\n         }\n     }\n \n+    if rm_asm {\n+        debug!(\"removing_assembly {:?}\", bc_out);\n+        if let Err(e) = fs::remove_file(&asm_out) {\n+            cgcx.handler.err(&format!(\"failed to remove assembly: {}\", e));\n+        }\n+    }\n+\n     llvm::LLVMRustDisposeTargetMachine(tm);\n }\n "}]}