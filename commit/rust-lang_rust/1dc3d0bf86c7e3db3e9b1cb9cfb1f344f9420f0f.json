{"sha": "1dc3d0bf86c7e3db3e9b1cb9cfb1f344f9420f0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkYzNkMGJmODZjN2UzZGIzZTliMWNiOWNmYjFmMzQ0Zjk0MjBmMGY=", "commit": {"author": {"name": "Georges Dubus", "email": "georges.dubus@compiletoi.net", "date": "2013-10-18T20:51:57Z"}, "committer": {"name": "Georges Dubus", "email": "georges.dubus@compiletoi.net", "date": "2013-10-21T19:58:34Z"}, "message": "Add support for nested comments\n\nFixes #9468.", "tree": {"sha": "32542a3752890539ccd9982df86ee153e079b335", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32542a3752890539ccd9982df86ee153e079b335"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1dc3d0bf86c7e3db3e9b1cb9cfb1f344f9420f0f", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1dc3d0bf86c7e3db3e9b1cb9cfb1f344f9420f0f", "html_url": "https://github.com/rust-lang/rust/commit/1dc3d0bf86c7e3db3e9b1cb9cfb1f344f9420f0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1dc3d0bf86c7e3db3e9b1cb9cfb1f344f9420f0f/comments", "author": {"login": "madjar", "id": 109141, "node_id": "MDQ6VXNlcjEwOTE0MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/109141?v=4", "gravatar_id": "", "url": "https://api.github.com/users/madjar", "html_url": "https://github.com/madjar", "followers_url": "https://api.github.com/users/madjar/followers", "following_url": "https://api.github.com/users/madjar/following{/other_user}", "gists_url": "https://api.github.com/users/madjar/gists{/gist_id}", "starred_url": "https://api.github.com/users/madjar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/madjar/subscriptions", "organizations_url": "https://api.github.com/users/madjar/orgs", "repos_url": "https://api.github.com/users/madjar/repos", "events_url": "https://api.github.com/users/madjar/events{/privacy}", "received_events_url": "https://api.github.com/users/madjar/received_events", "type": "User", "site_admin": false}, "committer": {"login": "madjar", "id": 109141, "node_id": "MDQ6VXNlcjEwOTE0MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/109141?v=4", "gravatar_id": "", "url": "https://api.github.com/users/madjar", "html_url": "https://github.com/madjar", "followers_url": "https://api.github.com/users/madjar/followers", "following_url": "https://api.github.com/users/madjar/following{/other_user}", "gists_url": "https://api.github.com/users/madjar/gists{/gist_id}", "starred_url": "https://api.github.com/users/madjar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/madjar/subscriptions", "organizations_url": "https://api.github.com/users/madjar/orgs", "repos_url": "https://api.github.com/users/madjar/repos", "events_url": "https://api.github.com/users/madjar/events{/privacy}", "received_events_url": "https://api.github.com/users/madjar/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69e46f3aa922fa651fe53b36a295011c590f09e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/69e46f3aa922fa651fe53b36a295011c590f09e4", "html_url": "https://github.com/rust-lang/rust/commit/69e46f3aa922fa651fe53b36a295011c590f09e4"}], "stats": {"total": 145, "additions": 70, "deletions": 75}, "files": [{"sha": "cdcb730e8bed5f5cba49df2a599b12f96d915abe", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1dc3d0bf86c7e3db3e9b1cb9cfb1f344f9420f0f/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc3d0bf86c7e3db3e9b1cb9cfb1f344f9420f0f/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=1dc3d0bf86c7e3db3e9b1cb9cfb1f344f9420f0f", "patch": "@@ -39,32 +39,32 @@ pub struct GlobIterator {\n     priv todo: ~[(Path,uint)]\n }\n \n-/**\n- * Return an iterator that produces all the Paths that match the given pattern,\n- * which may be absolute or relative to the current working directory.\n- *\n- * This method uses the default match options and is equivalent to calling\n- * `glob_with(pattern, MatchOptions::new())`. Use `glob_with` directly if you\n- * want to use non-default match options.\n- *\n- * # Example\n- *\n- * Consider a directory `/media/pictures` containing only the files `kittens.jpg`,\n- * `puppies.jpg` and `hamsters.gif`:\n- *\n- * ```rust\n- * for path in glob(\"/media/pictures/*.jpg\") {\n- *     println(path.to_str());\n- * }\n- * ```\n- *\n- * The above code will print:\n- *\n- * ```\n- * /media/pictures/kittens.jpg\n- * /media/pictures/puppies.jpg\n- * ```\n- */\n+///\n+/// Return an iterator that produces all the Paths that match the given pattern,\n+/// which may be absolute or relative to the current working directory.\n+///\n+/// is method uses the default match options and is equivalent to calling\n+/// `glob_with(pattern, MatchOptions::new())`. Use `glob_with` directly if you\n+/// want to use non-default match options.\n+///\n+/// # Example\n+///\n+/// Consider a directory `/media/pictures` containing only the files `kittens.jpg`,\n+/// `puppies.jpg` and `hamsters.gif`:\n+///\n+/// ```rust\n+/// for path in glob(\"/media/pictures/*.jpg\") {\n+///     println(path.to_str());\n+/// }\n+/// ```\n+///\n+/// The above code will print:\n+///\n+/// ```\n+/// /media/pictures/kittens.jpg\n+/// /media/pictures/puppies.jpg\n+/// ```\n+///\n pub fn glob(pattern: &str) -> GlobIterator {\n     glob_with(pattern, MatchOptions::new())\n }"}, {"sha": "6f68e293dac2ff6273594aead2fa6811a3055a57", "filename": "src/libstd/os.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1dc3d0bf86c7e3db3e9b1cb9cfb1f344f9420f0f/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc3d0bf86c7e3db3e9b1cb9cfb1f344f9420f0f/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=1dc3d0bf86c7e3db3e9b1cb9cfb1f344f9420f0f", "patch": "@@ -516,12 +516,6 @@ pub fn self_exe_path() -> Option<Path> {\n     load_self().and_then(|path| Path::new_opt(path).map(|mut p| { p.pop(); p }))\n }\n \n-\n-/**\n- * Returns the path to the user's home directory, if known.\n-}\n-\n-\n /**\n  * Returns the path to the user's home directory, if known.\n  *"}, {"sha": "8edc171fcacacf8c8e1c9974415532e83a42ec7d", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 41, "deletions": 33, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1dc3d0bf86c7e3db3e9b1cb9cfb1f344f9420f0f/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc3d0bf86c7e3db3e9b1cb9cfb1f344f9420f0f/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=1dc3d0bf86c7e3db3e9b1cb9cfb1f344f9420f0f", "patch": "@@ -373,49 +373,49 @@ pub fn is_block_non_doc_comment(s: &str) -> bool {\n fn consume_block_comment(rdr: @mut StringReader)\n                       -> Option<TokenAndSpan> {\n     // block comments starting with \"/**\" or \"/*!\" are doc-comments\n-    let res = if rdr.curr == '*' || rdr.curr == '!' {\n-        let start_bpos = rdr.pos - BytePos(3u);\n-        while !(rdr.curr == '*' && nextch(rdr) == '/') && !is_eof(rdr) {\n-            bump(rdr);\n-        }\n+    let is_doc_comment = rdr.curr == '*' || rdr.curr == '!';\n+    let start_bpos = rdr.pos - BytePos(if is_doc_comment {3u} else {2u});\n+\n+    let mut level: int = 1;\n+    while level > 0 {\n         if is_eof(rdr) {\n-            fatal_span(rdr, start_bpos, rdr.last_pos,\n-                       ~\"unterminated block doc-comment\");\n-        } else {\n+            let msg = if is_doc_comment {\n+                ~\"unterminated block doc-comment\"\n+            } else {\n+                ~\"unterminated block comment\"\n+            };\n+            fatal_span(rdr, start_bpos, rdr.last_pos, msg);\n+        } else if rdr.curr == '/' && nextch(rdr) == '*' {\n+            level += 1;\n             bump(rdr);\n             bump(rdr);\n-            do with_str_from(rdr, start_bpos) |string| {\n-                // but comments with only \"*\"s between two \"/\"s are not\n-                if !is_block_non_doc_comment(string) {\n-                    Some(TokenAndSpan{\n-                         tok: token::DOC_COMMENT(str_to_ident(string)),\n-                         sp: codemap::mk_sp(start_bpos, rdr.pos)\n-                         })\n-                } else {\n-                    None\n-                }\n-            }\n+        } else if rdr.curr == '*' && nextch(rdr) == '/' {\n+            level -= 1;\n+            bump(rdr);\n+            bump(rdr);\n+        } else {\n+            bump(rdr);\n         }\n-    } else {\n-        let start_bpos = rdr.last_pos - BytePos(2u);\n-        loop {\n-            if is_eof(rdr) {\n-                fatal_span(rdr, start_bpos, rdr.last_pos,\n-                           ~\"unterminated block comment\");\n-            }\n-            if rdr.curr == '*' && nextch(rdr) == '/' {\n-                bump(rdr);\n-                bump(rdr);\n-                break;\n+    }\n+\n+    let res = if is_doc_comment {\n+        do with_str_from(rdr, start_bpos) |string| {\n+            // but comments with only \"*\"s between two \"/\"s are not\n+            if !is_block_non_doc_comment(string) {\n+                Some(TokenAndSpan{\n+                        tok: token::DOC_COMMENT(str_to_ident(string)),\n+                        sp: codemap::mk_sp(start_bpos, rdr.pos)\n+                    })\n             } else {\n-                bump(rdr);\n+                None\n             }\n         }\n+    } else {\n         None\n     };\n-    // restart whitespace munch.\n \n-   if res.is_some() { res } else { consume_whitespace_and_comments(rdr) }\n+    // restart whitespace munch.\n+    if res.is_some() { res } else { consume_whitespace_and_comments(rdr) }\n }\n \n fn scan_exponent(rdr: @mut StringReader, start_bpos: BytePos) -> Option<~str> {\n@@ -1056,4 +1056,12 @@ mod test {\n         assert!(!is_line_non_doc_comment(\"/// blah\"));\n         assert!(is_line_non_doc_comment(\"////\"));\n     }\n+\n+    #[test] fn nested_block_comments() {\n+        let env = setup(@\"/* /* */ */'a'\");\n+        let TokenAndSpan {tok, sp: _} =\n+            env.string_reader.next_token();\n+        assert_eq!(tok,token::LIT_CHAR('a' as u32));\n+    }\n+\n }"}, {"sha": "0cbe46cb4ef17e9c691da6716b17d9c4dedcd0f4", "filename": "src/test/run-pass/nested-block-comment.rs", "status": "renamed", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1dc3d0bf86c7e3db3e9b1cb9cfb1f344f9420f0f/src%2Ftest%2Frun-pass%2Fnested-block-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc3d0bf86c7e3db3e9b1cb9cfb1f344f9420f0f/src%2Ftest%2Frun-pass%2Fnested-block-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-block-comment.rs?ref=1dc3d0bf86c7e3db3e9b1cb9cfb1f344f9420f0f", "patch": "@@ -8,19 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:\n-\n-/* This is a test to ensure that we do _not_ support nested/balanced comments. I know you might be\n-   thinking \"but nested comments are cool\", and that would be a valid point, but they are also a\n-   thing that would make our lexical syntax non-regular, and we do not want that to be true.\n-\n-   omitting-things at a higher level (tokens) should be done via token-trees / macros,\n-   not comments.\n+/* This test checks that nested comments are supported\n \n    /*\n-     fail here\n+     This should not fail\n    */\n */\n \n-fn main() {\n+pub fn main() {\n }", "previous_filename": "src/test/compile-fail/no-comment-balancing.rs"}]}