{"sha": "34e6673a0473e90ef01a18eb575392c9e3859747", "node_id": "C_kwDOAAsO6NoAKDM0ZTY2NzNhMDQ3M2U5MGVmMDFhMThlYjU3NTM5MmM5ZTM4NTk3NDc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-25T19:43:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-25T19:43:00Z"}, "message": "Auto merge of #107405 - hermitcore:bsd, r=bjorn3\n\nadd support of RustyHermit's BSD socket layer\n\nRustyHermit is a tier 3 platform and publishes a new kernel interface. The new version supports a common BSD socket layer. By supporting this interface, the implementation of `std` can be harmonized to other operating systems. In `sys_common/mod.rs` we remove only a special case for RustyHermit. All changes are done in the RustyHermit specific directories.\n\nTo realize this socket layer, the handling of file descriptors is also harmonized to other operating systems.", "tree": {"sha": "15737c17919b7bd59f16f743150d8aac9af6096f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15737c17919b7bd59f16f743150d8aac9af6096f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34e6673a0473e90ef01a18eb575392c9e3859747", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34e6673a0473e90ef01a18eb575392c9e3859747", "html_url": "https://github.com/rust-lang/rust/commit/34e6673a0473e90ef01a18eb575392c9e3859747", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34e6673a0473e90ef01a18eb575392c9e3859747/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31448badfd74ea72d2c8622cc60d3dca889ef7d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/31448badfd74ea72d2c8622cc60d3dca889ef7d4", "html_url": "https://github.com/rust-lang/rust/commit/31448badfd74ea72d2c8622cc60d3dca889ef7d4"}, {"sha": "af8ee641a84d9b56c97ecc1deddcd2c7aa5fc4d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/af8ee641a84d9b56c97ecc1deddcd2c7aa5fc4d4", "html_url": "https://github.com/rust-lang/rust/commit/af8ee641a84d9b56c97ecc1deddcd2c7aa5fc4d4"}], "stats": {"total": 1072, "additions": 594, "deletions": 478}, "files": [{"sha": "d86b8018b7979d22ac6697f4313a956f1f40a0a7", "filename": "Cargo.lock", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/34e6673a0473e90ef01a18eb575392c9e3859747/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/34e6673a0473e90ef01a18eb575392c9e3859747/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=34e6673a0473e90ef01a18eb575392c9e3859747", "patch": "@@ -1927,8 +1927,16 @@ version = \"0.2.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ee512640fe35acbfb4bb779db6f0d80704c2cacfa2e39b601ef3e3f47d1ae4c7\"\n dependencies = [\n- \"compiler_builtins\",\n  \"libc\",\n+]\n+\n+[[package]]\n+name = \"hermit-abi\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"856b5cb0902c2b6d65d5fd97dfa30f9b70c7538e770b98eab5ed52d8db923e01\"\n+dependencies = [\n+ \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n ]\n@@ -5294,7 +5302,7 @@ dependencies = [\n  \"dlmalloc\",\n  \"fortanix-sgx-abi\",\n  \"hashbrown 0.12.3\",\n- \"hermit-abi 0.2.6\",\n+ \"hermit-abi 0.3.0\",\n  \"libc\",\n  \"miniz_oxide\",\n  \"object 0.29.0\","}, {"sha": "311b2e21c17a6ad6f561cff85fa8c0e1621799be", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=34e6673a0473e90ef01a18eb575392c9e3859747", "patch": "@@ -43,7 +43,7 @@ dlmalloc = { version = \"0.2.3\", features = ['rustc-dep-of-std'] }\n fortanix-sgx-abi = { version = \"0.5.0\", features = ['rustc-dep-of-std'] }\n \n [target.'cfg(target_os = \"hermit\")'.dependencies]\n-hermit-abi = { version = \"0.2.6\", features = ['rustc-dep-of-std'] }\n+hermit-abi = { version = \"0.3.0\", features = ['rustc-dep-of-std'] }\n \n [target.wasm32-wasi.dependencies]\n wasi = { version = \"0.11.0\", features = ['rustc-dep-of-std'], default-features = false }"}, {"sha": "258919d53a4ec9725a96889407f060a9fffbcc65", "filename": "library/std/src/os/fd/owned.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs?ref=34e6673a0473e90ef01a18eb575392c9e3859747", "patch": "@@ -9,7 +9,7 @@ use crate::fs;\n use crate::io;\n use crate::marker::PhantomData;\n use crate::mem::forget;\n-#[cfg(not(any(target_arch = \"wasm32\", target_env = \"sgx\")))]\n+#[cfg(not(any(target_arch = \"wasm32\", target_env = \"sgx\", target_os = \"hermit\")))]\n use crate::sys::cvt;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n@@ -89,7 +89,7 @@ impl OwnedFd {\n impl BorrowedFd<'_> {\n     /// Creates a new `OwnedFd` instance that shares the same underlying file\n     /// description as the existing `BorrowedFd` instance.\n-    #[cfg(not(target_arch = \"wasm32\"))]\n+    #[cfg(not(any(target_arch = \"wasm32\", target_os = \"hermit\")))]\n     #[stable(feature = \"io_safety\", since = \"1.63.0\")]\n     pub fn try_clone_to_owned(&self) -> crate::io::Result<OwnedFd> {\n         // We want to atomically duplicate this file descriptor and set the\n@@ -112,7 +112,7 @@ impl BorrowedFd<'_> {\n \n     /// Creates a new `OwnedFd` instance that shares the same underlying file\n     /// description as the existing `BorrowedFd` instance.\n-    #[cfg(target_arch = \"wasm32\")]\n+    #[cfg(any(target_arch = \"wasm32\", target_os = \"hermit\"))]\n     #[stable(feature = \"io_safety\", since = \"1.63.0\")]\n     pub fn try_clone_to_owned(&self) -> crate::io::Result<OwnedFd> {\n         Err(crate::io::const_io_error!(\n@@ -174,7 +174,10 @@ impl Drop for OwnedFd {\n             // the file descriptor was closed or not, and if we retried (for\n             // something like EINTR), we might close another valid file descriptor\n             // opened after we closed ours.\n+            #[cfg(not(target_os = \"hermit\"))]\n             let _ = libc::close(self.fd);\n+            #[cfg(target_os = \"hermit\")]\n+            let _ = hermit_abi::close(self.fd);\n         }\n     }\n }"}, {"sha": "0a4cefd209558434559092a1ab7705a5e8efa45a", "filename": "library/std/src/os/fd/raw.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fraw.rs?ref=34e6673a0473e90ef01a18eb575392c9e3859747", "patch": "@@ -4,6 +4,9 @@\n \n use crate::fs;\n use crate::io;\n+#[cfg(target_os = \"hermit\")]\n+use crate::os::hermit::io::OwnedFd;\n+#[cfg(not(target_os = \"hermit\"))]\n use crate::os::raw;\n #[cfg(all(doc, not(target_arch = \"wasm32\")))]\n use crate::os::unix::io::AsFd;\n@@ -12,11 +15,18 @@ use crate::os::unix::io::OwnedFd;\n #[cfg(target_os = \"wasi\")]\n use crate::os::wasi::io::OwnedFd;\n use crate::sys_common::{AsInner, IntoInner};\n+#[cfg(target_os = \"hermit\")]\n+use hermit_abi as libc;\n \n /// Raw file descriptors.\n #[rustc_allowed_through_unstable_modules]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(target_os = \"hermit\"))]\n pub type RawFd = raw::c_int;\n+#[rustc_allowed_through_unstable_modules]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(target_os = \"hermit\")]\n+pub type RawFd = i32;\n \n /// A trait to extract the raw file descriptor from an underlying object.\n ///"}, {"sha": "524dfae0d63aeacac38da4f2c26b927eb7553962", "filename": "library/std/src/os/hermit/io/mod.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fos%2Fhermit%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fos%2Fhermit%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fhermit%2Fio%2Fmod.rs?ref=34e6673a0473e90ef01a18eb575392c9e3859747", "patch": "@@ -0,0 +1,13 @@\n+#![stable(feature = \"os_fd\", since = \"1.66.0\")]\n+\n+mod net;\n+#[path = \"../../fd/owned.rs\"]\n+mod owned;\n+#[path = \"../../fd/raw.rs\"]\n+mod raw;\n+\n+// Export the types and traits for the public API.\n+#[stable(feature = \"os_fd\", since = \"1.66.0\")]\n+pub use owned::*;\n+#[stable(feature = \"os_fd\", since = \"1.66.0\")]\n+pub use raw::*;"}, {"sha": "8f3802d7873dc485bcdad6c6cbc1f4ce641f4c23", "filename": "library/std/src/os/hermit/io/net.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fos%2Fhermit%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fos%2Fhermit%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fhermit%2Fio%2Fnet.rs?ref=34e6673a0473e90ef01a18eb575392c9e3859747", "patch": "@@ -0,0 +1,46 @@\n+use crate::os::hermit::io::OwnedFd;\n+use crate::os::hermit::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n+use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n+use crate::{net, sys};\n+\n+macro_rules! impl_as_raw_fd {\n+    ($($t:ident)*) => {$(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl AsRawFd for net::$t {\n+            #[inline]\n+            fn as_raw_fd(&self) -> RawFd {\n+                self.as_inner().socket().as_raw_fd()\n+            }\n+        }\n+    )*};\n+}\n+impl_as_raw_fd! { TcpStream TcpListener UdpSocket }\n+\n+macro_rules! impl_from_raw_fd {\n+    ($($t:ident)*) => {$(\n+        #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+        impl FromRawFd for net::$t {\n+            #[inline]\n+            unsafe fn from_raw_fd(fd: RawFd) -> net::$t {\n+                unsafe {\n+                    let socket = sys::net::Socket::from_inner(FromInner::from_inner(OwnedFd::from_raw_fd(fd)));\n+                    net::$t::from_inner(sys_common::net::$t::from_inner(socket))\n+                }\n+            }\n+        }\n+    )*};\n+}\n+impl_from_raw_fd! { TcpStream TcpListener UdpSocket }\n+\n+macro_rules! impl_into_raw_fd {\n+    ($($t:ident)*) => {$(\n+        #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+        impl IntoRawFd for net::$t {\n+            #[inline]\n+            fn into_raw_fd(self) -> RawFd {\n+                self.into_inner().into_socket().into_inner().into_inner().into_raw_fd()\n+            }\n+        }\n+    )*};\n+}\n+impl_into_raw_fd! { TcpStream TcpListener UdpSocket }"}, {"sha": "89b1b831912dfc7e5c084bf10768e268f5fcf37a", "filename": "library/std/src/os/hermit/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fos%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fos%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fhermit%2Fmod.rs?ref=34e6673a0473e90ef01a18eb575392c9e3859747", "patch": "@@ -1,6 +1,11 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+#[allow(unused_extern_crates)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub extern crate hermit_abi as abi;\n+\n pub mod ffi;\n+pub mod io;\n \n /// A prelude for conveniently writing platform-specific code.\n ///"}, {"sha": "af137c9bd8563ad310356e851b6b11af880dc3f5", "filename": "library/std/src/os/mod.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fmod.rs?ref=34e6673a0473e90ef01a18eb575392c9e3859747", "patch": "@@ -60,16 +60,6 @@ pub mod windows {}\n         all(target_vendor = \"fortanix\", target_env = \"sgx\")\n     )\n )))]\n-#[cfg(target_os = \"hermit\")]\n-#[path = \"hermit/mod.rs\"]\n-pub mod unix;\n-#[cfg(not(all(\n-    doc,\n-    any(\n-        all(target_arch = \"wasm32\", not(target_os = \"wasi\")),\n-        all(target_vendor = \"fortanix\", target_env = \"sgx\")\n-    )\n-)))]\n #[cfg(all(not(target_os = \"hermit\"), any(unix, doc)))]\n pub mod unix;\n \n@@ -123,6 +113,8 @@ pub mod freebsd;\n pub mod fuchsia;\n #[cfg(target_os = \"haiku\")]\n pub mod haiku;\n+#[cfg(target_os = \"hermit\")]\n+pub mod hermit;\n #[cfg(target_os = \"horizon\")]\n pub mod horizon;\n #[cfg(target_os = \"illumos\")]"}, {"sha": "220a76e4b1237b4e5ee324e64ebc9334f9bff714", "filename": "library/std/src/sys/hermit/args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fargs.rs?ref=34e6673a0473e90ef01a18eb575392c9e3859747", "patch": "@@ -1,6 +1,6 @@\n use crate::ffi::{c_char, CStr, OsString};\n use crate::fmt;\n-use crate::os::unix::ffi::OsStringExt;\n+use crate::os::hermit::ffi::OsStringExt;\n use crate::ptr;\n use crate::sync::atomic::{\n     AtomicIsize, AtomicPtr,"}, {"sha": "3a2cdd301ea45c16eabb6916d28e868840f53d45", "filename": "library/std/src/sys/hermit/fd.rs", "status": "modified", "additions": 45, "deletions": 32, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffd.rs?ref=34e6673a0473e90ef01a18eb575392c9e3859747", "patch": "@@ -1,36 +1,23 @@\n #![unstable(reason = \"not public\", issue = \"none\", feature = \"fd\")]\n \n use crate::io::{self, Read};\n-use crate::mem;\n+use crate::os::hermit::io::{FromRawFd, OwnedFd, RawFd};\n use crate::sys::cvt;\n use crate::sys::hermit::abi;\n use crate::sys::unsupported;\n-use crate::sys_common::AsInner;\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n+\n+use crate::os::hermit::io::*;\n \n #[derive(Debug)]\n pub struct FileDesc {\n-    fd: i32,\n+    fd: OwnedFd,\n }\n \n impl FileDesc {\n-    pub fn new(fd: i32) -> FileDesc {\n-        FileDesc { fd }\n-    }\n-\n-    pub fn raw(&self) -> i32 {\n-        self.fd\n-    }\n-\n-    /// Extracts the actual file descriptor without closing it.\n-    pub fn into_raw(self) -> i32 {\n-        let fd = self.fd;\n-        mem::forget(self);\n-        fd\n-    }\n-\n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        let result = unsafe { abi::read(self.fd, buf.as_mut_ptr(), buf.len()) };\n-        cvt(result as i32)\n+        let result = cvt(unsafe { abi::read(self.fd.as_raw_fd(), buf.as_mut_ptr(), buf.len()) })?;\n+        Ok(result as usize)\n     }\n \n     pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n@@ -39,8 +26,8 @@ impl FileDesc {\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        let result = unsafe { abi::write(self.fd, buf.as_ptr(), buf.len()) };\n-        cvt(result as i32)\n+        let result = cvt(unsafe { abi::write(self.fd.as_raw_fd(), buf.as_ptr(), buf.len()) })?;\n+        Ok(result as usize)\n     }\n \n     pub fn duplicate(&self) -> io::Result<FileDesc> {\n@@ -69,19 +56,45 @@ impl<'a> Read for &'a FileDesc {\n     }\n }\n \n-impl AsInner<i32> for FileDesc {\n-    fn as_inner(&self) -> &i32 {\n+impl IntoInner<OwnedFd> for FileDesc {\n+    fn into_inner(self) -> OwnedFd {\n+        self.fd\n+    }\n+}\n+\n+impl FromInner<OwnedFd> for FileDesc {\n+    fn from_inner(owned_fd: OwnedFd) -> Self {\n+        Self { fd: owned_fd }\n+    }\n+}\n+\n+impl FromRawFd for FileDesc {\n+    unsafe fn from_raw_fd(raw_fd: RawFd) -> Self {\n+        Self { fd: FromRawFd::from_raw_fd(raw_fd) }\n+    }\n+}\n+\n+impl AsInner<OwnedFd> for FileDesc {\n+    fn as_inner(&self) -> &OwnedFd {\n         &self.fd\n     }\n }\n \n-impl Drop for FileDesc {\n-    fn drop(&mut self) {\n-        // Note that errors are ignored when closing a file descriptor. The\n-        // reason for this is that if an error occurs we don't actually know if\n-        // the file descriptor was closed or not, and if we retried (for\n-        // something like EINTR), we might close another valid file descriptor\n-        // (opened after we closed ours.\n-        let _ = unsafe { abi::close(self.fd) };\n+impl AsFd for FileDesc {\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.fd.as_fd()\n+    }\n+}\n+\n+impl AsRawFd for FileDesc {\n+    #[inline]\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.fd.as_raw_fd()\n+    }\n+}\n+\n+impl IntoRawFd for FileDesc {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.fd.into_raw_fd()\n     }\n }"}, {"sha": "c966f217757274223b8c4153016362a4966ef1cf", "filename": "library/std/src/sys/hermit/fs.rs", "status": "modified", "additions": 54, "deletions": 3, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs?ref=34e6673a0473e90ef01a18eb575392c9e3859747", "patch": "@@ -3,14 +3,17 @@ use crate::fmt;\n use crate::hash::{Hash, Hasher};\n use crate::io::{self, Error, ErrorKind};\n use crate::io::{BorrowedCursor, IoSlice, IoSliceMut, SeekFrom};\n+use crate::os::hermit::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, RawFd};\n use crate::path::{Path, PathBuf};\n use crate::sys::common::small_c_string::run_path_with_cstr;\n use crate::sys::cvt;\n-use crate::sys::hermit::abi;\n-use crate::sys::hermit::abi::{O_APPEND, O_CREAT, O_EXCL, O_RDONLY, O_RDWR, O_TRUNC, O_WRONLY};\n+use crate::sys::hermit::abi::{\n+    self, O_APPEND, O_CREAT, O_EXCL, O_RDONLY, O_RDWR, O_TRUNC, O_WRONLY,\n+};\n use crate::sys::hermit::fd::FileDesc;\n use crate::sys::time::SystemTime;\n use crate::sys::unsupported;\n+use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n \n pub use crate::sys_common::fs::{copy, try_exists};\n //pub use crate::sys_common::fs::remove_dir_all;\n@@ -283,7 +286,7 @@ impl File {\n         }\n \n         let fd = unsafe { cvt(abi::open(path.as_ptr(), flags, mode))? };\n-        Ok(File(FileDesc::new(fd as i32)))\n+        Ok(File(unsafe { FileDesc::from_raw_fd(fd as i32) }))\n     }\n \n     pub fn file_attr(&self) -> io::Result<FileAttr> {\n@@ -363,6 +366,54 @@ impl DirBuilder {\n     }\n }\n \n+impl AsInner<FileDesc> for File {\n+    fn as_inner(&self) -> &FileDesc {\n+        &self.0\n+    }\n+}\n+\n+impl AsInnerMut<FileDesc> for File {\n+    fn as_inner_mut(&mut self) -> &mut FileDesc {\n+        &mut self.0\n+    }\n+}\n+\n+impl IntoInner<FileDesc> for File {\n+    fn into_inner(self) -> FileDesc {\n+        self.0\n+    }\n+}\n+\n+impl FromInner<FileDesc> for File {\n+    fn from_inner(file_desc: FileDesc) -> Self {\n+        Self(file_desc)\n+    }\n+}\n+\n+impl AsFd for File {\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.0.as_fd()\n+    }\n+}\n+\n+impl AsRawFd for File {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.0.as_raw_fd()\n+    }\n+}\n+\n+impl IntoRawFd for File {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_raw_fd()\n+    }\n+}\n+\n+impl FromRawFd for File {\n+    unsafe fn from_raw_fd(raw_fd: RawFd) -> Self {\n+        Self(FromRawFd::from_raw_fd(raw_fd))\n+    }\n+}\n+\n pub fn readdir(_p: &Path) -> io::Result<ReadDir> {\n     unsupported()\n }"}, {"sha": "d34a4cfedea783877477c07b7f5849cd485c2fae", "filename": "library/std/src/sys/hermit/mod.rs", "status": "modified", "additions": 66, "deletions": 21, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs?ref=34e6673a0473e90ef01a18eb575392c9e3859747", "patch": "@@ -13,7 +13,7 @@\n //! compiling for wasm. That way it's a compile time error for something that's\n //! guaranteed to be a runtime error!\n \n-#![allow(unsafe_op_in_unsafe_fn)]\n+#![allow(missing_docs, nonstandard_style, unsafe_op_in_unsafe_fn)]\n \n use crate::intrinsics;\n use crate::os::raw::c_char;\n@@ -57,9 +57,7 @@ pub mod locks {\n }\n \n use crate::io::ErrorKind;\n-\n-#[allow(unused_extern_crates)]\n-pub extern crate hermit_abi as abi;\n+use crate::os::hermit::abi;\n \n pub fn unsupported<T>() -> crate::io::Result<T> {\n     Err(unsupported_err())\n@@ -126,25 +124,72 @@ pub unsafe extern \"C\" fn runtime_entry(\n \n pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     match errno {\n-        x if x == 13 as i32 => ErrorKind::PermissionDenied,\n-        x if x == 98 as i32 => ErrorKind::AddrInUse,\n-        x if x == 99 as i32 => ErrorKind::AddrNotAvailable,\n-        x if x == 11 as i32 => ErrorKind::WouldBlock,\n-        x if x == 103 as i32 => ErrorKind::ConnectionAborted,\n-        x if x == 111 as i32 => ErrorKind::ConnectionRefused,\n-        x if x == 104 as i32 => ErrorKind::ConnectionReset,\n-        x if x == 17 as i32 => ErrorKind::AlreadyExists,\n-        x if x == 4 as i32 => ErrorKind::Interrupted,\n-        x if x == 22 as i32 => ErrorKind::InvalidInput,\n-        x if x == 2 as i32 => ErrorKind::NotFound,\n-        x if x == 107 as i32 => ErrorKind::NotConnected,\n-        x if x == 1 as i32 => ErrorKind::PermissionDenied,\n-        x if x == 32 as i32 => ErrorKind::BrokenPipe,\n-        x if x == 110 as i32 => ErrorKind::TimedOut,\n+        abi::errno::EACCES => ErrorKind::PermissionDenied,\n+        abi::errno::EADDRINUSE => ErrorKind::AddrInUse,\n+        abi::errno::EADDRNOTAVAIL => ErrorKind::AddrNotAvailable,\n+        abi::errno::EAGAIN => ErrorKind::WouldBlock,\n+        abi::errno::ECONNABORTED => ErrorKind::ConnectionAborted,\n+        abi::errno::ECONNREFUSED => ErrorKind::ConnectionRefused,\n+        abi::errno::ECONNRESET => ErrorKind::ConnectionReset,\n+        abi::errno::EEXIST => ErrorKind::AlreadyExists,\n+        abi::errno::EINTR => ErrorKind::Interrupted,\n+        abi::errno::EINVAL => ErrorKind::InvalidInput,\n+        abi::errno::ENOENT => ErrorKind::NotFound,\n+        abi::errno::ENOTCONN => ErrorKind::NotConnected,\n+        abi::errno::EPERM => ErrorKind::PermissionDenied,\n+        abi::errno::EPIPE => ErrorKind::BrokenPipe,\n+        abi::errno::ETIMEDOUT => ErrorKind::TimedOut,\n         _ => ErrorKind::Uncategorized,\n     }\n }\n \n-pub fn cvt(result: i32) -> crate::io::Result<usize> {\n-    if result < 0 { Err(crate::io::Error::from_raw_os_error(-result)) } else { Ok(result as usize) }\n+#[doc(hidden)]\n+pub trait IsNegative {\n+    fn is_negative(&self) -> bool;\n+    fn negate(&self) -> i32;\n+}\n+\n+macro_rules! impl_is_negative {\n+    ($($t:ident)*) => ($(impl IsNegative for $t {\n+        fn is_negative(&self) -> bool {\n+            *self < 0\n+        }\n+\n+        fn negate(&self) -> i32 {\n+            i32::try_from(-(*self)).unwrap()\n+        }\n+    })*)\n+}\n+\n+impl IsNegative for i32 {\n+    fn is_negative(&self) -> bool {\n+        *self < 0\n+    }\n+\n+    fn negate(&self) -> i32 {\n+        -(*self)\n+    }\n+}\n+impl_is_negative! { i8 i16 i64 isize }\n+\n+pub fn cvt<T: IsNegative>(t: T) -> crate::io::Result<T> {\n+    if t.is_negative() {\n+        let e = decode_error_kind(t.negate());\n+        Err(crate::io::Error::from(e))\n+    } else {\n+        Ok(t)\n+    }\n+}\n+\n+pub fn cvt_r<T, F>(mut f: F) -> crate::io::Result<T>\n+where\n+    T: IsNegative,\n+    F: FnMut() -> T,\n+{\n+    loop {\n+        match cvt(f()) {\n+            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n+            other => return other,\n+        }\n+    }\n }"}, {"sha": "5fb6281aa1e3d5f76ac0fdd4cba3e85a9c5d8cef", "filename": "library/std/src/sys/hermit/net.rs", "status": "modified", "additions": 251, "deletions": 388, "changes": 639, "blob_url": "https://github.com/rust-lang/rust/blob/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fnet.rs?ref=34e6673a0473e90ef01a18eb575392c9e3859747", "patch": "@@ -1,490 +1,353 @@\n-use crate::fmt;\n-use crate::io::{self, ErrorKind, IoSlice, IoSliceMut};\n-use crate::net::{IpAddr, Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n-use crate::str;\n-use crate::sync::Arc;\n-use crate::sys::hermit::abi;\n-use crate::sys::hermit::abi::IpAddress::{Ipv4, Ipv6};\n-use crate::sys::unsupported;\n-use crate::sys_common::AsInner;\n+#![allow(dead_code)]\n+\n+use crate::cmp;\n+use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::mem;\n+use crate::net::{Shutdown, SocketAddr};\n+use crate::os::hermit::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, RawFd};\n+use crate::sys::hermit::fd::FileDesc;\n+use crate::sys::time::Instant;\n+use crate::sys_common::net::{getsockopt, setsockopt, sockaddr_to_addr};\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::time::Duration;\n \n-/// Checks whether the HermitCore's socket interface has been started already, and\n-/// if not, starts it.\n-pub fn init() -> io::Result<()> {\n-    if abi::network_init() < 0 {\n-        return Err(io::const_io_error!(\n-            ErrorKind::Uncategorized,\n-            \"Unable to initialize network interface\",\n-        ));\n-    }\n-\n-    Ok(())\n-}\n-\n-#[derive(Debug, Clone)]\n-pub struct Socket(abi::Handle);\n-\n-impl AsInner<abi::Handle> for Socket {\n-    fn as_inner(&self) -> &abi::Handle {\n-        &self.0\n-    }\n-}\n+use core::ffi::c_int;\n \n-impl Drop for Socket {\n-    fn drop(&mut self) {\n-        let _ = abi::tcpstream::close(self.0);\n-    }\n-}\n+#[allow(unused_extern_crates)]\n+pub extern crate hermit_abi as netc;\n \n-// Arc is used to count the number of used sockets.\n-// Only if all sockets are released, the drop\n-// method will close the socket.\n-#[derive(Clone)]\n-pub struct TcpStream(Arc<Socket>);\n-\n-impl TcpStream {\n-    pub fn connect(addr: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n-        let addr = addr?;\n-\n-        match abi::tcpstream::connect(addr.ip().to_string().as_bytes(), addr.port(), None) {\n-            Ok(handle) => Ok(TcpStream(Arc::new(Socket(handle)))),\n-            _ => Err(io::const_io_error!(\n-                ErrorKind::Uncategorized,\n-                \"Unable to initiate a connection on a socket\",\n-            )),\n-        }\n-    }\n+pub use crate::sys::{cvt, cvt_r};\n \n-    pub fn connect_timeout(saddr: &SocketAddr, duration: Duration) -> io::Result<TcpStream> {\n-        match abi::tcpstream::connect(\n-            saddr.ip().to_string().as_bytes(),\n-            saddr.port(),\n-            Some(duration.as_millis() as u64),\n-        ) {\n-            Ok(handle) => Ok(TcpStream(Arc::new(Socket(handle)))),\n-            _ => Err(io::const_io_error!(\n-                ErrorKind::Uncategorized,\n-                \"Unable to initiate a connection on a socket\",\n-            )),\n-        }\n-    }\n+pub type wrlen_t = usize;\n \n-    pub fn set_read_timeout(&self, duration: Option<Duration>) -> io::Result<()> {\n-        abi::tcpstream::set_read_timeout(*self.0.as_inner(), duration.map(|d| d.as_millis() as u64))\n-            .map_err(|_| {\n-                io::const_io_error!(ErrorKind::Uncategorized, \"Unable to set timeout value\")\n-            })\n+pub fn cvt_gai(err: i32) -> io::Result<()> {\n+    if err == 0 {\n+        return Ok(());\n     }\n \n-    pub fn set_write_timeout(&self, duration: Option<Duration>) -> io::Result<()> {\n-        abi::tcpstream::set_write_timeout(\n-            *self.0.as_inner(),\n-            duration.map(|d| d.as_millis() as u64),\n-        )\n-        .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"Unable to set timeout value\"))\n-    }\n+    let detail = \"\";\n \n-    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        let duration = abi::tcpstream::get_read_timeout(*self.0.as_inner()).map_err(|_| {\n-            io::const_io_error!(ErrorKind::Uncategorized, \"Unable to determine timeout value\")\n-        })?;\n+    Err(io::Error::new(\n+        io::ErrorKind::Uncategorized,\n+        &format!(\"failed to lookup address information: {detail}\")[..],\n+    ))\n+}\n \n-        Ok(duration.map(|d| Duration::from_millis(d)))\n+/// Checks whether the HermitCore's socket interface has been started already, and\n+/// if not, starts it.\n+pub fn init() {\n+    if unsafe { netc::network_init() } < 0 {\n+        panic!(\"Unable to initialize network interface\");\n     }\n+}\n \n-    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        let duration = abi::tcpstream::get_write_timeout(*self.0.as_inner()).map_err(|_| {\n-            io::const_io_error!(ErrorKind::Uncategorized, \"Unable to determine timeout value\")\n-        })?;\n+#[derive(Debug)]\n+pub struct Socket(FileDesc);\n \n-        Ok(duration.map(|d| Duration::from_millis(d)))\n+impl Socket {\n+    pub fn new(addr: &SocketAddr, ty: i32) -> io::Result<Socket> {\n+        let fam = match *addr {\n+            SocketAddr::V4(..) => netc::AF_INET,\n+            SocketAddr::V6(..) => netc::AF_INET6,\n+        };\n+        Socket::new_raw(fam, ty)\n     }\n \n-    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        abi::tcpstream::peek(*self.0.as_inner(), buf)\n-            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"peek failed\"))\n+    pub fn new_raw(fam: i32, ty: i32) -> io::Result<Socket> {\n+        let fd = cvt(unsafe { netc::socket(fam, ty, 0) })?;\n+        Ok(Socket(unsafe { FileDesc::from_raw_fd(fd) }))\n     }\n \n-    pub fn read(&self, buffer: &mut [u8]) -> io::Result<usize> {\n-        self.read_vectored(&mut [IoSliceMut::new(buffer)])\n+    pub fn new_pair(_fam: i32, _ty: i32) -> io::Result<(Socket, Socket)> {\n+        unimplemented!()\n     }\n \n-    pub fn read_vectored(&self, ioslice: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        let mut size: usize = 0;\n-\n-        for i in ioslice.iter_mut() {\n-            let ret = abi::tcpstream::read(*self.0.as_inner(), &mut i[0..]).map_err(|_| {\n-                io::const_io_error!(ErrorKind::Uncategorized, \"Unable to read on socket\")\n-            })?;\n+    pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {\n+        self.set_nonblocking(true)?;\n+        let r = unsafe {\n+            let (addr, len) = addr.into_inner();\n+            cvt(netc::connect(self.as_raw_fd(), addr.as_ptr(), len))\n+        };\n+        self.set_nonblocking(false)?;\n \n-            if ret != 0 {\n-                size += ret;\n-            }\n+        match r {\n+            Ok(_) => return Ok(()),\n+            // there's no ErrorKind for EINPROGRESS :(\n+            Err(ref e) if e.raw_os_error() == Some(netc::errno::EINPROGRESS) => {}\n+            Err(e) => return Err(e),\n         }\n \n-        Ok(size)\n-    }\n-\n-    #[inline]\n-    pub fn is_read_vectored(&self) -> bool {\n-        true\n-    }\n-\n-    pub fn write(&self, buffer: &[u8]) -> io::Result<usize> {\n-        self.write_vectored(&[IoSlice::new(buffer)])\n-    }\n+        let mut pollfd = netc::pollfd { fd: self.as_raw_fd(), events: netc::POLLOUT, revents: 0 };\n \n-    pub fn write_vectored(&self, ioslice: &[IoSlice<'_>]) -> io::Result<usize> {\n-        let mut size: usize = 0;\n-\n-        for i in ioslice.iter() {\n-            size += abi::tcpstream::write(*self.0.as_inner(), i).map_err(|_| {\n-                io::const_io_error!(ErrorKind::Uncategorized, \"Unable to write on socket\")\n-            })?;\n+        if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n+            return Err(io::const_io_error!(\n+                io::ErrorKind::InvalidInput,\n+                \"cannot set a 0 duration timeout\",\n+            ));\n         }\n \n-        Ok(size)\n-    }\n-\n-    #[inline]\n-    pub fn is_write_vectored(&self) -> bool {\n-        true\n-    }\n-\n-    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        let (ipaddr, port) = abi::tcpstream::peer_addr(*self.0.as_inner())\n-            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"peer_addr failed\"))?;\n+        let start = Instant::now();\n \n-        let saddr = match ipaddr {\n-            Ipv4(ref addr) => SocketAddr::new(IpAddr::V4(Ipv4Addr::from(addr.0)), port),\n-            Ipv6(ref addr) => SocketAddr::new(IpAddr::V6(Ipv6Addr::from(addr.0)), port),\n-            _ => {\n-                return Err(io::const_io_error!(ErrorKind::Uncategorized, \"peer_addr failed\"));\n+        loop {\n+            let elapsed = start.elapsed();\n+            if elapsed >= timeout {\n+                return Err(io::const_io_error!(io::ErrorKind::TimedOut, \"connection timed out\"));\n             }\n-        };\n-\n-        Ok(saddr)\n-    }\n-\n-    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        unsupported()\n-    }\n-\n-    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n-        abi::tcpstream::shutdown(*self.0.as_inner(), how as i32)\n-            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"unable to shutdown socket\"))\n-    }\n-\n-    pub fn duplicate(&self) -> io::Result<TcpStream> {\n-        Ok(self.clone())\n-    }\n-\n-    pub fn set_linger(&self, _linger: Option<Duration>) -> io::Result<()> {\n-        unsupported()\n-    }\n-\n-    pub fn linger(&self) -> io::Result<Option<Duration>> {\n-        unsupported()\n-    }\n-\n-    pub fn set_nodelay(&self, mode: bool) -> io::Result<()> {\n-        abi::tcpstream::set_nodelay(*self.0.as_inner(), mode)\n-            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"set_nodelay failed\"))\n-    }\n-\n-    pub fn nodelay(&self) -> io::Result<bool> {\n-        abi::tcpstream::nodelay(*self.0.as_inner())\n-            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"nodelay failed\"))\n-    }\n-\n-    pub fn set_ttl(&self, tll: u32) -> io::Result<()> {\n-        abi::tcpstream::set_tll(*self.0.as_inner(), tll)\n-            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"unable to set TTL\"))\n-    }\n-\n-    pub fn ttl(&self) -> io::Result<u32> {\n-        abi::tcpstream::get_tll(*self.0.as_inner())\n-            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"unable to get TTL\"))\n-    }\n \n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        unsupported()\n-    }\n-\n-    pub fn set_nonblocking(&self, mode: bool) -> io::Result<()> {\n-        abi::tcpstream::set_nonblocking(*self.0.as_inner(), mode).map_err(|_| {\n-            io::const_io_error!(ErrorKind::Uncategorized, \"unable to set blocking mode\")\n-        })\n-    }\n-}\n-\n-impl fmt::Debug for TcpStream {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        Ok(())\n-    }\n-}\n-\n-#[derive(Clone)]\n-pub struct TcpListener(SocketAddr);\n-\n-impl TcpListener {\n-    pub fn bind(addr: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n-        let addr = addr?;\n-\n-        Ok(TcpListener(*addr))\n-    }\n-\n-    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        Ok(self.0)\n-    }\n-\n-    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n-        let (handle, ipaddr, port) = abi::tcplistener::accept(self.0.port())\n-            .map_err(|_| io::const_io_error!(ErrorKind::Uncategorized, \"accept failed\"))?;\n-        let saddr = match ipaddr {\n-            Ipv4(ref addr) => SocketAddr::new(IpAddr::V4(Ipv4Addr::from(addr.0)), port),\n-            Ipv6(ref addr) => SocketAddr::new(IpAddr::V6(Ipv6Addr::from(addr.0)), port),\n-            _ => {\n-                return Err(io::const_io_error!(ErrorKind::Uncategorized, \"accept failed\"));\n+            let timeout = timeout - elapsed;\n+            let mut timeout = timeout\n+                .as_secs()\n+                .saturating_mul(1_000)\n+                .saturating_add(timeout.subsec_nanos() as u64 / 1_000_000);\n+            if timeout == 0 {\n+                timeout = 1;\n             }\n-        };\n-\n-        Ok((TcpStream(Arc::new(Socket(handle))), saddr))\n-    }\n \n-    pub fn duplicate(&self) -> io::Result<TcpListener> {\n-        Ok(self.clone())\n-    }\n-\n-    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n-        unsupported()\n-    }\n-\n-    pub fn ttl(&self) -> io::Result<u32> {\n-        unsupported()\n-    }\n-\n-    pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n-        unsupported()\n+            let timeout = cmp::min(timeout, c_int::MAX as u64) as c_int;\n+\n+            match unsafe { netc::poll(&mut pollfd, 1, timeout) } {\n+                -1 => {\n+                    let err = io::Error::last_os_error();\n+                    if err.kind() != io::ErrorKind::Interrupted {\n+                        return Err(err);\n+                    }\n+                }\n+                0 => {}\n+                _ => {\n+                    // linux returns POLLOUT|POLLERR|POLLHUP for refused connections (!), so look\n+                    // for POLLHUP rather than read readiness\n+                    if pollfd.revents & netc::POLLHUP != 0 {\n+                        let e = self.take_error()?.unwrap_or_else(|| {\n+                            io::const_io_error!(\n+                                io::ErrorKind::Uncategorized,\n+                                \"no error set after POLLHUP\",\n+                            )\n+                        });\n+                        return Err(e);\n+                    }\n+\n+                    return Ok(());\n+                }\n+            }\n+        }\n     }\n \n-    pub fn only_v6(&self) -> io::Result<bool> {\n-        unsupported()\n+    pub fn accept(\n+        &self,\n+        storage: *mut netc::sockaddr,\n+        len: *mut netc::socklen_t,\n+    ) -> io::Result<Socket> {\n+        let fd = cvt(unsafe { netc::accept(self.0.as_raw_fd(), storage, len) })?;\n+        Ok(Socket(unsafe { FileDesc::from_raw_fd(fd) }))\n     }\n \n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        unsupported()\n+    pub fn duplicate(&self) -> io::Result<Socket> {\n+        let fd = cvt(unsafe { netc::dup(self.0.as_raw_fd()) })?;\n+        Ok(Socket(unsafe { FileDesc::from_raw_fd(fd) }))\n     }\n \n-    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n-        unsupported()\n+    fn recv_with_flags(&self, buf: &mut [u8], flags: i32) -> io::Result<usize> {\n+        let ret =\n+            cvt(unsafe { netc::recv(self.0.as_raw_fd(), buf.as_mut_ptr(), buf.len(), flags) })?;\n+        Ok(ret as usize)\n     }\n-}\n \n-impl fmt::Debug for TcpListener {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        Ok(())\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.recv_with_flags(buf, 0)\n     }\n-}\n-\n-pub struct UdpSocket(abi::Handle);\n \n-impl UdpSocket {\n-    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n-        unsupported()\n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.recv_with_flags(buf, netc::MSG_PEEK)\n     }\n \n-    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        unsupported()\n-    }\n+    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        let mut size: isize = 0;\n \n-    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        unsupported()\n-    }\n+        for i in bufs.iter_mut() {\n+            let ret: isize =\n+                cvt(unsafe { netc::read(self.0.as_raw_fd(), i.as_mut_ptr(), i.len()) })?;\n \n-    pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        unsupported()\n-    }\n+            if ret != 0 {\n+                size += ret;\n+            }\n+        }\n \n-    pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        unsupported()\n+        Ok(size.try_into().unwrap())\n     }\n \n-    pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {\n-        unsupported()\n+    #[inline]\n+    pub fn is_read_vectored(&self) -> bool {\n+        true\n     }\n \n-    pub fn duplicate(&self) -> io::Result<UdpSocket> {\n-        unsupported()\n-    }\n+    fn recv_from_with_flags(&self, buf: &mut [u8], flags: i32) -> io::Result<(usize, SocketAddr)> {\n+        let mut storage: netc::sockaddr_storage = unsafe { mem::zeroed() };\n+        let mut addrlen = mem::size_of_val(&storage) as netc::socklen_t;\n \n-    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-        unsupported()\n+        let n = cvt(unsafe {\n+            netc::recvfrom(\n+                self.as_raw_fd(),\n+                buf.as_mut_ptr(),\n+                buf.len(),\n+                flags,\n+                &mut storage as *mut _ as *mut _,\n+                &mut addrlen,\n+            )\n+        })?;\n+        Ok((n as usize, sockaddr_to_addr(&storage, addrlen as usize)?))\n     }\n \n-    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-        unsupported()\n+    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.recv_from_with_flags(buf, 0)\n     }\n \n-    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        unsupported()\n+    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.recv_from_with_flags(buf, netc::MSG_PEEK)\n     }\n \n-    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        unsupported()\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        let sz = cvt(unsafe { netc::write(self.0.as_raw_fd(), buf.as_ptr(), buf.len()) })?;\n+        Ok(sz.try_into().unwrap())\n     }\n \n-    pub fn set_broadcast(&self, _: bool) -> io::Result<()> {\n-        unsupported()\n-    }\n+    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        let mut size: isize = 0;\n \n-    pub fn broadcast(&self) -> io::Result<bool> {\n-        unsupported()\n-    }\n+        for i in bufs.iter() {\n+            size += cvt(unsafe { netc::write(self.0.as_raw_fd(), i.as_ptr(), i.len()) })?;\n+        }\n \n-    pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {\n-        unsupported()\n+        Ok(size.try_into().unwrap())\n     }\n \n-    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n-        unsupported()\n+    pub fn is_write_vectored(&self) -> bool {\n+        true\n     }\n \n-    pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {\n-        unsupported()\n-    }\n+    pub fn set_timeout(&self, dur: Option<Duration>, kind: i32) -> io::Result<()> {\n+        let timeout = match dur {\n+            Some(dur) => {\n+                if dur.as_secs() == 0 && dur.subsec_nanos() == 0 {\n+                    return Err(io::const_io_error!(\n+                        io::ErrorKind::InvalidInput,\n+                        \"cannot set a 0 duration timeout\",\n+                    ));\n+                }\n+\n+                let secs = if dur.as_secs() > netc::time_t::MAX as u64 {\n+                    netc::time_t::MAX\n+                } else {\n+                    dur.as_secs() as netc::time_t\n+                };\n+                let mut timeout = netc::timeval {\n+                    tv_sec: secs,\n+                    tv_usec: dur.subsec_micros() as netc::suseconds_t,\n+                };\n+                if timeout.tv_sec == 0 && timeout.tv_usec == 0 {\n+                    timeout.tv_usec = 1;\n+                }\n+                timeout\n+            }\n+            None => netc::timeval { tv_sec: 0, tv_usec: 0 },\n+        };\n \n-    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n-        unsupported()\n+        setsockopt(self, netc::SOL_SOCKET, kind, timeout)\n     }\n \n-    pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {\n-        unsupported()\n+    pub fn timeout(&self, kind: i32) -> io::Result<Option<Duration>> {\n+        let raw: netc::timeval = getsockopt(self, netc::SOL_SOCKET, kind)?;\n+        if raw.tv_sec == 0 && raw.tv_usec == 0 {\n+            Ok(None)\n+        } else {\n+            let sec = raw.tv_sec as u64;\n+            let nsec = (raw.tv_usec as u32) * 1000;\n+            Ok(Some(Duration::new(sec, nsec)))\n+        }\n     }\n \n-    pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n-        unsupported()\n+    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n+        let how = match how {\n+            Shutdown::Write => netc::SHUT_WR,\n+            Shutdown::Read => netc::SHUT_RD,\n+            Shutdown::Both => netc::SHUT_RDWR,\n+        };\n+        cvt(unsafe { netc::shutdown_socket(self.as_raw_fd(), how) })?;\n+        Ok(())\n     }\n \n-    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n-        unsupported()\n-    }\n+    pub fn set_linger(&self, linger: Option<Duration>) -> io::Result<()> {\n+        let linger = netc::linger {\n+            l_onoff: linger.is_some() as i32,\n+            l_linger: linger.unwrap_or_default().as_secs() as libc::c_int,\n+        };\n \n-    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n-        unsupported()\n+        setsockopt(self, netc::SOL_SOCKET, netc::SO_LINGER, linger)\n     }\n \n-    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n-        unsupported()\n-    }\n+    pub fn linger(&self) -> io::Result<Option<Duration>> {\n+        let val: netc::linger = getsockopt(self, netc::SOL_SOCKET, netc::SO_LINGER)?;\n \n-    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n-        unsupported()\n+        Ok((val.l_onoff != 0).then(|| Duration::from_secs(val.l_linger as u64)))\n     }\n \n-    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n-        unsupported()\n+    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n+        let value: i32 = if nodelay { 1 } else { 0 };\n+        setsockopt(self, netc::IPPROTO_TCP, netc::TCP_NODELAY, value)\n     }\n \n-    pub fn ttl(&self) -> io::Result<u32> {\n-        unsupported()\n+    pub fn nodelay(&self) -> io::Result<bool> {\n+        let raw: i32 = getsockopt(self, netc::IPPROTO_TCP, netc::TCP_NODELAY)?;\n+        Ok(raw != 0)\n+    }\n+\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        let mut nonblocking: i32 = if nonblocking { 1 } else { 0 };\n+        cvt(unsafe {\n+            netc::ioctl(\n+                self.as_raw_fd(),\n+                netc::FIONBIO,\n+                &mut nonblocking as *mut _ as *mut core::ffi::c_void,\n+            )\n+        })\n+        .map(drop)\n     }\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        unsupported()\n-    }\n-\n-    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n-        unsupported()\n-    }\n-\n-    pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {\n-        unsupported()\n-    }\n-\n-    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n-        unsupported()\n+        unimplemented!()\n     }\n \n-    pub fn send(&self, _: &[u8]) -> io::Result<usize> {\n-        unsupported()\n-    }\n-\n-    pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n-        unsupported()\n+    // This is used by sys_common code to abstract over Windows and Unix.\n+    pub fn as_raw(&self) -> RawFd {\n+        self.0.as_raw_fd()\n     }\n }\n \n-impl fmt::Debug for UdpSocket {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        Ok(())\n+impl AsInner<FileDesc> for Socket {\n+    fn as_inner(&self) -> &FileDesc {\n+        &self.0\n     }\n }\n \n-pub struct LookupHost(!);\n-\n-impl LookupHost {\n-    pub fn port(&self) -> u16 {\n+impl IntoInner<FileDesc> for Socket {\n+    fn into_inner(self) -> FileDesc {\n         self.0\n     }\n }\n \n-impl Iterator for LookupHost {\n-    type Item = SocketAddr;\n-    fn next(&mut self) -> Option<SocketAddr> {\n-        self.0\n+impl FromInner<FileDesc> for Socket {\n+    fn from_inner(file_desc: FileDesc) -> Self {\n+        Self(file_desc)\n     }\n }\n \n-impl TryFrom<&str> for LookupHost {\n-    type Error = io::Error;\n-\n-    fn try_from(_v: &str) -> io::Result<LookupHost> {\n-        unsupported()\n+impl AsFd for Socket {\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.0.as_fd()\n     }\n }\n \n-impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n-    type Error = io::Error;\n-\n-    fn try_from(_v: (&'a str, u16)) -> io::Result<LookupHost> {\n-        unsupported()\n+impl AsRawFd for Socket {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.0.as_raw_fd()\n     }\n }\n-\n-#[allow(nonstandard_style)]\n-pub mod netc {\n-    pub const AF_INET: u8 = 0;\n-    pub const AF_INET6: u8 = 1;\n-    pub type sa_family_t = u8;\n-\n-    #[derive(Copy, Clone)]\n-    pub struct in_addr {\n-        pub s_addr: u32,\n-    }\n-\n-    #[derive(Copy, Clone)]\n-    pub struct sockaddr_in {\n-        pub sin_family: sa_family_t,\n-        pub sin_port: u16,\n-        pub sin_addr: in_addr,\n-    }\n-\n-    #[derive(Copy, Clone)]\n-    pub struct in6_addr {\n-        pub s6_addr: [u8; 16],\n-    }\n-\n-    #[derive(Copy, Clone)]\n-    pub struct sockaddr_in6 {\n-        pub sin6_family: sa_family_t,\n-        pub sin6_port: u16,\n-        pub sin6_addr: in6_addr,\n-        pub sin6_flowinfo: u32,\n-        pub sin6_scope_id: u32,\n-    }\n-\n-    #[derive(Copy, Clone)]\n-    pub struct sockaddr {}\n-}"}, {"sha": "e53dbae6119810456f2f4e6521490138dcd8bf34", "filename": "library/std/src/sys/hermit/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fos.rs?ref=34e6673a0473e90ef01a18eb575392c9e3859747", "patch": "@@ -4,7 +4,7 @@ use crate::ffi::{CStr, OsStr, OsString};\n use crate::fmt;\n use crate::io;\n use crate::marker::PhantomData;\n-use crate::os::unix::ffi::OsStringExt;\n+use crate::os::hermit::ffi::OsStringExt;\n use crate::path::{self, PathBuf};\n use crate::str;\n use crate::sync::Mutex;"}, {"sha": "32ddc4346eefd5d0609fb701358fba9eb0020daa", "filename": "library/std/src/sys/hermit/time.rs", "status": "modified", "additions": 83, "deletions": 15, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ftime.rs?ref=34e6673a0473e90ef01a18eb575392c9e3859747", "patch": "@@ -1,6 +1,7 @@\n #![allow(dead_code)]\n \n use crate::cmp::Ordering;\n+use crate::ops::{Add, AddAssign, Sub, SubAssign};\n use crate::sys::hermit::abi;\n use crate::sys::hermit::abi::timespec;\n use crate::sys::hermit::abi::{CLOCK_MONOTONIC, CLOCK_REALTIME, NSEC_PER_SEC};\n@@ -102,55 +103,122 @@ impl Hash for Timespec {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n-pub struct Instant {\n-    t: Timespec,\n-}\n+pub struct Instant(Timespec);\n \n impl Instant {\n     pub fn now() -> Instant {\n         let mut time: Timespec = Timespec::zero();\n         let _ = unsafe { abi::clock_gettime(CLOCK_MONOTONIC, &mut time.t as *mut timespec) };\n \n-        Instant { t: time }\n+        Instant(time)\n+    }\n+\n+    #[stable(feature = \"time2\", since = \"1.8.0\")]\n+    pub fn elapsed(&self) -> Duration {\n+        Instant::now() - *self\n+    }\n+\n+    pub fn duration_since(&self, earlier: Instant) -> Duration {\n+        self.checked_duration_since(earlier).unwrap_or_default()\n+    }\n+\n+    pub fn checked_duration_since(&self, earlier: Instant) -> Option<Duration> {\n+        self.checked_sub_instant(&earlier)\n     }\n \n     pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n-        self.t.sub_timespec(&other.t).ok()\n+        self.0.sub_timespec(&other.0).ok()\n     }\n \n     pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n-        Some(Instant { t: self.t.checked_add_duration(other)? })\n+        Some(Instant(self.0.checked_add_duration(other)?))\n     }\n \n     pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n-        Some(Instant { t: self.t.checked_sub_duration(other)? })\n+        Some(Instant(self.0.checked_sub_duration(other)?))\n+    }\n+\n+    pub fn checked_add(&self, duration: Duration) -> Option<Instant> {\n+        self.0.checked_add_duration(&duration).map(Instant)\n+    }\n+\n+    pub fn checked_sub(&self, duration: Duration) -> Option<Instant> {\n+        self.0.checked_sub_duration(&duration).map(Instant)\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n-pub struct SystemTime {\n-    t: Timespec,\n+impl Add<Duration> for Instant {\n+    type Output = Instant;\n+\n+    /// # Panics\n+    ///\n+    /// This function may panic if the resulting point in time cannot be represented by the\n+    /// underlying data structure. See [`Instant::checked_add`] for a version without panic.\n+    fn add(self, other: Duration) -> Instant {\n+        self.checked_add(other).expect(\"overflow when adding duration to instant\")\n+    }\n }\n \n-pub const UNIX_EPOCH: SystemTime = SystemTime { t: Timespec::zero() };\n+impl AddAssign<Duration> for Instant {\n+    fn add_assign(&mut self, other: Duration) {\n+        *self = *self + other;\n+    }\n+}\n+\n+impl Sub<Duration> for Instant {\n+    type Output = Instant;\n+\n+    fn sub(self, other: Duration) -> Instant {\n+        self.checked_sub(other).expect(\"overflow when subtracting duration from instant\")\n+    }\n+}\n+\n+impl SubAssign<Duration> for Instant {\n+    fn sub_assign(&mut self, other: Duration) {\n+        *self = *self - other;\n+    }\n+}\n+\n+impl Sub<Instant> for Instant {\n+    type Output = Duration;\n+\n+    /// Returns the amount of time elapsed from another instant to this one,\n+    /// or zero duration if that instant is later than this one.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Previous rust versions panicked when `other` was later than `self`. Currently this\n+    /// method saturates. Future versions may reintroduce the panic in some circumstances.\n+    /// See [Monotonicity].\n+    ///\n+    /// [Monotonicity]: Instant#monotonicity\n+    fn sub(self, other: Instant) -> Duration {\n+        self.duration_since(other)\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+pub struct SystemTime(Timespec);\n+\n+pub const UNIX_EPOCH: SystemTime = SystemTime(Timespec::zero());\n \n impl SystemTime {\n     pub fn now() -> SystemTime {\n         let mut time: Timespec = Timespec::zero();\n         let _ = unsafe { abi::clock_gettime(CLOCK_REALTIME, &mut time.t as *mut timespec) };\n \n-        SystemTime { t: time }\n+        SystemTime(time)\n     }\n \n     pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n-        self.t.sub_timespec(&other.t)\n+        self.0.sub_timespec(&other.0)\n     }\n \n     pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n-        Some(SystemTime { t: self.t.checked_add_duration(other)? })\n+        Some(SystemTime(self.0.checked_add_duration(other)?))\n     }\n \n     pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n-        Some(SystemTime { t: self.t.checked_sub_duration(other)? })\n+        Some(SystemTime(self.0.checked_sub_duration(other)?))\n     }\n }"}, {"sha": "e9c727cbbd1220aabf1230e06f7b2f4d47000170", "filename": "library/std/src/sys_common/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e6673a0473e90ef01a18eb575392c9e3859747/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs?ref=34e6673a0473e90ef01a18eb575392c9e3859747", "patch": "@@ -44,7 +44,6 @@ cfg_if::cfg_if! {\n \n cfg_if::cfg_if! {\n     if #[cfg(any(target_os = \"l4re\",\n-                 target_os = \"hermit\",\n                  feature = \"restricted-std\",\n                  all(target_family = \"wasm\", not(target_os = \"emscripten\")),\n                  all(target_vendor = \"fortanix\", target_env = \"sgx\")))] {"}]}