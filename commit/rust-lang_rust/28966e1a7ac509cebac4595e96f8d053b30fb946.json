{"sha": "28966e1a7ac509cebac4595e96f8d053b30fb946", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4OTY2ZTFhN2FjNTA5Y2ViYWM0NTk1ZTk2ZjhkMDUzYjMwZmI5NDY=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-01-09T04:20:56Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-01-13T22:10:26Z"}, "message": "Remove `TokenStream::Tree` variant.\n\n`TokenStream::Stream` can represent a token stream containing any number\nof token trees. `TokenStream::Tree` is the special case representing a\nsingle token tree. The latter doesn't occur all that often dynamically,\nso this commit removes it, which simplifies the code quite a bit.\n\nThis change has mixed performance effects.\n\n- The size of `TokenStream` drops from 32 bytes to 8 bytes, and there\n  is one less case for all the match statements.\n\n- The conversion of a `TokenTree` to a `TokenStream` now requires two\n  allocations, for the creation of a single element Lrc<Vec<_>>. (But a\n  subsequent commit in this PR will reduce the main source of such\n  conversions.)", "tree": {"sha": "9c8098c50fb97a0f61c860537ae10be7f13afa72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c8098c50fb97a0f61c860537ae10be7f13afa72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28966e1a7ac509cebac4595e96f8d053b30fb946", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28966e1a7ac509cebac4595e96f8d053b30fb946", "html_url": "https://github.com/rust-lang/rust/commit/28966e1a7ac509cebac4595e96f8d053b30fb946", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28966e1a7ac509cebac4595e96f8d053b30fb946/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cf736f76563f054aecd84207b39114c6fceb8ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cf736f76563f054aecd84207b39114c6fceb8ed", "html_url": "https://github.com/rust-lang/rust/commit/2cf736f76563f054aecd84207b39114c6fceb8ed"}], "stats": {"total": 47, "additions": 6, "deletions": 41}, "files": [{"sha": "95ff7728897e554c21eb9ed4e192ffffe065beeb", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 5, "deletions": 40, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/28966e1a7ac509cebac4595e96f8d053b30fb946/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28966e1a7ac509cebac4595e96f8d053b30fb946/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=28966e1a7ac509cebac4595e96f8d053b30fb946", "patch": "@@ -113,7 +113,7 @@ impl TokenTree {\n     }\n \n     pub fn joint(self) -> TokenStream {\n-        TokenStream::Tree(self, Joint)\n+        TokenStream::new(vec![(self, Joint)])\n     }\n \n     /// Returns the opening delimiter as a token tree.\n@@ -146,15 +146,14 @@ impl TokenTree {\n #[derive(Clone, Debug)]\n pub enum TokenStream {\n     Empty,\n-    Tree(TokenTree, IsJoint),\n     Stream(Lrc<Vec<TreeAndJoint>>),\n }\n \n pub type TreeAndJoint = (TokenTree, IsJoint);\n \n // `TokenStream` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert!(MEM_SIZE_OF_TOKEN_STREAM: mem::size_of::<TokenStream>() == 32);\n+static_assert!(MEM_SIZE_OF_TOKEN_STREAM: mem::size_of::<TokenStream>() == 8);\n \n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum IsJoint {\n@@ -201,7 +200,7 @@ impl TokenStream {\n \n impl From<TokenTree> for TokenStream {\n     fn from(tree: TokenTree) -> TokenStream {\n-        TokenStream::Tree(tree, NonJoint)\n+        TokenStream::new(vec![(tree, NonJoint)])\n     }\n }\n \n@@ -260,7 +259,6 @@ impl TokenStream {\n                 for stream in streams {\n                     match stream {\n                         TokenStream::Empty => {},\n-                        TokenStream::Tree(tree, is_joint) => vec.push((tree, is_joint)),\n                         TokenStream::Stream(stream2) => vec.extend(stream2.iter().cloned()),\n                     }\n                 }\n@@ -269,21 +267,16 @@ impl TokenStream {\n         }\n     }\n \n-    pub fn new(mut streams: Vec<TreeAndJoint>) -> TokenStream {\n+    pub fn new(streams: Vec<TreeAndJoint>) -> TokenStream {\n         match streams.len() {\n             0 => TokenStream::empty(),\n-            1 => {\n-                let (tree, is_joint) = streams.pop().unwrap();\n-                TokenStream::Tree(tree, is_joint)\n-            }\n             _ => TokenStream::Stream(Lrc::new(streams)),\n         }\n     }\n \n     pub fn append_to_tree_and_joint_vec(self, vec: &mut Vec<TreeAndJoint>) {\n         match self {\n             TokenStream::Empty => {}\n-            TokenStream::Tree(tree, is_joint) => vec.push((tree, is_joint)),\n             TokenStream::Stream(stream) => vec.extend(stream.iter().cloned()),\n         }\n     }\n@@ -351,7 +344,6 @@ impl TokenStream {\n     pub fn map_enumerated<F: FnMut(usize, TokenTree) -> TokenTree>(self, mut f: F) -> TokenStream {\n         match self {\n             TokenStream::Empty => TokenStream::Empty,\n-            TokenStream::Tree(tree, is_joint) => TokenStream::Tree(f(0, tree), is_joint),\n             TokenStream::Stream(stream) => TokenStream::Stream(Lrc::new(\n                 stream\n                     .iter()\n@@ -365,7 +357,6 @@ impl TokenStream {\n     pub fn map<F: FnMut(TokenTree) -> TokenTree>(self, mut f: F) -> TokenStream {\n         match self {\n             TokenStream::Empty => TokenStream::Empty,\n-            TokenStream::Tree(tree, is_joint) => TokenStream::Tree(f(tree), is_joint),\n             TokenStream::Stream(stream) => TokenStream::Stream(Lrc::new(\n                 stream\n                     .iter()\n@@ -378,21 +369,13 @@ impl TokenStream {\n     fn first_tree_and_joint(&self) -> Option<(TokenTree, IsJoint)> {\n         match self {\n             TokenStream::Empty => None,\n-            TokenStream::Tree(ref tree, is_joint) => Some((tree.clone(), *is_joint)),\n             TokenStream::Stream(ref stream) => Some(stream.first().unwrap().clone())\n         }\n     }\n \n     fn last_tree_if_joint(&self) -> Option<TokenTree> {\n         match self {\n             TokenStream::Empty => None,\n-            TokenStream::Tree(ref tree, is_joint) => {\n-                if *is_joint == Joint {\n-                    Some(tree.clone())\n-                } else {\n-                    None\n-                }\n-            }\n             TokenStream::Stream(ref stream) => {\n                 if let (tree, Joint) = stream.last().unwrap() {\n                     Some(tree.clone())\n@@ -422,7 +405,7 @@ impl TokenStreamBuilder {\n                     self.push_all_but_last_tree(&last_stream);\n                     let glued_span = last_span.to(span);\n                     let glued_tt = TokenTree::Token(glued_span, glued_tok);\n-                    let glued_tokenstream = TokenStream::Tree(glued_tt, is_joint);\n+                    let glued_tokenstream = TokenStream::new(vec![(glued_tt, is_joint)]);\n                     self.0.push(glued_tokenstream);\n                     self.push_all_but_first_tree(&stream);\n                     return\n@@ -441,7 +424,6 @@ impl TokenStreamBuilder {\n             let len = streams.len();\n             match len {\n                 1 => {}\n-                2 => self.0.push(TokenStream::Tree(streams[0].0.clone(), streams[0].1)),\n                 _ => self.0.push(TokenStream::Stream(Lrc::new(streams[0 .. len - 1].to_vec()))),\n             }\n         }\n@@ -452,7 +434,6 @@ impl TokenStreamBuilder {\n             let len = streams.len();\n             match len {\n                 1 => {}\n-                2 => self.0.push(TokenStream::Tree(streams[1].0.clone(), streams[1].1)),\n                 _ => self.0.push(TokenStream::Stream(Lrc::new(streams[1 .. len].to_vec()))),\n             }\n         }\n@@ -481,14 +462,6 @@ impl Cursor {\n     pub fn next_with_joint(&mut self) -> Option<TreeAndJoint> {\n         match self.stream {\n             TokenStream::Empty => None,\n-            TokenStream::Tree(ref tree, ref is_joint) => {\n-                if self.index == 0 {\n-                    self.index = 1;\n-                    Some((tree.clone(), *is_joint))\n-                } else {\n-                    None\n-                }\n-            }\n             TokenStream::Stream(ref stream) => {\n                 if self.index < stream.len() {\n                     self.index += 1;\n@@ -513,13 +486,6 @@ impl Cursor {\n     pub fn look_ahead(&self, n: usize) -> Option<TokenTree> {\n         match self.stream {\n             TokenStream::Empty => None,\n-            TokenStream::Tree(ref tree, _) => {\n-                if n == 0 && self.index == 0 {\n-                    Some(tree.clone())\n-                } else {\n-                    None\n-                }\n-            }\n             TokenStream::Stream(ref stream) =>\n                 stream[self.index ..].get(n).map(|(tree, _)| tree.clone()),\n         }\n@@ -542,7 +508,6 @@ impl From<TokenStream> for ThinTokenStream {\n     fn from(stream: TokenStream) -> ThinTokenStream {\n         ThinTokenStream(match stream {\n             TokenStream::Empty => None,\n-            TokenStream::Tree(tree, is_joint) => Some(Lrc::new(vec![(tree, is_joint)])),\n             TokenStream::Stream(stream) => Some(stream),\n         })\n     }"}, {"sha": "7de9b9343a8faceb33609b220290e37dc5ca9b92", "filename": "src/libsyntax_ext/proc_macro_server.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28966e1a7ac509cebac4595e96f8d053b30fb946/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28966e1a7ac509cebac4595e96f8d053b30fb946/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_server.rs?ref=28966e1a7ac509cebac4595e96f8d053b30fb946", "patch": "@@ -269,7 +269,7 @@ impl ToInternal<TokenStream> for TokenTree<Group, Punct, Ident, Literal> {\n         };\n \n         let tree = tokenstream::TokenTree::Token(span, token);\n-        TokenStream::Tree(tree, if joint { Joint } else { NonJoint })\n+        TokenStream::new(vec![(tree, if joint { Joint } else { NonJoint })])\n     }\n }\n "}]}