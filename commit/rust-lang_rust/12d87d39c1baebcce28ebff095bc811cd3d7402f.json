{"sha": "12d87d39c1baebcce28ebff095bc811cd3d7402f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyZDg3ZDM5YzFiYWViY2NlMjhlYmZmMDk1YmM4MTFjZDNkNzQwMmY=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-07-10T15:28:28Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-07-19T05:57:38Z"}, "message": "Cleanup of ty::VariantInfo and related functions.", "tree": {"sha": "b26500e4a0040af990d324d362601e3217cad9fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b26500e4a0040af990d324d362601e3217cad9fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12d87d39c1baebcce28ebff095bc811cd3d7402f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12d87d39c1baebcce28ebff095bc811cd3d7402f", "html_url": "https://github.com/rust-lang/rust/commit/12d87d39c1baebcce28ebff095bc811cd3d7402f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12d87d39c1baebcce28ebff095bc811cd3d7402f/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77a00cca0307ad4d7de084b45168387e8d82d92e", "url": "https://api.github.com/repos/rust-lang/rust/commits/77a00cca0307ad4d7de084b45168387e8d82d92e", "html_url": "https://github.com/rust-lang/rust/commit/77a00cca0307ad4d7de084b45168387e8d82d92e"}], "stats": {"total": 275, "additions": 131, "deletions": 144}, "files": [{"sha": "2934751eeafd74f62bcdd688c4230690eea9eac0", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12d87d39c1baebcce28ebff095bc811cd3d7402f/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d87d39c1baebcce28ebff095bc811cd3d7402f/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=12d87d39c1baebcce28ebff095bc811cd3d7402f", "patch": "@@ -90,7 +90,7 @@ pub fn maybe_get_item_ast(tcx: ty::ctxt, def: ast::def_id,\n }\n \n pub fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id)\n-                      -> ~[ty::VariantInfo] {\n+                      -> ~[@ty::VariantInfo] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     return decoder::get_enum_variants(cstore.intr, cdata, def.node, tcx)"}, {"sha": "cf75bf45eaf0c8e9bf4b9071db3d24299fe34bd9", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12d87d39c1baebcce28ebff095bc811cd3d7402f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d87d39c1baebcce28ebff095bc811cd3d7402f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=12d87d39c1baebcce28ebff095bc811cd3d7402f", "patch": "@@ -733,11 +733,11 @@ pub fn maybe_get_item_ast(cdata: cmd, tcx: ty::ctxt,\n }\n \n pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n-                     tcx: ty::ctxt) -> ~[ty::VariantInfo] {\n+                     tcx: ty::ctxt) -> ~[@ty::VariantInfo] {\n     let data = cdata.data;\n     let items = reader::get_doc(reader::Doc(data), tag_items);\n     let item = find_item(id, items);\n-    let mut infos: ~[ty::VariantInfo] = ~[];\n+    let mut infos: ~[@ty::VariantInfo] = ~[];\n     let variant_ids = enum_variant_ids(item, cdata);\n     let mut disr_val = 0;\n     for variant_ids.iter().advance |did| {\n@@ -753,7 +753,7 @@ pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n           Some(val) => { disr_val = val; }\n           _         => { /* empty */ }\n         }\n-        infos.push(@ty::VariantInfo_{\n+        infos.push(@ty::VariantInfo{\n             args: arg_tys,\n             arg_names: None,\n             ctor_ty: ctor_ty,"}, {"sha": "a68a8437e1bb7e7ae8b54aabc847eb27db5bba79", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12d87d39c1baebcce28ebff095bc811cd3d7402f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d87d39c1baebcce28ebff095bc811cd3d7402f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=12d87d39c1baebcce28ebff095bc811cd3d7402f", "patch": "@@ -671,7 +671,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n     let _icx = push_ctxt(\"iter_structural_ty\");\n \n     fn iter_variant(cx: block, repr: &adt::Repr, av: ValueRef,\n-                    variant: ty::VariantInfo,\n+                    variant: @ty::VariantInfo,\n                     tps: &[ty::t], f: val_and_ty_fn) -> block {\n         let _icx = push_ctxt(\"iter_variant\");\n         let tcx = cx.tcx();\n@@ -2110,7 +2110,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n }\n \n pub fn trans_enum_def(ccx: @mut CrateContext, enum_definition: &ast::enum_def,\n-                      id: ast::node_id, vi: @~[ty::VariantInfo],\n+                      id: ast::node_id, vi: @~[@ty::VariantInfo],\n                       i: &mut uint) {\n     for enum_definition.variants.iter().advance |variant| {\n         let disr_val = vi[*i].disr_val;"}, {"sha": "59d33fc086dd0a67c301639bef1249a566c3433f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 76, "deletions": 68, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/12d87d39c1baebcce28ebff095bc811cd3d7402f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d87d39c1baebcce28ebff095bc811cd3d7402f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=12d87d39c1baebcce28ebff095bc811cd3d7402f", "patch": "@@ -50,6 +50,8 @@ use syntax::opt_vec;\n use syntax::abi::AbiSet;\n use syntax;\n \n+pub static INITIAL_DISCRIMINANT_VALUE: int = 0;\n+\n // Data types\n \n #[deriving(Eq, IterBytes)]\n@@ -282,7 +284,7 @@ struct ctxt_ {\n     needs_unwind_cleanup_cache: @mut HashMap<t, bool>,\n     tc_cache: @mut HashMap<uint, TypeContents>,\n     ast_ty_to_ty_cache: @mut HashMap<node_id, ast_ty_to_ty_cache_entry>,\n-    enum_var_cache: @mut HashMap<def_id, @~[VariantInfo]>,\n+    enum_var_cache: @mut HashMap<def_id, @~[@VariantInfo]>,\n     ty_param_defs: @mut HashMap<ast::node_id, TypeParameterDef>,\n     adjustments: @mut HashMap<ast::node_id, @AutoAdjustment>,\n     normalized_cache: @mut HashMap<t, t>,\n@@ -3702,19 +3704,70 @@ pub struct VariantInfo_ {\n     vis: visibility\n }\n \n-pub type VariantInfo = @VariantInfo_;\n+impl VariantInfo {\n+\n+    /// Creates a new VariantInfo from the corresponding ast representation.\n+    ///\n+    /// Does not do any caching of the value in the type context.\n+    pub fn from_ast_variant(cx: ctxt,\n+                            ast_variant: &ast::variant,\n+                            discriminant: int) -> VariantInfo {\n+\n+        let ctor_ty = node_id_to_type(cx, ast_variant.node.id);\n+\n+        match ast_variant.node.kind {\n+            ast::tuple_variant_kind(ref args) => {\n+                let arg_tys = if args.len() > 0 { ty_fn_args(ctor_ty).map(|a| *a) } else { ~[] };\n+\n+                return VariantInfo {\n+                    args: arg_tys,\n+                    arg_names: None,\n+                    ctor_ty: ctor_ty,\n+                    name: ast_variant.node.name,\n+                    id: ast_util::local_def(ast_variant.node.id),\n+                    disr_val: discriminant,\n+                    vis: ast_variant.node.vis\n+                };\n+            },\n+            ast::struct_variant_kind(ref struct_def) => {\n+\n+                let fields : &[@struct_field] = struct_def.fields;\n+\n+                assert!(fields.len() > 0);\n+\n+                let arg_tys = ty_fn_args(ctor_ty).map(|a| *a);\n+                let arg_names = do fields.map |field| {\n+                    match field.node.kind {\n+                        named_field(ident, _visibility) => ident,\n+                        unnamed_field => cx.sess.bug(\n+                            \"enum_variants: all fields in struct must have a name\")\n+                    }};\n+\n+                return VariantInfo {\n+                    args: arg_tys,\n+                    arg_names: Some(arg_names),\n+                    ctor_ty: ctor_ty,\n+                    name: ast_variant.node.name,\n+                    id: ast_util::local_def(ast_variant.node.id),\n+                    disr_val: discriminant,\n+                    vis: ast_variant.node.vis\n+                };\n+            }\n+        }\n+    }\n+}\n \n pub fn substd_enum_variants(cx: ctxt,\n                             id: ast::def_id,\n                             substs: &substs)\n-                         -> ~[VariantInfo] {\n+                         -> ~[@VariantInfo] {\n     do enum_variants(cx, id).iter().transform |variant_info| {\n         let substd_args = variant_info.args.iter()\n             .transform(|aty| subst(cx, substs, *aty)).collect();\n \n         let substd_ctor_ty = subst(cx, substs, variant_info.ctor_ty);\n \n-        @VariantInfo_ {\n+        @VariantInfo {\n             args: substd_args,\n             ctor_ty: substd_ctor_ty,\n             ..(**variant_info).clone()\n@@ -3832,7 +3885,7 @@ pub fn type_is_empty(cx: ctxt, t: t) -> bool {\n      }\n }\n \n-pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n+pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[@VariantInfo] {\n     match cx.enum_var_cache.find(&id) {\n       Some(&variants) => return variants,\n       _ => { /* fallthrough */ }\n@@ -3851,71 +3904,26 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n                     node: ast::item_enum(ref enum_definition, _),\n                     _\n                 }, _) => {\n-            let mut disr_val = -1;\n+            let mut last_discriminant : Option<int> = None;\n             @enum_definition.variants.iter().transform(|variant| {\n \n-                let ctor_ty = node_id_to_type(cx, variant.node.id);\n-\n-                match variant.node.kind {\n-                    ast::tuple_variant_kind(ref args) => {\n-                        let arg_tys = if args.len() > 0u {\n-                                ty_fn_args(ctor_ty).map(|a| *a) }\n-                            else {\n-                                ~[]\n-                            };\n-\n-                        match variant.node.disr_expr {\n-                          Some (ex) => {\n-                            disr_val = match const_eval::eval_const_expr(cx,\n-                                                                         ex) {\n-                              const_eval::const_int(val) => val as int,\n-                              _ => cx.sess.bug(\"enum_variants: bad disr expr\")\n-                            }\n-                          }\n-                          _ => disr_val += 1\n-                        }\n-                        @VariantInfo_{\n-                            args: arg_tys,\n-                            arg_names: None,\n-                            ctor_ty: ctor_ty,\n-                            name: variant.node.name,\n-                            id: ast_util::local_def(variant.node.id),\n-                            disr_val: disr_val,\n-                            vis: variant.node.vis\n-                         }\n+                let mut discriminant = match last_discriminant {\n+                    Some(val) => val + 1,\n+                    None => INITIAL_DISCRIMINANT_VALUE\n+                };\n+\n+                match variant.node.disr_expr {\n+                    Some(e) => match const_eval::eval_const_expr_partial(cx, e) {\n+                        Ok(const_eval::const_int(val)) => { discriminant = val as int; }\n+                        _ => {}\n                     },\n-                    ast::struct_variant_kind(struct_def) => {\n-\n-                        let fields : &[@struct_field] = struct_def.fields;\n-\n-                        let (arg_tys, arg_names) =\n-                            if fields.len() > 0 {\n-                                let arg_tys = ty_fn_args(ctor_ty).map(|a| *a);\n-                                let arg_names = do fields.map |field| { match field.node.kind {\n-                                    named_field(ident, _visibility) => ident,\n-                                    unnamed_field => cx.sess.bug(\n-                                        \"enum_variants: all fields in struct must have a name\")\n-                                }};\n-\n-                                (arg_tys, Some(arg_names))\n-                            } else {\n-                                (~[], None)\n-                            };\n-\n-                        assert!(variant.node.disr_expr.is_none());\n-                        disr_val += 1;\n-\n-                        @VariantInfo_{\n-                            args: arg_tys,\n-                            arg_names: arg_names,\n-                            ctor_ty: ctor_ty,\n-                            name: variant.node.name,\n-                            id: ast_util::local_def(variant.node.id),\n-                            disr_val: disr_val,\n-                            vis: variant.node.vis\n-                        }\n-                    }\n-                }\n+                    None => {}\n+                };\n+\n+                let variant_info = @VariantInfo::from_ast_variant(cx, variant, discriminant);\n+                last_discriminant = Some(discriminant);\n+                variant_info\n+\n             }).collect()\n           }\n           _ => cx.sess.bug(\"enum_variants: id not bound to an enum\")\n@@ -3930,7 +3938,7 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n pub fn enum_variant_with_id(cx: ctxt,\n                             enum_id: ast::def_id,\n                             variant_id: ast::def_id)\n-                         -> VariantInfo {\n+                         -> @VariantInfo {\n     let variants = enum_variants(cx, enum_id);\n     let mut i = 0;\n     while i < variants.len() {"}, {"sha": "319d94bae70383a581e468371e125dda2484ddcc", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 49, "deletions": 70, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/12d87d39c1baebcce28ebff095bc811cd3d7402f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d87d39c1baebcce28ebff095bc811cd3d7402f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=12d87d39c1baebcce28ebff095bc811cd3d7402f", "patch": "@@ -81,7 +81,7 @@ use middle::const_eval;\n use middle::pat_util::pat_id_map;\n use middle::pat_util;\n use middle::lint::unreachable_code;\n-use middle::ty::{FnSig, VariantInfo_};\n+use middle::ty::{FnSig, VariantInfo};\n use middle::ty::{ty_param_bounds_and_ty, ty_param_substs_and_ty};\n use middle::ty::{substs, param_ty, ExprTyProvider};\n use middle::ty;\n@@ -3133,87 +3133,66 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                            vs: &[ast::variant],\n                            id: ast::node_id) {\n     fn do_check(ccx: @mut CrateCtxt,\n-                _sp: span,\n                 vs: &[ast::variant],\n-                id: ast::node_id,\n-                disr_vals: &mut ~[int],\n-                disr_val: &mut int,\n-                variants: &mut ~[ty::VariantInfo]) {\n+                id: ast::node_id)\n+                -> ~[@ty::VariantInfo] {\n+\n         let rty = ty::node_id_to_type(ccx.tcx, id);\n-        for vs.iter().advance |v| {\n-            for v.node.disr_expr.iter().advance |e_ref| {\n-                let e = *e_ref;\n-                debug!(\"disr expr, checking %s\",\n-                       pprust::expr_to_str(e, ccx.tcx.sess.intr()));\n-                let declty = ty::mk_int();\n-                let fcx = blank_fn_ctxt(ccx, rty, e.id);\n-                check_const_with_ty(fcx, e.span, e, declty);\n-                // check_expr (from check_const pass) doesn't guarantee\n-                // that the expression is in an form that eval_const_expr can\n-                // handle, so we may still get an internal compiler error\n-\n-                match const_eval::eval_const_expr_partial(&ccx.tcx, e) {\n-                  Ok(const_eval::const_int(val)) => {\n-                    *disr_val = val as int;\n-                  }\n-                  Ok(_) => {\n-                    ccx.tcx.sess.span_err(e.span, \"expected signed integer \\\n-                                                   constant\");\n-                  }\n-                  Err(ref err) => {\n-                    ccx.tcx.sess.span_err(e.span,\n-                     fmt!(\"expected constant: %s\", (*err)));\n+        let mut variants : ~[@ty::VariantInfo] = ~[];\n+        let mut disr_vals: ~[int] = ~[];\n+        let mut prev_disr_val : Option<int> = None;\n \n-                  }\n-                }\n-            }\n-            if disr_vals.contains(&*disr_val) {\n-                ccx.tcx.sess.span_err(v.span,\n-                                      \"discriminator value already exists\");\n-            }\n-            disr_vals.push(*disr_val);\n-            let ctor_ty = ty::node_id_to_type(ccx.tcx, v.node.id);\n+        for vs.iter().advance |v| {\n \n-            let this_disr_val = *disr_val;\n-            *disr_val += 1;\n+            // If the discriminant value is specified explicitly in the enum check whether the\n+            // initialization expression is valid, otherwise use the last value plus one.\n+            let mut current_disr_val = match prev_disr_val {\n+                Some(prev_disr_val) => prev_disr_val + 1,\n+                None => ty::INITIAL_DISCRIMINANT_VALUE\n+            };\n \n-            let (arg_tys, arg_names) = match v.node.kind {\n-                ast::tuple_variant_kind(ref args) if args.len() > 0u => {\n-                    (ty::ty_fn_args(ctor_ty).map(|a| *a), None)\n-                }\n-                ast::tuple_variant_kind(_) => {\n-                    (~[], None)\n-                }\n-                ast::struct_variant_kind(struct_def) => {\n-                    let tys = ty::ty_fn_args(ctor_ty).map(|a| *a);\n-                    let names = do struct_def.fields.map |field| { match field.node.kind {\n-                        ast::named_field(ident, _visibility) => ident,\n-                        ast::unnamed_field => ccx.tcx.sess.bug(\n-                            \"enum_variants: all fields in struct must have a name\")\n-                    }};\n-\n-                    (tys, Some(names))\n-                }\n+            match v.node.disr_expr {\n+                Some(e) => {\n+                    debug!(\"disr expr, checking %s\", pprust::expr_to_str(e, ccx.tcx.sess.intr()));\n+\n+                    let declty = ty::mk_int();\n+                    let fcx = blank_fn_ctxt(ccx, rty, e.id);\n+                    check_const_with_ty(fcx, e.span, e, declty);\n+                    // check_expr (from check_const pass) doesn't guarantee\n+                    // that the expression is in an form that eval_const_expr can\n+                    // handle, so we may still get an internal compiler error\n+\n+                    match const_eval::eval_const_expr_partial(&ccx.tcx, e) {\n+                        Ok(const_eval::const_int(val)) => { current_disr_val = val as int; }\n+                        Ok(_) => {\n+                            ccx.tcx.sess.span_err(e.span, \"expected signed integer constant\");\n+                        }\n+                        Err(ref err) => {\n+                            ccx.tcx.sess.span_err(e.span, fmt!(\"expected constant: %s\", (*err)));\n+                        }\n+                    }\n+                },\n+                None => ()\n             };\n \n-            variants.push(@VariantInfo_{\n-                    args: arg_tys,\n-                    arg_names: arg_names,\n-                    ctor_ty: ctor_ty,\n-                    name: v.node.name,\n-                    id: local_def(v.node.id),\n-                    disr_val: this_disr_val,\n-                    vis: v.node.vis\n-            });\n+            // Check for duplicate discriminator values\n+            if disr_vals.contains(&current_disr_val) {\n+                ccx.tcx.sess.span_err(v.span, \"discriminator value already exists\");\n+            }\n+            disr_vals.push(current_disr_val);\n+\n+            let variant_info = @VariantInfo::from_ast_variant(ccx.tcx, v, current_disr_val);\n+            prev_disr_val = Some(current_disr_val);\n+\n+            variants.push(variant_info);\n         }\n+\n+        return variants;\n     }\n \n     let rty = ty::node_id_to_type(ccx.tcx, id);\n-    let mut disr_vals: ~[int] = ~[];\n-    let mut disr_val = 0;\n-    let mut variants = ~[];\n \n-    do_check(ccx, sp, vs, id, &mut disr_vals, &mut disr_val, &mut variants);\n+    let variants = do_check(ccx, vs, id);\n \n     // cache so that ty::enum_variants won't repeat this work\n     ccx.tcx.enum_var_cache.insert(local_def(id), @variants);"}]}