{"sha": "09f7713dd45c3a0b37073115575697c256238b18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5Zjc3MTNkZDQ1YzNhMGIzNzA3MzExNTU3NTY5N2MyNTYyMzhiMTg=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-11-27T19:28:51Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-07T00:05:58Z"}, "message": "libserialize: remove unnecessary `as_slice()` calls", "tree": {"sha": "a2da376b42f3840d40fcc460f7fc80644b61bba4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2da376b42f3840d40fcc460f7fc80644b61bba4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09f7713dd45c3a0b37073115575697c256238b18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09f7713dd45c3a0b37073115575697c256238b18", "html_url": "https://github.com/rust-lang/rust/commit/09f7713dd45c3a0b37073115575697c256238b18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09f7713dd45c3a0b37073115575697c256238b18/comments", "author": null, "committer": null, "parents": [{"sha": "e6bd217ce8cf3384bdf47b63833a8b04e40e0753", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6bd217ce8cf3384bdf47b63833a8b04e40e0753", "html_url": "https://github.com/rust-lang/rust/commit/e6bd217ce8cf3384bdf47b63833a8b04e40e0753"}], "stats": {"total": 68, "additions": 30, "deletions": 38}, "files": [{"sha": "8efb8e5b78d50a313244d4903872f74270f6a408", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/09f7713dd45c3a0b37073115575697c256238b18/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f7713dd45c3a0b37073115575697c256238b18/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=09f7713dd45c3a0b37073115575697c256238b18", "patch": "@@ -298,7 +298,6 @@ mod tests {\n     #[test]\n     fn test_to_base64_line_break() {\n         assert!(![0u8, ..1000].to_base64(Config {line_length: None, ..STANDARD})\n-                              .as_slice()\n                               .contains(\"\\r\\n\"));\n         assert_eq!(\"foobar\".as_bytes().to_base64(Config {line_length: Some(4),\n                                                          ..STANDARD}),\n@@ -319,26 +318,26 @@ mod tests {\n \n     #[test]\n     fn test_from_base64_basic() {\n-        assert_eq!(\"\".from_base64().unwrap().as_slice(), \"\".as_bytes());\n-        assert_eq!(\"Zg==\".from_base64().unwrap().as_slice(), \"f\".as_bytes());\n-        assert_eq!(\"Zm8=\".from_base64().unwrap().as_slice(), \"fo\".as_bytes());\n-        assert_eq!(\"Zm9v\".from_base64().unwrap().as_slice(), \"foo\".as_bytes());\n-        assert_eq!(\"Zm9vYg==\".from_base64().unwrap().as_slice(), \"foob\".as_bytes());\n-        assert_eq!(\"Zm9vYmE=\".from_base64().unwrap().as_slice(), \"fooba\".as_bytes());\n-        assert_eq!(\"Zm9vYmFy\".from_base64().unwrap().as_slice(), \"foobar\".as_bytes());\n+        assert_eq!(\"\".from_base64().unwrap(), b\"\");\n+        assert_eq!(\"Zg==\".from_base64().unwrap(), b\"f\");\n+        assert_eq!(\"Zm8=\".from_base64().unwrap(), b\"fo\");\n+        assert_eq!(\"Zm9v\".from_base64().unwrap(), b\"foo\");\n+        assert_eq!(\"Zm9vYg==\".from_base64().unwrap(), b\"foob\");\n+        assert_eq!(\"Zm9vYmE=\".from_base64().unwrap(), b\"fooba\");\n+        assert_eq!(\"Zm9vYmFy\".from_base64().unwrap(), b\"foobar\");\n     }\n \n     #[test]\n     fn test_from_base64_bytes() {\n-        assert_eq!(b\"Zm9vYmFy\".from_base64().unwrap().as_slice(), \"foobar\".as_bytes());\n+        assert_eq!(b\"Zm9vYmFy\".from_base64().unwrap(), b\"foobar\");\n     }\n \n     #[test]\n     fn test_from_base64_newlines() {\n-        assert_eq!(\"Zm9v\\r\\nYmFy\".from_base64().unwrap().as_slice(),\n-                   \"foobar\".as_bytes());\n-        assert_eq!(\"Zm9vYg==\\r\\n\".from_base64().unwrap().as_slice(),\n-                   \"foob\".as_bytes());\n+        assert_eq!(\"Zm9v\\r\\nYmFy\".from_base64().unwrap(),\n+                   b\"foobar\");\n+        assert_eq!(\"Zm9vYg==\\r\\n\".from_base64().unwrap(),\n+                   b\"foob\");\n     }\n \n     #[test]\n@@ -364,13 +363,10 @@ mod tests {\n         for _ in range(0u, 1000) {\n             let times = task_rng().gen_range(1u, 100);\n             let v = Vec::from_fn(times, |_| random::<u8>());\n-            assert_eq!(v.as_slice()\n-                        .to_base64(STANDARD)\n-                        .as_slice()\n+            assert_eq!(v.to_base64(STANDARD)\n                         .from_base64()\n-                        .unwrap()\n-                        .as_slice(),\n-                       v.as_slice());\n+                        .unwrap(),\n+                       v);\n         }\n     }\n \n@@ -390,7 +386,7 @@ mod tests {\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n         let sb = s.as_bytes().to_base64(STANDARD);\n         b.iter(|| {\n-            sb.as_slice().from_base64().unwrap();\n+            sb.from_base64().unwrap();\n         });\n         b.bytes = sb.len() as u64;\n     }"}, {"sha": "443a31f7493f2f2bec1e68b29e650167e3e49f06", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/09f7713dd45c3a0b37073115575697c256238b18/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f7713dd45c3a0b37073115575697c256238b18/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=09f7713dd45c3a0b37073115575697c256238b18", "patch": "@@ -163,10 +163,10 @@ mod tests {\n \n     #[test]\n     pub fn test_from_hex_okay() {\n-        assert_eq!(\"666f6f626172\".from_hex().unwrap().as_slice(),\n-                   \"foobar\".as_bytes());\n-        assert_eq!(\"666F6F626172\".from_hex().unwrap().as_slice(),\n-                   \"foobar\".as_bytes());\n+        assert_eq!(\"666f6f626172\".from_hex().unwrap(),\n+                   b\"foobar\");\n+        assert_eq!(\"666F6F626172\".from_hex().unwrap(),\n+                   b\"foobar\");\n     }\n \n     #[test]\n@@ -182,8 +182,8 @@ mod tests {\n \n     #[test]\n     pub fn test_from_hex_ignores_whitespace() {\n-        assert_eq!(\"666f 6f6\\r\\n26172 \".from_hex().unwrap().as_slice(),\n-                   \"foobar\".as_bytes());\n+        assert_eq!(\"666f 6f6\\r\\n26172 \".from_hex().unwrap(),\n+                   b\"foobar\");\n     }\n \n     #[test]\n@@ -197,15 +197,11 @@ mod tests {\n     pub fn test_from_hex_all_bytes() {\n         for i in range(0u, 256) {\n             let ii: &[u8] = &[i as u8];\n-            assert_eq!(format!(\"{:02x}\", i as uint).as_slice()\n-                                                   .from_hex()\n-                                                   .unwrap()\n-                                                   .as_slice(),\n+            assert_eq!(format!(\"{:02x}\", i as uint).from_hex()\n+                                                   .unwrap(),\n                        ii);\n-            assert_eq!(format!(\"{:02X}\", i as uint).as_slice()\n-                                                   .from_hex()\n-                                                   .unwrap()\n-                                                   .as_slice(),\n+            assert_eq!(format!(\"{:02X}\", i as uint).from_hex()\n+                                                   .unwrap(),\n                        ii);\n         }\n     }\n@@ -226,7 +222,7 @@ mod tests {\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n         let sb = s.as_bytes().to_hex();\n         b.iter(|| {\n-            sb.as_slice().from_hex().unwrap();\n+            sb.from_hex().unwrap();\n         });\n         b.bytes = sb.len() as u64;\n     }"}, {"sha": "abf2341a76cbe0ac7aeb0e2ee8747380064bf16b", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09f7713dd45c3a0b37073115575697c256238b18/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f7713dd45c3a0b37073115575697c256238b18/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=09f7713dd45c3a0b37073115575697c256238b18", "patch": "@@ -2039,7 +2039,7 @@ impl ::Decoder<DecoderError> for Decoder {\n     fn read_char(&mut self) -> DecodeResult<char> {\n         let s = try!(self.read_str());\n         {\n-            let mut it = s.as_slice().chars();\n+            let mut it = s.chars();\n             match (it.next(), it.next()) {\n                 // exactly one character\n                 (Some(c), None) => return Ok(c),\n@@ -2860,7 +2860,7 @@ mod tests {\n \n         for &(i, o) in s.iter() {\n             let v: string::String = super::decode(i).unwrap();\n-            assert_eq!(v.as_slice(), o);\n+            assert_eq!(v, o);\n         }\n     }\n \n@@ -3778,7 +3778,7 @@ mod tests {\n     fn bench_streaming_large(b: &mut Bencher) {\n         let src = big_json();\n         b.iter( || {\n-            let mut parser = Parser::new(src.as_slice().chars());\n+            let mut parser = Parser::new(src.chars());\n             loop {\n                 match parser.next() {\n                     None => return,"}]}