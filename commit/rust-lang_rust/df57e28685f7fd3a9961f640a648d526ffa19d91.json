{"sha": "df57e28685f7fd3a9961f640a648d526ffa19d91", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmNTdlMjg2ODVmN2ZkM2E5OTYxZjY0MGE2NDhkNTI2ZmZhMTlkOTE=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-07-29T16:26:15Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-08-22T18:19:47Z"}, "message": "Lazy decoding of DefPathTable from crate metadata (non-incremental case)", "tree": {"sha": "0bc75b50bf711ad012307395c19fc1f80eabd2d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0bc75b50bf711ad012307395c19fc1f80eabd2d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df57e28685f7fd3a9961f640a648d526ffa19d91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df57e28685f7fd3a9961f640a648d526ffa19d91", "html_url": "https://github.com/rust-lang/rust/commit/df57e28685f7fd3a9961f640a648d526ffa19d91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df57e28685f7fd3a9961f640a648d526ffa19d91/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "527a685e40d8fbe61442bdbd510c2b4e1d248019", "url": "https://api.github.com/repos/rust-lang/rust/commits/527a685e40d8fbe61442bdbd510c2b4e1d248019", "html_url": "https://github.com/rust-lang/rust/commit/527a685e40d8fbe61442bdbd510c2b4e1d248019"}], "stats": {"total": 174, "additions": 104, "deletions": 70}, "files": [{"sha": "45735ead256a798d246dc0c3067daa7c1dbf542f", "filename": "src/librustc_hir/definitions.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/df57e28685f7fd3a9961f640a648d526ffa19d91/src%2Flibrustc_hir%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df57e28685f7fd3a9961f640a648d526ffa19d91/src%2Flibrustc_hir%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdefinitions.rs?ref=df57e28685f7fd3a9961f640a648d526ffa19d91", "patch": "@@ -23,7 +23,7 @@ use tracing::debug;\n /// Internally the `DefPathTable` holds a tree of `DefKey`s, where each `DefKey`\n /// stores the `DefIndex` of its parent.\n /// There is one `DefPathTable` for each crate.\n-#[derive(Clone, Default, Decodable, Encodable)]\n+#[derive(Clone, Default)]\n pub struct DefPathTable {\n     index_to_key: IndexVec<DefIndex, DefKey>,\n     def_path_hashes: IndexVec<DefIndex, DefPathHash>,\n@@ -42,10 +42,6 @@ impl DefPathTable {\n         index\n     }\n \n-    pub fn next_id(&self) -> DefIndex {\n-        DefIndex::from(self.index_to_key.len())\n-    }\n-\n     #[inline(always)]\n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n         self.index_to_key[index]\n@@ -58,15 +54,25 @@ impl DefPathTable {\n         hash\n     }\n \n-    pub fn add_def_path_hashes_to(&self, cnum: CrateNum, out: &mut FxHashMap<DefPathHash, DefId>) {\n-        out.extend(self.def_path_hashes.iter().enumerate().map(|(index, &hash)| {\n-            let def_id = DefId { krate: cnum, index: DefIndex::from(index) };\n-            (hash, def_id)\n-        }));\n+    pub fn num_def_ids(&self) -> usize {\n+        self.index_to_key.len()\n     }\n \n-    pub fn size(&self) -> usize {\n-        self.index_to_key.len()\n+    pub fn enumerated_keys_and_path_hashes(\n+        &self,\n+    ) -> impl Iterator<Item = (DefIndex, &DefKey, &DefPathHash)> + '_ {\n+        self.index_to_key\n+            .iter_enumerated()\n+            .map(move |(index, key)| (index, key, &self.def_path_hashes[index]))\n+    }\n+\n+    pub fn all_def_path_hashes_and_def_ids(\n+        &self,\n+        krate: CrateNum,\n+    ) -> impl Iterator<Item = (DefPathHash, DefId)> + '_ {\n+        self.def_path_hashes\n+            .iter_enumerated()\n+            .map(move |(index, hash)| (*hash, DefId { krate, index }))\n     }\n }\n "}, {"sha": "e0347897e0c4d4333118372718ec7b01a500fda1", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 45, "deletions": 21, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/df57e28685f7fd3a9961f640a648d526ffa19d91/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df57e28685f7fd3a9961f640a648d526ffa19d91/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=df57e28685f7fd3a9961f640a648d526ffa19d91", "patch": "@@ -16,7 +16,6 @@ use rustc_expand::proc_macro::{AttrProcMacro, BangProcMacro, ProcMacroDerive};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc_hir::definitions::DefPathTable;\n use rustc_hir::definitions::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc_hir::lang_items;\n use rustc_index::vec::{Idx, IndexVec};\n@@ -29,7 +28,6 @@ use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc_middle::mir::{self, Body, Promoted};\n use rustc_middle::ty::codec::TyDecoder;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_middle::util::common::record_time;\n use rustc_serialize::{opaque, Decodable, Decoder};\n use rustc_session::Session;\n use rustc_span::hygiene::ExpnDataDecodeMode;\n@@ -69,12 +67,6 @@ crate struct CrateMetadata {\n     /// universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n     /// is being used to decode those values.\n     root: CrateRoot<'static>,\n-    /// For each definition in this crate, we encode a key. When the\n-    /// crate is loaded, we read all the keys and put them in this\n-    /// hashmap, which gives the reverse mapping. This allows us to\n-    /// quickly retrace a `DefPath`, which is needed for incremental\n-    /// compilation support.\n-    def_path_table: DefPathTable,\n     /// Trait impl data.\n     /// FIXME: Used only from queries and can use query cache,\n     /// so pre-decoding can probably be avoided.\n@@ -91,6 +83,10 @@ crate struct CrateMetadata {\n     /// Do not access the value directly, as it might not have been initialized yet.\n     /// The field must always be initialized to `DepNodeIndex::INVALID`.\n     dep_node_index: AtomicCell<DepNodeIndex>,\n+    /// Caches decoded `DefKey`s.\n+    def_key_cache: Lock<FxHashMap<DefIndex, DefKey>>,\n+    /// Caches decoded `DefPathHash`es.\n+    def_path_hash_cache: Lock<FxHashMap<DefIndex, DefPathHash>>,\n \n     // --- Other significant crate properties ---\n     /// ID of this crate, from the current compilation session's point of view.\n@@ -807,7 +803,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                     data.has_auto_impl,\n                     data.is_marker,\n                     data.specialization_kind,\n-                    self.def_path_table.def_path_hash(item_id),\n+                    self.def_path_hash(item_id),\n                 )\n             }\n             EntryKind::TraitAlias => ty::TraitDef::new(\n@@ -817,7 +813,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 false,\n                 false,\n                 ty::trait_def::TraitSpecializationKind::None,\n-                self.def_path_table.def_path_hash(item_id),\n+                self.def_path_hash(item_id),\n             ),\n             _ => bug!(\"def-index does not refer to trait or trait alias\"),\n         }\n@@ -1509,12 +1505,14 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n     #[inline]\n     fn def_key(&self, index: DefIndex) -> DefKey {\n-        let mut key = self.def_path_table.def_key(index);\n-        if self.is_proc_macro(index) {\n-            let name = self.raw_proc_macro(index).name();\n-            key.disambiguated_data.data = DefPathData::MacroNs(Symbol::intern(name));\n-        }\n-        key\n+        *self.def_key_cache.lock().entry(index).or_insert_with(|| {\n+            let mut key = self.root.tables.def_keys.get(self, index).unwrap().decode(self);\n+            if self.is_proc_macro(index) {\n+                let name = self.raw_proc_macro(index).name();\n+                key.disambiguated_data.data = DefPathData::MacroNs(Symbol::intern(name));\n+            }\n+            key\n+        })\n     }\n \n     // Returns the path leading to the thing with this `id`.\n@@ -1723,9 +1721,6 @@ impl CrateMetadata {\n         private_dep: bool,\n         host_hash: Option<Svh>,\n     ) -> CrateMetadata {\n-        let def_path_table = record_time(&sess.perf_stats.decode_def_path_tables_time, || {\n-            root.def_path_table.decode((&blob, sess))\n-        });\n         let trait_impls = root\n             .impls\n             .decode((&blob, sess))\n@@ -1737,7 +1732,6 @@ impl CrateMetadata {\n         CrateMetadata {\n             blob,\n             root,\n-            def_path_table,\n             trait_impls,\n             raw_proc_macros,\n             source_map_import_info: OnceCell::new(),\n@@ -1752,6 +1746,8 @@ impl CrateMetadata {\n             host_hash,\n             extern_crate: Lock::new(None),\n             hygiene_context: Default::default(),\n+            def_key_cache: Default::default(),\n+            def_path_hash_cache: Default::default(),\n         }\n     }\n \n@@ -1828,6 +1824,10 @@ impl CrateMetadata {\n         self.root.hash\n     }\n \n+    fn num_def_ids(&self) -> usize {\n+        self.root.tables.def_keys.size()\n+    }\n+\n     fn local_def_id(&self, index: DefIndex) -> DefId {\n         DefId { krate: self.cnum, index }\n     }\n@@ -1843,10 +1843,34 @@ impl CrateMetadata {\n \n         None\n     }\n+}\n+\n+impl<'a, 'tcx> CrateMetadataRef<'a> {\n+    fn def_path_hash_unlocked(\n+        &self,\n+        index: DefIndex,\n+        def_path_hashes: &mut FxHashMap<DefIndex, DefPathHash>,\n+    ) -> DefPathHash {\n+        *def_path_hashes.entry(index).or_insert_with(|| {\n+            self.root.tables.def_path_hashes.get(self, index).unwrap().decode(self)\n+        })\n+    }\n \n     #[inline]\n     fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n-        self.def_path_table.def_path_hash(index)\n+        let mut def_path_hashes = self.def_path_hash_cache.lock();\n+        self.def_path_hash_unlocked(index, &mut def_path_hashes)\n+    }\n+\n+    fn all_def_path_hashes_and_def_ids(&self) -> Vec<(DefPathHash, DefId)> {\n+        let mut result = Vec::new();\n+        let mut def_path_hashes = self.def_path_hash_cache.lock();\n+        for index in 0..self.num_def_ids() {\n+            let index = DefIndex::from_usize(index);\n+            let def_path_hash = self.def_path_hash_unlocked(index, &mut def_path_hashes);\n+            result.push((def_path_hash, self.local_def_id(index)));\n+        }\n+        result\n     }\n \n     /// Get the `DepNodeIndex` corresponding this crate. The result of this"}, {"sha": "36ff65fc5eb008c5c28b822655e91db4bfb131fb", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/df57e28685f7fd3a9961f640a648d526ffa19d91/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df57e28685f7fd3a9961f640a648d526ffa19d91/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=df57e28685f7fd3a9961f640a648d526ffa19d91", "patch": "@@ -9,7 +9,6 @@ use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_data_structures::svh::Svh;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc_hir::definitions::DefPathTable;\n use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n use rustc_middle::hir::exports::Export;\n use rustc_middle::middle::cstore::{CrateSource, CrateStore, EncodedMetadata};\n@@ -486,8 +485,12 @@ impl CrateStore for CStore {\n         self.get_crate_data(def.krate).def_path_hash(def.index)\n     }\n \n-    fn def_path_table(&self, cnum: CrateNum) -> &DefPathTable {\n-        &self.get_crate_data(cnum).cdata.def_path_table\n+    fn all_def_path_hashes_and_def_ids(&self, cnum: CrateNum) -> Vec<(DefPathHash, DefId)> {\n+        self.get_crate_data(cnum).all_def_path_hashes_and_def_ids()\n+    }\n+\n+    fn num_def_ids(&self, cnum: CrateNum) -> usize {\n+        self.get_crate_data(cnum).num_def_ids()\n     }\n \n     fn crates_untracked(&self) -> Vec<CrateNum> {"}, {"sha": "509ef1caf1a9d10553dff75c46694b8d936f7a75", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/df57e28685f7fd3a9961f640a648d526ffa19d91/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df57e28685f7fd3a9961f640a648d526ffa19d91/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=df57e28685f7fd3a9961f640a648d526ffa19d91", "patch": "@@ -9,7 +9,6 @@ use rustc_data_structures::sync::{join, Lrc};\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc_hir::definitions::DefPathTable;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::{ItemLikeVisitor, ParItemLikeVisitor};\n use rustc_hir::lang_items;\n@@ -418,9 +417,14 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_def_path_table(&mut self) -> Lazy<DefPathTable> {\n-        let definitions = self.tcx.hir().definitions();\n-        self.lazy(definitions.def_path_table())\n+    fn encode_def_path_table(&mut self) {\n+        let table = self.tcx.hir().definitions().def_path_table();\n+        for (def_index, def_key, def_path_hash) in table.enumerated_keys_and_path_hashes() {\n+            let def_key = self.lazy(def_key);\n+            let def_path_hash = self.lazy(def_path_hash);\n+            self.tables.def_keys.set(def_index, def_key);\n+            self.tables.def_path_hashes.set(def_index, def_path_hash);\n+        }\n     }\n \n     fn encode_source_map(&mut self) -> Lazy<[rustc_span::SourceFile]> {\n@@ -525,7 +529,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         // Encode DefPathTable\n         i = self.position();\n-        let def_path_table = self.encode_def_path_table();\n+        self.encode_def_path_table();\n         let def_path_table_bytes = self.position() - i;\n \n         // Encode the def IDs of impls, for coherence checking.\n@@ -642,7 +646,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             native_libraries,\n             foreign_modules,\n             source_map,\n-            def_path_table,\n             impls,\n             exported_symbols,\n             interpret_alloc_index,"}, {"sha": "1ba5962d119e807ac09a1e8e54efa802f02e95cd", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/df57e28685f7fd3a9961f640a648d526ffa19d91/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df57e28685f7fd3a9961f640a648d526ffa19d91/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=df57e28685f7fd3a9961f640a648d526ffa19d91", "patch": "@@ -7,7 +7,8 @@ use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n-use rustc_hir::def_id::{DefId, DefIndex};\n+use rustc_hir::def_id::{DefId, DefIndex, DefPathHash};\n+use rustc_hir::definitions::DefKey;\n use rustc_hir::lang_items;\n use rustc_index::{bit_set::FiniteBitSet, vec::IndexVec};\n use rustc_middle::hir::exports::Export;\n@@ -195,7 +196,6 @@ crate struct CrateRoot<'tcx> {\n     diagnostic_items: Lazy<[(Symbol, DefIndex)]>,\n     native_libraries: Lazy<[NativeLib]>,\n     foreign_modules: Lazy<[ForeignModule]>,\n-    def_path_table: Lazy<rustc_hir::definitions::DefPathTable>,\n     impls: Lazy<[TraitImpls]>,\n     interpret_alloc_index: Lazy<[u32]>,\n \n@@ -285,6 +285,12 @@ define_tables! {\n     mir: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n     promoted_mir: Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>,\n     unused_generic_params: Table<DefIndex, Lazy<FiniteBitSet<u32>>>,\n+    // `def_keys` and `def_path_hashes` represent a lazy version of a\n+    // `DefPathTable`. This allows us to avoid deserializing an entire\n+    // `DefPathTable` up front, since we may only ever use a few\n+    // definitions from any given crate.\n+    def_keys: Table<DefIndex, Lazy<DefKey>>,\n+    def_path_hashes: Table<DefIndex, Lazy<DefPathHash>>\n }\n \n #[derive(Copy, Clone, MetadataEncodable, MetadataDecodable)]"}, {"sha": "03bd4170ea99039ba1897a5495d599cf01b393fe", "filename": "src/librustc_metadata/rmeta/table.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df57e28685f7fd3a9961f640a648d526ffa19d91/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df57e28685f7fd3a9961f640a648d526ffa19d91/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs?ref=df57e28685f7fd3a9961f640a648d526ffa19d91", "patch": "@@ -201,4 +201,9 @@ where\n         let bytes = &metadata.raw_bytes()[start..start + self.meta];\n         <Option<T>>::maybe_read_from_bytes_at(bytes, i.index())?\n     }\n+\n+    /// Size of the table in entries, including possible gaps.\n+    pub(super) fn size(&self) -> usize {\n+        self.meta / <Option<T>>::BYTE_LEN\n+    }\n }"}, {"sha": "1af1d58181760b65aef5ad23f5bc4239e6fc172d", "filename": "src/librustc_middle/middle/cstore.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df57e28685f7fd3a9961f640a648d526ffa19d91/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df57e28685f7fd3a9961f640a648d526ffa19d91/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs?ref=df57e28685f7fd3a9961f640a648d526ffa19d91", "patch": "@@ -9,7 +9,7 @@ use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{self, MetadataRef};\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use rustc_hir::definitions::{DefKey, DefPath, DefPathHash, DefPathTable};\n+use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n use rustc_macros::HashStable;\n use rustc_session::search_paths::PathKind;\n use rustc_session::utils::NativeLibKind;\n@@ -187,7 +187,8 @@ pub trait CrateStore {\n     fn def_key(&self, def: DefId) -> DefKey;\n     fn def_path(&self, def: DefId) -> DefPath;\n     fn def_path_hash(&self, def: DefId) -> DefPathHash;\n-    fn def_path_table(&self, cnum: CrateNum) -> &DefPathTable;\n+    fn all_def_path_hashes_and_def_ids(&self, cnum: CrateNum) -> Vec<(DefPathHash, DefId)>;\n+    fn num_def_ids(&self, cnum: CrateNum) -> usize;\n \n     // \"queries\" used in resolve that aren't tracked for incremental compilation\n     fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol;"}, {"sha": "d1fd65fc244b7dfe8290a6009e65bce7cde72080", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/df57e28685f7fd3a9961f640a648d526ffa19d91/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df57e28685f7fd3a9961f640a648d526ffa19d91/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=df57e28685f7fd3a9961f640a648d526ffa19d91", "patch": "@@ -1102,20 +1102,13 @@ impl<'tcx> TyCtxt<'tcx> {\n         providers[LOCAL_CRATE] = local_providers;\n \n         let def_path_hash_to_def_id = if s.opts.build_dep_graph() {\n-            let def_path_tables = crates\n-                .iter()\n-                .map(|&cnum| (cnum, cstore.def_path_table(cnum)))\n-                .chain(iter::once((LOCAL_CRATE, definitions.def_path_table())));\n+            let capacity = definitions.def_path_table().num_def_ids()\n+                + crates.iter().map(|cnum| cstore.num_def_ids(*cnum)).sum::<usize>();\n+            let mut map = FxHashMap::with_capacity_and_hasher(capacity, Default::default());\n \n-            // Precompute the capacity of the hashmap so we don't have to\n-            // re-allocate when populating it.\n-            let capacity = def_path_tables.clone().map(|(_, t)| t.size()).sum::<usize>();\n-\n-            let mut map: FxHashMap<_, _> =\n-                FxHashMap::with_capacity_and_hasher(capacity, ::std::default::Default::default());\n-\n-            for (cnum, def_path_table) in def_path_tables {\n-                def_path_table.add_def_path_hashes_to(cnum, &mut map);\n+            map.extend(definitions.def_path_table().all_def_path_hashes_and_def_ids(LOCAL_CRATE));\n+            for cnum in &crates {\n+                map.extend(cstore.all_def_path_hashes_and_def_ids(*cnum).into_iter());\n             }\n \n             Some(map)"}, {"sha": "c006e593e47558152882a22668c1fba602c78def", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df57e28685f7fd3a9961f640a648d526ffa19d91/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df57e28685f7fd3a9961f640a648d526ffa19d91/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=df57e28685f7fd3a9961f640a648d526ffa19d91", "patch": "@@ -218,8 +218,6 @@ pub struct Session {\n pub struct PerfStats {\n     /// The accumulated time spent on computing symbol hashes.\n     pub symbol_hash_time: Lock<Duration>,\n-    /// The accumulated time spent decoding def path tables from metadata.\n-    pub decode_def_path_tables_time: Lock<Duration>,\n     /// Total number of values canonicalized queries constructed.\n     pub queries_canonicalized: AtomicUsize,\n     /// Number of times this query is invoked.\n@@ -862,10 +860,6 @@ impl Session {\n             \"Total time spent computing symbol hashes:      {}\",\n             duration_to_secs_str(*self.perf_stats.symbol_hash_time.lock())\n         );\n-        println!(\n-            \"Total time spent decoding DefPath tables:      {}\",\n-            duration_to_secs_str(*self.perf_stats.decode_def_path_tables_time.lock())\n-        );\n         println!(\n             \"Total queries canonicalized:                   {}\",\n             self.perf_stats.queries_canonicalized.load(Ordering::Relaxed)\n@@ -1339,7 +1333,6 @@ pub fn build_session(\n         prof,\n         perf_stats: PerfStats {\n             symbol_hash_time: Lock::new(Duration::from_secs(0)),\n-            decode_def_path_tables_time: Lock::new(Duration::from_secs(0)),\n             queries_canonicalized: AtomicUsize::new(0),\n             normalize_generic_arg_after_erasing_regions: AtomicUsize::new(0),\n             normalize_projection_ty: AtomicUsize::new(0),"}, {"sha": "c942a6cee700f8403f0e98eab46724ac84d95311", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df57e28685f7fd3a9961f640a648d526ffa19d91/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df57e28685f7fd3a9961f640a648d526ffa19d91/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=df57e28685f7fd3a9961f640a648d526ffa19d91", "patch": "@@ -117,13 +117,13 @@ impl<'tcx> DocContext<'tcx> {\n     // def ids, as we'll end up with a panic if we use the DefId Debug impl for fake DefIds\n     pub fn next_def_id(&self, crate_num: CrateNum) -> DefId {\n         let start_def_id = {\n-            let next_id = if crate_num == LOCAL_CRATE {\n-                self.tcx.hir().definitions().def_path_table().next_id()\n+            let num_def_ids = if crate_num == LOCAL_CRATE {\n+                self.tcx.hir().definitions().def_path_table().num_def_ids()\n             } else {\n-                self.enter_resolver(|r| r.cstore().def_path_table(crate_num).next_id())\n+                self.enter_resolver(|r| r.cstore().num_def_ids(crate_num))\n             };\n \n-            DefId { krate: crate_num, index: next_id }\n+            DefId { krate: crate_num, index: DefIndex::from_usize(num_def_ids) }\n         };\n \n         let mut fake_ids = self.fake_def_ids.borrow_mut();"}]}