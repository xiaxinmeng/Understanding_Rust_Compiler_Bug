{"sha": "8c87132103e350821bb8f8abbd90f3d6feebecd1", "node_id": "C_kwDOAAsO6NoAKDhjODcxMzIxMDNlMzUwODIxYmI4ZjhhYmJkOTBmM2Q2ZmVlYmVjZDE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-03-12T08:35:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-12T08:35:45Z"}, "message": "Rollup merge of #94833 - c410-f3r:meta-take-2, r=petrochenkov\n\n[2/2] Implement macro meta-variable expression\n\nFinal part of https://github.com/rust-lang/rust/pull/93545#issuecomment-1050963295\n\nr? `@petrochenkov`", "tree": {"sha": "a355f14dfbf504a78a46982888522b0654448a29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a355f14dfbf504a78a46982888522b0654448a29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c87132103e350821bb8f8abbd90f3d6feebecd1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiLFthCRBK7hj4Ov3rIwAA63gIAHm0ac/ObVGzLZa111XfSvOz\n9d9g6Iq8RuzzoM6g9nk1n4cNvdQZRMMA1rSxLnTdxMQu6OckF40ONTYgCWE8l8Si\n86NsVW7DCP5Y82XRl2xCgz3lNslBqapppqp7UCtZOW4tx9HUd6TZv8cCYbhPlfsM\noLGIvjI7zVhQY0oRpXcJRejUEcidcM0mOH9l5UlwroLdlNs1xyw4PQsNQMEJzMvt\nMKIUU4et1x2j9vCTrqQuvY53ciRPwnHlQUu4sZ7t9zN6snUo2PWxONXUJIK2Ykbw\nEvncFzOivaymTMUXDb16QtWk0I3TS8JTqnUOE1eWS676YqwoOVLvXbzyQF25WrY=\n=YDp6\n-----END PGP SIGNATURE-----\n", "payload": "tree a355f14dfbf504a78a46982888522b0654448a29\nparent 27e674d9e9d70a2c25b73d3ac57660c6146f2a3d\nparent d0eca08bc4acbccd5125d245788979cc933bdf0f\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1647074145 +0100\ncommitter GitHub <noreply@github.com> 1647074145 +0100\n\nRollup merge of #94833 - c410-f3r:meta-take-2, r=petrochenkov\n\n[2/2] Implement macro meta-variable expression\n\nFinal part of https://github.com/rust-lang/rust/pull/93545#issuecomment-1050963295\n\nr? `@petrochenkov`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c87132103e350821bb8f8abbd90f3d6feebecd1", "html_url": "https://github.com/rust-lang/rust/commit/8c87132103e350821bb8f8abbd90f3d6feebecd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c87132103e350821bb8f8abbd90f3d6feebecd1/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27e674d9e9d70a2c25b73d3ac57660c6146f2a3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/27e674d9e9d70a2c25b73d3ac57660c6146f2a3d", "html_url": "https://github.com/rust-lang/rust/commit/27e674d9e9d70a2c25b73d3ac57660c6146f2a3d"}, {"sha": "d0eca08bc4acbccd5125d245788979cc933bdf0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0eca08bc4acbccd5125d245788979cc933bdf0f", "html_url": "https://github.com/rust-lang/rust/commit/d0eca08bc4acbccd5125d245788979cc933bdf0f"}], "stats": {"total": 929, "additions": 836, "deletions": 93}, "files": [{"sha": "387d5895e24d728299a40110d099c021fc035450", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 147, "deletions": 10, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/8c87132103e350821bb8f8abbd90f3d6feebecd1/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c87132103e350821bb8f8abbd90f3d6feebecd1/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=8c87132103e350821bb8f8abbd90f3d6feebecd1", "patch": "@@ -1,15 +1,15 @@\n use crate::base::ExtCtxt;\n-use crate::mbe;\n use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq, NamedMatch};\n-\n+use crate::mbe::{self, MetaVarExpr};\n use rustc_ast::mut_visit::{self, MutVisitor};\n-use rustc_ast::token::{self, NtTT, Token};\n+use rustc_ast::token::{self, NtTT, Token, TokenKind};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndSpacing};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{pluralize, PResult};\n+use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n use rustc_span::hygiene::{LocalExpnId, Transparency};\n-use rustc_span::symbol::MacroRulesNormalizedIdent;\n+use rustc_span::symbol::{sym, Ident, MacroRulesNormalizedIdent};\n use rustc_span::Span;\n \n use smallvec::{smallvec, SmallVec};\n@@ -411,13 +411,150 @@ fn lockstep_iter_size(\n     }\n }\n \n+/// Used solely by the `count` meta-variable expression, counts the outer-most repetitions at a\n+/// given optional nested depth.\n+///\n+/// For example, a macro parameter of `$( { $( $foo:ident ),* } )*` called with `{ a, b } { c }`:\n+///\n+/// * `[ $( ${count(foo)} ),* ]` will return [2, 1] with a, b = 2 and c = 1\n+/// * `[ $( ${count(foo, 0)} ),* ]` will be the same as `[ $( ${count(foo)} ),* ]`\n+/// * `[ $( ${count(foo, 1)} ),* ]` will return an error because `${count(foo, 1)}` is\n+///   declared inside a single repetition and the index `1` implies two nested repetitions.\n+fn count_repetitions<'a>(\n+    cx: &ExtCtxt<'a>,\n+    depth_opt: Option<usize>,\n+    mut matched: &NamedMatch,\n+    repeats: &[(usize, usize)],\n+    sp: &DelimSpan,\n+) -> PResult<'a, usize> {\n+    // Recursively count the number of matches in `matched` at given depth\n+    // (or at the top-level of `matched` if no depth is given).\n+    fn count<'a>(\n+        cx: &ExtCtxt<'a>,\n+        declared_lhs_depth: usize,\n+        depth_opt: Option<usize>,\n+        matched: &NamedMatch,\n+        sp: &DelimSpan,\n+    ) -> PResult<'a, usize> {\n+        match matched {\n+            MatchedNonterminal(_) => {\n+                if declared_lhs_depth == 0 {\n+                    return Err(cx.struct_span_err(\n+                        sp.entire(),\n+                        \"`count` can not be placed inside the inner-most repetition\",\n+                    ));\n+                }\n+                match depth_opt {\n+                    None => Ok(1),\n+                    Some(_) => Err(out_of_bounds_err(cx, declared_lhs_depth, sp.entire(), \"count\")),\n+                }\n+            }\n+            MatchedSeq(ref named_matches) => {\n+                let new_declared_lhs_depth = declared_lhs_depth + 1;\n+                match depth_opt {\n+                    None => named_matches\n+                        .iter()\n+                        .map(|elem| count(cx, new_declared_lhs_depth, None, elem, sp))\n+                        .sum(),\n+                    Some(0) => Ok(named_matches.len()),\n+                    Some(depth) => named_matches\n+                        .iter()\n+                        .map(|elem| count(cx, new_declared_lhs_depth, Some(depth - 1), elem, sp))\n+                        .sum(),\n+                }\n+            }\n+        }\n+    }\n+    // `repeats` records all of the nested levels at which we are currently\n+    // matching meta-variables. The meta-var-expr `count($x)` only counts\n+    // matches that occur in this \"subtree\" of the `NamedMatch` where we\n+    // are currently transcribing, so we need to descend to that subtree\n+    // before we start counting. `matched` contains the various levels of the\n+    // tree as we descend, and its final value is the subtree we are currently at.\n+    for &(idx, _) in repeats {\n+        if let MatchedSeq(ref ads) = matched {\n+            matched = &ads[idx];\n+        }\n+    }\n+    count(cx, 0, depth_opt, matched, sp)\n+}\n+\n+/// Returns a `NamedMatch` item declared on the RHS given an arbitrary [Ident]\n+fn matched_from_ident<'ctx, 'interp, 'rslt>(\n+    cx: &ExtCtxt<'ctx>,\n+    ident: Ident,\n+    interp: &'interp FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,\n+) -> PResult<'ctx, &'rslt NamedMatch>\n+where\n+    'interp: 'rslt,\n+{\n+    let span = ident.span;\n+    let key = MacroRulesNormalizedIdent::new(ident);\n+    interp.get(&key).ok_or_else(|| {\n+        cx.struct_span_err(\n+            span,\n+            &format!(\"variable `{}` is not recognized in meta-variable expression\", key),\n+        )\n+    })\n+}\n+\n+/// Used by meta-variable expressions when an user input is out of the actual declared bounds. For\n+/// example, index(999999) in an repetition of only three elements.\n+fn out_of_bounds_err<'a>(\n+    cx: &ExtCtxt<'a>,\n+    max: usize,\n+    span: Span,\n+    ty: &str,\n+) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+    cx.struct_span_err(span, &format!(\"{ty} depth must be less than {max}\"))\n+}\n+\n fn transcribe_metavar_expr<'a>(\n-    _cx: &ExtCtxt<'a>,\n-    _expr: mbe::MetaVarExpr,\n-    _interp: &FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,\n-    _repeats: &[(usize, usize)],\n-    _result: &mut Vec<TreeAndSpacing>,\n-    _sp: &DelimSpan,\n+    cx: &ExtCtxt<'a>,\n+    expr: MetaVarExpr,\n+    interp: &FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,\n+    repeats: &[(usize, usize)],\n+    result: &mut Vec<TreeAndSpacing>,\n+    sp: &DelimSpan,\n ) -> PResult<'a, ()> {\n+    match expr {\n+        MetaVarExpr::Count(original_ident, depth_opt) => {\n+            let matched = matched_from_ident(cx, original_ident, interp)?;\n+            let count = count_repetitions(cx, depth_opt, matched, &repeats, sp)?;\n+            let tt = TokenTree::token(\n+                TokenKind::lit(token::Integer, sym::integer(count), None),\n+                sp.entire(),\n+            );\n+            result.push(tt.into());\n+        }\n+        MetaVarExpr::Ignore(original_ident) => {\n+            // Used to ensure that `original_ident` is present in the LHS\n+            let _ = matched_from_ident(cx, original_ident, interp)?;\n+        }\n+        MetaVarExpr::Index(depth) => match repeats.iter().nth_back(depth) {\n+            Some((index, _)) => {\n+                result.push(\n+                    TokenTree::token(\n+                        TokenKind::lit(token::Integer, sym::integer(*index), None),\n+                        sp.entire(),\n+                    )\n+                    .into(),\n+                );\n+            }\n+            None => return Err(out_of_bounds_err(cx, repeats.len(), sp.entire(), \"index\")),\n+        },\n+        MetaVarExpr::Length(depth) => match repeats.iter().nth_back(depth) {\n+            Some((_, length)) => {\n+                result.push(\n+                    TokenTree::token(\n+                        TokenKind::lit(token::Integer, sym::integer(*length), None),\n+                        sp.entire(),\n+                    )\n+                    .into(),\n+                );\n+            }\n+            None => return Err(out_of_bounds_err(cx, repeats.len(), sp.entire(), \"length\")),\n+        },\n+    }\n     Ok(())\n }"}, {"sha": "ab8d95a41d0d77390da2d09e2e18f4a9b3c40ba1", "filename": "src/test/ui/macros/rfc-3086-metavar-expr/count-and-length-are-distinct.rs", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/8c87132103e350821bb8f8abbd90f3d6feebecd1/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fcount-and-length-are-distinct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c87132103e350821bb8f8abbd90f3d6feebecd1/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fcount-and-length-are-distinct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fcount-and-length-are-distinct.rs?ref=8c87132103e350821bb8f8abbd90f3d6feebecd1", "patch": "@@ -0,0 +1,271 @@\n+// run-pass\n+\n+#![feature(macro_metavar_expr)]\n+\n+fn main() {\n+    macro_rules! one_nested_count_and_length {\n+        ( $( [ $( $l:literal ),* ] ),* ) => {\n+            [\n+                // outer-most repetition\n+                $(\n+                    // inner-most repetition\n+                    $(\n+                        ${ignore(l)} ${index()}, ${length()},\n+                    )*\n+                    ${count(l)}, ${index()}, ${length()},\n+                )*\n+                ${count(l)},\n+            ]\n+        };\n+    }\n+    assert_eq!(\n+        one_nested_count_and_length!([\"foo\"], [\"bar\", \"baz\"]),\n+        [\n+            // # [\"foo\"]\n+\n+            // ## inner-most repetition (first iteration)\n+            //\n+            // `index` is 0 because this is the first inner-most iteration.\n+            // `length` is 1 because there is only one inner-most repetition, \"foo\".\n+            0, 1,\n+\n+            // ## outer-most repetition (first iteration)\n+            //\n+            // `count` is 1 because of \"foo\", i,e, `$l` has only one repetition,\n+            // `index` is 0 because this is the first outer-most iteration.\n+            // `length` is 2 because there are 2 outer-most repetitions, [\"foo\"] and [\"bar\", \"baz\"]\n+            1, 0, 2,\n+\n+            // # [\"bar\", \"baz\"]\n+\n+            // ## inner-most repetition (first iteration)\n+            //\n+            // `index` is 0 because this is the first inner-most iteration\n+            // `length` is 2 because there are repetitions, \"bar\" and \"baz\"\n+            0, 2,\n+\n+            // ## inner-most repetition (second iteration)\n+            //\n+            // `index` is 1 because this is the second inner-most iteration\n+            // `length` is 2 because there are repetitions, \"bar\" and \"baz\"\n+            1, 2,\n+\n+            // ## outer-most repetition (second iteration)\n+            //\n+            // `count` is 2 because of \"bar\" and \"baz\", i,e, `$l` has two repetitions,\n+            // `index` is 1 because this is the second outer-most iteration\n+            // `length` is 2 because there are 2 outer-most repetitions, [\"foo\"] and [\"bar\", \"baz\"]\n+            2, 1, 2,\n+\n+            // # last count\n+\n+            // Because there are a total of 3 repetitions of `$l`, \"foo\", \"bar\" and \"baz\"\n+            3,\n+        ]\n+    );\n+\n+    // Based on the above explanation, the following macros should be straightforward\n+\n+    // Grouped from the outer-most to the inner-most\n+    macro_rules! three_nested_count {\n+        ( $( { $( [ $( ( $( $i:ident )* ) )* ] )* } )* ) => {\n+            &[\n+                $( $( $(\n+                    &[\n+                        ${ignore(i)} ${count(i, 0)},\n+                    ][..],\n+                )* )* )*\n+\n+                $( $(\n+                    &[\n+                        ${ignore(i)} ${count(i, 0)},\n+                        ${ignore(i)} ${count(i, 1)},\n+                    ][..],\n+                )* )*\n+\n+                $(\n+                    &[\n+                        ${ignore(i)} ${count(i, 0)},\n+                        ${ignore(i)} ${count(i, 1)},\n+                        ${ignore(i)} ${count(i, 2)},\n+                    ][..],\n+                )*\n+\n+                &[\n+                    ${count(i, 0)},\n+                    ${count(i, 1)},\n+                    ${count(i, 2)},\n+                    ${count(i, 3)},\n+                ][..]\n+            ][..]\n+        }\n+    }\n+    assert_eq!(\n+        three_nested_count!(\n+            {\n+                [ (a b c) (d e f) ]\n+                [ (g h) (i j k l m) ]\n+                [ (n) ]\n+            }\n+            {\n+                [ (o) (p q) (r s) ]\n+                [ (t u v w x y z) ]\n+            }\n+        ),\n+        &[\n+            // a b c\n+            &[3][..],\n+            // d e f\n+            &[3][..],\n+            // g h\n+            &[2][..],\n+            // i j k l m\n+            &[5][..],\n+            // n\n+            &[1][..],\n+            // o\n+            &[1][..],\n+            // p q\n+            &[2][..],\n+            // r s\n+            &[2][..],\n+            // t u v w x y z\n+            &[7][..],\n+\n+            // (a b c) (d e f)\n+            &[2, 6][..],\n+            // (g h) (i j k l m)\n+            &[2, 7][..],\n+            // (n)\n+            &[1, 1][..],\n+            // (o) (p q) (r s)\n+            &[3, 5][..],\n+            // (t u v w x y z)\n+            &[1, 7][..],\n+\n+            // [ (a b c) (d e f) ]\n+            // [ (g h) (i j k l m) ]\n+            // [ (n) ]\n+            &[3, 5, 14][..],\n+            // [ (o) (p q) (r s) ]\n+            // [ (t u v w x y z) ]\n+            &[2, 4, 12][..],\n+\n+            // {\n+            //     [ (a b c) (d e f) ]\n+            //     [ (g h) (i j k l m) ]\n+            //     [ (n) ]\n+            // }\n+            // {\n+            //     [ (o) (p q) (r s) ]\n+            //     [ (t u v w x y z) ]\n+            // }\n+            &[2, 5, 9, 26][..]\n+        ][..]\n+    );\n+\n+    // Grouped from the outer-most to the inner-most\n+    macro_rules! three_nested_length {\n+        ( $( { $( [ $( ( $( $i:ident )* ) )* ] )* } )* ) => {\n+            &[\n+                $( $( $( $(\n+                    &[\n+                        ${ignore(i)} ${length(3)},\n+                        ${ignore(i)} ${length(2)},\n+                        ${ignore(i)} ${length(1)},\n+                        ${ignore(i)} ${length(0)},\n+                    ][..],\n+                )* )* )* )*\n+\n+                $( $( $(\n+                    &[\n+                        ${ignore(i)} ${length(2)},\n+                        ${ignore(i)} ${length(1)},\n+                        ${ignore(i)} ${length(0)},\n+                    ][..],\n+                )* )* )*\n+\n+                $( $(\n+                    &[\n+                        ${ignore(i)} ${length(1)},\n+                        ${ignore(i)} ${length(0)},\n+                    ][..],\n+                )* )*\n+\n+                $(\n+                    &[\n+                        ${ignore(i)} ${length(0)},\n+                    ][..],\n+                )*\n+            ][..]\n+        }\n+    }\n+    assert_eq!(\n+        three_nested_length!(\n+            {\n+                [ (a b c) (d e f) ]\n+                [ (g h) (i j k l m) ]\n+                [ (n) ]\n+            }\n+            {\n+                [ (o) (p q) (r s) ]\n+                [ (t u v w x y z) ]\n+            }\n+        ),\n+        &[\n+            // a b c\n+            &[2, 3, 2, 3][..], &[2, 3, 2, 3][..], &[2, 3, 2, 3][..],\n+            // d e f\n+            &[2, 3, 2, 3][..], &[2, 3, 2, 3][..], &[2, 3, 2, 3][..],\n+            // g h\n+            &[2, 3, 2, 2][..], &[2, 3, 2, 2][..],\n+            // i j k l m\n+            &[2, 3, 2, 5][..], &[2, 3, 2, 5][..], &[2, 3, 2, 5][..], &[2, 3, 2, 5][..],\n+            &[2, 3, 2, 5][..],\n+            // n\n+            &[2, 3, 1, 1][..],\n+            // o\n+            &[2, 2, 3, 1][..],\n+            // p q\n+            &[2, 2, 3, 2][..], &[2, 2, 3, 2][..],\n+            // r s\n+            &[2, 2, 3, 2][..], &[2, 2, 3, 2][..],\n+            // t u v w x y z\n+            &[2, 2, 1, 7][..], &[2, 2, 1, 7][..], &[2, 2, 1, 7][..], &[2, 2, 1, 7][..],\n+            &[2, 2, 1, 7][..], &[2, 2, 1, 7][..], &[2, 2, 1, 7][..],\n+\n+            // (a b c) (d e f)\n+            &[2, 3, 2][..], &[2, 3, 2][..],\n+            // (g h) (i j k l m)\n+            &[2, 3, 2][..], &[2, 3, 2][..],\n+            // (n)\n+            &[2, 3, 1][..],\n+            // (o) (p q) (r s)\n+            &[2, 2, 3][..], &[2, 2, 3][..], &[2, 2, 3][..],\n+            // (t u v w x y z)\n+            &[2, 2, 1][..],\n+\n+            // [ (a b c) (d e f) ]\n+            // [ (g h) (i j k l m) ]\n+            // [ (n) ]\n+            &[2, 3][..], &[2, 3][..],  &[2, 3,][..],\n+            // [ (o) (p q) (r s) ]\n+            // [ (t u v w x y z) ]\n+            &[2, 2][..], &[2, 2][..],\n+\n+            // {\n+            //     [ (a b c) (d e f) ]\n+            //     [ (g h) (i j k l m) ]\n+            //     [ (n) ]\n+            // }\n+            // {\n+            //     [ (o) (p q) (r s) ]\n+            //     [ (t u v w x y z) ]\n+            // }\n+            &[2][..], &[2][..]\n+        ][..]\n+    );\n+\n+    // It is possible to say, to some degree, that count is an \"amalgamation\" of length (see\n+    // each length line result and compare them with the count results)\n+}"}, {"sha": "d05cd1b31bc12735fc3e06ca581376b055942941", "filename": "src/test/ui/macros/rfc-3086-metavar-expr/feature-gate-macro_metavar_expr.rs", "status": "modified", "additions": 140, "deletions": 6, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/8c87132103e350821bb8f8abbd90f3d6feebecd1/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Ffeature-gate-macro_metavar_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c87132103e350821bb8f8abbd90f3d6feebecd1/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Ffeature-gate-macro_metavar_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Ffeature-gate-macro_metavar_expr.rs?ref=8c87132103e350821bb8f8abbd90f3d6feebecd1", "patch": "@@ -2,13 +2,147 @@\n \n #![feature(macro_metavar_expr)]\n \n-macro_rules! ignore {\n-    ( $( $i:ident ),* ) => {{\n-        let array: [i32; 0] = [$( ${ignore(i)} )*];\n-        array\n-    }};\n+/// Count the number of idents in a macro repetition.\n+macro_rules! count_idents {\n+    ( $( $i:ident ),* ) => {\n+        ${count(i)}\n+    };\n }\n \n+/// Count the number of idents in a 2-dimensional macro repetition.\n+macro_rules! count_idents_2 {\n+    ( $( [ $( $i:ident ),* ] ),* ) => {\n+        ${count(i)}\n+    };\n+}\n+\n+/// Mostly counts the number of OUTER-MOST repetitions\n+macro_rules! count_depth_limits {\n+    ( $( { $( [ $( $outer:ident : ( $( $inner:ident )* ) )* ] )* } )* ) => {\n+        (\n+            (\n+                ${count(inner)},\n+                ${count(inner, 0)},\n+                ${count(inner, 1)},\n+                ${count(inner, 2)},\n+                ${count(inner, 3)},\n+            ),\n+            (\n+                ${count(outer)},\n+                ${count(outer, 0)},\n+                ${count(outer, 1)},\n+                ${count(outer, 2)},\n+            ),\n+        )\n+    };\n+}\n+\n+/// Produce (index, length) pairs for literals in a macro repetition.\n+/// The literal is not included in the output, so this macro uses the\n+/// `ignore` meta-variable expression to create a non-expanding\n+/// repetition binding.\n+macro_rules! enumerate_literals {\n+    ( $( ($l:stmt) ),* ) => {\n+        [$( ${ignore(l)} (${index()}, ${length()}) ),*]\n+    };\n+}\n+\n+/// Produce index and length tuples for literals in a 2-dimensional\n+/// macro repetition.\n+macro_rules! enumerate_literals_2 {\n+    ( $( [ $( ($l:literal) ),* ] ),* ) => {\n+        [\n+            $(\n+                $(\n+                    (\n+                        ${index(1)},\n+                        ${length(1)},\n+                        ${index(0)},\n+                        ${length(0)},\n+                        $l\n+                    ),\n+                )*\n+            )*\n+        ]\n+    };\n+}\n+\n+/// Generate macros that count idents and then add a constant number\n+/// to the count.\n+///\n+/// This macro uses dollar escaping to make it unambiguous as to which\n+/// macro the repetition belongs to.\n+macro_rules! make_count_adders {\n+    ( $( $i:ident, $b:literal );* ) => {\n+        $(\n+            macro_rules! $i {\n+                ( $$( $$j:ident ),* ) => {\n+                    $b + $${count(j)}\n+                };\n+            }\n+        )*\n+    };\n+}\n+\n+make_count_adders! { plus_one, 1; plus_five, 5 }\n+\n+/// Generate a macro that allows selection of a particular literal\n+/// from a sequence of inputs by their identifier.\n+///\n+/// This macro uses dollar escaping to make it unambiguous as to which\n+/// macro the repetition belongs to, and to allow expansion of an\n+/// identifier the name of which is not known in the definition\n+/// of `make_picker`.\n+macro_rules! make_picker {\n+    ( $m:ident => $( $i:ident ),* ; $p:ident ) => {\n+        macro_rules! $m {\n+            ( $( $$ $i:literal ),* ) => {\n+                $$ $p\n+            };\n+        }\n+    };\n+}\n+\n+make_picker!(first => a, b; a);\n+\n+make_picker!(second => a, b; b);\n+\n fn main() {\n-    assert_eq!(ignore!(a, b, c), []);\n+    assert_eq!(count_idents!(a, b, c), 3);\n+    assert_eq!(count_idents_2!([a, b, c], [d, e], [f]), 6);\n+    assert_eq!(\n+        count_depth_limits! {\n+            {\n+                [ A: (a b c) D: (d e f) ]\n+                [ G: (g h) I: (i j k l m) ]\n+                [ N: (n) ]\n+            }\n+            {\n+                [ O: (o) P: (p q) R: (r s) ]\n+                [ T: (t u v w x y z) ]\n+            }\n+        },\n+        ((26, 2, 5, 9, 26), (9, 2, 5, 9))\n+    );\n+    assert_eq!(enumerate_literals![(\"foo\"), (\"bar\")], [(0, 2), (1, 2)]);\n+    assert_eq!(\n+        enumerate_literals_2![\n+            [(\"foo\"), (\"bar\"), (\"baz\")],\n+            [(\"qux\"), (\"quux\"), (\"quuz\"), (\"xyzzy\")]\n+        ],\n+        [\n+            (0, 2, 0, 3, \"foo\"),\n+            (0, 2, 1, 3, \"bar\"),\n+            (0, 2, 2, 3, \"baz\"),\n+\n+            (1, 2, 0, 4, \"qux\"),\n+            (1, 2, 1, 4, \"quux\"),\n+            (1, 2, 2, 4, \"quuz\"),\n+            (1, 2, 3, 4, \"xyzzy\"),\n+        ]\n+    );\n+    assert_eq!(plus_one!(a, b, c), 4);\n+    assert_eq!(plus_five!(a, b), 7);\n+    assert_eq!(first!(1, 2), 1);\n+    assert_eq!(second!(1, 2), 2);\n }"}, {"sha": "b954967c4fe5a993c609ea801ca0494124e2bc24", "filename": "src/test/ui/macros/rfc-3086-metavar-expr/macro-expansion.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/8c87132103e350821bb8f8abbd90f3d6feebecd1/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fmacro-expansion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c87132103e350821bb8f8abbd90f3d6feebecd1/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fmacro-expansion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fmacro-expansion.rs?ref=8c87132103e350821bb8f8abbd90f3d6feebecd1", "patch": "@@ -0,0 +1,102 @@\n+// run-pass\n+\n+#![feature(macro_metavar_expr)]\n+\n+#[derive(Debug)]\n+struct Example<'a> {\n+    _indexes: &'a [(u32, u32)],\n+    _counts: &'a [u32],\n+    _nested: Vec<Example<'a>>,\n+}\n+\n+macro_rules! example {\n+    ( $( [ $( ( $( $x:ident )* ) )* ] )* ) => {\n+        Example {\n+            _indexes: &[],\n+            _counts: &[${count(x, 0)}, ${count(x, 1)}, ${count(x, 2)}],\n+            _nested: vec![\n+            $(\n+                Example {\n+                    _indexes: &[(${index()}, ${length()})],\n+                    _counts: &[${count(x, 0)}, ${count(x, 1)}],\n+                    _nested: vec![\n+                    $(\n+                        Example {\n+                            _indexes: &[(${index(1)}, ${length(1)}), (${index()}, ${length()})],\n+                            _counts: &[${count(x)}],\n+                            _nested: vec![\n+                            $(\n+                                Example {\n+                                    _indexes: &[\n+                                        (${index(2)}, ${length(2)}),\n+                                        (${index(1)}, ${length(1)}),\n+                                        (${index()}, ${length()})\n+                                    ],\n+                                    _counts: &[],\n+                                    _nested: vec![],\n+                                    ${ignore(x)}\n+                                }\n+                            ),*\n+                            ]\n+                        }\n+                    ),*\n+                    ]\n+                }\n+            ),*\n+            ]\n+        }\n+    };\n+}\n+\n+static EXPECTED: &str = concat!(\n+    \"Example { _indexes: [], _counts: [2, 4, 13], _nested: [\",\n+    concat!(\n+        \"Example { _indexes: [(0, 2)], _counts: [3, 10], _nested: [\",\n+        concat!(\n+            \"Example { _indexes: [(0, 2), (0, 3)], _counts: [4], _nested: [\",\n+            concat!(\n+                \"Example { _indexes: [(0, 2), (0, 3), (0, 4)], _counts: [], _nested: [] }, \",\n+                \"Example { _indexes: [(0, 2), (0, 3), (1, 4)], _counts: [], _nested: [] }, \",\n+                \"Example { _indexes: [(0, 2), (0, 3), (2, 4)], _counts: [], _nested: [] }, \",\n+                \"Example { _indexes: [(0, 2), (0, 3), (3, 4)], _counts: [], _nested: [] }\",\n+            ),\n+            \"] }, \",\n+            \"Example { _indexes: [(0, 2), (1, 3)], _counts: [4], _nested: [\",\n+            concat!(\n+                \"Example { _indexes: [(0, 2), (1, 3), (0, 4)], _counts: [], _nested: [] }, \",\n+                \"Example { _indexes: [(0, 2), (1, 3), (1, 4)], _counts: [], _nested: [] }, \",\n+                \"Example { _indexes: [(0, 2), (1, 3), (2, 4)], _counts: [], _nested: [] }, \",\n+                \"Example { _indexes: [(0, 2), (1, 3), (3, 4)], _counts: [], _nested: [] }\",\n+            ),\n+            \"] }, \",\n+            \"Example { _indexes: [(0, 2), (2, 3)], _counts: [2], _nested: [\",\n+            concat!(\n+                \"Example { _indexes: [(0, 2), (2, 3), (0, 2)], _counts: [], _nested: [] }, \",\n+                \"Example { _indexes: [(0, 2), (2, 3), (1, 2)], _counts: [], _nested: [] }\",\n+            ),\n+            \"] }\",\n+        ),\n+        \"] }, \",\n+        \"Example { _indexes: [(1, 2)], _counts: [1, 3], _nested: [\",\n+        concat!(\n+            \"Example { _indexes: [(1, 2), (0, 1)], _counts: [3], _nested: [\",\n+            concat!(\n+                \"Example { _indexes: [(1, 2), (0, 1), (0, 3)], _counts: [], _nested: [] }, \",\n+                \"Example { _indexes: [(1, 2), (0, 1), (1, 3)], _counts: [], _nested: [] }, \",\n+                \"Example { _indexes: [(1, 2), (0, 1), (2, 3)], _counts: [], _nested: [] }\",\n+            ),\n+            \"] }\",\n+        ),\n+        \"] }\",\n+    ),\n+    \"] }\",\n+);\n+\n+fn main() {\n+    let e = example! {\n+        [ ( A B C D ) ( E F G H ) ( I J ) ]\n+        [ ( K L M ) ]\n+    };\n+    let debug = format!(\"{:?}\", e);\n+    assert_eq!(debug, EXPECTED);\n+}"}, {"sha": "d81c8628bab26797343d1488c1d44131eefe97b5", "filename": "src/test/ui/macros/rfc-3086-metavar-expr/out-of-bounds-arguments.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8c87132103e350821bb8f8abbd90f3d6feebecd1/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fout-of-bounds-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c87132103e350821bb8f8abbd90f3d6feebecd1/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fout-of-bounds-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fout-of-bounds-arguments.rs?ref=8c87132103e350821bb8f8abbd90f3d6feebecd1", "patch": "@@ -0,0 +1,44 @@\n+#![feature(macro_metavar_expr)]\n+\n+macro_rules! a {\n+    ( $( { $( [ $( ( $( $foo:ident )* ) )* ] )* } )* ) => {\n+        (\n+            ${count(foo, 0)},\n+            ${count(foo, 10)},\n+            //~^ ERROR count depth must be less than 4\n+        )\n+    };\n+}\n+\n+macro_rules! b {\n+    ( $( { $( [ $( $foo:ident )* ] )* } )* ) => {\n+        (\n+            $( $( $(\n+                ${ignore(foo)}\n+                ${index(0)},\n+                ${index(10)},\n+                //~^ ERROR index depth must be less than 3\n+            )* )* )*\n+        )\n+    };\n+}\n+\n+macro_rules! c {\n+    ( $( { $( $foo:ident )* } )* ) => {\n+        (\n+            $( $(\n+                ${ignore(foo)}\n+                ${length(0)}\n+                ${length(10)}\n+                //~^ ERROR length depth must be less than 2\n+            )* )*\n+        )\n+    };\n+}\n+\n+\n+fn main() {\n+    a!( { [ (a) ] [ (b c) ] } );\n+    b!( { [ a b ] } );\n+    c!( { a } );\n+}"}, {"sha": "7474c03c0f98ba31e613ef34c397deb72bcdb0d7", "filename": "src/test/ui/macros/rfc-3086-metavar-expr/out-of-bounds-arguments.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c87132103e350821bb8f8abbd90f3d6feebecd1/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fout-of-bounds-arguments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c87132103e350821bb8f8abbd90f3d6feebecd1/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fout-of-bounds-arguments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fout-of-bounds-arguments.stderr?ref=8c87132103e350821bb8f8abbd90f3d6feebecd1", "patch": "@@ -0,0 +1,20 @@\n+error: count depth must be less than 4\n+  --> $DIR/out-of-bounds-arguments.rs:7:14\n+   |\n+LL |             ${count(foo, 10)},\n+   |              ^^^^^^^^^^^^^^^^\n+\n+error: index depth must be less than 3\n+  --> $DIR/out-of-bounds-arguments.rs:19:18\n+   |\n+LL |                 ${index(10)},\n+   |                  ^^^^^^^^^^^\n+\n+error: length depth must be less than 2\n+  --> $DIR/out-of-bounds-arguments.rs:32:18\n+   |\n+LL |                 ${length(10)}\n+   |                  ^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "fdf16442d2aa5d0d35917e559c2c0cc2511a6127", "filename": "src/test/ui/macros/rfc-3086-metavar-expr/syntax-errors.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8c87132103e350821bb8f8abbd90f3d6feebecd1/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fsyntax-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c87132103e350821bb8f8abbd90f3d6feebecd1/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fsyntax-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fsyntax-errors.rs?ref=8c87132103e350821bb8f8abbd90f3d6feebecd1", "patch": "@@ -10,6 +10,7 @@ macro_rules! curly__no_rhs_dollar__round {\n \n macro_rules! curly__no_rhs_dollar__no_round {\n     ( $i:ident ) => { ${ count(i) } };\n+    //~^ ERROR `count` can not be placed inside the inner-most repetition\n }\n \n macro_rules! curly__rhs_dollar__round {\n@@ -121,6 +122,20 @@ macro_rules! open_brackets_without_tokens {\n     //~| ERROR expected identifier\n }\n \n+macro_rules! unknown_count_ident {\n+    ( $( $i:ident )* ) => {\n+        ${count(foo)}\n+        //~^ ERROR variable `foo` is not recognized in meta-variable expression\n+    };\n+}\n+\n+macro_rules! unknown_ignore_ident {\n+    ( $( $i:ident )* ) => {\n+        ${ignore(bar)}\n+        //~^ ERROR variable `bar` is not recognized in meta-variable expression\n+    };\n+}\n+\n macro_rules! unknown_metavar {\n     ( $( $i:ident ),* ) => { ${ aaaaaaaaaaaaaa(i) } };\n     //~^ ERROR unrecognized meta-variable expression\n@@ -139,10 +154,12 @@ fn main() {\n     //~^ ERROR cannot find value `a` in this scope\n \n     extra_garbage_after_metavar!(a);\n-    unknown_metavar!(a);\n-    metavar_without_parens!(a);\n-    metavar_token_without_ident!(a);\n     metavar_depth_is_not_literal!(a);\n+    metavar_token_without_ident!(a);\n     metavar_with_literal_suffix!(a);\n-    open_brackets_without_tokens!(a)\n+    metavar_without_parens!(a);\n+    open_brackets_without_tokens!(a);\n+    unknown_count_ident!(a);\n+    unknown_ignore_ident!(a);\n+    unknown_metavar!(a);\n }"}, {"sha": "0188938a30e8d9bc58482f8f20e6a1ea2e5af0e9", "filename": "src/test/ui/macros/rfc-3086-metavar-expr/syntax-errors.stderr", "status": "modified", "additions": 91, "deletions": 73, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/8c87132103e350821bb8f8abbd90f3d6feebecd1/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fsyntax-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c87132103e350821bb8f8abbd90f3d6feebecd1/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fsyntax-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fsyntax-errors.stderr?ref=8c87132103e350821bb8f8abbd90f3d6feebecd1", "patch": "@@ -1,203 +1,209 @@\n error: expected identifier, found `$`\n-  --> $DIR/syntax-errors.rs:16:33\n+  --> $DIR/syntax-errors.rs:17:33\n    |\n LL |     ( $( $i:ident ),* ) => { ${ count($i) } };\n    |                                 ^^^^^ - help: try removing `$`\n \n error: expected identifier, found `$`\n-  --> $DIR/syntax-errors.rs:22:26\n+  --> $DIR/syntax-errors.rs:23:26\n    |\n LL |     ( $i:ident ) => { ${ count($i) } };\n    |                          ^^^^^ - help: try removing `$`\n \n error: unexpected token: $\n-  --> $DIR/syntax-errors.rs:52:8\n+  --> $DIR/syntax-errors.rs:53:8\n    |\n LL |     ( $$ $a:ident ) => {\n    |        ^\n \n note: `$$` and meta-variable expressions are not allowed inside macro parameter definitions\n-  --> $DIR/syntax-errors.rs:52:8\n+  --> $DIR/syntax-errors.rs:53:8\n    |\n LL |     ( $$ $a:ident ) => {\n    |        ^\n \n error: unexpected token: a\n-  --> $DIR/syntax-errors.rs:59:19\n+  --> $DIR/syntax-errors.rs:60:19\n    |\n LL |         ${count() a b c}\n    |                   ^\n    |\n note: meta-variable expression must not have trailing tokens\n-  --> $DIR/syntax-errors.rs:59:19\n+  --> $DIR/syntax-errors.rs:60:19\n    |\n LL |         ${count() a b c}\n    |                   ^\n \n error: unexpected token: a\n-  --> $DIR/syntax-errors.rs:62:19\n+  --> $DIR/syntax-errors.rs:63:19\n    |\n LL |         ${count(i a b c)}\n    |                   ^\n    |\n note: meta-variable expression must not have trailing tokens\n-  --> $DIR/syntax-errors.rs:62:19\n+  --> $DIR/syntax-errors.rs:63:19\n    |\n LL |         ${count(i a b c)}\n    |                   ^\n \n error: unexpected token: a\n-  --> $DIR/syntax-errors.rs:64:22\n+  --> $DIR/syntax-errors.rs:65:22\n    |\n LL |         ${count(i, 1 a b c)}\n    |                      ^\n    |\n note: meta-variable expression must not have trailing tokens\n-  --> $DIR/syntax-errors.rs:64:22\n+  --> $DIR/syntax-errors.rs:65:22\n    |\n LL |         ${count(i, 1 a b c)}\n    |                      ^\n \n error: unexpected token: a\n-  --> $DIR/syntax-errors.rs:66:20\n+  --> $DIR/syntax-errors.rs:67:20\n    |\n LL |         ${count(i) a b c}\n    |                    ^\n    |\n note: meta-variable expression must not have trailing tokens\n-  --> $DIR/syntax-errors.rs:66:20\n+  --> $DIR/syntax-errors.rs:67:20\n    |\n LL |         ${count(i) a b c}\n    |                    ^\n \n error: unexpected token: a\n-  --> $DIR/syntax-errors.rs:69:21\n+  --> $DIR/syntax-errors.rs:70:21\n    |\n LL |         ${ignore(i) a b c}\n    |                     ^\n    |\n note: meta-variable expression must not have trailing tokens\n-  --> $DIR/syntax-errors.rs:69:21\n+  --> $DIR/syntax-errors.rs:70:21\n    |\n LL |         ${ignore(i) a b c}\n    |                     ^\n \n error: unexpected token: a\n-  --> $DIR/syntax-errors.rs:71:20\n+  --> $DIR/syntax-errors.rs:72:20\n    |\n LL |         ${ignore(i a b c)}\n    |                    ^\n    |\n note: meta-variable expression must not have trailing tokens\n-  --> $DIR/syntax-errors.rs:71:20\n+  --> $DIR/syntax-errors.rs:72:20\n    |\n LL |         ${ignore(i a b c)}\n    |                    ^\n \n error: unexpected token: a\n-  --> $DIR/syntax-errors.rs:74:19\n+  --> $DIR/syntax-errors.rs:75:19\n    |\n LL |         ${index() a b c}\n    |                   ^\n    |\n note: meta-variable expression must not have trailing tokens\n-  --> $DIR/syntax-errors.rs:74:19\n+  --> $DIR/syntax-errors.rs:75:19\n    |\n LL |         ${index() a b c}\n    |                   ^\n \n error: unexpected token: a\n-  --> $DIR/syntax-errors.rs:76:19\n+  --> $DIR/syntax-errors.rs:77:19\n    |\n LL |         ${index(1 a b c)}\n    |                   ^\n    |\n note: meta-variable expression must not have trailing tokens\n-  --> $DIR/syntax-errors.rs:76:19\n+  --> $DIR/syntax-errors.rs:77:19\n    |\n LL |         ${index(1 a b c)}\n    |                   ^\n \n error: unexpected token: a\n-  --> $DIR/syntax-errors.rs:79:19\n+  --> $DIR/syntax-errors.rs:80:19\n    |\n LL |         ${index() a b c}\n    |                   ^\n    |\n note: meta-variable expression must not have trailing tokens\n-  --> $DIR/syntax-errors.rs:79:19\n+  --> $DIR/syntax-errors.rs:80:19\n    |\n LL |         ${index() a b c}\n    |                   ^\n \n error: unexpected token: a\n-  --> $DIR/syntax-errors.rs:81:19\n+  --> $DIR/syntax-errors.rs:82:19\n    |\n LL |         ${index(1 a b c)}\n    |                   ^\n    |\n note: meta-variable expression must not have trailing tokens\n-  --> $DIR/syntax-errors.rs:81:19\n+  --> $DIR/syntax-errors.rs:82:19\n    |\n LL |         ${index(1 a b c)}\n    |                   ^\n \n error: meta-variable expression depth must be a literal\n-  --> $DIR/syntax-errors.rs:88:33\n+  --> $DIR/syntax-errors.rs:89:33\n    |\n LL |     ( $( $i:ident ),* ) => { ${ index(IDX) } };\n    |                                 ^^^^^\n \n error: unexpected token: {\n-  --> $DIR/syntax-errors.rs:94:8\n+  --> $DIR/syntax-errors.rs:95:8\n    |\n LL |     ( ${ length() } ) => {\n    |        ^^^^^^^^^^^^\n \n note: `$$` and meta-variable expressions are not allowed inside macro parameter definitions\n-  --> $DIR/syntax-errors.rs:94:8\n+  --> $DIR/syntax-errors.rs:95:8\n    |\n LL |     ( ${ length() } ) => {\n    |        ^^^^^^^^^^^^\n \n error: expected one of: `*`, `+`, or `?`\n-  --> $DIR/syntax-errors.rs:94:8\n+  --> $DIR/syntax-errors.rs:95:8\n    |\n LL |     ( ${ length() } ) => {\n    |        ^^^^^^^^^^^^\n \n error: expected identifier\n-  --> $DIR/syntax-errors.rs:101:33\n+  --> $DIR/syntax-errors.rs:102:33\n    |\n LL |     ( $( $i:ident ),* ) => { ${ ignore() } };\n    |                                 ^^^^^^\n \n error: only unsuffixes integer literals are supported in meta-variable expressions\n-  --> $DIR/syntax-errors.rs:107:33\n+  --> $DIR/syntax-errors.rs:108:33\n    |\n LL |     ( $( $i:ident ),* ) => { ${ index(1u32) } };\n    |                                 ^^^^^\n \n error: meta-variable expression parameter must be wrapped in parentheses\n-  --> $DIR/syntax-errors.rs:113:33\n+  --> $DIR/syntax-errors.rs:114:33\n    |\n LL |     ( $( $i:ident ),* ) => { ${ count{i} } };\n    |                                 ^^^^^\n \n error: expected identifier\n-  --> $DIR/syntax-errors.rs:119:31\n+  --> $DIR/syntax-errors.rs:120:31\n    |\n LL |     ( $( $i:ident ),* ) => { ${ {} } };\n    |                               ^^^^^^\n \n error: unrecognized meta-variable expression\n-  --> $DIR/syntax-errors.rs:125:33\n+  --> $DIR/syntax-errors.rs:140:33\n    |\n LL |     ( $( $i:ident ),* ) => { ${ aaaaaaaaaaaaaa(i) } };\n    |                                 ^^^^^^^^^^^^^^ help: supported expressions are count, ignore, index and length\n \n+error: `count` can not be placed inside the inner-most repetition\n+  --> $DIR/syntax-errors.rs:12:24\n+   |\n+LL |     ( $i:ident ) => { ${ count(i) } };\n+   |                        ^^^^^^^^^^^^\n+\n error: expected expression, found `$`\n-  --> $DIR/syntax-errors.rs:16:30\n+  --> $DIR/syntax-errors.rs:17:30\n    |\n LL |     ( $( $i:ident ),* ) => { ${ count($i) } };\n    |                              ^ expected expression\n@@ -208,7 +214,7 @@ LL |     curly__rhs_dollar__round!(a, b, c);\n    = note: this error originates in the macro `curly__rhs_dollar__round` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: expected expression, found `$`\n-  --> $DIR/syntax-errors.rs:22:23\n+  --> $DIR/syntax-errors.rs:23:23\n    |\n LL |     ( $i:ident ) => { ${ count($i) } };\n    |                       ^ expected expression\n@@ -219,13 +225,13 @@ LL |     curly__rhs_dollar__no_round!(a);\n    = note: this error originates in the macro `curly__rhs_dollar__no_round` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: variable 'i' is still repeating at this depth\n-  --> $DIR/syntax-errors.rs:40:36\n+  --> $DIR/syntax-errors.rs:41:36\n    |\n LL |     ( $( $i:ident ),* ) => { count($i) };\n    |                                    ^^\n \n error: expected expression, found `$`\n-  --> $DIR/syntax-errors.rs:59:9\n+  --> $DIR/syntax-errors.rs:60:9\n    |\n LL |         ${count() a b c}\n    |         ^ expected expression\n@@ -236,29 +242,18 @@ LL |     extra_garbage_after_metavar!(a);\n    = note: this error originates in the macro `extra_garbage_after_metavar` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: expected expression, found `$`\n-  --> $DIR/syntax-errors.rs:125:30\n+  --> $DIR/syntax-errors.rs:89:30\n    |\n-LL |     ( $( $i:ident ),* ) => { ${ aaaaaaaaaaaaaa(i) } };\n-   |                              ^ expected expression\n-...\n-LL |     unknown_metavar!(a);\n-   |     ------------------- in this macro invocation\n-   |\n-   = note: this error originates in the macro `unknown_metavar` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error: expected expression, found `$`\n-  --> $DIR/syntax-errors.rs:113:30\n-   |\n-LL |     ( $( $i:ident ),* ) => { ${ count{i} } };\n+LL |     ( $( $i:ident ),* ) => { ${ index(IDX) } };\n    |                              ^ expected expression\n ...\n-LL |     metavar_without_parens!(a);\n-   |     -------------------------- in this macro invocation\n+LL |     metavar_depth_is_not_literal!(a);\n+   |     -------------------------------- in this macro invocation\n    |\n-   = note: this error originates in the macro `metavar_without_parens` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: this error originates in the macro `metavar_depth_is_not_literal` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: expected expression, found `$`\n-  --> $DIR/syntax-errors.rs:101:30\n+  --> $DIR/syntax-errors.rs:102:30\n    |\n LL |     ( $( $i:ident ),* ) => { ${ ignore() } };\n    |                              ^ expected expression\n@@ -269,40 +264,63 @@ LL |     metavar_token_without_ident!(a);\n    = note: this error originates in the macro `metavar_token_without_ident` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: expected expression, found `$`\n-  --> $DIR/syntax-errors.rs:88:30\n+  --> $DIR/syntax-errors.rs:108:30\n    |\n-LL |     ( $( $i:ident ),* ) => { ${ index(IDX) } };\n+LL |     ( $( $i:ident ),* ) => { ${ index(1u32) } };\n    |                              ^ expected expression\n ...\n-LL |     metavar_depth_is_not_literal!(a);\n-   |     -------------------------------- in this macro invocation\n+LL |     metavar_with_literal_suffix!(a);\n+   |     ------------------------------- in this macro invocation\n    |\n-   = note: this error originates in the macro `metavar_depth_is_not_literal` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: this error originates in the macro `metavar_with_literal_suffix` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: expected expression, found `$`\n-  --> $DIR/syntax-errors.rs:107:30\n+  --> $DIR/syntax-errors.rs:114:30\n    |\n-LL |     ( $( $i:ident ),* ) => { ${ index(1u32) } };\n+LL |     ( $( $i:ident ),* ) => { ${ count{i} } };\n    |                              ^ expected expression\n ...\n-LL |     metavar_with_literal_suffix!(a);\n-   |     ------------------------------- in this macro invocation\n+LL |     metavar_without_parens!(a);\n+   |     -------------------------- in this macro invocation\n    |\n-   = note: this error originates in the macro `metavar_with_literal_suffix` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: this error originates in the macro `metavar_without_parens` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: expected expression, found `$`\n-  --> $DIR/syntax-errors.rs:119:30\n+  --> $DIR/syntax-errors.rs:120:30\n    |\n LL |     ( $( $i:ident ),* ) => { ${ {} } };\n    |                              ^ expected expression\n ...\n-LL |     open_brackets_without_tokens!(a)\n+LL |     open_brackets_without_tokens!(a);\n    |     -------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `open_brackets_without_tokens` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n+error: variable `foo` is not recognized in meta-variable expression\n+  --> $DIR/syntax-errors.rs:127:17\n+   |\n+LL |         ${count(foo)}\n+   |                 ^^^\n+\n+error: variable `bar` is not recognized in meta-variable expression\n+  --> $DIR/syntax-errors.rs:134:18\n+   |\n+LL |         ${ignore(bar)}\n+   |                  ^^^\n+\n+error: expected expression, found `$`\n+  --> $DIR/syntax-errors.rs:140:30\n+   |\n+LL |     ( $( $i:ident ),* ) => { ${ aaaaaaaaaaaaaa(i) } };\n+   |                              ^ expected expression\n+...\n+LL |     unknown_metavar!(a);\n+   |     ------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `unknown_metavar` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n error[E0425]: cannot find function `count` in this scope\n-  --> $DIR/syntax-errors.rs:28:30\n+  --> $DIR/syntax-errors.rs:29:30\n    |\n LL |     ( $( $i:ident ),* ) => { count(i) };\n    |                              ^^^^^ not found in this scope\n@@ -313,7 +331,7 @@ LL |     no_curly__no_rhs_dollar__round!(a, b, c);\n    = note: this error originates in the macro `no_curly__no_rhs_dollar__round` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0425]: cannot find value `i` in this scope\n-  --> $DIR/syntax-errors.rs:28:36\n+  --> $DIR/syntax-errors.rs:29:36\n    |\n LL |     ( $( $i:ident ),* ) => { count(i) };\n    |                                    ^ not found in this scope\n@@ -324,7 +342,7 @@ LL |     no_curly__no_rhs_dollar__round!(a, b, c);\n    = note: this error originates in the macro `no_curly__no_rhs_dollar__round` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0425]: cannot find function `count` in this scope\n-  --> $DIR/syntax-errors.rs:34:23\n+  --> $DIR/syntax-errors.rs:35:23\n    |\n LL |     ( $i:ident ) => { count(i) };\n    |                       ^^^^^ not found in this scope\n@@ -335,7 +353,7 @@ LL |     no_curly__no_rhs_dollar__no_round!(a);\n    = note: this error originates in the macro `no_curly__no_rhs_dollar__no_round` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0425]: cannot find value `i` in this scope\n-  --> $DIR/syntax-errors.rs:34:29\n+  --> $DIR/syntax-errors.rs:35:29\n    |\n LL |     ( $i:ident ) => { count(i) };\n    |                             ^ not found in this scope\n@@ -346,7 +364,7 @@ LL |     no_curly__no_rhs_dollar__no_round!(a);\n    = note: this error originates in the macro `no_curly__no_rhs_dollar__no_round` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0425]: cannot find function `count` in this scope\n-  --> $DIR/syntax-errors.rs:45:23\n+  --> $DIR/syntax-errors.rs:46:23\n    |\n LL |     ( $i:ident ) => { count($i) };\n    |                       ^^^^^ not found in this scope\n@@ -357,11 +375,11 @@ LL |     no_curly__rhs_dollar__no_round!(a);\n    = note: this error originates in the macro `no_curly__rhs_dollar__no_round` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0425]: cannot find value `a` in this scope\n-  --> $DIR/syntax-errors.rs:138:37\n+  --> $DIR/syntax-errors.rs:153:37\n    |\n LL |     no_curly__rhs_dollar__no_round!(a);\n    |                                     ^ not found in this scope\n \n-error: aborting due to 37 previous errors\n+error: aborting due to 40 previous errors\n \n For more information about this error, try `rustc --explain E0425`."}]}