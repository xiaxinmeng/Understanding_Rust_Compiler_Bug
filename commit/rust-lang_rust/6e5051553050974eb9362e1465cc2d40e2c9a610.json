{"sha": "6e5051553050974eb9362e1465cc2d40e2c9a610", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlNTA1MTU1MzA1MDk3NGViOTM2MmUxNDY1Y2MyZDQwZTJjOWE2MTA=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-05-17T14:19:28Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-05-21T14:15:36Z"}, "message": "syntax/ext: migrate build.rs functions to AstBuilder methods.", "tree": {"sha": "7ad6c6fb53488402e7392008847cd2e60037bb12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ad6c6fb53488402e7392008847cd2e60037bb12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e5051553050974eb9362e1465cc2d40e2c9a610", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e5051553050974eb9362e1465cc2d40e2c9a610", "html_url": "https://github.com/rust-lang/rust/commit/6e5051553050974eb9362e1465cc2d40e2c9a610", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e5051553050974eb9362e1465cc2d40e2c9a610/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c15a0ec4cf023a08078d74ed615ecef0cc10a66", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c15a0ec4cf023a08078d74ed615ecef0cc10a66", "html_url": "https://github.com/rust-lang/rust/commit/8c15a0ec4cf023a08078d74ed615ecef0cc10a66"}], "stats": {"total": 2051, "additions": 1126, "deletions": 925}, "files": [{"sha": "eb48ed583750db33df58ce2c3cda09a61b31c88e", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 783, "deletions": 547, "changes": 1330, "blob_url": "https://github.com/rust-lang/rust/blob/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=6e5051553050974eb9362e1465cc2d40e2c9a610", "patch": "@@ -25,525 +25,6 @@ pub struct Field {\n     ex: @ast::expr\n }\n \n-pub fn mk_expr(cx: @ExtCtxt,\n-               sp: codemap::span,\n-               expr: ast::expr_)\n-            -> @ast::expr {\n-    @ast::expr {\n-        id: cx.next_id(),\n-        callee_id: cx.next_id(),\n-        node: expr,\n-        span: sp,\n-    }\n-}\n-\n-pub fn mk_lit(cx: @ExtCtxt, sp: span, lit: ast::lit_) -> @ast::expr {\n-    let sp_lit = @codemap::spanned { node: lit, span: sp };\n-    mk_expr(cx, sp, ast::expr_lit(sp_lit))\n-}\n-pub fn mk_int(cx: @ExtCtxt, sp: span, i: int) -> @ast::expr {\n-    let lit = ast::lit_int(i as i64, ast::ty_i);\n-    return mk_lit(cx, sp, lit);\n-}\n-pub fn mk_uint(cx: @ExtCtxt, sp: span, u: uint) -> @ast::expr {\n-    let lit = ast::lit_uint(u as u64, ast::ty_u);\n-    return mk_lit(cx, sp, lit);\n-}\n-pub fn mk_u8(cx: @ExtCtxt, sp: span, u: u8) -> @ast::expr {\n-    let lit = ast::lit_uint(u as u64, ast::ty_u8);\n-    return mk_lit(cx, sp, lit);\n-}\n-pub fn mk_binary(cx: @ExtCtxt, sp: span, op: ast::binop,\n-                 lhs: @ast::expr, rhs: @ast::expr) -> @ast::expr {\n-    cx.next_id(); // see ast_util::op_expr_callee_id\n-    mk_expr(cx, sp, ast::expr_binary(op, lhs, rhs))\n-}\n-\n-pub fn mk_deref(cx: @ExtCtxt, sp: span, e: @ast::expr) -> @ast::expr {\n-    mk_unary(cx, sp, ast::deref, e)\n-}\n-pub fn mk_unary(cx: @ExtCtxt, sp: span, op: ast::unop, e: @ast::expr)\n-             -> @ast::expr {\n-    cx.next_id(); // see ast_util::op_expr_callee_id\n-    mk_expr(cx, sp, ast::expr_unary(op, e))\n-}\n-pub fn mk_raw_path(sp: span, idents: ~[ast::ident]) -> @ast::Path {\n-    mk_raw_path_(sp, idents, None, ~[])\n-}\n-pub fn mk_raw_path_(sp: span,\n-                    idents: ~[ast::ident],\n-                    rp: Option<@ast::Lifetime>,\n-                    types: ~[@ast::Ty])\n-                 -> @ast::Path {\n-    @ast::Path { span: sp,\n-                 global: false,\n-                 idents: idents,\n-                 rp: rp,\n-                 types: types }\n-}\n-pub fn mk_raw_path_global(sp: span, idents: ~[ast::ident]) -> @ast::Path {\n-    mk_raw_path_global_(sp, idents, None, ~[])\n-}\n-pub fn mk_raw_path_global_(sp: span,\n-                           idents: ~[ast::ident],\n-                           rp: Option<@ast::Lifetime>,\n-                           types: ~[@ast::Ty]) -> @ast::Path {\n-    @ast::Path { span: sp,\n-                 global: true,\n-                 idents: idents,\n-                 rp: rp,\n-                 types: types }\n-}\n-pub fn mk_path_raw(cx: @ExtCtxt, sp: span, path: @ast::Path)-> @ast::expr {\n-    mk_expr(cx, sp, ast::expr_path(path))\n-}\n-pub fn mk_path(cx: @ExtCtxt, sp: span, idents: ~[ast::ident])\n-            -> @ast::expr {\n-    mk_path_raw(cx, sp, mk_raw_path(sp, idents))\n-}\n-pub fn mk_path_global(cx: @ExtCtxt, sp: span, idents: ~[ast::ident])\n-                   -> @ast::expr {\n-    mk_path_raw(cx, sp, mk_raw_path_global(sp, idents))\n-}\n-pub fn mk_access_(cx: @ExtCtxt, sp: span, p: @ast::expr, m: ast::ident)\n-               -> @ast::expr {\n-    mk_expr(cx, sp, ast::expr_field(p, m, ~[]))\n-}\n-pub fn mk_access(cx: @ExtCtxt, sp: span, p: ~[ast::ident], m: ast::ident)\n-              -> @ast::expr {\n-    let pathexpr = mk_path(cx, sp, p);\n-    return mk_access_(cx, sp, pathexpr, m);\n-}\n-pub fn mk_addr_of(cx: @ExtCtxt, sp: span, e: @ast::expr) -> @ast::expr {\n-    return mk_expr(cx, sp, ast::expr_addr_of(ast::m_imm, e));\n-}\n-pub fn mk_mut_addr_of(cx: @ExtCtxt, sp: span, e: @ast::expr) -> @ast::expr {\n-    return mk_expr(cx, sp, ast::expr_addr_of(ast::m_mutbl, e));\n-}\n-pub fn mk_method_call(cx: @ExtCtxt,\n-                      sp: span,\n-                      rcvr_expr: @ast::expr,\n-                      method_ident: ast::ident,\n-                      args: ~[@ast::expr]) -> @ast::expr {\n-    mk_expr(cx, sp, ast::expr_method_call(rcvr_expr, method_ident, ~[], args, ast::NoSugar))\n-}\n-pub fn mk_call_(cx: @ExtCtxt, sp: span, fn_expr: @ast::expr,\n-                args: ~[@ast::expr]) -> @ast::expr {\n-    mk_expr(cx, sp, ast::expr_call(fn_expr, args, ast::NoSugar))\n-}\n-pub fn mk_call(cx: @ExtCtxt, sp: span, fn_path: ~[ast::ident],\n-               args: ~[@ast::expr]) -> @ast::expr {\n-    let pathexpr = mk_path(cx, sp, fn_path);\n-    return mk_call_(cx, sp, pathexpr, args);\n-}\n-pub fn mk_call_global(cx: @ExtCtxt, sp: span, fn_path: ~[ast::ident],\n-                      args: ~[@ast::expr]) -> @ast::expr {\n-    let pathexpr = mk_path_global(cx, sp, fn_path);\n-    return mk_call_(cx, sp, pathexpr, args);\n-}\n-// e = expr, t = type\n-pub fn mk_base_vec_e(cx: @ExtCtxt, sp: span, exprs: ~[@ast::expr])\n-                  -> @ast::expr {\n-    let vecexpr = ast::expr_vec(exprs, ast::m_imm);\n-    mk_expr(cx, sp, vecexpr)\n-}\n-pub fn mk_vstore_e(cx: @ExtCtxt, sp: span, expr: @ast::expr,\n-                   vst: ast::expr_vstore) ->\n-   @ast::expr {\n-    mk_expr(cx, sp, ast::expr_vstore(expr, vst))\n-}\n-pub fn mk_uniq_vec_e(cx: @ExtCtxt, sp: span, exprs: ~[@ast::expr])\n-                  -> @ast::expr {\n-    mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs), ast::expr_vstore_uniq)\n-}\n-pub fn mk_slice_vec_e(cx: @ExtCtxt, sp: span, exprs: ~[@ast::expr])\n-                   -> @ast::expr {\n-    mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs),\n-                ast::expr_vstore_slice)\n-}\n-pub fn mk_base_str(cx: @ExtCtxt, sp: span, s: ~str) -> @ast::expr {\n-    let lit = ast::lit_str(@s);\n-    return mk_lit(cx, sp, lit);\n-}\n-pub fn mk_uniq_str(cx: @ExtCtxt, sp: span, s: ~str) -> @ast::expr {\n-    mk_vstore_e(cx, sp, mk_base_str(cx, sp, s), ast::expr_vstore_uniq)\n-}\n-pub fn mk_field(sp: span, f: &Field) -> ast::field {\n-    codemap::spanned {\n-        node: ast::field_ { mutbl: ast::m_imm, ident: f.ident, expr: f.ex },\n-        span: sp,\n-    }\n-}\n-pub fn mk_fields(sp: span, fields: ~[Field]) -> ~[ast::field] {\n-    fields.map(|f| mk_field(sp, f))\n-}\n-pub fn mk_struct_e(cx: @ExtCtxt,\n-                   sp: span,\n-                   ctor_path: ~[ast::ident],\n-                   fields: ~[Field])\n-                -> @ast::expr {\n-    mk_expr(cx, sp,\n-            ast::expr_struct(mk_raw_path(sp, ctor_path),\n-                             mk_fields(sp, fields),\n-                                    option::None::<@ast::expr>))\n-}\n-pub fn mk_global_struct_e(cx: @ExtCtxt,\n-                          sp: span,\n-                          ctor_path: ~[ast::ident],\n-                          fields: ~[Field])\n-                       -> @ast::expr {\n-    mk_expr(cx, sp,\n-            ast::expr_struct(mk_raw_path_global(sp, ctor_path),\n-                             mk_fields(sp, fields),\n-                                    option::None::<@ast::expr>))\n-}\n-pub fn mk_glob_use(cx: @ExtCtxt,\n-                   sp: span,\n-                   vis: ast::visibility,\n-                   path: ~[ast::ident]) -> @ast::view_item {\n-    let glob = @codemap::spanned {\n-        node: ast::view_path_glob(mk_raw_path(sp, path), cx.next_id()),\n-        span: sp,\n-    };\n-    @ast::view_item { node: ast::view_item_use(~[glob]),\n-                      attrs: ~[],\n-                      vis: vis,\n-                      span: sp }\n-}\n-pub fn mk_local(cx: @ExtCtxt, sp: span, mutbl: bool,\n-                ident: ast::ident, ex: @ast::expr) -> @ast::stmt {\n-\n-    let pat = @ast::pat {\n-        id: cx.next_id(),\n-        node: ast::pat_ident(\n-            ast::bind_by_copy,\n-            mk_raw_path(sp, ~[ident]),\n-            None),\n-        span: sp,\n-    };\n-    let ty = @ast::Ty { id: cx.next_id(), node: ast::ty_infer, span: sp };\n-    let local = @codemap::spanned {\n-        node: ast::local_ {\n-            is_mutbl: mutbl,\n-            ty: ty,\n-            pat: pat,\n-            init: Some(ex),\n-            id: cx.next_id(),\n-        },\n-        span: sp,\n-    };\n-    let decl = codemap::spanned {node: ast::decl_local(~[local]), span: sp};\n-    @codemap::spanned { node: ast::stmt_decl(@decl, cx.next_id()), span: sp }\n-}\n-pub fn mk_block(cx: @ExtCtxt, span: span,\n-                view_items: ~[@ast::view_item],\n-                stmts: ~[@ast::stmt],\n-                expr: Option<@ast::expr>) -> @ast::expr {\n-    let blk = codemap::spanned {\n-        node: ast::blk_ {\n-             view_items: view_items,\n-             stmts: stmts,\n-             expr: expr,\n-             id: cx.next_id(),\n-             rules: ast::default_blk,\n-        },\n-        span: span,\n-    };\n-    mk_expr(cx, span, ast::expr_block(blk))\n-}\n-pub fn mk_block_(cx: @ExtCtxt,\n-                 span: span,\n-                 stmts: ~[@ast::stmt])\n-              -> ast::blk {\n-    codemap::spanned {\n-        node: ast::blk_ {\n-            view_items: ~[],\n-            stmts: stmts,\n-            expr: None,\n-            id: cx.next_id(),\n-            rules: ast::default_blk,\n-        },\n-        span: span,\n-    }\n-}\n-pub fn mk_simple_block(cx: @ExtCtxt,\n-                       span: span,\n-                       expr: @ast::expr)\n-                    -> ast::blk {\n-    codemap::spanned {\n-        node: ast::blk_ {\n-            view_items: ~[],\n-            stmts: ~[],\n-            expr: Some(expr),\n-            id: cx.next_id(),\n-            rules: ast::default_blk,\n-        },\n-        span: span,\n-    }\n-}\n-pub fn mk_lambda_(cx: @ExtCtxt,\n-                 span: span,\n-                 fn_decl: ast::fn_decl,\n-                 blk: ast::blk)\n-              -> @ast::expr {\n-    mk_expr(cx, span, ast::expr_fn_block(fn_decl, blk))\n-}\n-pub fn mk_lambda(cx: @ExtCtxt,\n-                 span: span,\n-                 fn_decl: ast::fn_decl,\n-                 expr: @ast::expr)\n-              -> @ast::expr {\n-    let blk = mk_simple_block(cx, span, expr);\n-    mk_lambda_(cx, span, fn_decl, blk)\n-}\n-pub fn mk_lambda_stmts(cx: @ExtCtxt,\n-                       span: span,\n-                       fn_decl: ast::fn_decl,\n-                       stmts: ~[@ast::stmt])\n-                    -> @ast::expr {\n-    let blk = mk_block(cx, span, ~[], stmts, None);\n-    mk_lambda(cx, span, fn_decl, blk)\n-}\n-pub fn mk_lambda_no_args(cx: @ExtCtxt,\n-                         span: span,\n-                         expr: @ast::expr)\n-                      -> @ast::expr {\n-    let fn_decl = mk_fn_decl(~[], mk_ty_infer(cx, span));\n-    mk_lambda(cx, span, fn_decl, expr)\n-}\n-pub fn mk_copy(cx: @ExtCtxt, sp: span, e: @ast::expr) -> @ast::expr {\n-    mk_expr(cx, sp, ast::expr_copy(e))\n-}\n-pub fn mk_managed(cx: @ExtCtxt, sp: span, e: @ast::expr) -> @ast::expr {\n-    mk_expr(cx, sp, ast::expr_unary(ast::box(ast::m_imm), e))\n-}\n-pub fn mk_pat(cx: @ExtCtxt, span: span, pat: ast::pat_) -> @ast::pat {\n-    @ast::pat { id: cx.next_id(), node: pat, span: span }\n-}\n-pub fn mk_pat_wild(cx: @ExtCtxt, span: span) -> @ast::pat {\n-    mk_pat(cx, span, ast::pat_wild)\n-}\n-pub fn mk_pat_lit(cx: @ExtCtxt,\n-                  span: span,\n-                  expr: @ast::expr) -> @ast::pat {\n-    mk_pat(cx, span, ast::pat_lit(expr))\n-}\n-pub fn mk_pat_ident(cx: @ExtCtxt,\n-                    span: span,\n-                    ident: ast::ident) -> @ast::pat {\n-    mk_pat_ident_with_binding_mode(cx, span, ident, ast::bind_by_copy)\n-}\n-\n-pub fn mk_pat_ident_with_binding_mode(cx: @ExtCtxt,\n-                                      span: span,\n-                                      ident: ast::ident,\n-                                      bm: ast::binding_mode) -> @ast::pat {\n-    let path = mk_raw_path(span, ~[ ident ]);\n-    let pat = ast::pat_ident(bm, path, None);\n-    mk_pat(cx, span, pat)\n-}\n-pub fn mk_pat_enum(cx: @ExtCtxt,\n-                   span: span,\n-                   path: @ast::Path,\n-                   subpats: ~[@ast::pat])\n-                -> @ast::pat {\n-    let pat = ast::pat_enum(path, Some(subpats));\n-    mk_pat(cx, span, pat)\n-}\n-pub fn mk_pat_struct(cx: @ExtCtxt,\n-                     span: span,\n-                     path: @ast::Path,\n-                     field_pats: ~[ast::field_pat])\n-                  -> @ast::pat {\n-    let pat = ast::pat_struct(path, field_pats, false);\n-    mk_pat(cx, span, pat)\n-}\n-pub fn mk_bool(cx: @ExtCtxt, span: span, value: bool) -> @ast::expr {\n-    let lit_expr = ast::expr_lit(@codemap::spanned {\n-        node: ast::lit_bool(value),\n-        span: span });\n-    build::mk_expr(cx, span, lit_expr)\n-}\n-pub fn mk_stmt(cx: @ExtCtxt, span: span, expr: @ast::expr) -> @ast::stmt {\n-    let stmt_ = ast::stmt_semi(expr, cx.next_id());\n-    @codemap::spanned { node: stmt_, span: span }\n-}\n-\n-pub fn mk_ty_mt(ty: @ast::Ty, mutbl: ast::mutability) -> ast::mt {\n-    ast::mt {\n-        ty: ty,\n-        mutbl: mutbl\n-    }\n-}\n-\n-pub fn mk_ty(cx: @ExtCtxt,\n-             span: span,\n-             ty: ast::ty_) -> @ast::Ty {\n-    @ast::Ty {\n-        id: cx.next_id(),\n-        span: span,\n-        node: ty\n-    }\n-}\n-\n-pub fn mk_ty_path(cx: @ExtCtxt,\n-                  span: span,\n-                  idents: ~[ ast::ident ])\n-               -> @ast::Ty {\n-    let ty = build::mk_raw_path(span, idents);\n-    mk_ty_path_path(cx, span, ty)\n-}\n-\n-pub fn mk_ty_path_global(cx: @ExtCtxt,\n-                         span: span,\n-                         idents: ~[ ast::ident ])\n-                      -> @ast::Ty {\n-    let ty = build::mk_raw_path_global(span, idents);\n-    mk_ty_path_path(cx, span, ty)\n-}\n-\n-pub fn mk_ty_path_path(cx: @ExtCtxt,\n-                       span: span,\n-                       path: @ast::Path)\n-                      -> @ast::Ty {\n-    let ty = ast::ty_path(path, cx.next_id());\n-    mk_ty(cx, span, ty)\n-}\n-\n-pub fn mk_ty_rptr(cx: @ExtCtxt,\n-                  span: span,\n-                  ty: @ast::Ty,\n-                  lifetime: Option<@ast::Lifetime>,\n-                  mutbl: ast::mutability)\n-               -> @ast::Ty {\n-    mk_ty(cx, span,\n-          ast::ty_rptr(lifetime, mk_ty_mt(ty, mutbl)))\n-}\n-pub fn mk_ty_uniq(cx: @ExtCtxt, span: span, ty: @ast::Ty) -> @ast::Ty {\n-    mk_ty(cx, span, ast::ty_uniq(mk_ty_mt(ty, ast::m_imm)))\n-}\n-pub fn mk_ty_box(cx: @ExtCtxt, span: span,\n-                 ty: @ast::Ty, mutbl: ast::mutability) -> @ast::Ty {\n-    mk_ty(cx, span, ast::ty_box(mk_ty_mt(ty, mutbl)))\n-}\n-\n-\n-\n-pub fn mk_ty_infer(cx: @ExtCtxt, span: span) -> @ast::Ty {\n-    mk_ty(cx, span, ast::ty_infer)\n-}\n-pub fn mk_trait_ref_global(cx: @ExtCtxt,\n-                           span: span,\n-                           idents: ~[ ast::ident ])\n-    -> @ast::trait_ref\n-{\n-    mk_trait_ref_(cx, build::mk_raw_path_global(span, idents))\n-}\n-pub fn mk_trait_ref_(cx: @ExtCtxt, path: @ast::Path) -> @ast::trait_ref {\n-    @ast::trait_ref {\n-        path: path,\n-        ref_id: cx.next_id()\n-    }\n-}\n-pub fn mk_simple_ty_path(cx: @ExtCtxt,\n-                         span: span,\n-                         ident: ast::ident)\n-                      -> @ast::Ty {\n-    mk_ty_path(cx, span, ~[ ident ])\n-}\n-pub fn mk_arg(cx: @ExtCtxt,\n-              span: span,\n-              ident: ast::ident,\n-              ty: @ast::Ty)\n-           -> ast::arg {\n-    let arg_pat = mk_pat_ident(cx, span, ident);\n-    ast::arg {\n-        is_mutbl: false,\n-        ty: ty,\n-        pat: arg_pat,\n-        id: cx.next_id()\n-    }\n-}\n-pub fn mk_fn_decl(inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n-    ast::fn_decl { inputs: inputs, output: output, cf: ast::return_val }\n-}\n-pub fn mk_trait_ty_param_bound_global(cx: @ExtCtxt,\n-                                      span: span,\n-                                      idents: ~[ast::ident])\n-                                   -> ast::TyParamBound {\n-    ast::TraitTyParamBound(mk_trait_ref_global(cx, span, idents))\n-}\n-pub fn mk_trait_ty_param_bound_(cx: @ExtCtxt,\n-                                path: @ast::Path) -> ast::TyParamBound {\n-    ast::TraitTyParamBound(mk_trait_ref_(cx, path))\n-}\n-pub fn mk_ty_param(cx: @ExtCtxt,\n-                   ident: ast::ident,\n-                   bounds: @OptVec<ast::TyParamBound>)\n-                -> ast::TyParam {\n-    ast::TyParam { ident: ident, id: cx.next_id(), bounds: bounds }\n-}\n-pub fn mk_lifetime(cx: @ExtCtxt,\n-                   span: span,\n-                   ident: ast::ident)\n-                -> ast::Lifetime {\n-    ast::Lifetime { id: cx.next_id(), span: span, ident: ident }\n-}\n-pub fn mk_arm(cx: @ExtCtxt,\n-              span: span,\n-              pats: ~[@ast::pat],\n-              expr: @ast::expr)\n-           -> ast::arm {\n-    ast::arm {\n-        pats: pats,\n-        guard: None,\n-        body: mk_simple_block(cx, span, expr)\n-    }\n-}\n-pub fn mk_unreachable(cx: @ExtCtxt, span: span) -> @ast::expr {\n-    let loc = cx.codemap().lookup_char_pos(span.lo);\n-    mk_call_global(\n-        cx,\n-        span,\n-        ~[\n-            cx.ident_of(\"core\"),\n-            cx.ident_of(\"sys\"),\n-            cx.ident_of(\"FailWithCause\"),\n-            cx.ident_of(\"fail_with\"),\n-        ],\n-        ~[\n-            mk_base_str(cx, span, ~\"internal error: entered unreachable code\"),\n-            mk_base_str(cx, span, copy loc.file.name),\n-            mk_uint(cx, span, loc.line),\n-        ]\n-    )\n-}\n-pub fn mk_unreachable_arm(cx: @ExtCtxt, span: span) -> ast::arm {\n-    mk_arm(cx, span, ~[mk_pat_wild(cx, span)], mk_unreachable(cx, span))\n-}\n-\n-pub fn make_self(cx: @ExtCtxt, span: span) -> @ast::expr {\n-    build::mk_expr(cx, span, ast::expr_self)\n-}\n-\n-//\n-// Duplication functions\n-//\n-// These functions just duplicate AST nodes.\n-//\n-\n-pub fn duplicate_expr(cx: @ExtCtxt, expr: @ast::expr) -> @ast::expr {\n-    let folder = fold::default_ast_fold();\n-    let folder = @fold::AstFoldFns {\n-        new_id: |_| cx.next_id(),\n-        ..*folder\n-    };\n-    let folder = fold::make_fold(folder);\n-    folder.fold_expr(expr)\n-}\n-\n-\n-\n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n     pub use ext;\n@@ -555,12 +36,12 @@ pub trait AstBuilder {\n     fn path(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n     fn path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n     fn path_tps(&self, span: span, strs: ~[ast::ident], tps: ~[@ast::Ty])\n-                -> @ast::Path;\n+        -> @ast::Path;\n     fn path_tps_global(&self,\n                        span: span,\n                        strs: ~[ast::ident],\n                        tps: ~[@ast::Ty])\n-                       -> @ast::Path;\n+        -> @ast::Path;\n \n     // types\n     fn ty_path(&self, @ast::Path) -> @ast::Ty;\n@@ -595,15 +76,15 @@ pub trait AstBuilder {\n     fn expr_var(&self, span: span, var: &str) -> @ast::expr;\n     fn expr_self(&self, span: span) -> @ast::expr;\n     fn expr_field(&self, span: span, expr: @ast::expr, ident: ast::ident)\n-                  -> @ast::expr;\n+        -> @ast::expr;\n     fn expr_call(&self, span: span, expr: @ast::expr, args: ~[@ast::expr])\n-                 -> @ast::expr;\n+        -> @ast::expr;\n     fn expr_method_call(&self,\n                         span: span,\n                         expr: @ast::expr,\n                         ident: ast::ident,\n                         args: ~[@ast::expr])\n-                        -> @ast::expr;\n+        -> @ast::expr;\n     fn expr_blk(&self, b: ast::blk) -> @ast::expr;\n     fn field_imm(&self, name: ident, e: @ast::expr) -> ast::field;\n     fn expr_struct(&self,\n@@ -613,13 +94,13 @@ pub trait AstBuilder {\n     fn lambda1(&self, blk: ast::blk, ident: ast::ident) -> @ast::expr;\n     fn lambda_expr_0(&self, expr: @ast::expr) -> @ast::expr;\n     fn lambda_expr_1(&self, expr: @ast::expr, ident: ast::ident)\n-                    -> @ast::expr;\n+        -> @ast::expr;\n     fn lambda_stmts_0(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr;\n     fn lambda_stmts_1(&self,\n                       span: span,\n                       stmts: ~[@ast::stmt],\n                       ident: ast::ident)\n-                      -> @ast::expr;\n+        -> @ast::expr;\n \n     // items\n     fn item(&self, name: ident, span: span, node: ast::item_) -> @ast::item;\n@@ -675,6 +156,226 @@ pub trait AstBuilder {\n                     generics: Generics) -> @ast::item;\n     fn item_ty(&self, name: ident, span: span, ty: @ast::Ty) -> @ast::item;\n \n+\n+\n+\n+    fn mk_expr(&self,\n+               sp: codemap::span,\n+               expr: ast::expr_)\n+        -> @ast::expr;\n+\n+    fn mk_lit(&self, sp: span, lit: ast::lit_) -> @ast::expr;\n+    fn mk_int(&self, sp: span, i: int) -> @ast::expr;\n+    fn mk_uint(&self, sp: span, u: uint) -> @ast::expr;\n+    fn mk_u8(&self, sp: span, u: u8) -> @ast::expr;\n+    fn mk_binary(&self, sp: span, op: ast::binop,\n+                 lhs: @ast::expr, rhs: @ast::expr) -> @ast::expr;\n+\n+    fn mk_deref(&self, sp: span, e: @ast::expr) -> @ast::expr;\n+    fn mk_unary(&self, sp: span, op: ast::unop, e: @ast::expr)\n+        -> @ast::expr;\n+    // XXX: unused self\n+    fn mk_raw_path(&self, sp: span, idents: ~[ast::ident]) -> @ast::Path;\n+    // XXX: unused self\n+    fn mk_raw_path_(&self, sp: span,\n+                    idents: ~[ast::ident],\n+                    rp: Option<@ast::Lifetime>,\n+                    types: ~[@ast::Ty])\n+        -> @ast::Path;\n+    // XXX: unused self\n+    fn mk_raw_path_global(&self,  sp: span,idents: ~[ast::ident]) -> @ast::Path;\n+    // XXX: unused self\n+    fn mk_raw_path_global_(&self, sp: span,\n+                           idents: ~[ast::ident],\n+                           rp: Option<@ast::Lifetime>,\n+                           types: ~[@ast::Ty]) -> @ast::Path;\n+    fn mk_path_raw(&self, sp: span, path: @ast::Path)-> @ast::expr;\n+    fn mk_path(&self, sp: span, idents: ~[ast::ident])\n+        -> @ast::expr;\n+    fn mk_path_global(&self, sp: span, idents: ~[ast::ident])\n+        -> @ast::expr;\n+    fn mk_access_(&self, sp: span, p: @ast::expr, m: ast::ident)\n+        -> @ast::expr;\n+    fn mk_access(&self, sp: span, p: ~[ast::ident], m: ast::ident)\n+        -> @ast::expr;\n+    fn mk_addr_of(&self, sp: span, e: @ast::expr) -> @ast::expr;\n+    fn mk_mut_addr_of(&self, sp: span, e: @ast::expr) -> @ast::expr;\n+    fn mk_method_call(&self,\n+                      sp: span,\n+                      rcvr_expr: @ast::expr,\n+                      method_ident: ast::ident,\n+                      args: ~[@ast::expr]) -> @ast::expr;\n+    fn mk_call_(&self, sp: span, fn_expr: @ast::expr,\n+                args: ~[@ast::expr]) -> @ast::expr;\n+    fn mk_call(&self, sp: span, fn_path: ~[ast::ident],\n+               args: ~[@ast::expr]) -> @ast::expr;\n+    fn mk_call_global(&self, sp: span, fn_path: ~[ast::ident],\n+                      args: ~[@ast::expr]) -> @ast::expr;\n+    // e = expr, t = type\n+    fn mk_base_vec_e(&self, sp: span, exprs: ~[@ast::expr])\n+        -> @ast::expr;\n+    fn mk_vstore_e(&self, sp: span, expr: @ast::expr,\n+                   vst: ast::expr_vstore) ->\n+        @ast::expr;\n+    fn mk_uniq_vec_e(&self, sp: span, exprs: ~[@ast::expr])\n+        -> @ast::expr;\n+    fn mk_slice_vec_e(&self, sp: span, exprs: ~[@ast::expr])\n+        -> @ast::expr;\n+    fn mk_base_str(&self, sp: span, s: ~str) -> @ast::expr;\n+    fn mk_uniq_str(&self, sp: span, s: ~str) -> @ast::expr;\n+    // XXX: unused self\n+    fn mk_field(&self, sp: span, f: &Field) -> ast::field;\n+    // XXX: unused self\n+    fn mk_fields(&self, sp: span, fields: ~[Field]) -> ~[ast::field];\n+    fn mk_struct_e(&self,\n+                   sp: span,\n+                   ctor_path: ~[ast::ident],\n+                   fields: ~[Field])\n+        -> @ast::expr;\n+    fn mk_global_struct_e(&self,\n+                          sp: span,\n+                          ctor_path: ~[ast::ident],\n+                          fields: ~[Field])\n+        -> @ast::expr;\n+    fn mk_glob_use(&self,\n+                   sp: span,\n+                   vis: ast::visibility,\n+                   path: ~[ast::ident]) -> @ast::view_item;\n+    fn mk_local(&self, sp: span, mutbl: bool,\n+                ident: ast::ident, ex: @ast::expr) -> @ast::stmt;\n+    fn mk_block(&self, span: span,\n+                view_items: ~[@ast::view_item],\n+                stmts: ~[@ast::stmt],\n+                expr: Option<@ast::expr>) -> @ast::expr;\n+    fn mk_block_(&self,\n+                 span: span,\n+                 stmts: ~[@ast::stmt])\n+        -> ast::blk;\n+    fn mk_simple_block(&self,\n+                       span: span,\n+                       expr: @ast::expr)\n+        -> ast::blk;\n+    fn mk_lambda_(&self,\n+                  span: span,\n+                  fn_decl: ast::fn_decl,\n+                  blk: ast::blk)\n+        -> @ast::expr;\n+    fn mk_lambda(&self,\n+                 span: span,\n+                 fn_decl: ast::fn_decl,\n+                 expr: @ast::expr)\n+        -> @ast::expr;\n+    fn mk_lambda_stmts(&self,\n+                       span: span,\n+                       fn_decl: ast::fn_decl,\n+                       stmts: ~[@ast::stmt])\n+        -> @ast::expr ;\n+    fn mk_lambda_no_args(&self,\n+                         span: span,\n+                         expr: @ast::expr)\n+        -> @ast::expr;\n+    fn mk_copy(&self, sp: span, e: @ast::expr) -> @ast::expr;\n+    fn mk_managed(&self, sp: span, e: @ast::expr) -> @ast::expr;\n+    fn mk_pat(&self, span: span, pat: ast::pat_) -> @ast::pat;\n+    fn mk_pat_wild(&self, span: span) -> @ast::pat;\n+    fn mk_pat_lit(&self,\n+                  span: span,\n+                  expr: @ast::expr) -> @ast::pat;\n+    fn mk_pat_ident(&self,\n+                    span: span,\n+                    ident: ast::ident) -> @ast::pat;\n+\n+    fn mk_pat_ident_with_binding_mode(&self,\n+                                      span: span,\n+                                      ident: ast::ident,\n+                                      bm: ast::binding_mode) -> @ast::pat;\n+    fn mk_pat_enum(&self,\n+                   span: span,\n+                   path: @ast::Path,\n+                   subpats: ~[@ast::pat])\n+        -> @ast::pat;\n+    fn mk_pat_struct(&self,\n+                     span: span,\n+                     path: @ast::Path,\n+                     field_pats: ~[ast::field_pat])\n+        -> @ast::pat;\n+    fn mk_bool(&self, span: span, value: bool) -> @ast::expr;\n+    fn mk_stmt(&self, span: span, expr: @ast::expr) -> @ast::stmt;\n+\n+    // XXX: unused self\n+    fn mk_ty_mt(&self, ty: @ast::Ty, mutbl: ast::mutability) -> ast::mt;\n+\n+    fn mk_ty(&self,\n+             span: span,\n+             ty: ast::ty_) -> @ast::Ty;\n+\n+    fn mk_ty_path(&self,\n+                  span: span,\n+                  idents: ~[ ast::ident ])\n+        -> @ast::Ty;\n+\n+    fn mk_ty_path_global(&self,\n+                         span: span,\n+                         idents: ~[ ast::ident ])\n+        -> @ast::Ty;\n+\n+    fn mk_ty_path_path(&self,\n+                       span: span,\n+                       path: @ast::Path)\n+        -> @ast::Ty;\n+\n+    fn mk_ty_rptr(&self,\n+                  span: span,\n+                  ty: @ast::Ty,\n+                  lifetime: Option<@ast::Lifetime>,\n+                  mutbl: ast::mutability)\n+        -> @ast::Ty;\n+    fn mk_ty_uniq(&self, span: span, ty: @ast::Ty) -> @ast::Ty;\n+    fn mk_ty_box(&self, span: span,\n+                 ty: @ast::Ty, mutbl: ast::mutability) -> @ast::Ty;\n+\n+\n+\n+    fn mk_ty_infer(&self, span: span) -> @ast::Ty;\n+    fn mk_trait_ref_global(&self,\n+                           span: span,\n+                           idents: ~[ ast::ident ])\n+        -> @ast::trait_ref;\n+    fn mk_trait_ref_(&self, path: @ast::Path) -> @ast::trait_ref;\n+    fn mk_simple_ty_path(&self,\n+                         span: span,\n+                         ident: ast::ident)\n+        -> @ast::Ty;\n+    fn mk_arg(&self,\n+              span: span,\n+              ident: ast::ident,\n+              ty: @ast::Ty)\n+        -> ast::arg;\n+    // XXX unused self\n+    fn mk_fn_decl(&self, inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl;\n+    fn mk_trait_ty_param_bound_global(&self,\n+                                      span: span,\n+                                      idents: ~[ast::ident])\n+        -> ast::TyParamBound;\n+    fn mk_trait_ty_param_bound_(&self,\n+                                path: @ast::Path) -> ast::TyParamBound;\n+    fn mk_ty_param(&self,\n+                   ident: ast::ident,\n+                   bounds: @OptVec<ast::TyParamBound>)\n+        -> ast::TyParam;\n+    fn mk_lifetime(&self,\n+                   span: span,\n+                   ident: ast::ident)\n+        -> ast::Lifetime;\n+    fn mk_arm(&self,\n+              span: span,\n+              pats: ~[@ast::pat],\n+              expr: @ast::expr)\n+        -> ast::arm;\n+    fn mk_unreachable(&self, span: span) -> @ast::expr;\n+    fn mk_unreachable_arm(&self, span: span) -> ast::arm;\n+\n+    fn make_self(&self, span: span) -> @ast::expr;\n }\n \n impl AstBuilder for @ExtCtxt {\n@@ -729,8 +430,8 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     fn ty_path(&self, path: @ast::Path) -> @ast::Ty {\n-        build::mk_ty(*self, path.span,\n-                     ast::ty_path(path, self.next_id()))\n+        self.mk_ty(path.span,\n+                   ast::ty_path(path, self.next_id()))\n     }\n \n     fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty {\n@@ -779,14 +480,14 @@ impl AstBuilder for @ExtCtxt {\n     fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n         opt_vec::take_vec(\n             ty_params.map(|p| self.ty_path(\n-                mk_raw_path(dummy_sp(), ~[p.ident]))))\n+                self.mk_raw_path(dummy_sp(), ~[p.ident]))))\n     }\n \n     fn ty_vars_global(&self,\n                       ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n         opt_vec::take_vec(\n             ty_params.map(|p| self.ty_path(\n-                mk_raw_path(dummy_sp(), ~[p.ident]))))\n+                self.mk_raw_path(dummy_sp(), ~[p.ident]))))\n     }\n \n     fn strip_bounds(&self, generics: &Generics) -> Generics {\n@@ -803,7 +504,7 @@ impl AstBuilder for @ExtCtxt {\n \n     fn stmt_expr(&self, expr: @ast::expr) -> @ast::stmt {\n         @codemap::spanned { node: ast::stmt_semi(expr, self.next_id()),\n-                       span: expr.span }\n+                           span: expr.span }\n     }\n \n     fn stmt_let(&self, ident: ident, e: @ast::expr) -> @ast::stmt {\n@@ -819,7 +520,7 @@ impl AstBuilder for @ExtCtxt {\n                     span,\n                     ast::expr_lit(\n                         @codemap::spanned { node: ast::lit_str(s),\n-                                        span: span})),\n+                                           span: span})),\n                 ast::expr_vstore_uniq))\n     }\n \n@@ -828,7 +529,7 @@ impl AstBuilder for @ExtCtxt {\n             span,\n             ast::expr_lit(\n                 @codemap::spanned { node: ast::lit_uint(i as u64, ast::ty_u),\n-                                span: span}))\n+                                   span: span}))\n     }\n \n     fn blk(&self, span: span, stmts: ~[@ast::stmt], expr: Option<@expr>) -> ast::blk {\n@@ -942,7 +643,7 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     fn lambda_expr_1(&self, expr: @ast::expr, ident: ast::ident)\n-                    -> @ast::expr {\n+        -> @ast::expr {\n         self.lambda1(self.blk_expr(expr), ident)\n     }\n \n@@ -954,7 +655,7 @@ impl AstBuilder for @ExtCtxt {\n                       span: span,\n                       stmts: ~[@ast::stmt],\n                       ident: ast::ident)\n-                      -> @ast::expr {\n+        -> @ast::expr {\n         self.lambda1(self.blk(span, stmts, None), ident)\n     }\n \n@@ -992,20 +693,20 @@ impl AstBuilder for @ExtCtxt {\n         let non_camel_case_attribute = respan(dummy_sp(), ast::attribute_ {\n             style: ast::attr_outer,\n             value: @respan(dummy_sp(),\n-                          ast::meta_list(@~\"allow\", ~[\n-                              @respan(dummy_sp(),\n-                                      ast::meta_word(\n-                                         @~\"non_camel_case_types\"))\n-                          ])),\n+                           ast::meta_list(@~\"allow\", ~[\n+                               @respan(dummy_sp(),\n+                                       ast::meta_word(\n+                                           @~\"non_camel_case_types\"))\n+                           ])),\n             is_sugared_doc: false\n         });\n \n         @ast::item { ident: name,\n-                     attrs: ~[non_camel_case_attribute],\n-                     id: self.next_id(),\n-                     node: node,\n-                     vis: ast::public,\n-                     span: span }\n+                    attrs: ~[non_camel_case_attribute],\n+                    id: self.next_id(),\n+                    node: node,\n+                    vis: ast::public,\n+                    span: span }\n     }\n \n     fn item_fn_poly(&self, name: ident,\n@@ -1027,7 +728,7 @@ impl AstBuilder for @ExtCtxt {\n                inputs: ~[ast::arg],\n                output: @ast::Ty,\n                body: ast::blk\n-    ) -> @ast::item {\n+              ) -> @ast::item {\n         self.item_fn_poly(\n             name,\n             inputs,\n@@ -1100,7 +801,7 @@ impl AstBuilder for @ExtCtxt {\n             @codemap::spanned {\n                 node: ast::view_path_simple(\n                     self.ident_of(\"Owned\"),\n-                    mk_raw_path(\n+                    self.mk_raw_path(\n                         codemap::dummy_sp(),\n                         ~[\n                             self.ident_of(\"core\"),\n@@ -1140,4 +841,539 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n \n+\n+\n+\n+\n+\n+    fn mk_expr(&self,\n+               sp: codemap::span,\n+               expr: ast::expr_)\n+        -> @ast::expr {\n+        @ast::expr {\n+            id: self.next_id(),\n+            callee_id: self.next_id(),\n+            node: expr,\n+            span: sp,\n+        }\n+    }\n+\n+    fn mk_lit(&self, sp: span, lit: ast::lit_) -> @ast::expr {\n+        let sp_lit = @codemap::spanned { node: lit, span: sp };\n+        self.mk_expr( sp, ast::expr_lit(sp_lit))\n+    }\n+    fn mk_int(&self, sp: span, i: int) -> @ast::expr {\n+        let lit = ast::lit_int(i as i64, ast::ty_i);\n+        return self.mk_lit( sp, lit);\n+    }\n+    fn mk_uint(&self, sp: span, u: uint) -> @ast::expr {\n+        let lit = ast::lit_uint(u as u64, ast::ty_u);\n+        return self.mk_lit( sp, lit);\n+    }\n+    fn mk_u8(&self, sp: span, u: u8) -> @ast::expr {\n+        let lit = ast::lit_uint(u as u64, ast::ty_u8);\n+        return self.mk_lit( sp, lit);\n+    }\n+    fn mk_binary(&self, sp: span, op: ast::binop,\n+                 lhs: @ast::expr, rhs: @ast::expr) -> @ast::expr {\n+        self.next_id(); // see ast_util::op_expr_callee_id\n+        self.mk_expr( sp, ast::expr_binary(op, lhs, rhs))\n+    }\n+\n+    fn mk_deref(&self, sp: span, e: @ast::expr) -> @ast::expr {\n+        self.mk_unary( sp, ast::deref, e)\n+    }\n+    fn mk_unary(&self, sp: span, op: ast::unop, e: @ast::expr)\n+        -> @ast::expr {\n+        self.next_id(); // see ast_util::op_expr_callee_id\n+        self.mk_expr( sp, ast::expr_unary(op, e))\n+    }\n+    // XXX: unused self\n+    fn mk_raw_path(&self, sp: span, idents: ~[ast::ident]) -> @ast::Path {\n+        self.mk_raw_path_(sp, idents, None, ~[])\n+    }\n+    // XXX: unused self\n+    fn mk_raw_path_(&self, sp: span,\n+                    idents: ~[ast::ident],\n+                    rp: Option<@ast::Lifetime>,\n+                    types: ~[@ast::Ty])\n+        -> @ast::Path {\n+        @ast::Path { span: sp,\n+                    global: false,\n+                    idents: idents,\n+                    rp: rp,\n+                    types: types }\n+    }\n+    // XXX: unused self\n+    fn mk_raw_path_global(&self, sp: span, idents: ~[ast::ident]) -> @ast::Path {\n+        self.mk_raw_path_global_(sp, idents, None, ~[])\n+    }\n+    // XXX: unused self\n+    fn mk_raw_path_global_(&self, sp: span,\n+                           idents: ~[ast::ident],\n+                           rp: Option<@ast::Lifetime>,\n+                           types: ~[@ast::Ty]) -> @ast::Path {\n+        @ast::Path { span: sp,\n+                    global: true,\n+                    idents: idents,\n+                    rp: rp,\n+                    types: types }\n+    }\n+    fn mk_path_raw(&self, sp: span, path: @ast::Path)-> @ast::expr {\n+        self.mk_expr( sp, ast::expr_path(path))\n+    }\n+    fn mk_path(&self, sp: span, idents: ~[ast::ident])\n+        -> @ast::expr {\n+        self.mk_path_raw( sp, self.mk_raw_path(sp, idents))\n+    }\n+    fn mk_path_global(&self, sp: span, idents: ~[ast::ident])\n+        -> @ast::expr {\n+        self.mk_path_raw( sp, self.mk_raw_path_global(sp, idents))\n+    }\n+    fn mk_access_(&self, sp: span, p: @ast::expr, m: ast::ident)\n+        -> @ast::expr {\n+        self.mk_expr( sp, ast::expr_field(p, m, ~[]))\n+    }\n+    fn mk_access(&self, sp: span, p: ~[ast::ident], m: ast::ident)\n+        -> @ast::expr {\n+        let pathexpr = self.mk_path( sp, p);\n+        return self.mk_access_( sp, pathexpr, m);\n+    }\n+    fn mk_addr_of(&self, sp: span, e: @ast::expr) -> @ast::expr {\n+        return self.mk_expr( sp, ast::expr_addr_of(ast::m_imm, e));\n+    }\n+    fn mk_mut_addr_of(&self, sp: span, e: @ast::expr) -> @ast::expr {\n+        return self.mk_expr( sp, ast::expr_addr_of(ast::m_mutbl, e));\n+    }\n+    fn mk_method_call(&self,\n+                      sp: span,\n+                      rcvr_expr: @ast::expr,\n+                      method_ident: ast::ident,\n+                      args: ~[@ast::expr]) -> @ast::expr {\n+        self.mk_expr( sp, ast::expr_method_call(rcvr_expr, method_ident, ~[], args, ast::NoSugar))\n+    }\n+    fn mk_call_(&self, sp: span, fn_expr: @ast::expr,\n+                args: ~[@ast::expr]) -> @ast::expr {\n+        self.mk_expr( sp, ast::expr_call(fn_expr, args, ast::NoSugar))\n+    }\n+    fn mk_call(&self, sp: span, fn_path: ~[ast::ident],\n+               args: ~[@ast::expr]) -> @ast::expr {\n+        let pathexpr = self.mk_path( sp, fn_path);\n+        return self.mk_call_( sp, pathexpr, args);\n+    }\n+    fn mk_call_global(&self, sp: span, fn_path: ~[ast::ident],\n+                      args: ~[@ast::expr]) -> @ast::expr {\n+        let pathexpr = self.mk_path_global( sp, fn_path);\n+        return self.mk_call_( sp, pathexpr, args);\n+    }\n+    // e = expr, t = type\n+    fn mk_base_vec_e(&self, sp: span, exprs: ~[@ast::expr])\n+        -> @ast::expr {\n+        let vecexpr = ast::expr_vec(exprs, ast::m_imm);\n+        self.mk_expr( sp, vecexpr)\n+    }\n+    fn mk_vstore_e(&self, sp: span, expr: @ast::expr,\n+                   vst: ast::expr_vstore) ->\n+        @ast::expr {\n+        self.mk_expr( sp, ast::expr_vstore(expr, vst))\n+    }\n+    fn mk_uniq_vec_e(&self, sp: span, exprs: ~[@ast::expr])\n+        -> @ast::expr {\n+        self.mk_vstore_e( sp, self.mk_base_vec_e( sp, exprs), ast::expr_vstore_uniq)\n+    }\n+    fn mk_slice_vec_e(&self, sp: span, exprs: ~[@ast::expr])\n+        -> @ast::expr {\n+        self.mk_vstore_e( sp, self.mk_base_vec_e( sp, exprs),\n+                    ast::expr_vstore_slice)\n+    }\n+    fn mk_base_str(&self, sp: span, s: ~str) -> @ast::expr {\n+        let lit = ast::lit_str(@s);\n+        return self.mk_lit( sp, lit);\n+    }\n+    fn mk_uniq_str(&self, sp: span, s: ~str) -> @ast::expr {\n+        self.mk_vstore_e( sp, self.mk_base_str( sp, s), ast::expr_vstore_uniq)\n+    }\n+    // XXX: unused self\n+    fn mk_field(&self, sp: span, f: &Field) -> ast::field {\n+        codemap::spanned {\n+            node: ast::field_ { mutbl: ast::m_imm, ident: f.ident, expr: f.ex },\n+            span: sp,\n+        }\n+    }\n+    // XXX: unused self\n+    fn mk_fields(&self, sp: span, fields: ~[Field]) -> ~[ast::field] {\n+        fields.map(|f| self.mk_field(sp, f))\n+    }\n+    fn mk_struct_e(&self,\n+                   sp: span,\n+                   ctor_path: ~[ast::ident],\n+                   fields: ~[Field])\n+        -> @ast::expr {\n+        self.mk_expr( sp,\n+                ast::expr_struct(self.mk_raw_path(sp, ctor_path),\n+                                 self.mk_fields(sp, fields),\n+                                 option::None::<@ast::expr>))\n+    }\n+    fn mk_global_struct_e(&self,\n+                          sp: span,\n+                          ctor_path: ~[ast::ident],\n+                          fields: ~[Field])\n+        -> @ast::expr {\n+        self.mk_expr( sp,\n+                ast::expr_struct(self.mk_raw_path_global(sp, ctor_path),\n+                                 self.mk_fields(sp, fields),\n+                                 option::None::<@ast::expr>))\n+    }\n+    fn mk_glob_use(&self,\n+                   sp: span,\n+                   vis: ast::visibility,\n+                   path: ~[ast::ident]) -> @ast::view_item {\n+        let glob = @codemap::spanned {\n+            node: ast::view_path_glob(self.mk_raw_path(sp, path), self.next_id()),\n+            span: sp,\n+        };\n+        @ast::view_item { node: ast::view_item_use(~[glob]),\n+                         attrs: ~[],\n+                         vis: vis,\n+                         span: sp }\n+    }\n+    fn mk_local(&self, sp: span, mutbl: bool,\n+                ident: ast::ident, ex: @ast::expr) -> @ast::stmt {\n+\n+        let pat = @ast::pat {\n+            id: self.next_id(),\n+            node: ast::pat_ident(\n+                ast::bind_by_copy,\n+                self.mk_raw_path(sp, ~[ident]),\n+                None),\n+            span: sp,\n+        };\n+        let ty = @ast::Ty { id: self.next_id(), node: ast::ty_infer, span: sp };\n+        let local = @codemap::spanned {\n+            node: ast::local_ {\n+                is_mutbl: mutbl,\n+                ty: ty,\n+                pat: pat,\n+                init: Some(ex),\n+                id: self.next_id(),\n+            },\n+            span: sp,\n+        };\n+        let decl = codemap::spanned {node: ast::decl_local(~[local]), span: sp};\n+        @codemap::spanned { node: ast::stmt_decl(@decl, self.next_id()), span: sp }\n+    }\n+    fn mk_block(&self, span: span,\n+                view_items: ~[@ast::view_item],\n+                stmts: ~[@ast::stmt],\n+                expr: Option<@ast::expr>) -> @ast::expr {\n+        let blk = codemap::spanned {\n+            node: ast::blk_ {\n+                view_items: view_items,\n+                stmts: stmts,\n+                expr: expr,\n+                id: self.next_id(),\n+                rules: ast::default_blk,\n+            },\n+            span: span,\n+        };\n+        self.mk_expr( span, ast::expr_block(blk))\n+    }\n+    fn mk_block_(&self,\n+                 span: span,\n+                 stmts: ~[@ast::stmt])\n+        -> ast::blk {\n+        codemap::spanned {\n+            node: ast::blk_ {\n+                view_items: ~[],\n+                stmts: stmts,\n+                expr: None,\n+                id: self.next_id(),\n+                rules: ast::default_blk,\n+            },\n+            span: span,\n+        }\n+    }\n+    fn mk_simple_block(&self,\n+                       span: span,\n+                       expr: @ast::expr)\n+        -> ast::blk {\n+        codemap::spanned {\n+            node: ast::blk_ {\n+                view_items: ~[],\n+                stmts: ~[],\n+                expr: Some(expr),\n+                id: self.next_id(),\n+                rules: ast::default_blk,\n+            },\n+            span: span,\n+        }\n+    }\n+    fn mk_lambda_(&self,\n+                  span: span,\n+                  fn_decl: ast::fn_decl,\n+                  blk: ast::blk)\n+        -> @ast::expr {\n+        self.mk_expr( span, ast::expr_fn_block(fn_decl, blk))\n+    }\n+    fn mk_lambda(&self,\n+                 span: span,\n+                 fn_decl: ast::fn_decl,\n+                 expr: @ast::expr)\n+        -> @ast::expr {\n+        let blk = self.mk_simple_block( span, expr);\n+        self.mk_lambda_( span, fn_decl, blk)\n+    }\n+    fn mk_lambda_stmts(&self,\n+                       span: span,\n+                       fn_decl: ast::fn_decl,\n+                       stmts: ~[@ast::stmt])\n+        -> @ast::expr {\n+        let blk = self.mk_block( span, ~[], stmts, None);\n+        self.mk_lambda( span, fn_decl, blk)\n+    }\n+    fn mk_lambda_no_args(&self,\n+                         span: span,\n+                         expr: @ast::expr)\n+        -> @ast::expr {\n+        let fn_decl = self.mk_fn_decl(~[], self.mk_ty_infer( span));\n+        self.mk_lambda( span, fn_decl, expr)\n+    }\n+    fn mk_copy(&self, sp: span, e: @ast::expr) -> @ast::expr {\n+        self.mk_expr( sp, ast::expr_copy(e))\n+    }\n+    fn mk_managed(&self, sp: span, e: @ast::expr) -> @ast::expr {\n+        self.mk_expr( sp, ast::expr_unary(ast::box(ast::m_imm), e))\n+    }\n+    fn mk_pat(&self, span: span, pat: ast::pat_) -> @ast::pat {\n+        @ast::pat { id: self.next_id(), node: pat, span: span }\n+    }\n+    fn mk_pat_wild(&self, span: span) -> @ast::pat {\n+        self.mk_pat( span, ast::pat_wild)\n+    }\n+    fn mk_pat_lit(&self,\n+                  span: span,\n+                  expr: @ast::expr) -> @ast::pat {\n+        self.mk_pat( span, ast::pat_lit(expr))\n+    }\n+    fn mk_pat_ident(&self,\n+                    span: span,\n+                    ident: ast::ident) -> @ast::pat {\n+        self.mk_pat_ident_with_binding_mode( span, ident, ast::bind_by_copy)\n+    }\n+\n+    fn mk_pat_ident_with_binding_mode(&self,\n+                                      span: span,\n+                                      ident: ast::ident,\n+                                      bm: ast::binding_mode) -> @ast::pat {\n+        let path = self.mk_raw_path(span, ~[ ident ]);\n+        let pat = ast::pat_ident(bm, path, None);\n+        self.mk_pat( span, pat)\n+    }\n+    fn mk_pat_enum(&self,\n+                   span: span,\n+                   path: @ast::Path,\n+                   subpats: ~[@ast::pat])\n+        -> @ast::pat {\n+        let pat = ast::pat_enum(path, Some(subpats));\n+        self.mk_pat( span, pat)\n+    }\n+    fn mk_pat_struct(&self,\n+                     span: span,\n+                     path: @ast::Path,\n+                     field_pats: ~[ast::field_pat])\n+        -> @ast::pat {\n+        let pat = ast::pat_struct(path, field_pats, false);\n+        self.mk_pat( span, pat)\n+    }\n+    fn mk_bool(&self, span: span, value: bool) -> @ast::expr {\n+        let lit_expr = ast::expr_lit(@codemap::spanned {\n+            node: ast::lit_bool(value),\n+            span: span });\n+        self.mk_expr( span, lit_expr)\n+    }\n+    fn mk_stmt(&self, span: span, expr: @ast::expr) -> @ast::stmt {\n+        let stmt_ = ast::stmt_semi(expr, self.next_id());\n+        @codemap::spanned { node: stmt_, span: span }\n+    }\n+\n+    // XXX: unused self\n+    fn mk_ty_mt(&self, ty: @ast::Ty, mutbl: ast::mutability) -> ast::mt {\n+        ast::mt {\n+            ty: ty,\n+            mutbl: mutbl\n+        }\n+    }\n+\n+    fn mk_ty(&self,\n+             span: span,\n+             ty: ast::ty_) -> @ast::Ty {\n+        @ast::Ty {\n+            id: self.next_id(),\n+            span: span,\n+            node: ty\n+        }\n+    }\n+\n+    fn mk_ty_path(&self,\n+                  span: span,\n+                  idents: ~[ ast::ident ])\n+        -> @ast::Ty {\n+        let ty = self.mk_raw_path(span, idents);\n+        self.mk_ty_path_path( span, ty)\n+    }\n+\n+    fn mk_ty_path_global(&self,\n+                         span: span,\n+                         idents: ~[ ast::ident ])\n+        -> @ast::Ty {\n+        let ty = self.mk_raw_path_global(span, idents);\n+        self.mk_ty_path_path( span, ty)\n+    }\n+\n+    fn mk_ty_path_path(&self,\n+                       span: span,\n+                       path: @ast::Path)\n+        -> @ast::Ty {\n+        let ty = ast::ty_path(path, self.next_id());\n+        self.mk_ty( span, ty)\n+    }\n+\n+    fn mk_ty_rptr(&self,\n+                  span: span,\n+                  ty: @ast::Ty,\n+                  lifetime: Option<@ast::Lifetime>,\n+                  mutbl: ast::mutability)\n+        -> @ast::Ty {\n+        self.mk_ty( span,\n+              ast::ty_rptr(lifetime, self.mk_ty_mt(ty, mutbl)))\n+    }\n+    fn mk_ty_uniq(&self, span: span, ty: @ast::Ty) -> @ast::Ty {\n+        self.mk_ty( span, ast::ty_uniq(self.mk_ty_mt(ty, ast::m_imm)))\n+    }\n+    fn mk_ty_box(&self, span: span,\n+                 ty: @ast::Ty, mutbl: ast::mutability) -> @ast::Ty {\n+        self.mk_ty( span, ast::ty_box(self.mk_ty_mt(ty, mutbl)))\n+    }\n+\n+\n+\n+    fn mk_ty_infer(&self, span: span) -> @ast::Ty {\n+        self.mk_ty( span, ast::ty_infer)\n+    }\n+    fn mk_trait_ref_global(&self,\n+                           span: span,\n+                           idents: ~[ ast::ident ])\n+        -> @ast::trait_ref\n+    {\n+        self.mk_trait_ref_( self.mk_raw_path_global(span, idents))\n+    }\n+    fn mk_trait_ref_(&self, path: @ast::Path) -> @ast::trait_ref {\n+        @ast::trait_ref {\n+            path: path,\n+            ref_id: self.next_id()\n+        }\n+    }\n+    fn mk_simple_ty_path(&self,\n+                         span: span,\n+                         ident: ast::ident)\n+        -> @ast::Ty {\n+        self.mk_ty_path( span, ~[ ident ])\n+    }\n+    fn mk_arg(&self,\n+              span: span,\n+              ident: ast::ident,\n+              ty: @ast::Ty)\n+        -> ast::arg {\n+        let arg_pat = self.mk_pat_ident( span, ident);\n+        ast::arg {\n+            is_mutbl: false,\n+            ty: ty,\n+            pat: arg_pat,\n+            id: self.next_id()\n+        }\n+    }\n+    // XXX unused self\n+    fn mk_fn_decl(&self, inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n+        ast::fn_decl { inputs: inputs, output: output, cf: ast::return_val }\n+    }\n+    fn mk_trait_ty_param_bound_global(&self,\n+                                      span: span,\n+                                      idents: ~[ast::ident])\n+        -> ast::TyParamBound {\n+        ast::TraitTyParamBound(self.mk_trait_ref_global( span, idents))\n+    }\n+    fn mk_trait_ty_param_bound_(&self,\n+                                path: @ast::Path) -> ast::TyParamBound {\n+        ast::TraitTyParamBound(self.mk_trait_ref_( path))\n+    }\n+    fn mk_ty_param(&self,\n+                   ident: ast::ident,\n+                   bounds: @OptVec<ast::TyParamBound>)\n+        -> ast::TyParam {\n+        ast::TyParam { ident: ident, id: self.next_id(), bounds: bounds }\n+    }\n+    fn mk_lifetime(&self,\n+                   span: span,\n+                   ident: ast::ident)\n+        -> ast::Lifetime {\n+        ast::Lifetime { id: self.next_id(), span: span, ident: ident }\n+    }\n+    fn mk_arm(&self,\n+              span: span,\n+              pats: ~[@ast::pat],\n+              expr: @ast::expr)\n+        -> ast::arm {\n+        ast::arm {\n+            pats: pats,\n+            guard: None,\n+            body: self.mk_simple_block( span, expr)\n+        }\n+    }\n+    fn mk_unreachable(&self, span: span) -> @ast::expr {\n+        let loc = self.codemap().lookup_char_pos(span.lo);\n+        self.mk_call_global(\n+            span,\n+            ~[\n+                self.ident_of(\"core\"),\n+                self.ident_of(\"sys\"),\n+                self.ident_of(\"FailWithCause\"),\n+                self.ident_of(\"fail_with\"),\n+            ],\n+            ~[\n+                self.mk_base_str( span, ~\"internal error: entered unreachable code\"),\n+                self.mk_base_str( span, copy loc.file.name),\n+                self.mk_uint( span, loc.line),\n+            ]\n+        )\n+    }\n+    fn mk_unreachable_arm(&self, span: span) -> ast::arm {\n+        self.mk_arm( span, ~[self.mk_pat_wild( span)], self.mk_unreachable( span))\n+    }\n+\n+    fn make_self(&self, span: span) -> @ast::expr {\n+        self.mk_expr( span, ast::expr_self)\n+    }\n+}\n+\n+\n+pub trait Duplicate {\n+    //\n+    // Duplication functions\n+    //\n+    // These functions just duplicate AST nodes.\n+    //\n+\n+    fn duplicate(&self, cx: @ExtCtxt) -> Self;\n+}\n+\n+impl Duplicate for @ast::expr {\n+    fn duplicate(&self, cx: @ExtCtxt) -> @ast::expr {\n+        let folder = fold::default_ast_fold();\n+        let folder = @fold::AstFoldFns {\n+            new_id: |_| cx.next_id(),\n+            ..*folder\n+        };\n+        let folder = fold::make_fold(folder);\n+        folder.fold_expr(*self)\n+    }\n }"}, {"sha": "cdc6e267cccbaac19b1447f0eec59bc46978b11a", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=6e5051553050974eb9362e1465cc2d40e2c9a610", "patch": "@@ -14,7 +14,7 @@ use ast;\n use codemap::span;\n use ext::base::*;\n use ext::base;\n-use ext::build::{mk_u8, mk_slice_vec_e};\n+use ext::build::AstBuilder;\n \n pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree]) -> base::MacResult {\n     // Gather all argument expressions\n@@ -28,7 +28,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree]) -> bas\n                 // string literal, push each byte to vector expression\n                 ast::lit_str(s) => {\n                     for s.each |byte| {\n-                        bytes.push(mk_u8(cx, sp, byte));\n+                        bytes.push(cx.mk_u8(sp, byte));\n                     }\n                 }\n \n@@ -37,7 +37,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree]) -> bas\n                     if v > 0xFF {\n                         cx.span_err(sp, \"Too large u8 literal in bytes!\")\n                     } else {\n-                        bytes.push(mk_u8(cx, sp, v as u8));\n+                        bytes.push(cx.mk_u8(sp, v as u8));\n                     }\n                 }\n \n@@ -48,14 +48,14 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree]) -> bas\n                     } else if v < 0 {\n                         cx.span_err(sp, \"Negative integer literal in bytes!\")\n                     } else {\n-                        bytes.push(mk_u8(cx, sp, v as u8));\n+                        bytes.push(cx.mk_u8(sp, v as u8));\n                     }\n                 }\n \n                 // char literal, push to vector expression\n                 ast::lit_int(v, ast::ty_char) => {\n                     if (v as char).is_ascii() {\n-                        bytes.push(mk_u8(cx, sp, v as u8));\n+                        bytes.push(cx.mk_u8(sp, v as u8));\n                     } else {\n                         cx.span_err(sp, \"Non-ascii char literal in bytes!\")\n                     }\n@@ -68,6 +68,6 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree]) -> bas\n         }\n     }\n \n-    let e = mk_slice_vec_e(cx, sp, bytes);\n+    let e = cx.mk_slice_vec_e(sp, bytes);\n     MRExpr(e)\n }"}, {"sha": "07aead9588ac1c00d637c71f33b822c0558847a7", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=6e5051553050974eb9362e1465cc2d40e2c9a610", "patch": "@@ -12,6 +12,7 @@ use ast::{meta_item, item, expr};\n use codemap::span;\n use ext::base::ExtCtxt;\n use ext::build;\n+use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n \n@@ -79,7 +80,7 @@ fn cs_clone(\n     let ctor_ident;\n     let all_fields;\n     let subcall = |field|\n-        build::mk_method_call(cx, span, field, clone_ident, ~[]);\n+        cx.mk_method_call(span, field, clone_ident, ~[]);\n \n     match *substr.fields {\n         Struct(ref af) => {\n@@ -102,7 +103,7 @@ fn cs_clone(\n         [(None, _, _), .. _] => {\n             // enum-like\n             let subcalls = all_fields.map(|&(_, self_f, _)| subcall(self_f));\n-            build::mk_call(cx, span, ctor_ident, subcalls)\n+            cx.mk_call(span, ctor_ident, subcalls)\n         },\n         _ => {\n             // struct-like\n@@ -118,9 +119,9 @@ fn cs_clone(\n \n             if fields.is_empty() {\n                 // no fields, so construct like `None`\n-                build::mk_path(cx, span, ctor_ident)\n+                cx.mk_path(span, ctor_ident)\n             } else {\n-                build::mk_struct_e(cx, span,\n+                cx.mk_struct_e(span,\n                                    ctor_ident,\n                                    fields)\n             }"}, {"sha": "1af664044897763b741987fad1598b78f5f0285e", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=6e5051553050974eb9362e1465cc2d40e2c9a610", "patch": "@@ -11,7 +11,7 @@\n use ast::{meta_item, item, expr};\n use codemap::span;\n use ext::base::ExtCtxt;\n-use ext::build;\n+use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n pub fn expand_deriving_eq(cx: @ExtCtxt,\n@@ -21,11 +21,11 @@ pub fn expand_deriving_eq(cx: @ExtCtxt,\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different\n     fn cs_eq(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n-        cs_and(|cx, span, _, _| build::mk_bool(cx, span, false),\n+        cs_and(|cx, span, _, _| cx.mk_bool(span, false),\n                                  cx, span, substr)\n     }\n     fn cs_ne(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n-        cs_or(|cx, span, _, _| build::mk_bool(cx, span, true),\n+        cs_or(|cx, span, _, _| cx.mk_bool(span, true),\n               cx, span, substr)\n     }\n "}, {"sha": "41b5bf63aca34da77bd64b443226eceb7e9be360", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=6e5051553050974eb9362e1465cc2d40e2c9a610", "patch": "@@ -12,7 +12,7 @@\n use ast::{meta_item, item, expr_if, expr};\n use codemap::span;\n use ext::base::ExtCtxt;\n-use ext::build;\n+use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n pub fn expand_deriving_ord(cx: @ExtCtxt,\n@@ -62,10 +62,10 @@ fn cs_ord(less: bool, equal: bool,\n     } else {\n         cx.ident_of(\"gt\")\n     };\n-    let false_blk_expr = build::mk_block(cx, span,\n+    let false_blk_expr = cx.mk_block(span,\n                                          ~[], ~[],\n-                                         Some(build::mk_bool(cx, span, false)));\n-    let base = build::mk_bool(cx, span, equal);\n+                                         Some(cx.mk_bool(span, false)));\n+    let base = cx.mk_bool(span, equal);\n \n     cs_fold(\n         false, // need foldr,\n@@ -98,19 +98,19 @@ fn cs_ord(less: bool, equal: bool,\n                 cx.span_bug(span, \"Not exactly 2 arguments in `deriving(Ord)`\");\n             }\n \n-            let cmp = build::mk_method_call(cx, span,\n+            let cmp = cx.mk_method_call(span,\n                                             self_f, cx.ident_of(\"eq\"), other_fs.to_owned());\n-            let subexpr = build::mk_simple_block(cx, span, subexpr);\n+            let subexpr = cx.mk_simple_block(span, subexpr);\n             let elseif = expr_if(cmp, subexpr, Some(false_blk_expr));\n-            let elseif = build::mk_expr(cx, span, elseif);\n+            let elseif = cx.mk_expr(span, elseif);\n \n-            let cmp = build::mk_method_call(cx, span,\n+            let cmp = cx.mk_method_call(span,\n                                             self_f, binop, other_fs.to_owned());\n-            let true_blk = build::mk_simple_block(cx, span,\n-                                                  build::mk_bool(cx, span, true));\n+            let true_blk = cx.mk_simple_block(span,\n+                                                  cx.mk_bool(span, true));\n             let if_ = expr_if(cmp, true_blk, Some(elseif));\n \n-            build::mk_expr(cx, span, if_)\n+            cx.mk_expr(span, if_)\n         },\n         base,\n         |cx, span, args, _| {\n@@ -119,7 +119,7 @@ fn cs_ord(less: bool, equal: bool,\n             match args {\n                 [(self_var, _, _),\n                  (other_var, _, _)] =>\n-                    build::mk_bool(cx, span,\n+                    cx.mk_bool(span,\n                                    if less {\n                                        self_var < other_var\n                                    } else {"}, {"sha": "48393efce64873b9bdec0565eb2f19a217cbb11f", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=6e5051553050974eb9362e1465cc2d40e2c9a610", "patch": "@@ -12,7 +12,7 @@\n use ast::{meta_item, item, expr};\n use codemap::span;\n use ext::base::ExtCtxt;\n-use ext::build;\n+use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n pub fn expand_deriving_totaleq(cx: @ExtCtxt,\n@@ -21,7 +21,7 @@ pub fn expand_deriving_totaleq(cx: @ExtCtxt,\n                           in_items: ~[@item]) -> ~[@item] {\n \n     fn cs_equals(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n-        cs_and(|cx, span, _, _| build::mk_bool(cx, span, false),\n+        cs_and(|cx, span, _, _| cx.mk_bool(span, false),\n                cx, span, substr)\n     }\n "}, {"sha": "3404a21edd0de37f536e8dcae272d9cd8c2215c6", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=6e5051553050974eb9362e1465cc2d40e2c9a610", "patch": "@@ -11,7 +11,7 @@\n use ast::{meta_item, item, expr};\n use codemap::span;\n use ext::base::ExtCtxt;\n-use ext::build;\n+use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use core::cmp::{Ordering, Equal, Less, Greater};\n \n@@ -47,7 +47,7 @@ pub fn ordering_const(cx: @ExtCtxt, span: span, cnst: Ordering) -> @expr {\n         Equal => \"Equal\",\n         Greater => \"Greater\"\n     };\n-    build::mk_path_global(cx, span,\n+    cx.mk_path_global(span,\n                           ~[cx.ident_of(\"core\"),\n                             cx.ident_of(\"cmp\"),\n                             cx.ident_of(cnst)])\n@@ -60,7 +60,7 @@ pub fn cs_cmp(cx: @ExtCtxt, span: span,\n         // foldr (possibly) nests the matches in lexical_ordering better\n         false,\n         |cx, span, old, new| {\n-            build::mk_call_global(cx, span,\n+            cx.mk_call_global(span,\n                                   ~[cx.ident_of(\"core\"),\n                                     cx.ident_of(\"cmp\"),\n                                     cx.ident_of(\"lexical_ordering\")],"}, {"sha": "781ac9814ec9b931643b71c207599151287dd368", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 74, "deletions": 94, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=6e5051553050974eb9362e1465cc2d40e2c9a610", "patch": "@@ -16,7 +16,8 @@ encodable.rs for more.\n use ast;\n use ast::*;\n use ext::base::ExtCtxt;\n-use ext::build;\n+use ext::build::Field;\n+use ext::build::AstBuilder;\n use ext::deriving::*;\n use codemap::{span, spanned};\n use ast_util;\n@@ -44,12 +45,10 @@ fn create_derived_decodable_impl(\n     generics: &Generics,\n     method: @method\n ) -> @item {\n-    let decoder_ty_param = build::mk_ty_param(\n-        cx,\n+    let decoder_ty_param = cx.mk_ty_param(\n         cx.ident_of(\"__D\"),\n         @opt_vec::with(\n-            build::mk_trait_ty_param_bound_global(\n-                cx,\n+            cx.mk_trait_ty_param_bound_global(\n                 span,\n                 ~[\n                     cx.ident_of(\"std\"),\n@@ -64,7 +63,7 @@ fn create_derived_decodable_impl(\n     let generic_ty_params = opt_vec::with(decoder_ty_param);\n \n     let methods = [method];\n-    let trait_path = build::mk_raw_path_global_(\n+    let trait_path = cx.mk_raw_path_global_(\n         span,\n         ~[\n             cx.ident_of(\"std\"),\n@@ -73,7 +72,7 @@ fn create_derived_decodable_impl(\n         ],\n         None,\n         ~[\n-            build::mk_simple_ty_path(cx, span, cx.ident_of(\"__D\"))\n+            cx.mk_simple_ty_path(span, cx.ident_of(\"__D\"))\n         ]\n     );\n     create_derived_impl(\n@@ -98,15 +97,14 @@ fn create_decode_method(\n     expr: @ast::expr\n ) -> @method {\n     // Create the `e` parameter.\n-    let d_arg_type = build::mk_ty_rptr(\n-        cx,\n+    let d_arg_type = cx.mk_ty_rptr(\n         span,\n-        build::mk_simple_ty_path(cx, span, cx.ident_of(\"__D\")),\n+        cx.mk_simple_ty_path(span, cx.ident_of(\"__D\")),\n         None,\n         ast::m_mutbl\n     );\n     let d_ident = cx.ident_of(\"__d\");\n-    let d_arg = build::mk_arg(cx, span, d_ident, d_arg_type);\n+    let d_arg = cx.mk_arg(span, d_ident, d_arg_type);\n \n     // Create the type of the return value.\n     let output_type = create_self_type_with_params(\n@@ -118,10 +116,10 @@ fn create_decode_method(\n \n     // Create the function declaration.\n     let inputs = ~[d_arg];\n-    let fn_decl = build::mk_fn_decl(inputs, output_type);\n+    let fn_decl = cx.mk_fn_decl(inputs, output_type);\n \n     // Create the body block.\n-    let body_block = build::mk_simple_block(cx, span, expr);\n+    let body_block = cx.mk_simple_block(span, expr);\n \n     // Create the method.\n     let explicit_self = spanned { node: sty_static, span: span };\n@@ -146,11 +144,9 @@ fn call_substructure_decode_method(\n     span: span\n ) -> @ast::expr {\n     // Call the substructure method.\n-    build::mk_call_(\n-        cx,\n+    cx.mk_call_(\n         span,\n-        build::mk_path_global(\n-            cx,\n+        cx.mk_path_global(\n             span,\n             ~[\n                 cx.ident_of(\"std\"),\n@@ -160,7 +156,7 @@ fn call_substructure_decode_method(\n             ]\n         ),\n         ~[\n-            build::mk_path(cx, span, ~[cx.ident_of(\"__d\")])\n+            cx.mk_path(span, ~[cx.ident_of(\"__d\")])\n         ]\n     )\n }\n@@ -222,55 +218,53 @@ fn create_read_struct_field(\n     span: span,\n     idx: uint,\n     ident: ident\n-) -> build::Field {\n+) -> Field {\n     // Call the substructure method.\n     let decode_expr = call_substructure_decode_method(cx, span);\n \n-    let d_arg = build::mk_arg(cx,\n+    let d_arg = cx.mk_arg(\n                               span,\n                               cx.ident_of(\"__d\"),\n-                              build::mk_ty_infer(cx, span));\n+                              cx.mk_ty_infer(span));\n \n-    let call_expr = build::mk_method_call(\n-        cx,\n+    let call_expr = cx.mk_method_call(\n         span,\n-        build::mk_path(cx, span, ~[cx.ident_of(\"__d\")]),\n+        cx.mk_path(span, ~[cx.ident_of(\"__d\")]),\n         cx.ident_of(\"read_struct_field\"),\n         ~[\n-            build::mk_base_str(cx, span, cx.str_of(ident)),\n-            build::mk_uint(cx, span, idx),\n-            build::mk_lambda(cx,\n+            cx.mk_base_str(span, cx.str_of(ident)),\n+            cx.mk_uint(span, idx),\n+            cx.mk_lambda(\n                              span,\n-                             build::mk_fn_decl(~[d_arg],\n-                                               build::mk_ty_infer(cx, span)),\n+                             cx.mk_fn_decl(~[d_arg],\n+                                           cx.mk_ty_infer(span)),\n                              decode_expr),\n         ]\n     );\n \n-    build::Field { ident: ident, ex: call_expr }\n+    Field { ident: ident, ex: call_expr }\n }\n \n fn create_read_struct_arg(\n     cx: @ExtCtxt,\n     span: span,\n     idx: uint,\n     ident: ident\n-) -> build::Field {\n+) -> Field {\n     // Call the substructure method.\n     let decode_expr = call_substructure_decode_method(cx, span);\n \n-    let call_expr = build::mk_method_call(\n-        cx,\n+    let call_expr = cx.mk_method_call(\n         span,\n-        build::mk_path(cx, span, ~[cx.ident_of(\"__d\")]),\n+        cx.mk_path(span, ~[cx.ident_of(\"__d\")]),\n         cx.ident_of(\"read_struct_arg\"),\n         ~[\n-            build::mk_uint(cx, span, idx),\n-            build::mk_lambda_no_args(cx, span, decode_expr),\n+            cx.mk_uint(span, idx),\n+            cx.mk_lambda_no_args(span, decode_expr),\n         ]\n     );\n \n-    build::Field { ident: ident, ex: call_expr }\n+    Field { ident: ident, ex: call_expr }\n }\n \n fn expand_deriving_decodable_struct_method(\n@@ -298,29 +292,25 @@ fn expand_deriving_decodable_struct_method(\n         i += 1;\n     }\n \n-    let d_arg = build::mk_arg(cx,\n+    let d_arg = cx.mk_arg(\n                               span,\n                               cx.ident_of(\"__d\"),\n-                              build::mk_ty_infer(cx, span));\n+                              cx.mk_ty_infer(span));\n \n-    let read_struct_expr = build::mk_method_call(\n-        cx,\n+    let read_struct_expr = cx.mk_method_call(\n         span,\n-        build::mk_path(\n-            cx,\n+        cx.mk_path(\n             span,\n             ~[cx.ident_of(\"__d\")]\n         ),\n         cx.ident_of(\"read_struct\"),\n         ~[\n-            build::mk_base_str(cx, span, cx.str_of(type_ident)),\n-            build::mk_uint(cx, span, fields.len()),\n-            build::mk_lambda(\n-                cx,\n+            cx.mk_base_str(span, cx.str_of(type_ident)),\n+            cx.mk_uint(span, fields.len()),\n+            cx.mk_lambda(\n                 span,\n-                build::mk_fn_decl(~[d_arg], build::mk_ty_infer(cx, span)),\n-                build::mk_struct_e(\n-                    cx,\n+                cx.mk_fn_decl(~[d_arg], cx.mk_ty_infer(span)),\n+                cx.mk_struct_e(\n                     span,\n                     ~[type_ident],\n                     fields\n@@ -340,14 +330,14 @@ fn create_read_variant_arg(\n     variant: &ast::variant\n ) -> ast::arm {\n     // Create the matching pattern.\n-    let pat = build::mk_pat_lit(cx, span, build::mk_uint(cx, span, idx));\n+    let pat = cx.mk_pat_lit(span, cx.mk_uint(span, idx));\n \n     // Feed each argument in this variant to the decode function\n     // as well.\n     let variant_arg_len = variant_arg_count(cx, span, variant);\n \n     let expr = if variant_arg_len == 0 {\n-        build::mk_path(cx, span, ~[variant.node.name])\n+        cx.mk_path(span, ~[variant.node.name])\n     } else {\n         // Feed the discriminant to the decode function.\n         let mut args = ~[];\n@@ -356,39 +346,37 @@ fn create_read_variant_arg(\n             // Call the substructure method.\n             let expr = call_substructure_decode_method(cx, span);\n \n-            let d_arg = build::mk_arg(cx,\n+            let d_arg = cx.mk_arg(\n                                       span,\n                                       cx.ident_of(\"__d\"),\n-                                      build::mk_ty_infer(cx, span));\n-            let t_infer = build::mk_ty_infer(cx, span);\n+                                      cx.mk_ty_infer(span));\n+            let t_infer = cx.mk_ty_infer(span);\n \n-            let call_expr = build::mk_method_call(\n-                cx,\n+            let call_expr = cx.mk_method_call(\n                 span,\n-                build::mk_path(cx, span, ~[cx.ident_of(\"__d\")]),\n+                cx.mk_path(span, ~[cx.ident_of(\"__d\")]),\n                 cx.ident_of(\"read_enum_variant_arg\"),\n                 ~[\n-                    build::mk_uint(cx, span, j),\n-                    build::mk_lambda(cx,\n+                    cx.mk_uint(span, j),\n+                    cx.mk_lambda(\n                                      span,\n-                                     build::mk_fn_decl(~[d_arg], t_infer),\n+                                     cx.mk_fn_decl(~[d_arg], t_infer),\n                                      expr),\n                 ]\n             );\n \n             args.push(call_expr);\n         }\n \n-        build::mk_call(\n-            cx,\n+        cx.mk_call(\n             span,\n             ~[variant.node.name],\n             args\n         )\n     };\n \n     // Create the arm.\n-    build::mk_arm(cx, span, ~[pat], expr)\n+    cx.mk_arm(span, ~[pat], expr)\n }\n \n fn create_read_enum_variant(\n@@ -397,12 +385,10 @@ fn create_read_enum_variant(\n     enum_definition: &enum_def\n ) -> @expr {\n     // Create a vector that contains all the variant names.\n-    let expr_arm_names = build::mk_base_vec_e(\n-        cx,\n+    let expr_arm_names = cx.mk_base_vec_e(\n         span,\n         do enum_definition.variants.map |variant| {\n-            build::mk_base_str(\n-                cx,\n+            cx.mk_base_str(\n                 span,\n                 cx.str_of(variant.node.name)\n             )\n@@ -415,41 +401,36 @@ fn create_read_enum_variant(\n     };\n \n     // Add the impossible case arm.\n-    arms.push(build::mk_unreachable_arm(cx, span));\n+    arms.push(cx.mk_unreachable_arm(span));\n \n     // Create the read_enum_variant expression.\n-    build::mk_method_call(\n-        cx,\n+    cx.mk_method_call(\n         span,\n-        build::mk_path(cx, span, ~[cx.ident_of(\"__d\")]),\n+        cx.mk_path(span, ~[cx.ident_of(\"__d\")]),\n         cx.ident_of(\"read_enum_variant\"),\n         ~[\n             expr_arm_names,\n-            build::mk_lambda(\n-                cx,\n+            cx.mk_lambda(\n                 span,\n-                build::mk_fn_decl(\n+                cx.mk_fn_decl(\n                     ~[\n-                        build::mk_arg(\n-                            cx,\n+                        cx.mk_arg(\n                             span,\n                             cx.ident_of(\"__d\"),\n-                            build::mk_ty_infer(cx, span)\n+                            cx.mk_ty_infer(span)\n                         ),\n-                        build::mk_arg(\n-                            cx,\n+                        cx.mk_arg(\n                             span,\n                             cx.ident_of(\"__i\"),\n-                            build::mk_ty_infer(cx, span)\n+                            cx.mk_ty_infer(span)\n                         )\n                     ],\n-                    build::mk_ty_infer(cx, span)\n+                    cx.mk_ty_infer(span)\n                 ),\n-                build::mk_expr(\n-                    cx,\n+                cx.mk_expr(\n                     span,\n                     ast::expr_match(\n-                        build::mk_path(cx, span, ~[cx.ident_of(\"__i\")]),\n+                        cx.mk_path(span, ~[cx.ident_of(\"__i\")]),\n                         arms\n                     )\n                 )\n@@ -471,23 +452,22 @@ fn expand_deriving_decodable_enum_method(\n         enum_definition\n     );\n \n-    let d_arg = build::mk_arg(cx,\n+    let d_arg = cx.mk_arg(\n                               span,\n                               cx.ident_of(\"__d\"),\n-                              build::mk_ty_infer(cx, span));\n+                              cx.mk_ty_infer(span));\n \n     // Create the read_enum expression\n-    let read_enum_expr = build::mk_method_call(\n-        cx,\n+    let read_enum_expr = cx.mk_method_call(\n         span,\n-        build::mk_path(cx, span, ~[cx.ident_of(\"__d\")]),\n+        cx.mk_path(span, ~[cx.ident_of(\"__d\")]),\n         cx.ident_of(\"read_enum\"),\n         ~[\n-            build::mk_base_str(cx, span, cx.str_of(type_ident)),\n-            build::mk_lambda(cx,\n+            cx.mk_base_str(span, cx.str_of(type_ident)),\n+            cx.mk_lambda(\n                              span,\n-                             build::mk_fn_decl(~[d_arg],\n-                                               build::mk_ty_infer(cx, span)),\n+                             cx.mk_fn_decl(~[d_arg],\n+                                               cx.mk_ty_infer(span)),\n                              read_enum_variant_expr),\n         ]\n     );"}, {"sha": "eda1909aed4cba7883d8ea9472986157171a7a08", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 58, "deletions": 73, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=6e5051553050974eb9362e1465cc2d40e2c9a610", "patch": "@@ -79,7 +79,7 @@ would yield functions like:\n use ast;\n use ast::*;\n use ext::base::ExtCtxt;\n-use ext::build;\n+use ext::build::AstBuilder;\n use ext::deriving::*;\n use codemap::{span, spanned};\n use ast_util;\n@@ -107,12 +107,10 @@ fn create_derived_encodable_impl(\n     generics: &Generics,\n     method: @method\n ) -> @item {\n-    let encoder_ty_param = build::mk_ty_param(\n-        cx,\n+    let encoder_ty_param = cx.mk_ty_param(\n         cx.ident_of(\"__E\"),\n         @opt_vec::with(\n-            build::mk_trait_ty_param_bound_global(\n-                cx,\n+            cx.mk_trait_ty_param_bound_global(\n                 span,\n                 ~[\n                     cx.ident_of(\"std\"),\n@@ -127,7 +125,7 @@ fn create_derived_encodable_impl(\n     let generic_ty_params = opt_vec::with(encoder_ty_param);\n \n     let methods = [method];\n-    let trait_path = build::mk_raw_path_global_(\n+    let trait_path = cx.mk_raw_path_global_(\n         span,\n         ~[\n             cx.ident_of(\"std\"),\n@@ -136,7 +134,7 @@ fn create_derived_encodable_impl(\n         ],\n         None,\n         ~[\n-            build::mk_simple_ty_path(cx, span, cx.ident_of(\"__E\"))\n+            cx.mk_simple_ty_path(span, cx.ident_of(\"__E\"))\n         ]\n     );\n     create_derived_impl(\n@@ -159,24 +157,23 @@ fn create_encode_method(\n     statements: ~[@stmt]\n ) -> @method {\n     // Create the `e` parameter.\n-    let e_arg_type = build::mk_ty_rptr(\n-        cx,\n+    let e_arg_type = cx.mk_ty_rptr(\n         span,\n-        build::mk_simple_ty_path(cx, span, cx.ident_of(\"__E\")),\n+        cx.mk_simple_ty_path(span, cx.ident_of(\"__E\")),\n         None,\n         ast::m_mutbl\n     );\n-    let e_arg = build::mk_arg(cx, span, cx.ident_of(\"__e\"), e_arg_type);\n+    let e_arg = cx.mk_arg(span, cx.ident_of(\"__e\"), e_arg_type);\n \n     // Create the type of the return value.\n     let output_type = @ast::Ty { id: cx.next_id(), node: ty_nil, span: span };\n \n     // Create the function declaration.\n     let inputs = ~[e_arg];\n-    let fn_decl = build::mk_fn_decl(inputs, output_type);\n+    let fn_decl = cx.mk_fn_decl(inputs, output_type);\n \n     // Create the body block.\n-    let body_block = build::mk_block_(cx, span, statements);\n+    let body_block = cx.mk_block_(span, statements);\n \n     // Create the method.\n     let explicit_self = spanned { node: sty_region(None, m_imm), span: span };\n@@ -203,12 +200,11 @@ fn call_substructure_encode_method(\n ) -> @ast::expr {\n     // Gather up the parameters we want to chain along.\n     let e_ident = cx.ident_of(\"__e\");\n-    let e_expr = build::mk_path(cx, span, ~[e_ident]);\n+    let e_expr = cx.mk_path(span, ~[e_ident]);\n \n     // Call the substructure method.\n     let encode_ident = cx.ident_of(\"encode\");\n-    build::mk_method_call(\n-        cx,\n+    cx.mk_method_call(\n         span,\n         self_field,\n         encode_ident,\n@@ -279,9 +275,9 @@ fn expand_deriving_encodable_struct_method(\n         match struct_field.node.kind {\n             named_field(ident, _) => {\n                 // Create the accessor for this field.\n-                let self_field = build::mk_access_(cx,\n+                let self_field = cx.mk_access_(\n                                                    span,\n-                                                   build::make_self(cx, span),\n+                                                   cx.make_self(span),\n                                                    ident);\n \n                 // Call the substructure method.\n@@ -292,31 +288,29 @@ fn expand_deriving_encodable_struct_method(\n                 );\n \n                 let e_ident = cx.ident_of(\"__e\");\n-                let e_arg = build::mk_arg(cx,\n+                let e_arg = cx.mk_arg(\n                                           span,\n                                           e_ident,\n-                                          build::mk_ty_infer(cx, span));\n+                                          cx.mk_ty_infer(span));\n \n-                let blk_expr = build::mk_lambda(\n-                    cx,\n+                let blk_expr = cx.mk_lambda(\n                     span,\n-                    build::mk_fn_decl(~[e_arg], build::mk_ty_infer(cx, span)),\n+                    cx.mk_fn_decl(~[e_arg], cx.mk_ty_infer(span)),\n                     encode_expr\n                 );\n \n-                let call_expr = build::mk_method_call(\n-                    cx,\n+                let call_expr = cx.mk_method_call(\n                     span,\n-                    build::mk_path(cx, span, ~[cx.ident_of(\"__e\")]),\n+                    cx.mk_path(span, ~[cx.ident_of(\"__e\")]),\n                     cx.ident_of(\"emit_struct_field\"),\n                     ~[\n-                        build::mk_base_str(cx, span, cx.str_of(ident)),\n-                        build::mk_uint(cx, span, idx),\n+                        cx.mk_base_str(span, cx.str_of(ident)),\n+                        cx.mk_uint(span, idx),\n                         blk_expr\n                     ]\n                 );\n \n-                statements.push(build::mk_stmt(cx, span, call_expr));\n+                statements.push(cx.mk_stmt(span, call_expr));\n             }\n             unnamed_field => {\n                 cx.span_unimpl(\n@@ -328,33 +322,30 @@ fn expand_deriving_encodable_struct_method(\n         idx += 1;\n     }\n \n-    let e_arg = build::mk_arg(cx,\n+    let e_arg = cx.mk_arg(\n                               span,\n                               cx.ident_of(\"__e\"),\n-                              build::mk_ty_infer(cx, span));\n+                              cx.mk_ty_infer(span));\n \n-    let emit_struct_stmt = build::mk_method_call(\n-        cx,\n+    let emit_struct_stmt = cx.mk_method_call(\n         span,\n-        build::mk_path(\n-            cx,\n+        cx.mk_path(\n             span,\n             ~[cx.ident_of(\"__e\")]\n         ),\n         cx.ident_of(\"emit_struct\"),\n         ~[\n-            build::mk_base_str(cx, span, cx.str_of(type_ident)),\n-            build::mk_uint(cx, span, statements.len()),\n-            build::mk_lambda_stmts(\n-                cx,\n+            cx.mk_base_str(span, cx.str_of(type_ident)),\n+            cx.mk_uint(span, statements.len()),\n+            cx.mk_lambda_stmts(\n                 span,\n-                build::mk_fn_decl(~[e_arg], build::mk_ty_infer(cx, span)),\n+                cx.mk_fn_decl(~[e_arg], cx.mk_ty_infer(span)),\n                 statements\n             ),\n         ]\n     );\n \n-    let statements = ~[build::mk_stmt(cx, span, emit_struct_stmt)];\n+    let statements = ~[cx.mk_stmt(span, emit_struct_stmt)];\n \n     // Create the method itself.\n     return create_encode_method(cx, span, statements);\n@@ -382,56 +373,52 @@ fn expand_deriving_encodable_enum_method(\n             let expr = call_substructure_encode_method(cx, span, field);\n \n             let e_ident = cx.ident_of(\"__e\");\n-            let e_arg = build::mk_arg(cx,\n+            let e_arg = cx.mk_arg(\n                                       span,\n                                       e_ident,\n-                                      build::mk_ty_infer(cx, span));\n+                                      cx.mk_ty_infer(span));\n \n-            let blk_expr = build::mk_lambda(\n-                cx,\n+            let blk_expr = cx.mk_lambda(\n                 span,\n-                build::mk_fn_decl(~[e_arg], build::mk_ty_infer(cx, span)),\n+                cx.mk_fn_decl(~[e_arg], cx.mk_ty_infer(span)),\n                 expr\n             );\n \n-            let call_expr = build::mk_method_call(\n-                cx,\n+            let call_expr = cx.mk_method_call(\n                 span,\n-                build::mk_path(cx, span, ~[cx.ident_of(\"__e\")]),\n+                cx.mk_path(span, ~[cx.ident_of(\"__e\")]),\n                 cx.ident_of(\"emit_enum_variant_arg\"),\n                 ~[\n-                    build::mk_uint(cx, span, j),\n+                    cx.mk_uint(span, j),\n                     blk_expr,\n                 ]\n             );\n \n-            stmts.push(build::mk_stmt(cx, span, call_expr));\n+            stmts.push(cx.mk_stmt(span, call_expr));\n         }\n \n         // Create the pattern body.\n-        let e_arg = build::mk_arg(cx,\n+        let e_arg = cx.mk_arg(\n                                   span,\n                                   cx.ident_of(\"__e\"),\n-                                  build::mk_ty_infer(cx, span));\n-        let call_expr = build::mk_method_call(\n-            cx,\n+                                  cx.mk_ty_infer(span));\n+        let call_expr = cx.mk_method_call(\n             span,\n-            build::mk_path(cx, span, ~[cx.ident_of(\"__e\")]),\n+            cx.mk_path(span, ~[cx.ident_of(\"__e\")]),\n             cx.ident_of(\"emit_enum_variant\"),\n             ~[\n-                build::mk_base_str(cx, span, cx.str_of(variant.node.name)),\n-                build::mk_uint(cx, span, i),\n-                build::mk_uint(cx, span, variant_arg_len),\n-                build::mk_lambda_stmts(\n-                    cx,\n+                cx.mk_base_str(span, cx.str_of(variant.node.name)),\n+                cx.mk_uint(span, i),\n+                cx.mk_uint(span, variant_arg_len),\n+                cx.mk_lambda_stmts(\n                     span,\n-                    build::mk_fn_decl(~[e_arg], build::mk_ty_infer(cx, span)),\n+                    cx.mk_fn_decl(~[e_arg], cx.mk_ty_infer(span)),\n                     stmts\n                 )\n             ]\n         );\n \n-        let match_body_block = build::mk_simple_block(cx, span, call_expr);\n+        let match_body_block = cx.mk_simple_block(span, call_expr);\n \n         // Create the arm.\n         ast::arm {\n@@ -442,31 +429,29 @@ fn expand_deriving_encodable_enum_method(\n     };\n \n     let e_ident = cx.ident_of(\"__e\");\n-    let e_arg = build::mk_arg(cx,\n+    let e_arg = cx.mk_arg(\n                               span,\n                               e_ident,\n-                              build::mk_ty_infer(cx, span));\n+                              cx.mk_ty_infer(span));\n \n     // Create the method body.\n-    let lambda_expr = build::mk_lambda(\n-        cx,\n+    let lambda_expr = cx.mk_lambda(\n         span,\n-        build::mk_fn_decl(~[e_arg], build::mk_ty_infer(cx, span)),\n+        cx.mk_fn_decl(~[e_arg], cx.mk_ty_infer(span)),\n         expand_enum_or_struct_match(cx, span, arms)\n     );\n \n-    let call_expr = build::mk_method_call(\n-        cx,\n+    let call_expr = cx.mk_method_call(\n         span,\n-        build::mk_path(cx, span, ~[cx.ident_of(\"__e\")]),\n+        cx.mk_path(span, ~[cx.ident_of(\"__e\")]),\n         cx.ident_of(\"emit_enum\"),\n         ~[\n-            build::mk_base_str(cx, span, cx.str_of(type_ident)),\n+            cx.mk_base_str(span, cx.str_of(type_ident)),\n             lambda_expr,\n         ]\n     );\n \n-    let stmt = build::mk_stmt(cx, span, call_expr);\n+    let stmt = cx.mk_stmt(span, call_expr);\n \n     // Create the method.\n     create_encode_method(cx, span, ~[stmt])"}, {"sha": "4859fec2e445297c05e16351dda4387c8463cd04", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=6e5051553050974eb9362e1465cc2d40e2c9a610", "patch": "@@ -166,7 +166,7 @@ use ast;\n use ast::{enum_def, expr, ident, Generics, struct_def};\n \n use ext::base::ExtCtxt;\n-use ext::build;\n+use ext::build::AstBuilder;\n use ext::deriving::*;\n use codemap::{span,respan};\n use opt_vec;\n@@ -431,7 +431,7 @@ impl<'self> MethodDef<'self> {\n             let ident = cx.ident_of(fmt!(\"__arg_%u\", i));\n             arg_tys.push((ident, ast_ty));\n \n-            let arg_expr = build::mk_path(cx, span, ~[ident]);\n+            let arg_expr = cx.mk_path(span, ~[ident]);\n \n             match *ty {\n                 // for static methods, just treat any Self\n@@ -440,7 +440,7 @@ impl<'self> MethodDef<'self> {\n                     self_args.push(arg_expr);\n                 }\n                 Ptr(~Self, _) if nonstatic => {\n-                    self_args.push(build::mk_deref(cx, span, arg_expr))\n+                    self_args.push(cx.mk_deref(span, arg_expr))\n                 }\n                 _ => {\n                     nonself_args.push(arg_expr);\n@@ -461,14 +461,14 @@ impl<'self> MethodDef<'self> {\n         let fn_generics = self.generics.to_generics(cx, span, type_ident, generics);\n \n         let args = do arg_types.map |&(id, ty)| {\n-            build::mk_arg(cx, span, id, ty)\n+            cx.mk_arg(span, id, ty)\n         };\n \n         let ret_type = self.get_ret_ty(cx, span, generics, type_ident);\n \n         let method_ident = cx.ident_of(self.name);\n-        let fn_decl = build::mk_fn_decl(args, ret_type);\n-        let body_block = build::mk_simple_block(cx, span, body);\n+        let fn_decl = cx.mk_fn_decl(args, ret_type);\n+        let body_block = cx.mk_simple_block(span, body);\n \n \n         // Create the method.\n@@ -558,10 +558,10 @@ impl<'self> MethodDef<'self> {\n             let match_arm = ast::arm {\n                 pats: ~[ pat ],\n                 guard: None,\n-                body: build::mk_simple_block(cx, span, body)\n+                body: cx.mk_simple_block(span, body)\n             };\n \n-            body = build::mk_expr(cx, span, ast::expr_match(arg_expr, ~[match_arm]))\n+            body = cx.mk_expr(span, ast::expr_match(arg_expr, ~[match_arm]))\n         }\n         body\n     }\n@@ -738,15 +738,15 @@ impl<'self> MethodDef<'self> {\n                                                      matches_so_far,\n                                                      match_count + 1);\n                 matches_so_far.pop();\n-                arms.push(build::mk_arm(cx, span, ~[ pattern ], arm_expr));\n+                arms.push(cx.mk_arm(span, ~[ pattern ], arm_expr));\n \n                 if enum_def.variants.len() > 1 {\n                     let e = &EnumNonMatching(&[]);\n                     let wild_expr = self.call_substructure_method(cx, span, type_ident,\n                                                                   self_args, nonself_args,\n                                                                   e);\n-                    let wild_arm = build::mk_arm(cx, span,\n-                                                 ~[ build::mk_pat_wild(cx, span) ],\n+                    let wild_arm = cx.mk_arm(span,\n+                                                 ~[ cx.mk_pat_wild(span) ],\n                                                  wild_expr);\n                     arms.push(wild_arm);\n                 }\n@@ -774,13 +774,13 @@ impl<'self> MethodDef<'self> {\n                                                          match_count + 1);\n                     matches_so_far.pop();\n \n-                    let arm = build::mk_arm(cx, span, ~[ pattern ], arm_expr);\n+                    let arm = cx.mk_arm(span, ~[ pattern ], arm_expr);\n                     arms.push(arm);\n                 }\n             }\n \n             // match foo { arm, arm, arm, ... }\n-            build::mk_expr(cx, span,\n+            cx.mk_expr(span,\n                            ast::expr_match(self_args[match_count], arms))\n         }\n     }\n@@ -887,7 +887,7 @@ pub fn cs_same_method(f: &fn(@ExtCtxt, span, ~[@expr]) -> @expr,\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             // call self_n.method(other_1_n, other_2_n, ...)\n             let called = do all_fields.map |&(_, self_field, other_fields)| {\n-                build::mk_method_call(cx, span,\n+                cx.mk_method_call(span,\n                                       self_field,\n                                       substructure.method_ident,\n                                       other_fields)\n@@ -945,7 +945,7 @@ pub fn cs_binop(binop: ast::binop, base: @expr,\n     cs_same_method_fold(\n         true, // foldl is good enough\n         |cx, span, old, new| {\n-            build::mk_binary(cx, span,\n+            cx.mk_binary(span,\n                              binop,\n                              old, new)\n \n@@ -960,7 +960,7 @@ pub fn cs_binop(binop: ast::binop, base: @expr,\n pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n              cx: @ExtCtxt, span: span,\n              substructure: &Substructure) -> @expr {\n-    cs_binop(ast::or, build::mk_bool(cx, span, false),\n+    cs_binop(ast::or, cx.mk_bool(span, false),\n              enum_nonmatch_f,\n              cx, span, substructure)\n }\n@@ -969,7 +969,7 @@ pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n pub fn cs_and(enum_nonmatch_f: EnumNonMatchFunc,\n               cx: @ExtCtxt, span: span,\n               substructure: &Substructure) -> @expr {\n-    cs_binop(ast::and, build::mk_bool(cx, span, true),\n+    cs_binop(ast::and, cx.mk_bool(span, true),\n              enum_nonmatch_f,\n              cx, span, substructure)\n }"}, {"sha": "cc89bae37b76fcb6c9376263f65fb396517c5332", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=6e5051553050974eb9362e1465cc2d40e2c9a610", "patch": "@@ -11,7 +11,7 @@\n use ast::{meta_item, item, expr, and};\n use codemap::span;\n use ext::base::ExtCtxt;\n-use ext::build;\n+use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n pub fn expand_deriving_iter_bytes(cx: @ExtCtxt,\n@@ -48,7 +48,7 @@ fn iter_bytes_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @\n     };\n     let iter_bytes_ident = substr.method_ident;\n     let call_iterbytes = |thing_expr| {\n-        build::mk_method_call(cx, span,\n+        cx.mk_method_call(span,\n                               thing_expr, iter_bytes_ident,\n                               copy lsb0_f)\n     };\n@@ -63,7 +63,7 @@ fn iter_bytes_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @\n             // iteration function.\n             let discriminant = match variant.node.disr_expr {\n                 Some(copy d)=> d,\n-                None => build::mk_uint(cx, span, index)\n+                None => cx.mk_uint(span, index)\n             };\n \n             exprs.push(call_iterbytes(discriminant));\n@@ -82,6 +82,6 @@ fn iter_bytes_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @\n     }\n \n     do vec::foldl(exprs[0], exprs.slice(1, exprs.len())) |prev, me| {\n-        build::mk_binary(cx, span, and, prev, *me)\n+        cx.mk_binary(span, and, prev, *me)\n     }\n }"}, {"sha": "a7f70236251bab76f17b9dd2231d4d0eca8ae0e9", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=6e5051553050974eb9362e1465cc2d40e2c9a610", "patch": "@@ -21,7 +21,7 @@ library.\n use ast;\n use ast::{Ty, enum_def, expr, ident, item, Generics, meta_item, struct_def};\n use ext::base::ExtCtxt;\n-use ext::build;\n+use ext::build::AstBuilder;\n use codemap::{span, respan};\n use parse::token::special_idents::clownshoes_extensions;\n use opt_vec;\n@@ -172,7 +172,7 @@ pub fn create_self_type_with_params(cx: @ExtCtxt,\n     // Create the type parameters on the `self` path.\n     let mut self_ty_params = ~[];\n     for generics.ty_params.each |ty_param| {\n-        let self_ty_param = build::mk_simple_ty_path(cx,\n+        let self_ty_param = cx.mk_simple_ty_path(\n                                                      span,\n                                                      ty_param.ident);\n         self_ty_params.push(self_ty_param);\n@@ -186,11 +186,11 @@ pub fn create_self_type_with_params(cx: @ExtCtxt,\n \n \n     // Create the type of `self`.\n-    let self_type = build::mk_raw_path_(span,\n-                                        ~[ type_ident ],\n+    let self_type = cx.mk_raw_path_(span,\n+                                    ~[ type_ident ],\n                                         lifetime,\n                                         self_ty_params);\n-    build::mk_ty_path_path(cx, span, self_type)\n+    cx.mk_ty_path_path(span, self_type)\n }\n \n pub fn create_derived_impl(cx: @ExtCtxt,\n@@ -222,18 +222,18 @@ pub fn create_derived_impl(cx: @ExtCtxt,\n     for generics.ty_params.each |ty_param| {\n         // extra restrictions on the generics parameters to the type being derived upon\n         let mut bounds = do bounds_paths.map |&bound_path| {\n-            build::mk_trait_ty_param_bound_(cx, bound_path)\n+            cx.mk_trait_ty_param_bound_(bound_path)\n         };\n \n         let this_trait_bound =\n-            build::mk_trait_ty_param_bound_(cx, trait_path);\n+            cx.mk_trait_ty_param_bound_(trait_path);\n         bounds.push(this_trait_bound);\n \n-        impl_generics.ty_params.push(build::mk_ty_param(cx, ty_param.ident, @bounds));\n+        impl_generics.ty_params.push(cx.mk_ty_param(ty_param.ident, @bounds));\n     }\n \n     // Create the reference to the trait.\n-    let trait_ref = build::mk_trait_ref_(cx, trait_path);\n+    let trait_ref = cx.mk_trait_ref_(trait_path);\n \n     // Create the type of `self`.\n     let self_type = create_self_type_with_params(cx,\n@@ -255,7 +255,7 @@ pub fn create_subpatterns(cx: @ExtCtxt,\n                           mutbl: ast::mutability)\n                    -> ~[@ast::pat] {\n     do field_paths.map |&path| {\n-        build::mk_pat(cx, span,\n+        cx.mk_pat(span,\n                       ast::pat_ident(ast::bind_by_ref(mutbl), path, None))\n     }\n }\n@@ -274,12 +274,12 @@ pub fn create_struct_pattern(cx: @ExtCtxt,\n     -> (@ast::pat, ~[(Option<ident>, @expr)]) {\n     if struct_def.fields.is_empty() {\n         return (\n-            build::mk_pat_ident_with_binding_mode(\n-                cx, span, struct_ident, ast::bind_infer),\n+            cx.mk_pat_ident_with_binding_mode(\n+                span, struct_ident, ast::bind_infer),\n             ~[]);\n     }\n \n-    let matching_path = build::mk_raw_path(span, ~[ struct_ident ]);\n+    let matching_path = cx.mk_raw_path(span, ~[ struct_ident ]);\n \n     let mut paths = ~[], ident_expr = ~[];\n \n@@ -301,10 +301,10 @@ pub fn create_struct_pattern(cx: @ExtCtxt,\n                 cx.span_bug(span, \"A struct with named and unnamed fields in `deriving`\");\n             }\n         };\n-        let path = build::mk_raw_path(span,\n+        let path = cx.mk_raw_path(span,\n                                       ~[ cx.ident_of(fmt!(\"%s_%u\", prefix, i)) ]);\n         paths.push(path);\n-        ident_expr.push((opt_id, build::mk_path_raw(cx, span, path)));\n+        ident_expr.push((opt_id, cx.mk_path_raw(span, path)));\n     }\n \n     let subpats = create_subpatterns(cx, span, paths, mutbl);\n@@ -318,9 +318,9 @@ pub fn create_struct_pattern(cx: @ExtCtxt,\n                 push(ast::field_pat { ident: id.get(), pat: pat })\n             }\n         };\n-        build::mk_pat_struct(cx, span, matching_path, field_pats)\n+        cx.mk_pat_struct(span, matching_path, field_pats)\n     } else {\n-        build::mk_pat_enum(cx, span, matching_path, subpats)\n+        cx.mk_pat_enum(span, matching_path, subpats)\n     };\n \n     (pattern, ident_expr)\n@@ -337,24 +337,24 @@ pub fn create_enum_variant_pattern(cx: @ExtCtxt,\n     match variant.node.kind {\n         ast::tuple_variant_kind(ref variant_args) => {\n             if variant_args.is_empty() {\n-                return (build::mk_pat_ident_with_binding_mode(\n-                    cx, span, variant_ident, ast::bind_infer), ~[]);\n+                return (cx.mk_pat_ident_with_binding_mode(\n+                    span, variant_ident, ast::bind_infer), ~[]);\n             }\n \n-            let matching_path = build::mk_raw_path(span, ~[ variant_ident ]);\n+            let matching_path = cx.mk_raw_path(span, ~[ variant_ident ]);\n \n             let mut paths = ~[], ident_expr = ~[];\n             for uint::range(0, variant_args.len()) |i| {\n-                let path = build::mk_raw_path(span,\n+                let path = cx.mk_raw_path(span,\n                                               ~[ cx.ident_of(fmt!(\"%s_%u\", prefix, i)) ]);\n \n                 paths.push(path);\n-                ident_expr.push((None, build::mk_path_raw(cx, span, path)));\n+                ident_expr.push((None, cx.mk_path_raw(span, path)));\n             }\n \n             let subpats = create_subpatterns(cx, span, paths, mutbl);\n \n-            (build::mk_pat_enum(cx, span, matching_path, subpats),\n+            (cx.mk_pat_enum(span, matching_path, subpats),\n              ident_expr)\n         }\n         ast::struct_variant_kind(struct_def) => {\n@@ -377,8 +377,8 @@ pub fn expand_enum_or_struct_match(cx: @ExtCtxt,\n                                span: span,\n                                arms: ~[ ast::arm ])\n                             -> @expr {\n-    let self_expr = build::make_self(cx, span);\n-    let self_expr = build::mk_unary(cx, span, ast::deref, self_expr);\n+    let self_expr = cx.make_self(span);\n+    let self_expr = cx.mk_unary(span, ast::deref, self_expr);\n     let self_match_expr = ast::expr_match(self_expr, arms);\n-    build::mk_expr(cx, span, self_match_expr)\n+    cx.mk_expr(span, self_match_expr)\n }"}, {"sha": "b8e9de22fb0ef5261cf382c6a664d267ec9cabdd", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=6e5051553050974eb9362e1465cc2d40e2c9a610", "patch": "@@ -12,7 +12,7 @@ use ast;\n use ast::{meta_item, item, expr, ident};\n use codemap::span;\n use ext::base::ExtCtxt;\n-use ext::build;\n+use ext::build::{AstBuilder, Duplicate, Field};\n use ext::deriving::generic::*;\n \n pub fn expand_deriving_rand(cx: @ExtCtxt,\n@@ -59,10 +59,10 @@ fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n         cx.ident_of(\"rand\")\n     ];\n     let rand_call = || {\n-        build::mk_call_global(cx,\n+        cx.mk_call_global(\n                               span,\n                               copy rand_ident,\n-                              ~[ build::duplicate_expr(cx, rng[0]) ])\n+                              ~[ rng[0].duplicate(cx) ])\n     };\n \n     return match *substr.fields {\n@@ -74,40 +74,40 @@ fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n                 cx.span_fatal(span, \"`Rand` cannot be derived for enums with no variants\");\n             }\n \n-            let variant_count = build::mk_uint(cx, span, variants.len());\n+            let variant_count = cx.mk_uint(span, variants.len());\n \n             // need to specify the uint-ness of the random number\n-            let u32_ty = build::mk_ty_path(cx, span, ~[cx.ident_of(\"uint\")]);\n-            let r_ty = build::mk_ty_path(cx, span, ~[cx.ident_of(\"R\")]);\n-            let rand_name = build::mk_raw_path_(span, copy rand_ident, None, ~[ u32_ty, r_ty ]);\n-            let rand_name = build::mk_path_raw(cx, span, rand_name);\n+            let u32_ty = cx.mk_ty_path(span, ~[cx.ident_of(\"uint\")]);\n+            let r_ty = cx.mk_ty_path(span, ~[cx.ident_of(\"R\")]);\n+            let rand_name = cx.mk_raw_path_(span, copy rand_ident, None, ~[ u32_ty, r_ty ]);\n+            let rand_name = cx.mk_path_raw(span, rand_name);\n \n-            let rv_call = build::mk_call_(cx,\n+            let rv_call = cx.mk_call_(\n                                           span,\n                                           rand_name,\n-                                          ~[ build::duplicate_expr(cx, rng[0]) ]);\n+                                          ~[ rng[0].duplicate(cx) ]);\n \n             // rand() % variants.len()\n-            let rand_variant = build::mk_binary(cx, span, ast::rem,\n+            let rand_variant = cx.mk_binary(span, ast::rem,\n                                                 rv_call, variant_count);\n \n             let mut arms = do variants.mapi |i, id_sum| {\n-                let i_expr = build::mk_uint(cx, span, i);\n-                let pat = build::mk_pat_lit(cx, span, i_expr);\n+                let i_expr = cx.mk_uint(span, i);\n+                let pat = cx.mk_pat_lit(span, i_expr);\n \n                 match *id_sum {\n                     (ident, ref summary) => {\n-                        build::mk_arm(cx, span,\n+                        cx.mk_arm(span,\n                                       ~[ pat ],\n                                       rand_thing(cx, span, ident, summary, rand_call))\n                     }\n                 }\n             };\n \n             // _ => {} at the end. Should never occur\n-            arms.push(build::mk_unreachable_arm(cx, span));\n+            arms.push(cx.mk_unreachable_arm(span));\n \n-            build::mk_expr(cx, span,\n+            cx.mk_expr(span,\n                            ast::expr_match(rand_variant, arms))\n         }\n         _ => cx.bug(\"Non-static method in `deriving(Rand)`\")\n@@ -121,20 +121,20 @@ fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n         match *summary {\n             Left(copy count) => {\n                 if count == 0 {\n-                    build::mk_path(cx, span, ctor_ident)\n+                    cx.mk_path(span, ctor_ident)\n                 } else {\n                     let exprs = vec::from_fn(count, |_| rand_call());\n-                    build::mk_call(cx, span, ctor_ident, exprs)\n+                    cx.mk_call(span, ctor_ident, exprs)\n                 }\n             }\n             Right(ref fields) => {\n                 let rand_fields = do fields.map |ident| {\n-                    build::Field {\n+                    Field {\n                         ident: *ident,\n                         ex: rand_call()\n                     }\n                 };\n-                build::mk_struct_e(cx, span, ctor_ident, rand_fields)\n+                cx.mk_struct_e(span, ctor_ident, rand_fields)\n             }\n         }\n     }"}, {"sha": "9198c67177e53d5e2e8295e35b6a57a318821833", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=6e5051553050974eb9362e1465cc2d40e2c9a610", "patch": "@@ -11,7 +11,7 @@\n use ast::{meta_item, item, expr};\n use codemap::span;\n use ext::base::ExtCtxt;\n-use ext::build;\n+use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n pub fn expand_deriving_to_str(cx: @ExtCtxt,\n@@ -42,8 +42,8 @@ pub fn expand_deriving_to_str(cx: @ExtCtxt,\n fn to_str_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n     match substr.self_args {\n         [self_obj] => {\n-            let self_addr = build::mk_addr_of(cx, span, self_obj);\n-            build::mk_call_global(cx, span,\n+            let self_addr = cx.mk_addr_of(span, self_obj);\n+            cx.mk_call_global(span,\n                                   ~[cx.ident_of(\"core\"),\n                                     cx.ident_of(\"sys\"),\n                                     cx.ident_of(\"log_str\")],"}, {"sha": "a9d13bfe79c48668e1c87fed4f3fea0507d64f86", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=6e5051553050974eb9362e1465cc2d40e2c9a610", "patch": "@@ -16,7 +16,7 @@ explicit `Self` type to use when specifying impls to be derived.\n use ast;\n use ast::{expr,Generics,ident};\n use ext::base::ExtCtxt;\n-use ext::build;\n+use ext::build::AstBuilder;\n use codemap::{span,respan};\n use opt_vec;\n \n@@ -55,7 +55,7 @@ pub impl<'self> Path<'self> {\n \n     fn to_ty(&self, cx: @ExtCtxt, span: span,\n              self_ty: ident, self_generics: &Generics) -> @ast::Ty {\n-        build::mk_ty_path_path(cx, span,\n+        cx.mk_ty_path_path(span,\n                                self.to_path(cx, span,\n                                             self_ty, self_generics))\n     }\n@@ -66,9 +66,9 @@ pub impl<'self> Path<'self> {\n         let tys = self.params.map(|t| t.to_ty(cx, span, self_ty, self_generics));\n \n         if self.global {\n-            build::mk_raw_path_global_(span, idents, lt, tys)\n+            cx.mk_raw_path_global_(span, idents, lt, tys)\n         } else {\n-            build::mk_raw_path_(span, idents, lt, tys)\n+            cx.mk_raw_path_(span, idents, lt, tys)\n         }\n     }\n }\n@@ -106,7 +106,7 @@ pub fn nil_ty() -> Ty<'static> {\n \n fn mk_lifetime(cx: @ExtCtxt, span: span, lt: &Option<&str>) -> Option<@ast::Lifetime> {\n     match *lt {\n-        Some(ref s) => Some(@build::mk_lifetime(cx, span, cx.ident_of(*s))),\n+        Some(ref s) => Some(@cx.mk_lifetime(span, cx.ident_of(*s))),\n         None => None\n     }\n }\n@@ -119,20 +119,20 @@ pub impl<'self> Ty<'self> {\n                 let raw_ty = ty.to_ty(cx, span, self_ty, self_generics);\n                 match *ptr {\n                     Owned => {\n-                        build::mk_ty_uniq(cx, span, raw_ty)\n+                        cx.mk_ty_uniq(span, raw_ty)\n                     }\n                     Managed(mutbl) => {\n-                        build::mk_ty_box(cx, span, raw_ty, mutbl)\n+                        cx.mk_ty_box(span, raw_ty, mutbl)\n                     }\n                     Borrowed(ref lt, mutbl) => {\n                         let lt = mk_lifetime(cx, span, lt);\n-                        build::mk_ty_rptr(cx, span, raw_ty, lt, mutbl)\n+                        cx.mk_ty_rptr(span, raw_ty, lt, mutbl)\n                     }\n                 }\n             }\n             Literal(ref p) => { p.to_ty(cx, span, self_ty, self_generics) }\n             Self  => {\n-                build::mk_ty_path_path(cx, span, self.to_path(cx, span, self_ty, self_generics))\n+                cx.mk_ty_path_path(span, self.to_path(cx, span, self_ty, self_generics))\n             }\n             Tuple(ref fields) => {\n                 let ty = if fields.is_empty() {\n@@ -141,7 +141,7 @@ pub impl<'self> Ty<'self> {\n                     ast::ty_tup(fields.map(|f| f.to_ty(cx, span, self_ty, self_generics)))\n                 };\n \n-                build::mk_ty(cx, span, ty)\n+                cx.mk_ty(span, ty)\n             }\n         }\n     }\n@@ -151,15 +151,15 @@ pub impl<'self> Ty<'self> {\n         match *self {\n             Self => {\n                 let self_params = do self_generics.ty_params.map |ty_param| {\n-                    build::mk_ty_path(cx, span, ~[ ty_param.ident ])\n+                    cx.mk_ty_path(span, ~[ ty_param.ident ])\n                 };\n                 let lifetime = if self_generics.lifetimes.is_empty() {\n                     None\n                 } else {\n                     Some(@*self_generics.lifetimes.get(0))\n                 };\n \n-                build::mk_raw_path_(span, ~[self_ty], lifetime,\n+                cx.mk_raw_path_(span, ~[self_ty], lifetime,\n                                     opt_vec::take_vec(self_params))\n             }\n             Literal(ref p) => {\n@@ -177,9 +177,9 @@ fn mk_ty_param(cx: @ExtCtxt, span: span, name: &str, bounds: &[Path],\n     let bounds = opt_vec::from(\n         do bounds.map |b| {\n             let path = b.to_path(cx, span, self_ident, self_generics);\n-            build::mk_trait_ty_param_bound_(cx, path)\n+            cx.mk_trait_ty_param_bound_(path)\n         });\n-    build::mk_ty_param(cx, cx.ident_of(name), @bounds)\n+    cx.mk_ty_param(cx.ident_of(name), @bounds)\n }\n \n fn mk_generics(lifetimes: ~[ast::Lifetime],  ty_params: ~[ast::TyParam]) -> Generics {\n@@ -204,7 +204,7 @@ pub impl<'self> LifetimeBounds<'self> {\n     fn to_generics(&self, cx: @ExtCtxt, span: span,\n                    self_ty: ident, self_generics: &Generics) -> Generics {\n         let lifetimes = do self.lifetimes.map |lt| {\n-            build::mk_lifetime(cx, span, cx.ident_of(*lt))\n+            cx.mk_lifetime(span, cx.ident_of(*lt))\n         };\n         let ty_params = do self.bounds.map |t| {\n             match t {\n@@ -220,7 +220,7 @@ pub impl<'self> LifetimeBounds<'self> {\n \n pub fn get_explicit_self(cx: @ExtCtxt, span: span, self_ptr: &Option<PtrTy>)\n     -> (@expr, ast::explicit_self) {\n-    let self_path = build::make_self(cx, span);\n+    let self_path = cx.make_self(span);\n     match *self_ptr {\n         None => {\n             (self_path, respan(span, ast::sty_value))\n@@ -232,12 +232,12 @@ pub fn get_explicit_self(cx: @ExtCtxt, span: span, self_ptr: &Option<PtrTy>)\n                     Owned => ast::sty_uniq(ast::m_imm),\n                     Managed(mutbl) => ast::sty_box(mutbl),\n                     Borrowed(ref lt, mutbl) => {\n-                        let lt = lt.map(|s| @build::mk_lifetime(cx, span,\n+                        let lt = lt.map(|s| @cx.mk_lifetime(span,\n                                                                 cx.ident_of(*s)));\n                         ast::sty_region(lt, mutbl)\n                     }\n                 });\n-            let self_expr = build::mk_deref(cx, span, self_path);\n+            let self_expr = cx.mk_deref(span, self_path);\n             (self_expr, self_ty)\n         }\n     }"}, {"sha": "fb7367b47bafc86811e5e69fcca21137d1a72ce1", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=6e5051553050974eb9362e1465cc2d40e2c9a610", "patch": "@@ -18,7 +18,7 @@ use ast;\n use codemap::span;\n use ext::base::*;\n use ext::base;\n-use ext::build::mk_base_str;\n+use ext::build::AstBuilder;\n \n pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n@@ -29,8 +29,8 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     // Option<str> rather than just an maybe-empty string.\n \n     let e = match os::getenv(var) {\n-      None => mk_base_str(cx, sp, ~\"\"),\n-      Some(ref s) => mk_base_str(cx, sp, copy *s)\n+      None => cx.mk_base_str(sp, ~\"\"),\n+      Some(ref s) => cx.mk_base_str(sp, copy *s)\n     };\n     MRExpr(e)\n }"}, {"sha": "1e4ff03b610c81cf6f36c0a4e0452ad024f6fa5e", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=6e5051553050974eb9362e1465cc2d40e2c9a610", "patch": "@@ -19,7 +19,7 @@ use codemap::span;\n use ext::base::*;\n use ext::base;\n use ext::build;\n-use ext::build::*;\n+use ext::build::AstBuilder;\n \n use core::unstable::extfmt::ct::*;\n \n@@ -56,7 +56,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n     }\n     fn make_rt_path_expr(cx: @ExtCtxt, sp: span, nm: &str) -> @ast::expr {\n         let path = make_path_vec(cx, nm);\n-        return mk_path_global(cx, sp, path);\n+        cx.mk_path_global(sp, path)\n     }\n     // Produces an AST expression that represents a RT::conv record,\n     // which tells the RT::conv* functions how to perform the conversion\n@@ -72,7 +72,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n                   FlagSignAlways => \"flag_sign_always\",\n                   FlagAlternate => \"flag_alternate\"\n                 };\n-                tmp_expr = mk_binary(cx, sp, ast::bitor, tmp_expr,\n+                tmp_expr = cx.mk_binary(sp, ast::bitor, tmp_expr,\n                                      make_rt_path_expr(cx, sp, fstr));\n             }\n             return tmp_expr;\n@@ -83,10 +83,10 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n                 return make_rt_path_expr(cx, sp, \"CountImplied\");\n               }\n               CountIs(c) => {\n-                let count_lit = mk_uint(cx, sp, c as uint);\n+                let count_lit = cx.mk_uint(sp, c as uint);\n                 let count_is_path = make_path_vec(cx, \"CountIs\");\n                 let count_is_args = ~[count_lit];\n-                return mk_call_global(cx, sp, count_is_path, count_is_args);\n+                return cx.mk_call_global(sp, count_is_path, count_is_args);\n               }\n               _ => cx.span_unimpl(sp, \"unimplemented fmt! conversion\")\n             }\n@@ -107,8 +107,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n                          width_expr: @ast::expr, precision_expr: @ast::expr,\n                          ty_expr: @ast::expr) -> @ast::expr {\n             let intr = cx.parse_sess().interner;\n-            mk_global_struct_e(\n-                cx,\n+            cx.mk_global_struct_e(\n                 sp,\n                 make_path_vec(cx, \"Conv\"),\n                 ~[\n@@ -140,7 +139,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n         let path = make_path_vec(cx, fname);\n         let cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n         let args = ~[cnv_expr, arg, buf];\n-        return mk_call_global(cx, arg.span, path, args);\n+        cx.mk_call_global(arg.span, path, args)\n     }\n \n     fn make_new_conv(cx: @ExtCtxt, sp: span, cnv: &Conv,\n@@ -198,10 +197,10 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n             TyChar => (\"char\", arg),\n             TyBits | TyOctal | TyHex(_) | TyInt(Unsigned) => (\"uint\", arg),\n             TyFloat => (\"float\", arg),\n-            TyPoly => (\"poly\", mk_addr_of(cx, sp, arg))\n+            TyPoly => (\"poly\", cx.mk_addr_of(sp, arg))\n         };\n         return make_conv_call(cx, arg.span, name, cnv, actual_arg,\n-                              mk_mut_addr_of(cx, arg.span, buf));\n+                              cx.mk_mut_addr_of(arg.span, buf));\n     }\n     fn log_conv(c: &Conv) {\n         debug!(\"Building conversion:\");\n@@ -259,7 +258,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n \n     /* 'ident' is the local buffer building up the result of fmt! */\n     let ident = cx.parse_sess().interner.intern(\"__fmtbuf\");\n-    let buf = || mk_path(cx, fmt_sp, ~[ident]);\n+    let buf = || cx.mk_path(fmt_sp, ~[ident]);\n     let str_ident = cx.parse_sess().interner.intern(\"str\");\n     let push_ident = cx.parse_sess().interner.intern(\"push_str\");\n     let mut stms = ~[];\n@@ -276,14 +275,14 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n                    buffer with it directly. If it's actually the only piece,\n                    then there's no need for it to be mutable */\n                 if i == 0 {\n-                    stms.push(mk_local(cx, fmt_sp, npieces > 1, ident, mk_uniq_str(cx, fmt_sp, s)));\n+                    stms.push(cx.mk_local(fmt_sp, npieces > 1, ident, cx.mk_uniq_str(fmt_sp, s)));\n                 } else {\n-                    let args = ~[mk_mut_addr_of(cx, fmt_sp, buf()), mk_base_str(cx, fmt_sp, s)];\n-                    let call = mk_call_global(cx,\n+                    let args = ~[cx.mk_mut_addr_of(fmt_sp, buf()), cx.mk_base_str(fmt_sp, s)];\n+                    let call = cx.mk_call_global(\n                                               fmt_sp,\n                                               ~[str_ident, push_ident],\n                                               args);\n-                    stms.push(mk_stmt(cx, fmt_sp, call));\n+                    stms.push(cx.mk_stmt(fmt_sp, call));\n                 }\n             }\n \n@@ -300,12 +299,12 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n                 /* If the first portion is a conversion, then the local buffer\n                    must be initialized as an empty string */\n                 if i == 0 {\n-                    stms.push(mk_local(cx, fmt_sp, true, ident,\n-                                       mk_uniq_str(cx, fmt_sp, ~\"\")));\n+                    stms.push(cx.mk_local(fmt_sp, true, ident,\n+                                          cx.mk_uniq_str(fmt_sp, ~\"\")));\n                 }\n-                stms.push(mk_stmt(cx, fmt_sp,\n-                                  make_new_conv(cx, fmt_sp, conv,\n-                                                args[n], buf())));\n+                stms.push(cx.mk_stmt(fmt_sp,\n+                                     make_new_conv(cx, fmt_sp, conv,\n+                                                   args[n], buf())));\n             }\n         }\n     }\n@@ -317,5 +316,5 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n                            nargs, expected_nargs));\n     }\n \n-    return mk_block(cx, fmt_sp, ~[], stms, Some(buf()));\n+    cx.mk_block(fmt_sp, ~[], stms, Some(buf()))\n }"}, {"sha": "5ab28b50e841cbec5e2a934399329eef4a98422a", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=6e5051553050974eb9362e1465cc2d40e2c9a610", "patch": "@@ -12,7 +12,7 @@ use ast;\n use codemap::{BytePos, Pos, span};\n use ext::base::ExtCtxt;\n use ext::base;\n-use ext::build;\n+use ext::build::AstBuilder;\n use parse::token::*;\n use parse::token;\n use parse;\n@@ -382,31 +382,31 @@ pub fn expand_quote_expr(cx: @ExtCtxt,\n pub fn expand_quote_item(cx: @ExtCtxt,\n                          sp: span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n-    let e_attrs = build::mk_uniq_vec_e(cx, sp, ~[]);\n+    let e_attrs = cx.mk_uniq_vec_e(sp, ~[]);\n     base::MRExpr(expand_parse_call(cx, sp, \"parse_item\",\n                                     ~[e_attrs], tts))\n }\n \n pub fn expand_quote_pat(cx: @ExtCtxt,\n                         sp: span,\n                         tts: &[ast::token_tree]) -> base::MacResult {\n-    let e_refutable = build::mk_lit(cx, sp, ast::lit_bool(true));\n+    let e_refutable = cx.mk_lit(sp, ast::lit_bool(true));\n     base::MRExpr(expand_parse_call(cx, sp, \"parse_pat\",\n                                     ~[e_refutable], tts))\n }\n \n pub fn expand_quote_ty(cx: @ExtCtxt,\n                        sp: span,\n                        tts: &[ast::token_tree]) -> base::MacResult {\n-    let e_param_colons = build::mk_lit(cx, sp, ast::lit_bool(false));\n+    let e_param_colons = cx.mk_lit(sp, ast::lit_bool(false));\n     base::MRExpr(expand_parse_call(cx, sp, \"parse_ty\",\n                                     ~[e_param_colons], tts))\n }\n \n pub fn expand_quote_stmt(cx: @ExtCtxt,\n                          sp: span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n-    let e_attrs = build::mk_uniq_vec_e(cx, sp, ~[]);\n+    let e_attrs = cx.mk_uniq_vec_e(sp, ~[]);\n     base::MRExpr(expand_parse_call(cx, sp, \"parse_stmt\",\n                                     ~[e_attrs], tts))\n }\n@@ -421,17 +421,17 @@ fn id_ext(cx: @ExtCtxt, str: &str) -> ast::ident {\n \n // Lift an ident to the expr that evaluates to that ident.\n fn mk_ident(cx: @ExtCtxt, sp: span, ident: ast::ident) -> @ast::expr {\n-    let e_str = build::mk_base_str(cx, sp, cx.str_of(ident));\n-    build::mk_method_call(cx, sp,\n-                          build::mk_path(cx, sp, ids_ext(cx, ~[~\"ext_cx\"])),\n-                          id_ext(cx, \"ident_of\"),\n-                          ~[e_str])\n+    let e_str = cx.mk_base_str(sp, cx.str_of(ident));\n+    cx.mk_method_call(sp,\n+                      cx.mk_path(sp, ids_ext(cx, ~[~\"ext_cx\"])),\n+                      id_ext(cx, \"ident_of\"),\n+                      ~[e_str])\n }\n \n fn mk_bytepos(cx: @ExtCtxt, sp: span, bpos: BytePos) -> @ast::expr {\n     let path = ids_ext(cx, ~[~\"BytePos\"]);\n-    let arg = build::mk_uint(cx, sp, bpos.to_uint());\n-    build::mk_call(cx, sp, path, ~[arg])\n+    let arg = cx.mk_uint(sp, bpos.to_uint());\n+    cx.mk_call(sp, path, ~[arg])\n }\n \n fn mk_binop(cx: @ExtCtxt, sp: span, bop: token::binop) -> @ast::expr {\n@@ -447,20 +447,20 @@ fn mk_binop(cx: @ExtCtxt, sp: span, bop: token::binop) -> @ast::expr {\n         SHL => \"SHL\",\n         SHR => \"SHR\"\n     };\n-    build::mk_path(cx, sp,\n+    cx.mk_path(sp,\n                    ids_ext(cx, ~[name.to_owned()]))\n }\n \n fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n \n     match *tok {\n         BINOP(binop) => {\n-            return build::mk_call(cx, sp,\n+            return cx.mk_call(sp,\n                                   ids_ext(cx, ~[~\"BINOP\"]),\n                                   ~[mk_binop(cx, sp, binop)]);\n         }\n         BINOPEQ(binop) => {\n-            return build::mk_call(cx, sp,\n+            return cx.mk_call(sp,\n                                   ids_ext(cx, ~[~\"BINOPEQ\"]),\n                                   ~[mk_binop(cx, sp, binop)]);\n         }\n@@ -475,12 +475,12 @@ fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n                 ast::ty_i64 => ~\"ty_i64\"\n             };\n             let e_ity =\n-                build::mk_path(cx, sp,\n+                cx.mk_path(sp,\n                                ids_ext(cx, ~[s_ity]));\n \n-            let e_i64 = build::mk_lit(cx, sp, ast::lit_int(i, ast::ty_i64));\n+            let e_i64 = cx.mk_lit(sp, ast::lit_int(i, ast::ty_i64));\n \n-            return build::mk_call(cx, sp,\n+            return cx.mk_call(sp,\n                                   ids_ext(cx, ~[~\"LIT_INT\"]),\n                                   ~[e_i64, e_ity]);\n         }\n@@ -494,21 +494,21 @@ fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n                 ast::ty_u64 => ~\"ty_u64\"\n             };\n             let e_uty =\n-                build::mk_path(cx, sp,\n+                cx.mk_path(sp,\n                                ids_ext(cx, ~[s_uty]));\n \n-            let e_u64 = build::mk_lit(cx, sp, ast::lit_uint(u, ast::ty_u64));\n+            let e_u64 = cx.mk_lit(sp, ast::lit_uint(u, ast::ty_u64));\n \n-            return build::mk_call(cx, sp,\n+            return cx.mk_call(sp,\n                                   ids_ext(cx, ~[~\"LIT_UINT\"]),\n                                   ~[e_u64, e_uty]);\n         }\n \n         LIT_INT_UNSUFFIXED(i) => {\n-            let e_i64 = build::mk_lit(cx, sp,\n+            let e_i64 = cx.mk_lit(sp,\n                                       ast::lit_int(i, ast::ty_i64));\n \n-            return build::mk_call(cx, sp,\n+            return cx.mk_call(sp,\n                                   ids_ext(cx, ~[~\"LIT_INT_UNSUFFIXED\"]),\n                                   ~[e_i64]);\n         }\n@@ -520,37 +520,37 @@ fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n                 ast::ty_f64 => ~\"ty_f64\"\n             };\n             let e_fty =\n-                build::mk_path(cx, sp,\n+                cx.mk_path(sp,\n                                ids_ext(cx, ~[s_fty]));\n \n             let e_fident = mk_ident(cx, sp, fident);\n \n-            return build::mk_call(cx, sp,\n+            return cx.mk_call(sp,\n                                   ids_ext(cx, ~[~\"LIT_FLOAT\"]),\n                                   ~[e_fident, e_fty]);\n         }\n \n         LIT_STR(ident) => {\n-            return build::mk_call(cx, sp,\n+            return cx.mk_call(sp,\n                                   ids_ext(cx, ~[~\"LIT_STR\"]),\n                                   ~[mk_ident(cx, sp, ident)]);\n         }\n \n         IDENT(ident, b) => {\n-            return build::mk_call(cx, sp,\n+            return cx.mk_call(sp,\n                                   ids_ext(cx, ~[~\"IDENT\"]),\n                                   ~[mk_ident(cx, sp, ident),\n-                                    build::mk_lit(cx, sp, ast::lit_bool(b))]);\n+                                    cx.mk_lit(sp, ast::lit_bool(b))]);\n         }\n \n         LIFETIME(ident) => {\n-            return build::mk_call(cx, sp,\n+            return cx.mk_call(sp,\n                                   ids_ext(cx, ~[~\"LIFETIME\"]),\n                                   ~[mk_ident(cx, sp, ident)]);\n         }\n \n         DOC_COMMENT(ident) => {\n-            return build::mk_call(cx, sp,\n+            return cx.mk_call(sp,\n                                   ids_ext(cx, ~[~\"DOC_COMMENT\"]),\n                                   ~[mk_ident(cx, sp, ident)]);\n         }\n@@ -595,7 +595,7 @@ fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n         EOF => \"EOF\",\n         _ => fail!()\n     };\n-    build::mk_path(cx, sp,\n+    cx.mk_path(sp,\n                    ids_ext(cx, ~[name.to_owned()]))\n }\n \n@@ -606,18 +606,18 @@ fn mk_tt(cx: @ExtCtxt, sp: span, tt: &ast::token_tree)\n     match *tt {\n \n         ast::tt_tok(sp, ref tok) => {\n-            let e_sp = build::mk_path(cx, sp,\n+            let e_sp = cx.mk_path(sp,\n                                       ids_ext(cx, ~[~\"sp\"]));\n             let e_tok =\n-                build::mk_call(cx, sp,\n+                cx.mk_call(sp,\n                                ids_ext(cx, ~[~\"tt_tok\"]),\n                                ~[e_sp, mk_token(cx, sp, tok)]);\n             let e_push =\n-                build::mk_method_call(cx, sp,\n-                                      build::mk_path(cx, sp, ids_ext(cx, ~[~\"tt\"])),\n+                cx.mk_method_call(sp,\n+                                      cx.mk_path(sp, ids_ext(cx, ~[~\"tt\"])),\n                                       id_ext(cx, \"push\"),\n                                       ~[e_tok]);\n-            ~[build::mk_stmt(cx, sp, e_push)]\n+            ~[cx.mk_stmt(sp, e_push)]\n \n         }\n \n@@ -629,19 +629,19 @@ fn mk_tt(cx: @ExtCtxt, sp: span, tt: &ast::token_tree)\n             // tt.push_all_move($ident.to_tokens(ext_cx))\n \n             let e_to_toks =\n-                build::mk_method_call(cx, sp,\n-                                      build::mk_path(cx, sp, ~[ident]),\n+                cx.mk_method_call(sp,\n+                                      cx.mk_path(sp, ~[ident]),\n                                       id_ext(cx, \"to_tokens\"),\n-                                      ~[build::mk_path(cx, sp,\n+                                      ~[cx.mk_path(sp,\n                                                        ids_ext(cx, ~[~\"ext_cx\"]))]);\n \n             let e_push =\n-                build::mk_method_call(cx, sp,\n-                                      build::mk_path(cx, sp, ids_ext(cx, ~[~\"tt\"])),\n+                cx.mk_method_call(sp,\n+                                      cx.mk_path(sp, ids_ext(cx, ~[~\"tt\"])),\n                                       id_ext(cx, \"push_all_move\"),\n                                       ~[e_to_toks]);\n \n-            ~[build::mk_stmt(cx, sp, e_push)]\n+            ~[cx.mk_stmt(sp, e_push)]\n         }\n     }\n }\n@@ -677,11 +677,11 @@ fn expand_tts(cx: @ExtCtxt,\n     // We want to emit a block expression that does a sequence of 'use's to\n     // import the runtime module, followed by a tt-building expression.\n \n-    let uses = ~[ build::mk_glob_use(cx, sp, ast::public,\n-                                     ids_ext(cx, ~[~\"syntax\",\n-                                                   ~\"ext\",\n-                                                   ~\"quote\",\n-                                                   ~\"rt\"])) ];\n+    let uses = ~[ cx.mk_glob_use(sp, ast::public,\n+                                 ids_ext(cx, ~[~\"syntax\",\n+                                               ~\"ext\",\n+                                               ~\"quote\",\n+                                               ~\"rt\"])) ];\n \n     // We also bind a single value, sp, to ext_cx.call_site()\n     //\n@@ -709,23 +709,23 @@ fn expand_tts(cx: @ExtCtxt,\n     // of quotes, for example) but at this point it seems not likely to be\n     // worth the hassle.\n \n-    let e_sp = build::mk_method_call(cx, sp,\n-                                     build::mk_path(cx, sp, ids_ext(cx, ~[~\"ext_cx\"])),\n+    let e_sp = cx.mk_method_call(sp,\n+                                     cx.mk_path(sp, ids_ext(cx, ~[~\"ext_cx\"])),\n                                      id_ext(cx, \"call_site\"),\n                                      ~[]);\n \n-    let stmt_let_sp = build::mk_local(cx, sp, false,\n+    let stmt_let_sp = cx.mk_local(sp, false,\n                                       id_ext(cx, \"sp\"),\n                                       e_sp);\n \n-    let stmt_let_tt = build::mk_local(cx, sp, true,\n+    let stmt_let_tt = cx.mk_local(sp, true,\n                                       id_ext(cx, \"tt\"),\n-                                      build::mk_uniq_vec_e(cx, sp, ~[]));\n+                                      cx.mk_uniq_vec_e(sp, ~[]));\n \n-    build::mk_block(cx, sp, uses,\n+    cx.mk_block(sp, uses,\n                     ~[stmt_let_sp,\n                       stmt_let_tt] + mk_tts(cx, sp, tts),\n-                    Some(build::mk_path(cx, sp,\n+                    Some(cx.mk_path(sp,\n                                         ids_ext(cx, ~[~\"tt\"]))))\n }\n \n@@ -736,16 +736,16 @@ fn expand_parse_call(cx: @ExtCtxt,\n                      tts: &[ast::token_tree]) -> @ast::expr {\n     let tts_expr = expand_tts(cx, sp, tts);\n \n-    let cfg_call = || build::mk_method_call(\n-        cx, sp, build::mk_path(cx, sp, ids_ext(cx, ~[~\"ext_cx\"])),\n+    let cfg_call = || cx.mk_method_call(\n+        sp, cx.mk_path(sp, ids_ext(cx, ~[~\"ext_cx\"])),\n         id_ext(cx, \"cfg\"), ~[]);\n \n-    let parse_sess_call = || build::mk_method_call(\n-        cx, sp, build::mk_path(cx, sp, ids_ext(cx, ~[~\"ext_cx\"])),\n+    let parse_sess_call = || cx.mk_method_call(\n+        sp, cx.mk_path(sp, ids_ext(cx, ~[~\"ext_cx\"])),\n         id_ext(cx, \"parse_sess\"), ~[]);\n \n     let new_parser_call =\n-        build::mk_call_global(cx, sp,\n+        cx.mk_call_global(sp,\n                               ids_ext(cx, ~[~\"syntax\",\n                                             ~\"ext\",\n                                             ~\"quote\",\n@@ -755,7 +755,7 @@ fn expand_parse_call(cx: @ExtCtxt,\n                                 cfg_call(),\n                                 tts_expr]);\n \n-    build::mk_method_call(cx, sp,\n+    cx.mk_method_call(sp,\n                           new_parser_call,\n                           id_ext(cx, parse_method),\n                           arg_exprs)"}, {"sha": "40dc44ca99326c5a1fe89165b544a030fe8cc80d", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5051553050974eb9362e1465cc2d40e2c9a610/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=6e5051553050974eb9362e1465cc2d40e2c9a610", "patch": "@@ -14,7 +14,7 @@ use codemap::{FileMap, Loc, Pos, ExpandedFrom, span};\n use codemap::{CallInfo, NameAndSpan};\n use ext::base::*;\n use ext::base;\n-use ext::build::{mk_base_vec_e, mk_uint, mk_u8, mk_base_str};\n+use ext::build::AstBuilder;\n use parse;\n use print::pprust;\n \n@@ -30,7 +30,7 @@ pub fn expand_line(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     let topmost = topmost_expn_info(cx.backtrace().get());\n     let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n \n-    base::MRExpr(mk_uint(cx, topmost.call_site, loc.line))\n+    base::MRExpr(cx.mk_uint(topmost.call_site, loc.line))\n }\n \n /* col!(): expands to the current column number */\n@@ -40,7 +40,7 @@ pub fn expand_col(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n \n     let topmost = topmost_expn_info(cx.backtrace().get());\n     let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n-    base::MRExpr(mk_uint(cx, topmost.call_site, loc.col.to_uint()))\n+    base::MRExpr(cx.mk_uint(topmost.call_site, loc.col.to_uint()))\n }\n \n /* file!(): expands to the current filename */\n@@ -53,19 +53,19 @@ pub fn expand_file(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     let topmost = topmost_expn_info(cx.backtrace().get());\n     let Loc { file: @FileMap { name: filename, _ }, _ } =\n         cx.codemap().lookup_char_pos(topmost.call_site.lo);\n-    base::MRExpr(mk_base_str(cx, topmost.call_site, filename))\n+    base::MRExpr(cx.mk_base_str(topmost.call_site, filename))\n }\n \n pub fn expand_stringify(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let s = pprust::tts_to_str(tts, cx.parse_sess().interner);\n-    base::MRExpr(mk_base_str(cx, sp, s))\n+    base::MRExpr(cx.mk_base_str(sp, s))\n }\n \n pub fn expand_mod(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n-    base::MRExpr(mk_base_str(cx, sp,\n+    base::MRExpr(cx.mk_base_str(sp,\n                               str::connect(cx.mod_path().map(\n                                   |x| cx.str_of(*x)), \"::\")))\n }\n@@ -94,7 +94,7 @@ pub fn expand_include_str(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n       }\n     }\n \n-    base::MRExpr(mk_base_str(cx, sp, result::unwrap(res)))\n+    base::MRExpr(cx.mk_base_str(sp, result::unwrap(res)))\n }\n \n pub fn expand_include_bin(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n@@ -103,9 +103,9 @@ pub fn expand_include_bin(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     match io::read_whole_file(&res_rel_file(cx, sp, &Path(file))) {\n       result::Ok(src) => {\n         let u8_exprs = vec::map(src, |char| {\n-            mk_u8(cx, sp, *char)\n+            cx.mk_u8(sp, *char)\n         });\n-        base::MRExpr(mk_base_vec_e(cx, sp, u8_exprs))\n+        base::MRExpr(cx.mk_base_vec_e(sp, u8_exprs))\n       }\n       result::Err(ref e) => {\n         cx.parse_sess().span_diagnostic.handler().fatal((*e))"}]}