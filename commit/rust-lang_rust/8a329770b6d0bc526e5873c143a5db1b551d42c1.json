{"sha": "8a329770b6d0bc526e5873c143a5db1b551d42c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhMzI5NzcwYjZkMGJjNTI2ZTU4NzNjMTQzYTVkYjFiNTUxZDQyYzE=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-07-27T08:25:59Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-07-29T14:16:48Z"}, "message": "New naming convention for ast::{node_id, local_crate, crate_node_id, blk_check_mode, ty_field, ty_method}", "tree": {"sha": "8536d97806e765d2483cd5cf30ed9c506a13f1b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8536d97806e765d2483cd5cf30ed9c506a13f1b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a329770b6d0bc526e5873c143a5db1b551d42c1", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a329770b6d0bc526e5873c143a5db1b551d42c1", "html_url": "https://github.com/rust-lang/rust/commit/8a329770b6d0bc526e5873c143a5db1b551d42c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a329770b6d0bc526e5873c143a5db1b551d42c1/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27812ea5e025ed36dc80379b86bb249b33c528a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/27812ea5e025ed36dc80379b86bb249b33c528a2", "html_url": "https://github.com/rust-lang/rust/commit/27812ea5e025ed36dc80379b86bb249b33c528a2"}], "stats": {"total": 1431, "additions": 713, "deletions": 718}, "files": [{"sha": "3a315ef952d70fffcde94261a187e582886c883b", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -201,7 +201,7 @@ pub struct CrateAnalysis {\n     exp_map2: middle::resolve::ExportMap2,\n     ty_cx: ty::ctxt,\n     maps: astencode::Maps,\n-    reachable: @mut HashSet<ast::node_id>\n+    reachable: @mut HashSet<ast::NodeId>\n }\n \n /// Run the resolution, typechecking, region checking and other"}, {"sha": "e43f85008d5c365d9803c0f64a25ce29c3535e85", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -18,7 +18,7 @@ use metadata::filesearch;\n use metadata;\n use middle::lint;\n \n-use syntax::ast::node_id;\n+use syntax::ast::NodeId;\n use syntax::ast::{int_ty, uint_ty, float_ty};\n use syntax::codemap::span;\n use syntax::diagnostic;\n@@ -189,13 +189,13 @@ pub struct Session_ {\n     parse_sess: @mut ParseSess,\n     codemap: @codemap::CodeMap,\n     // For a library crate, this is always none\n-    entry_fn: @mut Option<(node_id, codemap::span)>,\n+    entry_fn: @mut Option<(NodeId, codemap::span)>,\n     entry_type: @mut Option<EntryFnType>,\n     span_diagnostic: @diagnostic::span_handler,\n     filesearch: @filesearch::FileSearch,\n     building_library: @mut bool,\n     working_dir: Path,\n-    lints: @mut HashMap<ast::node_id, ~[(lint::lint, codemap::span, ~str)]>,\n+    lints: @mut HashMap<ast::NodeId, ~[(lint::lint, codemap::span, ~str)]>,\n }\n \n pub type Session = @Session_;\n@@ -248,7 +248,7 @@ impl Session_ {\n     }\n     pub fn add_lint(@self,\n                     lint: lint::lint,\n-                    id: ast::node_id,\n+                    id: ast::NodeId,\n                     sp: span,\n                     msg: ~str) {\n         match self.lints.find_mut(&id) {\n@@ -257,7 +257,7 @@ impl Session_ {\n         }\n         self.lints.insert(id, ~[(lint, sp, msg)]);\n     }\n-    pub fn next_node_id(@self) -> ast::node_id {\n+    pub fn next_node_id(@self) -> ast::NodeId {\n         return syntax::parse::next_node_id(self.parse_sess);\n     }\n     pub fn diagnostic(@self) -> @diagnostic::span_handler {"}, {"sha": "8694c10053c02f3d82c947ae87e3c39df925725f", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -25,7 +25,7 @@ use syntax::print::pprust;\n use syntax::{ast, ast_util};\n use syntax::attr::AttrMetaMethods;\n \n-type node_id_gen = @fn() -> ast::node_id;\n+type node_id_gen = @fn() -> ast::NodeId;\n \n struct Test {\n     span: span,"}, {"sha": "317b9cf6ce34f7c82abe9594403f448905d1ce1f", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -44,7 +44,7 @@ pub fn get_type_param_count(cstore: @mut cstore::CStore, def: ast::def_id)\n /// Iterates over all the language items in the given crate.\n pub fn each_lang_item(cstore: @mut cstore::CStore,\n                       cnum: ast::CrateNum,\n-                      f: &fn(ast::node_id, uint) -> bool) -> bool {\n+                      f: &fn(ast::NodeId, uint) -> bool) -> bool {\n     let crate_data = cstore::get_crate_data(cstore, cnum);\n     decoder::each_lang_item(crate_data, f)\n }"}, {"sha": "bc4236d33956e8e994a500e6e1e0870d3079ed91", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -43,8 +43,8 @@ pub struct CStore {\n     intr: @ident_interner\n }\n \n-// Map from node_id's of local extern mod statements to crate numbers\n-type extern_mod_crate_map = HashMap<ast::node_id, ast::CrateNum>;\n+// Map from NodeId's of local extern mod statements to crate numbers\n+type extern_mod_crate_map = HashMap<ast::NodeId, ast::CrateNum>;\n \n pub fn mk_cstore(intr: @ident_interner) -> CStore {\n     return CStore {\n@@ -125,13 +125,13 @@ pub fn get_used_link_args<'a>(cstore: &'a CStore) -> &'a [@str] {\n }\n \n pub fn add_extern_mod_stmt_cnum(cstore: &mut CStore,\n-                                emod_id: ast::node_id,\n+                                emod_id: ast::NodeId,\n                                 cnum: ast::CrateNum) {\n     cstore.extern_mod_crate_map.insert(emod_id, cnum);\n }\n \n pub fn find_extern_mod_stmt_cnum(cstore: &CStore,\n-                                 emod_id: ast::node_id)\n+                                 emod_id: ast::NodeId)\n                        -> Option<ast::CrateNum> {\n     cstore.extern_mod_crate_map.find(&emod_id).map_consume(|x| *x)\n }"}, {"sha": "3a8b9a27f1cac8aba0fef868d01eff8eb15edf92", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -361,7 +361,7 @@ pub fn lookup_def(cnum: ast::CrateNum, data: @~[u8], did_: ast::def_id) ->\n }\n \n pub fn get_trait_def(cdata: cmd,\n-                     item_id: ast::node_id,\n+                     item_id: ast::NodeId,\n                      tcx: ty::ctxt) -> ty::TraitDef\n {\n     let item_doc = lookup_item(item_id, cdata.data);\n@@ -375,7 +375,7 @@ pub fn get_trait_def(cdata: cmd,\n     }\n }\n \n-pub fn get_type(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n+pub fn get_type(cdata: cmd, id: ast::NodeId, tcx: ty::ctxt)\n     -> ty::ty_param_bounds_and_ty {\n \n     let item = lookup_item(id, cdata.data);\n@@ -392,19 +392,19 @@ pub fn get_type(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     }\n }\n \n-pub fn get_region_param(cdata: cmd, id: ast::node_id)\n+pub fn get_region_param(cdata: cmd, id: ast::NodeId)\n     -> Option<ty::region_variance> {\n \n     let item = lookup_item(id, cdata.data);\n     return item_ty_region_param(item);\n }\n \n-pub fn get_type_param_count(data: @~[u8], id: ast::node_id) -> uint {\n+pub fn get_type_param_count(data: @~[u8], id: ast::NodeId) -> uint {\n     item_ty_param_count(lookup_item(id, data))\n }\n \n pub fn get_impl_trait(cdata: cmd,\n-                       id: ast::node_id,\n+                       id: ast::NodeId,\n                        tcx: ty::ctxt) -> Option<@ty::TraitRef>\n {\n     let item_doc = lookup_item(id, cdata.data);\n@@ -414,7 +414,7 @@ pub fn get_impl_trait(cdata: cmd,\n }\n \n pub fn get_impl_vtables(cdata: cmd,\n-                        id: ast::node_id,\n+                        id: ast::NodeId,\n                         tcx: ty::ctxt) -> typeck::impl_res\n {\n     let item_doc = lookup_item(id, cdata.data);\n@@ -428,7 +428,7 @@ pub fn get_impl_vtables(cdata: cmd,\n }\n \n \n-pub fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n+pub fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n                        name: ast::ident) -> Option<ast::def_id> {\n     let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n     let mut found = None;\n@@ -442,7 +442,7 @@ pub fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     found\n }\n \n-pub fn get_symbol(data: @~[u8], id: ast::node_id) -> ~str {\n+pub fn get_symbol(data: @~[u8], id: ast::NodeId) -> ~str {\n     return item_symbol(lookup_item(id, data));\n }\n \n@@ -462,15 +462,15 @@ fn def_like_to_def(def_like: def_like) -> ast::def {\n }\n \n /// Iterates over the language items in the given crate.\n-pub fn each_lang_item(cdata: cmd, f: &fn(ast::node_id, uint) -> bool) -> bool {\n+pub fn each_lang_item(cdata: cmd, f: &fn(ast::NodeId, uint) -> bool) -> bool {\n     let root = reader::Doc(cdata.data);\n     let lang_items = reader::get_doc(root, tag_lang_items);\n     for reader::tagged_docs(lang_items, tag_lang_items_item) |item_doc| {\n         let id_doc = reader::get_doc(item_doc, tag_lang_items_item_id);\n         let id = reader::doc_as_u32(id_doc) as uint;\n         let node_id_doc = reader::get_doc(item_doc,\n                                           tag_lang_items_item_node_id);\n-        let node_id = reader::doc_as_u32(node_id_doc) as ast::node_id;\n+        let node_id = reader::doc_as_u32(node_id_doc) as ast::NodeId;\n \n         if !f(node_id, id) {\n             return false;\n@@ -716,7 +716,7 @@ pub fn each_path(intr: @ident_interner,\n     context.each_child_of_module_or_crate(crate_items_doc)\n }\n \n-pub fn get_item_path(cdata: cmd, id: ast::node_id) -> ast_map::path {\n+pub fn get_item_path(cdata: cmd, id: ast::NodeId) -> ast_map::path {\n     item_path(lookup_item(id, cdata.data))\n }\n \n@@ -727,7 +727,7 @@ pub type decode_inlined_item<'self> = &'self fn(\n     par_doc: ebml::Doc) -> Option<ast::inlined_item>;\n \n pub fn maybe_get_item_ast(cdata: cmd, tcx: ty::ctxt,\n-                          id: ast::node_id,\n+                          id: ast::NodeId,\n                           decode_inlined_item: decode_inlined_item)\n                        -> csearch::found_ast {\n     debug!(\"Looking up item: %d\", id);\n@@ -754,7 +754,7 @@ pub fn maybe_get_item_ast(cdata: cmd, tcx: ty::ctxt,\n     }\n }\n \n-pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n+pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n                      tcx: ty::ctxt) -> ~[@ty::VariantInfo] {\n     let data = cdata.data;\n     let items = reader::get_doc(reader::Doc(data), tag_items);\n@@ -833,7 +833,7 @@ fn item_impl_methods(intr: @ident_interner, cdata: cmd, item: ebml::Doc,\n }\n \n /// Returns information about the given implementation.\n-pub fn get_impl(intr: @ident_interner, cdata: cmd, impl_id: ast::node_id,\n+pub fn get_impl(intr: @ident_interner, cdata: cmd, impl_id: ast::NodeId,\n                tcx: ty::ctxt)\n                 -> ty::Impl {\n     let data = cdata.data;\n@@ -851,15 +851,15 @@ pub fn get_impl(intr: @ident_interner, cdata: cmd, impl_id: ast::node_id,\n pub fn get_method_name_and_explicit_self(\n     intr: @ident_interner,\n     cdata: cmd,\n-    id: ast::node_id) -> (ast::ident, ast::explicit_self_)\n+    id: ast::NodeId) -> (ast::ident, ast::explicit_self_)\n {\n     let method_doc = lookup_item(id, cdata.data);\n     let name = item_name(intr, method_doc);\n     let explicit_self = get_explicit_self(method_doc);\n     (name, explicit_self)\n }\n \n-pub fn get_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n+pub fn get_method(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n                   tcx: ty::ctxt) -> ty::Method\n {\n     let method_doc = lookup_item(id, cdata.data);\n@@ -892,7 +892,7 @@ pub fn get_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n }\n \n pub fn get_trait_method_def_ids(cdata: cmd,\n-                                id: ast::node_id) -> ~[ast::def_id] {\n+                                id: ast::NodeId) -> ~[ast::def_id] {\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n@@ -903,7 +903,7 @@ pub fn get_trait_method_def_ids(cdata: cmd,\n }\n \n pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n-                                  id: ast::node_id, tcx: ty::ctxt) ->\n+                                  id: ast::NodeId, tcx: ty::ctxt) ->\n         ~[@ty::Method] {\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n@@ -922,7 +922,7 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n }\n \n /// Returns the supertraits of the given trait.\n-pub fn get_supertraits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n+pub fn get_supertraits(cdata: cmd, id: ast::NodeId, tcx: ty::ctxt)\n                     -> ~[@ty::TraitRef] {\n     let mut results = ~[];\n     let item_doc = lookup_item(id, cdata.data);\n@@ -933,7 +933,7 @@ pub fn get_supertraits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n }\n \n pub fn get_type_name_if_impl(cdata: cmd,\n-                             node_id: ast::node_id) -> Option<ast::ident> {\n+                             node_id: ast::NodeId) -> Option<ast::ident> {\n     let item = lookup_item(node_id, cdata.data);\n     if item_family(item) != Impl {\n         return None;\n@@ -948,7 +948,7 @@ pub fn get_type_name_if_impl(cdata: cmd,\n \n pub fn get_static_methods_if_impl(intr: @ident_interner,\n                                   cdata: cmd,\n-                                  node_id: ast::node_id)\n+                                  node_id: ast::NodeId)\n                                -> Option<~[StaticMethodInfo]> {\n     let item = lookup_item(node_id, cdata.data);\n     if item_family(item) != Impl {\n@@ -992,7 +992,7 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n }\n \n pub fn get_item_attrs(cdata: cmd,\n-                      node_id: ast::node_id,\n+                      node_id: ast::NodeId,\n                       f: &fn(~[@ast::MetaItem])) {\n \n     let item = lookup_item(node_id, cdata.data);\n@@ -1012,7 +1012,7 @@ fn struct_field_family_to_visibility(family: Family) -> ast::visibility {\n     }\n }\n \n-pub fn get_struct_fields(intr: @ident_interner, cdata: cmd, id: ast::node_id)\n+pub fn get_struct_fields(intr: @ident_interner, cdata: cmd, id: ast::NodeId)\n     -> ~[ty::field_ty] {\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n@@ -1040,7 +1040,7 @@ pub fn get_struct_fields(intr: @ident_interner, cdata: cmd, id: ast::node_id)\n     result\n }\n \n-pub fn get_item_visibility(cdata: cmd, id: ast::node_id)\n+pub fn get_item_visibility(cdata: cmd, id: ast::NodeId)\n                         -> ast::visibility {\n     item_visibility(lookup_item(id, cdata.data))\n }\n@@ -1068,7 +1068,7 @@ fn read_path(d: ebml::Doc) -> (~str, uint) {\n }\n \n fn describe_def(items: ebml::Doc, id: ast::def_id) -> ~str {\n-    if id.crate != ast::local_crate { return ~\"external\"; }\n+    if id.crate != ast::LOCAL_CRATE { return ~\"external\"; }\n     let it = match maybe_find_item(id.node, items) {\n         Some(it) => it,\n         None => fail!(\"describe_def: item not found %?\", id)\n@@ -1260,7 +1260,7 @@ pub fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n // then we must translate the crate number from that encoded in the external\n // crate to the correct local crate number.\n pub fn translate_def_id(cdata: cmd, did: ast::def_id) -> ast::def_id {\n-    if did.crate == ast::local_crate {\n+    if did.crate == ast::LOCAL_CRATE {\n         return ast::def_id { crate: cdata.cnum, node: did.node };\n     }\n "}, {"sha": "90604cf36cb5ca14bbdc3c30e7703bb8ee92909d", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -58,12 +58,12 @@ pub struct EncodeParams<'self> {\n     diag: @span_handler,\n     tcx: ty::ctxt,\n     reexports2: middle::resolve::ExportMap2,\n-    item_symbols: &'self HashMap<ast::node_id, ~str>,\n-    discrim_symbols: &'self HashMap<ast::node_id, @str>,\n+    item_symbols: &'self HashMap<ast::NodeId, ~str>,\n+    discrim_symbols: &'self HashMap<ast::NodeId, @str>,\n     link_meta: &'self LinkMeta,\n     cstore: @mut cstore::CStore,\n     encode_inlined_item: encode_inlined_item<'self>,\n-    reachable: @mut HashSet<ast::node_id>,\n+    reachable: @mut HashSet<ast::NodeId>,\n }\n \n struct Stats {\n@@ -86,16 +86,16 @@ pub struct EncodeContext<'self> {\n     tcx: ty::ctxt,\n     stats: @mut Stats,\n     reexports2: middle::resolve::ExportMap2,\n-    item_symbols: &'self HashMap<ast::node_id, ~str>,\n-    discrim_symbols: &'self HashMap<ast::node_id, @str>,\n+    item_symbols: &'self HashMap<ast::NodeId, ~str>,\n+    discrim_symbols: &'self HashMap<ast::NodeId, @str>,\n     link_meta: &'self LinkMeta,\n     cstore: &'self cstore::CStore,\n     encode_inlined_item: encode_inlined_item<'self>,\n     type_abbrevs: abbrev_map,\n-    reachable: @mut HashSet<ast::node_id>,\n+    reachable: @mut HashSet<ast::NodeId>,\n }\n \n-pub fn reachable(ecx: &EncodeContext, id: node_id) -> bool {\n+pub fn reachable(ecx: &EncodeContext, id: NodeId) -> bool {\n     ecx.reachable.contains(&id)\n }\n \n@@ -275,7 +275,7 @@ fn encode_method_fty(ecx: &EncodeContext,\n \n fn encode_symbol(ecx: &EncodeContext,\n                  ebml_w: &mut writer::Encoder,\n-                 id: node_id) {\n+                 id: NodeId) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     match ecx.item_symbols.find(&id) {\n         Some(x) => {\n@@ -292,7 +292,7 @@ fn encode_symbol(ecx: &EncodeContext,\n \n fn encode_discriminant(ecx: &EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n-                       id: node_id) {\n+                       id: NodeId) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     ebml_w.writer.write(ecx.discrim_symbols.get_copy(&id).as_bytes());\n     ebml_w.end_tag();\n@@ -316,7 +316,7 @@ fn encode_parent_item(ebml_w: &mut writer::Encoder, id: def_id) {\n \n fn encode_enum_variant_info(ecx: &EncodeContext,\n                             ebml_w: &mut writer::Encoder,\n-                            id: node_id,\n+                            id: NodeId,\n                             variants: &[variant],\n                             path: &[ast_map::path_elt],\n                             index: @mut ~[entry<int>],\n@@ -326,7 +326,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n     let mut disr_val = 0;\n     let mut i = 0;\n     let vi = ty::enum_variants(ecx.tcx,\n-                               ast::def_id { crate: local_crate, node: id });\n+                               ast::def_id { crate: LOCAL_CRATE, node: id });\n     for variants.iter().advance |variant| {\n         let def_id = local_def(variant.node.id);\n         index.push(entry {val: variant.node.id, pos: ebml_w.writer.tell()});\n@@ -481,7 +481,7 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n /// * For enums, iterates through the node IDs of the variants.\n ///\n /// * For newtype structs, iterates through the node ID of the constructor.\n-fn each_auxiliary_node_id(item: @item, callback: &fn(node_id) -> bool)\n+fn each_auxiliary_node_id(item: @item, callback: &fn(NodeId) -> bool)\n                           -> bool {\n     let mut continue = true;\n     match item.node {\n@@ -512,7 +512,7 @@ fn each_auxiliary_node_id(item: @item, callback: &fn(node_id) -> bool)\n \n fn encode_reexports(ecx: &EncodeContext,\n                     ebml_w: &mut writer::Encoder,\n-                    id: node_id,\n+                    id: NodeId,\n                     path: &[ast_map::path_elt]) {\n     debug!(\"(encoding info for module) encoding reexports for %d\", id);\n     match ecx.reexports2.find(&id) {\n@@ -542,7 +542,7 @@ fn encode_reexports(ecx: &EncodeContext,\n fn encode_info_for_mod(ecx: &EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n                        md: &_mod,\n-                       id: node_id,\n+                       id: NodeId,\n                        path: &[ast_map::path_elt],\n                        name: ident,\n                        vis: visibility) {\n@@ -710,7 +710,7 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n                                ebml_w: &mut writer::Encoder,\n                                path: &[ast_map::path_elt],\n                                name: ast::ident,\n-                               ctor_id: node_id,\n+                               ctor_id: NodeId,\n                                index: @mut ~[entry<int>]) {\n     index.push(entry { val: ctor_id, pos: ebml_w.writer.tell() });\n \n@@ -755,7 +755,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n                           m: &ty::Method,\n                           impl_path: &[ast_map::path_elt],\n                           is_default_impl: bool,\n-                          parent_id: node_id,\n+                          parent_id: NodeId,\n                           ast_method_opt: Option<@method>) {\n \n     debug!(\"encode_info_for_method: %? %s\", m.def_id,\n@@ -1081,7 +1081,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Now output the method info for each method.\n         let r = ty::trait_method_def_ids(tcx, def_id);\n         for r.iter().enumerate().advance |(i, &method_def_id)| {\n-            assert_eq!(method_def_id.crate, ast::local_crate);\n+            assert_eq!(method_def_id.crate, ast::LOCAL_CRATE);\n \n             let method_ty = ty::method(tcx, method_def_id);\n \n@@ -1186,11 +1186,11 @@ fn encode_info_for_items(ecx: &EncodeContext,\n                          -> ~[entry<int>] {\n     let index = @mut ~[];\n     ebml_w.start_tag(tag_items_data);\n-    index.push(entry { val: crate_node_id, pos: ebml_w.writer.tell() });\n+    index.push(entry { val: CRATE_NODE_ID, pos: ebml_w.writer.tell() });\n     encode_info_for_mod(ecx,\n                         ebml_w,\n                         &crate.module,\n-                        crate_node_id,\n+                        CRATE_NODE_ID,\n                         [],\n                         syntax::parse::token::special_idents::invalid,\n                         public);\n@@ -1458,7 +1458,7 @@ fn encode_lang_items(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n         let def_id = match def_id {\n             Some(id) => id, None => { loop }\n         };\n-        if def_id.crate != local_crate {\n+        if def_id.crate != LOCAL_CRATE {\n             loop;\n         }\n "}, {"sha": "31f0f67caf25bce01018de06863013a521e1ede7", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -165,7 +165,7 @@ fn reserve_id_range(sess: Session,\n }\n \n impl ExtendedDecodeContext {\n-    pub fn tr_id(&self, id: ast::node_id) -> ast::node_id {\n+    pub fn tr_id(&self, id: ast::NodeId) -> ast::NodeId {\n         /*!\n          * Translates an internal id, meaning a node id that is known\n          * to refer to some part of the item currently being inlined,\n@@ -212,8 +212,8 @@ impl ExtendedDecodeContext {\n          * refer to the current crate and to the new, inlined node-id.\n          */\n \n-        assert_eq!(did.crate, ast::local_crate);\n-        ast::def_id { crate: ast::local_crate, node: self.tr_id(did.node) }\n+        assert_eq!(did.crate, ast::LOCAL_CRATE);\n+        ast::def_id { crate: ast::LOCAL_CRATE, node: self.tr_id(did.node) }\n     }\n     pub fn tr_span(&self, _span: span) -> span {\n         codemap::dummy_sp() // FIXME (#1972): handle span properly\n@@ -802,7 +802,7 @@ impl ebml_writer_helpers for writer::Encoder {\n \n trait write_tag_and_id {\n     fn tag(&mut self, tag_id: c::astencode_tag, f: &fn(&mut Self));\n-    fn id(&mut self, id: ast::node_id);\n+    fn id(&mut self, id: ast::NodeId);\n }\n \n impl write_tag_and_id for writer::Encoder {\n@@ -814,7 +814,7 @@ impl write_tag_and_id for writer::Encoder {\n         self.end_tag();\n     }\n \n-    fn id(&mut self, id: ast::node_id) {\n+    fn id(&mut self, id: ast::NodeId) {\n         self.wr_tagged_u64(c::tag_table_id as uint, id as u64)\n     }\n }\n@@ -833,7 +833,7 @@ fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n     let ecx_ptr : *() = unsafe { cast::transmute(ecx) };\n     ast_util::visit_ids_for_inlined_item(\n         ii,\n-        |id: ast::node_id| {\n+        |id: ast::NodeId| {\n             // Note: this will cause a copy of ebml_w, which is bad as\n             // it is mutable. But I believe it's harmless since we generate\n             // balanced EBML.\n@@ -848,7 +848,7 @@ fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                              maps: Maps,\n                              ebml_w: &mut writer::Encoder,\n-                             id: ast::node_id) {\n+                             id: ast::NodeId) {\n     let tcx = ecx.tcx;\n \n     debug!(\"Encoding side tables for id %d\", id);\n@@ -903,7 +903,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         }\n     }\n \n-    let lid = ast::def_id { crate: ast::local_crate, node: id };\n+    let lid = ast::def_id { crate: ast::LOCAL_CRATE, node: id };\n     {\n         let r = tcx.tcache.find(&lid);\n         for r.iter().advance |&tpbt| {\n@@ -1181,7 +1181,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                     }\n                     c::tag_table_tcache => {\n                         let tpbt = val_dsr.read_ty_param_bounds_and_ty(xcx);\n-                        let lid = ast::def_id { crate: ast::local_crate, node: id };\n+                        let lid = ast::def_id { crate: ast::LOCAL_CRATE, node: id };\n                         dcx.tcx.tcache.insert(lid, tpbt);\n                     }\n                     c::tag_table_param_defs => {"}, {"sha": "7fde3f924ca46894d926e3d0e6cbfbcfb97dea10", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -37,7 +37,7 @@ struct CheckLoanCtxt<'self> {\n     dfcx_loans: &'self LoanDataFlow,\n     move_data: @move_data::FlowedMoveData,\n     all_loans: &'self [Loan],\n-    reported: @mut HashSet<ast::node_id>,\n+    reported: @mut HashSet<ast::NodeId>,\n }\n \n pub fn check_loans(bccx: @BorrowckCtxt,\n@@ -73,7 +73,7 @@ impl<'self> CheckLoanCtxt<'self> {\n     pub fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n     pub fn each_issued_loan(&self,\n-                            scope_id: ast::node_id,\n+                            scope_id: ast::NodeId,\n                             op: &fn(&Loan) -> bool)\n                             -> bool {\n         //! Iterates over each loan that has been issued\n@@ -92,7 +92,7 @@ impl<'self> CheckLoanCtxt<'self> {\n     }\n \n     pub fn each_in_scope_loan(&self,\n-                              scope_id: ast::node_id,\n+                              scope_id: ast::NodeId,\n                               op: &fn(&Loan) -> bool)\n                               -> bool {\n         //! Like `each_issued_loan()`, but only considers loans that are\n@@ -110,7 +110,7 @@ impl<'self> CheckLoanCtxt<'self> {\n     }\n \n     pub fn each_in_scope_restriction(&self,\n-                                     scope_id: ast::node_id,\n+                                     scope_id: ast::NodeId,\n                                      loan_path: @LoanPath,\n                                      op: &fn(&Loan, &Restriction) -> bool)\n                                      -> bool {\n@@ -129,7 +129,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         return true;\n     }\n \n-    pub fn loans_generated_by(&self, scope_id: ast::node_id) -> ~[uint] {\n+    pub fn loans_generated_by(&self, scope_id: ast::NodeId) -> ~[uint] {\n         //! Returns a vector of the loans that are generated as\n         //! we encounter `scope_id`.\n \n@@ -140,7 +140,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         return result;\n     }\n \n-    pub fn check_for_conflicting_loans(&self, scope_id: ast::node_id) {\n+    pub fn check_for_conflicting_loans(&self, scope_id: ast::NodeId) {\n         //! Checks to see whether any of the loans that are issued\n         //! by `scope_id` conflict with loans that have already been\n         //! issued when we enter `scope_id` (for example, we do not\n@@ -256,7 +256,7 @@ impl<'self> CheckLoanCtxt<'self> {\n     }\n \n     pub fn check_if_path_is_moved(&self,\n-                                  id: ast::node_id,\n+                                  id: ast::NodeId,\n                                   span: span,\n                                   use_kind: MovedValueUseKind,\n                                   lp: @LoanPath) {\n@@ -561,7 +561,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         }\n     }\n \n-    fn check_move_out_from_id(&self, id: ast::node_id, span: span) {\n+    fn check_move_out_from_id(&self, id: ast::NodeId, span: span) {\n         for self.move_data.each_path_moved_by(id) |_, move_path| {\n             match self.analyze_move_out_from(id, move_path) {\n                 MoveOk => {}\n@@ -581,7 +581,7 @@ impl<'self> CheckLoanCtxt<'self> {\n     }\n \n     pub fn analyze_move_out_from(&self,\n-                                 expr_id: ast::node_id,\n+                                 expr_id: ast::NodeId,\n                                  move_path: @LoanPath) -> MoveError {\n         debug!(\"analyze_move_out_from(expr_id=%?, move_path=%s)\",\n                expr_id, move_path.repr(self.tcx()));\n@@ -600,7 +600,7 @@ impl<'self> CheckLoanCtxt<'self> {\n     pub fn check_call(&self,\n                       _expr: @ast::expr,\n                       _callee: Option<@ast::expr>,\n-                      _callee_id: ast::node_id,\n+                      _callee_id: ast::NodeId,\n                       _callee_span: span,\n                       _args: &[@ast::expr]) {\n         // NB: This call to check for conflicting loans is not truly\n@@ -617,7 +617,7 @@ fn check_loans_in_fn<'a>(fk: &visit::fn_kind,\n                          decl: &ast::fn_decl,\n                          body: &ast::Block,\n                          sp: span,\n-                         id: ast::node_id,\n+                         id: ast::NodeId,\n                          (this, visitor): (CheckLoanCtxt<'a>,\n                                            visit::vt<CheckLoanCtxt<'a>>)) {\n     match *fk {\n@@ -636,7 +636,7 @@ fn check_loans_in_fn<'a>(fk: &visit::fn_kind,\n     visit::visit_fn(fk, decl, body, sp, id, (this, visitor));\n \n     fn check_captured_variables(this: CheckLoanCtxt,\n-                                closure_id: ast::node_id,\n+                                closure_id: ast::NodeId,\n                                 span: span) {\n         let cap_vars = this.bccx.capture_map.get(&closure_id);\n         for cap_vars.iter().advance |cap_var| {\n@@ -654,7 +654,7 @@ fn check_loans_in_fn<'a>(fk: &visit::fn_kind,\n         return;\n \n         fn check_by_move_capture(this: CheckLoanCtxt,\n-                                 closure_id: ast::node_id,\n+                                 closure_id: ast::NodeId,\n                                  cap_var: &moves::CaptureVar,\n                                  move_path: @LoanPath) {\n             let move_err = this.analyze_move_out_from(closure_id, move_path);"}, {"sha": "e942efbc534a82f0b82200a7d862c9a68862c7e7", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -24,9 +24,9 @@ use util::ppaux::{UserString};\n \n pub fn gather_decl(bccx: @BorrowckCtxt,\n                    move_data: &mut MoveData,\n-                   decl_id: ast::node_id,\n+                   decl_id: ast::NodeId,\n                    _decl_span: span,\n-                   var_id: ast::node_id) {\n+                   var_id: ast::NodeId) {\n     let loan_path = @LpVar(var_id);\n     move_data.add_move(bccx.tcx, loan_path, decl_id, Declared);\n }\n@@ -49,7 +49,7 @@ pub fn gather_move_from_pat(bccx: @BorrowckCtxt,\n \n fn gather_move_from_expr_or_pat(bccx: @BorrowckCtxt,\n                                 move_data: &mut MoveData,\n-                                move_id: ast::node_id,\n+                                move_id: ast::NodeId,\n                                 move_kind: MoveKind,\n                                 cmt: mc::cmt) {\n     if !check_is_legal_to_move_from(bccx, cmt, cmt) {\n@@ -85,10 +85,10 @@ pub fn gather_captures(bccx: @BorrowckCtxt,\n \n pub fn gather_assignment(bccx: @BorrowckCtxt,\n                          move_data: &mut MoveData,\n-                         assignment_id: ast::node_id,\n+                         assignment_id: ast::NodeId,\n                          assignment_span: span,\n                          assignee_loan_path: @LoanPath,\n-                         assignee_id: ast::node_id) {\n+                         assignee_id: ast::NodeId) {\n     move_data.add_assignment(bccx.tcx,\n                              assignee_loan_path,\n                              assignment_id,"}, {"sha": "ddcc5fe56d04352abb18f82afa4ae0cb5c113754", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -21,8 +21,8 @@ use syntax::codemap::span;\n use util::ppaux::{note_and_explain_region};\n \n pub fn guarantee_lifetime(bccx: @BorrowckCtxt,\n-                          item_scope_id: ast::node_id,\n-                          root_scope_id: ast::node_id,\n+                          item_scope_id: ast::NodeId,\n+                          root_scope_id: ast::NodeId,\n                           span: span,\n                           cmt: mc::cmt,\n                           loan_region: ty::Region,\n@@ -46,11 +46,11 @@ struct GuaranteeLifetimeContext {\n     bccx: @BorrowckCtxt,\n \n     // the node id of the function body for the enclosing item\n-    item_scope_id: ast::node_id,\n+    item_scope_id: ast::NodeId,\n \n     // the node id of the innermost loop / function body; this is the\n     // longest scope for which we can root managed boxes\n-    root_scope_id: ast::node_id,\n+    root_scope_id: ast::NodeId,\n \n     span: span,\n     loan_region: ty::Region,\n@@ -63,7 +63,7 @@ impl GuaranteeLifetimeContext {\n         self.bccx.tcx\n     }\n \n-    fn check(&self, cmt: mc::cmt, discr_scope: Option<ast::node_id>) {\n+    fn check(&self, cmt: mc::cmt, discr_scope: Option<ast::NodeId>) {\n         //! Main routine. Walks down `cmt` until we find the \"guarantor\".\n \n         match cmt.cat {\n@@ -189,7 +189,7 @@ impl GuaranteeLifetimeContext {\n                   cmt_base: mc::cmt,\n                   derefs: uint,\n                   ptr_mutbl: ast::mutability,\n-                  discr_scope: Option<ast::node_id>) {\n+                  discr_scope: Option<ast::NodeId>) {\n         debug!(\"check_root(cmt_deref=%s, cmt_base=%s, derefs=%?, ptr_mutbl=%?, \\\n                 discr_scope=%?)\",\n                cmt_deref.repr(self.tcx()),"}, {"sha": "dc120516deaaec2df20da5e8d17e1b25383982ac", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -68,8 +68,8 @@ struct GatherLoanCtxt {\n     id_range: id_range,\n     move_data: @mut move_data::MoveData,\n     all_loans: @mut ~[Loan],\n-    item_ub: ast::node_id,\n-    repeating_ids: ~[ast::node_id]\n+    item_ub: ast::NodeId,\n+    repeating_ids: ~[ast::NodeId]\n }\n \n pub fn gather_loans(bccx: @BorrowckCtxt,\n@@ -111,7 +111,7 @@ fn gather_loans_in_fn(fk: &visit::fn_kind,\n                       decl: &ast::fn_decl,\n                       body: &ast::Block,\n                       sp: span,\n-                      id: ast::node_id,\n+                      id: ast::NodeId,\n                       (this, v): (@mut GatherLoanCtxt,\n                                   visit::vt<@mut GatherLoanCtxt>)) {\n     match fk {\n@@ -294,11 +294,11 @@ fn gather_loans_in_expr(ex: @ast::expr,\n impl GatherLoanCtxt {\n     pub fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n-    pub fn push_repeating_id(&mut self, id: ast::node_id) {\n+    pub fn push_repeating_id(&mut self, id: ast::NodeId) {\n         self.repeating_ids.push(id);\n     }\n \n-    pub fn pop_repeating_id(&mut self, id: ast::node_id) {\n+    pub fn pop_repeating_id(&mut self, id: ast::NodeId) {\n         let popped = self.repeating_ids.pop();\n         assert_eq!(id, popped);\n     }\n@@ -369,7 +369,7 @@ impl GatherLoanCtxt {\n     // also entail \"rooting\" GC'd pointers, which means ensuring\n     // dynamically that they are not freed.\n     pub fn guarantee_valid(&mut self,\n-                           borrow_id: ast::node_id,\n+                           borrow_id: ast::NodeId,\n                            borrow_span: span,\n                            cmt: mc::cmt,\n                            req_mutbl: ast::mutability,\n@@ -559,9 +559,9 @@ impl GatherLoanCtxt {\n     }\n \n     pub fn compute_gen_scope(&self,\n-                             borrow_id: ast::node_id,\n-                             loan_scope: ast::node_id)\n-                             -> ast::node_id {\n+                             borrow_id: ast::NodeId,\n+                             loan_scope: ast::NodeId)\n+                             -> ast::NodeId {\n         //! Determine when to introduce the loan. Typically the loan\n         //! is introduced at the point of the borrow, but in some cases,\n         //! notably method arguments, the loan may be introduced only\n@@ -575,8 +575,8 @@ impl GatherLoanCtxt {\n         }\n     }\n \n-    pub fn compute_kill_scope(&self, loan_scope: ast::node_id, lp: @LoanPath)\n-                              -> ast::node_id {\n+    pub fn compute_kill_scope(&self, loan_scope: ast::NodeId, lp: @LoanPath)\n+                              -> ast::NodeId {\n         //! Determine when the loan restrictions go out of scope.\n         //! This is either when the lifetime expires or when the\n         //! local variable which roots the loan-path goes out of scope,\n@@ -633,7 +633,7 @@ impl GatherLoanCtxt {\n     fn gather_pat(&mut self,\n                   discr_cmt: mc::cmt,\n                   root_pat: @ast::pat,\n-                  arm_match_ids: Option<(ast::node_id, ast::node_id)>) {\n+                  arm_match_ids: Option<(ast::NodeId, ast::NodeId)>) {\n         /*!\n          * Walks patterns, examining the bindings to determine if they\n          * cause borrows (`ref` bindings, vector patterns) or"}, {"sha": "13ee902390b3bb20ea28f20b8dc4080364fd31f7", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -117,7 +117,7 @@ fn borrowck_fn(fk: &visit::fn_kind,\n                decl: &ast::fn_decl,\n                body: &ast::Block,\n                sp: span,\n-               id: ast::node_id,\n+               id: ast::NodeId,\n                (this, v): (@BorrowckCtxt,\n                            visit::vt<@BorrowckCtxt>)) {\n     match fk {\n@@ -185,7 +185,7 @@ pub struct BorrowStats {\n     guaranteed_paths: uint\n }\n \n-pub type LoanMap = @mut HashMap<ast::node_id, @Loan>;\n+pub type LoanMap = @mut HashMap<ast::NodeId, @Loan>;\n \n // The keys to the root map combine the `id` of the deref expression\n // with the number of types that it is *autodereferenced*. So, for\n@@ -212,7 +212,7 @@ pub type LoanMap = @mut HashMap<ast::node_id, @Loan>;\n // auto-slice.\n #[deriving(Eq, IterBytes)]\n pub struct root_map_key {\n-    id: ast::node_id,\n+    id: ast::NodeId,\n     derefs: uint\n }\n \n@@ -238,14 +238,14 @@ pub struct Loan {\n     cmt: mc::cmt,\n     mutbl: ast::mutability,\n     restrictions: ~[Restriction],\n-    gen_scope: ast::node_id,\n-    kill_scope: ast::node_id,\n+    gen_scope: ast::NodeId,\n+    kill_scope: ast::NodeId,\n     span: span,\n }\n \n #[deriving(Eq, IterBytes)]\n pub enum LoanPath {\n-    LpVar(ast::node_id),               // `x` in doc.rs\n+    LpVar(ast::NodeId),               // `x` in doc.rs\n     LpExtend(@LoanPath, mc::MutabilityCategory, LoanPathElem)\n }\n \n@@ -256,7 +256,7 @@ pub enum LoanPathElem {\n }\n \n impl LoanPath {\n-    pub fn node_id(&self) -> ast::node_id {\n+    pub fn node_id(&self) -> ast::NodeId {\n         match *self {\n             LpVar(local_id) => local_id,\n             LpExtend(base, _, _) => base.node_id()\n@@ -376,7 +376,7 @@ impl BitAnd<RestrictionSet,RestrictionSet> for RestrictionSet {\n // uncovered after a certain number of auto-derefs.\n \n pub struct RootInfo {\n-    scope: ast::node_id,\n+    scope: ast::NodeId,\n     freeze: Option<DynaFreezeKind> // Some() if we should freeze box at runtime\n }\n \n@@ -440,12 +440,12 @@ impl BorrowckCtxt {\n         self.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n     }\n \n-    pub fn is_subscope_of(&self, r_sub: ast::node_id, r_sup: ast::node_id)\n+    pub fn is_subscope_of(&self, r_sub: ast::NodeId, r_sup: ast::NodeId)\n                           -> bool {\n         self.tcx.region_maps.is_subscope_of(r_sub, r_sup)\n     }\n \n-    pub fn is_move(&self, id: ast::node_id) -> bool {\n+    pub fn is_move(&self, id: ast::NodeId) -> bool {\n         self.moves_map.contains(&id)\n     }\n \n@@ -477,15 +477,15 @@ impl BorrowckCtxt {\n     }\n \n     pub fn cat_def(&self,\n-                   id: ast::node_id,\n+                   id: ast::NodeId,\n                    span: span,\n                    ty: ty::t,\n                    def: ast::def)\n                    -> mc::cmt {\n         mc::cat_def(self.tcx, self.method_map, id, span, ty, def)\n     }\n \n-    pub fn cat_discr(&self, cmt: mc::cmt, match_id: ast::node_id) -> mc::cmt {\n+    pub fn cat_discr(&self, cmt: mc::cmt, match_id: ast::NodeId) -> mc::cmt {\n         @mc::cmt_ {cat:mc::cat_discr(cmt, match_id),\n                    mutbl:cmt.mutbl.inherit(),\n                    ..*cmt}"}, {"sha": "223b18bfa7e5006693a988355716a2096c69c373", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -49,7 +49,7 @@ pub struct MoveData {\n     /// assigned dataflow bits, but we track them because they still\n     /// kill move bits.\n     path_assignments: ~[Assignment],\n-    assignee_ids: HashSet<ast::node_id>,\n+    assignee_ids: HashSet<ast::NodeId>,\n }\n \n pub struct FlowedMoveData {\n@@ -118,7 +118,7 @@ pub struct Move {\n     path: MovePathIndex,\n \n     /// id of node that is doing the move.\n-    id: ast::node_id,\n+    id: ast::NodeId,\n \n     /// Kind of move, for error messages.\n     kind: MoveKind,\n@@ -132,7 +132,7 @@ pub struct Assignment {\n     path: MovePathIndex,\n \n     /// id where assignment occurs\n-    id: ast::node_id,\n+    id: ast::NodeId,\n \n     /// span of node where assignment occurs\n     span: span,\n@@ -296,7 +296,7 @@ impl MoveData {\n     pub fn add_move(&mut self,\n                     tcx: ty::ctxt,\n                     lp: @LoanPath,\n-                    id: ast::node_id,\n+                    id: ast::NodeId,\n                     kind: MoveKind) {\n         /*!\n          * Adds a new move entry for a move of `lp` that occurs at\n@@ -325,9 +325,9 @@ impl MoveData {\n     pub fn add_assignment(&mut self,\n                           tcx: ty::ctxt,\n                           lp: @LoanPath,\n-                          assign_id: ast::node_id,\n+                          assign_id: ast::NodeId,\n                           span: span,\n-                          assignee_id: ast::node_id) {\n+                          assignee_id: ast::NodeId) {\n         /*!\n          * Adds a new record for an assignment to `lp` that occurs at\n          * location `id` with the given `span`.\n@@ -460,7 +460,7 @@ impl MoveData {\n \n     fn kill_moves(&self,\n                   path: MovePathIndex,\n-                  kill_id: ast::node_id,\n+                  kill_id: ast::NodeId,\n                   dfcx_moves: &mut MoveDataFlow) {\n         for self.each_applicable_move(path) |move_index| {\n             dfcx_moves.add_kill(kill_id, *move_index);\n@@ -499,7 +499,7 @@ impl FlowedMoveData {\n     }\n \n     pub fn each_path_moved_by(&self,\n-                              id: ast::node_id,\n+                              id: ast::NodeId,\n                               f: &fn(&Move, @LoanPath) -> bool)\n                               -> bool {\n         /*!\n@@ -517,7 +517,7 @@ impl FlowedMoveData {\n     }\n \n     pub fn each_move_of(&self,\n-                        id: ast::node_id,\n+                        id: ast::NodeId,\n                         loan_path: @LoanPath,\n                         f: &fn(&Move, @LoanPath) -> bool)\n                         -> bool {\n@@ -573,15 +573,15 @@ impl FlowedMoveData {\n     }\n \n     pub fn is_assignee(&self,\n-                       id: ast::node_id)\n+                       id: ast::NodeId)\n                        -> bool {\n         //! True if `id` is the id of the LHS of an assignment\n \n         self.move_data.assignee_ids.iter().any(|x| x == &id)\n     }\n \n     pub fn each_assignment_of(&self,\n-                              id: ast::node_id,\n+                              id: ast::NodeId,\n                               loan_path: @LoanPath,\n                               f: &fn(&Assignment) -> bool)\n                               -> bool {"}, {"sha": "97fc49b23d0229842c505e04ad0a05c178565e4d", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -20,13 +20,13 @@ use syntax::opt_vec;\n struct CFGBuilder {\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n-    exit_map: HashMap<ast::node_id, CFGIndex>,\n+    exit_map: HashMap<ast::NodeId, CFGIndex>,\n     graph: CFGGraph,\n     loop_scopes: ~[LoopScope],\n }\n \n struct LoopScope {\n-    loop_id: ast::node_id,    // id of loop/while node\n+    loop_id: ast::NodeId,     // id of loop/while node\n     continue_index: CFGIndex, // where to go on a `loop`\n     break_index: CFGIndex,    // where to go on a `break\n }\n@@ -454,7 +454,7 @@ impl CFGBuilder {\n         self.add_node(0, preds)\n     }\n \n-    fn add_node(&mut self, id: ast::node_id, preds: &[CFGIndex]) -> CFGIndex {\n+    fn add_node(&mut self, id: ast::NodeId, preds: &[CFGIndex]) -> CFGIndex {\n         assert!(!self.exit_map.contains_key(&id));\n         let node = self.graph.add_node(CFGNodeData {id: id});\n         self.exit_map.insert(id, node);"}, {"sha": "cc00ab921b4e9474e30007d0233c8b5b6c9ea36f", "filename": "src/librustc/middle/cfg/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -25,18 +25,18 @@ use syntax::opt_vec::OptVec;\n mod construct;\n \n pub struct CFG {\n-    exit_map: HashMap<ast::node_id, CFGIndex>,\n+    exit_map: HashMap<ast::NodeId, CFGIndex>,\n     graph: CFGGraph,\n     entry: CFGIndex,\n     exit: CFGIndex,\n }\n \n pub struct CFGNodeData {\n-    id: ast::node_id\n+    id: ast::NodeId\n }\n \n pub struct CFGEdgeData {\n-    exiting_scopes: OptVec<ast::node_id>\n+    exiting_scopes: OptVec<ast::NodeId>\n }\n \n pub type CFGIndex = graph::NodeIndex;\n@@ -58,4 +58,4 @@ impl CFG {\n                blk: &ast::Block) -> CFG {\n         construct::construct(tcx, method_map, blk)\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "bb6736b3de9e083ec24b002ad0e6a4b0f528869a", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -200,7 +200,7 @@ struct env {\n     sess: Session,\n     ast_map: ast_map::map,\n     def_map: resolve::DefMap,\n-    idstack: @mut ~[node_id]\n+    idstack: @mut ~[NodeId]\n }\n \n // Make sure a const item doesn't recursively refer to itself"}, {"sha": "987443de30dc3ee7f829aa3b5d27b6da0b5a75ab", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -777,7 +777,7 @@ pub fn check_fn(cx: &MatchCheckCtxt,\n                 decl: &fn_decl,\n                 body: &Block,\n                 sp: span,\n-                id: node_id,\n+                id: NodeId,\n                 (s, v): ((),\n                          visit::vt<()>)) {\n     visit::visit_fn(kind, decl, body, sp, id, (s, v));"}, {"sha": "cdf887f464367b1f355bfb91fa45bf47c3bf809e", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -175,7 +175,7 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n                             enum_def: ast::def_id,\n                             variant_def: ast::def_id)\n                        -> Option<@expr> {\n-    fn variant_expr(variants: &[ast::variant], id: ast::node_id) -> Option<@expr> {\n+    fn variant_expr(variants: &[ast::variant], id: ast::NodeId) -> Option<@expr> {\n         for variants.iter().advance |variant| {\n             if variant.node.id == id {\n                 return variant.node.disr_expr;"}, {"sha": "1da3b31c93634a0eb85b55fcfc6e5c0ad35a05f1", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -46,7 +46,7 @@ pub struct DataFlowContext<O> {\n     priv words_per_id: uint,\n \n     // mapping from node to bitset index.\n-    priv nodeid_to_bitset: HashMap<ast::node_id,uint>,\n+    priv nodeid_to_bitset: HashMap<ast::NodeId,uint>,\n \n     // Bit sets per id.  The following three fields (`gens`, `kills`,\n     // and `on_entry`) all have the same structure. For each id in\n@@ -93,7 +93,7 @@ enum LoopKind {\n }\n \n struct LoopScope<'self> {\n-    loop_id: ast::node_id,\n+    loop_id: ast::NodeId,\n     loop_kind: LoopKind,\n     break_bits: ~[uint]\n }\n@@ -126,7 +126,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         }\n     }\n \n-    pub fn add_gen(&mut self, id: ast::node_id, bit: uint) {\n+    pub fn add_gen(&mut self, id: ast::NodeId, bit: uint) {\n         //! Indicates that `id` generates `bit`\n \n         debug!(\"add_gen(id=%?, bit=%?)\", id, bit);\n@@ -137,7 +137,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         }\n     }\n \n-    pub fn add_kill(&mut self, id: ast::node_id, bit: uint) {\n+    pub fn add_kill(&mut self, id: ast::NodeId, bit: uint) {\n         //! Indicates that `id` kills `bit`\n \n         debug!(\"add_kill(id=%?, bit=%?)\", id, bit);\n@@ -148,7 +148,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         }\n     }\n \n-    fn apply_gen_kill(&mut self, id: ast::node_id, bits: &mut [uint]) {\n+    fn apply_gen_kill(&mut self, id: ast::NodeId, bits: &mut [uint]) {\n         //! Applies the gen and kill sets for `id` to `bits`\n \n         debug!(\"apply_gen_kill(id=%?, bits=%s) [before]\",\n@@ -163,7 +163,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n                id, mut_bits_to_str(bits));\n     }\n \n-    fn apply_kill(&mut self, id: ast::node_id, bits: &mut [uint]) {\n+    fn apply_kill(&mut self, id: ast::NodeId, bits: &mut [uint]) {\n         debug!(\"apply_kill(id=%?, bits=%s) [before]\",\n                id, mut_bits_to_str(bits));\n         let (start, end) = self.compute_id_range(id);\n@@ -173,14 +173,14 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n                id, mut_bits_to_str(bits));\n     }\n \n-    fn compute_id_range_frozen(&self, id: ast::node_id) -> (uint, uint) {\n+    fn compute_id_range_frozen(&self, id: ast::NodeId) -> (uint, uint) {\n         let n = *self.nodeid_to_bitset.get(&id);\n         let start = n * self.words_per_id;\n         let end = start + self.words_per_id;\n         (start, end)\n     }\n \n-    fn compute_id_range(&mut self, id: ast::node_id) -> (uint, uint) {\n+    fn compute_id_range(&mut self, id: ast::NodeId) -> (uint, uint) {\n         let mut expanded = false;\n         let len = self.nodeid_to_bitset.len();\n         let n = do self.nodeid_to_bitset.find_or_insert_with(id) |_| {\n@@ -208,7 +208,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n \n \n     pub fn each_bit_on_entry_frozen(&self,\n-                                    id: ast::node_id,\n+                                    id: ast::NodeId,\n                                     f: &fn(uint) -> bool) -> bool {\n         //! Iterates through each bit that is set on entry to `id`.\n         //! Only useful after `propagate()` has been called.\n@@ -223,7 +223,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n     }\n \n     pub fn each_bit_on_entry(&mut self,\n-                             id: ast::node_id,\n+                             id: ast::NodeId,\n                              f: &fn(uint) -> bool) -> bool {\n         //! Iterates through each bit that is set on entry to `id`.\n         //! Only useful after `propagate()` has been called.\n@@ -236,7 +236,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n     }\n \n     pub fn each_gen_bit(&mut self,\n-                        id: ast::node_id,\n+                        id: ast::NodeId,\n                         f: &fn(uint) -> bool) -> bool {\n         //! Iterates through each bit in the gen set for `id`.\n \n@@ -248,7 +248,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n     }\n \n     pub fn each_gen_bit_frozen(&self,\n-                               id: ast::node_id,\n+                               id: ast::NodeId,\n                                f: &fn(uint) -> bool) -> bool {\n         //! Iterates through each bit in the gen set for `id`.\n         if !self.nodeid_to_bitset.contains_key(&id) {\n@@ -851,8 +851,8 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n     }\n \n     fn walk_call(&mut self,\n-                 _callee_id: ast::node_id,\n-                 call_id: ast::node_id,\n+                 _callee_id: ast::NodeId,\n+                 call_id: ast::NodeId,\n                  arg0: @ast::expr,\n                  args: &[@ast::expr],\n                  in_out: &mut [uint],\n@@ -949,7 +949,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n         for bits.mut_iter().advance |b| { *b = e; }\n     }\n \n-    fn add_to_entry_set(&mut self, id: ast::node_id, pred_bits: &[uint]) {\n+    fn add_to_entry_set(&mut self, id: ast::NodeId, pred_bits: &[uint]) {\n         debug!(\"add_to_entry_set(id=%?, pred_bits=%s)\",\n                id, bits_to_str(pred_bits));\n         let (start, end) = self.dfcx.compute_id_range(id);\n@@ -965,7 +965,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n     }\n \n     fn merge_with_entry_set(&mut self,\n-                            id: ast::node_id,\n+                            id: ast::NodeId,\n                             pred_bits: &mut [uint]) {\n         debug!(\"merge_with_entry_set(id=%?, pred_bits=%s)\",\n                id, mut_bits_to_str(pred_bits));"}, {"sha": "711598ed1551aa9880ce103275ee302dca61c913", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -17,7 +17,7 @@ use middle::typeck::method_map;\n use util::ppaux;\n \n use syntax::ast::{deref, expr_call, expr_inline_asm, expr_method_call};\n-use syntax::ast::{expr_unary, node_id, unsafe_blk, unsafe_fn, expr_path};\n+use syntax::ast::{expr_unary, unsafe_fn, expr_path};\n use syntax::ast;\n use syntax::codemap::span;\n use syntax::visit::{fk_item_fn, fk_method};\n@@ -27,7 +27,7 @@ use syntax::visit;\n enum UnsafeContext {\n     SafeContext,\n     UnsafeFn,\n-    UnsafeBlock(node_id),\n+    UnsafeBlock(ast::NodeId),\n }\n \n struct Context {\n@@ -99,7 +99,7 @@ pub fn check_crate(tcx: ty::ctxt,\n \n         visit_block: |block, (_, visitor)| {\n             let old_unsafe_context = context.unsafe_context;\n-            if block.rules == unsafe_blk &&\n+            if block.rules == ast::UnsafeBlock &&\n                     context.unsafe_context == SafeContext {\n                 context.unsafe_context = UnsafeBlock(block.id)\n             }"}, {"sha": "17d7b6e828e757e7c514337c00a4e344d36d9dc3", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -12,7 +12,7 @@\n use driver::session;\n use driver::session::Session;\n use syntax::parse::token::special_idents;\n-use syntax::ast::{Crate, node_id, item, item_fn};\n+use syntax::ast::{Crate, NodeId, item, item_fn};\n use syntax::attr;\n use syntax::codemap::span;\n use syntax::visit::{default_visitor, mk_vt, vt, Visitor, visit_crate, visit_item};\n@@ -25,17 +25,17 @@ struct EntryContext {\n     ast_map: ast_map::map,\n \n     // The top-level function called 'main'\n-    main_fn: Option<(node_id, span)>,\n+    main_fn: Option<(NodeId, span)>,\n \n     // The function that has attribute named 'main'\n-    attr_main_fn: Option<(node_id, span)>,\n+    attr_main_fn: Option<(NodeId, span)>,\n \n     // The function that has the attribute 'start' on it\n-    start_fn: Option<(node_id, span)>,\n+    start_fn: Option<(NodeId, span)>,\n \n     // The functions that one might think are 'main' but aren't, e.g.\n     // main functions not defined at the top level. For diagnostics.\n-    non_main_fns: ~[(node_id, span)],\n+    non_main_fns: ~[(NodeId, span)],\n }\n \n type EntryVisitor = vt<@mut EntryContext>;"}, {"sha": "65903442964bd32496bf6ec67802960d82ab6951", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -27,7 +27,7 @@ pub struct freevar_entry {\n     span: span     //< First span where it is accessed (there can be multiple)\n }\n pub type freevar_info = @~[@freevar_entry];\n-pub type freevar_map = @mut HashMap<ast::node_id, freevar_info>;\n+pub type freevar_map = @mut HashMap<ast::NodeId, freevar_info>;\n \n // Searches through part of the AST for all references to locals or\n // upvars in this frame and returns the list of definition IDs thus found.\n@@ -95,7 +95,7 @@ pub fn annotate_freevars(def_map: resolve::DefMap, crate: &ast::Crate) ->\n                      &ast::fn_decl,\n                      &ast::Block,\n                      span,\n-                     ast::node_id) = |_, _, blk, _, nid| {\n+                     ast::NodeId) = |_, _, blk, _, nid| {\n         let vars = collect_freevars(def_map, blk);\n         freevars.insert(nid, vars);\n     };\n@@ -109,13 +109,13 @@ pub fn annotate_freevars(def_map: resolve::DefMap, crate: &ast::Crate) ->\n     return freevars;\n }\n \n-pub fn get_freevars(tcx: ty::ctxt, fid: ast::node_id) -> freevar_info {\n+pub fn get_freevars(tcx: ty::ctxt, fid: ast::NodeId) -> freevar_info {\n     match tcx.freevars.find(&fid) {\n       None => fail!(\"get_freevars: %d has no freevars\", fid),\n       Some(&d) => return d\n     }\n }\n \n-pub fn has_freevars(tcx: ty::ctxt, fid: ast::node_id) -> bool {\n+pub fn has_freevars(tcx: ty::ctxt, fid: ast::NodeId) -> bool {\n     !get_freevars(tcx, fid).is_empty()\n }"}, {"sha": "715ebc48a6fc9b36d43354353ad8a62b5c673c23", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -55,7 +55,7 @@ pub static try_adding: &'static str = \"Try adding a move\";\n pub struct Context {\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n-    current_item: node_id\n+    current_item: NodeId\n }\n \n pub fn check_crate(tcx: ty::ctxt,\n@@ -156,9 +156,9 @@ fn check_item(item: @item, (cx, visitor): (Context, visit::vt<Context>)) {\n }\n \n // Yields the appropriate function to check the kind of closed over\n-// variables. `id` is the node_id for some expression that creates the\n+// variables. `id` is the NodeId for some expression that creates the\n // closure.\n-fn with_appropriate_checker(cx: Context, id: node_id,\n+fn with_appropriate_checker(cx: Context, id: NodeId,\n                             b: &fn(checker: &fn(Context, @freevar_entry))) {\n     fn check_for_uniq(cx: Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n         // all captured data must be owned, regardless of whether it is\n@@ -230,7 +230,7 @@ fn check_fn(\n     decl: &fn_decl,\n     body: &Block,\n     sp: span,\n-    fn_id: node_id,\n+    fn_id: NodeId,\n     (cx, v): (Context,\n               visit::vt<Context>)) {\n \n@@ -348,7 +348,7 @@ pub fn check_builtin_bounds(cx: Context, ty: ty::t, bounds: ty::BuiltinBounds,\n }\n \n pub fn check_typaram_bounds(cx: Context,\n-                    _type_parameter_id: node_id,\n+                    _type_parameter_id: NodeId,\n                     sp: span,\n                     ty: ty::t,\n                     type_param_def: &ty::TypeParameterDef)"}, {"sha": "41b6c52466f1e87f67bbce10cc31cfa5f5d2238b", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -874,7 +874,7 @@ fn lint_unused_unsafe() -> visit::vt<@mut Context> {\n     visit::mk_vt(@visit::Visitor {\n         visit_expr: |e, (cx, vt): (@mut Context, visit::vt<@mut Context>)| {\n             match e.node {\n-                ast::expr_block(ref blk) if blk.rules == ast::unsafe_blk => {\n+                ast::expr_block(ref blk) if blk.rules == ast::UnsafeBlock => {\n                     if !cx.tcx.used_unsafe.contains(&blk.id) {\n                         cx.span_lint(unused_unsafe, blk.span,\n                                      \"unnecessary `unsafe` block\");"}, {"sha": "385f23a73d6c4bc9b58c3b4493a56a5e64d498c3", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -212,7 +212,7 @@ fn invalid_node() -> LiveNode { LiveNode(uint::max_value) }\n struct CaptureInfo {\n     ln: LiveNode,\n     is_move: bool,\n-    var_nid: node_id\n+    var_nid: NodeId\n }\n \n enum LocalKind {\n@@ -222,14 +222,14 @@ enum LocalKind {\n }\n \n struct LocalInfo {\n-    id: node_id,\n+    id: NodeId,\n     ident: ident,\n     is_mutbl: bool,\n     kind: LocalKind,\n }\n \n enum VarKind {\n-    Arg(node_id, ident),\n+    Arg(NodeId, ident),\n     Local(LocalInfo),\n     ImplicitRet\n }\n@@ -241,9 +241,9 @@ struct IrMaps {\n \n     num_live_nodes: uint,\n     num_vars: uint,\n-    live_node_map: HashMap<node_id, LiveNode>,\n-    variable_map: HashMap<node_id, Variable>,\n-    capture_info_map: HashMap<node_id, @~[CaptureInfo]>,\n+    live_node_map: HashMap<NodeId, LiveNode>,\n+    variable_map: HashMap<NodeId, Variable>,\n+    capture_info_map: HashMap<NodeId, @~[CaptureInfo]>,\n     var_kinds: ~[VarKind],\n     lnks: ~[LiveNodeKind],\n }\n@@ -279,7 +279,7 @@ impl IrMaps {\n     }\n \n     pub fn add_live_node_for_node(&mut self,\n-                                  node_id: node_id,\n+                                  node_id: NodeId,\n                                   lnk: LiveNodeKind) {\n         let ln = self.add_live_node(lnk);\n         self.live_node_map.insert(node_id, ln);\n@@ -304,7 +304,7 @@ impl IrMaps {\n         v\n     }\n \n-    pub fn variable(&mut self, node_id: node_id, span: span) -> Variable {\n+    pub fn variable(&mut self, node_id: NodeId, span: span) -> Variable {\n         match self.variable_map.find(&node_id) {\n           Some(&var) => var,\n           None => {\n@@ -323,7 +323,7 @@ impl IrMaps {\n         }\n     }\n \n-    pub fn set_captures(&mut self, node_id: node_id, cs: ~[CaptureInfo]) {\n+    pub fn set_captures(&mut self, node_id: NodeId, cs: ~[CaptureInfo]) {\n         self.capture_info_map.insert(node_id, @cs);\n     }\n \n@@ -345,7 +345,7 @@ fn visit_fn(fk: &visit::fn_kind,\n             decl: &fn_decl,\n             body: &Block,\n             sp: span,\n-            id: node_id,\n+            id: NodeId,\n             (this, v): (@mut IrMaps,\n                         vt<@mut IrMaps>)) {\n     debug!(\"visit_fn: id=%d\", id);\n@@ -553,7 +553,7 @@ static ACC_READ: uint = 1u;\n static ACC_WRITE: uint = 2u;\n static ACC_USE: uint = 4u;\n \n-type LiveNodeMap = @mut HashMap<node_id, LiveNode>;\n+type LiveNodeMap = @mut HashMap<NodeId, LiveNode>;\n \n struct Liveness {\n     tcx: ty::ctxt,\n@@ -563,7 +563,7 @@ struct Liveness {\n     users: @mut ~[Users],\n     // The list of node IDs for the nested loop scopes\n     // we're in.\n-    loop_scope: @mut ~[node_id],\n+    loop_scope: @mut ~[NodeId],\n     // mappings from loop node ID to LiveNode\n     // (\"break\" label should map to loop node ID,\n     // it probably doesn't now)\n@@ -586,7 +586,7 @@ fn Liveness(ir: @mut IrMaps, specials: Specials) -> Liveness {\n }\n \n impl Liveness {\n-    pub fn live_node(&self, node_id: node_id, span: span) -> LiveNode {\n+    pub fn live_node(&self, node_id: NodeId, span: span) -> LiveNode {\n         let ir: &mut IrMaps = self.ir;\n         match ir.live_node_map.find(&node_id) {\n           Some(&ln) => ln,\n@@ -614,11 +614,11 @@ impl Liveness {\n         }\n     }\n \n-    pub fn variable(&self, node_id: node_id, span: span) -> Variable {\n+    pub fn variable(&self, node_id: NodeId, span: span) -> Variable {\n         self.ir.variable(node_id, span)\n     }\n \n-    pub fn variable_from_def_map(&self, node_id: node_id, span: span)\n+    pub fn variable_from_def_map(&self, node_id: NodeId, span: span)\n                                  -> Option<Variable> {\n         match self.tcx.def_map.find(&node_id) {\n           Some(&def) => {\n@@ -635,7 +635,7 @@ impl Liveness {\n \n     pub fn pat_bindings(&self,\n                         pat: @pat,\n-                        f: &fn(LiveNode, Variable, span, node_id)) {\n+                        f: &fn(LiveNode, Variable, span, NodeId)) {\n         let def_map = self.tcx.def_map;\n         do pat_util::pat_bindings(def_map, pat) |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n@@ -646,7 +646,7 @@ impl Liveness {\n \n     pub fn arm_pats_bindings(&self,\n                              pats: &[@pat],\n-                             f: &fn(LiveNode, Variable, span, node_id)) {\n+                             f: &fn(LiveNode, Variable, span, NodeId)) {\n         // only consider the first pattern; any later patterns must have\n         // the same bindings, and we also consider the first pattern to be\n         // the \"authoratative\" set of ids\n@@ -741,9 +741,9 @@ impl Liveness {\n \n     pub fn find_loop_scope(&self,\n                            opt_label: Option<ident>,\n-                           id: node_id,\n+                           id: NodeId,\n                            sp: span)\n-                           -> node_id {\n+                           -> NodeId {\n         match opt_label {\n             Some(_) => // Refers to a labeled loop. Use the results of resolve\n                       // to find with one\n@@ -765,7 +765,7 @@ impl Liveness {\n         }\n     }\n \n-    pub fn last_loop_scope(&self) -> node_id {\n+    pub fn last_loop_scope(&self) -> NodeId {\n         let loop_scope = &mut *self.loop_scope;\n         *loop_scope.last()\n     }\n@@ -1388,7 +1388,7 @@ impl Liveness {\n     }\n \n     pub fn with_loop_nodes<R>(&self,\n-                              loop_node_id: node_id,\n+                              loop_node_id: NodeId,\n                               break_ln: LiveNode,\n                               cont_ln: LiveNode,\n                               f: &fn() -> R)\n@@ -1491,7 +1491,7 @@ fn check_expr(expr: @expr, (this, vt): (@Liveness, vt<@Liveness>)) {\n }\n \n fn check_fn(_fk: &visit::fn_kind, _decl: &fn_decl,\n-            _body: &Block, _sp: span, _id: node_id,\n+            _body: &Block, _sp: span, _id: NodeId,\n             (_self, _v): (@Liveness, vt<@Liveness>)) {\n     // do not check contents of nested fns\n }\n@@ -1505,7 +1505,7 @@ enum ReadKind {\n \n impl Liveness {\n     pub fn check_ret(&self,\n-                     id: node_id,\n+                     id: NodeId,\n                      sp: span,\n                      _fk: &visit::fn_kind,\n                      entry_ln: LiveNode) {\n@@ -1618,7 +1618,7 @@ impl Liveness {\n \n     pub fn warn_about_unused(&self,\n                              sp: span,\n-                             id: node_id,\n+                             id: NodeId,\n                              ln: LiveNode,\n                              var: Variable)\n                              -> bool {\n@@ -1652,7 +1652,7 @@ impl Liveness {\n \n     pub fn warn_about_dead_assign(&self,\n                                   sp: span,\n-                                  id: node_id,\n+                                  id: NodeId,\n                                   ln: LiveNode,\n                                   var: Variable) {\n         if self.live_on_exit(ln, var).is_none() {"}, {"sha": "1c5f3b9bfdf184f4f53765a2c9d8060eef812a16", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -60,25 +60,25 @@ use syntax::print::pprust;\n \n #[deriving(Eq)]\n pub enum categorization {\n-    cat_rvalue(ast::node_id),          // temporary val, argument is its scope\n+    cat_rvalue(ast::NodeId),          // temporary val, argument is its scope\n     cat_static_item,\n     cat_implicit_self,\n     cat_copied_upvar(CopiedUpvar),     // upvar copied into @fn or ~fn env\n     cat_stack_upvar(cmt),              // by ref upvar from &fn\n-    cat_local(ast::node_id),           // local variable\n-    cat_arg(ast::node_id),             // formal argument\n+    cat_local(ast::NodeId),           // local variable\n+    cat_arg(ast::NodeId),             // formal argument\n     cat_deref(cmt, uint, ptr_kind),    // deref of a ptr\n     cat_interior(cmt, InteriorKind),   // something interior: field, tuple, etc\n     cat_downcast(cmt),                 // selects a particular enum variant (*)\n-    cat_discr(cmt, ast::node_id),      // match discriminant (see preserve())\n-    cat_self(ast::node_id),            // explicit `self`\n+    cat_discr(cmt, ast::NodeId),      // match discriminant (see preserve())\n+    cat_self(ast::NodeId),            // explicit `self`\n \n     // (*) downcast is only required if the enum has more than one variant\n }\n \n #[deriving(Eq)]\n pub struct CopiedUpvar {\n-    upvar_id: ast::node_id,\n+    upvar_id: ast::NodeId,\n     onceness: ast::Onceness,\n }\n \n@@ -136,7 +136,7 @@ pub enum MutabilityCategory {\n // fashion. For more details, see the method `cat_pattern`\n #[deriving(Eq)]\n pub struct cmt_ {\n-    id: ast::node_id,          // id of expr/pat producing this value\n+    id: ast::NodeId,          // id of expr/pat producing this value\n     span: span,                // span of same expr/pat\n     cat: categorization,       // categorization of expr\n     mutbl: MutabilityCategory, // mutability of expr as lvalue\n@@ -252,7 +252,7 @@ pub fn cat_expr_autoderefd(\n pub fn cat_def(\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n-    expr_id: ast::node_id,\n+    expr_id: ast::NodeId,\n     expr_span: span,\n     expr_ty: ty::t,\n     def: ast::def) -> cmt {\n@@ -264,17 +264,17 @@ pub fn cat_def(\n }\n \n pub trait ast_node {\n-    fn id(&self) -> ast::node_id;\n+    fn id(&self) -> ast::NodeId;\n     fn span(&self) -> span;\n }\n \n impl ast_node for @ast::expr {\n-    fn id(&self) -> ast::node_id { self.id }\n+    fn id(&self) -> ast::NodeId { self.id }\n     fn span(&self) -> span { self.span }\n }\n \n impl ast_node for @ast::pat {\n-    fn id(&self) -> ast::node_id { self.id }\n+    fn id(&self) -> ast::NodeId { self.id }\n     fn span(&self) -> span { self.span }\n }\n \n@@ -439,7 +439,7 @@ impl mem_categorization_ctxt {\n     }\n \n     pub fn cat_def(&self,\n-                   id: ast::node_id,\n+                   id: ast::NodeId,\n                    span: span,\n                    expr_ty: ty::t,\n                    def: ast::def)\n@@ -587,9 +587,9 @@ impl mem_categorization_ctxt {\n     }\n \n     pub fn cat_rvalue(&self,\n-                      cmt_id: ast::node_id,\n+                      cmt_id: ast::NodeId,\n                       span: span,\n-                      cleanup_scope_id: ast::node_id,\n+                      cleanup_scope_id: ast::NodeId,\n                       expr_ty: ty::t) -> cmt {\n         @cmt_ {\n             id:cmt_id,\n@@ -1069,7 +1069,7 @@ impl mem_categorization_ctxt {\n pub fn field_mutbl(tcx: ty::ctxt,\n                    base_ty: ty::t,\n                    f_name: ast::ident,\n-                   node_id: ast::node_id)\n+                   node_id: ast::NodeId)\n                 -> Option<ast::mutability> {\n     // Need to refactor so that struct/enum fields can be treated uniformly.\n     match ty::get(base_ty).sty {"}, {"sha": "1cf0162d784dc3c4a9867d27f155de86ffe92d04", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -157,17 +157,17 @@ pub struct CaptureVar {\n     mode: CaptureMode // How variable is being accessed\n }\n \n-pub type CaptureMap = @mut HashMap<node_id, @[CaptureVar]>;\n+pub type CaptureMap = @mut HashMap<NodeId, @[CaptureVar]>;\n \n-pub type MovesMap = @mut HashSet<node_id>;\n+pub type MovesMap = @mut HashSet<NodeId>;\n \n /**\n  * Set of variable node-ids that are moved.\n  *\n  * Note: The `VariableMovesMap` stores expression ids that\n  * are moves, whereas this set stores the ids of the variables\n  * that are moved at some point */\n-pub type MovedVariablesSet = @mut HashSet<node_id>;\n+pub type MovedVariablesSet = @mut HashSet<NodeId>;\n \n /** See the section Output on the module comment for explanation. */\n #[deriving(Clone)]\n@@ -213,7 +213,7 @@ pub fn compute_moves(tcx: ty::ctxt,\n     return visit_cx.move_maps;\n }\n \n-pub fn moved_variable_node_id_from_def(def: def) -> Option<node_id> {\n+pub fn moved_variable_node_id_from_def(def: def) -> Option<NodeId> {\n     match def {\n       def_binding(nid, _) |\n       def_arg(nid, _) |\n@@ -240,7 +240,7 @@ fn compute_modes_for_fn(fk: &visit::fn_kind,\n                         decl: &fn_decl,\n                         body: &Block,\n                         span: span,\n-                        id: node_id,\n+                        id: NodeId,\n                         (cx, v): (VisitContext,\n                                   vt<VisitContext>)) {\n     for decl.inputs.iter().advance |a| {\n@@ -634,7 +634,7 @@ impl VisitContext {\n     }\n \n     pub fn use_fn_args(&self,\n-                       _: node_id,\n+                       _: NodeId,\n                        arg_exprs: &[@expr],\n                        visitor: vt<VisitContext>) {\n         //! Uses the argument expressions.\n@@ -664,7 +664,7 @@ impl VisitContext {\n         return None;\n     }\n \n-    pub fn compute_captures(&self, fn_expr_id: node_id) -> @[CaptureVar] {\n+    pub fn compute_captures(&self, fn_expr_id: NodeId) -> @[CaptureVar] {\n         debug!(\"compute_capture_vars(fn_expr_id=%?)\", fn_expr_id);\n         let _indenter = indenter();\n "}, {"sha": "6991c38799dc9d930b5b918ace6385e207d30b6b", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -16,10 +16,10 @@ use syntax::ast::*;\n use syntax::ast_util::{path_to_ident, walk_pat};\n use syntax::codemap::span;\n \n-pub type PatIdMap = HashMap<ident, node_id>;\n+pub type PatIdMap = HashMap<ident, NodeId>;\n \n // This is used because same-named variables in alternative patterns need to\n-// use the node_id of their namesake in the first pattern.\n+// use the NodeId of their namesake in the first pattern.\n pub fn pat_id_map(dm: resolve::DefMap, pat: @pat) -> PatIdMap {\n     let mut map = HashMap::new();\n     do pat_bindings(dm, pat) |_bm, p_id, _s, n| {\n@@ -71,7 +71,7 @@ pub fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: @pat) -> bool {\n }\n \n pub fn pat_bindings(dm: resolve::DefMap, pat: @pat,\n-                    it: &fn(binding_mode, node_id, span, &Path)) {\n+                    it: &fn(binding_mode, NodeId, span, &Path)) {\n     for walk_pat(pat) |p| {\n         match p.node {\n           pat_ident(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {\n@@ -82,7 +82,7 @@ pub fn pat_bindings(dm: resolve::DefMap, pat: @pat,\n     }\n }\n \n-pub fn pat_binding_ids(dm: resolve::DefMap, pat: @pat) -> ~[node_id] {\n+pub fn pat_binding_ids(dm: resolve::DefMap, pat: @pat) -> ~[NodeId] {\n     let mut found = ~[];\n     pat_bindings(dm, pat, |_bm, b_id, _sp, _pt| found.push(b_id) );\n     return found;"}, {"sha": "521eb8a95b0b6fb1542cc4499f6dfbecc54fd0ca", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -23,7 +23,7 @@ use syntax::ast::{decl_item, def, def_fn, def_id, def_static_method};\n use syntax::ast::{def_variant, expr_field, expr_method_call, expr_path};\n use syntax::ast::{expr_struct, expr_unary, ident, inherited, item_enum};\n use syntax::ast::{item_foreign_mod, item_fn, item_impl, item_struct};\n-use syntax::ast::{item_trait, local_crate, node_id, pat_struct, Path};\n+use syntax::ast::{item_trait, LOCAL_CRATE, NodeId, pat_struct, Path};\n use syntax::ast::{private, provided, public, required, stmt_decl, visibility};\n use syntax::ast;\n use syntax::ast_map::{node_foreign_item, node_item, node_method};\n@@ -106,7 +106,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n     };\n \n     // Returns true if a crate-local method is private and false otherwise.\n-    let method_is_private: @fn(span: span, method_id: node_id) -> bool =\n+    let method_is_private: @fn(span: span, method_id: NodeId) -> bool =\n             |span, method_id| {\n         let check = |vis: visibility, container_id: def_id| {\n             let mut is_private = false;\n@@ -116,7 +116,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                 is_private = false;\n             } else {\n                 // Look up the enclosing impl.\n-                if container_id.crate != local_crate {\n+                if container_id.crate != LOCAL_CRATE {\n                     tcx.sess.span_bug(span,\n                                       \"local method isn't in local \\\n                                        impl?!\");\n@@ -170,9 +170,9 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n     };\n \n     // Returns true if the given local item is private and false otherwise.\n-    let local_item_is_private: @fn(span: span, item_id: node_id) -> bool =\n+    let local_item_is_private: @fn(span: span, item_id: NodeId) -> bool =\n             |span, item_id| {\n-        let mut f: &fn(node_id) -> bool = |_| false;\n+        let mut f: &fn(NodeId) -> bool = |_| false;\n         f = |item_id| {\n             match tcx.items.find(&item_id) {\n                 Some(&node_item(item, _)) => item.vis != public,\n@@ -227,11 +227,11 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n         let method_id = ty::method(tcx, method_id).provided_source\n             .get_or_default(method_id);\n \n-        if method_id.crate == local_crate {\n+        if method_id.crate == LOCAL_CRATE {\n             let is_private = method_is_private(span, method_id.node);\n             let container_id = ty::method(tcx, method_id).container_id;\n             if is_private &&\n-                    (container_id.crate != local_crate ||\n+                    (container_id.crate != LOCAL_CRATE ||\n                      !privileged_items.iter().any(|x| x == &(container_id.node))) {\n                 tcx.sess.span_err(span,\n                                   fmt!(\"method `%s` is private\",\n@@ -258,7 +258,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                 check_method_common(span, method_id, path.idents.last())\n             }\n             def_fn(def_id, _) => {\n-                if def_id.crate == local_crate {\n+                if def_id.crate == LOCAL_CRATE {\n                     if local_item_is_private(span, def_id.node) &&\n                             !privileged_items.iter().any(|x| x == &def_id.node) {\n                         tcx.sess.span_err(span,\n@@ -291,7 +291,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                  _\n             }) |\n             method_trait(trait_id, method_num, _) => {\n-                if trait_id.crate == local_crate {\n+                if trait_id.crate == LOCAL_CRATE {\n                     match tcx.items.find(&trait_id.node) {\n                         Some(&node_item(item, _)) => {\n                             match item.node {\n@@ -386,7 +386,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                     match ty::get(ty::type_autoderef(tcx, ty::expr_ty(tcx,\n                                                           base))).sty {\n                         ty_struct(id, _)\n-                        if id.crate != local_crate || !privileged_items.iter()\n+                        if id.crate != LOCAL_CRATE || !privileged_items.iter()\n                                 .any(|x| x == &(id.node)) => {\n                             debug!(\"(privacy checking) checking field access\");\n                             check_field(expr.span, id, ident);\n@@ -399,7 +399,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                     match ty::get(ty::type_autoderef(tcx, ty::expr_ty(tcx,\n                                                           base))).sty {\n                         ty_struct(id, _)\n-                        if id.crate != local_crate ||\n+                        if id.crate != LOCAL_CRATE ||\n                            !privileged_items.iter().any(|x| x == &(id.node)) => {\n                             match method_map.find(&expr.id) {\n                                 None => {\n@@ -423,7 +423,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                 expr_struct(_, ref fields, _) => {\n                     match ty::get(ty::expr_ty(tcx, expr)).sty {\n                         ty_struct(id, _) => {\n-                            if id.crate != local_crate ||\n+                            if id.crate != LOCAL_CRATE ||\n                                     !privileged_items.iter().any(|x| x == &(id.node)) {\n                                 for (*fields).iter().advance |field| {\n                                         debug!(\"(privacy checking) checking \\\n@@ -433,7 +433,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                             }\n                         }\n                         ty_enum(id, _) => {\n-                            if id.crate != local_crate ||\n+                            if id.crate != LOCAL_CRATE ||\n                                     !privileged_items.iter().any(|x| x == &(id.node)) {\n                                 match tcx.def_map.get_copy(&expr.id) {\n                                     def_variant(_, variant_id) => {\n@@ -469,7 +469,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                     // since typeck already happened.)\n                     match ty::get(ty::expr_ty(tcx, operand)).sty {\n                         ty_enum(id, _) => {\n-                            if id.crate != local_crate ||\n+                            if id.crate != LOCAL_CRATE ||\n                                 !privileged_items.iter().any(|x| x == &(id.node)) {\n                                 check_variant(expr.span, id);\n                             }\n@@ -487,7 +487,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                 pat_struct(_, ref fields, _) => {\n                     match ty::get(ty::pat_ty(tcx, pattern)).sty {\n                         ty_struct(id, _) => {\n-                            if id.crate != local_crate ||\n+                            if id.crate != LOCAL_CRATE ||\n                                     !privileged_items.iter().any(|x| x == &(id.node)) {\n                                 for fields.iter().advance |field| {\n                                         debug!(\"(privacy checking) checking \\\n@@ -497,7 +497,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                             }\n                         }\n                         ty_enum(enum_id, _) => {\n-                            if enum_id.crate != local_crate ||\n+                            if enum_id.crate != LOCAL_CRATE ||\n                                     !privileged_items.iter().any(|x| x == &enum_id.node) {\n                                 match tcx.def_map.find(&pattern.id) {\n                                     Some(&def_variant(_, variant_id)) => {"}, {"sha": "1d9708bb82d2d8e2d8bfc3d4ae49661689eeb818", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -59,7 +59,7 @@ fn item_might_be_inlined(item: @item) -> bool {\n \n // Returns true if the given type method must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`.\n-fn ty_method_might_be_inlined(ty_method: &ty_method) -> bool {\n+fn ty_method_might_be_inlined(ty_method: &TypeMethod) -> bool {\n     attributes_specify_inlining(ty_method.attrs) ||\n         generics_require_inlining(&ty_method.generics)\n }\n@@ -90,10 +90,10 @@ struct ReachableContext {\n     // methods they've been resolved to.\n     method_map: typeck::method_map,\n     // The set of items which must be exported in the linkage sense.\n-    reachable_symbols: @mut HashSet<node_id>,\n+    reachable_symbols: @mut HashSet<NodeId>,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n     // and will be scanned for further references.\n-    worklist: @mut ~[node_id],\n+    worklist: @mut ~[NodeId],\n }\n \n impl ReachableContext {\n@@ -216,7 +216,7 @@ impl ReachableContext {\n     // eligible for inlining and false otherwise.\n     fn def_id_represents_local_inlined_item(tcx: ty::ctxt, def_id: def_id)\n                                             -> bool {\n-        if def_id.crate != local_crate {\n+        if def_id.crate != LOCAL_CRATE {\n             return false\n         }\n \n@@ -241,7 +241,7 @@ impl ReachableContext {\n                 } else {\n                     // Check the impl. If the generics on the self type of the\n                     // impl require inlining, this method does too.\n-                    assert!(impl_did.crate == local_crate);\n+                    assert!(impl_did.crate == LOCAL_CRATE);\n                     match tcx.items.find(&impl_did.node) {\n                         Some(&ast_map::node_item(item, _)) => {\n                             match item.node {\n@@ -394,7 +394,7 @@ impl ReachableContext {\n     fn mark_destructors_reachable(&self) {\n         for self.tcx.destructor_for_type.iter().advance\n                 |(_, destructor_def_id)| {\n-            if destructor_def_id.crate == local_crate {\n+            if destructor_def_id.crate == LOCAL_CRATE {\n                 self.reachable_symbols.insert(destructor_def_id.node);\n             }\n         }\n@@ -404,7 +404,7 @@ impl ReachableContext {\n pub fn find_reachable(tcx: ty::ctxt,\n                       method_map: typeck::method_map,\n                       crate: @Crate)\n-                      -> @mut HashSet<node_id> {\n+                      -> @mut HashSet<NodeId> {\n     // XXX(pcwalton): We only need to mark symbols that are exported. But this\n     // is more complicated than just looking at whether the symbol is `pub`,\n     // because it might be the target of a `pub use` somewhere. For now, I"}, {"sha": "d1c32bfd4b7b3537dceeadcb64e4043e53f2cd38", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -55,9 +55,9 @@ The region maps encode information about region relationships.\n     necessarily how I think things ought to work\n */\n pub struct RegionMaps {\n-    priv scope_map: HashMap<ast::node_id, ast::node_id>,\n+    priv scope_map: HashMap<ast::NodeId, ast::NodeId>,\n     priv free_region_map: HashMap<FreeRegion, ~[FreeRegion]>,\n-    priv cleanup_scopes: HashSet<ast::node_id>\n+    priv cleanup_scopes: HashSet<ast::NodeId>\n }\n \n #[deriving(Clone)]\n@@ -69,10 +69,10 @@ pub struct Context {\n     region_maps: @mut RegionMaps,\n \n     // Scope where variables should be parented to\n-    var_parent: Option<ast::node_id>,\n+    var_parent: Option<ast::NodeId>,\n \n     // Innermost enclosing expression\n-    parent: Option<ast::node_id>,\n+    parent: Option<ast::NodeId>,\n }\n \n impl RegionMaps {\n@@ -92,14 +92,14 @@ impl RegionMaps {\n         self.free_region_map.insert(sub, ~[sup]);\n     }\n \n-    pub fn record_parent(&mut self, sub: ast::node_id, sup: ast::node_id) {\n+    pub fn record_parent(&mut self, sub: ast::NodeId, sup: ast::NodeId) {\n         debug!(\"record_parent(sub=%?, sup=%?)\", sub, sup);\n         assert!(sub != sup);\n \n         self.scope_map.insert(sub, sup);\n     }\n \n-    pub fn record_cleanup_scope(&mut self, scope_id: ast::node_id) {\n+    pub fn record_cleanup_scope(&mut self, scope_id: ast::NodeId) {\n         //! Records that a scope is a CLEANUP SCOPE.  This is invoked\n         //! from within regionck.  We wait until regionck because we do\n         //! not know which operators are overloaded until that point,\n@@ -108,13 +108,13 @@ impl RegionMaps {\n         self.cleanup_scopes.insert(scope_id);\n     }\n \n-    pub fn opt_encl_scope(&self, id: ast::node_id) -> Option<ast::node_id> {\n+    pub fn opt_encl_scope(&self, id: ast::NodeId) -> Option<ast::NodeId> {\n         //! Returns the narrowest scope that encloses `id`, if any.\n \n         self.scope_map.find(&id).map(|&x| *x)\n     }\n \n-    pub fn encl_scope(&self, id: ast::node_id) -> ast::node_id {\n+    pub fn encl_scope(&self, id: ast::NodeId) -> ast::NodeId {\n         //! Returns the narrowest scope that encloses `id`, if any.\n \n         match self.scope_map.find(&id) {\n@@ -123,11 +123,11 @@ impl RegionMaps {\n         }\n     }\n \n-    pub fn is_cleanup_scope(&self, scope_id: ast::node_id) -> bool {\n+    pub fn is_cleanup_scope(&self, scope_id: ast::NodeId) -> bool {\n         self.cleanup_scopes.contains(&scope_id)\n     }\n \n-    pub fn cleanup_scope(&self, expr_id: ast::node_id) -> ast::node_id {\n+    pub fn cleanup_scope(&self, expr_id: ast::NodeId) -> ast::NodeId {\n         //! Returns the scope when temps in expr will be cleaned up\n \n         let mut id = self.encl_scope(expr_id);\n@@ -137,21 +137,21 @@ impl RegionMaps {\n         return id;\n     }\n \n-    pub fn encl_region(&self, id: ast::node_id) -> ty::Region {\n+    pub fn encl_region(&self, id: ast::NodeId) -> ty::Region {\n         //! Returns the narrowest scope region that encloses `id`, if any.\n \n         ty::re_scope(self.encl_scope(id))\n     }\n \n-    pub fn scopes_intersect(&self, scope1: ast::node_id, scope2: ast::node_id)\n+    pub fn scopes_intersect(&self, scope1: ast::NodeId, scope2: ast::NodeId)\n                             -> bool {\n         self.is_subscope_of(scope1, scope2) ||\n         self.is_subscope_of(scope2, scope1)\n     }\n \n     pub fn is_subscope_of(&self,\n-                          subscope: ast::node_id,\n-                          superscope: ast::node_id)\n+                          subscope: ast::NodeId,\n+                          superscope: ast::NodeId)\n                           -> bool {\n         /*!\n          * Returns true if `subscope` is equal to or is lexically\n@@ -254,9 +254,9 @@ impl RegionMaps {\n     }\n \n     pub fn nearest_common_ancestor(&self,\n-                                   scope_a: ast::node_id,\n-                                   scope_b: ast::node_id)\n-                                   -> Option<ast::node_id> {\n+                                   scope_a: ast::NodeId,\n+                                   scope_b: ast::NodeId)\n+                                   -> Option<ast::NodeId> {\n         /*!\n          * Finds the nearest common ancestor (if any) of two scopes.  That\n          * is, finds the smallest scope which is greater than or equal to\n@@ -294,8 +294,8 @@ impl RegionMaps {\n             }\n         }\n \n-        fn ancestors_of(this: &RegionMaps, scope: ast::node_id)\n-            -> ~[ast::node_id]\n+        fn ancestors_of(this: &RegionMaps, scope: ast::NodeId)\n+            -> ~[ast::NodeId]\n         {\n             // debug!(\"ancestors_of(scope=%d)\", scope);\n             let mut result = ~[scope];\n@@ -315,7 +315,7 @@ impl RegionMaps {\n }\n \n /// Records the current parent (if any) as the parent of `child_id`.\n-fn parent_to_expr(cx: Context, child_id: ast::node_id, sp: span) {\n+fn parent_to_expr(cx: Context, child_id: ast::NodeId, sp: span) {\n     debug!(\"region::parent_to_expr(span=%?)\",\n            cx.sess.codemap.span_to_str(sp));\n     for cx.parent.iter().advance |parent_id| {\n@@ -416,7 +416,7 @@ fn resolve_fn(fk: &visit::fn_kind,\n               decl: &ast::fn_decl,\n               body: &ast::Block,\n               sp: span,\n-              id: ast::node_id,\n+              id: ast::NodeId,\n               (cx, visitor): (Context,\n                               visit::vt<Context>)) {\n     debug!(\"region::resolve_fn(id=%?, \\\n@@ -503,24 +503,24 @@ pub fn resolve_crate(sess: Session,\n // a worklist.  We can then process the worklist, propagating indirect\n // dependencies until a fixed point is reached.\n \n-pub type region_paramd_items = @mut HashMap<ast::node_id, region_variance>;\n+pub type region_paramd_items = @mut HashMap<ast::NodeId, region_variance>;\n \n #[deriving(Eq)]\n pub struct region_dep {\n     ambient_variance: region_variance,\n-    id: ast::node_id\n+    id: ast::NodeId\n }\n \n pub struct DetermineRpCtxt {\n     sess: Session,\n     ast_map: ast_map::map,\n     def_map: resolve::DefMap,\n     region_paramd_items: region_paramd_items,\n-    dep_map: @mut HashMap<ast::node_id, @mut ~[region_dep]>,\n-    worklist: ~[ast::node_id],\n+    dep_map: @mut HashMap<ast::NodeId, @mut ~[region_dep]>,\n+    worklist: ~[ast::NodeId],\n \n     // the innermost enclosing item id\n-    item_id: ast::node_id,\n+    item_id: ast::NodeId,\n \n     // true when we are within an item but not within a method.\n     // see long discussion on region_is_relevant().\n@@ -572,7 +572,7 @@ impl DetermineRpCtxt {\n     /// Records that item `id` is region-parameterized with the\n     /// variance `variance`.  If `id` was already parameterized, then\n     /// the new variance is joined with the old variance.\n-    pub fn add_rp(&mut self, id: ast::node_id, variance: region_variance) {\n+    pub fn add_rp(&mut self, id: ast::NodeId, variance: region_variance) {\n         assert!(id != 0);\n         let old_variance = self.region_paramd_items.find(&id).\n                                 map_consume(|x| *x);\n@@ -598,7 +598,7 @@ impl DetermineRpCtxt {\n     /// `from`.  Put another way, it indicates that the current item\n     /// contains a value of type `from`, so if `from` is\n     /// region-parameterized, so is the current item.\n-    pub fn add_dep(&mut self, from: ast::node_id) {\n+    pub fn add_dep(&mut self, from: ast::NodeId) {\n         debug!(\"add dependency from %d -> %d (%s -> %s) with variance %?\",\n                from, self.item_id,\n                ast_map::node_id_to_str(self.ast_map, from,\n@@ -670,7 +670,7 @@ impl DetermineRpCtxt {\n     }\n \n     pub fn with(@mut self,\n-                item_id: ast::node_id,\n+                item_id: ast::NodeId,\n                 anon_implies_rp: bool,\n                 f: &fn()) {\n         let old_item_id = self.item_id;\n@@ -708,7 +708,7 @@ fn determine_rp_in_fn(fk: &visit::fn_kind,\n                       decl: &ast::fn_decl,\n                       body: &ast::Block,\n                       _: span,\n-                      _: ast::node_id,\n+                      _: ast::NodeId,\n                       (cx, visitor): (@mut DetermineRpCtxt,\n                                       visit::vt<@mut DetermineRpCtxt>)) {\n     do cx.with(cx.item_id, false) {\n@@ -724,7 +724,7 @@ fn determine_rp_in_fn(fk: &visit::fn_kind,\n     }\n }\n \n-fn determine_rp_in_ty_method(ty_m: &ast::ty_method,\n+fn determine_rp_in_ty_method(ty_m: &ast::TypeMethod,\n                              (cx, visitor): (@mut DetermineRpCtxt,\n                                              visit::vt<@mut DetermineRpCtxt>)) {\n     do cx.with(cx.item_id, false) {\n@@ -790,7 +790,7 @@ fn determine_rp_in_ty(ty: &ast::Ty,\n           Some(&ast::def_ty(did)) |\n           Some(&ast::def_trait(did)) |\n           Some(&ast::def_struct(did)) => {\n-            if did.crate == ast::local_crate {\n+            if did.crate == ast::LOCAL_CRATE {\n                 if cx.region_is_relevant(&path.rp) {\n                     cx.add_dep(did.node);\n                 }"}, {"sha": "4f7a2f67b3cf554df7359179aafd99166ce13fe0", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -45,7 +45,7 @@ use std::hashmap::{HashMap, HashSet};\n use std::util;\n \n // Definition mapping\n-pub type DefMap = @mut HashMap<node_id,def>;\n+pub type DefMap = @mut HashMap<NodeId,def>;\n \n pub struct binding_info {\n     span: span,\n@@ -56,11 +56,11 @@ pub struct binding_info {\n pub type BindingMap = HashMap<ident,binding_info>;\n \n // Trait method resolution\n-pub type TraitMap = HashMap<node_id,@mut ~[def_id]>;\n+pub type TraitMap = HashMap<NodeId,@mut ~[def_id]>;\n \n // This is the replacement export map. It maps a module to all of the exports\n // within.\n-pub type ExportMap2 = @mut HashMap<node_id, ~[Export2]>;\n+pub type ExportMap2 = @mut HashMap<NodeId, ~[Export2]>;\n \n pub struct Export2 {\n     name: @str,        // The name of the target.\n@@ -128,7 +128,7 @@ pub enum Mutability {\n \n pub enum SelfBinding {\n     NoSelfBinding,\n-    HasSelfBinding(node_id, bool /* is implicit */)\n+    HasSelfBinding(NodeId, bool /* is implicit */)\n }\n \n pub type ResolveVisitor = vt<()>;\n@@ -163,7 +163,7 @@ impl<T> ResolveResult<T> {\n pub enum TypeParameters<'self> {\n     NoTypeParameters,                   //< No type parameters.\n     HasTypeParameters(&'self Generics,  //< Type parameters.\n-                      node_id,          //< ID of the enclosing item\n+                      NodeId,          //< ID of the enclosing item\n \n                       // The index to start numbering the type parameters at.\n                       // This is zero if this is the outermost set of type\n@@ -191,14 +191,14 @@ pub enum RibKind {\n \n     // We passed through a function scope at the given node ID. Translate\n     // upvars as appropriate.\n-    FunctionRibKind(node_id /* func id */, node_id /* body id */),\n+    FunctionRibKind(NodeId /* func id */, NodeId /* body id */),\n \n     // We passed through an impl or trait and are now in one of its\n     // methods. Allow references to ty params that impl or trait\n     // binds. Disallow any other upvars (including other ty params that are\n     // upvars).\n               // parent;   method itself\n-    MethodRibKind(node_id, MethodSort),\n+    MethodRibKind(NodeId, MethodSort),\n \n     // We passed through a function *item* scope. Disallow upvars.\n     OpaqueFunctionRibKind,\n@@ -210,7 +210,7 @@ pub enum RibKind {\n // Methods can be required or provided. Required methods only occur in traits.\n pub enum MethodSort {\n     Required,\n-    Provided(node_id)\n+    Provided(NodeId)\n }\n \n // The X-ray flag indicates that a context has the X-ray privilege, which\n@@ -304,14 +304,14 @@ pub struct ImportDirective {\n     module_path: ~[ident],\n     subclass: @ImportDirectiveSubclass,\n     span: span,\n-    id: node_id,\n+    id: NodeId,\n }\n \n pub fn ImportDirective(privacy: Privacy,\n                        module_path: ~[ident],\n                        subclass: @ImportDirectiveSubclass,\n                        span: span,\n-                       id: node_id)\n+                       id: NodeId)\n                     -> ImportDirective {\n     ImportDirective {\n         privacy: privacy,\n@@ -352,17 +352,17 @@ pub struct ImportResolution {\n     value_target: Option<Target>,\n     /// The source node of the `use` directive leading to the value target\n     /// being non-none\n-    value_id: node_id,\n+    value_id: NodeId,\n \n     /// The type that this `use` directive names, if there is one.\n     type_target: Option<Target>,\n     /// The source node of the `use` directive leading to the type target\n     /// being non-none\n-    type_id: node_id,\n+    type_id: NodeId,\n }\n \n pub fn ImportResolution(privacy: Privacy,\n-                        id: node_id) -> ImportResolution {\n+                        id: NodeId) -> ImportResolution {\n     ImportResolution {\n         privacy: privacy,\n         type_id: id,\n@@ -382,7 +382,7 @@ impl ImportResolution {\n         }\n     }\n \n-    fn id(&self, namespace: Namespace) -> node_id {\n+    fn id(&self, namespace: Namespace) -> NodeId {\n         match namespace {\n             TypeNS  => self.type_id,\n             ValueNS => self.value_id,\n@@ -394,7 +394,7 @@ impl ImportResolution {\n pub enum ParentLink {\n     NoParentLink,\n     ModuleParentLink(@mut Module, ident),\n-    BlockParentLink(@mut Module, node_id)\n+    BlockParentLink(@mut Module, NodeId)\n }\n \n /// The type of module this is.\n@@ -434,7 +434,7 @@ pub struct Module {\n     //\n     // There will be an anonymous module created around `g` with the ID of the\n     // entry block for `f`.\n-    anonymous_children: @mut HashMap<node_id,@mut Module>,\n+    anonymous_children: @mut HashMap<NodeId,@mut Module>,\n \n     // The status of resolving each import in this module.\n     import_resolutions: @mut HashMap<ident, @mut ImportResolution>,\n@@ -868,7 +868,7 @@ pub struct Resolver {\n     export_map2: ExportMap2,\n     trait_map: TraitMap,\n \n-    used_imports: HashSet<node_id>,\n+    used_imports: HashSet<NodeId>,\n }\n \n impl Resolver {\n@@ -1903,7 +1903,7 @@ impl Resolver {\n                                   module_path: ~[ident],\n                                   subclass: @ImportDirectiveSubclass,\n                                   span: span,\n-                                  id: node_id) {\n+                                  id: NodeId) {\n         let directive = @ImportDirective(privacy, module_path,\n                                          subclass, span, id);\n         module_.imports.push(directive);\n@@ -2428,7 +2428,7 @@ impl Resolver {\n                                privacy: Privacy,\n                                module_: @mut Module,\n                                containing_module: @mut Module,\n-                               id: node_id)\n+                               id: NodeId)\n                                -> ResolveResult<()> {\n         // This function works in a highly imperative manner; it eagerly adds\n         // everything it can to the list of import resolutions of the module\n@@ -3145,7 +3145,7 @@ impl Resolver {\n         // exports for nonlocal crates.\n \n         match module_.def_id {\n-            Some(def_id) if def_id.crate == local_crate => {\n+            Some(def_id) if def_id.crate == LOCAL_CRATE => {\n                 // OK. Continue.\n                 debug!(\"(recording exports for module subtree) recording \\\n                         exports for local module `%s`\",\n@@ -3791,7 +3791,7 @@ impl Resolver {\n     }\n \n     pub fn resolve_type_parameter_bound(@mut self,\n-                                        id: node_id,\n+                                        id: NodeId,\n                                         type_parameter_bound: &TyParamBound,\n                                         visitor: ResolveVisitor) {\n         match *type_parameter_bound {\n@@ -3803,7 +3803,7 @@ impl Resolver {\n     }\n \n     pub fn resolve_trait_reference(@mut self,\n-                                   id: node_id,\n+                                   id: NodeId,\n                                    trait_reference: &trait_ref,\n                                    visitor: ResolveVisitor,\n                                    reference_type: TraitReferenceType) {\n@@ -3828,7 +3828,7 @@ impl Resolver {\n     }\n \n     pub fn resolve_struct(@mut self,\n-                          id: node_id,\n+                          id: NodeId,\n                           generics: &Generics,\n                           fields: &[@struct_field],\n                           visitor: ResolveVisitor) {\n@@ -3896,7 +3896,7 @@ impl Resolver {\n     }\n \n     pub fn resolve_implementation(@mut self,\n-                                  id: node_id,\n+                                  id: NodeId,\n                                   generics: &Generics,\n                                   opt_trait_reference: &Option<trait_ref>,\n                                   self_type: &Ty,\n@@ -3976,7 +3976,7 @@ impl Resolver {\n                           module_: &_mod,\n                           span: span,\n                           _name: ident,\n-                          id: node_id,\n+                          id: NodeId,\n                           visitor: ResolveVisitor) {\n         // Write the implementations in scope into the module metadata.\n         debug!(\"(resolving module) resolving module ID %d\", id);\n@@ -4192,7 +4192,7 @@ impl Resolver {\n                            mutability: Mutability,\n                            // Maps idents to the node ID for the (outermost)\n                            // pattern that binds them\n-                           bindings_list: Option<@mut HashMap<ident,node_id>>,\n+                           bindings_list: Option<@mut HashMap<ident,NodeId>>,\n                            visitor: ResolveVisitor) {\n         let pat_id = pattern.id;\n         for walk_pat(pattern) |pattern| {\n@@ -4470,7 +4470,7 @@ impl Resolver {\n     /// If `check_ribs` is true, checks the local definitions first; i.e.\n     /// doesn't skip straight to the containing module.\n     pub fn resolve_path(@mut self,\n-                        id: node_id,\n+                        id: NodeId,\n                         path: &Path,\n                         namespace: Namespace,\n                         check_ribs: bool,\n@@ -5250,7 +5250,7 @@ impl Resolver {\n     }\n \n     pub fn add_fixed_trait_for_expr(@mut self,\n-                                    expr_id: node_id,\n+                                    expr_id: NodeId,\n                                     trait_id: Option<def_id>) {\n         match trait_id {\n             Some(trait_id) => {\n@@ -5260,7 +5260,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn record_def(@mut self, node_id: node_id, def: def) {\n+    pub fn record_def(@mut self, node_id: NodeId, def: def) {\n         debug!(\"(recording def) recording %? for %?\", def, node_id);\n         self.def_map.insert(node_id, def);\n     }"}, {"sha": "9668f1ec46e3d36eee18046ceebbacbc3f028ce2", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -184,7 +184,7 @@ use syntax::print::pprust::pat_to_str;\n // An option identifying a literal: either a unit-like struct or an\n // expression.\n pub enum Lit {\n-    UnitLikeStructLit(ast::node_id),    // the node ID of the pattern\n+    UnitLikeStructLit(ast::NodeId),    // the node ID of the pattern\n     ExprLit(@ast::expr),\n     ConstLit(ast::def_id),              // the def ID of the constant\n }\n@@ -292,7 +292,7 @@ pub fn trans_opt(bcx: @mut Block, o: &Opt) -> opt_result {\n     }\n }\n \n-pub fn variant_opt(bcx: @mut Block, pat_id: ast::node_id)\n+pub fn variant_opt(bcx: @mut Block, pat_id: ast::NodeId)\n     -> Opt {\n     let ccx = bcx.ccx();\n     match ccx.tcx.def_map.get_copy(&pat_id) {\n@@ -334,7 +334,7 @@ pub enum TransBindingMode {\n pub struct BindingInfo {\n     llmatch: ValueRef,\n     trmode: TransBindingMode,\n-    id: ast::node_id,\n+    id: ast::NodeId,\n     ty: ty::t,\n }\n \n@@ -885,7 +885,7 @@ pub fn extract_variant_args(bcx: @mut Block,\n     ExtractedBlock { vals: args, bcx: bcx }\n }\n \n-fn match_datum(bcx: @mut Block, val: ValueRef, pat_id: ast::node_id) -> Datum {\n+fn match_datum(bcx: @mut Block, val: ValueRef, pat_id: ast::NodeId) -> Datum {\n     //! Helper for converting from the ValueRef that we pass around in\n     //! the match code, which is always by ref, into a Datum. Eventually\n     //! we should just pass around a Datum and be done with it.\n@@ -897,7 +897,7 @@ fn match_datum(bcx: @mut Block, val: ValueRef, pat_id: ast::node_id) -> Datum {\n \n pub fn extract_vec_elems(bcx: @mut Block,\n                          pat_span: span,\n-                         pat_id: ast::node_id,\n+                         pat_id: ast::NodeId,\n                          elem_count: uint,\n                          slice: Option<uint>,\n                          val: ValueRef,\n@@ -1871,7 +1871,7 @@ pub fn store_arg(mut bcx: @mut Block,\n }\n \n fn mk_binding_alloca(mut bcx: @mut Block,\n-                     p_id: ast::node_id,\n+                     p_id: ast::NodeId,\n                      path: &ast::Path,\n                      binding_mode: IrrefutablePatternBindingMode,\n                      populate: &fn(@mut Block, ty::t, ValueRef) -> @mut Block) -> @mut Block {"}, {"sha": "70b204621b082a91fa01ce4c8c7a4f9f0f04507a", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -106,7 +106,7 @@ pub struct Struct {\n  * these, for places in trans where the `ty::t` isn't directly\n  * available.\n  */\n-pub fn represent_node(bcx: @mut Block, node: ast::node_id) -> @Repr {\n+pub fn represent_node(bcx: @mut Block, node: ast::NodeId) -> @Repr {\n     represent_type(bcx.ccx(), node_id_type(bcx, node))\n }\n "}, {"sha": "7d7f78379a449d5afc390d90363a3021c9d2d8e5", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -509,12 +509,12 @@ pub fn get_res_dtor(ccx: @mut CrateContext,\n                  -> ValueRef {\n     let _icx = push_ctxt(\"trans_res_dtor\");\n     if !substs.is_empty() {\n-        let did = if did.crate != ast::local_crate {\n+        let did = if did.crate != ast::LOCAL_CRATE {\n             inline::maybe_instantiate_inline(ccx, did)\n         } else {\n             did\n         };\n-        assert_eq!(did.crate, ast::local_crate);\n+        assert_eq!(did.crate, ast::LOCAL_CRATE);\n         let tsubsts = ty::substs {regions: ty::ErasedRegions,\n                                   self_ty: None,\n                                   tps: /*bad*/ substs.to_owned() };\n@@ -526,7 +526,7 @@ pub fn get_res_dtor(ccx: @mut CrateContext,\n                                                     None);\n \n         val\n-    } else if did.crate == ast::local_crate {\n+    } else if did.crate == ast::LOCAL_CRATE {\n         get_item_val(ccx, did.node)\n     } else {\n         let tcx = ccx.tcx;\n@@ -1012,7 +1012,7 @@ pub fn get_landing_pad(bcx: @mut Block) -> BasicBlockRef {\n     return pad_bcx.llbb;\n }\n \n-pub fn find_bcx_for_scope(bcx: @mut Block, scope_id: ast::node_id) -> @mut Block {\n+pub fn find_bcx_for_scope(bcx: @mut Block, scope_id: ast::NodeId) -> @mut Block {\n     let mut bcx_sid = bcx;\n     let mut cur_scope = bcx_sid.scope;\n     loop {\n@@ -1617,7 +1617,7 @@ pub fn make_return_pointer(fcx: @mut FunctionContext, output_type: ty::t) -> Val\n pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n                         path: path,\n                         llfndecl: ValueRef,\n-                        id: ast::node_id,\n+                        id: ast::NodeId,\n                         output_type: ty::t,\n                         skip_retptr: bool,\n                         param_substs: Option<@param_substs>,\n@@ -1838,7 +1838,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n                      llfndecl: ValueRef,\n                      self_arg: self_arg,\n                      param_substs: Option<@param_substs>,\n-                     id: ast::node_id,\n+                     id: ast::NodeId,\n                      attributes: &[ast::Attribute],\n                      output_type: ty::t,\n                      maybe_load_env: &fn(@mut FunctionContext),\n@@ -1919,7 +1919,7 @@ pub fn trans_fn(ccx: @mut CrateContext,\n                 llfndecl: ValueRef,\n                 self_arg: self_arg,\n                 param_substs: Option<@param_substs>,\n-                id: ast::node_id,\n+                id: ast::NodeId,\n                 attrs: &[ast::Attribute]) {\n \n     let the_path_str = path_str(ccx.sess, path);\n@@ -1976,7 +1976,7 @@ fn insert_synthetic_type_entries(bcx: @mut Block,\n }\n \n pub fn trans_enum_variant(ccx: @mut CrateContext,\n-                          _enum_id: ast::node_id,\n+                          _enum_id: ast::NodeId,\n                           variant: &ast::variant,\n                           args: &[ast::variant_arg],\n                           disr: uint,\n@@ -1995,7 +1995,7 @@ pub fn trans_enum_variant(ccx: @mut CrateContext,\n \n pub fn trans_tuple_struct(ccx: @mut CrateContext,\n                           fields: &[@ast::struct_field],\n-                          ctor_id: ast::node_id,\n+                          ctor_id: ast::NodeId,\n                           param_substs: Option<@param_substs>,\n                           llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_tuple_struct\");\n@@ -2010,23 +2010,23 @@ pub fn trans_tuple_struct(ccx: @mut CrateContext,\n }\n \n trait IdAndTy {\n-    fn id(&self) -> ast::node_id;\n+    fn id(&self) -> ast::NodeId;\n     fn ty<'a>(&'a self) -> &'a ast::Ty;\n }\n \n impl IdAndTy for ast::variant_arg {\n-    fn id(&self) -> ast::node_id { self.id }\n+    fn id(&self) -> ast::NodeId { self.id }\n     fn ty<'a>(&'a self) -> &'a ast::Ty { &self.ty }\n }\n \n impl IdAndTy for @ast::struct_field {\n-    fn id(&self) -> ast::node_id { self.node.id }\n+    fn id(&self) -> ast::NodeId { self.node.id }\n     fn ty<'a>(&'a self) -> &'a ast::Ty { &self.node.ty }\n }\n \n pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n     ccx: @mut CrateContext,\n-    ctor_id: ast::node_id,\n+    ctor_id: ast::NodeId,\n     args: &[A],\n     disr: uint,\n     param_substs: Option<@param_substs>,\n@@ -2104,7 +2104,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n }\n \n pub fn trans_enum_def(ccx: @mut CrateContext, enum_definition: &ast::enum_def,\n-                      id: ast::node_id, vi: @~[@ty::VariantInfo],\n+                      id: ast::NodeId, vi: @~[@ty::VariantInfo],\n                       i: &mut uint) {\n     for enum_definition.variants.iter().advance |variant| {\n         let disr_val = vi[*i].disr_val;\n@@ -2245,7 +2245,7 @@ pub fn trans_mod(ccx: @mut CrateContext, m: &ast::_mod) {\n pub fn register_fn(ccx: @mut CrateContext,\n                    sp: span,\n                    sym: ~str,\n-                   node_id: ast::node_id)\n+                   node_id: ast::NodeId)\n                 -> ValueRef {\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n     register_fn_full(ccx, sp, sym, node_id, t)\n@@ -2254,7 +2254,7 @@ pub fn register_fn(ccx: @mut CrateContext,\n pub fn register_fn_full(ccx: @mut CrateContext,\n                         sp: span,\n                         sym: ~str,\n-                        node_id: ast::node_id,\n+                        node_id: ast::NodeId,\n                         node_type: ty::t)\n                      -> ValueRef {\n     let llfty = type_of_fn_from_ty(ccx, node_type);\n@@ -2265,7 +2265,7 @@ pub fn register_fn_full(ccx: @mut CrateContext,\n pub fn register_fn_fuller(ccx: @mut CrateContext,\n                           sp: span,\n                           sym: ~str,\n-                          node_id: ast::node_id,\n+                          node_id: ast::NodeId,\n                           node_type: ty::t,\n                           cc: lib::llvm::CallConv,\n                           fn_ty: Type)\n@@ -2287,7 +2287,7 @@ pub fn register_fn_fuller(ccx: @mut CrateContext,\n     llfn\n }\n \n-pub fn is_entry_fn(sess: &Session, node_id: ast::node_id) -> bool {\n+pub fn is_entry_fn(sess: &Session, node_id: ast::NodeId) -> bool {\n     match *sess.entry_fn {\n         Some((entry_id, _)) => node_id == entry_id,\n         None => false\n@@ -2367,7 +2367,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n                     Ok(id) => id,\n                     Err(s) => { ccx.tcx.sess.fatal(s); }\n                 };\n-                let start_fn = if start_def_id.crate == ast::local_crate {\n+                let start_fn = if start_def_id.crate == ast::LOCAL_CRATE {\n                     get_item_val(ccx, start_def_id.node)\n                 } else {\n                     let start_fn_type = csearch::get_type(ccx.tcx,\n@@ -2421,7 +2421,7 @@ pub fn fill_fn_pair(bcx: @mut Block, pair: ValueRef, llfn: ValueRef,\n     Store(bcx, llenvblobptr, env_cell);\n }\n \n-pub fn item_path(ccx: &CrateContext, id: &ast::node_id) -> path {\n+pub fn item_path(ccx: &CrateContext, id: &ast::NodeId) -> path {\n     match ccx.tcx.items.get_copy(id) {\n         ast_map::node_item(i, p) =>\n             vec::append((*p).clone(), [path_name(i.ident)]),\n@@ -2438,7 +2438,7 @@ fn exported_name(ccx: @mut CrateContext, path: path, ty: ty::t, attrs: &[ast::At\n     }\n }\n \n-pub fn get_item_val(ccx: @mut CrateContext, id: ast::node_id) -> ValueRef {\n+pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n     debug!(\"get_item_val(id=`%?`)\", id);\n \n     let val = ccx.item_vals.find_copy(&id);\n@@ -2601,7 +2601,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::node_id) -> ValueRef {\n }\n \n pub fn register_method(ccx: @mut CrateContext,\n-                       id: ast::node_id,\n+                       id: ast::NodeId,\n                        path: @ast_map::path,\n                        m: @ast::method) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx, id);\n@@ -2623,7 +2623,7 @@ pub fn trans_constant(ccx: &mut CrateContext, it: @ast::item) {\n     match it.node {\n       ast::item_enum(ref enum_definition, _) => {\n         let vi = ty::enum_variants(ccx.tcx,\n-                                   ast::def_id { crate: ast::local_crate,\n+                                   ast::def_id { crate: ast::LOCAL_CRATE,\n                                                  node: it.id });\n         let mut i = 0;\n         let path = item_path(ccx, &it.id);\n@@ -2870,7 +2870,7 @@ pub fn fill_crate_map(ccx: @mut CrateContext, map: ValueRef) {\n \n     let llannihilatefn = match ccx.tcx.lang_items.annihilate_fn() {\n         Some(annihilate_def_id) => {\n-            if annihilate_def_id.crate == ast::local_crate {\n+            if annihilate_def_id.crate == ast::LOCAL_CRATE {\n                 get_item_val(ccx, annihilate_def_id.node)\n             } else {\n                 let annihilate_fn_type = csearch::get_type(ccx.tcx,"}, {"sha": "845229c4eda58e59940b0fc9faf9582c0eb68c2d", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -157,14 +157,14 @@ pub fn trans(bcx: @mut Block, expr: @ast::expr) -> Callee {\n \n pub fn trans_fn_ref_to_callee(bcx: @mut Block,\n                               def_id: ast::def_id,\n-                              ref_id: ast::node_id) -> Callee {\n+                              ref_id: ast::NodeId) -> Callee {\n     Callee {bcx: bcx,\n             data: Fn(trans_fn_ref(bcx, def_id, ref_id))}\n }\n \n pub fn trans_fn_ref(bcx: @mut Block,\n                     def_id: ast::def_id,\n-                    ref_id: ast::node_id) -> FnData {\n+                    ref_id: ast::NodeId) -> FnData {\n     /*!\n      *\n      * Translates a reference (with id `ref_id`) to the fn/method\n@@ -184,7 +184,7 @@ pub fn trans_fn_ref(bcx: @mut Block,\n pub fn trans_fn_ref_with_vtables_to_callee(\n         bcx: @mut Block,\n         def_id: ast::def_id,\n-        ref_id: ast::node_id,\n+        ref_id: ast::NodeId,\n         type_params: &[ty::t],\n         vtables: Option<typeck::vtable_res>)\n      -> Callee {\n@@ -238,7 +238,7 @@ fn resolve_default_method_vtables(bcx: @mut Block,\n pub fn trans_fn_ref_with_vtables(\n         bcx: @mut Block,       //\n         def_id: ast::def_id,   // def id of fn\n-        ref_id: ast::node_id,  // node id of use of fn; may be zero if N/A\n+        ref_id: ast::NodeId,  // node id of use of fn; may be zero if N/A\n         type_params: &[ty::t], // values for fn's ty params\n         vtables: Option<typeck::vtable_res>) // vtables for the call\n      -> FnData {\n@@ -334,7 +334,7 @@ pub fn trans_fn_ref_with_vtables(\n     // Check whether this fn has an inlined copy and, if so, redirect\n     // def_id to the local id of the inlined copy.\n     let def_id = {\n-        if def_id.crate != ast::local_crate {\n+        if def_id.crate != ast::LOCAL_CRATE {\n             inline::maybe_instantiate_inline(ccx, def_id)\n         } else {\n             def_id\n@@ -348,7 +348,7 @@ pub fn trans_fn_ref_with_vtables(\n     let must_monomorphise;\n     if type_params.len() > 0 || is_default {\n         must_monomorphise = true;\n-    } else if def_id.crate == ast::local_crate {\n+    } else if def_id.crate == ast::LOCAL_CRATE {\n         let map_node = session::expect(\n             ccx.sess,\n             ccx.tcx.items.find(&def_id.node),\n@@ -369,7 +369,7 @@ pub fn trans_fn_ref_with_vtables(\n     // Create a monomorphic verison of generic functions\n     if must_monomorphise {\n         // Should be either intra-crate or inlined.\n-        assert_eq!(def_id.crate, ast::local_crate);\n+        assert_eq!(def_id.crate, ast::LOCAL_CRATE);\n \n         let (val, must_cast) =\n             monomorphize::monomorphic_fn(ccx, def_id, &substs,\n@@ -389,7 +389,7 @@ pub fn trans_fn_ref_with_vtables(\n \n     // Find the actual function pointer.\n     let val = {\n-        if def_id.crate == ast::local_crate {\n+        if def_id.crate == ast::LOCAL_CRATE {\n             // Internal reference.\n             get_item_val(ccx, def_id.node)\n         } else {\n@@ -408,7 +408,7 @@ pub fn trans_call(in_cx: @mut Block,\n                   call_ex: @ast::expr,\n                   f: @ast::expr,\n                   args: CallArgs,\n-                  id: ast::node_id,\n+                  id: ast::NodeId,\n                   dest: expr::Dest)\n                   -> @mut Block {\n     let _icx = push_ctxt(\"trans_call\");\n@@ -424,7 +424,7 @@ pub fn trans_call(in_cx: @mut Block,\n \n pub fn trans_method_call(in_cx: @mut Block,\n                          call_ex: @ast::expr,\n-                         callee_id: ast::node_id,\n+                         callee_id: ast::NodeId,\n                          rcvr: @ast::expr,\n                          args: CallArgs,\n                          dest: expr::Dest)\n@@ -465,7 +465,7 @@ pub fn trans_lang_call(bcx: @mut Block,\n                        args: &[ValueRef],\n                        dest: Option<expr::Dest>)\n     -> Result {\n-    let fty = if did.crate == ast::local_crate {\n+    let fty = if did.crate == ast::LOCAL_CRATE {\n         ty::node_id_to_type(bcx.ccx().tcx, did.node)\n     } else {\n         csearch::get_type(bcx.ccx().tcx, did).ty\n@@ -494,7 +494,7 @@ pub fn trans_lang_call_with_type_params(bcx: @mut Block,\n                                         dest: expr::Dest)\n     -> @mut Block {\n     let fty;\n-    if did.crate == ast::local_crate {\n+    if did.crate == ast::LOCAL_CRATE {\n         fty = ty::node_id_to_type(bcx.tcx(), did.node);\n     } else {\n         fty = csearch::get_type(bcx.tcx(), did).ty;"}, {"sha": "d9e9062a777e6409217f208ec63c2c33f72aa3cd", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -359,8 +359,8 @@ pub fn trans_expr_fn(bcx: @mut Block,\n                      sigil: ast::Sigil,\n                      decl: &ast::fn_decl,\n                      body: &ast::Block,\n-                     outer_id: ast::node_id,\n-                     user_id: ast::node_id,\n+                     outer_id: ast::NodeId,\n+                     user_id: ast::NodeId,\n                      is_loop_body: Option<Option<ValueRef>>,\n                      dest: expr::Dest) -> @mut Block {\n     /*!"}, {"sha": "8b2e5e39a82c13f4b8c445b99f2e4fec875f2e38", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -203,16 +203,16 @@ pub struct FunctionContext {\n     has_immediate_return_value: bool,\n \n     // Maps arguments to allocas created for them in llallocas.\n-    llargs: @mut HashMap<ast::node_id, ValueRef>,\n+    llargs: @mut HashMap<ast::NodeId, ValueRef>,\n     // Maps the def_ids for local variables to the allocas created for\n     // them in llallocas.\n-    lllocals: @mut HashMap<ast::node_id, ValueRef>,\n+    lllocals: @mut HashMap<ast::NodeId, ValueRef>,\n     // Same as above, but for closure upvars\n-    llupvars: @mut HashMap<ast::node_id, ValueRef>,\n+    llupvars: @mut HashMap<ast::NodeId, ValueRef>,\n \n-    // The node_id of the function, or -1 if it doesn't correspond to\n+    // The NodeId of the function, or -1 if it doesn't correspond to\n     // a user-defined function.\n-    id: ast::node_id,\n+    id: ast::NodeId,\n \n     // If this function is being monomorphized, this contains the type\n     // substitutions used.\n@@ -361,13 +361,13 @@ pub fn add_clean_temp_mem(bcx: @mut Block, val: ValueRef, t: ty::t) {\n }\n \n pub fn add_clean_temp_mem_in_scope(bcx: @mut Block,\n-                                   scope_id: ast::node_id,\n+                                   scope_id: ast::NodeId,\n                                    val: ValueRef,\n                                    t: ty::t) {\n     add_clean_temp_mem_in_scope_(bcx, Some(scope_id), val, t);\n }\n \n-pub fn add_clean_temp_mem_in_scope_(bcx: @mut Block, scope_id: Option<ast::node_id>,\n+pub fn add_clean_temp_mem_in_scope_(bcx: @mut Block, scope_id: Option<ast::NodeId>,\n                                     val: ValueRef, t: ty::t) {\n     if !ty::type_needs_drop(bcx.tcx(), t) { return; }\n     debug!(\"add_clean_temp_mem(%s, %s, %s)\",\n@@ -380,7 +380,7 @@ pub fn add_clean_temp_mem_in_scope_(bcx: @mut Block, scope_id: Option<ast::node_\n     }\n }\n pub fn add_clean_return_to_mut(bcx: @mut Block,\n-                               scope_id: ast::node_id,\n+                               scope_id: ast::NodeId,\n                                root_key: root_map_key,\n                                frozen_val_ref: ValueRef,\n                                bits_val_ref: ValueRef,\n@@ -504,8 +504,8 @@ impl get_node_info for Option<@ast::expr> {\n }\n \n pub struct NodeInfo {\n-    id: ast::node_id,\n-    callee_id: Option<ast::node_id>,\n+    id: ast::NodeId,\n+    callee_id: Option<ast::NodeId>,\n     span: span\n }\n \n@@ -563,7 +563,7 @@ impl Block {\n         token::ident_to_str(&ident)\n     }\n \n-    pub fn node_id_to_str(&self, id: ast::node_id) -> ~str {\n+    pub fn node_id_to_str(&self, id: ast::NodeId) -> ~str {\n         ast_map::node_id_to_str(self.tcx().items, id, self.sess().intr())\n     }\n \n@@ -579,7 +579,7 @@ impl Block {\n         ty::expr_kind(self.tcx(), self.ccx().maps.method_map, e)\n     }\n \n-    pub fn def(&self, nid: ast::node_id) -> ast::def {\n+    pub fn def(&self, nid: ast::NodeId) -> ast::def {\n         match self.tcx().def_map.find(&nid) {\n             Some(&v) => v,\n             None => {\n@@ -633,7 +633,7 @@ pub fn val_ty(v: ValueRef) -> Type {\n     }\n }\n \n-pub fn in_scope_cx(cx: @mut Block, scope_id: Option<ast::node_id>, f: &fn(si: &mut ScopeInfo)) {\n+pub fn in_scope_cx(cx: @mut Block, scope_id: Option<ast::NodeId>, f: &fn(si: &mut ScopeInfo)) {\n     let mut cur = cx;\n     let mut cur_scope = cur.scope;\n     loop {\n@@ -971,7 +971,7 @@ pub fn monomorphize_type(bcx: @mut Block, t: ty::t) -> ty::t {\n     }\n }\n \n-pub fn node_id_type(bcx: @mut Block, id: ast::node_id) -> ty::t {\n+pub fn node_id_type(bcx: @mut Block, id: ast::NodeId) -> ty::t {\n     let tcx = bcx.tcx();\n     let t = ty::node_id_to_type(tcx, id);\n     monomorphize_type(bcx, t)\n@@ -987,7 +987,7 @@ pub fn expr_ty_adjusted(bcx: @mut Block, ex: &ast::expr) -> ty::t {\n     monomorphize_type(bcx, t)\n }\n \n-pub fn node_id_type_params(bcx: @mut Block, id: ast::node_id) -> ~[ty::t] {\n+pub fn node_id_type_params(bcx: @mut Block, id: ast::NodeId) -> ~[ty::t] {\n     let tcx = bcx.tcx();\n     let params = ty::node_id_to_type_params(tcx, id);\n \n@@ -1007,7 +1007,7 @@ pub fn node_id_type_params(bcx: @mut Block, id: ast::node_id) -> ~[ty::t] {\n     }\n }\n \n-pub fn node_vtables(bcx: @mut Block, id: ast::node_id)\n+pub fn node_vtables(bcx: @mut Block, id: ast::NodeId)\n                  -> Option<typeck::vtable_res> {\n     let raw_vtables = bcx.ccx().maps.vtable_map.find(&id);\n     raw_vtables.map("}, {"sha": "a1ae29337a6b97c5a2ac5c88bb3445cd61c1820a", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -601,7 +601,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n     }\n }\n \n-pub fn trans_const(ccx: @mut CrateContext, m: ast::mutability, id: ast::node_id) {\n+pub fn trans_const(ccx: @mut CrateContext, m: ast::mutability, id: ast::NodeId) {\n     unsafe {\n         let _icx = push_ctxt(\"trans_const\");\n         let g = base::get_item_val(ccx, id);"}, {"sha": "802163583d6a1dacb8ee552cbf392403f5d7ca27", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -43,20 +43,20 @@ pub struct CrateContext {\n      tn: TypeNames,\n      externs: ExternMap,\n      intrinsics: HashMap<&'static str, ValueRef>,\n-     item_vals: HashMap<ast::node_id, ValueRef>,\n+     item_vals: HashMap<ast::NodeId, ValueRef>,\n      exp_map2: resolve::ExportMap2,\n-     reachable: @mut HashSet<ast::node_id>,\n-     item_symbols: HashMap<ast::node_id, ~str>,\n+     reachable: @mut HashSet<ast::NodeId>,\n+     item_symbols: HashMap<ast::NodeId, ~str>,\n      link_meta: LinkMeta,\n      enum_sizes: HashMap<ty::t, uint>,\n      discrims: HashMap<ast::def_id, ValueRef>,\n-     discrim_symbols: HashMap<ast::node_id, @str>,\n+     discrim_symbols: HashMap<ast::NodeId, @str>,\n      tydescs: HashMap<ty::t, @mut tydesc_info>,\n      // Set when running emit_tydescs to enforce that no more tydescs are\n      // created.\n      finished_tydescs: bool,\n      // Track mapping of external ids to local items imported for inlining\n-     external: HashMap<ast::def_id, Option<ast::node_id>>,\n+     external: HashMap<ast::def_id, Option<ast::NodeId>>,\n      // Cache instances of monomorphized functions\n      monomorphized: HashMap<mono_id, ValueRef>,\n      monomorphizing: HashMap<ast::def_id, uint>,\n@@ -78,7 +78,7 @@ pub struct CrateContext {\n      const_globals: HashMap<int, ValueRef>,\n \n      // Cache of emitted const values\n-     const_values: HashMap<ast::node_id, ValueRef>,\n+     const_values: HashMap<ast::NodeId, ValueRef>,\n \n      // Cache of external const values\n      extern_const_values: HashMap<ast::def_id, ValueRef>,\n@@ -119,7 +119,7 @@ impl CrateContext {\n                maps: astencode::Maps,\n                symbol_hasher: hash::State,\n                link_meta: LinkMeta,\n-               reachable: @mut HashSet<ast::node_id>)\n+               reachable: @mut HashSet<ast::NodeId>)\n                -> CrateContext {\n         unsafe {\n             let llcx = llvm::LLVMContextCreate();"}, {"sha": "c8a09ce87c0a15beeb32eb8ad4735a3ea02619b6", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -614,7 +614,7 @@ impl Datum {\n     pub fn try_deref(&self,\n                      bcx: @mut Block,\n                      span: span,\n-                     expr_id: ast::node_id,\n+                     expr_id: ast::NodeId,\n                      derefs: uint,\n                      is_auto: bool)\n                      -> (Option<Datum>, @mut Block) {\n@@ -740,7 +740,7 @@ impl Datum {\n     pub fn autoderef(&self,\n                      bcx: @mut Block,\n                      span: span,\n-                     expr_id: ast::node_id,\n+                     expr_id: ast::NodeId,\n                      max: uint)\n                      -> DatumBlock {\n         let _icx = push_ctxt(\"autoderef\");\n@@ -773,7 +773,7 @@ impl Datum {\n     pub fn get_vec_base_and_len(&self,\n                                 mut bcx: @mut Block,\n                                 span: span,\n-                                expr_id: ast::node_id,\n+                                expr_id: ast::NodeId,\n                                 derefs: uint)\n                                 -> (@mut Block, ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair. Performs rooting\n@@ -797,7 +797,7 @@ impl Datum {\n     pub fn root_and_write_guard(&self,\n                                 bcx: @mut Block,\n                                 span: span,\n-                                expr_id: ast::node_id,\n+                                expr_id: ast::NodeId,\n                                 derefs: uint)\n                                 -> @mut Block {\n         write_guard::root_and_write_guard(self, bcx, span, expr_id, derefs)"}, {"sha": "e31a27a4c6ca0a035e2dcf9e2e158833e6bf13f8", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -96,10 +96,10 @@ pub struct DebugContext {\n     priv builder: DIBuilderRef,\n     priv curr_loc: (uint, uint),\n     priv created_files: HashMap<~str, DIFile>,\n-    priv created_functions: HashMap<ast::node_id, DISubprogram>,\n-    priv created_blocks: HashMap<ast::node_id, DILexicalBlock>,\n+    priv created_functions: HashMap<ast::NodeId, DISubprogram>,\n+    priv created_blocks: HashMap<ast::NodeId, DILexicalBlock>,\n     priv created_types: HashMap<uint, DIType>,\n-    priv last_function_context_id: ast::node_id,\n+    priv last_function_context_id: ast::NodeId,\n     priv argument_counter: uint,\n }\n "}, {"sha": "b657f162cc3c0390dda94b7eb316c52603a84f28", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -943,7 +943,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n \n                 fn get_did(ccx: @mut CrateContext, did: ast::def_id)\n                     -> ast::def_id {\n-                    if did.crate != ast::local_crate {\n+                    if did.crate != ast::LOCAL_CRATE {\n                         inline::maybe_instantiate_inline(ccx, did)\n                     } else {\n                         did\n@@ -953,7 +953,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n                 fn get_val(bcx: @mut Block, did: ast::def_id, const_ty: ty::t)\n                            -> ValueRef {\n                     // For external constants, we don't inline.\n-                    if did.crate == ast::local_crate {\n+                    if did.crate == ast::LOCAL_CRATE {\n                         // The LLVM global has the type of its initializer,\n                         // which may not be equal to the enum's type for\n                         // non-C-like enums.\n@@ -1057,8 +1057,8 @@ pub fn trans_local_var(bcx: @mut Block, def: ast::def) -> Datum {\n     };\n \n     fn take_local(bcx: @mut Block,\n-                  table: &HashMap<ast::node_id, ValueRef>,\n-                  nid: ast::node_id) -> Datum {\n+                  table: &HashMap<ast::NodeId, ValueRef>,\n+                  nid: ast::NodeId) -> Datum {\n         let v = match table.find(&nid) {\n             Some(&v) => v,\n             None => {\n@@ -1082,7 +1082,7 @@ pub fn trans_local_var(bcx: @mut Block, def: ast::def) -> Datum {\n // is and `node_id_opt` is none, this function fails).\n pub fn with_field_tys<R>(tcx: ty::ctxt,\n                          ty: ty::t,\n-                         node_id_opt: Option<ast::node_id>,\n+                         node_id_opt: Option<ast::NodeId>,\n                          op: &fn(uint, (&[ty::field])) -> R) -> R {\n     match ty::get(ty).sty {\n         ty::ty_struct(did, ref substs) => {\n@@ -1127,7 +1127,7 @@ fn trans_rec_or_struct(bcx: @mut Block,\n                        fields: &[ast::Field],\n                        base: Option<@ast::expr>,\n                        expr_span: codemap::span,\n-                       id: ast::node_id,\n+                       id: ast::NodeId,\n                        dest: Dest) -> @mut Block\n {\n     let _icx = push_ctxt(\"trans_rec\");\n@@ -1529,7 +1529,7 @@ fn trans_binary(bcx: @mut Block,\n \n fn trans_overloaded_op(bcx: @mut Block,\n                        expr: &ast::expr,\n-                       callee_id: ast::node_id,\n+                       callee_id: ast::NodeId,\n                        rcvr: @ast::expr,\n                        args: ~[@ast::expr],\n                        ret_ty: ty::t,\n@@ -1605,7 +1605,7 @@ pub fn cast_type_kind(t: ty::t) -> cast_kind {\n }\n \n fn trans_imm_cast(bcx: @mut Block, expr: @ast::expr,\n-                  id: ast::node_id) -> DatumBlock {\n+                  id: ast::NodeId) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_cast\");\n     let ccx = bcx.ccx();\n \n@@ -1668,7 +1668,7 @@ fn trans_imm_cast(bcx: @mut Block, expr: @ast::expr,\n \n fn trans_assign_op(bcx: @mut Block,\n                    expr: @ast::expr,\n-                   callee_id: ast::node_id,\n+                   callee_id: ast::NodeId,\n                    op: ast::binop,\n                    dst: @ast::expr,\n                    src: @ast::expr) -> @mut Block"}, {"sha": "a6fc20669101f815845d0fa09c5fd10b0ea62a29", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -108,7 +108,7 @@ fn foreign_signature(ccx: &mut CrateContext, fn_sig: &ty::FnSig)\n     }\n }\n \n-fn shim_types(ccx: @mut CrateContext, id: ast::node_id) -> ShimTypes {\n+fn shim_types(ccx: @mut CrateContext, id: ast::NodeId) -> ShimTypes {\n     let fn_sig = match ty::get(ty::node_id_to_type(ccx.tcx, id)).sty {\n         ty::ty_bare_fn(ref fn_ty) => fn_ty.sig.clone(),\n         _ => ccx.sess.bug(\"c_arg_and_ret_lltys called on non-function type\")\n@@ -338,7 +338,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n     }\n \n     fn build_foreign_fn(ccx: @mut CrateContext,\n-                        id: ast::node_id,\n+                        id: ast::NodeId,\n                         foreign_item: @ast::foreign_item,\n                         cc: lib::llvm::CallConv) {\n         let llwrapfn = get_item_val(ccx, id);\n@@ -537,7 +537,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                        path: ast_map::path,\n                        substs: @param_substs,\n                        attributes: &[ast::Attribute],\n-                       ref_id: Option<ast::node_id>) {\n+                       ref_id: Option<ast::NodeId>) {\n     debug!(\"trans_intrinsic(item.ident=%s)\", ccx.sess.str_of(item.ident));\n \n     fn simple_llvm_intrinsic(bcx: @mut Block, name: &'static str, num_args: uint) {\n@@ -975,14 +975,14 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n                         decl: &ast::fn_decl,\n                         body: &ast::Block,\n                         llwrapfn: ValueRef,\n-                        id: ast::node_id) {\n+                        id: ast::NodeId) {\n     let _icx = push_ctxt(\"foreign::build_foreign_fn\");\n \n     fn build_rust_fn(ccx: @mut CrateContext,\n                      path: &ast_map::path,\n                      decl: &ast::fn_decl,\n                      body: &ast::Block,\n-                     id: ast::node_id)\n+                     id: ast::NodeId)\n                   -> ValueRef {\n         let _icx = push_ctxt(\"foreign::foreign::build_rust_fn\");\n         let t = ty::node_id_to_type(ccx.tcx, id);\n@@ -1145,7 +1145,7 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n pub fn register_foreign_fn(ccx: @mut CrateContext,\n                            sp: span,\n                            sym: ~str,\n-                           node_id: ast::node_id)\n+                           node_id: ast::NodeId)\n                            -> ValueRef {\n     let _icx = push_ctxt(\"foreign::register_foreign_fn\");\n "}, {"sha": "3547745794e214dab1365aaadefd1a470b0b2cfa", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -48,7 +48,7 @@ pub fn trans_impl(ccx: @mut CrateContext,\n                   name: ast::ident,\n                   methods: &[@ast::method],\n                   generics: &ast::Generics,\n-                  id: ast::node_id) {\n+                  id: ast::NodeId) {\n     let _icx = push_ctxt(\"impl::trans_impl\");\n     let tcx = ccx.tcx;\n \n@@ -142,7 +142,7 @@ pub fn trans_self_arg(bcx: @mut Block,\n }\n \n pub fn trans_method_callee(bcx: @mut Block,\n-                           callee_id: ast::node_id,\n+                           callee_id: ast::NodeId,\n                            this: @ast::expr,\n                            mentry: typeck::method_map_entry)\n                            -> Callee {\n@@ -201,7 +201,7 @@ pub fn trans_method_callee(bcx: @mut Block,\n pub fn trans_static_method_callee(bcx: @mut Block,\n                                   method_id: ast::def_id,\n                                   trait_id: ast::def_id,\n-                                  callee_id: ast::node_id)\n+                                  callee_id: ast::NodeId)\n                                -> FnData {\n     let _icx = push_ctxt(\"impl::trans_static_method_callee\");\n     let ccx = bcx.ccx();\n@@ -229,7 +229,7 @@ pub fn trans_static_method_callee(bcx: @mut Block,\n     let bound_index = ty::lookup_trait_def(bcx.tcx(), trait_id).\n         generics.type_param_defs.len();\n \n-    let mname = if method_id.crate == ast::local_crate {\n+    let mname = if method_id.crate == ast::LOCAL_CRATE {\n         match bcx.tcx().items.get_copy(&method_id.node) {\n             ast_map::node_trait_method(trait_method, _, _) => {\n                 ast_util::trait_method_to_ty_method(trait_method).ident\n@@ -296,7 +296,7 @@ pub fn method_with_name(ccx: &mut CrateContext,\n }\n \n pub fn trans_monomorphized_callee(bcx: @mut Block,\n-                                  callee_id: ast::node_id,\n+                                  callee_id: ast::NodeId,\n                                   base: @ast::expr,\n                                   mentry: typeck::method_map_entry,\n                                   trait_id: ast::def_id,\n@@ -355,7 +355,7 @@ pub fn trans_monomorphized_callee(bcx: @mut Block,\n \n pub fn combine_impl_and_methods_tps(bcx: @mut Block,\n                                     mth_did: ast::def_id,\n-                                    callee_id: ast::node_id,\n+                                    callee_id: ast::NodeId,\n                                     rcvr_substs: &[ty::t],\n                                     rcvr_origins: typeck::vtable_res)\n                                     -> (~[ty::t], typeck::vtable_res) {\n@@ -404,7 +404,7 @@ pub fn combine_impl_and_methods_tps(bcx: @mut Block,\n \n \n pub fn trans_trait_callee(bcx: @mut Block,\n-                          callee_id: ast::node_id,\n+                          callee_id: ast::NodeId,\n                           n_method: uint,\n                           self_expr: @ast::expr,\n                           store: ty::TraitStore,\n@@ -662,7 +662,7 @@ pub fn make_impl_vtable(bcx: @mut Block,\n \n pub fn trans_trait_cast(bcx: @mut Block,\n                         val: @ast::expr,\n-                        id: ast::node_id,\n+                        id: ast::NodeId,\n                         dest: expr::Dest,\n                         _store: ty::TraitStore)\n                      -> @mut Block {"}, {"sha": "ac3e06e3495779a6c771746236f32a90424689a9", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -42,7 +42,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n                       real_substs: &ty::substs,\n                       vtables: Option<typeck::vtable_res>,\n                       self_vtables: Option<typeck::vtable_param_res>,\n-                      ref_id: Option<ast::node_id>)\n+                      ref_id: Option<ast::NodeId>)\n     -> (ValueRef, bool)\n {\n     debug!(\"monomorphic_fn(\\"}, {"sha": "003bf458bf16ced70d3e39102588f7fee705f563", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -72,7 +72,7 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n       None => ()\n     }\n \n-    let fn_id_loc = if fn_id.crate == local_crate {\n+    let fn_id_loc = if fn_id.crate == LOCAL_CRATE {\n         fn_id\n     } else {\n         inline::maybe_instantiate_inline(ccx, fn_id)\n@@ -93,7 +93,7 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n     let is_default = ty::provided_source(ccx.tcx, fn_id_loc).is_some();\n     // We also mark all of the params as used if it is an extern thing\n     // that we haven't been able to inline yet.\n-    if is_default || fn_id_loc.crate != local_crate {\n+    if is_default || fn_id_loc.crate != LOCAL_CRATE {\n         for uint::range(0u, n_tps) |n| { cx.uses[n] |= use_all; }\n         return store_type_uses(cx, fn_id);\n     }\n@@ -260,11 +260,11 @@ pub fn type_needs_inner(cx: &Context,\n     }\n }\n \n-pub fn node_type_needs(cx: &Context, use_: uint, id: node_id) {\n+pub fn node_type_needs(cx: &Context, use_: uint, id: NodeId) {\n     type_needs(cx, use_, ty::node_id_to_type(cx.ccx.tcx, id));\n }\n \n-pub fn mark_for_method_call(cx: &Context, e_id: node_id, callee_id: node_id) {\n+pub fn mark_for_method_call(cx: &Context, e_id: NodeId, callee_id: NodeId) {\n     let mut opt_static_did = None;\n     {\n         let r = cx.ccx.maps.method_map.find(&e_id);"}, {"sha": "182044c8d0dfdb9093c1cb581e55a750a2603381", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -36,7 +36,7 @@ use middle::trans::type_::Type;\n pub fn root_and_write_guard(datum: &Datum,\n                             mut bcx: @mut Block,\n                             span: span,\n-                            expr_id: ast::node_id,\n+                            expr_id: ast::NodeId,\n                             derefs: uint) -> @mut Block {\n     let key = root_map_key { id: expr_id, derefs: derefs };\n     debug!(\"write_guard::root_and_write_guard(key=%?)\", key);"}, {"sha": "050b6d3fddefc96736c69a432d580d7d907ff4bf", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -251,7 +251,7 @@ struct ctxt_ {\n     // of this node.  This only applies to nodes that refer to entities\n     // parameterized by type parameters, such as generic fns, types, or\n     // other items.\n-    node_type_substs: @mut HashMap<node_id, ~[t]>,\n+    node_type_substs: @mut HashMap<NodeId, ~[t]>,\n \n     // Maps from a method to the method \"descriptor\"\n     methods: @mut HashMap<def_id, @Method>,\n@@ -264,7 +264,7 @@ struct ctxt_ {\n \n     impl_trait_cache: @mut HashMap<ast::def_id, Option<@ty::TraitRef>>,\n \n-    trait_refs: @mut HashMap<node_id, @TraitRef>,\n+    trait_refs: @mut HashMap<NodeId, @TraitRef>,\n     trait_defs: @mut HashMap<def_id, @TraitDef>,\n \n     items: ast_map::map,\n@@ -276,10 +276,10 @@ struct ctxt_ {\n     short_names_cache: @mut HashMap<t, @str>,\n     needs_unwind_cleanup_cache: @mut HashMap<t, bool>,\n     tc_cache: @mut HashMap<uint, TypeContents>,\n-    ast_ty_to_ty_cache: @mut HashMap<node_id, ast_ty_to_ty_cache_entry>,\n+    ast_ty_to_ty_cache: @mut HashMap<NodeId, ast_ty_to_ty_cache_entry>,\n     enum_var_cache: @mut HashMap<def_id, @~[@VariantInfo]>,\n-    ty_param_defs: @mut HashMap<ast::node_id, TypeParameterDef>,\n-    adjustments: @mut HashMap<ast::node_id, @AutoAdjustment>,\n+    ty_param_defs: @mut HashMap<ast::NodeId, TypeParameterDef>,\n+    adjustments: @mut HashMap<ast::NodeId, @AutoAdjustment>,\n     normalized_cache: @mut HashMap<t, t>,\n     lang_items: middle::lang_items::LanguageItems,\n     // A mapping of fake provided method def_ids to the default implementation\n@@ -311,12 +311,12 @@ struct ctxt_ {\n \n     // Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     // present in this set can be warned about.\n-    used_unsafe: @mut HashSet<ast::node_id>,\n+    used_unsafe: @mut HashSet<ast::NodeId>,\n \n     // Set of nodes which mark locals as mutable which end up getting used at\n     // some point. Local variable definitions not in this set can be warned\n     // about.\n-    used_mut_nodes: @mut HashSet<ast::node_id>,\n+    used_mut_nodes: @mut HashSet<ast::NodeId>,\n \n     // vtable resolution information for impl declarations\n     impl_vtables: typeck::impl_vtable_map\n@@ -430,7 +430,7 @@ pub enum Region {\n     re_free(FreeRegion),\n \n     /// A concrete region naming some expression within the current function.\n-    re_scope(node_id),\n+    re_scope(NodeId),\n \n     /// Static data that has an \"infinite\" lifetime. Top in the region lattice.\n     re_static,\n@@ -459,7 +459,7 @@ impl Region {\n \n #[deriving(Clone, Eq, IterBytes, Encodable, Decodable)]\n pub struct FreeRegion {\n-    scope_id: node_id,\n+    scope_id: NodeId,\n     bound_region: bound_region\n }\n \n@@ -486,7 +486,7 @@ pub enum bound_region {\n      * enclosing scope, which may define the same names.  For an example of\n      * where this comes up, see src/test/compile-fail/regions-ret-borrowed.rs\n      * and regions-ret-borrowed-1.rs. */\n-    br_cap_avoid(ast::node_id, @bound_region),\n+    br_cap_avoid(ast::NodeId, @bound_region),\n }\n \n /**\n@@ -2135,7 +2135,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 // If this assertion failures, it is likely because of a\n                 // failure in the cross-crate inlining code to translate a\n                 // def-id.\n-                assert_eq!(p.def_id.crate, ast::local_crate);\n+                assert_eq!(p.def_id.crate, ast::LOCAL_CRATE);\n \n                 type_param_def_to_contents(\n                     cx, cx.ty_param_defs.get(&p.def_id.node))\n@@ -2732,7 +2732,7 @@ impl cmp::TotalEq for bound_region {\n     }\n }\n \n-pub fn node_id_to_trait_ref(cx: ctxt, id: ast::node_id) -> @ty::TraitRef {\n+pub fn node_id_to_trait_ref(cx: ctxt, id: ast::NodeId) -> @ty::TraitRef {\n     match cx.trait_refs.find(&id) {\n        Some(&t) => t,\n        None => cx.sess.bug(\n@@ -2742,7 +2742,7 @@ pub fn node_id_to_trait_ref(cx: ctxt, id: ast::node_id) -> @ty::TraitRef {\n     }\n }\n \n-pub fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n+pub fn node_id_to_type(cx: ctxt, id: ast::NodeId) -> t {\n     //printfln!(\"%?/%?\", id, cx.node_types.len());\n     match cx.node_types.find(&(id as uint)) {\n        Some(&t) => t,\n@@ -2754,14 +2754,14 @@ pub fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n }\n \n // XXX(pcwalton): Makes a copy, bleh. Probably better to not do that.\n-pub fn node_id_to_type_params(cx: ctxt, id: ast::node_id) -> ~[t] {\n+pub fn node_id_to_type_params(cx: ctxt, id: ast::NodeId) -> ~[t] {\n     match cx.node_type_substs.find(&id) {\n       None => return ~[],\n       Some(ts) => return (*ts).clone(),\n     }\n }\n \n-fn node_id_has_type_params(cx: ctxt, id: ast::node_id) -> bool {\n+fn node_id_has_type_params(cx: ctxt, id: ast::NodeId) -> bool {\n     cx.node_type_substs.contains_key(&id)\n }\n \n@@ -3079,7 +3079,7 @@ pub fn expr_has_ty_params(cx: ctxt, expr: &ast::expr) -> bool {\n \n pub fn method_call_type_param_defs(tcx: ctxt,\n                                    method_map: typeck::method_map,\n-                                   id: ast::node_id)\n+                                   id: ast::NodeId)\n                                    -> Option<@~[TypeParameterDef]> {\n     do method_map.find(&id).map |method| {\n         match method.origin {\n@@ -3260,7 +3260,7 @@ pub fn expr_kind(tcx: ctxt,\n     }\n }\n \n-pub fn stmt_node_id(s: &ast::stmt) -> ast::node_id {\n+pub fn stmt_node_id(s: &ast::stmt) -> ast::NodeId {\n     match s.node {\n       ast::stmt_decl(_, id) | stmt_expr(_, id) | stmt_semi(_, id) => {\n         return id;\n@@ -3616,7 +3616,7 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n         None => { }\n     }\n \n-    if def_id.crate == ast::local_crate {\n+    if def_id.crate == ast::LOCAL_CRATE {\n         fail!(\"No def'n found for %? in tcx.%s\", def_id, descr);\n     }\n     let v = load_external();\n@@ -3659,7 +3659,7 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::def_id) -> Option<@TraitRef> {\n         Some(&ret) => { return ret; }\n         None => {}\n     }\n-    let ret = if id.crate == ast::local_crate {\n+    let ret = if id.crate == ast::LOCAL_CRATE {\n         debug!(\"(impl_trait_ref) searching for trait impl %?\", id);\n         match cx.items.find(&id.node) {\n             Some(&ast_map::node_item(@ast::item {\n@@ -3691,7 +3691,7 @@ pub fn ty_to_def_id(ty: t) -> Option<ast::def_id> {\n /// None if the struct is not tuple-like. Fails if the given def ID does not\n /// refer to a struct at all.\n fn struct_ctor_id(cx: ctxt, struct_did: ast::def_id) -> Option<ast::def_id> {\n-    if struct_did.crate != ast::local_crate {\n+    if struct_did.crate != ast::LOCAL_CRATE {\n         // XXX: Cross-crate functionality.\n         cx.sess.unimpl(\"constructor ID of cross-crate tuple structs\");\n     }\n@@ -3841,7 +3841,7 @@ pub fn has_dtor(cx: ctxt, struct_id: def_id) -> bool {\n }\n \n pub fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n-    if id.crate != ast::local_crate {\n+    if id.crate != ast::LOCAL_CRATE {\n         csearch::get_item_path(cx, id)\n     } else {\n         // FIXME (#5521): uncomment this code and don't have a catch-all at the\n@@ -3910,7 +3910,7 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[@VariantInfo] {\n       _ => { /* fallthrough */ }\n     }\n \n-    let result = if ast::local_crate != id.crate {\n+    let result = if ast::LOCAL_CRATE != id.crate {\n         @csearch::get_enum_variants(cx, id)\n     } else {\n         /*\n@@ -4002,7 +4002,7 @@ pub fn lookup_trait_def(cx: ctxt, did: ast::def_id) -> @ty::TraitDef {\n             return trait_def;\n         }\n         None => {\n-            assert!(did.crate != ast::local_crate);\n+            assert!(did.crate != ast::LOCAL_CRATE);\n             let trait_def = @csearch::get_trait_def(cx, did);\n             cx.trait_defs.insert(did, trait_def);\n             return trait_def;\n@@ -4048,7 +4048,7 @@ pub fn lookup_field_type(tcx: ctxt,\n                          id: def_id,\n                          substs: &substs)\n                       -> ty::t {\n-    let t = if id.crate == ast::local_crate {\n+    let t = if id.crate == ast::LOCAL_CRATE {\n         node_id_to_type(tcx, id.node)\n     }\n     else {\n@@ -4067,7 +4067,7 @@ pub fn lookup_field_type(tcx: ctxt,\n // Look up the list of field names and IDs for a given struct\n // Fails if the id is not bound to a struct.\n pub fn lookup_struct_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n-  if did.crate == ast::local_crate {\n+  if did.crate == ast::LOCAL_CRATE {\n     match cx.items.find(&did.node) {\n        Some(&ast_map::node_item(i,_)) => {\n          match i.node {\n@@ -4360,10 +4360,10 @@ pub fn eval_repeat_count<T: ExprTyProvider>(tcx: &T, count_expr: &ast::expr) ->\n }\n \n // Determine what purity to check a nested function under\n-pub fn determine_inherited_purity(parent: (ast::purity, ast::node_id),\n-                                  child: (ast::purity, ast::node_id),\n+pub fn determine_inherited_purity(parent: (ast::purity, ast::NodeId),\n+                                  child: (ast::purity, ast::NodeId),\n                                   child_sigil: ast::Sigil)\n-                                    -> (ast::purity, ast::node_id) {\n+                                    -> (ast::purity, ast::NodeId) {\n     // If the closure is a stack closure and hasn't had some non-standard\n     // purity inferred for it, then check it under its parent's purity.\n     // Otherwise, use its own"}, {"sha": "5853d6b9b0a4323b8bdcf522122531b93777effc", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -323,7 +323,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n     }\n }\n \n-pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::node_id, span: span,\n+pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::NodeId, span: span,\n                         expected: ty::t, path: &ast::Path,\n                         fields: &[ast::field_pat], etc: bool,\n                         class_id: ast::def_id, substitutions: &ty::substs) {\n@@ -355,7 +355,7 @@ pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::node_id, span: span,\n }\n \n pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n-                                          pat_id: ast::node_id,\n+                                          pat_id: ast::NodeId,\n                                           span: span,\n                                           expected: ty::t,\n                                           path: &ast::Path,\n@@ -619,7 +619,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n pub fn check_pointer_pat(pcx: &pat_ctxt,\n                          pointer_kind: PointerKind,\n                          inner: @ast::pat,\n-                         pat_id: ast::node_id,\n+                         pat_id: ast::NodeId,\n                          span: span,\n                          expected: ty::t) {\n     let fcx = pcx.fcx;"}, {"sha": "0df3a0e839ba356f9708bca68d21617b0d7455fb", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -101,7 +101,7 @@ use std::uint;\n use std::vec;\n use extra::list::Nil;\n use syntax::ast::{def_id, sty_value, sty_region, sty_box};\n-use syntax::ast::{sty_uniq, sty_static, node_id};\n+use syntax::ast::{sty_uniq, sty_static, NodeId};\n use syntax::ast::{m_const, m_mutbl, m_imm};\n use syntax::ast;\n use syntax::ast_map;\n@@ -124,7 +124,7 @@ pub fn lookup(\n         // In a call `a.b::<X, Y, ...>(...)`:\n         expr: @ast::expr,                   // The expression `a.b(...)`.\n         self_expr: @ast::expr,              // The expression `a`.\n-        callee_id: node_id,                 /* Where to store `a.b`'s type,\n+        callee_id: NodeId,                  /* Where to store `a.b`'s type,\n                                              * also the scope of the call */\n         m_name: ast::ident,                 // The ident `b`.\n         self_ty: ty::t,                     // The type of `a`.\n@@ -157,7 +157,7 @@ pub struct LookupContext<'self> {\n     fcx: @mut FnCtxt,\n     expr: @ast::expr,\n     self_expr: @ast::expr,\n-    callee_id: node_id,\n+    callee_id: NodeId,\n     m_name: ast::ident,\n     supplied_tps: &'self [ty::t],\n     impl_dups: @mut HashSet<def_id>,\n@@ -1147,7 +1147,7 @@ impl<'self> LookupContext<'self> {\n     }\n \n     pub fn report_static_candidate(&self, idx: uint, did: def_id) {\n-        let span = if did.crate == ast::local_crate {\n+        let span = if did.crate == ast::LOCAL_CRATE {\n             match self.tcx().items.find(&did.node) {\n               Some(&ast_map::node_method(m, _, _)) => m.span,\n               _ => fail!(\"report_static_candidate: bad item %?\", did)"}, {"sha": "3c12b9b294f80f47d00f290e517bf8b8062b5daa", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -142,7 +142,7 @@ pub mod method;\n \n pub struct SelfInfo {\n     self_ty: ty::t,\n-    self_id: ast::node_id,\n+    self_id: ast::NodeId,\n     span: span\n }\n \n@@ -158,12 +158,12 @@ pub struct SelfInfo {\n /// share the inherited fields.\n pub struct inherited {\n     infcx: @mut infer::InferCtxt,\n-    locals: @mut HashMap<ast::node_id, ty::t>,\n+    locals: @mut HashMap<ast::NodeId, ty::t>,\n \n     // Temporary tables:\n-    node_types: @mut HashMap<ast::node_id, ty::t>,\n-    node_type_substs: @mut HashMap<ast::node_id, ty::substs>,\n-    adjustments: @mut HashMap<ast::node_id, @ty::AutoAdjustment>,\n+    node_types: @mut HashMap<ast::NodeId, ty::t>,\n+    node_type_substs: @mut HashMap<ast::NodeId, ty::substs>,\n+    adjustments: @mut HashMap<ast::NodeId, @ty::AutoAdjustment>,\n     method_map: method_map,\n     vtable_map: vtable_map,\n }\n@@ -183,13 +183,13 @@ pub enum FnKind {\n \n #[deriving(Clone)]\n pub struct PurityState {\n-    def: ast::node_id,\n+    def: ast::NodeId,\n     purity: ast::purity,\n     priv from_fn: bool\n }\n \n impl PurityState {\n-    pub fn function(purity: ast::purity, def: ast::node_id) -> PurityState {\n+    pub fn function(purity: ast::purity, def: ast::NodeId) -> PurityState {\n         PurityState { def: def, purity: purity, from_fn: true }\n     }\n \n@@ -203,8 +203,8 @@ impl PurityState {\n \n             purity => {\n                 let (purity, def) = match blk.rules {\n-                    ast::unsafe_blk => (ast::unsafe_fn, blk.id),\n-                    ast::default_blk => (purity, self.def),\n+                    ast::UnsafeBlock => (ast::unsafe_fn, blk.id),\n+                    ast::DefaultBlock => (purity, self.def),\n                 };\n                 PurityState{ def: def,\n                              purity: purity,\n@@ -247,7 +247,7 @@ pub struct FnCtxt {\n     // inference selects the ultimate value.  Finally, borrowck is\n     // charged with guaranteeing that the value whose address was taken\n     // can actually be made to live as long as it needs to live.\n-    region_lb: ast::node_id,\n+    region_lb: ast::NodeId,\n \n     // Says whether we're inside a for loop, in a do block\n     // or neither. Helps with error messages involving the\n@@ -276,7 +276,7 @@ pub fn blank_inherited(ccx: @mut CrateCtxt) -> @inherited {\n // Used by check_const and check_enum_variants\n pub fn blank_fn_ctxt(ccx: @mut CrateCtxt,\n                      rty: ty::t,\n-                     region_bnd: ast::node_id)\n+                     region_bnd: ast::NodeId)\n                   -> @mut FnCtxt {\n // It's kind of a kludge to manufacture a fake function context\n // and statement context, but we might as well do write the code only once\n@@ -314,7 +314,7 @@ pub fn check_item_types(ccx: @mut CrateCtxt, crate: &ast::Crate) {\n pub fn check_bare_fn(ccx: @mut CrateCtxt,\n                      decl: &ast::fn_decl,\n                      body: &ast::Block,\n-                     id: ast::node_id,\n+                     id: ast::NodeId,\n                      self_info: Option<SelfInfo>) {\n     let fty = ty::node_id_to_type(ccx.tcx, id);\n     match ty::get(fty).sty {\n@@ -338,7 +338,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                 purity: ast::purity,\n                 fn_sig: &ty::FnSig,\n                 decl: &ast::fn_decl,\n-                id: ast::node_id,\n+                id: ast::NodeId,\n                 body: &ast::Block,\n                 fn_kind: FnKind,\n                 inherited_isr: isr_alist,\n@@ -444,7 +444,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                      opt_self_info: Option<SelfInfo>) {\n         let tcx = fcx.ccx.tcx;\n \n-        let assign: @fn(ast::node_id, Option<ty::t>) = |nid, ty_opt| {\n+        let assign: @fn(ast::NodeId, Option<ty::t>) = |nid, ty_opt| {\n             match ty_opt {\n                 None => {\n                     // infer the variable's type\n@@ -526,7 +526,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         // Don't descend into fns and items\n         fn visit_fn(_fk: &visit::fn_kind, _decl: &ast::fn_decl,\n                     _body: &ast::Block, _sp: span,\n-                    _id: ast::node_id, (_t,_v): ((), visit::vt<()>)) {\n+                    _id: ast::NodeId, (_t,_v): ((), visit::vt<()>)) {\n         }\n         fn visit_item(_i: @ast::item, (_e,_v): ((), visit::vt<()>)) { }\n \n@@ -583,7 +583,7 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n     }\n }\n \n-pub fn check_struct(ccx: @mut CrateCtxt, id: ast::node_id, span: span) {\n+pub fn check_struct(ccx: @mut CrateCtxt, id: ast::NodeId, span: span) {\n     let tcx = ccx.tcx;\n \n     // Check that the class is instantiable\n@@ -732,7 +732,7 @@ impl FnCtxt {\n         }\n     }\n \n-    pub fn local_ty(&self, span: span, nid: ast::node_id) -> ty::t {\n+    pub fn local_ty(&self, span: span, nid: ast::NodeId) -> ty::t {\n         match self.inh.locals.find(&nid) {\n             Some(&t) => t,\n             None => {\n@@ -748,13 +748,13 @@ impl FnCtxt {\n     }\n \n     #[inline]\n-    pub fn write_ty(&self, node_id: ast::node_id, ty: ty::t) {\n+    pub fn write_ty(&self, node_id: ast::NodeId, ty: ty::t) {\n         debug!(\"write_ty(%d, %s) in fcx %s\",\n                node_id, ppaux::ty_to_str(self.tcx(), ty), self.tag());\n         self.inh.node_types.insert(node_id, ty);\n     }\n \n-    pub fn write_substs(&self, node_id: ast::node_id, substs: ty::substs) {\n+    pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::substs) {\n         if !ty::substs_is_noop(&substs) {\n             debug!(\"write_substs(%d, %s) in fcx %s\",\n                    node_id,\n@@ -765,7 +765,7 @@ impl FnCtxt {\n     }\n \n     pub fn write_ty_substs(&self,\n-                           node_id: ast::node_id,\n+                           node_id: ast::NodeId,\n                            ty: ty::t,\n                            substs: ty::substs) {\n         let ty = ty::subst(self.tcx(), &substs, ty);\n@@ -774,7 +774,7 @@ impl FnCtxt {\n     }\n \n     pub fn write_autoderef_adjustment(&self,\n-                                      node_id: ast::node_id,\n+                                      node_id: ast::NodeId,\n                                       derefs: uint) {\n         if derefs == 0 { return; }\n         self.write_adjustment(\n@@ -786,19 +786,19 @@ impl FnCtxt {\n     }\n \n     pub fn write_adjustment(&self,\n-                            node_id: ast::node_id,\n+                            node_id: ast::NodeId,\n                             adj: @ty::AutoAdjustment) {\n         debug!(\"write_adjustment(node_id=%?, adj=%?)\", node_id, adj);\n         self.inh.adjustments.insert(node_id, adj);\n     }\n \n-    pub fn write_nil(&self, node_id: ast::node_id) {\n+    pub fn write_nil(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, ty::mk_nil());\n     }\n-    pub fn write_bot(&self, node_id: ast::node_id) {\n+    pub fn write_bot(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, ty::mk_bot());\n     }\n-    pub fn write_error(@mut self, node_id: ast::node_id) {\n+    pub fn write_error(@mut self, node_id: ast::NodeId) {\n         self.write_ty(node_id, ty::mk_err());\n     }\n \n@@ -820,7 +820,7 @@ impl FnCtxt {\n         }\n     }\n \n-    pub fn node_ty(&self, id: ast::node_id) -> ty::t {\n+    pub fn node_ty(&self, id: ast::NodeId) -> ty::t {\n         match self.inh.node_types.find(&id) {\n             Some(&t) => t,\n             None => {\n@@ -834,7 +834,7 @@ impl FnCtxt {\n         }\n     }\n \n-    pub fn node_ty_substs(&self, id: ast::node_id) -> ty::substs {\n+    pub fn node_ty_substs(&self, id: ast::NodeId) -> ty::substs {\n         match self.inh.node_type_substs.find(&id) {\n             Some(ts) => (*ts).clone(),\n             None => {\n@@ -849,7 +849,7 @@ impl FnCtxt {\n     }\n \n     pub fn opt_node_ty_substs(&self,\n-                              id: ast::node_id,\n+                              id: ast::NodeId,\n                               f: &fn(&ty::substs) -> bool)\n                               -> bool {\n         match self.inh.node_type_substs.find(&id) {\n@@ -913,7 +913,7 @@ impl FnCtxt {\n         infer::mk_subr(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n-    pub fn with_region_lb<R>(@mut self, lb: ast::node_id, f: &fn() -> R)\n+    pub fn with_region_lb<R>(@mut self, lb: ast::NodeId, f: &fn() -> R)\n                              -> R {\n         let old_region_lb = self.region_lb;\n         self.region_lb = lb;\n@@ -1308,7 +1308,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     fn check_assignment(fcx: @mut FnCtxt,\n                         lhs: @ast::expr,\n                         rhs: @ast::expr,\n-                        id: ast::node_id) {\n+                        id: ast::NodeId) {\n         check_expr(fcx, lhs);\n         let lhs_type = fcx.expr_ty(lhs);\n         check_expr_has_type(fcx, rhs, lhs_type);\n@@ -1338,7 +1338,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n     // A generic function for doing all of the checking for call expressions\n     fn check_call(fcx: @mut FnCtxt,\n-                  callee_id: ast::node_id,\n+                  callee_id: ast::NodeId,\n                   call_expr: @ast::expr,\n                   f: @ast::expr,\n                   args: &[@ast::expr],\n@@ -1400,7 +1400,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n     // Checks a method call.\n     fn check_method_call(fcx: @mut FnCtxt,\n-                         callee_id: ast::node_id,\n+                         callee_id: ast::NodeId,\n                          expr: @ast::expr,\n                          rcvr: @ast::expr,\n                          method_name: ast::ident,\n@@ -1463,7 +1463,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                        cond_expr: @ast::expr,\n                        then_blk: &ast::Block,\n                        opt_else_expr: Option<@ast::expr>,\n-                       id: ast::node_id,\n+                       id: ast::NodeId,\n                        sp: span,\n                        expected: Option<ty::t>) {\n         check_expr_has_type(fcx, cond_expr, ty::mk_bool());\n@@ -1499,7 +1499,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     }\n \n     fn lookup_op_method(fcx: @mut FnCtxt,\n-                        callee_id: ast::node_id,\n+                        callee_id: ast::NodeId,\n                         op_ex: @ast::expr,\n                         self_ex: @ast::expr,\n                         self_t: ty::t,\n@@ -1537,7 +1537,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n     // could be either a expr_binop or an expr_assign_binop\n     fn check_binop(fcx: @mut FnCtxt,\n-                   callee_id: ast::node_id,\n+                   callee_id: ast::NodeId,\n                    expr: @ast::expr,\n                    op: ast::binop,\n                    lhs: @ast::expr,\n@@ -1625,7 +1625,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     }\n \n     fn check_user_binop(fcx: @mut FnCtxt,\n-                        callee_id: ast::node_id,\n+                        callee_id: ast::NodeId,\n                         ex: @ast::expr,\n                         lhs_expr: @ast::expr,\n                         lhs_resolved_t: ty::t,\n@@ -1667,7 +1667,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     }\n \n     fn check_user_unop(fcx: @mut FnCtxt,\n-                       callee_id: ast::node_id,\n+                       callee_id: ast::NodeId,\n                        op_str: &str,\n                        mname: &str,\n                        ex: @ast::expr,\n@@ -1874,7 +1874,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     fn check_struct_or_variant_fields(fcx: @mut FnCtxt,\n                                       span: span,\n                                       class_id: ast::def_id,\n-                                      node_id: ast::node_id,\n+                                      node_id: ast::NodeId,\n                                       substitutions: ty::substs,\n                                       field_types: &[ty::field_ty],\n                                       ast_fields: &[ast::Field],\n@@ -1963,7 +1963,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     }\n \n     fn check_struct_constructor(fcx: @mut FnCtxt,\n-                                id: ast::node_id,\n+                                id: ast::NodeId,\n                                 span: codemap::span,\n                                 class_id: ast::def_id,\n                                 fields: &[ast::Field],\n@@ -1975,7 +1975,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let type_parameter_count;\n         let region_parameterized;\n         let raw_type;\n-        if class_id.crate == ast::local_crate {\n+        if class_id.crate == ast::LOCAL_CRATE {\n             region_parameterized =\n                 tcx.region_paramd_items.find(&class_id.node).\n                     map_consume(|x| *x);\n@@ -2052,7 +2052,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     }\n \n     fn check_struct_enum_variant(fcx: @mut FnCtxt,\n-                                 id: ast::node_id,\n+                                 id: ast::NodeId,\n                                  span: codemap::span,\n                                  enum_id: ast::def_id,\n                                  variant_id: ast::def_id,\n@@ -2064,7 +2064,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let type_parameter_count;\n         let region_parameterized;\n         let raw_type;\n-        if enum_id.crate == ast::local_crate {\n+        if enum_id.crate == ast::LOCAL_CRATE {\n             region_parameterized =\n                 tcx.region_paramd_items.find(&enum_id.node).map_consume(|x| *x);\n             match tcx.items.find(&enum_id.node) {\n@@ -2897,7 +2897,7 @@ pub fn require_integral(fcx: @mut FnCtxt, sp: span, t: ty::t) {\n }\n \n pub fn check_decl_initializer(fcx: @mut FnCtxt,\n-                              nid: ast::node_id,\n+                              nid: ast::NodeId,\n                               init: @ast::expr)\n                             {\n     let local_ty = fcx.local_ty(init.span, nid);\n@@ -3062,7 +3062,7 @@ pub fn check_block_with_expected(fcx: @mut FnCtxt,\n pub fn check_const(ccx: @mut CrateCtxt,\n                    sp: span,\n                    e: @ast::expr,\n-                   id: ast::node_id) {\n+                   id: ast::NodeId) {\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n     let fcx = blank_fn_ctxt(ccx, rty, e.id);\n     let declty = fcx.ccx.tcx.tcache.get(&local_def(id)).ty;\n@@ -3093,7 +3093,7 @@ pub fn check_const_with_ty(fcx: @mut FnCtxt,\n /// is representable, but not instantiable.\n pub fn check_instantiable(tcx: ty::ctxt,\n                           sp: span,\n-                          item_id: ast::node_id) {\n+                          item_id: ast::NodeId) {\n     let item_ty = ty::node_id_to_type(tcx, item_id);\n     if !ty::is_instantiable(tcx, item_ty) {\n         tcx.sess.span_err(sp, fmt!(\"this type cannot be instantiated \\\n@@ -3103,7 +3103,7 @@ pub fn check_instantiable(tcx: ty::ctxt,\n     }\n }\n \n-pub fn check_simd(tcx: ty::ctxt, sp: span, id: ast::node_id) {\n+pub fn check_simd(tcx: ty::ctxt, sp: span, id: ast::NodeId) {\n     let t = ty::node_id_to_type(tcx, id);\n     if ty::type_needs_subst(t) {\n         tcx.sess.span_err(sp, \"SIMD vector cannot be generic\");\n@@ -3135,10 +3135,10 @@ pub fn check_simd(tcx: ty::ctxt, sp: span, id: ast::node_id) {\n pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                            sp: span,\n                            vs: &[ast::variant],\n-                           id: ast::node_id) {\n+                           id: ast::NodeId) {\n     fn do_check(ccx: @mut CrateCtxt,\n                 vs: &[ast::variant],\n-                id: ast::node_id)\n+                id: ast::NodeId)\n                 -> ~[@ty::VariantInfo] {\n \n         let rty = ty::node_id_to_type(ccx.tcx, id);\n@@ -3226,7 +3226,7 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n     check_instantiable(ccx.tcx, sp, id);\n }\n \n-pub fn lookup_def(fcx: @mut FnCtxt, sp: span, id: ast::node_id) -> ast::def {\n+pub fn lookup_def(fcx: @mut FnCtxt, sp: span, id: ast::NodeId) -> ast::def {\n     lookup_def_ccx(fcx.ccx, sp, id)\n }\n \n@@ -3302,7 +3302,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n                         pth: &ast::Path,\n                         tpt: ty_param_bounds_and_ty,\n                         span: span,\n-                        node_id: ast::node_id) {\n+                        node_id: ast::NodeId) {\n     debug!(\">>> instantiate_path\");\n \n     let ty_param_count = tpt.generics.type_param_defs.len();\n@@ -3427,7 +3427,7 @@ pub fn ast_expr_vstore_to_vstore(fcx: @mut FnCtxt,\n }\n \n // Returns true if b contains a break that can exit from b\n-pub fn may_break(cx: ty::ctxt, id: ast::node_id, b: &ast::Block) -> bool {\n+pub fn may_break(cx: ty::ctxt, id: ast::NodeId, b: &ast::Block) -> bool {\n     // First: is there an unlabeled break immediately\n     // inside the loop?\n     (loop_query(b, |e| {"}, {"sha": "1f4c37a783feb0ea99589ea458adeb325b619c7b", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -51,7 +51,7 @@ pub struct Rcx {\n     errors_reported: uint,\n \n     // id of innermost fn or loop\n-    repeating_scope: ast::node_id,\n+    repeating_scope: ast::NodeId,\n }\n \n pub type rvt = visit::vt<@mut Rcx>;\n@@ -81,7 +81,7 @@ impl Rcx {\n         self.fcx.ccx.tcx\n     }\n \n-    pub fn set_repeating_scope(&mut self, scope: ast::node_id) -> ast::node_id {\n+    pub fn set_repeating_scope(&mut self, scope: ast::NodeId) -> ast::NodeId {\n         let old_scope = self.repeating_scope;\n         self.repeating_scope = scope;\n         old_scope\n@@ -124,7 +124,7 @@ impl Rcx {\n     }\n \n     /// Try to resolve the type for the given node.\n-    pub fn resolve_node_type(@mut self, id: ast::node_id) -> ty::t {\n+    pub fn resolve_node_type(@mut self, id: ast::NodeId) -> ty::t {\n         self.resolve_type(self.fcx.node_ty(id))\n     }\n \n@@ -500,7 +500,7 @@ fn check_expr_fn_block(rcx: @mut Rcx,\n }\n \n fn constrain_callee(rcx: @mut Rcx,\n-                    callee_id: ast::node_id,\n+                    callee_id: ast::NodeId,\n                     call_expr: @ast::expr,\n                     callee_expr: @ast::expr)\n {\n@@ -527,7 +527,7 @@ fn constrain_callee(rcx: @mut Rcx,\n fn constrain_call(rcx: @mut Rcx,\n                   // might be expr_call, expr_method_call, or an overloaded\n                   // operator\n-                  callee_id: ast::node_id,\n+                  callee_id: ast::NodeId,\n                   call_expr: @ast::expr,\n                   receiver: Option<@ast::expr>,\n                   arg_exprs: &[@ast::expr],\n@@ -680,7 +680,7 @@ fn constrain_free_variables(rcx: @mut Rcx,\n \n fn constrain_regions_in_type_of_node(\n     rcx: @mut Rcx,\n-    id: ast::node_id,\n+    id: ast::NodeId,\n     minimum_lifetime: ty::Region,\n     origin: infer::SubregionOrigin) -> bool\n {\n@@ -895,7 +895,7 @@ pub mod guarantor {\n \n     pub fn for_by_ref(rcx: @mut Rcx,\n                       expr: @ast::expr,\n-                      callee_scope: ast::node_id) {\n+                      callee_scope: ast::NodeId) {\n         /*!\n          * Computes the guarantor for cases where the `expr` is\n          * being passed by implicit reference and must outlive\n@@ -918,7 +918,7 @@ pub mod guarantor {\n     fn link(\n         rcx: @mut Rcx,\n         span: span,\n-        id: ast::node_id,\n+        id: ast::NodeId,\n         guarantor: Option<ty::Region>) {\n         /*!\n          *"}, {"sha": "3bae934f2707848600719702b7bd0a43bdcf41da", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -62,7 +62,7 @@ use syntax::visit;\n /// if the vtable instantiation is being performed as part of \"deriving\".)\n pub struct LocationInfo {\n     span: span,\n-    id: ast::node_id\n+    id: ast::NodeId\n }\n \n /// A vtable context includes an inference context, a crate context, and a\n@@ -522,7 +522,7 @@ fn connect_trait_tps(vcx: &VtableContext,\n }\n \n fn insert_vtables(fcx: @mut FnCtxt,\n-                  callee_id: ast::node_id,\n+                  callee_id: ast::NodeId,\n                   vtables: vtable_res) {\n     debug!(\"insert_vtables(callee_id=%d, vtables=%?)\",\n            callee_id, vtables.repr(fcx.tcx()));"}, {"sha": "5976cb2dda7a650412e0c4888709c7a936aef603", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -59,7 +59,7 @@ fn resolve_type_vars_in_types(fcx: @mut FnCtxt, sp: span, tys: &[ty::t])\n     })\n }\n \n-fn resolve_method_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::node_id) {\n+fn resolve_method_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::NodeId) {\n     // Resolve any method map entry\n     match fcx.inh.method_map.find(&id) {\n         None => {}\n@@ -79,7 +79,7 @@ fn resolve_method_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::node_id) {\n     }\n }\n \n-fn resolve_vtable_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::node_id) {\n+fn resolve_vtable_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::NodeId) {\n     // Resolve any method map entry\n     match fcx.inh.vtable_map.find(&id) {\n         None => {}\n@@ -113,7 +113,7 @@ fn resolve_vtable_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::node_id) {\n     }\n }\n \n-fn resolve_type_vars_for_node(wbcx: @mut WbCtxt, sp: span, id: ast::node_id)\n+fn resolve_type_vars_for_node(wbcx: @mut WbCtxt, sp: span, id: ast::NodeId)\n                            -> Option<ty::t> {\n     let fcx = wbcx.fcx;\n     let tcx = fcx.ccx.tcx;\n@@ -195,7 +195,7 @@ fn resolve_type_vars_for_node(wbcx: @mut WbCtxt, sp: span, id: ast::node_id)\n \n fn maybe_resolve_type_vars_for_node(wbcx: @mut WbCtxt,\n                                     sp: span,\n-                                    id: ast::node_id)\n+                                    id: ast::NodeId)\n                                  -> Option<ty::t> {\n     if wbcx.fcx.inh.node_types.contains_key(&id) {\n         resolve_type_vars_for_node(wbcx, sp, id)"}, {"sha": "5555a8906565f26ed67d1063b42dbc92061d6d3f", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -38,7 +38,7 @@ use middle::typeck::infer::{new_infer_ctxt, resolve_ivar, resolve_type};\n use middle::typeck::infer;\n use syntax::ast::{Crate, def_id, def_struct, def_ty};\n use syntax::ast::{item, item_enum, item_impl, item_mod, item_struct};\n-use syntax::ast::{local_crate, trait_ref, ty_path};\n+use syntax::ast::{LOCAL_CRATE, trait_ref, ty_path};\n use syntax::ast;\n use syntax::ast_map::node_item;\n use syntax::ast_map;\n@@ -114,7 +114,7 @@ pub fn type_is_defined_in_local_crate(original_type: t) -> bool {\n             ty_enum(def_id, _) |\n             ty_trait(def_id, _, _, _, _) |\n             ty_struct(def_id, _) => {\n-                if def_id.crate == ast::local_crate {\n+                if def_id.crate == ast::LOCAL_CRATE {\n                     found_nominal = true;\n                 }\n             }\n@@ -513,7 +513,7 @@ impl CoherenceChecker {\n                             let trait_def_id =\n                                 self.trait_ref_to_trait_def_id(trait_ref);\n \n-                            if trait_def_id.crate != local_crate {\n+                            if trait_def_id.crate != LOCAL_CRATE {\n                                 let session = self.crate_context.tcx.sess;\n                                 session.span_err(item.span,\n                                                  \"cannot provide an extension implementation \\\n@@ -575,7 +575,7 @@ impl CoherenceChecker {\n             ty_path(_, _, path_id) => {\n                 match self.crate_context.tcx.def_map.get_copy(&path_id) {\n                     def_ty(def_id) | def_struct(def_id) => {\n-                        if def_id.crate != local_crate {\n+                        if def_id.crate != LOCAL_CRATE {\n                             return false;\n                         }\n \n@@ -647,7 +647,7 @@ impl CoherenceChecker {\n     }\n \n     pub fn span_of_impl(&self, implementation: @Impl) -> span {\n-        assert_eq!(implementation.did.crate, local_crate);\n+        assert_eq!(implementation.did.crate, LOCAL_CRATE);\n         match self.crate_context.tcx.items.find(&implementation.did.node) {\n             Some(&node_item(item, _)) => {\n                 return item.span;\n@@ -783,7 +783,7 @@ impl CoherenceChecker {\n                 }\n                 _ => {\n                     // Destructors only work on nominal types.\n-                    if impl_info.did.crate == ast::local_crate {\n+                    if impl_info.did.crate == ast::LOCAL_CRATE {\n                         match tcx.items.find(&impl_info.did.node) {\n                             Some(&ast_map::node_item(@ref item, _)) => {\n                                 tcx.sess.span_err((*item).span,"}, {"sha": "08378c9930a09196aefabf555c09d0aede9830d7", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -107,7 +107,7 @@ impl AstConv for CrateCtxt {\n     fn tcx(&self) -> ty::ctxt { self.tcx }\n \n     fn get_item_ty(&self, id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n-        if id.crate != ast::local_crate {\n+        if id.crate != ast::LOCAL_CRATE {\n             csearch::get_type(self.tcx, id)\n         } else {\n             match self.tcx.items.find(&id.node) {\n@@ -195,7 +195,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n }\n \n pub fn ensure_trait_methods(ccx: &CrateCtxt,\n-                            trait_id: ast::node_id)\n+                            trait_id: ast::NodeId)\n {\n     let tcx = ccx.tcx;\n     let region_paramd = tcx.region_paramd_items.find(&trait_id).map(|&x| *x);\n@@ -248,7 +248,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n     }\n \n     fn make_static_method_ty(ccx: &CrateCtxt,\n-                             trait_id: ast::node_id,\n+                             trait_id: ast::NodeId,\n                              m: &ty::Method,\n                              trait_ty_generics: &ty::Generics) {\n         // If declaration is\n@@ -352,10 +352,10 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n     }\n \n     fn ty_method_of_trait_method(this: &CrateCtxt,\n-                                 trait_id: ast::node_id,\n+                                 trait_id: ast::NodeId,\n                                  trait_rp: Option<ty::region_variance>,\n                                  trait_generics: &ast::Generics,\n-                                 m_id: &ast::node_id,\n+                                 m_id: &ast::NodeId,\n                                  m_ident: &ast::ident,\n                                  m_explicit_self: &ast::explicit_self,\n                                  m_generics: &ast::Generics,\n@@ -384,7 +384,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n }\n \n pub fn ensure_supertraits(ccx: &CrateCtxt,\n-                          id: ast::node_id,\n+                          id: ast::NodeId,\n                           sp: codemap::span,\n                           rp: Option<ty::region_variance>,\n                           ast_trait_refs: &[ast::trait_ref],\n@@ -666,7 +666,7 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n     let trait_ref = instantiate_trait_ref(ccx, a_trait_ty, rp,\n                                           generics, selfty);\n \n-    if trait_ref.def_id.crate == ast::local_crate {\n+    if trait_ref.def_id.crate == ast::LOCAL_CRATE {\n         ensure_trait_methods(ccx, trait_ref.def_id.node);\n     }\n \n@@ -716,13 +716,13 @@ pub fn convert_field(ccx: &CrateCtxt,\n \n pub struct ConvertedMethod {\n     mty: @ty::Method,\n-    id: ast::node_id,\n+    id: ast::NodeId,\n     span: span,\n-    body_id: ast::node_id\n+    body_id: ast::NodeId\n }\n \n pub fn convert_methods(ccx: &CrateCtxt,\n-                       container_id: ast::node_id,\n+                       container_id: ast::NodeId,\n                        ms: &[@ast::method],\n                        untransformed_rcvr_ty: ty::t,\n                        rcvr_ty_generics: &ty::Generics,\n@@ -763,7 +763,7 @@ pub fn convert_methods(ccx: &CrateCtxt,\n     }).collect();\n \n     fn ty_of_method(ccx: &CrateCtxt,\n-                    container_id: ast::node_id,\n+                    container_id: ast::NodeId,\n                     m: &ast::method,\n                     rp: Option<ty::region_variance>,\n                     untransformed_rcvr_ty: ty::t,\n@@ -908,7 +908,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n                       struct_def: &ast::struct_def,\n                       generics: &ast::Generics,\n                       tpt: ty::ty_param_bounds_and_ty,\n-                      id: ast::node_id) {\n+                      id: ast::NodeId) {\n     let tcx = ccx.tcx;\n \n     // Write the type of each of the members\n@@ -1002,7 +1002,7 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n }\n \n fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::def_id) -> @ty::TraitDef {\n-    if trait_id.crate != ast::local_crate {\n+    if trait_id.crate != ast::LOCAL_CRATE {\n         ty::lookup_trait_def(ccx.tcx, trait_id)\n     } else {\n         match ccx.tcx.items.get(&trait_id.node) {"}, {"sha": "c4e41ea94a6cbb015f41762e12a42ddf69914065", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -686,8 +686,8 @@ impl RegionVarBindings {\n     fn intersect_scopes(&self,\n                         region_a: ty::Region,\n                         region_b: ty::Region,\n-                        scope_a: ast::node_id,\n-                        scope_b: ast::node_id) -> cres<Region>\n+                        scope_a: ast::NodeId,\n+                        scope_b: ast::NodeId) -> cres<Region>\n     {\n         // We want to generate the intersection of two\n         // scopes or two free regions.  So, if one of"}, {"sha": "85b339daa462e944681d819bc2e438e9278b2de7", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -128,7 +128,7 @@ pub struct method_map_entry {\n \n // maps from an expression id that corresponds to a method call to the details\n // of the method to be invoked\n-pub type method_map = @mut HashMap<ast::node_id, method_map_entry>;\n+pub type method_map = @mut HashMap<ast::NodeId, method_map_entry>;\n \n pub type vtable_param_res = @~[vtable_origin];\n // Resolutions for bounds of all parameters, left to right, for a given path.\n@@ -172,7 +172,7 @@ impl Repr for vtable_origin {\n     }\n }\n \n-pub type vtable_map = @mut HashMap<ast::node_id, vtable_res>;\n+pub type vtable_map = @mut HashMap<ast::NodeId, vtable_res>;\n \n \n // Information about the vtable resolutions for for a trait impl.\n@@ -205,13 +205,13 @@ pub struct CrateCtxt {\n }\n \n // Functions that write types into the node type table\n-pub fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t) {\n+pub fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::NodeId, ty: ty::t) {\n     debug!(\"write_ty_to_tcx(%d, %s)\", node_id, ppaux::ty_to_str(tcx, ty));\n     assert!(!ty::type_needs_infer(ty));\n     tcx.node_types.insert(node_id as uint, ty);\n }\n pub fn write_substs_to_tcx(tcx: ty::ctxt,\n-                           node_id: ast::node_id,\n+                           node_id: ast::NodeId,\n                            substs: ~[ty::t]) {\n     if substs.len() > 0u {\n         debug!(\"write_substs_to_tcx(%d, %?)\", node_id,\n@@ -221,15 +221,15 @@ pub fn write_substs_to_tcx(tcx: ty::ctxt,\n     }\n }\n pub fn write_tpt_to_tcx(tcx: ty::ctxt,\n-                        node_id: ast::node_id,\n+                        node_id: ast::NodeId,\n                         tpt: &ty::ty_param_substs_and_ty) {\n     write_ty_to_tcx(tcx, node_id, tpt.ty);\n     if !tpt.substs.tps.is_empty() {\n         write_substs_to_tcx(tcx, node_id, tpt.substs.tps.clone());\n     }\n }\n \n-pub fn lookup_def_tcx(tcx: ty::ctxt, sp: span, id: ast::node_id) -> ast::def {\n+pub fn lookup_def_tcx(tcx: ty::ctxt, sp: span, id: ast::NodeId) -> ast::def {\n     match tcx.def_map.find(&id) {\n       Some(&x) => x,\n       _ => {\n@@ -238,7 +238,7 @@ pub fn lookup_def_tcx(tcx: ty::ctxt, sp: span, id: ast::node_id) -> ast::def {\n     }\n }\n \n-pub fn lookup_def_ccx(ccx: &CrateCtxt, sp: span, id: ast::node_id)\n+pub fn lookup_def_ccx(ccx: &CrateCtxt, sp: span, id: ast::NodeId)\n                    -> ast::def {\n     lookup_def_tcx(ccx.tcx, sp, id)\n }\n@@ -308,7 +308,7 @@ impl get_and_find_region for isr_alist {\n }\n \n fn check_main_fn_ty(ccx: &CrateCtxt,\n-                    main_id: ast::node_id,\n+                    main_id: ast::NodeId,\n                     main_span: span) {\n     let tcx = ccx.tcx;\n     let main_t = ty::node_id_to_type(tcx, main_id);\n@@ -352,7 +352,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n }\n \n fn check_start_fn_ty(ccx: &CrateCtxt,\n-                     start_id: ast::node_id,\n+                     start_id: ast::NodeId,\n                      start_span: span) {\n     let tcx = ccx.tcx;\n     let start_t = ty::node_id_to_type(tcx, start_id);"}, {"sha": "2e698227120cb1ead09f79b61bd62317b724a102", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -112,4 +112,4 @@ pub fn pluralize(n: uint, s: ~str) -> ~str {\n }\n \n // A set of node IDs (used to keep track of which node IDs are for statements)\n-pub type stmt_set = @mut HashSet<ast::node_id>;\n+pub type stmt_set = @mut HashSet<ast::NodeId>;"}, {"sha": "68e05ad7d04ba1668d08005b9f84abe184fb7060", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -165,7 +165,7 @@ pub fn bound_region_to_str(cx: ctxt,\n     }\n }\n \n-pub fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n+pub fn re_scope_id_to_str(cx: ctxt, node_id: ast::NodeId) -> ~str {\n     match cx.items.find(&node_id) {\n       Some(&ast_map::node_block(ref blk)) => {\n         fmt!(\"<block at %s>\",\n@@ -643,7 +643,7 @@ impl Repr for ast::def_id {\n         // Unfortunately, there seems to be no way to attempt to print\n         // a path for a def-id, so I'll just make a best effort for now\n         // and otherwise fallback to just printing the crate/node pair\n-        if self.crate == ast::local_crate {\n+        if self.crate == ast::LOCAL_CRATE {\n             match tcx.items.find(&self.node) {\n                 Some(&ast_map::node_item(*)) |\n                 Some(&ast_map::node_foreign_item(*)) |"}, {"sha": "b189bd2bc2dcdf5ff8dec5537d6888c525d54319", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -84,7 +84,7 @@ fn fold_item(\n     let srv = fold.ctxt.clone();\n     let doc = fold::default_seq_fold_item(fold, doc);\n \n-    let desc = if doc.id == ast::crate_node_id {\n+    let desc = if doc.id == ast::CRATE_NODE_ID {\n         // This is the top-level mod, use the crate attributes\n         do astsrv::exec(srv) |ctxt| {\n             attr_parser::parse_desc(ctxt.ast.attrs.clone())"}, {"sha": "8ac987108b39f0c31c4f9851abdf06645322ec5e", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -60,11 +60,11 @@ fn top_moddoc_from_crate(\n     crate: @ast::Crate,\n     default_name: ~str\n ) -> doc::ModDoc {\n-    moddoc_from_mod(mk_itemdoc(ast::crate_node_id, default_name),\n+    moddoc_from_mod(mk_itemdoc(ast::CRATE_NODE_ID, default_name),\n                     crate.module.clone())\n }\n \n-fn mk_itemdoc(id: ast::node_id, name: ~str) -> doc::ItemDoc {\n+fn mk_itemdoc(id: ast::NodeId, name: ~str) -> doc::ItemDoc {\n     doc::ItemDoc {\n         id: id,\n         name: name,"}, {"sha": "7ee31d5a8e7e01f5b446cd986ab8a30ac92db090", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -138,7 +138,7 @@ fn write_header_(ctxt: &Ctxt, lvl: Hlvl, title: ~str) {\n pub fn header_kind(doc: doc::ItemTag) -> ~str {\n     match doc {\n         doc::ModTag(_) => {\n-            if doc.id() == syntax::ast::crate_node_id {\n+            if doc.id() == syntax::ast::CRATE_NODE_ID {\n                 ~\"Crate\"\n             } else {\n                 ~\"Module\"\n@@ -174,7 +174,7 @@ pub fn header_kind(doc: doc::ItemTag) -> ~str {\n pub fn header_name(doc: doc::ItemTag) -> ~str {\n     let fullpath = (doc.path() + &[doc.name_()]).connect(\"::\");\n     match &doc {\n-        &doc::ModTag(_) if doc.id() != syntax::ast::crate_node_id => {\n+        &doc::ModTag(_) if doc.id() != syntax::ast::CRATE_NODE_ID => {\n             fullpath\n         }\n         &doc::NmodTag(_) => {"}, {"sha": "82a4724496dd189f8f6eb3b2f6f3a12285907afc", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -106,7 +106,7 @@ fn fold_crate(fold: &fold::Fold<PageChan>, doc: doc::CrateDoc)\n fn fold_mod(fold: &fold::Fold<PageChan>, doc: doc::ModDoc) -> doc::ModDoc {\n     let doc = fold::default_any_fold_mod(fold, doc);\n \n-    if doc.id() != ast::crate_node_id {\n+    if doc.id() != ast::CRATE_NODE_ID {\n \n         let doc = strip_mod(doc.clone());\n         let page = doc::ItemPage(doc::ModTag(doc));"}, {"sha": "6e6092a6a3fa359c8947f17de3134e14c7285f71", "filename": "src/librustdoc/path_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpath_pass.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -66,7 +66,7 @@ fn fold_item(fold: &fold::Fold<Ctxt>, doc: doc::ItemDoc) -> doc::ItemDoc {\n }\n \n fn fold_mod(fold: &fold::Fold<Ctxt>, doc: doc::ModDoc) -> doc::ModDoc {\n-    let is_topmod = doc.id() == ast::crate_node_id;\n+    let is_topmod = doc.id() == ast::CRATE_NODE_ID;\n \n     if !is_topmod { fold.ctxt.path.push(doc.name_()); }\n     let doc = fold::default_any_fold_mod(fold, doc);"}, {"sha": "eca204832664b813858a5e3fba11ad5514e06528", "filename": "src/librusti/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrusti%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibrusti%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Futils.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -14,7 +14,7 @@ use syntax::print::pp;\n use syntax::print::pprust;\n use syntax::parse::token;\n \n-pub fn each_binding(l: @ast::Local, f: @fn(&ast::Path, ast::node_id)) {\n+pub fn each_binding(l: @ast::Local, f: @fn(&ast::Path, ast::NodeId)) {\n     use syntax::visit;\n \n     let vt = visit::mk_simple_visitor("}, {"sha": "97e69cd69184afe4cc20ddf895575465ad8e2fbe", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 57, "deletions": 58, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -94,7 +94,7 @@ pub type fn_ident = Option<ident>;\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct Lifetime {\n-    id: node_id,\n+    id: NodeId,\n     span: span,\n     ident: ident\n }\n@@ -119,16 +119,16 @@ pub struct Path {\n \n pub type CrateNum = int;\n \n-pub type node_id = int;\n+pub type NodeId = int;\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct def_id {\n     crate: CrateNum,\n-    node: node_id,\n+    node: NodeId,\n }\n \n-pub static local_crate: CrateNum = 0;\n-pub static crate_node_id: node_id = 0;\n+pub static LOCAL_CRATE: CrateNum = 0;\n+pub static CRATE_NODE_ID: NodeId = 0;\n \n // The AST represents all type param bounds as types.\n // typeck::collect::compute_bounds matches these against\n@@ -143,7 +143,7 @@ pub enum TyParamBound {\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct TyParam {\n     ident: ident,\n-    id: node_id,\n+    id: NodeId,\n     bounds: OptVec<TyParamBound>\n }\n \n@@ -171,28 +171,28 @@ pub enum def {\n     def_static_method(/* method */ def_id,\n                       /* trait */  Option<def_id>,\n                       purity),\n-    def_self(node_id, bool /* is_implicit */),\n-    def_self_ty(/* trait id */ node_id),\n+    def_self(NodeId, bool /* is_implicit */),\n+    def_self_ty(/* trait id */ NodeId),\n     def_mod(def_id),\n     def_foreign_mod(def_id),\n     def_static(def_id, bool /* is_mutbl */),\n-    def_arg(node_id, bool /* is_mutbl */),\n-    def_local(node_id, bool /* is_mutbl */),\n+    def_arg(NodeId, bool /* is_mutbl */),\n+    def_local(NodeId, bool /* is_mutbl */),\n     def_variant(def_id /* enum */, def_id /* variant */),\n     def_ty(def_id),\n     def_trait(def_id),\n     def_prim_ty(prim_ty),\n     def_ty_param(def_id, uint),\n-    def_binding(node_id, binding_mode),\n+    def_binding(NodeId, binding_mode),\n     def_use(def_id),\n-    def_upvar(node_id,  // id of closed over var\n+    def_upvar(NodeId,  // id of closed over var\n               @def,     // closed over def\n-              node_id,  // expr node that creates the closure\n-              node_id), // id for the block/body of the closure expr\n+              NodeId,  // expr node that creates the closure\n+              NodeId), // id for the block/body of the closure expr\n     def_struct(def_id),\n-    def_typaram_binder(node_id), /* struct, impl or trait with ty params */\n-    def_region(node_id),\n-    def_label(node_id),\n+    def_typaram_binder(NodeId), /* struct, impl or trait with ty params */\n+    def_region(NodeId),\n+    def_label(NodeId),\n     def_method(def_id /* method */, Option<def_id> /* trait */),\n }\n \n@@ -248,14 +248,14 @@ pub struct Block {\n     view_items: ~[view_item],\n     stmts: ~[@stmt],\n     expr: Option<@expr>,\n-    id: node_id,\n-    rules: blk_check_mode,\n+    id: NodeId,\n+    rules: BlockCheckMode,\n     span: span,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct pat {\n-    id: node_id,\n+    id: NodeId,\n     node: pat_,\n     span: span,\n }\n@@ -280,7 +280,7 @@ pub enum pat_ {\n     // is None).\n     // In the nullary enum case, the parser can't determine\n     // which it is. The resolver determines this, and\n-    // records this pattern's node_id in an auxiliary\n+    // records this pattern's NodeId in an auxiliary\n     // set (of \"pat_idents that refer to nullary enums\")\n     pat_ident(binding_mode, Path, Option<@pat>),\n     pat_enum(Path, Option<~[@pat]>), /* \"none\" means a * pattern where\n@@ -371,13 +371,13 @@ pub type stmt = spanned<stmt_>;\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum stmt_ {\n     // could be an item or a local (let) binding:\n-    stmt_decl(@decl, node_id),\n+    stmt_decl(@decl, NodeId),\n \n     // expr without trailing semi-colon (must have unit type):\n-    stmt_expr(@expr, node_id),\n+    stmt_expr(@expr, NodeId),\n \n     // expr with trailing semi-colon (may have any type):\n-    stmt_semi(@expr, node_id),\n+    stmt_semi(@expr, NodeId),\n \n     // bool: is there a trailing sem-colon?\n     stmt_mac(mac, bool),\n@@ -391,7 +391,7 @@ pub struct Local {\n     ty: Ty,\n     pat: @pat,\n     init: Option<@expr>,\n-    id: node_id,\n+    id: NodeId,\n     span: span,\n }\n \n@@ -420,20 +420,20 @@ pub struct Field {\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum blk_check_mode {\n-    default_blk,\n-    unsafe_blk,\n+pub enum BlockCheckMode {\n+    DefaultBlock,\n+    UnsafeBlock,\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct expr {\n-    id: node_id,\n+    id: NodeId,\n     node: expr_,\n     span: span,\n }\n \n impl expr {\n-    pub fn get_callee_id(&self) -> Option<node_id> {\n+    pub fn get_callee_id(&self) -> Option<NodeId> {\n         match self.node {\n             expr_method_call(callee_id, _, _, _, _, _) |\n             expr_index(callee_id, _, _) |\n@@ -457,10 +457,10 @@ pub enum expr_ {\n     expr_vstore(@expr, expr_vstore),\n     expr_vec(~[@expr], mutability),\n     expr_call(@expr, ~[@expr], CallSugar),\n-    expr_method_call(node_id, @expr, ident, ~[Ty], ~[@expr], CallSugar),\n+    expr_method_call(NodeId, @expr, ident, ~[Ty], ~[@expr], CallSugar),\n     expr_tup(~[@expr]),\n-    expr_binary(node_id, binop, @expr, @expr),\n-    expr_unary(node_id, unop, @expr),\n+    expr_binary(NodeId, binop, @expr, @expr),\n+    expr_unary(NodeId, unop, @expr),\n     expr_lit(@lit),\n     expr_cast(@expr, Ty),\n     expr_if(@expr, Block, Option<@expr>),\n@@ -480,9 +480,9 @@ pub enum expr_ {\n     expr_block(Block),\n \n     expr_assign(@expr, @expr),\n-    expr_assign_op(node_id, binop, @expr, @expr),\n+    expr_assign_op(NodeId, binop, @expr, @expr),\n     expr_field(@expr, ident, ~[Ty]),\n-    expr_index(node_id, @expr, @expr),\n+    expr_index(NodeId, @expr, @expr),\n     expr_path(Path),\n \n     /// The special identifier `self`.\n@@ -636,22 +636,21 @@ pub struct mt {\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n-pub struct ty_field_ {\n+pub struct TypeField {\n     ident: ident,\n     mt: mt,\n+    span: span,\n }\n \n-pub type ty_field = spanned<ty_field_>;\n-\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub struct ty_method {\n+pub struct TypeMethod {\n     ident: ident,\n     attrs: ~[Attribute],\n     purity: purity,\n     decl: fn_decl,\n     generics: Generics,\n     explicit_self: explicit_self,\n-    id: node_id,\n+    id: NodeId,\n     span: span,\n }\n \n@@ -660,7 +659,7 @@ pub struct ty_method {\n // implementation).\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum trait_method {\n-    required(ty_method),\n+    required(TypeMethod),\n     provided(@method),\n }\n \n@@ -711,7 +710,7 @@ impl ToStr for float_ty {\n // NB Eq method appears below.\n #[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n pub struct Ty {\n-    id: node_id,\n+    id: NodeId,\n     node: ty_,\n     span: span,\n }\n@@ -778,7 +777,7 @@ pub enum ty_ {\n     ty_closure(@TyClosure),\n     ty_bare_fn(@TyBareFn),\n     ty_tup(~[Ty]),\n-    ty_path(Path, Option<OptVec<TyParamBound>>, node_id), // for #7264; see above\n+    ty_path(Path, Option<OptVec<TyParamBound>>, NodeId), // for #7264; see above\n     ty_mac(mac),\n     // ty_infer means the type should be inferred instead of it having been\n     // specified. This should only appear at the \"top level\" of a type and not\n@@ -808,7 +807,7 @@ pub struct arg {\n     is_mutbl: bool,\n     ty: Ty,\n     pat: @pat,\n-    id: node_id,\n+    id: NodeId,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n@@ -863,9 +862,9 @@ pub struct method {\n     purity: purity,\n     decl: fn_decl,\n     body: Block,\n-    id: node_id,\n+    id: NodeId,\n     span: span,\n-    self_id: node_id,\n+    self_id: NodeId,\n     vis: visibility,\n }\n \n@@ -893,7 +892,7 @@ pub struct foreign_mod {\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct variant_arg {\n     ty: Ty,\n-    id: node_id,\n+    id: NodeId,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n@@ -912,7 +911,7 @@ pub struct variant_ {\n     name: ident,\n     attrs: ~[Attribute],\n     kind: variant_kind,\n-    id: node_id,\n+    id: NodeId,\n     disr_expr: Option<@expr>,\n     vis: visibility,\n }\n@@ -922,7 +921,7 @@ pub type variant = spanned<variant_>;\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct path_list_ident_ {\n     name: ident,\n-    id: node_id,\n+    id: NodeId,\n }\n \n pub type path_list_ident = spanned<path_list_ident_>;\n@@ -937,13 +936,13 @@ pub enum view_path_ {\n     // or just\n     //\n     // foo::bar::baz  (with 'baz =' implicitly on the left)\n-    view_path_simple(ident, Path, node_id),\n+    view_path_simple(ident, Path, NodeId),\n \n     // foo::bar::*\n-    view_path_glob(Path, node_id),\n+    view_path_glob(Path, NodeId),\n \n     // foo::bar::{a,b,c}\n-    view_path_list(Path, ~[path_list_ident], node_id)\n+    view_path_list(Path, ~[path_list_ident], NodeId)\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n@@ -956,7 +955,7 @@ pub struct view_item {\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum view_item_ {\n-    view_item_extern_mod(ident, ~[@MetaItem], node_id),\n+    view_item_extern_mod(ident, ~[@MetaItem], NodeId),\n     view_item_use(~[@view_path]),\n }\n \n@@ -990,7 +989,7 @@ pub struct Attribute_ {\n #[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n pub struct trait_ref {\n     path: Path,\n-    ref_id: node_id,\n+    ref_id: NodeId,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n@@ -1012,7 +1011,7 @@ impl visibility {\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct struct_field_ {\n     kind: struct_field_kind,\n-    id: node_id,\n+    id: NodeId,\n     ty: Ty,\n     attrs: ~[Attribute],\n }\n@@ -1030,7 +1029,7 @@ pub struct struct_def {\n     fields: ~[@struct_field], /* fields, not including ctor */\n     /* ID of the constructor. This is only used for tuple- or enum-like\n      * structs. */\n-    ctor_id: Option<node_id>\n+    ctor_id: Option<NodeId>\n }\n \n /*\n@@ -1041,7 +1040,7 @@ pub struct struct_def {\n pub struct item {\n     ident: ident,\n     attrs: ~[Attribute],\n-    id: node_id,\n+    id: NodeId,\n     node: item_,\n     vis: visibility,\n     span: span,\n@@ -1070,7 +1069,7 @@ pub struct foreign_item {\n     ident: ident,\n     attrs: ~[Attribute],\n     node: foreign_item_,\n-    id: node_id,\n+    id: NodeId,\n     span: span,\n     vis: visibility,\n }"}, {"sha": "7e70817a68e71eeba72185e989fc35674590153d", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -78,7 +78,7 @@ pub enum ast_node {\n     node_callee_scope(@expr)\n }\n \n-pub type map = @mut HashMap<node_id, ast_node>;\n+pub type map = @mut HashMap<NodeId, ast_node>;\n \n pub struct Ctx {\n     map: map,\n@@ -159,7 +159,7 @@ pub fn map_fn(\n     decl: &fn_decl,\n     body: &Block,\n     sp: codemap::span,\n-    id: node_id,\n+    id: NodeId,\n     (cx,v): (@mut Ctx,\n              visit::vt<@mut Ctx>)\n ) {\n@@ -313,7 +313,7 @@ pub fn map_stmt(stmt: @stmt, (cx,v): (@mut Ctx, visit::vt<@mut Ctx>)) {\n     visit::visit_stmt(stmt, (cx, v));\n }\n \n-pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n+pub fn node_id_to_str(map: map, id: NodeId, itr: @ident_interner) -> ~str {\n     match map.find(&id) {\n       None => {\n         fmt!(\"unknown node (id=%d)\", id)\n@@ -376,7 +376,7 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n     }\n }\n \n-pub fn node_item_query<Result>(items: map, id: node_id,\n+pub fn node_item_query<Result>(items: map, id: NodeId,\n                                query: &fn(@item) -> Result,\n                                error_msg: ~str) -> Result {\n     match items.find(&id) {"}, {"sha": "5ad325fed569e4c8b81fef6475cb9fcdf941d455", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -31,13 +31,13 @@ pub fn path_to_ident(p: &Path) -> ident {\n     *p.idents.last()\n }\n \n-pub fn local_def(id: node_id) -> def_id {\n-    ast::def_id { crate: local_crate, node: id }\n+pub fn local_def(id: NodeId) -> def_id {\n+    ast::def_id { crate: LOCAL_CRATE, node: id }\n }\n \n-pub fn is_local(did: ast::def_id) -> bool { did.crate == local_crate }\n+pub fn is_local(did: ast::def_id) -> bool { did.crate == LOCAL_CRATE }\n \n-pub fn stmt_id(s: &stmt) -> node_id {\n+pub fn stmt_id(s: &stmt) -> NodeId {\n     match s.node {\n       stmt_decl(_, id) => id,\n       stmt_expr(_, id) => id,\n@@ -204,14 +204,14 @@ pub fn block_from_expr(e: @expr) -> Block {\n pub fn default_block(\n     stmts1: ~[@stmt],\n     expr1: Option<@expr>,\n-    id1: node_id\n+    id1: NodeId\n ) -> Block {\n     ast::Block {\n         view_items: ~[],\n         stmts: stmts1,\n         expr: expr1,\n         id: id1,\n-        rules: default_blk,\n+        rules: DefaultBlock,\n         span: dummy_sp(),\n     }\n }\n@@ -224,7 +224,7 @@ pub fn ident_to_path(s: span, i: ident) -> Path {\n                  types: ~[] }\n }\n \n-pub fn ident_to_pat(id: node_id, s: span, i: ident) -> @pat {\n+pub fn ident_to_pat(id: NodeId, s: span, i: ident) -> @pat {\n     @ast::pat { id: id,\n                 node: pat_ident(bind_infer, ident_to_path(s, i), None),\n                 span: s }\n@@ -254,13 +254,13 @@ pub fn public_methods(ms: ~[@method]) -> ~[@method] {\n     }.collect()\n }\n \n-// extract a ty_method from a trait_method. if the trait_method is\n-// a default, pull out the useful fields to make a ty_method\n-pub fn trait_method_to_ty_method(method: &trait_method) -> ty_method {\n+// extract a TypeMethod from a trait_method. if the trait_method is\n+// a default, pull out the useful fields to make a TypeMethod\n+pub fn trait_method_to_ty_method(method: &trait_method) -> TypeMethod {\n     match *method {\n         required(ref m) => (*m).clone(),\n         provided(ref m) => {\n-            ty_method {\n+            TypeMethod {\n                 ident: m.ident,\n                 attrs: m.attrs.clone(),\n                 purity: m.purity,\n@@ -275,7 +275,7 @@ pub fn trait_method_to_ty_method(method: &trait_method) -> ty_method {\n }\n \n pub fn split_trait_methods(trait_methods: &[trait_method])\n-    -> (~[ty_method], ~[@method]) {\n+    -> (~[TypeMethod], ~[@method]) {\n     let mut reqd = ~[];\n     let mut provd = ~[];\n     for trait_methods.iter().advance |trt_method| {\n@@ -296,7 +296,7 @@ pub fn struct_field_visibility(field: ast::struct_field) -> visibility {\n \n pub trait inlined_item_utils {\n     fn ident(&self) -> ident;\n-    fn id(&self) -> ast::node_id;\n+    fn id(&self) -> ast::NodeId;\n     fn accept<E: Clone>(&self, e: E, v: visit::vt<E>);\n }\n \n@@ -309,7 +309,7 @@ impl inlined_item_utils for inlined_item {\n         }\n     }\n \n-    fn id(&self) -> ast::node_id {\n+    fn id(&self) -> ast::NodeId {\n         match *self {\n             ii_item(i) => i.id,\n             ii_foreign(i) => i.id,\n@@ -367,8 +367,8 @@ pub fn empty_generics() -> Generics {\n \n #[deriving(Encodable, Decodable)]\n pub struct id_range {\n-    min: node_id,\n-    max: node_id,\n+    min: NodeId,\n+    max: NodeId,\n }\n \n impl id_range {\n@@ -383,13 +383,13 @@ impl id_range {\n         self.min >= self.max\n     }\n \n-    pub fn add(&mut self, id: node_id) {\n+    pub fn add(&mut self, id: NodeId) {\n         self.min = num::min(self.min, id);\n         self.max = num::max(self.max, id + 1);\n     }\n }\n \n-pub fn id_visitor<T: Clone>(vfn: @fn(node_id, T)) -> visit::vt<T> {\n+pub fn id_visitor<T: Clone>(vfn: @fn(NodeId, T)) -> visit::vt<T> {\n     let visit_generics: @fn(&Generics, T) = |generics, t| {\n         for generics.ty_params.iter().advance |p| {\n             vfn(p.id, t.clone());\n@@ -515,11 +515,11 @@ pub fn id_visitor<T: Clone>(vfn: @fn(node_id, T)) -> visit::vt<T> {\n     })\n }\n \n-pub fn visit_ids_for_inlined_item(item: &inlined_item, vfn: @fn(node_id)) {\n+pub fn visit_ids_for_inlined_item(item: &inlined_item, vfn: @fn(NodeId)) {\n     item.accept((), id_visitor(|id, ()| vfn(id)));\n }\n \n-pub fn compute_id_range(visit_ids_fn: &fn(@fn(node_id))) -> id_range {\n+pub fn compute_id_range(visit_ids_fn: &fn(@fn(NodeId))) -> id_range {\n     let result = @mut id_range::max();\n     do visit_ids_fn |id| {\n         result.add(id);\n@@ -581,7 +581,7 @@ impl EachViewItem for ast::Crate {\n     }\n }\n \n-pub fn view_path_id(p: &view_path) -> node_id {\n+pub fn view_path_id(p: &view_path) -> NodeId {\n     match p.node {\n       view_path_simple(_, _, id) |\n       view_path_glob(_, id) |"}, {"sha": "ea87646e60b0b69a9b09eb58fe76802fe507323f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -294,7 +294,7 @@ impl ExtCtxt {\n         self.print_backtrace();\n         self.parse_sess.span_diagnostic.handler().bug(msg);\n     }\n-    pub fn next_id(&self) -> ast::node_id {\n+    pub fn next_id(&self) -> ast::NodeId {\n         parse::next_node_id(self.parse_sess)\n     }\n     pub fn trace_macros(&self) -> bool {"}, {"sha": "7e017838496b522ae2d2d8bd96c380d4b900296e", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -62,7 +62,7 @@ pub trait AstBuilder {\n \n     fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[ast::Ty];\n     fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[ast::Ty];\n-    fn ty_field_imm(&self, span: span, name: ident, ty: ast::Ty) -> ast::ty_field;\n+    fn ty_field_imm(&self, span: span, name: ident, ty: ast::Ty) -> ast::TypeField;\n     fn strip_bounds(&self, bounds: &Generics) -> Generics;\n \n     fn typaram(&self, id: ast::ident, bounds: OptVec<ast::TyParamBound>) -> ast::TyParam;\n@@ -306,12 +306,12 @@ impl AstBuilder for @ExtCtxt {\n                           ~[ ty ]), None)\n     }\n \n-    fn ty_field_imm(&self, span: span, name: ident, ty: ast::Ty) -> ast::ty_field {\n-        respan(span,\n-               ast::ty_field_ {\n-                   ident: name,\n-                   mt: ast::mt { ty: ~ty, mutbl: ast::m_imm },\n-               })\n+    fn ty_field_imm(&self, span: span, name: ident, ty: ast::Ty) -> ast::TypeField {\n+        ast::TypeField {\n+            ident: name,\n+            mt: ast::mt { ty: ~ty, mutbl: ast::m_imm },\n+            span: span,\n+        }\n     }\n \n     fn ty_infer(&self, span: span) -> ast::Ty {\n@@ -404,7 +404,7 @@ impl AstBuilder for @ExtCtxt {\n                stmts: stmts,\n                expr: expr,\n                id: self.next_id(),\n-               rules: ast::default_blk,\n+               rules: ast::DefaultBlock,\n                span: span,\n            }\n     }"}, {"sha": "51475528174f481cdce44142abed57a7f990f8c5", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -36,7 +36,7 @@ pub trait ast_fold {\n     fn fold_path(@self, &Path) -> Path;\n     fn fold_local(@self, @Local) -> @Local;\n     fn map_exprs(@self, @fn(@expr) -> @expr, &[@expr]) -> ~[@expr];\n-    fn new_id(@self, node_id) -> node_id;\n+    fn new_id(@self, NodeId) -> NodeId;\n     fn new_span(@self, span) -> span;\n }\n \n@@ -65,7 +65,7 @@ pub struct AstFoldFns {\n     fold_path: @fn(&Path, @ast_fold) -> Path,\n     fold_local: @fn(@Local, @ast_fold) -> @Local,\n     map_exprs: @fn(@fn(@expr) -> @expr, &[@expr]) -> ~[@expr],\n-    new_id: @fn(node_id) -> node_id,\n+    new_id: @fn(NodeId) -> NodeId,\n     new_span: @fn(span) -> span\n }\n \n@@ -646,12 +646,10 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n             mutbl: mt.mutbl,\n         }\n     }\n-    fn fold_field(f: ty_field, fld: @ast_fold) -> ty_field {\n-        spanned {\n-            node: ast::ty_field_ {\n-                ident: fld.fold_ident(f.node.ident),\n-                mt: fold_mt(&f.node.mt, fld),\n-            },\n+    fn fold_field(f: TypeField, fld: @ast_fold) -> TypeField {\n+        ast::TypeField {\n+            ident: fld.fold_ident(f.ident),\n+            mt: fold_mt(&f.mt, fld),\n             span: fld.new_span(f.span),\n         }\n     }\n@@ -787,7 +785,7 @@ fn noop_map_exprs(f: @fn(@expr) -> @expr, es: &[@expr]) -> ~[@expr] {\n     es.map(|x| f(*x))\n }\n \n-fn noop_id(i: node_id) -> node_id { return i; }\n+fn noop_id(i: NodeId) -> NodeId { return i; }\n \n fn noop_span(sp: span) -> span { return sp; }\n \n@@ -924,7 +922,7 @@ impl ast_fold for AstFoldFns {\n               -> ~[@expr] {\n         (self.map_exprs)(f, e)\n     }\n-    fn new_id(@self, node_id: ast::node_id) -> node_id {\n+    fn new_id(@self, node_id: ast::NodeId) -> NodeId {\n         (self.new_id)(node_id)\n     }\n     fn new_span(@self, span: span) -> span {"}, {"sha": "c7c556c9728dd1a4de5a7e15deaab435aa7a054c", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -39,7 +39,7 @@ pub fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n pub fn expr_is_simple_block(e: @ast::expr) -> bool {\n     match e.node {\n         ast::expr_block(\n-            ast::Block { rules: ast::default_blk, _ }\n+            ast::Block { rules: ast::DefaultBlock, _ }\n         ) => true,\n       _ => false\n     }"}, {"sha": "1731a587a8efa3c3c75c091aaf71cf7d0db58db4", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -11,7 +11,7 @@\n //! The main parser interface\n \n \n-use ast::node_id;\n+use ast::NodeId;\n use ast;\n use codemap::{span, CodeMap, FileMap, FileSubstr};\n use codemap;\n@@ -42,7 +42,7 @@ pub mod obsolete;\n // info about a parsing session.\n pub struct ParseSess {\n     cm: @codemap::CodeMap, // better be the same as the one in the reader!\n-    next_id: node_id,\n+    next_id: NodeId,\n     span_diagnostic: @span_handler, // better be the same as the one in the reader!\n     /// Used to determine and report recursive mod inclusions\n     included_mod_stack: ~[Path],\n@@ -202,7 +202,7 @@ pub fn parse_from_source_str<T>(\n }\n \n // return the next unused node id.\n-pub fn next_node_id(sess: @mut ParseSess) -> node_id {\n+pub fn next_node_id(sess: @mut ParseSess) -> NodeId {\n     let rv = sess.next_id;\n     sess.next_id += 1;\n     // ID 0 is reserved for the crate and doesn't actually exist in the AST\n@@ -506,7 +506,7 @@ mod test {\n     // check the contents of the tt manually:\n     #[test] fn parse_fundecl () {\n         // this test depends on the intern order of \"fn\" and \"int\", and on the\n-        // assignment order of the node_ids.\n+        // assignment order of the NodeIds.\n         assert_eq!(string_to_item(@\"fn a (b : int) { b; }\"),\n                   Some(\n                       @ast::item{ident:str_to_ident(\"a\"),\n@@ -566,7 +566,7 @@ mod test {\n                                             span: sp(17,18)}],\n                                         expr: None,\n                                         id: 8, // fixme\n-                                        rules: ast::default_blk, // no idea\n+                                        rules: ast::DefaultBlock, // no idea\n                                         span: sp(15,21),\n                                     }),\n                             vis: ast::inherited,"}, {"sha": "61dc6f47549b943c225afadce09b829a3530a45d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -17,9 +17,9 @@ use ast::{RegionTyParamBound, TraitTyParamBound};\n use ast::{provided, public, purity};\n use ast::{_mod, add, arg, arm, Attribute, bind_by_ref, bind_infer};\n use ast::{bitand, bitor, bitxor, Block};\n-use ast::{blk_check_mode, box};\n+use ast::{BlockCheckMode, box};\n use ast::{Crate, CrateConfig, decl, decl_item};\n-use ast::{decl_local, default_blk, deref, div, enum_def, explicit_self};\n+use ast::{decl_local, DefaultBlock, deref, div, enum_def, explicit_self};\n use ast::{expr, expr_, expr_addr_of, expr_match, expr_again};\n use ast::{expr_assign, expr_assign_op, expr_binary, expr_block};\n use ast::{expr_break, expr_call, expr_cast, expr_do_body};\n@@ -39,7 +39,7 @@ use ast::{lit_bool, lit_float, lit_float_unsuffixed, lit_int};\n use ast::{lit_int_unsuffixed, lit_nil, lit_str, lit_uint, Local, m_const};\n use ast::{m_imm, m_mutbl, mac_, mac_invoc_tt, matcher, match_nonterminal};\n use ast::{match_seq, match_tok, method, mt, mul, mutability};\n-use ast::{named_field, neg, node_id, noreturn, not, pat, pat_box, pat_enum};\n+use ast::{named_field, neg, NodeId, noreturn, not, pat, pat_box, pat_enum};\n use ast::{pat_ident, pat_lit, pat_range, pat_region, pat_struct};\n use ast::{pat_tup, pat_uniq, pat_wild, private};\n use ast::{rem, required};\n@@ -49,11 +49,11 @@ use ast::{struct_variant_kind, subtract};\n use ast::{sty_box, sty_region, sty_static, sty_uniq, sty_value};\n use ast::{token_tree, trait_method, trait_ref, tt_delim, tt_seq, tt_tok};\n use ast::{tt_nonterminal, tuple_variant_kind, Ty, ty_, ty_bot, ty_box};\n-use ast::{ty_field, ty_fixed_length_vec, ty_closure, ty_bare_fn};\n-use ast::{ty_infer, ty_method};\n+use ast::{TypeField, ty_fixed_length_vec, ty_closure, ty_bare_fn};\n+use ast::{ty_infer, TypeMethod};\n use ast::{ty_nil, TyParam, TyParamBound, ty_path, ty_ptr, ty_rptr};\n use ast::{ty_tup, ty_u32, ty_uniq, ty_vec, uniq};\n-use ast::{unnamed_field, unsafe_blk, unsafe_fn, view_item};\n+use ast::{unnamed_field, UnsafeBlock, unsafe_fn, view_item};\n use ast::{view_item_, view_item_extern_mod, view_item_use};\n use ast::{view_path, view_path_glob, view_path_list, view_path_simple};\n use ast::visibility;\n@@ -645,7 +645,7 @@ impl Parser {\n     pub fn abort_if_errors(&self) {\n         self.sess.span_diagnostic.handler().abort_if_errors();\n     }\n-    pub fn get_id(&self) -> node_id { next_node_id(self.sess) }\n+    pub fn get_id(&self) -> NodeId { next_node_id(self.sess) }\n \n     pub fn id_to_str(&self, id: ident) -> @str {\n         get_ident_interner().get(id.name)\n@@ -837,7 +837,7 @@ impl Parser {\n                 debug!(\"parse_trait_methods(): parsing required method\");\n                 // NB: at the moment, visibility annotations on required\n                 // methods are ignored; this could change.\n-                required(ty_method {\n+                required(TypeMethod {\n                     ident: ident,\n                     attrs: attrs,\n                     purity: pur,\n@@ -889,20 +889,18 @@ impl Parser {\n \n     // parse [mut/const/imm] ID : TY\n     // now used only by obsolete record syntax parser...\n-    pub fn parse_ty_field(&self) -> ty_field {\n+    pub fn parse_ty_field(&self) -> TypeField {\n         let lo = self.span.lo;\n         let mutbl = self.parse_mutability();\n         let id = self.parse_ident();\n         self.expect(&token::COLON);\n         let ty = ~self.parse_ty(false);\n-        spanned(\n-            lo,\n-            ty.span.hi,\n-            ast::ty_field_ {\n-                ident: id,\n-                mt: ast::mt { ty: ty, mutbl: mutbl },\n-            }\n-        )\n+        let hi = ty.span.hi;\n+        ast::TypeField {\n+            ident: id,\n+            mt: ast::mt { ty: ty, mutbl: mutbl },\n+            span: mk_sp(lo, hi),\n+        }\n     }\n \n     // parse optional return type [ -> TY ] in function decl\n@@ -1614,7 +1612,7 @@ impl Parser {\n             }\n         } else if *self.token == token::LBRACE {\n             self.bump();\n-            let blk = self.parse_block_tail(lo, default_blk);\n+            let blk = self.parse_block_tail(lo, DefaultBlock);\n             return self.mk_expr(blk.span.lo, blk.span.hi,\n                                  expr_block(blk));\n         } else if token::is_bar(&*self.token) {\n@@ -1643,7 +1641,7 @@ impl Parser {\n         } else if self.eat_keyword(keywords::Match) {\n             return self.parse_match_expr();\n         } else if self.eat_keyword(keywords::Unsafe) {\n-            return self.parse_block_expr(lo, unsafe_blk);\n+            return self.parse_block_expr(lo, UnsafeBlock);\n         } else if *self.token == token::LBRACKET {\n             self.bump();\n             let mutbl = self.parse_mutability();\n@@ -1779,7 +1777,7 @@ impl Parser {\n     }\n \n     // parse a block or unsafe block\n-    pub fn parse_block_expr(&self, lo: BytePos, blk_mode: blk_check_mode)\n+    pub fn parse_block_expr(&self, lo: BytePos, blk_mode: BlockCheckMode)\n                             -> @expr {\n         self.expect(&token::LBRACE);\n         let blk = self.parse_block_tail(lo, blk_mode);\n@@ -2308,7 +2306,7 @@ impl Parser {\n             stmts: ~[],\n             expr: Some(body),\n             id: self.get_id(),\n-            rules: default_blk,\n+            rules: DefaultBlock,\n             span: body.span,\n         };\n \n@@ -2474,7 +2472,7 @@ impl Parser {\n                 stmts: ~[],\n                 expr: Some(expr),\n                 id: self.get_id(),\n-                rules: default_blk,\n+                rules: DefaultBlock,\n                 span: expr.span,\n             };\n \n@@ -3093,7 +3091,7 @@ impl Parser {\n         }\n         self.expect(&token::LBRACE);\n \n-        return self.parse_block_tail_(lo, default_blk, ~[]);\n+        return self.parse_block_tail_(lo, DefaultBlock, ~[]);\n     }\n \n     // parse a block. Inner attrs are allowed.\n@@ -3109,19 +3107,19 @@ impl Parser {\n         self.expect(&token::LBRACE);\n         let (inner, next) = self.parse_inner_attrs_and_next();\n \n-        (inner, self.parse_block_tail_(lo, default_blk, next))\n+        (inner, self.parse_block_tail_(lo, DefaultBlock, next))\n     }\n \n     // Precondition: already parsed the '{' or '#{'\n     // I guess that also means \"already parsed the 'impure'\" if\n     // necessary, and this should take a qualifier.\n     // some blocks start with \"#{\"...\n-    fn parse_block_tail(&self, lo: BytePos, s: blk_check_mode) -> Block {\n+    fn parse_block_tail(&self, lo: BytePos, s: BlockCheckMode) -> Block {\n         self.parse_block_tail_(lo, s, ~[])\n     }\n \n     // parse the rest of a block expression or function body\n-    fn parse_block_tail_(&self, lo: BytePos, s: blk_check_mode,\n+    fn parse_block_tail_(&self, lo: BytePos, s: BlockCheckMode,\n                          first_item_attrs: ~[Attribute]) -> Block {\n         let mut stmts = ~[];\n         let mut expr = None;"}, {"sha": "7083d6655f1d0bed9627743353c3aaaa32cdb252", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -807,7 +807,7 @@ pub fn print_variant(s: @ps, v: &ast::variant) {\n     }\n }\n \n-pub fn print_ty_method(s: @ps, m: &ast::ty_method) {\n+pub fn print_ty_method(s: @ps, m: &ast::TypeMethod) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, m.span.lo);\n     print_outer_attributes(s, m.attrs);\n@@ -948,8 +948,8 @@ pub fn print_possibly_embedded_block_(s: @ps,\n                                       attrs: &[ast::Attribute],\n                                       close_box: bool) {\n     match blk.rules {\n-      ast::unsafe_blk => word_space(s, \"unsafe\"),\n-      ast::default_blk => ()\n+      ast::UnsafeBlock => word_space(s, \"unsafe\"),\n+      ast::DefaultBlock => ()\n     }\n     maybe_print_comment(s, blk.span.lo);\n     let ann_node = node_block(s, blk);\n@@ -1272,7 +1272,7 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n             // in the case of foo => expr\n             if arm.body.view_items.is_empty() &&\n                 arm.body.stmts.is_empty() &&\n-                arm.body.rules == ast::default_blk &&\n+                arm.body.rules == ast::DefaultBlock &&\n                 arm.body.expr.is_some()\n             {\n                 match arm.body.expr {"}, {"sha": "1d264bcc20ece5ea6c05253f71f4cb6c5e28e14f", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -71,7 +71,7 @@ pub fn generics_of_fn(fk: &fn_kind) -> Generics {\n }\n \n pub struct Visitor<E> {\n-    visit_mod: @fn(&_mod, span, node_id, (E, vt<E>)),\n+    visit_mod: @fn(&_mod, span, NodeId, (E, vt<E>)),\n     visit_view_item: @fn(&view_item, (E, vt<E>)),\n     visit_foreign_item: @fn(@foreign_item, (E, vt<E>)),\n     visit_item: @fn(@item, (E, vt<E>)),\n@@ -85,10 +85,10 @@ pub struct Visitor<E> {\n     visit_expr_post: @fn(@expr, (E, vt<E>)),\n     visit_ty: @fn(&Ty, (E, vt<E>)),\n     visit_generics: @fn(&Generics, (E, vt<E>)),\n-    visit_fn: @fn(&fn_kind, &fn_decl, &Block, span, node_id, (E, vt<E>)),\n-    visit_ty_method: @fn(&ty_method, (E, vt<E>)),\n+    visit_fn: @fn(&fn_kind, &fn_decl, &Block, span, NodeId, (E, vt<E>)),\n+    visit_ty_method: @fn(&TypeMethod, (E, vt<E>)),\n     visit_trait_method: @fn(&trait_method, (E, vt<E>)),\n-    visit_struct_def: @fn(@struct_def, ident, &Generics, node_id, (E, vt<E>)),\n+    visit_struct_def: @fn(@struct_def, ident, &Generics, NodeId, (E, vt<E>)),\n     visit_struct_field: @fn(@struct_field, (E, vt<E>)),\n }\n \n@@ -119,12 +119,12 @@ pub fn default_visitor<E:Clone>() -> visitor<E> {\n }\n \n pub fn visit_crate<E:Clone>(c: &Crate, (e, v): (E, vt<E>)) {\n-    (v.visit_mod)(&c.module, c.span, crate_node_id, (e, v));\n+    (v.visit_mod)(&c.module, c.span, CRATE_NODE_ID, (e, v));\n }\n \n pub fn visit_mod<E:Clone>(m: &_mod,\n                           _sp: span,\n-                          _id: node_id,\n+                          _id: NodeId,\n                           (e, v): (E, vt<E>)) {\n     for m.view_items.iter().advance |vi| {\n         (v.visit_view_item)(vi, (e.clone(), v));\n@@ -387,14 +387,14 @@ pub fn visit_method_helper<E:Clone>(m: &method, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_fn<E:Clone>(fk: &fn_kind, decl: &fn_decl, body: &Block, _sp: span,\n-                         _id: node_id, (e, v): (E, vt<E>)) {\n+                         _id: NodeId, (e, v): (E, vt<E>)) {\n     visit_fn_decl(decl, (e.clone(), v));\n     let generics = generics_of_fn(fk);\n     (v.visit_generics)(&generics, (e.clone(), v));\n     (v.visit_block)(body, (e, v));\n }\n \n-pub fn visit_ty_method<E:Clone>(m: &ty_method, (e, v): (E, vt<E>)) {\n+pub fn visit_ty_method<E:Clone>(m: &TypeMethod, (e, v): (E, vt<E>)) {\n     for m.decl.inputs.iter().advance |a| {\n         (v.visit_ty)(&a.ty, (e.clone(), v));\n     }\n@@ -413,7 +413,7 @@ pub fn visit_struct_def<E:Clone>(\n     sd: @struct_def,\n     _nm: ast::ident,\n     _generics: &Generics,\n-    _id: node_id,\n+    _id: NodeId,\n     (e, v): (E, vt<E>)\n ) {\n     for sd.fields.iter().advance |f| {\n@@ -579,7 +579,7 @@ pub fn visit_arm<E:Clone>(a: &arm, (e, v): (E, vt<E>)) {\n // calls the given functions on the nodes.\n \n pub struct SimpleVisitor {\n-    visit_mod: @fn(&_mod, span, node_id),\n+    visit_mod: @fn(&_mod, span, NodeId),\n     visit_view_item: @fn(&view_item),\n     visit_foreign_item: @fn(@foreign_item),\n     visit_item: @fn(@item),\n@@ -593,10 +593,10 @@ pub struct SimpleVisitor {\n     visit_expr_post: @fn(@expr),\n     visit_ty: @fn(&Ty),\n     visit_generics: @fn(&Generics),\n-    visit_fn: @fn(&fn_kind, &fn_decl, &Block, span, node_id),\n-    visit_ty_method: @fn(&ty_method),\n+    visit_fn: @fn(&fn_kind, &fn_decl, &Block, span, NodeId),\n+    visit_ty_method: @fn(&TypeMethod),\n     visit_trait_method: @fn(&trait_method),\n-    visit_struct_def: @fn(@struct_def, ident, &Generics, node_id),\n+    visit_struct_def: @fn(@struct_def, ident, &Generics, NodeId),\n     visit_struct_field: @fn(@struct_field),\n     visit_struct_method: @fn(@method)\n }\n@@ -632,10 +632,10 @@ pub fn default_simple_visitor() -> @SimpleVisitor {\n \n pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n     fn v_mod(\n-        f: @fn(&_mod, span, node_id),\n+        f: @fn(&_mod, span, NodeId),\n         m: &_mod,\n         sp: span,\n-        id: node_id,\n+        id: NodeId,\n         (e, v): ((), vt<()>)\n     ) {\n         f(m, sp, id);\n@@ -688,7 +688,7 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(ty);\n         visit_ty(ty, (e, v));\n     }\n-    fn v_ty_method(f: @fn(&ty_method), ty: &ty_method, (e, v): ((), vt<()>)) {\n+    fn v_ty_method(f: @fn(&TypeMethod), ty: &TypeMethod, (e, v): ((), vt<()>)) {\n         f(ty);\n         visit_ty_method(ty, (e, v));\n     }\n@@ -699,11 +699,11 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         visit_trait_method(m, (e, v));\n     }\n     fn v_struct_def(\n-        f: @fn(@struct_def, ident, &Generics, node_id),\n+        f: @fn(@struct_def, ident, &Generics, NodeId),\n         sd: @struct_def,\n         nm: ident,\n         generics: &Generics,\n-        id: node_id,\n+        id: NodeId,\n         (e, v): ((), vt<()>)\n     ) {\n         f(sd, nm, generics, id);\n@@ -718,12 +718,12 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         visit_generics(ps, (e, v));\n     }\n     fn v_fn(\n-        f: @fn(&fn_kind, &fn_decl, &Block, span, node_id),\n+        f: @fn(&fn_kind, &fn_decl, &Block, span, NodeId),\n         fk: &fn_kind,\n         decl: &fn_decl,\n         body: &Block,\n         sp: span,\n-        id: node_id,\n+        id: NodeId,\n         (e, v): ((), vt<()>)\n     ) {\n         f(fk, decl, body, sp, id);"}, {"sha": "83f0dc71aa0f7cd3ae932ece171eec8db1e6ca33", "filename": "src/test/compile-fail/qquote-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -23,7 +23,7 @@ use syntax::print::*;\n \n \n trait fake_ext_ctxt {\n-    fn cfg() -> ast::Crate_cfg;\n+    fn cfg() -> ast::CrateConfig;\n     fn parse_sess() -> parse::parse_sess;\n     fn call_site() -> span;\n     fn ident_of(st: &str) -> ast::ident;\n@@ -32,7 +32,7 @@ trait fake_ext_ctxt {\n type fake_session = parse::parse_sess;\n \n impl fake_ext_ctxt for fake_session {\n-    fn cfg() -> ast::Crate_cfg { ~[] }\n+    fn cfg() -> ast::CrateConfig { ~[] }\n     fn parse_sess() -> parse::parse_sess { self }\n     fn call_site() -> span {\n         codemap::span {"}, {"sha": "c9981f7b0319d530d85517ed8d40851d30cef899", "filename": "src/test/compile-fail/qquote-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -22,7 +22,7 @@ use syntax::parse::parser;\n use syntax::print::*;\n \n trait fake_ext_ctxt {\n-    fn cfg() -> ast::Crate_cfg;\n+    fn cfg() -> ast::CrateConfig;\n     fn parse_sess() -> parse::parse_sess;\n     fn call_site() -> span;\n     fn ident_of(st: &str) -> ast::ident;\n@@ -31,7 +31,7 @@ trait fake_ext_ctxt {\n type fake_session = parse::parse_sess;\n \n impl fake_ext_ctxt for fake_session {\n-    fn cfg() -> ast::Crate_cfg { ~[] }\n+    fn cfg() -> ast::CrateConfig { ~[] }\n     fn parse_sess() -> parse::parse_sess { self }\n     fn call_site() -> span {\n         codemap::span {"}, {"sha": "4ab3b8ea65a40ce435664561a756832dc3c1c98a", "filename": "src/test/run-pass-fulldeps/issue-1926.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -32,18 +32,18 @@ fn new_parse_sess() -> parser::parse_sess {\n \n trait fake_ext_ctxt {\n     fn session() -> fake_session;\n-    fn cfg() -> ast::Crate_cfg;\n+    fn cfg() -> ast::CrateConfig;\n     fn parse_sess() -> parser::parse_sess;\n }\n \n-type fake_options = {cfg: ast::Crate_cfg};\n+type fake_options = {cfg: ast::CrateConfig};\n \n type fake_session = {opts: @fake_options,\n                      parse_sess: parser::parse_sess};\n \n impl of fake_ext_ctxt for fake_session {\n     fn session() -> fake_session {self}\n-    fn cfg() -> ast::Crate_cfg { self.opts.cfg }\n+    fn cfg() -> ast::CrateConfig { self.opts.cfg }\n     fn parse_sess() -> parser::parse_sess { self.parse_sess }\n }\n "}, {"sha": "ce5225055e2e173706d61f6ef76c2d2c03f59272", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a329770b6d0bc526e5873c143a5db1b551d42c1/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=8a329770b6d0bc526e5873c143a5db1b551d42c1", "patch": "@@ -24,7 +24,7 @@ use syntax::print::*;\n \n \n trait fake_ext_ctxt {\n-    fn cfg() -> ast::Crate_cfg;\n+    fn cfg() -> ast::CrateConfig;\n     fn parse_sess() -> parse::parse_sess;\n     fn call_site() -> span;\n     fn ident_of(st: &str) -> ast::ident;\n@@ -33,7 +33,7 @@ trait fake_ext_ctxt {\n type fake_session = parse::parse_sess;\n \n impl fake_ext_ctxt for fake_session {\n-    fn cfg() -> ast::Crate_cfg { ~[] }\n+    fn cfg() -> ast::CrateConfig { ~[] }\n     fn parse_sess() -> parse::parse_sess { self }\n     fn call_site() -> span {\n         codemap::span {"}]}