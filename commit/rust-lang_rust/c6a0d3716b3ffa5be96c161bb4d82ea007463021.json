{"sha": "c6a0d3716b3ffa5be96c161bb4d82ea007463021", "node_id": "C_kwDOAAsO6NoAKGM2YTBkMzcxNmIzZmZhNWJlOTZjMTYxYmI0ZDgyZWEwMDc0NjMwMjE", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2023-02-17T10:41:31Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2023-02-17T18:20:34Z"}, "message": "Move windows i128 indirect return handling to lib_call", "tree": {"sha": "5717c64c34fd3c3069bfe47f1d63a5336ede9ac6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5717c64c34fd3c3069bfe47f1d63a5336ede9ac6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6a0d3716b3ffa5be96c161bb4d82ea007463021", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6a0d3716b3ffa5be96c161bb4d82ea007463021", "html_url": "https://github.com/rust-lang/rust/commit/c6a0d3716b3ffa5be96c161bb4d82ea007463021", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6a0d3716b3ffa5be96c161bb4d82ea007463021/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ede7cde065d94fa53127c70c7db7f86c58eb749f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ede7cde065d94fa53127c70c7db7f86c58eb749f", "html_url": "https://github.com/rust-lang/rust/commit/ede7cde065d94fa53127c70c7db7f86c58eb749f"}], "stats": {"total": 64, "additions": 33, "deletions": 31}, "files": [{"sha": "f1c3ea61636b4d168c1697666c26808c1314068a", "filename": "src/abi/mod.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c6a0d3716b3ffa5be96c161bb4d82ea007463021/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a0d3716b3ffa5be96c161bb4d82ea007463021/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=c6a0d3716b3ffa5be96c161bb4d82ea007463021", "patch": "@@ -4,6 +4,8 @@ mod comments;\n mod pass_mode;\n mod returning;\n \n+use std::borrow::Cow;\n+\n use cranelift_module::ModuleError;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::ty::layout::FnAbiOf;\n@@ -116,11 +118,11 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         params: Vec<AbiParam>,\n         returns: Vec<AbiParam>,\n         args: &[Value],\n-    ) -> &[Value] {\n+    ) -> Cow<'_, [Value]> {\n         if self.tcx.sess.target.is_like_windows\n             && params.iter().any(|param| param.value_type == types::I128)\n         {\n-            let (params, args): (Vec<_>, Vec<_>) =\n+            let (mut params, mut args): (Vec<_>, Vec<_>) =\n                 params\n                     .into_iter()\n                     .zip(args)\n@@ -136,7 +138,22 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n                         }\n                     })\n                     .unzip();\n-            return self.lib_call(name, params, returns, &args);\n+\n+            let indirect_ret_val = returns.len() == 1 && returns[0].value_type == types::I128;\n+\n+            if indirect_ret_val {\n+                params.insert(0, AbiParam::new(types::I128));\n+                let ret_ptr =\n+                    Pointer::stack_slot(self.bcx.create_sized_stack_slot(StackSlotData {\n+                        kind: StackSlotKind::ExplicitSlot,\n+                        size: 16,\n+                    }));\n+                args.insert(0, ret_ptr.get_addr(self));\n+                self.lib_call(name, params, vec![], &args);\n+                return Cow::Owned(vec![ret_ptr.load(self, types::I128, MemFlags::trusted())]);\n+            } else {\n+                return self.lib_call(name, params, returns, &args);\n+            }\n         }\n \n         let sig = Signature { params, returns, call_conv: self.target_config.default_call_conv };\n@@ -151,7 +168,7 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         }\n         let results = self.bcx.inst_results(call_inst);\n         assert!(results.len() <= 2, \"{}\", results.len());\n-        results\n+        Cow::Borrowed(results)\n     }\n }\n "}, {"sha": "6640f0f358780cec7b2b04ec85f6604feb61ced2", "filename": "src/codegen_i128.rs", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c6a0d3716b3ffa5be96c161bb4d82ea007463021/src%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a0d3716b3ffa5be96c161bb4d82ea007463021/src%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodegen_i128.rs?ref=c6a0d3716b3ffa5be96c161bb4d82ea007463021", "patch": "@@ -29,32 +29,17 @@ pub(crate) fn maybe_codegen<'tcx>(\n         BinOp::Add | BinOp::Sub if !checked => None,\n         BinOp::Mul if !checked || is_signed => {\n             if !checked {\n-                let val_ty = if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n-                if fx.tcx.sess.target.is_like_windows {\n-                    let ret_place = CPlace::new_stack_slot(fx, lhs.layout());\n-                    let args =\n-                        [ret_place.to_ptr().get_addr(fx), lhs.load_scalar(fx), rhs.load_scalar(fx)];\n-                    fx.lib_call(\n-                        \"__multi3\",\n-                        vec![\n-                            AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n-                            AbiParam::new(types::I128),\n-                            AbiParam::new(types::I128),\n-                        ],\n-                        vec![],\n-                        &args,\n-                    );\n-                    Some(ret_place.to_cvalue(fx))\n-                } else {\n-                    let args: Vec<_> = vec![lhs.load_scalar(fx), rhs.load_scalar(fx)];\n-                    let ret_val = fx.lib_call(\n-                        \"__multi3\",\n-                        vec![AbiParam::new(types::I128), AbiParam::new(types::I128)],\n-                        vec![AbiParam::new(types::I128)],\n-                        &args,\n-                    )[0];\n-                    Some(CValue::by_val(ret_val, fx.layout_of(val_ty)))\n-                }\n+                let args = [lhs.load_scalar(fx), rhs.load_scalar(fx)];\n+                let ret_val = fx.lib_call(\n+                    \"__multi3\",\n+                    vec![AbiParam::new(types::I128), AbiParam::new(types::I128)],\n+                    vec![AbiParam::new(types::I128)],\n+                    &args,\n+                )[0];\n+                Some(CValue::by_val(\n+                    ret_val,\n+                    fx.layout_of(if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 }),\n+                ))\n             } else {\n                 let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n                 let oflow = CPlace::new_stack_slot(fx, fx.layout_of(fx.tcx.types.i32));\n@@ -120,7 +105,7 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 ret_place.to_ptr().store(fx, ret, MemFlags::trusted());\n                 Some(ret_place.to_cvalue(fx))\n             } else {\n-                let args: Vec<_> = vec![lhs.load_scalar(fx), rhs.load_scalar(fx)];\n+                let args = [lhs.load_scalar(fx), rhs.load_scalar(fx)];\n                 let ret_val = fx.lib_call(\n                     name,\n                     vec![AbiParam::new(types::I128), AbiParam::new(types::I128)],"}]}