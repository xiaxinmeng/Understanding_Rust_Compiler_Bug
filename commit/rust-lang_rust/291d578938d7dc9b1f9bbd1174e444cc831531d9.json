{"sha": "291d578938d7dc9b1f9bbd1174e444cc831531d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5MWQ1Nzg5MzhkN2RjOWIxZjliYmQxMTc0ZTQ0NGNjODMxNTMxZDk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-04T13:01:06Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-04T13:58:10Z"}, "message": "extract area to a crate", "tree": {"sha": "153e44aa0ccb17be658acbc9ae2e62d2a87178ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/153e44aa0ccb17be658acbc9ae2e62d2a87178ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/291d578938d7dc9b1f9bbd1174e444cc831531d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/291d578938d7dc9b1f9bbd1174e444cc831531d9", "html_url": "https://github.com/rust-lang/rust/commit/291d578938d7dc9b1f9bbd1174e444cc831531d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/291d578938d7dc9b1f9bbd1174e444cc831531d9/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "821fa7a50ab8c4886adc60a2093aa8e06cc3a9d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/821fa7a50ab8c4886adc60a2093aa8e06cc3a9d6", "html_url": "https://github.com/rust-lang/rust/commit/821fa7a50ab8c4886adc60a2093aa8e06cc3a9d6"}], "stats": {"total": 236, "additions": 142, "deletions": 94}, "files": [{"sha": "4666347f8eefbd958d9f2417d073d82fb5be7928", "filename": "Cargo.lock", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/291d578938d7dc9b1f9bbd1174e444cc831531d9/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/291d578938d7dc9b1f9bbd1174e444cc831531d9/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=291d578938d7dc9b1f9bbd1174e444cc831531d9", "patch": "@@ -683,6 +683,10 @@ dependencies = [\n  \"unicase 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"ra_arena\"\n+version = \"0.1.0\"\n+\n [[package]]\n name = \"ra_cli\"\n version = \"0.1.0\"\n@@ -808,6 +812,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"crossbeam-channel 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_arena 0.1.0\",\n  \"relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "9594e2d0f518d95bfb3f82f29f4d5d2d9218725c", "filename": "crates/ra_arena/Cargo.toml", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/291d578938d7dc9b1f9bbd1174e444cc831531d9/crates%2Fra_arena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/291d578938d7dc9b1f9bbd1174e444cc831531d9/crates%2Fra_arena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_arena%2FCargo.toml?ref=291d578938d7dc9b1f9bbd1174e444cc831531d9", "patch": "@@ -0,0 +1,5 @@\n+[package]\n+edition = \"2018\"\n+name = \"ra_arena\"\n+version = \"0.1.0\"\n+authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]"}, {"sha": "44d9e826b142eed69147026a0e6ff4c99e92b005", "filename": "crates/ra_arena/src/lib.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/291d578938d7dc9b1f9bbd1174e444cc831531d9/crates%2Fra_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291d578938d7dc9b1f9bbd1174e444cc831531d9/crates%2Fra_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_arena%2Fsrc%2Flib.rs?ref=291d578938d7dc9b1f9bbd1174e444cc831531d9", "patch": "@@ -0,0 +1,97 @@\n+//! Yet another index-based arena.\n+\n+use std::{\n+    fmt,\n+    marker::PhantomData,\n+    ops::{Index, IndexMut},\n+};\n+\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct RawId(u32);\n+\n+impl From<RawId> for u32 {\n+    fn from(raw: RawId) -> u32 {\n+        raw.0\n+    }\n+}\n+\n+impl From<u32> for RawId {\n+    fn from(id: u32) -> RawId {\n+        RawId(id)\n+    }\n+}\n+\n+impl fmt::Debug for RawId {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+impl fmt::Display for RawId {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Arena<ID: ArenaId, T> {\n+    data: Vec<T>,\n+    _ty: PhantomData<ID>,\n+}\n+\n+#[macro_export]\n+macro_rules! impl_arena_id {\n+    ($name:ident) => {\n+        impl $crate::ArenaId for $name {\n+            fn from_raw(raw: $crate::RawId) -> Self {\n+                $name(raw)\n+            }\n+            fn into_raw(self) -> $crate::RawId {\n+                self.0\n+            }\n+        }\n+    };\n+}\n+\n+pub trait ArenaId {\n+    fn from_raw(raw: RawId) -> Self;\n+    fn into_raw(self) -> RawId;\n+}\n+\n+impl<ID: ArenaId, T> Arena<ID, T> {\n+    pub fn alloc(&mut self, value: T) -> ID {\n+        let id = RawId(self.data.len() as u32);\n+        self.data.push(value);\n+        ID::from_raw(id)\n+    }\n+    pub fn iter<'a>(&'a self) -> impl Iterator<Item = (ID, &'a T)> {\n+        self.data\n+            .iter()\n+            .enumerate()\n+            .map(|(idx, value)| (ID::from_raw(RawId(idx as u32)), value))\n+    }\n+}\n+\n+impl<ID: ArenaId, T> Default for Arena<ID, T> {\n+    fn default() -> Arena<ID, T> {\n+        Arena {\n+            data: Vec::new(),\n+            _ty: PhantomData,\n+        }\n+    }\n+}\n+\n+impl<ID: ArenaId, T> Index<ID> for Arena<ID, T> {\n+    type Output = T;\n+    fn index(&self, idx: ID) -> &T {\n+        let idx = idx.into_raw().0 as usize;\n+        &self.data[idx]\n+    }\n+}\n+\n+impl<ID: ArenaId, T> IndexMut<ID> for Arena<ID, T> {\n+    fn index_mut(&mut self, idx: ID) -> &mut T {\n+        let idx = idx.into_raw().0 as usize;\n+        &mut self.data[idx]\n+    }\n+}"}, {"sha": "60d9671dee7b139049d7c67c5b5c554802a371ea", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/291d578938d7dc9b1f9bbd1174e444cc831531d9/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291d578938d7dc9b1f9bbd1174e444cc831531d9/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=291d578938d7dc9b1f9bbd1174e444cc831531d9", "patch": "@@ -350,7 +350,7 @@ fn on_notification(\n                 .write()\n                 .add_file_overlay(&path, params.text_document.text)\n             {\n-                subs.add_sub(FileId(file_id.0));\n+                subs.add_sub(FileId(file_id.0.into()));\n             }\n             return Ok(());\n         }\n@@ -379,7 +379,7 @@ fn on_notification(\n                 .to_file_path()\n                 .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n             if let Some(file_id) = state.vfs.write().remove_file_overlay(path.as_path()) {\n-                subs.remove_sub(FileId(file_id.0));\n+                subs.remove_sub(FileId(file_id.0.into()));\n             }\n             let params = req::PublishDiagnosticsParams {\n                 uri,"}, {"sha": "4e895a9a9ea0892ce021afedc9065305e5c64e8a", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/291d578938d7dc9b1f9bbd1174e444cc831531d9/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291d578938d7dc9b1f9bbd1174e444cc831531d9/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=291d578938d7dc9b1f9bbd1174e444cc831531d9", "patch": "@@ -337,7 +337,10 @@ pub fn handle_runnables(\n                 None => return Ok(None),\n             };\n             let file_id = world.analysis().crate_root(crate_id)?;\n-            let path = world.vfs.read().file2path(ra_vfs::VfsFile(file_id.0));\n+            let path = world\n+                .vfs\n+                .read()\n+                .file2path(ra_vfs::VfsFile(file_id.0.into()));\n             let res = world.workspaces.iter().find_map(|ws| {\n                 let tgt = ws.target_by_root(&path)?;\n                 let res = CargoTargetSpec {"}, {"sha": "ebf2b15ccd80d120f9c05d0e672d00647e2bc4ec", "filename": "crates/ra_lsp_server/src/server_world.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/291d578938d7dc9b1f9bbd1174e444cc831531d9/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291d578938d7dc9b1f9bbd1174e444cc831531d9/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs?ref=291d578938d7dc9b1f9bbd1174e444cc831531d9", "patch": "@@ -49,7 +49,7 @@ impl ServerWorldState {\n         let (mut vfs, roots) = Vfs::new(roots);\n         for r in roots {\n             let is_local = vfs.root2path(r).starts_with(&root);\n-            change.add_root(SourceRootId(r.0), is_local);\n+            change.add_root(SourceRootId(r.0.into()), is_local);\n         }\n \n         let mut crate_graph = CrateGraph::default();\n@@ -60,7 +60,7 @@ impl ServerWorldState {\n                 for tgt in pkg.targets(ws) {\n                     let root = tgt.root(ws);\n                     if let Some(file_id) = vfs.load(root) {\n-                        let file_id = FileId(file_id.0);\n+                        let file_id = FileId(file_id.0.into());\n                         let crate_id = crate_graph.add_crate_root(file_id);\n                         if tgt.kind(ws) == TargetKind::Lib {\n                             pkg_to_lib_crate.insert(pkg, crate_id);\n@@ -113,14 +113,19 @@ impl ServerWorldState {\n                     if root_path.starts_with(&self.root) {\n                         self.roots_to_scan -= 1;\n                         for (file, path, text) in files {\n-                            change.add_file(SourceRootId(root.0), FileId(file.0), path, text);\n+                            change.add_file(\n+                                SourceRootId(root.0.into()),\n+                                FileId(file.0.into()),\n+                                path,\n+                                text,\n+                            );\n                         }\n                     } else {\n                         let files = files\n                             .into_iter()\n-                            .map(|(vfsfile, path, text)| (FileId(vfsfile.0), path, text))\n+                            .map(|(vfsfile, path, text)| (FileId(vfsfile.0.into()), path, text))\n                             .collect();\n-                        libs.push((SourceRootId(root.0), files));\n+                        libs.push((SourceRootId(root.0.into()), files));\n                     }\n                 }\n                 VfsChange::AddFile {\n@@ -129,13 +134,18 @@ impl ServerWorldState {\n                     path,\n                     text,\n                 } => {\n-                    change.add_file(SourceRootId(root.0), FileId(file.0), path, text);\n+                    change.add_file(\n+                        SourceRootId(root.0.into()),\n+                        FileId(file.0.into()),\n+                        path,\n+                        text,\n+                    );\n                 }\n                 VfsChange::RemoveFile { root, file, path } => {\n-                    change.remove_file(SourceRootId(root.0), FileId(file.0), path)\n+                    change.remove_file(SourceRootId(root.0.into()), FileId(file.0.into()), path)\n                 }\n                 VfsChange::ChangeFile { file, text } => {\n-                    change.change_file(FileId(file.0), text);\n+                    change.change_file(FileId(file.0.into()), text);\n                 }\n             }\n         }\n@@ -173,18 +183,18 @@ impl ServerWorld {\n             .read()\n             .path2file(&path)\n             .ok_or_else(|| format_err!(\"unknown file: {}\", path.display()))?;\n-        Ok(FileId(file.0))\n+        Ok(FileId(file.0.into()))\n     }\n \n     pub fn file_id_to_uri(&self, id: FileId) -> Result<Url> {\n-        let path = self.vfs.read().file2path(VfsFile(id.0));\n+        let path = self.vfs.read().file2path(VfsFile(id.0.into()));\n         let url = Url::from_file_path(&path)\n             .map_err(|_| format_err!(\"can't convert path to url: {}\", path.display()))?;\n         Ok(url)\n     }\n \n     pub fn path_to_uri(&self, root: SourceRootId, path: &RelativePathBuf) -> Result<Url> {\n-        let base = self.vfs.read().root2path(VfsRoot(root.0));\n+        let base = self.vfs.read().root2path(VfsRoot(root.0.into()));\n         let path = path.to_path(base);\n         let url = Url::from_file_path(&path)\n             .map_err(|_| format_err!(\"can't convert path to url: {}\", path.display()))?;"}, {"sha": "e637063c97b34d97149edbd5b98a852648f76fe6", "filename": "crates/ra_vfs/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/291d578938d7dc9b1f9bbd1174e444cc831531d9/crates%2Fra_vfs%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/291d578938d7dc9b1f9bbd1174e444cc831531d9/crates%2Fra_vfs%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2FCargo.toml?ref=291d578938d7dc9b1f9bbd1174e444cc831531d9", "patch": "@@ -12,6 +12,7 @@ crossbeam-channel = \"0.3.5\"\n log = \"0.4.6\"\n \n thread_worker = { path = \"../thread_worker\" }\n+ra_arena = { path = \"../ra_arena\" }\n \n [dev-dependencies]\n tempfile = \"3\""}, {"sha": "6b42ae26d22d432d188aa459de45c8ddfc9ac42b", "filename": "crates/ra_vfs/src/arena.rs", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/821fa7a50ab8c4886adc60a2093aa8e06cc3a9d6/crates%2Fra_vfs%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/821fa7a50ab8c4886adc60a2093aa8e06cc3a9d6/crates%2Fra_vfs%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Farena.rs?ref=821fa7a50ab8c4886adc60a2093aa8e06cc3a9d6", "patch": "@@ -1,53 +0,0 @@\n-use std::{\n-    marker::PhantomData,\n-    ops::{Index, IndexMut},\n-};\n-\n-#[derive(Clone, Debug)]\n-pub(crate) struct Arena<ID: ArenaId, T> {\n-    data: Vec<T>,\n-    _ty: PhantomData<ID>,\n-}\n-\n-pub(crate) trait ArenaId {\n-    fn from_u32(id: u32) -> Self;\n-    fn to_u32(self) -> u32;\n-}\n-\n-impl<ID: ArenaId, T> Arena<ID, T> {\n-    pub fn alloc(&mut self, value: T) -> ID {\n-        let id = self.data.len() as u32;\n-        self.data.push(value);\n-        ID::from_u32(id)\n-    }\n-    pub fn iter<'a>(&'a self) -> impl Iterator<Item = (ID, &'a T)> {\n-        self.data\n-            .iter()\n-            .enumerate()\n-            .map(|(idx, value)| (ID::from_u32(idx as u32), value))\n-    }\n-}\n-\n-impl<ID: ArenaId, T> Default for Arena<ID, T> {\n-    fn default() -> Arena<ID, T> {\n-        Arena {\n-            data: Vec::new(),\n-            _ty: PhantomData,\n-        }\n-    }\n-}\n-\n-impl<ID: ArenaId, T> Index<ID> for Arena<ID, T> {\n-    type Output = T;\n-    fn index(&self, idx: ID) -> &T {\n-        let idx = idx.to_u32() as usize;\n-        &self.data[idx]\n-    }\n-}\n-\n-impl<ID: ArenaId, T> IndexMut<ID> for Arena<ID, T> {\n-    fn index_mut(&mut self, idx: ID) -> &mut T {\n-        let idx = idx.to_u32() as usize;\n-        &mut self.data[idx]\n-    }\n-}"}, {"sha": "cdea18d734227494429c0a3715a3654c6c1ae2fe", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/291d578938d7dc9b1f9bbd1174e444cc831531d9/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291d578938d7dc9b1f9bbd1174e444cc831531d9/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=291d578938d7dc9b1f9bbd1174e444cc831531d9", "patch": "@@ -13,7 +13,6 @@\n //! VFS is based on a concept of roots: a set of directories on the file system\n //! which are watched for changes. Typically, there will be a root for each\n //! Cargo package.\n-mod arena;\n mod io;\n \n use std::{\n@@ -32,10 +31,7 @@ use relative_path::RelativePathBuf;\n use crossbeam_channel::Receiver;\n use walkdir::DirEntry;\n use thread_worker::WorkerHandle;\n-\n-use crate::{\n-    arena::{ArenaId, Arena},\n-};\n+use ra_arena::{Arena, RawId, impl_arena_id};\n \n pub use crate::io::TaskResult as VfsTask;\n \n@@ -68,29 +64,13 @@ fn has_rs_extension(p: &Path) -> bool {\n     p.extension() == Some(OsStr::new(\"rs\"))\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n-pub struct VfsRoot(pub u32);\n-\n-impl ArenaId for VfsRoot {\n-    fn from_u32(idx: u32) -> VfsRoot {\n-        VfsRoot(idx)\n-    }\n-    fn to_u32(self) -> u32 {\n-        self.0\n-    }\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n-pub struct VfsFile(pub u32);\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct VfsRoot(pub RawId);\n+impl_arena_id!(VfsRoot);\n \n-impl ArenaId for VfsFile {\n-    fn from_u32(idx: u32) -> VfsFile {\n-        VfsFile(idx)\n-    }\n-    fn to_u32(self) -> u32 {\n-        self.0\n-    }\n-}\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct VfsFile(pub RawId);\n+impl_arena_id!(VfsFile);\n \n struct VfsFileData {\n     root: VfsRoot,"}]}