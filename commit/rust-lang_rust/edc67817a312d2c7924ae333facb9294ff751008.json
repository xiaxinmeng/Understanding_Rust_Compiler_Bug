{"sha": "edc67817a312d2c7924ae333facb9294ff751008", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkYzY3ODE3YTMxMmQyYzc5MjRhZTMzM2ZhY2I5Mjk0ZmY3NTEwMDg=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-01-23T20:02:05Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-01-23T20:31:55Z"}, "message": "Improve libcore/cell.rs docs", "tree": {"sha": "55cf23f74982a32c6a142c1525780d0672e30987", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55cf23f74982a32c6a142c1525780d0672e30987"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edc67817a312d2c7924ae333facb9294ff751008", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edc67817a312d2c7924ae333facb9294ff751008", "html_url": "https://github.com/rust-lang/rust/commit/edc67817a312d2c7924ae333facb9294ff751008", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edc67817a312d2c7924ae333facb9294ff751008/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86fbdbfbcd4c019fda26ff73b9e1e30ed7a8b174", "url": "https://api.github.com/repos/rust-lang/rust/commits/86fbdbfbcd4c019fda26ff73b9e1e30ed7a8b174", "html_url": "https://github.com/rust-lang/rust/commit/86fbdbfbcd4c019fda26ff73b9e1e30ed7a8b174"}], "stats": {"total": 294, "additions": 209, "deletions": 85}, "files": [{"sha": "202d860021ee4fe44b9547d5accc4b05eb6ce399", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 209, "deletions": 85, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/edc67817a312d2c7924ae333facb9294ff751008/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc67817a312d2c7924ae333facb9294ff751008/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=edc67817a312d2c7924ae333facb9294ff751008", "patch": "@@ -10,55 +10,44 @@\n \n //! Shareable mutable containers.\n //!\n-//! Values of the `Cell` and `RefCell` types may be mutated through\n-//! shared references (i.e. the common `&T` type), whereas most Rust\n-//! types can only be mutated through unique (`&mut T`) references. We\n-//! say that `Cell` and `RefCell` provide *interior mutability*, in\n-//! contrast with typical Rust types that exhibit *inherited\n-//! mutability*.\n+//! Values of the `Cell<T>` and `RefCell<T>` types may be mutated through shared references (i.e.\n+//! the common `&T` type), whereas most Rust types can only be mutated through unique (`&mut T`)\n+//! references. We say that `Cell<T>` and `RefCell<T>` provide 'interior mutability', in contrast\n+//! with typical Rust types that exhibit 'inherited mutability'.\n //!\n-//! Cell types come in two flavors: `Cell` and `RefCell`. `Cell`\n-//! provides `get` and `set` methods that change the\n-//! interior value with a single method call. `Cell` though is only\n-//! compatible with types that implement `Copy`. For other types,\n-//! one must use the `RefCell` type, acquiring a write lock before\n-//! mutating.\n+//! Cell types come in two flavors: `Cell<T>` and `RefCell<T>`. `Cell<T>` provides `get` and `set`\n+//! methods that change the interior value with a single method call. `Cell<T>` though is only\n+//! compatible with types that implement `Copy`. For other types, one must use the `RefCell<T>`\n+//! type, acquiring a write lock before mutating.\n //!\n-//! `RefCell` uses Rust's lifetimes to implement *dynamic borrowing*,\n-//! a process whereby one can claim temporary, exclusive, mutable\n-//! access to the inner value. Borrows for `RefCell`s are tracked *at\n-//! runtime*, unlike Rust's native reference types which are entirely\n-//! tracked statically, at compile time. Because `RefCell` borrows are\n-//! dynamic it is possible to attempt to borrow a value that is\n-//! already mutably borrowed; when this happens it results in task\n-//! panic.\n+//! `RefCell<T>` uses Rust's lifetimes to implement 'dynamic borrowing', a process whereby one can\n+//! claim temporary, exclusive, mutable access to the inner value. Borrows for `RefCell<T>`s are\n+//! tracked 'at runtime', unlike Rust's native reference types which are entirely tracked\n+//! statically, at compile time. Because `RefCell<T>` borrows are dynamic it is possible to attempt\n+//! to borrow a value that is already mutably borrowed; when this happens it results in task panic.\n //!\n //! # When to choose interior mutability\n //!\n-//! The more common inherited mutability, where one must have unique\n-//! access to mutate a value, is one of the key language elements that\n-//! enables Rust to reason strongly about pointer aliasing, statically\n-//! preventing crash bugs. Because of that, inherited mutability is\n-//! preferred, and interior mutability is something of a last\n-//! resort. Since cell types enable mutation where it would otherwise\n-//! be disallowed though, there are occasions when interior\n-//! mutability might be appropriate, or even *must* be used, e.g.\n+//! The more common inherited mutability, where one must have unique access to mutate a value, is\n+//! one of the key language elements that enables Rust to reason strongly about pointer aliasing,\n+//! statically preventing crash bugs. Because of that, inherited mutability is preferred, and\n+//! interior mutability is something of a last resort. Since cell types enable mutation where it\n+//! would otherwise be disallowed though, there are occasions when interior mutability might be\n+//! appropriate, or even *must* be used, e.g.\n //!\n //! * Introducing inherited mutability roots to shared types.\n //! * Implementation details of logically-immutable methods.\n //! * Mutating implementations of `clone`.\n //!\n //! ## Introducing inherited mutability roots to shared types\n //!\n-//! Shared smart pointer types, including `Rc` and `Arc`, provide\n-//! containers that can be cloned and shared between multiple parties.\n-//! Because the contained values may be multiply-aliased, they can\n-//! only be borrowed as shared references, not mutable references.\n-//! Without cells it would be impossible to mutate data inside of\n-//! shared boxes at all!\n+//! Shared smart pointer types, including `Rc<T>` and `Arc<T>`, provide containers that can be\n+//! cloned and shared between multiple parties. Because the contained values may be\n+//! multiply-aliased, they can only be borrowed as shared references, not mutable references.\n+//! Without cells it would be impossible to mutate data inside of shared boxes at all!\n //!\n-//! It's very common then to put a `RefCell` inside shared pointer\n-//! types to reintroduce mutability:\n+//! It's very common then to put a `RefCell<T>` inside shared pointer types to reintroduce\n+//! mutability:\n //!\n //! ```\n //! use std::collections::HashMap;\n@@ -80,12 +69,10 @@\n //!\n //! ## Implementation details of logically-immutable methods\n //!\n-//! Occasionally it may be desirable not to expose in an API that\n-//! there is mutation happening \"under the hood\". This may be because\n-//! logically the operation is immutable, but e.g. caching forces the\n-//! implementation to perform mutation; or because you must employ\n-//! mutation to implement a trait method that was originally defined\n-//! to take `&self`.\n+//! Occasionally it may be desirable not to expose in an API that there is mutation happening\n+//! \"under the hood\". This may be because logically the operation is immutable, but e.g. caching\n+//! forces the implementation to perform mutation; or because you must employ mutation to implement\n+//! a trait method that was originally defined to take `&self`.\n //!\n //! ```\n //! use std::cell::RefCell;\n@@ -123,13 +110,11 @@\n //!\n //! ## Mutating implementations of `clone`\n //!\n-//! This is simply a special - but common - case of the previous:\n-//! hiding mutability for operations that appear to be immutable.\n-//! The `clone` method is expected to not change the source value, and\n-//! is declared to take `&self`, not `&mut self`. Therefore any\n-//! mutation that happens in the `clone` method must use cell\n-//! types. For example, `Rc` maintains its reference counts within a\n-//! `Cell`.\n+//! This is simply a special - but common - case of the previous: hiding mutability for operations\n+//! that appear to be immutable. The `clone` method is expected to not change the source value, and\n+//! is declared to take `&self`, not `&mut self`. Therefore any mutation that happens in the\n+//! `clone` method must use cell types. For example, `Rc<T>` maintains its reference counts within a\n+//! `Cell<T>`.\n //!\n //! ```\n //! use std::cell::Cell;\n@@ -153,10 +138,6 @@\n //! }\n //! ```\n //!\n-// FIXME: Explain difference between Cell and RefCell\n-// FIXME: Downsides to interior mutability\n-// FIXME: Can't be shared between threads. Dynamic borrows\n-// FIXME: Relationship to Atomic types and RWLock\n \n #![stable]\n \n@@ -169,13 +150,23 @@ use option::Option;\n use option::Option::{None, Some};\n \n /// A mutable memory location that admits only `Copy` data.\n+///\n+/// See the [module-level documentation](../index.html) for more.\n #[stable]\n pub struct Cell<T> {\n     value: UnsafeCell<T>,\n }\n \n impl<T:Copy> Cell<T> {\n     /// Creates a new `Cell` containing the given value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    /// ```\n     #[stable]\n     pub fn new(value: T) -> Cell<T> {\n         Cell {\n@@ -184,13 +175,33 @@ impl<T:Copy> Cell<T> {\n     }\n \n     /// Returns a copy of the contained value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    ///\n+    /// let five = c.get();\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn get(&self) -> T {\n         unsafe{ *self.value.get() }\n     }\n \n     /// Sets the contained value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    ///\n+    /// c.set(10);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn set(&self, value: T) {\n@@ -201,9 +212,19 @@ impl<T:Copy> Cell<T> {\n \n     /// Get a reference to the underlying `UnsafeCell`.\n     ///\n-    /// This can be used to circumvent `Cell`'s safety checks.\n+    /// # Unsafety\n     ///\n     /// This function is `unsafe` because `UnsafeCell`'s field is public.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    ///\n+    /// let uc = unsafe { c.as_unsafe_cell() };\n+    /// ```\n     #[inline]\n     #[unstable]\n     pub unsafe fn as_unsafe_cell<'a>(&'a self) -> &'a UnsafeCell<T> {\n@@ -237,6 +258,8 @@ impl<T:PartialEq + Copy> PartialEq for Cell<T> {\n }\n \n /// A mutable memory location with dynamically checked borrow rules\n+///\n+/// See the [module-level documentation](../index.html) for more.\n #[stable]\n pub struct RefCell<T> {\n     value: UnsafeCell<T>,\n@@ -250,7 +273,15 @@ const UNUSED: BorrowFlag = 0;\n const WRITING: BorrowFlag = -1;\n \n impl<T> RefCell<T> {\n-    /// Create a new `RefCell` containing `value`\n+    /// Creates a new `RefCell` containing `value`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::RefCell;\n+    ///\n+    /// let c = RefCell::new(5);\n+    /// ```\n     #[stable]\n     pub fn new(value: T) -> RefCell<T> {\n         RefCell {\n@@ -260,6 +291,16 @@ impl<T> RefCell<T> {\n     }\n \n     /// Consumes the `RefCell`, returning the wrapped value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::RefCell;\n+    ///\n+    /// let c = RefCell::new(5);\n+    ///\n+    /// let five = c.into_inner();\n+    /// ```\n     #[stable]\n     pub fn into_inner(self) -> T {\n         // Since this function takes `self` (the `RefCell`) by value, the\n@@ -285,12 +326,39 @@ impl<T> RefCell<T> {\n \n     /// Immutably borrows the wrapped value.\n     ///\n-    /// The borrow lasts until the returned `Ref` exits scope. Multiple\n-    /// immutable borrows can be taken out at the same time.\n+    /// The borrow lasts until the returned `Ref` exits scope. Multiple immutable borrows can be\n+    /// taken out at the same time.\n     ///\n     /// # Panics\n     ///\n     /// Panics if the value is currently mutably borrowed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::RefCell;\n+    ///\n+    /// let c = RefCell::new(5);\n+    ///\n+    /// let borrowed_five = c.borrow();\n+    /// let borrowed_five2 = c.borrow();\n+    /// ```\n+    ///\n+    /// An example of panic:\n+    ///\n+    /// ```\n+    /// use std::cell::RefCell;\n+    /// use std::thread::Thread;\n+    ///\n+    /// let result = Thread::scoped(move || {\n+    ///    let c = RefCell::new(5);\n+    ///    let m = c.borrow_mut();\n+    ///\n+    ///    let b = c.borrow(); // this causes a panic\n+    /// }).join();\n+    ///\n+    /// assert!(result.is_err());\n+    /// ```\n     #[stable]\n     pub fn borrow<'a>(&'a self) -> Ref<'a, T> {\n         match self.try_borrow() {\n@@ -315,12 +383,38 @@ impl<T> RefCell<T> {\n \n     /// Mutably borrows the wrapped value.\n     ///\n-    /// The borrow lasts until the returned `RefMut` exits scope. The value\n-    /// cannot be borrowed while this borrow is active.\n+    /// The borrow lasts until the returned `RefMut` exits scope. The value cannot be borrowed\n+    /// while this borrow is active.\n     ///\n     /// # Panics\n     ///\n     /// Panics if the value is currently borrowed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::RefCell;\n+    ///\n+    /// let c = RefCell::new(5);\n+    ///\n+    /// let borrowed_five = c.borrow_mut();\n+    /// ```\n+    ///\n+    /// An example of panic:\n+    ///\n+    /// ```\n+    /// use std::cell::RefCell;\n+    /// use std::thread::Thread;\n+    ///\n+    /// let result = Thread::scoped(move || {\n+    ///    let c = RefCell::new(5);\n+    ///    let m = c.borrow_mut();\n+    ///\n+    ///    let b = c.borrow_mut(); // this causes a panic\n+    /// }).join();\n+    ///\n+    /// assert!(result.is_err());\n+    /// ```\n     #[stable]\n     pub fn borrow_mut<'a>(&'a self) -> RefMut<'a, T> {\n         match self.try_borrow_mut() {\n@@ -402,7 +496,9 @@ impl<'b> Clone for BorrowRef<'b> {\n     }\n }\n \n-/// Wraps a borrowed reference to a value in a `RefCell` box.\n+/// A wrapper type for an immutably borrowed value from a `RefCell<T>`.\n+///\n+/// See the [module-level documentation](../index.html) for more.\n #[stable]\n pub struct Ref<'b, T:'b> {\n     // FIXME #12808: strange name to try to avoid interfering with\n@@ -460,7 +556,9 @@ impl<'b> BorrowRefMut<'b> {\n     }\n }\n \n-/// Wraps a mutable borrowed reference to a value in a `RefCell` box.\n+/// A wrapper type for a mutably borrowed value from a `RefCell<T>`.\n+///\n+/// See the [module-level documentation](../index.html) for more.\n #[stable]\n pub struct RefMut<'b, T:'b> {\n     // FIXME #12808: strange name to try to avoid interfering with\n@@ -489,28 +587,25 @@ impl<'b, T> DerefMut for RefMut<'b, T> {\n \n /// The core primitive for interior mutability in Rust.\n ///\n-/// `UnsafeCell` type that wraps a type T and indicates unsafe interior\n-/// operations on the wrapped type. Types with an `UnsafeCell<T>` field are\n-/// considered to have an *unsafe interior*. The `UnsafeCell` type is the only\n-/// legal way to obtain aliasable data that is considered mutable. In general,\n-/// transmuting an &T type into an &mut T is considered undefined behavior.\n+/// `UnsafeCell<T>` is a type that wraps some `T` and indicates unsafe interior operations on the\n+/// wrapped type. Types with an `UnsafeCell<T>` field are considered to have an 'unsafe interior'.\n+/// The `UnsafeCell<T>` type is the only legal way to obtain aliasable data that is considered\n+/// mutable. In general, transmuting an `&T` type into an `&mut T` is considered undefined behavior.\n ///\n-/// Although it is possible to put an `UnsafeCell<T>` into static item, it is\n-/// not permitted to take the address of the static item if the item is not\n-/// declared as mutable. This rule exists because immutable static items are\n-/// stored in read-only memory, and thus any attempt to mutate their interior\n-/// can cause segfaults. Immutable static items containing `UnsafeCell<T>`\n-/// instances are still useful as read-only initializers, however, so we do not\n-/// forbid them altogether.\n+/// Although it is possible to put an `UnsafeCell<T>` into static item, it is not permitted to take\n+/// the address of the static item if the item is not declared as mutable. This rule exists because\n+/// immutable static items are stored in read-only memory, and thus any attempt to mutate their\n+/// interior can cause segfaults. Immutable static items containing `UnsafeCell<T>` instances are\n+/// still useful as read-only initializers, however, so we do not forbid them altogether.\n ///\n-/// Types like `Cell` and `RefCell` use this type to wrap their internal data.\n+/// Types like `Cell<T>` and `RefCell<T>` use this type to wrap their internal data.\n ///\n-/// `UnsafeCell` doesn't opt-out from any kind, instead, types with an\n-/// `UnsafeCell` interior are expected to opt-out from kinds themselves.\n+/// `UnsafeCell<T>` doesn't opt-out from any marker traits, instead, types with an `UnsafeCell<T>`\n+/// interior are expected to opt-out from those traits themselves.\n ///\n-/// # Example:\n+/// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::cell::UnsafeCell;\n /// use std::marker::Sync;\n ///\n@@ -521,9 +616,8 @@ impl<'b, T> DerefMut for RefMut<'b, T> {\n /// unsafe impl<T> Sync for NotThreadSafe<T> {}\n /// ```\n ///\n-/// **NOTE:** `UnsafeCell<T>` fields are public to allow static initializers. It\n-/// is not recommended to access its fields directly, `get` should be used\n-/// instead.\n+/// **NOTE:** `UnsafeCell<T>`'s fields are public to allow static initializers. It is not\n+/// recommended to access its fields directly, `get` should be used instead.\n #[lang=\"unsafe\"]\n #[stable]\n pub struct UnsafeCell<T> {\n@@ -539,22 +633,52 @@ impl<T> UnsafeCell<T> {\n     /// Construct a new instance of `UnsafeCell` which will wrap the specified\n     /// value.\n     ///\n-    /// All access to the inner value through methods is `unsafe`, and it is\n-    /// highly discouraged to access the fields directly.\n+    /// All access to the inner value through methods is `unsafe`, and it is highly discouraged to\n+    /// access the fields directly.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::UnsafeCell;\n+    ///\n+    /// let uc = UnsafeCell::new(5);\n+    /// ```\n     #[stable]\n     pub fn new(value: T) -> UnsafeCell<T> {\n         UnsafeCell { value: value }\n     }\n \n     /// Gets a mutable pointer to the wrapped value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::UnsafeCell;\n+    ///\n+    /// let uc = UnsafeCell::new(5);\n+    ///\n+    /// let five = uc.get();\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn get(&self) -> *mut T { &self.value as *const T as *mut T }\n \n     /// Unwraps the value\n     ///\n-    /// This function is unsafe because there is no guarantee that this or other\n-    /// tasks are currently inspecting the inner value.\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe because there is no guarantee that this or other threads are\n+    /// currently inspecting the inner value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::UnsafeCell;\n+    ///\n+    /// let uc = UnsafeCell::new(5);\n+    ///\n+    /// let five = unsafe { uc.into_inner() };\n+    /// ```\n     #[inline]\n     #[stable]\n     pub unsafe fn into_inner(self) -> T { self.value }"}]}