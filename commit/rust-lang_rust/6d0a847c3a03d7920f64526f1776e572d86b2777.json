{"sha": "6d0a847c3a03d7920f64526f1776e572d86b2777", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkMGE4NDdjM2EwM2Q3OTIwZjY0NTI2ZjE3NzZlNTcyZDg2YjI3Nzc=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-09-13T04:14:17Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-09-16T03:34:11Z"}, "message": "teach Call/CallWithConv to set attributes", "tree": {"sha": "a70432c3030b5036f2664bdb374cb5991c9c8f61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a70432c3030b5036f2664bdb374cb5991c9c8f61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d0a847c3a03d7920f64526f1776e572d86b2777", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d0a847c3a03d7920f64526f1776e572d86b2777", "html_url": "https://github.com/rust-lang/rust/commit/6d0a847c3a03d7920f64526f1776e572d86b2777", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d0a847c3a03d7920f64526f1776e572d86b2777/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "137eb346f69501c0f67fe43dfcddb01669ba2734", "url": "https://api.github.com/repos/rust-lang/rust/commits/137eb346f69501c0f67fe43dfcddb01669ba2734", "html_url": "https://github.com/rust-lang/rust/commit/137eb346f69501c0f67fe43dfcddb01669ba2734"}], "stats": {"total": 90, "additions": 47, "deletions": 43}, "files": [{"sha": "4d1ea783c3971025fed13861fdacd1b87644a800", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6d0a847c3a03d7920f64526f1776e572d86b2777/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0a847c3a03d7920f64526f1776e572d86b2777/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=6d0a847c3a03d7920f64526f1776e572d86b2777", "patch": "@@ -825,7 +825,8 @@ pub fn trans_external_path(ccx: &mut CrateContext, did: ast::DefId, t: ty::t)\n     };\n }\n \n-pub fn invoke(bcx: @mut Block, llfn: ValueRef, llargs: ~[ValueRef])\n+pub fn invoke(bcx: @mut Block, llfn: ValueRef, llargs: ~[ValueRef],\n+              attributes: &[(uint, lib::llvm::Attribute)])\n            -> (ValueRef, @mut Block) {\n     let _icx = push_ctxt(\"invoke_\");\n     if bcx.unreachable {\n@@ -865,7 +866,7 @@ pub fn invoke(bcx: @mut Block, llfn: ValueRef, llargs: ~[ValueRef])\n                 debug!(\"arg: %x\", ::std::cast::transmute(llarg));\n             }\n         }\n-        let llresult = Call(bcx, llfn, llargs);\n+        let llresult = Call(bcx, llfn, llargs, attributes);\n         return (llresult, bcx);\n     }\n }\n@@ -976,7 +977,7 @@ pub fn get_landing_pad(bcx: @mut Block) -> BasicBlockRef {\n     // Because we may have unwound across a stack boundary, we must call into\n     // the runtime to figure out which stack segment we are on and place the\n     // stack limit back into the TLS.\n-    Call(pad_bcx, bcx.ccx().upcalls.reset_stack_limit, []);\n+    Call(pad_bcx, bcx.ccx().upcalls.reset_stack_limit, [], []);\n \n     // We store the retval in a function-central alloca, so that calls to\n     // Resume can find it.\n@@ -1071,7 +1072,7 @@ pub fn trans_trace(bcx: @mut Block, sp_opt: Option<Span>, trace_str: @str) {\n     let V_trace_str = PointerCast(bcx, V_trace_str, Type::i8p());\n     let V_filename = PointerCast(bcx, V_filename, Type::i8p());\n     let args = ~[V_trace_str, V_filename, C_int(ccx, V_line)];\n-    Call(bcx, ccx.upcalls.trace, args);\n+    Call(bcx, ccx.upcalls.trace, args, []);\n }\n \n pub fn ignore_lhs(_bcx: @mut Block, local: &ast::Local) -> bool {\n@@ -1465,7 +1466,7 @@ pub fn call_memcpy(cx: @mut Block, dst: ValueRef, src: ValueRef, n_bytes: ValueR\n     let size = IntCast(cx, n_bytes, ccx.int_type);\n     let align = C_i32(align as i32);\n     let volatile = C_i1(false);\n-    Call(cx, memcpy, [dst_ptr, src_ptr, size, align, volatile]);\n+    Call(cx, memcpy, [dst_ptr, src_ptr, size, align, volatile], []);\n }\n \n pub fn memcpy_ty(bcx: @mut Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n@@ -1510,7 +1511,7 @@ pub fn memzero(b: &Builder, llptr: ValueRef, ty: Type) {\n     let size = machine::llsize_of(ccx, ty);\n     let align = C_i32(llalign_of_min(ccx, ty) as i32);\n     let volatile = C_i1(false);\n-    b.call(llintrinsicfn, [llptr, llzeroval, size, align, volatile]);\n+    b.call(llintrinsicfn, [llptr, llzeroval, size, align, volatile], []);\n }\n \n pub fn alloc_ty(bcx: @mut Block, t: ty::t, name: &str) -> ValueRef {\n@@ -2353,7 +2354,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n             llvm::LLVMGetParam(llfdecl, env_arg as c_uint)\n         };\n         let args = ~[llenvarg];\n-        Call(bcx, main_llfn, args);\n+        Call(bcx, main_llfn, args, []);\n \n         finish_fn(fcx, bcx);\n         return llfdecl;\n@@ -2808,7 +2809,7 @@ pub fn declare_dbg_intrinsics(llmod: ModuleRef, intrinsics: &mut HashMap<&'stati\n \n pub fn trap(bcx: @mut Block) {\n     match bcx.ccx().intrinsics.find_equiv(& &\"llvm.trap\") {\n-      Some(&x) => { Call(bcx, x, []); },\n+      Some(&x) => { Call(bcx, x, [], []); },\n       _ => bcx.sess().bug(\"unbound llvm.trap in trap\")\n     }\n }"}, {"sha": "aabb389dde114b13d6fe22552a2e2e75d557c52f", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6d0a847c3a03d7920f64526f1776e572d86b2777/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0a847c3a03d7920f64526f1776e572d86b2777/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=6d0a847c3a03d7920f64526f1776e572d86b2777", "patch": "@@ -644,15 +644,16 @@ pub fn InlineAsmCall(cx: @mut Block, asm: *c_char, cons: *c_char,\n     B(cx).inline_asm_call(asm, cons, inputs, output, volatile, alignstack, dia)\n }\n \n-pub fn Call(cx: @mut Block, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n+pub fn Call(cx: @mut Block, Fn: ValueRef, Args: &[ValueRef],\n+            attributes: &[(uint, lib::llvm::Attribute)]) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n-    B(cx).call(Fn, Args)\n+    B(cx).call(Fn, Args, attributes)\n }\n \n-pub fn CallWithConv(cx: @mut Block, Fn: ValueRef, Args: &[ValueRef],\n-                    Conv: CallConv, sret: bool) -> ValueRef {\n+pub fn CallWithConv(cx: @mut Block, Fn: ValueRef, Args: &[ValueRef], Conv: CallConv,\n+                    attributes: &[(uint, lib::llvm::Attribute)]) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n-    B(cx).call_with_conv(Fn, Args, Conv, sret)\n+    B(cx).call_with_conv(Fn, Args, Conv, attributes)\n }\n \n pub fn AtomicFence(cx: @mut Block, order: AtomicOrdering) {"}, {"sha": "85e45942b7981d7cfe4e62ac36f2f4b594106151", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6d0a847c3a03d7920f64526f1776e572d86b2777/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0a847c3a03d7920f64526f1776e572d86b2777/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=6d0a847c3a03d7920f64526f1776e572d86b2777", "patch": "@@ -13,7 +13,6 @@ use lib::llvm::llvm;\n use lib::llvm::{CallConv, AtomicBinOp, AtomicOrdering, AsmDialect};\n use lib::llvm::{Opcode, IntPredicate, RealPredicate, False};\n use lib::llvm::{ValueRef, BasicBlockRef, BuilderRef, ModuleRef};\n-use lib::llvm::{StructRetAttribute};\n use middle::trans::base;\n use middle::trans::common::*;\n use middle::trans::machine::llalign_of_min;\n@@ -748,7 +747,7 @@ impl Builder {\n                                              c, noname(), False, False)\n                 }\n             };\n-            self.call(asm, []);\n+            self.call(asm, [], []);\n         }\n     }\n \n@@ -773,34 +772,31 @@ impl Builder {\n         unsafe {\n             let v = llvm::LLVMInlineAsm(\n                 fty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);\n-            self.call(v, inputs)\n+            self.call(v, inputs, [])\n         }\n     }\n \n-    pub fn call(&self, llfn: ValueRef, args: &[ValueRef]) -> ValueRef {\n+    pub fn call(&self, llfn: ValueRef, args: &[ValueRef],\n+                attributes: &[(uint, lib::llvm::Attribute)]) -> ValueRef {\n         self.count_insn(\"call\");\n-        do args.as_imm_buf |ptr, len| {\n-            unsafe {\n-                llvm::LLVMBuildCall(self.llbuilder, llfn, ptr, len as c_uint, noname())\n-            }\n-        }\n-    }\n-\n-    pub fn call_with_conv(&self, llfn: ValueRef, args: &[ValueRef],\n-                         conv: CallConv, sret: bool) -> ValueRef {\n-        self.count_insn(\"callwithconv\");\n         unsafe {\n             let v = llvm::LLVMBuildCall(self.llbuilder, llfn, vec::raw::to_ptr(args),\n                                         args.len() as c_uint, noname());\n-            lib::llvm::SetInstructionCallConv(v, conv);\n-            if sret {\n-                let return_slot = 1;\n-                llvm::LLVMAddInstrAttribute(v, return_slot, StructRetAttribute as c_uint);\n+            for &(idx, attr) in attributes.iter() {\n+                llvm::LLVMAddInstrAttribute(v, idx as c_uint, attr as c_uint);\n             }\n             v\n         }\n     }\n \n+    pub fn call_with_conv(&self, llfn: ValueRef, args: &[ValueRef],\n+                          conv: CallConv, attributes: &[(uint, lib::llvm::Attribute)]) -> ValueRef {\n+        self.count_insn(\"callwithconv\");\n+        let v = self.call(llfn, args, attributes);\n+        lib::llvm::SetInstructionCallConv(v, conv);\n+        v\n+    }\n+\n     pub fn select(&self, cond: ValueRef, then_val: ValueRef, else_val: ValueRef) -> ValueRef {\n         self.count_insn(\"select\");\n         unsafe {"}, {"sha": "45da026afd06ac5d1df8bd7e9ec78102f6e5973d", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d0a847c3a03d7920f64526f1776e572d86b2777/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0a847c3a03d7920f64526f1776e572d86b2777/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=6d0a847c3a03d7920f64526f1776e572d86b2777", "patch": "@@ -707,7 +707,7 @@ pub fn trans_call_inner(in_cx: @mut Block,\n             }\n \n             // Invoke the actual rust fn and update bcx/llresult.\n-            let (llret, b) = base::invoke(bcx, llfn, llargs);\n+            let (llret, b) = base::invoke(bcx, llfn, llargs, []);\n             bcx = b;\n             llresult = llret;\n "}, {"sha": "87755b4431c0eb52bb059b479baac9c90ccbf4ba", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6d0a847c3a03d7920f64526f1776e572d86b2777/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0a847c3a03d7920f64526f1776e572d86b2777/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=6d0a847c3a03d7920f64526f1776e572d86b2777", "patch": "@@ -11,7 +11,7 @@\n \n use back::{link};\n use std::libc::c_uint;\n-use lib::llvm::{ValueRef, Attribute, CallConv};\n+use lib::llvm::{ValueRef, Attribute, CallConv, StructRetAttribute};\n use lib::llvm::llvm;\n use lib;\n use middle::trans::machine;\n@@ -266,7 +266,13 @@ pub fn trans_native_call(bcx: @mut Block,\n         }\n     };\n \n-    let llforeign_retval = CallWithConv(bcx, llfn, llargs_foreign, cc, fn_type.sret);\n+    let attrs;\n+    if fn_type.sret {\n+        attrs = &[(1, StructRetAttribute)];\n+    } else {\n+        attrs = &[];\n+    }\n+    let llforeign_retval = CallWithConv(bcx, llfn, llargs_foreign, cc, attrs);\n \n     // If the function we just called does not use an outpointer,\n     // store the result into the rust outpointer. Cast the outpointer"}, {"sha": "1958d3c9adb4f6b1f13101421061490d4712247c", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6d0a847c3a03d7920f64526f1776e572d86b2777/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0a847c3a03d7920f64526f1776e572d86b2777/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=6d0a847c3a03d7920f64526f1776e572d86b2777", "patch": "@@ -332,7 +332,7 @@ pub fn call_tydesc_glue_full(bcx: @mut Block,\n         }\n     };\n \n-    Call(bcx, llfn, [C_null(Type::nil().ptr_to()), llrawptr]);\n+    Call(bcx, llfn, [C_null(Type::nil().ptr_to()), llrawptr], []);\n }\n \n // See [Note-arg-mode]\n@@ -424,7 +424,7 @@ pub fn trans_struct_drop_flag(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did:\n         let self_arg = PointerCast(bcx, v0, params[0]);\n         let args = ~[self_arg];\n \n-        Call(bcx, dtor_addr, args);\n+        Call(bcx, dtor_addr, args, []);\n \n         // Drop the fields\n         let field_tys = ty::struct_fields(bcx.tcx(), class_did, substs);\n@@ -459,7 +459,7 @@ pub fn trans_struct_drop(mut bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did:\n     let self_arg = PointerCast(bcx, v0, params[0]);\n     let args = ~[self_arg];\n \n-    Call(bcx, dtor_addr, args);\n+    Call(bcx, dtor_addr, args, []);\n \n     // Drop the fields\n     let field_tys = ty::struct_fields(bcx.tcx(), class_did, substs);"}, {"sha": "d17773d3302f1f480c949520c06c39548e1c6509", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6d0a847c3a03d7920f64526f1776e572d86b2777/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d0a847c3a03d7920f64526f1776e572d86b2777/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=6d0a847c3a03d7920f64526f1776e572d86b2777", "patch": "@@ -49,7 +49,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             args[i] = get_param(bcx.fcx.llfn, first_real_arg + i);\n         }\n         let llfn = bcx.ccx().intrinsics.get_copy(&name);\n-        Ret(bcx, Call(bcx, llfn, args.slice(0, num_args)));\n+        Ret(bcx, Call(bcx, llfn, args.slice(0, num_args), []));\n     }\n \n     fn with_overflow_instrinsic(bcx: @mut Block, name: &'static str) {\n@@ -59,7 +59,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         let llfn = bcx.ccx().intrinsics.get_copy(&name);\n \n         // convert `i1` to a `bool`, and write to the out parameter\n-        let val = Call(bcx, llfn, [a, b]);\n+        let val = Call(bcx, llfn, [a, b], []);\n         let result = ExtractValue(bcx, val, 0);\n         let overflow = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool());\n         let retptr = get_param(bcx.fcx.llfn, bcx.fcx.out_arg_pos());\n@@ -87,7 +87,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         let count = get_param(decl, first_real_arg + 2);\n         let volatile = C_i1(false);\n         let llfn = bcx.ccx().intrinsics.get_copy(&name);\n-        Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n+        Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile], []);\n         RetVoid(bcx);\n     }\n \n@@ -108,15 +108,15 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         let count = get_param(decl, first_real_arg + 2);\n         let volatile = C_i1(false);\n         let llfn = bcx.ccx().intrinsics.get_copy(&name);\n-        Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, volatile]);\n+        Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, volatile], []);\n         RetVoid(bcx);\n     }\n \n     fn count_zeros_intrinsic(bcx: @mut Block, name: &'static str) {\n         let x = get_param(bcx.fcx.llfn, bcx.fcx.arg_pos(0u));\n         let y = C_i1(false);\n         let llfn = bcx.ccx().intrinsics.get_copy(&name);\n-        Ret(bcx, Call(bcx, llfn, [x, y]));\n+        Ret(bcx, Call(bcx, llfn, [x, y], []));\n     }\n \n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, item.id));\n@@ -366,7 +366,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         }\n         \"frame_address\" => {\n             let frameaddress = ccx.intrinsics.get_copy(& &\"llvm.frameaddress\");\n-            let frameaddress_val = Call(bcx, frameaddress, [C_i32(0i32)]);\n+            let frameaddress_val = Call(bcx, frameaddress, [C_i32(0i32)], []);\n             let star_u8 = ty::mk_imm_ptr(\n                 bcx.tcx(),\n                 ty::mk_mach_uint(ast::ty_u8));"}]}