{"sha": "7aed441ac8ef9da3f12c0606a93a55bd998f2d4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhZWQ0NDFhYzhlZjlkYTNmMTJjMDYwNmE5M2E1NWJkOTk4ZjJkNGY=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-09-17T16:55:43Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-10-01T15:21:04Z"}, "message": "don't emit leading zeros in tagged integers\n\nwe *already* need a length, so might as well use it\n\nthis saves 3% in libcore\n\n559870 liballoc-bb943c5a.rlib\n1425170 liballoc_jemalloc-bb943c5a.rlib\n10120 liballoc_system-bb943c5a.rlib\n152398 libarena-bb943c5a.rlib\n4023670 libcollections-bb943c5a.rlib\n18042746 libcore-bb943c5a.rlib\n198202 libflate-bb943c5a.rlib\n244412 libfmt_macros-bb943c5a.rlib\n555750 libgetopts-bb943c5a.rlib\n222462 libgraphviz-bb943c5a.rlib\n417824 liblibc-bb943c5a.rlib\n187804 liblog-bb943c5a.rlib\n722742 librand-bb943c5a.rlib\n604846 librbml-bb943c5a.rlib\n1397814 librustc_back-bb943c5a.rlib\n38382616 librustc-bb943c5a.rlib\n12826 librustc_bitflags-bb943c5a.rlib\n2298772 librustc_borrowck-bb943c5a.rlib\n570822 librustc_data_structures-bb943c5a.rlib\n9361826 librustc_driver-bb943c5a.rlib\n9479914 librustc_front-bb943c5a.rlib\n1604576 librustc_lint-bb943c5a.rlib\n79190586 librustc_llvm-bb943c5a.rlib\n4783104 librustc_mir-bb943c5a.rlib\n3534332 librustc_platform_intrinsics-bb943c5a.rlib\n592710 librustc_privacy-bb943c5a.rlib\n3123792 librustc_resolve-bb943c5a.rlib\n14183434 librustc_trans-bb943c5a.rlib\n11937016 librustc_typeck-bb943c5a.rlib\n1830988 librustc_unicode-bb943c5a.rlib\n15611582 librustdoc-bb943c5a.rlib\n2892482 libserialize-bb943c5a.rlib\n8642922 libstd-bb943c5a.rlib\n30590774 libsyntax-bb943c5a.rlib\n912678 libterm-bb943c5a.rlib\n1369754 libtest-bb943c5a.rlib", "tree": {"sha": "9a2269705b45874bb8d22ff3f7a05549adb564b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a2269705b45874bb8d22ff3f7a05549adb564b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7aed441ac8ef9da3f12c0606a93a55bd998f2d4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7aed441ac8ef9da3f12c0606a93a55bd998f2d4f", "html_url": "https://github.com/rust-lang/rust/commit/7aed441ac8ef9da3f12c0606a93a55bd998f2d4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7aed441ac8ef9da3f12c0606a93a55bd998f2d4f/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38cd6d40d2370b9bc0ab3bd6dae389c61d171c9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/38cd6d40d2370b9bc0ab3bd6dae389c61d171c9e", "html_url": "https://github.com/rust-lang/rust/commit/38cd6d40d2370b9bc0ab3bd6dae389c61d171c9e"}], "stats": {"total": 73, "additions": 44, "deletions": 29}, "files": [{"sha": "dbd6ba700fa1db7c0c03673648ad62b08a3a7ec8", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 44, "deletions": 29, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/7aed441ac8ef9da3f12c0606a93a55bd998f2d4f/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aed441ac8ef9da3f12c0606a93a55bd998f2d4f/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=7aed441ac8ef9da3f12c0606a93a55bd998f2d4f", "patch": "@@ -467,37 +467,44 @@ pub mod reader {\n         f(&d.data[d.start..d.end])\n     }\n \n-\n     pub fn doc_as_u8(d: Doc) -> u8 {\n         assert_eq!(d.end, d.start + 1);\n         d.data[d.start]\n     }\n \n-    pub fn doc_as_u16(d: Doc) -> u16 {\n-        assert_eq!(d.end, d.start + 2);\n-        let mut b = [0; 2];\n-        bytes::copy_memory(&d.data[d.start..d.end], &mut b);\n-        unsafe { (*(b.as_ptr() as *const u16)).to_be() }\n-    }\n-\n-    pub fn doc_as_u32(d: Doc) -> u32 {\n-        assert_eq!(d.end, d.start + 4);\n-        let mut b = [0; 4];\n-        bytes::copy_memory(&d.data[d.start..d.end], &mut b);\n-        unsafe { (*(b.as_ptr() as *const u32)).to_be() }\n-    }\n-\n     pub fn doc_as_u64(d: Doc) -> u64 {\n-        assert_eq!(d.end, d.start + 8);\n-        let mut b = [0; 8];\n-        bytes::copy_memory(&d.data[d.start..d.end], &mut b);\n-        unsafe { (*(b.as_ptr() as *const u64)).to_be() }\n+        if d.end >= 8 {\n+            // For performance, we read 8 big-endian bytes,\n+            // and mask off the junk if there is any. This\n+            // obviously won't work on the first 8 bytes\n+            // of a file - we will fall of the start\n+            // of the page and segfault.\n+\n+            let mut b = [0; 8];\n+            bytes::copy_memory(&d.data[d.end-8..d.end], &mut b);\n+            let data = unsafe { (*(b.as_ptr() as *const u64)).to_be() };\n+            let len = d.end - d.start;\n+            if len < 8 {\n+                data & ((1<<(len*8))-1)\n+            } else {\n+                data\n+            }\n+        } else {\n+            let mut result = 0;\n+            for b in &d.data[d.start..d.end] {\n+                result = (result<<8) + (*b as u64);\n+            }\n+            result\n+        }\n     }\n \n-    pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n-    pub fn doc_as_i16(d: Doc) -> i16 { doc_as_u16(d) as i16 }\n-    pub fn doc_as_i32(d: Doc) -> i32 { doc_as_u32(d) as i32 }\n-    pub fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n+    #[inline] pub fn doc_as_u16(d: Doc) -> u16 { doc_as_u64(d) as u16 }\n+    #[inline] pub fn doc_as_u32(d: Doc) -> u32 { doc_as_u64(d) as u32 }\n+\n+    #[inline] pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n+    #[inline] pub fn doc_as_i16(d: Doc) -> i16 { doc_as_u16(d) as i16 }\n+    #[inline] pub fn doc_as_i32(d: Doc) -> i32 { doc_as_u32(d) as i32 }\n+    #[inline] pub fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n \n     pub struct Decoder<'a> {\n         parent: Doc<'a>,\n@@ -996,35 +1003,43 @@ pub mod writer {\n \n         pub fn wr_tagged_u64(&mut self, tag_id: usize, v: u64) -> EncodeResult {\n             let bytes: [u8; 8] = unsafe { mem::transmute(v.to_be()) };\n-            self.wr_tagged_bytes(tag_id, &bytes)\n+            // tagged integers are emitted in big-endian, with no\n+            // leading zeros.\n+            let leading_zero_bytes = v.leading_zeros()/8;\n+            self.wr_tagged_bytes(tag_id, &bytes[leading_zero_bytes as usize..])\n         }\n \n-        pub fn wr_tagged_u32(&mut self, tag_id: usize, v: u32)  -> EncodeResult{\n-            let bytes: [u8; 4] = unsafe { mem::transmute(v.to_be()) };\n-            self.wr_tagged_bytes(tag_id, &bytes)\n+        #[inline]\n+        pub fn wr_tagged_u32(&mut self, tag_id: usize, v: u32)  -> EncodeResult {\n+            self.wr_tagged_u64(tag_id, v as u64)\n         }\n \n+        #[inline]\n         pub fn wr_tagged_u16(&mut self, tag_id: usize, v: u16) -> EncodeResult {\n-            let bytes: [u8; 2] = unsafe { mem::transmute(v.to_be()) };\n-            self.wr_tagged_bytes(tag_id, &bytes)\n+            self.wr_tagged_u64(tag_id, v as u64)\n         }\n \n+        #[inline]\n         pub fn wr_tagged_u8(&mut self, tag_id: usize, v: u8) -> EncodeResult {\n             self.wr_tagged_bytes(tag_id, &[v])\n         }\n \n+        #[inline]\n         pub fn wr_tagged_i64(&mut self, tag_id: usize, v: i64) -> EncodeResult {\n             self.wr_tagged_u64(tag_id, v as u64)\n         }\n \n+        #[inline]\n         pub fn wr_tagged_i32(&mut self, tag_id: usize, v: i32) -> EncodeResult {\n             self.wr_tagged_u32(tag_id, v as u32)\n         }\n \n+        #[inline]\n         pub fn wr_tagged_i16(&mut self, tag_id: usize, v: i16) -> EncodeResult {\n             self.wr_tagged_u16(tag_id, v as u16)\n         }\n \n+        #[inline]\n         pub fn wr_tagged_i8(&mut self, tag_id: usize, v: i8) -> EncodeResult {\n             self.wr_tagged_bytes(tag_id, &[v as u8])\n         }"}]}