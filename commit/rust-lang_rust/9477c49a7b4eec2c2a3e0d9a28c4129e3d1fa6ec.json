{"sha": "9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0NzdjNDlhN2I0ZWVjMmMyYTNlMGQ5YTI4YzQxMjllM2QxZmE2ZWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-26T09:01:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-26T09:01:54Z"}, "message": "auto merge of #10965 : alexcrichton/rust/libgreen, r=brson\n\nThis pull request extracts all scheduling functionality from libstd, moving it into its own separate crates. The new libnative and libgreen will be the new way in which 1:1 and M:N scheduling is implemented. The standard library still requires an interface to the runtime, however, (think of things like `std::comm` and `io::println`). The interface is now defined by the `Runtime` trait inside of `std::rt`.\r\n\r\nThe booting process is now that libgreen defines the start lang-item and that's it. I want to extend this soon to have libnative also have a \"start lang item\" but also allow libgreen and libnative to be linked together in the same process. For now though, only libgreen can be used to start a program (unless you define the start lang item yourself). Again though, I want to change this soon, I just figured that this pull request is large enough as-is.\r\n\r\nThis certainly wasn't a smooth transition, certain functionality has no equivalent in this new separation, and some functionality is now better enabled through this new system. I did my best to separate all of the commits by topic and keep things fairly bite-sized, although are indeed larger than others.\r\n\r\nAs a note, this is currently rebased on top of my `std::comm` rewrite (or at least an old copy of it), but none of those commits need reviewing (that will all happen in another pull request).", "tree": {"sha": "bd57f2b50c352a4a63d0ae75ef52419e19ebf994", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd57f2b50c352a4a63d0ae75ef52419e19ebf994"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "html_url": "https://github.com/rust-lang/rust/commit/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d975060de6c944ca12ce5205fbc9fc7726948ae1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d975060de6c944ca12ce5205fbc9fc7726948ae1", "html_url": "https://github.com/rust-lang/rust/commit/d975060de6c944ca12ce5205fbc9fc7726948ae1"}, {"sha": "6cad8f4f14da1dd529100779db74b03d6db20faf", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cad8f4f14da1dd529100779db74b03d6db20faf", "html_url": "https://github.com/rust-lang/rust/commit/6cad8f4f14da1dd529100779db74b03d6db20faf"}], "stats": {"total": 12162, "additions": 5810, "deletions": 6352}, "files": [{"sha": "f1b18e8f64b0a41356080b9a22d1a079ba09571b", "filename": "Makefile.in", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -235,6 +235,8 @@ CFG_LIBSYNTAX_$(1) :=$(call CFG_LIB_NAME_$(1),syntax)\n CFG_LIBRUSTPKG_$(1) :=$(call CFG_LIB_NAME_$(1),rustpkg)\n CFG_LIBRUSTDOC_$(1) :=$(call CFG_LIB_NAME_$(1),rustdoc)\n CFG_LIBRUSTUV_$(1) :=$(call CFG_LIB_NAME_$(1),rustuv)\n+CFG_LIBGREEN_$(1) :=$(call CFG_LIB_NAME_$(1),green)\n+CFG_LIBNATIVE_$(1) :=$(call CFG_LIB_NAME_$(1),native)\n \n EXTRALIB_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),extra)\n STDLIB_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),std)\n@@ -243,19 +245,25 @@ LIBSYNTAX_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),syntax)\n LIBRUSTPKG_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustpkg)\n LIBRUSTDOC_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustdoc)\n LIBRUSTUV_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustuv)\n+LIBGREEN_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),green)\n+LIBNATIVE_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),native)\n EXTRALIB_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),extra)\n STDLIB_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),std)\n LIBRUSTC_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustc)\n LIBSYNTAX_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),syntax)\n LIBRUSTPKG_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustpkg)\n LIBRUSTDOC_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustdoc)\n LIBRUSTUV_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustuv)\n+LIBGREEN_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),green)\n+LIBNATIVE_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),native)\n \n EXTRALIB_RGLOB_$(1) :=$(call CFG_RLIB_GLOB,extra)\n STDLIB_RGLOB_$(1) :=$(call CFG_RLIB_GLOB,std)\n LIBRUSTUV_RGLOB_$(1) :=$(call CFG_RLIB_GLOB,rustuv)\n LIBSYNTAX_RGLOB_$(1) :=$(call CFG_RLIB_GLOB,syntax)\n LIBRUSTC_RGLOB_$(1) :=$(call CFG_RLIB_GLOB,rustc)\n+LIBNATIVE_RGLOB_$(1) :=$(call CFG_RLIB_GLOB,native)\n+LIBGREEN_RGLOB_$(1) :=$(call CFG_RLIB_GLOB,green)\n \n endef\n \n@@ -272,9 +280,15 @@ define CHECK_FOR_OLD_GLOB_MATCHES_EXCEPT\n endef\n \n # Same interface as above, but deletes rather than just listing the files.\n+ifdef VERBOSE\n define REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT\n   $(Q)MATCHES=\"$(filter-out %$(3),$(wildcard $(1)/$(2)))\"; if [ -n \"$$MATCHES\" ] ; then echo \"warning: removing previous\" \\'$(2)\\' \"libraries:\" $$MATCHES; rm $$MATCHES ; fi\n endef\n+else\n+define REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT\n+  $(Q)MATCHES=\"$(filter-out %$(3),$(wildcard $(1)/$(2)))\"; if [ -n \"$$MATCHES\" ] ; then rm $$MATCHES ; fi\n+endef\n+endif\n \n # We use a different strategy for LIST_ALL_OLD_GLOB_MATCHES_EXCEPT\n # than in the macros above because it needs the result of running the\n@@ -319,6 +333,22 @@ LIBRUSTUV_CRATE := $(S)src/librustuv/lib.rs\n LIBRUSTUV_INPUTS := $(wildcard $(addprefix $(S)src/librustuv/,          \\\n                                           *.rs */*.rs))\n \n+######################################################################\n+# Green threading library variables\n+######################################################################\n+\n+LIBGREEN_CRATE := $(S)src/libgreen/lib.rs\n+LIBGREEN_INPUTS := $(wildcard $(addprefix $(S)src/libgreen/,          \\\n+                                          *.rs */*.rs))\n+\n+######################################################################\n+# Native threading library variables\n+######################################################################\n+\n+LIBNATIVE_CRATE := $(S)src/libnative/lib.rs\n+LIBNATIVE_INPUTS := $(wildcard $(addprefix $(S)src/libnative/,          \\\n+                                          *.rs */*.rs))\n+\n ######################################################################\n # rustc crate variables\n ######################################################################\n@@ -430,6 +460,16 @@ HLIBRUSTUV_DEFAULT$(1)_H_$(3) = \\\n TLIBRUSTUV_DEFAULT$(1)_T_$(2)_H_$(3) = \\\n   $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTUV_$(2))\n \n+HLIBGREEN_DEFAULT$(1)_H_$(3) = \\\n+  $$(HLIB$(1)_H_$(3))/$(CFG_LIBGREEN_$(3))\n+TLIBGREEN_DEFAULT$(1)_T_$(2)_H_$(3) = \\\n+  $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBGREEN_$(2))\n+\n+HLIBNATIVE_DEFAULT$(1)_H_$(3) = \\\n+  $$(HLIB$(1)_H_$(3))/$(CFG_LIBNATIVE_$(3))\n+TLIBNATIVE_DEFAULT$(1)_T_$(2)_H_$(3) = \\\n+  $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBNATIVE_$(2))\n+\n # Preqrequisites for using the stageN compiler\n ifeq ($(1),0)\n HSREQ$(1)_H_$(3) = $$(HBIN$(1)_H_$(3))/rustc$$(X_$(3))\n@@ -441,6 +481,8 @@ HSREQ$(1)_H_$(3) = \\\n \t$$(HLIBSYNTAX_DEFAULT$(1)_H_$(3)) \\\n \t$$(HLIBRUSTC_DEFAULT$(1)_H_$(3)) \\\n \t$$(HLIBRUSTUV_DEFAULT$(1)_H_$(3)) \\\n+\t$$(HLIBGREEN_DEFAULT$(1)_H_$(3)) \\\n+\t$$(HLIBNATIVE_DEFAULT$(1)_H_$(3)) \\\n \t$$(MKFILE_DEPS)\n endif\n \n@@ -455,7 +497,9 @@ SREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_STDLIB_$(2)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_EXTRALIB_$(2)) \\\n-\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTUV_$(2))\n+\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTUV_$(2)) \\\n+\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBGREEN_$(2)) \\\n+\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBNATIVE_$(2))\n \n # Prerequisites for a working stageN compiler and libraries, for a specific target\n CSREQ$(1)_T_$(2)_H_$(3) = \\\n@@ -470,7 +514,9 @@ CSREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTC_$(2)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTPKG_$(2)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTDOC_$(2)) \\\n-\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTUV_$(2))\n+\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTUV_$(2)) \\\n+\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBGREEN_$(2)) \\\n+\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBNATIVE_$(2))\n \n ifeq ($(1),0)\n # Don't run the the stage0 compiler under valgrind - that ship has sailed"}, {"sha": "c59298d1ecb63d4bddc06aadcaafea2e8068235a", "filename": "mk/clean.mk", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -90,6 +90,8 @@ clean$(1)_H_$(2):\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_STDLIB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_EXTRALIB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTUV_$(2))\n+\t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBNATIVE_$(2))\n+\t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBGREEN_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTC_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBSYNTAX_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(STDLIB_GLOB_$(2))\n@@ -98,6 +100,10 @@ clean$(1)_H_$(2):\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(EXTRALIB_RGLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTUV_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTUV_RGLOB_$(2))\n+\t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBNATIVE_GLOB_$(2))\n+\t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBNATIVE_RGLOB_$(2))\n+\t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBGREEN_GLOB_$(2))\n+\t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBGREEN_RGLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTC_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBSYNTAX_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTPKG_GLOB_$(2))\n@@ -124,6 +130,8 @@ clean$(1)_T_$(2)_H_$(3):\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_STDLIB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_EXTRALIB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTUV_$(2))\n+\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBGREEN_$(2))\n+\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBNATIVE_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTC_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBSYNTAX_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(STDLIB_GLOB_$(2))\n@@ -132,6 +140,10 @@ clean$(1)_T_$(2)_H_$(3):\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(EXTRALIB_RGLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTUV_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTUV_RGLOB_$(2))\n+\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBNATIVE_GLOB_$(2))\n+\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBNATIVE_RGLOB_$(2))\n+\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBGREEN_GLOB_$(2))\n+\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBGREEN_RGLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTC_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTC_RGLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBSYNTAX_GLOB_$(2))"}, {"sha": "9f0f64f4c6561a4b0408f5d8eb9ea5b87984e093", "filename": "mk/dist.mk", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -35,6 +35,9 @@ PKG_FILES := \\\n       libextra                                 \\\n       libstd                                   \\\n       libsyntax                                \\\n+      librustuv\t\t\t\t       \\\n+      libgreen \t\t\t\t       \\\n+      libnative \t\t\t       \\\n       rt                                       \\\n       librustdoc                               \\\n       rustllvm                                 \\"}, {"sha": "9997384d2502a346c04a12ed1598aeec3baf5905", "filename": "mk/host.mk", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/mk%2Fhost.mk", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/mk%2Fhost.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fhost.mk?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -25,24 +25,14 @@ define CP_HOST_STAGE_N\n \n $$(HBIN$(2)_H_$(4))/rustc$$(X_$(4)): \\\n \t$$(TBIN$(1)_T_$(4)_H_$(3))/rustc$$(X_$(4)) \\\n-\t$$(HLIB$(2)_H_$(4))/$(CFG_RUNTIME_$(4)) \\\n \t$$(HLIB$(2)_H_$(4))/$(CFG_LIBRUSTC_$(4)) \\\n-\t$$(HSTDLIB_DEFAULT$(2)_H_$(4)) \\\n-\t$$(HEXTRALIB_DEFAULT$(2)_H_$(4)) \\\n-\t$$(HLIBRUSTUV_DEFAULT$(2)_H_$(4)) \\\n-\t$$(HLIBRUSTC_DEFAULT$(2)_H_$(4)) \\\n-\t$$(HLIBSYNTAX_DEFAULT$(2)_H_$(4)) \\\n \t| $$(HBIN$(2)_H_$(4))/\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n \n $$(HLIB$(2)_H_$(4))/$(CFG_LIBRUSTC_$(4)): \\\n \t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTC_$(4)) \\\n \t$$(HLIB$(2)_H_$(4))/$(CFG_LIBSYNTAX_$(4)) \\\n-\t$$(HLIB$(2)_H_$(4))/$(CFG_RUNTIME_$(4)) \\\n-\t$$(HSTDLIB_DEFAULT$(2)_H_$(4)) \\\n-\t$$(HEXTRALIB_DEFAULT$(2)_H_$(4)) \\\n-\t$$(HLIBRUSTUV_DEFAULT$(2)_H_$(4)) \\\n \t| $$(HLIB$(2)_H_$(4))/\n \n \t@$$(call E, cp: $$@)\n@@ -55,10 +45,11 @@ $$(HLIB$(2)_H_$(4))/$(CFG_LIBRUSTC_$(4)): \\\n \n $$(HLIB$(2)_H_$(4))/$(CFG_LIBSYNTAX_$(4)): \\\n \t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBSYNTAX_$(4)) \\\n-\t$$(HLIB$(2)_H_$(4))/$(CFG_RUNTIME_$(4)) \\\n \t$$(HSTDLIB_DEFAULT$(2)_H_$(4)) \\\n \t$$(HEXTRALIB_DEFAULT$(2)_H_$(4)) \\\n \t$$(HLIBRUSTUV_DEFAULT$(2)_H_$(4)) \\\n+\t$$(HLIBGREEN_DEFAULT$(2)_H_$(4)) \\\n+\t$$(HLIBNATIVE_DEFAULT$(2)_H_$(4)) \\\n \t| $$(HLIB$(2)_H_$(4))/\n \t@$$(call E, cp: $$@)\n \t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBSYNTAX_GLOB_$(4)),$$(notdir $$@))\n@@ -76,7 +67,6 @@ $$(HLIB$(2)_H_$(4))/$(CFG_RUNTIME_$(4)): \\\n \n $$(HLIB$(2)_H_$(4))/$(CFG_STDLIB_$(4)): \\\n \t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_STDLIB_$(4)) \\\n-\t$$(HLIB$(2)_H_$(4))/$(CFG_RUNTIME_$(4)) \\\n \t| $$(HLIB$(2)_H_$(4))/\n \t@$$(call E, cp: $$@)\n \t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(STDLIB_GLOB_$(4)),$$(notdir $$@))\n@@ -98,8 +88,7 @@ $$(HLIB$(2)_H_$(4))/$(CFG_STDLIB_$(4)): \\\n \n $$(HLIB$(2)_H_$(4))/$(CFG_EXTRALIB_$(4)): \\\n \t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_EXTRALIB_$(4)) \\\n-\t$$(HLIB$(2)_H_$(4))/$(CFG_STDLIB_$(4)) \\\n-\t$$(HLIB$(2)_H_$(4))/$(CFG_RUNTIME_$(4)) \\\n+\t$$(HSTDLIB_DEFAULT$(2)_H_$(4)) \\\n \t| $$(HLIB$(2)_H_$(4))/\n \t@$$(call E, cp: $$@)\n \t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(EXTRALIB_GLOB_$(4)),$$(notdir $$@))\n@@ -115,7 +104,6 @@ $$(HLIB$(2)_H_$(4))/$(CFG_EXTRALIB_$(4)): \\\n $$(HLIB$(2)_H_$(4))/$(CFG_LIBRUSTUV_$(4)): \\\n \t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTUV_$(4)) \\\n \t$$(HLIB$(2)_H_$(4))/$(CFG_STDLIB_$(4)) \\\n-\t$$(HLIB$(2)_H_$(4))/$(CFG_RUNTIME_$(4)) \\\n \t| $$(HLIB$(2)_H_$(4))/\n \t@$$(call E, cp: $$@)\n \t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTUV_GLOB_$(4)),$$(notdir $$@))\n@@ -128,6 +116,36 @@ $$(HLIB$(2)_H_$(4))/$(CFG_LIBRUSTUV_$(4)): \\\n \t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTUV_GLOB_$(4)),$$(notdir $$@))\n \t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTUV_RGLOB_$(4)),$$(notdir $$@))\n \n+$$(HLIB$(2)_H_$(4))/$(CFG_LIBGREEN_$(4)): \\\n+\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBGREEN_$(4)) \\\n+\t$$(HLIB$(2)_H_$(4))/$(CFG_STDLIB_$(4)) \\\n+\t| $$(HLIB$(2)_H_$(4))/\n+\t@$$(call E, cp: $$@)\n+\t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBGREEN_GLOB_$(4)),$$(notdir $$@))\n+\t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBGREEN_RGLOB_$(4)),$$(notdir $$@))\n+\t$$(Q)cp $$< $$@\n+\t$$(Q)cp -R $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBGREEN_GLOB_$(4)) \\\n+\t\t$$(wildcard $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBGREEN_RGLOB_$(4))) \\\n+\t\t$$(wildcard $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBGREEN_DSYM_GLOB_$(4))) \\\n+\t        $$(HLIB$(2)_H_$(4))\n+\t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBGREEN_GLOB_$(4)),$$(notdir $$@))\n+\t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBGREEN_RGLOB_$(4)),$$(notdir $$@))\n+\n+$$(HLIB$(2)_H_$(4))/$(CFG_LIBNATIVE_$(4)): \\\n+\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBNATIVE_$(4)) \\\n+\t$$(HLIB$(2)_H_$(4))/$(CFG_STDLIB_$(4)) \\\n+\t| $$(HLIB$(2)_H_$(4))/\n+\t@$$(call E, cp: $$@)\n+\t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBNATIVE_GLOB_$(4)),$$(notdir $$@))\n+\t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBNATIVE_RGLOB_$(4)),$$(notdir $$@))\n+\t$$(Q)cp $$< $$@\n+\t$$(Q)cp -R $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBNATIVE_GLOB_$(4)) \\\n+\t\t$$(wildcard $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBNATIVE_RGLOB_$(4))) \\\n+\t\t$$(wildcard $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBNATIVE_DSYM_GLOB_$(4))) \\\n+\t        $$(HLIB$(2)_H_$(4))\n+\t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBNATIVE_GLOB_$(4)),$$(notdir $$@))\n+\t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBNATIVE_RGLOB_$(4)),$$(notdir $$@))\n+\n $$(HBIN$(2)_H_$(4))/:\n \tmkdir -p $$@\n "}, {"sha": "f81367010ed71cf855307391e2d9d4de2bfff8f0", "filename": "mk/install.mk", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/mk%2Finstall.mk", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/mk%2Finstall.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Finstall.mk?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -94,6 +94,10 @@ install-target-$(1)-host-$(2): $$(TSREQ$$(ISTAGE)_T_$(1)_H_$(2)) $$(SREQ$$(ISTAG\n \t$$(Q)$$(call INSTALL_LIB,$$(EXTRALIB_RGLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTUV_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTUV_RGLOB_$(1)))\n+\t$$(Q)$$(call INSTALL_LIB,$$(LIBGREEN_GLOB_$(1)))\n+\t$$(Q)$$(call INSTALL_LIB,$$(LIBGREEN_RGLOB_$(1)))\n+\t$$(Q)$$(call INSTALL_LIB,$$(LIBNATIVE_GLOB_$(1)))\n+\t$$(Q)$$(call INSTALL_LIB,$$(LIBNATIVE_RGLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,libmorestack.a)\n \n endef\n@@ -109,6 +113,10 @@ install-target-$(1)-host-$(2): $$(CSREQ$$(ISTAGE)_T_$(1)_H_$(2))\n \t$$(Q)$$(call INSTALL_LIB,$$(EXTRALIB_RGLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTUV_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTUV_RGLOB_$(1)))\n+\t$$(Q)$$(call INSTALL_LIB,$$(LIBGREEN_GLOB_$(1)))\n+\t$$(Q)$$(call INSTALL_LIB,$$(LIBGREEN_RGLOB_$(1)))\n+\t$$(Q)$$(call INSTALL_LIB,$$(LIBNATIVE_GLOB_$(1)))\n+\t$$(Q)$$(call INSTALL_LIB,$$(LIBNATIVE_RGLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTC_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBSYNTAX_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTPKG_GLOB_$(1)))\n@@ -149,6 +157,7 @@ install-host: $(CSREQ$(ISTAGE)_T_$(CFG_BUILD_)_H_$(CFG_BUILD_))\n \t$(Q)$(call INSTALL_LIB,$(STDLIB_GLOB_$(CFG_BUILD)))\n \t$(Q)$(call INSTALL_LIB,$(EXTRALIB_GLOB_$(CFG_BUILD)))\n \t$(Q)$(call INSTALL_LIB,$(LIBRUSTUV_GLOB_$(CFG_BUILD)))\n+\t$(Q)$(call INSTALL_LIB,$(LIBGREEN_GLOB_$(CFG_BUILD)))\n \t$(Q)$(call INSTALL_LIB,$(LIBRUSTC_GLOB_$(CFG_BUILD)))\n \t$(Q)$(call INSTALL_LIB,$(LIBSYNTAX_GLOB_$(CFG_BUILD)))\n \t$(Q)$(call INSTALL_LIB,$(LIBRUSTPKG_GLOB_$(CFG_BUILD)))\n@@ -174,6 +183,10 @@ uninstall:\n           $(call HOST_LIB_FROM_HL_GLOB,$(EXTRALIB_RGLOB_$(CFG_BUILD))) \\\n           $(call HOST_LIB_FROM_HL_GLOB,$(LIBRUSTUV_GLOB_$(CFG_BUILD))) \\\n           $(call HOST_LIB_FROM_HL_GLOB,$(LIBRUSTUV_RGLOB_$(CFG_BUILD))) \\\n+          $(call HOST_LIB_FROM_HL_GLOB,$(LIBGREEN_GLOB_$(CFG_BUILD))) \\\n+          $(call HOST_LIB_FROM_HL_GLOB,$(LIBGREEN_RGLOB_$(CFG_BUILD))) \\\n+          $(call HOST_LIB_FROM_HL_GLOB,$(LIBNATIVE_GLOB_$(CFG_BUILD))) \\\n+          $(call HOST_LIB_FROM_HL_GLOB,$(LIBNATIVE_RGLOB_$(CFG_BUILD))) \\\n           $(call HOST_LIB_FROM_HL_GLOB,$(LIBRUSTC_GLOB_$(CFG_BUILD))) \\\n           $(call HOST_LIB_FROM_HL_GLOB,$(LIBSYNTAX_GLOB_$(CFG_BUILD))) \\\n           $(call HOST_LIB_FROM_HL_GLOB,$(LIBRUSTPKG_GLOB_$(CFG_BUILD))) \\\n@@ -237,6 +250,7 @@ install-runtime-target-$(1)-host-$(2): $$(TSREQ$$(ISTAGE)_T_$(1)_H_$(2)) $$(SREQ\n \t$(Q)$(call ADB_PUSH,$$(TL$(1)$(2))/$$(STDLIB_GLOB_$(1)),$(CFG_RUNTIME_PUSH_DIR))\n \t$(Q)$(call ADB_PUSH,$$(TL$(1)$(2))/$$(EXTRALIB_GLOB_$(1)),$(CFG_RUNTIME_PUSH_DIR))\n \t$(Q)$(call ADB_PUSH,$$(TL$(1)$(2))/$$(LIBRUSTUV_GLOB_$(1)),$(CFG_RUNTIME_PUSH_DIR))\n+\t$(Q)$(call ADB_PUSH,$$(TL$(1)$(2))/$$(LIBGREEN_GLOB_$(1)),$(CFG_RUNTIME_PUSH_DIR))\n endef\n \n define INSTALL_RUNTIME_TARGET_CLEANUP_N\n@@ -245,6 +259,7 @@ install-runtime-target-$(1)-cleanup:\n \t$(Q)$(call ADB_SHELL,rm,$(CFG_RUNTIME_PUSH_DIR)/$(STDLIB_GLOB_$(1)))\n \t$(Q)$(call ADB_SHELL,rm,$(CFG_RUNTIME_PUSH_DIR)/$(EXTRALIB_GLOB_$(1)))\n \t$(Q)$(call ADB_SHELL,rm,$(CFG_RUNTIME_PUSH_DIR)/$(LIBRUSTUV_GLOB_$(1)))\n+\t$(Q)$(call ADB_SHELL,rm,$(CFG_RUNTIME_PUSH_DIR)/$(LIBGREEN_GLOB_$(1)))\n endef\n \n $(eval $(call INSTALL_RUNTIME_TARGET_N,arm-linux-androideabi,$(CFG_BUILD)))"}, {"sha": "64bc6ab3afdae5eff9620a3d633bb4eab1e0b802", "filename": "mk/target.mk", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -94,12 +94,37 @@ $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTUV_$(2)): \\\n \t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTUV_GLOB_$(2)),$$(notdir $$@))\n \t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTUV_RGLOB_$(2)),$$(notdir $$@))\n \n+$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBGREEN_$(2)): \\\n+\t\t$$(LIBGREEN_CRATE) $$(LIBGREEN_INPUTS) \\\n+\t        $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_STDLIB_$(2)) \\\n+\t\t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n+\t\t| $$(TLIB$(1)_T_$(2)_H_$(3))/\n+\t@$$(call E, compile_and_link: $$@)\n+\t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBGREEN_GLOB_$(2)),$$(notdir $$@))\n+\t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBGREEN_RGLOB_$(2)),$$(notdir $$@))\n+\t$$(STAGE$(1)_T_$(2)_H_$(3)) $$(WFLAGS_ST$(1)) \\\n+\t\t--out-dir $$(@D) $$< && touch $$@\n+\t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBGREEN_GLOB_$(2)),$$(notdir $$@))\n+\t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBGREEN_RGLOB_$(2)),$$(notdir $$@))\n+\n+$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBNATIVE_$(2)): \\\n+\t\t$$(LIBNATIVE_CRATE) $$(LIBNATIVE_INPUTS) \\\n+\t        $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_STDLIB_$(2)) \\\n+\t\t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n+\t\t| $$(TLIB$(1)_T_$(2)_H_$(3))/\n+\t@$$(call E, compile_and_link: $$@)\n+\t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBNATIVE_GLOB_$(2)),$$(notdir $$@))\n+\t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBNATIVE_RGLOB_$(2)),$$(notdir $$@))\n+\t$$(STAGE$(1)_T_$(2)_H_$(3)) $$(WFLAGS_ST$(1)) \\\n+\t\t--out-dir $$(@D) $$< && touch $$@\n+\t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBNATIVE_GLOB_$(2)),$$(notdir $$@))\n+\t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBNATIVE_RGLOB_$(2)),$$(notdir $$@))\n+\n $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBSYNTAX_$(3)): \\\n                 $$(LIBSYNTAX_CRATE) $$(LIBSYNTAX_INPUTS) \\\n \t\t$$(TSREQ$(1)_T_$(2)_H_$(3))\t\t\t\\\n \t\t$$(TSTDLIB_DEFAULT$(1)_T_$(2)_H_$(3))      \\\n \t\t$$(TEXTRALIB_DEFAULT$(1)_T_$(2)_H_$(3)) \\\n-\t\t$$(TLIBRUSTUV_DEFAULT$(1)_T_$(2)_H_$(3)) \\\n \t\t| $$(TLIB$(1)_T_$(2)_H_$(3))/\n \t@$$(call E, compile_and_link: $$@)\n \t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBSYNTAX_GLOB_$(2)),$$(notdir $$@))\n@@ -135,16 +160,13 @@ $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTC_$(3)):\t\t\\\n \t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTC_GLOB_$(2)),$$(notdir $$@))\n \t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTC_RGLOB_$(2)),$$(notdir $$@))\n \n-# NOTE: after the next snapshot remove these '-L' flags\n $$(TBIN$(1)_T_$(2)_H_$(3))/rustc$$(X_$(3)):\t\t\t\\\n \t\t$$(DRIVER_CRATE)\t\t\t\t\\\n-\t\t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n+\t\t$$(SREQ$(1)_T_$(2)_H_$(3)) \\\n \t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTC_$(3)) \\\n \t\t| $$(TBIN$(1)_T_$(2)_H_$(3))/\n \t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)_T_$(2)_H_$(3)) --cfg rustc -o $$@ $$< \\\n-\t\t-L $$(UV_SUPPORT_DIR_$(2)) \\\n-\t\t-L $$(dir $$(LIBUV_LIB_$(2)))\n+\t$$(STAGE$(1)_T_$(2)_H_$(3)) --cfg rustc -o $$@ $$<\n ifdef CFG_ENABLE_PAX_FLAGS\n \t@$$(call E, apply PaX flags: $$@)\n \t@\"$(CFG_PAXCTL)\" -cm \"$$@\""}, {"sha": "882fc7e554fc7bf9b473d352b823f8dbc15270f5", "filename": "mk/tests.mk", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -14,7 +14,7 @@\n ######################################################################\n \n # The names of crates that must be tested\n-TEST_TARGET_CRATES = std extra rustuv\n+TEST_TARGET_CRATES = std extra rustuv green native\n TEST_DOC_CRATES = std extra\n TEST_HOST_CRATES = rustpkg rustc rustdoc syntax\n TEST_CRATES = $(TEST_TARGET_CRATES) $(TEST_HOST_CRATES)\n@@ -162,6 +162,8 @@ $(info check: android device test dir $(CFG_ADB_TEST_DIR) ready \\\n                   $(CFG_ADB_TEST_DIR)) \\\n  $(shell adb push $(TLIB2_T_arm-linux-androideabi_H_$(CFG_BUILD))/$(LIBRUSTUV_GLOB_arm-linux-androideabi) \\\n                   $(CFG_ADB_TEST_DIR)) \\\n+ $(shell adb push $(TLIB2_T_arm-linux-androideabi_H_$(CFG_BUILD))/$(LIBGREEN_GLOB_arm-linux-androideabi) \\\n+                  $(CFG_ADB_TEST_DIR)) \\\n  )\n else\n CFG_ADB_TEST_DIR=\n@@ -187,7 +189,7 @@ check-test: cleantestlibs cleantmptestlogs all check-stage2-rfail\n \n check-lite: cleantestlibs cleantmptestlogs \\\n \tcheck-stage2-std check-stage2-extra check-stage2-rpass \\\n-\tcheck-stage2-rustuv \\\n+\tcheck-stage2-rustuv check-stage2-native check-stage2-green \\\n \tcheck-stage2-rustpkg \\\n \tcheck-stage2-rfail check-stage2-cfail check-stage2-rmake\n \t$(Q)$(CFG_PYTHON) $(S)src/etc/check-summary.py tmp/*.log\n@@ -339,19 +341,20 @@ define TEST_RUNNER\n ifeq ($(NO_REBUILD),)\n STDTESTDEP_$(1)_$(2)_$(3) = $$(SREQ$(1)_T_$(2)_H_$(3)) \\\n                             $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_EXTRALIB_$(2)) \\\n-                            $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTUV_$(2))\n+                            $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTUV_$(2)) \\\n+                            $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBGREEN_$(2))\n else\n STDTESTDEP_$(1)_$(2)_$(3) =\n endif\n \n $(3)/stage$(1)/test/stdtest-$(2)$$(X_$(2)):\t\t\t\\\n-\t\t$$(STDLIB_CRATE) $$(STDLIB_INPUTS)\t\\\n+\t\t$$(STDLIB_CRATE) $$(STDLIB_INPUTS)\t\t\\\n \t\t$$(STDTESTDEP_$(1)_$(2)_$(3))\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test\n \n $(3)/stage$(1)/test/extratest-$(2)$$(X_$(2)):\t\t\t\\\n-\t\t$$(EXTRALIB_CRATE) $$(EXTRALIB_INPUTS)\t\\\n+\t\t$$(EXTRALIB_CRATE) $$(EXTRALIB_INPUTS)\t\t\\\n \t\t$$(STDTESTDEP_$(1)_$(2)_$(3))\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test\n@@ -364,6 +367,18 @@ $(3)/stage$(1)/test/rustuvtest-$(2)$$(X_$(2)):\t\t\t\\\n \t\t-L $$(UV_SUPPORT_DIR_$(2)) \\\n \t\t-L $$(dir $$(LIBUV_LIB_$(2)))\n \n+$(3)/stage$(1)/test/nativetest-$(2)$$(X_$(2)):\t\t\t\\\n+\t\t$$(LIBNATIVE_CRATE) $$(LIBNATIVE_INPUTS)\t\\\n+\t\t$$(STDTESTDEP_$(1)_$(2)_$(3))\n+\t@$$(call E, compile_and_link: $$@)\n+\t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test\n+\n+$(3)/stage$(1)/test/greentest-$(2)$$(X_$(2)):\t\t\t\\\n+\t\t$$(LIBGREEN_CRATE) $$(LIBGREEN_INPUTS)\t\\\n+\t\t$$(STDTESTDEP_$(1)_$(2)_$(3))\n+\t@$$(call E, compile_and_link: $$@)\n+\t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test\n+\n $(3)/stage$(1)/test/syntaxtest-$(2)$$(X_$(2)):\t\t\t\\\n \t\t$$(LIBSYNTAX_CRATE) $$(LIBSYNTAX_INPUTS)\t\\\n \t\t$$(STDTESTDEP_$(1)_$(2)_$(3))\n@@ -375,7 +390,7 @@ $(3)/stage$(1)/test/rustctest-$(2)$$(X_$(2)):\t\t\t\t\t\\\n \t\t$$(COMPILER_CRATE) $$(COMPILER_INPUTS) \\\n \t\t$$(SREQ$(1)_T_$(2)_H_$(3)) \\\n \t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_RUSTLLVM_$(2)) \\\n-                $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBSYNTAX_$(2))\n+\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBSYNTAX_$(2))\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test \\\n \t    -L \"$$(LLVM_LIBDIR_$(2))\"\n@@ -416,10 +431,10 @@ check-stage$(1)-T-$(2)-H-$(3)-$(4)-exec: $$(call TEST_OK_FILE,$(1),$(2),$(3),$(4\n $$(call TEST_OK_FILE,$(1),$(2),$(3),$(4)): \\\n \t\t$(3)/stage$(1)/test/$(4)test-$(2)$$(X_$(2))\n \t@$$(call E, run: $$<)\n-\t$$(Q)$$(call CFG_RUN_TEST_$(2),$$<,$(2),$(3)) $$(TESTARGS)\t\\\n-\t--logfile $$(call TEST_LOG_FILE,$(1),$(2),$(3),$(4)) \\\n-\t$$(call CRATE_TEST_EXTRA_ARGS,$(1),$(2),$(3),$(4)) \\\n-\t&& touch $$@\n+\t$$(Q)$$(call CFG_RUN_TEST_$(2),$$<,$(2),$(3)) $$(TESTARGS) \\\n+\t    --logfile $$(call TEST_LOG_FILE,$(1),$(2),$(3),$(4)) \\\n+\t    $$(call CRATE_TEST_EXTRA_ARGS,$(1),$(2),$(3),$(4)) \\\n+\t    && touch $$@\n endef\n \n define DEF_TEST_CRATE_RULES_arm-linux-androideabi"}, {"sha": "ae7d1a30a841d036413cc73419221f82dda29f3f", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -13,10 +13,11 @@\n #[allow(non_camel_case_types)];\n #[deny(warnings)];\n \n+#[cfg(stage0)] extern mod green;\n extern mod extra;\n \n use std::os;\n-use std::rt;\n+use std::io;\n use std::io::fs;\n \n use extra::getopts;\n@@ -234,7 +235,7 @@ pub fn run_tests(config: &config) {\n     // sadly osx needs some file descriptor limits raised for running tests in\n     // parallel (especially when we have lots and lots of child processes).\n     // For context, see #8904\n-    rt::test::prepare_for_lots_of_tests();\n+    io::test::raise_fd_limit();\n     let res = test::run_tests_console(&opts, tests);\n     if !res { fail!(\"Some tests failed\"); }\n }"}, {"sha": "b22c17fb4387e804bdd24523cfabd3787be60ebc", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -757,8 +757,8 @@ fn make_lib_name(config: &config, auxfile: &Path, testfile: &Path) -> Path {\n \n fn make_exe_name(config: &config, testfile: &Path) -> Path {\n     let mut f = output_base_name(config, testfile);\n-    if !os::EXE_SUFFIX.is_empty() {\n-        match f.filename().map(|s| s + os::EXE_SUFFIX.as_bytes()) {\n+    if !os::consts::EXE_SUFFIX.is_empty() {\n+        match f.filename().map(|s| s + os::consts::EXE_SUFFIX.as_bytes()) {\n             Some(v) => f.set_filename(v),\n             None => ()\n         }"}, {"sha": "8e5b6356a0b834506eb3097643b920cffb352dc2", "filename": "src/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fdriver.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[cfg(stage0)] extern mod green;\n+\n #[cfg(rustpkg)]\n extern mod this = \"rustpkg\";\n "}, {"sha": "073322b0815a2251abe558383c738555e0b49b7b", "filename": "src/etc/licenseck.py", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Fetc%2Flicenseck.py", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Fetc%2Flicenseck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flicenseck.py?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -76,9 +76,9 @@\n     \"rt/isaac/randport.cpp\", # public domain\n     \"rt/isaac/rand.h\", # public domain\n     \"rt/isaac/standard.h\", # public domain\n-    \"libstd/rt/mpsc_queue.rs\", # BSD\n-    \"libstd/rt/spsc_queue.rs\", # BSD\n-    \"libstd/rt/mpmc_bounded_queue.rs\", # BSD\n+    \"libstd/sync/mpsc_queue.rs\", # BSD\n+    \"libstd/sync/spsc_queue.rs\", # BSD\n+    \"libstd/sync/mpmc_bounded_queue.rs\", # BSD\n ]\n \n def check_license(name, contents):"}, {"sha": "a411c4e9185b10d489161a6f124627870b5cd95b", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 1, "deletions": 64, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -45,7 +45,7 @@ use sync;\n use sync::{Mutex, RWLock};\n \n use std::cast;\n-use std::unstable::sync::UnsafeArc;\n+use std::sync::arc::UnsafeArc;\n use std::task;\n use std::borrow;\n \n@@ -127,20 +127,6 @@ impl<T:Freeze+Send> Arc<T> {\n     pub fn get<'a>(&'a self) -> &'a T {\n         unsafe { &*self.x.get_immut() }\n     }\n-\n-    /**\n-     * Retrieve the data back out of the Arc. This function blocks until the\n-     * reference given to it is the last existing one, and then unwrap the data\n-     * instead of destroying it.\n-     *\n-     * If multiple tasks call unwrap, all but the first will fail. Do not call\n-     * unwrap from a task that holds another reference to the same Arc; it is\n-     * guaranteed to deadlock.\n-     */\n-    pub fn unwrap(self) -> T {\n-        let Arc { x: x } = self;\n-        x.unwrap()\n-    }\n }\n \n impl<T:Freeze + Send> Clone for Arc<T> {\n@@ -247,22 +233,6 @@ impl<T:Send> MutexArc<T> {\n                           cond: cond })\n         })\n     }\n-\n-    /**\n-     * Retrieves the data, blocking until all other references are dropped,\n-     * exactly as arc::unwrap.\n-     *\n-     * Will additionally fail if another task has failed while accessing the arc.\n-     */\n-    pub fn unwrap(self) -> T {\n-        let MutexArc { x: x } = self;\n-        let inner = x.unwrap();\n-        let MutexArcInner { failed: failed, data: data, .. } = inner;\n-        if failed {\n-            fail!(\"Can't unwrap poisoned MutexArc - another task failed inside!\");\n-        }\n-        data\n-    }\n }\n \n impl<T:Freeze + Send> MutexArc<T> {\n@@ -503,23 +473,6 @@ impl<T:Freeze + Send> RWArc<T> {\n             }\n         }\n     }\n-\n-    /**\n-     * Retrieves the data, blocking until all other references are dropped,\n-     * exactly as arc::unwrap.\n-     *\n-     * Will additionally fail if another task has failed while accessing the arc\n-     * in write mode.\n-     */\n-    pub fn unwrap(self) -> T {\n-        let RWArc { x: x, .. } = self;\n-        let inner = x.unwrap();\n-        let RWArcInner { failed: failed, data: data, .. } = inner;\n-        if failed {\n-            fail!(\"Can't unwrap poisoned RWArc - another task failed inside!\")\n-        }\n-        data\n-    }\n }\n \n // Borrowck rightly complains about immutably aliasing the rwlock in order to\n@@ -689,22 +642,6 @@ mod tests {\n         })\n     }\n \n-    #[test] #[should_fail]\n-    pub fn test_mutex_arc_unwrap_poison() {\n-        let arc = MutexArc::new(1);\n-        let arc2 = ~(&arc).clone();\n-        let (p, c) = Chan::new();\n-        do task::spawn {\n-            arc2.access(|one| {\n-                c.send(());\n-                assert!(*one == 2);\n-            })\n-        }\n-        let _ = p.recv();\n-        let one = arc.unwrap();\n-        assert!(one == 1);\n-    }\n-\n     #[test]\n     fn test_unsafe_mutex_arc_nested() {\n         unsafe {"}, {"sha": "52b5bedb7ea4917cdf111d84d097ef5c285f1e52", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -96,7 +96,6 @@ pub fn rendezvous<T: Send>() -> (SyncPort<T>, SyncChan<T>) {\n #[cfg(test)]\n mod test {\n     use comm::{DuplexStream, rendezvous};\n-    use std::rt::test::run_in_uv_task;\n \n \n     #[test]\n@@ -124,13 +123,11 @@ mod test {\n     #[test]\n     fn recv_a_lot() {\n         // Rendezvous streams should be able to handle any number of messages being sent\n-        do run_in_uv_task {\n-            let (port, chan) = rendezvous();\n-            do spawn {\n-                1000000.times(|| { chan.send(()) })\n-            }\n-            1000000.times(|| { port.recv() })\n+        let (port, chan) = rendezvous();\n+        do spawn {\n+            1000000.times(|| { chan.send(()) })\n         }\n+        1000000.times(|| { port.recv() })\n     }\n \n     #[test]"}, {"sha": "f43329076c8b8c9544270c06e317db0ccd6cee00", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -19,8 +19,9 @@\n \n \n use std::borrow;\n-use std::unstable::sync::{Exclusive, UnsafeArc};\n-use std::unstable::atomics;\n+use std::unstable::sync::Exclusive;\n+use std::sync::arc::UnsafeArc;\n+use std::sync::atomics;\n use std::unstable::finally::Finally;\n use std::util;\n use std::util::NonCopyable;\n@@ -78,7 +79,7 @@ impl WaitQueue {\n \n     fn wait_end(&self) -> WaitEnd {\n         let (wait_end, signal_end) = Chan::new();\n-        self.tail.send_deferred(signal_end);\n+        assert!(self.tail.try_send_deferred(signal_end));\n         wait_end\n     }\n }\n@@ -760,23 +761,21 @@ mod tests {\n     fn test_sem_runtime_friendly_blocking() {\n         // Force the runtime to schedule two threads on the same sched_loop.\n         // When one blocks, it should schedule the other one.\n-        do task::spawn_sched(task::SingleThreaded) {\n-            let s = Semaphore::new(1);\n-            let s2 = s.clone();\n-            let (p, c) = Chan::new();\n-            let mut child_data = Some((s2, c));\n-            s.access(|| {\n-                let (s2, c) = child_data.take_unwrap();\n-                do task::spawn {\n-                    c.send(());\n-                    s2.access(|| { });\n-                    c.send(());\n-                }\n-                let _ = p.recv(); // wait for child to come alive\n-                5.times(|| { task::deschedule(); }); // let the child contend\n-            });\n-            let _ = p.recv(); // wait for child to be done\n-        }\n+        let s = Semaphore::new(1);\n+        let s2 = s.clone();\n+        let (p, c) = Chan::new();\n+        let mut child_data = Some((s2, c));\n+        s.access(|| {\n+            let (s2, c) = child_data.take_unwrap();\n+            do task::spawn {\n+                c.send(());\n+                s2.access(|| { });\n+                c.send(());\n+            }\n+            let _ = p.recv(); // wait for child to come alive\n+            5.times(|| { task::deschedule(); }); // let the child contend\n+        });\n+        let _ = p.recv(); // wait for child to be done\n     }\n     /************************************************************************\n      * Mutex tests"}, {"sha": "ba38f8762873120c69a53419375bdea054268b92", "filename": "src/libextra/task_pool.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibextra%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibextra%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftask_pool.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -14,12 +14,9 @@\n /// parallelism.\n \n \n-use std::task::SchedMode;\n use std::task;\n use std::vec;\n \n-#[cfg(test)] use std::task::SingleThreaded;\n-\n enum Msg<T> {\n     Execute(proc(&T)),\n     Quit\n@@ -46,7 +43,6 @@ impl<T> TaskPool<T> {\n     /// returns a function which, given the index of the task, should return\n     /// local data to be kept around in that task.\n     pub fn new(n_tasks: uint,\n-               opt_sched_mode: Option<SchedMode>,\n                init_fn_factory: || -> proc(uint) -> T)\n                -> TaskPool<T> {\n         assert!(n_tasks >= 1);\n@@ -65,18 +61,8 @@ impl<T> TaskPool<T> {\n                 }\n             };\n \n-            // Start the task.\n-            match opt_sched_mode {\n-                None => {\n-                    // Run on this scheduler.\n-                    task::spawn(task_body);\n-                }\n-                Some(sched_mode) => {\n-                    let mut task = task::task();\n-                    task.sched_mode(sched_mode);\n-                    task.spawn(task_body);\n-                }\n-            }\n+            // Run on this scheduler.\n+            task::spawn(task_body);\n \n             chan\n         });\n@@ -99,7 +85,7 @@ fn test_task_pool() {\n         let g: proc(uint) -> uint = proc(i) i;\n         g\n     };\n-    let mut pool = TaskPool::new(4, Some(SingleThreaded), f);\n+    let mut pool = TaskPool::new(4, f);\n     8.times(|| {\n         pool.execute(proc(i) println!(\"Hello from thread {}!\", *i));\n     })"}, {"sha": "0574792c18da8b7e475b789a08b375d08128fedc", "filename": "src/libgreen/basic.rs", "status": "renamed", "additions": 67, "deletions": 14, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -11,15 +11,15 @@\n //! This is a basic event loop implementation not meant for any \"real purposes\"\n //! other than testing the scheduler and proving that it's possible to have a\n //! pluggable event loop.\n+//!\n+//! This implementation is also used as the fallback implementation of an event\n+//! loop if no other one is provided (and M:N scheduling is desired).\n \n-use prelude::*;\n-\n-use cast;\n-use rt::rtio::{EventLoop, IoFactory, RemoteCallback, PausableIdleCallback,\n-               Callback};\n-use unstable::sync::Exclusive;\n-use io::native;\n-use util;\n+use std::cast;\n+use std::rt::rtio::{EventLoop, IoFactory, RemoteCallback, PausableIdleCallback,\n+                    Callback};\n+use std::unstable::sync::Exclusive;\n+use std::util;\n \n /// This is the only exported function from this module.\n pub fn event_loop() -> ~EventLoop {\n@@ -32,7 +32,6 @@ struct BasicLoop {\n     remotes: ~[(uint, ~Callback)],\n     next_remote: uint,\n     messages: Exclusive<~[Message]>,\n-    io: ~IoFactory,\n }\n \n enum Message { RunRemote(uint), RemoveRemote(uint) }\n@@ -45,7 +44,6 @@ impl BasicLoop {\n             next_remote: 0,\n             remotes: ~[],\n             messages: Exclusive::new(~[]),\n-            io: ~native::IoFactory as ~IoFactory,\n         }\n     }\n \n@@ -159,10 +157,7 @@ impl EventLoop for BasicLoop {\n         ~BasicRemote::new(self.messages.clone(), id) as ~RemoteCallback\n     }\n \n-    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory> {\n-        let factory: &mut IoFactory = self.io;\n-        Some(factory)\n-    }\n+    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory> { None }\n }\n \n struct BasicRemote {\n@@ -228,3 +223,61 @@ impl Drop for BasicPausable {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use std::task::TaskOpts;\n+\n+    use basic;\n+    use PoolConfig;\n+    use SchedPool;\n+\n+    fn pool() -> SchedPool {\n+        SchedPool::new(PoolConfig {\n+            threads: 1,\n+            event_loop_factory: Some(basic::event_loop),\n+        })\n+    }\n+\n+    fn run(f: proc()) {\n+        let mut pool = pool();\n+        pool.spawn(TaskOpts::new(), f);\n+        pool.shutdown();\n+    }\n+\n+    #[test]\n+    fn smoke() {\n+        do run {}\n+    }\n+\n+    #[test]\n+    fn some_channels() {\n+        do run {\n+            let (p, c) = Chan::new();\n+            do spawn {\n+                c.send(());\n+            }\n+            p.recv();\n+        }\n+    }\n+\n+    #[test]\n+    fn multi_thread() {\n+        let mut pool = SchedPool::new(PoolConfig {\n+            threads: 2,\n+            event_loop_factory: Some(basic::event_loop),\n+        });\n+\n+        for _ in range(0, 20) {\n+            do pool.spawn(TaskOpts::new()) {\n+                let (p, c) = Chan::new();\n+                do spawn {\n+                    c.send(());\n+                }\n+                p.recv();\n+            }\n+        }\n+\n+        pool.shutdown();\n+    }\n+}", "previous_filename": "src/libstd/rt/basic.rs"}, {"sha": "8530e3e837ea811c4857aa87a2486be16b619871", "filename": "src/libgreen/context.rs", "status": "renamed", "additions": 35, "deletions": 196, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibgreen%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibgreen%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcontext.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use option::*;\n-use super::stack::StackSegment;\n-use libc::c_void;\n-use uint;\n-use cast::{transmute, transmute_mut_unsafe,\n-           transmute_region, transmute_mut_region};\n+use std::libc::c_void;\n+use std::uint;\n+use std::cast::{transmute, transmute_mut_unsafe,\n+                transmute_region, transmute_mut_region};\n+use std::unstable::stack;\n \n-pub static RED_ZONE: uint = 20 * 1024;\n+use stack::StackSegment;\n \n // FIXME #7761: Registers is boxed so that it is 16-byte aligned, for storing\n // SSE regs.  It would be marginally better not to do this. In C++ we\n@@ -43,32 +42,47 @@ impl Context {\n \n     /// Create a new context that will resume execution by running proc()\n     pub fn new(start: proc(), stack: &mut StackSegment) -> Context {\n-        // FIXME #7767: Putting main into a ~ so it's a thin pointer and can\n-        // be passed to the spawn function.  Another unfortunate\n-        // allocation\n-        let start = ~start;\n-\n         // The C-ABI function that is the task entry point\n+        //\n+        // Note that this function is a little sketchy. We're taking a\n+        // procedure, transmuting it to a stack-closure, and then calling to\n+        // closure. This leverages the fact that the representation of these two\n+        // types is the same.\n+        //\n+        // The reason that we're doing this is that this procedure is expected\n+        // to never return. The codegen which frees the environment of the\n+        // procedure occurs *after* the procedure has completed, and this means\n+        // that we'll never actually free the procedure.\n+        //\n+        // To solve this, we use this transmute (to not trigger the procedure\n+        // deallocation here), and then store a copy of the procedure in the\n+        // `Context` structure returned. When the `Context` is deallocated, then\n+        // the entire procedure box will be deallocated as well.\n         extern fn task_start_wrapper(f: &proc()) {\n-            // XXX(pcwalton): This may be sketchy.\n             unsafe {\n                 let f: &|| = transmute(f);\n                 (*f)()\n             }\n         }\n \n-        let fp: *c_void = task_start_wrapper as *c_void;\n-        let argp: *c_void = unsafe { transmute::<&proc(), *c_void>(&*start) };\n         let sp: *uint = stack.end();\n         let sp: *mut uint = unsafe { transmute_mut_unsafe(sp) };\n         // Save and then immediately load the current context,\n         // which we will then modify to call the given function when restored\n         let mut regs = new_regs();\n         unsafe {\n-            rust_swap_registers(transmute_mut_region(&mut *regs), transmute_region(&*regs));\n+            rust_swap_registers(transmute_mut_region(&mut *regs),\n+                                transmute_region(&*regs));\n         };\n \n-        initialize_call_frame(&mut *regs, fp, argp, sp);\n+        // FIXME #7767: Putting main into a ~ so it's a thin pointer and can\n+        // be passed to the spawn function.  Another unfortunate\n+        // allocation\n+        let start = ~start;\n+        initialize_call_frame(&mut *regs,\n+                              task_start_wrapper as *c_void,\n+                              unsafe { transmute(&*start) },\n+                              sp);\n \n         // Scheduler tasks don't have a stack in the \"we allocated it\" sense,\n         // but rather they run on pthreads stacks. We have complete control over\n@@ -113,17 +127,18 @@ impl Context {\n             // invalid for the current task. Lucky for us `rust_swap_registers`\n             // is a C function so we don't have to worry about that!\n             match in_context.stack_bounds {\n-                Some((lo, hi)) => record_stack_bounds(lo, hi),\n+                Some((lo, hi)) => stack::record_stack_bounds(lo, hi),\n                 // If we're going back to one of the original contexts or\n                 // something that's possibly not a \"normal task\", then reset\n                 // the stack limit to 0 to make morestack never fail\n-                None => record_stack_bounds(0, uint::max_value),\n+                None => stack::record_stack_bounds(0, uint::max_value),\n             }\n             rust_swap_registers(out_regs, in_regs)\n         }\n     }\n }\n \n+#[link(name = \"rustrt\", kind = \"static\")]\n extern {\n     fn rust_swap_registers(out_regs: *mut Registers, in_regs: *Registers);\n }\n@@ -282,182 +297,6 @@ fn align_down(sp: *mut uint) -> *mut uint {\n // ptr::mut_offset is positive ints only\n #[inline]\n pub fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n-    use mem::size_of;\n+    use std::mem::size_of;\n     (ptr as int + count * (size_of::<T>() as int)) as *mut T\n }\n-\n-#[inline(always)]\n-pub unsafe fn record_stack_bounds(stack_lo: uint, stack_hi: uint) {\n-    // When the old runtime had segmented stacks, it used a calculation that was\n-    // \"limit + RED_ZONE + FUDGE\". The red zone was for things like dynamic\n-    // symbol resolution, llvm function calls, etc. In theory this red zone\n-    // value is 0, but it matters far less when we have gigantic stacks because\n-    // we don't need to be so exact about our stack budget. The \"fudge factor\"\n-    // was because LLVM doesn't emit a stack check for functions < 256 bytes in\n-    // size. Again though, we have giant stacks, so we round all these\n-    // calculations up to the nice round number of 20k.\n-    record_sp_limit(stack_lo + RED_ZONE);\n-\n-    return target_record_stack_bounds(stack_lo, stack_hi);\n-\n-    #[cfg(not(windows))] #[cfg(not(target_arch = \"x86_64\"))] #[inline(always)]\n-    unsafe fn target_record_stack_bounds(_stack_lo: uint, _stack_hi: uint) {}\n-    #[cfg(windows, target_arch = \"x86_64\")] #[inline(always)]\n-    unsafe fn target_record_stack_bounds(stack_lo: uint, stack_hi: uint) {\n-        // Windows compiles C functions which may check the stack bounds. This\n-        // means that if we want to perform valid FFI on windows, then we need\n-        // to ensure that the stack bounds are what they truly are for this\n-        // task. More info can be found at:\n-        //   https://github.com/mozilla/rust/issues/3445#issuecomment-26114839\n-        //\n-        // stack range is at TIB: %gs:0x08 (top) and %gs:0x10 (bottom)\n-        asm!(\"mov $0, %gs:0x08\" :: \"r\"(stack_hi) :: \"volatile\");\n-        asm!(\"mov $0, %gs:0x10\" :: \"r\"(stack_lo) :: \"volatile\");\n-    }\n-}\n-\n-/// Records the current limit of the stack as specified by `end`.\n-///\n-/// This is stored in an OS-dependent location, likely inside of the thread\n-/// local storage. The location that the limit is stored is a pre-ordained\n-/// location because it's where LLVM has emitted code to check.\n-///\n-/// Note that this cannot be called under normal circumstances. This function is\n-/// changing the stack limit, so upon returning any further function calls will\n-/// possibly be triggering the morestack logic if you're not careful.\n-///\n-/// Also note that this and all of the inside functions are all flagged as\n-/// \"inline(always)\" because they're messing around with the stack limits.  This\n-/// would be unfortunate for the functions themselves to trigger a morestack\n-/// invocation (if they were an actual function call).\n-#[inline(always)]\n-pub unsafe fn record_sp_limit(limit: uint) {\n-    return target_record_sp_limit(limit);\n-\n-    // x86-64\n-    #[cfg(target_arch = \"x86_64\", target_os = \"macos\")] #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: uint) {\n-        asm!(\"movq $$0x60+90*8, %rsi\n-              movq $0, %gs:(%rsi)\" :: \"r\"(limit) : \"rsi\" : \"volatile\")\n-    }\n-    #[cfg(target_arch = \"x86_64\", target_os = \"linux\")] #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: uint) {\n-        asm!(\"movq $0, %fs:112\" :: \"r\"(limit) :: \"volatile\")\n-    }\n-    #[cfg(target_arch = \"x86_64\", target_os = \"win32\")] #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: uint) {\n-        // see: http://en.wikipedia.org/wiki/Win32_Thread_Information_Block\n-        // store this inside of the \"arbitrary data slot\", but double the size\n-        // because this is 64 bit instead of 32 bit\n-        asm!(\"movq $0, %gs:0x28\" :: \"r\"(limit) :: \"volatile\")\n-    }\n-    #[cfg(target_arch = \"x86_64\", target_os = \"freebsd\")] #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: uint) {\n-        asm!(\"movq $0, %fs:24\" :: \"r\"(limit) :: \"volatile\")\n-    }\n-\n-    // x86\n-    #[cfg(target_arch = \"x86\", target_os = \"macos\")] #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: uint) {\n-        asm!(\"movl $$0x48+90*4, %eax\n-              movl $0, %gs:(%eax)\" :: \"r\"(limit) : \"eax\" : \"volatile\")\n-    }\n-    #[cfg(target_arch = \"x86\", target_os = \"linux\")]\n-    #[cfg(target_arch = \"x86\", target_os = \"freebsd\")] #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: uint) {\n-        asm!(\"movl $0, %gs:48\" :: \"r\"(limit) :: \"volatile\")\n-    }\n-    #[cfg(target_arch = \"x86\", target_os = \"win32\")] #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: uint) {\n-        // see: http://en.wikipedia.org/wiki/Win32_Thread_Information_Block\n-        // store this inside of the \"arbitrary data slot\"\n-        asm!(\"movl $0, %fs:0x14\" :: \"r\"(limit) :: \"volatile\")\n-    }\n-\n-    // mips, arm - Some brave soul can port these to inline asm, but it's over\n-    //             my head personally\n-    #[cfg(target_arch = \"mips\")]\n-    #[cfg(target_arch = \"arm\")] #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: uint) {\n-        return record_sp_limit(limit as *c_void);\n-        extern {\n-            fn record_sp_limit(limit: *c_void);\n-        }\n-    }\n-}\n-\n-/// The counterpart of the function above, this function will fetch the current\n-/// stack limit stored in TLS.\n-///\n-/// Note that all of these functions are meant to be exact counterparts of their\n-/// brethren above, except that the operands are reversed.\n-///\n-/// As with the setter, this function does not have a __morestack header and can\n-/// therefore be called in a \"we're out of stack\" situation.\n-#[inline(always)]\n-// currently only called by `rust_stack_exhausted`, which doesn't\n-// exist in a test build.\n-#[cfg(not(test))]\n-pub unsafe fn get_sp_limit() -> uint {\n-    return target_get_sp_limit();\n-\n-    // x86-64\n-    #[cfg(target_arch = \"x86_64\", target_os = \"macos\")] #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> uint {\n-        let limit;\n-        asm!(\"movq $$0x60+90*8, %rsi\n-              movq %gs:(%rsi), $0\" : \"=r\"(limit) :: \"rsi\" : \"volatile\");\n-        return limit;\n-    }\n-    #[cfg(target_arch = \"x86_64\", target_os = \"linux\")] #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> uint {\n-        let limit;\n-        asm!(\"movq %fs:112, $0\" : \"=r\"(limit) ::: \"volatile\");\n-        return limit;\n-    }\n-    #[cfg(target_arch = \"x86_64\", target_os = \"win32\")] #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> uint {\n-        let limit;\n-        asm!(\"movq %gs:0x28, $0\" : \"=r\"(limit) ::: \"volatile\");\n-        return limit;\n-    }\n-    #[cfg(target_arch = \"x86_64\", target_os = \"freebsd\")] #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> uint {\n-        let limit;\n-        asm!(\"movq %fs:24, $0\" : \"=r\"(limit) ::: \"volatile\");\n-        return limit;\n-    }\n-\n-    // x86\n-    #[cfg(target_arch = \"x86\", target_os = \"macos\")] #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> uint {\n-        let limit;\n-        asm!(\"movl $$0x48+90*4, %eax\n-              movl %gs:(%eax), $0\" : \"=r\"(limit) :: \"eax\" : \"volatile\");\n-        return limit;\n-    }\n-    #[cfg(target_arch = \"x86\", target_os = \"linux\")]\n-    #[cfg(target_arch = \"x86\", target_os = \"freebsd\")] #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> uint {\n-        let limit;\n-        asm!(\"movl %gs:48, $0\" : \"=r\"(limit) ::: \"volatile\");\n-        return limit;\n-    }\n-    #[cfg(target_arch = \"x86\", target_os = \"win32\")] #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> uint {\n-        let limit;\n-        asm!(\"movl %fs:0x14, $0\" : \"=r\"(limit) ::: \"volatile\");\n-        return limit;\n-    }\n-\n-    // mips, arm - Some brave soul can port these to inline asm, but it's over\n-    //             my head personally\n-    #[cfg(target_arch = \"mips\")]\n-    #[cfg(target_arch = \"arm\")] #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> uint {\n-        return get_sp_limit() as uint;\n-        extern {\n-            fn get_sp_limit() -> *c_void;\n-        }\n-    }\n-}", "previous_filename": "src/libstd/rt/context.rs"}, {"sha": "7bc5d0accfe3b2aae28920ce046a21266d5ca88f", "filename": "src/libgreen/coroutine.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibgreen%2Fcoroutine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibgreen%2Fcoroutine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcoroutine.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Coroutines represent nothing more than a context and a stack\n+// segment.\n+\n+use std::rt::env;\n+\n+use context::Context;\n+use stack::{StackPool, StackSegment};\n+\n+/// A coroutine is nothing more than a (register context, stack) pair.\n+pub struct Coroutine {\n+    /// The segment of stack on which the task is currently running or\n+    /// if the task is blocked, on which the task will resume\n+    /// execution.\n+    ///\n+    /// Servo needs this to be public in order to tell SpiderMonkey\n+    /// about the stack bounds.\n+    current_stack_segment: StackSegment,\n+\n+    /// Always valid if the task is alive and not running.\n+    saved_context: Context\n+}\n+\n+impl Coroutine {\n+    pub fn new(stack_pool: &mut StackPool,\n+               stack_size: Option<uint>,\n+               start: proc())\n+               -> Coroutine {\n+        let stack_size = match stack_size {\n+            Some(size) => size,\n+            None => env::min_stack()\n+        };\n+        let mut stack = stack_pool.take_segment(stack_size);\n+        let initial_context = Context::new(start, &mut stack);\n+        Coroutine {\n+            current_stack_segment: stack,\n+            saved_context: initial_context\n+        }\n+    }\n+\n+    pub fn empty() -> Coroutine {\n+        Coroutine {\n+            current_stack_segment: StackSegment::new(0),\n+            saved_context: Context::empty()\n+        }\n+    }\n+\n+    /// Destroy coroutine and try to reuse std::stack segment.\n+    pub fn recycle(self, stack_pool: &mut StackPool) {\n+        let Coroutine { current_stack_segment, .. } = self;\n+        stack_pool.give_segment(current_stack_segment);\n+    }\n+}"}, {"sha": "3a2e8a2b36cf54cadd3799c95338c368b643fccd", "filename": "src/libgreen/lib.rs", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -0,0 +1,320 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The \"green scheduling\" library\n+//!\n+//! This library provides M:N threading for rust programs. Internally this has\n+//! the implementation of a green scheduler along with context switching and a\n+//! stack-allocation strategy.\n+//!\n+//! This can be optionally linked in to rust programs in order to provide M:N\n+//! functionality inside of 1:1 programs.\n+\n+#[pkgid = \"green#0.9-pre\"];\n+#[crate_id = \"green#0.9-pre\"];\n+#[license = \"MIT/ASL2\"];\n+#[crate_type = \"rlib\"];\n+#[crate_type = \"dylib\"];\n+\n+// NB this does *not* include globs, please keep it that way.\n+#[feature(macro_rules)];\n+\n+use std::os;\n+use std::rt::crate_map;\n+use std::rt::local::Local;\n+use std::rt::rtio;\n+use std::rt::task::Task;\n+use std::rt::thread::Thread;\n+use std::rt;\n+use std::sync::atomics::{SeqCst, AtomicUint, INIT_ATOMIC_UINT};\n+use std::sync::deque;\n+use std::task::TaskOpts;\n+use std::util;\n+use std::vec;\n+\n+use sched::{Shutdown, Scheduler, SchedHandle, TaskFromFriend, NewNeighbor};\n+use sleeper_list::SleeperList;\n+use stack::StackPool;\n+use task::GreenTask;\n+\n+mod macros;\n+mod simple;\n+\n+pub mod basic;\n+pub mod context;\n+pub mod coroutine;\n+pub mod sched;\n+pub mod sleeper_list;\n+pub mod stack;\n+pub mod task;\n+\n+#[lang = \"start\"]\n+#[cfg(not(test))]\n+pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {\n+    use std::cast;\n+    do start(argc, argv) {\n+        let main: extern \"Rust\" fn() = unsafe { cast::transmute(main) };\n+        main();\n+    }\n+}\n+\n+/// Set up a default runtime configuration, given compiler-supplied arguments.\n+///\n+/// This function will block until the entire pool of M:N schedulers have\n+/// exited. This function also requires a local task to be available.\n+///\n+/// # Arguments\n+///\n+/// * `argc` & `argv` - The argument vector. On Unix this information is used\n+///   by os::args.\n+/// * `main` - The initial procedure to run inside of the M:N scheduling pool.\n+///            Once this procedure exits, the scheduling pool will begin to shut\n+///            down. The entire pool (and this function) will only return once\n+///            all child tasks have finished executing.\n+///\n+/// # Return value\n+///\n+/// The return value is used as the process return code. 0 on success, 101 on\n+/// error.\n+pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n+    rt::init(argc, argv);\n+    let mut main = Some(main);\n+    let mut ret = None;\n+    simple::task().run(|| {\n+        ret = Some(run(main.take_unwrap()));\n+    });\n+    // unsafe is ok b/c we're sure that the runtime is gone\n+    unsafe { rt::cleanup() }\n+    ret.unwrap()\n+}\n+\n+/// Execute the main function in a pool of M:N schedulers.\n+///\n+/// Configures the runtime according to the environment, by default using a task\n+/// scheduler with the same number of threads as cores.  Returns a process exit\n+/// code.\n+///\n+/// This function will not return until all schedulers in the associated pool\n+/// have returned.\n+pub fn run(main: proc()) -> int {\n+    // Create a scheduler pool and spawn the main task into this pool. We will\n+    // get notified over a channel when the main task exits.\n+    let mut pool = SchedPool::new(PoolConfig::new());\n+    let (port, chan) = Chan::new();\n+    let mut opts = TaskOpts::new();\n+    opts.notify_chan = Some(chan);\n+    opts.name = Some(SendStrStatic(\"<main>\"));\n+    pool.spawn(opts, main);\n+\n+    // Wait for the main task to return, and set the process error code\n+    // appropriately.\n+    if port.recv().is_err() {\n+        os::set_exit_status(rt::DEFAULT_ERROR_CODE);\n+    }\n+\n+    // Once the main task has exited and we've set our exit code, wait for all\n+    // spawned sub-tasks to finish running. This is done to allow all schedulers\n+    // to remain active while there are still tasks possibly running.\n+    unsafe {\n+        let mut task = Local::borrow(None::<Task>);\n+        task.get().wait_for_other_tasks();\n+    }\n+\n+    // Now that we're sure all tasks are dead, shut down the pool of schedulers,\n+    // waiting for them all to return.\n+    pool.shutdown();\n+    os::get_exit_status()\n+}\n+\n+/// Configuration of how an M:N pool of schedulers is spawned.\n+pub struct PoolConfig {\n+    /// The number of schedulers (OS threads) to spawn into this M:N pool.\n+    threads: uint,\n+    /// A factory function used to create new event loops. If this is not\n+    /// specified then the default event loop factory is used.\n+    event_loop_factory: Option<fn() -> ~rtio::EventLoop>,\n+}\n+\n+impl PoolConfig {\n+    /// Returns the default configuration, as determined the the environment\n+    /// variables of this process.\n+    pub fn new() -> PoolConfig {\n+        PoolConfig {\n+            threads: rt::default_sched_threads(),\n+            event_loop_factory: None,\n+        }\n+    }\n+}\n+\n+/// A structure representing a handle to a pool of schedulers. This handle is\n+/// used to keep the pool alive and also reap the status from the pool.\n+pub struct SchedPool {\n+    priv id: uint,\n+    priv threads: ~[Thread<()>],\n+    priv handles: ~[SchedHandle],\n+    priv stealers: ~[deque::Stealer<~task::GreenTask>],\n+    priv next_friend: uint,\n+    priv stack_pool: StackPool,\n+    priv deque_pool: deque::BufferPool<~task::GreenTask>,\n+    priv sleepers: SleeperList,\n+    priv factory: fn() -> ~rtio::EventLoop,\n+}\n+\n+impl SchedPool {\n+    /// Execute the main function in a pool of M:N schedulers.\n+    ///\n+    /// This will configure the pool according to the `config` parameter, and\n+    /// initially run `main` inside the pool of schedulers.\n+    pub fn new(config: PoolConfig) -> SchedPool {\n+        static mut POOL_ID: AtomicUint = INIT_ATOMIC_UINT;\n+\n+        let PoolConfig {\n+            threads: nscheds,\n+            event_loop_factory: factory\n+        } = config;\n+        let factory = factory.unwrap_or(default_event_loop_factory());\n+        assert!(nscheds > 0);\n+\n+        // The pool of schedulers that will be returned from this function\n+        let mut pool = SchedPool {\n+            threads: ~[],\n+            handles: ~[],\n+            stealers: ~[],\n+            id: unsafe { POOL_ID.fetch_add(1, SeqCst) },\n+            sleepers: SleeperList::new(),\n+            stack_pool: StackPool::new(),\n+            deque_pool: deque::BufferPool::new(),\n+            next_friend: 0,\n+            factory: factory,\n+        };\n+\n+        // Create a work queue for each scheduler, ntimes. Create an extra\n+        // for the main thread if that flag is set. We won't steal from it.\n+        let arr = vec::from_fn(nscheds, |_| pool.deque_pool.deque());\n+        let (workers, stealers) = vec::unzip(arr.move_iter());\n+        pool.stealers = stealers;\n+\n+        // Now that we've got all our work queues, create one scheduler per\n+        // queue, spawn the scheduler into a thread, and be sure to keep a\n+        // handle to the scheduler and the thread to keep them alive.\n+        for worker in workers.move_iter() {\n+            rtdebug!(\"inserting a regular scheduler\");\n+\n+            let mut sched = ~Scheduler::new(pool.id,\n+                                            (pool.factory)(),\n+                                            worker,\n+                                            pool.stealers.clone(),\n+                                            pool.sleepers.clone());\n+            pool.handles.push(sched.make_handle());\n+            let sched = sched;\n+            pool.threads.push(do Thread::start {\n+                let mut sched = sched;\n+                let task = do GreenTask::new(&mut sched.stack_pool, None) {\n+                    rtdebug!(\"boostraping a non-primary scheduler\");\n+                };\n+                sched.bootstrap(task);\n+            });\n+        }\n+\n+        return pool;\n+    }\n+\n+    pub fn task(&mut self, opts: TaskOpts, f: proc()) -> ~GreenTask {\n+        GreenTask::configure(&mut self.stack_pool, opts, f)\n+    }\n+\n+    pub fn spawn(&mut self, opts: TaskOpts, f: proc()) {\n+        let task = self.task(opts, f);\n+\n+        // Figure out someone to send this task to\n+        let idx = self.next_friend;\n+        self.next_friend += 1;\n+        if self.next_friend >= self.handles.len() {\n+            self.next_friend = 0;\n+        }\n+\n+        // Jettison the task away!\n+        self.handles[idx].send(TaskFromFriend(task));\n+    }\n+\n+    /// Spawns a new scheduler into this M:N pool. A handle is returned to the\n+    /// scheduler for use. The scheduler will not exit as long as this handle is\n+    /// active.\n+    ///\n+    /// The scheduler spawned will participate in work stealing with all of the\n+    /// other schedulers currently in the scheduler pool.\n+    pub fn spawn_sched(&mut self) -> SchedHandle {\n+        let (worker, stealer) = self.deque_pool.deque();\n+        self.stealers.push(stealer.clone());\n+\n+        // Tell all existing schedulers about this new scheduler so they can all\n+        // steal work from it\n+        for handle in self.handles.mut_iter() {\n+            handle.send(NewNeighbor(stealer.clone()));\n+        }\n+\n+        // Create the new scheduler, using the same sleeper list as all the\n+        // other schedulers as well as having a stealer handle to all other\n+        // schedulers.\n+        let mut sched = ~Scheduler::new(self.id,\n+                                        (self.factory)(),\n+                                        worker,\n+                                        self.stealers.clone(),\n+                                        self.sleepers.clone());\n+        let ret = sched.make_handle();\n+        self.handles.push(sched.make_handle());\n+        let sched = sched;\n+        self.threads.push(do Thread::start {\n+            let mut sched = sched;\n+            let task = do GreenTask::new(&mut sched.stack_pool, None) {\n+                rtdebug!(\"boostraping a non-primary scheduler\");\n+            };\n+            sched.bootstrap(task);\n+        });\n+\n+        return ret;\n+    }\n+\n+    pub fn shutdown(mut self) {\n+        self.stealers = ~[];\n+\n+        for mut handle in util::replace(&mut self.handles, ~[]).move_iter() {\n+            handle.send(Shutdown);\n+        }\n+        for thread in util::replace(&mut self.threads, ~[]).move_iter() {\n+            thread.join();\n+        }\n+    }\n+}\n+\n+impl Drop for SchedPool {\n+    fn drop(&mut self) {\n+        if self.threads.len() > 0 {\n+            fail!(\"dropping a M:N scheduler pool that wasn't shut down\");\n+        }\n+    }\n+}\n+\n+fn default_event_loop_factory() -> fn() -> ~rtio::EventLoop {\n+    match crate_map::get_crate_map() {\n+        None => {}\n+        Some(map) => {\n+            match map.event_loop_factory {\n+                None => {}\n+                Some(factory) => return factory\n+            }\n+        }\n+    }\n+\n+    // If the crate map didn't specify a factory to create an event loop, then\n+    // instead just use a basic event loop missing all I/O services to at least\n+    // get the scheduler running.\n+    return basic::event_loop;\n+}"}, {"sha": "56dc3204da86e1ad391db59f7e35c2eb812c675f", "filename": "src/libgreen/macros.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibgreen%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibgreen%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fmacros.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -0,0 +1,129 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// XXX: this file probably shouldn't exist\n+\n+#[macro_escape];\n+\n+use std::fmt;\n+use std::libc;\n+\n+// Indicates whether we should perform expensive sanity checks, including rtassert!\n+// XXX: Once the runtime matures remove the `true` below to turn off rtassert, etc.\n+pub static ENFORCE_SANITY: bool = true || !cfg!(rtopt) || cfg!(rtdebug) || cfg!(rtassert);\n+\n+macro_rules! rterrln (\n+    ($($arg:tt)*) => ( {\n+        format_args!(::macros::dumb_println, $($arg)*)\n+    } )\n+)\n+\n+// Some basic logging. Enabled by passing `--cfg rtdebug` to the libstd build.\n+macro_rules! rtdebug (\n+    ($($arg:tt)*) => ( {\n+        if cfg!(rtdebug) {\n+            rterrln!($($arg)*)\n+        }\n+    })\n+)\n+\n+macro_rules! rtassert (\n+    ( $arg:expr ) => ( {\n+        if ::macros::ENFORCE_SANITY {\n+            if !$arg {\n+                rtabort!(\" assertion failed: {}\", stringify!($arg));\n+            }\n+        }\n+    } )\n+)\n+\n+\n+macro_rules! rtabort (\n+    ($($arg:tt)*) => ( {\n+        ::macros::abort(format!($($arg)*));\n+    } )\n+)\n+\n+pub fn dumb_println(args: &fmt::Arguments) {\n+    use std::io;\n+    use std::libc;\n+\n+    struct Stderr;\n+    impl io::Writer for Stderr {\n+        fn write(&mut self, data: &[u8]) {\n+            unsafe {\n+                libc::write(libc::STDERR_FILENO,\n+                            data.as_ptr() as *libc::c_void,\n+                            data.len() as libc::size_t);\n+            }\n+        }\n+    }\n+    let mut w = Stderr;\n+    fmt::writeln(&mut w as &mut io::Writer, args);\n+}\n+\n+pub fn abort(msg: &str) -> ! {\n+    let msg = if !msg.is_empty() { msg } else { \"aborted\" };\n+    let hash = msg.chars().fold(0, |accum, val| accum + (val as uint) );\n+    let quote = match hash % 10 {\n+        0 => \"\n+It was from the artists and poets that the pertinent answers came, and I\n+know that panic would have broken loose had they been able to compare notes.\n+As it was, lacking their original letters, I half suspected the compiler of\n+having asked leading questions, or of having edited the correspondence in\n+corroboration of what he had latently resolved to see.\",\n+        1 => \"\n+There are not many persons who know what wonders are opened to them in the\n+stories and visions of their youth; for when as children we listen and dream,\n+we think but half-formed thoughts, and when as men we try to remember, we are\n+dulled and prosaic with the poison of life. But some of us awake in the night\n+with strange phantasms of enchanted hills and gardens, of fountains that sing\n+in the sun, of golden cliffs overhanging murmuring seas, of plains that stretch\n+down to sleeping cities of bronze and stone, and of shadowy companies of heroes\n+that ride caparisoned white horses along the edges of thick forests; and then\n+we know that we have looked back through the ivory gates into that world of\n+wonder which was ours before we were wise and unhappy.\",\n+        2 => \"\n+Instead of the poems I had hoped for, there came only a shuddering blackness\n+and ineffable loneliness; and I saw at last a fearful truth which no one had\n+ever dared to breathe before \u2014 the unwhisperable secret of secrets \u2014 The fact\n+that this city of stone and stridor is not a sentient perpetuation of Old New\n+York as London is of Old London and Paris of Old Paris, but that it is in fact\n+quite dead, its sprawling body imperfectly embalmed and infested with queer\n+animate things which have nothing to do with it as it was in life.\",\n+        3 => \"\n+The ocean ate the last of the land and poured into the smoking gulf, thereby\n+giving up all it had ever conquered. From the new-flooded lands it flowed\n+again, uncovering death and decay; and from its ancient and immemorial bed it\n+trickled loathsomely, uncovering nighted secrets of the years when Time was\n+young and the gods unborn. Above the waves rose weedy remembered spires. The\n+moon laid pale lilies of light on dead London, and Paris stood up from its damp\n+grave to be sanctified with star-dust. Then rose spires and monoliths that were\n+weedy but not remembered; terrible spires and monoliths of lands that men never\n+knew were lands...\",\n+        4 => \"\n+There was a night when winds from unknown spaces whirled us irresistibly into\n+limitless vacuum beyond all thought and entity. Perceptions of the most\n+maddeningly untransmissible sort thronged upon us; perceptions of infinity\n+which at the time convulsed us with joy, yet which are now partly lost to my\n+memory and partly incapable of presentation to others.\",\n+        _ => \"You've met with a terrible fate, haven't you?\"\n+    };\n+    rterrln!(\"{}\", \"\");\n+    rterrln!(\"{}\", quote);\n+    rterrln!(\"{}\", \"\");\n+    rterrln!(\"fatal runtime error: {}\", msg);\n+\n+    abort();\n+\n+    fn abort() -> ! {\n+        unsafe { libc::abort() }\n+    }\n+}"}, {"sha": "ef62f654ddf487bcb42573816b98f41daa3b9447", "filename": "src/libgreen/sched.rs", "status": "renamed", "additions": 518, "deletions": 430, "changes": 948, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -8,27 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use option::{Option, Some, None};\n-use cast::{transmute, transmute_mut_region, transmute_mut_unsafe};\n-use clone::Clone;\n-use unstable::raw;\n-use super::sleeper_list::SleeperList;\n-use super::stack::{StackPool};\n-use super::rtio::EventLoop;\n-use super::context::Context;\n-use super::task::{Task, AnySched, Sched};\n-use rt::kill::BlockedTask;\n-use rt::deque;\n-use rt::local_ptr;\n-use rt::local::Local;\n-use rt::rtio::{RemoteCallback, PausableIdleCallback, Callback};\n-use borrow::{to_uint};\n-use rand::{XorShiftRng, Rng, Rand};\n-use iter::range;\n-use unstable::mutex::Mutex;\n-use vec::{OwnedVector};\n-\n-use mpsc = super::mpsc_queue;\n+use std::cast;\n+use std::rand::{XorShiftRng, Rng, Rand};\n+use std::rt::local::Local;\n+use std::rt::rtio::{RemoteCallback, PausableIdleCallback, Callback, EventLoop};\n+use std::rt::task::BlockedTask;\n+use std::rt::task::Task;\n+use std::sync::deque;\n+use std::unstable::mutex::Mutex;\n+use std::unstable::raw;\n+use mpsc = std::sync::mpsc_queue;\n+\n+use context::Context;\n+use coroutine::Coroutine;\n+use sleeper_list::SleeperList;\n+use stack::StackPool;\n+use task::{TypeSched, GreenTask, HomeSched, AnySched};\n \n /// A scheduler is responsible for coordinating the execution of Tasks\n /// on a single thread. The scheduler runs inside a slightly modified\n@@ -39,11 +34,15 @@ use mpsc = super::mpsc_queue;\n /// XXX: This creates too many callbacks to run_sched_once, resulting\n /// in too much allocation and too many events.\n pub struct Scheduler {\n+    /// ID number of the pool that this scheduler is a member of. When\n+    /// reawakening green tasks, this is used to ensure that tasks aren't\n+    /// reawoken on the wrong pool of schedulers.\n+    pool_id: uint,\n     /// There are N work queues, one per scheduler.\n-    work_queue: deque::Worker<~Task>,\n+    work_queue: deque::Worker<~GreenTask>,\n     /// Work queues for the other schedulers. These are created by\n     /// cloning the core work queues.\n-    work_queues: ~[deque::Stealer<~Task>],\n+    work_queues: ~[deque::Stealer<~GreenTask>],\n     /// The queue of incoming messages from other schedulers.\n     /// These are enqueued by SchedHandles after which a remote callback\n     /// is triggered to handle the message.\n@@ -66,15 +65,15 @@ pub struct Scheduler {\n     stack_pool: StackPool,\n     /// The scheduler runs on a special task. When it is not running\n     /// it is stored here instead of the work queue.\n-    sched_task: Option<~Task>,\n+    sched_task: Option<~GreenTask>,\n     /// An action performed after a context switch on behalf of the\n     /// code running before the context switch\n     cleanup_job: Option<CleanupJob>,\n-    /// Should this scheduler run any task, or only pinned tasks?\n-    run_anything: bool,\n     /// If the scheduler shouldn't run some tasks, a friend to send\n     /// them to.\n     friend_handle: Option<SchedHandle>,\n+    /// Should this scheduler run any task, or only pinned tasks?\n+    run_anything: bool,\n     /// A fast XorShift rng for scheduler use\n     rng: XorShiftRng,\n     /// A togglable idle callback\n@@ -117,28 +116,30 @@ impl Scheduler {\n \n     // * Initialization Functions\n \n-    pub fn new(event_loop: ~EventLoop,\n-               work_queue: deque::Worker<~Task>,\n-               work_queues: ~[deque::Stealer<~Task>],\n+    pub fn new(pool_id: uint,\n+               event_loop: ~EventLoop,\n+               work_queue: deque::Worker<~GreenTask>,\n+               work_queues: ~[deque::Stealer<~GreenTask>],\n                sleeper_list: SleeperList)\n         -> Scheduler {\n \n-        Scheduler::new_special(event_loop, work_queue,\n-                               work_queues,\n+        Scheduler::new_special(pool_id, event_loop, work_queue, work_queues,\n                                sleeper_list, true, None)\n \n     }\n \n-    pub fn new_special(event_loop: ~EventLoop,\n-                       work_queue: deque::Worker<~Task>,\n-                       work_queues: ~[deque::Stealer<~Task>],\n+    pub fn new_special(pool_id: uint,\n+                       event_loop: ~EventLoop,\n+                       work_queue: deque::Worker<~GreenTask>,\n+                       work_queues: ~[deque::Stealer<~GreenTask>],\n                        sleeper_list: SleeperList,\n                        run_anything: bool,\n                        friend: Option<SchedHandle>)\n         -> Scheduler {\n \n         let (consumer, producer) = mpsc::queue(());\n         let mut sched = Scheduler {\n+            pool_id: pool_id,\n             sleeper_list: sleeper_list,\n             message_queue: consumer,\n             message_producer: producer,\n@@ -170,83 +171,83 @@ impl Scheduler {\n \n     // Take a main task to run, and a scheduler to run it in. Create a\n     // scheduler task and bootstrap into it.\n-    pub fn bootstrap(mut ~self, task: ~Task) {\n+    pub fn bootstrap(mut ~self, task: ~GreenTask) {\n \n         // Build an Idle callback.\n         let cb = ~SchedRunner as ~Callback;\n         self.idle_callback = Some(self.event_loop.pausable_idle_callback(cb));\n \n-        // Initialize the TLS key.\n-        local_ptr::init();\n-\n         // Create a task for the scheduler with an empty context.\n-        let sched_task = ~Task::new_sched_task();\n-\n-        // Now that we have an empty task struct for the scheduler\n-        // task, put it in TLS.\n-        Local::put(sched_task);\n+        let sched_task = GreenTask::new_typed(Some(Coroutine::empty()),\n+                                              TypeSched);\n \n         // Before starting our first task, make sure the idle callback\n         // is active. As we do not start in the sleep state this is\n         // important.\n         self.idle_callback.get_mut_ref().resume();\n \n-        // Now, as far as all the scheduler state is concerned, we are\n-        // inside the \"scheduler\" context. So we can act like the\n-        // scheduler and resume the provided task.\n-        self.resume_task_immediately(task);\n+        // Now, as far as all the scheduler state is concerned, we are inside\n+        // the \"scheduler\" context. So we can act like the scheduler and resume\n+        // the provided task. Let it think that the currently running task is\n+        // actually the sched_task so it knows where to squirrel it away.\n+        let mut sched_task = self.resume_task_immediately(sched_task, task);\n \n         // Now we are back in the scheduler context, having\n         // successfully run the input task. Start by running the\n         // scheduler. Grab it out of TLS - performing the scheduler\n         // action will have given it away.\n-        let sched: ~Scheduler = Local::take();\n-\n+        let sched = sched_task.sched.take_unwrap();\n         rtdebug!(\"starting scheduler {}\", sched.sched_id());\n-        sched.run();\n+        let mut sched_task = sched.run(sched_task);\n \n         // Close the idle callback.\n-        let mut sched: ~Scheduler = Local::take();\n+        let mut sched = sched_task.sched.take_unwrap();\n         sched.idle_callback.take();\n         // Make one go through the loop to run the close callback.\n-        sched.run();\n+        let mut stask = sched.run(sched_task);\n \n         // Now that we are done with the scheduler, clean up the\n         // scheduler task. Do so by removing it from TLS and manually\n         // cleaning up the memory it uses. As we didn't actually call\n         // task.run() on the scheduler task we never get through all\n         // the cleanup code it runs.\n-        let mut stask: ~Task = Local::take();\n-\n         rtdebug!(\"stopping scheduler {}\", stask.sched.get_ref().sched_id());\n \n         // Should not have any messages\n         let message = stask.sched.get_mut_ref().message_queue.pop();\n         rtassert!(match message { mpsc::Empty => true, _ => false });\n \n-        stask.destroyed = true;\n+        stask.task.get_mut_ref().destroyed = true;\n     }\n \n     // This does not return a scheduler, as the scheduler is placed\n     // inside the task.\n-    pub fn run(mut ~self) {\n+    pub fn run(mut ~self, stask: ~GreenTask) -> ~GreenTask {\n \n         // This is unsafe because we need to place the scheduler, with\n         // the event_loop inside, inside our task. But we still need a\n         // mutable reference to the event_loop to give it the \"run\"\n         // command.\n         unsafe {\n             let event_loop: *mut ~EventLoop = &mut self.event_loop;\n-\n-            {\n-                // Our scheduler must be in the task before the event loop\n-                // is started.\n-                let mut stask = Local::borrow(None::<Task>);\n-                stask.get().sched = Some(self);\n-            }\n-\n+            // Our scheduler must be in the task before the event loop\n+            // is started.\n+            stask.put_with_sched(self);\n             (*event_loop).run();\n         }\n+\n+        //  This is a serious code smell, but this function could be done away\n+        //  with if necessary. The ownership of `stask` was transferred into\n+        //  local storage just before the event loop ran, so it is possible to\n+        //  transmute `stask` as a uint across the running of the event loop to\n+        //  re-acquire ownership here.\n+        //\n+        // This would involve removing the Task from TLS, removing the runtime,\n+        // forgetting the runtime, and then putting the task into `stask`. For\n+        // now, because we have `GreenTask::convert`, I chose to take this\n+        // method for cleanliness. This function is *not* a fundamental reason\n+        // why this function should exist.\n+        GreenTask::convert(Local::take())\n     }\n \n     // * Execution Functions - Core Loop Logic\n@@ -257,38 +258,37 @@ impl Scheduler {\n     // you reach the end and sleep. In the case that a scheduler\n     // action is performed the loop is evented such that this function\n     // is called again.\n-    fn run_sched_once() {\n-\n-        // When we reach the scheduler context via the event loop we\n-        // already have a scheduler stored in our local task, so we\n-        // start off by taking it. This is the only path through the\n-        // scheduler where we get the scheduler this way.\n-        let mut sched: ~Scheduler = Local::take();\n+    fn run_sched_once(mut ~self, stask: ~GreenTask) {\n+        // Make sure that we're not lying in that the `stask` argument is indeed\n+        // the scheduler task for this scheduler.\n+        assert!(self.sched_task.is_none());\n \n         // Assume that we need to continue idling unless we reach the\n         // end of this function without performing an action.\n-        sched.idle_callback.get_mut_ref().resume();\n+        self.idle_callback.get_mut_ref().resume();\n \n         // First we check for scheduler messages, these are higher\n         // priority than regular tasks.\n-        let sched = match sched.interpret_message_queue(DontTryTooHard) {\n-            Some(sched) => sched,\n-            None => return\n-        };\n+        let (sched, stask) =\n+            match self.interpret_message_queue(stask, DontTryTooHard) {\n+                Some(pair) => pair,\n+                None => return\n+            };\n \n         // This helper will use a randomized work-stealing algorithm\n         // to find work.\n-        let sched = match sched.do_work() {\n-            Some(sched) => sched,\n+        let (sched, stask) = match sched.do_work(stask) {\n+            Some(pair) => pair,\n             None => return\n         };\n \n         // Now, before sleeping we need to find out if there really\n         // were any messages. Give it your best!\n-        let mut sched = match sched.interpret_message_queue(GiveItYourBest) {\n-            Some(sched) => sched,\n-            None => return\n-        };\n+        let (mut sched, stask) =\n+            match sched.interpret_message_queue(stask, GiveItYourBest) {\n+                Some(pair) => pair,\n+                None => return\n+            };\n \n         // If we got here then there was no work to do.\n         // Generate a SchedHandle and push it to the sleeper list so\n@@ -309,14 +309,17 @@ impl Scheduler {\n \n         // Finished a cycle without using the Scheduler. Place it back\n         // in TLS.\n-        Local::put(sched);\n+        stask.put_with_sched(sched);\n     }\n \n     // This function returns None if the scheduler is \"used\", or it\n     // returns the still-available scheduler. At this point all\n     // message-handling will count as a turn of work, and as a result\n     // return None.\n-    fn interpret_message_queue(mut ~self, effort: EffortLevel) -> Option<~Scheduler> {\n+    fn interpret_message_queue(mut ~self, stask: ~GreenTask,\n+                               effort: EffortLevel)\n+        -> Option<(~Scheduler, ~GreenTask)>\n+    {\n \n         let msg = if effort == DontTryTooHard {\n             self.message_queue.casual_pop()\n@@ -345,24 +348,25 @@ impl Scheduler {\n         match msg {\n             Some(PinnedTask(task)) => {\n                 let mut task = task;\n-                task.give_home(Sched(self.make_handle()));\n-                self.resume_task_immediately(task);\n+                task.give_home(HomeSched(self.make_handle()));\n+                self.resume_task_immediately(stask, task).put();\n                 return None;\n             }\n             Some(TaskFromFriend(task)) => {\n                 rtdebug!(\"got a task from a friend. lovely!\");\n-                self.process_task(task, Scheduler::resume_task_immediately_cl);\n+                self.process_task(stask, task,\n+                                  Scheduler::resume_task_immediately_cl);\n                 return None;\n             }\n             Some(RunOnce(task)) => {\n                 // bypass the process_task logic to force running this task once\n                 // on this home scheduler. This is often used for I/O (homing).\n-                Scheduler::resume_task_immediately_cl(self, task);\n+                self.resume_task_immediately(stask, task).put();\n                 return None;\n             }\n             Some(Wake) => {\n                 self.sleepy = false;\n-                Local::put(self);\n+                stask.put_with_sched(self);\n                 return None;\n             }\n             Some(Shutdown) => {\n@@ -385,26 +389,31 @@ impl Scheduler {\n                 // event loop references we will shut down.\n                 self.no_sleep = true;\n                 self.sleepy = false;\n-                Local::put(self);\n+                stask.put_with_sched(self);\n                 return None;\n             }\n+            Some(NewNeighbor(neighbor)) => {\n+                self.work_queues.push(neighbor);\n+                return Some((self, stask));\n+            }\n             None => {\n-                return Some(self);\n+                return Some((self, stask));\n             }\n         }\n     }\n \n-    fn do_work(mut ~self) -> Option<~Scheduler> {\n+    fn do_work(mut ~self, stask: ~GreenTask) -> Option<(~Scheduler, ~GreenTask)> {\n         rtdebug!(\"scheduler calling do work\");\n         match self.find_work() {\n             Some(task) => {\n-                rtdebug!(\"found some work! processing the task\");\n-                self.process_task(task, Scheduler::resume_task_immediately_cl);\n+                rtdebug!(\"found some work! running the task\");\n+                self.process_task(stask, task,\n+                                  Scheduler::resume_task_immediately_cl);\n                 return None;\n             }\n             None => {\n                 rtdebug!(\"no work was found, returning the scheduler struct\");\n-                return Some(self);\n+                return Some((self, stask));\n             }\n         }\n     }\n@@ -418,7 +427,7 @@ impl Scheduler {\n     // First step in the process is to find a task. This function does\n     // that by first checking the local queue, and if there is no work\n     // there, trying to steal from the remote work queues.\n-    fn find_work(&mut self) -> Option<~Task> {\n+    fn find_work(&mut self) -> Option<~GreenTask> {\n         rtdebug!(\"scheduler looking for work\");\n         if !self.steal_for_yield {\n             match self.work_queue.pop() {\n@@ -456,7 +465,7 @@ impl Scheduler {\n     // Try stealing from all queues the scheduler knows about. This\n     // naive implementation can steal from our own queue or from other\n     // special schedulers.\n-    fn try_steals(&mut self) -> Option<~Task> {\n+    fn try_steals(&mut self) -> Option<~GreenTask> {\n         let work_queues = &mut self.work_queues;\n         let len = work_queues.len();\n         let start_index = self.rng.gen_range(0, len);\n@@ -476,53 +485,48 @@ impl Scheduler {\n     // * Task Routing Functions - Make sure tasks send up in the right\n     // place.\n \n-    fn process_task(mut ~self, mut task: ~Task, schedule_fn: SchedulingFn) {\n+    fn process_task(mut ~self, cur: ~GreenTask,\n+                    mut next: ~GreenTask, schedule_fn: SchedulingFn) {\n         rtdebug!(\"processing a task\");\n \n-        let home = task.take_unwrap_home();\n-        match home {\n-            Sched(home_handle) => {\n+        match next.take_unwrap_home() {\n+            HomeSched(home_handle) => {\n                 if home_handle.sched_id != self.sched_id() {\n                     rtdebug!(\"sending task home\");\n-                    task.give_home(Sched(home_handle));\n-                    Scheduler::send_task_home(task);\n-                    Local::put(self);\n+                    next.give_home(HomeSched(home_handle));\n+                    Scheduler::send_task_home(next);\n+                    cur.put_with_sched(self);\n                 } else {\n                     rtdebug!(\"running task here\");\n-                    task.give_home(Sched(home_handle));\n-                    schedule_fn(self, task);\n+                    next.give_home(HomeSched(home_handle));\n+                    schedule_fn(self, cur, next);\n                 }\n             }\n             AnySched if self.run_anything => {\n                 rtdebug!(\"running anysched task here\");\n-                task.give_home(AnySched);\n-                schedule_fn(self, task);\n+                next.give_home(AnySched);\n+                schedule_fn(self, cur, next);\n             }\n             AnySched => {\n                 rtdebug!(\"sending task to friend\");\n-                task.give_home(AnySched);\n-                self.send_to_friend(task);\n-                Local::put(self);\n+                next.give_home(AnySched);\n+                self.send_to_friend(next);\n+                cur.put_with_sched(self);\n             }\n         }\n     }\n \n-    fn send_task_home(task: ~Task) {\n+    fn send_task_home(task: ~GreenTask) {\n         let mut task = task;\n-        let mut home = task.take_unwrap_home();\n-        match home {\n-            Sched(ref mut home_handle) => {\n-                home_handle.send(PinnedTask(task));\n-            }\n-            AnySched => {\n-                        rtabort!(\"error: cannot send anysched task home\");\n-            }\n+        match task.take_unwrap_home() {\n+            HomeSched(mut home_handle) => home_handle.send(PinnedTask(task)),\n+            AnySched => rtabort!(\"error: cannot send anysched task home\"),\n         }\n     }\n \n     /// Take a non-homed task we aren't allowed to run here and send\n     /// it to the designated friend scheduler to execute.\n-    fn send_to_friend(&mut self, task: ~Task) {\n+    fn send_to_friend(&mut self, task: ~GreenTask) {\n         rtdebug!(\"sending a task to friend\");\n         match self.friend_handle {\n             Some(ref mut handle) => {\n@@ -539,9 +543,10 @@ impl Scheduler {\n     /// Pushes the task onto the work stealing queue and tells the\n     /// event loop to run it later. Always use this instead of pushing\n     /// to the work queue directly.\n-    pub fn enqueue_task(&mut self, task: ~Task) {\n+    pub fn enqueue_task(&mut self, task: ~GreenTask) {\n \n         // We push the task onto our local queue clone.\n+        assert!(!task.is_sched());\n         self.work_queue.push(task);\n         self.idle_callback.get_mut_ref().resume();\n \n@@ -557,47 +562,31 @@ impl Scheduler {\n         };\n     }\n \n-    /// As enqueue_task, but with the possibility for the blocked task to\n-    /// already have been killed.\n-    pub fn enqueue_blocked_task(&mut self, blocked_task: BlockedTask) {\n-        blocked_task.wake().map(|task| self.enqueue_task(task));\n-    }\n-\n     // * Core Context Switching Functions\n \n     // The primary function for changing contexts. In the current\n     // design the scheduler is just a slightly modified GreenTask, so\n-    // all context swaps are from Task to Task. The only difference\n+    // all context swaps are from GreenTask to GreenTask. The only difference\n     // between the various cases is where the inputs come from, and\n     // what is done with the resulting task. That is specified by the\n     // cleanup function f, which takes the scheduler and the\n     // old task as inputs.\n \n     pub fn change_task_context(mut ~self,\n-                               next_task: ~Task,\n-                               f: |&mut Scheduler, ~Task|) {\n-        // The current task is grabbed from TLS, not taken as an input.\n-        // Doing an unsafe_take to avoid writing back a null pointer -\n-        // We're going to call `put` later to do that.\n-        let current_task: ~Task = unsafe { Local::unsafe_take() };\n-\n-        // Check that the task is not in an atomically() section (e.g.,\n-        // holding a pthread mutex, which could deadlock the scheduler).\n-        current_task.death.assert_may_sleep();\n-\n-        // These transmutes do something fishy with a closure.\n-        let f_fake_region = unsafe {\n-            transmute::<|&mut Scheduler, ~Task|,\n-                        |&mut Scheduler, ~Task|>(f)\n+                               current_task: ~GreenTask,\n+                               mut next_task: ~GreenTask,\n+                               f: |&mut Scheduler, ~GreenTask|) -> ~GreenTask {\n+        let f_opaque = ClosureConverter::from_fn(f);\n+\n+        let current_task_dupe = unsafe {\n+            *cast::transmute::<&~GreenTask, &uint>(&current_task)\n         };\n-        let f_opaque = ClosureConverter::from_fn(f_fake_region);\n \n         // The current task is placed inside an enum with the cleanup\n         // function. This enum is then placed inside the scheduler.\n         self.cleanup_job = Some(CleanupJob::new(current_task, f_opaque));\n \n         // The scheduler is then placed inside the next task.\n-        let mut next_task = next_task;\n         next_task.sched = Some(self);\n \n         // However we still need an internal mutable pointer to the\n@@ -607,12 +596,12 @@ impl Scheduler {\n         unsafe {\n \n             let sched: &mut Scheduler =\n-                transmute_mut_region(*next_task.sched.get_mut_ref());\n+                cast::transmute_mut_region(*next_task.sched.get_mut_ref());\n \n-            let current_task: &mut Task = match sched.cleanup_job {\n+            let current_task: &mut GreenTask = match sched.cleanup_job {\n                 Some(CleanupJob { task: ref task, .. }) => {\n-                    let task_ptr: *~Task = task;\n-                    transmute_mut_region(*transmute_mut_unsafe(task_ptr))\n+                    let task_ptr: *~GreenTask = task;\n+                    cast::transmute_mut_region(*cast::transmute_mut_unsafe(task_ptr))\n                 }\n                 None => {\n                     rtabort!(\"no cleanup job\");\n@@ -626,7 +615,7 @@ impl Scheduler {\n             // works because due to transmute the borrow checker\n             // believes that we have no internal pointers to\n             // next_task.\n-            Local::put(next_task);\n+            cast::forget(next_task);\n \n             // The raw context swap operation. The next action taken\n             // will be running the cleanup job from the context of the\n@@ -637,54 +626,53 @@ impl Scheduler {\n         // When the context swaps back to this task we immediately\n         // run the cleanup job, as expected by the previously called\n         // swap_contexts function.\n+        let mut current_task: ~GreenTask = unsafe {\n+            cast::transmute(current_task_dupe)\n+        };\n+        current_task.sched.get_mut_ref().run_cleanup_job();\n+\n+        // See the comments in switch_running_tasks_and_then for why a lock\n+        // is acquired here. This is the resumption points and the \"bounce\"\n+        // that it is referring to.\n         unsafe {\n-            let task: *mut Task = Local::unsafe_borrow();\n-            (*task).sched.get_mut_ref().run_cleanup_job();\n-\n-            // See the comments in switch_running_tasks_and_then for why a lock\n-            // is acquired here. This is the resumption points and the \"bounce\"\n-            // that it is referring to.\n-            (*task).nasty_deschedule_lock.lock();\n-            (*task).nasty_deschedule_lock.unlock();\n+            current_task.nasty_deschedule_lock.lock();\n+            current_task.nasty_deschedule_lock.unlock();\n         }\n+        return current_task;\n     }\n \n     // Returns a mutable reference to both contexts involved in this\n     // swap. This is unsafe - we are getting mutable internal\n     // references to keep even when we don't own the tasks. It looks\n     // kinda safe because we are doing transmutes before passing in\n     // the arguments.\n-    pub fn get_contexts<'a>(current_task: &mut Task, next_task: &mut Task) ->\n+    pub fn get_contexts<'a>(current_task: &mut GreenTask, next_task: &mut GreenTask) ->\n         (&'a mut Context, &'a mut Context) {\n         let current_task_context =\n             &mut current_task.coroutine.get_mut_ref().saved_context;\n         let next_task_context =\n                 &mut next_task.coroutine.get_mut_ref().saved_context;\n         unsafe {\n-            (transmute_mut_region(current_task_context),\n-             transmute_mut_region(next_task_context))\n+            (cast::transmute_mut_region(current_task_context),\n+             cast::transmute_mut_region(next_task_context))\n         }\n     }\n \n     // * Context Swapping Helpers - Here be ugliness!\n \n-    pub fn resume_task_immediately(~self, task: ~Task) {\n-        self.change_task_context(task, |sched, stask| {\n+    pub fn resume_task_immediately(~self, cur: ~GreenTask,\n+                                   next: ~GreenTask) -> ~GreenTask {\n+        assert!(cur.is_sched());\n+        self.change_task_context(cur, next, |sched, stask| {\n+            assert!(sched.sched_task.is_none());\n             sched.sched_task = Some(stask);\n         })\n     }\n \n     fn resume_task_immediately_cl(sched: ~Scheduler,\n-                                  task: ~Task) {\n-        sched.resume_task_immediately(task)\n-    }\n-\n-\n-    pub fn resume_blocked_task_immediately(~self, blocked_task: BlockedTask) {\n-        match blocked_task.wake() {\n-            Some(task) => { self.resume_task_immediately(task); }\n-            None => Local::put(self)\n-        };\n+                                  cur: ~GreenTask,\n+                                  next: ~GreenTask) {\n+        sched.resume_task_immediately(cur, next).put()\n     }\n \n     /// Block a running task, context switch to the scheduler, then pass the\n@@ -709,15 +697,18 @@ impl Scheduler {\n     /// guaranteed that this function will not return before the given closure\n     /// has returned.\n     pub fn deschedule_running_task_and_then(mut ~self,\n+                                            cur: ~GreenTask,\n                                             f: |&mut Scheduler, BlockedTask|) {\n         // Trickier - we need to get the scheduler task out of self\n         // and use it as the destination.\n         let stask = self.sched_task.take_unwrap();\n         // Otherwise this is the same as below.\n-        self.switch_running_tasks_and_then(stask, f);\n+        self.switch_running_tasks_and_then(cur, stask, f)\n     }\n \n-    pub fn switch_running_tasks_and_then(~self, next_task: ~Task,\n+    pub fn switch_running_tasks_and_then(~self,\n+                                         cur: ~GreenTask,\n+                                         next: ~GreenTask,\n                                          f: |&mut Scheduler, BlockedTask|) {\n         // And here comes one of the sad moments in which a lock is used in a\n         // core portion of the rust runtime. As always, this is highly\n@@ -733,80 +724,99 @@ impl Scheduler {\n         // task-local lock around this block. The resumption of the task in\n         // context switching will bounce on the lock, thereby waiting for this\n         // block to finish, eliminating the race mentioned above.\n+        // fail!(\"should never return!\");\n         //\n         // To actually maintain a handle to the lock, we use an unsafe pointer\n         // to it, but we're guaranteed that the task won't exit until we've\n         // unlocked the lock so there's no worry of this memory going away.\n-        self.change_task_context(next_task, |sched, mut task| {\n+        let cur = self.change_task_context(cur, next, |sched, mut task| {\n             let lock: *mut Mutex = &mut task.nasty_deschedule_lock;\n             unsafe { (*lock).lock() }\n-            f(sched, BlockedTask::block(task));\n+            f(sched, BlockedTask::block(task.swap()));\n             unsafe { (*lock).unlock() }\n-        })\n+        });\n+        cur.put();\n     }\n \n-    fn switch_task(sched: ~Scheduler, task: ~Task) {\n-        sched.switch_running_tasks_and_then(task, |sched, last_task| {\n-            sched.enqueue_blocked_task(last_task);\n-        });\n+    fn switch_task(sched: ~Scheduler, cur: ~GreenTask, next: ~GreenTask) {\n+        sched.change_task_context(cur, next, |sched, last_task| {\n+            if last_task.is_sched() {\n+                assert!(sched.sched_task.is_none());\n+                sched.sched_task = Some(last_task);\n+            } else {\n+                sched.enqueue_task(last_task);\n+            }\n+        }).put()\n     }\n \n     // * Task Context Helpers\n \n     /// Called by a running task to end execution, after which it will\n     /// be recycled by the scheduler for reuse in a new task.\n-    pub fn terminate_current_task(mut ~self) {\n+    pub fn terminate_current_task(mut ~self, cur: ~GreenTask) {\n         // Similar to deschedule running task and then, but cannot go through\n         // the task-blocking path. The task is already dying.\n         let stask = self.sched_task.take_unwrap();\n-        self.change_task_context(stask, |sched, mut dead_task| {\n+        let _cur = self.change_task_context(cur, stask, |sched, mut dead_task| {\n             let coroutine = dead_task.coroutine.take_unwrap();\n             coroutine.recycle(&mut sched.stack_pool);\n-        })\n+        });\n+        fail!(\"should never return!\");\n     }\n \n-    pub fn run_task(task: ~Task) {\n-        let sched: ~Scheduler = Local::take();\n-        sched.process_task(task, Scheduler::switch_task);\n+    pub fn run_task(~self, cur: ~GreenTask, next: ~GreenTask) {\n+        self.process_task(cur, next, Scheduler::switch_task);\n     }\n \n-    pub fn run_task_later(next_task: ~Task) {\n-        let mut sched = Local::borrow(None::<Scheduler>);\n-        sched.get().enqueue_task(next_task);\n+    pub fn run_task_later(mut cur: ~GreenTask, next: ~GreenTask) {\n+        let mut sched = cur.sched.take_unwrap();\n+        sched.enqueue_task(next);\n+        cur.put_with_sched(sched);\n     }\n \n     /// Yield control to the scheduler, executing another task. This is guaranteed\n     /// to introduce some amount of randomness to the scheduler. Currently the\n     /// randomness is a result of performing a round of work stealing (which\n     /// may end up stealing from the current scheduler).\n-    pub fn yield_now(mut ~self) {\n-        self.yield_check_count = reset_yield_check(&mut self.rng);\n-        // Tell the scheduler to start stealing on the next iteration\n-        self.steal_for_yield = true;\n-        self.deschedule_running_task_and_then(|sched, task| {\n-            sched.enqueue_blocked_task(task);\n-        })\n+    pub fn yield_now(mut ~self, cur: ~GreenTask) {\n+        // Async handles trigger the scheduler by calling yield_now on the local\n+        // task, which eventually gets us to here. See comments in SchedRunner\n+        // for more info on this.\n+        if cur.is_sched() {\n+            assert!(self.sched_task.is_none());\n+            self.run_sched_once(cur);\n+        } else {\n+            self.yield_check_count = reset_yield_check(&mut self.rng);\n+            // Tell the scheduler to start stealing on the next iteration\n+            self.steal_for_yield = true;\n+            let stask = self.sched_task.take_unwrap();\n+            let cur = self.change_task_context(cur, stask, |sched, task| {\n+                sched.enqueue_task(task);\n+            });\n+            cur.put()\n+        }\n     }\n \n-    pub fn maybe_yield(mut ~self) {\n-        // The number of times to do the yield check before yielding, chosen arbitrarily.\n+    pub fn maybe_yield(mut ~self, cur: ~GreenTask) {\n+        // The number of times to do the yield check before yielding, chosen\n+        // arbitrarily.\n         rtassert!(self.yield_check_count > 0);\n         self.yield_check_count -= 1;\n         if self.yield_check_count == 0 {\n-            self.yield_now();\n+            self.yield_now(cur);\n         } else {\n-            Local::put(self);\n+            cur.put_with_sched(self);\n         }\n     }\n \n \n     // * Utility Functions\n \n-    pub fn sched_id(&self) -> uint { to_uint(self) }\n+    pub fn sched_id(&self) -> uint { unsafe { cast::transmute(self) } }\n \n     pub fn run_cleanup_job(&mut self) {\n         let cleanup_job = self.cleanup_job.take_unwrap();\n-        cleanup_job.run(self);\n+        cleanup_job.run(self)\n     }\n \n     pub fn make_handle(&mut self) -> SchedHandle {\n@@ -816,20 +826,21 @@ impl Scheduler {\n             remote: remote,\n             queue: self.message_producer.clone(),\n             sched_id: self.sched_id()\n-        };\n+        }\n     }\n }\n \n // Supporting types\n \n-type SchedulingFn = extern \"Rust\" fn (~Scheduler, ~Task);\n+type SchedulingFn = extern \"Rust\" fn (~Scheduler, ~GreenTask, ~GreenTask);\n \n pub enum SchedMessage {\n     Wake,\n     Shutdown,\n-    PinnedTask(~Task),\n-    TaskFromFriend(~Task),\n-    RunOnce(~Task),\n+    NewNeighbor(deque::Stealer<~GreenTask>),\n+    PinnedTask(~GreenTask),\n+    TaskFromFriend(~GreenTask),\n+    RunOnce(~GreenTask),\n }\n \n pub struct SchedHandle {\n@@ -849,17 +860,28 @@ struct SchedRunner;\n \n impl Callback for SchedRunner {\n     fn call(&mut self) {\n-        Scheduler::run_sched_once();\n+        // In theory, this function needs to invoke the `run_sched_once`\n+        // function on the scheduler. Sadly, we have no context here, except for\n+        // knowledge of the local `Task`. In order to avoid a call to\n+        // `GreenTask::convert`, we just call `yield_now` and the scheduler will\n+        // detect when a sched task performs a yield vs a green task performing\n+        // a yield (and act accordingly).\n+        //\n+        // This function could be converted to `GreenTask::convert` if\n+        // absolutely necessary, but for cleanliness it is much better to not\n+        // use the conversion function.\n+        let task: ~Task = Local::take();\n+        task.yield_now();\n     }\n }\n \n struct CleanupJob {\n-    task: ~Task,\n+    task: ~GreenTask,\n     f: UnsafeTaskReceiver\n }\n \n impl CleanupJob {\n-    pub fn new(task: ~Task, f: UnsafeTaskReceiver) -> CleanupJob {\n+    pub fn new(task: ~GreenTask, f: UnsafeTaskReceiver) -> CleanupJob {\n         CleanupJob {\n             task: task,\n             f: f\n@@ -876,14 +898,16 @@ impl CleanupJob {\n // complaining\n type UnsafeTaskReceiver = raw::Closure;\n trait ClosureConverter {\n-    fn from_fn(|&mut Scheduler, ~Task|) -> Self;\n-    fn to_fn(self) -> |&mut Scheduler, ~Task|;\n+    fn from_fn(|&mut Scheduler, ~GreenTask|) -> Self;\n+    fn to_fn(self) -> |&mut Scheduler, ~GreenTask|;\n }\n impl ClosureConverter for UnsafeTaskReceiver {\n-    fn from_fn(f: |&mut Scheduler, ~Task|) -> UnsafeTaskReceiver {\n-        unsafe { transmute(f) }\n+    fn from_fn(f: |&mut Scheduler, ~GreenTask|) -> UnsafeTaskReceiver {\n+        unsafe { cast::transmute(f) }\n+    }\n+    fn to_fn(self) -> |&mut Scheduler, ~GreenTask| {\n+        unsafe { cast::transmute(self) }\n     }\n-    fn to_fn(self) -> |&mut Scheduler, ~Task| { unsafe { transmute(self) } }\n }\n \n // On unix, we read randomness straight from /dev/urandom, but the\n@@ -897,12 +921,9 @@ fn new_sched_rng() -> XorShiftRng {\n }\n #[cfg(unix)]\n fn new_sched_rng() -> XorShiftRng {\n-    use libc;\n-    use mem;\n-    use c_str::ToCStr;\n-    use vec::MutableVector;\n-    use iter::Iterator;\n-    use rand::SeedableRng;\n+    use std::libc;\n+    use std::mem;\n+    use std::rand::SeedableRng;\n \n     let fd = \"/dev/urandom\".with_c_str(|name| {\n         unsafe { libc::open(name, libc::O_RDONLY, 0) }\n@@ -933,24 +954,47 @@ fn new_sched_rng() -> XorShiftRng {\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n-\n-    use borrow::to_uint;\n-    use rt::deque::BufferPool;\n-    use rt::basic;\n-    use rt::sched::{Scheduler};\n-    use rt::task::{Task, Sched};\n-    use rt::test::*;\n-    use rt::thread::Thread;\n-    use rt::util;\n-    use task::TaskResult;\n-    use unstable::run_in_bare_thread;\n+    use std::task::TaskOpts;\n+    use std::rt::Runtime;\n+    use std::rt::task::Task;\n+    use std::rt::local::Local;\n+\n+    use basic;\n+    use sched::{TaskFromFriend, PinnedTask};\n+    use task::{GreenTask, HomeSched};\n+    use PoolConfig;\n+    use SchedPool;\n+\n+    fn pool() -> SchedPool {\n+        SchedPool::new(PoolConfig {\n+            threads: 1,\n+            event_loop_factory: Some(basic::event_loop),\n+        })\n+    }\n+\n+    fn run(f: proc()) {\n+        let mut pool = pool();\n+        pool.spawn(TaskOpts::new(), f);\n+        pool.shutdown();\n+    }\n+\n+    fn sched_id() -> uint {\n+        let mut task = Local::borrow(None::<Task>);\n+        match task.get().maybe_take_runtime::<GreenTask>() {\n+            Some(green) => {\n+                let ret = green.sched.get_ref().sched_id();\n+                task.get().put_runtime(green as ~Runtime);\n+                return ret;\n+            }\n+            None => fail!()\n+        }\n+    }\n \n     #[test]\n     fn trivial_run_in_newsched_task_test() {\n         let mut task_ran = false;\n         let task_ran_ptr: *mut bool = &mut task_ran;\n-        do run_in_newsched_task || {\n+        do run {\n             unsafe { *task_ran_ptr = true };\n             rtdebug!(\"executed from the new scheduler\")\n         }\n@@ -962,9 +1006,11 @@ mod test {\n         let total = 10;\n         let mut task_run_count = 0;\n         let task_run_count_ptr: *mut uint = &mut task_run_count;\n-        do run_in_newsched_task || {\n+        // with only one thread this is safe to run in without worries of\n+        // contention.\n+        do run {\n             for _ in range(0u, total) {\n-                do spawntask || {\n+                do spawn || {\n                     unsafe { *task_run_count_ptr = *task_run_count_ptr + 1};\n                 }\n             }\n@@ -976,12 +1022,12 @@ mod test {\n     fn multiple_task_nested_test() {\n         let mut task_run_count = 0;\n         let task_run_count_ptr: *mut uint = &mut task_run_count;\n-        do run_in_newsched_task || {\n-            do spawntask || {\n+        do run {\n+            do spawn {\n                 unsafe { *task_run_count_ptr = *task_run_count_ptr + 1 };\n-                do spawntask || {\n+                do spawn {\n                     unsafe { *task_run_count_ptr = *task_run_count_ptr + 1 };\n-                    do spawntask || {\n+                    do spawn {\n                         unsafe { *task_run_count_ptr = *task_run_count_ptr + 1 };\n                     }\n                 }\n@@ -990,65 +1036,47 @@ mod test {\n         assert!(task_run_count == 3);\n     }\n \n-    // Confirm that a sched_id actually is the uint form of the\n-    // pointer to the scheduler struct.\n-    #[test]\n-    fn simple_sched_id_test() {\n-        do run_in_bare_thread {\n-            let sched = ~new_test_uv_sched();\n-            assert!(to_uint(sched) == sched.sched_id());\n-        }\n-    }\n-\n-    // Compare two scheduler ids that are different, this should never\n-    // fail but may catch a mistake someday.\n-    #[test]\n-    fn compare_sched_id_test() {\n-        do run_in_bare_thread {\n-            let sched_one = ~new_test_uv_sched();\n-            let sched_two = ~new_test_uv_sched();\n-            assert!(sched_one.sched_id() != sched_two.sched_id());\n-        }\n-    }\n-\n-\n     // A very simple test that confirms that a task executing on the\n     // home scheduler notices that it is home.\n     #[test]\n     fn test_home_sched() {\n-        do run_in_bare_thread {\n-            let mut task_ran = false;\n-            let task_ran_ptr: *mut bool = &mut task_ran;\n+        let mut pool = pool();\n \n-            let mut sched = ~new_test_uv_sched();\n-            let sched_handle = sched.make_handle();\n+        let (dport, dchan) = Chan::new();\n+        {\n+            let (port, chan) = Chan::new();\n+            let mut handle1 = pool.spawn_sched();\n+            let mut handle2 = pool.spawn_sched();\n \n-            let mut task = ~do Task::new_root_homed(&mut sched.stack_pool, None,\n-                                                Sched(sched_handle)) {\n-                unsafe { *task_ran_ptr = true };\n-                assert!(Task::on_appropriate_sched());\n-            };\n+            handle1.send(TaskFromFriend(do pool.task(TaskOpts::new()) {\n+                chan.send(sched_id());\n+            }));\n+            let sched1_id = port.recv();\n \n-            let on_exit: proc(TaskResult) = proc(exit_status) {\n-                rtassert!(exit_status.is_ok())\n+            let mut task = do pool.task(TaskOpts::new()) {\n+                assert_eq!(sched_id(), sched1_id);\n+                dchan.send(());\n             };\n-            task.death.on_exit = Some(on_exit);\n-\n-            sched.bootstrap(task);\n+            task.give_home(HomeSched(handle1));\n+            handle2.send(TaskFromFriend(task));\n         }\n+        dport.recv();\n+\n+        pool.shutdown();\n     }\n \n     // An advanced test that checks all four possible states that a\n     // (task,sched) can be in regarding homes.\n \n     #[test]\n     fn test_schedule_home_states() {\n-        use rt::sleeper_list::SleeperList;\n-        use rt::sched::Shutdown;\n-        use borrow;\n+        use sleeper_list::SleeperList;\n+        use super::{Shutdown, Scheduler, SchedHandle};\n+        use std::unstable::run_in_bare_thread;\n+        use std::rt::thread::Thread;\n+        use std::sync::deque::BufferPool;\n \n         do run_in_bare_thread {\n-\n             let sleepers = SleeperList::new();\n             let mut pool = BufferPool::new();\n             let (normal_worker, normal_stealer) = pool.deque();\n@@ -1057,17 +1085,18 @@ mod test {\n \n             // Our normal scheduler\n             let mut normal_sched = ~Scheduler::new(\n+                1,\n                 basic::event_loop(),\n                 normal_worker,\n                 queues.clone(),\n                 sleepers.clone());\n \n             let normal_handle = normal_sched.make_handle();\n-\n             let friend_handle = normal_sched.make_handle();\n \n             // Our special scheduler\n             let mut special_sched = ~Scheduler::new_special(\n+                1,\n                 basic::event_loop(),\n                 special_worker,\n                 queues.clone(),\n@@ -1086,175 +1115,168 @@ mod test {\n             //   3) task not homed, sched requeues\n             //   4) task not home, send home\n \n-            let task1 = ~do Task::new_root_homed(&mut special_sched.stack_pool, None,\n-                                                 Sched(t1_handle)) || {\n-                rtassert!(Task::on_appropriate_sched());\n+            // Grab both the scheduler and the task from TLS and check if the\n+            // task is executing on an appropriate scheduler.\n+            fn on_appropriate_sched() -> bool {\n+                use task::{TypeGreen, TypeSched, HomeSched};\n+                let task = GreenTask::convert(Local::take());\n+                let sched_id = task.sched.get_ref().sched_id();\n+                let run_any = task.sched.get_ref().run_anything;\n+                let ret = match task.task_type {\n+                    TypeGreen(Some(AnySched)) => {\n+                        run_any\n+                    }\n+                    TypeGreen(Some(HomeSched(SchedHandle {\n+                        sched_id: ref id,\n+                        ..\n+                    }))) => {\n+                        *id == sched_id\n+                    }\n+                    TypeGreen(None) => { fail!(\"task without home\"); }\n+                    TypeSched => { fail!(\"expected green task\"); }\n+                };\n+                task.put();\n+                ret\n+            }\n+\n+            let task1 = do GreenTask::new_homed(&mut special_sched.stack_pool,\n+                                                None, HomeSched(t1_handle)) {\n+                rtassert!(on_appropriate_sched());\n             };\n-            rtdebug!(\"task1 id: **{}**\", borrow::to_uint(task1));\n \n-            let task2 = ~do Task::new_root(&mut normal_sched.stack_pool, None) {\n-                rtassert!(Task::on_appropriate_sched());\n+            let task2 = do GreenTask::new(&mut normal_sched.stack_pool, None) {\n+                rtassert!(on_appropriate_sched());\n             };\n \n-            let task3 = ~do Task::new_root(&mut normal_sched.stack_pool, None) {\n-                rtassert!(Task::on_appropriate_sched());\n+            let task3 = do GreenTask::new(&mut normal_sched.stack_pool, None) {\n+                rtassert!(on_appropriate_sched());\n             };\n \n-            let task4 = ~do Task::new_root_homed(&mut special_sched.stack_pool, None,\n-                                                 Sched(t4_handle)) {\n-                rtassert!(Task::on_appropriate_sched());\n+            let task4 = do GreenTask::new_homed(&mut special_sched.stack_pool,\n+                                                None, HomeSched(t4_handle)) {\n+                rtassert!(on_appropriate_sched());\n             };\n-            rtdebug!(\"task4 id: **{}**\", borrow::to_uint(task4));\n \n             // Signal from the special task that we are done.\n             let (port, chan) = Chan::<()>::new();\n \n-            let normal_task = ~do Task::new_root(&mut normal_sched.stack_pool, None) {\n-                rtdebug!(\"*about to submit task2*\");\n-                Scheduler::run_task(task2);\n-                rtdebug!(\"*about to submit task4*\");\n-                Scheduler::run_task(task4);\n-                rtdebug!(\"*normal_task done*\");\n+            fn run(next: ~GreenTask) {\n+                let mut task = GreenTask::convert(Local::take());\n+                let sched = task.sched.take_unwrap();\n+                sched.run_task(task, next)\n+            }\n+\n+            let normal_task = do GreenTask::new(&mut normal_sched.stack_pool,\n+                                                None) {\n+                run(task2);\n+                run(task4);\n                 port.recv();\n                 let mut nh = normal_handle;\n                 nh.send(Shutdown);\n                 let mut sh = special_handle;\n                 sh.send(Shutdown);\n             };\n \n-            rtdebug!(\"normal task: {}\", borrow::to_uint(normal_task));\n \n-            let special_task = ~do Task::new_root(&mut special_sched.stack_pool, None) {\n-                rtdebug!(\"*about to submit task1*\");\n-                Scheduler::run_task(task1);\n-                rtdebug!(\"*about to submit task3*\");\n-                Scheduler::run_task(task3);\n-                rtdebug!(\"*done with special_task*\");\n+            let special_task = do GreenTask::new(&mut special_sched.stack_pool,\n+                                                 None) {\n+                run(task1);\n+                run(task3);\n                 chan.send(());\n             };\n \n-            rtdebug!(\"special task: {}\", borrow::to_uint(special_task));\n \n             let normal_sched = normal_sched;\n             let normal_thread = do Thread::start {\n                 normal_sched.bootstrap(normal_task);\n-                rtdebug!(\"finished with normal_thread\");\n             };\n \n             let special_sched = special_sched;\n             let special_thread = do Thread::start {\n                 special_sched.bootstrap(special_task);\n-                rtdebug!(\"finished with special_sched\");\n             };\n \n             normal_thread.join();\n             special_thread.join();\n         }\n     }\n \n-    #[test]\n-    fn test_stress_schedule_task_states() {\n-        if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        let n = stress_factor() * 120;\n-        for _ in range(0, n as int) {\n-            test_schedule_home_states();\n-        }\n-    }\n+    //#[test]\n+    //fn test_stress_schedule_task_states() {\n+    //    if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n+    //    let n = stress_factor() * 120;\n+    //    for _ in range(0, n as int) {\n+    //        test_schedule_home_states();\n+    //    }\n+    //}\n \n     #[test]\n     fn test_io_callback() {\n-        use io::timer;\n-\n-        // This is a regression test that when there are no schedulable tasks\n-        // in the work queue, but we are performing I/O, that once we do put\n-        // something in the work queue again the scheduler picks it up and doesn't\n-        // exit before emptying the work queue\n-        do run_in_uv_task {\n-            do spawntask {\n+        use std::io::timer;\n+\n+        let mut pool = SchedPool::new(PoolConfig {\n+            threads: 2,\n+            event_loop_factory: None,\n+        });\n+\n+        // This is a regression test that when there are no schedulable tasks in\n+        // the work queue, but we are performing I/O, that once we do put\n+        // something in the work queue again the scheduler picks it up and\n+        // doesn't exit before emptying the work queue\n+        do pool.spawn(TaskOpts::new()) {\n+            do spawn {\n                 timer::sleep(10);\n             }\n         }\n+\n+        pool.shutdown();\n     }\n \n     #[test]\n-    fn handle() {\n-        do run_in_bare_thread {\n-            let (port, chan) = Chan::new();\n-\n-            let thread_one = do Thread::start {\n-                let chan = chan;\n-                do run_in_newsched_task_core {\n-                    chan.send(());\n-                }\n-            };\n-\n-            let thread_two = do Thread::start {\n-                let port = port;\n-                do run_in_newsched_task_core {\n-                    port.recv();\n-                }\n-            };\n+    fn wakeup_across_scheds() {\n+        let (port1, chan1) = Chan::new();\n+        let (port2, chan2) = Chan::new();\n+\n+        let mut pool1 = pool();\n+        let mut pool2 = pool();\n+\n+        do pool1.spawn(TaskOpts::new()) {\n+            let id = sched_id();\n+            chan1.send(());\n+            port2.recv();\n+            assert_eq!(id, sched_id());\n+        }\n \n-            thread_two.join();\n-            thread_one.join();\n+        do pool2.spawn(TaskOpts::new()) {\n+            let id = sched_id();\n+            port1.recv();\n+            assert_eq!(id, sched_id());\n+            chan2.send(());\n         }\n+\n+        pool1.shutdown();\n+        pool2.shutdown();\n     }\n \n     // A regression test that the final message is always handled.\n     // Used to deadlock because Shutdown was never recvd.\n     #[test]\n     fn no_missed_messages() {\n-        use rt::sleeper_list::SleeperList;\n-        use rt::stack::StackPool;\n-        use rt::sched::{Shutdown, TaskFromFriend};\n-\n-        do run_in_bare_thread {\n-            stress_factor().times(|| {\n-                let sleepers = SleeperList::new();\n-                let mut pool = BufferPool::new();\n-                let (worker, stealer) = pool.deque();\n-\n-                let mut sched = ~Scheduler::new(\n-                    basic::event_loop(),\n-                    worker,\n-                    ~[stealer],\n-                    sleepers.clone());\n-\n-                let mut handle = sched.make_handle();\n-\n-                let sched = sched;\n-                let thread = do Thread::start {\n-                    let mut sched = sched;\n-                    let bootstrap_task =\n-                        ~Task::new_root(&mut sched.stack_pool,\n-                                        None,\n-                                        proc()());\n-                    sched.bootstrap(bootstrap_task);\n-                };\n-\n-                let mut stack_pool = StackPool::new();\n-                let task = ~Task::new_root(&mut stack_pool, None, proc()());\n-                handle.send(TaskFromFriend(task));\n+        let mut pool = pool();\n \n-                handle.send(Shutdown);\n-                drop(handle);\n+        let task = pool.task(TaskOpts::new(), proc()());\n+        pool.spawn_sched().send(TaskFromFriend(task));\n \n-                thread.join();\n-            })\n-        }\n+        pool.shutdown();\n     }\n \n     #[test]\n     fn multithreading() {\n-        use num::Times;\n-        use vec::OwnedVector;\n-        use container::Container;\n-\n-        do run_in_mt_newsched_task {\n+        do run {\n             let mut ports = ~[];\n             10.times(|| {\n                 let (port, chan) = Chan::new();\n-                do spawntask_later {\n+                do spawn {\n                     chan.send(());\n                 }\n                 ports.push(port);\n@@ -1268,7 +1290,7 @@ mod test {\n \n      #[test]\n     fn thread_ring() {\n-        do run_in_mt_newsched_task {\n+        do run {\n             let (end_port, end_chan) = Chan::new();\n \n             let n_tasks = 10;\n@@ -1281,14 +1303,14 @@ mod test {\n                 let (next_p, ch) = Chan::new();\n                 let imm_i = i;\n                 let imm_p = p;\n-                do spawntask_random {\n+                do spawn {\n                     roundtrip(imm_i, n_tasks, &imm_p, &ch);\n                 };\n                 p = next_p;\n                 i += 1;\n             }\n             let p = p;\n-            do spawntask_random {\n+            do spawn {\n                 roundtrip(1, n_tasks, &p, &ch1);\n             }\n \n@@ -1319,22 +1341,20 @@ mod test {\n \n     #[test]\n     fn start_closure_dtor() {\n-        use ops::Drop;\n-\n         // Regression test that the `start` task entrypoint can\n         // contain dtors that use task resources\n-        do run_in_newsched_task {\n+        do run {\n             struct S { field: () }\n \n             impl Drop for S {\n                 fn drop(&mut self) {\n-                    let _foo = @0;\n+                    let _foo = ~0;\n                 }\n             }\n \n             let s = S { field: () };\n \n-            do spawntask {\n+            do spawn {\n                 let _ss = &s;\n             }\n         }\n@@ -1344,52 +1364,120 @@ mod test {\n     #[ignore]\n     #[test]\n     fn dont_starve_1() {\n-        stress_factor().times(|| {\n-            do run_in_mt_newsched_task {\n-                let (port, chan) = Chan::new();\n-\n-                // This task should not be able to starve the sender;\n-                // The sender should get stolen to another thread.\n-                do spawntask {\n-                    while port.try_recv().is_none() { }\n-                }\n+        let mut pool = SchedPool::new(PoolConfig {\n+            threads: 2, // this must be > 1\n+            event_loop_factory: Some(basic::event_loop),\n+        });\n+        do pool.spawn(TaskOpts::new()) {\n+            let (port, chan) = Chan::new();\n \n-                chan.send(());\n+            // This task should not be able to starve the sender;\n+            // The sender should get stolen to another thread.\n+            do spawn {\n+                while port.try_recv().is_none() { }\n             }\n-        })\n+\n+            chan.send(());\n+        }\n+        pool.shutdown();\n     }\n \n     #[test]\n     fn dont_starve_2() {\n-        stress_factor().times(|| {\n-            do run_in_newsched_task {\n-                let (port, chan) = Chan::new();\n-                let (_port2, chan2) = Chan::new();\n+        do run {\n+            let (port, chan) = Chan::new();\n+            let (_port2, chan2) = Chan::new();\n \n-                // This task should not be able to starve the other task.\n-                // The sends should eventually yield.\n-                do spawntask {\n-                    while port.try_recv().is_none() {\n-                        chan2.send(());\n-                    }\n+            // This task should not be able to starve the other task.\n+            // The sends should eventually yield.\n+            do spawn {\n+                while port.try_recv().is_none() {\n+                    chan2.send(());\n                 }\n-\n-                chan.send(());\n             }\n-        })\n+\n+            chan.send(());\n+        }\n     }\n \n-    // Regression test for a logic bug that would cause single-threaded schedulers\n-    // to sleep forever after yielding and stealing another task.\n+    // Regression test for a logic bug that would cause single-threaded\n+    // schedulers to sleep forever after yielding and stealing another task.\n     #[test]\n     fn single_threaded_yield() {\n-        use task::{spawn, spawn_sched, SingleThreaded, deschedule};\n-        use num::Times;\n+        use std::task::deschedule;\n+        do run {\n+            5.times(deschedule);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_spawn_sched_blocking() {\n+        use std::unstable::mutex::Mutex;\n+\n+        // Testing that a task in one scheduler can block in foreign code\n+        // without affecting other schedulers\n+        for _ in range(0, 20) {\n+            let mut pool = pool();\n+            let (start_po, start_ch) = Chan::new();\n+            let (fin_po, fin_ch) = Chan::new();\n+\n+            let lock = unsafe { Mutex::new() };\n+            let lock2 = unsafe { lock.clone() };\n+\n+            let mut handle = pool.spawn_sched();\n+            handle.send(PinnedTask(pool.task(TaskOpts::new(), proc() {\n+                let mut lock = lock2;\n+                unsafe {\n+                    lock.lock();\n+\n+                    start_ch.send(());\n+                    lock.wait();   // block the scheduler thread\n+                    lock.signal(); // let them know we have the lock\n+                    lock.unlock();\n+                }\n+\n+                fin_ch.send(());\n+            })));\n+            drop(handle);\n+\n+            let mut handle = pool.spawn_sched();\n+            handle.send(TaskFromFriend(pool.task(TaskOpts::new(), proc() {\n+                // Wait until the other task has its lock\n+                start_po.recv();\n \n-        do spawn_sched(SingleThreaded) {\n-            5.times(|| { deschedule(); })\n+                fn pingpong(po: &Port<int>, ch: &Chan<int>) {\n+                    let mut val = 20;\n+                    while val > 0 {\n+                        val = po.recv();\n+                        ch.try_send(val - 1);\n+                    }\n+                }\n+\n+                let (setup_po, setup_ch) = Chan::new();\n+                let (parent_po, parent_ch) = Chan::new();\n+                do spawn {\n+                    let (child_po, child_ch) = Chan::new();\n+                    setup_ch.send(child_ch);\n+                    pingpong(&child_po, &parent_ch);\n+                };\n+\n+                let child_ch = setup_po.recv();\n+                child_ch.send(20);\n+                pingpong(&parent_po, &child_ch);\n+                unsafe {\n+                    let mut lock = lock;\n+                    lock.lock();\n+                    lock.signal();   // wakeup waiting scheduler\n+                    lock.wait();     // wait for them to grab the lock\n+                    lock.unlock();\n+                    lock.destroy();  // now we're guaranteed they have no locks\n+                }\n+            })));\n+            drop(handle);\n+\n+            fin_po.recv();\n+            pool.shutdown();\n         }\n-        do spawn { }\n-        do spawn { }\n+\n     }\n }", "previous_filename": "src/libstd/rt/sched.rs"}, {"sha": "4f904ee6e6dd9985e2687d51bc816292fee3d092", "filename": "src/libgreen/simple.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibgreen%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibgreen%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsimple.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A small module implementing a simple \"runtime\" used for bootstrapping a rust\n+//! scheduler pool and then interacting with it.\n+\n+use std::cast;\n+use std::rt::Runtime;\n+use std::rt::local::Local;\n+use std::rt::rtio;\n+use std::rt::task::{Task, BlockedTask};\n+use std::task::TaskOpts;\n+use std::unstable::sync::LittleLock;\n+\n+struct SimpleTask {\n+    lock: LittleLock,\n+    awoken: bool,\n+}\n+\n+impl Runtime for SimpleTask {\n+    // Implement the simple tasks of descheduling and rescheduling, but only in\n+    // a simple number of cases.\n+    fn deschedule(mut ~self, times: uint, mut cur_task: ~Task,\n+                  f: |BlockedTask| -> Result<(), BlockedTask>) {\n+        assert!(times == 1);\n+\n+        let me = &mut *self as *mut SimpleTask;\n+        let cur_dupe = &*cur_task as *Task;\n+        cur_task.put_runtime(self as ~Runtime);\n+        let task = BlockedTask::block(cur_task);\n+\n+        // See libnative/task.rs for what's going on here with the `awoken`\n+        // field and the while loop around wait()\n+        unsafe {\n+            let mut guard = (*me).lock.lock();\n+            (*me).awoken = false;\n+            match f(task) {\n+                Ok(()) => {\n+                    while !(*me).awoken {\n+                        guard.wait();\n+                    }\n+                }\n+                Err(task) => { cast::forget(task.wake()); }\n+            }\n+            drop(guard);\n+            cur_task = cast::transmute(cur_dupe);\n+        }\n+        Local::put(cur_task);\n+    }\n+    fn reawaken(mut ~self, mut to_wake: ~Task, _can_resched: bool) {\n+        let me = &mut *self as *mut SimpleTask;\n+        to_wake.put_runtime(self as ~Runtime);\n+        unsafe {\n+            cast::forget(to_wake);\n+            let _l = (*me).lock.lock();\n+            (*me).awoken = true;\n+            (*me).lock.signal();\n+        }\n+    }\n+\n+    // These functions are all unimplemented and fail as a result. This is on\n+    // purpose. A \"simple task\" is just that, a very simple task that can't\n+    // really do a whole lot. The only purpose of the task is to get us off our\n+    // feet and running.\n+    fn yield_now(~self, _cur_task: ~Task) { fail!() }\n+    fn maybe_yield(~self, _cur_task: ~Task) { fail!() }\n+    fn spawn_sibling(~self, _cur_task: ~Task, _opts: TaskOpts, _f: proc()) {\n+        fail!()\n+    }\n+    fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> { None }\n+    fn wrap(~self) -> ~Any { fail!() }\n+}\n+\n+pub fn task() -> ~Task {\n+    let mut task = ~Task::new();\n+    task.put_runtime(~SimpleTask {\n+        lock: LittleLock::new(),\n+        awoken: false,\n+    } as ~Runtime);\n+    return task;\n+}"}, {"sha": "5be260efdfaefe1453137d9ba95712eb39e6bef7", "filename": "src/libgreen/sleeper_list.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibgreen%2Fsleeper_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibgreen%2Fsleeper_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsleeper_list.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -11,10 +11,9 @@\n //! Maintains a shared list of sleeping schedulers. Schedulers\n //! use this to wake each other up.\n \n-use rt::sched::SchedHandle;\n-use rt::mpmc_bounded_queue::Queue;\n-use option::*;\n-use clone::Clone;\n+use std::sync::mpmc_bounded_queue::Queue;\n+\n+use sched::SchedHandle;\n \n pub struct SleeperList {\n     priv q: Queue<SchedHandle>,", "previous_filename": "src/libstd/rt/sleeper_list.rs"}, {"sha": "cf2a3d5f1414c8e808dcda21995af4cd3949689c", "filename": "src/libgreen/stack.rs", "status": "renamed", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibgreen%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibgreen%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fstack.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -8,11 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use container::Container;\n-use ptr::RawPtr;\n-use vec;\n-use ops::Drop;\n-use libc::{c_uint, uintptr_t};\n+use std::vec;\n+use std::libc::{c_uint, uintptr_t};\n \n pub struct StackSegment {\n     priv buf: ~[u8],", "previous_filename": "src/libstd/rt/stack.rs"}, {"sha": "eff80df2a118e7d7d42f5aaca68a5d0e28d3ad75", "filename": "src/libgreen/task.rs", "status": "added", "additions": 536, "deletions": 0, "changes": 536, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -0,0 +1,536 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The Green Task implementation\n+//!\n+//! This module contains the glue to the libstd runtime necessary to integrate\n+//! M:N scheduling. This GreenTask structure is hidden as a trait object in all\n+//! rust tasks and virtual calls are made in order to interface with it.\n+//!\n+//! Each green task contains a scheduler if it is currently running, and it also\n+//! contains the rust task itself in order to juggle around ownership of the\n+//! values.\n+\n+use std::cast;\n+use std::rt::Runtime;\n+use std::rt::rtio;\n+use std::rt::local::Local;\n+use std::rt::task::{Task, BlockedTask};\n+use std::task::TaskOpts;\n+use std::unstable::mutex::Mutex;\n+\n+use coroutine::Coroutine;\n+use sched::{Scheduler, SchedHandle, RunOnce};\n+use stack::StackPool;\n+\n+/// The necessary fields needed to keep track of a green task (as opposed to a\n+/// 1:1 task).\n+pub struct GreenTask {\n+    coroutine: Option<Coroutine>,\n+    handle: Option<SchedHandle>,\n+    sched: Option<~Scheduler>,\n+    task: Option<~Task>,\n+    task_type: TaskType,\n+    pool_id: uint,\n+\n+    // See the comments in the scheduler about why this is necessary\n+    nasty_deschedule_lock: Mutex,\n+}\n+\n+pub enum TaskType {\n+    TypeGreen(Option<Home>),\n+    TypeSched,\n+}\n+\n+pub enum Home {\n+    AnySched,\n+    HomeSched(SchedHandle),\n+}\n+\n+impl GreenTask {\n+    /// Creates a new green task which is not homed to any particular scheduler\n+    /// and will not have any contained Task structure.\n+    pub fn new(stack_pool: &mut StackPool,\n+               stack_size: Option<uint>,\n+               start: proc()) -> ~GreenTask {\n+        GreenTask::new_homed(stack_pool, stack_size, AnySched, start)\n+    }\n+\n+    /// Creates a new task (like `new`), but specifies the home for new task.\n+    pub fn new_homed(stack_pool: &mut StackPool,\n+                     stack_size: Option<uint>,\n+                     home: Home,\n+                     start: proc()) -> ~GreenTask {\n+        let mut ops = GreenTask::new_typed(None, TypeGreen(Some(home)));\n+        let start = GreenTask::build_start_wrapper(start, ops.as_uint());\n+        ops.coroutine = Some(Coroutine::new(stack_pool, stack_size, start));\n+        return ops;\n+    }\n+\n+    /// Creates a new green task with the specified coroutine and type, this is\n+    /// useful when creating scheduler tasks.\n+    pub fn new_typed(coroutine: Option<Coroutine>,\n+                     task_type: TaskType) -> ~GreenTask {\n+        ~GreenTask {\n+            pool_id: 0,\n+            coroutine: coroutine,\n+            task_type: task_type,\n+            sched: None,\n+            handle: None,\n+            nasty_deschedule_lock: unsafe { Mutex::new() },\n+            task: Some(~Task::new()),\n+        }\n+    }\n+\n+    /// Creates a new green task with the given configuration options for the\n+    /// contained Task object. The given stack pool is also used to allocate a\n+    /// new stack for this task.\n+    pub fn configure(pool: &mut StackPool,\n+                     opts: TaskOpts,\n+                     f: proc()) -> ~GreenTask {\n+        let TaskOpts {\n+            watched: _watched,\n+            notify_chan, name, stack_size\n+        } = opts;\n+\n+        let mut green = GreenTask::new(pool, stack_size, f);\n+        {\n+            let task = green.task.get_mut_ref();\n+            task.name = name;\n+            match notify_chan {\n+                Some(chan) => {\n+                    let on_exit = proc(task_result) { chan.send(task_result) };\n+                    task.death.on_exit = Some(on_exit);\n+                }\n+                None => {}\n+            }\n+        }\n+        return green;\n+    }\n+\n+    /// Just like the `maybe_take_runtime` function, this function should *not*\n+    /// exist. Usage of this function is _strongly_ discouraged. This is an\n+    /// absolute last resort necessary for converting a libstd task to a green\n+    /// task.\n+    ///\n+    /// This function will assert that the task is indeed a green task before\n+    /// returning (and will kill the entire process if this is wrong).\n+    pub fn convert(mut task: ~Task) -> ~GreenTask {\n+        match task.maybe_take_runtime::<GreenTask>() {\n+            Some(mut green) => {\n+                green.put_task(task);\n+                green\n+            }\n+            None => rtabort!(\"not a green task any more?\"),\n+        }\n+    }\n+\n+    /// Builds a function which is the actual starting execution point for a\n+    /// rust task. This function is the glue necessary to execute the libstd\n+    /// task and then clean up the green thread after it exits.\n+    ///\n+    /// The second argument to this function is actually a transmuted copy of\n+    /// the `GreenTask` pointer. Context switches in the scheduler silently\n+    /// transfer ownership of the `GreenTask` to the other end of the context\n+    /// switch, so because this is the first code that is running in this task,\n+    /// it must first re-acquire ownership of the green task.\n+    pub fn build_start_wrapper(start: proc(), ops: uint) -> proc() {\n+        proc() {\n+            // First code after swap to this new context. Run our\n+            // cleanup job after we have re-acquired ownership of the green\n+            // task.\n+            let mut task: ~GreenTask = unsafe { GreenTask::from_uint(ops) };\n+            task.sched.get_mut_ref().run_cleanup_job();\n+\n+            // Convert our green task to a libstd task and then execute the code\n+            // requeted. This is the \"try/catch\" block for this green task and\n+            // is the wrapper for *all* code run in the task.\n+            let mut start = Some(start);\n+            let task = task.swap().run(|| start.take_unwrap()());\n+\n+            // Once the function has exited, it's time to run the termination\n+            // routine. This means we need to context switch one more time but\n+            // clean ourselves up on the other end. Since we have no way of\n+            // preserving a handle to the GreenTask down to this point, this\n+            // unfortunately must call `GreenTask::convert`. In order to avoid\n+            // this we could add a `terminate` function to the `Runtime` trait\n+            // in libstd, but that seems less appropriate since the coversion\n+            // method exists.\n+            GreenTask::convert(task).terminate();\n+        }\n+    }\n+\n+    pub fn give_home(&mut self, new_home: Home) {\n+        match self.task_type {\n+            TypeGreen(ref mut home) => { *home = Some(new_home); }\n+            TypeSched => rtabort!(\"type error: used SchedTask as GreenTask\"),\n+        }\n+    }\n+\n+    pub fn take_unwrap_home(&mut self) -> Home {\n+        match self.task_type {\n+            TypeGreen(ref mut home) => home.take_unwrap(),\n+            TypeSched => rtabort!(\"type error: used SchedTask as GreenTask\"),\n+        }\n+    }\n+\n+    // New utility functions for homes.\n+\n+    pub fn is_home_no_tls(&self, sched: &Scheduler) -> bool {\n+        match self.task_type {\n+            TypeGreen(Some(AnySched)) => { false }\n+            TypeGreen(Some(HomeSched(SchedHandle { sched_id: ref id, .. }))) => {\n+                *id == sched.sched_id()\n+            }\n+            TypeGreen(None) => { rtabort!(\"task without home\"); }\n+            TypeSched => {\n+                // Awe yea\n+                rtabort!(\"type error: expected: TypeGreen, found: TaskSched\");\n+            }\n+        }\n+    }\n+\n+    pub fn homed(&self) -> bool {\n+        match self.task_type {\n+            TypeGreen(Some(AnySched)) => { false }\n+            TypeGreen(Some(HomeSched(SchedHandle { .. }))) => { true }\n+            TypeGreen(None) => {\n+                rtabort!(\"task without home\");\n+            }\n+            TypeSched => {\n+                rtabort!(\"type error: expected: TypeGreen, found: TaskSched\");\n+            }\n+        }\n+    }\n+\n+    pub fn is_sched(&self) -> bool {\n+        match self.task_type {\n+            TypeGreen(..) => false, TypeSched => true,\n+        }\n+    }\n+\n+    // Unsafe functions for transferring ownership of this GreenTask across\n+    // context switches\n+\n+    pub fn as_uint(&self) -> uint {\n+        unsafe { cast::transmute(self) }\n+    }\n+\n+    pub unsafe fn from_uint(val: uint) -> ~GreenTask { cast::transmute(val) }\n+\n+    // Runtime glue functions and helpers\n+\n+    pub fn put_with_sched(mut ~self, sched: ~Scheduler) {\n+        assert!(self.sched.is_none());\n+        self.sched = Some(sched);\n+        self.put();\n+    }\n+\n+    pub fn put_task(&mut self, task: ~Task) {\n+        assert!(self.task.is_none());\n+        self.task = Some(task);\n+    }\n+\n+    pub fn swap(mut ~self) -> ~Task {\n+        let mut task = self.task.take_unwrap();\n+        task.put_runtime(self as ~Runtime);\n+        return task;\n+    }\n+\n+    pub fn put(~self) {\n+        assert!(self.sched.is_some());\n+        Local::put(self.swap());\n+    }\n+\n+    fn terminate(mut ~self) {\n+        let sched = self.sched.take_unwrap();\n+        sched.terminate_current_task(self);\n+    }\n+\n+    // This function is used to remotely wakeup this green task back on to its\n+    // original pool of schedulers. In order to do so, each tasks arranges a\n+    // SchedHandle upon descheduling to be available for sending itself back to\n+    // the original pool.\n+    //\n+    // Note that there is an interesting transfer of ownership going on here. We\n+    // must relinquish ownership of the green task, but then also send the task\n+    // over the handle back to the original scheduler. In order to safely do\n+    // this, we leverage the already-present \"nasty descheduling lock\". The\n+    // reason for doing this is that each task will bounce on this lock after\n+    // resuming after a context switch. By holding the lock over the enqueueing\n+    // of the task, we're guaranteed that the SchedHandle's memory will be valid\n+    // for this entire function.\n+    //\n+    // An alternative would include having incredibly cheaply cloneable handles,\n+    // but right now a SchedHandle is something like 6 allocations, so it is\n+    // *not* a cheap operation to clone a handle. Until the day comes that we\n+    // need to optimize this, a lock should do just fine (it's completely\n+    // uncontended except for when the task is rescheduled).\n+    fn reawaken_remotely(mut ~self) {\n+        unsafe {\n+            let mtx = &mut self.nasty_deschedule_lock as *mut Mutex;\n+            let handle = self.handle.get_mut_ref() as *mut SchedHandle;\n+            (*mtx).lock();\n+            (*handle).send(RunOnce(self));\n+            (*mtx).unlock();\n+        }\n+    }\n+}\n+\n+impl Runtime for GreenTask {\n+    fn yield_now(mut ~self, cur_task: ~Task) {\n+        self.put_task(cur_task);\n+        let sched = self.sched.take_unwrap();\n+        sched.yield_now(self);\n+    }\n+\n+    fn maybe_yield(mut ~self, cur_task: ~Task) {\n+        self.put_task(cur_task);\n+        let sched = self.sched.take_unwrap();\n+        sched.maybe_yield(self);\n+    }\n+\n+    fn deschedule(mut ~self, times: uint, cur_task: ~Task,\n+                  f: |BlockedTask| -> Result<(), BlockedTask>) {\n+        self.put_task(cur_task);\n+        let mut sched = self.sched.take_unwrap();\n+\n+        // In order for this task to be reawoken in all possible contexts, we\n+        // may need a handle back in to the current scheduler. When we're woken\n+        // up in anything other than the local scheduler pool, this handle is\n+        // used to send this task back into the scheduler pool.\n+        if self.handle.is_none() {\n+            self.handle = Some(sched.make_handle());\n+            self.pool_id = sched.pool_id;\n+        }\n+\n+        // This code is pretty standard, except for the usage of\n+        // `GreenTask::convert`. Right now if we use `reawaken` directly it will\n+        // expect for there to be a task in local TLS, but that is not true for\n+        // this deschedule block (because the scheduler must retain ownership of\n+        // the task while the cleanup job is running). In order to get around\n+        // this for now, we invoke the scheduler directly with the converted\n+        // Task => GreenTask structure.\n+        if times == 1 {\n+            sched.deschedule_running_task_and_then(self, |sched, task| {\n+                match f(task) {\n+                    Ok(()) => {}\n+                    Err(t) => {\n+                        t.wake().map(|t| {\n+                            sched.enqueue_task(GreenTask::convert(t))\n+                        });\n+                    }\n+                }\n+            });\n+        } else {\n+            sched.deschedule_running_task_and_then(self, |sched, task| {\n+                for task in task.make_selectable(times) {\n+                    match f(task) {\n+                        Ok(()) => {},\n+                        Err(task) => {\n+                            task.wake().map(|t| {\n+                                sched.enqueue_task(GreenTask::convert(t))\n+                            });\n+                            break\n+                        }\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    fn reawaken(mut ~self, to_wake: ~Task, can_resched: bool) {\n+        self.put_task(to_wake);\n+        assert!(self.sched.is_none());\n+\n+        // Waking up a green thread is a bit of a tricky situation. We have no\n+        // guarantee about where the current task is running. The options we\n+        // have for where this current task is running are:\n+        //\n+        //  1. Our original scheduler pool\n+        //  2. Some other scheduler pool\n+        //  3. Something that isn't a scheduler pool\n+        //\n+        // In order to figure out what case we're in, this is the reason that\n+        // the `maybe_take_runtime` function exists. Using this function we can\n+        // dynamically check to see which of these cases is the current\n+        // situation and then dispatch accordingly.\n+        //\n+        // In case 1, we just use the local scheduler to resume ourselves\n+        // immediately (if a rescheduling is possible).\n+        //\n+        // In case 2 and 3, we need to remotely reawaken ourself in order to be\n+        // transplanted back to the correct scheduler pool.\n+        let mut running_task: ~Task = Local::take();\n+        match running_task.maybe_take_runtime::<GreenTask>() {\n+            Some(mut running_green_task) => {\n+                running_green_task.put_task(running_task);\n+                let mut sched = running_green_task.sched.take_unwrap();\n+\n+                if sched.pool_id == self.pool_id {\n+                    if can_resched {\n+                        sched.run_task(running_green_task, self);\n+                    } else {\n+                        sched.enqueue_task(self);\n+                        running_green_task.put_with_sched(sched);\n+                    }\n+                } else {\n+                    self.reawaken_remotely();\n+\n+                    // put that thing back where it came from!\n+                    running_green_task.put_with_sched(sched);\n+                }\n+            }\n+            None => {\n+                self.reawaken_remotely();\n+                Local::put(running_task);\n+            }\n+        }\n+    }\n+\n+    fn spawn_sibling(mut ~self, cur_task: ~Task, opts: TaskOpts, f: proc()) {\n+        self.put_task(cur_task);\n+\n+        // Spawns a task into the current scheduler. We allocate the new task's\n+        // stack from the scheduler's stack pool, and then configure it\n+        // accordingly to `opts`. Afterwards we bootstrap it immediately by\n+        // switching to it.\n+        //\n+        // Upon returning, our task is back in TLS and we're good to return.\n+        let mut sched = self.sched.take_unwrap();\n+        let sibling = GreenTask::configure(&mut sched.stack_pool, opts, f);\n+        sched.run_task(self, sibling)\n+    }\n+\n+    // Local I/O is provided by the scheduler's event loop\n+    fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> {\n+        match self.sched.get_mut_ref().event_loop.io() {\n+            Some(io) => Some(rtio::LocalIo::new(io)),\n+            None => None,\n+        }\n+    }\n+\n+    fn wrap(~self) -> ~Any { self as ~Any }\n+}\n+\n+impl Drop for GreenTask {\n+    fn drop(&mut self) {\n+        unsafe { self.nasty_deschedule_lock.destroy(); }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::rt::Runtime;\n+    use std::rt::local::Local;\n+    use std::rt::task::Task;\n+    use std::task;\n+    use std::task::TaskOpts;\n+\n+    use super::super::{PoolConfig, SchedPool};\n+    use super::GreenTask;\n+\n+    fn spawn_opts(opts: TaskOpts, f: proc()) {\n+        let mut pool = SchedPool::new(PoolConfig {\n+            threads: 1,\n+            event_loop_factory: None,\n+        });\n+        pool.spawn(opts, f);\n+        pool.shutdown();\n+    }\n+\n+    #[test]\n+    fn smoke() {\n+        let (p, c) = Chan::new();\n+        do spawn_opts(TaskOpts::new()) {\n+            c.send(());\n+        }\n+        p.recv();\n+    }\n+\n+    #[test]\n+    fn smoke_fail() {\n+        let (p, c) = Chan::<()>::new();\n+        do spawn_opts(TaskOpts::new()) {\n+            let _c = c;\n+            fail!()\n+        }\n+        assert_eq!(p.recv_opt(), None);\n+    }\n+\n+    #[test]\n+    fn smoke_opts() {\n+        let mut opts = TaskOpts::new();\n+        opts.name = Some(SendStrStatic(\"test\"));\n+        opts.stack_size = Some(20 * 4096);\n+        let (p, c) = Chan::new();\n+        opts.notify_chan = Some(c);\n+        spawn_opts(opts, proc() {});\n+        assert!(p.recv().is_ok());\n+    }\n+\n+    #[test]\n+    fn smoke_opts_fail() {\n+        let mut opts = TaskOpts::new();\n+        let (p, c) = Chan::new();\n+        opts.notify_chan = Some(c);\n+        spawn_opts(opts, proc() { fail!() });\n+        assert!(p.recv().is_err());\n+    }\n+\n+    #[test]\n+    fn yield_test() {\n+        let (p, c) = Chan::new();\n+        do spawn_opts(TaskOpts::new()) {\n+            10.times(task::deschedule);\n+            c.send(());\n+        }\n+        p.recv();\n+    }\n+\n+    #[test]\n+    fn spawn_children() {\n+        let (p, c) = Chan::new();\n+        do spawn_opts(TaskOpts::new()) {\n+            let (p, c2) = Chan::new();\n+            do spawn {\n+                let (p, c3) = Chan::new();\n+                do spawn {\n+                    c3.send(());\n+                }\n+                p.recv();\n+                c2.send(());\n+            }\n+            p.recv();\n+            c.send(());\n+        }\n+        p.recv();\n+    }\n+\n+    #[test]\n+    fn spawn_inherits() {\n+        let (p, c) = Chan::new();\n+        do spawn_opts(TaskOpts::new()) {\n+            let c = c;\n+            do spawn {\n+                let mut task: ~Task = Local::take();\n+                match task.maybe_take_runtime::<GreenTask>() {\n+                    Some(ops) => {\n+                        task.put_runtime(ops as ~Runtime);\n+                    }\n+                    None => fail!(),\n+                }\n+                Local::put(task);\n+                c.send(());\n+            }\n+        }\n+        p.recv();\n+    }\n+}"}, {"sha": "c1a378c7e3cc1748b308bf16445fcd09d195e265", "filename": "src/libnative/io/file.rs", "status": "renamed", "additions": 24, "deletions": 32, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibnative%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibnative%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -10,28 +10,21 @@\n \n //! Blocking posix-based file I/O\n \n-#[allow(non_camel_case_types)];\n-\n-use c_str::CString;\n-use io::IoError;\n-use io;\n-use libc::c_int;\n-use libc;\n-use ops::Drop;\n-use option::{Some, None, Option};\n-use os;\n-use path::{Path, GenericPath};\n-use ptr::RawPtr;\n-use result::{Result, Ok, Err};\n-use rt::rtio;\n+use std::c_str::CString;\n+use std::io::IoError;\n+use std::io;\n+use std::libc::c_int;\n+use std::libc;\n+use std::os;\n+use std::rt::rtio;\n+use std::unstable::intrinsics;\n+use std::vec;\n+\n use super::IoResult;\n-use unstable::intrinsics;\n-use vec::ImmutableVector;\n-use vec;\n \n-#[cfg(windows)] use os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n-#[cfg(windows)] use ptr;\n-#[cfg(windows)] use str;\n+#[cfg(windows)] use std::os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n+#[cfg(windows)] use std::ptr;\n+#[cfg(windows)] use std::str;\n \n fn keep_going(data: &[u8], f: |*u8, uint| -> i64) -> i64 {\n     #[cfg(windows)] static eintr: int = 0; // doesn't matter\n@@ -490,8 +483,8 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n     unsafe {\n         #[cfg(not(windows))]\n         unsafe fn get_list(p: &CString) -> IoResult<~[Path]> {\n-            use libc::{dirent_t};\n-            use libc::{opendir, readdir, closedir};\n+            use std::libc::{dirent_t};\n+            use std::libc::{opendir, readdir, closedir};\n             extern {\n                 fn rust_list_dir_val(ptr: *dirent_t) -> *libc::c_char;\n             }\n@@ -517,14 +510,14 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n \n         #[cfg(windows)]\n         unsafe fn get_list(p: &CString) -> IoResult<~[Path]> {\n-            use libc::consts::os::extra::INVALID_HANDLE_VALUE;\n-            use libc::{wcslen, free};\n-            use libc::funcs::extra::kernel32::{\n+            use std::libc::consts::os::extra::INVALID_HANDLE_VALUE;\n+            use std::libc::{wcslen, free};\n+            use std::libc::funcs::extra::kernel32::{\n                 FindFirstFileW,\n                 FindNextFileW,\n                 FindClose,\n             };\n-            use libc::types::os::arch::extra::HANDLE;\n+            use std::libc::types::os::arch::extra::HANDLE;\n             use os::win32::{\n                 as_utf16_p\n             };\n@@ -906,12 +899,11 @@ pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n \n #[cfg(test)]\n mod tests {\n-    use io::native::file::{CFile, FileDesc};\n-    use io;\n-    use libc;\n-    use os;\n-    use result::Ok;\n-    use rt::rtio::RtioFileStream;\n+    use super::{CFile, FileDesc};\n+    use std::io;\n+    use std::libc;\n+    use std::os;\n+    use std::rt::rtio::RtioFileStream;\n \n     #[ignore(cfg(target_os = \"freebsd\"))] // hmm, maybe pipes have a tiny buffer\n     #[test]", "previous_filename": "src/libstd/io/native/file.rs"}, {"sha": "32056215e7c97935c087ec7a1eb101ed9c38221a", "filename": "src/libnative/io/mod.rs", "status": "renamed", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -21,24 +21,21 @@\n //! play. The only dependencies of these modules are the normal system libraries\n //! that you would find on the respective platform.\n \n-use c_str::CString;\n-use comm::SharedChan;\n-use libc::c_int;\n-use libc;\n-use option::{Option, None, Some};\n-use os;\n-use path::Path;\n-use result::{Result, Ok, Err};\n-use rt::rtio;\n-use rt::rtio::{RtioTcpStream, RtioTcpListener, RtioUdpSocket, RtioUnixListener,\n-               RtioPipe, RtioFileStream, RtioProcess, RtioSignal, RtioTTY,\n-               CloseBehavior, RtioTimer};\n-use io;\n-use io::IoError;\n-use io::net::ip::SocketAddr;\n-use io::process::ProcessConfig;\n-use io::signal::Signum;\n-use ai = io::net::addrinfo;\n+use std::c_str::CString;\n+use std::comm::SharedChan;\n+use std::libc::c_int;\n+use std::libc;\n+use std::os;\n+use std::rt::rtio;\n+use std::rt::rtio::{RtioTcpStream, RtioTcpListener, RtioUdpSocket,\n+                    RtioUnixListener, RtioPipe, RtioFileStream, RtioProcess,\n+                    RtioSignal, RtioTTY, CloseBehavior, RtioTimer};\n+use std::io;\n+use std::io::IoError;\n+use std::io::net::ip::SocketAddr;\n+use std::io::process::ProcessConfig;\n+use std::io::signal::Signum;\n+use ai = std::io::net::addrinfo;\n \n // Local re-exports\n pub use self::file::FileDesc;\n@@ -223,6 +220,3 @@ impl rtio::IoFactory for IoFactory {\n         Err(unimpl())\n     }\n }\n-\n-pub static mut NATIVE_IO_FACTORY: IoFactory = IoFactory;\n-", "previous_filename": "src/libstd/io/native/mod.rs"}, {"sha": "64ce9d7e3482d395af15d8116ba79e7c927590bc", "filename": "src/libnative/io/process.rs", "status": "renamed", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -8,18 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use io;\n-use libc::{pid_t, c_void, c_int};\n-use libc;\n-use os;\n-use prelude::*;\n-use ptr;\n-use rt::rtio;\n-use super::file;\n-#[cfg(windows)]\n-use cast;\n+use std::io;\n+use std::libc::{pid_t, c_void, c_int};\n+use std::libc;\n+use std::os;\n+use std::ptr;\n+use std::rt::rtio;\n+use p = std::io::process;\n \n-use p = io::process;\n+#[cfg(windows)] use std::cast;\n+\n+use super::file;\n \n /**\n  * A value representing a child process.\n@@ -179,22 +178,22 @@ fn spawn_process_os(prog: &str, args: &[~str],\n                     env: Option<~[(~str, ~str)]>,\n                     dir: Option<&Path>,\n                     in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n-    use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n-    use libc::consts::os::extra::{\n+    use std::libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n+    use std::libc::consts::os::extra::{\n         TRUE, FALSE,\n         STARTF_USESTDHANDLES,\n         INVALID_HANDLE_VALUE,\n         DUPLICATE_SAME_ACCESS\n     };\n-    use libc::funcs::extra::kernel32::{\n+    use std::libc::funcs::extra::kernel32::{\n         GetCurrentProcess,\n         DuplicateHandle,\n         CloseHandle,\n         CreateProcessA\n     };\n-    use libc::funcs::extra::msvcrt::get_osfhandle;\n+    use std::libc::funcs::extra::msvcrt::get_osfhandle;\n \n-    use mem;\n+    use std::mem;\n \n     unsafe {\n \n@@ -256,10 +255,10 @@ fn spawn_process_os(prog: &str, args: &[~str],\n             fail!(\"failure in CreateProcess: {}\", *msg);\n         }\n \n-        // We close the thread handle because we don't care about keeping the\n+        // We close the thread handle because std::we don't care about keeping the\n         // thread id valid, and we aren't keeping the thread handle around to be\n         // able to close it later. We don't close the process handle however\n-        // because we want the process id to stay valid at least until the\n+        // because std::we want the process id to stay valid at least until the\n         // calling code closes the process handle.\n         CloseHandle(pi.hThread);\n \n@@ -362,8 +361,8 @@ fn spawn_process_os(prog: &str, args: &[~str],\n                     env: Option<~[(~str, ~str)]>,\n                     dir: Option<&Path>,\n                     in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n-    use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n-    use libc::funcs::bsd44::getdtablesize;\n+    use std::libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n+    use std::libc::funcs::bsd44::getdtablesize;\n \n     mod rustrt {\n         extern {\n@@ -433,7 +432,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n \n #[cfg(unix)]\n fn with_argv<T>(prog: &str, args: &[~str], cb: |**libc::c_char| -> T) -> T {\n-    use vec;\n+    use std::vec;\n \n     // We can't directly convert `str`s into `*char`s, as someone needs to hold\n     // a reference to the intermediary byte buffers. So first build an array to\n@@ -459,7 +458,7 @@ fn with_argv<T>(prog: &str, args: &[~str], cb: |**libc::c_char| -> T) -> T {\n \n #[cfg(unix)]\n fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: |*c_void| -> T) -> T {\n-    use vec;\n+    use std::vec;\n \n     // On posixy systems we can pass a char** for envp, which is a\n     // null-terminated array of \"k=v\\n\" strings. Like `with_argv`, we have to\n@@ -540,16 +539,16 @@ fn waitpid(pid: pid_t) -> int {\n \n     #[cfg(windows)]\n     fn waitpid_os(pid: pid_t) -> int {\n-        use libc::types::os::arch::extra::DWORD;\n-        use libc::consts::os::extra::{\n+        use std::libc::types::os::arch::extra::DWORD;\n+        use std::libc::consts::os::extra::{\n             SYNCHRONIZE,\n             PROCESS_QUERY_INFORMATION,\n             FALSE,\n             STILL_ACTIVE,\n             INFINITE,\n             WAIT_FAILED\n         };\n-        use libc::funcs::extra::kernel32::{\n+        use std::libc::funcs::extra::kernel32::{\n             OpenProcess,\n             GetExitCodeProcess,\n             CloseHandle,\n@@ -585,7 +584,7 @@ fn waitpid(pid: pid_t) -> int {\n \n     #[cfg(unix)]\n     fn waitpid_os(pid: pid_t) -> int {\n-        use libc::funcs::posix01::wait::*;\n+        use std::libc::funcs::posix01::wait;\n \n         #[cfg(target_os = \"linux\")]\n         #[cfg(target_os = \"android\")]\n@@ -612,7 +611,7 @@ fn waitpid(pid: pid_t) -> int {\n         }\n \n         let mut status = 0 as c_int;\n-        if unsafe { waitpid(pid, &mut status, 0) } == -1 {\n+        if unsafe { wait::waitpid(pid, &mut status, 0) } == -1 {\n             fail!(\"failure in waitpid: {}\", os::last_os_error());\n         }\n ", "previous_filename": "src/libstd/io/native/process.rs"}, {"sha": "e0666592651490addd7335032ce4e7f919896b4d", "filename": "src/libnative/lib.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The native runtime crate\n+//!\n+//! This crate contains an implementation of 1:1 scheduling for a \"native\"\n+//! runtime. In addition, all I/O provided by this crate is the thread blocking\n+//! version of I/O.\n+\n+#[pkgid = \"native#0.9-pre\"];\n+#[crate_id = \"native#0.9-pre\"];\n+#[license = \"MIT/ASL2\"];\n+#[crate_type = \"rlib\"];\n+#[crate_type = \"dylib\"];\n+\n+// Allow check-stage0-native for now\n+#[cfg(stage0, test)] extern mod green;\n+\n+// NB this crate explicitly does *not* allow glob imports, please seriously\n+//    consider whether they're needed before adding that feature here (the\n+//    answer is that you don't need them)\n+\n+use std::os;\n+use std::rt::local::Local;\n+use std::rt::task::Task;\n+use std::rt;\n+\n+pub mod io;\n+pub mod task;\n+\n+\n+// XXX: this should not exist here\n+#[cfg(stage0)]\n+#[lang = \"start\"]\n+pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {\n+    use std::cast;\n+    use std::task;\n+\n+    do start(argc, argv) {\n+        // Instead of invoking main directly on this thread, invoke it on\n+        // another spawned thread that we are guaranteed to know the size of the\n+        // stack of. Currently, we do not have a method of figuring out the size\n+        // of the main thread's stack, so for stack overflow detection to work\n+        // we must spawn the task in a subtask which we know the stack size of.\n+        let main: extern \"Rust\" fn() = unsafe { cast::transmute(main) };\n+        let mut task = task::task();\n+        task.name(\"<main>\");\n+        match do task.try { main() } {\n+            Ok(()) => { os::set_exit_status(0); }\n+            Err(..) => { os::set_exit_status(rt::DEFAULT_ERROR_CODE); }\n+        }\n+    }\n+}\n+\n+/// Executes the given procedure after initializing the runtime with the given\n+/// argc/argv.\n+///\n+/// This procedure is guaranteed to run on the thread calling this function, but\n+/// the stack bounds for this rust task will *not* be set. Care must be taken\n+/// for this function to not overflow its stack.\n+///\n+/// This function will only return once *all* native threads in the system have\n+/// exited.\n+pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n+    rt::init(argc, argv);\n+    let mut exit_code = None;\n+    let mut main = Some(main);\n+    task::new().run(|| {\n+        exit_code = Some(run(main.take_unwrap()));\n+    });\n+    unsafe { rt::cleanup(); }\n+    return exit_code.unwrap();\n+}\n+\n+/// Executes a procedure on the current thread in a Rust task context.\n+///\n+/// This function has all of the same details as `start` except for a different\n+/// number of arguments.\n+pub fn run(main: proc()) -> int {\n+    // Run the main procedure and then wait for everything to finish\n+    main();\n+    unsafe {\n+        let mut task = Local::borrow(None::<Task>);\n+        task.get().wait_for_other_tasks();\n+    }\n+    os::get_exit_status()\n+}"}, {"sha": "12e361d8041c86fd599bcfdf3b9609eb174e9907", "filename": "src/libnative/task.rs", "status": "added", "additions": 330, "deletions": 0, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -0,0 +1,330 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Tasks implemented on top of OS threads\n+//!\n+//! This module contains the implementation of the 1:1 threading module required\n+//! by rust tasks. This implements the necessary API traits laid out by std::rt\n+//! in order to spawn new tasks and deschedule the current task.\n+\n+use std::cast;\n+use std::rt::env;\n+use std::rt::local::Local;\n+use std::rt::rtio;\n+use std::rt::task::{Task, BlockedTask};\n+use std::rt::thread::Thread;\n+use std::rt;\n+use std::task::TaskOpts;\n+use std::unstable::mutex::Mutex;\n+use std::unstable::stack;\n+\n+use io;\n+use task;\n+\n+/// Creates a new Task which is ready to execute as a 1:1 task.\n+pub fn new() -> ~Task {\n+    let mut task = ~Task::new();\n+    task.put_runtime(~Ops {\n+        lock: unsafe { Mutex::new() },\n+        awoken: false,\n+    } as ~rt::Runtime);\n+    return task;\n+}\n+\n+/// Spawns a function with the default configuration\n+pub fn spawn(f: proc()) {\n+    spawn_opts(TaskOpts::new(), f)\n+}\n+\n+/// Spawns a new task given the configuration options and a procedure to run\n+/// inside the task.\n+pub fn spawn_opts(opts: TaskOpts, f: proc()) {\n+    let TaskOpts {\n+        watched: _watched,\n+        notify_chan, name, stack_size\n+    } = opts;\n+\n+    let mut task = new();\n+    task.name = name;\n+    match notify_chan {\n+        Some(chan) => {\n+            let on_exit = proc(task_result) { chan.send(task_result) };\n+            task.death.on_exit = Some(on_exit);\n+        }\n+        None => {}\n+    }\n+\n+    let stack = stack_size.unwrap_or(env::min_stack());\n+    let task = task;\n+\n+    // Spawning a new OS thread guarantees that __morestack will never get\n+    // triggered, but we must manually set up the actual stack bounds once this\n+    // function starts executing. This raises the lower limit by a bit because\n+    // by the time that this function is executing we've already consumed at\n+    // least a little bit of stack (we don't know the exact byte address at\n+    // which our stack started).\n+    Thread::spawn_stack(stack, proc() {\n+        let something_around_the_top_of_the_stack = 1;\n+        let addr = &something_around_the_top_of_the_stack as *int;\n+        unsafe {\n+            let my_stack = addr as uint;\n+            stack::record_stack_bounds(my_stack - stack + 1024, my_stack);\n+        }\n+\n+        let mut f = Some(f);\n+        task.run(|| { f.take_unwrap()() });\n+    })\n+}\n+\n+// This structure is the glue between channels and the 1:1 scheduling mode. This\n+// structure is allocated once per task.\n+struct Ops {\n+    lock: Mutex,  // native synchronization\n+    awoken: bool, // used to prevent spurious wakeups\n+}\n+\n+impl rt::Runtime for Ops {\n+    fn yield_now(~self, mut cur_task: ~Task) {\n+        // put the task back in TLS and then invoke the OS thread yield\n+        cur_task.put_runtime(self as ~rt::Runtime);\n+        Local::put(cur_task);\n+        Thread::yield_now();\n+    }\n+\n+    fn maybe_yield(~self, mut cur_task: ~Task) {\n+        // just put the task back in TLS, on OS threads we never need to\n+        // opportunistically yield b/c the OS will do that for us (preemption)\n+        cur_task.put_runtime(self as ~rt::Runtime);\n+        Local::put(cur_task);\n+    }\n+\n+    fn wrap(~self) -> ~Any {\n+        self as ~Any\n+    }\n+\n+    // This function gets a little interesting. There are a few safety and\n+    // ownership violations going on here, but this is all done in the name of\n+    // shared state. Additionally, all of the violations are protected with a\n+    // mutex, so in theory there are no races.\n+    //\n+    // The first thing we need to do is to get a pointer to the task's internal\n+    // mutex. This address will not be changing (because the task is allocated\n+    // on the heap). We must have this handle separately because the task will\n+    // have its ownership transferred to the given closure. We're guaranteed,\n+    // however, that this memory will remain valid because *this* is the current\n+    // task's execution thread.\n+    //\n+    // The next weird part is where ownership of the task actually goes. We\n+    // relinquish it to the `f` blocking function, but upon returning this\n+    // function needs to replace the task back in TLS. There is no communication\n+    // from the wakeup thread back to this thread about the task pointer, and\n+    // there's really no need to. In order to get around this, we cast the task\n+    // to a `uint` which is then used at the end of this function to cast back\n+    // to a `~Task` object. Naturally, this looks like it violates ownership\n+    // semantics in that there may be two `~Task` objects.\n+    //\n+    // The fun part is that the wakeup half of this implementation knows to\n+    // \"forget\" the task on the other end. This means that the awakening half of\n+    // things silently relinquishes ownership back to this thread, but not in a\n+    // way that the compiler can understand. The task's memory is always valid\n+    // for both tasks because these operations are all done inside of a mutex.\n+    //\n+    // You'll also find that if blocking fails (the `f` function hands the\n+    // BlockedTask back to us), we will `cast::forget` the handles. The\n+    // reasoning for this is the same logic as above in that the task silently\n+    // transfers ownership via the `uint`, not through normal compiler\n+    // semantics.\n+    //\n+    // On a mildly unrelated note, it should also be pointed out that OS\n+    // condition variables are susceptible to spurious wakeups, which we need to\n+    // be ready for. In order to accomodate for this fact, we have an extra\n+    // `awoken` field which indicates whether we were actually woken up via some\n+    // invocation of `reawaken`. This flag is only ever accessed inside the\n+    // lock, so there's no need to make it atomic.\n+    fn deschedule(mut ~self, times: uint, mut cur_task: ~Task,\n+                  f: |BlockedTask| -> Result<(), BlockedTask>) {\n+        let me = &mut *self as *mut Ops;\n+        cur_task.put_runtime(self as ~rt::Runtime);\n+\n+        unsafe {\n+            let cur_task_dupe = *cast::transmute::<&~Task, &uint>(&cur_task);\n+            let task = BlockedTask::block(cur_task);\n+\n+            if times == 1 {\n+                (*me).lock.lock();\n+                (*me).awoken = false;\n+                match f(task) {\n+                    Ok(()) => {\n+                        while !(*me).awoken {\n+                            (*me).lock.wait();\n+                        }\n+                    }\n+                    Err(task) => { cast::forget(task.wake()); }\n+                }\n+                (*me).lock.unlock();\n+            } else {\n+                let mut iter = task.make_selectable(times);\n+                (*me).lock.lock();\n+                (*me).awoken = false;\n+                let success = iter.all(|task| {\n+                    match f(task) {\n+                        Ok(()) => true,\n+                        Err(task) => {\n+                            cast::forget(task.wake());\n+                            false\n+                        }\n+                    }\n+                });\n+                while success && !(*me).awoken {\n+                    (*me).lock.wait();\n+                }\n+                (*me).lock.unlock();\n+            }\n+            // re-acquire ownership of the task\n+            cur_task = cast::transmute::<uint, ~Task>(cur_task_dupe);\n+        }\n+\n+        // put the task back in TLS, and everything is as it once was.\n+        Local::put(cur_task);\n+    }\n+\n+    // See the comments on `deschedule` for why the task is forgotten here, and\n+    // why it's valid to do so.\n+    fn reawaken(mut ~self, mut to_wake: ~Task, _can_resched: bool) {\n+        unsafe {\n+            let me = &mut *self as *mut Ops;\n+            to_wake.put_runtime(self as ~rt::Runtime);\n+            cast::forget(to_wake);\n+            (*me).lock.lock();\n+            (*me).awoken = true;\n+            (*me).lock.signal();\n+            (*me).lock.unlock();\n+        }\n+    }\n+\n+    fn spawn_sibling(~self, mut cur_task: ~Task, opts: TaskOpts, f: proc()) {\n+        cur_task.put_runtime(self as ~rt::Runtime);\n+        Local::put(cur_task);\n+\n+        task::spawn_opts(opts, f);\n+    }\n+\n+    fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> {\n+        static mut io: io::IoFactory = io::IoFactory;\n+        // Unsafety is from accessing `io`, which is guaranteed to be safe\n+        // because you can't do anything usable with this statically initialized\n+        // unit struct.\n+        Some(unsafe { rtio::LocalIo::new(&mut io as &mut rtio::IoFactory) })\n+    }\n+}\n+\n+impl Drop for Ops {\n+    fn drop(&mut self) {\n+        unsafe { self.lock.destroy() }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::rt::Runtime;\n+    use std::rt::local::Local;\n+    use std::rt::task::Task;\n+    use std::task;\n+    use std::task::TaskOpts;\n+    use super::{spawn, spawn_opts, Ops};\n+\n+    #[test]\n+    fn smoke() {\n+        let (p, c) = Chan::new();\n+        do spawn {\n+            c.send(());\n+        }\n+        p.recv();\n+    }\n+\n+    #[test]\n+    fn smoke_fail() {\n+        let (p, c) = Chan::<()>::new();\n+        do spawn {\n+            let _c = c;\n+            fail!()\n+        }\n+        assert_eq!(p.recv_opt(), None);\n+    }\n+\n+    #[test]\n+    fn smoke_opts() {\n+        let mut opts = TaskOpts::new();\n+        opts.name = Some(SendStrStatic(\"test\"));\n+        opts.stack_size = Some(20 * 4096);\n+        let (p, c) = Chan::new();\n+        opts.notify_chan = Some(c);\n+        spawn_opts(opts, proc() {});\n+        assert!(p.recv().is_ok());\n+    }\n+\n+    #[test]\n+    fn smoke_opts_fail() {\n+        let mut opts = TaskOpts::new();\n+        let (p, c) = Chan::new();\n+        opts.notify_chan = Some(c);\n+        spawn_opts(opts, proc() { fail!() });\n+        assert!(p.recv().is_err());\n+    }\n+\n+    #[test]\n+    fn yield_test() {\n+        let (p, c) = Chan::new();\n+        do spawn {\n+            10.times(task::deschedule);\n+            c.send(());\n+        }\n+        p.recv();\n+    }\n+\n+    #[test]\n+    fn spawn_children() {\n+        let (p, c) = Chan::new();\n+        do spawn {\n+            let (p, c2) = Chan::new();\n+            do spawn {\n+                let (p, c3) = Chan::new();\n+                do spawn {\n+                    c3.send(());\n+                }\n+                p.recv();\n+                c2.send(());\n+            }\n+            p.recv();\n+            c.send(());\n+        }\n+        p.recv();\n+    }\n+\n+    #[test]\n+    fn spawn_inherits() {\n+        let (p, c) = Chan::new();\n+        do spawn {\n+            let c = c;\n+            do spawn {\n+                let mut task: ~Task = Local::take();\n+                match task.maybe_take_runtime::<Ops>() {\n+                    Some(ops) => {\n+                        task.put_runtime(ops as ~Runtime);\n+                    }\n+                    None => fail!(),\n+                }\n+                Local::put(task);\n+                c.send(());\n+            }\n+        }\n+        p.recv();\n+    }\n+}"}, {"sha": "11a63db6abaaf361b3d9ad54088816c585faa3dd", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -333,6 +333,10 @@ pub mod write {\n     }\n \n     unsafe fn configure_llvm(sess: Session) {\n+        use std::unstable::mutex::{MUTEX_INIT, Mutex};\n+        static mut LOCK: Mutex = MUTEX_INIT;\n+        static mut CONFIGURED: bool = false;\n+\n         // Copy what clan does by turning on loop vectorization at O2 and\n         // slp vectorization at O3\n         let vectorize_loop = !sess.no_vectorize_loops() &&\n@@ -360,7 +364,13 @@ pub mod write {\n             add(*arg);\n         }\n \n-        llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int, llvm_args.as_ptr());\n+        LOCK.lock();\n+        if !CONFIGURED {\n+            llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int,\n+                                         llvm_args.as_ptr());\n+            CONFIGURED = true;\n+        }\n+        LOCK.unlock();\n     }\n \n     unsafe fn populate_llvm_passes(fpm: lib::llvm::PassManagerRef,"}, {"sha": "1503e4effeb364c59e2e78a8eb155cc236e09855", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -70,6 +70,15 @@ impl fold::ast_fold for StandardLibraryInjector {\n         }];\n \n         if use_uv(&crate) && !*self.sess.building_library {\n+            vis.push(ast::view_item {\n+                node: ast::view_item_extern_mod(self.sess.ident_of(\"green\"),\n+                                                None,\n+                                                ~[vers_item],\n+                                                ast::DUMMY_NODE_ID),\n+                attrs: ~[],\n+                vis: ast::private,\n+                span: dummy_sp()\n+            });\n             vis.push(ast::view_item {\n                 node: ast::view_item_extern_mod(self.sess.ident_of(\"rustuv\"),\n                                                 None,"}, {"sha": "61fadb7e2365476d1722511808cfff3cd7d16ee8", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -146,7 +146,7 @@ use std::hashmap::HashMap;\n use std::hashmap::HashSet;\n use std::libc::{c_uint, c_ulonglong, c_longlong};\n use std::ptr;\n-use std::unstable::atomics;\n+use std::sync::atomics;\n use std::vec;\n use syntax::codemap::{Span, Pos};\n use syntax::{ast, codemap, ast_util, ast_map, opt_vec};"}, {"sha": "0d927fc36aece5cecdde0176b0a7ee78ba96808e", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -390,7 +390,7 @@ pub fn mk_output_path(what: OutputType, where: Target,\n                                Bench => \"bench\",\n                                _     => \"\"\n                            },\n-                           os::EXE_SUFFIX))\n+                           os::consts::EXE_SUFFIX))\n     };\n     if !output_path.is_absolute() {\n         output_path = os::getcwd().join(&output_path);"}, {"sha": "21f18eda1409d648d1a70fc491433dc3d358dce5", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -487,8 +487,9 @@ fn lib_output_file_name(workspace: &Path, short_name: &str) -> Path {\n }\n \n fn output_file_name(workspace: &Path, short_name: ~str) -> Path {\n-    target_build_dir(workspace).join(short_name.as_slice()).join(format!(\"{}{}\", short_name,\n-                                                                         os::EXE_SUFFIX))\n+    target_build_dir(workspace).join(short_name.as_slice())\n+                               .join(format!(\"{}{}\", short_name,\n+                                             os::consts::EXE_SUFFIX))\n }\n \n #[cfg(target_os = \"linux\")]\n@@ -1353,7 +1354,7 @@ fn test_import_rustpkg() {\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n     debug!(\"workspace = {}\", workspace.display());\n     assert!(target_build_dir(workspace).join(\"foo\").join(format!(\"pkg{}\",\n-        os::EXE_SUFFIX)).exists());\n+        os::consts::EXE_SUFFIX)).exists());\n }\n \n #[test]\n@@ -1366,7 +1367,7 @@ fn test_macro_pkg_script() {\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n     debug!(\"workspace = {}\", workspace.display());\n     assert!(target_build_dir(workspace).join(\"foo\").join(format!(\"pkg{}\",\n-        os::EXE_SUFFIX)).exists());\n+        os::consts::EXE_SUFFIX)).exists());\n }\n \n #[test]"}, {"sha": "f6fad524b5c68f5d2257d292349191af1df7b50b", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -11,12 +11,10 @@\n use ai = std::io::net::addrinfo;\n use std::libc::c_int;\n use std::ptr::null;\n-use std::rt::BlockedTask;\n-use std::rt::local::Local;\n-use std::rt::sched::Scheduler;\n+use std::rt::task::BlockedTask;\n \n use net;\n-use super::{Loop, UvError, Request, wait_until_woken_after};\n+use super::{Loop, UvError, Request, wait_until_woken_after, wakeup};\n use uvll;\n \n struct Addrinfo {\n@@ -108,8 +106,7 @@ impl GetAddrInfoRequest {\n             cx.status = status;\n             cx.addrinfo = Some(Addrinfo { handle: res });\n \n-            let sched: ~Scheduler = Local::take();\n-            sched.resume_blocked_task_immediately(cx.slot.take_unwrap());\n+            wakeup(&mut cx.slot);\n         }\n     }\n }\n@@ -188,12 +185,13 @@ pub fn accum_addrinfo(addr: &Addrinfo) -> ~[ai::Info] {\n #[cfg(test, not(target_os=\"android\"))]\n mod test {\n     use std::io::net::ip::{SocketAddr, Ipv4Addr};\n-    use super::*;\n     use super::super::local_loop;\n+    use super::GetAddrInfoRequest;\n \n     #[test]\n     fn getaddrinfo_test() {\n-        match GetAddrInfoRequest::run(local_loop(), Some(\"localhost\"), None, None) {\n+        let loop_ = &mut local_loop().loop_;\n+        match GetAddrInfoRequest::run(loop_, Some(\"localhost\"), None, None) {\n             Ok(infos) => {\n                 let mut found_local = false;\n                 let local_addr = &SocketAddr {\n@@ -211,9 +209,10 @@ mod test {\n \n     #[test]\n     fn issue_10663() {\n+        let loop_ = &mut local_loop().loop_;\n         // Something should happen here, but this certainly shouldn't cause\n         // everything to die. The actual outcome we don't care too much about.\n-        GetAddrInfoRequest::run(local_loop(), Some(\"irc.n0v4.com\"), None,\n+        GetAddrInfoRequest::run(loop_, Some(\"irc.n0v4.com\"), None,\n                                 None);\n     }\n }"}, {"sha": "0c353785982e6e7bcc5d9d0cddf43b03834a9c65", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -127,16 +127,15 @@ impl Drop for AsyncWatcher {\n mod test_remote {\n     use std::rt::rtio::Callback;\n     use std::rt::thread::Thread;\n-    use std::rt::tube::Tube;\n \n-    use super::*;\n+    use super::AsyncWatcher;\n     use super::super::local_loop;\n \n     // Make sure that we can fire watchers in remote threads and that they\n     // actually trigger what they say they will.\n     #[test]\n     fn smoke_test() {\n-        struct MyCallback(Option<Tube<int>>);\n+        struct MyCallback(Option<Chan<int>>);\n         impl Callback for MyCallback {\n             fn call(&mut self) {\n                 // this can get called more than once, but we only want to send\n@@ -147,16 +146,17 @@ mod test_remote {\n             }\n         }\n \n-        let mut tube = Tube::new();\n-        let cb = ~MyCallback(Some(tube.clone()));\n-        let watcher = AsyncWatcher::new(local_loop(), cb as ~Callback);\n+        let (port, chan) = Chan::new();\n+        let cb = ~MyCallback(Some(chan));\n+        let watcher = AsyncWatcher::new(&mut local_loop().loop_,\n+                                        cb as ~Callback);\n \n         let thread = do Thread::start {\n             let mut watcher = watcher;\n             watcher.fire();\n         };\n \n-        assert_eq!(tube.recv(), 1);\n+        assert_eq!(port.recv(), 1);\n         thread.join();\n     }\n }"}, {"sha": "82d0fd823a32078d56ccf2a683ecb9759c579884", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -14,15 +14,14 @@ use std::cast::transmute;\n use std::cast;\n use std::libc::{c_int, c_char, c_void, size_t};\n use std::libc;\n-use std::rt::BlockedTask;\n+use std::rt::task::BlockedTask;\n use std::io::{FileStat, IoError};\n use std::io;\n-use std::rt::local::Local;\n use std::rt::rtio;\n-use std::rt::sched::{Scheduler, SchedHandle};\n \n-use super::{Loop, UvError, uv_error_to_io_error, wait_until_woken_after};\n-use uvio::HomingIO;\n+use homing::{HomingIO, HomeHandle};\n+use super::{Loop, UvError, uv_error_to_io_error, wait_until_woken_after, wakeup};\n+use uvio::UvIoFactory;\n use uvll;\n \n pub struct FsRequest {\n@@ -34,19 +33,19 @@ pub struct FileWatcher {\n     priv loop_: Loop,\n     priv fd: c_int,\n     priv close: rtio::CloseBehavior,\n-    priv home: SchedHandle,\n+    priv home: HomeHandle,\n }\n \n impl FsRequest {\n-    pub fn open(loop_: &Loop, path: &CString, flags: int, mode: int)\n+    pub fn open(io: &mut UvIoFactory, path: &CString, flags: int, mode: int)\n         -> Result<FileWatcher, UvError>\n     {\n         execute(|req, cb| unsafe {\n-            uvll::uv_fs_open(loop_.handle,\n+            uvll::uv_fs_open(io.uv_loop(),\n                              req, path.with_ref(|p| p), flags as c_int,\n                              mode as c_int, cb)\n         }).map(|req|\n-            FileWatcher::new(*loop_, req.get_result() as c_int,\n+            FileWatcher::new(io, req.get_result() as c_int,\n                              rtio::CloseSynchronously)\n         )\n     }\n@@ -320,8 +319,7 @@ fn execute(f: |*uvll::uv_fs_t, uvll::uv_fs_cb| -> c_int)\n         let slot: &mut Option<BlockedTask> = unsafe {\n             cast::transmute(uvll::get_data_for_req(req))\n         };\n-        let sched: ~Scheduler = Local::take();\n-        sched.resume_blocked_task_immediately(slot.take_unwrap());\n+        wakeup(slot);\n     }\n }\n \n@@ -331,16 +329,17 @@ fn execute_nop(f: |*uvll::uv_fs_t, uvll::uv_fs_cb| -> c_int)\n }\n \n impl HomingIO for FileWatcher {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n }\n \n impl FileWatcher {\n-    pub fn new(loop_: Loop, fd: c_int, close: rtio::CloseBehavior) -> FileWatcher {\n+    pub fn new(io: &mut UvIoFactory, fd: c_int,\n+               close: rtio::CloseBehavior) -> FileWatcher {\n         FileWatcher {\n-            loop_: loop_,\n+            loop_: Loop::wrap(io.uv_loop()),\n             fd: fd,\n             close: close,\n-            home: get_handle_to_current_scheduler!()\n+            home: io.make_handle(),\n         }\n     }\n \n@@ -448,8 +447,11 @@ mod test {\n     use std::io;\n     use std::str;\n     use std::vec;\n-    use super::*;\n-    use l = super::super::local_loop;\n+    use super::FsRequest;\n+    use super::super::Loop;\n+    use super::super::local_loop;\n+\n+    fn l() -> &mut Loop { &mut local_loop().loop_ }\n \n     #[test]\n     fn file_test_full_simple_sync() {\n@@ -460,7 +462,7 @@ mod test {\n \n         {\n             // open/create\n-            let result = FsRequest::open(l(), &path_str.to_c_str(),\n+            let result = FsRequest::open(local_loop(), &path_str.to_c_str(),\n                                          create_flags as int, mode as int);\n             assert!(result.is_ok());\n             let result = result.unwrap();\n@@ -473,7 +475,7 @@ mod test {\n \n         {\n             // re-open\n-            let result = FsRequest::open(l(), &path_str.to_c_str(),\n+            let result = FsRequest::open(local_loop(), &path_str.to_c_str(),\n                                          read_flags as int, 0);\n             assert!(result.is_ok());\n             let result = result.unwrap();\n@@ -500,7 +502,7 @@ mod test {\n         let create_flags = (O_RDWR | O_CREAT) as int;\n         let mode = (S_IWUSR | S_IRUSR) as int;\n \n-        let result = FsRequest::open(l(), path, create_flags, mode);\n+        let result = FsRequest::open(local_loop(), path, create_flags, mode);\n         assert!(result.is_ok());\n         let file = result.unwrap();\n "}, {"sha": "16534b7b38babbdbaf1a42d0f61a49e47a800ac6", "filename": "src/librustuv/homing.rs", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fhoming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fhoming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fhoming.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -0,0 +1,212 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Homing I/O implementation\n+//!\n+//! In libuv, whenever a handle is created on an I/O loop it is illegal to use\n+//! that handle outside of that I/O loop. We use libuv I/O with our green\n+//! scheduler, and each green scheduler corresponds to a different I/O loop on a\n+//! different OS thread. Green tasks are also free to roam among schedulers,\n+//! which implies that it is possible to create an I/O handle on one event loop\n+//! and then attempt to use it on another.\n+//!\n+//! In order to solve this problem, this module implements the notion of a\n+//! \"homing operation\" which will transplant a task from its currently running\n+//! scheduler back onto the original I/O loop. This is accomplished entirely at\n+//! the librustuv layer with very little cooperation from the scheduler (which\n+//! we don't even know exists technically).\n+//!\n+//! These homing operations are completed by first realizing that we're on the\n+//! wrong I/O loop, then descheduling ourselves, sending ourselves to the\n+//! correct I/O loop, and then waking up the I/O loop in order to process its\n+//! local queue of tasks which need to run.\n+//!\n+//! This enqueueing is done with a concurrent queue from libstd, and the\n+//! signalling is achieved with an async handle.\n+\n+#[allow(dead_code)];\n+\n+use std::cast;\n+use std::rt::local::Local;\n+use std::rt::rtio::LocalIo;\n+use std::rt::task::{Task, BlockedTask};\n+\n+use ForbidUnwind;\n+use queue::{Queue, QueuePool};\n+\n+/// A handle to a remote libuv event loop. This handle will keep the event loop\n+/// alive while active in order to ensure that a homing operation can always be\n+/// completed.\n+///\n+/// Handles are clone-able in order to derive new handles from existing handles\n+/// (very useful for when accepting a socket from a server).\n+pub struct HomeHandle {\n+    priv queue: Queue,\n+    priv id: uint,\n+}\n+\n+impl HomeHandle {\n+    pub fn new(id: uint, pool: &mut QueuePool) -> HomeHandle {\n+        HomeHandle { queue: pool.queue(), id: id }\n+    }\n+\n+    fn send(&mut self, task: BlockedTask) {\n+        self.queue.push(task);\n+    }\n+}\n+\n+impl Clone for HomeHandle {\n+    fn clone(&self) -> HomeHandle {\n+        HomeHandle {\n+            queue: self.queue.clone(),\n+            id: self.id,\n+        }\n+    }\n+}\n+\n+pub fn local_id() -> uint {\n+    let mut io = match LocalIo::borrow() {\n+        Some(io) => io, None => return 0,\n+    };\n+    let io = io.get();\n+    unsafe {\n+        let (_vtable, ptr): (uint, uint) = cast::transmute(io);\n+        return ptr;\n+    }\n+}\n+\n+pub trait HomingIO {\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle;\n+\n+    /// This function will move tasks to run on their home I/O scheduler. Note\n+    /// that this function does *not* pin the task to the I/O scheduler, but\n+    /// rather it simply moves it to running on the I/O scheduler.\n+    fn go_to_IO_home(&mut self) -> uint {\n+        let _f = ForbidUnwind::new(\"going home\");\n+\n+        let cur_loop_id = local_id();\n+        let destination = self.home().id;\n+\n+        // Try at all costs to avoid the homing operation because it is quite\n+        // expensive. Hence, we only deschedule/send if we're not on the correct\n+        // event loop. If we're already on the home event loop, then we're good\n+        // to go (remember we have no preemption, so we're guaranteed to stay on\n+        // this event loop as long as we avoid the scheduler).\n+        if cur_loop_id != destination {\n+            let cur_task: ~Task = Local::take();\n+            cur_task.deschedule(1, |task| {\n+                self.home().send(task);\n+                Ok(())\n+            });\n+\n+            // Once we wake up, assert that we're in the right location\n+            assert_eq!(local_id(), destination);\n+        }\n+\n+        return destination;\n+    }\n+\n+    /// Fires a single homing missile, returning another missile targeted back\n+    /// at the original home of this task. In other words, this function will\n+    /// move the local task to its I/O scheduler and then return an RAII wrapper\n+    /// which will return the task home.\n+    fn fire_homing_missile(&mut self) -> HomingMissile {\n+        HomingMissile { io_home: self.go_to_IO_home() }\n+    }\n+}\n+\n+/// After a homing operation has been completed, this will return the current\n+/// task back to its appropriate home (if applicable). The field is used to\n+/// assert that we are where we think we are.\n+struct HomingMissile {\n+    priv io_home: uint,\n+}\n+\n+impl HomingMissile {\n+    /// Check at runtime that the task has *not* transplanted itself to a\n+    /// different I/O loop while executing.\n+    pub fn check(&self, msg: &'static str) {\n+        assert!(local_id() == self.io_home, \"{}\", msg);\n+    }\n+}\n+\n+impl Drop for HomingMissile {\n+    fn drop(&mut self) {\n+        let _f = ForbidUnwind::new(\"leaving home\");\n+\n+        // It would truly be a sad day if we had moved off the home I/O\n+        // scheduler while we were doing I/O.\n+        self.check(\"task moved away from the home scheduler\");\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use green::sched;\n+    use green::{SchedPool, PoolConfig};\n+    use std::rt::rtio::RtioUdpSocket;\n+    use std::io::test::next_test_ip4;\n+    use std::task::TaskOpts;\n+\n+    use net::UdpWatcher;\n+    use super::super::local_loop;\n+\n+    // On one thread, create a udp socket. Then send that socket to another\n+    // thread and destroy the socket on the remote thread. This should make sure\n+    // that homing kicks in for the socket to go back home to the original\n+    // thread, close itself, and then come back to the last thread.\n+    #[test]\n+    fn test_homing_closes_correctly() {\n+        let (port, chan) = Chan::new();\n+        let mut pool = SchedPool::new(PoolConfig {\n+            threads: 1,\n+            event_loop_factory: None,\n+        });\n+\n+        do pool.spawn(TaskOpts::new()) {\n+            let listener = UdpWatcher::bind(local_loop(), next_test_ip4());\n+            chan.send(listener.unwrap());\n+        }\n+\n+        let task = do pool.task(TaskOpts::new()) {\n+            port.recv();\n+        };\n+        pool.spawn_sched().send(sched::TaskFromFriend(task));\n+\n+        pool.shutdown();\n+    }\n+\n+    #[test]\n+    fn test_homing_read() {\n+        let (port, chan) = Chan::new();\n+        let mut pool = SchedPool::new(PoolConfig {\n+            threads: 1,\n+            event_loop_factory: None,\n+        });\n+\n+        do pool.spawn(TaskOpts::new()) {\n+            let addr1 = next_test_ip4();\n+            let addr2 = next_test_ip4();\n+            let listener = UdpWatcher::bind(local_loop(), addr2);\n+            chan.send((listener.unwrap(), addr1));\n+            let mut listener = UdpWatcher::bind(local_loop(), addr1).unwrap();\n+            listener.sendto([1, 2, 3, 4], addr2);\n+        }\n+\n+        let task = do pool.task(TaskOpts::new()) {\n+            let (mut watcher, addr) = port.recv();\n+            let mut buf = [0, ..10];\n+            assert_eq!(watcher.recvfrom(buf).unwrap(), (4, addr));\n+        };\n+        pool.spawn_sched().send(sched::TaskFromFriend(task));\n+\n+        pool.shutdown();\n+    }\n+}"}, {"sha": "80d21404e4bcb4ff3aeba9309f56f5edbb12d501", "filename": "src/librustuv/idle.rs", "status": "modified", "additions": 58, "deletions": 28, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -97,72 +97,102 @@ impl Drop for IdleWatcher {\n \n #[cfg(test)]\n mod test {\n-    use super::*;\n-    use std::rt::tube::Tube;\n+    use std::cast;\n+    use std::cell::RefCell;\n+    use std::rc::Rc;\n     use std::rt::rtio::{Callback, PausableIdleCallback};\n+    use std::rt::task::{BlockedTask, Task};\n+    use std::rt::local::Local;\n+    use super::IdleWatcher;\n     use super::super::local_loop;\n \n-    struct MyCallback(Tube<int>, int);\n+    type Chan = Rc<RefCell<(Option<BlockedTask>, uint)>>;\n+\n+    struct MyCallback(Rc<RefCell<(Option<BlockedTask>, uint)>>, uint);\n     impl Callback for MyCallback {\n         fn call(&mut self) {\n-            match *self {\n-                MyCallback(ref mut tube, val) => tube.send(val)\n-            }\n+            let task = match *self {\n+                MyCallback(ref rc, n) => {\n+                    let mut slot = rc.borrow().borrow_mut();\n+                    match *slot.get() {\n+                        (ref mut task, ref mut val) => {\n+                            *val = n;\n+                            task.take_unwrap()\n+                        }\n+                    }\n+                }\n+            };\n+            task.wake().map(|t| t.reawaken(true));\n         }\n     }\n \n+    fn mk(v: uint) -> (~IdleWatcher, Chan) {\n+        let rc = Rc::from_send(RefCell::new((None, 0)));\n+        let cb = ~MyCallback(rc.clone(), v);\n+        let cb = cb as ~Callback:;\n+        let cb = unsafe { cast::transmute(cb) };\n+        (IdleWatcher::new(&mut local_loop().loop_, cb), rc)\n+    }\n+\n+    fn sleep(chan: &Chan) -> uint {\n+        let task: ~Task = Local::take();\n+        task.deschedule(1, |task| {\n+            let mut slot = chan.borrow().borrow_mut();\n+            match *slot.get() {\n+                (ref mut slot, _) => {\n+                    assert!(slot.is_none());\n+                    *slot = Some(task);\n+                }\n+            }\n+            Ok(())\n+        });\n+\n+        let slot = chan.borrow().borrow();\n+        match *slot.get() { (_, n) => n }\n+    }\n+\n     #[test]\n     fn not_used() {\n-        let cb = ~MyCallback(Tube::new(), 1);\n-        let _idle = IdleWatcher::new(local_loop(), cb as ~Callback);\n+        let (_idle, _chan) = mk(1);\n     }\n \n     #[test]\n     fn smoke_test() {\n-        let mut tube = Tube::new();\n-        let cb = ~MyCallback(tube.clone(), 1);\n-        let mut idle = IdleWatcher::new(local_loop(), cb as ~Callback);\n+        let (mut idle, chan) = mk(1);\n         idle.resume();\n-        tube.recv();\n+        assert_eq!(sleep(&chan), 1);\n     }\n \n     #[test] #[should_fail]\n     fn smoke_fail() {\n-        let tube = Tube::new();\n-        let cb = ~MyCallback(tube.clone(), 1);\n-        let mut idle = IdleWatcher::new(local_loop(), cb as ~Callback);\n+        let (mut idle, _chan) = mk(1);\n         idle.resume();\n         fail!();\n     }\n \n     #[test]\n     fn fun_combinations_of_methods() {\n-        let mut tube = Tube::new();\n-        let cb = ~MyCallback(tube.clone(), 1);\n-        let mut idle = IdleWatcher::new(local_loop(), cb as ~Callback);\n+        let (mut idle, chan) = mk(1);\n         idle.resume();\n-        tube.recv();\n+        assert_eq!(sleep(&chan), 1);\n         idle.pause();\n         idle.resume();\n         idle.resume();\n-        tube.recv();\n+        assert_eq!(sleep(&chan), 1);\n         idle.pause();\n         idle.pause();\n         idle.resume();\n-        tube.recv();\n+        assert_eq!(sleep(&chan), 1);\n     }\n \n     #[test]\n     fn pause_pauses() {\n-        let mut tube = Tube::new();\n-        let cb = ~MyCallback(tube.clone(), 1);\n-        let mut idle1 = IdleWatcher::new(local_loop(), cb as ~Callback);\n-        let cb = ~MyCallback(tube.clone(), 2);\n-        let mut idle2 = IdleWatcher::new(local_loop(), cb as ~Callback);\n+        let (mut idle1, chan1) = mk(1);\n+        let (mut idle2, chan2) = mk(2);\n         idle2.resume();\n-        assert_eq!(tube.recv(), 2);\n+        assert_eq!(sleep(&chan2), 2);\n         idle2.pause();\n         idle1.resume();\n-        assert_eq!(tube.recv(), 1);\n+        assert_eq!(sleep(&chan1), 1);\n     }\n }"}, {"sha": "2ef10dd33ac9c915d0e5ac3c2988f20a6b18cc1e", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 41, "deletions": 35, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -41,23 +41,23 @@ via `close` and `delete` methods.\n #[crate_type = \"rlib\"];\n #[crate_type = \"dylib\"];\n \n-#[feature(macro_rules, globs)];\n+#[feature(macro_rules)];\n+\n+#[cfg(test)] extern mod green;\n \n-use std::cast::transmute;\n use std::cast;\n+use std::io;\n+use std::io::IoError;\n use std::libc::{c_int, malloc};\n use std::ptr::null;\n use std::ptr;\n-use std::rt::BlockedTask;\n use std::rt::local::Local;\n-use std::rt::sched::Scheduler;\n+use std::rt::task::{BlockedTask, Task};\n use std::str::raw::from_c_str;\n use std::str;\n use std::task;\n use std::unstable::finally::Finally;\n \n-use std::io::IoError;\n-\n pub use self::async::AsyncWatcher;\n pub use self::file::{FsRequest, FileWatcher};\n pub use self::idle::IdleWatcher;\n@@ -70,6 +70,9 @@ pub use self::tty::TtyWatcher;\n \n mod macros;\n \n+mod queue;\n+mod homing;\n+\n /// The implementation of `rtio` for libuv\n pub mod uvio;\n \n@@ -144,32 +147,29 @@ pub trait UvHandle<T> {\n                 uvll::free_handle(handle);\n                 if data == ptr::null() { return }\n                 let slot: &mut Option<BlockedTask> = cast::transmute(data);\n-                let sched: ~Scheduler = Local::take();\n-                sched.resume_blocked_task_immediately(slot.take_unwrap());\n+                wakeup(slot);\n             }\n         }\n     }\n }\n \n pub struct ForbidSwitch {\n-    msg: &'static str,\n-    sched: uint,\n+    priv msg: &'static str,\n+    priv io: uint,\n }\n \n impl ForbidSwitch {\n     fn new(s: &'static str) -> ForbidSwitch {\n-        let mut sched = Local::borrow(None::<Scheduler>);\n         ForbidSwitch {\n             msg: s,\n-            sched: sched.get().sched_id(),\n+            io: homing::local_id(),\n         }\n     }\n }\n \n impl Drop for ForbidSwitch {\n     fn drop(&mut self) {\n-        let mut sched = Local::borrow(None::<Scheduler>);\n-        assert!(self.sched == sched.get().sched_id(),\n+        assert!(self.io == homing::local_id(),\n                 \"didnt want a scheduler switch: {}\",\n                 self.msg);\n     }\n@@ -199,14 +199,20 @@ fn wait_until_woken_after(slot: *mut Option<BlockedTask>, f: ||) {\n     let _f = ForbidUnwind::new(\"wait_until_woken_after\");\n     unsafe {\n         assert!((*slot).is_none());\n-        let sched: ~Scheduler = Local::take();\n-        sched.deschedule_running_task_and_then(|_, task| {\n-            f();\n+        let task: ~Task = Local::take();\n+        task.deschedule(1, |task| {\n             *slot = Some(task);\n-        })\n+            f();\n+            Ok(())\n+        });\n     }\n }\n \n+fn wakeup(slot: &mut Option<BlockedTask>) {\n+    assert!(slot.is_some());\n+    slot.take_unwrap().wake().map(|t| t.reawaken(true));\n+}\n+\n pub struct Request {\n     handle: *uvll::uv_req_t,\n     priv defused: bool,\n@@ -325,28 +331,26 @@ fn error_smoke_test() {\n pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n     unsafe {\n         // Importing error constants\n-        use uvll::*;\n-        use std::io::*;\n \n         // uv error descriptions are static\n         let c_desc = uvll::uv_strerror(*uverr);\n         let desc = str::raw::c_str_to_static_slice(c_desc);\n \n         let kind = match *uverr {\n-            UNKNOWN => OtherIoError,\n-            OK => OtherIoError,\n-            EOF => EndOfFile,\n-            EACCES => PermissionDenied,\n-            ECONNREFUSED => ConnectionRefused,\n-            ECONNRESET => ConnectionReset,\n-            ENOENT => FileNotFound,\n-            ENOTCONN => NotConnected,\n-            EPIPE => BrokenPipe,\n-            ECONNABORTED => ConnectionAborted,\n+            uvll::UNKNOWN => io::OtherIoError,\n+            uvll::OK => io::OtherIoError,\n+            uvll::EOF => io::EndOfFile,\n+            uvll::EACCES => io::PermissionDenied,\n+            uvll::ECONNREFUSED => io::ConnectionRefused,\n+            uvll::ECONNRESET => io::ConnectionReset,\n+            uvll::ENOTCONN => io::NotConnected,\n+            uvll::ENOENT => io::FileNotFound,\n+            uvll::EPIPE => io::BrokenPipe,\n+            uvll::ECONNABORTED => io::ConnectionAborted,\n             err => {\n                 uvdebug!(\"uverr.code {}\", err as int);\n                 // XXX: Need to map remaining uv error types\n-                OtherIoError\n+                io::OtherIoError\n             }\n         };\n \n@@ -387,15 +391,17 @@ pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n     uvll::uv_buf_t { base: data, len: v.len() as uvll::uv_buf_len_t }\n }\n \n+// This function is full of lies!\n #[cfg(test)]\n-fn local_loop() -> &'static mut Loop {\n+fn local_loop() -> &'static mut uvio::UvIoFactory {\n     unsafe {\n         cast::transmute({\n-            let mut sched = Local::borrow(None::<Scheduler>);\n+            let mut task = Local::borrow(None::<Task>);\n+            let mut io = task.get().local_io().unwrap();\n             let (_vtable, uvio): (uint, &'static mut uvio::UvIoFactory) =\n-                cast::transmute(sched.get().event_loop.io().unwrap());\n+                cast::transmute(io.get());\n             uvio\n-        }.uv_loop())\n+        })\n     }\n }\n "}, {"sha": "6c8c16784a12bf21074a056048c98765777ee7f0", "filename": "src/librustuv/macros.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fmacros.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -27,18 +27,20 @@ macro_rules! uvdebug (\n     })\n )\n \n-// get a handle for the current scheduler\n-macro_rules! get_handle_to_current_scheduler(\n-    () => ({\n-        let mut sched = Local::borrow(None::<Scheduler>);\n-        sched.get().make_handle()\n-    })\n-)\n-\n pub fn dumb_println(args: &fmt::Arguments) {\n-    use std::io::native::file::FileDesc;\n     use std::io;\n     use std::libc;\n-    let mut out = FileDesc::new(libc::STDERR_FILENO, false);\n-    fmt::writeln(&mut out as &mut io::Writer, args);\n+\n+    struct Stderr;\n+    impl io::Writer for Stderr {\n+        fn write(&mut self, data: &[u8]) {\n+            unsafe {\n+                libc::write(libc::STDERR_FILENO,\n+                            data.as_ptr() as *libc::c_void,\n+                            data.len() as libc::size_t);\n+            }\n+        }\n+    }\n+    let mut w = Stderr;\n+    fmt::writeln(&mut w as &mut io::Writer, args);\n }"}, {"sha": "85e9202c1fa609791beea0875d7dfdefe0f18b0e", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 111, "deletions": 314, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -9,24 +9,22 @@\n // except according to those terms.\n \n use std::cast;\n-use std::libc;\n-use std::libc::{size_t, ssize_t, c_int, c_void, c_uint, c_char};\n-use std::ptr;\n-use std::rt::BlockedTask;\n use std::io::IoError;\n use std::io::net::ip::{Ipv4Addr, Ipv6Addr, SocketAddr, IpAddr};\n-use std::rt::local::Local;\n+use std::libc::{size_t, ssize_t, c_int, c_void, c_uint, c_char};\n+use std::libc;\n+use std::ptr;\n use std::rt::rtio;\n-use std::rt::sched::{Scheduler, SchedHandle};\n-use std::rt::tube::Tube;\n+use std::rt::task::BlockedTask;\n use std::str;\n use std::vec;\n \n+use homing::{HomingIO, HomeHandle};\n use stream::StreamWatcher;\n use super::{Loop, Request, UvError, Buf, status_to_io_result,\n             uv_error_to_io_error, UvHandle, slice_to_uv_buf,\n-            wait_until_woken_after};\n-use uvio::HomingIO;\n+            wait_until_woken_after, wakeup};\n+use uvio::UvIoFactory;\n use uvll;\n use uvll::sockaddr;\n \n@@ -88,21 +86,19 @@ pub fn sockaddr_to_socket_addr(addr: *sockaddr) -> SocketAddr {\n     }\n }\n \n-#[cfg(test)]\n #[test]\n fn test_ip4_conversion() {\n-    use std::rt;\n-    let ip4 = rt::test::next_test_ip4();\n+    use std::io::net::ip::{SocketAddr, Ipv4Addr};\n+    let ip4 = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 4824 };\n     socket_addr_as_sockaddr(ip4, |addr| {\n         assert_eq!(ip4, sockaddr_to_socket_addr(addr));\n     })\n }\n \n-#[cfg(test)]\n #[test]\n fn test_ip6_conversion() {\n-    use std::rt;\n-    let ip6 = rt::test::next_test_ip6();\n+    use std::io::net::ip::{SocketAddr, Ipv6Addr};\n+    let ip6 = SocketAddr { ip: Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1), port: 4824 };\n     socket_addr_as_sockaddr(ip6, |addr| {\n         assert_eq!(ip6, sockaddr_to_socket_addr(addr));\n     })\n@@ -145,42 +141,47 @@ fn socket_name(sk: SocketNameKind, handle: *c_void) -> Result<SocketAddr, IoErro\n pub struct TcpWatcher {\n     handle: *uvll::uv_tcp_t,\n     stream: StreamWatcher,\n-    home: SchedHandle,\n+    home: HomeHandle,\n }\n \n pub struct TcpListener {\n-    home: SchedHandle,\n+    home: HomeHandle,\n     handle: *uvll::uv_pipe_t,\n     priv closing_task: Option<BlockedTask>,\n-    priv outgoing: Tube<Result<~rtio::RtioTcpStream, IoError>>,\n+    priv outgoing: Chan<Result<~rtio::RtioTcpStream, IoError>>,\n+    priv incoming: Port<Result<~rtio::RtioTcpStream, IoError>>,\n }\n \n pub struct TcpAcceptor {\n     listener: ~TcpListener,\n-    priv incoming: Tube<Result<~rtio::RtioTcpStream, IoError>>,\n }\n \n // TCP watchers (clients/streams)\n \n impl TcpWatcher {\n-    pub fn new(loop_: &Loop) -> TcpWatcher {\n+    pub fn new(io: &mut UvIoFactory) -> TcpWatcher {\n+        let handle = io.make_handle();\n+        TcpWatcher::new_home(&io.loop_, handle)\n+    }\n+\n+    fn new_home(loop_: &Loop, home: HomeHandle) -> TcpWatcher {\n         let handle = unsafe { uvll::malloc_handle(uvll::UV_TCP) };\n         assert_eq!(unsafe {\n             uvll::uv_tcp_init(loop_.handle, handle)\n         }, 0);\n         TcpWatcher {\n-            home: get_handle_to_current_scheduler!(),\n+            home: home,\n             handle: handle,\n             stream: StreamWatcher::new(handle),\n         }\n     }\n \n-    pub fn connect(loop_: &mut Loop, address: SocketAddr)\n+    pub fn connect(io: &mut UvIoFactory, address: SocketAddr)\n         -> Result<TcpWatcher, UvError>\n     {\n         struct Ctx { status: c_int, task: Option<BlockedTask> }\n \n-        let tcp = TcpWatcher::new(loop_);\n+        let tcp = TcpWatcher::new(io);\n         let ret = socket_addr_as_sockaddr(address, |addr| {\n             let mut req = Request::new(uvll::UV_CONNECT);\n             let result = unsafe {\n@@ -213,14 +214,13 @@ impl TcpWatcher {\n             assert!(status != uvll::ECANCELED);\n             let cx: &mut Ctx = unsafe { req.get_data() };\n             cx.status = status;\n-            let scheduler: ~Scheduler = Local::take();\n-            scheduler.resume_blocked_task_immediately(cx.task.take_unwrap());\n+            wakeup(&mut cx.task);\n         }\n     }\n }\n \n impl HomingIO for TcpWatcher {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n }\n \n impl rtio::RtioSocket for TcpWatcher {\n@@ -290,17 +290,19 @@ impl Drop for TcpWatcher {\n // TCP listeners (unbound servers)\n \n impl TcpListener {\n-    pub fn bind(loop_: &mut Loop, address: SocketAddr)\n+    pub fn bind(io: &mut UvIoFactory, address: SocketAddr)\n                 -> Result<~TcpListener, UvError> {\n         let handle = unsafe { uvll::malloc_handle(uvll::UV_TCP) };\n         assert_eq!(unsafe {\n-            uvll::uv_tcp_init(loop_.handle, handle)\n+            uvll::uv_tcp_init(io.uv_loop(), handle)\n         }, 0);\n+        let (port, chan) = Chan::new();\n         let l = ~TcpListener {\n-            home: get_handle_to_current_scheduler!(),\n+            home: io.make_handle(),\n             handle: handle,\n             closing_task: None,\n-            outgoing: Tube::new(),\n+            outgoing: chan,\n+            incoming: port,\n         };\n         let res = socket_addr_as_sockaddr(address, |addr| unsafe {\n             uvll::uv_tcp_bind(l.handle, addr)\n@@ -313,7 +315,7 @@ impl TcpListener {\n }\n \n impl HomingIO for TcpListener {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n }\n \n impl UvHandle<uvll::uv_tcp_t> for TcpListener {\n@@ -330,11 +332,7 @@ impl rtio::RtioSocket for TcpListener {\n impl rtio::RtioTcpListener for TcpListener {\n     fn listen(mut ~self) -> Result<~rtio::RtioTcpAcceptor, IoError> {\n         // create the acceptor object from ourselves\n-        let incoming = self.outgoing.clone();\n-        let mut acceptor = ~TcpAcceptor {\n-            listener: self,\n-            incoming: incoming,\n-        };\n+        let mut acceptor = ~TcpAcceptor { listener: self };\n \n         let _m = acceptor.fire_homing_missile();\n         // XXX: the 128 backlog should be configurable\n@@ -347,19 +345,18 @@ impl rtio::RtioTcpListener for TcpListener {\n \n extern fn listen_cb(server: *uvll::uv_stream_t, status: c_int) {\n     assert!(status != uvll::ECANCELED);\n+    let tcp: &mut TcpListener = unsafe { UvHandle::from_uv_handle(&server) };\n     let msg = match status {\n         0 => {\n             let loop_ = Loop::wrap(unsafe {\n                 uvll::get_loop_for_uv_handle(server)\n             });\n-            let client = TcpWatcher::new(&loop_);\n+            let client = TcpWatcher::new_home(&loop_, tcp.home().clone());\n             assert_eq!(unsafe { uvll::uv_accept(server, client.handle) }, 0);\n             Ok(~client as ~rtio::RtioTcpStream)\n         }\n         n => Err(uv_error_to_io_error(UvError(n)))\n     };\n-\n-    let tcp: &mut TcpListener = unsafe { UvHandle::from_uv_handle(&server) };\n     tcp.outgoing.send(msg);\n }\n \n@@ -373,7 +370,7 @@ impl Drop for TcpListener {\n // TCP acceptors (bound servers)\n \n impl HomingIO for TcpAcceptor {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.listener.home() }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { self.listener.home() }\n }\n \n impl rtio::RtioSocket for TcpAcceptor {\n@@ -385,8 +382,7 @@ impl rtio::RtioSocket for TcpAcceptor {\n \n impl rtio::RtioTcpAcceptor for TcpAcceptor {\n     fn accept(&mut self) -> Result<~rtio::RtioTcpStream, IoError> {\n-        let _m = self.fire_homing_missile();\n-        self.incoming.recv()\n+        self.listener.incoming.recv()\n     }\n \n     fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n@@ -410,18 +406,18 @@ impl rtio::RtioTcpAcceptor for TcpAcceptor {\n \n pub struct UdpWatcher {\n     handle: *uvll::uv_udp_t,\n-    home: SchedHandle,\n+    home: HomeHandle,\n }\n \n impl UdpWatcher {\n-    pub fn bind(loop_: &Loop, address: SocketAddr)\n+    pub fn bind(io: &mut UvIoFactory, address: SocketAddr)\n                 -> Result<UdpWatcher, UvError> {\n         let udp = UdpWatcher {\n             handle: unsafe { uvll::malloc_handle(uvll::UV_UDP) },\n-            home: get_handle_to_current_scheduler!(),\n+            home: io.make_handle(),\n         };\n         assert_eq!(unsafe {\n-            uvll::uv_udp_init(loop_.handle, udp.handle)\n+            uvll::uv_udp_init(io.uv_loop(), udp.handle)\n         }, 0);\n         let result = socket_addr_as_sockaddr(address, |addr| unsafe {\n             uvll::uv_udp_bind(udp.handle, addr, 0u32)\n@@ -438,7 +434,7 @@ impl UvHandle<uvll::uv_udp_t> for UdpWatcher {\n }\n \n impl HomingIO for UdpWatcher {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n }\n \n impl rtio::RtioSocket for UdpWatcher {\n@@ -519,9 +515,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                 Some(sockaddr_to_socket_addr(addr))\n             };\n             cx.result = Some((nread, addr));\n-\n-            let sched: ~Scheduler = Local::take();\n-            sched.resume_blocked_task_immediately(cx.task.take_unwrap());\n+            wakeup(&mut cx.task);\n         }\n     }\n \n@@ -556,9 +550,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n             assert!(status != uvll::ECANCELED);\n             let cx: &mut Ctx = unsafe { req.get_data() };\n             cx.result = status;\n-\n-            let sched: ~Scheduler = Local::take();\n-            sched.resume_blocked_task_immediately(cx.task.take_unwrap());\n+            wakeup(&mut cx.task);\n         }\n     }\n \n@@ -640,18 +632,13 @@ impl Drop for UdpWatcher {\n     }\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-/// UV request support\n-////////////////////////////////////////////////////////////////////////////////\n-\n #[cfg(test)]\n mod test {\n-    use std::rt::test::*;\n     use std::rt::rtio::{RtioTcpStream, RtioTcpListener, RtioTcpAcceptor,\n                         RtioUdpSocket};\n-    use std::task;\n+    use std::io::test::{next_test_ip4, next_test_ip6};\n \n-    use super::*;\n+    use super::{UdpWatcher, TcpWatcher, TcpListener};\n     use super::super::local_loop;\n \n     #[test]\n@@ -824,7 +811,6 @@ mod test {\n \n     #[test]\n     fn test_read_read_read() {\n-        use std::rt::rtio::*;\n         let addr = next_test_ip4();\n         static MAX: uint = 5000;\n         let (port, chan) = Chan::new();\n@@ -843,20 +829,18 @@ mod test {\n             }\n         }\n \n-        do spawn {\n-            port.recv();\n-            let mut stream = TcpWatcher::connect(local_loop(), addr).unwrap();\n-            let mut buf = [0, .. 2048];\n-            let mut total_bytes_read = 0;\n-            while total_bytes_read < MAX {\n-                let nread = stream.read(buf).unwrap();\n-                total_bytes_read += nread;\n-                for i in range(0u, nread) {\n-                    assert_eq!(buf[i], 1);\n-                }\n+        port.recv();\n+        let mut stream = TcpWatcher::connect(local_loop(), addr).unwrap();\n+        let mut buf = [0, .. 2048];\n+        let mut total_bytes_read = 0;\n+        while total_bytes_read < MAX {\n+            let nread = stream.read(buf).unwrap();\n+            total_bytes_read += nread;\n+            for i in range(0u, nread) {\n+                assert_eq!(buf[i], 1);\n             }\n-            uvdebug!(\"read {} bytes total\", total_bytes_read);\n         }\n+        uvdebug!(\"read {} bytes total\", total_bytes_read);\n     }\n \n     #[test]\n@@ -922,65 +906,35 @@ mod test {\n             assert!(total_bytes_sent >= MAX);\n         }\n \n-        do spawn {\n-            let l = local_loop();\n-            let mut client_out = UdpWatcher::bind(l, client_out_addr).unwrap();\n-            let mut client_in = UdpWatcher::bind(l, client_in_addr).unwrap();\n-            let (port, chan) = (p2, c1);\n-            port.recv();\n-            chan.send(());\n-            let mut total_bytes_recv = 0;\n-            let mut buf = [0, .. 2048];\n-            while total_bytes_recv < MAX {\n-                // ask for more\n-                assert!(client_out.sendto([1], server_in_addr).is_ok());\n-                // wait for data\n-                let res = client_in.recvfrom(buf);\n-                assert!(res.is_ok());\n-                let (nread, src) = res.unwrap();\n-                assert_eq!(src, server_out_addr);\n-                total_bytes_recv += nread;\n-                for i in range(0u, nread) {\n-                    assert_eq!(buf[i], 1);\n-                }\n+        let l = local_loop();\n+        let mut client_out = UdpWatcher::bind(l, client_out_addr).unwrap();\n+        let mut client_in = UdpWatcher::bind(l, client_in_addr).unwrap();\n+        let (port, chan) = (p2, c1);\n+        port.recv();\n+        chan.send(());\n+        let mut total_bytes_recv = 0;\n+        let mut buf = [0, .. 2048];\n+        while total_bytes_recv < MAX {\n+            // ask for more\n+            assert!(client_out.sendto([1], server_in_addr).is_ok());\n+            // wait for data\n+            let res = client_in.recvfrom(buf);\n+            assert!(res.is_ok());\n+            let (nread, src) = res.unwrap();\n+            assert_eq!(src, server_out_addr);\n+            total_bytes_recv += nread;\n+            for i in range(0u, nread) {\n+                assert_eq!(buf[i], 1);\n             }\n-            // tell the server we're done\n-            assert!(client_out.sendto([0], server_in_addr).is_ok());\n         }\n+        // tell the server we're done\n+        assert!(client_out.sendto([0], server_in_addr).is_ok());\n     }\n \n     #[test]\n     fn test_read_and_block() {\n         let addr = next_test_ip4();\n-        let (port, chan) = Chan::new();\n-\n-        do spawn {\n-            let listener = TcpListener::bind(local_loop(), addr).unwrap();\n-            let mut acceptor = listener.listen().unwrap();\n-            let (port2, chan2) = Chan::new();\n-            chan.send(port2);\n-            let mut stream = acceptor.accept().unwrap();\n-            let mut buf = [0, .. 2048];\n-\n-            let expected = 32;\n-            let mut current = 0;\n-            let mut reads = 0;\n-\n-            while current < expected {\n-                let nread = stream.read(buf).unwrap();\n-                for i in range(0u, nread) {\n-                    let val = buf[i] as uint;\n-                    assert_eq!(val, current % 8);\n-                    current += 1;\n-                }\n-                reads += 1;\n-\n-                chan2.send(());\n-            }\n-\n-            // Make sure we had multiple reads\n-            assert!(reads > 1);\n-        }\n+        let (port, chan) = Chan::<Port<()>>::new();\n \n         do spawn {\n             let port2 = port.recv();\n@@ -992,13 +946,39 @@ mod test {\n             stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n             port2.recv();\n         }\n+\n+        let listener = TcpListener::bind(local_loop(), addr).unwrap();\n+        let mut acceptor = listener.listen().unwrap();\n+        let (port2, chan2) = Chan::new();\n+        chan.send(port2);\n+        let mut stream = acceptor.accept().unwrap();\n+        let mut buf = [0, .. 2048];\n+\n+        let expected = 32;\n+        let mut current = 0;\n+        let mut reads = 0;\n+\n+        while current < expected {\n+            let nread = stream.read(buf).unwrap();\n+            for i in range(0u, nread) {\n+                let val = buf[i] as uint;\n+                assert_eq!(val, current % 8);\n+                current += 1;\n+            }\n+            reads += 1;\n+\n+            chan2.try_send(());\n+        }\n+\n+        // Make sure we had multiple reads\n+        assert!(reads > 1);\n     }\n \n     #[test]\n     fn test_simple_tcp_server_and_client_on_diff_threads() {\n         let addr = next_test_ip4();\n \n-        do task::spawn_sched(task::SingleThreaded) {\n+        do spawn {\n             let listener = TcpListener::bind(local_loop(), addr).unwrap();\n             let mut acceptor = listener.listen().unwrap();\n             let mut stream = acceptor.accept().unwrap();\n@@ -1010,131 +990,11 @@ mod test {\n             }\n         }\n \n-        do task::spawn_sched(task::SingleThreaded) {\n-            let mut stream = TcpWatcher::connect(local_loop(), addr);\n-            while stream.is_err() {\n-                stream = TcpWatcher::connect(local_loop(), addr);\n-            }\n-            stream.unwrap().write([0, 1, 2, 3, 4, 5, 6, 7]);\n-        }\n-    }\n-\n-    // On one thread, create a udp socket. Then send that socket to another\n-    // thread and destroy the socket on the remote thread. This should make sure\n-    // that homing kicks in for the socket to go back home to the original\n-    // thread, close itself, and then come back to the last thread.\n-    #[test]\n-    fn test_homing_closes_correctly() {\n-        let (port, chan) = Chan::new();\n-\n-        do task::spawn_sched(task::SingleThreaded) {\n-            let listener = UdpWatcher::bind(local_loop(), next_test_ip4()).unwrap();\n-            chan.send(listener);\n-        }\n-\n-        do task::spawn_sched(task::SingleThreaded) {\n-            port.recv();\n-        }\n-    }\n-\n-    // This is a bit of a crufty old test, but it has its uses.\n-    #[test]\n-    fn test_simple_homed_udp_io_bind_then_move_task_then_home_and_close() {\n-        use std::cast;\n-        use std::rt::local::Local;\n-        use std::rt::rtio::{EventLoop, IoFactory};\n-        use std::rt::sched::Scheduler;\n-        use std::rt::sched::{Shutdown, TaskFromFriend};\n-        use std::rt::sleeper_list::SleeperList;\n-        use std::rt::task::Task;\n-        use std::rt::thread::Thread;\n-        use std::rt::deque::BufferPool;\n-        use std::task::TaskResult;\n-        use std::unstable::run_in_bare_thread;\n-        use uvio::UvEventLoop;\n-\n-        do run_in_bare_thread {\n-            let sleepers = SleeperList::new();\n-            let mut pool = BufferPool::new();\n-            let (worker1, stealer1) = pool.deque();\n-            let (worker2, stealer2) = pool.deque();\n-            let queues = ~[stealer1, stealer2];\n-\n-            let loop1 = ~UvEventLoop::new() as ~EventLoop;\n-            let mut sched1 = ~Scheduler::new(loop1, worker1, queues.clone(),\n-                                             sleepers.clone());\n-            let loop2 = ~UvEventLoop::new() as ~EventLoop;\n-            let mut sched2 = ~Scheduler::new(loop2, worker2, queues.clone(),\n-                                             sleepers.clone());\n-\n-            let handle1 = sched1.make_handle();\n-            let handle2 = sched2.make_handle();\n-            let tasksFriendHandle = sched2.make_handle();\n-\n-            let on_exit: proc(TaskResult) = proc(exit_status) {\n-                let mut handle1 = handle1;\n-                let mut handle2 = handle2;\n-                handle1.send(Shutdown);\n-                handle2.send(Shutdown);\n-                assert!(exit_status.is_ok());\n-            };\n-\n-            unsafe fn local_io() -> &'static mut IoFactory {\n-                let mut sched = Local::borrow(None::<Scheduler>);\n-                let io = sched.get().event_loop.io();\n-                cast::transmute(io.unwrap())\n-            }\n-\n-            let test_function: proc() = proc() {\n-                let io = unsafe { local_io() };\n-                let addr = next_test_ip4();\n-                let maybe_socket = io.udp_bind(addr);\n-                // this socket is bound to this event loop\n-                assert!(maybe_socket.is_ok());\n-\n-                // block self on sched1\n-                let scheduler: ~Scheduler = Local::take();\n-                let mut tasksFriendHandle = Some(tasksFriendHandle);\n-                scheduler.deschedule_running_task_and_then(|_, task| {\n-                    // unblock task\n-                    task.wake().map(|task| {\n-                        // send self to sched2\n-                        tasksFriendHandle.take_unwrap()\n-                                         .send(TaskFromFriend(task));\n-                    });\n-                    // sched1 should now sleep since it has nothing else to do\n-                })\n-                // sched2 will wake up and get the task as we do nothing else,\n-                // the function ends and the socket goes out of scope sched2\n-                // will start to run the destructor the destructor will first\n-                // block the task, set it's home as sched1, then enqueue it\n-                // sched2 will dequeue the task, see that it has a home, and\n-                // send it to sched1 sched1 will wake up, exec the close\n-                // function on the correct loop, and then we're done\n-            };\n-\n-            let mut main_task = ~Task::new_root(&mut sched1.stack_pool, None,\n-                                                test_function);\n-            main_task.death.on_exit = Some(on_exit);\n-\n-            let null_task = ~do Task::new_root(&mut sched2.stack_pool, None) {\n-                // nothing\n-            };\n-\n-            let main_task = main_task;\n-            let sched1 = sched1;\n-            let thread1 = do Thread::start {\n-                sched1.bootstrap(main_task);\n-            };\n-\n-            let sched2 = sched2;\n-            let thread2 = do Thread::start {\n-                sched2.bootstrap(null_task);\n-            };\n-\n-            thread1.join();\n-            thread2.join();\n+        let mut stream = TcpWatcher::connect(local_loop(), addr);\n+        while stream.is_err() {\n+            stream = TcpWatcher::connect(local_loop(), addr);\n         }\n+        stream.unwrap().write([0, 1, 2, 3, 4, 5, 6, 7]);\n     }\n \n     #[should_fail] #[test]\n@@ -1176,75 +1036,12 @@ mod test {\n         // force the handle to be created on a different scheduler, failure in\n         // the original task will force a homing operation back to this\n         // scheduler.\n-        do task::spawn_sched(task::SingleThreaded) {\n+        do spawn {\n             let w = UdpWatcher::bind(local_loop(), addr).unwrap();\n             chan.send(w);\n         }\n \n         let _w = port.recv();\n         fail!();\n     }\n-\n-    #[should_fail]\n-    #[test]\n-    #[ignore(reason = \"linked failure\")]\n-    fn linked_failure1() {\n-        let (port, chan) = Chan::new();\n-        let addr = next_test_ip4();\n-\n-        do spawn {\n-            let w = TcpListener::bind(local_loop(), addr).unwrap();\n-            let mut w = w.listen().unwrap();\n-            chan.send(());\n-            w.accept();\n-        }\n-\n-        port.recv();\n-        fail!();\n-    }\n-\n-    #[should_fail]\n-    #[test]\n-    #[ignore(reason = \"linked failure\")]\n-    fn linked_failure2() {\n-        let (port, chan) = Chan::new();\n-        let addr = next_test_ip4();\n-\n-        do spawn {\n-            let w = TcpListener::bind(local_loop(), addr).unwrap();\n-            let mut w = w.listen().unwrap();\n-            chan.send(());\n-            let mut buf = [0];\n-            w.accept().unwrap().read(buf);\n-        }\n-\n-        port.recv();\n-        let _w = TcpWatcher::connect(local_loop(), addr).unwrap();\n-\n-        fail!();\n-    }\n-\n-    #[should_fail]\n-    #[test]\n-    #[ignore(reason = \"linked failure\")]\n-    fn linked_failure3() {\n-        let (port, chan) = Chan::new();\n-        let addr = next_test_ip4();\n-\n-        do spawn {\n-            let chan = chan;\n-            let w = TcpListener::bind(local_loop(), addr).unwrap();\n-            let mut w = w.listen().unwrap();\n-            chan.send(());\n-            let mut conn = w.accept().unwrap();\n-            chan.send(());\n-            let buf = [0, ..65536];\n-            conn.write(buf);\n-        }\n-\n-        port.recv();\n-        let _w = TcpWatcher::connect(local_loop(), addr).unwrap();\n-        port.recv();\n-        fail!();\n-    }\n }"}, {"sha": "ff4481e8b97f45b588239b294f56a47590c0e595", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -9,35 +9,33 @@\n // except according to those terms.\n \n use std::c_str::CString;\n-use std::libc;\n-use std::rt::BlockedTask;\n use std::io::IoError;\n-use std::rt::local::Local;\n+use std::libc;\n use std::rt::rtio::{RtioPipe, RtioUnixListener, RtioUnixAcceptor};\n-use std::rt::sched::{Scheduler, SchedHandle};\n-use std::rt::tube::Tube;\n+use std::rt::task::BlockedTask;\n \n+use homing::{HomingIO, HomeHandle};\n use stream::StreamWatcher;\n use super::{Loop, UvError, UvHandle, Request, uv_error_to_io_error,\n-            wait_until_woken_after};\n-use uvio::HomingIO;\n+            wait_until_woken_after, wakeup};\n+use uvio::UvIoFactory;\n use uvll;\n \n pub struct PipeWatcher {\n     stream: StreamWatcher,\n-    home: SchedHandle,\n+    home: HomeHandle,\n     priv defused: bool,\n }\n \n pub struct PipeListener {\n-    home: SchedHandle,\n+    home: HomeHandle,\n     pipe: *uvll::uv_pipe_t,\n-    priv outgoing: Tube<Result<~RtioPipe, IoError>>,\n+    priv outgoing: Chan<Result<~RtioPipe, IoError>>,\n+    priv incoming: Port<Result<~RtioPipe, IoError>>,\n }\n \n pub struct PipeAcceptor {\n     listener: ~PipeListener,\n-    priv incoming: Tube<Result<~RtioPipe, IoError>>,\n }\n \n // PipeWatcher implementation and traits\n@@ -46,7 +44,12 @@ impl PipeWatcher {\n     // Creates an uninitialized pipe watcher. The underlying uv pipe is ready to\n     // get bound to some other source (this is normally a helper method paired\n     // with another call).\n-    pub fn new(loop_: &Loop, ipc: bool) -> PipeWatcher {\n+    pub fn new(io: &mut UvIoFactory, ipc: bool) -> PipeWatcher {\n+        let home = io.make_handle();\n+        PipeWatcher::new_home(&io.loop_, home, ipc)\n+    }\n+\n+    pub fn new_home(loop_: &Loop, home: HomeHandle, ipc: bool) -> PipeWatcher {\n         let handle = unsafe {\n             let handle = uvll::malloc_handle(uvll::UV_NAMED_PIPE);\n             assert!(!handle.is_null());\n@@ -56,26 +59,28 @@ impl PipeWatcher {\n         };\n         PipeWatcher {\n             stream: StreamWatcher::new(handle),\n-            home: get_handle_to_current_scheduler!(),\n+            home: home,\n             defused: false,\n         }\n     }\n \n-    pub fn open(loop_: &Loop, file: libc::c_int) -> Result<PipeWatcher, UvError>\n+    pub fn open(io: &mut UvIoFactory, file: libc::c_int)\n+        -> Result<PipeWatcher, UvError>\n     {\n-        let pipe = PipeWatcher::new(loop_, false);\n+        let pipe = PipeWatcher::new(io, false);\n         match unsafe { uvll::uv_pipe_open(pipe.handle(), file) } {\n             0 => Ok(pipe),\n             n => Err(UvError(n))\n         }\n     }\n \n-    pub fn connect(loop_: &Loop, name: &CString) -> Result<PipeWatcher, UvError>\n+    pub fn connect(io: &mut UvIoFactory, name: &CString)\n+        -> Result<PipeWatcher, UvError>\n     {\n         struct Ctx { task: Option<BlockedTask>, result: libc::c_int, }\n         let mut cx = Ctx { task: None, result: 0 };\n         let mut req = Request::new(uvll::UV_CONNECT);\n-        let pipe = PipeWatcher::new(loop_, false);\n+        let pipe = PipeWatcher::new(io, false);\n \n         wait_until_woken_after(&mut cx.task, || {\n             unsafe {\n@@ -97,8 +102,7 @@ impl PipeWatcher {\n             assert!(status != uvll::ECANCELED);\n             let cx: &mut Ctx = unsafe { req.get_data() };\n             cx.result = status;\n-            let sched: ~Scheduler = Local::take();\n-            sched.resume_blocked_task_immediately(cx.task.take_unwrap());\n+            wakeup(&mut cx.task);\n         }\n     }\n \n@@ -125,7 +129,7 @@ impl RtioPipe for PipeWatcher {\n }\n \n impl HomingIO for PipeWatcher {\n-    fn home<'a>(&'a mut self) -> &'a mut SchedHandle { &mut self.home }\n+    fn home<'a>(&'a mut self) -> &'a mut HomeHandle { &mut self.home }\n }\n \n impl UvHandle<uvll::uv_pipe_t> for PipeWatcher {\n@@ -144,19 +148,23 @@ impl Drop for PipeWatcher {\n // PipeListener implementation and traits\n \n impl PipeListener {\n-    pub fn bind(loop_: &Loop, name: &CString) -> Result<~PipeListener, UvError> {\n-        let pipe = PipeWatcher::new(loop_, false);\n+    pub fn bind(io: &mut UvIoFactory, name: &CString)\n+        -> Result<~PipeListener, UvError>\n+    {\n+        let pipe = PipeWatcher::new(io, false);\n         match unsafe {\n             uvll::uv_pipe_bind(pipe.handle(), name.with_ref(|p| p))\n         } {\n             0 => {\n                 // If successful, unwrap the PipeWatcher because we control how\n                 // we close the pipe differently. We can't rely on\n                 // StreamWatcher's default close method.\n+                let (port, chan) = Chan::new();\n                 let p = ~PipeListener {\n-                    home: get_handle_to_current_scheduler!(),\n+                    home: io.make_handle(),\n                     pipe: pipe.unwrap(),\n-                    outgoing: Tube::new(),\n+                    incoming: port,\n+                    outgoing: chan,\n                 };\n                 Ok(p.install())\n             }\n@@ -168,11 +176,7 @@ impl PipeListener {\n impl RtioUnixListener for PipeListener {\n     fn listen(mut ~self) -> Result<~RtioUnixAcceptor, IoError> {\n         // create the acceptor object from ourselves\n-        let incoming = self.outgoing.clone();\n-        let mut acceptor = ~PipeAcceptor {\n-            listener: self,\n-            incoming: incoming,\n-        };\n+        let mut acceptor = ~PipeAcceptor { listener: self };\n \n         let _m = acceptor.fire_homing_missile();\n         // XXX: the 128 backlog should be configurable\n@@ -184,7 +188,7 @@ impl RtioUnixListener for PipeListener {\n }\n \n impl HomingIO for PipeListener {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n }\n \n impl UvHandle<uvll::uv_pipe_t> for PipeListener {\n@@ -193,19 +197,19 @@ impl UvHandle<uvll::uv_pipe_t> for PipeListener {\n \n extern fn listen_cb(server: *uvll::uv_stream_t, status: libc::c_int) {\n     assert!(status != uvll::ECANCELED);\n+\n+    let pipe: &mut PipeListener = unsafe { UvHandle::from_uv_handle(&server) };\n     let msg = match status {\n         0 => {\n             let loop_ = Loop::wrap(unsafe {\n                 uvll::get_loop_for_uv_handle(server)\n             });\n-            let client = PipeWatcher::new(&loop_, false);\n+            let client = PipeWatcher::new_home(&loop_, pipe.home().clone(), false);\n             assert_eq!(unsafe { uvll::uv_accept(server, client.handle()) }, 0);\n             Ok(~client as ~RtioPipe)\n         }\n         n => Err(uv_error_to_io_error(UvError(n)))\n     };\n-\n-    let pipe: &mut PipeListener = unsafe { UvHandle::from_uv_handle(&server) };\n     pipe.outgoing.send(msg);\n }\n \n@@ -220,21 +224,20 @@ impl Drop for PipeListener {\n \n impl RtioUnixAcceptor for PipeAcceptor {\n     fn accept(&mut self) -> Result<~RtioPipe, IoError> {\n-        let _m = self.fire_homing_missile();\n-        self.incoming.recv()\n+        self.listener.incoming.recv()\n     }\n }\n \n impl HomingIO for PipeAcceptor {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.listener.home() }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.listener.home }\n }\n \n #[cfg(test)]\n mod tests {\n     use std::rt::rtio::{RtioUnixListener, RtioUnixAcceptor, RtioPipe};\n-    use std::rt::test::next_test_unix;\n+    use std::io::test::next_test_unix;\n \n-    use super::*;\n+    use super::{PipeWatcher, PipeListener};\n     use super::super::local_loop;\n \n     #[test]"}, {"sha": "7b7a16d7084e5aa8da28c5e64d246e369719f410", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -8,40 +8,39 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::io::IoError;\n+use std::io::process;\n use std::libc::c_int;\n use std::libc;\n use std::ptr;\n-use std::rt::BlockedTask;\n-use std::io::IoError;\n-use std::io::process::*;\n-use std::rt::local::Local;\n use std::rt::rtio::RtioProcess;\n-use std::rt::sched::{Scheduler, SchedHandle};\n+use std::rt::task::BlockedTask;\n use std::vec;\n \n-use super::{Loop, UvHandle, UvError, uv_error_to_io_error,\n-            wait_until_woken_after};\n-use uvio::HomingIO;\n-use uvll;\n+use homing::{HomingIO, HomeHandle};\n use pipe::PipeWatcher;\n+use super::{UvHandle, UvError, uv_error_to_io_error,\n+            wait_until_woken_after, wakeup};\n+use uvio::UvIoFactory;\n+use uvll;\n \n pub struct Process {\n     handle: *uvll::uv_process_t,\n-    home: SchedHandle,\n+    home: HomeHandle,\n \n     /// Task to wake up (may be null) for when the process exits\n     to_wake: Option<BlockedTask>,\n \n     /// Collected from the exit_cb\n-    exit_status: Option<ProcessExit>,\n+    exit_status: Option<process::ProcessExit>,\n }\n \n impl Process {\n     /// Spawn a new process inside the specified event loop.\n     ///\n     /// Returns either the corresponding process object or an error which\n     /// occurred.\n-    pub fn spawn(loop_: &Loop, config: ProcessConfig)\n+    pub fn spawn(io_loop: &mut UvIoFactory, config: process::ProcessConfig)\n                 -> Result<(~Process, ~[Option<PipeWatcher>]), UvError>\n     {\n         let cwd = config.cwd.map(|s| s.to_c_str());\n@@ -52,7 +51,7 @@ impl Process {\n             stdio.set_len(io.len());\n             for (slot, other) in stdio.iter().zip(io.iter()) {\n                 let io = set_stdio(slot as *uvll::uv_stdio_container_t, other,\n-                                   loop_);\n+                                   io_loop);\n                 ret_io.push(io);\n             }\n         }\n@@ -78,12 +77,12 @@ impl Process {\n                 let handle = UvHandle::alloc(None::<Process>, uvll::UV_PROCESS);\n                 let process = ~Process {\n                     handle: handle,\n-                    home: get_handle_to_current_scheduler!(),\n+                    home: io_loop.make_handle(),\n                     to_wake: None,\n                     exit_status: None,\n                 };\n                 match unsafe {\n-                    uvll::uv_spawn(loop_.handle, handle, &options)\n+                    uvll::uv_spawn(io_loop.uv_loop(), handle, &options)\n                 } {\n                     0 => Ok(process.install()),\n                     err => Err(UvError(err)),\n@@ -105,41 +104,36 @@ extern fn on_exit(handle: *uvll::uv_process_t,\n \n     assert!(p.exit_status.is_none());\n     p.exit_status = Some(match term_signal {\n-        0 => ExitStatus(exit_status as int),\n-        n => ExitSignal(n as int),\n+        0 => process::ExitStatus(exit_status as int),\n+        n => process::ExitSignal(n as int),\n     });\n \n-    match p.to_wake.take() {\n-        Some(task) => {\n-            let scheduler: ~Scheduler = Local::take();\n-            scheduler.resume_blocked_task_immediately(task);\n-        }\n-        None => {}\n-    }\n+    if p.to_wake.is_none() { return }\n+    wakeup(&mut p.to_wake);\n }\n \n unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t,\n-                    io: &StdioContainer,\n-                    loop_: &Loop) -> Option<PipeWatcher> {\n+                    io: &process::StdioContainer,\n+                    io_loop: &mut UvIoFactory) -> Option<PipeWatcher> {\n     match *io {\n-        Ignored => {\n+        process::Ignored => {\n             uvll::set_stdio_container_flags(dst, uvll::STDIO_IGNORE);\n             None\n         }\n-        InheritFd(fd) => {\n+        process::InheritFd(fd) => {\n             uvll::set_stdio_container_flags(dst, uvll::STDIO_INHERIT_FD);\n             uvll::set_stdio_container_fd(dst, fd);\n             None\n         }\n-        CreatePipe(readable, writable) => {\n+        process::CreatePipe(readable, writable) => {\n             let mut flags = uvll::STDIO_CREATE_PIPE as libc::c_int;\n             if readable {\n                 flags |= uvll::STDIO_READABLE_PIPE as libc::c_int;\n             }\n             if writable {\n                 flags |= uvll::STDIO_WRITABLE_PIPE as libc::c_int;\n             }\n-            let pipe = PipeWatcher::new(loop_, false);\n+            let pipe = PipeWatcher::new(io_loop, false);\n             uvll::set_stdio_container_flags(dst, flags);\n             uvll::set_stdio_container_stream(dst, pipe.handle());\n             Some(pipe)\n@@ -186,7 +180,7 @@ fn with_env<T>(env: Option<&[(~str, ~str)]>, f: |**libc::c_char| -> T) -> T {\n }\n \n impl HomingIO for Process {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n }\n \n impl UvHandle<uvll::uv_process_t> for Process {\n@@ -208,7 +202,7 @@ impl RtioProcess for Process {\n         }\n     }\n \n-    fn wait(&mut self) -> ProcessExit {\n+    fn wait(&mut self) -> process::ProcessExit {\n         // Make sure (on the home scheduler) that we have an exit status listed\n         let _m = self.fire_homing_missile();\n         match self.exit_status {"}, {"sha": "32f8d8532a209f83448ec745e940d359fe3aeb43", "filename": "src/librustuv/queue.rs", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fqueue.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -0,0 +1,192 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A concurrent queue used to signal remote event loops\n+//!\n+//! This queue implementation is used to send tasks among event loops. This is\n+//! backed by a multi-producer/single-consumer queue from libstd and uv_async_t\n+//! handles (to wake up a remote event loop).\n+//!\n+//! The uv_async_t is stored next to the event loop, so in order to not keep the\n+//! event loop alive we use uv_ref and uv_unref in order to control when the\n+//! async handle is active or not.\n+\n+#[allow(dead_code)];\n+\n+use std::cast;\n+use std::libc::{c_void, c_int};\n+use std::rt::task::BlockedTask;\n+use std::unstable::sync::LittleLock;\n+use mpsc = std::sync::mpsc_queue;\n+\n+use async::AsyncWatcher;\n+use super::{Loop, UvHandle};\n+use uvll;\n+\n+enum Message {\n+    Task(BlockedTask),\n+    Increment,\n+    Decrement,\n+}\n+\n+struct State {\n+    handle: *uvll::uv_async_t,\n+    lock: LittleLock, // see comments in async_cb for why this is needed\n+}\n+\n+/// This structure is intended to be stored next to the event loop, and it is\n+/// used to create new `Queue` structures.\n+pub struct QueuePool {\n+    priv producer: mpsc::Producer<Message, State>,\n+    priv consumer: mpsc::Consumer<Message, State>,\n+    priv refcnt: uint,\n+}\n+\n+/// This type is used to send messages back to the original event loop.\n+pub struct Queue {\n+    priv queue: mpsc::Producer<Message, State>,\n+}\n+\n+extern fn async_cb(handle: *uvll::uv_async_t, status: c_int) {\n+    assert_eq!(status, 0);\n+    let state: &mut QueuePool = unsafe {\n+        cast::transmute(uvll::get_data_for_uv_handle(handle))\n+    };\n+    let packet = unsafe { state.consumer.packet() };\n+\n+    // Remember that there is no guarantee about how many times an async\n+    // callback is called with relation to the number of sends, so process the\n+    // entire queue in a loop.\n+    loop {\n+        match state.consumer.pop() {\n+            mpsc::Data(Task(task)) => {\n+                task.wake().map(|t| t.reawaken(true));\n+            }\n+            mpsc::Data(Increment) => unsafe {\n+                if state.refcnt == 0 {\n+                    uvll::uv_ref((*packet).handle);\n+                }\n+                state.refcnt += 1;\n+            },\n+            mpsc::Data(Decrement) => unsafe {\n+                state.refcnt -= 1;\n+                if state.refcnt == 0 {\n+                    uvll::uv_unref((*packet).handle);\n+                }\n+            },\n+            mpsc::Empty | mpsc::Inconsistent => break\n+        };\n+    }\n+\n+    // If the refcount is now zero after processing the queue, then there is no\n+    // longer a reference on the async handle and it is possible that this event\n+    // loop can exit. What we're not guaranteed, however, is that a producer in\n+    // the middle of dropping itself is yet done with the handle. It could be\n+    // possible that we saw their Decrement message but they have yet to signal\n+    // on the async handle. If we were to return immediately, the entire uv loop\n+    // could be destroyed meaning the call to uv_async_send would abort()\n+    //\n+    // In order to fix this, an OS mutex is used to wait for the other end to\n+    // finish before we continue. The drop block on a handle will acquire a\n+    // mutex and then drop it after both the push and send have been completed.\n+    // If we acquire the mutex here, then we are guaranteed that there are no\n+    // longer any senders which are holding on to their handles, so we can\n+    // safely allow the event loop to exit.\n+    if state.refcnt == 0 {\n+        unsafe {\n+            let _l = (*packet).lock.lock();\n+        }\n+    }\n+}\n+\n+impl QueuePool {\n+    pub fn new(loop_: &mut Loop) -> ~QueuePool {\n+        let handle = UvHandle::alloc(None::<AsyncWatcher>, uvll::UV_ASYNC);\n+        let (c, p) = mpsc::queue(State {\n+            handle: handle,\n+            lock: LittleLock::new(),\n+        });\n+        let q = ~QueuePool {\n+            producer: p,\n+            consumer: c,\n+            refcnt: 0,\n+        };\n+\n+        unsafe {\n+            assert_eq!(uvll::uv_async_init(loop_.handle, handle, async_cb), 0);\n+            uvll::uv_unref(handle);\n+            let data: *c_void = *cast::transmute::<&~QueuePool, &*c_void>(&q);\n+            uvll::set_data_for_uv_handle(handle, data);\n+        }\n+\n+        return q;\n+    }\n+\n+    pub fn queue(&mut self) -> Queue {\n+        unsafe {\n+            if self.refcnt == 0 {\n+                uvll::uv_ref((*self.producer.packet()).handle);\n+            }\n+            self.refcnt += 1;\n+        }\n+        Queue { queue: self.producer.clone() }\n+    }\n+\n+    pub fn handle(&self) -> *uvll::uv_async_t {\n+        unsafe { (*self.producer.packet()).handle }\n+    }\n+}\n+\n+impl Queue {\n+    pub fn push(&mut self, task: BlockedTask) {\n+        self.queue.push(Task(task));\n+        unsafe {\n+            uvll::uv_async_send((*self.queue.packet()).handle);\n+        }\n+    }\n+}\n+\n+impl Clone for Queue {\n+    fn clone(&self) -> Queue {\n+        // Push a request to increment on the queue, but there's no need to\n+        // signal the event loop to process it at this time. We're guaranteed\n+        // that the count is at least one (because we have a queue right here),\n+        // and if the queue is dropped later on it'll see the increment for the\n+        // decrement anyway.\n+        unsafe {\n+            cast::transmute_mut(self).queue.push(Increment);\n+        }\n+        Queue { queue: self.queue.clone() }\n+    }\n+}\n+\n+impl Drop for Queue {\n+    fn drop(&mut self) {\n+        // See the comments in the async_cb function for why there is a lock\n+        // that is acquired only on a drop.\n+        unsafe {\n+            let state = self.queue.packet();\n+            let _l = (*state).lock.lock();\n+            self.queue.push(Decrement);\n+            uvll::uv_async_send((*state).handle);\n+        }\n+    }\n+}\n+\n+impl Drop for State {\n+    fn drop(&mut self) {\n+        unsafe {\n+            uvll::uv_close(self.handle, cast::transmute(0));\n+            // Note that this does *not* free the handle, that is the\n+            // responsibility of the caller because the uv loop must be closed\n+            // before we deallocate this uv handle.\n+        }\n+    }\n+}"}, {"sha": "6772c6d19361447a63b574a432c37281164792ed", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -10,34 +10,33 @@\n \n use std::libc::c_int;\n use std::io::signal::Signum;\n-use std::rt::sched::{SchedHandle, Scheduler};\n use std::comm::SharedChan;\n-use std::rt::local::Local;\n use std::rt::rtio::RtioSignal;\n \n-use super::{Loop, UvError, UvHandle};\n+use homing::{HomingIO, HomeHandle};\n+use super::{UvError, UvHandle};\n use uvll;\n-use uvio::HomingIO;\n+use uvio::UvIoFactory;\n \n pub struct SignalWatcher {\n     handle: *uvll::uv_signal_t,\n-    home: SchedHandle,\n+    home: HomeHandle,\n \n     channel: SharedChan<Signum>,\n     signal: Signum,\n }\n \n impl SignalWatcher {\n-    pub fn new(loop_: &mut Loop, signum: Signum,\n+    pub fn new(io: &mut UvIoFactory, signum: Signum,\n                channel: SharedChan<Signum>) -> Result<~SignalWatcher, UvError> {\n         let s = ~SignalWatcher {\n             handle: UvHandle::alloc(None::<SignalWatcher>, uvll::UV_SIGNAL),\n-            home: get_handle_to_current_scheduler!(),\n+            home: io.make_handle(),\n             channel: channel,\n             signal: signum,\n         };\n         assert_eq!(unsafe {\n-            uvll::uv_signal_init(loop_.handle, s.handle)\n+            uvll::uv_signal_init(io.uv_loop(), s.handle)\n         }, 0);\n \n         match unsafe {\n@@ -53,11 +52,11 @@ impl SignalWatcher {\n extern fn signal_cb(handle: *uvll::uv_signal_t, signum: c_int) {\n     let s: &mut SignalWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n     assert_eq!(signum as int, s.signal as int);\n-    s.channel.send_deferred(s.signal);\n+    s.channel.try_send(s.signal);\n }\n \n impl HomingIO for SignalWatcher {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n }\n \n impl UvHandle<uvll::uv_signal_t> for SignalWatcher {\n@@ -69,15 +68,15 @@ impl RtioSignal for SignalWatcher {}\n impl Drop for SignalWatcher {\n     fn drop(&mut self) {\n         let _m = self.fire_homing_missile();\n-        self.close_async_();\n+        self.close();\n     }\n }\n \n #[cfg(test)]\n mod test {\n-    use super::*;\n     use super::super::local_loop;\n     use std::io::signal;\n+    use super::SignalWatcher;\n \n     #[test]\n     fn closing_channel_during_drop_doesnt_kill_everything() {"}, {"sha": "73173fc677e8f786c782afc3388e0fd7b6132d76", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -11,12 +11,10 @@\n use std::cast;\n use std::libc::{c_int, size_t, ssize_t};\n use std::ptr;\n-use std::rt::BlockedTask;\n-use std::rt::local::Local;\n-use std::rt::sched::Scheduler;\n+use std::rt::task::BlockedTask;\n \n use super::{UvError, Buf, slice_to_uv_buf, Request, wait_until_woken_after,\n-            ForbidUnwind};\n+            ForbidUnwind, wakeup};\n use uvll;\n \n // This is a helper structure which is intended to get embedded into other\n@@ -164,8 +162,7 @@ extern fn read_cb(handle: *uvll::uv_stream_t, nread: ssize_t, _buf: *Buf) {\n     unsafe { assert_eq!(uvll::uv_read_stop(handle), 0); }\n     rcx.result = nread;\n \n-    let scheduler: ~Scheduler = Local::take();\n-    scheduler.resume_blocked_task_immediately(rcx.task.take_unwrap());\n+    wakeup(&mut rcx.task);\n }\n \n // Unlike reading, the WriteContext is stored in the uv_write_t request. Like\n@@ -180,6 +177,5 @@ extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n     wcx.result = status;\n     req.defuse();\n \n-    let sched: ~Scheduler = Local::take();\n-    sched.resume_blocked_task_immediately(wcx.task.take_unwrap());\n+    wakeup(&mut wcx.task);\n }"}, {"sha": "4a0ad44d311476212545183411d6d9dc4e945c00", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -9,19 +9,19 @@\n // except according to those terms.\n \n use std::libc::c_int;\n-use std::rt::BlockedTask;\n use std::rt::local::Local;\n use std::rt::rtio::RtioTimer;\n-use std::rt::sched::{Scheduler, SchedHandle};\n+use std::rt::task::{BlockedTask, Task};\n use std::util;\n \n+use homing::{HomeHandle, HomingIO};\n+use super::{UvHandle, ForbidUnwind, ForbidSwitch};\n+use uvio::UvIoFactory;\n use uvll;\n-use super::{Loop, UvHandle, ForbidUnwind, ForbidSwitch};\n-use uvio::HomingIO;\n \n pub struct TimerWatcher {\n     handle: *uvll::uv_timer_t,\n-    home: SchedHandle,\n+    home: HomeHandle,\n     action: Option<NextAction>,\n     id: uint, // see comments in timer_cb\n }\n@@ -33,15 +33,15 @@ pub enum NextAction {\n }\n \n impl TimerWatcher {\n-    pub fn new(loop_: &mut Loop) -> ~TimerWatcher {\n+    pub fn new(io: &mut UvIoFactory) -> ~TimerWatcher {\n         let handle = UvHandle::alloc(None::<TimerWatcher>, uvll::UV_TIMER);\n         assert_eq!(unsafe {\n-            uvll::uv_timer_init(loop_.handle, handle)\n+            uvll::uv_timer_init(io.uv_loop(), handle)\n         }, 0);\n         let me = ~TimerWatcher {\n             handle: handle,\n             action: None,\n-            home: get_handle_to_current_scheduler!(),\n+            home: io.make_handle(),\n             id: 0,\n         };\n         return me.install();\n@@ -59,7 +59,7 @@ impl TimerWatcher {\n }\n \n impl HomingIO for TimerWatcher {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n }\n \n impl UvHandle<uvll::uv_timer_t> for TimerWatcher {\n@@ -89,10 +89,11 @@ impl RtioTimer for TimerWatcher {\n         // started, then we need to call stop on the timer.\n         let _f = ForbidUnwind::new(\"timer\");\n \n-        let sched: ~Scheduler = Local::take();\n-        sched.deschedule_running_task_and_then(|_sched, task| {\n+        let task: ~Task = Local::take();\n+        task.deschedule(1, |task| {\n             self.action = Some(WakeTask(task));\n             self.start(msecs, 0);\n+            Ok(())\n         });\n         self.stop();\n     }\n@@ -137,12 +138,11 @@ extern fn timer_cb(handle: *uvll::uv_timer_t, status: c_int) {\n \n     match timer.action.take_unwrap() {\n         WakeTask(task) => {\n-            let sched: ~Scheduler = Local::take();\n-            sched.resume_blocked_task_immediately(task);\n+            task.wake().map(|t| t.reawaken(true));\n         }\n-        SendOnce(chan) => { chan.try_send_deferred(()); }\n+        SendOnce(chan) => { chan.try_send(()); }\n         SendMany(chan, id) => {\n-            chan.try_send_deferred(());\n+            chan.try_send(());\n \n             // Note that the above operation could have performed some form of\n             // scheduling. This means that the timer may have decided to insert\n@@ -169,17 +169,17 @@ impl Drop for TimerWatcher {\n         let _action = {\n             let _m = self.fire_homing_missile();\n             self.stop();\n-            self.close_async_();\n+            self.close();\n             self.action.take()\n         };\n     }\n }\n \n #[cfg(test)]\n mod test {\n-    use super::*;\n     use std::rt::rtio::RtioTimer;\n     use super::super::local_loop;\n+    use super::TimerWatcher;\n \n     #[test]\n     fn oneshot() {\n@@ -207,9 +207,9 @@ mod test {\n         let port = timer.period(1);\n         port.recv();\n         port.recv();\n-        let port = timer.period(1);\n-        port.recv();\n-        port.recv();\n+        let port2 = timer.period(1);\n+        port2.recv();\n+        port2.recv();\n     }\n \n     #[test]"}, {"sha": "0e76ed9feb93dfe78985e3cda7372a6063ae5e66", "filename": "src/librustuv/tty.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftty.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -10,24 +10,23 @@\n \n use std::libc;\n use std::io::IoError;\n-use std::rt::local::Local;\n use std::rt::rtio::RtioTTY;\n-use std::rt::sched::{Scheduler, SchedHandle};\n \n+use homing::{HomingIO, HomeHandle};\n use stream::StreamWatcher;\n-use super::{Loop, UvError, UvHandle, uv_error_to_io_error};\n-use uvio::HomingIO;\n+use super::{UvError, UvHandle, uv_error_to_io_error};\n+use uvio::UvIoFactory;\n use uvll;\n \n pub struct TtyWatcher{\n     tty: *uvll::uv_tty_t,\n     stream: StreamWatcher,\n-    home: SchedHandle,\n+    home: HomeHandle,\n     fd: libc::c_int,\n }\n \n impl TtyWatcher {\n-    pub fn new(loop_: &Loop, fd: libc::c_int, readable: bool)\n+    pub fn new(io: &mut UvIoFactory, fd: libc::c_int, readable: bool)\n         -> Result<TtyWatcher, UvError>\n     {\n         // libuv may succeed in giving us a handle (via uv_tty_init), but if the\n@@ -56,14 +55,14 @@ impl TtyWatcher {\n         // with attempting to open it as a tty.\n         let handle = UvHandle::alloc(None::<TtyWatcher>, uvll::UV_TTY);\n         match unsafe {\n-            uvll::uv_tty_init(loop_.handle, handle, fd as libc::c_int,\n+            uvll::uv_tty_init(io.uv_loop(), handle, fd as libc::c_int,\n                               readable as libc::c_int)\n         } {\n             0 => {\n                 Ok(TtyWatcher {\n                     tty: handle,\n                     stream: StreamWatcher::new(handle),\n-                    home: get_handle_to_current_scheduler!(),\n+                    home: io.make_handle(),\n                     fd: fd,\n                 })\n             }\n@@ -120,7 +119,7 @@ impl UvHandle<uvll::uv_tty_t> for TtyWatcher {\n }\n \n impl HomingIO for TtyWatcher {\n-    fn home<'a>(&'a mut self) -> &'a mut SchedHandle { &mut self.home }\n+    fn home<'a>(&'a mut self) -> &'a mut HomeHandle { &mut self.home }\n }\n \n impl Drop for TtyWatcher {"}, {"sha": "dbf129d0b699c81ee7f6785b0498b2f9f6503838", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 114, "deletions": 171, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -9,121 +9,41 @@\n // except according to those terms.\n \n use std::c_str::CString;\n+use std::cast;\n use std::comm::SharedChan;\n-use std::libc::c_int;\n-use std::libc;\n-use std::path::Path;\n use std::io::IoError;\n use std::io::net::ip::SocketAddr;\n use std::io::process::ProcessConfig;\n-use std::io;\n-use std::rt::local::Local;\n-use std::rt::rtio::*;\n-use std::rt::sched::{Scheduler, SchedHandle};\n-use std::rt::task::Task;\n-use std::libc::{O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY,\n-                S_IRUSR, S_IWUSR};\n-use std::io::{FileMode, FileAccess, Open, Append, Truncate, Read, Write,\n-                  ReadWrite, FileStat};\n use std::io::signal::Signum;\n+use std::io::{FileMode, FileAccess, Open, Append, Truncate, Read, Write,\n+              ReadWrite, FileStat};\n+use std::io;\n+use std::libc::c_int;\n+use std::libc::{O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY, S_IRUSR,\n+                S_IWUSR};\n+use std::libc;\n+use std::path::Path;\n+use std::rt::rtio;\n+use std::rt::rtio::IoFactory;\n use ai = std::io::net::addrinfo;\n \n #[cfg(test)] use std::unstable::run_in_bare_thread;\n \n-use super::*;\n-use addrinfo::GetAddrInfoRequest;\n-\n-pub trait HomingIO {\n-\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle;\n-\n-    /// This function will move tasks to run on their home I/O scheduler. Note\n-    /// that this function does *not* pin the task to the I/O scheduler, but\n-    /// rather it simply moves it to running on the I/O scheduler.\n-    fn go_to_IO_home(&mut self) -> uint {\n-        use std::rt::sched::RunOnce;\n-\n-        let _f = ForbidUnwind::new(\"going home\");\n-\n-        let current_sched_id = {\n-            let mut sched = Local::borrow(None::<Scheduler>);\n-            sched.get().sched_id()\n-        };\n-\n-        // Only need to invoke a context switch if we're not on the right\n-        // scheduler.\n-        if current_sched_id != self.home().sched_id {\n-            let scheduler: ~Scheduler = Local::take();\n-            scheduler.deschedule_running_task_and_then(|_, task| {\n-                task.wake().map(|task| {\n-                    self.home().send(RunOnce(task));\n-                });\n-            })\n-        }\n-        let current_sched_id = {\n-            let mut sched = Local::borrow(None::<Scheduler>);\n-            sched.get().sched_id()\n-        };\n-        assert!(current_sched_id == self.home().sched_id);\n-\n-        self.home().sched_id\n-    }\n-\n-    /// Fires a single homing missile, returning another missile targeted back\n-    /// at the original home of this task. In other words, this function will\n-    /// move the local task to its I/O scheduler and then return an RAII wrapper\n-    /// which will return the task home.\n-    fn fire_homing_missile(&mut self) -> HomingMissile {\n-        HomingMissile { io_home: self.go_to_IO_home() }\n-    }\n+use super::{uv_error_to_io_error, Loop};\n \n-    /// Same as `fire_homing_missile`, but returns the local I/O scheduler as\n-    /// well (the one that was homed to).\n-    fn fire_homing_missile_sched(&mut self) -> (HomingMissile, ~Scheduler) {\n-        // First, transplant ourselves to the home I/O scheduler\n-        let missile = self.fire_homing_missile();\n-        // Next (must happen next), grab the local I/O scheduler\n-        let io_sched: ~Scheduler = Local::take();\n-\n-        (missile, io_sched)\n-    }\n-}\n-\n-/// After a homing operation has been completed, this will return the current\n-/// task back to its appropriate home (if applicable). The field is used to\n-/// assert that we are where we think we are.\n-struct HomingMissile {\n-    priv io_home: uint,\n-}\n-\n-impl HomingMissile {\n-    pub fn check(&self, msg: &'static str) {\n-        let mut sched = Local::borrow(None::<Scheduler>);\n-        let local_id = sched.get().sched_id();\n-        assert!(local_id == self.io_home, \"{}\", msg);\n-    }\n-}\n-\n-impl Drop for HomingMissile {\n-    fn drop(&mut self) {\n-        let _f = ForbidUnwind::new(\"leaving home\");\n-\n-        // It would truly be a sad day if we had moved off the home I/O\n-        // scheduler while we were doing I/O.\n-        self.check(\"task moved away from the home scheduler\");\n-\n-        // If we were a homed task, then we must send ourselves back to the\n-        // original scheduler. Otherwise, we can just return and keep running\n-        if !Task::on_appropriate_sched() {\n-            let scheduler: ~Scheduler = Local::take();\n-            scheduler.deschedule_running_task_and_then(|_, task| {\n-                task.wake().map(|task| {\n-                    Scheduler::run_task(task);\n-                });\n-            })\n-        }\n-    }\n-}\n+use addrinfo::GetAddrInfoRequest;\n+use async::AsyncWatcher;\n+use file::{FsRequest, FileWatcher};\n+use queue::QueuePool;\n+use homing::HomeHandle;\n+use idle::IdleWatcher;\n+use net::{TcpWatcher, TcpListener, UdpWatcher};\n+use pipe::{PipeWatcher, PipeListener};\n+use process::Process;\n+use signal::SignalWatcher;\n+use timer::TimerWatcher;\n+use tty::TtyWatcher;\n+use uvll;\n \n // Obviously an Event Loop is always home.\n pub struct UvEventLoop {\n@@ -132,49 +52,65 @@ pub struct UvEventLoop {\n \n impl UvEventLoop {\n     pub fn new() -> UvEventLoop {\n+        let mut loop_ = Loop::new();\n+        let handle_pool = QueuePool::new(&mut loop_);\n         UvEventLoop {\n-            uvio: UvIoFactory(Loop::new())\n+            uvio: UvIoFactory {\n+                loop_: loop_,\n+                handle_pool: Some(handle_pool),\n+            }\n         }\n     }\n }\n \n impl Drop for UvEventLoop {\n     fn drop(&mut self) {\n-        self.uvio.uv_loop().close();\n+        // Must first destroy the pool of handles before we destroy the loop\n+        // because otherwise the contained async handle will be destroyed after\n+        // the loop is free'd (use-after-free). We also must free the uv handle\n+        // after the loop has been closed because during the closing of the loop\n+        // the handle is required to be used apparently.\n+        let handle = self.uvio.handle_pool.get_ref().handle();\n+        self.uvio.handle_pool.take();\n+        self.uvio.loop_.close();\n+        unsafe { uvll::free_handle(handle) }\n     }\n }\n \n-impl EventLoop for UvEventLoop {\n+impl rtio::EventLoop for UvEventLoop {\n     fn run(&mut self) {\n-        self.uvio.uv_loop().run();\n+        self.uvio.loop_.run();\n     }\n \n     fn callback(&mut self, f: proc()) {\n-        IdleWatcher::onetime(self.uvio.uv_loop(), f);\n+        IdleWatcher::onetime(&mut self.uvio.loop_, f);\n     }\n \n-    fn pausable_idle_callback(&mut self, cb: ~Callback) -> ~PausableIdleCallback {\n-        IdleWatcher::new(self.uvio.uv_loop(), cb) as ~PausableIdleCallback\n+    fn pausable_idle_callback(&mut self, cb: ~rtio::Callback)\n+        -> ~rtio::PausableIdleCallback\n+    {\n+        IdleWatcher::new(&mut self.uvio.loop_, cb) as ~rtio::PausableIdleCallback\n     }\n \n-    fn remote_callback(&mut self, f: ~Callback) -> ~RemoteCallback {\n-        ~AsyncWatcher::new(self.uvio.uv_loop(), f) as ~RemoteCallback\n+    fn remote_callback(&mut self, f: ~rtio::Callback) -> ~rtio::RemoteCallback {\n+        ~AsyncWatcher::new(&mut self.uvio.loop_, f) as ~rtio::RemoteCallback\n     }\n \n-    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory> {\n-        let factory = &mut self.uvio as &mut IoFactory;\n+    fn io<'a>(&'a mut self) -> Option<&'a mut rtio::IoFactory> {\n+        let factory = &mut self.uvio as &mut rtio::IoFactory;\n         Some(factory)\n     }\n }\n \n #[cfg(not(test))]\n #[lang = \"event_loop_factory\"]\n-pub extern \"C\" fn new_loop() -> ~EventLoop {\n-    ~UvEventLoop::new() as ~EventLoop\n+pub fn new_loop() -> ~rtio::EventLoop {\n+    ~UvEventLoop::new() as ~rtio::EventLoop\n }\n \n #[test]\n fn test_callback_run_once() {\n+    use std::rt::rtio::EventLoop;\n     do run_in_bare_thread {\n         let mut event_loop = UvEventLoop::new();\n         let mut count = 0;\n@@ -187,11 +123,19 @@ fn test_callback_run_once() {\n     }\n }\n \n-pub struct UvIoFactory(Loop);\n+pub struct UvIoFactory {\n+    loop_: Loop,\n+    priv handle_pool: Option<~QueuePool>,\n+}\n \n impl UvIoFactory {\n-    pub fn uv_loop<'a>(&'a mut self) -> &'a mut Loop {\n-        match self { &UvIoFactory(ref mut ptr) => ptr }\n+    pub fn uv_loop<'a>(&mut self) -> *uvll::uv_loop_t { self.loop_.handle }\n+\n+    pub fn make_handle(&mut self) -> HomeHandle {\n+        // It's understood by the homing code that the \"local id\" is just the\n+        // pointer of the local I/O factory cast to a uint.\n+        let id: uint = unsafe { cast::transmute_copy(&self) };\n+        HomeHandle::new(id, &mut **self.handle_pool.get_mut_ref())\n     }\n }\n \n@@ -200,46 +144,45 @@ impl IoFactory for UvIoFactory {\n     // NB: This blocks the task waiting on the connection.\n     // It would probably be better to return a future\n     fn tcp_connect(&mut self, addr: SocketAddr)\n-        -> Result<~RtioTcpStream, IoError>\n+        -> Result<~rtio::RtioTcpStream, IoError>\n     {\n-        match TcpWatcher::connect(self.uv_loop(), addr) {\n-            Ok(t) => Ok(~t as ~RtioTcpStream),\n+        match TcpWatcher::connect(self, addr) {\n+            Ok(t) => Ok(~t as ~rtio::RtioTcpStream),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~RtioTcpListener, IoError> {\n-        match TcpListener::bind(self.uv_loop(), addr) {\n-            Ok(t) => Ok(t as ~RtioTcpListener),\n+    fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~rtio::RtioTcpListener, IoError> {\n+        match TcpListener::bind(self, addr) {\n+            Ok(t) => Ok(t as ~rtio::RtioTcpListener),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocket, IoError> {\n-        match UdpWatcher::bind(self.uv_loop(), addr) {\n-            Ok(u) => Ok(~u as ~RtioUdpSocket),\n+    fn udp_bind(&mut self, addr: SocketAddr) -> Result<~rtio::RtioUdpSocket, IoError> {\n+        match UdpWatcher::bind(self, addr) {\n+            Ok(u) => Ok(~u as ~rtio::RtioUdpSocket),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn timer_init(&mut self) -> Result<~RtioTimer, IoError> {\n-        Ok(TimerWatcher::new(self.uv_loop()) as ~RtioTimer)\n+    fn timer_init(&mut self) -> Result<~rtio::RtioTimer, IoError> {\n+        Ok(TimerWatcher::new(self) as ~rtio::RtioTimer)\n     }\n \n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n                           hint: Option<ai::Hint>) -> Result<~[ai::Info], IoError> {\n-        let r = GetAddrInfoRequest::run(self.uv_loop(), host, servname, hint);\n+        let r = GetAddrInfoRequest::run(&self.loop_, host, servname, hint);\n         r.map_err(uv_error_to_io_error)\n     }\n \n     fn fs_from_raw_fd(&mut self, fd: c_int,\n-                      close: CloseBehavior) -> ~RtioFileStream {\n-        let loop_ = Loop::wrap(self.uv_loop().handle);\n-        ~FileWatcher::new(loop_, fd, close) as ~RtioFileStream\n+                      close: rtio::CloseBehavior) -> ~rtio::RtioFileStream {\n+        ~FileWatcher::new(self, fd, close) as ~rtio::RtioFileStream\n     }\n \n     fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n-        -> Result<~RtioFileStream, IoError> {\n+        -> Result<~rtio::RtioFileStream, IoError> {\n         let flags = match fm {\n             io::Open => 0,\n             io::Append => libc::O_APPEND,\n@@ -254,117 +197,117 @@ impl IoFactory for UvIoFactory {\n                               libc::S_IRUSR | libc::S_IWUSR),\n         };\n \n-        match FsRequest::open(self.uv_loop(), path, flags as int, mode as int) {\n-            Ok(fs) => Ok(~fs as ~RtioFileStream),\n+        match FsRequest::open(self, path, flags as int, mode as int) {\n+            Ok(fs) => Ok(~fs as ~rtio::RtioFileStream),\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n \n     fn fs_unlink(&mut self, path: &CString) -> Result<(), IoError> {\n-        let r = FsRequest::unlink(self.uv_loop(), path);\n+        let r = FsRequest::unlink(&self.loop_, path);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_lstat(&mut self, path: &CString) -> Result<FileStat, IoError> {\n-        let r = FsRequest::lstat(self.uv_loop(), path);\n+        let r = FsRequest::lstat(&self.loop_, path);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_stat(&mut self, path: &CString) -> Result<FileStat, IoError> {\n-        let r = FsRequest::stat(self.uv_loop(), path);\n+        let r = FsRequest::stat(&self.loop_, path);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_mkdir(&mut self, path: &CString,\n                 perm: io::FilePermission) -> Result<(), IoError> {\n-        let r = FsRequest::mkdir(self.uv_loop(), path, perm as c_int);\n+        let r = FsRequest::mkdir(&self.loop_, path, perm as c_int);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_rmdir(&mut self, path: &CString) -> Result<(), IoError> {\n-        let r = FsRequest::rmdir(self.uv_loop(), path);\n+        let r = FsRequest::rmdir(&self.loop_, path);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_rename(&mut self, path: &CString, to: &CString) -> Result<(), IoError> {\n-        let r = FsRequest::rename(self.uv_loop(), path, to);\n+        let r = FsRequest::rename(&self.loop_, path, to);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_chmod(&mut self, path: &CString,\n                 perm: io::FilePermission) -> Result<(), IoError> {\n-        let r = FsRequest::chmod(self.uv_loop(), path, perm as c_int);\n+        let r = FsRequest::chmod(&self.loop_, path, perm as c_int);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_readdir(&mut self, path: &CString, flags: c_int)\n         -> Result<~[Path], IoError>\n     {\n-        let r = FsRequest::readdir(self.uv_loop(), path, flags);\n+        let r = FsRequest::readdir(&self.loop_, path, flags);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_link(&mut self, src: &CString, dst: &CString) -> Result<(), IoError> {\n-        let r = FsRequest::link(self.uv_loop(), src, dst);\n+        let r = FsRequest::link(&self.loop_, src, dst);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_symlink(&mut self, src: &CString, dst: &CString) -> Result<(), IoError> {\n-        let r = FsRequest::symlink(self.uv_loop(), src, dst);\n+        let r = FsRequest::symlink(&self.loop_, src, dst);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_chown(&mut self, path: &CString, uid: int, gid: int) -> Result<(), IoError> {\n-        let r = FsRequest::chown(self.uv_loop(), path, uid, gid);\n+        let r = FsRequest::chown(&self.loop_, path, uid, gid);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_readlink(&mut self, path: &CString) -> Result<Path, IoError> {\n-        let r = FsRequest::readlink(self.uv_loop(), path);\n+        let r = FsRequest::readlink(&self.loop_, path);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_utime(&mut self, path: &CString, atime: u64, mtime: u64)\n         -> Result<(), IoError>\n     {\n-        let r = FsRequest::utime(self.uv_loop(), path, atime, mtime);\n+        let r = FsRequest::utime(&self.loop_, path, atime, mtime);\n         r.map_err(uv_error_to_io_error)\n     }\n \n     fn spawn(&mut self, config: ProcessConfig)\n-            -> Result<(~RtioProcess, ~[Option<~RtioPipe>]), IoError>\n+            -> Result<(~rtio::RtioProcess, ~[Option<~rtio::RtioPipe>]), IoError>\n     {\n-        match Process::spawn(self.uv_loop(), config) {\n+        match Process::spawn(self, config) {\n             Ok((p, io)) => {\n-                Ok((p as ~RtioProcess,\n-                    io.move_iter().map(|i| i.map(|p| ~p as ~RtioPipe)).collect()))\n+                Ok((p as ~rtio::RtioProcess,\n+                    io.move_iter().map(|i| i.map(|p| ~p as ~rtio::RtioPipe)).collect()))\n             }\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn unix_bind(&mut self, path: &CString) -> Result<~RtioUnixListener, IoError>\n+    fn unix_bind(&mut self, path: &CString) -> Result<~rtio::RtioUnixListener, IoError>\n     {\n-        match PipeListener::bind(self.uv_loop(), path) {\n-            Ok(p) => Ok(p as ~RtioUnixListener),\n+        match PipeListener::bind(self, path) {\n+            Ok(p) => Ok(p as ~rtio::RtioUnixListener),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn unix_connect(&mut self, path: &CString) -> Result<~RtioPipe, IoError> {\n-        match PipeWatcher::connect(self.uv_loop(), path) {\n-            Ok(p) => Ok(~p as ~RtioPipe),\n+    fn unix_connect(&mut self, path: &CString) -> Result<~rtio::RtioPipe, IoError> {\n+        match PipeWatcher::connect(self, path) {\n+            Ok(p) => Ok(~p as ~rtio::RtioPipe),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n     fn tty_open(&mut self, fd: c_int, readable: bool)\n-            -> Result<~RtioTTY, IoError> {\n-        match TtyWatcher::new(self.uv_loop(), fd, readable) {\n-            Ok(tty) => Ok(~tty as ~RtioTTY),\n+            -> Result<~rtio::RtioTTY, IoError> {\n+        match TtyWatcher::new(self, fd, readable) {\n+            Ok(tty) => Ok(~tty as ~rtio::RtioTTY),\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n \n-    fn pipe_open(&mut self, fd: c_int) -> Result<~RtioPipe, IoError> {\n-        match PipeWatcher::open(self.uv_loop(), fd) {\n-            Ok(s) => Ok(~s as ~RtioPipe),\n+    fn pipe_open(&mut self, fd: c_int) -> Result<~rtio::RtioPipe, IoError> {\n+        match PipeWatcher::open(self, fd) {\n+            Ok(s) => Ok(~s as ~rtio::RtioPipe),\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n \n     fn signal(&mut self, signum: Signum, channel: SharedChan<Signum>)\n-        -> Result<~RtioSignal, IoError> {\n-        match SignalWatcher::new(self.uv_loop(), signum, channel) {\n-            Ok(s) => Ok(s as ~RtioSignal),\n+        -> Result<~rtio::RtioSignal, IoError> {\n+        match SignalWatcher::new(self, signum, channel) {\n+            Ok(s) => Ok(s as ~rtio::RtioSignal),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }"}, {"sha": "ad5fad99f20633a84d952c77418af5d98607b2c1", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -37,7 +37,8 @@ use std::libc;\n #[cfg(test)]\n use std::libc::uintptr_t;\n \n-pub use self::errors::*;\n+pub use self::errors::{EACCES, ECONNREFUSED, ECONNRESET, EPIPE, ECONNABORTED,\n+                       ECANCELED, EBADF, ENOTCONN, ENOENT};\n \n pub static OK: c_int = 0;\n pub static EOF: c_int = -4095;\n@@ -576,6 +577,8 @@ extern {\n \n     // generic uv functions\n     pub fn uv_loop_delete(l: *uv_loop_t);\n+    pub fn uv_ref(t: *uv_handle_t);\n+    pub fn uv_unref(t: *uv_handle_t);\n     pub fn uv_handle_size(ty: uv_handle_type) -> size_t;\n     pub fn uv_req_size(ty: uv_req_type) -> size_t;\n     pub fn uv_run(l: *uv_loop_t, mode: uv_run_mode) -> c_int;"}, {"sha": "45a91d01b7a9cee9920a1a3d7176b366d688ad47", "filename": "src/libstd/any.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fany.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -20,10 +20,11 @@\n \n use cast::transmute;\n use option::{Option, Some, None};\n+use result::{Result, Ok, Err};\n use to_str::ToStr;\n+use unstable::intrinsics::TypeId;\n use unstable::intrinsics;\n use util::Void;\n-use unstable::intrinsics::TypeId;\n \n ///////////////////////////////////////////////////////////////////////////////\n // Any trait\n@@ -118,13 +119,13 @@ impl<'a> AnyMutRefExt<'a> for &'a mut Any {\n /// Extension methods for a owning `Any` trait object\n pub trait AnyOwnExt {\n     /// Returns the boxed value if it is of type `T`, or\n-    /// `None` if it isn't.\n-    fn move<T: 'static>(self) -> Option<~T>;\n+    /// `Err(Self)` if it isn't.\n+    fn move<T: 'static>(self) -> Result<~T, Self>;\n }\n \n impl AnyOwnExt for ~Any {\n     #[inline]\n-    fn move<T: 'static>(self) -> Option<~T> {\n+    fn move<T: 'static>(self) -> Result<~T, ~Any> {\n         if self.is::<T>() {\n             unsafe {\n                 // Extract the pointer to the boxed value, temporary alias with self\n@@ -133,10 +134,10 @@ impl AnyOwnExt for ~Any {\n                 // Prevent destructor on self being run\n                 intrinsics::forget(self);\n \n-                Some(ptr)\n+                Ok(ptr)\n             }\n         } else {\n-            None\n+            Err(self)\n         }\n     }\n }\n@@ -155,9 +156,8 @@ impl<'a> ToStr for &'a Any {\n \n #[cfg(test)]\n mod tests {\n+    use prelude::*;\n     use super::*;\n-    use super::AnyRefExt;\n-    use option::{Some, None};\n \n     #[deriving(Eq)]\n     struct Test;\n@@ -384,13 +384,19 @@ mod tests {\n         let a = ~8u as ~Any;\n         let b = ~Test as ~Any;\n \n-        assert_eq!(a.move(), Some(~8u));\n-        assert_eq!(b.move(), Some(~Test));\n+        match a.move::<uint>() {\n+            Ok(a) => { assert_eq!(a, ~8u); }\n+            Err(..) => fail!()\n+        }\n+        match b.move::<Test>() {\n+            Ok(a) => { assert_eq!(a, ~Test); }\n+            Err(..) => fail!()\n+        }\n \n         let a = ~8u as ~Any;\n         let b = ~Test as ~Any;\n \n-        assert_eq!(a.move(), None::<~Test>);\n-        assert_eq!(b.move(), None::<~uint>);\n+        assert!(a.move::<~Test>().is_err());\n+        assert!(b.move::<~uint>().is_err());\n     }\n }"}, {"sha": "bd1d6fed901caf9b382bdbe949133582ab09bcea", "filename": "src/libstd/comm/imp.rs", "status": "removed", "additions": 0, "deletions": 337, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibstd%2Fcomm%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibstd%2Fcomm%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fimp.rs?ref=d975060de6c944ca12ce5205fbc9fc7726948ae1", "patch": "@@ -1,337 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! One of the major goals behind this channel implementation is to work\n-//! seamlessly on and off the runtime. This also means that the code isn't\n-//! littered with \"if is_green() { ... } else { ... }\". Right now, the rest of\n-//! the runtime isn't quite ready to for this abstraction to be done very\n-//! nicely, so the conditional \"if green\" blocks are all contained in this inner\n-//! module.\n-//!\n-//! The goal of this module is to mirror what the runtime \"should be\", not the\n-//! state that it is currently in today. You'll notice that there is no mention\n-//! of schedulers or is_green inside any of the channel code, it is currently\n-//! entirely contained in this one module.\n-//!\n-//! In the ideal world, nothing in this module exists and it is all implemented\n-//! elsewhere in the runtime (in the proper location). All of this code is\n-//! structured in order to easily refactor this to the correct location whenever\n-//! we have the trait objects in place to serve as the boundary of the\n-//! abstraction.\n-\n-use iter::{range, Iterator};\n-use ops::Drop;\n-use option::{Some, None, Option};\n-use rt::local::Local;\n-use rt::sched::{SchedHandle, Scheduler, TaskFromFriend};\n-use rt::thread::Thread;\n-use rt;\n-use unstable::mutex::Mutex;\n-use unstable::sync::UnsafeArc;\n-\n-// A task handle is a method of waking up a blocked task. The handle itself\n-// is completely opaque and only has a wake() method defined on it. This\n-// method will wake the method regardless of the context of the thread which\n-// is currently calling wake().\n-//\n-// This abstraction should be able to be created when putting a task to\n-// sleep. This should basically be a method on whatever the local Task is,\n-// consuming the local Task.\n-\n-pub struct TaskHandle {\n-    priv inner: TaskRepr\n-}\n-enum TaskRepr {\n-    Green(rt::BlockedTask, *mut SchedHandle),\n-    Native(NativeWakeupStyle),\n-}\n-enum NativeWakeupStyle {\n-    ArcWakeup(UnsafeArc<Mutex>),    // shared mutex to synchronize on\n-    LocalWakeup(*mut Mutex),        // synchronize on the task-local mutex\n-}\n-\n-impl TaskHandle {\n-    // Signal that this handle should be woken up. The `can_resched`\n-    // argument indicates whether the current task could possibly be\n-    // rescheduled or not. This does not have a lot of meaning for the\n-    // native case, but for an M:N case it indicates whether a context\n-    // switch can happen or not.\n-    pub fn wake(self, can_resched: bool) {\n-        match self.inner {\n-            Green(task, handle) => {\n-                // If we have a local scheduler, then use that to run the\n-                // blocked task, otherwise we can use the handle to send the\n-                // task back to its home.\n-                if rt::in_green_task_context() {\n-                    if can_resched {\n-                        task.wake().map(Scheduler::run_task);\n-                    } else {\n-                        let mut s: ~Scheduler = Local::take();\n-                        s.enqueue_blocked_task(task);\n-                        Local::put(s);\n-                    }\n-                } else {\n-                    let task = match task.wake() {\n-                        Some(task) => task, None => return\n-                    };\n-                    // XXX: this is not an easy section of code to refactor.\n-                    //      If this handle is owned by the Task (which it\n-                    //      should be), then this would be a use-after-free\n-                    //      because once the task is pushed onto the message\n-                    //      queue, the handle is gone.\n-                    //\n-                    //      Currently the handle is instead owned by the\n-                    //      Port/Chan pair, which means that because a\n-                    //      channel is invoking this method the handle will\n-                    //      continue to stay alive for the entire duration\n-                    //      of this method. This will require thought when\n-                    //      moving the handle into the task.\n-                    unsafe { (*handle).send(TaskFromFriend(task)) }\n-                }\n-            }\n-\n-            // Note that there are no use-after-free races in this code. In\n-            // the arc-case, we own the lock, and in the local case, we're\n-            // using a lock so it's guranteed that they aren't running while\n-            // we hold the lock.\n-            Native(ArcWakeup(lock)) => {\n-                unsafe {\n-                    let lock = lock.get();\n-                    (*lock).lock();\n-                    (*lock).signal();\n-                    (*lock).unlock();\n-                }\n-            }\n-            Native(LocalWakeup(lock)) => {\n-                unsafe {\n-                    (*lock).lock();\n-                    (*lock).signal();\n-                    (*lock).unlock();\n-                }\n-            }\n-        }\n-    }\n-\n-    // Trashes handle to this task. This ensures that necessary memory is\n-    // deallocated, and there may be some extra assertions as well.\n-    pub fn trash(self) {\n-        match self.inner {\n-            Green(task, _) => task.assert_already_awake(),\n-            Native(..) => {}\n-        }\n-    }\n-}\n-\n-// This structure is an abstraction of what should be stored in the local\n-// task itself. This data is currently stored inside of each channel, but\n-// this should rather be stored in each task (and channels will still\n-// continue to lazily initialize this data).\n-\n-pub struct TaskData {\n-    priv handle: Option<SchedHandle>,\n-    priv lock: Mutex,\n-}\n-\n-impl TaskData {\n-    pub fn new() -> TaskData {\n-        TaskData {\n-            handle: None,\n-            lock: unsafe { Mutex::empty() },\n-        }\n-    }\n-}\n-\n-impl Drop for TaskData {\n-    fn drop(&mut self) {\n-        unsafe { self.lock.destroy() }\n-    }\n-}\n-\n-// Now this is the really fun part. This is where all the M:N/1:1-agnostic\n-// along with recv/select-agnostic blocking information goes. A \"blocking\n-// context\" is really just a stack-allocated structure (which is probably\n-// fine to be a stack-trait-object).\n-//\n-// This has some particularly strange interfaces, but the reason for all\n-// this is to support selection/recv/1:1/M:N all in one bundle.\n-\n-pub struct BlockingContext<'a> {\n-    priv inner: BlockingRepr<'a>\n-}\n-\n-enum BlockingRepr<'a> {\n-    GreenBlock(rt::BlockedTask, &'a mut Scheduler),\n-    NativeBlock(Option<UnsafeArc<Mutex>>),\n-}\n-\n-impl<'a> BlockingContext<'a> {\n-    // Creates one blocking context. The data provided should in theory be\n-    // acquired from the local task, but it is instead acquired from the\n-    // channel currently.\n-    //\n-    // This function will call `f` with a blocking context, plus the data\n-    // that it is given. This function will then return whether this task\n-    // should actually go to sleep or not. If `true` is returned, then this\n-    // function does not return until someone calls `wake()` on the task.\n-    // If `false` is returned, then this function immediately returns.\n-    //\n-    // # Safety note\n-    //\n-    // Note that this stack closure may not be run on the same stack as when\n-    // this function was called. This means that the environment of this\n-    // stack closure could be unsafely aliased. This is currently prevented\n-    // through the guarantee that this function will never return before `f`\n-    // finishes executing.\n-    pub fn one(data: &mut TaskData,\n-               f: |BlockingContext, &mut TaskData| -> bool) {\n-        if rt::in_green_task_context() {\n-            let sched: ~Scheduler = Local::take();\n-            sched.deschedule_running_task_and_then(|sched, task| {\n-                let ctx = BlockingContext { inner: GreenBlock(task, sched) };\n-                // no need to do something on success/failure other than\n-                // returning because the `block` function for a BlockingContext\n-                // takes care of reawakening itself if the blocking procedure\n-                // fails. If this function is successful, then we're already\n-                // blocked, and if it fails, the task will already be\n-                // rescheduled.\n-                f(ctx, data);\n-            });\n-        } else {\n-            unsafe { data.lock.lock(); }\n-            let ctx = BlockingContext { inner: NativeBlock(None) };\n-            if f(ctx, data) {\n-                unsafe { data.lock.wait(); }\n-            }\n-            unsafe { data.lock.unlock(); }\n-        }\n-    }\n-\n-    // Creates many blocking contexts. The intended use case for this\n-    // function is selection over a number of ports. This will create `amt`\n-    // blocking contexts, yielding them to `f` in turn. If `f` returns\n-    // false, then this function aborts and returns immediately. If `f`\n-    // repeatedly returns `true` `amt` times, then this function will block.\n-    pub fn many(amt: uint, f: |BlockingContext| -> bool) {\n-        if rt::in_green_task_context() {\n-            let sched: ~Scheduler = Local::take();\n-            sched.deschedule_running_task_and_then(|sched, task| {\n-                for handle in task.make_selectable(amt) {\n-                    let ctx = BlockingContext {\n-                        inner: GreenBlock(handle, sched)\n-                    };\n-                    // see comment above in `one` for why no further action is\n-                    // necessary here\n-                    if !f(ctx) { break }\n-                }\n-            });\n-        } else {\n-            // In the native case, our decision to block must be shared\n-            // amongst all of the channels. It may be possible to\n-            // stack-allocate this mutex (instead of putting it in an\n-            // UnsafeArc box), but for now in order to prevent\n-            // use-after-free trivially we place this into a box and then\n-            // pass that around.\n-            unsafe {\n-                let mtx = UnsafeArc::new(Mutex::new());\n-                (*mtx.get()).lock();\n-                let success = range(0, amt).all(|_| {\n-                    f(BlockingContext {\n-                        inner: NativeBlock(Some(mtx.clone()))\n-                    })\n-                });\n-                if success {\n-                    (*mtx.get()).wait();\n-                }\n-                (*mtx.get()).unlock();\n-            }\n-        }\n-    }\n-\n-    // This function will consume this BlockingContext, and optionally block\n-    // if according to the atomic `decision` function. The semantics of this\n-    // functions are:\n-    //\n-    //  * `slot` is required to be a `None`-slot (which is owned by the\n-    //    channel)\n-    //  * The `slot` will be filled in with a blocked version of the current\n-    //    task (with `wake`-ability if this function is successful).\n-    //  * If the `decision` function returns true, then this function\n-    //    immediately returns having relinquished ownership of the task.\n-    //  * If the `decision` function returns false, then the `slot` is reset\n-    //    to `None` and the task is re-scheduled if necessary (remember that\n-    //    the task will not resume executing before the outer `one` or\n-    //    `many` function has returned. This function is expected to have a\n-    //    release memory fence in order for the modifications of `to_wake` to be\n-    //    visible to other tasks. Code which attempts to read `to_wake` should\n-    //    have an acquiring memory fence to guarantee that this write is\n-    //    visible.\n-    //\n-    // This function will return whether the blocking occurred or not.\n-    pub fn block(self,\n-                 data: &mut TaskData,\n-                 slot: &mut Option<TaskHandle>,\n-                 decision: || -> bool) -> bool {\n-        assert!(slot.is_none());\n-        match self.inner {\n-            GreenBlock(task, sched) => {\n-                if data.handle.is_none() {\n-                    data.handle = Some(sched.make_handle());\n-                }\n-                let handle = data.handle.get_mut_ref() as *mut SchedHandle;\n-                *slot = Some(TaskHandle { inner: Green(task, handle) });\n-\n-                if !decision() {\n-                    match slot.take_unwrap().inner {\n-                        Green(task, _) => sched.enqueue_blocked_task(task),\n-                        Native(..) => unreachable!()\n-                    }\n-                    false\n-                } else {\n-                    true\n-                }\n-            }\n-            NativeBlock(shared) => {\n-                *slot = Some(TaskHandle {\n-                    inner: Native(match shared {\n-                        Some(arc) => ArcWakeup(arc),\n-                        None => LocalWakeup(&mut data.lock as *mut Mutex),\n-                    })\n-                });\n-\n-                if !decision() {\n-                    *slot = None;\n-                    false\n-                } else {\n-                    true\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-// Agnostic method of forcing a yield of the current task\n-pub fn yield_now() {\n-    if rt::in_green_task_context() {\n-        let sched: ~Scheduler = Local::take();\n-        sched.yield_now();\n-    } else {\n-        Thread::yield_now();\n-    }\n-}\n-\n-// Agnostic method of \"maybe yielding\" in order to provide fairness\n-pub fn maybe_yield() {\n-    if rt::in_green_task_context() {\n-        let sched: ~Scheduler = Local::take();\n-        sched.maybe_yield();\n-    } else {\n-        // the OS decides fairness, nothing for us to do.\n-    }\n-}"}, {"sha": "21db234122b2e662358c712199004c9504e9e658", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 228, "deletions": 281, "changes": 509, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -233,39 +233,43 @@ use iter::Iterator;\n use kinds::Send;\n use ops::Drop;\n use option::{Option, Some, None};\n+use result::{Ok, Err};\n+use rt::local::Local;\n+use rt::task::{Task, BlockedTask};\n use rt::thread::Thread;\n-use unstable::atomics::{AtomicInt, AtomicBool, SeqCst, Relaxed};\n+use sync::atomics::{AtomicInt, AtomicBool, SeqCst, Relaxed};\n use vec::{ImmutableVector, OwnedVector};\n \n-use spsc = rt::spsc_queue;\n-use mpsc = rt::mpsc_queue;\n+use spsc = sync::spsc_queue;\n+use mpsc = sync::mpsc_queue;\n \n-use self::imp::{TaskHandle, TaskData, BlockingContext};\n pub use self::select::Select;\n \n macro_rules! test (\n     { fn $name:ident() $b:block $($a:attr)*} => (\n         mod $name {\n             #[allow(unused_imports)];\n \n-            use util;\n-            use super::super::*;\n+            use native;\n             use prelude::*;\n+            use super::*;\n+            use super::super::*;\n+            use task;\n+            use util;\n \n             fn f() $b\n \n             $($a)* #[test] fn uv() { f() }\n-            $($a)* #[test]\n-            #[ignore(cfg(windows))] // FIXME(#11003)\n-            fn native() {\n-                use unstable::run_in_bare_thread;\n-                run_in_bare_thread(f);\n+            $($a)* #[test] fn native() {\n+                use native;\n+                let (p, c) = Chan::new();\n+                do native::task::spawn { c.send(f()) }\n+                p.recv();\n             }\n         }\n     )\n )\n \n-mod imp;\n mod select;\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -326,9 +330,7 @@ pub struct SharedChan<T> {\n struct Packet {\n     cnt: AtomicInt, // How many items are on this channel\n     steals: int,    // How many times has a port received without blocking?\n-    to_wake: Option<TaskHandle>, // Task to wake up\n-\n-    data: TaskData,\n+    to_wake: Option<BlockedTask>, // Task to wake up\n \n     // This lock is used to wake up native threads blocked in select. The\n     // `lock` field is not used because the thread blocking in select must\n@@ -343,6 +345,7 @@ struct Packet {\n     selection_id: uint,\n     select_next: *mut Packet,\n     select_prev: *mut Packet,\n+    recv_cnt: int,\n }\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -358,13 +361,13 @@ impl Packet {\n             cnt: AtomicInt::new(0),\n             steals: 0,\n             to_wake: None,\n-            data: TaskData::new(),\n             channels: AtomicInt::new(1),\n \n             selecting: AtomicBool::new(false),\n             selection_id: 0,\n             select_next: 0 as *mut Packet,\n             select_prev: 0 as *mut Packet,\n+            recv_cnt: 0,\n         }\n     }\n \n@@ -418,7 +421,10 @@ impl Packet {\n     // This function must have had at least an acquire fence before it to be\n     // properly called.\n     fn wakeup(&mut self, can_resched: bool) {\n-        self.to_wake.take_unwrap().wake(can_resched);\n+        match self.to_wake.take_unwrap().wake() {\n+            Some(task) => task.reawaken(can_resched),\n+            None => {}\n+        }\n         self.selecting.store(false, Relaxed);\n     }\n \n@@ -490,7 +496,7 @@ impl Packet {\n         match self.channels.fetch_sub(1, SeqCst) {\n             1 => {\n                 match self.cnt.swap(DISCONNECTED, SeqCst) {\n-                    -1 => { self.wakeup(false); }\n+                    -1 => { self.wakeup(true); }\n                     DISCONNECTED => {}\n                     n => { assert!(n >= 0); }\n                 }\n@@ -531,9 +537,6 @@ impl<T: Send> Chan<T> {\n     /// port.\n     ///\n     /// Rust channels are infinitely buffered so this method will never block.\n-    /// This method may trigger a rescheduling, however, in order to wake up a\n-    /// blocked receiver (if one is present). If no scheduling is desired, then\n-    /// the `send_deferred` guarantees that there will be no reschedulings.\n     ///\n     /// # Failure\n     ///\n@@ -555,15 +558,6 @@ impl<T: Send> Chan<T> {\n         }\n     }\n \n-    /// This function is equivalent in the semantics of `send`, but it\n-    /// guarantees that a rescheduling will never occur when this method is\n-    /// called.\n-    pub fn send_deferred(&self, t: T) {\n-        if !self.try_send_deferred(t) {\n-            fail!(\"sending on a closed channel\");\n-        }\n-    }\n-\n     /// Attempts to send a value on this channel, returning whether it was\n     /// successfully sent.\n     ///\n@@ -579,9 +573,8 @@ impl<T: Send> Chan<T> {\n     /// be tolerated, then this method should be used instead.\n     pub fn try_send(&self, t: T) -> bool { self.try(t, true) }\n \n-    /// This function is equivalent in the semantics of `try_send`, but it\n-    /// guarantees that a rescheduling will never occur when this method is\n-    /// called.\n+    /// This function will not stick around for very long. The purpose of this\n+    /// function is to guarantee that no rescheduling is performed.\n     pub fn try_send_deferred(&self, t: T) -> bool { self.try(t, false) }\n \n     fn try(&self, t: T, can_resched: bool) -> bool {\n@@ -606,8 +599,9 @@ impl<T: Send> Chan<T> {\n                 // the TLS overhead can be a bit much.\n                 n => {\n                     assert!(n >= 0);\n-                    if can_resched && n > 0 && n % RESCHED_FREQ == 0 {\n-                        imp::maybe_yield();\n+                    if n > 0 && n % RESCHED_FREQ == 0 {\n+                        let task: ~Task = Local::take();\n+                        task.maybe_yield();\n                     }\n                     true\n                 }\n@@ -642,25 +636,9 @@ impl<T: Send> SharedChan<T> {\n         }\n     }\n \n-    /// This function is equivalent in the semantics of `send`, but it\n-    /// guarantees that a rescheduling will never occur when this method is\n-    /// called.\n-    pub fn send_deferred(&self, t: T) {\n-        if !self.try_send_deferred(t) {\n-            fail!(\"sending on a closed channel\");\n-        }\n-    }\n-\n     /// Equivalent method to `try_send` on the `Chan` type (using the same\n     /// semantics)\n-    pub fn try_send(&self, t: T) -> bool { self.try(t, true) }\n-\n-    /// This function is equivalent in the semantics of `try_send`, but it\n-    /// guarantees that a rescheduling will never occur when this method is\n-    /// called.\n-    pub fn try_send_deferred(&self, t: T) -> bool { self.try(t, false) }\n-\n-    fn try(&self, t: T, can_resched: bool) -> bool {\n+    pub fn try_send(&self, t: T) -> bool {\n         unsafe {\n             // Note that the multiple sender case is a little tricker\n             // semantically than the single sender case. The logic for\n@@ -697,10 +675,11 @@ impl<T: Send> SharedChan<T> {\n \n             match (*packet).increment() {\n                 DISCONNECTED => {} // oh well, we tried\n-                -1 => { (*packet).wakeup(can_resched); }\n+                -1 => { (*packet).wakeup(true); }\n                 n => {\n-                    if can_resched && n > 0 && n % RESCHED_FREQ == 0 {\n-                        imp::maybe_yield();\n+                    if n > 0 && n % RESCHED_FREQ == 0 {\n+                        let task: ~Task = Local::take();\n+                        task.maybe_yield();\n                     }\n                 }\n             }\n@@ -768,6 +747,18 @@ impl<T: Send> Port<T> {\n         // This is a \"best effort\" situation, so if a queue is inconsistent just\n         // don't worry about it.\n         let this = unsafe { cast::transmute_mut(self) };\n+\n+        // See the comment about yielding on sends, but the same applies here.\n+        // If a thread is spinning in try_recv we should try\n+        unsafe {\n+            let packet = this.queue.packet();\n+            (*packet).recv_cnt += 1;\n+            if (*packet).recv_cnt % RESCHED_FREQ == 0 {\n+                let task: ~Task = Local::take();\n+                task.maybe_yield();\n+            }\n+        }\n+\n         let ret = match this.queue {\n             SPSC(ref mut queue) => queue.pop(),\n             MPSC(ref mut queue) => match queue.pop() {\n@@ -840,15 +831,22 @@ impl<T: Send> Port<T> {\n         unsafe {\n             this = cast::transmute_mut(self);\n             packet = this.queue.packet();\n-            BlockingContext::one(&mut (*packet).data, |ctx, data| {\n-                ctx.block(data, &mut (*packet).to_wake, || (*packet).decrement())\n+            let task: ~Task = Local::take();\n+            task.deschedule(1, |task| {\n+                assert!((*packet).to_wake.is_none());\n+                (*packet).to_wake = Some(task);\n+                if (*packet).decrement() {\n+                    Ok(())\n+                } else {\n+                    Err((*packet).to_wake.take_unwrap())\n+                }\n             });\n         }\n \n         let data = self.try_recv_inc(false);\n         if data.is_none() &&\n            unsafe { (*packet).cnt.load(SeqCst) } != DISCONNECTED {\n-            fail!(\"bug: woke up too soon\");\n+            fail!(\"bug: woke up too soon {}\", unsafe { (*packet).cnt.load(SeqCst) });\n         }\n         return data;\n     }\n@@ -880,10 +878,16 @@ impl<T: Send> Drop for Port<T> {\n mod test {\n     use prelude::*;\n \n-    use task;\n-    use rt::thread::Thread;\n+    use native;\n+    use os;\n     use super::*;\n-    use rt::test::*;\n+\n+    pub fn stress_factor() -> uint {\n+        match os::getenv(\"RUST_TEST_STRESS\") {\n+            Some(val) => from_str::<uint>(val).unwrap(),\n+            None => 1,\n+        }\n+    }\n \n     test!(fn smoke() {\n         let (p, c) = Chan::new();\n@@ -910,99 +914,88 @@ mod test {\n         assert_eq!(p.recv(), 1);\n     })\n \n-    #[test]\n-    fn smoke_threads() {\n+    test!(fn smoke_threads() {\n         let (p, c) = Chan::new();\n-        do task::spawn_sched(task::SingleThreaded) {\n+        do spawn {\n             c.send(1);\n         }\n         assert_eq!(p.recv(), 1);\n-    }\n+    })\n \n-    #[test] #[should_fail]\n-    fn smoke_port_gone() {\n+    test!(fn smoke_port_gone() {\n         let (p, c) = Chan::new();\n         drop(p);\n         c.send(1);\n-    }\n+    } #[should_fail])\n \n-    #[test] #[should_fail]\n-    fn smoke_shared_port_gone() {\n+    test!(fn smoke_shared_port_gone() {\n         let (p, c) = SharedChan::new();\n         drop(p);\n         c.send(1);\n-    }\n+    } #[should_fail])\n \n-    #[test] #[should_fail]\n-    fn smoke_shared_port_gone2() {\n+    test!(fn smoke_shared_port_gone2() {\n         let (p, c) = SharedChan::new();\n         drop(p);\n         let c2 = c.clone();\n         drop(c);\n         c2.send(1);\n-    }\n+    } #[should_fail])\n \n-    #[test] #[should_fail]\n-    fn port_gone_concurrent() {\n+    test!(fn port_gone_concurrent() {\n         let (p, c) = Chan::new();\n-        do task::spawn_sched(task::SingleThreaded) {\n+        do spawn {\n             p.recv();\n         }\n         loop { c.send(1) }\n-    }\n+    } #[should_fail])\n \n-    #[test] #[should_fail]\n-    fn port_gone_concurrent_shared() {\n+    test!(fn port_gone_concurrent_shared() {\n         let (p, c) = SharedChan::new();\n         let c1 = c.clone();\n-        do task::spawn_sched(task::SingleThreaded) {\n+        do spawn {\n             p.recv();\n         }\n         loop {\n             c.send(1);\n             c1.send(1);\n         }\n-    }\n+    } #[should_fail])\n \n-    #[test] #[should_fail]\n-    fn smoke_chan_gone() {\n+    test!(fn smoke_chan_gone() {\n         let (p, c) = Chan::<int>::new();\n         drop(c);\n         p.recv();\n-    }\n+    } #[should_fail])\n \n-    #[test] #[should_fail]\n-    fn smoke_chan_gone_shared() {\n+    test!(fn smoke_chan_gone_shared() {\n         let (p, c) = SharedChan::<()>::new();\n         let c2 = c.clone();\n         drop(c);\n         drop(c2);\n         p.recv();\n-    }\n+    } #[should_fail])\n \n-    #[test] #[should_fail]\n-    fn chan_gone_concurrent() {\n+    test!(fn chan_gone_concurrent() {\n         let (p, c) = Chan::new();\n-        do task::spawn_sched(task::SingleThreaded) {\n+        do spawn {\n             c.send(1);\n             c.send(1);\n         }\n         loop { p.recv(); }\n-    }\n+    } #[should_fail])\n \n-    #[test]\n-    fn stress() {\n+    test!(fn stress() {\n         let (p, c) = Chan::new();\n-        do task::spawn_sched(task::SingleThreaded) {\n+        do spawn {\n             for _ in range(0, 10000) { c.send(1); }\n         }\n         for _ in range(0, 10000) {\n             assert_eq!(p.recv(), 1);\n         }\n-    }\n+    })\n \n-    #[test]\n-    fn stress_shared() {\n+    test!(fn stress_shared() {\n         static AMT: uint = 10000;\n         static NTHREADS: uint = 8;\n         let (p, c) = SharedChan::<int>::new();\n@@ -1018,221 +1011,186 @@ mod test {\n \n         for _ in range(0, NTHREADS) {\n             let c = c.clone();\n-            do task::spawn_sched(task::SingleThreaded) {\n+            do spawn {\n                 for _ in range(0, AMT) { c.send(1); }\n             }\n         }\n         p1.recv();\n-\n-    }\n+    })\n \n     #[test]\n     #[ignore(cfg(windows))] // FIXME(#11003)\n     fn send_from_outside_runtime() {\n         let (p, c) = Chan::<int>::new();\n         let (p1, c1) = Chan::new();\n+        let (port, chan) = SharedChan::new();\n+        let chan2 = chan.clone();\n         do spawn {\n             c1.send(());\n             for _ in range(0, 40) {\n                 assert_eq!(p.recv(), 1);\n             }\n+            chan2.send(());\n         }\n         p1.recv();\n-        let t = do Thread::start {\n+        do native::task::spawn {\n             for _ in range(0, 40) {\n                 c.send(1);\n             }\n-        };\n-        t.join();\n+            chan.send(());\n+        }\n+        port.recv();\n+        port.recv();\n     }\n \n     #[test]\n     #[ignore(cfg(windows))] // FIXME(#11003)\n     fn recv_from_outside_runtime() {\n         let (p, c) = Chan::<int>::new();\n-        let t = do Thread::start {\n+        let (dp, dc) = Chan::new();\n+        do native::task::spawn {\n             for _ in range(0, 40) {\n                 assert_eq!(p.recv(), 1);\n             }\n+            dc.send(());\n         };\n         for _ in range(0, 40) {\n             c.send(1);\n         }\n-        t.join();\n+        dp.recv();\n     }\n \n     #[test]\n     #[ignore(cfg(windows))] // FIXME(#11003)\n     fn no_runtime() {\n         let (p1, c1) = Chan::<int>::new();\n         let (p2, c2) = Chan::<int>::new();\n-        let t1 = do Thread::start {\n+        let (port, chan) = SharedChan::new();\n+        let chan2 = chan.clone();\n+        do native::task::spawn {\n             assert_eq!(p1.recv(), 1);\n             c2.send(2);\n-        };\n-        let t2 = do Thread::start {\n+            chan2.send(());\n+        }\n+        do native::task::spawn {\n             c1.send(1);\n             assert_eq!(p2.recv(), 2);\n-        };\n-        t1.join();\n-        t2.join();\n+            chan.send(());\n+        }\n+        port.recv();\n+        port.recv();\n     }\n \n-    #[test]\n-    fn oneshot_single_thread_close_port_first() {\n+    test!(fn oneshot_single_thread_close_port_first() {\n         // Simple test of closing without sending\n-        do run_in_newsched_task {\n-            let (port, _chan) = Chan::<int>::new();\n-            { let _p = port; }\n-        }\n-    }\n+        let (port, _chan) = Chan::<int>::new();\n+        { let _p = port; }\n+    })\n \n-    #[test]\n-    fn oneshot_single_thread_close_chan_first() {\n+    test!(fn oneshot_single_thread_close_chan_first() {\n         // Simple test of closing without sending\n-        do run_in_newsched_task {\n-            let (_port, chan) = Chan::<int>::new();\n-            { let _c = chan; }\n-        }\n-    }\n+        let (_port, chan) = Chan::<int>::new();\n+        { let _c = chan; }\n+    })\n \n-    #[test] #[should_fail]\n-    fn oneshot_single_thread_send_port_close() {\n+    test!(fn oneshot_single_thread_send_port_close() {\n         // Testing that the sender cleans up the payload if receiver is closed\n         let (port, chan) = Chan::<~int>::new();\n         { let _p = port; }\n         chan.send(~0);\n-    }\n+    } #[should_fail])\n \n-    #[test]\n-    fn oneshot_single_thread_recv_chan_close() {\n+    test!(fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will fail\n-        do run_in_newsched_task {\n-            let res = do spawntask_try {\n-                let (port, chan) = Chan::<~int>::new();\n-                { let _c = chan; }\n-                port.recv();\n-            };\n-            // What is our res?\n-            assert!(res.is_err());\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_send_then_recv() {\n-        do run_in_newsched_task {\n+        let res = do task::try {\n             let (port, chan) = Chan::<~int>::new();\n-            chan.send(~10);\n-            assert!(port.recv() == ~10);\n-        }\n-    }\n+            { let _c = chan; }\n+            port.recv();\n+        };\n+        // What is our res?\n+        assert!(res.is_err());\n+    })\n \n-    #[test]\n-    fn oneshot_single_thread_try_send_open() {\n-        do run_in_newsched_task {\n-            let (port, chan) = Chan::<int>::new();\n-            assert!(chan.try_send(10));\n-            assert!(port.recv() == 10);\n-        }\n-    }\n+    test!(fn oneshot_single_thread_send_then_recv() {\n+        let (port, chan) = Chan::<~int>::new();\n+        chan.send(~10);\n+        assert!(port.recv() == ~10);\n+    })\n \n-    #[test]\n-    fn oneshot_single_thread_try_send_closed() {\n-        do run_in_newsched_task {\n-            let (port, chan) = Chan::<int>::new();\n-            { let _p = port; }\n-            assert!(!chan.try_send(10));\n-        }\n-    }\n+    test!(fn oneshot_single_thread_try_send_open() {\n+        let (port, chan) = Chan::<int>::new();\n+        assert!(chan.try_send(10));\n+        assert!(port.recv() == 10);\n+    })\n \n-    #[test]\n-    fn oneshot_single_thread_try_recv_open() {\n-        do run_in_newsched_task {\n-            let (port, chan) = Chan::<int>::new();\n-            chan.send(10);\n-            assert!(port.try_recv() == Some(10));\n-        }\n-    }\n+    test!(fn oneshot_single_thread_try_send_closed() {\n+        let (port, chan) = Chan::<int>::new();\n+        { let _p = port; }\n+        assert!(!chan.try_send(10));\n+    })\n \n-    #[test]\n-    fn oneshot_single_thread_try_recv_closed() {\n-        do run_in_newsched_task {\n-            let (port, chan) = Chan::<int>::new();\n-            { let _c = chan; }\n-            assert!(port.recv_opt() == None);\n-        }\n-    }\n+    test!(fn oneshot_single_thread_try_recv_open() {\n+        let (port, chan) = Chan::<int>::new();\n+        chan.send(10);\n+        assert!(port.try_recv() == Some(10));\n+    })\n \n-    #[test]\n-    fn oneshot_single_thread_peek_data() {\n-        do run_in_newsched_task {\n-            let (port, chan) = Chan::<int>::new();\n-            assert!(port.try_recv().is_none());\n-            chan.send(10);\n-            assert!(port.try_recv().is_some());\n-        }\n-    }\n+    test!(fn oneshot_single_thread_try_recv_closed() {\n+        let (port, chan) = Chan::<int>::new();\n+        { let _c = chan; }\n+        assert!(port.recv_opt() == None);\n+    })\n \n-    #[test]\n-    fn oneshot_single_thread_peek_close() {\n-        do run_in_newsched_task {\n-            let (port, chan) = Chan::<int>::new();\n-            { let _c = chan; }\n-            assert!(port.try_recv().is_none());\n-            assert!(port.try_recv().is_none());\n-        }\n-    }\n+    test!(fn oneshot_single_thread_peek_data() {\n+        let (port, chan) = Chan::<int>::new();\n+        assert!(port.try_recv().is_none());\n+        chan.send(10);\n+        assert!(port.try_recv().is_some());\n+    })\n \n-    #[test]\n-    fn oneshot_single_thread_peek_open() {\n-        do run_in_newsched_task {\n-            let (port, _) = Chan::<int>::new();\n-            assert!(port.try_recv().is_none());\n-        }\n-    }\n+    test!(fn oneshot_single_thread_peek_close() {\n+        let (port, chan) = Chan::<int>::new();\n+        { let _c = chan; }\n+        assert!(port.try_recv().is_none());\n+        assert!(port.try_recv().is_none());\n+    })\n \n-    #[test]\n-    fn oneshot_multi_task_recv_then_send() {\n-        do run_in_newsched_task {\n-            let (port, chan) = Chan::<~int>::new();\n-            do spawntask {\n-                assert!(port.recv() == ~10);\n-            }\n+    test!(fn oneshot_single_thread_peek_open() {\n+        let (port, _) = Chan::<int>::new();\n+        assert!(port.try_recv().is_none());\n+    })\n \n-            chan.send(~10);\n+    test!(fn oneshot_multi_task_recv_then_send() {\n+        let (port, chan) = Chan::<~int>::new();\n+        do spawn {\n+            assert!(port.recv() == ~10);\n         }\n-    }\n \n-    #[test]\n-    fn oneshot_multi_task_recv_then_close() {\n-        do run_in_newsched_task {\n-            let (port, chan) = Chan::<~int>::new();\n-            do spawntask_later {\n-                let _chan = chan;\n-            }\n-            let res = do spawntask_try {\n-                assert!(port.recv() == ~10);\n-            };\n-            assert!(res.is_err());\n+        chan.send(~10);\n+    })\n+\n+    test!(fn oneshot_multi_task_recv_then_close() {\n+        let (port, chan) = Chan::<~int>::new();\n+        do spawn {\n+            let _chan = chan;\n         }\n-    }\n+        let res = do task::try {\n+            assert!(port.recv() == ~10);\n+        };\n+        assert!(res.is_err());\n+    })\n \n-    #[test]\n-    fn oneshot_multi_thread_close_stress() {\n+    test!(fn oneshot_multi_thread_close_stress() {\n         stress_factor().times(|| {\n-            do run_in_newsched_task {\n-                let (port, chan) = Chan::<int>::new();\n-                let thread = do spawntask_thread {\n-                    let _p = port;\n-                };\n-                let _chan = chan;\n-                thread.join();\n+            let (port, chan) = Chan::<int>::new();\n+            do spawn {\n+                let _p = port;\n             }\n+            let _chan = chan;\n         })\n-    }\n+    })\n \n-    #[test]\n-    fn oneshot_multi_thread_send_close_stress() {\n+    test!(fn oneshot_multi_thread_send_close_stress() {\n         stress_factor().times(|| {\n             let (port, chan) = Chan::<int>::new();\n             do spawn {\n@@ -1242,10 +1200,9 @@ mod test {\n                 chan.send(1);\n             };\n         })\n-    }\n+    })\n \n-    #[test]\n-    fn oneshot_multi_thread_recv_close_stress() {\n+    test!(fn oneshot_multi_thread_recv_close_stress() {\n         stress_factor().times(|| {\n             let (port, chan) = Chan::<int>::new();\n             do spawn {\n@@ -1262,10 +1219,9 @@ mod test {\n                 }\n             };\n         })\n-    }\n+    })\n \n-    #[test]\n-    fn oneshot_multi_thread_send_recv_stress() {\n+    test!(fn oneshot_multi_thread_send_recv_stress() {\n         stress_factor().times(|| {\n             let (port, chan) = Chan::<~int>::new();\n             do spawn {\n@@ -1275,10 +1231,9 @@ mod test {\n                 assert!(port.recv() == ~10);\n             }\n         })\n-    }\n+    })\n \n-    #[test]\n-    fn stream_send_recv_stress() {\n+    test!(fn stream_send_recv_stress() {\n         stress_factor().times(|| {\n             let (port, chan) = Chan::<~int>::new();\n \n@@ -1288,7 +1243,7 @@ mod test {\n             fn send(chan: Chan<~int>, i: int) {\n                 if i == 10 { return }\n \n-                do spawntask_random {\n+                do spawn {\n                     chan.send(~i);\n                     send(chan, i + 1);\n                 }\n@@ -1297,44 +1252,37 @@ mod test {\n             fn recv(port: Port<~int>, i: int) {\n                 if i == 10 { return }\n \n-                do spawntask_random {\n+                do spawn {\n                     assert!(port.recv() == ~i);\n                     recv(port, i + 1);\n                 };\n             }\n         })\n-    }\n+    })\n \n-    #[test]\n-    fn recv_a_lot() {\n+    test!(fn recv_a_lot() {\n         // Regression test that we don't run out of stack in scheduler context\n-        do run_in_newsched_task {\n-            let (port, chan) = Chan::new();\n-            10000.times(|| { chan.send(()) });\n-            10000.times(|| { port.recv() });\n-        }\n-    }\n+        let (port, chan) = Chan::new();\n+        10000.times(|| { chan.send(()) });\n+        10000.times(|| { port.recv() });\n+    })\n \n-    #[test]\n-    fn shared_chan_stress() {\n-        do run_in_mt_newsched_task {\n-            let (port, chan) = SharedChan::new();\n-            let total = stress_factor() + 100;\n-            total.times(|| {\n-                let chan_clone = chan.clone();\n-                do spawntask_random {\n-                    chan_clone.send(());\n-                }\n-            });\n+    test!(fn shared_chan_stress() {\n+        let (port, chan) = SharedChan::new();\n+        let total = stress_factor() + 100;\n+        total.times(|| {\n+            let chan_clone = chan.clone();\n+            do spawn {\n+                chan_clone.send(());\n+            }\n+        });\n \n-            total.times(|| {\n-                port.recv();\n-            });\n-        }\n-    }\n+        total.times(|| {\n+            port.recv();\n+        });\n+    })\n \n-    #[test]\n-    fn test_nested_recv_iter() {\n+    test!(fn test_nested_recv_iter() {\n         let (port, chan) = Chan::<int>::new();\n         let (total_port, total_chan) = Chan::<int>::new();\n \n@@ -1351,10 +1299,9 @@ mod test {\n         chan.send(2);\n         drop(chan);\n         assert_eq!(total_port.recv(), 6);\n-    }\n+    })\n \n-    #[test]\n-    fn test_recv_iter_break() {\n+    test!(fn test_recv_iter_break() {\n         let (port, chan) = Chan::<int>::new();\n         let (count_port, count_chan) = Chan::<int>::new();\n \n@@ -1376,5 +1323,5 @@ mod test {\n         chan.try_send(2);\n         drop(chan);\n         assert_eq!(count_port.recv(), 4);\n-    }\n+    })\n }"}, {"sha": "302c9d9ea469be20b9ea917caf3ba1443d8d97e5", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 29, "deletions": 91, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -50,10 +50,13 @@ use kinds::Send;\n use ops::Drop;\n use option::{Some, None, Option};\n use ptr::RawPtr;\n-use super::imp::BlockingContext;\n-use super::{Packet, Port, imp};\n+use result::{Ok, Err};\n+use rt::local::Local;\n+use rt::task::Task;\n+use super::{Packet, Port};\n+use sync::atomics::{Relaxed, SeqCst};\n+use task;\n use uint;\n-use unstable::atomics::{Relaxed, SeqCst};\n \n macro_rules! select {\n     (\n@@ -184,19 +187,22 @@ impl Select {\n             // Acquire a number of blocking contexts, and block on each one\n             // sequentially until one fails. If one fails, then abort\n             // immediately so we can go unblock on all the other ports.\n-            BlockingContext::many(amt, |ctx| {\n+            let task: ~Task = Local::take();\n+            task.deschedule(amt, |task| {\n+                // Prepare for the block\n                 let (i, packet) = iter.next().unwrap();\n+                assert!((*packet).to_wake.is_none());\n+                (*packet).to_wake = Some(task);\n                 (*packet).selecting.store(true, SeqCst);\n-                if !ctx.block(&mut (*packet).data,\n-                              &mut (*packet).to_wake,\n-                              || (*packet).decrement()) {\n+\n+                if (*packet).decrement() {\n+                    Ok(())\n+                } else {\n                     (*packet).abort_selection(false);\n                     (*packet).selecting.store(false, SeqCst);\n                     ready_index = i;\n                     ready_id = (*packet).selection_id;\n-                    false\n-                } else {\n-                    true\n+                    Err((*packet).to_wake.take_unwrap())\n                 }\n             });\n \n@@ -225,7 +231,7 @@ impl Select {\n                 if (*packet).abort_selection(true) {\n                     ready_id = (*packet).selection_id;\n                     while (*packet).selecting.load(Relaxed) {\n-                        imp::yield_now();\n+                        task::deschedule();\n                     }\n                 }\n             }\n@@ -304,6 +310,7 @@ impl Iterator<*mut Packet> for PacketIterator {\n }\n \n #[cfg(test)]\n+#[allow(unused_imports)]\n mod test {\n     use super::super::*;\n     use prelude::*;\n@@ -359,19 +366,16 @@ mod test {\n         )\n     })\n \n-    #[test]\n-    fn unblocks() {\n-        use std::io::timer;\n-\n+    test!(fn unblocks() {\n         let (mut p1, c1) = Chan::<int>::new();\n         let (mut p2, _c2) = Chan::<int>::new();\n         let (p3, c3) = Chan::<int>::new();\n \n         do spawn {\n-            timer::sleep(3);\n+            20.times(task::deschedule);\n             c1.send(1);\n             p3.recv();\n-            timer::sleep(3);\n+            20.times(task::deschedule);\n         }\n \n         select! (\n@@ -383,18 +387,15 @@ mod test {\n             a = p1.recv_opt() => { assert_eq!(a, None); },\n             _b = p2.recv() => { fail!() }\n         )\n-    }\n-\n-    #[test]\n-    fn both_ready() {\n-        use std::io::timer;\n+    })\n \n+    test!(fn both_ready() {\n         let (mut p1, c1) = Chan::<int>::new();\n         let (mut p2, c2) = Chan::<int>::new();\n         let (p3, c3) = Chan::<()>::new();\n \n         do spawn {\n-            timer::sleep(3);\n+            20.times(task::deschedule);\n             c1.send(1);\n             c2.send(2);\n             p3.recv();\n@@ -408,11 +409,12 @@ mod test {\n             a = p1.recv() => { assert_eq!(a, 1); },\n             a = p2.recv() => { assert_eq!(a, 2); }\n         )\n+        assert_eq!(p1.try_recv(), None);\n+        assert_eq!(p2.try_recv(), None);\n         c3.send(());\n-    }\n+    })\n \n-    #[test]\n-    fn stress() {\n+    test!(fn stress() {\n         static AMT: int = 10000;\n         let (mut p1, c1) = Chan::<int>::new();\n         let (mut p2, c2) = Chan::<int>::new();\n@@ -436,69 +438,5 @@ mod test {\n             )\n             c3.send(());\n         }\n-    }\n-\n-    #[test]\n-    #[ignore(cfg(windows))] // FIXME(#11003)\n-    fn stress_native() {\n-        use std::rt::thread::Thread;\n-        use std::unstable::run_in_bare_thread;\n-        static AMT: int = 10000;\n-\n-        do run_in_bare_thread {\n-            let (mut p1, c1) = Chan::<int>::new();\n-            let (mut p2, c2) = Chan::<int>::new();\n-            let (p3, c3) = Chan::<()>::new();\n-\n-            let t = do Thread::start {\n-                for i in range(0, AMT) {\n-                    if i % 2 == 0 {\n-                        c1.send(i);\n-                    } else {\n-                        c2.send(i);\n-                    }\n-                    p3.recv();\n-                }\n-            };\n-\n-            for i in range(0, AMT) {\n-                select! (\n-                    i1 = p1.recv() => { assert!(i % 2 == 0 && i == i1); },\n-                    i2 = p2.recv() => { assert!(i % 2 == 1 && i == i2); }\n-                )\n-                c3.send(());\n-            }\n-            t.join();\n-        }\n-    }\n-\n-    #[test]\n-    #[ignore(cfg(windows))] // FIXME(#11003)\n-    fn native_both_ready() {\n-        use std::rt::thread::Thread;\n-        use std::unstable::run_in_bare_thread;\n-\n-        do run_in_bare_thread {\n-            let (mut p1, c1) = Chan::<int>::new();\n-            let (mut p2, c2) = Chan::<int>::new();\n-            let (p3, c3) = Chan::<()>::new();\n-\n-            let t = do Thread::start {\n-                c1.send(1);\n-                c2.send(2);\n-                p3.recv();\n-            };\n-\n-            select! (\n-                a = p1.recv() => { assert_eq!(a, 1); },\n-                b = p2.recv() => { assert_eq!(b, 2); }\n-            )\n-            select! (\n-                a = p1.recv() => { assert_eq!(a, 1); },\n-                b = p2.recv() => { assert_eq!(b, 2); }\n-            )\n-            c3.send(());\n-            t.join();\n-        }\n-    }\n+    })\n }"}, {"sha": "b4838d534dcd6c05813f6c465b3e86711d98428e", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 60, "deletions": 93, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -54,7 +54,7 @@ use super::{SeekStyle, Read, Write, Open, IoError, Truncate,\n use rt::rtio::{RtioFileStream, IoFactory, LocalIo};\n use io;\n use option::{Some, None, Option};\n-use result::{Ok, Err, Result};\n+use result::{Ok, Err};\n use path;\n use path::{Path, GenericPath};\n use vec::{OwnedVector, ImmutableVector};\n@@ -75,17 +75,6 @@ pub struct File {\n     priv last_nread: int,\n }\n \n-fn io_raise<T>(f: |io: &mut IoFactory| -> Result<T, IoError>) -> Option<T> {\n-    let mut io = LocalIo::borrow();\n-    match f(io.get()) {\n-        Ok(t) => Some(t),\n-        Err(ioerr) => {\n-            io_error::cond.raise(ioerr);\n-            None\n-        }\n-    }\n-}\n-\n impl File {\n     /// Open a file at `path` in the mode specified by the `mode` and `access`\n     /// arguments\n@@ -131,18 +120,15 @@ impl File {\n     pub fn open_mode(path: &Path,\n                      mode: FileMode,\n                      access: FileAccess) -> Option<File> {\n-        let mut io = LocalIo::borrow();\n-        match io.get().fs_open(&path.to_c_str(), mode, access) {\n-            Ok(fd) => Some(File {\n-                path: path.clone(),\n-                fd: fd,\n-                last_nread: -1\n-            }),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+        LocalIo::maybe_raise(|io| {\n+            io.fs_open(&path.to_c_str(), mode, access).map(|fd| {\n+                File {\n+                    path: path.clone(),\n+                    fd: fd,\n+                    last_nread: -1\n+                }\n+            })\n+        })\n     }\n \n     /// Attempts to open a file in read-only mode. This function is equivalent to\n@@ -242,7 +228,7 @@ impl File {\n /// directory, the user lacks permissions to remove the file, or if some\n /// other filesystem-level error occurs.\n pub fn unlink(path: &Path) {\n-    io_raise(|io| io.fs_unlink(&path.to_c_str()));\n+    LocalIo::maybe_raise(|io| io.fs_unlink(&path.to_c_str()));\n }\n \n /// Given a path, query the file system to get information about a file,\n@@ -270,7 +256,9 @@ pub fn unlink(path: &Path) {\n /// requisite permissions to perform a `stat` call on the given path or if\n /// there is no entry in the filesystem at the provided path.\n pub fn stat(path: &Path) -> FileStat {\n-    io_raise(|io| io.fs_stat(&path.to_c_str())).unwrap_or_else(dummystat)\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_stat(&path.to_c_str())\n+    }).unwrap_or_else(dummystat)\n }\n \n fn dummystat() -> FileStat {\n@@ -306,7 +294,9 @@ fn dummystat() -> FileStat {\n ///\n /// See `stat`\n pub fn lstat(path: &Path) -> FileStat {\n-    io_raise(|io| io.fs_lstat(&path.to_c_str())).unwrap_or_else(dummystat)\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_lstat(&path.to_c_str())\n+    }).unwrap_or_else(dummystat)\n }\n \n /// Rename a file or directory to a new name.\n@@ -324,7 +314,7 @@ pub fn lstat(path: &Path) -> FileStat {\n /// the process lacks permissions to view the contents, or if some other\n /// intermittent I/O error occurs.\n pub fn rename(from: &Path, to: &Path) {\n-    io_raise(|io| io.fs_rename(&from.to_c_str(), &to.to_c_str()));\n+    LocalIo::maybe_raise(|io| io.fs_rename(&from.to_c_str(), &to.to_c_str()));\n }\n \n /// Copies the contents of one file to another. This function will also\n@@ -395,7 +385,7 @@ pub fn copy(from: &Path, to: &Path) {\n /// condition. Some possible error situations are not having the permission to\n /// change the attributes of a file or the file not existing.\n pub fn chmod(path: &Path, mode: io::FilePermission) {\n-    io_raise(|io| io.fs_chmod(&path.to_c_str(), mode));\n+    LocalIo::maybe_raise(|io| io.fs_chmod(&path.to_c_str(), mode));\n }\n \n /// Change the user and group owners of a file at the specified path.\n@@ -404,7 +394,7 @@ pub fn chmod(path: &Path, mode: io::FilePermission) {\n ///\n /// This function will raise on the `io_error` condition on failure.\n pub fn chown(path: &Path, uid: int, gid: int) {\n-    io_raise(|io| io.fs_chown(&path.to_c_str(), uid, gid));\n+    LocalIo::maybe_raise(|io| io.fs_chown(&path.to_c_str(), uid, gid));\n }\n \n /// Creates a new hard link on the filesystem. The `dst` path will be a\n@@ -415,7 +405,7 @@ pub fn chown(path: &Path, uid: int, gid: int) {\n ///\n /// This function will raise on the `io_error` condition on failure.\n pub fn link(src: &Path, dst: &Path) {\n-    io_raise(|io| io.fs_link(&src.to_c_str(), &dst.to_c_str()));\n+    LocalIo::maybe_raise(|io| io.fs_link(&src.to_c_str(), &dst.to_c_str()));\n }\n \n /// Creates a new symbolic link on the filesystem. The `dst` path will be a\n@@ -425,7 +415,7 @@ pub fn link(src: &Path, dst: &Path) {\n ///\n /// This function will raise on the `io_error` condition on failure.\n pub fn symlink(src: &Path, dst: &Path) {\n-    io_raise(|io| io.fs_symlink(&src.to_c_str(), &dst.to_c_str()));\n+    LocalIo::maybe_raise(|io| io.fs_symlink(&src.to_c_str(), &dst.to_c_str()));\n }\n \n /// Reads a symlink, returning the file that the symlink points to.\n@@ -436,7 +426,7 @@ pub fn symlink(src: &Path, dst: &Path) {\n /// conditions include reading a file that does not exist or reading a file\n /// which is not a symlink.\n pub fn readlink(path: &Path) -> Option<Path> {\n-    io_raise(|io| io.fs_readlink(&path.to_c_str()))\n+    LocalIo::maybe_raise(|io| io.fs_readlink(&path.to_c_str()))\n }\n \n /// Create a new, empty directory at the provided path\n@@ -456,7 +446,7 @@ pub fn readlink(path: &Path) -> Option<Path> {\n /// to make a new directory at the provided path, or if the directory already\n /// exists.\n pub fn mkdir(path: &Path, mode: FilePermission) {\n-    io_raise(|io| io.fs_mkdir(&path.to_c_str(), mode));\n+    LocalIo::maybe_raise(|io| io.fs_mkdir(&path.to_c_str(), mode));\n }\n \n /// Remove an existing, empty directory\n@@ -475,7 +465,7 @@ pub fn mkdir(path: &Path, mode: FilePermission) {\n /// to remove the directory at the provided path, or if the directory isn't\n /// empty.\n pub fn rmdir(path: &Path) {\n-    io_raise(|io| io.fs_rmdir(&path.to_c_str()));\n+    LocalIo::maybe_raise(|io| io.fs_rmdir(&path.to_c_str()));\n }\n \n /// Retrieve a vector containing all entries within a provided directory\n@@ -502,7 +492,9 @@ pub fn rmdir(path: &Path) {\n /// the process lacks permissions to view the contents or if the `path` points\n /// at a non-directory file\n pub fn readdir(path: &Path) -> ~[Path] {\n-    io_raise(|io| io.fs_readdir(&path.to_c_str(), 0)).unwrap_or_else(|| ~[])\n+    LocalIo::maybe_raise(|io| {\n+        io.fs_readdir(&path.to_c_str(), 0)\n+    }).unwrap_or_else(|| ~[])\n }\n \n /// Returns an iterator which will recursively walk the directory structure\n@@ -583,7 +575,7 @@ pub fn rmdir_recursive(path: &Path) {\n /// happens.\n // FIXME(#10301) these arguments should not be u64\n pub fn change_file_times(path: &Path, atime: u64, mtime: u64) {\n-    io_raise(|io| io.fs_utime(&path.to_c_str(), atime, mtime));\n+    LocalIo::maybe_raise(|io| io.fs_utime(&path.to_c_str(), atime, mtime));\n }\n \n impl Reader for File {\n@@ -722,40 +714,15 @@ mod test {\n         }\n     }\n \n-    fn tmpdir() -> TempDir {\n+    pub fn tmpdir() -> TempDir {\n         use os;\n         use rand;\n         let ret = os::tmpdir().join(format!(\"rust-{}\", rand::random::<u32>()));\n         io::fs::mkdir(&ret, io::UserRWX);\n         TempDir(ret)\n     }\n \n-    macro_rules! test (\n-        { fn $name:ident() $b:block } => (\n-            mod $name {\n-                use prelude::*;\n-                use io::{SeekSet, SeekCur, SeekEnd, io_error, Read, Open,\n-                         ReadWrite};\n-                use io;\n-                use str;\n-                use io::fs::{File, rmdir, mkdir, readdir, rmdir_recursive,\n-                             mkdir_recursive, copy, unlink, stat, symlink, link,\n-                             readlink, chmod, lstat, change_file_times};\n-                use io::fs::test::tmpdir;\n-                use util;\n-\n-                fn f() $b\n-\n-                #[test] fn uv() { f() }\n-                #[test] fn native() {\n-                    use rt::test::run_in_newsched_task;\n-                    run_in_newsched_task(f);\n-                }\n-            }\n-        )\n-    )\n-\n-    test!(fn file_test_io_smoke_test() {\n+    iotest!(fn file_test_io_smoke_test() {\n         let message = \"it's alright. have a good time\";\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_rt_io_file_test.txt\");\n@@ -775,7 +742,7 @@ mod test {\n         unlink(filename);\n     })\n \n-    test!(fn invalid_path_raises() {\n+    iotest!(fn invalid_path_raises() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_that_does_not_exist.txt\");\n         let mut called = false;\n@@ -788,7 +755,7 @@ mod test {\n         assert!(called);\n     })\n \n-    test!(fn file_test_iounlinking_invalid_path_should_raise_condition() {\n+    iotest!(fn file_test_iounlinking_invalid_path_should_raise_condition() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_another_file_that_does_not_exist.txt\");\n         let mut called = false;\n@@ -798,7 +765,7 @@ mod test {\n         assert!(called);\n     })\n \n-    test!(fn file_test_io_non_positional_read() {\n+    iotest!(fn file_test_io_non_positional_read() {\n         let message: &str = \"ten-four\";\n         let mut read_mem = [0, .. 8];\n         let tmpdir = tmpdir();\n@@ -823,7 +790,7 @@ mod test {\n         assert_eq!(read_str, message);\n     })\n \n-    test!(fn file_test_io_seek_and_tell_smoke_test() {\n+    iotest!(fn file_test_io_seek_and_tell_smoke_test() {\n         let message = \"ten-four\";\n         let mut read_mem = [0, .. 4];\n         let set_cursor = 4 as u64;\n@@ -849,7 +816,7 @@ mod test {\n         assert_eq!(tell_pos_post_read, message.len() as u64);\n     })\n \n-    test!(fn file_test_io_seek_and_write() {\n+    iotest!(fn file_test_io_seek_and_write() {\n         let initial_msg =   \"food-is-yummy\";\n         let overwrite_msg =    \"-the-bar!!\";\n         let final_msg =     \"foo-the-bar!!\";\n@@ -872,7 +839,7 @@ mod test {\n         assert!(read_str == final_msg.to_owned());\n     })\n \n-    test!(fn file_test_io_seek_shakedown() {\n+    iotest!(fn file_test_io_seek_shakedown() {\n         use std::str;          // 01234567890123\n         let initial_msg =   \"qwer-asdf-zxcv\";\n         let chunk_one: &str = \"qwer\";\n@@ -903,7 +870,7 @@ mod test {\n         unlink(filename);\n     })\n \n-    test!(fn file_test_stat_is_correct_on_is_file() {\n+    iotest!(fn file_test_stat_is_correct_on_is_file() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_stat_correct_on_is_file.txt\");\n         {\n@@ -916,7 +883,7 @@ mod test {\n         unlink(filename);\n     })\n \n-    test!(fn file_test_stat_is_correct_on_is_dir() {\n+    iotest!(fn file_test_stat_is_correct_on_is_dir() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_stat_correct_on_is_dir\");\n         mkdir(filename, io::UserRWX);\n@@ -925,15 +892,15 @@ mod test {\n         rmdir(filename);\n     })\n \n-    test!(fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n+    iotest!(fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"fileinfo_false_on_dir\");\n         mkdir(dir, io::UserRWX);\n         assert!(dir.is_file() == false);\n         rmdir(dir);\n     })\n \n-    test!(fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n+    iotest!(fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n         let tmpdir = tmpdir();\n         let file = &tmpdir.join(\"fileinfo_check_exists_b_and_a.txt\");\n         File::create(file).write(bytes!(\"foo\"));\n@@ -942,7 +909,7 @@ mod test {\n         assert!(!file.exists());\n     })\n \n-    test!(fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n+    iotest!(fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"before_and_after_dir\");\n         assert!(!dir.exists());\n@@ -953,7 +920,7 @@ mod test {\n         assert!(!dir.exists());\n     })\n \n-    test!(fn file_test_directoryinfo_readdir() {\n+    iotest!(fn file_test_directoryinfo_readdir() {\n         use std::str;\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"di_readdir\");\n@@ -984,11 +951,11 @@ mod test {\n         rmdir(dir);\n     })\n \n-    test!(fn recursive_mkdir_slash() {\n+    iotest!(fn recursive_mkdir_slash() {\n         mkdir_recursive(&Path::new(\"/\"), io::UserRWX);\n     })\n \n-    test!(fn unicode_path_is_dir() {\n+    iotest!(fn unicode_path_is_dir() {\n         assert!(Path::new(\".\").is_dir());\n         assert!(!Path::new(\"test/stdtest/fs.rs\").is_dir());\n \n@@ -1006,7 +973,7 @@ mod test {\n         assert!(filepath.exists());\n     })\n \n-    test!(fn unicode_path_exists() {\n+    iotest!(fn unicode_path_exists() {\n         assert!(Path::new(\".\").exists());\n         assert!(!Path::new(\"test/nonexistent-bogus-path\").exists());\n \n@@ -1018,7 +985,7 @@ mod test {\n         assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n     })\n \n-    test!(fn copy_file_does_not_exist() {\n+    iotest!(fn copy_file_does_not_exist() {\n         let from = Path::new(\"test/nonexistent-bogus-path\");\n         let to = Path::new(\"test/other-bogus-path\");\n         match io::result(|| copy(&from, &to)) {\n@@ -1030,7 +997,7 @@ mod test {\n         }\n     })\n \n-    test!(fn copy_file_ok() {\n+    iotest!(fn copy_file_ok() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n@@ -1043,7 +1010,7 @@ mod test {\n         assert_eq!(input.stat().perm, out.stat().perm);\n     })\n \n-    test!(fn copy_file_dst_dir() {\n+    iotest!(fn copy_file_dst_dir() {\n         let tmpdir = tmpdir();\n         let out = tmpdir.join(\"out\");\n \n@@ -1053,7 +1020,7 @@ mod test {\n         }\n     })\n \n-    test!(fn copy_file_dst_exists() {\n+    iotest!(fn copy_file_dst_exists() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in\");\n         let output = tmpdir.join(\"out\");\n@@ -1066,7 +1033,7 @@ mod test {\n                    (bytes!(\"foo\")).to_owned());\n     })\n \n-    test!(fn copy_file_src_dir() {\n+    iotest!(fn copy_file_src_dir() {\n         let tmpdir = tmpdir();\n         let out = tmpdir.join(\"out\");\n \n@@ -1076,7 +1043,7 @@ mod test {\n         assert!(!out.exists());\n     })\n \n-    test!(fn copy_file_preserves_perm_bits() {\n+    iotest!(fn copy_file_preserves_perm_bits() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n@@ -1091,7 +1058,7 @@ mod test {\n     })\n \n     #[cfg(not(windows))] // FIXME(#10264) operation not permitted?\n-    test!(fn symlinks_work() {\n+    iotest!(fn symlinks_work() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n@@ -1106,22 +1073,22 @@ mod test {\n     })\n \n     #[cfg(not(windows))] // apparently windows doesn't like symlinks\n-    test!(fn symlink_noexist() {\n+    iotest!(fn symlink_noexist() {\n         let tmpdir = tmpdir();\n         // symlinks can point to things that don't exist\n         symlink(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\"));\n         assert!(readlink(&tmpdir.join(\"bar\")).unwrap() == tmpdir.join(\"foo\"));\n     })\n \n-    test!(fn readlink_not_symlink() {\n+    iotest!(fn readlink_not_symlink() {\n         let tmpdir = tmpdir();\n         match io::result(|| readlink(&*tmpdir)) {\n             Ok(..) => fail!(\"wanted a failure\"),\n             Err(..) => {}\n         }\n     })\n \n-    test!(fn links_work() {\n+    iotest!(fn links_work() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n@@ -1147,7 +1114,7 @@ mod test {\n         }\n     })\n \n-    test!(fn chmod_works() {\n+    iotest!(fn chmod_works() {\n         let tmpdir = tmpdir();\n         let file = tmpdir.join(\"in.txt\");\n \n@@ -1164,7 +1131,7 @@ mod test {\n         chmod(&file, io::UserFile);\n     })\n \n-    test!(fn sync_doesnt_kill_anything() {\n+    iotest!(fn sync_doesnt_kill_anything() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"in.txt\");\n \n@@ -1177,7 +1144,7 @@ mod test {\n         drop(file);\n     })\n \n-    test!(fn truncate_works() {\n+    iotest!(fn truncate_works() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"in.txt\");\n \n@@ -1208,7 +1175,7 @@ mod test {\n         drop(file);\n     })\n \n-    test!(fn open_flavors() {\n+    iotest!(fn open_flavors() {\n         let tmpdir = tmpdir();\n \n         match io::result(|| File::open_mode(&tmpdir.join(\"a\"), io::Open,"}, {"sha": "2d52986294d1c6884ea61e843e433e6c3d2d3083", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -164,9 +164,6 @@ requests are implemented by descheduling the running task and\n performing an asynchronous request; the task is only resumed once the\n asynchronous request completes.\n \n-For blocking (but possibly more efficient) implementations, look\n-in the `io::native` module.\n-\n # Error Handling\n \n I/O is an area where nearly every operation can result in unexpected\n@@ -316,6 +313,9 @@ pub use self::net::udp::UdpStream;\n pub use self::pipe::PipeStream;\n pub use self::process::Process;\n \n+/// Various utility functions useful for writing I/O tests\n+pub mod test;\n+\n /// Synchronous, non-blocking filesystem operations.\n pub mod fs;\n \n@@ -349,8 +349,6 @@ pub mod timer;\n /// Buffered I/O wrappers\n pub mod buffered;\n \n-pub mod native;\n-\n /// Signal handling\n pub mod signal;\n "}, {"sha": "6d968de209ca85f07f3a128bfd8b27b7b6eeec4b", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -18,8 +18,6 @@ getaddrinfo()\n */\n \n use option::{Option, Some, None};\n-use result::{Ok, Err};\n-use io::{io_error};\n use io::net::ip::{SocketAddr, IpAddr};\n use rt::rtio::{IoFactory, LocalIo};\n use vec::ImmutableVector;\n@@ -97,14 +95,7 @@ pub fn get_host_addresses(host: &str) -> Option<~[IpAddr]> {\n ///      consumption just yet.\n fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)\n           -> Option<~[Info]> {\n-    let mut io = LocalIo::borrow();\n-    match io.get().get_host_addresses(hostname, servname, hint) {\n-        Ok(i) => Some(i),\n-        Err(ioerr) => {\n-            io_error::cond.raise(ioerr);\n-            None\n-        }\n-    }\n+    LocalIo::maybe_raise(|io| io.get_host_addresses(hostname, servname, hint))\n }\n \n #[cfg(test)]"}, {"sha": "e7787692dd2f56f2a8f42ad5f5828ffdbc6a334e", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 321, "deletions": 375, "changes": 696, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -26,17 +26,9 @@ impl TcpStream {\n     }\n \n     pub fn connect(addr: SocketAddr) -> Option<TcpStream> {\n-        let result = {\n-            let mut io = LocalIo::borrow();\n-            io.get().tcp_connect(addr)\n-        };\n-        match result {\n-            Ok(s) => Some(TcpStream::new(s)),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+        LocalIo::maybe_raise(|io| {\n+            io.tcp_connect(addr).map(TcpStream::new)\n+        })\n     }\n \n     pub fn peer_name(&mut self) -> Option<SocketAddr> {\n@@ -94,14 +86,9 @@ pub struct TcpListener {\n \n impl TcpListener {\n     pub fn bind(addr: SocketAddr) -> Option<TcpListener> {\n-        let mut io = LocalIo::borrow();\n-        match io.get().tcp_bind(addr) {\n-            Ok(l) => Some(TcpListener { obj: l }),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+        LocalIo::maybe_raise(|io| {\n+            io.tcp_bind(addr).map(|l| TcpListener { obj: l })\n+        })\n     }\n \n     pub fn socket_name(&mut self) -> Option<SocketAddr> {\n@@ -147,513 +134,473 @@ impl Acceptor<TcpStream> for TcpAcceptor {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use rt::test::*;\n     use io::net::ip::{Ipv4Addr, SocketAddr};\n     use io::*;\n+    use io::test::{next_test_ip4, next_test_ip6};\n     use prelude::*;\n \n     #[test] #[ignore]\n     fn bind_error() {\n-        do run_in_mt_newsched_task {\n-            let mut called = false;\n-            io_error::cond.trap(|e| {\n-                assert!(e.kind == PermissionDenied);\n-                called = true;\n-            }).inside(|| {\n-                let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n-                let listener = TcpListener::bind(addr);\n-                assert!(listener.is_none());\n-            });\n-            assert!(called);\n-        }\n+        let mut called = false;\n+        io_error::cond.trap(|e| {\n+            assert!(e.kind == PermissionDenied);\n+            called = true;\n+        }).inside(|| {\n+            let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n+            let listener = TcpListener::bind(addr);\n+            assert!(listener.is_none());\n+        });\n+        assert!(called);\n     }\n \n     #[test]\n     fn connect_error() {\n-        do run_in_mt_newsched_task {\n-            let mut called = false;\n-            io_error::cond.trap(|e| {\n-                let expected_error = if cfg!(unix) {\n-                    ConnectionRefused\n-                } else {\n-                    // On Win32, opening port 1 gives WSAEADDRNOTAVAIL error.\n-                    OtherIoError\n-                };\n-                assert_eq!(e.kind, expected_error);\n-                called = true;\n-            }).inside(|| {\n-                let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n-                let stream = TcpStream::connect(addr);\n-                assert!(stream.is_none());\n-            });\n-            assert!(called);\n-        }\n+        let mut called = false;\n+        io_error::cond.trap(|e| {\n+            let expected_error = if cfg!(unix) {\n+                ConnectionRefused\n+            } else {\n+                // On Win32, opening port 1 gives WSAEADDRNOTAVAIL error.\n+                OtherIoError\n+            };\n+            assert_eq!(e.kind, expected_error);\n+            called = true;\n+        }).inside(|| {\n+            let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n+            let stream = TcpStream::connect(addr);\n+            assert!(stream.is_none());\n+        });\n+        assert!(called);\n     }\n \n     #[test]\n     fn smoke_test_ip4() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip4();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                let mut stream = acceptor.accept();\n-                let mut buf = [0];\n-                stream.read(buf);\n-                assert!(buf[0] == 99);\n-            }\n+        let addr = next_test_ip4();\n+        let (port, chan) = Chan::new();\n \n+        do spawn {\n             port.recv();\n             let mut stream = TcpStream::connect(addr);\n             stream.write([99]);\n         }\n+\n+        let mut acceptor = TcpListener::bind(addr).listen();\n+        chan.send(());\n+        let mut stream = acceptor.accept();\n+        let mut buf = [0];\n+        stream.read(buf);\n+        assert!(buf[0] == 99);\n     }\n \n     #[test]\n     fn smoke_test_ip6() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip6();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                let mut stream = acceptor.accept();\n-                let mut buf = [0];\n-                stream.read(buf);\n-                assert!(buf[0] == 99);\n-            }\n+        let addr = next_test_ip6();\n+        let (port, chan) = Chan::new();\n \n+        do spawn {\n             port.recv();\n             let mut stream = TcpStream::connect(addr);\n             stream.write([99]);\n         }\n+\n+        let mut acceptor = TcpListener::bind(addr).listen();\n+        chan.send(());\n+        let mut stream = acceptor.accept();\n+        let mut buf = [0];\n+        stream.read(buf);\n+        assert!(buf[0] == 99);\n     }\n \n     #[test]\n     fn read_eof_ip4() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip4();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                let mut stream = acceptor.accept();\n-                let mut buf = [0];\n-                let nread = stream.read(buf);\n-                assert!(nread.is_none());\n-            }\n+        let addr = next_test_ip4();\n+        let (port, chan) = Chan::new();\n \n+        do spawn {\n             port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n         }\n+\n+        let mut acceptor = TcpListener::bind(addr).listen();\n+        chan.send(());\n+        let mut stream = acceptor.accept();\n+        let mut buf = [0];\n+        let nread = stream.read(buf);\n+        assert!(nread.is_none());\n     }\n \n     #[test]\n     fn read_eof_ip6() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip6();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                let mut stream = acceptor.accept();\n-                let mut buf = [0];\n-                let nread = stream.read(buf);\n-                assert!(nread.is_none());\n-            }\n+        let addr = next_test_ip6();\n+        let (port, chan) = Chan::new();\n \n+        do spawn {\n             port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n         }\n+\n+        let mut acceptor = TcpListener::bind(addr).listen();\n+        chan.send(());\n+        let mut stream = acceptor.accept();\n+        let mut buf = [0];\n+        let nread = stream.read(buf);\n+        assert!(nread.is_none());\n     }\n \n     #[test]\n     fn read_eof_twice_ip4() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip4();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                let mut stream = acceptor.accept();\n-                let mut buf = [0];\n-                let nread = stream.read(buf);\n-                assert!(nread.is_none());\n-                io_error::cond.trap(|e| {\n-                    if cfg!(windows) {\n-                        assert_eq!(e.kind, NotConnected);\n-                    } else {\n-                        fail!();\n-                    }\n-                }).inside(|| {\n-                    let nread = stream.read(buf);\n-                    assert!(nread.is_none());\n-                })\n-            }\n+        let addr = next_test_ip4();\n+        let (port, chan) = Chan::new();\n \n+        do spawn {\n             port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n         }\n+\n+        let mut acceptor = TcpListener::bind(addr).listen();\n+        chan.send(());\n+        let mut stream = acceptor.accept();\n+        let mut buf = [0];\n+        let nread = stream.read(buf);\n+        assert!(nread.is_none());\n+        io_error::cond.trap(|e| {\n+            if cfg!(windows) {\n+                assert_eq!(e.kind, NotConnected);\n+            } else {\n+                fail!();\n+            }\n+        }).inside(|| {\n+            let nread = stream.read(buf);\n+            assert!(nread.is_none());\n+        })\n     }\n \n     #[test]\n     fn read_eof_twice_ip6() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip6();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                let mut stream = acceptor.accept();\n-                let mut buf = [0];\n-                let nread = stream.read(buf);\n-                assert!(nread.is_none());\n-                io_error::cond.trap(|e| {\n-                    if cfg!(windows) {\n-                        assert_eq!(e.kind, NotConnected);\n-                    } else {\n-                        fail!();\n-                    }\n-                }).inside(|| {\n-                    let nread = stream.read(buf);\n-                    assert!(nread.is_none());\n-                })\n-            }\n+        let addr = next_test_ip6();\n+        let (port, chan) = Chan::new();\n \n+        do spawn {\n             port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n         }\n+\n+        let mut acceptor = TcpListener::bind(addr).listen();\n+        chan.send(());\n+        let mut stream = acceptor.accept();\n+        let mut buf = [0];\n+        let nread = stream.read(buf);\n+        assert!(nread.is_none());\n+        io_error::cond.trap(|e| {\n+            if cfg!(windows) {\n+                assert_eq!(e.kind, NotConnected);\n+            } else {\n+                fail!();\n+            }\n+        }).inside(|| {\n+            let nread = stream.read(buf);\n+            assert!(nread.is_none());\n+        })\n     }\n \n     #[test]\n     fn write_close_ip4() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip4();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                let mut stream = acceptor.accept();\n-                let buf = [0];\n-                loop {\n-                    let mut stop = false;\n-                    io_error::cond.trap(|e| {\n-                        // NB: ECONNRESET on linux, EPIPE on mac, ECONNABORTED\n-                        //     on windows\n-                        assert!(e.kind == ConnectionReset ||\n-                                e.kind == BrokenPipe ||\n-                                e.kind == ConnectionAborted,\n-                                \"unknown error: {:?}\", e);\n-                        stop = true;\n-                    }).inside(|| {\n-                        stream.write(buf);\n-                    });\n-                    if stop { break }\n-                }\n-            }\n+        let addr = next_test_ip4();\n+        let (port, chan) = Chan::new();\n \n+        do spawn {\n             port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n         }\n+\n+        let mut acceptor = TcpListener::bind(addr).listen();\n+        chan.send(());\n+        let mut stream = acceptor.accept();\n+        let buf = [0];\n+        loop {\n+            let mut stop = false;\n+            io_error::cond.trap(|e| {\n+                // NB: ECONNRESET on linux, EPIPE on mac, ECONNABORTED\n+                //     on windows\n+                assert!(e.kind == ConnectionReset ||\n+                        e.kind == BrokenPipe ||\n+                        e.kind == ConnectionAborted,\n+                        \"unknown error: {:?}\", e);\n+                stop = true;\n+            }).inside(|| {\n+                stream.write(buf);\n+            });\n+            if stop { break }\n+        }\n     }\n \n     #[test]\n     fn write_close_ip6() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip6();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                let mut stream = acceptor.accept();\n-                let buf = [0];\n-                loop {\n-                    let mut stop = false;\n-                    io_error::cond.trap(|e| {\n-                        // NB: ECONNRESET on linux, EPIPE on mac, ECONNABORTED\n-                        //     on windows\n-                        assert!(e.kind == ConnectionReset ||\n-                                e.kind == BrokenPipe ||\n-                                e.kind == ConnectionAborted,\n-                                \"unknown error: {:?}\", e);\n-                        stop = true;\n-                    }).inside(|| {\n-                        stream.write(buf);\n-                    });\n-                    if stop { break }\n-                }\n-            }\n+        let addr = next_test_ip6();\n+        let (port, chan) = Chan::new();\n \n+        do spawn {\n             port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n         }\n+\n+        let mut acceptor = TcpListener::bind(addr).listen();\n+        chan.send(());\n+        let mut stream = acceptor.accept();\n+        let buf = [0];\n+        loop {\n+            let mut stop = false;\n+            io_error::cond.trap(|e| {\n+                // NB: ECONNRESET on linux, EPIPE on mac, ECONNABORTED\n+                //     on windows\n+                assert!(e.kind == ConnectionReset ||\n+                        e.kind == BrokenPipe ||\n+                        e.kind == ConnectionAborted,\n+                        \"unknown error: {:?}\", e);\n+                stop = true;\n+            }).inside(|| {\n+                stream.write(buf);\n+            });\n+            if stop { break }\n+        }\n     }\n \n     #[test]\n     fn multiple_connect_serial_ip4() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip4();\n-            let max = 10;\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                for ref mut stream in acceptor.incoming().take(max) {\n-                    let mut buf = [0];\n-                    stream.read(buf);\n-                    assert_eq!(buf[0], 99);\n-                }\n-            }\n+        let addr = next_test_ip4();\n+        let max = 10;\n+        let (port, chan) = Chan::new();\n \n+        do spawn {\n             port.recv();\n             max.times(|| {\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write([99]);\n             });\n         }\n+\n+        let mut acceptor = TcpListener::bind(addr).listen();\n+        chan.send(());\n+        for ref mut stream in acceptor.incoming().take(max) {\n+            let mut buf = [0];\n+            stream.read(buf);\n+            assert_eq!(buf[0], 99);\n+        }\n     }\n \n     #[test]\n     fn multiple_connect_serial_ip6() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip6();\n-            let max = 10;\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                for ref mut stream in acceptor.incoming().take(max) {\n-                    let mut buf = [0];\n-                    stream.read(buf);\n-                    assert_eq!(buf[0], 99);\n-                }\n-            }\n+        let addr = next_test_ip6();\n+        let max = 10;\n+        let (port, chan) = Chan::new();\n \n+        do spawn {\n             port.recv();\n             max.times(|| {\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write([99]);\n             });\n         }\n+\n+        let mut acceptor = TcpListener::bind(addr).listen();\n+        chan.send(());\n+        for ref mut stream in acceptor.incoming().take(max) {\n+            let mut buf = [0];\n+            stream.read(buf);\n+            assert_eq!(buf[0], 99);\n+        }\n     }\n \n     #[test]\n     fn multiple_connect_interleaved_greedy_schedule_ip4() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip4();\n-            static MAX: int = 10;\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n-                    // Start another task to handle the connection\n-                    do spawntask {\n-                        let mut stream = stream;\n-                        let mut buf = [0];\n-                        stream.read(buf);\n-                        assert!(buf[0] == i as u8);\n-                        debug!(\"read\");\n-                    }\n+        let addr = next_test_ip4();\n+        static MAX: int = 10;\n+        let (port, chan) = Chan::new();\n+\n+        do spawn {\n+            let mut acceptor = TcpListener::bind(addr).listen();\n+            chan.send(());\n+            for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n+                // Start another task to handle the connection\n+                do spawn {\n+                    let mut stream = stream;\n+                    let mut buf = [0];\n+                    stream.read(buf);\n+                    assert!(buf[0] == i as u8);\n+                    debug!(\"read\");\n                 }\n             }\n+        }\n \n-            port.recv();\n-            connect(0, addr);\n-\n-            fn connect(i: int, addr: SocketAddr) {\n-                if i == MAX { return }\n-\n-                do spawntask {\n-                    debug!(\"connecting\");\n-                    let mut stream = TcpStream::connect(addr);\n-                    // Connect again before writing\n-                    connect(i + 1, addr);\n-                    debug!(\"writing\");\n-                    stream.write([i as u8]);\n-                }\n+        port.recv();\n+        connect(0, addr);\n+\n+        fn connect(i: int, addr: SocketAddr) {\n+            if i == MAX { return }\n+\n+            do spawn {\n+                debug!(\"connecting\");\n+                let mut stream = TcpStream::connect(addr);\n+                // Connect again before writing\n+                connect(i + 1, addr);\n+                debug!(\"writing\");\n+                stream.write([i as u8]);\n             }\n         }\n     }\n \n     #[test]\n     fn multiple_connect_interleaved_greedy_schedule_ip6() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip6();\n-            static MAX: int = 10;\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n-                    // Start another task to handle the connection\n-                    do spawntask {\n-                        let mut stream = stream;\n-                        let mut buf = [0];\n-                        stream.read(buf);\n-                        assert!(buf[0] == i as u8);\n-                        debug!(\"read\");\n-                    }\n+        let addr = next_test_ip6();\n+        static MAX: int = 10;\n+        let (port, chan) = Chan::<()>::new();\n+\n+        do spawn {\n+            let mut acceptor = TcpListener::bind(addr).listen();\n+            chan.send(());\n+            for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n+                // Start another task to handle the connection\n+                do spawn {\n+                    let mut stream = stream;\n+                    let mut buf = [0];\n+                    stream.read(buf);\n+                    assert!(buf[0] == i as u8);\n+                    debug!(\"read\");\n                 }\n             }\n+        }\n \n-            port.recv();\n-            connect(0, addr);\n-\n-            fn connect(i: int, addr: SocketAddr) {\n-                if i == MAX { return }\n-\n-                do spawntask {\n-                    debug!(\"connecting\");\n-                    let mut stream = TcpStream::connect(addr);\n-                    // Connect again before writing\n-                    connect(i + 1, addr);\n-                    debug!(\"writing\");\n-                    stream.write([i as u8]);\n-                }\n+        port.recv();\n+        connect(0, addr);\n+\n+        fn connect(i: int, addr: SocketAddr) {\n+            if i == MAX { return }\n+\n+            do spawn {\n+                debug!(\"connecting\");\n+                let mut stream = TcpStream::connect(addr);\n+                // Connect again before writing\n+                connect(i + 1, addr);\n+                debug!(\"writing\");\n+                stream.write([i as u8]);\n             }\n         }\n     }\n \n     #[test]\n     fn multiple_connect_interleaved_lazy_schedule_ip4() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip4();\n-            static MAX: int = 10;\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                for stream in acceptor.incoming().take(MAX as uint) {\n-                    // Start another task to handle the connection\n-                    do spawntask_later {\n-                        let mut stream = stream;\n-                        let mut buf = [0];\n-                        stream.read(buf);\n-                        assert!(buf[0] == 99);\n-                        debug!(\"read\");\n-                    }\n+        let addr = next_test_ip4();\n+        static MAX: int = 10;\n+        let (port, chan) = Chan::new();\n+\n+        do spawn {\n+            let mut acceptor = TcpListener::bind(addr).listen();\n+            chan.send(());\n+            for stream in acceptor.incoming().take(MAX as uint) {\n+                // Start another task to handle the connection\n+                do spawn {\n+                    let mut stream = stream;\n+                    let mut buf = [0];\n+                    stream.read(buf);\n+                    assert!(buf[0] == 99);\n+                    debug!(\"read\");\n                 }\n             }\n+        }\n \n-            port.recv();\n-            connect(0, addr);\n-\n-            fn connect(i: int, addr: SocketAddr) {\n-                if i == MAX { return }\n-\n-                do spawntask_later {\n-                    debug!(\"connecting\");\n-                    let mut stream = TcpStream::connect(addr);\n-                    // Connect again before writing\n-                    connect(i + 1, addr);\n-                    debug!(\"writing\");\n-                    stream.write([99]);\n-                }\n+        port.recv();\n+        connect(0, addr);\n+\n+        fn connect(i: int, addr: SocketAddr) {\n+            if i == MAX { return }\n+\n+            do spawn {\n+                debug!(\"connecting\");\n+                let mut stream = TcpStream::connect(addr);\n+                // Connect again before writing\n+                connect(i + 1, addr);\n+                debug!(\"writing\");\n+                stream.write([99]);\n             }\n         }\n     }\n     #[test]\n     fn multiple_connect_interleaved_lazy_schedule_ip6() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip6();\n-            static MAX: int = 10;\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                for stream in acceptor.incoming().take(MAX as uint) {\n-                    // Start another task to handle the connection\n-                    do spawntask_later {\n-                        let mut stream = stream;\n-                        let mut buf = [0];\n-                        stream.read(buf);\n-                        assert!(buf[0] == 99);\n-                        debug!(\"read\");\n-                    }\n+        let addr = next_test_ip6();\n+        static MAX: int = 10;\n+        let (port, chan) = Chan::new();\n+\n+        do spawn {\n+            let mut acceptor = TcpListener::bind(addr).listen();\n+            chan.send(());\n+            for stream in acceptor.incoming().take(MAX as uint) {\n+                // Start another task to handle the connection\n+                do spawn {\n+                    let mut stream = stream;\n+                    let mut buf = [0];\n+                    stream.read(buf);\n+                    assert!(buf[0] == 99);\n+                    debug!(\"read\");\n                 }\n             }\n+        }\n \n-            port.recv();\n-            connect(0, addr);\n-\n-            fn connect(i: int, addr: SocketAddr) {\n-                if i == MAX { return }\n-\n-                do spawntask_later {\n-                    debug!(\"connecting\");\n-                    let mut stream = TcpStream::connect(addr);\n-                    // Connect again before writing\n-                    connect(i + 1, addr);\n-                    debug!(\"writing\");\n-                    stream.write([99]);\n-                }\n+        port.recv();\n+        connect(0, addr);\n+\n+        fn connect(i: int, addr: SocketAddr) {\n+            if i == MAX { return }\n+\n+            do spawn {\n+                debug!(\"connecting\");\n+                let mut stream = TcpStream::connect(addr);\n+                // Connect again before writing\n+                connect(i + 1, addr);\n+                debug!(\"writing\");\n+                stream.write([99]);\n             }\n         }\n     }\n \n     #[cfg(test)]\n     fn socket_name(addr: SocketAddr) {\n-        do run_in_mt_newsched_task {\n-            do spawntask {\n-                let mut listener = TcpListener::bind(addr).unwrap();\n-\n-                // Make sure socket_name gives\n-                // us the socket we binded to.\n-                let so_name = listener.socket_name();\n-                assert!(so_name.is_some());\n-                assert_eq!(addr, so_name.unwrap());\n+        let mut listener = TcpListener::bind(addr).unwrap();\n \n-            }\n-        }\n+        // Make sure socket_name gives\n+        // us the socket we binded to.\n+        let so_name = listener.socket_name();\n+        assert!(so_name.is_some());\n+        assert_eq!(addr, so_name.unwrap());\n     }\n \n     #[cfg(test)]\n     fn peer_name(addr: SocketAddr) {\n-        do run_in_mt_newsched_task {\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n+        let (port, chan) = Chan::new();\n \n-                acceptor.accept();\n-            }\n+        do spawn {\n+            let mut acceptor = TcpListener::bind(addr).listen();\n+            chan.send(());\n+            acceptor.accept();\n+        }\n \n-            port.recv();\n-            let stream = TcpStream::connect(addr);\n+        port.recv();\n+        let stream = TcpStream::connect(addr);\n \n-            assert!(stream.is_some());\n-            let mut stream = stream.unwrap();\n+        assert!(stream.is_some());\n+        let mut stream = stream.unwrap();\n \n-            // Make sure peer_name gives us the\n-            // address/port of the peer we've\n-            // connected to.\n-            let peer_name = stream.peer_name();\n-            assert!(peer_name.is_some());\n-            assert_eq!(addr, peer_name.unwrap());\n-        }\n+        // Make sure peer_name gives us the\n+        // address/port of the peer we've\n+        // connected to.\n+        let peer_name = stream.peer_name();\n+        assert!(peer_name.is_some());\n+        assert_eq!(addr, peer_name.unwrap());\n     }\n \n     #[test]\n@@ -668,5 +615,4 @@ mod test {\n         //peer_name(next_test_ip6());\n         socket_name(next_test_ip6());\n     }\n-\n }"}, {"sha": "7cb8f741cf3c157634fc3af1394e585d27dd36ae", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 101, "deletions": 122, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -21,14 +21,9 @@ pub struct UdpSocket {\n \n impl UdpSocket {\n     pub fn bind(addr: SocketAddr) -> Option<UdpSocket> {\n-        let mut io = LocalIo::borrow();\n-        match io.get().udp_bind(addr) {\n-            Ok(s) => Some(UdpSocket { obj: s }),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+        LocalIo::maybe_raise(|io| {\n+            io.udp_bind(addr).map(|s| UdpSocket { obj: s })\n+        })\n     }\n \n     pub fn recvfrom(&mut self, buf: &mut [u8]) -> Option<(uint, SocketAddr)> {\n@@ -104,52 +99,32 @@ impl Writer for UdpStream {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use rt::test::*;\n     use io::net::ip::{Ipv4Addr, SocketAddr};\n     use io::*;\n+    use io::test::*;\n     use prelude::*;\n \n     #[test]  #[ignore]\n     fn bind_error() {\n-        do run_in_mt_newsched_task {\n-            let mut called = false;\n-            io_error::cond.trap(|e| {\n-                assert!(e.kind == PermissionDenied);\n-                called = true;\n-            }).inside(|| {\n-                let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n-                let socket = UdpSocket::bind(addr);\n-                assert!(socket.is_none());\n-            });\n-            assert!(called);\n-        }\n+        let mut called = false;\n+        io_error::cond.trap(|e| {\n+            assert!(e.kind == PermissionDenied);\n+            called = true;\n+        }).inside(|| {\n+            let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n+            let socket = UdpSocket::bind(addr);\n+            assert!(socket.is_none());\n+        });\n+        assert!(called);\n     }\n \n     #[test]\n     fn socket_smoke_test_ip4() {\n-        do run_in_mt_newsched_task {\n-            let server_ip = next_test_ip4();\n-            let client_ip = next_test_ip4();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                match UdpSocket::bind(server_ip) {\n-                    Some(ref mut server) => {\n-                        chan.send(());\n-                        let mut buf = [0];\n-                        match server.recvfrom(buf) {\n-                            Some((nread, src)) => {\n-                                assert_eq!(nread, 1);\n-                                assert_eq!(buf[0], 99);\n-                                assert_eq!(src, client_ip);\n-                            }\n-                            None => fail!()\n-                        }\n-                    }\n-                    None => fail!()\n-                }\n-            }\n+        let server_ip = next_test_ip4();\n+        let client_ip = next_test_ip4();\n+        let (port, chan) = Chan::new();\n \n+        do spawn {\n             match UdpSocket::bind(client_ip) {\n                 Some(ref mut client) => {\n                     port.recv();\n@@ -158,33 +133,31 @@ mod test {\n                 None => fail!()\n             }\n         }\n-    }\n \n-    #[test]\n-    fn socket_smoke_test_ip6() {\n-        do run_in_mt_newsched_task {\n-            let server_ip = next_test_ip6();\n-            let client_ip = next_test_ip6();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                match UdpSocket::bind(server_ip) {\n-                    Some(ref mut server) => {\n-                        chan.send(());\n-                        let mut buf = [0];\n-                        match server.recvfrom(buf) {\n-                            Some((nread, src)) => {\n-                                assert_eq!(nread, 1);\n-                                assert_eq!(buf[0], 99);\n-                                assert_eq!(src, client_ip);\n-                            }\n-                            None => fail!()\n-                        }\n+        match UdpSocket::bind(server_ip) {\n+            Some(ref mut server) => {\n+                chan.send(());\n+                let mut buf = [0];\n+                match server.recvfrom(buf) {\n+                    Some((nread, src)) => {\n+                        assert_eq!(nread, 1);\n+                        assert_eq!(buf[0], 99);\n+                        assert_eq!(src, client_ip);\n                     }\n                     None => fail!()\n                 }\n             }\n+            None => fail!()\n+        }\n+    }\n \n+    #[test]\n+    fn socket_smoke_test_ip6() {\n+        let server_ip = next_test_ip6();\n+        let client_ip = next_test_ip6();\n+        let (port, chan) = Chan::<()>::new();\n+\n+        do spawn {\n             match UdpSocket::bind(client_ip) {\n                 Some(ref mut client) => {\n                     port.recv();\n@@ -193,34 +166,31 @@ mod test {\n                 None => fail!()\n             }\n         }\n-    }\n \n-    #[test]\n-    fn stream_smoke_test_ip4() {\n-        do run_in_mt_newsched_task {\n-            let server_ip = next_test_ip4();\n-            let client_ip = next_test_ip4();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                match UdpSocket::bind(server_ip) {\n-                    Some(server) => {\n-                        let server = ~server;\n-                        let mut stream = server.connect(client_ip);\n-                        chan.send(());\n-                        let mut buf = [0];\n-                        match stream.read(buf) {\n-                            Some(nread) => {\n-                                assert_eq!(nread, 1);\n-                                assert_eq!(buf[0], 99);\n-                            }\n-                            None => fail!()\n-                        }\n+        match UdpSocket::bind(server_ip) {\n+            Some(ref mut server) => {\n+                chan.send(());\n+                let mut buf = [0];\n+                match server.recvfrom(buf) {\n+                    Some((nread, src)) => {\n+                        assert_eq!(nread, 1);\n+                        assert_eq!(buf[0], 99);\n+                        assert_eq!(src, client_ip);\n                     }\n                     None => fail!()\n                 }\n             }\n+            None => fail!()\n+        }\n+    }\n+\n+    #[test]\n+    fn stream_smoke_test_ip4() {\n+        let server_ip = next_test_ip4();\n+        let client_ip = next_test_ip4();\n+        let (port, chan) = Chan::new();\n \n+        do spawn {\n             match UdpSocket::bind(client_ip) {\n                 Some(client) => {\n                     let client = ~client;\n@@ -231,34 +201,32 @@ mod test {\n                 None => fail!()\n             }\n         }\n-    }\n \n-    #[test]\n-    fn stream_smoke_test_ip6() {\n-        do run_in_mt_newsched_task {\n-            let server_ip = next_test_ip6();\n-            let client_ip = next_test_ip6();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                match UdpSocket::bind(server_ip) {\n-                    Some(server) => {\n-                        let server = ~server;\n-                        let mut stream = server.connect(client_ip);\n-                        chan.send(());\n-                        let mut buf = [0];\n-                        match stream.read(buf) {\n-                            Some(nread) => {\n-                                assert_eq!(nread, 1);\n-                                assert_eq!(buf[0], 99);\n-                            }\n-                            None => fail!()\n-                        }\n+        match UdpSocket::bind(server_ip) {\n+            Some(server) => {\n+                let server = ~server;\n+                let mut stream = server.connect(client_ip);\n+                chan.send(());\n+                let mut buf = [0];\n+                match stream.read(buf) {\n+                    Some(nread) => {\n+                        assert_eq!(nread, 1);\n+                        assert_eq!(buf[0], 99);\n                     }\n                     None => fail!()\n                 }\n             }\n+            None => fail!()\n+        }\n+    }\n+\n+    #[test]\n+    fn stream_smoke_test_ip6() {\n+        let server_ip = next_test_ip6();\n+        let client_ip = next_test_ip6();\n+        let (port, chan) = Chan::new();\n \n+        do spawn {\n             match UdpSocket::bind(client_ip) {\n                 Some(client) => {\n                     let client = ~client;\n@@ -269,25 +237,36 @@ mod test {\n                 None => fail!()\n             }\n         }\n+\n+        match UdpSocket::bind(server_ip) {\n+            Some(server) => {\n+                let server = ~server;\n+                let mut stream = server.connect(client_ip);\n+                chan.send(());\n+                let mut buf = [0];\n+                match stream.read(buf) {\n+                    Some(nread) => {\n+                        assert_eq!(nread, 1);\n+                        assert_eq!(buf[0], 99);\n+                    }\n+                    None => fail!()\n+                }\n+            }\n+            None => fail!()\n+        }\n     }\n \n-    #[cfg(test)]\n     fn socket_name(addr: SocketAddr) {\n-        do run_in_mt_newsched_task {\n-            do spawntask {\n-                let server = UdpSocket::bind(addr);\n-\n-                assert!(server.is_some());\n-                let mut server = server.unwrap();\n+        let server = UdpSocket::bind(addr);\n \n-                // Make sure socket_name gives\n-                // us the socket we binded to.\n-                let so_name = server.socket_name();\n-                assert!(so_name.is_some());\n-                assert_eq!(addr, so_name.unwrap());\n+        assert!(server.is_some());\n+        let mut server = server.unwrap();\n \n-            }\n-        }\n+        // Make sure socket_name gives\n+        // us the socket we binded to.\n+        let so_name = server.socket_name();\n+        assert!(so_name.is_some());\n+        assert_eq!(addr, so_name.unwrap());\n     }\n \n     #[test]"}, {"sha": "01b409d43163ad0971a6801edbf938bf4a53eaa7", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 51, "deletions": 71, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -59,14 +59,9 @@ impl UnixStream {\n     ///     stream.write([1, 2, 3]);\n     ///\n     pub fn connect<P: ToCStr>(path: &P) -> Option<UnixStream> {\n-        let mut io = LocalIo::borrow();\n-        match io.get().unix_connect(&path.to_c_str()) {\n-            Ok(s) => Some(UnixStream::new(s)),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+        LocalIo::maybe_raise(|io| {\n+            io.unix_connect(&path.to_c_str()).map(UnixStream::new)\n+        })\n     }\n }\n \n@@ -107,14 +102,9 @@ impl UnixListener {\n     ///     }\n     ///\n     pub fn bind<P: ToCStr>(path: &P) -> Option<UnixListener> {\n-        let mut io = LocalIo::borrow();\n-        match io.get().unix_bind(&path.to_c_str()) {\n-            Ok(s) => Some(UnixListener{ obj: s }),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+        LocalIo::maybe_raise(|io| {\n+            io.unix_bind(&path.to_c_str()).map(|s| UnixListener { obj: s })\n+        })\n     }\n }\n \n@@ -150,55 +140,49 @@ impl Acceptor<UnixStream> for UnixAcceptor {\n mod tests {\n     use prelude::*;\n     use super::*;\n-    use rt::test::*;\n     use io::*;\n+    use io::test::*;\n \n     fn smalltest(server: proc(UnixStream), client: proc(UnixStream)) {\n-        do run_in_mt_newsched_task {\n-            let path1 = next_test_unix();\n-            let path2 = path1.clone();\n-            let (client, server) = (client, server);\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = UnixListener::bind(&path1).listen();\n-                chan.send(());\n-                server(acceptor.accept().unwrap());\n-            }\n+        let path1 = next_test_unix();\n+        let path2 = path1.clone();\n+        let (port, chan) = Chan::new();\n \n+        do spawn {\n             port.recv();\n             client(UnixStream::connect(&path2).unwrap());\n         }\n+\n+        let mut acceptor = UnixListener::bind(&path1).listen();\n+        chan.send(());\n+        server(acceptor.accept().unwrap());\n     }\n \n     #[test]\n     fn bind_error() {\n-        do run_in_mt_newsched_task {\n-            let mut called = false;\n-            io_error::cond.trap(|e| {\n-                assert!(e.kind == PermissionDenied);\n-                called = true;\n-            }).inside(|| {\n-                let listener = UnixListener::bind(&(\"path/to/nowhere\"));\n-                assert!(listener.is_none());\n-            });\n-            assert!(called);\n-        }\n+        let mut called = false;\n+        io_error::cond.trap(|e| {\n+            assert!(e.kind == PermissionDenied);\n+            called = true;\n+        }).inside(|| {\n+            let listener = UnixListener::bind(&(\"path/to/nowhere\"));\n+            assert!(listener.is_none());\n+        });\n+        assert!(called);\n     }\n \n     #[test]\n     fn connect_error() {\n-        do run_in_mt_newsched_task {\n-            let mut called = false;\n-            io_error::cond.trap(|e| {\n-                assert_eq!(e.kind, FileNotFound);\n-                called = true;\n-            }).inside(|| {\n-                let stream = UnixStream::connect(&(\"path/to/nowhere\"));\n-                assert!(stream.is_none());\n-            });\n-            assert!(called);\n-        }\n+        let mut called = false;\n+        io_error::cond.trap(|e| {\n+            assert_eq!(e.kind,\n+                       if cfg!(windows) {OtherIoError} else {FileNotFound});\n+            called = true;\n+        }).inside(|| {\n+            let stream = UnixStream::connect(&(\"path/to/nowhere\"));\n+            assert!(stream.is_none());\n+        });\n+        assert!(called);\n     }\n \n     #[test]\n@@ -244,37 +228,33 @@ mod tests {\n \n     #[test]\n     fn accept_lots() {\n-        do run_in_mt_newsched_task {\n-            let times = 10;\n-            let path1 = next_test_unix();\n-            let path2 = path1.clone();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = UnixListener::bind(&path1).listen();\n-                chan.send(());\n-                times.times(|| {\n-                    let mut client = acceptor.accept();\n-                    let mut buf = [0];\n-                    client.read(buf);\n-                    assert_eq!(buf[0], 100);\n-                })\n-            }\n+        let times = 10;\n+        let path1 = next_test_unix();\n+        let path2 = path1.clone();\n+        let (port, chan) = Chan::new();\n \n+        do spawn {\n             port.recv();\n             times.times(|| {\n                 let mut stream = UnixStream::connect(&path2);\n                 stream.write([100]);\n             })\n         }\n+\n+        let mut acceptor = UnixListener::bind(&path1).listen();\n+        chan.send(());\n+        times.times(|| {\n+            let mut client = acceptor.accept();\n+            let mut buf = [0];\n+            client.read(buf);\n+            assert_eq!(buf[0], 100);\n+        })\n     }\n \n     #[test]\n     fn path_exists() {\n-        do run_in_mt_newsched_task {\n-            let path = next_test_unix();\n-            let _acceptor = UnixListener::bind(&path).listen();\n-            assert!(path.exists());\n-        }\n+        let path = next_test_unix();\n+        let _acceptor = UnixListener::bind(&path).listen();\n+        assert!(path.exists());\n     }\n }"}, {"sha": "a661d6ab7eb79f784057481492539341acdedc78", "filename": "src/libstd/io/option.rs", "status": "modified", "additions": 28, "deletions": 35, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Foption.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -106,53 +106,46 @@ impl<T, A: Acceptor<T>> Acceptor<T> for Option<A> {\n mod test {\n     use option::*;\n     use super::super::mem::*;\n-    use rt::test::*;\n     use super::super::{PreviousIoError, io_error};\n \n     #[test]\n     fn test_option_writer() {\n-        do run_in_mt_newsched_task {\n-            let mut writer: Option<MemWriter> = Some(MemWriter::new());\n-            writer.write([0, 1, 2]);\n-            writer.flush();\n-            assert_eq!(writer.unwrap().inner(), ~[0, 1, 2]);\n-        }\n+        let mut writer: Option<MemWriter> = Some(MemWriter::new());\n+        writer.write([0, 1, 2]);\n+        writer.flush();\n+        assert_eq!(writer.unwrap().inner(), ~[0, 1, 2]);\n     }\n \n     #[test]\n     fn test_option_writer_error() {\n-        do run_in_mt_newsched_task {\n-            let mut writer: Option<MemWriter> = None;\n-\n-            let mut called = false;\n-            io_error::cond.trap(|err| {\n-                assert_eq!(err.kind, PreviousIoError);\n-                called = true;\n-            }).inside(|| {\n-                writer.write([0, 0, 0]);\n-            });\n-            assert!(called);\n-\n-            let mut called = false;\n-            io_error::cond.trap(|err| {\n-                assert_eq!(err.kind, PreviousIoError);\n-                called = true;\n-            }).inside(|| {\n-                writer.flush();\n-            });\n-            assert!(called);\n-        }\n+        let mut writer: Option<MemWriter> = None;\n+\n+        let mut called = false;\n+        io_error::cond.trap(|err| {\n+            assert_eq!(err.kind, PreviousIoError);\n+            called = true;\n+        }).inside(|| {\n+            writer.write([0, 0, 0]);\n+        });\n+        assert!(called);\n+\n+        let mut called = false;\n+        io_error::cond.trap(|err| {\n+            assert_eq!(err.kind, PreviousIoError);\n+            called = true;\n+        }).inside(|| {\n+            writer.flush();\n+        });\n+        assert!(called);\n     }\n \n     #[test]\n     fn test_option_reader() {\n-        do run_in_mt_newsched_task {\n-            let mut reader: Option<MemReader> = Some(MemReader::new(~[0, 1, 2, 3]));\n-            let mut buf = [0, 0];\n-            reader.read(buf);\n-            assert_eq!(buf, [0, 1]);\n-            assert!(!reader.eof());\n-        }\n+        let mut reader: Option<MemReader> = Some(MemReader::new(~[0, 1, 2, 3]));\n+        let mut buf = [0, 0];\n+        reader.read(buf);\n+        assert_eq!(buf, [0, 1]);\n+        assert!(!reader.eof());\n     }\n \n     #[test]"}, {"sha": "2349c64a84b272e791849b46dd384d4d4069a795", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -14,10 +14,9 @@\n //! enough so that pipes can be created to child processes.\n \n use prelude::*;\n-use super::{Reader, Writer};\n use io::{io_error, EndOfFile};\n-use io::native::file;\n-use rt::rtio::{LocalIo, RtioPipe};\n+use libc;\n+use rt::rtio::{RtioPipe, LocalIo};\n \n pub struct PipeStream {\n     priv obj: ~RtioPipe,\n@@ -43,15 +42,10 @@ impl PipeStream {\n     ///\n     /// If the pipe cannot be created, an error will be raised on the\n     /// `io_error` condition.\n-    pub fn open(fd: file::fd_t) -> Option<PipeStream> {\n-        let mut io = LocalIo::borrow();\n-        match io.get().pipe_open(fd) {\n-            Ok(obj) => Some(PipeStream { obj: obj }),\n-            Err(e) => {\n-                io_error::cond.raise(e);\n-                None\n-            }\n-        }\n+    pub fn open(fd: libc::c_int) -> Option<PipeStream> {\n+        LocalIo::maybe_raise(|io| {\n+            io.pipe_open(fd).map(|obj| PipeStream { obj: obj })\n+        })\n     }\n \n     pub fn new(inner: ~RtioPipe) -> PipeStream {"}, {"sha": "bbb2a7ef3984df2fec2406cc4b9738659e4dfcde", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -119,19 +119,17 @@ impl Process {\n     /// Creates a new pipe initialized, but not bound to any particular\n     /// source/destination\n     pub fn new(config: ProcessConfig) -> Option<Process> {\n-        let mut io = LocalIo::borrow();\n-        match io.get().spawn(config) {\n-            Ok((p, io)) => Some(Process{\n-                handle: p,\n-                io: io.move_iter().map(|p|\n-                    p.map(|p| io::PipeStream::new(p))\n-                ).collect()\n-            }),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+        let mut config = Some(config);\n+        LocalIo::maybe_raise(|io| {\n+            io.spawn(config.take_unwrap()).map(|(p, io)| {\n+                Process {\n+                    handle: p,\n+                    io: io.move_iter().map(|p| {\n+                        p.map(|p| io::PipeStream::new(p))\n+                    }).collect()\n+                }\n+            })\n+        })\n     }\n \n     /// Returns the process id of this child process"}, {"sha": "4cde35796a642e8abb821718e6a0bff951594d76", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -23,8 +23,7 @@ use clone::Clone;\n use comm::{Port, SharedChan};\n use container::{Map, MutableMap};\n use hashmap;\n-use io::io_error;\n-use result::{Err, Ok};\n+use option::{Some, None};\n use rt::rtio::{IoFactory, LocalIo, RtioSignal};\n \n #[repr(int)]\n@@ -122,16 +121,14 @@ impl Listener {\n         if self.handles.contains_key(&signum) {\n             return true; // self is already listening to signum, so succeed\n         }\n-        let mut io = LocalIo::borrow();\n-        match io.get().signal(signum, self.chan.clone()) {\n-            Ok(w) => {\n-                self.handles.insert(signum, w);\n+        match LocalIo::maybe_raise(|io| {\n+            io.signal(signum, self.chan.clone())\n+        }) {\n+            Some(handle) => {\n+                self.handles.insert(signum, handle);\n                 true\n-            },\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                false\n             }\n+            None => false\n         }\n     }\n "}, {"sha": "1e4fa7968dc421399df2d5d052b97b137f7353de", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 22, "deletions": 32, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -27,13 +27,13 @@ out.write(bytes!(\"Hello, world!\"));\n */\n \n use fmt;\n+use io::buffered::LineBufferedWriter;\n+use io::{Reader, Writer, io_error, IoError, OtherIoError,\n+         standard_error, EndOfFile};\n use libc;\n use option::{Option, Some, None};\n use result::{Ok, Err};\n-use io::buffered::LineBufferedWriter;\n use rt::rtio::{DontClose, IoFactory, LocalIo, RtioFileStream, RtioTTY};\n-use super::{Reader, Writer, io_error, IoError, OtherIoError,\n-            standard_error, EndOfFile};\n \n // And so begins the tale of acquiring a uv handle to a stdio stream on all\n // platforms in all situations. Our story begins by splitting the world into two\n@@ -69,19 +69,12 @@ enum StdSource {\n }\n \n fn src<T>(fd: libc::c_int, readable: bool, f: |StdSource| -> T) -> T {\n-    let mut io = LocalIo::borrow();\n-    match io.get().tty_open(fd, readable) {\n-        Ok(tty) => f(TTY(tty)),\n-        Err(_) => {\n-            // It's not really that desirable if these handles are closed\n-            // synchronously, and because they're squirreled away in a task\n-            // structure the destructors will be run when the task is\n-            // attempted to get destroyed. This means that if we run a\n-            // synchronous destructor we'll attempt to do some scheduling\n-            // operations which will just result in sadness.\n-            f(File(io.get().fs_from_raw_fd(fd, DontClose)))\n-        }\n-    }\n+    LocalIo::maybe_raise(|io| {\n+        Ok(match io.tty_open(fd, readable) {\n+            Ok(tty) => f(TTY(tty)),\n+            Err(_) => f(File(io.fs_from_raw_fd(fd, DontClose))),\n+        })\n+    }).unwrap()\n }\n \n /// Creates a new non-blocking handle to the stdin of the current process.\n@@ -138,7 +131,17 @@ fn with_task_stdout(f: |&mut Writer|) {\n             }\n \n             None => {\n-                let mut io = stdout();\n+                struct Stdout;\n+                impl Writer for Stdout {\n+                    fn write(&mut self, data: &[u8]) {\n+                        unsafe {\n+                            libc::write(libc::STDOUT_FILENO,\n+                                        data.as_ptr() as *libc::c_void,\n+                                        data.len() as libc::size_t);\n+                        }\n+                    }\n+                }\n+                let mut io = Stdout;\n                 f(&mut io as &mut Writer);\n             }\n         }\n@@ -304,23 +307,10 @@ impl Writer for StdWriter {\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n-    use rt::test::run_in_newsched_task;\n-\n-    #[test]\n-    fn smoke_uv() {\n+    iotest!(fn smoke() {\n         // Just make sure we can acquire handles\n         stdin();\n         stdout();\n         stderr();\n-    }\n-\n-    #[test]\n-    fn smoke_native() {\n-        do run_in_newsched_task {\n-            stdin();\n-            stdout();\n-            stderr();\n-        }\n-    }\n+    })\n }"}, {"sha": "4be1122796584c6a09a261530678b05b00a0ee71", "filename": "src/libstd/io/test.rs", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -0,0 +1,195 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_escape];\n+\n+use os;\n+use prelude::*;\n+use rand;\n+use rand::Rng;\n+use std::io::net::ip::*;\n+use sync::atomics::{AtomicUint, INIT_ATOMIC_UINT, Relaxed};\n+\n+macro_rules! iotest (\n+    { fn $name:ident() $b:block } => (\n+        mod $name {\n+            #[allow(unused_imports)];\n+\n+            use super::super::*;\n+            use super::*;\n+            use io;\n+            use prelude::*;\n+            use io::*;\n+            use io::fs::*;\n+            use io::net::tcp::*;\n+            use io::net::ip::*;\n+            use io::net::udp::*;\n+            #[cfg(unix)]\n+            use io::net::unix::*;\n+            use str;\n+            use util;\n+\n+            fn f() $b\n+\n+            #[test] fn green() { f() }\n+            #[test] fn native() {\n+                use native;\n+                let (p, c) = Chan::new();\n+                do native::task::spawn { c.send(f()) }\n+                p.recv();\n+            }\n+        }\n+    )\n+)\n+\n+/// Get a port number, starting at 9600, for use in tests\n+pub fn next_test_port() -> u16 {\n+    static mut next_offset: AtomicUint = INIT_ATOMIC_UINT;\n+    unsafe {\n+        base_port() + next_offset.fetch_add(1, Relaxed) as u16\n+    }\n+}\n+\n+/// Get a temporary path which could be the location of a unix socket\n+pub fn next_test_unix() -> Path {\n+    if cfg!(unix) {\n+        os::tmpdir().join(rand::task_rng().gen_ascii_str(20))\n+    } else {\n+        Path::new(r\"\\\\.\\pipe\\\" + rand::task_rng().gen_ascii_str(20))\n+    }\n+}\n+\n+/// Get a unique IPv4 localhost:port pair starting at 9600\n+pub fn next_test_ip4() -> SocketAddr {\n+    SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: next_test_port() }\n+}\n+\n+/// Get a unique IPv6 localhost:port pair starting at 9600\n+pub fn next_test_ip6() -> SocketAddr {\n+    SocketAddr { ip: Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1), port: next_test_port() }\n+}\n+\n+/*\n+XXX: Welcome to MegaHack City.\n+\n+The bots run multiple builds at the same time, and these builds\n+all want to use ports. This function figures out which workspace\n+it is running in and assigns a port range based on it.\n+*/\n+fn base_port() -> u16 {\n+\n+    let base = 9600u16;\n+    let range = 1000u16;\n+\n+    let bases = [\n+        (\"32-opt\", base + range * 1),\n+        (\"32-noopt\", base + range * 2),\n+        (\"64-opt\", base + range * 3),\n+        (\"64-noopt\", base + range * 4),\n+        (\"64-opt-vg\", base + range * 5),\n+        (\"all-opt\", base + range * 6),\n+        (\"snap3\", base + range * 7),\n+        (\"dist\", base + range * 8)\n+    ];\n+\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let path = os::getcwd();\n+    let path_s = path.as_str().unwrap();\n+\n+    let mut final_base = base;\n+\n+    for &(dir, base) in bases.iter() {\n+        if path_s.contains(dir) {\n+            final_base = base;\n+            break;\n+        }\n+    }\n+\n+    return final_base;\n+}\n+\n+pub fn raise_fd_limit() {\n+    unsafe { darwin_fd_limit::raise_fd_limit() }\n+}\n+\n+#[cfg(target_os=\"macos\")]\n+#[allow(non_camel_case_types)]\n+mod darwin_fd_limit {\n+    /*!\n+     * darwin_fd_limit exists to work around an issue where launchctl on Mac OS X defaults the\n+     * rlimit maxfiles to 256/unlimited. The default soft limit of 256 ends up being far too low\n+     * for our multithreaded scheduler testing, depending on the number of cores available.\n+     *\n+     * This fixes issue #7772.\n+     */\n+\n+    use libc;\n+    type rlim_t = libc::uint64_t;\n+    struct rlimit {\n+        rlim_cur: rlim_t,\n+        rlim_max: rlim_t\n+    }\n+    #[nolink]\n+    extern {\n+        // name probably doesn't need to be mut, but the C function doesn't specify const\n+        fn sysctl(name: *mut libc::c_int, namelen: libc::c_uint,\n+                  oldp: *mut libc::c_void, oldlenp: *mut libc::size_t,\n+                  newp: *mut libc::c_void, newlen: libc::size_t) -> libc::c_int;\n+        fn getrlimit(resource: libc::c_int, rlp: *mut rlimit) -> libc::c_int;\n+        fn setrlimit(resource: libc::c_int, rlp: *rlimit) -> libc::c_int;\n+    }\n+    static CTL_KERN: libc::c_int = 1;\n+    static KERN_MAXFILESPERPROC: libc::c_int = 29;\n+    static RLIMIT_NOFILE: libc::c_int = 8;\n+\n+    pub unsafe fn raise_fd_limit() {\n+        // The strategy here is to fetch the current resource limits, read the kern.maxfilesperproc\n+        // sysctl value, and bump the soft resource limit for maxfiles up to the sysctl value.\n+        use ptr::{to_unsafe_ptr, to_mut_unsafe_ptr, mut_null};\n+        use mem::size_of_val;\n+        use os::last_os_error;\n+\n+        // Fetch the kern.maxfilesperproc value\n+        let mut mib: [libc::c_int, ..2] = [CTL_KERN, KERN_MAXFILESPERPROC];\n+        let mut maxfiles: libc::c_int = 0;\n+        let mut size: libc::size_t = size_of_val(&maxfiles) as libc::size_t;\n+        if sysctl(to_mut_unsafe_ptr(&mut mib[0]), 2,\n+                  to_mut_unsafe_ptr(&mut maxfiles) as *mut libc::c_void,\n+                  to_mut_unsafe_ptr(&mut size),\n+                  mut_null(), 0) != 0 {\n+            let err = last_os_error();\n+            error!(\"raise_fd_limit: error calling sysctl: {}\", err);\n+            return;\n+        }\n+\n+        // Fetch the current resource limits\n+        let mut rlim = rlimit{rlim_cur: 0, rlim_max: 0};\n+        if getrlimit(RLIMIT_NOFILE, to_mut_unsafe_ptr(&mut rlim)) != 0 {\n+            let err = last_os_error();\n+            error!(\"raise_fd_limit: error calling getrlimit: {}\", err);\n+            return;\n+        }\n+\n+        // Bump the soft limit to the smaller of kern.maxfilesperproc and the hard limit\n+        rlim.rlim_cur = ::cmp::min(maxfiles as rlim_t, rlim.rlim_max);\n+\n+        // Set our newly-increased resource limit\n+        if setrlimit(RLIMIT_NOFILE, to_unsafe_ptr(&rlim)) != 0 {\n+            let err = last_os_error();\n+            error!(\"raise_fd_limit: error calling setrlimit: {}\", err);\n+            return;\n+        }\n+    }\n+}\n+\n+#[cfg(not(target_os=\"macos\"))]\n+mod darwin_fd_limit {\n+    pub unsafe fn raise_fd_limit() {}\n+}"}, {"sha": "7c9aa28bfe9a8008aa3fa6c6472248911498ddc4", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 25, "deletions": 52, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -39,9 +39,7 @@ loop {\n */\n \n use comm::Port;\n-use option::{Option, Some, None};\n-use result::{Ok, Err};\n-use io::io_error;\n+use option::Option;\n use rt::rtio::{IoFactory, LocalIo, RtioTimer};\n \n pub struct Timer {\n@@ -60,15 +58,7 @@ impl Timer {\n     /// for a number of milliseconds, or to possibly create channels which will\n     /// get notified after an amount of time has passed.\n     pub fn new() -> Option<Timer> {\n-        let mut io = LocalIo::borrow();\n-        match io.get().timer_init() {\n-            Ok(t) => Some(Timer { obj: t }),\n-            Err(ioerr) => {\n-                debug!(\"Timer::init: failed to init: {:?}\", ioerr);\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+        LocalIo::maybe_raise(|io| io.timer_init().map(|t| Timer { obj: t }))\n     }\n \n     /// Blocks the current task for `msecs` milliseconds.\n@@ -108,77 +98,60 @@ impl Timer {\n mod test {\n     use prelude::*;\n     use super::*;\n-    use rt::test::*;\n \n     #[test]\n     fn test_io_timer_sleep_simple() {\n-        do run_in_mt_newsched_task {\n-            let mut timer = Timer::new().unwrap();\n-            timer.sleep(1);\n-        }\n+        let mut timer = Timer::new().unwrap();\n+        timer.sleep(1);\n     }\n \n     #[test]\n     fn test_io_timer_sleep_oneshot() {\n-        do run_in_mt_newsched_task {\n-            let mut timer = Timer::new().unwrap();\n-            timer.oneshot(1).recv();\n-        }\n+        let mut timer = Timer::new().unwrap();\n+        timer.oneshot(1).recv();\n     }\n \n     #[test]\n     fn test_io_timer_sleep_oneshot_forget() {\n-        do run_in_mt_newsched_task {\n-            let mut timer = Timer::new().unwrap();\n-            timer.oneshot(100000000000);\n-        }\n+        let mut timer = Timer::new().unwrap();\n+        timer.oneshot(100000000000);\n     }\n \n     #[test]\n     fn oneshot_twice() {\n-        do run_in_mt_newsched_task {\n-            let mut timer = Timer::new().unwrap();\n-            let port1 = timer.oneshot(10000);\n-            let port = timer.oneshot(1);\n-            port.recv();\n-            assert_eq!(port1.try_recv(), None);\n-        }\n+        let mut timer = Timer::new().unwrap();\n+        let port1 = timer.oneshot(10000);\n+        let port = timer.oneshot(1);\n+        port.recv();\n+        assert_eq!(port1.try_recv(), None);\n     }\n \n     #[test]\n     fn test_io_timer_oneshot_then_sleep() {\n-        do run_in_mt_newsched_task {\n-            let mut timer = Timer::new().unwrap();\n-            let port = timer.oneshot(100000000000);\n-            timer.sleep(1); // this should invalidate the port\n+        let mut timer = Timer::new().unwrap();\n+        let port = timer.oneshot(100000000000);\n+        timer.sleep(1); // this should invalidate the port\n \n-            assert_eq!(port.try_recv(), None);\n-        }\n+        assert_eq!(port.try_recv(), None);\n     }\n \n     #[test]\n     fn test_io_timer_sleep_periodic() {\n-        do run_in_mt_newsched_task {\n-            let mut timer = Timer::new().unwrap();\n-            let port = timer.periodic(1);\n-            port.recv();\n-            port.recv();\n-            port.recv();\n-        }\n+        let mut timer = Timer::new().unwrap();\n+        let port = timer.periodic(1);\n+        port.recv();\n+        port.recv();\n+        port.recv();\n     }\n \n     #[test]\n     fn test_io_timer_sleep_periodic_forget() {\n-        do run_in_mt_newsched_task {\n-            let mut timer = Timer::new().unwrap();\n-            timer.periodic(100000000000);\n-        }\n+        let mut timer = Timer::new().unwrap();\n+        timer.periodic(100000000000);\n     }\n \n     #[test]\n     fn test_io_timer_sleep_standalone() {\n-        do run_in_mt_newsched_task {\n-            sleep(1)\n-        }\n+        sleep(1)\n     }\n }"}, {"sha": "4f633a63babc4c1a3b49ac0f1bcd73543dcafa54", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -65,13 +65,15 @@\n // When testing libstd, bring in libuv as the I/O backend so tests can print\n // things and all of the std::io tests have an I/O interface to run on top\n // of\n-#[cfg(test)] extern mod rustuv = \"rustuv#0.9-pre\";\n+#[cfg(test)] extern mod rustuv = \"rustuv\";\n+#[cfg(test)] extern mod native = \"native\";\n+#[cfg(test)] extern mod green = \"green\";\n \n // Make extra accessible for benchmarking\n-#[cfg(test)] extern mod extra = \"extra#0.9-pre\";\n+#[cfg(test)] extern mod extra = \"extra\";\n \n // Make std testable by not duplicating lang items. See #2912\n-#[cfg(test)] extern mod realstd = \"std#0.9-pre\";\n+#[cfg(test)] extern mod realstd = \"std\";\n #[cfg(test)] pub use kinds = realstd::kinds;\n #[cfg(test)] pub use ops = realstd::ops;\n #[cfg(test)] pub use cmp = realstd::cmp;\n@@ -159,6 +161,7 @@ pub mod trie;\n pub mod task;\n pub mod comm;\n pub mod local_data;\n+pub mod sync;\n \n \n /* Runtime and platform support */"}, {"sha": "d7e11d2f3a70f693a1ff9b8f44386ab0d0e2e4be", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -432,6 +432,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(dead_code)]\n     fn test_tls_overwrite_multiple_types() {\n         static str_key: Key<~str> = &Key;\n         static box_key: Key<@()> = &Key;"}, {"sha": "fb83cfdd6ea8aecd9922ff2af0bee20385ef624c", "filename": "src/libstd/logging.rs", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flogging.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -118,26 +118,16 @@ pub static ERROR: u32 = 1;\n /// It is not recommended to call this function directly, rather it should be\n /// invoked through the logging family of macros.\n pub fn log(_level: u32, args: &fmt::Arguments) {\n-    unsafe {\n-        let optional_task: Option<*mut Task> = Local::try_unsafe_borrow();\n-        match optional_task {\n-            Some(local) => {\n-                // Lazily initialize the local task's logger\n-                match (*local).logger {\n-                    // Use the available logger if we have one\n-                    Some(ref mut logger) => { logger.log(args); }\n-                    None => {\n-                        let mut logger = StdErrLogger::new();\n-                        logger.log(args);\n-                        (*local).logger = Some(logger);\n-                    }\n-                }\n-            }\n-            // If there's no local task, then always log to stderr\n-            None => {\n-                let mut logger = StdErrLogger::new();\n-                logger.log(args);\n-            }\n-        }\n+    let mut logger = {\n+        let mut task = Local::borrow(None::<Task>);\n+        task.get().logger.take()\n+    };\n+\n+    if logger.is_none() {\n+        logger = Some(StdErrLogger::new());\n     }\n+    logger.get_mut_ref().log(args);\n+\n+    let mut task = Local::borrow(None::<Task>);\n+    task.get().logger = logger;\n }"}, {"sha": "8f2f21908850451c7bdc9e1cea54ac5adfd9bf6e", "filename": "src/libstd/os.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -28,8 +28,6 @@\n \n #[allow(missing_doc)];\n \n-#[cfg(unix)]\n-use c_str::CString;\n use clone::Clone;\n use container::Container;\n #[cfg(target_os = \"macos\")]\n@@ -43,8 +41,7 @@ use ptr;\n use str;\n use to_str;\n use unstable::finally::Finally;\n-\n-pub use os::consts::*;\n+use sync::atomics::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n \n /// Delegates to the libc close() function, returning the same return value.\n pub fn close(fd: c_int) -> c_int {\n@@ -58,6 +55,8 @@ static BUF_BYTES : uint = 2048u;\n \n #[cfg(unix)]\n pub fn getcwd() -> Path {\n+    use c_str::CString;\n+\n     let mut buf = [0 as libc::c_char, ..BUF_BYTES];\n     unsafe {\n         if libc::getcwd(buf.as_mut_ptr(), buf.len() as size_t).is_null() {\n@@ -333,7 +332,7 @@ pub fn pipe() -> Pipe {\n \n /// Returns the proper dll filename for the given basename of a file.\n pub fn dll_filename(base: &str) -> ~str {\n-    format!(\"{}{}{}\", DLL_PREFIX, base, DLL_SUFFIX)\n+    format!(\"{}{}{}\", consts::DLL_PREFIX, base, consts::DLL_SUFFIX)\n }\n \n /// Optionally returns the filesystem path to the current executable which is\n@@ -675,17 +674,26 @@ pub fn last_os_error() -> ~str {\n     strerror()\n }\n \n+static mut EXIT_STATUS: AtomicInt = INIT_ATOMIC_INT;\n+\n /**\n  * Sets the process exit code\n  *\n  * Sets the exit code returned by the process if all supervised tasks\n  * terminate successfully (without failing). If the current root task fails\n  * and is supervised by the scheduler then any user-specified exit status is\n- * ignored and the process exits with the default failure status\n+ * ignored and the process exits with the default failure status.\n+ *\n+ * Note that this is not synchronized against modifications of other threads.\n  */\n pub fn set_exit_status(code: int) {\n-    use rt;\n-    rt::set_exit_status(code);\n+    unsafe { EXIT_STATUS.store(code, SeqCst) }\n+}\n+\n+/// Fetches the process's current exit code. This defaults to 0 and can change\n+/// by calling `set_exit_status`.\n+pub fn get_exit_status() -> int {\n+    unsafe { EXIT_STATUS.load(SeqCst) }\n }\n \n #[cfg(target_os = \"macos\")]"}, {"sha": "d1e97cb6ec0f8a993f9244ba8d8af6f708a78282", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -12,9 +12,8 @@ use c_str::{ToCStr, CString};\n use libc::{c_char, size_t};\n use option::{Option, None, Some};\n use ptr::RawPtr;\n-use rt::env;\n+use rt;\n use rt::local::Local;\n-use rt::task;\n use rt::task::Task;\n use str::OwnedStr;\n use str;\n@@ -62,7 +61,7 @@ unsafe fn fail_borrowed(alloc: *mut raw::Box<()>, file: *c_char, line: size_t)\n     match try_take_task_borrow_list() {\n         None => { // not recording borrows\n             let msg = \"borrowed\";\n-            msg.with_c_str(|msg_p| task::begin_unwind_raw(msg_p, file, line))\n+            msg.with_c_str(|msg_p| rt::begin_unwind_raw(msg_p, file, line))\n         }\n         Some(borrow_list) => { // recording borrows\n             let mut msg = ~\"borrowed\";\n@@ -76,7 +75,7 @@ unsafe fn fail_borrowed(alloc: *mut raw::Box<()>, file: *c_char, line: size_t)\n                     sep = \" and at \";\n                 }\n             }\n-            msg.with_c_str(|msg_p| task::begin_unwind_raw(msg_p, file, line))\n+            msg.with_c_str(|msg_p| rt::begin_unwind_raw(msg_p, file, line))\n         }\n     }\n }\n@@ -95,7 +94,7 @@ unsafe fn debug_borrow<T,P:RawPtr<T>>(tag: &'static str,\n     //! A useful debugging function that prints a pointer + tag + newline\n     //! without allocating memory.\n \n-    if ENABLE_DEBUG && env::debug_borrow() {\n+    if ENABLE_DEBUG && rt::env::debug_borrow() {\n         debug_borrow_slow(tag, p, old_bits, new_bits, filename, line);\n     }\n \n@@ -180,7 +179,7 @@ pub unsafe fn unrecord_borrow(a: *u8,\n             if br.alloc != a || br.file != file || br.line != line {\n                 let err = format!(\"wrong borrow found, br={:?}\", br);\n                 err.with_c_str(|msg_p| {\n-                    task::begin_unwind_raw(msg_p, file, line)\n+                    rt::begin_unwind_raw(msg_p, file, line)\n                 })\n             }\n             borrow_list"}, {"sha": "d9b40cfbb6e8ce329b27bb4026189e8978fc91c0", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -30,7 +30,7 @@ pub struct CrateMap<'a> {\n     version: i32,\n     entries: &'a [ModEntry<'a>],\n     children: &'a [&'a CrateMap<'a>],\n-    event_loop_factory: Option<extern \"C\" fn() -> ~EventLoop>,\n+    event_loop_factory: Option<fn() -> ~EventLoop>,\n }\n \n #[cfg(not(windows))]"}, {"sha": "f3fa482b18cca468217bcaea08f99f618d71e92c", "filename": "src/libstd/rt/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frt%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frt%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fenv.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -17,7 +17,7 @@ use os;\n // Note that these are all accessed without any synchronization.\n // They are expected to be initialized once then left alone.\n \n-static mut MIN_STACK: uint = 2000000;\n+static mut MIN_STACK: uint = 2 * 1024 * 1024;\n static mut DEBUG_BORROW: bool = false;\n static mut POISON_ON_FREE: bool = false;\n "}, {"sha": "f4f128cf5aac1053852c2475d59fa99f229d920d", "filename": "src/libstd/rt/kill.rs", "status": "removed", "additions": 0, "deletions": 318, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=d975060de6c944ca12ce5205fbc9fc7726948ae1", "patch": "@@ -1,318 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Task death: asynchronous killing, linked failure, exit code propagation.\n-\n-This file implements two orthogonal building-blocks for communicating failure\n-between tasks. One is 'linked failure' or 'task killing', that is, a failing\n-task causing other tasks to fail promptly (even those that are blocked on\n-pipes or I/O). The other is 'exit code propagation', which affects the result\n-observed by the parent of a task::try task that itself spawns child tasks\n-(such as any #[test] function). In both cases the data structures live in\n-KillHandle.\n-\n-\n-I. Task killing.\n-\n-The model for killing involves two atomic flags, the \"kill flag\" and the\n-\"unkillable flag\". Operations on the kill flag include:\n-\n-- In the taskgroup code (task/spawn.rs), tasks store a clone of their\n-  KillHandle in their shared taskgroup. Another task in the group that fails\n-  will use that handle to call kill().\n-- When a task blocks, it turns its ~Task into a BlockedTask by storing a\n-  the transmuted ~Task pointer inside the KillHandle's kill flag. A task\n-  trying to block and a task trying to kill it can simultaneously access the\n-  kill flag, after which the task will get scheduled and fail (no matter who\n-  wins the race). Likewise, a task trying to wake a blocked task normally and\n-  a task trying to kill it can simultaneously access the flag; only one will\n-  get the task to reschedule it.\n-\n-Operations on the unkillable flag include:\n-\n-- When a task becomes unkillable, it swaps on the flag to forbid any killer\n-  from waking it up while it's blocked inside the unkillable section. If a\n-  kill was already pending, the task fails instead of becoming unkillable.\n-- When a task is done being unkillable, it restores the flag to the normal\n-  running state. If a kill was received-but-blocked during the unkillable\n-  section, the task fails at this later point.\n-- When a task tries to kill another task, before swapping on the kill flag, it\n-  first swaps on the unkillable flag, to see if it's \"allowed\" to wake up the\n-  task. If it isn't, the killed task will receive the signal when it becomes\n-  killable again. (Of course, a task trying to wake the task normally (e.g.\n-  sending on a channel) does not access the unkillable flag at all.)\n-\n-Why do we not need acquire/release barriers on any of the kill flag swaps?\n-This is because barriers establish orderings between accesses on different\n-memory locations, but each kill-related operation is only a swap on a single\n-location, so atomicity is all that matters. The exception is kill(), which\n-does a swap on both flags in sequence. kill() needs no barriers because it\n-does not matter if its two accesses are seen reordered on another CPU: if a\n-killer does perform both writes, it means it saw a KILL_RUNNING in the\n-unkillable flag, which means an unkillable task will see KILL_KILLED and fail\n-immediately (rendering the subsequent write to the kill flag unnecessary).\n-\n-\n-II. Exit code propagation.\n-\n-The basic model for exit code propagation, which is used with the \"watched\"\n-spawn mode (on by default for linked spawns, off for supervised and unlinked\n-spawns), is that a parent will wait for all its watched children to exit\n-before reporting whether it succeeded or failed. A watching parent will only\n-report success if it succeeded and all its children also reported success;\n-otherwise, it will report failure. This is most useful for writing test cases:\n-\n- ```\n-#[test]\n-fn test_something_in_another_task {\n-    do spawn {\n-        assert!(collatz_conjecture_is_false());\n-    }\n-}\n- ```\n-\n-Here, as the child task will certainly outlive the parent task, we might miss\n-the failure of the child when deciding whether or not the test case passed.\n-The watched spawn mode avoids this problem.\n-\n-In order to propagate exit codes from children to their parents, any\n-'watching' parent must wait for all of its children to exit before it can\n-report its final exit status. We achieve this by using an UnsafeArc, using the\n-reference counting to track how many children are still alive, and using the\n-unwrap() operation in the parent's exit path to wait for all children to exit.\n-The UnsafeArc referred to here is actually the KillHandle itself.\n-\n-This also works transitively, as if a \"middle\" watched child task is itself\n-watching a grandchild task, the \"middle\" task will do unwrap() on its own\n-KillHandle (thereby waiting for the grandchild to exit) before dropping its\n-reference to its watching parent (which will alert the parent).\n-\n-While UnsafeArc::unwrap() accomplishes the synchronization, there remains the\n-matter of reporting the exit codes themselves. This is easiest when an exiting\n-watched task has no watched children of its own:\n-\n-- If the task with no watched children exits successfully, it need do nothing.\n-- If the task with no watched children has failed, it sets a flag in the\n-  parent's KillHandle (\"any_child_failed\") to false. It then stays false forever.\n-\n-However, if a \"middle\" watched task with watched children of its own exits\n-before its child exits, we need to ensure that the grandparent task may still\n-see a failure from the grandchild task. While we could achieve this by having\n-each intermediate task block on its handle, this keeps around the other resources\n-the task was using. To be more efficient, this is accomplished via \"tombstones\".\n-\n-A tombstone is a closure, proc() -> bool, which will perform any waiting necessary\n-to collect the exit code of descendant tasks. In its environment is captured\n-the KillHandle of whichever task created the tombstone, and perhaps also any\n-tombstones that that task itself had, and finally also another tombstone,\n-effectively creating a lazy-list of heap closures.\n-\n-When a child wishes to exit early and leave tombstones behind for its parent,\n-it must use a LittleLock (pthread mutex) to synchronize with any possible\n-sibling tasks which are trying to do the same thing with the same parent.\n-However, on the other side, when the parent is ready to pull on the tombstones,\n-it need not use this lock, because the unwrap() serves as a barrier that ensures\n-no children will remain with references to the handle.\n-\n-The main logic for creating and assigning tombstones can be found in the\n-function reparent_children_to() in the impl for KillHandle.\n-\n-\n-IIA. Issues with exit code propagation.\n-\n-There are two known issues with the current scheme for exit code propagation.\n-\n-- As documented in issue #8136, the structure mandates the possibility for stack\n-  overflow when collecting tombstones that are very deeply nested. This cannot\n-  be avoided with the closure representation, as tombstones end up structured in\n-  a sort of tree. However, notably, the tombstones do not actually need to be\n-  collected in any particular order, and so a doubly-linked list may be used.\n-  However we do not do this yet because DList is in libextra.\n-\n-- A discussion with Graydon made me realize that if we decoupled the exit code\n-  propagation from the parents-waiting action, this could result in a simpler\n-  implementation as the exit codes themselves would not have to be propagated,\n-  and could instead be propagated implicitly through the taskgroup mechanism\n-  that we already have. The tombstoning scheme would still be required. I have\n-  not implemented this because currently we can't receive a linked failure kill\n-  signal during the task cleanup activity, as that is currently \"unkillable\",\n-  and occurs outside the task's unwinder's \"try\" block, so would require some\n-  restructuring.\n-\n-*/\n-\n-use cast;\n-use option::{Option, Some, None};\n-use prelude::*;\n-use iter;\n-use task::TaskResult;\n-use rt::task::Task;\n-use unstable::atomics::{AtomicUint, SeqCst};\n-use unstable::sync::UnsafeArc;\n-\n-/// A handle to a blocked task. Usually this means having the ~Task pointer by\n-/// ownership, but if the task is killable, a killer can steal it at any time.\n-pub enum BlockedTask {\n-    Owned(~Task),\n-    Shared(UnsafeArc<AtomicUint>),\n-}\n-\n-/// Per-task state related to task death, killing, failure, etc.\n-pub struct Death {\n-    // Action to be done with the exit code. If set, also makes the task wait\n-    // until all its watched children exit before collecting the status.\n-    on_exit:         Option<proc(TaskResult)>,\n-    // nesting level counter for unstable::atomically calls (0 == can deschedule).\n-    priv wont_sleep:      int,\n-}\n-\n-pub struct BlockedTaskIterator {\n-    priv inner: UnsafeArc<AtomicUint>,\n-}\n-\n-impl Iterator<BlockedTask> for BlockedTaskIterator {\n-    fn next(&mut self) -> Option<BlockedTask> {\n-        Some(Shared(self.inner.clone()))\n-    }\n-}\n-\n-impl BlockedTask {\n-    /// Returns Some if the task was successfully woken; None if already killed.\n-    pub fn wake(self) -> Option<~Task> {\n-        match self {\n-            Owned(task) => Some(task),\n-            Shared(arc) => unsafe {\n-                match (*arc.get()).swap(0, SeqCst) {\n-                    0 => None,\n-                    n => cast::transmute(n),\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Create a blocked task, unless the task was already killed.\n-    pub fn block(task: ~Task) -> BlockedTask {\n-        Owned(task)\n-    }\n-\n-    /// Converts one blocked task handle to a list of many handles to the same.\n-    pub fn make_selectable(self, num_handles: uint)\n-        -> iter::Take<BlockedTaskIterator>\n-    {\n-        let arc = match self {\n-            Owned(task) => {\n-                let flag = unsafe { AtomicUint::new(cast::transmute(task)) };\n-                UnsafeArc::new(flag)\n-            }\n-            Shared(arc) => arc.clone(),\n-        };\n-        BlockedTaskIterator{ inner: arc }.take(num_handles)\n-    }\n-\n-    // This assertion has two flavours because the wake involves an atomic op.\n-    // In the faster version, destructors will fail dramatically instead.\n-    #[inline] #[cfg(not(test))]\n-    pub fn assert_already_awake(self) { }\n-    #[inline] #[cfg(test)]\n-    pub fn assert_already_awake(self) { assert!(self.wake().is_none()); }\n-\n-    /// Convert to an unsafe uint value. Useful for storing in a pipe's state flag.\n-    #[inline]\n-    pub unsafe fn cast_to_uint(self) -> uint {\n-        match self {\n-            Owned(task) => {\n-                let blocked_task_ptr: uint = cast::transmute(task);\n-                rtassert!(blocked_task_ptr & 0x1 == 0);\n-                blocked_task_ptr\n-            }\n-            Shared(arc) => {\n-                let blocked_task_ptr: uint = cast::transmute(~arc);\n-                rtassert!(blocked_task_ptr & 0x1 == 0);\n-                blocked_task_ptr | 0x1\n-            }\n-        }\n-    }\n-\n-    /// Convert from an unsafe uint value. Useful for retrieving a pipe's state flag.\n-    #[inline]\n-    pub unsafe fn cast_from_uint(blocked_task_ptr: uint) -> BlockedTask {\n-        if blocked_task_ptr & 0x1 == 0 {\n-            Owned(cast::transmute(blocked_task_ptr))\n-        } else {\n-            let ptr: ~UnsafeArc<AtomicUint> = cast::transmute(blocked_task_ptr & !1);\n-            Shared(*ptr)\n-        }\n-    }\n-}\n-\n-impl Death {\n-    pub fn new() -> Death {\n-        Death {\n-            on_exit:         None,\n-            wont_sleep:      0,\n-        }\n-    }\n-\n-    /// Collect failure exit codes from children and propagate them to a parent.\n-    pub fn collect_failure(&mut self, result: TaskResult) {\n-        match self.on_exit.take() {\n-            Some(f) => f(result),\n-            None => {}\n-        }\n-    }\n-\n-    /// Enter a possibly-nested \"atomic\" section of code. Just for assertions.\n-    /// All calls must be paired with a subsequent call to allow_deschedule.\n-    #[inline]\n-    pub fn inhibit_deschedule(&mut self) {\n-        self.wont_sleep += 1;\n-    }\n-\n-    /// Exit a possibly-nested \"atomic\" section of code. Just for assertions.\n-    /// All calls must be paired with a preceding call to inhibit_deschedule.\n-    #[inline]\n-    pub fn allow_deschedule(&mut self) {\n-        rtassert!(self.wont_sleep != 0);\n-        self.wont_sleep -= 1;\n-    }\n-\n-    /// Ensure that the task is allowed to become descheduled.\n-    #[inline]\n-    pub fn assert_may_sleep(&self) {\n-        if self.wont_sleep != 0 {\n-            rtabort!(\"illegal atomic-sleep: attempt to reschedule while \\\n-                      using an Exclusive or LittleLock\");\n-        }\n-    }\n-}\n-\n-impl Drop for Death {\n-    fn drop(&mut self) {\n-        // Mustn't be in an atomic or unkillable section at task death.\n-        rtassert!(self.wont_sleep == 0);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use rt::test::*;\n-    use super::*;\n-\n-    // Task blocking tests\n-\n-    #[test]\n-    fn block_and_wake() {\n-        do with_test_task |task| {\n-            BlockedTask::block(task).wake().unwrap()\n-        }\n-    }\n-}"}, {"sha": "1c04b6b43ce77418f0f6cf2c99bab13f0bf8e8a1", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 10, "deletions": 88, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use option::{Option, Some, None};\n-use rt::sched::Scheduler;\n+use option::Option;\n use rt::task::Task;\n use rt::local_ptr;\n \n@@ -46,87 +45,10 @@ impl Local<local_ptr::Borrowed<Task>> for Task {\n     }\n }\n \n-/// Encapsulates a temporarily-borrowed scheduler.\n-pub struct BorrowedScheduler {\n-    priv task: local_ptr::Borrowed<Task>,\n-}\n-\n-impl BorrowedScheduler {\n-    fn new(mut task: local_ptr::Borrowed<Task>) -> BorrowedScheduler {\n-        if task.get().sched.is_none() {\n-            rtabort!(\"no scheduler\")\n-        } else {\n-            BorrowedScheduler {\n-                task: task,\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn get<'a>(&'a mut self) -> &'a mut ~Scheduler {\n-        match self.task.get().sched {\n-            None => rtabort!(\"no scheduler\"),\n-            Some(ref mut sched) => sched,\n-        }\n-    }\n-}\n-\n-impl Local<BorrowedScheduler> for Scheduler {\n-    fn put(value: ~Scheduler) {\n-        let mut task = Local::borrow(None::<Task>);\n-        task.get().sched = Some(value);\n-    }\n-    #[inline]\n-    fn take() -> ~Scheduler {\n-        unsafe {\n-            // XXX: Unsafe for speed\n-            let task: *mut Task = Local::unsafe_borrow();\n-            (*task).sched.take_unwrap()\n-        }\n-    }\n-    fn exists(_: Option<Scheduler>) -> bool {\n-        let mut task = Local::borrow(None::<Task>);\n-        task.get().sched.is_some()\n-    }\n-    #[inline]\n-    fn borrow(_: Option<Scheduler>) -> BorrowedScheduler {\n-        BorrowedScheduler::new(Local::borrow(None::<Task>))\n-    }\n-    unsafe fn unsafe_take() -> ~Scheduler { rtabort!(\"unimpl\") }\n-    unsafe fn unsafe_borrow() -> *mut Scheduler {\n-        let task: *mut Task = Local::unsafe_borrow();\n-        match (*task).sched {\n-            Some(~ref mut sched) => {\n-                let s: *mut Scheduler = &mut *sched;\n-                return s;\n-            }\n-            None => {\n-                rtabort!(\"no scheduler\")\n-            }\n-        }\n-    }\n-    unsafe fn try_unsafe_borrow() -> Option<*mut Scheduler> {\n-        let task_opt: Option<*mut Task> = Local::try_unsafe_borrow();\n-        match task_opt {\n-            Some(task) => {\n-                match (*task).sched {\n-                    Some(~ref mut sched) => {\n-                        let s: *mut Scheduler = &mut *sched;\n-                        Some(s)\n-                    }\n-                    None => None\n-                }\n-            }\n-            None => None\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod test {\n     use option::None;\n     use unstable::run_in_bare_thread;\n-    use rt::test::*;\n     use super::*;\n     use rt::task::Task;\n     use rt::local_ptr;\n@@ -135,8 +57,7 @@ mod test {\n     fn thread_local_task_smoke_test() {\n         do run_in_bare_thread {\n             local_ptr::init();\n-            let mut sched = ~new_test_uv_sched();\n-            let task = ~Task::new_root(&mut sched.stack_pool, None, proc(){});\n+            let task = ~Task::new();\n             Local::put(task);\n             let task: ~Task = Local::take();\n             cleanup_task(task);\n@@ -147,12 +68,11 @@ mod test {\n     fn thread_local_task_two_instances() {\n         do run_in_bare_thread {\n             local_ptr::init();\n-            let mut sched = ~new_test_uv_sched();\n-            let task = ~Task::new_root(&mut sched.stack_pool, None, proc(){});\n+            let task = ~Task::new();\n             Local::put(task);\n             let task: ~Task = Local::take();\n             cleanup_task(task);\n-            let task = ~Task::new_root(&mut sched.stack_pool, None, proc(){});\n+            let task = ~Task::new();\n             Local::put(task);\n             let task: ~Task = Local::take();\n             cleanup_task(task);\n@@ -164,8 +84,7 @@ mod test {\n     fn borrow_smoke_test() {\n         do run_in_bare_thread {\n             local_ptr::init();\n-            let mut sched = ~new_test_uv_sched();\n-            let task = ~Task::new_root(&mut sched.stack_pool, None, proc(){});\n+            let task = ~Task::new();\n             Local::put(task);\n \n             unsafe {\n@@ -180,8 +99,7 @@ mod test {\n     fn borrow_with_return() {\n         do run_in_bare_thread {\n             local_ptr::init();\n-            let mut sched = ~new_test_uv_sched();\n-            let task = ~Task::new_root(&mut sched.stack_pool, None, proc(){});\n+            let task = ~Task::new();\n             Local::put(task);\n \n             {\n@@ -193,5 +111,9 @@ mod test {\n         }\n     }\n \n+    fn cleanup_task(mut t: ~Task) {\n+        t.destroyed = true;\n+    }\n+\n }\n "}, {"sha": "42cce272e4430807d437cebf90d69f235c5e9099", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -42,7 +42,7 @@ impl<T> Drop for Borrowed<T> {\n             }\n             let val: ~T = cast::transmute(self.val);\n             put::<T>(val);\n-            assert!(exists());\n+            rtassert!(exists());\n         }\n     }\n }\n@@ -109,7 +109,9 @@ pub mod compiled {\n     /// Does not validate the pointer type.\n     #[inline]\n     pub unsafe fn take<T>() -> ~T {\n-        let ptr: ~T = cast::transmute(RT_TLS_PTR);\n+        let ptr = RT_TLS_PTR;\n+        rtassert!(!ptr.is_null());\n+        let ptr: ~T = cast::transmute(ptr);\n         // can't use `as`, due to type not matching with `cfg(test)`\n         RT_TLS_PTR = cast::transmute(0);\n         ptr\n@@ -178,7 +180,7 @@ pub mod native {\n     }\n \n     pub unsafe fn cleanup() {\n-        assert!(INITIALIZED);\n+        rtassert!(INITIALIZED);\n         tls::destroy(RT_TLS_KEY);\n         LOCK.destroy();\n         INITIALIZED = false;"}, {"sha": "0dd6c883d5b47affb4142130cc8d9c004fd2ff59", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 33, "deletions": 326, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -57,36 +57,26 @@ Several modules in `core` are clients of `rt`:\n // XXX: this should not be here.\n #[allow(missing_doc)];\n \n+use any::Any;\n use clone::Clone;\n use container::Container;\n use iter::Iterator;\n-use option::{Option, None, Some};\n+use option::Option;\n use ptr::RawPtr;\n-use rt::local::Local;\n-use rt::sched::{Scheduler, Shutdown};\n-use rt::sleeper_list::SleeperList;\n-use task::TaskResult;\n-use rt::task::{Task, SchedTask, GreenTask, Sched};\n-use send_str::SendStrStatic;\n-use unstable::atomics::{AtomicInt, AtomicBool, SeqCst};\n-use unstable::sync::UnsafeArc;\n+use result::Result;\n+use task::TaskOpts;\n use vec::{OwnedVector, MutableVector, ImmutableVector};\n-use vec;\n \n-use self::thread::Thread;\n-\n-// the os module needs to reach into this helper, so allow general access\n-// through this reexport.\n-pub use self::util::set_exit_status;\n+use self::task::{Task, BlockedTask};\n \n // this is somewhat useful when a program wants to spawn a \"reasonable\" number\n // of workers based on the constraints of the system that it's running on.\n // Perhaps this shouldn't be a `pub use` though and there should be another\n // method...\n pub use self::util::default_sched_threads;\n \n-// Re-export of the functionality in the kill module\n-pub use self::kill::BlockedTask;\n+// Export unwinding facilities used by the failure macros\n+pub use self::unwind::{begin_unwind, begin_unwind_raw};\n \n // XXX: these probably shouldn't be public...\n #[doc(hidden)]\n@@ -99,49 +89,19 @@ pub mod shouldnt_be_public {\n // Internal macros used by the runtime.\n mod macros;\n \n-/// Basic implementation of an EventLoop, provides no I/O interfaces\n-mod basic;\n-\n /// The global (exchange) heap.\n pub mod global_heap;\n \n /// Implementations of language-critical runtime features like @.\n pub mod task;\n \n-/// Facilities related to task failure, killing, and death.\n-mod kill;\n-\n-/// The coroutine task scheduler, built on the `io` event loop.\n-pub mod sched;\n-\n /// The EventLoop and internal synchronous I/O interface.\n pub mod rtio;\n \n /// The Local trait for types that are accessible via thread-local\n /// or task-local storage.\n pub mod local;\n \n-/// A mostly lock-free multi-producer, single consumer queue.\n-pub mod mpsc_queue;\n-\n-/// A lock-free single-producer, single consumer queue.\n-pub mod spsc_queue;\n-\n-/// A lock-free multi-producer, multi-consumer bounded queue.\n-mod mpmc_bounded_queue;\n-\n-/// A parallel work-stealing deque\n-pub mod deque;\n-\n-/// A parallel data structure for tracking sleeping schedulers.\n-pub mod sleeper_list;\n-\n-/// Stack segments and caching.\n-pub mod stack;\n-\n-/// CPU context swapping.\n-mod context;\n-\n /// Bindings to system threading libraries.\n pub mod thread;\n \n@@ -157,16 +117,6 @@ pub mod logging;\n /// Crate map\n pub mod crate_map;\n \n-/// Tools for testing the runtime\n-pub mod test;\n-\n-/// Reference counting\n-pub mod rc;\n-\n-/// A simple single-threaded channel type for passing buffered data between\n-/// scheduler and task context\n-pub mod tube;\n-\n /// The runtime needs to be able to put a pointer into thread-local storage.\n mod local_ptr;\n \n@@ -185,41 +135,33 @@ pub mod args;\n // Support for dynamic borrowck\n pub mod borrowck;\n \n-/// Set up a default runtime configuration, given compiler-supplied arguments.\n-///\n-/// This is invoked by the `start` _language item_ (unstable::lang) to\n-/// run a Rust executable.\n-///\n-/// # Arguments\n-///\n-/// * `argc` & `argv` - The argument vector. On Unix this information is used\n-///   by os::args.\n-///\n-/// # Return value\n-///\n-/// The return value is used as the process return code. 0 on success, 101 on error.\n-pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n-\n-    init(argc, argv);\n-    let exit_code = run(main);\n-    // unsafe is ok b/c we're sure that the runtime is gone\n-    unsafe { cleanup(); }\n-\n-    return exit_code;\n-}\n+/// The default error code of the rust runtime if the main task fails instead\n+/// of exiting cleanly.\n+pub static DEFAULT_ERROR_CODE: int = 101;\n \n-/// Like `start` but creates an additional scheduler on the current thread,\n-/// which in most cases will be the 'main' thread, and pins the main task to it.\n+/// The interface to the current runtime.\n ///\n-/// This is appropriate for running code that must execute on the main thread,\n-/// such as the platform event loop and GUI.\n-pub fn start_on_main_thread(argc: int, argv: **u8, main: proc()) -> int {\n-    init(argc, argv);\n-    let exit_code = run_on_main_thread(main);\n-    // unsafe is ok b/c we're sure that the runtime is gone\n-    unsafe { cleanup(); }\n-\n-    return exit_code;\n+/// This trait is used as the abstraction between 1:1 and M:N scheduling. The\n+/// two independent crates, libnative and libgreen, both have objects which\n+/// implement this trait. The goal of this trait is to encompass all the\n+/// fundamental differences in functionality between the 1:1 and M:N runtime\n+/// modes.\n+pub trait Runtime {\n+    // Necessary scheduling functions, used for channels and blocking I/O\n+    // (sometimes).\n+    fn yield_now(~self, cur_task: ~Task);\n+    fn maybe_yield(~self, cur_task: ~Task);\n+    fn deschedule(~self, times: uint, cur_task: ~Task,\n+                  f: |BlockedTask| -> Result<(), BlockedTask>);\n+    fn reawaken(~self, to_wake: ~Task, can_resched: bool);\n+\n+    // Miscellaneous calls which are very different depending on what context\n+    // you're in.\n+    fn spawn_sibling(~self, cur_task: ~Task, opts: TaskOpts, f: proc());\n+    fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>>;\n+\n+    // XXX: This is a serious code smell and this should not exist at all.\n+    fn wrap(~self) -> ~Any;\n }\n \n /// One-time runtime initialization.\n@@ -234,6 +176,7 @@ pub fn init(argc: int, argv: **u8) {\n         args::init(argc, argv);\n         env::init();\n         logging::init();\n+        local_ptr::init();\n     }\n }\n \n@@ -250,239 +193,3 @@ pub unsafe fn cleanup() {\n     args::cleanup();\n     local_ptr::cleanup();\n }\n-\n-/// Execute the main function in a scheduler.\n-///\n-/// Configures the runtime according to the environment, by default\n-/// using a task scheduler with the same number of threads as cores.\n-/// Returns a process exit code.\n-pub fn run(main: proc()) -> int {\n-    run_(main, false)\n-}\n-\n-pub fn run_on_main_thread(main: proc()) -> int {\n-    run_(main, true)\n-}\n-\n-fn run_(main: proc(), use_main_sched: bool) -> int {\n-    static DEFAULT_ERROR_CODE: int = 101;\n-\n-    let nscheds = util::default_sched_threads();\n-\n-    let mut main = Some(main);\n-\n-    // The shared list of sleeping schedulers.\n-    let sleepers = SleeperList::new();\n-\n-    // Create a work queue for each scheduler, ntimes. Create an extra\n-    // for the main thread if that flag is set. We won't steal from it.\n-    let mut pool = deque::BufferPool::new();\n-    let arr = vec::from_fn(nscheds, |_| pool.deque());\n-    let (workers, stealers) = vec::unzip(arr.move_iter());\n-\n-    // The schedulers.\n-    let mut scheds = ~[];\n-    // Handles to the schedulers. When the main task ends these will be\n-    // sent the Shutdown message to terminate the schedulers.\n-    let mut handles = ~[];\n-\n-    for worker in workers.move_iter() {\n-        rtdebug!(\"inserting a regular scheduler\");\n-\n-        // Every scheduler is driven by an I/O event loop.\n-        let loop_ = new_event_loop();\n-        let mut sched = ~Scheduler::new(loop_,\n-                                        worker,\n-                                        stealers.clone(),\n-                                        sleepers.clone());\n-        let handle = sched.make_handle();\n-\n-        scheds.push(sched);\n-        handles.push(handle);\n-    }\n-\n-    // If we need a main-thread task then create a main thread scheduler\n-    // that will reject any task that isn't pinned to it\n-    let main_sched = if use_main_sched {\n-\n-        // Create a friend handle.\n-        let mut friend_sched = scheds.pop();\n-        let friend_handle = friend_sched.make_handle();\n-        scheds.push(friend_sched);\n-\n-        // This scheduler needs a queue that isn't part of the stealee\n-        // set.\n-        let (worker, _) = pool.deque();\n-\n-        let main_loop = new_event_loop();\n-        let mut main_sched = ~Scheduler::new_special(main_loop,\n-                                                     worker,\n-                                                     stealers.clone(),\n-                                                     sleepers.clone(),\n-                                                     false,\n-                                                     Some(friend_handle));\n-        let mut main_handle = main_sched.make_handle();\n-        // Allow the scheduler to exit when the main task exits.\n-        // Note: sending the shutdown message also prevents the scheduler\n-        // from pushing itself to the sleeper list, which is used for\n-        // waking up schedulers for work stealing; since this is a\n-        // non-work-stealing scheduler it should not be adding itself\n-        // to the list.\n-        main_handle.send(Shutdown);\n-        Some(main_sched)\n-    } else {\n-        None\n-    };\n-\n-    // Create a shared cell for transmitting the process exit\n-    // code from the main task to this function.\n-    let exit_code = UnsafeArc::new(AtomicInt::new(0));\n-    let exit_code_clone = exit_code.clone();\n-\n-    // Used to sanity check that the runtime only exits once\n-    let exited_already = UnsafeArc::new(AtomicBool::new(false));\n-\n-    // When the main task exits, after all the tasks in the main\n-    // task tree, shut down the schedulers and set the exit code.\n-    let handles = handles;\n-    let on_exit: proc(TaskResult) = proc(exit_success) {\n-        unsafe {\n-            assert!(!(*exited_already.get()).swap(true, SeqCst),\n-                    \"the runtime already exited\");\n-        }\n-\n-        let mut handles = handles;\n-        for handle in handles.mut_iter() {\n-            handle.send(Shutdown);\n-        }\n-\n-        unsafe {\n-            let exit_code = if exit_success.is_ok() {\n-                use rt::util;\n-\n-                // If we're exiting successfully, then return the global\n-                // exit status, which can be set programmatically.\n-                util::get_exit_status()\n-            } else {\n-                DEFAULT_ERROR_CODE\n-            };\n-            (*exit_code_clone.get()).store(exit_code, SeqCst);\n-        }\n-    };\n-\n-    let mut threads = ~[];\n-    let mut on_exit = Some(on_exit);\n-\n-    if !use_main_sched {\n-\n-        // In the case where we do not use a main_thread scheduler we\n-        // run the main task in one of our threads.\n-\n-        let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool,\n-                                            None,\n-                                            ::util::replace(&mut main,\n-                                                            None).unwrap());\n-        main_task.name = Some(SendStrStatic(\"<main>\"));\n-        main_task.death.on_exit = ::util::replace(&mut on_exit, None);\n-\n-        let sched = scheds.pop();\n-        let main_task = main_task;\n-        let thread = do Thread::start {\n-            sched.bootstrap(main_task);\n-        };\n-        threads.push(thread);\n-    }\n-\n-    // Run each remaining scheduler in a thread.\n-    for sched in scheds.move_rev_iter() {\n-        rtdebug!(\"creating regular schedulers\");\n-        let thread = do Thread::start {\n-            let mut sched = sched;\n-            let bootstrap_task = ~do Task::new_root(&mut sched.stack_pool, None) || {\n-                rtdebug!(\"boostraping a non-primary scheduler\");\n-            };\n-            sched.bootstrap(bootstrap_task);\n-        };\n-        threads.push(thread);\n-    }\n-\n-    // If we do have a main thread scheduler, run it now.\n-\n-    if use_main_sched {\n-        rtdebug!(\"about to create the main scheduler task\");\n-\n-        let mut main_sched = main_sched.unwrap();\n-\n-        let home = Sched(main_sched.make_handle());\n-        let mut main_task = ~Task::new_root_homed(&mut main_sched.stack_pool,\n-                                                  None,\n-                                                  home,\n-                                                  ::util::replace(&mut main,\n-                                                                  None).\n-                                                                  unwrap());\n-        main_task.name = Some(SendStrStatic(\"<main>\"));\n-        main_task.death.on_exit = ::util::replace(&mut on_exit, None);\n-        rtdebug!(\"bootstrapping main_task\");\n-\n-        main_sched.bootstrap(main_task);\n-    }\n-\n-    rtdebug!(\"waiting for threads\");\n-\n-    // Wait for schedulers\n-    for thread in threads.move_iter() {\n-        thread.join();\n-    }\n-\n-    // Return the exit code\n-    unsafe {\n-        (*exit_code.get()).load(SeqCst)\n-    }\n-}\n-\n-pub fn in_sched_context() -> bool {\n-    unsafe {\n-        let task_ptr: Option<*mut Task> = Local::try_unsafe_borrow();\n-        match task_ptr {\n-            Some(task) => {\n-                match (*task).task_type {\n-                    SchedTask => true,\n-                    _ => false\n-                }\n-            }\n-            None => false\n-        }\n-    }\n-}\n-\n-pub fn in_green_task_context() -> bool {\n-    unsafe {\n-        let task: Option<*mut Task> = Local::try_unsafe_borrow();\n-        match task {\n-            Some(task) => {\n-                match (*task).task_type {\n-                    GreenTask(_) => true,\n-                    _ => false\n-                }\n-            }\n-            None => false\n-        }\n-    }\n-}\n-\n-pub fn new_event_loop() -> ~rtio::EventLoop {\n-    match crate_map::get_crate_map() {\n-        None => {}\n-        Some(map) => {\n-            match map.event_loop_factory {\n-                None => {}\n-                Some(factory) => return factory()\n-            }\n-        }\n-    }\n-\n-    // If the crate map didn't specify a factory to create an event loop, then\n-    // instead just use a basic event loop missing all I/O services to at least\n-    // get the scheduler running.\n-    return basic::event_loop();\n-}"}, {"sha": "2699dab6d38a871586762b7f331092b32fbc2d6b", "filename": "src/libstd/rt/rc.rs", "status": "removed", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibstd%2Frt%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibstd%2Frt%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frc.rs?ref=d975060de6c944ca12ce5205fbc9fc7726948ae1", "patch": "@@ -1,139 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! An owned, task-local, reference counted type\n-//!\n-//! # Safety note\n-//!\n-//! XXX There is currently no type-system mechanism for enforcing that\n-//! reference counted types are both allocated on the exchange heap\n-//! and also non-sendable\n-//!\n-//! This doesn't prevent borrowing multiple aliasable mutable pointers\n-\n-use ops::Drop;\n-use clone::Clone;\n-use libc::c_void;\n-use cast;\n-\n-pub struct RC<T> {\n-    priv p: *c_void // ~(uint, T)\n-}\n-\n-impl<T> RC<T> {\n-    pub fn new(val: T) -> RC<T> {\n-        unsafe {\n-            let v = ~(1, val);\n-            let p: *c_void = cast::transmute(v);\n-            RC { p: p }\n-        }\n-    }\n-\n-    fn get_mut_state(&mut self) -> *mut (uint, T) {\n-        unsafe {\n-            let p: &mut ~(uint, T) = cast::transmute(&mut self.p);\n-            let p: *mut (uint, T) = &mut **p;\n-            return p;\n-        }\n-    }\n-\n-    fn get_state(&self) -> *(uint, T) {\n-        unsafe {\n-            let p: &~(uint, T) = cast::transmute(&self.p);\n-            let p: *(uint, T) = &**p;\n-            return p;\n-        }\n-    }\n-\n-    pub fn unsafe_borrow_mut(&mut self) -> *mut T {\n-        unsafe {\n-            match *self.get_mut_state() {\n-                (_, ref mut p) => {\n-                    let p: *mut T = p;\n-                    return p;\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn refcount(&self) -> uint {\n-        unsafe {\n-            match *self.get_state() {\n-                (count, _) => count\n-            }\n-        }\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<T> Drop for RC<T> {\n-    fn drop(&mut self) {\n-        assert!(self.refcount() > 0);\n-\n-        unsafe {\n-            match *self.get_mut_state() {\n-                (ref mut count, _) => {\n-                    *count = *count - 1\n-                }\n-            }\n-\n-            if self.refcount() == 0 {\n-                let _: ~(uint, T) = cast::transmute(self.p);\n-            }\n-        }\n-    }\n-}\n-\n-impl<T> Clone for RC<T> {\n-    fn clone(&self) -> RC<T> {\n-        unsafe {\n-            // XXX: Mutable clone\n-            let this: &mut RC<T> = cast::transmute_mut(self);\n-\n-            match *this.get_mut_state() {\n-                (ref mut count, _) => {\n-                    *count = *count + 1;\n-                }\n-            }\n-        }\n-\n-        RC { p: self.p }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::RC;\n-\n-    #[test]\n-    fn smoke_test() {\n-        unsafe {\n-            let mut v1 = RC::new(100);\n-            assert!(*v1.unsafe_borrow_mut() == 100);\n-            assert!(v1.refcount() == 1);\n-\n-            let mut v2 = v1.clone();\n-            assert!(*v2.unsafe_borrow_mut() == 100);\n-            assert!(v2.refcount() == 2);\n-\n-            *v2.unsafe_borrow_mut() = 200;\n-            assert!(*v2.unsafe_borrow_mut() == 200);\n-            assert!(*v1.unsafe_borrow_mut() == 200);\n-\n-            let v3 = v2.clone();\n-            assert!(v3.refcount() == 3);\n-            {\n-                let _v1 = v1;\n-                let _v2 = v2;\n-            }\n-            assert!(v3.refcount() == 1);\n-        }\n-    }\n-}"}, {"sha": "6b3d50a76ac8fce9151b09259b296e37e8aec424", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 44, "deletions": 27, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -14,14 +14,15 @@ use comm::{SharedChan, Port};\n use libc::c_int;\n use libc;\n use ops::Drop;\n-use option::*;\n+use option::{Option, Some, None};\n use path::Path;\n-use result::*;\n+use result::{Result, Ok, Err};\n+use rt::task::Task;\n+use rt::local::Local;\n \n use ai = io::net::addrinfo;\n+use io;\n use io::IoError;\n-use io::native::NATIVE_IO_FACTORY;\n-use io::native;\n use io::net::ip::{IpAddr, SocketAddr};\n use io::process::{ProcessConfig, ProcessExit};\n use io::signal::Signum;\n@@ -93,36 +94,52 @@ impl<'a> Drop for LocalIo<'a> {\n impl<'a> LocalIo<'a> {\n     /// Returns the local I/O: either the local scheduler's I/O services or\n     /// the native I/O services.\n-    pub fn borrow() -> LocalIo {\n-        use rt::sched::Scheduler;\n-        use rt::local::Local;\n+    pub fn borrow() -> Option<LocalIo> {\n+        // FIXME(#11053): bad\n+        //\n+        // This is currently very unsafely implemented. We don't actually\n+        // *take* the local I/O so there's a very real possibility that we\n+        // can have two borrows at once. Currently there is not a clear way\n+        // to actually borrow the local I/O factory safely because even if\n+        // ownership were transferred down to the functions that the I/O\n+        // factory implements it's just too much of a pain to know when to\n+        // relinquish ownership back into the local task (but that would be\n+        // the safe way of implementing this function).\n+        //\n+        // In order to get around this, we just transmute a copy out of the task\n+        // in order to have what is likely a static lifetime (bad).\n+        let mut t: ~Task = Local::take();\n+        let ret = t.local_io().map(|t| {\n+            unsafe { cast::transmute_copy(&t) }\n+        });\n+        Local::put(t);\n+        return ret;\n+    }\n \n-        unsafe {\n-            // First, attempt to use the local scheduler's I/O services\n-            let sched: Option<*mut Scheduler> = Local::try_unsafe_borrow();\n-            match sched {\n-                Some(sched) => {\n-                    match (*sched).event_loop.io() {\n-                        Some(factory) => {\n-                            return LocalIo {\n-                                factory: factory,\n-                            }\n-                        }\n-                        None => {}\n+    pub fn maybe_raise<T>(f: |io: &mut IoFactory| -> Result<T, IoError>)\n+        -> Option<T>\n+    {\n+        match LocalIo::borrow() {\n+            None => {\n+                io::io_error::cond.raise(io::standard_error(io::IoUnavailable));\n+                None\n+            }\n+            Some(mut io) => {\n+                match f(io.get()) {\n+                    Ok(t) => Some(t),\n+                    Err(ioerr) => {\n+                        io::io_error::cond.raise(ioerr);\n+                        None\n                     }\n                 }\n-                None => {}\n-            }\n-            // If we don't have a scheduler or the scheduler doesn't have I/O\n-            // services, then fall back to the native I/O services.\n-            let native_io: &'static mut native::IoFactory =\n-                &mut NATIVE_IO_FACTORY;\n-            LocalIo {\n-                factory: native_io as &mut IoFactory:'static\n             }\n         }\n     }\n \n+    pub fn new<'a>(io: &'a mut IoFactory) -> LocalIo<'a> {\n+        LocalIo { factory: io }\n+    }\n+\n     /// Returns the underlying I/O factory as a trait reference.\n     #[inline]\n     pub fn get<'a>(&'a mut self) -> &'a mut IoFactory {"}, {"sha": "e6ab159a769528d03339347d55fc52d754886b32", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 306, "deletions": 494, "changes": 800, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -13,29 +13,41 @@\n //! local storage, and logging. Even a 'freestanding' Rust would likely want\n //! to implement this.\n \n-use super::local_heap::LocalHeap;\n-\n-use prelude::*;\n-\n+use any::AnyOwnExt;\n use borrow;\n+use cast;\n use cleanup;\n use io::Writer;\n-use libc::{c_char, size_t};\n+use iter::{Iterator, Take};\n use local_data;\n+use ops::Drop;\n use option::{Option, Some, None};\n+use prelude::drop;\n+use result::{Result, Ok, Err};\n+use rt::Runtime;\n use rt::borrowck::BorrowRecord;\n use rt::borrowck;\n-use rt::context::Context;\n-use rt::env;\n-use rt::kill::Death;\n use rt::local::Local;\n+use rt::local_heap::LocalHeap;\n use rt::logging::StdErrLogger;\n-use rt::sched::{Scheduler, SchedHandle};\n-use rt::stack::{StackSegment, StackPool};\n+use rt::rtio::LocalIo;\n use rt::unwind::Unwinder;\n use send_str::SendStr;\n+use sync::arc::UnsafeArc;\n+use sync::atomics::{AtomicUint, SeqCst, INIT_ATOMIC_UINT};\n+use task::{TaskResult, TaskOpts};\n use unstable::finally::Finally;\n-use unstable::mutex::Mutex;\n+use unstable::mutex::{Mutex, MUTEX_INIT};\n+\n+#[cfg(stage0)]\n+pub use rt::unwind::begin_unwind;\n+\n+// These two statics are used as bookeeping to keep track of the rust runtime's\n+// count of threads. In 1:1 contexts, this is used to know when to return from\n+// the main function, and in M:N contexts this is used to know when to shut down\n+// the pool of schedulers.\n+static mut TASK_COUNT: AtomicUint = INIT_ATOMIC_UINT;\n+static mut TASK_LOCK: Mutex = MUTEX_INIT;\n \n // The Task struct represents all state associated with a rust\n // task. There are at this point two primary \"subtypes\" of task,\n@@ -45,201 +57,90 @@ use unstable::mutex::Mutex;\n \n pub struct Task {\n     heap: LocalHeap,\n-    priv gc: GarbageCollector,\n+    gc: GarbageCollector,\n     storage: LocalStorage,\n-    logger: Option<StdErrLogger>,\n     unwinder: Unwinder,\n     death: Death,\n     destroyed: bool,\n     name: Option<SendStr>,\n-    coroutine: Option<Coroutine>,\n-    sched: Option<~Scheduler>,\n-    task_type: TaskType,\n     // Dynamic borrowck debugging info\n     borrow_list: Option<~[BorrowRecord]>,\n+\n+    logger: Option<StdErrLogger>,\n     stdout_handle: Option<~Writer>,\n \n-    // See the comments in the scheduler about why this is necessary\n-    nasty_deschedule_lock: Mutex,\n+    priv imp: Option<~Runtime>,\n }\n \n-pub enum TaskType {\n-    GreenTask(Option<SchedHome>),\n-    SchedTask\n-}\n+pub struct GarbageCollector;\n+pub struct LocalStorage(Option<local_data::Map>);\n \n-/// A coroutine is nothing more than a (register context, stack) pair.\n-pub struct Coroutine {\n-    /// The segment of stack on which the task is currently running or\n-    /// if the task is blocked, on which the task will resume\n-    /// execution.\n-    ///\n-    /// Servo needs this to be public in order to tell SpiderMonkey\n-    /// about the stack bounds.\n-    current_stack_segment: StackSegment,\n-    /// Always valid if the task is alive and not running.\n-    saved_context: Context\n+/// A handle to a blocked task. Usually this means having the ~Task pointer by\n+/// ownership, but if the task is killable, a killer can steal it at any time.\n+pub enum BlockedTask {\n+    Owned(~Task),\n+    Shared(UnsafeArc<AtomicUint>),\n }\n \n-/// Some tasks have a dedicated home scheduler that they must run on.\n-pub enum SchedHome {\n-    AnySched,\n-    Sched(SchedHandle)\n+/// Per-task state related to task death, killing, failure, etc.\n+pub struct Death {\n+    // Action to be done with the exit code. If set, also makes the task wait\n+    // until all its watched children exit before collecting the status.\n+    on_exit: Option<proc(TaskResult)>,\n }\n \n-pub struct GarbageCollector;\n-pub struct LocalStorage(Option<local_data::Map>);\n+pub struct BlockedTaskIterator {\n+    priv inner: UnsafeArc<AtomicUint>,\n+}\n \n impl Task {\n-\n-    // A helper to build a new task using the dynamically found\n-    // scheduler and task. Only works in GreenTask context.\n-    pub fn build_homed_child(stack_size: Option<uint>,\n-                             f: proc(),\n-                             home: SchedHome)\n-                             -> ~Task {\n-        let mut running_task = Local::borrow(None::<Task>);\n-        let mut sched = running_task.get().sched.take_unwrap();\n-        let new_task = ~running_task.get()\n-                                    .new_child_homed(&mut sched.stack_pool,\n-                                                     stack_size,\n-                                                     home,\n-                                                     f);\n-        running_task.get().sched = Some(sched);\n-        new_task\n-    }\n-\n-    pub fn build_child(stack_size: Option<uint>, f: proc()) -> ~Task {\n-        Task::build_homed_child(stack_size, f, AnySched)\n-    }\n-\n-    pub fn build_homed_root(stack_size: Option<uint>,\n-                            f: proc(),\n-                            home: SchedHome)\n-                            -> ~Task {\n-        let mut running_task = Local::borrow(None::<Task>);\n-        let mut sched = running_task.get().sched.take_unwrap();\n-        let new_task = ~Task::new_root_homed(&mut sched.stack_pool,\n-                                             stack_size,\n-                                             home,\n-                                             f);\n-        running_task.get().sched = Some(sched);\n-        new_task\n-    }\n-\n-    pub fn build_root(stack_size: Option<uint>, f: proc()) -> ~Task {\n-        Task::build_homed_root(stack_size, f, AnySched)\n-    }\n-\n-    pub fn new_sched_task() -> Task {\n+    pub fn new() -> Task {\n         Task {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n             storage: LocalStorage(None),\n-            logger: None,\n-            unwinder: Unwinder { unwinding: false, cause: None },\n+            unwinder: Unwinder::new(),\n             death: Death::new(),\n             destroyed: false,\n-            coroutine: Some(Coroutine::empty()),\n             name: None,\n-            sched: None,\n-            task_type: SchedTask,\n             borrow_list: None,\n-            stdout_handle: None,\n-            nasty_deschedule_lock: unsafe { Mutex::new() },\n-        }\n-    }\n-\n-    pub fn new_root(stack_pool: &mut StackPool,\n-                    stack_size: Option<uint>,\n-                    start: proc()) -> Task {\n-        Task::new_root_homed(stack_pool, stack_size, AnySched, start)\n-    }\n-\n-    pub fn new_child(&mut self,\n-                     stack_pool: &mut StackPool,\n-                     stack_size: Option<uint>,\n-                     start: proc()) -> Task {\n-        self.new_child_homed(stack_pool, stack_size, AnySched, start)\n-    }\n-\n-    pub fn new_root_homed(stack_pool: &mut StackPool,\n-                          stack_size: Option<uint>,\n-                          home: SchedHome,\n-                          start: proc()) -> Task {\n-        Task {\n-            heap: LocalHeap::new(),\n-            gc: GarbageCollector,\n-            storage: LocalStorage(None),\n             logger: None,\n-            unwinder: Unwinder { unwinding: false, cause: None },\n-            death: Death::new(),\n-            destroyed: false,\n-            name: None,\n-            coroutine: Some(Coroutine::new(stack_pool, stack_size, start)),\n-            sched: None,\n-            task_type: GreenTask(Some(home)),\n-            borrow_list: None,\n             stdout_handle: None,\n-            nasty_deschedule_lock: unsafe { Mutex::new() },\n+            imp: None,\n         }\n     }\n \n-    pub fn new_child_homed(&mut self,\n-                           stack_pool: &mut StackPool,\n-                           stack_size: Option<uint>,\n-                           home: SchedHome,\n-                           start: proc()) -> Task {\n-        Task {\n-            heap: LocalHeap::new(),\n-            gc: GarbageCollector,\n-            storage: LocalStorage(None),\n-            logger: None,\n-            unwinder: Unwinder { unwinding: false, cause: None },\n-            death: Death::new(),\n-            destroyed: false,\n-            name: None,\n-            coroutine: Some(Coroutine::new(stack_pool, stack_size, start)),\n-            sched: None,\n-            task_type: GreenTask(Some(home)),\n-            borrow_list: None,\n-            stdout_handle: None,\n-            nasty_deschedule_lock: unsafe { Mutex::new() },\n-        }\n-    }\n-\n-    pub fn give_home(&mut self, new_home: SchedHome) {\n-        match self.task_type {\n-            GreenTask(ref mut home) => {\n-                *home = Some(new_home);\n-            }\n-            SchedTask => {\n-                rtabort!(\"type error: used SchedTask as GreenTask\");\n-            }\n-        }\n-    }\n-\n-    pub fn take_unwrap_home(&mut self) -> SchedHome {\n-        match self.task_type {\n-            GreenTask(ref mut home) => {\n-                let out = home.take_unwrap();\n-                return out;\n-            }\n-            SchedTask => {\n-                rtabort!(\"type error: used SchedTask as GreenTask\");\n-            }\n-        }\n-    }\n-\n-    pub fn run(&mut self, f: ||) {\n-        rtdebug!(\"run called on task: {}\", borrow::to_uint(self));\n+    /// Executes the given closure as if it's running inside this task. The task\n+    /// is consumed upon entry, and the destroyed task is returned from this\n+    /// function in order for the caller to free. This function is guaranteed to\n+    /// not unwind because the closure specified is run inside of a `rust_try`\n+    /// block. (this is the only try/catch block in the world).\n+    ///\n+    /// This function is *not* meant to be abused as a \"try/catch\" block. This\n+    /// is meant to be used at the absolute boundaries of a task's lifetime, and\n+    /// only for that purpose.\n+    pub fn run(~self, f: ||) -> ~Task {\n+        // Need to put ourselves into TLS, but also need access to the unwinder.\n+        // Unsafely get a handle to the task so we can continue to use it after\n+        // putting it in tls (so we can invoke the unwinder).\n+        let handle: *mut Task = unsafe {\n+            *cast::transmute::<&~Task, &*mut Task>(&self)\n+        };\n+        Local::put(self);\n+        unsafe { TASK_COUNT.fetch_add(1, SeqCst); }\n \n         // The only try/catch block in the world. Attempt to run the task's\n         // client-specified code and catch any failures.\n-        self.unwinder.try(|| {\n+        let try_block = || {\n \n             // Run the task main function, then do some cleanup.\n             f.finally(|| {\n+                fn flush(w: Option<~Writer>) {\n+                    match w {\n+                        Some(mut w) => { w.flush(); }\n+                        None => {}\n+                    }\n+                }\n \n                 // First, destroy task-local storage. This may run user dtors.\n                 //\n@@ -260,434 +161,345 @@ impl Task {\n                 // TLS, or possibly some destructors for those objects being\n                 // annihilated invoke TLS. Sadly these two operations seemed to\n                 // be intertwined, and miraculously work for now...\n-                self.storage.take();\n+                let mut task = Local::borrow(None::<Task>);\n+                let storage = task.get().storage.take();\n+                drop(task);\n+                drop(storage);\n \n                 // Destroy remaining boxes. Also may run user dtors.\n                 unsafe { cleanup::annihilate(); }\n \n                 // Finally flush and destroy any output handles which the task\n                 // owns. There are no boxes here, and no user destructors should\n                 // run after this any more.\n-                match self.stdout_handle.take() {\n-                    Some(handle) => {\n-                        let mut handle = handle;\n-                        handle.flush();\n-                    }\n-                    None => {}\n-                }\n-                self.logger.take();\n+                let mut task = Local::borrow(None::<Task>);\n+                let stdout = task.get().stdout_handle.take();\n+                let logger = task.get().logger.take();\n+                drop(task);\n+\n+                flush(stdout);\n+                drop(logger);\n             })\n-        });\n+        };\n+\n+        unsafe { (*handle).unwinder.try(try_block); }\n \n         // Cleanup the dynamic borrowck debugging info\n         borrowck::clear_task_borrow_list();\n \n-        self.death.collect_failure(self.unwinder.result());\n-        self.destroyed = true;\n+        // Here we must unsafely borrow the task in order to not remove it from\n+        // TLS. When collecting failure, we may attempt to send on a channel (or\n+        // just run aribitrary code), so we must be sure to still have a local\n+        // task in TLS.\n+        unsafe {\n+            let me: *mut Task = Local::unsafe_borrow();\n+            (*me).death.collect_failure((*me).unwinder.result());\n+\n+            // see comments on these statics for why they're used\n+            if TASK_COUNT.fetch_sub(1, SeqCst) == 1 {\n+                TASK_LOCK.lock();\n+                TASK_LOCK.signal();\n+                TASK_LOCK.unlock();\n+            }\n+        }\n+        let mut me: ~Task = Local::take();\n+        me.destroyed = true;\n+        return me;\n     }\n \n-    // New utility functions for homes.\n+    /// Inserts a runtime object into this task, transferring ownership to the\n+    /// task. It is illegal to replace a previous runtime object in this task\n+    /// with this argument.\n+    pub fn put_runtime(&mut self, ops: ~Runtime) {\n+        assert!(self.imp.is_none());\n+        self.imp = Some(ops);\n+    }\n \n-    pub fn is_home_no_tls(&self, sched: &~Scheduler) -> bool {\n-        match self.task_type {\n-            GreenTask(Some(AnySched)) => { false }\n-            GreenTask(Some(Sched(SchedHandle { sched_id: ref id, .. }))) => {\n-                *id == sched.sched_id()\n-            }\n-            GreenTask(None) => {\n-                rtabort!(\"task without home\");\n-            }\n-            SchedTask => {\n-                // Awe yea\n-                rtabort!(\"type error: expected: GreenTask, found: SchedTask\");\n+    /// Attempts to extract the runtime as a specific type. If the runtime does\n+    /// not have the provided type, then the runtime is not removed. If the\n+    /// runtime does have the specified type, then it is removed and returned\n+    /// (transfer of ownership).\n+    ///\n+    /// It is recommended to only use this method when *absolutely necessary*.\n+    /// This function may not be available in the future.\n+    pub fn maybe_take_runtime<T: 'static>(&mut self) -> Option<~T> {\n+        // This is a terrible, terrible function. The general idea here is to\n+        // take the runtime, cast it to ~Any, check if it has the right type,\n+        // and then re-cast it back if necessary. The method of doing this is\n+        // pretty sketchy and involves shuffling vtables of trait objects\n+        // around, but it gets the job done.\n+        //\n+        // XXX: This function is a serious code smell and should be avoided at\n+        //      all costs. I have yet to think of a method to avoid this\n+        //      function, and I would be saddened if more usage of the function\n+        //      crops up.\n+        unsafe {\n+            let imp = self.imp.take_unwrap();\n+            let &(vtable, _): &(uint, uint) = cast::transmute(&imp);\n+            match imp.wrap().move::<T>() {\n+                Ok(t) => Some(t),\n+                Err(t) => {\n+                    let (_, obj): (uint, uint) = cast::transmute(t);\n+                    let obj: ~Runtime = cast::transmute((vtable, obj));\n+                    self.put_runtime(obj);\n+                    None\n+                }\n             }\n         }\n     }\n \n-    pub fn homed(&self) -> bool {\n-        match self.task_type {\n-            GreenTask(Some(AnySched)) => { false }\n-            GreenTask(Some(Sched(SchedHandle { .. }))) => { true }\n-            GreenTask(None) => {\n-                rtabort!(\"task without home\");\n-            }\n-            SchedTask => {\n-                rtabort!(\"type error: expected: GreenTask, found: SchedTask\");\n-            }\n-        }\n+    /// Spawns a sibling to this task. The newly spawned task is configured with\n+    /// the `opts` structure and will run `f` as the body of its code.\n+    pub fn spawn_sibling(mut ~self, opts: TaskOpts, f: proc()) {\n+        let ops = self.imp.take_unwrap();\n+        ops.spawn_sibling(self, opts, f)\n     }\n \n-    // Grab both the scheduler and the task from TLS and check if the\n-    // task is executing on an appropriate scheduler.\n-    pub fn on_appropriate_sched() -> bool {\n-        let mut task = Local::borrow(None::<Task>);\n-        let sched_id = task.get().sched.get_ref().sched_id();\n-        let sched_run_anything = task.get().sched.get_ref().run_anything;\n-        match task.get().task_type {\n-            GreenTask(Some(AnySched)) => {\n-                rtdebug!(\"anysched task in sched check ****\");\n-                sched_run_anything\n-            }\n-            GreenTask(Some(Sched(SchedHandle { sched_id: ref id, ..}))) => {\n-                rtdebug!(\"homed task in sched check ****\");\n-                *id == sched_id\n-            }\n-            GreenTask(None) => {\n-                rtabort!(\"task without home\");\n-            }\n-            SchedTask => {\n-                rtabort!(\"type error: expected: GreenTask, found: SchedTask\");\n-            }\n+    /// Deschedules the current task, invoking `f` `amt` times. It is not\n+    /// recommended to use this function directly, but rather communication\n+    /// primitives in `std::comm` should be used.\n+    pub fn deschedule(mut ~self, amt: uint,\n+                      f: |BlockedTask| -> Result<(), BlockedTask>) {\n+        let ops = self.imp.take_unwrap();\n+        ops.deschedule(amt, self, f)\n+    }\n+\n+    /// Wakes up a previously blocked task, optionally specifiying whether the\n+    /// current task can accept a change in scheduling. This function can only\n+    /// be called on tasks that were previously blocked in `deschedule`.\n+    pub fn reawaken(mut ~self, can_resched: bool) {\n+        let ops = self.imp.take_unwrap();\n+        ops.reawaken(self, can_resched);\n+    }\n+\n+    /// Yields control of this task to another task. This function will\n+    /// eventually return, but possibly not immediately. This is used as an\n+    /// opportunity to allow other tasks a chance to run.\n+    pub fn yield_now(mut ~self) {\n+        let ops = self.imp.take_unwrap();\n+        ops.yield_now(self);\n+    }\n+\n+    /// Similar to `yield_now`, except that this function may immediately return\n+    /// without yielding (depending on what the runtime decides to do).\n+    pub fn maybe_yield(mut ~self) {\n+        let ops = self.imp.take_unwrap();\n+        ops.maybe_yield(self);\n+    }\n+\n+    /// Acquires a handle to the I/O factory that this task contains, normally\n+    /// stored in the task's runtime. This factory may not always be available,\n+    /// which is why the return type is `Option`\n+    pub fn local_io<'a>(&'a mut self) -> Option<LocalIo<'a>> {\n+        self.imp.get_mut_ref().local_io()\n+    }\n+\n+    /// The main function of all rust executables will by default use this\n+    /// function. This function will *block* the OS thread (hence the `unsafe`)\n+    /// waiting for all known tasks to complete. Once this function has\n+    /// returned, it is guaranteed that no more user-defined code is still\n+    /// running.\n+    pub unsafe fn wait_for_other_tasks(&mut self) {\n+        TASK_COUNT.fetch_sub(1, SeqCst); // don't count ourselves\n+        TASK_LOCK.lock();\n+        while TASK_COUNT.load(SeqCst) > 0 {\n+            TASK_LOCK.wait();\n         }\n+        TASK_LOCK.unlock();\n+        TASK_COUNT.fetch_add(1, SeqCst); // add ourselves back in\n     }\n }\n \n impl Drop for Task {\n     fn drop(&mut self) {\n         rtdebug!(\"called drop for a task: {}\", borrow::to_uint(self));\n         rtassert!(self.destroyed);\n-\n-        unsafe { self.nasty_deschedule_lock.destroy(); }\n     }\n }\n \n-// Coroutines represent nothing more than a context and a stack\n-// segment.\n-\n-impl Coroutine {\n-\n-    pub fn new(stack_pool: &mut StackPool,\n-               stack_size: Option<uint>,\n-               start: proc())\n-               -> Coroutine {\n-        let stack_size = match stack_size {\n-            Some(size) => size,\n-            None => env::min_stack()\n-        };\n-        let start = Coroutine::build_start_wrapper(start);\n-        let mut stack = stack_pool.take_segment(stack_size);\n-        let initial_context = Context::new(start, &mut stack);\n-        Coroutine {\n-            current_stack_segment: stack,\n-            saved_context: initial_context\n-        }\n+impl Iterator<BlockedTask> for BlockedTaskIterator {\n+    fn next(&mut self) -> Option<BlockedTask> {\n+        Some(Shared(self.inner.clone()))\n     }\n+}\n \n-    pub fn empty() -> Coroutine {\n-        Coroutine {\n-            current_stack_segment: StackSegment::new(0),\n-            saved_context: Context::empty()\n+impl BlockedTask {\n+    /// Returns Some if the task was successfully woken; None if already killed.\n+    pub fn wake(self) -> Option<~Task> {\n+        match self {\n+            Owned(task) => Some(task),\n+            Shared(arc) => unsafe {\n+                match (*arc.get()).swap(0, SeqCst) {\n+                    0 => None,\n+                    n => Some(cast::transmute(n)),\n+                }\n+            }\n         }\n     }\n \n-    fn build_start_wrapper(start: proc()) -> proc() {\n-        let wrapper: proc() = proc() {\n-            // First code after swap to this new context. Run our\n-            // cleanup job.\n-            unsafe {\n+    // This assertion has two flavours because the wake involves an atomic op.\n+    // In the faster version, destructors will fail dramatically instead.\n+    #[cfg(not(test))] pub fn trash(self) { }\n+    #[cfg(test)]      pub fn trash(self) { assert!(self.wake().is_none()); }\n \n-                // Again - might work while safe, or it might not.\n-                {\n-                    let mut sched = Local::borrow(None::<Scheduler>);\n-                    sched.get().run_cleanup_job();\n-                }\n+    /// Create a blocked task, unless the task was already killed.\n+    pub fn block(task: ~Task) -> BlockedTask {\n+        Owned(task)\n+    }\n \n-                // To call the run method on a task we need a direct\n-                // reference to it. The task is in TLS, so we can\n-                // simply unsafe_borrow it to get this reference. We\n-                // need to still have the task in TLS though, so we\n-                // need to unsafe_borrow.\n-                let task: *mut Task = Local::unsafe_borrow();\n-\n-                let mut start_cell = Some(start);\n-                (*task).run(|| {\n-                    // N.B. Removing `start` from the start wrapper\n-                    // closure by emptying a cell is critical for\n-                    // correctness. The ~Task pointer, and in turn the\n-                    // closure used to initialize the first call\n-                    // frame, is destroyed in the scheduler context,\n-                    // not task context. So any captured closures must\n-                    // not contain user-definable dtors that expect to\n-                    // be in task context. By moving `start` out of\n-                    // the closure, all the user code goes our of\n-                    // scope while the task is still running.\n-                    let start = start_cell.take_unwrap();\n-                    start();\n-                });\n+    /// Converts one blocked task handle to a list of many handles to the same.\n+    pub fn make_selectable(self, num_handles: uint) -> Take<BlockedTaskIterator>\n+    {\n+        let arc = match self {\n+            Owned(task) => {\n+                let flag = unsafe { AtomicUint::new(cast::transmute(task)) };\n+                UnsafeArc::new(flag)\n             }\n-\n-            // We remove the sched from the Task in TLS right now.\n-            let sched: ~Scheduler = Local::take();\n-            // ... allowing us to give it away when performing a\n-            // scheduling operation.\n-            sched.terminate_current_task()\n+            Shared(arc) => arc.clone(),\n         };\n-        return wrapper;\n+        BlockedTaskIterator{ inner: arc }.take(num_handles)\n     }\n \n-    /// Destroy coroutine and try to reuse stack segment.\n-    pub fn recycle(self, stack_pool: &mut StackPool) {\n+    /// Convert to an unsafe uint value. Useful for storing in a pipe's state\n+    /// flag.\n+    #[inline]\n+    pub unsafe fn cast_to_uint(self) -> uint {\n         match self {\n-            Coroutine { current_stack_segment, .. } => {\n-                stack_pool.give_segment(current_stack_segment);\n+            Owned(task) => {\n+                let blocked_task_ptr: uint = cast::transmute(task);\n+                rtassert!(blocked_task_ptr & 0x1 == 0);\n+                blocked_task_ptr\n+            }\n+            Shared(arc) => {\n+                let blocked_task_ptr: uint = cast::transmute(~arc);\n+                rtassert!(blocked_task_ptr & 0x1 == 0);\n+                blocked_task_ptr | 0x1\n             }\n         }\n     }\n \n-}\n-\n-/// This function is invoked from rust's current __morestack function. Segmented\n-/// stacks are currently not enabled as segmented stacks, but rather one giant\n-/// stack segment. This means that whenever we run out of stack, we want to\n-/// truly consider it to be stack overflow rather than allocating a new stack.\n-#[no_mangle]      // - this is called from C code\n-#[no_split_stack] // - it would be sad for this function to trigger __morestack\n-#[doc(hidden)]    // - Function must be `pub` to get exported, but it's\n-                  //   irrelevant for documentation purposes.\n-#[cfg(not(test))] // in testing, use the original libstd's version\n-pub extern \"C\" fn rust_stack_exhausted() {\n-    use rt::context;\n-    use rt::in_green_task_context;\n-    use rt::task::Task;\n-    use rt::local::Local;\n-    use unstable::intrinsics;\n-\n-    unsafe {\n-        // We're calling this function because the stack just ran out. We need\n-        // to call some other rust functions, but if we invoke the functions\n-        // right now it'll just trigger this handler being called again. In\n-        // order to alleviate this, we move the stack limit to be inside of the\n-        // red zone that was allocated for exactly this reason.\n-        let limit = context::get_sp_limit();\n-        context::record_sp_limit(limit - context::RED_ZONE / 2);\n-\n-        // This probably isn't the best course of action. Ideally one would want\n-        // to unwind the stack here instead of just aborting the entire process.\n-        // This is a tricky problem, however. There's a few things which need to\n-        // be considered:\n-        //\n-        //  1. We're here because of a stack overflow, yet unwinding will run\n-        //     destructors and hence arbitrary code. What if that code overflows\n-        //     the stack? One possibility is to use the above allocation of an\n-        //     extra 10k to hope that we don't hit the limit, and if we do then\n-        //     abort the whole program. Not the best, but kind of hard to deal\n-        //     with unless we want to switch stacks.\n-        //\n-        //  2. LLVM will optimize functions based on whether they can unwind or\n-        //     not. It will flag functions with 'nounwind' if it believes that\n-        //     the function cannot trigger unwinding, but if we do unwind on\n-        //     stack overflow then it means that we could unwind in any function\n-        //     anywhere. We would have to make sure that LLVM only places the\n-        //     nounwind flag on functions which don't call any other functions.\n-        //\n-        //  3. The function that overflowed may have owned arguments. These\n-        //     arguments need to have their destructors run, but we haven't even\n-        //     begun executing the function yet, so unwinding will not run the\n-        //     any landing pads for these functions. If this is ignored, then\n-        //     the arguments will just be leaked.\n-        //\n-        // Exactly what to do here is a very delicate topic, and is possibly\n-        // still up in the air for what exactly to do. Some relevant issues:\n-        //\n-        //  #3555 - out-of-stack failure leaks arguments\n-        //  #3695 - should there be a stack limit?\n-        //  #9855 - possible strategies which could be taken\n-        //  #9854 - unwinding on windows through __morestack has never worked\n-        //  #2361 - possible implementation of not using landing pads\n-\n-        if in_green_task_context() {\n-            let mut task = Local::borrow(None::<Task>);\n-            let n = task.get()\n-                        .name\n-                        .as_ref()\n-                        .map(|n| n.as_slice())\n-                        .unwrap_or(\"<unnamed>\");\n-\n-            // See the message below for why this is not emitted to the\n-            // task's logger. This has the additional conundrum of the\n-            // logger may not be initialized just yet, meaning that an FFI\n-            // call would happen to initialized it (calling out to libuv),\n-            // and the FFI call needs 2MB of stack when we just ran out.\n-            rterrln!(\"task '{}' has overflowed its stack\", n);\n+    /// Convert from an unsafe uint value. Useful for retrieving a pipe's state\n+    /// flag.\n+    #[inline]\n+    pub unsafe fn cast_from_uint(blocked_task_ptr: uint) -> BlockedTask {\n+        if blocked_task_ptr & 0x1 == 0 {\n+            Owned(cast::transmute(blocked_task_ptr))\n         } else {\n-            rterrln!(\"stack overflow in non-task context\");\n+            let ptr: ~UnsafeArc<AtomicUint> =\n+                cast::transmute(blocked_task_ptr & !1);\n+            Shared(*ptr)\n         }\n-\n-        intrinsics::abort();\n     }\n }\n \n-/// This is the entry point of unwinding for things like lang items and such.\n-/// The arguments are normally generated by the compiler, and need to\n-/// have static lifetimes.\n-pub fn begin_unwind_raw(msg: *c_char, file: *c_char, line: size_t) -> ! {\n-    use c_str::CString;\n-    use cast::transmute;\n+impl Death {\n+    pub fn new() -> Death {\n+        Death { on_exit: None, }\n+    }\n \n-    #[inline]\n-    fn static_char_ptr(p: *c_char) -> &'static str {\n-        let s = unsafe { CString::new(p, false) };\n-        match s.as_str() {\n-            Some(s) => unsafe { transmute::<&str, &'static str>(s) },\n-            None => rtabort!(\"message wasn't utf8?\")\n+    /// Collect failure exit codes from children and propagate them to a parent.\n+    pub fn collect_failure(&mut self, result: TaskResult) {\n+        match self.on_exit.take() {\n+            Some(f) => f(result),\n+            None => {}\n         }\n     }\n-\n-    let msg = static_char_ptr(msg);\n-    let file = static_char_ptr(file);\n-\n-    begin_unwind(msg, file, line as uint)\n }\n \n-/// This is the entry point of unwinding for fail!() and assert!().\n-pub fn begin_unwind<M: Any + Send>(msg: M, file: &'static str, line: uint) -> ! {\n-    use any::AnyRefExt;\n-    use rt::in_green_task_context;\n-    use rt::local::Local;\n-    use rt::task::Task;\n-    use str::Str;\n-    use unstable::intrinsics;\n-\n-    unsafe {\n-        let task: *mut Task;\n-        // Note that this should be the only allocation performed in this block.\n-        // Currently this means that fail!() on OOM will invoke this code path,\n-        // but then again we're not really ready for failing on OOM anyway. If\n-        // we do start doing this, then we should propagate this allocation to\n-        // be performed in the parent of this task instead of the task that's\n-        // failing.\n-        let msg = ~msg as ~Any;\n-\n-        {\n-            //let msg: &Any = msg;\n-            let msg_s = match msg.as_ref::<&'static str>() {\n-                Some(s) => *s,\n-                None => match msg.as_ref::<~str>() {\n-                    Some(s) => s.as_slice(),\n-                    None => \"~Any\",\n-                }\n-            };\n-\n-            if !in_green_task_context() {\n-                rterrln!(\"failed in non-task context at '{}', {}:{}\",\n-                         msg_s, file, line);\n-                intrinsics::abort();\n-            }\n-\n-            task = Local::unsafe_borrow();\n-            let n = (*task).name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n-\n-            // XXX: this should no get forcibly printed to the console, this should\n-            //      either be sent to the parent task (ideally), or get printed to\n-            //      the task's logger. Right now the logger is actually a uvio\n-            //      instance, which uses unkillable blocks internally for various\n-            //      reasons. This will cause serious trouble if the task is failing\n-            //      due to mismanagment of its own kill flag, so calling our own\n-            //      logger in its current state is a bit of a problem.\n-\n-            rterrln!(\"task '{}' failed at '{}', {}:{}\", n, msg_s, file, line);\n-\n-            if (*task).unwinder.unwinding {\n-                rtabort!(\"unwinding again\");\n-            }\n-        }\n-\n-        (*task).unwinder.begin_unwind(msg);\n+impl Drop for Death {\n+    fn drop(&mut self) {\n+        // make this type noncopyable\n     }\n }\n \n #[cfg(test)]\n mod test {\n     use super::*;\n-    use rt::test::*;\n     use prelude::*;\n+    use task;\n \n     #[test]\n     fn local_heap() {\n-        do run_in_newsched_task() {\n-            let a = @5;\n-            let b = a;\n-            assert!(*a == 5);\n-            assert!(*b == 5);\n-        }\n+        let a = @5;\n+        let b = a;\n+        assert!(*a == 5);\n+        assert!(*b == 5);\n     }\n \n     #[test]\n     fn tls() {\n         use local_data;\n-        do run_in_newsched_task() {\n-            local_data_key!(key: @~str)\n-            local_data::set(key, @~\"data\");\n-            assert!(*local_data::get(key, |k| k.map(|k| *k)).unwrap() == ~\"data\");\n-            local_data_key!(key2: @~str)\n-            local_data::set(key2, @~\"data\");\n-            assert!(*local_data::get(key2, |k| k.map(|k| *k)).unwrap() == ~\"data\");\n-        }\n+        local_data_key!(key: @~str)\n+        local_data::set(key, @~\"data\");\n+        assert!(*local_data::get(key, |k| k.map(|k| *k)).unwrap() == ~\"data\");\n+        local_data_key!(key2: @~str)\n+        local_data::set(key2, @~\"data\");\n+        assert!(*local_data::get(key2, |k| k.map(|k| *k)).unwrap() == ~\"data\");\n     }\n \n     #[test]\n     fn unwind() {\n-        do run_in_newsched_task() {\n-            let result = spawntask_try(proc()());\n-            rtdebug!(\"trying first assert\");\n-            assert!(result.is_ok());\n-            let result = spawntask_try(proc() fail!());\n-            rtdebug!(\"trying second assert\");\n-            assert!(result.is_err());\n-        }\n+        let result = task::try(proc()());\n+        rtdebug!(\"trying first assert\");\n+        assert!(result.is_ok());\n+        let result = task::try::<()>(proc() fail!());\n+        rtdebug!(\"trying second assert\");\n+        assert!(result.is_err());\n     }\n \n     #[test]\n     fn rng() {\n-        do run_in_uv_task() {\n-            use rand::{rng, Rng};\n-            let mut r = rng();\n-            let _ = r.next_u32();\n-        }\n+        use rand::{rng, Rng};\n+        let mut r = rng();\n+        let _ = r.next_u32();\n     }\n \n     #[test]\n     fn logging() {\n-        do run_in_uv_task() {\n-            info!(\"here i am. logging in a newsched task\");\n-        }\n+        info!(\"here i am. logging in a newsched task\");\n     }\n \n     #[test]\n     fn comm_stream() {\n-        do run_in_newsched_task() {\n-            let (port, chan) = Chan::new();\n-            chan.send(10);\n-            assert!(port.recv() == 10);\n-        }\n+        let (port, chan) = Chan::new();\n+        chan.send(10);\n+        assert!(port.recv() == 10);\n     }\n \n     #[test]\n     fn comm_shared_chan() {\n-        do run_in_newsched_task() {\n-            let (port, chan) = SharedChan::new();\n-            chan.send(10);\n-            assert!(port.recv() == 10);\n-        }\n+        let (port, chan) = SharedChan::new();\n+        chan.send(10);\n+        assert!(port.recv() == 10);\n     }\n \n     #[test]\n     fn heap_cycles() {\n         use option::{Option, Some, None};\n \n-        do run_in_newsched_task {\n-            struct List {\n-                next: Option<@mut List>,\n-            }\n+        struct List {\n+            next: Option<@mut List>,\n+        }\n \n-            let a = @mut List { next: None };\n-            let b = @mut List { next: Some(a) };\n+        let a = @mut List { next: None };\n+        let b = @mut List { next: Some(a) };\n \n-            a.next = Some(b);\n-        }\n+        a.next = Some(b);\n     }\n \n     #[test]\n     #[should_fail]\n-    fn test_begin_unwind() { begin_unwind(\"cause\", file!(), line!()) }\n+    fn test_begin_unwind() {\n+        use rt::unwind::begin_unwind;\n+        begin_unwind(\"cause\", file!(), line!())\n+    }\n+\n+    // Task blocking tests\n+\n+    #[test]\n+    fn block_and_wake() {\n+        let task = ~Task::new();\n+        let mut task = BlockedTask::block(task).wake().unwrap();\n+        task.destroyed = true;\n+    }\n }"}, {"sha": "2b48b396c99e9fe5439bc1169b27e0db1b6c10be", "filename": "src/libstd/rt/test.rs", "status": "removed", "additions": 0, "deletions": 440, "changes": 440, "blob_url": "https://github.com/rust-lang/rust/blob/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=d975060de6c944ca12ce5205fbc9fc7726948ae1", "patch": "@@ -1,440 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n-\n-use clone::Clone;\n-use container::Container;\n-use iter::{Iterator, range};\n-use option::{Some, None};\n-use os;\n-use path::GenericPath;\n-use path::Path;\n-use rand::Rng;\n-use rand;\n-use result::{Result, Ok, Err};\n-use rt::basic;\n-use rt::deque::BufferPool;\n-use comm::Chan;\n-use rt::new_event_loop;\n-use rt::sched::Scheduler;\n-use rt::sleeper_list::SleeperList;\n-use rt::task::Task;\n-use rt::thread::Thread;\n-use task::TaskResult;\n-use unstable::{run_in_bare_thread};\n-use vec;\n-use vec::{OwnedVector, MutableVector, ImmutableVector};\n-\n-pub fn new_test_uv_sched() -> Scheduler {\n-\n-    let mut pool = BufferPool::new();\n-    let (worker, stealer) = pool.deque();\n-\n-    let mut sched = Scheduler::new(new_event_loop(),\n-                                   worker,\n-                                   ~[stealer],\n-                                   SleeperList::new());\n-\n-    // Don't wait for the Shutdown message\n-    sched.no_sleep = true;\n-    return sched;\n-\n-}\n-\n-pub fn new_test_sched() -> Scheduler {\n-    let mut pool = BufferPool::new();\n-    let (worker, stealer) = pool.deque();\n-\n-    let mut sched = Scheduler::new(basic::event_loop(),\n-                                   worker,\n-                                   ~[stealer],\n-                                   SleeperList::new());\n-\n-    // Don't wait for the Shutdown message\n-    sched.no_sleep = true;\n-    return sched;\n-}\n-\n-pub fn run_in_uv_task(f: proc()) {\n-    do run_in_bare_thread {\n-        run_in_uv_task_core(f);\n-    }\n-}\n-\n-pub fn run_in_newsched_task(f: proc()) {\n-    do run_in_bare_thread {\n-        run_in_newsched_task_core(f);\n-    }\n-}\n-\n-pub fn run_in_uv_task_core(f: proc()) {\n-\n-    use rt::sched::Shutdown;\n-\n-    let mut sched = ~new_test_uv_sched();\n-    let exit_handle = sched.make_handle();\n-\n-    let on_exit: proc(TaskResult) = proc(exit_status: TaskResult) {\n-        let mut exit_handle = exit_handle;\n-        exit_handle.send(Shutdown);\n-        rtassert!(exit_status.is_ok());\n-    };\n-    let mut task = ~Task::new_root(&mut sched.stack_pool, None, f);\n-    task.death.on_exit = Some(on_exit);\n-\n-    sched.bootstrap(task);\n-}\n-\n-pub fn run_in_newsched_task_core(f: proc()) {\n-    use rt::sched::Shutdown;\n-\n-    let mut sched = ~new_test_sched();\n-    let exit_handle = sched.make_handle();\n-\n-    let on_exit: proc(TaskResult) = proc(exit_status: TaskResult) {\n-        let mut exit_handle = exit_handle;\n-        exit_handle.send(Shutdown);\n-        rtassert!(exit_status.is_ok());\n-    };\n-    let mut task = ~Task::new_root(&mut sched.stack_pool, None, f);\n-    task.death.on_exit = Some(on_exit);\n-\n-    sched.bootstrap(task);\n-}\n-\n-#[cfg(target_os=\"macos\")]\n-#[allow(non_camel_case_types)]\n-mod darwin_fd_limit {\n-    /*!\n-     * darwin_fd_limit exists to work around an issue where launchctl on Mac OS X defaults the\n-     * rlimit maxfiles to 256/unlimited. The default soft limit of 256 ends up being far too low\n-     * for our multithreaded scheduler testing, depending on the number of cores available.\n-     *\n-     * This fixes issue #7772.\n-     */\n-\n-    use libc;\n-    type rlim_t = libc::uint64_t;\n-    struct rlimit {\n-        rlim_cur: rlim_t,\n-        rlim_max: rlim_t\n-    }\n-    #[nolink]\n-    extern {\n-        // name probably doesn't need to be mut, but the C function doesn't specify const\n-        fn sysctl(name: *mut libc::c_int, namelen: libc::c_uint,\n-                  oldp: *mut libc::c_void, oldlenp: *mut libc::size_t,\n-                  newp: *mut libc::c_void, newlen: libc::size_t) -> libc::c_int;\n-        fn getrlimit(resource: libc::c_int, rlp: *mut rlimit) -> libc::c_int;\n-        fn setrlimit(resource: libc::c_int, rlp: *rlimit) -> libc::c_int;\n-    }\n-    static CTL_KERN: libc::c_int = 1;\n-    static KERN_MAXFILESPERPROC: libc::c_int = 29;\n-    static RLIMIT_NOFILE: libc::c_int = 8;\n-\n-    pub unsafe fn raise_fd_limit() {\n-        // The strategy here is to fetch the current resource limits, read the kern.maxfilesperproc\n-        // sysctl value, and bump the soft resource limit for maxfiles up to the sysctl value.\n-        use ptr::{to_unsafe_ptr, to_mut_unsafe_ptr, mut_null};\n-        use mem::size_of_val;\n-        use os::last_os_error;\n-\n-        // Fetch the kern.maxfilesperproc value\n-        let mut mib: [libc::c_int, ..2] = [CTL_KERN, KERN_MAXFILESPERPROC];\n-        let mut maxfiles: libc::c_int = 0;\n-        let mut size: libc::size_t = size_of_val(&maxfiles) as libc::size_t;\n-        if sysctl(to_mut_unsafe_ptr(&mut mib[0]), 2,\n-                  to_mut_unsafe_ptr(&mut maxfiles) as *mut libc::c_void,\n-                  to_mut_unsafe_ptr(&mut size),\n-                  mut_null(), 0) != 0 {\n-            let err = last_os_error();\n-            error!(\"raise_fd_limit: error calling sysctl: {}\", err);\n-            return;\n-        }\n-\n-        // Fetch the current resource limits\n-        let mut rlim = rlimit{rlim_cur: 0, rlim_max: 0};\n-        if getrlimit(RLIMIT_NOFILE, to_mut_unsafe_ptr(&mut rlim)) != 0 {\n-            let err = last_os_error();\n-            error!(\"raise_fd_limit: error calling getrlimit: {}\", err);\n-            return;\n-        }\n-\n-        // Bump the soft limit to the smaller of kern.maxfilesperproc and the hard limit\n-        rlim.rlim_cur = ::cmp::min(maxfiles as rlim_t, rlim.rlim_max);\n-\n-        // Set our newly-increased resource limit\n-        if setrlimit(RLIMIT_NOFILE, to_unsafe_ptr(&rlim)) != 0 {\n-            let err = last_os_error();\n-            error!(\"raise_fd_limit: error calling setrlimit: {}\", err);\n-            return;\n-        }\n-    }\n-}\n-\n-#[cfg(not(target_os=\"macos\"))]\n-mod darwin_fd_limit {\n-    pub unsafe fn raise_fd_limit() {}\n-}\n-\n-#[doc(hidden)]\n-pub fn prepare_for_lots_of_tests() {\n-    // Bump the fd limit on OS X. See darwin_fd_limit for an explanation.\n-    unsafe { darwin_fd_limit::raise_fd_limit() }\n-}\n-\n-/// Create more than one scheduler and run a function in a task\n-/// in one of the schedulers. The schedulers will stay alive\n-/// until the function `f` returns.\n-pub fn run_in_mt_newsched_task(f: proc()) {\n-    use os;\n-    use from_str::FromStr;\n-    use rt::sched::Shutdown;\n-    use rt::util;\n-\n-    // see comment in other function (raising fd limits)\n-    prepare_for_lots_of_tests();\n-\n-    do run_in_bare_thread {\n-        let nthreads = match os::getenv(\"RUST_RT_TEST_THREADS\") {\n-            Some(nstr) => FromStr::from_str(nstr).unwrap(),\n-            None => {\n-                if util::limit_thread_creation_due_to_osx_and_valgrind() {\n-                    1\n-                } else {\n-                    // Using more threads than cores in test code\n-                    // to force the OS to preempt them frequently.\n-                    // Assuming that this help stress test concurrent types.\n-                    util::num_cpus() * 2\n-                }\n-            }\n-        };\n-\n-        let sleepers = SleeperList::new();\n-\n-        let mut handles = ~[];\n-        let mut scheds = ~[];\n-\n-        let mut pool = BufferPool::<~Task>::new();\n-        let workers = range(0, nthreads).map(|_| pool.deque());\n-        let (workers, stealers) = vec::unzip(workers);\n-\n-        for worker in workers.move_iter() {\n-            let loop_ = new_event_loop();\n-            let mut sched = ~Scheduler::new(loop_,\n-                                            worker,\n-                                            stealers.clone(),\n-                                            sleepers.clone());\n-            let handle = sched.make_handle();\n-\n-            handles.push(handle);\n-            scheds.push(sched);\n-        }\n-\n-        let handles = handles;  // Work around not being able to capture mut\n-        let on_exit: proc(TaskResult) = proc(exit_status: TaskResult) {\n-            // Tell schedulers to exit\n-            let mut handles = handles;\n-            for handle in handles.mut_iter() {\n-                handle.send(Shutdown);\n-            }\n-\n-            rtassert!(exit_status.is_ok());\n-        };\n-        let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool,\n-                                            None,\n-                                            f);\n-        main_task.death.on_exit = Some(on_exit);\n-\n-        let mut threads = ~[];\n-\n-        let main_thread = {\n-            let sched = scheds.pop();\n-            let main_task = main_task;\n-            do Thread::start {\n-                sched.bootstrap(main_task);\n-            }\n-        };\n-        threads.push(main_thread);\n-\n-        while !scheds.is_empty() {\n-            let mut sched = scheds.pop();\n-            let bootstrap_task = ~do Task::new_root(&mut sched.stack_pool, None) || {\n-                rtdebug!(\"bootstrapping non-primary scheduler\");\n-            };\n-            let sched = sched;\n-            let thread = do Thread::start {\n-                sched.bootstrap(bootstrap_task);\n-            };\n-\n-            threads.push(thread);\n-        }\n-\n-        // Wait for schedulers\n-        for thread in threads.move_iter() {\n-            thread.join();\n-        }\n-    }\n-\n-}\n-\n-/// Test tasks will abort on failure instead of unwinding\n-pub fn spawntask(f: proc()) {\n-    Scheduler::run_task(Task::build_child(None, f));\n-}\n-\n-/// Create a new task and run it right now. Aborts on failure\n-pub fn spawntask_later(f: proc()) {\n-    Scheduler::run_task_later(Task::build_child(None, f));\n-}\n-\n-pub fn spawntask_random(f: proc()) {\n-    use rand::{Rand, rng};\n-\n-    let mut rng = rng();\n-    let run_now: bool = Rand::rand(&mut rng);\n-\n-    if run_now {\n-        spawntask(f)\n-    } else {\n-        spawntask_later(f)\n-    }\n-}\n-\n-pub fn spawntask_try(f: proc()) -> Result<(),()> {\n-\n-    let (port, chan) = Chan::new();\n-    let on_exit: proc(TaskResult) = proc(exit_status) {\n-        chan.send(exit_status)\n-    };\n-\n-    let mut new_task = Task::build_root(None, f);\n-    new_task.death.on_exit = Some(on_exit);\n-\n-    Scheduler::run_task(new_task);\n-\n-    let exit_status = port.recv();\n-    if exit_status.is_ok() { Ok(()) } else { Err(()) }\n-\n-}\n-\n-/// Spawn a new task in a new scheduler and return a thread handle.\n-pub fn spawntask_thread(f: proc()) -> Thread<()> {\n-    let thread = do Thread::start {\n-        run_in_newsched_task_core(f);\n-    };\n-\n-    return thread;\n-}\n-\n-/// Get a ~Task for testing purposes other than actually scheduling it.\n-pub fn with_test_task(blk: proc(~Task) -> ~Task) {\n-    do run_in_bare_thread {\n-        let mut sched = ~new_test_sched();\n-        let task = blk(~Task::new_root(&mut sched.stack_pool,\n-                                       None,\n-                                       proc() {}));\n-        cleanup_task(task);\n-    }\n-}\n-\n-/// Use to cleanup tasks created for testing but not \"run\".\n-pub fn cleanup_task(mut task: ~Task) {\n-    task.destroyed = true;\n-}\n-\n-/// Get a port number, starting at 9600, for use in tests\n-pub fn next_test_port() -> u16 {\n-    use unstable::mutex::{Mutex, MUTEX_INIT};\n-    static mut lock: Mutex = MUTEX_INIT;\n-    static mut next_offset: u16 = 0;\n-    unsafe {\n-        let base = base_port();\n-        lock.lock();\n-        let ret = base + next_offset;\n-        next_offset += 1;\n-        lock.unlock();\n-        return ret;\n-    }\n-}\n-\n-/// Get a temporary path which could be the location of a unix socket\n-pub fn next_test_unix() -> Path {\n-    if cfg!(unix) {\n-        os::tmpdir().join(rand::task_rng().gen_ascii_str(20))\n-    } else {\n-        Path::new(r\"\\\\.\\pipe\\\" + rand::task_rng().gen_ascii_str(20))\n-    }\n-}\n-\n-/// Get a unique IPv4 localhost:port pair starting at 9600\n-pub fn next_test_ip4() -> SocketAddr {\n-    SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: next_test_port() }\n-}\n-\n-/// Get a unique IPv6 localhost:port pair starting at 9600\n-pub fn next_test_ip6() -> SocketAddr {\n-    SocketAddr { ip: Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1), port: next_test_port() }\n-}\n-\n-/*\n-XXX: Welcome to MegaHack City.\n-\n-The bots run multiple builds at the same time, and these builds\n-all want to use ports. This function figures out which workspace\n-it is running in and assigns a port range based on it.\n-*/\n-fn base_port() -> u16 {\n-    use os;\n-    use str::StrSlice;\n-    use vec::ImmutableVector;\n-\n-    let base = 9600u16;\n-    let range = 1000u16;\n-\n-    let bases = [\n-        (\"32-opt\", base + range * 1),\n-        (\"32-noopt\", base + range * 2),\n-        (\"64-opt\", base + range * 3),\n-        (\"64-noopt\", base + range * 4),\n-        (\"64-opt-vg\", base + range * 5),\n-        (\"all-opt\", base + range * 6),\n-        (\"snap3\", base + range * 7),\n-        (\"dist\", base + range * 8)\n-    ];\n-\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let path = os::getcwd();\n-    let path_s = path.as_str().unwrap();\n-\n-    let mut final_base = base;\n-\n-    for &(dir, base) in bases.iter() {\n-        if path_s.contains(dir) {\n-            final_base = base;\n-            break;\n-        }\n-    }\n-\n-    return final_base;\n-}\n-\n-/// Get a constant that represents the number of times to repeat\n-/// stress tests. Default 1.\n-pub fn stress_factor() -> uint {\n-    use os::getenv;\n-    use from_str::from_str;\n-\n-    match getenv(\"RUST_RT_STRESS\") {\n-        Some(val) => from_str::<uint>(val).unwrap(),\n-        None => 1\n-    }\n-}"}, {"sha": "f4f4aaa276524231e34a3efdfe95c6bc11010fa4", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -33,17 +33,17 @@ pub struct Thread<T> {\n     priv packet: ~Option<T>,\n }\n \n-static DEFAULT_STACK_SIZE: libc::size_t = 1024 * 1024;\n+static DEFAULT_STACK_SIZE: uint = 1024 * 1024;\n \n // This is the starting point of rust os threads. The first thing we do\n // is make sure that we don't trigger __morestack (also why this has a\n // no_split_stack annotation), and then we extract the main function\n // and invoke it.\n #[no_split_stack]\n extern fn thread_start(main: *libc::c_void) -> imp::rust_thread_return {\n-    use rt::context;\n+    use unstable::stack;\n     unsafe {\n-        context::record_stack_bounds(0, uint::max_value);\n+        stack::record_stack_bounds(0, uint::max_value);\n         let f: ~proc() = cast::transmute(main);\n         (*f)();\n         cast::transmute(0 as imp::rust_thread_return)\n@@ -69,6 +69,12 @@ impl Thread<()> {\n     /// called, when the `Thread` falls out of scope its destructor will block\n     /// waiting for the OS thread.\n     pub fn start<T: Send>(main: proc() -> T) -> Thread<T> {\n+        Thread::start_stack(DEFAULT_STACK_SIZE, main)\n+    }\n+\n+    /// Performs the same functionality as `start`, but specifies an explicit\n+    /// stack size for the new thread.\n+    pub fn start_stack<T: Send>(stack: uint, main: proc() -> T) -> Thread<T> {\n \n         // We need the address of the packet to fill in to be stable so when\n         // `main` fills it in it's still valid, so allocate an extra ~ box to do\n@@ -78,7 +84,7 @@ impl Thread<()> {\n             *cast::transmute::<&~Option<T>, **mut Option<T>>(&packet)\n         };\n         let main: proc() = proc() unsafe { *packet2 = Some(main()); };\n-        let native = unsafe { imp::create(~main) };\n+        let native = unsafe { imp::create(stack, ~main) };\n \n         Thread {\n             native: native,\n@@ -94,8 +100,14 @@ impl Thread<()> {\n     /// systems. Note that platforms may not keep the main program alive even if\n     /// there are detached thread still running around.\n     pub fn spawn(main: proc()) {\n+        Thread::spawn_stack(DEFAULT_STACK_SIZE, main)\n+    }\n+\n+    /// Performs the same functionality as `spawn`, but explicitly specifies a\n+    /// stack size for the new thread.\n+    pub fn spawn_stack(stack: uint, main: proc()) {\n         unsafe {\n-            let handle = imp::create(~main);\n+            let handle = imp::create(stack, ~main);\n             imp::detach(handle);\n         }\n     }\n@@ -132,8 +144,6 @@ impl<T: Send> Drop for Thread<T> {\n \n #[cfg(windows)]\n mod imp {\n-    use super::DEFAULT_STACK_SIZE;\n-\n     use cast;\n     use libc;\n     use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, SIZE_T, BOOL,\n@@ -143,9 +153,9 @@ mod imp {\n     pub type rust_thread = HANDLE;\n     pub type rust_thread_return = DWORD;\n \n-    pub unsafe fn create(p: ~proc()) -> rust_thread {\n+    pub unsafe fn create(stack: uint, p: ~proc()) -> rust_thread {\n         let arg: *mut libc::c_void = cast::transmute(p);\n-        CreateThread(ptr::mut_null(), DEFAULT_STACK_SIZE, super::thread_start,\n+        CreateThread(ptr::mut_null(), stack as libc::size_t, super::thread_start,\n                      arg, 0, ptr::mut_null())\n     }\n \n@@ -183,17 +193,17 @@ mod imp {\n     use libc::consts::os::posix01::PTHREAD_CREATE_JOINABLE;\n     use libc;\n     use ptr;\n-    use super::DEFAULT_STACK_SIZE;\n     use unstable::intrinsics;\n \n     pub type rust_thread = libc::pthread_t;\n     pub type rust_thread_return = *libc::c_void;\n \n-    pub unsafe fn create(p: ~proc()) -> rust_thread {\n+    pub unsafe fn create(stack: uint, p: ~proc()) -> rust_thread {\n         let mut native: libc::pthread_t = intrinsics::uninit();\n         let mut attr: libc::pthread_attr_t = intrinsics::uninit();\n         assert_eq!(pthread_attr_init(&mut attr), 0);\n-        assert_eq!(pthread_attr_setstacksize(&mut attr, DEFAULT_STACK_SIZE), 0);\n+        assert_eq!(pthread_attr_setstacksize(&mut attr,\n+                                             stack as libc::size_t), 0);\n         assert_eq!(pthread_attr_setdetachstate(&mut attr,\n                                                PTHREAD_CREATE_JOINABLE), 0);\n "}, {"sha": "5e867bcdfbac6655649f871650f2d777365ea082", "filename": "src/libstd/rt/tube.rs", "status": "removed", "additions": 0, "deletions": 170, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibstd%2Frt%2Ftube.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibstd%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftube.rs?ref=d975060de6c944ca12ce5205fbc9fc7726948ae1", "patch": "@@ -1,170 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A very simple unsynchronized channel type for sending buffered data from\n-//! scheduler context to task context.\n-//!\n-//! XXX: This would be safer to use if split into two types like Port/Chan\n-\n-use option::*;\n-use clone::Clone;\n-use super::rc::RC;\n-use rt::sched::Scheduler;\n-use rt::kill::BlockedTask;\n-use rt::local::Local;\n-use vec::OwnedVector;\n-use container::Container;\n-\n-struct TubeState<T> {\n-    blocked_task: Option<BlockedTask>,\n-    buf: ~[T]\n-}\n-\n-pub struct Tube<T> {\n-    priv p: RC<TubeState<T>>\n-}\n-\n-impl<T> Tube<T> {\n-    pub fn new() -> Tube<T> {\n-        Tube {\n-            p: RC::new(TubeState {\n-                blocked_task: None,\n-                buf: ~[]\n-            })\n-        }\n-    }\n-\n-    pub fn send(&mut self, val: T) {\n-        rtdebug!(\"tube send\");\n-        unsafe {\n-            let state = self.p.unsafe_borrow_mut();\n-            (*state).buf.push(val);\n-\n-            if (*state).blocked_task.is_some() {\n-                // There's a waiting task. Wake it up\n-                rtdebug!(\"waking blocked tube\");\n-                let task = (*state).blocked_task.take_unwrap();\n-                let sched: ~Scheduler = Local::take();\n-                sched.resume_blocked_task_immediately(task);\n-            }\n-        }\n-    }\n-\n-    pub fn recv(&mut self) -> T {\n-        unsafe {\n-            let state = self.p.unsafe_borrow_mut();\n-            if !(*state).buf.is_empty() {\n-                return (*state).buf.shift();\n-            } else {\n-                // Block and wait for the next message\n-                rtdebug!(\"blocking on tube recv\");\n-                assert!(self.p.refcount() > 1); // There better be somebody to wake us up\n-                assert!((*state).blocked_task.is_none());\n-                let sched: ~Scheduler = Local::take();\n-                sched.deschedule_running_task_and_then(|_, task| {\n-                    (*state).blocked_task = Some(task);\n-                });\n-                rtdebug!(\"waking after tube recv\");\n-                let buf = &mut (*state).buf;\n-                assert!(!buf.is_empty());\n-                return buf.shift();\n-            }\n-        }\n-    }\n-}\n-\n-impl<T> Clone for Tube<T> {\n-    fn clone(&self) -> Tube<T> {\n-        Tube { p: self.p.clone() }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use rt::test::*;\n-    use rt::rtio::EventLoop;\n-    use rt::sched::Scheduler;\n-    use rt::local::Local;\n-    use super::*;\n-    use prelude::*;\n-\n-    #[test]\n-    fn simple_test() {\n-        do run_in_newsched_task {\n-            let mut tube: Tube<int> = Tube::new();\n-            let mut tube_clone = Some(tube.clone());\n-            let sched: ~Scheduler = Local::take();\n-            sched.deschedule_running_task_and_then(|sched, task| {\n-                let mut tube_clone = tube_clone.take_unwrap();\n-                tube_clone.send(1);\n-                sched.enqueue_blocked_task(task);\n-            });\n-\n-            assert!(tube.recv() == 1);\n-        }\n-    }\n-\n-    #[test]\n-    fn blocking_test() {\n-        do run_in_newsched_task {\n-            let mut tube: Tube<int> = Tube::new();\n-            let mut tube_clone = Some(tube.clone());\n-            let sched: ~Scheduler = Local::take();\n-            sched.deschedule_running_task_and_then(|sched, task| {\n-                let tube_clone = tube_clone.take_unwrap();\n-                do sched.event_loop.callback {\n-                    let mut tube_clone = tube_clone;\n-                    // The task should be blocked on this now and\n-                    // sending will wake it up.\n-                    tube_clone.send(1);\n-                }\n-                sched.enqueue_blocked_task(task);\n-            });\n-\n-            assert!(tube.recv() == 1);\n-        }\n-    }\n-\n-    #[test]\n-    fn many_blocking_test() {\n-        static MAX: int = 100;\n-\n-        do run_in_newsched_task {\n-            let mut tube: Tube<int> = Tube::new();\n-            let mut tube_clone = Some(tube.clone());\n-            let sched: ~Scheduler = Local::take();\n-            sched.deschedule_running_task_and_then(|sched, task| {\n-                callback_send(tube_clone.take_unwrap(), 0);\n-\n-                fn callback_send(tube: Tube<int>, i: int) {\n-                    if i == 100 {\n-                        return\n-                    }\n-\n-                    let mut sched = Local::borrow(None::<Scheduler>);\n-                    do sched.get().event_loop.callback {\n-                        let mut tube = tube;\n-                        // The task should be blocked on this now and\n-                        // sending will wake it up.\n-                        tube.send(i);\n-                        callback_send(tube, i + 1);\n-                    }\n-                }\n-\n-                sched.enqueue_blocked_task(task);\n-            });\n-\n-            for i in range(0, MAX) {\n-                let j = tube.recv();\n-                assert!(j == i);\n-            }\n-        }\n-    }\n-}"}, {"sha": "9706dbae4c61b8f095735090fa5a3d78bc69dae6", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 185, "deletions": 85, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n // Implementation of Rust stack unwinding\n //\n-// For background on exception handling and stack unwinding please see \"Exception Handling in LLVM\"\n-// (llvm.org/docs/ExceptionHandling.html) and documents linked from it.\n+// For background on exception handling and stack unwinding please see\n+// \"Exception Handling in LLVM\" (llvm.org/docs/ExceptionHandling.html) and\n+// documents linked from it.\n // These are also good reads:\n //     http://theofilos.cs.columbia.edu/blog/2013/09/22/base_abi/\n //     http://monoinfinito.wordpress.com/series/exception-handling-in-c/\n@@ -21,41 +21,55 @@\n // ~~~ A brief summary ~~~\n // Exception handling happens in two phases: a search phase and a cleanup phase.\n //\n-// In both phases the unwinder walks stack frames from top to bottom using information from\n-// the stack frame unwind sections of the current process's modules (\"module\" here refers to\n-// an OS module, i.e. an executable or a dynamic library).\n+// In both phases the unwinder walks stack frames from top to bottom using\n+// information from the stack frame unwind sections of the current process's\n+// modules (\"module\" here refers to an OS module, i.e. an executable or a\n+// dynamic library).\n //\n-// For each stack frame, it invokes the associated \"personality routine\", whose address is also\n-// stored in the unwind info section.\n+// For each stack frame, it invokes the associated \"personality routine\", whose\n+// address is also stored in the unwind info section.\n //\n-// In the search phase, the job of a personality routine is to examine exception object being\n-// thrown, and to decide whether it should be caught at that stack frame.  Once the handler frame\n-// has been identified, cleanup phase begins.\n+// In the search phase, the job of a personality routine is to examine exception\n+// object being thrown, and to decide whether it should be caught at that stack\n+// frame.  Once the handler frame has been identified, cleanup phase begins.\n //\n-// In the cleanup phase, personality routines invoke cleanup code associated with their\n-// stack frames (i.e. destructors).  Once stack has been unwound down to the handler frame level,\n-// unwinding stops and the last personality routine transfers control to its' catch block.\n+// In the cleanup phase, personality routines invoke cleanup code associated\n+// with their stack frames (i.e. destructors).  Once stack has been unwound down\n+// to the handler frame level, unwinding stops and the last personality routine\n+// transfers control to its' catch block.\n //\n // ~~~ Frame unwind info registration ~~~\n-// Each module has its' own frame unwind info section (usually \".eh_frame\"), and unwinder needs\n-// to know about all of them in order for unwinding to be able to cross module boundaries.\n+// Each module has its' own frame unwind info section (usually \".eh_frame\"), and\n+// unwinder needs to know about all of them in order for unwinding to be able to\n+// cross module boundaries.\n //\n-// On some platforms, like Linux, this is achieved by dynamically enumerating currently loaded\n-// modules via the dl_iterate_phdr() API and finding all .eh_frame sections.\n+// On some platforms, like Linux, this is achieved by dynamically enumerating\n+// currently loaded modules via the dl_iterate_phdr() API and finding all\n+// .eh_frame sections.\n //\n-// Others, like Windows, require modules to actively register their unwind info sections by calling\n-// __register_frame_info() API at startup.\n-// In the latter case it is essential that there is only one copy of the unwinder runtime\n-// in the process.  This is usually achieved by linking to the dynamic version of the unwind\n-// runtime.\n+// Others, like Windows, require modules to actively register their unwind info\n+// sections by calling __register_frame_info() API at startup.  In the latter\n+// case it is essential that there is only one copy of the unwinder runtime in\n+// the process.  This is usually achieved by linking to the dynamic version of\n+// the unwind runtime.\n //\n // Currently Rust uses unwind runtime provided by libgcc.\n \n-use prelude::*;\n-use cast::transmute;\n-use task::TaskResult;\n+use any::{Any, AnyRefExt};\n+use c_str::CString;\n+use cast;\n+use kinds::Send;\n+use libc::{c_char, size_t};\n use libc::{c_void, c_int};\n-use self::libunwind::*;\n+use option::{Some, None, Option};\n+use result::{Err, Ok};\n+use rt::local::Local;\n+use rt::task::Task;\n+use str::Str;\n+use task::TaskResult;\n+use unstable::intrinsics;\n+\n+use uw = self::libunwind;\n \n mod libunwind {\n     //! Unwind library interface\n@@ -110,45 +124,53 @@ mod libunwind {\n }\n \n pub struct Unwinder {\n-    unwinding: bool,\n-    cause: Option<~Any>\n+    priv unwinding: bool,\n+    priv cause: Option<~Any>\n }\n \n impl Unwinder {\n+    pub fn new() -> Unwinder {\n+        Unwinder {\n+            unwinding: false,\n+            cause: None,\n+        }\n+    }\n+\n+    pub fn unwinding(&self) -> bool {\n+        self.unwinding\n+    }\n \n     pub fn try(&mut self, f: ||) {\n         use unstable::raw::Closure;\n \n         unsafe {\n-            let closure: Closure = transmute(f);\n-            let code = transmute(closure.code);\n-            let env = transmute(closure.env);\n-\n-            let ep = rust_try(try_fn, code, env);\n+            let closure: Closure = cast::transmute(f);\n+            let ep = rust_try(try_fn, closure.code as *c_void,\n+                              closure.env as *c_void);\n             if !ep.is_null() {\n                 rtdebug!(\"Caught {}\", (*ep).exception_class);\n-                _Unwind_DeleteException(ep);\n+                uw::_Unwind_DeleteException(ep);\n             }\n         }\n \n         extern fn try_fn(code: *c_void, env: *c_void) {\n             unsafe {\n-                let closure: Closure = Closure {\n-                    code: transmute(code),\n-                    env: transmute(env),\n-                };\n-                let closure: || = transmute(closure);\n+                let closure: || = cast::transmute(Closure {\n+                    code: code as *(),\n+                    env: env as *(),\n+                });\n                 closure();\n             }\n         }\n \n         extern {\n             // Rust's try-catch\n             // When f(...) returns normally, the return value is null.\n-            // When f(...) throws, the return value is a pointer to the caught exception object.\n+            // When f(...) throws, the return value is a pointer to the caught\n+            // exception object.\n             fn rust_try(f: extern \"C\" fn(*c_void, *c_void),\n                         code: *c_void,\n-                        data: *c_void) -> *_Unwind_Exception;\n+                        data: *c_void) -> *uw::_Unwind_Exception;\n         }\n     }\n \n@@ -159,21 +181,21 @@ impl Unwinder {\n         self.cause = Some(cause);\n \n         unsafe {\n-            let exception = ~_Unwind_Exception {\n+            let exception = ~uw::_Unwind_Exception {\n                 exception_class: rust_exception_class(),\n                 exception_cleanup: exception_cleanup,\n                 private_1: 0,\n                 private_2: 0\n             };\n-            let error = _Unwind_RaiseException(transmute(exception));\n+            let error = uw::_Unwind_RaiseException(cast::transmute(exception));\n             rtabort!(\"Could not unwind stack, error = {}\", error as int)\n         }\n \n-        extern \"C\" fn exception_cleanup(_unwind_code: _Unwind_Reason_Code,\n-                                        exception: *_Unwind_Exception) {\n+        extern \"C\" fn exception_cleanup(_unwind_code: uw::_Unwind_Reason_Code,\n+                                        exception: *uw::_Unwind_Exception) {\n             rtdebug!(\"exception_cleanup()\");\n             unsafe {\n-                let _: ~_Unwind_Exception = transmute(exception);\n+                let _: ~uw::_Unwind_Exception = cast::transmute(exception);\n             }\n         }\n     }\n@@ -189,68 +211,146 @@ impl Unwinder {\n \n // Rust's exception class identifier.  This is used by personality routines to\n // determine whether the exception was thrown by their own runtime.\n-fn rust_exception_class() -> _Unwind_Exception_Class {\n-    let bytes = bytes!(\"MOZ\\0RUST\"); // vendor, language\n-    unsafe {\n-        let ptr: *_Unwind_Exception_Class = transmute(bytes.as_ptr());\n-        *ptr\n-    }\n+fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n+    // M O Z \\0  R U S T -- vendor, language\n+    0x4d4f5a_00_52555354\n }\n \n-\n-// We could implement our personality routine in pure Rust, however exception info decoding\n-// is tedious.  More importantly, personality routines have to handle various platform\n-// quirks, which are not fun to maintain.  For this reason, we attempt to reuse personality\n-// routine of the C language: __gcc_personality_v0.\n+// We could implement our personality routine in pure Rust, however exception\n+// info decoding is tedious.  More importantly, personality routines have to\n+// handle various platform quirks, which are not fun to maintain.  For this\n+// reason, we attempt to reuse personality routine of the C language:\n+// __gcc_personality_v0.\n //\n-// Since C does not support exception catching, __gcc_personality_v0 simply always\n-// returns _URC_CONTINUE_UNWIND in search phase, and always returns _URC_INSTALL_CONTEXT\n-// (i.e. \"invoke cleanup code\") in cleanup phase.\n+// Since C does not support exception catching, __gcc_personality_v0 simply\n+// always returns _URC_CONTINUE_UNWIND in search phase, and always returns\n+// _URC_INSTALL_CONTEXT (i.e. \"invoke cleanup code\") in cleanup phase.\n //\n-// This is pretty close to Rust's exception handling approach, except that Rust does have\n-// a single \"catch-all\" handler at the bottom of each task's stack.\n+// This is pretty close to Rust's exception handling approach, except that Rust\n+// does have a single \"catch-all\" handler at the bottom of each task's stack.\n // So we have two versions:\n-// - rust_eh_personality, used by all cleanup landing pads, which never catches, so\n-//   the behavior of __gcc_personality_v0 is perfectly adequate there, and\n-// - rust_eh_personality_catch, used only by rust_try(), which always catches.  This is\n-//   achieved by overriding the return value in search phase to always say \"catch!\".\n+// - rust_eh_personality, used by all cleanup landing pads, which never catches,\n+//   so the behavior of __gcc_personality_v0 is perfectly adequate there, and\n+// - rust_eh_personality_catch, used only by rust_try(), which always catches.\n+//   This is achieved by overriding the return value in search phase to always\n+//   say \"catch!\".\n \n extern \"C\" {\n     fn __gcc_personality_v0(version: c_int,\n-                            actions: _Unwind_Action,\n-                            exception_class: _Unwind_Exception_Class,\n-                            ue_header: *_Unwind_Exception,\n-                            context: *_Unwind_Context) -> _Unwind_Reason_Code;\n+                            actions: uw::_Unwind_Action,\n+                            exception_class: uw::_Unwind_Exception_Class,\n+                            ue_header: *uw::_Unwind_Exception,\n+                            context: *uw::_Unwind_Context)\n+        -> uw::_Unwind_Reason_Code;\n }\n \n #[lang=\"eh_personality\"]\n #[no_mangle] // so we can reference it by name from middle/trans/base.rs\n #[doc(hidden)]\n #[cfg(not(test))]\n-pub extern \"C\" fn rust_eh_personality(version: c_int,\n-                                      actions: _Unwind_Action,\n-                                      exception_class: _Unwind_Exception_Class,\n-                                      ue_header: *_Unwind_Exception,\n-                                      context: *_Unwind_Context) -> _Unwind_Reason_Code {\n+pub extern \"C\" fn rust_eh_personality(\n+    version: c_int,\n+    actions: uw::_Unwind_Action,\n+    exception_class: uw::_Unwind_Exception_Class,\n+    ue_header: *uw::_Unwind_Exception,\n+    context: *uw::_Unwind_Context\n+) -> uw::_Unwind_Reason_Code\n+{\n     unsafe {\n-        __gcc_personality_v0(version, actions, exception_class, ue_header, context)\n+        __gcc_personality_v0(version, actions, exception_class, ue_header,\n+                             context)\n     }\n }\n \n #[no_mangle] // referenced from rust_try.ll\n #[doc(hidden)]\n #[cfg(not(test))]\n-pub extern \"C\" fn rust_eh_personality_catch(version: c_int,\n-                                            actions: _Unwind_Action,\n-                                            exception_class: _Unwind_Exception_Class,\n-                                            ue_header: *_Unwind_Exception,\n-                                            context: *_Unwind_Context) -> _Unwind_Reason_Code {\n-    if (actions as c_int & _UA_SEARCH_PHASE as c_int) != 0 { // search phase\n-        _URC_HANDLER_FOUND // catch!\n+pub extern \"C\" fn rust_eh_personality_catch(\n+    version: c_int,\n+    actions: uw::_Unwind_Action,\n+    exception_class: uw::_Unwind_Exception_Class,\n+    ue_header: *uw::_Unwind_Exception,\n+    context: *uw::_Unwind_Context\n+) -> uw::_Unwind_Reason_Code\n+{\n+    if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n+        uw::_URC_HANDLER_FOUND // catch!\n     }\n     else { // cleanup phase\n         unsafe {\n-             __gcc_personality_v0(version, actions, exception_class, ue_header, context)\n+             __gcc_personality_v0(version, actions, exception_class, ue_header,\n+                                  context)\n         }\n     }\n }\n+\n+/// This is the entry point of unwinding for things like lang items and such.\n+/// The arguments are normally generated by the compiler, and need to\n+/// have static lifetimes.\n+pub fn begin_unwind_raw(msg: *c_char, file: *c_char, line: size_t) -> ! {\n+    #[inline]\n+    fn static_char_ptr(p: *c_char) -> &'static str {\n+        let s = unsafe { CString::new(p, false) };\n+        match s.as_str() {\n+            Some(s) => unsafe { cast::transmute::<&str, &'static str>(s) },\n+            None => rtabort!(\"message wasn't utf8?\")\n+        }\n+    }\n+\n+    let msg = static_char_ptr(msg);\n+    let file = static_char_ptr(file);\n+\n+    begin_unwind(msg, file, line as uint)\n+}\n+\n+/// This is the entry point of unwinding for fail!() and assert!().\n+pub fn begin_unwind<M: Any + Send>(msg: M, file: &'static str, line: uint) -> ! {\n+    unsafe {\n+        let task: *mut Task;\n+        // Note that this should be the only allocation performed in this block.\n+        // Currently this means that fail!() on OOM will invoke this code path,\n+        // but then again we're not really ready for failing on OOM anyway. If\n+        // we do start doing this, then we should propagate this allocation to\n+        // be performed in the parent of this task instead of the task that's\n+        // failing.\n+        let msg = ~msg as ~Any;\n+\n+        {\n+            let msg_s = match msg.as_ref::<&'static str>() {\n+                Some(s) => *s,\n+                None => match msg.as_ref::<~str>() {\n+                    Some(s) => s.as_slice(),\n+                    None => \"~Any\",\n+                }\n+            };\n+\n+            // It is assumed that all reasonable rust code will have a local\n+            // task at all times. This means that this `try_unsafe_borrow` will\n+            // succeed almost all of the time. There are border cases, however,\n+            // when the runtime has *almost* set up the local task, but hasn't\n+            // quite gotten there yet. In order to get some better diagnostics,\n+            // we print on failure and immediately abort the whole process if\n+            // there is no local task available.\n+            match Local::try_unsafe_borrow() {\n+                Some(t) => {\n+                    task = t;\n+                    let n = (*task).name.as_ref()\n+                                   .map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n+\n+                    rterrln!(\"task '{}' failed at '{}', {}:{}\", n, msg_s,\n+                             file, line);\n+                }\n+                None => {\n+                    rterrln!(\"failed at '{}', {}:{}\", msg_s, file, line);\n+                    intrinsics::abort();\n+                }\n+            }\n+\n+            if (*task).unwinder.unwinding {\n+                rtabort!(\"unwinding again\");\n+            }\n+        }\n+\n+        (*task).unwinder.begin_unwind(msg);\n+    }\n+}"}, {"sha": "730a38ce8867d86c29254646d57462c3983d3bde", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -15,7 +15,6 @@ use libc;\n use option::{Some, None, Option};\n use os;\n use str::StrSlice;\n-use unstable::atomics::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n use unstable::running_on_valgrind;\n \n // Indicates whether we should perform expensive sanity checks, including rtassert!\n@@ -68,11 +67,21 @@ pub fn default_sched_threads() -> uint {\n }\n \n pub fn dumb_println(args: &fmt::Arguments) {\n-    use io::native::file::FileDesc;\n     use io;\n     use libc;\n-    let mut out = FileDesc::new(libc::STDERR_FILENO, false);\n-    fmt::writeln(&mut out as &mut io::Writer, args);\n+\n+    struct Stderr;\n+    impl io::Writer for Stderr {\n+        fn write(&mut self, data: &[u8]) {\n+            unsafe {\n+                libc::write(libc::STDERR_FILENO,\n+                            data.as_ptr() as *libc::c_void,\n+                            data.len() as libc::size_t);\n+            }\n+        }\n+    }\n+    let mut w = Stderr;\n+    fmt::writeln(&mut w as &mut io::Writer, args);\n }\n \n pub fn abort(msg: &str) -> ! {\n@@ -133,13 +142,3 @@ memory and partly incapable of presentation to others.\",\n         unsafe { libc::abort() }\n     }\n }\n-\n-static mut EXIT_STATUS: AtomicInt = INIT_ATOMIC_INT;\n-\n-pub fn set_exit_status(code: int) {\n-    unsafe { EXIT_STATUS.store(code, SeqCst) }\n-}\n-\n-pub fn get_exit_status() -> int {\n-    unsafe { EXIT_STATUS.load(SeqCst) }\n-}"}, {"sha": "69704c855ee8f2f3a5da4d45d31facee7bc94172", "filename": "src/libstd/run.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -338,8 +338,8 @@ mod tests {\n     use str;\n     use task::spawn;\n     use unstable::running_on_valgrind;\n-    use io::native::file;\n-    use io::{FileNotFound, Reader, Writer, io_error};\n+    use io::pipe::PipeStream;\n+    use io::{Writer, Reader, io_error, FileNotFound, OtherIoError};\n \n     #[test]\n     #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n@@ -426,13 +426,13 @@ mod tests {\n     }\n \n     fn writeclose(fd: c_int, s: &str) {\n-        let mut writer = file::FileDesc::new(fd, true);\n+        let mut writer = PipeStream::open(fd);\n         writer.write(s.as_bytes());\n     }\n \n     fn readclose(fd: c_int) -> ~str {\n         let mut res = ~[];\n-        let mut reader = file::FileDesc::new(fd, true);\n+        let mut reader = PipeStream::open(fd);\n         let mut buf = [0, ..1024];\n         loop {\n             match reader.read(buf) {"}, {"sha": "7b94a3acc2b7dac27a06ded944c800f11d54edda", "filename": "src/libstd/sync/arc.rs", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Farc.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -0,0 +1,152 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Atomically reference counted data\n+//!\n+//! This modules contains the implementation of an atomically reference counted\n+//! pointer for the purpose of sharing data between tasks. This is obviously a\n+//! very unsafe primitive to use, but it has its use cases when implementing\n+//! concurrent data structures and similar tasks.\n+//!\n+//! Great care must be taken to ensure that data races do not arise through the\n+//! usage of `UnsafeArc`, and this often requires some form of external\n+//! synchronization. The only guarantee provided to you by this class is that\n+//! the underlying data will remain valid (not free'd) so long as the reference\n+//! count is greater than one.\n+\n+use cast;\n+use clone::Clone;\n+use kinds::Send;\n+use ops::Drop;\n+use ptr::RawPtr;\n+use sync::atomics::{AtomicUint, SeqCst, Relaxed, Acquire};\n+use vec;\n+\n+/// An atomically reference counted pointer.\n+///\n+/// Enforces no shared-memory safety.\n+#[unsafe_no_drop_flag]\n+pub struct UnsafeArc<T> {\n+    priv data: *mut ArcData<T>,\n+}\n+\n+struct ArcData<T> {\n+    count: AtomicUint,\n+    data: T,\n+}\n+\n+unsafe fn new_inner<T: Send>(data: T, refcount: uint) -> *mut ArcData<T> {\n+    let data = ~ArcData { count: AtomicUint::new(refcount), data: data };\n+    cast::transmute(data)\n+}\n+\n+impl<T: Send> UnsafeArc<T> {\n+    /// Creates a new `UnsafeArc` which wraps the given data.\n+    pub fn new(data: T) -> UnsafeArc<T> {\n+        unsafe { UnsafeArc { data: new_inner(data, 1) } }\n+    }\n+\n+    /// As new(), but returns an extra pre-cloned handle.\n+    pub fn new2(data: T) -> (UnsafeArc<T>, UnsafeArc<T>) {\n+        unsafe {\n+            let ptr = new_inner(data, 2);\n+            (UnsafeArc { data: ptr }, UnsafeArc { data: ptr })\n+        }\n+    }\n+\n+    /// As new(), but returns a vector of as many pre-cloned handles as\n+    /// requested.\n+    pub fn newN(data: T, num_handles: uint) -> ~[UnsafeArc<T>] {\n+        unsafe {\n+            if num_handles == 0 {\n+                ~[] // need to free data here\n+            } else {\n+                let ptr = new_inner(data, num_handles);\n+                vec::from_fn(num_handles, |_| UnsafeArc { data: ptr })\n+            }\n+        }\n+    }\n+\n+    /// Gets a pointer to the inner shared data. Note that care must be taken to\n+    /// ensure that the outer `UnsafeArc` does not fall out of scope while this\n+    /// pointer is in use, otherwise it could possibly contain a use-after-free.\n+    #[inline]\n+    pub fn get(&self) -> *mut T {\n+        unsafe {\n+            assert!((*self.data).count.load(Relaxed) > 0);\n+            return &mut (*self.data).data as *mut T;\n+        }\n+    }\n+\n+    /// Gets an immutable pointer to the inner shared data. This has the same\n+    /// caveats as the `get` method.\n+    #[inline]\n+    pub fn get_immut(&self) -> *T {\n+        unsafe {\n+            assert!((*self.data).count.load(Relaxed) > 0);\n+            return &(*self.data).data as *T;\n+        }\n+    }\n+}\n+\n+impl<T: Send> Clone for UnsafeArc<T> {\n+    fn clone(&self) -> UnsafeArc<T> {\n+        unsafe {\n+            // This barrier might be unnecessary, but I'm not sure...\n+            let old_count = (*self.data).count.fetch_add(1, Acquire);\n+            assert!(old_count >= 1);\n+            return UnsafeArc { data: self.data };\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for UnsafeArc<T>{\n+    fn drop(&mut self) {\n+        unsafe {\n+            // Happens when destructing an unwrapper's handle and from\n+            // `#[unsafe_no_drop_flag]`\n+            if self.data.is_null() {\n+                return\n+            }\n+            // Must be acquire+release, not just release, to make sure this\n+            // doesn't get reordered to after the unwrapper pointer load.\n+            let old_count = (*self.data).count.fetch_sub(1, SeqCst);\n+            assert!(old_count >= 1);\n+            if old_count == 1 {\n+                let _: ~ArcData<T> = cast::transmute(self.data);\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::*;\n+    use super::UnsafeArc;\n+    use mem::size_of;\n+\n+    #[test]\n+    fn test_size() {\n+        assert_eq!(size_of::<UnsafeArc<[int, ..10]>>(), size_of::<*[int, ..10]>());\n+    }\n+\n+    #[test]\n+    fn arclike_newN() {\n+        // Tests that the many-refcounts-at-once constructors don't leak.\n+        let _ = UnsafeArc::new2(~~\"hello\");\n+        let x = UnsafeArc::newN(~~\"hello\", 0);\n+        assert_eq!(x.len(), 0)\n+        let x = UnsafeArc::newN(~~\"hello\", 1);\n+        assert_eq!(x.len(), 1)\n+        let x = UnsafeArc::newN(~~\"hello\", 10);\n+        assert_eq!(x.len(), 10)\n+    }\n+}"}, {"sha": "bc9d99c0f37d7f85b3cad745aa085f447a2cc95a", "filename": "src/libstd/sync/atomics.rs", "status": "renamed", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fsync%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fsync%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomics.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -11,13 +11,16 @@\n /*!\n  * Atomic types\n  *\n- * Basic atomic types supporting atomic operations. Each method takes an `Ordering` which\n- * represents the strength of the memory barrier for that operation. These orderings are the same\n- * as C++11 atomic orderings [http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync]\n+ * Basic atomic types supporting atomic operations. Each method takes an\n+ * `Ordering` which represents the strength of the memory barrier for that\n+ * operation. These orderings are the same as C++11 atomic orderings\n+ * [http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync]\n  *\n  * All atomic types are a single word in size.\n  */\n \n+#[allow(missing_doc)];\n+\n use unstable::intrinsics;\n use cast;\n use option::{Option,Some,None};", "previous_filename": "src/libstd/unstable/atomics.rs"}, {"sha": "4d0efcd6ee10ada30cffce16e1300cb34bfa1651", "filename": "src/libstd/sync/deque.rs", "status": "renamed", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -50,15 +50,18 @@\n \n use cast;\n use clone::Clone;\n-use iter::range;\n+use iter::{range, Iterator};\n use kinds::Send;\n use libc;\n use mem;\n use ops::Drop;\n use option::{Option, Some, None};\n use ptr;\n-use unstable::atomics::{AtomicInt, AtomicPtr, SeqCst};\n-use unstable::sync::{UnsafeArc, Exclusive};\n+use ptr::RawPtr;\n+use sync::arc::UnsafeArc;\n+use sync::atomics::{AtomicInt, AtomicPtr, SeqCst};\n+use unstable::sync::Exclusive;\n+use vec::{OwnedVector, ImmutableVector};\n \n // Once the queue is less than 1/K full, then it will be downsized. Note that\n // the deque requires that this number be less than 2.\n@@ -399,8 +402,8 @@ mod tests {\n     use rt::thread::Thread;\n     use rand;\n     use rand::Rng;\n-    use unstable::atomics::{AtomicBool, INIT_ATOMIC_BOOL, SeqCst,\n-                            AtomicUint, INIT_ATOMIC_UINT};\n+    use sync::atomics::{AtomicBool, INIT_ATOMIC_BOOL, SeqCst,\n+                        AtomicUint, INIT_ATOMIC_UINT};\n     use vec;\n \n     #[test]", "previous_filename": "src/libstd/rt/deque.rs"}, {"sha": "3213c538152c676ce8bbfd659e6205b5662a6442", "filename": "src/libstd/sync/mod.rs", "status": "renamed", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -8,19 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-fast make-check does not like `#[start]`\n+//! Useful synchronization primitives\n+//!\n+//! This modules contains useful safe and unsafe synchronization primitives.\n+//! Most of the primitives in this module do not provide any sort of locking\n+//! and/or blocking at all, but rather provide the necessary tools to build\n+//! other types of concurrent primitives.\n \n-use std::rt;\n-\n-#[start]\n-fn start(argc: int, argv: **u8) -> int {\n-    do rt::start(argc, argv) {\n-        println(\"First invocation\");\n-    };\n-\n-    do rt::start(argc, argv) {\n-        println(\"Second invocation\");\n-    };\n-\n-    0\n-}\n+pub mod arc;\n+pub mod atomics;\n+pub mod deque;\n+pub mod mpmc_bounded_queue;\n+pub mod mpsc_queue;\n+pub mod spsc_queue;", "previous_filename": "src/test/run-pass/rt-run-twice.rs"}, {"sha": "fe51de4e42d067c5aab7d4c4b94de76f0902b166", "filename": "src/libstd/sync/mpmc_bounded_queue.rs", "status": "renamed", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -25,15 +25,17 @@\n  * policies, either expressed or implied, of Dmitry Vyukov.\n  */\n \n+#[allow(missing_doc, dead_code)];\n+\n // http://www.1024cores.net/home/lock-free-algorithms/queues/bounded-mpmc-queue\n \n-use unstable::sync::UnsafeArc;\n-use unstable::atomics::{AtomicUint,Relaxed,Release,Acquire};\n-use option::*;\n-use vec;\n use clone::Clone;\n use kinds::Send;\n use num::{Exponential,Algebraic,Round};\n+use option::{Option, Some, None};\n+use sync::arc::UnsafeArc;\n+use sync::atomics::{AtomicUint,Relaxed,Release,Acquire};\n+use vec;\n \n struct Node<T> {\n     sequence: AtomicUint,\n@@ -161,23 +163,26 @@ impl<T: Send> Clone for Queue<T> {\n mod tests {\n     use prelude::*;\n     use option::*;\n-    use task;\n     use super::Queue;\n+    use native;\n \n     #[test]\n     fn test() {\n         let nthreads = 8u;\n         let nmsgs = 1000u;\n         let mut q = Queue::with_capacity(nthreads*nmsgs);\n         assert_eq!(None, q.pop());\n+        let (port, chan) = SharedChan::new();\n \n         for _ in range(0, nthreads) {\n             let q = q.clone();\n-            do task::spawn_sched(task::SingleThreaded) {\n+            let chan = chan.clone();\n+            do native::task::spawn {\n                 let mut q = q;\n                 for i in range(0, nmsgs) {\n                     assert!(q.push(i));\n                 }\n+                chan.send(());\n             }\n         }\n \n@@ -186,7 +191,7 @@ mod tests {\n             let (completion_port, completion_chan) = Chan::new();\n             completion_ports.push(completion_port);\n             let q = q.clone();\n-            do task::spawn_sched(task::SingleThreaded) {\n+            do native::task::spawn {\n                 let mut q = q;\n                 let mut i = 0u;\n                 loop {\n@@ -205,5 +210,8 @@ mod tests {\n         for completion_port in completion_ports.mut_iter() {\n             assert_eq!(nmsgs, completion_port.recv());\n         }\n+        for _ in range(0, nthreads) {\n+            port.recv();\n+        }\n     }\n }", "previous_filename": "src/libstd/rt/mpmc_bounded_queue.rs"}, {"sha": "a249d6ed2e8ce8cc65e93398db6a74fc4c251500", "filename": "src/libstd/sync/mpsc_queue.rs", "status": "renamed", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fsync%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fsync%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc_queue.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -26,6 +26,14 @@\n  */\n \n //! A mostly lock-free multi-producer, single consumer queue.\n+//!\n+//! This module contains an implementation of a concurrent MPSC queue. This\n+//! queue can be used to share data between tasks, and is also used as the\n+//! building block of channels in rust.\n+//!\n+//! Note that the current implementation of this queue has a caveat of the `pop`\n+//! method, and see the method for more information about it. Due to this\n+//! caveat, this queue may not be appropriate for all use-cases.\n \n // http://www.1024cores.net/home/lock-free-algorithms\n //                         /queues/non-intrusive-mpsc-node-based-queue\n@@ -35,9 +43,11 @@ use clone::Clone;\n use kinds::Send;\n use ops::Drop;\n use option::{Option, None, Some};\n-use unstable::atomics::{AtomicPtr, Release, Acquire, AcqRel, Relaxed};\n-use unstable::sync::UnsafeArc;\n+use ptr::RawPtr;\n+use sync::arc::UnsafeArc;\n+use sync::atomics::{AtomicPtr, Release, Acquire, AcqRel, Relaxed};\n \n+/// A result of the `pop` function.\n pub enum PopResult<T> {\n     /// Some data has been popped\n     Data(T),\n@@ -61,10 +71,14 @@ struct State<T, P> {\n     packet: P,\n }\n \n+/// The consumer half of this concurrent queue. This half is used to receive\n+/// data from the producers.\n pub struct Consumer<T, P> {\n     priv state: UnsafeArc<State<T, P>>,\n }\n \n+/// The production half of the concurrent queue. This handle may be cloned in\n+/// order to make handles for new producers.\n pub struct Producer<T, P> {\n     priv state: UnsafeArc<State<T, P>>,\n }\n@@ -75,6 +89,11 @@ impl<T: Send, P: Send> Clone for Producer<T, P> {\n     }\n }\n \n+/// Creates a new MPSC queue. The given argument `p` is a user-defined \"packet\"\n+/// of information which will be shared by the consumer and the producer which\n+/// can be re-acquired via the `packet` function. This is helpful when extra\n+/// state is shared between the producer and consumer, but note that there is no\n+/// synchronization performed of this data.\n pub fn queue<T: Send, P: Send>(p: P) -> (Consumer<T, P>, Producer<T, P>) {\n     unsafe {\n         let (a, b) = UnsafeArc::new2(State::new(p));\n@@ -92,7 +111,7 @@ impl<T> Node<T> {\n }\n \n impl<T: Send, P: Send> State<T, P> {\n-    pub unsafe fn new(p: P) -> State<T, P> {\n+    unsafe fn new(p: P) -> State<T, P> {\n         let stub = Node::new(None);\n         State {\n             head: AtomicPtr::new(stub),\n@@ -122,10 +141,6 @@ impl<T: Send, P: Send> State<T, P> {\n \n         if self.head.load(Acquire) == tail {Empty} else {Inconsistent}\n     }\n-\n-    unsafe fn is_empty(&mut self) -> bool {\n-        return (*self.tail).next.load(Acquire).is_null();\n-    }\n }\n \n #[unsafe_destructor]\n@@ -143,27 +158,42 @@ impl<T: Send, P: Send> Drop for State<T, P> {\n }\n \n impl<T: Send, P: Send> Producer<T, P> {\n+    /// Pushes a new value onto this queue.\n     pub fn push(&mut self, value: T) {\n         unsafe { (*self.state.get()).push(value) }\n     }\n-    pub fn is_empty(&self) -> bool {\n-        unsafe{ (*self.state.get()).is_empty() }\n-    }\n+    /// Gets an unsafe pointer to the user-defined packet shared by the\n+    /// producers and the consumer. Note that care must be taken to ensure that\n+    /// the lifetime of the queue outlives the usage of the returned pointer.\n     pub unsafe fn packet(&self) -> *mut P {\n         &mut (*self.state.get()).packet as *mut P\n     }\n }\n \n impl<T: Send, P: Send> Consumer<T, P> {\n+    /// Pops some data from this queue.\n+    ///\n+    /// Note that the current implementation means that this function cannot\n+    /// return `Option<T>`. It is possible for this queue to be in an\n+    /// inconsistent state where many pushes have suceeded and completely\n+    /// finished, but pops cannot return `Some(t)`. This inconsistent state\n+    /// happens when a pusher is pre-empted at an inopportune moment.\n+    ///\n+    /// This inconsistent state means that this queue does indeed have data, but\n+    /// it does not currently have access to it at this time.\n     pub fn pop(&mut self) -> PopResult<T> {\n         unsafe { (*self.state.get()).pop() }\n     }\n+    /// Attempts to pop data from this queue, but doesn't attempt too hard. This\n+    /// will canonicalize inconsistent states to a `None` value.\n     pub fn casual_pop(&mut self) -> Option<T> {\n         match self.pop() {\n             Data(t) => Some(t),\n             Empty | Inconsistent => None,\n         }\n     }\n+    /// Gets an unsafe pointer to the underlying user-defined packet. See\n+    /// `Producer.packet` for more information.\n     pub unsafe fn packet(&self) -> *mut P {\n         &mut (*self.state.get()).packet as *mut P\n     }\n@@ -173,8 +203,8 @@ impl<T: Send, P: Send> Consumer<T, P> {\n mod tests {\n     use prelude::*;\n \n-    use task;\n     use super::{queue, Data, Empty, Inconsistent};\n+    use native;\n \n     #[test]\n     fn test_full() {\n@@ -192,14 +222,17 @@ mod tests {\n             Empty => {}\n             Inconsistent | Data(..) => fail!()\n         }\n+        let (port, chan) = SharedChan::new();\n \n         for _ in range(0, nthreads) {\n             let q = p.clone();\n-            do task::spawn_sched(task::SingleThreaded) {\n+            let chan = chan.clone();\n+            do native::task::spawn {\n                 let mut q = q;\n                 for i in range(0, nmsgs) {\n                     q.push(i);\n                 }\n+                chan.send(());\n             }\n         }\n \n@@ -210,6 +243,9 @@ mod tests {\n                 Data(_) => { i += 1 }\n             }\n         }\n+        for _ in range(0, nthreads) {\n+            port.recv();\n+        }\n     }\n }\n ", "previous_filename": "src/libstd/rt/mpsc_queue.rs"}, {"sha": "6f1b887c271569c2ca23a9d6209367768fc719c6", "filename": "src/libstd/sync/spsc_queue.rs", "status": "renamed", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fsync%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fsync%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fspsc_queue.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -26,12 +26,20 @@\n  */\n \n // http://www.1024cores.net/home/lock-free-algorithms/queues/unbounded-spsc-queue\n+\n+//! A single-producer single-consumer concurrent queue\n+//!\n+//! This module contains the implementation of an SPSC queue which can be used\n+//! concurrently between two tasks. This data structure is safe to use and\n+//! enforces the semantics that there is one pusher and one popper.\n+\n use cast;\n use kinds::Send;\n use ops::Drop;\n use option::{Some, None, Option};\n-use unstable::atomics::{AtomicPtr, Relaxed, AtomicUint, Acquire, Release};\n-use unstable::sync::UnsafeArc;\n+use ptr::RawPtr;\n+use sync::arc::UnsafeArc;\n+use sync::atomics::{AtomicPtr, Relaxed, AtomicUint, Acquire, Release};\n \n // Node within the linked list queue of messages to send\n struct Node<T> {\n@@ -64,14 +72,34 @@ struct State<T, P> {\n     packet: P,\n }\n \n+/// Producer half of this queue. This handle is used to push data to the\n+/// consumer.\n pub struct Producer<T, P> {\n     priv state: UnsafeArc<State<T, P>>,\n }\n \n+/// Consumer half of this queue. This handle is used to receive data from the\n+/// producer.\n pub struct Consumer<T, P> {\n     priv state: UnsafeArc<State<T, P>>,\n }\n \n+/// Creates a new queue. The producer returned is connected to the consumer to\n+/// push all data to the consumer.\n+///\n+/// # Arguments\n+///\n+///   * `bound` - This queue implementation is implemented with a linked list,\n+///               and this means that a push is always a malloc. In order to\n+///               amortize this cost, an internal cache of nodes is maintained\n+///               to prevent a malloc from always being necessary. This bound is\n+///               the limit on the size of the cache (if desired). If the value\n+///               is 0, then the cache has no bound. Otherwise, the cache will\n+///               never grow larger than `bound` (although the queue itself\n+///               could be much larger.\n+///\n+///   * `p` - This is the user-defined packet of data which will also be shared\n+///           between the producer and consumer.\n pub fn queue<T: Send, P: Send>(bound: uint,\n                                p: P) -> (Consumer<T, P>, Producer<T, P>)\n {\n@@ -105,21 +133,31 @@ impl<T: Send> Node<T> {\n }\n \n impl<T: Send, P: Send> Producer<T, P> {\n+    /// Pushes data onto the queue\n     pub fn push(&mut self, t: T) {\n         unsafe { (*self.state.get()).push(t) }\n     }\n+    /// Tests whether the queue is empty. Note that if this function returns\n+    /// `false`, the return value is significant, but if the return value is\n+    /// `true` then almost no meaning can be attached to the return value.\n     pub fn is_empty(&self) -> bool {\n         unsafe { (*self.state.get()).is_empty() }\n     }\n+    /// Acquires an unsafe pointer to the underlying user-defined packet. Note\n+    /// that care must be taken to ensure that the queue outlives the usage of\n+    /// the packet (because it is an unsafe pointer).\n     pub unsafe fn packet(&self) -> *mut P {\n         &mut (*self.state.get()).packet as *mut P\n     }\n }\n \n impl<T: Send, P: Send> Consumer<T, P> {\n+    /// Pops some data from this queue, returning `None` when the queue is\n+    /// empty.\n     pub fn pop(&mut self) -> Option<T> {\n         unsafe { (*self.state.get()).pop() }\n     }\n+    /// Same function as the producer's `packet` method.\n     pub unsafe fn packet(&self) -> *mut P {\n         &mut (*self.state.get()).packet as *mut P\n     }\n@@ -230,7 +268,7 @@ impl<T: Send, P: Send> Drop for State<T, P> {\n mod test {\n     use prelude::*;\n     use super::queue;\n-    use task;\n+    use native;\n \n     #[test]\n     fn smoke() {\n@@ -276,7 +314,8 @@ mod test {\n \n         fn stress_bound(bound: uint) {\n             let (c, mut p) = queue(bound, ());\n-            do task::spawn_sched(task::SingleThreaded) {\n+            let (port, chan) = Chan::new();\n+            do native::task::spawn {\n                 let mut c = c;\n                 for _ in range(0, 100000) {\n                     loop {\n@@ -287,10 +326,12 @@ mod test {\n                         }\n                     }\n                 }\n+                chan.send(());\n             }\n             for _ in range(0, 100000) {\n                 p.push(1);\n             }\n+            port.recv();\n         }\n     }\n }", "previous_filename": "src/libstd/rt/spsc_queue.rs"}, {"sha": "2f0f9bf64af4c5506df468398289f04cec4bfea2", "filename": "src/libstd/task.rs", "status": "renamed", "additions": 63, "deletions": 210, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -53,22 +53,22 @@\n \n #[allow(missing_doc)];\n \n-use prelude::*;\n-\n+use any::Any;\n use comm::{Chan, Port};\n+use kinds::Send;\n+use option::{None, Some, Option};\n use result::{Result, Ok, Err};\n-use rt::in_green_task_context;\n use rt::local::Local;\n+use rt::task::Task;\n use send_str::{SendStr, IntoSendStr};\n+use str::Str;\n use util;\n \n-#[cfg(test)] use any::Any;\n+#[cfg(test)] use any::{AnyOwnExt, AnyRefExt};\n #[cfg(test)] use comm::SharedChan;\n #[cfg(test)] use ptr;\n #[cfg(test)] use result;\n \n-pub mod spawn;\n-\n /// Indicates the manner in which a task exited.\n ///\n /// A task that completes without failing is considered to exit successfully.\n@@ -80,27 +80,6 @@ pub mod spawn;\n /// children tasks complete, recommend using a result future.\n pub type TaskResult = Result<(), ~Any>;\n \n-/// Scheduler modes\n-#[deriving(Eq)]\n-pub enum SchedMode {\n-    /// Run task on the default scheduler\n-    DefaultScheduler,\n-    /// All tasks run in the same OS thread\n-    SingleThreaded,\n-}\n-\n-/**\n- * Scheduler configuration options\n- *\n- * # Fields\n- *\n- * * sched_mode - The operating mode of the scheduler\n- *\n- */\n-pub struct SchedOpts {\n-    priv mode: SchedMode,\n-}\n-\n /**\n  * Task configuration options\n  *\n@@ -121,10 +100,9 @@ pub struct SchedOpts {\n  *           scheduler other tasks will be impeded or even blocked indefinitely.\n  */\n pub struct TaskOpts {\n-    priv watched: bool,\n-    priv notify_chan: Option<Chan<TaskResult>>,\n+    watched: bool,\n+    notify_chan: Option<Chan<TaskResult>>,\n     name: Option<SendStr>,\n-    sched: SchedOpts,\n     stack_size: Option<uint>\n }\n \n@@ -153,7 +131,7 @@ pub struct TaskBuilder {\n  */\n pub fn task() -> TaskBuilder {\n     TaskBuilder {\n-        opts: default_task_opts(),\n+        opts: TaskOpts::new(),\n         gen_body: None,\n         can_not_copy: None,\n     }\n@@ -169,7 +147,6 @@ impl TaskBuilder {\n                 watched: self.opts.watched,\n                 notify_chan: notify_chan,\n                 name: name,\n-                sched: self.opts.sched,\n                 stack_size: self.opts.stack_size\n             },\n             gen_body: gen_body,\n@@ -229,11 +206,6 @@ impl TaskBuilder {\n         self.opts.name = Some(name.into_send_str());\n     }\n \n-    /// Configure a custom scheduler mode for the task.\n-    pub fn sched_mode(&mut self, mode: SchedMode) {\n-        self.opts.sched.mode = mode;\n-    }\n-\n     /**\n      * Add a wrapper to the body of the spawned task.\n      *\n@@ -285,7 +257,6 @@ impl TaskBuilder {\n             watched: x.opts.watched,\n             notify_chan: notify_chan,\n             name: name,\n-            sched: x.opts.sched,\n             stack_size: x.opts.stack_size\n         };\n         let f = match gen_body {\n@@ -296,7 +267,9 @@ impl TaskBuilder {\n                 f\n             }\n         };\n-        spawn::spawn_raw(opts, f);\n+\n+        let t: ~Task = Local::take();\n+        t.spawn_sibling(opts, f);\n     }\n \n     /**\n@@ -328,25 +301,23 @@ impl TaskBuilder {\n     }\n }\n \n-\n /* Task construction */\n \n-pub fn default_task_opts() -> TaskOpts {\n-    /*!\n-     * The default task options\n-     *\n-     * By default all tasks are supervised by their parent, are spawned\n-     * into the same scheduler, and do not post lifecycle notifications.\n-     */\n-\n-    TaskOpts {\n-        watched: true,\n-        notify_chan: None,\n-        name: None,\n-        sched: SchedOpts {\n-            mode: DefaultScheduler,\n-        },\n-        stack_size: None\n+impl TaskOpts {\n+    pub fn new() -> TaskOpts {\n+        /*!\n+         * The default task options\n+         *\n+         * By default all tasks are supervised by their parent, are spawned\n+         * into the same scheduler, and do not post lifecycle notifications.\n+         */\n+\n+        TaskOpts {\n+            watched: true,\n+            notify_chan: None,\n+            name: None,\n+            stack_size: None\n+        }\n     }\n }\n \n@@ -363,24 +334,6 @@ pub fn spawn(f: proc()) {\n     task.spawn(f)\n }\n \n-pub fn spawn_sched(mode: SchedMode, f: proc()) {\n-    /*!\n-     * Creates a new task on a new or existing scheduler.\n-     *\n-     * When there are no more tasks to execute the\n-     * scheduler terminates.\n-     *\n-     * # Failure\n-     *\n-     * In manual threads mode the number of threads requested must be\n-     * greater than zero.\n-     */\n-\n-    let mut task = task();\n-    task.sched_mode(mode);\n-    task.spawn(f)\n-}\n-\n pub fn try<T:Send>(f: proc() -> T) -> Result<T, ~Any> {\n     /*!\n      * Execute a function in another task and return either the return value\n@@ -400,26 +353,21 @@ pub fn try<T:Send>(f: proc() -> T) -> Result<T, ~Any> {\n pub fn with_task_name<U>(blk: |Option<&str>| -> U) -> U {\n     use rt::task::Task;\n \n-    if in_green_task_context() {\n-        let mut task = Local::borrow(None::<Task>);\n-        match task.get().name {\n-            Some(ref name) => blk(Some(name.as_slice())),\n-            None => blk(None)\n-        }\n-    } else {\n-        fail!(\"no task name exists in non-green task context\")\n+    let mut task = Local::borrow(None::<Task>);\n+    match task.get().name {\n+        Some(ref name) => blk(Some(name.as_slice())),\n+        None => blk(None)\n     }\n }\n \n pub fn deschedule() {\n     //! Yield control to the task scheduler\n \n     use rt::local::Local;\n-    use rt::sched::Scheduler;\n \n     // FIXME(#7544): Optimize this, since we know we won't block.\n-    let sched: ~Scheduler = Local::take();\n-    sched.yield_now();\n+    let task: ~Task = Local::take();\n+    task.yield_now();\n }\n \n pub fn failing() -> bool {\n@@ -428,7 +376,7 @@ pub fn failing() -> bool {\n     use rt::task::Task;\n \n     let mut local = Local::borrow(None::<Task>);\n-    local.get().unwinder.unwinding\n+    local.get().unwinder.unwinding()\n }\n \n // The following 8 tests test the following 2^3 combinations:\n@@ -439,59 +387,43 @@ pub fn failing() -> bool {\n \n #[test]\n fn test_unnamed_task() {\n-    use rt::test::run_in_uv_task;\n-\n-    do run_in_uv_task {\n-        do spawn {\n-            with_task_name(|name| {\n-                assert!(name.is_none());\n-            })\n-        }\n+    do spawn {\n+        with_task_name(|name| {\n+            assert!(name.is_none());\n+        })\n     }\n }\n \n #[test]\n fn test_owned_named_task() {\n-    use rt::test::run_in_uv_task;\n-\n-    do run_in_uv_task {\n-        let mut t = task();\n-        t.name(~\"ada lovelace\");\n-        do t.spawn {\n-            with_task_name(|name| {\n-                assert!(name.unwrap() == \"ada lovelace\");\n-            })\n-        }\n+    let mut t = task();\n+    t.name(~\"ada lovelace\");\n+    do t.spawn {\n+        with_task_name(|name| {\n+            assert!(name.unwrap() == \"ada lovelace\");\n+        })\n     }\n }\n \n #[test]\n fn test_static_named_task() {\n-    use rt::test::run_in_uv_task;\n-\n-    do run_in_uv_task {\n-        let mut t = task();\n-        t.name(\"ada lovelace\");\n-        do t.spawn {\n-            with_task_name(|name| {\n-                assert!(name.unwrap() == \"ada lovelace\");\n-            })\n-        }\n+    let mut t = task();\n+    t.name(\"ada lovelace\");\n+    do t.spawn {\n+        with_task_name(|name| {\n+            assert!(name.unwrap() == \"ada lovelace\");\n+        })\n     }\n }\n \n #[test]\n fn test_send_named_task() {\n-    use rt::test::run_in_uv_task;\n-\n-    do run_in_uv_task {\n-        let mut t = task();\n-        t.name(\"ada lovelace\".into_send_str());\n-        do t.spawn {\n-            with_task_name(|name| {\n-                assert!(name.unwrap() == \"ada lovelace\");\n-            })\n-        }\n+    let mut t = task();\n+    t.name(\"ada lovelace\".into_send_str());\n+    do t.spawn {\n+        with_task_name(|name| {\n+            assert!(name.unwrap() == \"ada lovelace\");\n+        })\n     }\n }\n \n@@ -562,28 +494,19 @@ fn test_try_fail() {\n     }\n }\n \n-#[cfg(test)]\n-fn get_sched_id() -> int {\n-    use rt::sched::Scheduler;\n-    let mut sched = Local::borrow(None::<Scheduler>);\n-    sched.get().sched_id() as int\n-}\n-\n #[test]\n fn test_spawn_sched() {\n+    use clone::Clone;\n+\n     let (po, ch) = SharedChan::new();\n \n     fn f(i: int, ch: SharedChan<()>) {\n-        let parent_sched_id = get_sched_id();\n-\n-        do spawn_sched(SingleThreaded) {\n-            let child_sched_id = get_sched_id();\n-            assert!(parent_sched_id != child_sched_id);\n-\n+        let ch = ch.clone();\n+        do spawn {\n             if (i == 0) {\n                 ch.send(());\n             } else {\n-                f(i - 1, ch.clone());\n+                f(i - 1, ch);\n             }\n         };\n \n@@ -596,82 +519,16 @@ fn test_spawn_sched() {\n fn test_spawn_sched_childs_on_default_sched() {\n     let (po, ch) = Chan::new();\n \n-    // Assuming tests run on the default scheduler\n-    let default_id = get_sched_id();\n-\n-    do spawn_sched(SingleThreaded) {\n+    do spawn {\n         let ch = ch;\n-        let parent_sched_id = get_sched_id();\n         do spawn {\n-            let child_sched_id = get_sched_id();\n-            assert!(parent_sched_id != child_sched_id);\n-            assert_eq!(child_sched_id, default_id);\n             ch.send(());\n         };\n     };\n \n     po.recv();\n }\n \n-#[test]\n-fn test_spawn_sched_blocking() {\n-    use unstable::mutex::Mutex;\n-\n-    unsafe {\n-\n-        // Testing that a task in one scheduler can block in foreign code\n-        // without affecting other schedulers\n-        20u.times(|| {\n-            let (start_po, start_ch) = Chan::new();\n-            let (fin_po, fin_ch) = Chan::new();\n-\n-            let mut lock = Mutex::new();\n-            let lock2 = lock.clone();\n-\n-            do spawn_sched(SingleThreaded) {\n-                let mut lock = lock2;\n-                lock.lock();\n-\n-                start_ch.send(());\n-\n-                // Block the scheduler thread\n-                lock.wait();\n-                lock.unlock();\n-\n-                fin_ch.send(());\n-            };\n-\n-            // Wait until the other task has its lock\n-            start_po.recv();\n-\n-            fn pingpong(po: &Port<int>, ch: &Chan<int>) {\n-                let mut val = 20;\n-                while val > 0 {\n-                    val = po.recv();\n-                    ch.try_send(val - 1);\n-                }\n-            }\n-\n-            let (setup_po, setup_ch) = Chan::new();\n-            let (parent_po, parent_ch) = Chan::new();\n-            do spawn {\n-                let (child_po, child_ch) = Chan::new();\n-                setup_ch.send(child_ch);\n-                pingpong(&child_po, &parent_ch);\n-            };\n-\n-            let child_ch = setup_po.recv();\n-            child_ch.send(20);\n-            pingpong(&parent_po, &child_ch);\n-            lock.lock();\n-            lock.signal();\n-            lock.unlock();\n-            fin_po.recv();\n-            lock.destroy();\n-        })\n-    }\n-}\n-\n #[cfg(test)]\n fn avoid_copying_the_body(spawnfn: |v: proc()|) {\n     let (p, ch) = Chan::<uint>::new();\n@@ -735,11 +592,7 @@ fn test_child_doesnt_ref_parent() {\n \n #[test]\n fn test_simple_newsched_spawn() {\n-    use rt::test::run_in_uv_task;\n-\n-    do run_in_uv_task {\n-        spawn(proc()())\n-    }\n+    spawn(proc()())\n }\n \n #[test]", "previous_filename": "src/libstd/task/mod.rs"}, {"sha": "1148774020a14b083f73d6b5d5e3064ff7061312", "filename": "src/libstd/task/spawn.rs", "status": "removed", "additions": 0, "deletions": 233, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=d975060de6c944ca12ce5205fbc9fc7726948ae1", "patch": "@@ -1,233 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!**************************************************************************\n- *\n- * WARNING: linked failure has been removed since this doc comment was written,\n- *          but it was so pretty that I didn't want to remove it.\n- *\n- * Spawning & linked failure\n- *\n- * Several data structures are involved in task management to allow properly\n- * propagating failure across linked/supervised tasks.\n- *\n- * (1) The \"taskgroup_arc\" is an unsafe::exclusive which contains a hashset of\n- *     all tasks that are part of the group. Some tasks are 'members', which\n- *     means if they fail, they will kill everybody else in the taskgroup.\n- *     Other tasks are 'descendants', which means they will not kill tasks\n- *     from this group, but can be killed by failing members.\n- *\n- *     A new one of these is created each spawn_linked or spawn_supervised.\n- *\n- * (2) The \"taskgroup\" is a per-task control structure that tracks a task's\n- *     spawn configuration. It contains a reference to its taskgroup_arc, a\n- *     reference to its node in the ancestor list (below), and an optionally\n- *     configured notification port. These are stored in TLS.\n- *\n- * (3) The \"ancestor_list\" is a cons-style list of unsafe::exclusives which\n- *     tracks 'generations' of taskgroups -- a group's ancestors are groups\n- *     which (directly or transitively) spawn_supervised-ed them. Each task\n- *     is recorded in the 'descendants' of each of its ancestor groups.\n- *\n- *     Spawning a supervised task is O(n) in the number of generations still\n- *     alive, and exiting (by success or failure) that task is also O(n).\n- *\n- * This diagram depicts the references between these data structures:\n- *\n- *          linked_________________________________\n- *        ___/                   _________         \\___\n- *       /   \\                  | group X |        /   \\\n- *      (  A  ) - - - - - - - > | {A,B} {}|< - - -(  B  )\n- *       \\___/                  |_________|        \\___/\n- *      unlinked\n- *         |      __ (nil)\n- *         |      //|                         The following code causes this:\n- *         |__   //   /\\         _________\n- *        /   \\ //    ||        | group Y |     fn taskA() {\n- *       (  C  )- - - ||- - - > |{C} {D,E}|         spawn(taskB);\n- *        \\___/      /  \\=====> |_________|         spawn_unlinked(taskC);\n- *      supervise   /gen \\                          ...\n- *         |    __  \\ 00 /                      }\n- *         |    //|  \\__/                       fn taskB() { ... }\n- *         |__ //     /\\         _________      fn taskC() {\n- *        /   \\/      ||        | group Z |         spawn_supervised(taskD);\n- *       (  D  )- - - ||- - - > | {D} {E} |         ...\n- *        \\___/      /  \\=====> |_________|     }\n- *      supervise   /gen \\                      fn taskD() {\n- *         |    __  \\ 01 /                          spawn_supervised(taskE);\n- *         |    //|  \\__/                           ...\n- *         |__ //                _________      }\n- *        /   \\/                | group W |     fn taskE() { ... }\n- *       (  E  )- - - - - - - > | {E}  {} |\n- *        \\___/                 |_________|\n- *\n- *        \"tcb\"               \"taskgroup_arc\"\n- *             \"ancestor_list\"\n- *\n- ****************************************************************************/\n-\n-#[doc(hidden)];\n-\n-use prelude::*;\n-\n-use comm::Chan;\n-use rt::local::Local;\n-use rt::sched::{Scheduler, Shutdown, TaskFromFriend};\n-use rt::task::{Task, Sched};\n-use rt::thread::Thread;\n-use rt::{in_green_task_context, new_event_loop};\n-use task::{SingleThreaded, TaskOpts, TaskResult};\n-\n-#[cfg(test)] use task::default_task_opts;\n-#[cfg(test)] use task;\n-\n-pub fn spawn_raw(mut opts: TaskOpts, f: proc()) {\n-    assert!(in_green_task_context());\n-\n-    let mut task = if opts.sched.mode != SingleThreaded {\n-        if opts.watched {\n-            Task::build_child(opts.stack_size, f)\n-        } else {\n-            Task::build_root(opts.stack_size, f)\n-        }\n-    } else {\n-        unsafe {\n-            // Creating a 1:1 task:thread ...\n-            let sched: *mut Scheduler = Local::unsafe_borrow();\n-            let sched_handle = (*sched).make_handle();\n-\n-            // Since this is a 1:1 scheduler we create a queue not in\n-            // the stealee set. The run_anything flag is set false\n-            // which will disable stealing.\n-            let (worker, _stealer) = (*sched).work_queue.pool().deque();\n-\n-            // Create a new scheduler to hold the new task\n-            let mut new_sched = ~Scheduler::new_special(new_event_loop(),\n-                                                        worker,\n-                                                        (*sched).work_queues.clone(),\n-                                                        (*sched).sleeper_list.clone(),\n-                                                        false,\n-                                                        Some(sched_handle));\n-            let mut new_sched_handle = new_sched.make_handle();\n-\n-            // Allow the scheduler to exit when the pinned task exits\n-            new_sched_handle.send(Shutdown);\n-\n-            // Pin the new task to the new scheduler\n-            let new_task = if opts.watched {\n-                Task::build_homed_child(opts.stack_size, f, Sched(new_sched_handle))\n-            } else {\n-                Task::build_homed_root(opts.stack_size, f, Sched(new_sched_handle))\n-            };\n-\n-            // Create a task that will later be used to join with the new scheduler\n-            // thread when it is ready to terminate\n-            let (thread_port, thread_chan) = Chan::new();\n-            let join_task = do Task::build_child(None) {\n-                debug!(\"running join task\");\n-                let thread: Thread<()> = thread_port.recv();\n-                thread.join();\n-            };\n-\n-            // Put the scheduler into another thread\n-            let orig_sched_handle = (*sched).make_handle();\n-\n-            let new_sched = new_sched;\n-            let thread = do Thread::start {\n-                let mut new_sched = new_sched;\n-                let mut orig_sched_handle = orig_sched_handle;\n-\n-                let bootstrap_task = ~do Task::new_root(&mut new_sched.stack_pool, None) || {\n-                    debug!(\"boostrapping a 1:1 scheduler\");\n-                };\n-                new_sched.bootstrap(bootstrap_task);\n-\n-                // Now tell the original scheduler to join with this thread\n-                // by scheduling a thread-joining task on the original scheduler\n-                orig_sched_handle.send(TaskFromFriend(join_task));\n-\n-                // NB: We can't simply send a message from here to another task\n-                // because this code isn't running in a task and message passing doesn't\n-                // work outside of tasks. Hence we're sending a scheduler message\n-                // to execute a new task directly to a scheduler.\n-            };\n-\n-            // Give the thread handle to the join task\n-            thread_chan.send(thread);\n-\n-            // When this task is enqueued on the current scheduler it will then get\n-            // forwarded to the scheduler to which it is pinned\n-            new_task\n-        }\n-    };\n-\n-    if opts.notify_chan.is_some() {\n-        let notify_chan = opts.notify_chan.take_unwrap();\n-        let on_exit: proc(TaskResult) = proc(task_result) {\n-            notify_chan.try_send(task_result);\n-        };\n-        task.death.on_exit = Some(on_exit);\n-    }\n-\n-    task.name = opts.name.take();\n-    debug!(\"spawn calling run_task\");\n-    Scheduler::run_task(task);\n-\n-}\n-\n-#[test]\n-fn test_spawn_raw_simple() {\n-    let (po, ch) = Chan::new();\n-    do spawn_raw(default_task_opts()) {\n-        ch.send(());\n-    }\n-    po.recv();\n-}\n-\n-#[test]\n-fn test_spawn_raw_unsupervise() {\n-    let opts = task::TaskOpts {\n-        watched: false,\n-        notify_chan: None,\n-        .. default_task_opts()\n-    };\n-    do spawn_raw(opts) {\n-        fail!();\n-    }\n-}\n-\n-#[test]\n-fn test_spawn_raw_notify_success() {\n-    let (notify_po, notify_ch) = Chan::new();\n-\n-    let opts = task::TaskOpts {\n-        notify_chan: Some(notify_ch),\n-        .. default_task_opts()\n-    };\n-    do spawn_raw(opts) {\n-    }\n-    assert!(notify_po.recv().is_ok());\n-}\n-\n-#[test]\n-fn test_spawn_raw_notify_failure() {\n-    // New bindings for these\n-    let (notify_po, notify_ch) = Chan::new();\n-\n-    let opts = task::TaskOpts {\n-        watched: false,\n-        notify_chan: Some(notify_ch),\n-        .. default_task_opts()\n-    };\n-    do spawn_raw(opts) {\n-        fail!();\n-    }\n-    assert!(notify_po.recv().is_err());\n-}"}, {"sha": "0569fe32c58b37f1a781db84ca2b125b98b7ae6b", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -140,7 +140,6 @@ pub mod dl {\n     use path;\n     use ptr;\n     use str;\n-    use unstable::sync::atomic;\n     use result::*;\n \n     pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n@@ -158,11 +157,7 @@ pub mod dl {\n         static mut lock: Mutex = MUTEX_INIT;\n         unsafe {\n             // dlerror isn't thread safe, so we need to lock around this entire\n-            // sequence. `atomic` asserts that we don't do anything that\n-            // would cause this task to be descheduled, which could deadlock\n-            // the scheduler if it happens while the lock is held.\n-            // FIXME #9105 use a Rust mutex instead of C++ mutexes.\n-            let _guard = atomic();\n+            // sequence\n             lock.lock();\n             let _old_error = dlerror();\n \n@@ -208,7 +203,6 @@ pub mod dl {\n     use libc;\n     use path;\n     use ptr;\n-    use unstable::sync::atomic;\n     use result::*;\n \n     pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n@@ -225,7 +219,6 @@ pub mod dl {\n \n     pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, ~str> {\n         unsafe {\n-            let _guard = atomic();\n             SetLastError(0);\n \n             let result = f();"}, {"sha": "e7e8cec9d5f178e8584969a8af511c3711eea91e", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -11,15 +11,13 @@\n //! Runtime calls emitted by the compiler.\n \n use c_str::ToCStr;\n-use cast::transmute;\n use libc::{c_char, size_t, uintptr_t};\n-use rt::task;\n use rt::borrowck;\n \n #[cold]\n #[lang=\"fail_\"]\n pub fn fail_(expr: *c_char, file: *c_char, line: size_t) -> ! {\n-    task::begin_unwind_raw(expr, file, line);\n+    ::rt::begin_unwind_raw(expr, file, line);\n }\n \n #[cold]\n@@ -81,15 +79,3 @@ pub unsafe fn check_not_borrowed(a: *u8,\n                                  line: size_t) {\n     borrowck::check_not_borrowed(a, file, line)\n }\n-\n-#[lang=\"start\"]\n-pub fn start(main: *u8, argc: int, argv: **c_char) -> int {\n-    use rt;\n-\n-    unsafe {\n-        return do rt::start(argc, argv as **u8) {\n-            let main: extern \"Rust\" fn() = transmute(main);\n-            main();\n-        };\n-    }\n-}"}, {"sha": "f4573785996c437e668ce3615349c0c68f15ecfb", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -22,8 +22,8 @@ pub mod simd;\n pub mod lang;\n pub mod sync;\n pub mod mutex;\n-pub mod atomics;\n pub mod raw;\n+pub mod stack;\n \n /**\n "}, {"sha": "5b2fac8e74e2eb44cf095fcb7230a87cf9bfa8cc", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -48,7 +48,7 @@\n #[allow(non_camel_case_types)];\n \n use libc::c_void;\n-use unstable::atomics;\n+use sync::atomics;\n \n pub struct Mutex {\n     // pointers for the lock/cond handles, atomically updated\n@@ -333,12 +333,12 @@ mod test {\n     fn somke_cond() {\n         static mut lock: Mutex = MUTEX_INIT;\n         unsafe {\n+            lock.lock();\n             let t = do Thread::start {\n                 lock.lock();\n                 lock.signal();\n                 lock.unlock();\n             };\n-            lock.lock();\n             lock.wait();\n             lock.unlock();\n             t.join();"}, {"sha": "d6cd690eaa9db9b567b7e369e86be653148f2cf9", "filename": "src/libstd/unstable/stack.rs", "status": "added", "additions": 275, "deletions": 0, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Funstable%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Funstable%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fstack.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -0,0 +1,275 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Rust stack-limit management\n+//!\n+//! Currently Rust uses a segmented-stack-like scheme in order to detect stack\n+//! overflow for rust tasks. In this scheme, the prologue of all functions are\n+//! preceded with a check to see whether the current stack limits are being\n+//! exceeded.\n+//!\n+//! This module provides the functionality necessary in order to manage these\n+//! stack limits (which are stored in platform-specific locations). The\n+//! functions here are used at the borders of the task lifetime in order to\n+//! manage these limits.\n+//!\n+//! This function is an unstable module because this scheme for stack overflow\n+//! detection is not guaranteed to continue in the future. Usage of this module\n+//! is discouraged unless absolutely necessary.\n+\n+static RED_ZONE: uint = 20 * 1024;\n+\n+/// This function is invoked from rust's current __morestack function. Segmented\n+/// stacks are currently not enabled as segmented stacks, but rather one giant\n+/// stack segment. This means that whenever we run out of stack, we want to\n+/// truly consider it to be stack overflow rather than allocating a new stack.\n+#[no_mangle]      // - this is called from C code\n+#[no_split_stack] // - it would be sad for this function to trigger __morestack\n+#[doc(hidden)]    // - Function must be `pub` to get exported, but it's\n+                  //   irrelevant for documentation purposes.\n+#[cfg(not(test))] // in testing, use the original libstd's version\n+pub extern \"C\" fn rust_stack_exhausted() {\n+    use rt::task::Task;\n+    use option::None;\n+    use rt::local::Local;\n+    use unstable::intrinsics;\n+\n+    unsafe {\n+        // We're calling this function because the stack just ran out. We need\n+        // to call some other rust functions, but if we invoke the functions\n+        // right now it'll just trigger this handler being called again. In\n+        // order to alleviate this, we move the stack limit to be inside of the\n+        // red zone that was allocated for exactly this reason.\n+        let limit = get_sp_limit();\n+        record_sp_limit(limit - RED_ZONE / 2);\n+\n+        // This probably isn't the best course of action. Ideally one would want\n+        // to unwind the stack here instead of just aborting the entire process.\n+        // This is a tricky problem, however. There's a few things which need to\n+        // be considered:\n+        //\n+        //  1. We're here because of a stack overflow, yet unwinding will run\n+        //     destructors and hence arbitrary code. What if that code overflows\n+        //     the stack? One possibility is to use the above allocation of an\n+        //     extra 10k to hope that we don't hit the limit, and if we do then\n+        //     abort the whole program. Not the best, but kind of hard to deal\n+        //     with unless we want to switch stacks.\n+        //\n+        //  2. LLVM will optimize functions based on whether they can unwind or\n+        //     not. It will flag functions with 'nounwind' if it believes that\n+        //     the function cannot trigger unwinding, but if we do unwind on\n+        //     stack overflow then it means that we could unwind in any function\n+        //     anywhere. We would have to make sure that LLVM only places the\n+        //     nounwind flag on functions which don't call any other functions.\n+        //\n+        //  3. The function that overflowed may have owned arguments. These\n+        //     arguments need to have their destructors run, but we haven't even\n+        //     begun executing the function yet, so unwinding will not run the\n+        //     any landing pads for these functions. If this is ignored, then\n+        //     the arguments will just be leaked.\n+        //\n+        // Exactly what to do here is a very delicate topic, and is possibly\n+        // still up in the air for what exactly to do. Some relevant issues:\n+        //\n+        //  #3555 - out-of-stack failure leaks arguments\n+        //  #3695 - should there be a stack limit?\n+        //  #9855 - possible strategies which could be taken\n+        //  #9854 - unwinding on windows through __morestack has never worked\n+        //  #2361 - possible implementation of not using landing pads\n+\n+        let mut task = Local::borrow(None::<Task>);\n+        let n = task.get().name.as_ref()\n+                    .map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n+\n+        // See the message below for why this is not emitted to the\n+        // task's logger. This has the additional conundrum of the\n+        // logger may not be initialized just yet, meaning that an FFI\n+        // call would happen to initialized it (calling out to libuv),\n+        // and the FFI call needs 2MB of stack when we just ran out.\n+        println!(\"task '{}' has overflowed its stack\", n);\n+\n+        intrinsics::abort();\n+    }\n+}\n+\n+#[inline(always)]\n+pub unsafe fn record_stack_bounds(stack_lo: uint, stack_hi: uint) {\n+    // When the old runtime had segmented stacks, it used a calculation that was\n+    // \"limit + RED_ZONE + FUDGE\". The red zone was for things like dynamic\n+    // symbol resolution, llvm function calls, etc. In theory this red zone\n+    // value is 0, but it matters far less when we have gigantic stacks because\n+    // we don't need to be so exact about our stack budget. The \"fudge factor\"\n+    // was because LLVM doesn't emit a stack check for functions < 256 bytes in\n+    // size. Again though, we have giant stacks, so we round all these\n+    // calculations up to the nice round number of 20k.\n+    record_sp_limit(stack_lo + RED_ZONE);\n+\n+    return target_record_stack_bounds(stack_lo, stack_hi);\n+\n+    #[cfg(not(windows))] #[cfg(not(target_arch = \"x86_64\"))] #[inline(always)]\n+    unsafe fn target_record_stack_bounds(_stack_lo: uint, _stack_hi: uint) {}\n+    #[cfg(windows, target_arch = \"x86_64\")] #[inline(always)]\n+    unsafe fn target_record_stack_bounds(stack_lo: uint, stack_hi: uint) {\n+        // Windows compiles C functions which may check the stack bounds. This\n+        // means that if we want to perform valid FFI on windows, then we need\n+        // to ensure that the stack bounds are what they truly are for this\n+        // task. More info can be found at:\n+        //   https://github.com/mozilla/rust/issues/3445#issuecomment-26114839\n+        //\n+        // stack range is at TIB: %gs:0x08 (top) and %gs:0x10 (bottom)\n+        asm!(\"mov $0, %gs:0x08\" :: \"r\"(stack_hi) :: \"volatile\");\n+        asm!(\"mov $0, %gs:0x10\" :: \"r\"(stack_lo) :: \"volatile\");\n+    }\n+}\n+\n+/// Records the current limit of the stack as specified by `end`.\n+///\n+/// This is stored in an OS-dependent location, likely inside of the thread\n+/// local storage. The location that the limit is stored is a pre-ordained\n+/// location because it's where LLVM has emitted code to check.\n+///\n+/// Note that this cannot be called under normal circumstances. This function is\n+/// changing the stack limit, so upon returning any further function calls will\n+/// possibly be triggering the morestack logic if you're not careful.\n+///\n+/// Also note that this and all of the inside functions are all flagged as\n+/// \"inline(always)\" because they're messing around with the stack limits.  This\n+/// would be unfortunate for the functions themselves to trigger a morestack\n+/// invocation (if they were an actual function call).\n+#[inline(always)]\n+pub unsafe fn record_sp_limit(limit: uint) {\n+    return target_record_sp_limit(limit);\n+\n+    // x86-64\n+    #[cfg(target_arch = \"x86_64\", target_os = \"macos\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        asm!(\"movq $$0x60+90*8, %rsi\n+              movq $0, %gs:(%rsi)\" :: \"r\"(limit) : \"rsi\" : \"volatile\")\n+    }\n+    #[cfg(target_arch = \"x86_64\", target_os = \"linux\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        asm!(\"movq $0, %fs:112\" :: \"r\"(limit) :: \"volatile\")\n+    }\n+    #[cfg(target_arch = \"x86_64\", target_os = \"win32\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        // see: http://en.wikipedia.org/wiki/Win32_Thread_Information_Block\n+        // store this inside of the \"arbitrary data slot\", but double the size\n+        // because this is 64 bit instead of 32 bit\n+        asm!(\"movq $0, %gs:0x28\" :: \"r\"(limit) :: \"volatile\")\n+    }\n+    #[cfg(target_arch = \"x86_64\", target_os = \"freebsd\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        asm!(\"movq $0, %fs:24\" :: \"r\"(limit) :: \"volatile\")\n+    }\n+\n+    // x86\n+    #[cfg(target_arch = \"x86\", target_os = \"macos\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        asm!(\"movl $$0x48+90*4, %eax\n+              movl $0, %gs:(%eax)\" :: \"r\"(limit) : \"eax\" : \"volatile\")\n+    }\n+    #[cfg(target_arch = \"x86\", target_os = \"linux\")]\n+    #[cfg(target_arch = \"x86\", target_os = \"freebsd\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        asm!(\"movl $0, %gs:48\" :: \"r\"(limit) :: \"volatile\")\n+    }\n+    #[cfg(target_arch = \"x86\", target_os = \"win32\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        // see: http://en.wikipedia.org/wiki/Win32_Thread_Information_Block\n+        // store this inside of the \"arbitrary data slot\"\n+        asm!(\"movl $0, %fs:0x14\" :: \"r\"(limit) :: \"volatile\")\n+    }\n+\n+    // mips, arm - Some brave soul can port these to inline asm, but it's over\n+    //             my head personally\n+    #[cfg(target_arch = \"mips\")]\n+    #[cfg(target_arch = \"arm\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        use libc::c_void;\n+        return record_sp_limit(limit as *c_void);\n+        extern {\n+            fn record_sp_limit(limit: *c_void);\n+        }\n+    }\n+}\n+\n+/// The counterpart of the function above, this function will fetch the current\n+/// stack limit stored in TLS.\n+///\n+/// Note that all of these functions are meant to be exact counterparts of their\n+/// brethren above, except that the operands are reversed.\n+///\n+/// As with the setter, this function does not have a __morestack header and can\n+/// therefore be called in a \"we're out of stack\" situation.\n+#[inline(always)]\n+pub unsafe fn get_sp_limit() -> uint {\n+    return target_get_sp_limit();\n+\n+    // x86-64\n+    #[cfg(target_arch = \"x86_64\", target_os = \"macos\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        let limit;\n+        asm!(\"movq $$0x60+90*8, %rsi\n+              movq %gs:(%rsi), $0\" : \"=r\"(limit) :: \"rsi\" : \"volatile\");\n+        return limit;\n+    }\n+    #[cfg(target_arch = \"x86_64\", target_os = \"linux\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        let limit;\n+        asm!(\"movq %fs:112, $0\" : \"=r\"(limit) ::: \"volatile\");\n+        return limit;\n+    }\n+    #[cfg(target_arch = \"x86_64\", target_os = \"win32\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        let limit;\n+        asm!(\"movq %gs:0x28, $0\" : \"=r\"(limit) ::: \"volatile\");\n+        return limit;\n+    }\n+    #[cfg(target_arch = \"x86_64\", target_os = \"freebsd\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        let limit;\n+        asm!(\"movq %fs:24, $0\" : \"=r\"(limit) ::: \"volatile\");\n+        return limit;\n+    }\n+\n+    // x86\n+    #[cfg(target_arch = \"x86\", target_os = \"macos\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        let limit;\n+        asm!(\"movl $$0x48+90*4, %eax\n+              movl %gs:(%eax), $0\" : \"=r\"(limit) :: \"eax\" : \"volatile\");\n+        return limit;\n+    }\n+    #[cfg(target_arch = \"x86\", target_os = \"linux\")]\n+    #[cfg(target_arch = \"x86\", target_os = \"freebsd\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        let limit;\n+        asm!(\"movl %gs:48, $0\" : \"=r\"(limit) ::: \"volatile\");\n+        return limit;\n+    }\n+    #[cfg(target_arch = \"x86\", target_os = \"win32\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        let limit;\n+        asm!(\"movl %fs:0x14, $0\" : \"=r\"(limit) ::: \"volatile\");\n+        return limit;\n+    }\n+\n+    // mips, arm - Some brave soul can port these to inline asm, but it's over\n+    //             my head personally\n+    #[cfg(target_arch = \"mips\")]\n+    #[cfg(target_arch = \"arm\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        use libc::c_void;\n+        return get_sp_limit() as uint;\n+        extern {\n+            fn get_sp_limit() -> *c_void;\n+        }\n+    }\n+}"}, {"sha": "687efea939b52705e2f011174b0564d30a43a8c8", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 5, "deletions": 479, "changes": 484, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -8,353 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use cast;\n-use comm::{Chan, Port};\n-use ptr;\n-use option::{Option,Some,None};\n-use task;\n-use unstable::atomics::{AtomicOption,AtomicUint,Acquire,Release,Relaxed,SeqCst};\n-use unstable::mutex::Mutex;\n-use ops::Drop;\n use clone::Clone;\n use kinds::Send;\n-use vec;\n-\n-/// An atomically reference counted pointer.\n-///\n-/// Enforces no shared-memory safety.\n-//#[unsafe_no_drop_flag] FIXME: #9758\n-pub struct UnsafeArc<T> {\n-    data: *mut ArcData<T>,\n-}\n-\n-pub enum UnsafeArcUnwrap<T> {\n-    UnsafeArcSelf(UnsafeArc<T>),\n-    UnsafeArcT(T)\n-}\n-\n-#[cfg(test)]\n-impl<T> UnsafeArcUnwrap<T> {\n-    fn expect_t(self, msg: &'static str) -> T {\n-        match self {\n-            UnsafeArcSelf(_) => fail!(msg),\n-            UnsafeArcT(t) => t\n-        }\n-    }\n-\n-    fn is_self(&self) -> bool {\n-        match *self {\n-            UnsafeArcSelf(_) => true,\n-            UnsafeArcT(_) => false\n-        }\n-    }\n-}\n-\n-struct ArcData<T> {\n-    count: AtomicUint,\n-    // An unwrapper uses this protocol to communicate with the \"other\" task that\n-    // drops the last refcount on an arc. Unfortunately this can't be a proper\n-    // pipe protocol because the unwrapper has to access both stages at once.\n-    // FIXME(#7544): Maybe use AtomicPtr instead (to avoid xchg in take() later)?\n-    unwrapper: AtomicOption<(Chan<()>, Port<bool>)>,\n-    // FIXME(#3224) should be able to make this non-option to save memory\n-    data: Option<T>,\n-}\n-\n-unsafe fn new_inner<T: Send>(data: T, refcount: uint) -> *mut ArcData<T> {\n-    let data = ~ArcData { count: AtomicUint::new(refcount),\n-                          unwrapper: AtomicOption::empty(),\n-                          data: Some(data) };\n-    cast::transmute(data)\n-}\n-\n-/// A helper object used by `UnsafeArc::unwrap`.\n-struct ChannelAndDataGuard<T> {\n-    channel: Option<Chan<bool>>,\n-    data: Option<~ArcData<T>>,\n-}\n-\n-#[unsafe_destructor]\n-impl<T> Drop for ChannelAndDataGuard<T> {\n-    fn drop(&mut self) {\n-        if task::failing() {\n-            // Killed during wait. Because this might happen while\n-            // someone else still holds a reference, we can't free\n-            // the data now; the \"other\" last refcount will free it.\n-            unsafe {\n-                let channel = self.channel.take_unwrap();\n-                let data = self.data.take_unwrap();\n-                channel.send(false);\n-                cast::forget(data);\n-            }\n-        }\n-    }\n-}\n-\n-impl<T> ChannelAndDataGuard<T> {\n-    fn unwrap(mut self) -> (Chan<bool>, ~ArcData<T>) {\n-        (self.channel.take_unwrap(), self.data.take_unwrap())\n-    }\n-}\n-\n-impl<T: Send> UnsafeArc<T> {\n-    pub fn new(data: T) -> UnsafeArc<T> {\n-        unsafe { UnsafeArc { data: new_inner(data, 1) } }\n-    }\n-\n-    /// As new(), but returns an extra pre-cloned handle.\n-    pub fn new2(data: T) -> (UnsafeArc<T>, UnsafeArc<T>) {\n-        unsafe {\n-            let ptr = new_inner(data, 2);\n-            (UnsafeArc { data: ptr }, UnsafeArc { data: ptr })\n-        }\n-    }\n-\n-    /// As new(), but returns a vector of as many pre-cloned handles as requested.\n-    pub fn newN(data: T, num_handles: uint) -> ~[UnsafeArc<T>] {\n-        unsafe {\n-            if num_handles == 0 {\n-                ~[] // need to free data here\n-            } else {\n-                let ptr = new_inner(data, num_handles);\n-                vec::from_fn(num_handles, |_| UnsafeArc { data: ptr })\n-            }\n-        }\n-    }\n-\n-    /// As newN(), but from an already-existing handle. Uses one xadd.\n-    pub fn cloneN(self, num_handles: uint) -> ~[UnsafeArc<T>] {\n-        if num_handles == 0 {\n-            ~[] // The \"num_handles - 1\" trick (below) fails in the 0 case.\n-        } else {\n-            unsafe {\n-                // Minus one because we are recycling the given handle's refcount.\n-                let old_count = (*self.data).count.fetch_add(num_handles - 1, Acquire);\n-                // let old_count = (*self.data).count.fetch_add(num_handles, Acquire);\n-                assert!(old_count >= 1);\n-                let ptr = self.data;\n-                cast::forget(self); // Don't run the destructor on this handle.\n-                vec::from_fn(num_handles, |_| UnsafeArc { data: ptr })\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn get(&self) -> *mut T {\n-        unsafe {\n-            assert!((*self.data).count.load(Relaxed) > 0);\n-            let r: *mut T = (*self.data).data.get_mut_ref();\n-            return r;\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn get_immut(&self) -> *T {\n-        unsafe {\n-            assert!((*self.data).count.load(Relaxed) > 0);\n-            let r: *T = (*self.data).data.get_ref();\n-            return r;\n-        }\n-    }\n-\n-    /// Wait until all other handles are dropped, then retrieve the enclosed\n-    /// data. See extra::arc::Arc for specific semantics documentation.\n-    /// If called when the task is already unkillable, unwrap will unkillably\n-    /// block; otherwise, an unwrapping task can be killed by linked failure.\n-    pub fn unwrap(self) -> T {\n-        unsafe {\n-            let mut this = self;\n-            // The ~ dtor needs to run if this code succeeds.\n-            let mut data: ~ArcData<T> = cast::transmute(this.data);\n-            // Set up the unwrap protocol.\n-            let (p1,c1) = Chan::new(); // ()\n-            let (p2,c2) = Chan::new(); // bool\n-            // Try to put our server end in the unwrapper slot.\n-            // This needs no barrier -- it's protected by the release barrier on\n-            // the xadd, and the acquire+release barrier in the destructor's xadd.\n-            if data.unwrapper.fill(~(c1,p2), Relaxed).is_none() {\n-                // Got in. Tell this handle's destructor not to run (we are now it).\n-                this.data = ptr::mut_null();\n-                // Drop our own reference.\n-                let old_count = data.count.fetch_sub(1, Release);\n-                assert!(old_count >= 1);\n-                if old_count == 1 {\n-                    // We were the last owner. Can unwrap immediately.\n-                    // AtomicOption's destructor will free the server endpoint.\n-                    // FIXME(#3224): it should be like this\n-                    // let ~ArcData { data: user_data, _ } = data;\n-                    // user_data\n-                    data.data.take_unwrap()\n-                } else {\n-                    // The *next* person who sees the refcount hit 0 will wake us.\n-                    let c2_and_data = ChannelAndDataGuard {\n-                        channel: Some(c2),\n-                        data: Some(data),\n-                    };\n-                    p1.recv();\n-                    // Got here. Back in the 'unkillable' without getting killed.\n-                    let (c2, data) = c2_and_data.unwrap();\n-                    c2.send(true);\n-                    // FIXME(#3224): it should be like this\n-                    // let ~ArcData { data: user_data, _ } = data;\n-                    // user_data\n-                    let mut data = data;\n-                    data.data.take_unwrap()\n-                }\n-            } else {\n-                // If 'put' returns the server end back to us, we were rejected;\n-                // someone else was trying to unwrap. Avoid guaranteed deadlock.\n-                cast::forget(data);\n-                fail!(\"Another task is already unwrapping this Arc!\");\n-            }\n-        }\n-    }\n-\n-    /// As unwrap above, but without blocking. Returns 'UnsafeArcSelf(self)' if this is\n-    /// not the last reference; 'UnsafeArcT(unwrapped_data)' if so.\n-    pub fn try_unwrap(mut self) -> UnsafeArcUnwrap<T> {\n-        unsafe {\n-            // The ~ dtor needs to run if this code succeeds.\n-            let mut data: ~ArcData<T> = cast::transmute(self.data);\n-            // This can of course race with anybody else who has a handle, but in\n-            // such a case, the returned count will always be at least 2. If we\n-            // see 1, no race was possible. All that matters is 1 or not-1.\n-            let count = data.count.load(Acquire);\n-            assert!(count >= 1);\n-            // The more interesting race is one with an unwrapper. They may have\n-            // already dropped their count -- but if so, the unwrapper pointer\n-            // will have been set first, which the barriers ensure we will see.\n-            // (Note: using is_empty(), not take(), to not free the unwrapper.)\n-            if count == 1 && data.unwrapper.is_empty(Acquire) {\n-                // Tell this handle's destructor not to run (we are now it).\n-                self.data = ptr::mut_null();\n-                // FIXME(#3224) as above\n-                UnsafeArcT(data.data.take_unwrap())\n-            } else {\n-                cast::forget(data);\n-                UnsafeArcSelf(self)\n-            }\n-        }\n-    }\n-}\n-\n-impl<T: Send> Clone for UnsafeArc<T> {\n-    fn clone(&self) -> UnsafeArc<T> {\n-        unsafe {\n-            // This barrier might be unnecessary, but I'm not sure...\n-            let old_count = (*self.data).count.fetch_add(1, Acquire);\n-            assert!(old_count >= 1);\n-            return UnsafeArc { data: self.data };\n-        }\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<T> Drop for UnsafeArc<T>{\n-    fn drop(&mut self) {\n-        unsafe {\n-            // Happens when destructing an unwrapper's handle and from `#[unsafe_no_drop_flag]`\n-            if self.data.is_null() {\n-                return\n-            }\n-            let mut data: ~ArcData<T> = cast::transmute(self.data);\n-            // Must be acquire+release, not just release, to make sure this\n-            // doesn't get reordered to after the unwrapper pointer load.\n-            let old_count = data.count.fetch_sub(1, SeqCst);\n-            assert!(old_count >= 1);\n-            if old_count == 1 {\n-                // Were we really last, or should we hand off to an\n-                // unwrapper? It's safe to not xchg because the unwrapper\n-                // will set the unwrap lock *before* dropping his/her\n-                // reference. In effect, being here means we're the only\n-                // *awake* task with the data.\n-                match data.unwrapper.take(Acquire) {\n-                    Some(~(message, response)) => {\n-                        // Send 'ready' and wait for a response.\n-                        message.send(());\n-                        // Unkillable wait. Message guaranteed to come.\n-                        if response.recv() {\n-                            // Other task got the data.\n-                            cast::forget(data);\n-                        } else {\n-                            // Other task was killed. drop glue takes over.\n-                        }\n-                    }\n-                    None => {\n-                        // drop glue takes over.\n-                    }\n-                }\n-            } else {\n-                cast::forget(data);\n-            }\n-        }\n-    }\n-}\n-\n-\n-/****************************************************************************/\n-\n-pub struct AtomicGuard {\n-    on: bool,\n-}\n-\n-impl Drop for AtomicGuard {\n-    fn drop(&mut self) {\n-        use rt::task::{Task, GreenTask, SchedTask};\n-        use rt::local::Local;\n-\n-        if self.on {\n-            unsafe {\n-                let task_opt: Option<*mut Task> = Local::try_unsafe_borrow();\n-                match task_opt {\n-                    Some(t) => {\n-                        match (*t).task_type {\n-                            GreenTask(_) => (*t).death.allow_deschedule(),\n-                            SchedTask => {}\n-                        }\n-                    }\n-                    None => {}\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-/**\n- * Enables a runtime assertion that no operation while the returned guard is\n- * live uses scheduler operations (deschedule, recv, spawn, etc). This is for\n- * use with pthread mutexes, which may block the entire scheduler thread,\n- * rather than just one task, and is hence prone to deadlocks if mixed with\n- * descheduling.\n- *\n- * NOTE: THIS DOES NOT PROVIDE LOCKING, or any sort of critical-section\n- * synchronization whatsoever. It only makes sense to use for CPU-local issues.\n- */\n-// FIXME(#8140) should not be pub\n-pub unsafe fn atomic() -> AtomicGuard {\n-    use rt::task::{Task, GreenTask, SchedTask};\n-    use rt::local::Local;\n-\n-    let task_opt: Option<*mut Task> = Local::try_unsafe_borrow();\n-    match task_opt {\n-        Some(t) => {\n-            match (*t).task_type {\n-                GreenTask(_) => {\n-                    (*t).death.inhibit_deschedule();\n-                    return AtomicGuard {\n-                        on: true,\n-                    };\n-                }\n-                SchedTask => {}\n-            }\n-        }\n-        None => {}\n-    }\n-\n-    AtomicGuard {\n-        on: false,\n-    }\n-}\n+use ops::Drop;\n+use option::{Option,Some,None};\n+use sync::arc::UnsafeArc;\n+use unstable::mutex::Mutex;\n \n pub struct LittleLock {\n     priv l: Mutex,\n@@ -496,37 +155,14 @@ impl<T:Send> Exclusive<T> {\n             l.wait();\n         }\n     }\n-\n-    pub fn unwrap(self) -> T {\n-        let Exclusive { x: x } = self;\n-        // Someday we might need to unkillably unwrap an Exclusive, but not today.\n-        let inner = x.unwrap();\n-        let ExData { data: user_data, .. } = inner; // will destroy the LittleLock\n-        user_data\n-    }\n }\n \n #[cfg(test)]\n mod tests {\n     use option::*;\n     use prelude::*;\n-    use super::{Exclusive, UnsafeArc, atomic};\n+    use super::Exclusive;\n     use task;\n-    use mem::size_of;\n-\n-    //#[unsafe_no_drop_flag] FIXME: #9758\n-    #[ignore]\n-    #[test]\n-    fn test_size() {\n-        assert_eq!(size_of::<UnsafeArc<[int, ..10]>>(), size_of::<*[int, ..10]>());\n-    }\n-\n-    #[test]\n-    fn test_atomic() {\n-        // NB. The whole runtime will abort on an 'atomic-sleep' violation,\n-        // so we can't really test for the converse behaviour.\n-        unsafe { let _ = atomic(); } // oughtn't fail\n-    }\n \n     #[test]\n     fn exclusive_new_arc() {\n@@ -570,114 +206,4 @@ mod tests {\n             x.with(|one| assert_eq!(*one, 1));\n         }\n     }\n-\n-    #[test]\n-    fn arclike_newN() {\n-        // Tests that the many-refcounts-at-once constructors don't leak.\n-        let _ = UnsafeArc::new2(~~\"hello\");\n-        let x = UnsafeArc::newN(~~\"hello\", 0);\n-        assert_eq!(x.len(), 0)\n-        let x = UnsafeArc::newN(~~\"hello\", 1);\n-        assert_eq!(x.len(), 1)\n-        let x = UnsafeArc::newN(~~\"hello\", 10);\n-        assert_eq!(x.len(), 10)\n-    }\n-\n-    #[test]\n-    fn arclike_cloneN() {\n-        // Tests that the many-refcounts-at-once special-clone doesn't leak.\n-        let x = UnsafeArc::new(~~\"hello\");\n-        let x = x.cloneN(0);\n-        assert_eq!(x.len(), 0);\n-        let x = UnsafeArc::new(~~\"hello\");\n-        let x = x.cloneN(1);\n-        assert_eq!(x.len(), 1);\n-        let x = UnsafeArc::new(~~\"hello\");\n-        let x = x.cloneN(10);\n-        assert_eq!(x.len(), 10);\n-    }\n-\n-    #[test]\n-    fn arclike_unwrap_basic() {\n-        let x = UnsafeArc::new(~~\"hello\");\n-        assert!(x.unwrap() == ~~\"hello\");\n-    }\n-\n-    #[test]\n-    fn arclike_try_unwrap() {\n-        let x = UnsafeArc::new(~~\"hello\");\n-        assert!(x.try_unwrap().expect_t(\"try_unwrap failed\") == ~~\"hello\");\n-    }\n-\n-    #[test]\n-    fn arclike_try_unwrap_fail() {\n-        let x = UnsafeArc::new(~~\"hello\");\n-        let x2 = x.clone();\n-        let left_x = x.try_unwrap();\n-        assert!(left_x.is_self());\n-        drop(left_x);\n-        assert!(x2.try_unwrap().expect_t(\"try_unwrap none\") == ~~\"hello\");\n-    }\n-\n-    #[test]\n-    fn arclike_try_unwrap_unwrap_race() {\n-        // When an unwrap and a try_unwrap race, the unwrapper should always win.\n-        let x = UnsafeArc::new(~~\"hello\");\n-        let x2 = x.clone();\n-        let (p,c) = Chan::new();\n-        do task::spawn {\n-            c.send(());\n-            assert!(x2.unwrap() == ~~\"hello\");\n-            c.send(());\n-        }\n-        p.recv();\n-        task::deschedule(); // Try to make the unwrapper get blocked first.\n-        let left_x = x.try_unwrap();\n-        assert!(left_x.is_self());\n-        drop(left_x);\n-        p.recv();\n-    }\n-\n-    #[test]\n-    fn exclusive_new_unwrap_basic() {\n-        // Unlike the above, also tests no double-freeing of the LittleLock.\n-        let x = Exclusive::new(~~\"hello\");\n-        assert!(x.unwrap() == ~~\"hello\");\n-    }\n-\n-    #[test]\n-    fn exclusive_new_unwrap_contended() {\n-        let x = Exclusive::new(~~\"hello\");\n-        let x2 = x.clone();\n-        do task::spawn {\n-            unsafe { x2.with(|_hello| ()); }\n-            task::deschedule();\n-        }\n-        assert!(x.unwrap() == ~~\"hello\");\n-\n-        // Now try the same thing, but with the child task blocking.\n-        let x = Exclusive::new(~~\"hello\");\n-        let x2 = x.clone();\n-        let mut builder = task::task();\n-        let res = builder.future_result();\n-        do builder.spawn {\n-            assert!(x2.unwrap() == ~~\"hello\");\n-        }\n-        // Have to get rid of our reference before blocking.\n-        drop(x);\n-        res.recv();\n-    }\n-\n-    #[test] #[should_fail]\n-    fn exclusive_new_unwrap_conflict() {\n-        let x = Exclusive::new(~~\"hello\");\n-        let x2 = x.clone();\n-        let mut builder = task::task();\n-        let res = builder.future_result();\n-        do builder.spawn {\n-            assert!(x2.unwrap() == ~~\"hello\");\n-        }\n-        assert!(x.unwrap() == ~~\"hello\");\n-        assert!(res.recv().is_ok());\n-    }\n }"}, {"sha": "86f28c28f6977597f063a899c984fd8e90bae17c", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -2874,7 +2874,6 @@ impl<A> Extendable<A> for ~[A] {\n \n #[cfg(test)]\n mod tests {\n-    use option::{None, Some};\n     use mem;\n     use vec::*;\n     use cmp::*;"}, {"sha": "aa7e0d0eced8d3877618ae19fdc3d6b474a2d498", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -606,7 +606,6 @@ impl AstBuilder for @ExtCtxt {\n             ~[\n                 self.ident_of(\"std\"),\n                 self.ident_of(\"rt\"),\n-                self.ident_of(\"task\"),\n                 self.ident_of(\"begin_unwind\"),\n             ],\n             ~["}, {"sha": "2c2669e914cca9cce3d4cc2d3e578389e5092961", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -740,10 +740,10 @@ pub fn std_macros() -> @str {\n             fail!(\"explicit failure\")\n         );\n         ($msg:expr) => (\n-            ::std::rt::task::begin_unwind($msg, file!(), line!())\n+            ::std::rt::begin_unwind($msg, file!(), line!())\n         );\n         ($fmt:expr, $($arg:tt)*) => (\n-            ::std::rt::task::begin_unwind(format!($fmt, $($arg)*), file!(), line!())\n+            ::std::rt::begin_unwind(format!($fmt, $($arg)*), file!(), line!())\n         )\n     )\n "}, {"sha": "6eef71622c5c6232b656d13dc142e295e9af278e", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -1,4 +1,3 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -12,7 +11,6 @@ extern mod extra;\n \n use std::os;\n use std::uint;\n-use std::rt::test::spawntask_later;\n \n // This is a simple bench that creates M pairs of of tasks. These\n // tasks ping-pong back and forth over a pair of streams. This is a\n@@ -28,7 +26,7 @@ fn ping_pong_bench(n: uint, m: uint) {\n         // Create a stream B->A\n         let (pb,cb) = Chan::<()>::new();\n \n-        do spawntask_later() || {\n+        do spawn() || {\n             let chan = ca;\n             let port = pb;\n             n.times(|| {\n@@ -37,7 +35,7 @@ fn ping_pong_bench(n: uint, m: uint) {\n             })\n         }\n \n-        do spawntask_later() || {\n+        do spawn() || {\n             let chan = cb;\n             let port = pa;\n             n.times(|| {"}, {"sha": "6e3c42f2a4dea031194717995a7cfd31e626f7ae", "filename": "src/test/bench/rt-parfib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Fbench%2Frt-parfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Fbench%2Frt-parfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-parfib.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -12,7 +12,6 @@ extern mod extra;\n \n use std::os;\n use std::uint;\n-use std::rt::test::spawntask_later;\n \n // A simple implementation of parfib. One subtree is found in a new\n // task and communicated over a oneshot pipe, the other is found\n@@ -24,7 +23,7 @@ fn parfib(n: uint) -> uint {\n     }\n \n     let (port,chan) = Chan::new();\n-    do spawntask_later {\n+    do spawn {\n         chan.send(parfib(n-1));\n     };\n     let m2 = parfib(n-2);"}, {"sha": "8174347e3869e1fb38ee14ca546df91e4c3d8fc1", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test arcs no longer unwrap\n+\n extern mod extra;\n \n use std::from_str::FromStr;"}, {"sha": "57c66974fcd01f8f1db9bd48c604d6db283c971b", "filename": "src/test/compile-fail/std-uncopyable-atomics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -12,7 +12,7 @@\n \n #[feature(globs)];\n \n-use std::unstable::atomics::*;\n+use std::sync::atomics::*;\n use std::ptr;\n \n fn main() {"}, {"sha": "7f466573da73087c0b72de342dd54fdadde6cdb4", "filename": "src/test/run-make/bootstrap-from-c-with-green/Makefile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2FMakefile?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "previous_filename": "src/test/run-make/bootstrap-from-c-with-uvio/Makefile"}, {"sha": "9a03c772f3a3fef5d713d6af26754e0fc2de8e5c", "filename": "src/test/run-make/bootstrap-from-c-with-green/lib.rs", "status": "renamed", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Flib.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -8,14 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-fast\n+#[crate_id=\"boot#0.1\"];\n+#[crate_type=\"lib\"];\n+#[no_uv];\n \n-#[start]\n-fn start(argc: int, argv: **u8) -> int {\n-    do std::rt::start_on_main_thread(argc, argv) {\n-        info!(\"running on main thread\");\n+extern mod rustuv;\n+extern mod green;\n+\n+#[no_mangle] // this needs to get called from C\n+pub extern \"C\" fn foo(argc: int, argv: **u8) -> int {\n+    do green::start(argc, argv) {\n         do spawn {\n-            info!(\"running on another thread\");\n+            println!(\"hello\");\n         }\n     }\n }", "previous_filename": "src/test/run-pass/rt-start-main-thread.rs"}, {"sha": "1872c1ea43b1139cfaf90e728d6f11d8c07c2c52", "filename": "src/test/run-make/bootstrap-from-c-with-green/main.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Fmain.c", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Fmain.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Fmain.c?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "previous_filename": "src/test/run-make/bootstrap-from-c-with-uvio/main.c"}, {"sha": "7f466573da73087c0b72de342dd54fdadde6cdb4", "filename": "src/test/run-make/bootstrap-from-c-with-native/Makefile", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2FMakefile?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -0,0 +1,9 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) lib.rs -Z gen-crate-map\n+\tln -nsf $(call DYLIB,boot-*) $(call DYLIB,boot)\n+\t$(CC) main.c -o $(call RUN,main) -lboot -Wl,-rpath,$(TMPDIR)\n+\t$(call RUN,main)\n+\trm $(call DYLIB,boot)\n+\t$(call FAIL,main)"}, {"sha": "d0639d45fa569895aa16f02f8f8c9f7a34803a95", "filename": "src/test/run-make/bootstrap-from-c-with-native/lib.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -10,14 +10,13 @@\n \n #[crate_id=\"boot#0.1\"];\n #[crate_type=\"lib\"];\n+#[no_uv];\n \n-extern mod rustuv; // pull in uvio\n-\n-use std::rt;\n+extern mod native;\n \n #[no_mangle] // this needs to get called from C\n pub extern \"C\" fn foo(argc: int, argv: **u8) -> int {\n-    do rt::start(argc, argv) {\n+    do native::start(argc, argv) {\n         do spawn {\n             println!(\"hello\");\n         }", "previous_filename": "src/test/run-make/bootstrap-from-c-with-uvio/lib.rs"}, {"sha": "1872c1ea43b1139cfaf90e728d6f11d8c07c2c52", "filename": "src/test/run-make/bootstrap-from-c-with-native/main.c", "status": "renamed", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Fmain.c", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Fmain.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Fmain.c?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-fast\n+// this is the rust entry point that we're going to call.\n+int foo(int argc, char *argv[]);\n \n-#[no_uv];\n-\n-fn main() {\n-    println!(\"hello\");\n+int main(int argc, char *argv[]) {\n+  return foo(argc, argv);\n }", "previous_filename": "src/test/run-pass/native-print-no-uv.rs"}, {"sha": "6e3d9629da043b88befd8963236c86181a63171b", "filename": "src/test/run-pass/core-rt-smoke.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Ftest%2Frun-pass%2Fcore-rt-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d975060de6c944ca12ce5205fbc9fc7726948ae1/src%2Ftest%2Frun-pass%2Fcore-rt-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-rt-smoke.rs?ref=d975060de6c944ca12ce5205fbc9fc7726948ae1", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-fast\n-\n-// A simple test of starting the runtime manually\n-\n-#[start]\n-fn start(argc: int, argv: **u8) -> int {\n-    do std::rt::start(argc, argv) {\n-        info!(\"creating my own runtime is joy\");\n-    }\n-}"}, {"sha": "f8094f9fdb9e87abb42bd51a93f02db9019bf7d4", "filename": "src/test/run-pass/spawning-with-debug.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Frun-pass%2Fspawning-with-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Frun-pass%2Fspawning-with-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawning-with-debug.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -17,6 +17,5 @@ use std::task;\n \n fn main() {\n     let mut t = task::task();\n-    t.sched_mode(task::SingleThreaded);\n     t.spawn(proc() ());\n }"}, {"sha": "013487e5803813ff18ebf925cd9ad72a589cb62c", "filename": "src/test/run-pass/use.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Frun-pass%2Fuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec/src%2Ftest%2Frun-pass%2Fuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuse.rs?ref=9477c49a7b4eec2c2a3e0d9a28c4129e3d1fa6ec", "patch": "@@ -10,6 +10,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-fast\n+\n #[allow(unused_imports)];\n \n #[no_std];\n@@ -25,4 +27,5 @@ mod baz {\n     pub use x = std::str;\n }\n \n-pub fn main() { }\n+#[start]\n+pub fn start(_: int, _: **u8) -> int { 0 }"}]}