{"sha": "ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkZmJmMmIwZjQ3MjZmMTFiYzhlODU3Mjc0YWUxYTBmODM0M2E3M2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-01T21:14:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-01T21:14:35Z"}, "message": "Auto merge of #47861 - sgrif:sg-rebase-chalkify-universe-refactorings, r=nikomatsakis\n\nRebased refactorings for Chalk\n\nThe code is Niko's, I just handled the rebase.\n\nr? @nikomatsakis", "tree": {"sha": "76f70a510dc79c8d3fca5d6c941dcc6a7bffb2be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76f70a510dc79c8d3fca5d6c941dcc6a7bffb2be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "html_url": "https://github.com/rust-lang/rust/commit/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3eeb5a665e313c5b281820099e04d4c6c8188b46", "url": "https://api.github.com/repos/rust-lang/rust/commits/3eeb5a665e313c5b281820099e04d4c6c8188b46", "html_url": "https://github.com/rust-lang/rust/commit/3eeb5a665e313c5b281820099e04d4c6c8188b46"}, {"sha": "fec4d3b71161aa7b2861861cbf9b708c8c393b30", "url": "https://api.github.com/repos/rust-lang/rust/commits/fec4d3b71161aa7b2861861cbf9b708c8c393b30", "html_url": "https://github.com/rust-lang/rust/commit/fec4d3b71161aa7b2861861cbf9b708c8c393b30"}], "stats": {"total": 1975, "additions": 660, "deletions": 1315}, "files": [{"sha": "2cc647c49c6270f1d44d93ea7c9d415b47a4905c", "filename": "src/Cargo.lock", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -598,6 +598,14 @@ name = \"either\"\n version = \"1.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"ena\"\n+version = \"0.9.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"endian-type\"\n version = \"0.1.2\"\n@@ -1866,6 +1874,7 @@ name = \"rustc_data_structures\"\n version = \"0.0.0\"\n dependencies = [\n  \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ena 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot_core 0.2.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2861,6 +2870,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum dtoa 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"09c3753c3db574d215cba4ea76018483895d7bff25a31b49ba45db21c48e50ab\"\n \"checksum duct 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e45aa15fe0a8a8f511e6d834626afd55e49b62e5c8802e18328a87e8a8f6065c\"\n \"checksum either 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"740178ddf48b1a9e878e6d6509a1442a2d42fd2928aae8e7a6f8a36fb01981b3\"\n+\"checksum ena 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1733e41a3c37b0893685933d09dcb0c30269aa5d14dc5cafebf4bcded1e58225\"\n \"checksum endian-type 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c34f04666d835ff5d62e058c3995147c06f42fe86ff053337632bca83e42702d\"\n \"checksum enum_primitive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"be4551092f4d519593039259a9ed8daedf0da12e5109c5280338073eaeb81180\"\n \"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\""}, {"sha": "7b2cfa0a3ffecb2dd3ab3afed077d6ae5f88c9ce", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -870,6 +870,7 @@ for ty::steal::Steal<T>\n \n impl_stable_hash_for!(struct ty::ParamEnv<'tcx> {\n     caller_bounds,\n+    universe,\n     reveal\n });\n \n@@ -1039,3 +1040,12 @@ for traits::VtableGeneratorData<'gcx, N> where N: HashStable<StableHashingContex\n         nested.hash_stable(hcx, hasher);\n     }\n }\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+for ty::UniverseIndex {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.depth().hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "eb26f0c1188bf639bf8c0b31aa40a8c85e7cdf40", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -600,7 +600,8 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n             return anon_defn.concrete_ty;\n         }\n         let span = tcx.def_span(def_id);\n-        let ty_var = infcx.next_ty_var(TypeVariableOrigin::TypeInference(span));\n+        let ty_var = infcx.next_ty_var(ty::UniverseIndex::ROOT,\n+                                       TypeVariableOrigin::TypeInference(span));\n \n         let predicates_of = tcx.predicates_of(def_id);\n         let bounds = predicates_of.instantiate(tcx, substs);"}, {"sha": "469cb4591124e1b68c994fd483f62c19758f1c58", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -34,10 +34,10 @@\n \n use super::equate::Equate;\n use super::glb::Glb;\n+use super::{InferCtxt, MiscVariable, TypeTrace};\n use super::lub::Lub;\n use super::sub::Sub;\n-use super::InferCtxt;\n-use super::{MiscVariable, TypeTrace};\n+use super::type_variable::TypeVariableValue;\n \n use hir::def_id::DefId;\n use ty::{IntType, UintType};\n@@ -132,7 +132,7 @@ impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n     {\n         self.int_unification_table\n             .borrow_mut()\n-            .unify_var_value(vid, val)\n+            .unify_var_value(vid, Some(val))\n             .map_err(|e| int_unification_error(vid_is_expected, e))?;\n         match val {\n             IntType(v) => Ok(self.tcx.mk_mach_int(v)),\n@@ -148,7 +148,7 @@ impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n     {\n         self.float_unification_table\n             .borrow_mut()\n-            .unify_var_value(vid, val)\n+            .unify_var_value(vid, Some(ty::FloatVarValue(val)))\n             .map_err(|e| float_unification_error(vid_is_expected, e))?;\n         Ok(self.tcx.mk_mach_float(val))\n     }\n@@ -194,7 +194,7 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n         use self::RelationDir::*;\n \n         // Get the actual variable that b_vid has been inferred to\n-        debug_assert!(self.infcx.type_variables.borrow_mut().probe(b_vid).is_none());\n+        debug_assert!(self.infcx.type_variables.borrow_mut().probe(b_vid).is_unknown());\n \n         debug!(\"instantiate(a_ty={:?} dir={:?} b_vid={:?})\", a_ty, dir, b_vid);\n \n@@ -402,12 +402,12 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                     // `vid` are related via subtyping.\n                     return Err(TypeError::CyclicTy(self.root_ty));\n                 } else {\n-                    match variables.probe_root(vid) {\n-                        Some(u) => {\n+                    match variables.probe(vid) {\n+                        TypeVariableValue::Known { value: u } => {\n                             drop(variables);\n                             self.relate(&u, &u)\n                         }\n-                        None => {\n+                        TypeVariableValue::Unknown { universe } => {\n                             match self.ambient_variance {\n                                 // Invariant: no need to make a fresh type variable.\n                                 ty::Invariant => return Ok(t),\n@@ -423,8 +423,8 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                                 ty::Covariant | ty::Contravariant => (),\n                             }\n \n-                            let origin = variables.origin(vid);\n-                            let new_var_id = variables.new_var(false, origin, None);\n+                            let origin = *variables.var_origin(vid);\n+                            let new_var_id = variables.new_var(universe, false, origin);\n                             let u = self.tcx().mk_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\",\n                                    vid, u);\n@@ -518,9 +518,9 @@ fn int_unification_error<'tcx>(a_is_expected: bool, v: (ty::IntVarValue, ty::Int\n }\n \n fn float_unification_error<'tcx>(a_is_expected: bool,\n-                                 v: (ast::FloatTy, ast::FloatTy))\n+                                 v: (ty::FloatVarValue, ty::FloatVarValue))\n                                  -> TypeError<'tcx>\n {\n-    let (a, b) = v;\n+    let (ty::FloatVarValue(a), ty::FloatVarValue(b)) = v;\n     TypeError::FloatMismatch(ty::relate::expected_found_bool(a_is_expected, &a, &b))\n }"}, {"sha": "ee0921f4b07ae6487b7675c666f0917f05245992", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n \n         match t.sty {\n             ty::TyInfer(ty::TyVar(v)) => {\n-                let opt_ty = self.infcx.type_variables.borrow_mut().probe(v);\n+                let opt_ty = self.infcx.type_variables.borrow_mut().probe(v).known();\n                 self.freshen(\n                     opt_ty,\n                     ty::TyVar(v),\n@@ -143,7 +143,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::TyInfer(ty::IntVar(v)) => {\n                 self.freshen(\n                     self.infcx.int_unification_table.borrow_mut()\n-                                                    .probe(v)\n+                                                    .probe_value(v)\n                                                     .map(|v| v.to_type(tcx)),\n                     ty::IntVar(v),\n                     ty::FreshIntTy)\n@@ -152,7 +152,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::TyInfer(ty::FloatVar(v)) => {\n                 self.freshen(\n                     self.infcx.float_unification_table.borrow_mut()\n-                                                      .probe(v)\n+                                                      .probe_value(v)\n                                                       .map(|v| v.to_type(tcx)),\n                     ty::FloatVar(v),\n                     ty::FreshFloatTy)"}, {"sha": "48eb253415cdf07172abb3e66a6575fdac7f9eb9", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -131,15 +131,21 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFudger<'a, 'gcx, 'tcx> {\n                         // variables to their binding anyhow, we know\n                         // that it is unbound, so we can just return\n                         // it.\n-                        debug_assert!(self.infcx.type_variables.borrow_mut().probe(vid).is_none());\n+                        debug_assert!(self.infcx.type_variables.borrow_mut()\n+                                      .probe(vid)\n+                                      .is_unknown());\n                         ty\n                     }\n \n                     Some(&origin) => {\n                         // This variable was created during the\n                         // fudging. Recreate it with a fresh variable\n                         // here.\n-                        self.infcx.next_ty_var(origin)\n+                        //\n+                        // The ROOT universe is fine because we only\n+                        // ever invoke this routine at the\n+                        // \"item-level\" of inference.\n+                        self.infcx.next_ty_var(ty::UniverseIndex::ROOT, origin)\n                     }\n                 }\n             }"}, {"sha": "a317e0699b4bba29e755138815ef2036b24fcbd6", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -244,7 +244,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n         fn generalize_region<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                              span: Span,\n-                                             snapshot: &CombinedSnapshot,\n+                                             snapshot: &CombinedSnapshot<'a, 'tcx>,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n                                              a_map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>,\n@@ -340,7 +340,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n         fn generalize_region<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                              span: Span,\n-                                             snapshot: &CombinedSnapshot,\n+                                             snapshot: &CombinedSnapshot<'a, 'tcx>,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n                                              a_map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>,\n@@ -479,7 +479,7 @@ fn fold_regions_in<'a, 'gcx, 'tcx, T, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn tainted_regions(&self,\n-                       snapshot: &CombinedSnapshot,\n+                       snapshot: &CombinedSnapshot<'a, 'tcx>,\n                        r: ty::Region<'tcx>,\n                        directions: TaintDirections)\n                        -> FxHashSet<ty::Region<'tcx>> {\n@@ -491,7 +491,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn region_vars_confined_to_snapshot(&self,\n-                                        snapshot: &CombinedSnapshot)\n+                                        snapshot: &CombinedSnapshot<'a, 'tcx>)\n                                         -> Vec<ty::RegionVid>\n     {\n         /*!\n@@ -583,7 +583,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// See `README.md` for more details.\n     pub fn skolemize_late_bound_regions<T>(&self,\n                                            binder: &ty::Binder<T>,\n-                                           snapshot: &CombinedSnapshot)\n+                                           snapshot: &CombinedSnapshot<'a, 'tcx>)\n                                            -> (T, SkolemizationMap<'tcx>)\n         where T : TypeFoldable<'tcx>\n     {\n@@ -609,7 +609,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                       overly_polymorphic: bool,\n                       _span: Span,\n                       skol_map: &SkolemizationMap<'tcx>,\n-                      snapshot: &CombinedSnapshot)\n+                      snapshot: &CombinedSnapshot<'a, 'tcx>)\n                       -> RelateResult<'tcx, ()>\n     {\n         debug!(\"leak_check: skol_map={:?}\",\n@@ -684,7 +684,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// predicate is `for<'a> &'a int : Clone`.\n     pub fn plug_leaks<T>(&self,\n                          skol_map: SkolemizationMap<'tcx>,\n-                         snapshot: &CombinedSnapshot,\n+                         snapshot: &CombinedSnapshot<'a, 'tcx>,\n                          value: T) -> T\n         where T : TypeFoldable<'tcx>\n     {\n@@ -770,8 +770,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Note: popping also occurs implicitly as part of `leak_check`.\n     pub fn pop_skolemized(&self,\n                           skol_map: SkolemizationMap<'tcx>,\n-                          snapshot: &CombinedSnapshot)\n-    {\n+                          snapshot: &CombinedSnapshot<'a, 'tcx>) {\n         debug!(\"pop_skolemized({:?})\", skol_map);\n         let skol_regions: FxHashSet<_> = skol_map.values().cloned().collect();\n         self.borrow_region_constraints()"}, {"sha": "c4722f9a7f96cb39d86cdbbad25092baceeb2133", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -70,14 +70,6 @@ pub fn super_lattice_tys<'a, 'gcx, 'tcx, L>(this: &mut L,\n     let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n     let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n     match (&a.sty, &b.sty) {\n-        (&ty::TyInfer(TyVar(..)), &ty::TyInfer(TyVar(..)))\n-            if infcx.type_var_diverges(a) && infcx.type_var_diverges(b) => {\n-            let v = infcx.next_diverging_ty_var(\n-                TypeVariableOrigin::LatticeVariable(this.cause().span));\n-            this.relate_bound(v, a, b)?;\n-            Ok(v)\n-        }\n-\n         // If one side is known to be a variable and one is not,\n         // create a variable (`v`) to represent the LUB. Make sure to\n         // relate `v` to the non-type-variable first (by passing it\n@@ -96,13 +88,17 @@ pub fn super_lattice_tys<'a, 'gcx, 'tcx, L>(this: &mut L,\n         // is (e.g.) `Box<i32>`. A more obvious solution might be to\n         // iterate on the subtype obligations that are returned, but I\n         // think this suffices. -nmatsakis\n-        (&ty::TyInfer(TyVar(..)), _) => {\n-            let v = infcx.next_ty_var(TypeVariableOrigin::LatticeVariable(this.cause().span));\n+        (&ty::TyInfer(TyVar(a_vid)), _) => {\n+            let universe = infcx.type_variables.borrow_mut().probe(a_vid).universe().unwrap();\n+            let v = infcx.next_ty_var(universe,\n+                                      TypeVariableOrigin::LatticeVariable(this.cause().span));\n             this.relate_bound(v, b, a)?;\n             Ok(v)\n         }\n-        (_, &ty::TyInfer(TyVar(..))) => {\n-            let v = infcx.next_ty_var(TypeVariableOrigin::LatticeVariable(this.cause().span));\n+        (_, &ty::TyInfer(TyVar(b_vid))) => {\n+            let universe = infcx.type_variables.borrow_mut().probe(b_vid).universe().unwrap();\n+            let v = infcx.next_ty_var(universe,\n+                                      TypeVariableOrigin::LatticeVariable(this.cause().span));\n             this.relate_bound(v, a, b)?;\n             Ok(v)\n         }"}, {"sha": "402cb6a8fef43622f5284928c30234022b940cbd", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 68, "deletions": 104, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -22,14 +22,14 @@ use middle::free_region::RegionRelations;\n use middle::region;\n use middle::lang_items;\n use mir::tcx::PlaceTy;\n-use ty::subst::{Kind, Subst, Substs};\n+use ty::subst::Substs;\n use ty::{TyVid, IntVid, FloatVid};\n use ty::{self, Ty, TyCtxt};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use ty::relate::RelateResult;\n use traits::{self, ObligationCause, PredicateObligations, Reveal};\n-use rustc_data_structures::unify::{self, UnificationTable};\n+use rustc_data_structures::unify as ut;\n use std::cell::{Cell, RefCell, Ref, RefMut};\n use std::collections::BTreeMap;\n use std::fmt;\n@@ -99,10 +99,10 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n \n     // Map from integral variable to the kind of integer it represents\n-    int_unification_table: RefCell<UnificationTable<ty::IntVid>>,\n+    int_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::IntVid>>>,\n \n     // Map from floating variable to the kind of float it represents\n-    float_unification_table: RefCell<UnificationTable<ty::FloatVid>>,\n+    float_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::FloatVid>>>,\n \n     // Tracks the set of region variables and the constraints between\n     // them.  This is initially `Some(_)` but when\n@@ -441,8 +441,8 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             in_progress_tables,\n             projection_cache: RefCell::new(traits::ProjectionCache::new()),\n             type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n-            int_unification_table: RefCell::new(UnificationTable::new()),\n-            float_unification_table: RefCell::new(UnificationTable::new()),\n+            int_unification_table: RefCell::new(ut::UnificationTable::new()),\n+            float_unification_table: RefCell::new(ut::UnificationTable::new()),\n             region_constraints: RefCell::new(Some(RegionConstraintCollector::new())),\n             lexical_region_resolutions: RefCell::new(None),\n             selection_cache: traits::SelectionCache::new(),\n@@ -475,9 +475,9 @@ impl<'tcx, T> InferOk<'tcx, T> {\n #[must_use = \"once you start a snapshot, you should always consume it\"]\n pub struct CombinedSnapshot<'a, 'tcx:'a> {\n     projection_cache_snapshot: traits::ProjectionCacheSnapshot,\n-    type_snapshot: type_variable::Snapshot,\n-    int_snapshot: unify::Snapshot<ty::IntVid>,\n-    float_snapshot: unify::Snapshot<ty::FloatVid>,\n+    type_snapshot: type_variable::Snapshot<'tcx>,\n+    int_snapshot: ut::Snapshot<ut::InPlace<ty::IntVid>>,\n+    float_snapshot: ut::Snapshot<ut::InPlace<ty::FloatVid>>,\n     region_constraints_snapshot: RegionSnapshot,\n     region_obligations_snapshot: usize,\n     was_in_snapshot: bool,\n@@ -678,14 +678,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         use ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n         match ty.sty {\n             ty::TyInfer(ty::IntVar(vid)) => {\n-                if self.int_unification_table.borrow_mut().has_value(vid) {\n+                if self.int_unification_table.borrow_mut().probe_value(vid).is_some() {\n                     Neither\n                 } else {\n                     UnconstrainedInt\n                 }\n             },\n             ty::TyInfer(ty::FloatVar(vid)) => {\n-                if self.float_unification_table.borrow_mut().has_value(vid) {\n+                if self.float_unification_table.borrow_mut().probe_value(vid).is_some() {\n                     Neither\n                 } else {\n                     UnconstrainedFloat\n@@ -695,46 +695,35 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Returns a type variable's default fallback if any exists. A default\n-    /// must be attached to the variable when created, if it is created\n-    /// without a default, this will return None.\n-    ///\n-    /// This code does not apply to integral or floating point variables,\n-    /// only to use declared defaults.\n-    ///\n-    /// See `new_ty_var_with_default` to create a type variable with a default.\n-    /// See `type_variable::Default` for details about what a default entails.\n-    pub fn default(&self, ty: Ty<'tcx>) -> Option<type_variable::Default<'tcx>> {\n-        match ty.sty {\n-            ty::TyInfer(ty::TyVar(vid)) => self.type_variables.borrow().default(vid),\n-            _ => None\n-        }\n-    }\n-\n     pub fn unsolved_variables(&self) -> Vec<Ty<'tcx>> {\n         let mut variables = Vec::new();\n \n-        let unbound_ty_vars = self.type_variables\n-                                  .borrow_mut()\n-                                  .unsolved_variables()\n-                                  .into_iter()\n-                                  .map(|t| self.tcx.mk_var(t));\n-\n-        let unbound_int_vars = self.int_unification_table\n-                                   .borrow_mut()\n-                                   .unsolved_variables()\n-                                   .into_iter()\n-                                   .map(|v| self.tcx.mk_int_var(v));\n+        {\n+            let mut type_variables = self.type_variables.borrow_mut();\n+            variables.extend(\n+                type_variables\n+                    .unsolved_variables()\n+                    .into_iter()\n+                    .map(|t| self.tcx.mk_var(t)));\n+        }\n \n-        let unbound_float_vars = self.float_unification_table\n-                                     .borrow_mut()\n-                                     .unsolved_variables()\n-                                     .into_iter()\n-                                     .map(|v| self.tcx.mk_float_var(v));\n+        {\n+            let mut int_unification_table = self.int_unification_table.borrow_mut();\n+            variables.extend(\n+                (0..int_unification_table.len())\n+                    .map(|i| ty::IntVid { index: i as u32 })\n+                    .filter(|&vid| int_unification_table.probe_value(vid).is_none())\n+                    .map(|v| self.tcx.mk_int_var(v)));\n+        }\n \n-        variables.extend(unbound_ty_vars);\n-        variables.extend(unbound_int_vars);\n-        variables.extend(unbound_float_vars);\n+        {\n+            let mut float_unification_table = self.float_unification_table.borrow_mut();\n+            variables.extend(\n+                (0..float_unification_table.len())\n+                    .map(|i| ty::FloatVid { index: i as u32 })\n+                    .filter(|&vid| float_unification_table.probe_value(vid).is_none())\n+                    .map(|v| self.tcx.mk_float_var(v)));\n+        }\n \n         return variables;\n     }\n@@ -776,7 +765,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         result\n     }\n \n-    fn start_snapshot<'b>(&'b self) -> CombinedSnapshot<'b, 'tcx> {\n+    fn start_snapshot(&self) -> CombinedSnapshot<'a, 'tcx> {\n         debug!(\"start_snapshot()\");\n \n         let in_snapshot = self.in_snapshot.get();\n@@ -798,7 +787,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn rollback_to(&self, cause: &str, snapshot: CombinedSnapshot) {\n+    fn rollback_to(&self, cause: &str, snapshot: CombinedSnapshot<'a, 'tcx>) {\n         debug!(\"rollback_to(cause={})\", cause);\n         let CombinedSnapshot { projection_cache_snapshot,\n                                type_snapshot,\n@@ -830,7 +819,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .rollback_to(region_constraints_snapshot);\n     }\n \n-    fn commit_from(&self, snapshot: CombinedSnapshot) {\n+    fn commit_from(&self, snapshot: CombinedSnapshot<'a, 'tcx>) {\n         debug!(\"commit_from()\");\n         let CombinedSnapshot { projection_cache_snapshot,\n                                type_snapshot,\n@@ -872,7 +861,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Execute `f` and commit the bindings if closure `f` returns `Ok(_)`\n     pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E> where\n-        F: FnOnce(&CombinedSnapshot) -> Result<T, E>\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> Result<T, E>\n     {\n         debug!(\"commit_if_ok()\");\n         let snapshot = self.start_snapshot();\n@@ -887,7 +876,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     // Execute `f` in a snapshot, and commit the bindings it creates\n     pub fn in_snapshot<T, F>(&self, f: F) -> T where\n-        F: FnOnce(&CombinedSnapshot) -> T\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> T\n     {\n         debug!(\"in_snapshot()\");\n         let snapshot = self.start_snapshot();\n@@ -898,7 +887,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Execute `f` then unroll any bindings it creates\n     pub fn probe<R, F>(&self, f: F) -> R where\n-        F: FnOnce(&CombinedSnapshot) -> R,\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n     {\n         debug!(\"probe()\");\n         let snapshot = self.start_snapshot();\n@@ -1026,18 +1015,25 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n+    pub fn next_ty_var_id(&self,\n+                          universe: ty::UniverseIndex,\n+                          diverging: bool,\n+                          origin: TypeVariableOrigin)\n+                          -> TyVid {\n         self.type_variables\n             .borrow_mut()\n-            .new_var(diverging, origin, None)\n+            .new_var(universe, diverging, origin)\n     }\n \n-    pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_var(self.next_ty_var_id(false, origin))\n+    pub fn next_ty_var(&self, universe: ty::UniverseIndex, origin: TypeVariableOrigin) -> Ty<'tcx> {\n+        self.tcx.mk_var(self.next_ty_var_id(universe, false, origin))\n     }\n \n-    pub fn next_diverging_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_var(self.next_ty_var_id(true, origin))\n+    pub fn next_diverging_ty_var(&self,\n+                                 universe: ty::UniverseIndex,\n+                                 origin: TypeVariableOrigin)\n+                                 -> Ty<'tcx> {\n+        self.tcx.mk_var(self.next_ty_var_id(universe, true, origin))\n     }\n \n     pub fn next_int_var_id(&self) -> IntVid {\n@@ -1092,41 +1088,30 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// use an inference variable for `C` with `[T, U]`\n     /// as the substitutions for the default, `(T, U)`.\n     pub fn type_var_for_def(&self,\n+                            universe: ty::UniverseIndex,\n                             span: Span,\n-                            def: &ty::TypeParameterDef,\n-                            substs: &[Kind<'tcx>])\n+                            def: &ty::TypeParameterDef)\n                             -> Ty<'tcx> {\n-        let default = if def.has_default {\n-            let default = self.tcx.type_of(def.def_id);\n-            Some(type_variable::Default {\n-                ty: default.subst_spanned(self.tcx, substs, Some(span)),\n-                origin_span: span,\n-                def_id: def.def_id\n-            })\n-        } else {\n-            None\n-        };\n-\n-\n         let ty_var_id = self.type_variables\n                             .borrow_mut()\n-                            .new_var(false,\n-                                     TypeVariableOrigin::TypeParameterDefinition(span, def.name),\n-                                     default);\n+                            .new_var(universe,\n+                                     false,\n+                                     TypeVariableOrigin::TypeParameterDefinition(span, def.name));\n \n         self.tcx.mk_var(ty_var_id)\n     }\n \n     /// Given a set of generics defined on a type or impl, returns a substitution mapping each\n     /// type/region parameter to a fresh inference variable.\n     pub fn fresh_substs_for_item(&self,\n+                                 universe: ty::UniverseIndex,\n                                  span: Span,\n                                  def_id: DefId)\n                                  -> &'tcx Substs<'tcx> {\n         Substs::for_item(self.tcx, def_id, |def, _| {\n             self.region_var_for_def(span, def)\n-        }, |def, substs| {\n-            self.type_var_for_def(span, def, substs)\n+        }, |def, _| {\n+            self.type_var_for_def(universe, span, def)\n         })\n     }\n \n@@ -1284,23 +1269,24 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // so this recursion should always be of very limited\n                 // depth.\n                 self.type_variables.borrow_mut()\n-                    .probe(v)\n-                    .map(|t| self.shallow_resolve(t))\n-                    .unwrap_or(typ)\n+                                   .probe(v)\n+                                   .known()\n+                                   .map(|t| self.shallow_resolve(t))\n+                                   .unwrap_or(typ)\n             }\n \n             ty::TyInfer(ty::IntVar(v)) => {\n                 self.int_unification_table\n                     .borrow_mut()\n-                    .probe(v)\n+                    .probe_value(v)\n                     .map(|v| v.to_type(self.tcx))\n                     .unwrap_or(typ)\n             }\n \n             ty::TyInfer(ty::FloatVar(v)) => {\n                 self.float_unification_table\n                     .borrow_mut()\n-                    .probe(v)\n+                    .probe_value(v)\n                     .map(|v| v.to_type(self.tcx))\n                     .unwrap_or(typ)\n             }\n@@ -1402,28 +1388,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.report_and_explain_type_error(trace, &err)\n     }\n \n-    pub fn report_conflicting_default_types(&self,\n-                                            span: Span,\n-                                            body_id: ast::NodeId,\n-                                            expected: type_variable::Default<'tcx>,\n-                                            actual: type_variable::Default<'tcx>) {\n-        let trace = TypeTrace {\n-            cause: ObligationCause::misc(span, body_id),\n-            values: Types(ExpectedFound {\n-                expected: expected.ty,\n-                found: actual.ty\n-            })\n-        };\n-\n-        self.report_and_explain_type_error(\n-            trace,\n-            &TypeError::TyParamDefaultMismatch(ExpectedFound {\n-                expected,\n-                found: actual\n-            }))\n-            .emit();\n-    }\n-\n     pub fn replace_late_bound_regions_with_fresh_var<T>(\n         &self,\n         span: Span,"}, {"sha": "4a75037aa50354ebdc3cdc895695ac3316c9c77a", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -18,7 +18,7 @@ use super::unify_key;\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::unify::{self, UnificationTable};\n+use rustc_data_structures::unify as ut;\n use ty::{self, Ty, TyCtxt};\n use ty::{Region, RegionVid};\n use ty::ReStatic;\n@@ -48,7 +48,7 @@ pub struct RegionConstraintCollector<'tcx> {\n     glbs: CombineMap<'tcx>,\n \n     /// Number of skolemized variables currently active.\n-    skolemization_count: u32,\n+    skolemization_count: ty::UniverseIndex,\n \n     /// Global counter used during the GLB algorithm to create unique\n     /// names for fresh bound regions\n@@ -73,7 +73,7 @@ pub struct RegionConstraintCollector<'tcx> {\n     /// is iterating to a fixed point, because otherwise we sometimes\n     /// would wind up with a fresh stream of region variables that\n     /// have been equated but appear distinct.\n-    unification_table: UnificationTable<ty::RegionVid>,\n+    unification_table: ut::UnificationTable<ut::InPlace<ty::RegionVid>>,\n }\n \n pub type VarOrigins = IndexVec<RegionVid, RegionVariableOrigin>;\n@@ -232,8 +232,8 @@ type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n \n pub struct RegionSnapshot {\n     length: usize,\n-    region_snapshot: unify::Snapshot<ty::RegionVid>,\n-    skolemization_count: u32,\n+    region_snapshot: ut::Snapshot<ut::InPlace<ty::RegionVid>>,\n+    skolemization_count: ty::UniverseIndex,\n }\n \n /// When working with skolemized regions, we often wish to find all of\n@@ -277,10 +277,10 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             data: RegionConstraintData::default(),\n             lubs: FxHashMap(),\n             glbs: FxHashMap(),\n-            skolemization_count: 0,\n+            skolemization_count: ty::UniverseIndex::ROOT,\n             bound_count: 0,\n             undo_log: Vec::new(),\n-            unification_table: UnificationTable::new(),\n+            unification_table: ut::UnificationTable::new(),\n         }\n     }\n \n@@ -329,7 +329,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             unification_table,\n         } = self;\n \n-        assert_eq!(*skolemization_count, 0);\n+        assert_eq!(skolemization_count.as_usize(), 0);\n \n         // Clear the tables of (lubs, glbs), so that we will create\n         // fresh regions if we do a LUB operation. As it happens,\n@@ -342,7 +342,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         // un-unified\" state. Note that when we unify `a` and `b`, we\n         // also insert `a <= b` and a `b <= a` edges, so the\n         // `RegionConstraintData` contains the relationship here.\n-        *unification_table = UnificationTable::new();\n+        *unification_table = ut::UnificationTable::new();\n         for vid in var_origins.indices() {\n             unification_table.new_key(unify_key::RegionVidKey { min_vid: vid });\n         }\n@@ -371,7 +371,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n         assert!(\n             self.skolemization_count == snapshot.skolemization_count,\n-            \"failed to pop skolemized regions: {} now vs {} at start\",\n+            \"failed to pop skolemized regions: {:?} now vs {:?} at start\",\n             self.skolemization_count,\n             snapshot.skolemization_count\n         );\n@@ -479,9 +479,9 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         assert!(self.in_snapshot());\n         assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n \n-        let sc = self.skolemization_count;\n-        self.skolemization_count = sc + 1;\n-        tcx.mk_region(ReSkolemized(ty::SkolemizedRegionVid { index: sc }, br))\n+        let universe = self.skolemization_count.subuniverse();\n+        self.skolemization_count = universe;\n+        tcx.mk_region(ReSkolemized(universe, br))\n     }\n \n     /// Removes all the edges to/from the skolemized regions that are\n@@ -499,34 +499,34 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         assert!(self.in_snapshot());\n         assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n         assert!(\n-            self.skolemization_count as usize >= skols.len(),\n+            self.skolemization_count.as_usize() >= skols.len(),\n             \"popping more skolemized variables than actually exist, \\\n              sc now = {}, skols.len = {}\",\n-            self.skolemization_count,\n+            self.skolemization_count.as_usize(),\n             skols.len()\n         );\n \n-        let last_to_pop = self.skolemization_count;\n-        let first_to_pop = last_to_pop - (skols.len() as u32);\n+        let last_to_pop = self.skolemization_count.subuniverse();\n+        let first_to_pop = ty::UniverseIndex::from(last_to_pop.as_u32() - (skols.len() as u32));\n \n         assert!(\n             first_to_pop >= snapshot.skolemization_count,\n             \"popping more regions than snapshot contains, \\\n-             sc now = {}, sc then = {}, skols.len = {}\",\n+             sc now = {:?}, sc then = {:?}, skols.len = {}\",\n             self.skolemization_count,\n             snapshot.skolemization_count,\n             skols.len()\n         );\n         debug_assert! {\n             skols.iter()\n                  .all(|&k| match *k {\n-                     ty::ReSkolemized(index, _) =>\n-                         index.index >= first_to_pop &&\n-                         index.index < last_to_pop,\n+                     ty::ReSkolemized(universe, _) =>\n+                         universe >= first_to_pop &&\n+                         universe < last_to_pop,\n                      _ =>\n                          false\n                  }),\n-            \"invalid skolemization keys or keys out of range ({}..{}): {:?}\",\n+            \"invalid skolemization keys or keys out of range ({:?}..{:?}): {:?}\",\n             snapshot.skolemization_count,\n             self.skolemization_count,\n             skols\n@@ -776,7 +776,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         tcx: TyCtxt<'_, '_, 'tcx>,\n         rid: RegionVid,\n     ) -> ty::Region<'tcx> {\n-        let vid = self.unification_table.find_value(rid).min_vid;\n+        let vid = self.unification_table.probe_value(rid).min_vid;\n         tcx.mk_region(ty::ReVar(vid))\n     }\n \n@@ -861,7 +861,7 @@ impl fmt::Debug for RegionSnapshot {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(\n             f,\n-            \"RegionSnapshot(length={},skolemization={})\",\n+            \"RegionSnapshot(length={},skolemization={:?})\",\n             self.length,\n             self.skolemization_count\n         )"}, {"sha": "5daac988f80b76e49143bd7815f7081c1813fbda", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 233, "deletions": 184, "changes": 417, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -8,26 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use self::TypeVariableValue::*;\n-use hir::def_id::{DefId};\n use syntax::ast;\n use syntax_pos::Span;\n use ty::{self, Ty};\n \n-use std::cmp::min;\n+use std::cmp;\n use std::marker::PhantomData;\n-use std::mem;\n use std::u32;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::snapshot_vec as sv;\n use rustc_data_structures::unify as ut;\n \n pub struct TypeVariableTable<'tcx> {\n-    values: sv::SnapshotVec<Delegate<'tcx>>,\n+    /// Extra data for each type variable, such as the origin. This is\n+    /// not stored in the unification table since, when we inquire\n+    /// after the origin of a variable X, we want the origin of **that\n+    /// variable X**, not the origin of some other variable Y with\n+    /// which X has been unified.\n+    var_data: Vec<TypeVariableData>,\n \n     /// Two variables are unified in `eq_relations` when we have a\n-    /// constraint `?X == ?Y`.\n-    eq_relations: ut::UnificationTable<ty::TyVid>,\n+    /// constraint `?X == ?Y`. This table also stores, for each key,\n+    /// the known value.\n+    eq_relations: ut::UnificationTable<ut::InPlace<TyVidEqKey<'tcx>>>,\n \n     /// Two variables are unified in `eq_relations` when we have a\n     /// constraint `?X <: ?Y` *or* a constraint `?Y <: ?X`. This second\n@@ -46,7 +48,7 @@ pub struct TypeVariableTable<'tcx> {\n     /// This is reasonable because, in Rust, subtypes have the same\n     /// \"skeleton\" and hence there is no possible type such that\n     /// (e.g.)  `Box<?3> <: ?3` for any `?3`.\n-    sub_relations: ut::UnificationTable<ty::TyVid>,\n+    sub_relations: ut::UnificationTable<ut::InPlace<ty::TyVid>>,\n }\n \n /// Reasons to create a type inference variable\n@@ -72,73 +74,91 @@ pub enum TypeVariableOrigin {\n \n pub type TypeVariableMap = FxHashMap<ty::TyVid, TypeVariableOrigin>;\n \n-struct TypeVariableData<'tcx> {\n-    value: TypeVariableValue<'tcx>,\n+struct TypeVariableData {\n     origin: TypeVariableOrigin,\n     diverging: bool\n }\n \n-enum TypeVariableValue<'tcx> {\n-    Known(Ty<'tcx>),\n-    Bounded {\n-        default: Option<Default<'tcx>>\n-    }\n+#[derive(Copy, Clone, Debug)]\n+pub enum TypeVariableValue<'tcx> {\n+    Known { value: Ty<'tcx> },\n+    Unknown { universe: ty::UniverseIndex },\n }\n \n-// We will use this to store the required information to recapitulate what happened when\n-// an error occurs.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct Default<'tcx> {\n-    pub ty: Ty<'tcx>,\n-    /// The span where the default was incurred\n-    pub origin_span: Span,\n-    /// The definition that the default originates from\n-    pub def_id: DefId\n+#[derive(Copy, Clone, Debug)]\n+pub enum ProbeTyValue<'tcx> {\n+    Ty(Ty<'tcx>),\n+    Vid(ty::TyVid),\n }\n \n-pub struct Snapshot {\n-    snapshot: sv::Snapshot,\n-    eq_snapshot: ut::Snapshot<ty::TyVid>,\n-    sub_snapshot: ut::Snapshot<ty::TyVid>,\n-}\n+impl<'tcx> TypeVariableValue<'tcx> {\n+    /// If this value is known, returns the type it is known to be.\n+    /// Otherwise, `None`.\n+    pub fn known(&self) -> Option<Ty<'tcx>> {\n+        match *self {\n+            TypeVariableValue::Unknown { .. } => None,\n+            TypeVariableValue::Known { value } => Some(value),\n+        }\n+    }\n \n-struct Instantiate<'tcx> {\n-    vid: ty::TyVid,\n-    default: Option<Default<'tcx>>,\n+    /// If this value is unknown, returns the universe, otherwise `None`.\n+    pub fn universe(&self) -> Option<ty::UniverseIndex> {\n+        match *self {\n+            TypeVariableValue::Unknown { universe } => Some(universe),\n+            TypeVariableValue::Known { .. } => None,\n+        }\n+    }\n+\n+    pub fn is_unknown(&self) -> bool {\n+        match *self {\n+            TypeVariableValue::Unknown { .. } => true,\n+            TypeVariableValue::Known { .. } => false,\n+        }\n+    }\n }\n \n-struct Delegate<'tcx>(PhantomData<&'tcx ()>);\n+pub struct Snapshot<'tcx> {\n+    /// number of variables at the time of the snapshot\n+    num_vars: usize,\n+\n+    /// snapshot from the `eq_relations` table\n+    eq_snapshot: ut::Snapshot<ut::InPlace<TyVidEqKey<'tcx>>>,\n+\n+    /// snapshot from the `sub_relations` table\n+    sub_snapshot: ut::Snapshot<ut::InPlace<ty::TyVid>>,\n+}\n \n impl<'tcx> TypeVariableTable<'tcx> {\n     pub fn new() -> TypeVariableTable<'tcx> {\n         TypeVariableTable {\n-            values: sv::SnapshotVec::new(),\n+            var_data: Vec::new(),\n             eq_relations: ut::UnificationTable::new(),\n             sub_relations: ut::UnificationTable::new(),\n         }\n     }\n \n-    pub fn default(&self, vid: ty::TyVid) -> Option<Default<'tcx>> {\n-        match &self.values.get(vid.index as usize).value {\n-            &Known(_) => None,\n-            &Bounded { ref default, .. } => default.clone()\n-        }\n-    }\n-\n+    /// Returns the diverges flag given when `vid` was created.\n+    ///\n+    /// Note that this function does not return care whether\n+    /// `vid` has been unified with something else or not.\n     pub fn var_diverges<'a>(&'a self, vid: ty::TyVid) -> bool {\n-        self.values.get(vid.index as usize).diverging\n+        self.var_data[vid.index as usize].diverging\n     }\n \n+    /// Returns the origin that was given when `vid` was created.\n+    ///\n+    /// Note that this function does not return care whether\n+    /// `vid` has been unified with something else or not.\n     pub fn var_origin(&self, vid: ty::TyVid) -> &TypeVariableOrigin {\n-        &self.values.get(vid.index as usize).origin\n+        &self.var_data[vid.index as usize].origin\n     }\n \n     /// Records that `a == b`, depending on `dir`.\n     ///\n     /// Precondition: neither `a` nor `b` are known.\n     pub fn equate(&mut self, a: ty::TyVid, b: ty::TyVid) {\n-        debug_assert!(self.probe(a).is_none());\n-        debug_assert!(self.probe(b).is_none());\n+        debug_assert!(self.probe(a).is_unknown());\n+        debug_assert!(self.probe(b).is_unknown());\n         self.eq_relations.union(a, b);\n         self.sub_relations.union(a, b);\n     }\n@@ -147,8 +167,8 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     ///\n     /// Precondition: neither `a` nor `b` are known.\n     pub fn sub(&mut self, a: ty::TyVid, b: ty::TyVid) {\n-        debug_assert!(self.probe(a).is_none());\n-        debug_assert!(self.probe(b).is_none());\n+        debug_assert!(self.probe(a).is_unknown());\n+        debug_assert!(self.probe(b).is_unknown());\n         self.sub_relations.union(a, b);\n     }\n \n@@ -157,43 +177,44 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// Precondition: `vid` must not have been previously instantiated.\n     pub fn instantiate(&mut self, vid: ty::TyVid, ty: Ty<'tcx>) {\n         let vid = self.root_var(vid);\n-        debug_assert!(self.probe_root(vid).is_none());\n-\n-        let old_value = {\n-            let vid_data = &mut self.values[vid.index as usize];\n-            mem::replace(&mut vid_data.value, TypeVariableValue::Known(ty))\n-        };\n-\n-        match old_value {\n-            TypeVariableValue::Bounded { default } => {\n-                self.values.record(Instantiate { vid: vid, default: default });\n-            }\n-            TypeVariableValue::Known(old_ty) => {\n-                bug!(\"instantiating type variable `{:?}` twice: new-value = {:?}, old-value={:?}\",\n-                     vid, ty, old_ty)\n-            }\n-        }\n+        debug_assert!(self.probe(vid).is_unknown());\n+        debug_assert!(self.eq_relations.probe_value(vid).is_unknown(),\n+                      \"instantiating type variable `{:?}` twice: new-value = {:?}, old-value={:?}\",\n+                      vid, ty, self.eq_relations.probe_value(vid));\n+        self.eq_relations.union_value(vid, TypeVariableValue::Known { value: ty });\n     }\n \n+    /// Creates a new type variable.\n+    ///\n+    /// - `diverging`: indicates if this is a \"diverging\" type\n+    ///   variable, e.g.  one created as the type of a `return`\n+    ///   expression. The code in this module doesn't care if a\n+    ///   variable is diverging, but the main Rust type-checker will\n+    ///   sometimes \"unify\" such variables with the `!` or `()` types.\n+    /// - `origin`: indicates *why* the type variable was created.\n+    ///   The code in this module doesn't care, but it can be useful\n+    ///   for improving error messages.\n     pub fn new_var(&mut self,\n+                   universe: ty::UniverseIndex,\n                    diverging: bool,\n-                   origin: TypeVariableOrigin,\n-                   default: Option<Default<'tcx>>,) -> ty::TyVid {\n-        debug!(\"new_var(diverging={:?}, origin={:?})\", diverging, origin);\n-        self.eq_relations.new_key(());\n-        self.sub_relations.new_key(());\n-        let index = self.values.push(TypeVariableData {\n-            value: Bounded { default: default },\n-            origin,\n-            diverging,\n-        });\n-        let v = ty::TyVid { index: index as u32 };\n-        debug!(\"new_var: diverging={:?} index={:?}\", diverging, v);\n-        v\n+                   origin: TypeVariableOrigin)\n+                   -> ty::TyVid {\n+        let eq_key = self.eq_relations.new_key(TypeVariableValue::Unknown { universe });\n+\n+        let sub_key = self.sub_relations.new_key(());\n+        assert_eq!(eq_key.vid, sub_key);\n+\n+        assert_eq!(self.var_data.len(), sub_key.index as usize);\n+        self.var_data.push(TypeVariableData { origin, diverging });\n+\n+        debug!(\"new_var(index={:?}, diverging={:?}, origin={:?}\", eq_key.vid, diverging, origin);\n+\n+        eq_key.vid\n     }\n \n+    /// Returns the number of type variables created thus far.\n     pub fn num_vars(&self) -> usize {\n-        self.values.len()\n+        self.var_data.len()\n     }\n \n     /// Returns the \"root\" variable of `vid` in the `eq_relations`\n@@ -202,7 +223,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// algorithm), so `root_var(a) == root_var(b)` implies that `a ==\n     /// b` (transitively).\n     pub fn root_var(&mut self, vid: ty::TyVid) -> ty::TyVid {\n-        self.eq_relations.find(vid)\n+        self.eq_relations.find(vid).vid\n     }\n \n     /// Returns the \"root\" variable of `vid` in the `sub_relations`\n@@ -222,65 +243,58 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         self.sub_root_var(a) == self.sub_root_var(b)\n     }\n \n-    pub fn probe(&mut self, vid: ty::TyVid) -> Option<Ty<'tcx>> {\n-        let vid = self.root_var(vid);\n-        self.probe_root(vid)\n-    }\n-\n-    pub fn origin(&self, vid: ty::TyVid) -> TypeVariableOrigin {\n-        self.values.get(vid.index as usize).origin.clone()\n-    }\n-\n-    /// Retrieves the type of `vid` given that it is currently a root in the unification table\n-    pub fn probe_root(&mut self, vid: ty::TyVid) -> Option<Ty<'tcx>> {\n-        debug_assert!(self.root_var(vid) == vid);\n-        match self.values.get(vid.index as usize).value {\n-            Bounded { .. } => None,\n-            Known(t) => Some(t)\n-        }\n+    /// Retrieves the type to which `vid` has been instantiated, if\n+    /// any.\n+    pub fn probe(&mut self, vid: ty::TyVid) -> TypeVariableValue<'tcx> {\n+        self.eq_relations.probe_value(vid)\n     }\n \n+    /// If `t` is a type-inference variable, and it has been\n+    /// instantiated, then return the with which it was\n+    /// instantiated. Otherwise, returns `t`.\n     pub fn replace_if_possible(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match t.sty {\n             ty::TyInfer(ty::TyVar(v)) => {\n                 match self.probe(v) {\n-                    None => t,\n-                    Some(u) => u\n+                    TypeVariableValue::Unknown { .. } => t,\n+                    TypeVariableValue::Known { value } => value,\n                 }\n             }\n             _ => t,\n         }\n     }\n \n-    pub fn snapshot(&mut self) -> Snapshot {\n+    /// Creates a snapshot of the type variable state.  This snapshot\n+    /// must later be committed (`commit()`) or rolled back\n+    /// (`rollback_to()`).  Nested snapshots are permitted, but must\n+    /// be processed in a stack-like fashion.\n+    pub fn snapshot(&mut self) -> Snapshot<'tcx> {\n         Snapshot {\n-            snapshot: self.values.start_snapshot(),\n+            num_vars: self.var_data.len(),\n             eq_snapshot: self.eq_relations.snapshot(),\n             sub_snapshot: self.sub_relations.snapshot(),\n         }\n     }\n \n-    pub fn rollback_to(&mut self, s: Snapshot) {\n-        debug!(\"rollback_to{:?}\", {\n-            for action in self.values.actions_since_snapshot(&s.snapshot) {\n-                match *action {\n-                    sv::UndoLog::NewElem(index) => {\n-                        debug!(\"inference variable _#{}t popped\", index)\n-                    }\n-                    _ => { }\n-                }\n-            }\n-        });\n-\n-        let Snapshot { snapshot, eq_snapshot, sub_snapshot } = s;\n-        self.values.rollback_to(snapshot);\n+    /// Undoes all changes since the snapshot was created. Any\n+    /// snapshots created since that point must already have been\n+    /// committed or rolled back.\n+    pub fn rollback_to(&mut self, s: Snapshot<'tcx>) {\n+        let Snapshot { num_vars, eq_snapshot, sub_snapshot } = s;\n+        debug!(\"type_variables::rollback_to(num_vars = {})\", num_vars);\n+        assert!(self.var_data.len() >= num_vars);\n         self.eq_relations.rollback_to(eq_snapshot);\n         self.sub_relations.rollback_to(sub_snapshot);\n+        self.var_data.truncate(num_vars);\n     }\n \n-    pub fn commit(&mut self, s: Snapshot) {\n-        let Snapshot { snapshot, eq_snapshot, sub_snapshot } = s;\n-        self.values.commit(snapshot);\n+    /// Commits all changes since the snapshot was created, making\n+    /// them permanent (unless this snapshot was created within\n+    /// another snapshot). Any snapshots created since that point\n+    /// must already have been committed or rolled back.\n+    pub fn commit(&mut self, s: Snapshot<'tcx>) {\n+        let Snapshot { num_vars, eq_snapshot, sub_snapshot } = s;\n+        debug!(\"type_variables::commit(num_vars = {})\", num_vars);\n         self.eq_relations.commit(eq_snapshot);\n         self.sub_relations.commit(sub_snapshot);\n     }\n@@ -289,90 +303,125 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// ty-variables created during the snapshot, and the values\n     /// `{V2}` are the root variables that they were unified with,\n     /// along with their origin.\n-    pub fn types_created_since_snapshot(&mut self, s: &Snapshot) -> TypeVariableMap {\n-        let actions_since_snapshot = self.values.actions_since_snapshot(&s.snapshot);\n-\n-        actions_since_snapshot\n+    pub fn types_created_since_snapshot(&mut self, snapshot: &Snapshot<'tcx>) -> TypeVariableMap {\n+        self.var_data\n             .iter()\n-            .filter_map(|action| match action {\n-                &sv::UndoLog::NewElem(index) => Some(ty::TyVid { index: index as u32 }),\n-                _ => None,\n-            })\n-            .map(|vid| {\n-                let origin = self.values.get(vid.index as usize).origin.clone();\n-                (vid, origin)\n-            })\n+            .enumerate()\n+            .skip(snapshot.num_vars) // skip those that existed when snapshot was taken\n+            .map(|(index, data)| (ty::TyVid { index: index as u32 }, data.origin))\n             .collect()\n     }\n \n-    pub fn types_escaping_snapshot(&mut self, s: &Snapshot) -> Vec<Ty<'tcx>> {\n-        /*!\n-         * Find the set of type variables that existed *before* `s`\n-         * but which have only been unified since `s` started, and\n-         * return the types with which they were unified. So if we had\n-         * a type variable `V0`, then we started the snapshot, then we\n-         * created a type variable `V1`, unifed `V0` with `T0`, and\n-         * unified `V1` with `T1`, this function would return `{T0}`.\n-         */\n-\n-        let mut new_elem_threshold = u32::MAX;\n-        let mut escaping_types = Vec::new();\n-        let actions_since_snapshot = self.values.actions_since_snapshot(&s.snapshot);\n-        debug!(\"actions_since_snapshot.len() = {}\", actions_since_snapshot.len());\n-        for action in actions_since_snapshot {\n-            match *action {\n-                sv::UndoLog::NewElem(index) => {\n-                    // if any new variables were created during the\n-                    // snapshot, remember the lower index (which will\n-                    // always be the first one we see). Note that this\n-                    // action must precede those variables being\n-                    // specified.\n-                    new_elem_threshold = min(new_elem_threshold, index as u32);\n-                    debug!(\"NewElem({}) new_elem_threshold={}\", index, new_elem_threshold);\n-                }\n-\n-                sv::UndoLog::Other(Instantiate { vid, .. }) => {\n-                    if vid.index < new_elem_threshold {\n-                        // quick check to see if this variable was\n-                        // created since the snapshot started or not.\n-                        let escaping_type = match self.values.get(vid.index as usize).value {\n-                            Bounded { .. } => bug!(),\n-                            Known(ty) => ty,\n-                        };\n-                        escaping_types.push(escaping_type);\n-                    }\n-                    debug!(\"SpecifyVar({:?}) new_elem_threshold={}\", vid, new_elem_threshold);\n-                }\n-\n-                _ => { }\n-            }\n-        }\n-\n+    /// Find the set of type variables that existed *before* `s`\n+    /// but which have only been unified since `s` started, and\n+    /// return the types with which they were unified. So if we had\n+    /// a type variable `V0`, then we started the snapshot, then we\n+    /// created a type variable `V1`, unifed `V0` with `T0`, and\n+    /// unified `V1` with `T1`, this function would return `{T0}`.\n+    pub fn types_escaping_snapshot(&mut self, snapshot: &Snapshot<'tcx>) -> Vec<Ty<'tcx>> {\n+        // We want to select only those instantiations that have\n+        // occurred since the snapshot *and* which affect some\n+        // variable that existed prior to the snapshot. This code just\n+        // affects all instantiatons that ever occurred which affect\n+        // variables prior to the snapshot.\n+        //\n+        // It's hard to do better than this, though, without changing\n+        // the unification table to prefer \"lower\" vids -- the problem\n+        // is that we may have a variable X (from before the snapshot)\n+        // and Y (from after the snapshot) which get unified, with Y\n+        // chosen as the new root. Now we are \"instantiating\" Y with a\n+        // value, but it escapes into X, but we wouldn't readily see\n+        // that. (In fact, earlier revisions of this code had this\n+        // bug; it was introduced when we added the `eq_relations`\n+        // table, but it's hard to create rust code that triggers it.)\n+        //\n+        // We could tell the table to prefer lower vids, and then we would\n+        // see the case above, but we would get less-well-balanced trees.\n+        //\n+        // Since I hope to kill the leak-check in this branch, and\n+        // that's the code which uses this logic anyway, I'm going to\n+        // use the less efficient algorithm for now.\n+        let mut escaping_types = Vec::with_capacity(snapshot.num_vars);\n+        escaping_types.extend(\n+            (0..snapshot.num_vars) // for all variables that pre-exist the snapshot, collect..\n+                .map(|i| ty::TyVid { index: i as u32 })\n+                .filter_map(|vid| self.probe(vid).known())); // ..types they are instantiated with.\n+        debug!(\"types_escaping_snapshot = {:?}\", escaping_types);\n         escaping_types\n     }\n \n+    /// Returns indices of all variables that are not yet\n+    /// instantiated.\n     pub fn unsolved_variables(&mut self) -> Vec<ty::TyVid> {\n-        (0..self.values.len())\n+        (0..self.var_data.len())\n             .filter_map(|i| {\n                 let vid = ty::TyVid { index: i as u32 };\n-                if self.probe(vid).is_some() {\n-                    None\n-                } else {\n-                    Some(vid)\n+                match self.probe(vid) {\n+                    TypeVariableValue::Unknown { .. } => Some(vid),\n+                    TypeVariableValue::Known { .. } => None,\n                 }\n             })\n             .collect()\n     }\n }\n+///////////////////////////////////////////////////////////////////////////\n \n-impl<'tcx> sv::SnapshotVecDelegate for Delegate<'tcx> {\n-    type Value = TypeVariableData<'tcx>;\n-    type Undo = Instantiate<'tcx>;\n+/// These structs (a newtyped TyVid) are used as the unification key\n+/// for the `eq_relations`; they carry a `TypeVariableValue` along\n+/// with them.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+struct TyVidEqKey<'tcx> {\n+    vid: ty::TyVid,\n \n-    fn reverse(values: &mut Vec<TypeVariableData<'tcx>>, action: Instantiate<'tcx>) {\n-        let Instantiate { vid, default } = action;\n-        values[vid.index as usize].value = Bounded {\n-            default,\n-        };\n+    // in the table, we map each ty-vid to one of these:\n+    phantom: PhantomData<TypeVariableValue<'tcx>>,\n+}\n+\n+impl<'tcx> From<ty::TyVid> for TyVidEqKey<'tcx> {\n+    fn from(vid: ty::TyVid) -> Self {\n+        TyVidEqKey { vid, phantom: PhantomData }\n+    }\n+}\n+\n+impl<'tcx> ut::UnifyKey for TyVidEqKey<'tcx> {\n+    type Value = TypeVariableValue<'tcx>;\n+    fn index(&self) -> u32 { self.vid.index }\n+    fn from_index(i: u32) -> Self { TyVidEqKey::from(ty::TyVid { index: i }) }\n+    fn tag() -> &'static str { \"TyVidEqKey\" }\n+}\n+\n+impl<'tcx> ut::UnifyValue for TypeVariableValue<'tcx> {\n+    type Error = ut::NoError;\n+\n+    fn unify_values(value1: &Self, value2: &Self) -> Result<Self, ut::NoError> {\n+        match (value1, value2) {\n+            // We never equate two type variables, both of which\n+            // have known types.  Instead, we recursively equate\n+            // those types.\n+            (&TypeVariableValue::Known { .. }, &TypeVariableValue::Known { .. }) => {\n+                bug!(\"equating two type variables, both of which have known types\")\n+            }\n+\n+            // If one side is known, prefer that one.\n+            (&TypeVariableValue::Known { .. }, &TypeVariableValue::Unknown { .. }) => Ok(*value1),\n+            (&TypeVariableValue::Unknown { .. }, &TypeVariableValue::Known { .. }) => Ok(*value2),\n+\n+            // If both sides are unknown, we need to pick the most restrictive universe.\n+            (&TypeVariableValue::Unknown { universe: universe1 },\n+             &TypeVariableValue::Unknown { universe: universe2 }) => {\n+                let universe = cmp::min(universe1, universe2);\n+                Ok(TypeVariableValue::Unknown { universe })\n+            }\n+        }\n     }\n }\n+\n+/// Raw `TyVid` are used as the unification key for `sub_relations`;\n+/// they carry no values.\n+impl ut::UnifyKey for ty::TyVid {\n+    type Value = ();\n+    fn index(&self) -> u32 { self.index }\n+    fn from_index(i: u32) -> ty::TyVid { ty::TyVid { index: i } }\n+    fn tag() -> &'static str { \"TyVid\" }\n+}\n+"}, {"sha": "a1145572b79d95d9a80460cb22ac0821d1c40669", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax::ast;\n-use ty::{self, IntVarValue, Ty, TyCtxt};\n-use rustc_data_structures::unify::{Combine, UnifyKey};\n+use ty::{self, FloatVarValue, IntVarValue, Ty, TyCtxt};\n+use rustc_data_structures::unify::{NoError, EqUnifyValue, UnifyKey, UnifyValue};\n \n pub trait ToType {\n     fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>;\n@@ -20,7 +19,10 @@ impl UnifyKey for ty::IntVid {\n     type Value = Option<IntVarValue>;\n     fn index(&self) -> u32 { self.index }\n     fn from_index(i: u32) -> ty::IntVid { ty::IntVid { index: i } }\n-    fn tag(_: Option<ty::IntVid>) -> &'static str { \"IntVid\" }\n+    fn tag() -> &'static str { \"IntVid\" }\n+}\n+\n+impl EqUnifyValue for IntVarValue {\n }\n \n #[derive(PartialEq, Copy, Clone, Debug)]\n@@ -31,23 +33,25 @@ pub struct RegionVidKey {\n     pub min_vid: ty::RegionVid\n }\n \n-impl Combine for RegionVidKey {\n-    fn combine(&self, other: &RegionVidKey) -> RegionVidKey {\n-        let min_vid = if self.min_vid.index() < other.min_vid.index() {\n-            self.min_vid\n+impl UnifyValue for RegionVidKey {\n+    type Error = NoError;\n+\n+    fn unify_values(value1: &Self, value2: &Self) -> Result<Self, NoError> {\n+        let min_vid = if value1.min_vid.index() < value2.min_vid.index() {\n+            value1.min_vid\n         } else {\n-            other.min_vid\n+            value2.min_vid\n         };\n \n-        RegionVidKey { min_vid: min_vid }\n+        Ok(RegionVidKey { min_vid: min_vid })\n     }\n }\n \n impl UnifyKey for ty::RegionVid {\n     type Value = RegionVidKey;\n     fn index(&self) -> u32 { self.0 }\n     fn from_index(i: u32) -> ty::RegionVid { ty::RegionVid(i) }\n-    fn tag(_: Option<ty::RegionVid>) -> &'static str { \"RegionVid\" }\n+    fn tag() -> &'static str { \"RegionVid\" }\n }\n \n impl ToType for IntVarValue {\n@@ -62,21 +66,17 @@ impl ToType for IntVarValue {\n // Floating point type keys\n \n impl UnifyKey for ty::FloatVid {\n-    type Value = Option<ast::FloatTy>;\n+    type Value = Option<FloatVarValue>;\n     fn index(&self) -> u32 { self.index }\n     fn from_index(i: u32) -> ty::FloatVid { ty::FloatVid { index: i } }\n-    fn tag(_: Option<ty::FloatVid>) -> &'static str { \"FloatVid\" }\n+    fn tag() -> &'static str { \"FloatVid\" }\n }\n \n-impl ToType for ast::FloatTy {\n-    fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n-        tcx.mk_mach_float(*self)\n-    }\n+impl EqUnifyValue for FloatVarValue {\n }\n \n-impl UnifyKey for ty::TyVid {\n-    type Value = ();\n-    fn index(&self) -> u32 { self.index }\n-    fn from_index(i: u32) -> ty::TyVid { ty::TyVid { index: i } }\n-    fn tag(_: Option<ty::TyVid>) -> &'static str { \"TyVid\" }\n+impl ToType for FloatVarValue {\n+    fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+        tcx.mk_mach_float(self.0)\n+    }\n }"}, {"sha": "183b1a5470e5ac0a7aa5cdb65f27f99f3aa778cc", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -92,7 +92,9 @@ fn with_fresh_ty_vars<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, '\n                                        -> ty::ImplHeader<'tcx>\n {\n     let tcx = selcx.tcx();\n-    let impl_substs = selcx.infcx().fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+    let impl_substs = selcx.infcx().fresh_substs_for_item(param_env.universe,\n+                                                          DUMMY_SP,\n+                                                          impl_def_id);\n \n     let header = ty::ImplHeader {\n         impl_def_id,"}, {"sha": "dba23c22647f8048b2590dcc6091b6cbf6d45f19", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -292,7 +292,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         self.tcx.for_each_relevant_impl(\n             trait_ref.def_id, trait_self_ty, |def_id| {\n-                let impl_substs = self.fresh_substs_for_item(obligation.cause.span, def_id);\n+                let impl_substs = self.fresh_substs_for_item(param_env.universe,\n+                                                             obligation.cause.span,\n+                                                             def_id);\n                 let impl_trait_ref = tcx\n                     .impl_trait_ref(def_id)\n                     .unwrap()\n@@ -1194,6 +1196,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                            -> bool {\n         struct ParamToVarFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n             infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+            param_env: ty::ParamEnv<'tcx>,\n             var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>\n         }\n \n@@ -1203,9 +1206,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n                 if let ty::TyParam(ty::ParamTy {name, ..}) = ty.sty {\n                     let infcx = self.infcx;\n-                    self.var_map.entry(ty).or_insert_with(||\n-                        infcx.next_ty_var(\n-                            TypeVariableOrigin::TypeParameterDefinition(DUMMY_SP, name)))\n+                    let param_env = self.param_env;\n+                    self.var_map\n+                        .entry(ty)\n+                        .or_insert_with(|| {\n+                            let origin = TypeVariableOrigin::TypeParameterDefinition(DUMMY_SP,\n+                                                                                     name);\n+                            infcx.next_ty_var(param_env.universe, origin)\n+                        })\n                 } else {\n                     ty.super_fold_with(self)\n                 }\n@@ -1217,6 +1225,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n             let cleaned_pred = pred.fold_with(&mut ParamToVarFolder {\n                 infcx: self,\n+                param_env,\n                 var_map: FxHashMap()\n             });\n "}, {"sha": "76d3c7f150670605e073a76cb3160bf5a338d361", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -77,10 +77,21 @@ pub enum IntercrateMode {\n /// scope. The eventual result is usually a `Selection` (defined below).\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct Obligation<'tcx, T> {\n+    /// Why do we have to prove this thing?\n     pub cause: ObligationCause<'tcx>,\n+\n+    /// In which environment should we prove this thing?\n     pub param_env: ty::ParamEnv<'tcx>,\n-    pub recursion_depth: usize,\n+\n+    /// What are we trying to prove?\n     pub predicate: T,\n+\n+    /// If we started proving this as a result of trying to prove\n+    /// something else, track the total depth to ensure termination.\n+    /// If this goes over a certain threshold, we abort compilation --\n+    /// in such cases, we can not say whether or not the predicate\n+    /// holds for certain. Stupid halting problem. Such a drag.\n+    pub recursion_depth: usize,\n }\n \n pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n@@ -535,7 +546,8 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            predicates);\n \n     let elaborated_env = ty::ParamEnv::new(tcx.intern_predicates(&predicates),\n-                                           unnormalized_env.reveal);\n+                                           unnormalized_env.reveal,\n+                                           unnormalized_env.universe);\n \n     tcx.infer_ctxt().enter(|infcx| {\n         // FIXME. We should really... do something with these region\n@@ -609,7 +621,9 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         debug!(\"normalize_param_env_or_error: resolved predicates={:?}\",\n                predicates);\n \n-        ty::ParamEnv::new(tcx.intern_predicates(&predicates), unnormalized_env.reveal)\n+        ty::ParamEnv::new(tcx.intern_predicates(&predicates),\n+                          unnormalized_env.reveal,\n+                          unnormalized_env.universe)\n     })\n }\n "}, {"sha": "3fe72344e8feac6727952529cb4c24a3e4aafcb0", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -469,6 +469,7 @@ pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             let tcx = selcx.infcx().tcx;\n             let def_id = projection_ty.item_def_id;\n             let ty_var = selcx.infcx().next_ty_var(\n+                param_env.universe,\n                 TypeVariableOrigin::NormalizeProjectionType(tcx.def_span(def_id)));\n             let projection = ty::Binder(ty::ProjectionPredicate {\n                 projection_ty,\n@@ -789,6 +790,7 @@ fn normalize_to_error<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tc\n     let tcx = selcx.infcx().tcx;\n     let def_id = projection_ty.item_def_id;\n     let new_value = selcx.infcx().next_ty_var(\n+        param_env.universe,\n         TypeVariableOrigin::NormalizeProjectionType(tcx.def_span(def_id)));\n     Normalized {\n         value: new_value,"}, {"sha": "9e24a4e6afacf5dcf91299035127957e63556db1", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -496,7 +496,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     /// Wraps the inference context's in_snapshot s.t. snapshot handling is only from the selection\n     /// context's self.\n     fn in_snapshot<R, F>(&mut self, f: F) -> R\n-        where F: FnOnce(&mut Self, &infer::CombinedSnapshot) -> R\n+        where F: FnOnce(&mut Self, &infer::CombinedSnapshot<'cx, 'tcx>) -> R\n     {\n         // The irrefutable nature of the operation means we don't need to snapshot the\n         // inferred_obligations vector.\n@@ -506,7 +506,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     /// Wraps a probe s.t. obligations collected during it are ignored and old obligations are\n     /// retained.\n     fn probe<R, F>(&mut self, f: F) -> R\n-        where F: FnOnce(&mut Self, &infer::CombinedSnapshot) -> R\n+        where F: FnOnce(&mut Self, &infer::CombinedSnapshot<'cx, 'tcx>) -> R\n     {\n         let inferred_obligations_snapshot = self.inferred_obligations.start_snapshot();\n         let result = self.infcx.probe(|snapshot| f(self, snapshot));\n@@ -1478,7 +1478,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn match_projection_obligation_against_definition_bounds(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-        snapshot: &infer::CombinedSnapshot)\n+        snapshot: &infer::CombinedSnapshot<'cx, 'tcx>)\n         -> bool\n     {\n         let poly_trait_predicate =\n@@ -1549,7 +1549,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         trait_bound: ty::PolyTraitRef<'tcx>,\n                         skol_trait_ref: ty::TraitRef<'tcx>,\n                         skol_map: &infer::SkolemizationMap<'tcx>,\n-                        snapshot: &infer::CombinedSnapshot)\n+                        snapshot: &infer::CombinedSnapshot<'cx, 'tcx>)\n                         -> bool\n     {\n         assert!(!skol_trait_ref.has_escaping_regions());\n@@ -2587,7 +2587,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                    recursion_depth: usize,\n                    param_env: ty::ParamEnv<'tcx>,\n                    skol_map: infer::SkolemizationMap<'tcx>,\n-                   snapshot: &infer::CombinedSnapshot)\n+                   snapshot: &infer::CombinedSnapshot<'cx, 'tcx>)\n                    -> VtableImplData<'tcx, PredicateObligation<'tcx>>\n     {\n         debug!(\"vtable_impl(impl_def_id={:?}, substs={:?}, recursion_depth={}, skol_map={:?})\",\n@@ -3076,7 +3076,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn rematch_impl(&mut self,\n                     impl_def_id: DefId,\n                     obligation: &TraitObligation<'tcx>,\n-                    snapshot: &infer::CombinedSnapshot)\n+                    snapshot: &infer::CombinedSnapshot<'cx, 'tcx>)\n                     -> (Normalized<'tcx, &'tcx Substs<'tcx>>,\n                         infer::SkolemizationMap<'tcx>)\n     {\n@@ -3093,7 +3093,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn match_impl(&mut self,\n                   impl_def_id: DefId,\n                   obligation: &TraitObligation<'tcx>,\n-                  snapshot: &infer::CombinedSnapshot)\n+                  snapshot: &infer::CombinedSnapshot<'cx, 'tcx>)\n                   -> Result<(Normalized<'tcx, &'tcx Substs<'tcx>>,\n                              infer::SkolemizationMap<'tcx>), ()>\n     {\n@@ -3111,7 +3111,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             snapshot);\n         let skol_obligation_trait_ref = skol_obligation.trait_ref;\n \n-        let impl_substs = self.infcx.fresh_substs_for_item(obligation.cause.span,\n+        let impl_substs = self.infcx.fresh_substs_for_item(obligation.param_env.universe,\n+                                                           obligation.cause.span,\n                                                            impl_def_id);\n \n         let impl_trait_ref = impl_trait_ref.subst(self.tcx(),\n@@ -3288,7 +3289,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                  def_id: DefId, // of impl or trait\n                                  substs: &Substs<'tcx>, // for impl or trait\n                                  skol_map: infer::SkolemizationMap<'tcx>,\n-                                 snapshot: &infer::CombinedSnapshot)\n+                                 snapshot: &infer::CombinedSnapshot<'cx, 'tcx>)\n                                  -> Vec<PredicateObligation<'tcx>>\n     {\n         debug!(\"impl_or_trait_obligations(def_id={:?})\", def_id);"}, {"sha": "5dfeb1bb4292842aeeac36f187fbefa62d69a5af", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -221,7 +221,7 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                        target_impl: DefId)\n                                        -> Result<&'tcx Substs<'tcx>, ()> {\n     let selcx = &mut SelectionContext::new(&infcx);\n-    let target_substs = infcx.fresh_substs_for_item(DUMMY_SP, target_impl);\n+    let target_substs = infcx.fresh_substs_for_item(param_env.universe, DUMMY_SP, target_impl);\n     let (target_trait_ref, mut obligations) = impl_trait_ref_and_oblig(selcx,\n                                                                        param_env,\n                                                                        target_impl,"}, {"sha": "be89aeebdea756445c2bfb4f296e9e9d206d55ac", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 44, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -9,9 +9,8 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n-use infer::type_variable;\n use middle::const_val::ConstVal;\n-use ty::{self, BoundRegion, DefIdTree, Region, Ty, TyCtxt};\n+use ty::{self, BoundRegion, Region, Ty, TyCtxt};\n \n use std::fmt;\n use syntax::abi;\n@@ -56,7 +55,6 @@ pub enum TypeError<'tcx> {\n     CyclicTy(Ty<'tcx>),\n     ProjectionMismatched(ExpectedFound<DefId>),\n     ProjectionBoundsLength(ExpectedFound<usize>),\n-    TyParamDefaultMismatch(ExpectedFound<type_variable::Default<'tcx>>),\n     ExistentialMismatch(ExpectedFound<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>),\n \n     OldStyleLUB(Box<TypeError<'tcx>>),\n@@ -167,11 +165,6 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                        values.expected,\n                        values.found)\n             },\n-            TyParamDefaultMismatch(ref values) => {\n-                write!(f, \"conflicting type parameter defaults `{}` and `{}`\",\n-                       values.expected.ty,\n-                       values.found.ty)\n-            }\n             ExistentialMismatch(ref values) => {\n                 report_maybe_different(f, format!(\"trait `{}`\", values.expected),\n                                        format!(\"trait `{}`\", values.found))\n@@ -265,42 +258,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     db.help(\"consider boxing your closure and/or using it as a trait object\");\n                 }\n             },\n-            TyParamDefaultMismatch(values) => {\n-                let expected = values.expected;\n-                let found = values.found;\n-                db.span_note(sp, &format!(\"conflicting type parameter defaults `{}` and `{}`\",\n-                                          expected.ty,\n-                                          found.ty));\n-\n-                match self.hir.span_if_local(expected.def_id) {\n-                    Some(span) => {\n-                        db.span_note(span, \"a default was defined here...\");\n-                    }\n-                    None => {\n-                        let item_def_id = self.parent(expected.def_id).unwrap();\n-                        db.note(&format!(\"a default is defined on `{}`\",\n-                                         self.item_path_str(item_def_id)));\n-                    }\n-                }\n-\n-                db.span_note(\n-                    expected.origin_span,\n-                    \"...that was applied to an unconstrained type variable here\");\n-\n-                match self.hir.span_if_local(found.def_id) {\n-                    Some(span) => {\n-                        db.span_note(span, \"a second default was defined here...\");\n-                    }\n-                    None => {\n-                        let item_def_id = self.parent(found.def_id).unwrap();\n-                        db.note(&format!(\"a second default is defined on `{}`\",\n-                                         self.item_path_str(item_def_id)));\n-                    }\n-                }\n-\n-                db.span_note(found.origin_span,\n-                             \"...that also applies to the same type variable here\");\n-            }\n             OldStyleLUB(err) => {\n                 db.note(\"this was previously accepted by the compiler but has been phased out\");\n                 db.note(\"for more information, see https://github.com/rust-lang/rust/issues/45852\");"}, {"sha": "88422a3ef82359479bffc5360ef4ce01ed539b09", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 97, "deletions": 3, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -69,7 +69,7 @@ pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n pub use self::sty::{ExistentialProjection, PolyExistentialProjection, Const};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::RegionKind;\n-pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid, SkolemizedRegionVid};\n+pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid};\n pub use self::sty::BoundRegion::*;\n pub use self::sty::InferTy::*;\n pub use self::sty::RegionKind::*;\n@@ -685,12 +685,15 @@ pub struct ClosureUpvar<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n-#[derive(Clone, Copy, PartialEq)]\n+#[derive(Clone, Copy, PartialEq, Eq)]\n pub enum IntVarValue {\n     IntType(ast::IntTy),\n     UintType(ast::UintTy),\n }\n \n+#[derive(Clone, Copy, PartialEq, Eq)]\n+pub struct FloatVarValue(pub ast::FloatTy);\n+\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub struct TypeParameterDef {\n     pub name: Name,\n@@ -1306,6 +1309,85 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n     }\n }\n \n+/// \"Universes\" are used during type- and trait-checking in the\n+/// presence of `for<..>` binders to control what sets of names are\n+/// visible. Universes are arranged into a tree: the root universe\n+/// contains names that are always visible. But when you enter into\n+/// some subuniverse, then it may add names that are only visible\n+/// within that subtree (but it can still name the names of its\n+/// ancestor universes).\n+///\n+/// To make this more concrete, consider this program:\n+///\n+/// ```\n+/// struct Foo { }\n+/// fn bar<T>(x: T) {\n+///   let y: for<'a> fn(&'a u8, Foo) = ...;\n+/// }\n+/// ```\n+///\n+/// The struct name `Foo` is in the root universe U0. But the type\n+/// parameter `T`, introduced on `bar`, is in a subuniverse U1 --\n+/// i.e., within `bar`, we can name both `T` and `Foo`, but outside of\n+/// `bar`, we cannot name `T`. Then, within the type of `y`, the\n+/// region `'a` is in a subuniverse U2 of U1, because we can name it\n+/// inside the fn type but not outside.\n+///\n+/// Universes are related to **skolemization** -- which is a way of\n+/// doing type- and trait-checking around these \"forall\" binders (also\n+/// called **universal quantification**). The idea is that when, in\n+/// the body of `bar`, we refer to `T` as a type, we aren't referring\n+/// to any type in particular, but rather a kind of \"fresh\" type that\n+/// is distinct from all other types we have actually declared. This\n+/// is called a **skolemized** type, and we use universes to talk\n+/// about this. In other words, a type name in universe 0 always\n+/// corresponds to some \"ground\" type that the user declared, but a\n+/// type name in a non-zero universe is a skolemized type -- an\n+/// idealized representative of \"types in general\" that we use for\n+/// checking generic functions.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+pub struct UniverseIndex(u32);\n+\n+impl UniverseIndex {\n+    /// The root universe, where things that the user defined are\n+    /// visible.\n+    pub const ROOT: UniverseIndex = UniverseIndex(0);\n+\n+    /// A \"subuniverse\" corresponds to being inside a `forall` quantifier.\n+    /// So, for example, suppose we have this type in universe `U`:\n+    ///\n+    /// ```\n+    /// for<'a> fn(&'a u32)\n+    /// ```\n+    ///\n+    /// Once we \"enter\" into this `for<'a>` quantifier, we are in a\n+    /// subuniverse of `U` -- in this new universe, we can name the\n+    /// region `'a`, but that region was not nameable from `U` because\n+    /// it was not in scope there.\n+    pub fn subuniverse(self) -> UniverseIndex {\n+        UniverseIndex(self.0.checked_add(1).unwrap())\n+    }\n+\n+    pub fn from(v: u32) -> UniverseIndex {\n+        UniverseIndex(v)\n+    }\n+\n+    pub fn as_u32(&self) -> u32 {\n+        self.0\n+    }\n+\n+    pub fn as_usize(&self) -> usize {\n+        self.0 as usize\n+    }\n+\n+    /// Gets the \"depth\" of this universe in the universe tree. This\n+    /// is not really useful except for e.g. the `HashStable`\n+    /// implementation\n+    pub fn depth(&self) -> u32 {\n+        self.0\n+    }\n+}\n+\n /// When type checking, we use the `ParamEnv` to track\n /// details about the set of where-clauses that are in scope at this\n /// particular point.\n@@ -1320,6 +1402,17 @@ pub struct ParamEnv<'tcx> {\n     /// want `Reveal::All` -- note that this is always paired with an\n     /// empty environment. To get that, use `ParamEnv::reveal()`.\n     pub reveal: traits::Reveal,\n+\n+    /// What is the innermost universe we have created? Starts out as\n+    /// `UniverseIndex::root()` but grows from there as we enter\n+    /// universal quantifiers.\n+    ///\n+    /// NB: At present, we exclude the universal quantifiers on the\n+    /// item we are type-checking, and just consider those names as\n+    /// part of the root universe. So this would only get incremented\n+    /// when we enter into a higher-ranked (`for<..>`) type or trait\n+    /// bound.\n+    pub universe: UniverseIndex,\n }\n \n impl<'tcx> ParamEnv<'tcx> {\n@@ -2595,7 +2688,8 @@ fn param_env<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // sure that this will succeed without errors anyway.\n \n     let unnormalized_env = ty::ParamEnv::new(tcx.intern_predicates(&predicates),\n-                                             traits::Reveal::UserFacing);\n+                                             traits::Reveal::UserFacing,\n+                                             ty::UniverseIndex::ROOT);\n \n     let body_id = tcx.hir.as_local_node_id(def_id).map_or(DUMMY_NODE_ID, |id| {\n         tcx.hir.maybe_body_owned_by(id).map_or(id, |body| body.node_id)"}, {"sha": "6147b52844fe4d1bcb31de5ec9780fa6e1a40fd3", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -13,7 +13,6 @@\n //! hand, though we've recently added some macros (e.g.,\n //! `BraceStructLiftImpl!`) to help with the tedium.\n \n-use infer::type_variable;\n use middle::const_val::{self, ConstVal, ConstAggregate, ConstEvalErr};\n use ty::{self, Lift, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n@@ -405,6 +404,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n         tcx.lift(&self.caller_bounds).map(|caller_bounds| {\n             ty::ParamEnv {\n                 reveal: self.reveal,\n+                universe: self.universe,\n                 caller_bounds,\n             }\n         })\n@@ -547,13 +547,6 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::error::ExpectedFound<T> {\n     }\n }\n \n-BraceStructLiftImpl! {\n-    impl<'a, 'tcx> Lift<'tcx> for type_variable::Default<'a> {\n-        type Lifted = type_variable::Default<'tcx>;\n-        ty, origin_span, def_id\n-    }\n-}\n-\n impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n     type Lifted = ty::error::TypeError<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -585,11 +578,8 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             ProjectionBoundsLength(x) => ProjectionBoundsLength(x),\n \n             Sorts(ref x) => return tcx.lift(x).map(Sorts),\n-            TyParamDefaultMismatch(ref x) => {\n-                return tcx.lift(x).map(TyParamDefaultMismatch)\n-            }\n-            ExistentialMismatch(ref x) => return tcx.lift(x).map(ExistentialMismatch),\n             OldStyleLUB(ref x) => return tcx.lift(x).map(OldStyleLUB),\n+            ExistentialMismatch(ref x) => return tcx.lift(x).map(ExistentialMismatch)\n         })\n     }\n }\n@@ -733,8 +723,29 @@ impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     }\n }\n \n-BraceStructTypeFoldableImpl! {\n-    impl<'tcx> TypeFoldable<'tcx> for ty::ParamEnv<'tcx> { reveal, caller_bounds }\n+impl<'tcx> TypeFoldable<'tcx> for ty::ParamEnv<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::ParamEnv {\n+            reveal: self.reveal,\n+            caller_bounds: self.caller_bounds.fold_with(folder),\n+            universe: self.universe.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        let &ty::ParamEnv { reveal: _, ref universe, ref caller_bounds } = self;\n+        universe.super_visit_with(visitor) || caller_bounds.super_visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::UniverseIndex {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n+        *self\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n+        false\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {\n@@ -1177,20 +1188,6 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::error::ExpectedFoun\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for type_variable::Default<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        type_variable::Default {\n-            ty: self.ty.fold_with(folder),\n-            origin_span: self.origin_span,\n-            def_id: self.def_id\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.ty.visit_with(visitor)\n-    }\n-}\n-\n impl<'tcx, T: TypeFoldable<'tcx>, I: Idx> TypeFoldable<'tcx> for IndexVec<I, T> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         self.iter().map(|x| x.fold_with(folder)).collect()\n@@ -1230,7 +1227,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n             ProjectionMismatched(x) => ProjectionMismatched(x),\n             ProjectionBoundsLength(x) => ProjectionBoundsLength(x),\n             Sorts(x) => Sorts(x.fold_with(folder)),\n-            TyParamDefaultMismatch(ref x) => TyParamDefaultMismatch(x.fold_with(folder)),\n             ExistentialMismatch(x) => ExistentialMismatch(x.fold_with(folder)),\n             OldStyleLUB(ref x) => OldStyleLUB(x.fold_with(folder)),\n         }\n@@ -1251,7 +1247,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n             },\n             Sorts(x) => x.visit_with(visitor),\n             OldStyleLUB(ref x) => x.visit_with(visitor),\n-            TyParamDefaultMismatch(ref x) => x.visit_with(visitor),\n             ExistentialMismatch(x) => x.visit_with(visitor),\n             CyclicTy(t) => t.visit_with(visitor),\n             Mismatch |"}, {"sha": "7bcc816b5f03dac1ad321a55da712d12b6683e97", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -1028,7 +1028,7 @@ pub enum RegionKind {\n \n     /// A skolemized region - basically the higher-ranked version of ReFree.\n     /// Should not exist after typeck.\n-    ReSkolemized(SkolemizedRegionVid, BoundRegion),\n+    ReSkolemized(ty::UniverseIndex, BoundRegion),\n \n     /// Empty lifetime is for data that is never accessed.\n     /// Bottom in the region lattice. We treat ReEmpty somewhat\n@@ -1079,11 +1079,6 @@ newtype_index!(RegionVid\n         DEBUG_FORMAT = custom,\n     });\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, PartialOrd, Ord)]\n-pub struct SkolemizedRegionVid {\n-    pub index: u32,\n-}\n-\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum InferTy {\n     TyVar(TyVid),"}, {"sha": "44771444c8aa85ea0346e5e1c77a3f386143bab0", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -153,14 +153,15 @@ impl<'tcx> ty::ParamEnv<'tcx> {\n     /// Construct a trait environment suitable for contexts where\n     /// there are no where clauses in scope.\n     pub fn empty(reveal: Reveal) -> Self {\n-        Self::new(ty::Slice::empty(), reveal)\n+        Self::new(ty::Slice::empty(), reveal, ty::UniverseIndex::ROOT)\n     }\n \n     /// Construct a trait environment with the given set of predicates.\n     pub fn new(caller_bounds: &'tcx ty::Slice<ty::Predicate<'tcx>>,\n-               reveal: Reveal)\n+               reveal: Reveal,\n+               universe: ty::UniverseIndex)\n                -> Self {\n-        ty::ParamEnv { caller_bounds, reveal }\n+        ty::ParamEnv { caller_bounds, reveal, universe }\n     }\n \n     /// Returns a new parameter environment with the same clauses, but"}, {"sha": "40c8e8aa4a29aae34a5dba9df241b68e671f0398", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -786,7 +786,7 @@ define_print! {\n                 }\n \n                 ty::ReSkolemized(id, ref bound_region) => {\n-                    write!(f, \"ReSkolemized({}, {:?})\", id.index, bound_region)\n+                    write!(f, \"ReSkolemized({:?}, {:?})\", id, bound_region)\n                 }\n \n                 ty::ReEmpty => write!(f, \"ReEmpty\"),\n@@ -916,6 +916,12 @@ impl fmt::Debug for ty::IntVarValue {\n     }\n }\n \n+impl fmt::Debug for ty::FloatVarValue {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n // The generic impl doesn't work yet because projections are not\n // normalized under HRTB.\n /*impl<T> fmt::Display for ty::Binder<T>"}, {"sha": "e1f0a74fc683d152c0516f9e22e8f311d03ab11b", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -9,6 +9,7 @@ path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n+ena = \"0.9.1\"\n log = \"0.4\"\n serialize = { path = \"../libserialize\" }\n cfg-if = \"0.1.2\""}, {"sha": "265c64858300b4f79d7dedd8fca1920faa974a49", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -39,6 +39,7 @@\n #![cfg_attr(test, feature(test))]\n \n extern crate core;\n+extern crate ena;\n #[macro_use]\n extern crate log;\n extern crate serialize as rustc_serialize; // used by deriving\n@@ -63,10 +64,10 @@ pub mod indexed_vec;\n pub mod obligation_forest;\n pub mod sip128;\n pub mod snapshot_map;\n-pub mod snapshot_vec;\n+pub use ena::snapshot_vec;\n pub mod stable_hasher;\n pub mod transitive_relation;\n-pub mod unify;\n+pub use ena::unify;\n pub mod fx;\n pub mod tuple_slice;\n pub mod control_flow_graph;"}, {"sha": "2da91918288bab77ff8266086a662ea150fc4aad", "filename": "src/librustc_data_structures/snapshot_vec.rs", "status": "removed", "additions": 0, "deletions": 230, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/3eeb5a665e313c5b281820099e04d4c6c8188b46/src%2Flibrustc_data_structures%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eeb5a665e313c5b281820099e04d4c6c8188b46/src%2Flibrustc_data_structures%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_vec.rs?ref=3eeb5a665e313c5b281820099e04d4c6c8188b46", "patch": "@@ -1,230 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A utility class for implementing \"snapshottable\" things; a snapshottable data structure permits\n-//! you to take a snapshot (via `start_snapshot`) and then, after making some changes, elect either\n-//! to rollback to the start of the snapshot or commit those changes.\n-//!\n-//! This vector is intended to be used as part of an abstraction, not serve as a complete\n-//! abstraction on its own. As such, while it will roll back most changes on its own, it also\n-//! supports a `get_mut` operation that gives you an arbitrary mutable pointer into the vector. To\n-//! ensure that any changes you make this with this pointer are rolled back, you must invoke\n-//! `record` to record any changes you make and also supplying a delegate capable of reversing\n-//! those changes.\n-use self::UndoLog::*;\n-\n-use std::mem;\n-use std::ops;\n-\n-pub enum UndoLog<D: SnapshotVecDelegate> {\n-    /// Indicates where a snapshot started.\n-    OpenSnapshot,\n-\n-    /// Indicates a snapshot that has been committed.\n-    CommittedSnapshot,\n-\n-    /// New variable with given index was created.\n-    NewElem(usize),\n-\n-    /// Variable with given index was changed *from* the given value.\n-    SetElem(usize, D::Value),\n-\n-    /// Extensible set of actions\n-    Other(D::Undo),\n-}\n-\n-pub struct SnapshotVec<D: SnapshotVecDelegate> {\n-    values: Vec<D::Value>,\n-    undo_log: Vec<UndoLog<D>>,\n-}\n-\n-// Snapshots are tokens that should be created/consumed linearly.\n-pub struct Snapshot {\n-    // Length of the undo log at the time the snapshot was taken.\n-    length: usize,\n-}\n-\n-pub trait SnapshotVecDelegate {\n-    type Value;\n-    type Undo;\n-\n-    fn reverse(values: &mut Vec<Self::Value>, action: Self::Undo);\n-}\n-\n-impl<D: SnapshotVecDelegate> SnapshotVec<D> {\n-    pub fn new() -> SnapshotVec<D> {\n-        SnapshotVec {\n-            values: Vec::new(),\n-            undo_log: Vec::new(),\n-        }\n-    }\n-\n-    pub fn with_capacity(n: usize) -> SnapshotVec<D> {\n-        SnapshotVec {\n-            values: Vec::with_capacity(n),\n-            undo_log: Vec::new(),\n-        }\n-    }\n-\n-    fn in_snapshot(&self) -> bool {\n-        !self.undo_log.is_empty()\n-    }\n-\n-    pub fn record(&mut self, action: D::Undo) {\n-        if self.in_snapshot() {\n-            self.undo_log.push(Other(action));\n-        }\n-    }\n-\n-    pub fn len(&self) -> usize {\n-        self.values.len()\n-    }\n-\n-    pub fn push(&mut self, elem: D::Value) -> usize {\n-        let len = self.values.len();\n-        self.values.push(elem);\n-\n-        if self.in_snapshot() {\n-            self.undo_log.push(NewElem(len));\n-        }\n-\n-        len\n-    }\n-\n-    pub fn get(&self, index: usize) -> &D::Value {\n-        &self.values[index]\n-    }\n-\n-    /// Returns a mutable pointer into the vec; whatever changes you make here cannot be undone\n-    /// automatically, so you should be sure call `record()` with some sort of suitable undo\n-    /// action.\n-    pub fn get_mut(&mut self, index: usize) -> &mut D::Value {\n-        &mut self.values[index]\n-    }\n-\n-    /// Updates the element at the given index. The old value will saved (and perhaps restored) if\n-    /// a snapshot is active.\n-    pub fn set(&mut self, index: usize, new_elem: D::Value) {\n-        let old_elem = mem::replace(&mut self.values[index], new_elem);\n-        if self.in_snapshot() {\n-            self.undo_log.push(SetElem(index, old_elem));\n-        }\n-    }\n-\n-    pub fn start_snapshot(&mut self) -> Snapshot {\n-        let length = self.undo_log.len();\n-        self.undo_log.push(OpenSnapshot);\n-        Snapshot { length: length }\n-    }\n-\n-    pub fn actions_since_snapshot(&self, snapshot: &Snapshot) -> &[UndoLog<D>] {\n-        &self.undo_log[snapshot.length..]\n-    }\n-\n-    fn assert_open_snapshot(&self, snapshot: &Snapshot) {\n-        // Or else there was a failure to follow a stack discipline:\n-        assert!(self.undo_log.len() > snapshot.length);\n-\n-        // Invariant established by start_snapshot():\n-        assert!(match self.undo_log[snapshot.length] {\n-            OpenSnapshot => true,\n-            _ => false,\n-        });\n-    }\n-\n-    pub fn rollback_to(&mut self, snapshot: Snapshot) {\n-        debug!(\"rollback_to({})\", snapshot.length);\n-\n-        self.assert_open_snapshot(&snapshot);\n-\n-        while self.undo_log.len() > snapshot.length + 1 {\n-            match self.undo_log.pop().unwrap() {\n-                OpenSnapshot => {\n-                    // This indicates a failure to obey the stack discipline.\n-                    panic!(\"Cannot rollback an uncommitted snapshot\");\n-                }\n-\n-                CommittedSnapshot => {\n-                    // This occurs when there are nested snapshots and\n-                    // the inner is committed but outer is rolled back.\n-                }\n-\n-                NewElem(i) => {\n-                    self.values.pop();\n-                    assert!(self.values.len() == i);\n-                }\n-\n-                SetElem(i, v) => {\n-                    self.values[i] = v;\n-                }\n-\n-                Other(u) => {\n-                    D::reverse(&mut self.values, u);\n-                }\n-            }\n-        }\n-\n-        let v = self.undo_log.pop().unwrap();\n-        assert!(match v {\n-            OpenSnapshot => true,\n-            _ => false,\n-        });\n-        assert!(self.undo_log.len() == snapshot.length);\n-    }\n-\n-    /// Commits all changes since the last snapshot. Of course, they\n-    /// can still be undone if there is a snapshot further out.\n-    pub fn commit(&mut self, snapshot: Snapshot) {\n-        debug!(\"commit({})\", snapshot.length);\n-\n-        self.assert_open_snapshot(&snapshot);\n-\n-        if snapshot.length == 0 {\n-            // The root snapshot.\n-            self.undo_log.truncate(0);\n-        } else {\n-            self.undo_log[snapshot.length] = CommittedSnapshot;\n-        }\n-    }\n-}\n-\n-impl<D: SnapshotVecDelegate> ops::Deref for SnapshotVec<D> {\n-    type Target = [D::Value];\n-    fn deref(&self) -> &[D::Value] {\n-        &*self.values\n-    }\n-}\n-\n-impl<D: SnapshotVecDelegate> ops::DerefMut for SnapshotVec<D> {\n-    fn deref_mut(&mut self) -> &mut [D::Value] {\n-        &mut *self.values\n-    }\n-}\n-\n-impl<D: SnapshotVecDelegate> ops::Index<usize> for SnapshotVec<D> {\n-    type Output = D::Value;\n-    fn index(&self, index: usize) -> &D::Value {\n-        self.get(index)\n-    }\n-}\n-\n-impl<D: SnapshotVecDelegate> ops::IndexMut<usize> for SnapshotVec<D> {\n-    fn index_mut(&mut self, index: usize) -> &mut D::Value {\n-        self.get_mut(index)\n-    }\n-}\n-\n-impl<D: SnapshotVecDelegate> Extend<D::Value> for SnapshotVec<D> {\n-    fn extend<T>(&mut self, iterable: T) where T: IntoIterator<Item=D::Value> {\n-        for item in iterable {\n-            self.push(item);\n-        }\n-    }\n-}"}, {"sha": "5411ae0257a4b050be7a05cf9b0b19189808eb86", "filename": "src/librustc_data_structures/unify/mod.rs", "status": "removed", "additions": 0, "deletions": 363, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/3eeb5a665e313c5b281820099e04d4c6c8188b46/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eeb5a665e313c5b281820099e04d4c6c8188b46/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Fmod.rs?ref=3eeb5a665e313c5b281820099e04d4c6c8188b46", "patch": "@@ -1,363 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::marker;\n-use std::fmt::Debug;\n-use std::marker::PhantomData;\n-use snapshot_vec as sv;\n-\n-#[cfg(test)]\n-mod tests;\n-\n-/// This trait is implemented by any type that can serve as a type\n-/// variable. We call such variables *unification keys*. For example,\n-/// this trait is implemented by `IntVid`, which represents integral\n-/// variables.\n-///\n-/// Each key type has an associated value type `V`. For example, for\n-/// `IntVid`, this is `Option<IntVarValue>`, representing some\n-/// (possibly not yet known) sort of integer.\n-///\n-/// Clients are expected to provide implementations of this trait; you\n-/// can see some examples in the `test` module.\n-pub trait UnifyKey: Copy + Clone + Debug + PartialEq {\n-    type Value: Clone + PartialEq + Debug;\n-\n-    fn index(&self) -> u32;\n-\n-    fn from_index(u: u32) -> Self;\n-\n-    fn tag(k: Option<Self>) -> &'static str;\n-}\n-\n-/// This trait is implemented for unify values that can be\n-/// combined. This relation should be a monoid.\n-pub trait Combine {\n-    fn combine(&self, other: &Self) -> Self;\n-}\n-\n-impl Combine for () {\n-    fn combine(&self, _other: &()) {}\n-}\n-\n-/// Value of a unification key. We implement Tarjan's union-find\n-/// algorithm: when two keys are unified, one of them is converted\n-/// into a \"redirect\" pointing at the other. These redirects form a\n-/// DAG: the roots of the DAG (nodes that are not redirected) are each\n-/// associated with a value of type `V` and a rank. The rank is used\n-/// to keep the DAG relatively balanced, which helps keep the running\n-/// time of the algorithm under control. For more information, see\n-/// <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>.\n-#[derive(PartialEq,Clone,Debug)]\n-pub struct VarValue<K: UnifyKey> {\n-    parent: K, // if equal to self, this is a root\n-    value: K::Value, // value assigned (only relevant to root)\n-    rank: u32, // max depth (only relevant to root)\n-}\n-\n-/// Table of unification keys and their values.\n-pub struct UnificationTable<K: UnifyKey> {\n-    /// Indicates the current value of each key.\n-    values: sv::SnapshotVec<Delegate<K>>,\n-}\n-\n-/// At any time, users may snapshot a unification table.  The changes\n-/// made during the snapshot may either be *committed* or *rolled back*.\n-pub struct Snapshot<K: UnifyKey> {\n-    // Link snapshot to the key type `K` of the table.\n-    marker: marker::PhantomData<K>,\n-    snapshot: sv::Snapshot,\n-}\n-\n-#[derive(Copy, Clone)]\n-struct Delegate<K>(PhantomData<K>);\n-\n-impl<K: UnifyKey> VarValue<K> {\n-    fn new_var(key: K, value: K::Value) -> VarValue<K> {\n-        VarValue::new(key, value, 0)\n-    }\n-\n-    fn new(parent: K, value: K::Value, rank: u32) -> VarValue<K> {\n-        VarValue {\n-            parent: parent, // this is a root\n-            value,\n-            rank,\n-        }\n-    }\n-\n-    fn redirect(self, to: K) -> VarValue<K> {\n-        VarValue { parent: to, ..self }\n-    }\n-\n-    fn root(self, rank: u32, value: K::Value) -> VarValue<K> {\n-        VarValue {\n-            rank,\n-            value,\n-            ..self\n-        }\n-    }\n-\n-    /// Returns the key of this node. Only valid if this is a root\n-    /// node, which you yourself must ensure.\n-    fn key(&self) -> K {\n-        self.parent\n-    }\n-\n-    fn parent(&self, self_key: K) -> Option<K> {\n-        self.if_not_self(self.parent, self_key)\n-    }\n-\n-    fn if_not_self(&self, key: K, self_key: K) -> Option<K> {\n-        if key == self_key { None } else { Some(key) }\n-    }\n-}\n-\n-/// We can't use V:LatticeValue, much as I would like to,\n-/// because frequently the pattern is that V=Option<U> for some\n-/// other type parameter U, and we have no way to say\n-/// Option<U>:LatticeValue.\n-\n-impl<K: UnifyKey> UnificationTable<K> {\n-    pub fn new() -> UnificationTable<K> {\n-        UnificationTable { values: sv::SnapshotVec::new() }\n-    }\n-\n-    /// Starts a new snapshot. Each snapshot must be either\n-    /// rolled back or committed in a \"LIFO\" (stack) order.\n-    pub fn snapshot(&mut self) -> Snapshot<K> {\n-        Snapshot {\n-            marker: marker::PhantomData::<K>,\n-            snapshot: self.values.start_snapshot(),\n-        }\n-    }\n-\n-    /// Reverses all changes since the last snapshot. Also\n-    /// removes any keys that have been created since then.\n-    pub fn rollback_to(&mut self, snapshot: Snapshot<K>) {\n-        debug!(\"{}: rollback_to()\", UnifyKey::tag(None::<K>));\n-        self.values.rollback_to(snapshot.snapshot);\n-    }\n-\n-    /// Commits all changes since the last snapshot. Of course, they\n-    /// can still be undone if there is a snapshot further out.\n-    pub fn commit(&mut self, snapshot: Snapshot<K>) {\n-        debug!(\"{}: commit()\", UnifyKey::tag(None::<K>));\n-        self.values.commit(snapshot.snapshot);\n-    }\n-\n-    pub fn new_key(&mut self, value: K::Value) -> K {\n-        let len = self.values.len();\n-        let key: K = UnifyKey::from_index(len as u32);\n-        self.values.push(VarValue::new_var(key, value));\n-        debug!(\"{}: created new key: {:?}\", UnifyKey::tag(None::<K>), key);\n-        key\n-    }\n-\n-    /// Find the root node for `vid`. This uses the standard\n-    /// union-find algorithm with path compression:\n-    /// <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>.\n-    ///\n-    /// NB. This is a building-block operation and you would probably\n-    /// prefer to call `probe` below.\n-    fn get(&mut self, vid: K) -> VarValue<K> {\n-        let index = vid.index() as usize;\n-        let mut value: VarValue<K> = self.values.get(index).clone();\n-        match value.parent(vid) {\n-            Some(redirect) => {\n-                let root: VarValue<K> = self.get(redirect);\n-                if root.key() != redirect {\n-                    // Path compression\n-                    value.parent = root.key();\n-                    self.values.set(index, value);\n-                }\n-                root\n-            }\n-            None => value,\n-        }\n-    }\n-\n-    fn is_root(&self, key: K) -> bool {\n-        let index = key.index() as usize;\n-        self.values.get(index).parent(key).is_none()\n-    }\n-\n-    /// Sets the value for `vid` to `new_value`. `vid` MUST be a root\n-    /// node! This is an internal operation used to impl other things.\n-    fn set(&mut self, key: K, new_value: VarValue<K>) {\n-        assert!(self.is_root(key));\n-\n-        debug!(\"Updating variable {:?} to {:?}\", key, new_value);\n-\n-        let index = key.index() as usize;\n-        self.values.set(index, new_value);\n-    }\n-\n-    /// Either redirects `node_a` to `node_b` or vice versa, depending\n-    /// on the relative rank. The value associated with the new root\n-    /// will be `new_value`.\n-    ///\n-    /// NB: This is the \"union\" operation of \"union-find\". It is\n-    /// really more of a building block. If the values associated with\n-    /// your key are non-trivial, you would probably prefer to call\n-    /// `unify_var_var` below.\n-    fn unify(&mut self, root_a: VarValue<K>, root_b: VarValue<K>, new_value: K::Value) -> K {\n-        debug!(\"unify(root_a(id={:?}, rank={:?}), root_b(id={:?}, rank={:?}))\",\n-               root_a.key(),\n-               root_a.rank,\n-               root_b.key(),\n-               root_b.rank);\n-\n-        if root_a.rank > root_b.rank {\n-            // a has greater rank, so a should become b's parent,\n-            // i.e., b should redirect to a.\n-            self.redirect_root(root_a.rank, root_b, root_a, new_value)\n-        } else if root_a.rank < root_b.rank {\n-            // b has greater rank, so a should redirect to b.\n-            self.redirect_root(root_b.rank, root_a, root_b, new_value)\n-        } else {\n-            // If equal, redirect one to the other and increment the\n-            // other's rank.\n-            self.redirect_root(root_a.rank + 1, root_a, root_b, new_value)\n-        }\n-    }\n-\n-    fn redirect_root(&mut self,\n-                     new_rank: u32,\n-                     old_root: VarValue<K>,\n-                     new_root: VarValue<K>,\n-                     new_value: K::Value)\n-                     -> K {\n-        let old_root_key = old_root.key();\n-        let new_root_key = new_root.key();\n-        self.set(old_root_key, old_root.redirect(new_root_key));\n-        self.set(new_root_key, new_root.root(new_rank, new_value));\n-        new_root_key\n-    }\n-}\n-\n-impl<K: UnifyKey> sv::SnapshotVecDelegate for Delegate<K> {\n-    type Value = VarValue<K>;\n-    type Undo = ();\n-\n-    fn reverse(_: &mut Vec<VarValue<K>>, _: ()) {}\n-}\n-\n-/// # Base union-find algorithm, where we are just making sets\n-\n-impl<'tcx, K: UnifyKey> UnificationTable<K>\n-    where K::Value: Combine\n-{\n-    pub fn union(&mut self, a_id: K, b_id: K) -> K {\n-        let node_a = self.get(a_id);\n-        let node_b = self.get(b_id);\n-        let a_id = node_a.key();\n-        let b_id = node_b.key();\n-        if a_id != b_id {\n-            let new_value = node_a.value.combine(&node_b.value);\n-            self.unify(node_a, node_b, new_value)\n-        } else {\n-            a_id\n-        }\n-    }\n-\n-    pub fn find(&mut self, id: K) -> K {\n-        self.get(id).key()\n-    }\n-\n-    pub fn find_value(&mut self, id: K) -> K::Value {\n-        self.get(id).value\n-    }\n-\n-    #[cfg(test)]\n-    fn unioned(&mut self, a_id: K, b_id: K) -> bool {\n-        self.find(a_id) == self.find(b_id)\n-    }\n-}\n-\n-/// # Non-subtyping unification\n-///\n-/// Code to handle keys which carry a value, like ints,\n-/// floats---anything that doesn't have a subtyping relationship we\n-/// need to worry about.\n-\n-impl<'tcx, K, V> UnificationTable<K>\n-    where K: UnifyKey<Value = Option<V>>,\n-          V: Clone + PartialEq + Debug\n-{\n-    pub fn unify_var_var(&mut self, a_id: K, b_id: K) -> Result<K, (V, V)> {\n-        let node_a = self.get(a_id);\n-        let node_b = self.get(b_id);\n-        let a_id = node_a.key();\n-        let b_id = node_b.key();\n-\n-        if a_id == b_id {\n-            return Ok(a_id);\n-        }\n-\n-        let combined = {\n-            match (&node_a.value, &node_b.value) {\n-                (&None, &None) => None,\n-                (&Some(ref v), &None) |\n-                (&None, &Some(ref v)) => Some(v.clone()),\n-                (&Some(ref v1), &Some(ref v2)) => {\n-                    if *v1 != *v2 {\n-                        return Err((v1.clone(), v2.clone()));\n-                    }\n-                    Some(v1.clone())\n-                }\n-            }\n-        };\n-\n-        Ok(self.unify(node_a, node_b, combined))\n-    }\n-\n-    /// Sets the value of the key `a_id` to `b`. Because simple keys do not have any subtyping\n-    /// relationships, if `a_id` already has a value, it must be the same as `b`.\n-    pub fn unify_var_value(&mut self, a_id: K, b: V) -> Result<(), (V, V)> {\n-        let mut node_a = self.get(a_id);\n-\n-        match node_a.value {\n-            None => {\n-                node_a.value = Some(b);\n-                self.set(node_a.key(), node_a);\n-                Ok(())\n-            }\n-\n-            Some(ref a_t) => {\n-                if *a_t == b {\n-                    Ok(())\n-                } else {\n-                    Err((a_t.clone(), b))\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn has_value(&mut self, id: K) -> bool {\n-        self.get(id).value.is_some()\n-    }\n-\n-    pub fn probe(&mut self, a_id: K) -> Option<V> {\n-        self.get(a_id).value\n-    }\n-\n-    pub fn unsolved_variables(&mut self) -> Vec<K> {\n-        self.values\n-            .iter()\n-            .filter_map(|vv| {\n-                if vv.value.is_some() {\n-                    None\n-                } else {\n-                    Some(vv.key())\n-                }\n-            })\n-            .collect()\n-    }\n-}"}, {"sha": "f29a7132e831b3f0e926968ce0d4fc6d843200fe", "filename": "src/librustc_data_structures/unify/tests.rs", "status": "removed", "additions": 0, "deletions": 205, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/3eeb5a665e313c5b281820099e04d4c6c8188b46/src%2Flibrustc_data_structures%2Funify%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eeb5a665e313c5b281820099e04d4c6c8188b46/src%2Flibrustc_data_structures%2Funify%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Ftests.rs?ref=3eeb5a665e313c5b281820099e04d4c6c8188b46", "patch": "@@ -1,205 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(non_snake_case)]\n-\n-extern crate test;\n-use self::test::Bencher;\n-use unify::{UnifyKey, UnificationTable};\n-\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-struct UnitKey(u32);\n-\n-impl UnifyKey for UnitKey {\n-    type Value = ();\n-    fn index(&self) -> u32 {\n-        self.0\n-    }\n-    fn from_index(u: u32) -> UnitKey {\n-        UnitKey(u)\n-    }\n-    fn tag(_: Option<UnitKey>) -> &'static str {\n-        \"UnitKey\"\n-    }\n-}\n-\n-#[test]\n-fn basic() {\n-    let mut ut: UnificationTable<UnitKey> = UnificationTable::new();\n-    let k1 = ut.new_key(());\n-    let k2 = ut.new_key(());\n-    assert_eq!(ut.unioned(k1, k2), false);\n-    ut.union(k1, k2);\n-    assert_eq!(ut.unioned(k1, k2), true);\n-}\n-\n-#[test]\n-fn big_array() {\n-    let mut ut: UnificationTable<UnitKey> = UnificationTable::new();\n-    let mut keys = Vec::new();\n-    const MAX: usize = 1 << 15;\n-\n-    for _ in 0..MAX {\n-        keys.push(ut.new_key(()));\n-    }\n-\n-    for i in 1..MAX {\n-        let l = keys[i - 1];\n-        let r = keys[i];\n-        ut.union(l, r);\n-    }\n-\n-    for i in 0..MAX {\n-        assert!(ut.unioned(keys[0], keys[i]));\n-    }\n-}\n-\n-#[bench]\n-fn big_array_bench(b: &mut Bencher) {\n-    let mut ut: UnificationTable<UnitKey> = UnificationTable::new();\n-    let mut keys = Vec::new();\n-    const MAX: usize = 1 << 15;\n-\n-    for _ in 0..MAX {\n-        keys.push(ut.new_key(()));\n-    }\n-\n-\n-    b.iter(|| {\n-        for i in 1..MAX {\n-            let l = keys[i - 1];\n-            let r = keys[i];\n-            ut.union(l, r);\n-        }\n-\n-        for i in 0..MAX {\n-            assert!(ut.unioned(keys[0], keys[i]));\n-        }\n-    })\n-}\n-\n-#[test]\n-fn even_odd() {\n-    let mut ut: UnificationTable<UnitKey> = UnificationTable::new();\n-    let mut keys = Vec::new();\n-    const MAX: usize = 1 << 10;\n-\n-    for i in 0..MAX {\n-        let key = ut.new_key(());\n-        keys.push(key);\n-\n-        if i >= 2 {\n-            ut.union(key, keys[i - 2]);\n-        }\n-    }\n-\n-    for i in 1..MAX {\n-        assert!(!ut.unioned(keys[i - 1], keys[i]));\n-    }\n-\n-    for i in 2..MAX {\n-        assert!(ut.unioned(keys[i - 2], keys[i]));\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-struct IntKey(u32);\n-\n-impl UnifyKey for IntKey {\n-    type Value = Option<i32>;\n-    fn index(&self) -> u32 {\n-        self.0\n-    }\n-    fn from_index(u: u32) -> IntKey {\n-        IntKey(u)\n-    }\n-    fn tag(_: Option<IntKey>) -> &'static str {\n-        \"IntKey\"\n-    }\n-}\n-\n-/// Test unifying a key whose value is `Some(_)`  with a key whose value is `None`.\n-/// Afterwards both should be `Some(_)`.\n-#[test]\n-fn unify_key_Some_key_None() {\n-    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n-    let k1 = ut.new_key(Some(22));\n-    let k2 = ut.new_key(None);\n-    assert!(ut.unify_var_var(k1, k2).is_ok());\n-    assert_eq!(ut.probe(k2), Some(22));\n-    assert_eq!(ut.probe(k1), Some(22));\n-}\n-\n-/// Test unifying a key whose value is `None`  with a key whose value is `Some(_)`.\n-/// Afterwards both should be `Some(_)`.\n-#[test]\n-fn unify_key_None_key_Some() {\n-    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n-    let k1 = ut.new_key(Some(22));\n-    let k2 = ut.new_key(None);\n-    assert!(ut.unify_var_var(k2, k1).is_ok());\n-    assert_eq!(ut.probe(k2), Some(22));\n-    assert_eq!(ut.probe(k1), Some(22));\n-}\n-\n-/// Test unifying a key whose value is `Some(x)` with a key whose value is `Some(y)`.\n-/// This should yield an error.\n-#[test]\n-fn unify_key_Some_x_key_Some_y() {\n-    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n-    let k1 = ut.new_key(Some(22));\n-    let k2 = ut.new_key(Some(23));\n-    assert_eq!(ut.unify_var_var(k1, k2), Err((22, 23)));\n-    assert_eq!(ut.unify_var_var(k2, k1), Err((23, 22)));\n-    assert_eq!(ut.probe(k1), Some(22));\n-    assert_eq!(ut.probe(k2), Some(23));\n-}\n-\n-/// Test unifying a key whose value is `Some(x)` with a key whose value is `Some(x)`.\n-/// This should be ok.\n-#[test]\n-fn unify_key_Some_x_key_Some_x() {\n-    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n-    let k1 = ut.new_key(Some(22));\n-    let k2 = ut.new_key(Some(22));\n-    assert!(ut.unify_var_var(k1, k2).is_ok());\n-    assert_eq!(ut.probe(k1), Some(22));\n-    assert_eq!(ut.probe(k2), Some(22));\n-}\n-\n-/// Test unifying a key whose value is `None` with a value is `x`.\n-/// Afterwards key should be `x`.\n-#[test]\n-fn unify_key_None_val() {\n-    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n-    let k1 = ut.new_key(None);\n-    assert!(ut.unify_var_value(k1, 22).is_ok());\n-    assert_eq!(ut.probe(k1), Some(22));\n-}\n-\n-/// Test unifying a key whose value is `Some(x)` with the value `y`.\n-/// This should yield an error.\n-#[test]\n-fn unify_key_Some_x_val_y() {\n-    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n-    let k1 = ut.new_key(Some(22));\n-    assert_eq!(ut.unify_var_value(k1, 23), Err((22, 23)));\n-    assert_eq!(ut.probe(k1), Some(22));\n-}\n-\n-/// Test unifying a key whose value is `Some(x)` with the value `x`.\n-/// This should be ok.\n-#[test]\n-fn unify_key_Some_x_val_x() {\n-    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n-    let k1 = ut.new_key(Some(22));\n-    assert!(ut.unify_var_value(k1, 22).is_ok());\n-    assert_eq!(ut.probe(k1), Some(22));\n-}"}, {"sha": "665a71a90898d725bd1eaf41be2476acfe47d1d3", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -444,7 +444,8 @@ fn sub_free_bound_false_infer() {\n     //! does NOT hold for any instantiation of `_#1`.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_infer1 = env.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n+        let t_infer1 = env.infcx.next_ty_var(ty::UniverseIndex::ROOT,\n+                                             TypeVariableOrigin::MiscVariable(DUMMY_SP));\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         env.check_not_sub(env.t_fn(&[t_infer1], env.tcx().types.isize),\n                           env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));"}, {"sha": "bc1b70ffc8e1c8b8fe1e3aac6515762be489c1dc", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -51,7 +51,6 @@ pub trait AstConv<'gcx, 'tcx> {\n     /// Same as ty_infer, but with a known type parameter definition.\n     fn ty_infer_for_def(&self,\n                         _def: &ty::TypeParameterDef,\n-                        _substs: &[Kind<'tcx>],\n                         span: Span) -> Ty<'tcx> {\n         self.ty_infer(span)\n     }\n@@ -261,7 +260,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             } else if infer_types {\n                 // No type parameters were provided, we can infer all.\n                 let ty_var = if !default_needs_object_self(def) {\n-                    self.ty_infer_for_def(def, substs, span)\n+                    self.ty_infer_for_def(def, span)\n                 } else {\n                     self.ty_infer(span)\n                 };"}, {"sha": "da66a2e52e81f78eab943e69936e635f74953753", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -329,6 +329,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let element_tys_iter = (0..max_len).map(|_| self.next_ty_var(\n                     // FIXME: MiscVariable for now, obtaining the span and name information\n                     //       from all tuple elements isn't trivial.\n+                    ty::UniverseIndex::ROOT,\n                     TypeVariableOrigin::TypeInference(pat.span)));\n                 let element_tys = tcx.mk_type_list(element_tys_iter);\n                 let pat_ty = tcx.mk_ty(ty::TyTuple(element_tys, false));\n@@ -339,7 +340,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 pat_ty\n             }\n             PatKind::Box(ref inner) => {\n-                let inner_ty = self.next_ty_var(TypeVariableOrigin::TypeInference(inner.span));\n+                let inner_ty = self.next_ty_var(ty::UniverseIndex::ROOT,\n+                                                TypeVariableOrigin::TypeInference(inner.span));\n                 let uniq_ty = tcx.mk_box(inner_ty);\n \n                 if self.check_dereferencable(pat.span, expected, &inner) {\n@@ -372,6 +374,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                         _ => {\n                             let inner_ty = self.next_ty_var(\n+                                ty::UniverseIndex::ROOT,\n                                 TypeVariableOrigin::TypeInference(inner.span));\n                             let mt = ty::TypeAndMut { ty: inner_ty, mutbl: mutbl };\n                             let region = self.next_region_var(infer::PatternRegion(pat.span));\n@@ -630,7 +633,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             // ...but otherwise we want to use any supertype of the\n             // discriminant. This is sort of a workaround, see note (*) in\n             // `check_pat` for some details.\n-            discrim_ty = self.next_ty_var(TypeVariableOrigin::TypeInference(discrim.span));\n+            discrim_ty = self.next_ty_var(ty::UniverseIndex::ROOT,\n+                                          TypeVariableOrigin::TypeInference(discrim.span));\n             self.check_expr_has_type_or_error(discrim, discrim_ty);\n         };\n \n@@ -691,7 +695,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 // arm for inconsistent arms or to the whole match when a `()` type\n                 // is required).\n                 Expectation::ExpectHasType(ety) if ety != self.tcx.mk_nil() => ety,\n-                _ => self.next_ty_var(TypeVariableOrigin::MiscVariable(expr.span)),\n+                _ => self.next_ty_var(ty::UniverseIndex::ROOT,\n+                                      TypeVariableOrigin::MiscVariable(expr.span)),\n             };\n             CoerceMany::with_coercion_sites(coerce_first, arms)\n         };"}, {"sha": "5e0c47f18bf5ac5c862de440daebdfae09e55a4b", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -110,7 +110,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             |_, _| span_bug!(expr.span, \"closure has region param\"),\n             |_, _| {\n                 self.infcx\n-                    .next_ty_var(TypeVariableOrigin::ClosureSynthetic(expr.span))\n+                    .next_ty_var(ty::UniverseIndex::ROOT,\n+                                 TypeVariableOrigin::ClosureSynthetic(expr.span))\n             },\n         );\n         let substs = ty::ClosureSubsts { substs };"}, {"sha": "e2d6817697e8fd87de5180e03b262d5d6648e87c", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -177,6 +177,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 // micro-optimization: no need for this if `b` is\n                 // already resolved in some way.\n                 let diverging_ty = self.next_diverging_ty_var(\n+                    ty::UniverseIndex::ROOT,\n                     TypeVariableOrigin::AdjustmentType(self.cause.span));\n                 self.unify_and(&b, &diverging_ty, simple(Adjust::NeverToAny))\n             } else {\n@@ -510,7 +511,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // We only have the latter, so we use an inference variable\n         // for the former and let type inference do the rest.\n         let origin = TypeVariableOrigin::MiscVariable(self.cause.span);\n-        let coerce_target = self.next_ty_var(origin);\n+        let coerce_target = self.next_ty_var(ty::UniverseIndex::ROOT, origin);\n         let mut coercion = self.unify_and(coerce_target, target, |target| {\n             let unsize = Adjustment {\n                 kind: Adjust::Unsize,"}, {"sha": "d0419382bc3123ed94d863c8df9526fe5add5ad2", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -218,7 +218,8 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // the new hybrid bounds we computed.\n     let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_node_id);\n     let param_env = ty::ParamEnv::new(tcx.intern_predicates(&hybrid_preds.predicates),\n-                                      Reveal::UserFacing);\n+                                      Reveal::UserFacing,\n+                                      ty::UniverseIndex::ROOT);\n     let param_env = traits::normalize_param_env_or_error(tcx,\n                                                          impl_m.def_id,\n                                                          param_env,"}, {"sha": "165cfe6604e8b0ec1905fa60ace5500718a8f509", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -90,7 +90,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n \n         let drop_impl_span = tcx.def_span(drop_impl_did);\n         let fresh_impl_substs =\n-            infcx.fresh_substs_for_item(drop_impl_span, drop_impl_did);\n+            infcx.fresh_substs_for_item(ty::UniverseIndex::ROOT, drop_impl_span, drop_impl_did);\n         let fresh_impl_self_ty = drop_impl_ty.subst(tcx, fresh_impl_substs);\n \n         let cause = &ObligationCause::misc(drop_impl_span, drop_impl_node_id);"}, {"sha": "b777ac30920cdab16abe9270f40ae89f1231cbd6", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -259,7 +259,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                 // the process we will unify the transformed-self-type\n                 // of the method with the actual type in order to\n                 // unify some of these variables.\n-                self.fresh_substs_for_item(self.span, trait_def_id)\n+                self.fresh_substs_for_item(ty::UniverseIndex::ROOT, self.span, trait_def_id)\n             }\n \n             probe::WhereClausePick(ref poly_trait_ref) => {\n@@ -325,7 +325,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             } else {\n                 self.region_var_for_def(self.span, def)\n             }\n-        }, |def, cur_substs| {\n+        }, |def, _cur_substs| {\n             let i = def.index as usize;\n             if i < parent_substs.len() {\n                 parent_substs.type_at(i)\n@@ -336,7 +336,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             {\n                 self.to_ty(ast_ty)\n             } else {\n-                self.type_var_for_def(self.span, def, cur_substs)\n+                self.type_var_for_def(ty::UniverseIndex::ROOT, self.span, def)\n             }\n         })\n     }"}, {"sha": "af86570309dfd9a0df5cec5a6f3d508158c288e6", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -249,13 +249,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let substs = Substs::for_item(self.tcx,\n                                       trait_def_id,\n                                       |def, _| self.region_var_for_def(span, def),\n-                                      |def, substs| {\n+                                      |def, _substs| {\n             if def.index == 0 {\n                 self_ty\n             } else if let Some(ref input_types) = opt_input_types {\n                 input_types[def.index as usize - 1]\n             } else {\n-                self.type_var_for_def(span, def, substs)\n+                self.type_var_for_def(ty::UniverseIndex::ROOT, span, def)\n             }\n         });\n "}, {"sha": "c95ead285594b8bf3d5eeee0e5e27f4bc7414d88", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -730,7 +730,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             Def::Method(def_id) => {\n                 let fty = self.tcx.fn_sig(def_id);\n                 self.probe(|_| {\n-                    let substs = self.fresh_substs_for_item(self.span, method.def_id);\n+                    let substs = self.fresh_substs_for_item(ty::UniverseIndex::ROOT,\n+                                                            self.span,\n+                                                            method.def_id);\n                     let fty = fty.subst(self.tcx, substs);\n                     let (fty, _) = self.replace_late_bound_regions_with_fresh_var(\n                         self.span, infer::FnCall, &fty);\n@@ -1304,12 +1306,12 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     // `impl_self_ty()` for an explanation.\n                     self.tcx.types.re_erased\n                 }\n-            }, |def, cur_substs| {\n+            }, |def, _cur_substs| {\n                 let i = def.index as usize;\n                 if i < substs.len() {\n                     substs.type_at(i)\n                 } else {\n-                    self.type_var_for_def(self.span, def, cur_substs)\n+                    self.type_var_for_def(ty::UniverseIndex::ROOT, self.span, def)\n                 }\n             });\n             xform_fn_sig.subst(self.tcx, substs)\n@@ -1326,6 +1328,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                          def_id,\n                          |_, _| self.tcx.types.re_erased,\n                          |_, _| self.next_ty_var(\n+                             ty::UniverseIndex::ROOT,\n                              TypeVariableOrigin::SubstitutionPlaceholder(\n                                  self.tcx.def_span(def_id))))\n     }"}, {"sha": "5c20490f8230316b392c527d50de33a9f69c5c20", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -54,7 +54,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.autoderef(span, ty).any(|(ty, _)| {\n                     self.probe(|_| {\n                         let fn_once_substs = tcx.mk_substs_trait(ty,\n-                            &[self.next_ty_var(TypeVariableOrigin::MiscVariable(span))]);\n+                            &[self.next_ty_var(ty::UniverseIndex::ROOT,\n+                                               TypeVariableOrigin::MiscVariable(span))]);\n                         let trait_ref = ty::TraitRef::new(fn_once, fn_once_substs);\n                         let poly_trait_ref = trait_ref.to_poly_trait_ref();\n                         let obligation ="}, {"sha": "df3d081f898a797aac9de64f9c27484013df010b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -362,7 +362,8 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     /// hard constraint exists, creates a fresh type variable.\n     fn coercion_target_type(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>, span: Span) -> Ty<'tcx> {\n         self.only_has_type(fcx)\n-            .unwrap_or_else(|| fcx.next_ty_var(TypeVariableOrigin::MiscVariable(span)))\n+            .unwrap_or_else(|| fcx.next_ty_var(ty::UniverseIndex::ROOT,\n+                                               TypeVariableOrigin::MiscVariable(span)))\n     }\n }\n \n@@ -921,7 +922,8 @@ impl<'a, 'gcx, 'tcx> GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n         match ty_opt {\n             None => {\n                 // infer the variable's type\n-                let var_ty = self.fcx.next_ty_var(TypeVariableOrigin::TypeInference(span));\n+                let var_ty = self.fcx.next_ty_var(ty::UniverseIndex::ROOT,\n+                                                  TypeVariableOrigin::TypeInference(span));\n                 self.fcx.locals.borrow_mut().insert(nid, var_ty);\n                 var_ty\n             }\n@@ -1025,7 +1027,8 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     let span = body.value.span;\n \n     if body.is_generator && can_be_generator.is_some() {\n-        let yield_ty = fcx.next_ty_var(TypeVariableOrigin::TypeInference(span));\n+        let yield_ty = fcx.next_ty_var(ty::UniverseIndex::ROOT,\n+                                       TypeVariableOrigin::TypeInference(span));\n         fcx.require_type_is_sized(yield_ty, span, traits::SizedYieldType);\n         fcx.yield_ty = Some(yield_ty);\n     }\n@@ -1058,7 +1061,8 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     // This ensures that all nested generators appear before the entry of this generator.\n     // resolve_generator_interiors relies on this property.\n     let gen_ty = if can_be_generator.is_some() && body.is_generator {\n-        let witness = fcx.next_ty_var(TypeVariableOrigin::MiscVariable(span));\n+        let witness = fcx.next_ty_var(ty::UniverseIndex::ROOT,\n+                                      TypeVariableOrigin::MiscVariable(span));\n         let interior = ty::GeneratorInterior {\n             witness,\n             movable: can_be_generator.unwrap() == hir::GeneratorMovability::Movable,\n@@ -1096,6 +1100,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     let mut actual_return_ty = coercion.complete(&fcx);\n     if actual_return_ty.is_never() {\n         actual_return_ty = fcx.next_diverging_ty_var(\n+            ty::UniverseIndex::ROOT,\n             TypeVariableOrigin::DivergingFn(span));\n     }\n     fcx.demand_suptype(span, ret_ty, actual_return_ty);\n@@ -1687,14 +1692,14 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n-        self.next_ty_var(TypeVariableOrigin::TypeInference(span))\n+        self.next_ty_var(ty::UniverseIndex::ROOT,\n+                         TypeVariableOrigin::TypeInference(span))\n     }\n \n     fn ty_infer_for_def(&self,\n                         ty_param_def: &ty::TypeParameterDef,\n-                        substs: &[Kind<'tcx>],\n                         span: Span) -> Ty<'tcx> {\n-        self.type_var_for_def(span, ty_param_def, substs)\n+        self.type_var_for_def(ty::UniverseIndex::ROOT, span, ty_param_def)\n     }\n \n     fn projected_ty_from_poly_trait_ref(&self,\n@@ -2316,7 +2321,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // If some lookup succeeds, write callee into table and extract index/element\n             // type from the method signature.\n             // If some lookup succeeded, install method in table\n-            let input_ty = self.next_ty_var(TypeVariableOrigin::AutoDeref(base_expr.span));\n+            let input_ty = self.next_ty_var(ty::UniverseIndex::ROOT,\n+                                            TypeVariableOrigin::AutoDeref(base_expr.span));\n             let method = self.try_overloaded_place_op(\n                 expr.span, self_ty, &[input_ty], needs, PlaceOp::Index);\n \n@@ -2755,6 +2761,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             assert!(!self.tables.borrow().adjustments().contains_key(expr.hir_id),\n                     \"expression with never type wound up being adjusted\");\n             let adj_ty = self.next_diverging_ty_var(\n+                ty::UniverseIndex::ROOT,\n                 TypeVariableOrigin::AdjustmentType(expr.span));\n             self.apply_adjustments(expr, vec![Adjustment {\n                 kind: Adjust::NeverToAny,\n@@ -2832,7 +2839,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let ity = self.tcx.type_of(did);\n         debug!(\"impl_self_ty: ity={:?}\", ity);\n \n-        let substs = self.fresh_substs_for_item(span, did);\n+        let substs = self.fresh_substs_for_item(ty::UniverseIndex::ROOT, span, did);\n         let substd_ty = self.instantiate_type_scheme(span, &substs, &ity);\n \n         TypeAndSubsts { substs: substs, ty: substd_ty }\n@@ -3972,7 +3979,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n               let element_ty = if !args.is_empty() {\n                   let coerce_to = uty.unwrap_or_else(\n-                      || self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span)));\n+                      || self.next_ty_var(ty::UniverseIndex::ROOT,\n+                                          TypeVariableOrigin::TypeInference(expr.span)));\n                   let mut coerce = CoerceMany::with_coercion_sites(coerce_to, args);\n                   assert_eq!(self.diverges.get(), Diverges::Maybe);\n                   for e in args {\n@@ -3982,7 +3990,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   }\n                   coerce.complete(self)\n               } else {\n-                  self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span))\n+                  self.next_ty_var(ty::UniverseIndex::ROOT,\n+                                   TypeVariableOrigin::TypeInference(expr.span))\n               };\n               tcx.mk_array(element_ty, args.len() as u64)\n           }\n@@ -4012,7 +4021,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     (uty, uty)\n                 }\n                 None => {\n-                    let t: Ty = self.next_ty_var(TypeVariableOrigin::MiscVariable(element.span));\n+                    let t: Ty = self.next_ty_var(ty::UniverseIndex::ROOT,\n+                                                 TypeVariableOrigin::MiscVariable(element.span));\n                     let element_ty = self.check_expr_has_type_or_error(&element, t);\n                     (element_ty, t)\n                 }\n@@ -4793,7 +4803,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // Handle Self first, so we can adjust the index to match the AST.\n                 if has_self && i == 0 {\n                     return opt_self_ty.unwrap_or_else(|| {\n-                        self.type_var_for_def(span, def, substs)\n+                        self.type_var_for_def(ty::UniverseIndex::ROOT, span, def)\n                     });\n                 }\n                 i -= has_self as usize;\n@@ -4826,7 +4836,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // This can also be reached in some error cases:\n                 // We prefer to use inference variables instead of\n                 // TyError to let type inference recover somewhat.\n-                self.type_var_for_def(span, def, substs)\n+                self.type_var_for_def(ty::UniverseIndex::ROOT, span, def)\n             }\n         });\n "}, {"sha": "12791107ebb412234f4232964daba0664e2ce153", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -174,8 +174,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // trait matching creating lifetime constraints that are too strict.\n         // E.g. adding `&'a T` and `&'b T`, given `&'x T: Add<&'x T>`, will result\n         // in `&'a T <: &'x T` and `&'b T <: &'x T`, instead of `'a = 'b = 'x`.\n-        let lhs_ty = self.check_expr_coercable_to_type_with_needs(lhs_expr,\n-            self.next_ty_var(TypeVariableOrigin::MiscVariable(lhs_expr.span)),\n+        let lhs_ty = self.check_expr_coercable_to_type_with_needs(\n+            lhs_expr,\n+            self.next_ty_var(ty::UniverseIndex::ROOT,\n+                             TypeVariableOrigin::MiscVariable(lhs_expr.span)),\n             lhs_needs);\n         let lhs_ty = self.resolve_type_vars_with_obligations(lhs_ty);\n \n@@ -185,7 +187,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // using this variable as the expected type, which sometimes lets\n         // us do better coercions than we would be able to do otherwise,\n         // particularly for things like `String + &String`.\n-        let rhs_ty_var = self.next_ty_var(TypeVariableOrigin::MiscVariable(rhs_expr.span));\n+        let rhs_ty_var = self.next_ty_var(ty::UniverseIndex::ROOT,\n+                         TypeVariableOrigin::MiscVariable(rhs_expr.span));\n \n         let result = self.lookup_op_method(lhs_ty, &[rhs_ty_var], Op::Binary(op, is_assign));\n "}, {"sha": "370fc9bbca2431224761fb82d24ab84d0cc684de", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=ddfbf2b0f4726f11bc8e857274ae1a0f8343a73f", "patch": "@@ -681,12 +681,17 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n             computed_preds.extend(user_computed_preds.iter().cloned());\n             let normalized_preds =\n                 traits::elaborate_predicates(tcx, computed_preds.clone().into_iter().collect());\n-            new_env = ty::ParamEnv::new(tcx.mk_predicates(normalized_preds), param_env.reveal);\n+            new_env = ty::ParamEnv::new(\n+                tcx.mk_predicates(normalized_preds),\n+                param_env.reveal,\n+                ty::UniverseIndex::ROOT,\n+            );\n         }\n \n         let final_user_env = ty::ParamEnv::new(\n             tcx.mk_predicates(user_computed_preds.into_iter()),\n             user_env.reveal,\n+            ty::UniverseIndex::ROOT,\n         );\n         debug!(\n             \"evaluate_nested_obligations(ty_did={:?}, trait_did={:?}): succeeded with '{:?}' \\"}]}