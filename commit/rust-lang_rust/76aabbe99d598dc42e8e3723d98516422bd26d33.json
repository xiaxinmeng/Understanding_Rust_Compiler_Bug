{"sha": "76aabbe99d598dc42e8e3723d98516422bd26d33", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2YWFiYmU5OWQ1OThkYzQyZThlMzcyM2Q5ODUxNjQyMmJkMjZkMzM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-25T13:34:31Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-25T13:34:31Z"}, "message": "Rename tag to enum throughout the compiler\n\nThis should reduce confusion of people trying to read the code.", "tree": {"sha": "3beefd7e656624cba83b6c3f503459de1ac2e299", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3beefd7e656624cba83b6c3f503459de1ac2e299"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76aabbe99d598dc42e8e3723d98516422bd26d33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76aabbe99d598dc42e8e3723d98516422bd26d33", "html_url": "https://github.com/rust-lang/rust/commit/76aabbe99d598dc42e8e3723d98516422bd26d33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76aabbe99d598dc42e8e3723d98516422bd26d33/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8420f8c52e5946f64d93c721d0f673b49ad966f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8420f8c52e5946f64d93c721d0f673b49ad966f7", "html_url": "https://github.com/rust-lang/rust/commit/8420f8c52e5946f64d93c721d0f673b49ad966f7"}], "stats": {"total": 643, "additions": 314, "deletions": 329}, "files": [{"sha": "64d28988ff42de41035936f7367ff1f029153eea", "filename": "src/comp/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcommon.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -30,7 +30,7 @@ const tag_items_data_item_symbol: uint = 0x0du;\n \n const tag_items_data_item_variant: uint = 0x0eu;\n \n-const tag_items_data_item_tag_id: uint = 0x0fu;\n+const tag_items_data_item_enum_id: uint = 0x0fu;\n \n const tag_index: uint = 0x11u;\n "}, {"sha": "1f1593ae742d2356e299b589241b5d7dc47827c7", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -9,7 +9,7 @@ import driver::session;\n export get_symbol;\n export get_type_param_count;\n export lookup_defs;\n-export get_tag_variants;\n+export get_enum_variants;\n export get_impls_for_mod;\n export get_iface_methods;\n export get_type;\n@@ -56,10 +56,10 @@ fn resolve_path(cstore: cstore::cstore, cnum: ast::crate_num,\n     ret result;\n }\n \n-fn get_tag_variants(tcx: ty::ctxt, def: ast::def_id) -> [ty::variant_info] {\n+fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id) -> [ty::variant_info] {\n     let cstore = tcx.sess.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    ret decoder::get_tag_variants(cdata, def.node, tcx)\n+    ret decoder::get_enum_variants(cdata, def.node, tcx)\n }\n \n fn get_impls_for_mod(cstore: cstore::cstore, def: ast::def_id,"}, {"sha": "fb0e25842c2e21329f58e4bfbdb3747a0b6a7192", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -11,7 +11,7 @@ import syntax::print::pprust;\n import cmd=cstore::crate_metadata;\n \n export get_symbol;\n-export get_tag_variants;\n+export get_enum_variants;\n export get_type;\n export get_type_param_count;\n export get_impl_iface;\n@@ -86,8 +86,8 @@ fn item_symbol(item: ebml::doc) -> str {\n     ret str::unsafe_from_bytes(ebml::doc_data(sym));\n }\n \n-fn variant_tag_id(d: ebml::doc) -> ast::def_id {\n-    let tagdoc = ebml::get_doc(d, tag_items_data_item_tag_id);\n+fn variant_enum_id(d: ebml::doc) -> ast::def_id {\n+    let tagdoc = ebml::get_doc(d, tag_items_data_item_enum_id);\n     ret parse_def_id(ebml::doc_data(tagdoc));\n }\n \n@@ -147,7 +147,7 @@ fn item_ty_param_count(item: ebml::doc) -> uint {\n     n\n }\n \n-fn tag_variant_ids(item: ebml::doc, cdata: cmd) -> [ast::def_id] {\n+fn enum_variant_ids(item: ebml::doc, cdata: cmd) -> [ast::def_id] {\n     let ids: [ast::def_id] = [];\n     let v = tag_items_data_item_variant;\n     ebml::tagged_docs(item, v) {|p|\n@@ -189,7 +189,7 @@ fn lookup_def(cnum: ast::crate_num, data: @[u8], did_: ast::def_id) ->\n     let item = lookup_item(did_.node, data);\n     let fam_ch = item_family(item);\n     let did = {crate: cnum, node: did_.node};\n-    // We treat references to tags as references to types.\n+    // We treat references to enums as references to types.\n     let def =\n         alt fam_ch as char {\n           'c' { ast::def_const(did) }\n@@ -205,7 +205,7 @@ fn lookup_def(cnum: ast::crate_num, data: @[u8], did_: ast::def_id) ->\n           'm' { ast::def_mod(did) }\n           'n' { ast::def_native_mod(did) }\n           'v' {\n-            let tid = variant_tag_id(item);\n+            let tid = variant_enum_id(item);\n             tid = {crate: cnum, node: tid.node};\n             ast::def_variant(tid, did)\n           }\n@@ -237,13 +237,13 @@ fn get_symbol(data: @[u8], id: ast::node_id) -> str {\n     ret item_symbol(lookup_item(id, data));\n }\n \n-fn get_tag_variants(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n+fn get_enum_variants(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     -> [ty::variant_info] {\n     let data = cdata.data;\n     let items = ebml::get_doc(ebml::new_doc(data), tag_items);\n     let item = find_item(id, items);\n     let infos: [ty::variant_info] = [];\n-    let variant_ids = tag_variant_ids(item, cdata);\n+    let variant_ids = enum_variant_ids(item, cdata);\n     let disr_val = 0;\n     for did: ast::def_id in variant_ids {\n         let item = find_item(did.node, items);"}, {"sha": "7d22749053db377e984a676d2efab29cca9939b9", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -33,7 +33,7 @@ fn encode_def_id(ebml_w: ebml::writer, id: def_id) {\n \n type entry<T> = {val: T, pos: uint};\n \n-fn encode_tag_variant_paths(ebml_w: ebml::writer, variants: [variant],\n+fn encode_enum_variant_paths(ebml_w: ebml::writer, variants: [variant],\n                             path: [str], &index: [entry<str>]) {\n     for variant: variant in variants {\n         add_to_index(ebml_w, path, index, variant.node.name);\n@@ -118,13 +118,13 @@ fn encode_module_item_paths(ebml_w: ebml::writer, module: _mod, path: [str],\n             encode_def_id(ebml_w, local_def(it.id));\n             ebml::end_tag(ebml_w);\n           }\n-          item_tag(variants, tps) {\n+          item_enum(variants, tps) {\n             add_to_index(ebml_w, path, index, it.ident);\n             ebml::start_tag(ebml_w, tag_paths_data_item);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n             ebml::end_tag(ebml_w);\n-            encode_tag_variant_paths(ebml_w, variants, path, index);\n+            encode_enum_variant_paths(ebml_w, variants, path, index);\n           }\n           item_iface(_, _) {\n             add_to_index(ebml_w, path, index, it.ident);\n@@ -222,25 +222,25 @@ fn encode_disr_val(_ecx: @encode_ctxt, ebml_w: ebml::writer, disr_val: int) {\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_tag_id(ebml_w: ebml::writer, id: def_id) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_tag_id);\n+fn encode_enum_id(ebml_w: ebml::writer, id: def_id) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_enum_id);\n     ebml_w.writer.write(str::bytes(def_to_str(id)));\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_tag_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n+fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                            id: node_id, variants: [variant],\n                            &index: [entry<int>], ty_params: [ty_param]) {\n     let disr_val = 0;\n     let i = 0;\n-    let vi = ty::tag_variants(ecx.ccx.tcx, {crate: local_crate, node: id});\n+    let vi = ty::enum_variants(ecx.ccx.tcx, {crate: local_crate, node: id});\n     for variant: variant in variants {\n         index += [{val: variant.node.id, pos: ebml_w.writer.tell()}];\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n         encode_family(ebml_w, 'v' as u8);\n         encode_name(ebml_w, variant.node.name);\n-        encode_tag_id(ebml_w, local_def(id));\n+        encode_enum_id(ebml_w, local_def(id));\n         encode_type(ecx, ebml_w,\n                     node_id_to_monotype(ecx.ccx.tcx, variant.node.id));\n         if vec::len::<variant_arg>(variant.node.args) > 0u {\n@@ -324,7 +324,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_name(ebml_w, item.ident);\n         ebml::end_tag(ebml_w);\n       }\n-      item_tag(variants, tps) {\n+      item_enum(variants, tps) {\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 't' as u8);\n@@ -335,7 +335,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             encode_variant_id(ebml_w, local_def(v.node.id));\n         }\n         ebml::end_tag(ebml_w);\n-        encode_tag_variant_info(ecx, ebml_w, item.id, variants, index, tps);\n+        encode_enum_variant_info(ecx, ebml_w, item.id, variants, index, tps);\n       }\n       item_res(_, tps, _, _, ctor_id) {\n         let fn_ty = node_id_to_monotype(tcx, ctor_id);"}, {"sha": "f5c74bd87ad499f9de9a55f4a26b7e541c3e4eda", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -202,7 +202,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         let params: [ty::t] = [];\n         while peek(st) as char != ']' { params += [parse_ty(st, conv)]; }\n         st.pos = st.pos + 1u;\n-        ret ty::mk_tag(st.tcx, def, params);\n+        ret ty::mk_enum(st.tcx, def, params);\n       }\n       'x' {\n         assert (next(st) as char == '[');"}, {"sha": "e0d734f25e4b3f7956a4345b6e9cd3b5dfb487d7", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -117,7 +117,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         }\n       }\n       ty::ty_str { w.write_char('S'); }\n-      ty::ty_tag(def, tys) {\n+      ty::ty_enum(def, tys) {\n         w.write_str(\"t[\");\n         w.write_str(cx.ds(def));\n         w.write_char('|');"}, {"sha": "fb1ff020997c02948bc10bdc00be89e58d71c785", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -502,7 +502,7 @@ fn ty_can_unsafely_include(cx: ctx, needle: unsafe_ty, haystack: ty::t,\n           mut_contains(ty) { mut && ty == haystack }\n         } { ret true; }\n         alt ty::struct(tcx, haystack) {\n-          ty::ty_tag(_, ts) {\n+          ty::ty_enum(_, ts) {\n             for t: ty::t in ts {\n                 if helper(tcx, needle, t, mut) { ret true; }\n             }\n@@ -565,7 +565,7 @@ fn copy_is_expensive(tcx: ty::ctxt, ty: ty::t) -> bool {\n           ty::ty_fn(_) | ty::ty_native_fn(_, _) { 4u }\n           ty::ty_str | ty::ty_vec(_) | ty::ty_param(_, _) { 50u }\n           ty::ty_uniq(mt) { 1u + score_ty(tcx, mt.ty) }\n-          ty::ty_tag(_, ts) | ty::ty_tup(ts) {\n+          ty::ty_enum(_, ts) | ty::ty_tup(ts) {\n             let sum = 0u;\n             for t in ts { sum += score_ty(tcx, t); }\n             sum\n@@ -596,7 +596,7 @@ fn pattern_roots(tcx: ty::ctxt, mut: option::t<unsafe_ty>, pat: @ast::pat)\n                         span: pat.span}];\n             alt sub { some(p) { walk(tcx, mut, p, set); } _ {} }\n           }\n-          ast::pat_tag(_, ps) | ast::pat_tup(ps) {\n+          ast::pat_enum(_, ps) | ast::pat_tup(ps) {\n             for p in ps { walk(tcx, mut, p, set); }\n           }\n           ast::pat_rec(fs, _) {"}, {"sha": "e78b9ddb77f8f9cd180b8ce5be3dc4d08425783f", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -80,9 +80,9 @@ fn pattern_supersedes(tcx: ty::ctxt, a: @pat, b: @pat) -> bool {\n           _ { false }\n         }\n       }\n-      pat_tag(va, suba) {\n+      pat_enum(va, suba) {\n         alt b.node {\n-          pat_tag(vb, subb) {\n+          pat_enum(vb, subb) {\n             tcx.def_map.get(a.id) == tcx.def_map.get(b.id) &&\n                 patterns_supersede(tcx, suba, subb)\n           }\n@@ -154,9 +154,9 @@ fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n         for elt in elts { if is_refutable(tcx, elt) { ret true; } }\n         false\n       }\n-      pat_tag(_, args) {\n+      pat_enum(_, args) {\n         let vdef = variant_def_ids(tcx.def_map.get(pat.id));\n-        if vec::len(*ty::tag_variants(tcx, vdef.tg)) != 1u { ret true; }\n+        if vec::len(*ty::enum_variants(tcx, vdef.tg)) != 1u { ret true; }\n         for p: @pat in args { if is_refutable(tcx, p) { ret true; } }\n         false\n       }"}, {"sha": "78eec533e3fbcad07f3c13ee3c2b65f587e646e0", "filename": "src/comp/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_const.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -15,7 +15,7 @@ fn check_crate(sess: session, crate: @crate) {\n fn check_item(it: @item, &&_is_const: bool, v: visit::vt<bool>) {\n     alt it.node {\n       item_const(_, ex) { v.visit_expr(ex, true, v); }\n-      item_tag(vs, _) {\n+      item_enum(vs, _) {\n         for var in vs {\n             option::may(var.node.disr_expr) {|ex|\n                 v.visit_expr(ex, true, v);"}, {"sha": "40b4f8ebb3ca9661dfae740d54b43bb5287a4758", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -108,11 +108,6 @@ fn type_is_gc_relevant(cx: ty::ctxt, ty: ty::t) -> bool {\n       ty::ty_type | ty::ty_ptr(_) | ty::ty_native(_) {\n         ret false;\n       }\n-\n-\n-\n-\n-\n       ty::ty_rec(fields) {\n         for f in fields { if type_is_gc_relevant(cx, f.mt.ty) { ret true; } }\n         ret false;\n@@ -121,13 +116,8 @@ fn type_is_gc_relevant(cx: ty::ctxt, ty: ty::t) -> bool {\n         for elt in elts { if type_is_gc_relevant(cx, elt) { ret true; } }\n         ret false;\n       }\n-\n-\n-\n-\n-\n-      ty::ty_tag(did, tps) {\n-        let variants = ty::tag_variants(cx, did);\n+      ty::ty_enum(did, tps) {\n+        let variants = ty::enum_variants(cx, did);\n         for variant in *variants {\n             for aty in variant.args {\n                 let arg_ty = ty::substitute_type_params(cx, tps, aty);\n@@ -136,11 +126,6 @@ fn type_is_gc_relevant(cx: ty::ctxt, ty: ty::t) -> bool {\n         }\n         ret false;\n       }\n-\n-\n-\n-\n-\n       ty::ty_vec(tm) {\n         ret type_is_gc_relevant(cx, tm.ty);\n       }"}, {"sha": "87a2c596fde3b79fc437b8396357bfad687da3c0", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -31,8 +31,8 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n                 ds += [@{mut: false, kind: unbox, outer_t: t}];\n                 t = ty::substitute_type_params(tcx, tps, inner);\n               }\n-              ty::ty_tag(did, tps) {\n-                let variants = ty::tag_variants(tcx, did);\n+              ty::ty_enum(did, tps) {\n+                let variants = ty::enum_variants(tcx, did);\n                 if vec::len(*variants) != 1u ||\n                        vec::len(variants[0].args) != 1u {\n                     break;\n@@ -90,7 +90,7 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n                   ty::ty_box(mt) { is_mut = mt.mut == mut; }\n                   ty::ty_uniq(mt) { is_mut = mt.mut == mut; }\n                   ty::ty_res(_, _, _) { }\n-                  ty::ty_tag(_, _) { }\n+                  ty::ty_enum(_, _) { }\n                   ty::ty_ptr(mt) { is_mut = mt.mut == mut; }\n                 }\n                 ds += [@{mut: is_mut, kind: unbox, outer_t: base_t}];"}, {"sha": "023d49db8a1246eb8282d0f3d4c02f96dccf1368", "filename": "src/comp/middle/pat_util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fpat_util.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -22,8 +22,8 @@ fn normalize_pat_def_map(dm: resolve::def_map, p: @pat) -> @pat {\n         @{node: pat_ident(q, some(normalize_pat_def_map(dm, r)))\n             with *p}\n       }\n-      pat_tag(a_path, subs) {\n-        @{node: pat_tag(a_path,\n+      pat_enum(a_path, subs) {\n+        @{node: pat_enum(a_path,\n            vec::map(subs, {|p| normalize_pat_def_map(dm, p)})) with *p}\n       }\n       pat_rec(field_pats, b) {\n@@ -52,8 +52,8 @@ fn normalize_one(dm: resolve::def_map, p: @pat) -> @pat {\n     alt dm.find(p.id) {\n         some(d) {\n           alt p.node {\n-              pat_ident(tag_path, _) { @{id: p.id,\n-                    node: pat_tag(tag_path, []),\n+              pat_ident(enum_path, _) { @{id: p.id,\n+                    node: pat_enum(enum_path, []),\n                     span: p.span} }\n               _ { p }\n           }\n@@ -95,7 +95,7 @@ fn pat_bindings(pat: @pat, it: fn(@pat)) {\n   alt pat.node {\n       pat_ident(_, option::none) { it(pat); }\n       pat_ident(_, option::some(sub)) { it(pat); pat_bindings(sub, it); }\n-      pat_tag(_, sub) { for p in sub { pat_bindings(p, it); } }\n+      pat_enum(_, sub) { for p in sub { pat_bindings(p, it); } }\n       pat_rec(fields, _) { for f in fields { pat_bindings(f.pat, it); } }\n       pat_tup(elts) { for elt in elts { pat_bindings(elt, it); } }\n       pat_box(sub) { pat_bindings(sub, it); }"}, {"sha": "6515b26644b921a8cba3de686c52b86728994380", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -103,7 +103,7 @@ enum mod_index_entry {\n     mie_import_ident(node_id, codemap::span),\n     mie_item(@ast::item),\n     mie_native_item(@ast::native_item),\n-    mie_tag_variant(/* enum item */@ast::item, /* variant index */uint),\n+    mie_enum_variant(/* enum item */@ast::item, /* variant index */uint),\n }\n \n type mod_index = hashmap<ident, list<mod_index_entry>>;\n@@ -119,8 +119,9 @@ type indexed_mod = {\n     path: str\n };\n \n-/* native modules can't contain tags, and we don't store their ASTs because we\n-   only need to look at them to determine exports, which they can't control.*/\n+/* native modules can't contain enums, and we don't store their ASTs because\n+   we only need to look at them to determine exports, which they can't\n+   control.*/\n \n type def_map = hashmap<node_id, def>;\n type ext_map = hashmap<def_id, [ident]>;\n@@ -158,7 +159,7 @@ enum dir { inside, outside, }\n // when looking up a variable name that's not yet in scope to check\n // if it's already bound to a enum.\n enum namespace { ns_val(ns_value_type), ns_type, ns_module, }\n-enum ns_value_type { ns_a_tag, ns_any_value, }\n+enum ns_value_type { ns_a_enum, ns_any_value, }\n \n fn resolve_crate(sess: session, amap: ast_map::map, crate: @ast::crate) ->\n    {def_map: def_map, exp_map: exp_map, impl_map: impl_map} {\n@@ -406,7 +407,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n     fn walk_pat(e: @env, pat: @ast::pat, sc: scopes, v: vt<scopes>) {\n         visit::visit_pat(pat, sc, v);\n         alt pat.node {\n-          ast::pat_tag(p, _) {\n+          ast::pat_enum(p, _) {\n             let fnd = lookup_path_strict(*e, sc, p.span, p.node,\n                                            ns_val(ns_any_value));\n             alt option::get(fnd) {\n@@ -424,7 +425,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n            variable a refers to a nullary enum. */\n           ast::pat_ident(p, none) {\n               let fnd = lookup_in_scope(*e, sc, p.span, path_to_ident(p),\n-                                    ns_val(ns_a_tag));\n+                                    ns_val(ns_a_enum));\n               alt fnd {\n                 some(ast::def_variant(did, vid)) {\n                     e.def_map.insert(pat.id, ast::def_variant(did, vid));\n@@ -566,11 +567,11 @@ fn visit_local_with_scope(e: @env, loc: @local, sc:scopes, v:vt<scopes>) {\n     // to enum foo, or is it binding a new name foo?)\n     alt loc.node.pat.node {\n       pat_ident(an_ident,_) {\n-          // Be sure to pass ns_a_tag to lookup_in_scope so that\n+          // Be sure to pass ns_a_enum to lookup_in_scope so that\n           // if this is a name that's being shadowed, we don't die\n           alt lookup_in_scope(*e, sc, loc.span,\n-                 path_to_ident(an_ident), ns_val(ns_a_tag)) {\n-              some(ast::def_variant(tag_id,variant_id)) {\n+                 path_to_ident(an_ident), ns_val(ns_a_enum)) {\n+              some(ast::def_variant(enum_id,variant_id)) {\n                   // Declaration shadows a enum that's in scope.\n                   // That's an error.\n                   e.sess.span_err(loc.span,\n@@ -742,7 +743,7 @@ fn ns_name(ns: namespace) -> str {\n       ns_val(v) {\n           alt (v) {\n               ns_any_value { \"name\" }\n-              ns_a_tag     { \"enum\" }\n+              ns_a_enum    { \"enum\" }\n           }\n       }\n       ns_module { ret \"modulename\" }\n@@ -893,7 +894,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n               ast::item_impl(tps, _, _, _) {\n                 if ns == ns_type { ret lookup_in_ty_params(e, name, tps); }\n               }\n-              ast::item_iface(tps, _) | ast::item_tag(_, tps) |\n+              ast::item_iface(tps, _) | ast::item_enum(_, tps) |\n               ast::item_ty(_, tps) {\n                 if ns == ns_type { ret lookup_in_ty_params(e, name, tps); }\n               }\n@@ -970,7 +971,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n                             /* If we were looking for a enum, at this point\n                                we know it's bound to a non-enum value, and\n                                we can return none instead of failing */\n-                            ns_a_tag { ret none; }\n+                            ns_a_enum { ret none; }\n                             _ { \"attempted dynamic environment-capture\" }\n                           }\n                       }\n@@ -1074,7 +1075,7 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n               }\n               ast::decl_item(it) {\n                 alt it.node {\n-                  ast::item_tag(variants, _) {\n+                  ast::item_enum(variants, _) {\n                     if ns == ns_type {\n                         if str::eq(it.ident, name) {\n                             ret some(ast::def_ty(local_def(it.id)));\n@@ -1150,7 +1151,7 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option::t<def> {\n       ast::item_native_mod(_) {\n         if ns == ns_module { ret some(ast::def_native_mod(local_def(i.id))); }\n       }\n-      ast::item_ty(_, _) | item_iface(_, _) | item_tag(_, _) {\n+      ast::item_ty(_, _) | item_iface(_, _) | item_enum(_, _) {\n         if ns == ns_type { ret some(ast::def_ty(local_def(i.id))); }\n       }\n       ast::item_res(_, _, _, _, ctor_id) {\n@@ -1292,7 +1293,7 @@ fn lookup_in_globs(e: env, globs: [glob_imp_def], sp: span, id: ident,\n     if vec::len(matches) == 0u {\n         ret none;\n         }\n-    else if vec::len(matches) == 1u || ns == ns_val(ns_a_tag) {\n+    else if vec::len(matches) == 1u || ns == ns_val(ns_a_enum) {\n         ret some(matches[0].def);\n     } else {\n         for match: glob_imp_def in matches {\n@@ -1312,8 +1313,8 @@ fn lookup_glob_in_mod(e: env, info: @indexed_mod, sp: span, id: ident,\n         info.glob_imported_names.insert(id, glob_resolving(sp));\n         let val = lookup_in_globs(e, info.glob_imports, sp, id,\n                                   // kludge\n-                                  (if wanted_ns == ns_val(ns_a_tag)\n-                                  { ns_val(ns_a_tag) }\n+                                  (if wanted_ns == ns_val(ns_a_enum)\n+                                  { ns_val(ns_a_enum) }\n                                   else { ns_val(ns_any_value) }), dr);\n         let typ = lookup_in_globs(e, info.glob_imports, sp, id, ns_type, dr);\n         let md = lookup_in_globs(e, info.glob_imports, sp, id, ns_module, dr);\n@@ -1341,9 +1342,9 @@ fn lookup_in_mie(e: env, mie: mod_index_entry, ns: namespace) ->\n       }\n       mie_import_ident(id, _) { ret lookup_import(e, local_def(id), ns); }\n       mie_item(item) { ret found_def_item(item, ns); }\n-      mie_tag_variant(item, variant_idx) {\n+      mie_enum_variant(item, variant_idx) {\n         alt item.node {\n-          ast::item_tag(variants, _) {\n+          ast::item_enum(variants, _) {\n               alt ns {\n                   ns_val(_) {\n                      let vid = variants[variant_idx].node.id;\n@@ -1415,12 +1416,12 @@ fn index_mod(md: ast::_mod) -> mod_index {\n           ast::item_impl(_, _, _, _) | ast::item_iface(_, _) {\n             add_to_index(index, it.ident, mie_item(it));\n           }\n-          ast::item_tag(variants, _) {\n+          ast::item_enum(variants, _) {\n             add_to_index(index, it.ident, mie_item(it));\n             let variant_idx: uint = 0u;\n             for v: ast::variant in variants {\n                 add_to_index(index, v.node.name,\n-                             mie_tag_variant(it, variant_idx));\n+                             mie_enum_variant(it, variant_idx));\n                 variant_idx += 1u;\n             }\n           }\n@@ -1458,7 +1459,7 @@ fn index_nmod(md: ast::native_mod) -> mod_index {\n // External lookups\n fn ns_for_def(d: def) -> namespace {\n     alt d {\n-      ast::def_variant(_, _) { ns_val(ns_a_tag) }\n+      ast::def_variant(_, _) { ns_val(ns_a_enum) }\n       ast::def_fn(_, _) | ast::def_self(_) |\n       ast::def_const(_) | ast::def_arg(_, _) | ast::def_local(_, _) |\n       ast::def_upvar(_, _, _) |  ast::def_native_fn(_, _) | ast::def_self(_)\n@@ -1473,7 +1474,7 @@ fn ns_for_def(d: def) -> namespace {\n // a enum\n fn ns_ok(wanted:namespace, actual:namespace) -> bool {\n     alt actual {\n-      ns_val(ns_a_tag) {\n+      ns_val(ns_a_enum) {\n         alt wanted {\n           ns_val(_) { true }\n           _ { false }\n@@ -1548,7 +1549,7 @@ fn mie_span(mie: mod_index_entry) -> span {\n           mie_view_item(item) { item.span }\n           mie_import_ident(_, span) { span }\n           mie_item(item) { item.span }\n-          mie_tag_variant(item, _) { item.span }\n+          mie_enum_variant(item, _) { item.span }\n           mie_native_item(item) { item.span }\n         };\n }\n@@ -1566,7 +1567,7 @@ fn check_item(e: @env, i: @ast::item, &&x: (), v: vt<()>) {\n         ensure_unique(*e, i.span, typaram_names(ty_params), ident_id,\n                       \"type parameter\");\n       }\n-      ast::item_tag(_, ty_params) {\n+      ast::item_enum(_, ty_params) {\n         ensure_unique(*e, i.span, typaram_names(ty_params), ident_id,\n                       \"type parameter\");\n       }\n@@ -1635,7 +1636,7 @@ fn check_block(e: @env, b: ast::blk, &&x: (), v: vt<()>) {\n               }\n               ast::decl_item(it) {\n                 alt it.node {\n-                  ast::item_tag(variants, _) {\n+                  ast::item_enum(variants, _) {\n                     add_name(types, it.span, it.ident);\n                     for v: ast::variant in variants {\n                         add_name(values, v.span, v.node.name);\n@@ -1776,7 +1777,7 @@ fn check_exports(e: @env) {\n                   alt m {\n                      mie_item(an_item) {\n                       alt an_item.node {\n-                          item_tag(_,_) { /* OK */ some(an_item.id) }\n+                          item_enum(_,_) { /* OK */ some(an_item.id) }\n                           _ { none }\n                       }\n                      }\n@@ -1802,10 +1803,10 @@ fn check_exports(e: @env) {\n                         check_export(e, ident, val, vi);\n                     }\n                   }\n-                  ast::view_item_export_tag_none(id, _) {\n+                  ast::view_item_export_enum_none(id, _) {\n                       let _ = check_enum_ok(e, vi.span, id, val);\n                   }\n-                  ast::view_item_export_tag_some(id, ids, _) {\n+                  ast::view_item_export_enum_some(id, ids, _) {\n                       // Check that it's an enum and all the given variants\n                       // belong to it\n                       let parent_id = check_enum_ok(e, vi.span, id, val);\n@@ -1814,7 +1815,7 @@ fn check_exports(e: @env) {\n                             some(ms) {\n                                 list::iter(ms) {|m|\n                                    alt m {\n-                                     mie_tag_variant(parent_item,_) {\n+                                     mie_enum_variant(parent_item,_) {\n                                        if parent_item.id != parent_id {\n                                           e.sess.span_err(vi.span,\n                                            #fmt(\"variant %s \\"}, {"sha": "2196373b91e6fcb76c40f02241d91de1d8cda235", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -8,7 +8,7 @@ import driver::session;\n import driver::session::session;\n import middle::{trans, trans_common};\n import middle::trans_common::{crate_ctxt, val_ty, C_bytes, C_int,\n-                              C_named_struct, C_struct, T_tag_variant,\n+                              C_named_struct, C_struct, T_enum_variant,\n                               block_ctxt, result, rslt, bcx_ccx, bcx_tcx,\n                               type_has_static_size, umax, umin, align_to,\n                               tydesc_info};\n@@ -51,7 +51,7 @@ const shape_f32: u8 = 8u8;\n const shape_f64: u8 = 9u8;\n // (10 is currently unused, was evec)\n const shape_vec: u8 = 11u8;\n-const shape_tag: u8 = 12u8;\n+const shape_enum: u8 = 12u8;\n const shape_box: u8 = 13u8;\n const shape_struct: u8 = 17u8;\n const shape_box_fn: u8 = 18u8;\n@@ -119,7 +119,7 @@ fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n     // contains (T,T) must be as least as large as any variant that contains\n     // just T.\n     let ranges = [];\n-    let variants = ty::tag_variants(ccx.tcx, tag_id);\n+    let variants = ty::enum_variants(ccx.tcx, tag_id);\n     for variant: ty::variant_info in *variants {\n         let bounded = true;\n         let {a: min_size, b: min_align} = {a: 0u, b: 0u};\n@@ -201,17 +201,17 @@ fn round_up(size: u16, align: u8) -> u16 {\n \n type size_align = {size: u16, align: u8};\n \n-fn compute_static_tag_size(ccx: @crate_ctxt, largest_variants: [uint],\n+fn compute_static_enum_size(ccx: @crate_ctxt, largest_variants: [uint],\n                            did: ast::def_id) -> size_align {\n     let max_size = 0u16;\n     let max_align = 1u8;\n-    let variants = ty::tag_variants(ccx.tcx, did);\n+    let variants = ty::enum_variants(ccx.tcx, did);\n     for vid: uint in largest_variants {\n         // We increment a \"virtual data pointer\" to compute the size.\n         let lltys = [];\n         for typ: ty::t in variants[vid].args {\n             // FIXME: there should really be a postcondition\n-            // on tag_variants that would obviate the need for\n+            // on enum_variants that would obviate the need for\n             // this check. (Issue #586)\n             check (trans_common::type_has_static_size(ccx, typ));\n             lltys += [trans::type_of(ccx, dummy_sp(), typ)];\n@@ -229,7 +229,7 @@ fn compute_static_tag_size(ccx: @crate_ctxt, largest_variants: [uint],\n     // FIXME (issue #792): This is wrong. If the enum starts with an 8 byte\n     // aligned quantity, we don't align it.\n     if vec::len(*variants) > 1u {\n-        let variant_t = T_tag_variant(ccx);\n+        let variant_t = T_enum_variant(ccx);\n         max_size += llsize_of_real(ccx, variant_t) as u16;\n         let align = llalign_of_real(ccx, variant_t) as u8;\n         if max_align < align { max_align = align; }\n@@ -238,15 +238,15 @@ fn compute_static_tag_size(ccx: @crate_ctxt, largest_variants: [uint],\n     ret {size: max_size, align: max_align};\n }\n \n-enum tag_kind {\n+enum enum_kind {\n     tk_unit,    // 1 variant, no data\n     tk_enum,    // N variants, no data\n     tk_newtype, // 1 variant, data\n     tk_complex  // N variants, no data\n }\n \n-fn tag_kind(ccx: @crate_ctxt, did: ast::def_id) -> tag_kind {\n-    let variants = ty::tag_variants(ccx.tcx, did);\n+fn enum_kind(ccx: @crate_ctxt, did: ast::def_id) -> enum_kind {\n+    let variants = ty::enum_variants(ccx.tcx, did);\n     if vec::any(*variants) {|v| vec::len(v.args) > 0u} {\n         if vec::len(*variants) == 1u { tk_newtype }\n         else { tk_complex }\n@@ -281,7 +281,7 @@ fn s_float(tcx: ty_ctxt) -> u8 {\n     };\n }\n \n-fn s_variant_tag_t(tcx: ty_ctxt) -> u8 {\n+fn s_variant_enum_t(tcx: ty_ctxt) -> u8 {\n     ret s_int(tcx);\n }\n \n@@ -349,15 +349,15 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n         let unit_ty = ty::mk_mach_uint(ccx.tcx, ast::ty_u8);\n         add_substr(s, shape_of(ccx, unit_ty, ty_param_map));\n       }\n-      ty::ty_tag(did, tps) {\n-        alt tag_kind(ccx, did) {\n+      ty::ty_enum(did, tps) {\n+        alt enum_kind(ccx, did) {\n           tk_unit {\n             // FIXME: For now we do this.\n-            s += [s_variant_tag_t(ccx.tcx)];\n+            s += [s_variant_enum_t(ccx.tcx)];\n           }\n-          tk_enum { s += [s_variant_tag_t(ccx.tcx)]; }\n+          tk_enum { s += [s_variant_enum_t(ccx.tcx)]; }\n           tk_newtype | tk_complex {\n-            s += [shape_tag];\n+            s += [shape_enum];\n \n             let sub = [];\n \n@@ -481,16 +481,16 @@ fn shape_of_variant(ccx: @crate_ctxt, v: ty::variant_info,\n //    }\n //}\n \n-fn gen_tag_shapes(ccx: @crate_ctxt) -> ValueRef {\n-    // Loop over all the enum variants and write their shapes into a data\n-    // buffer. As we do this, it's possible for us to discover new tags, so we\n-    // must do this first.\n+fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n+    // Loop over all the enum variants and write their shapes into a\n+    // data buffer. As we do this, it's possible for us to discover\n+    // new enums, so we must do this first.\n     let i = 0u;\n     let data = [];\n     let offsets = [];\n     while i < vec::len(ccx.shape_cx.tag_order) {\n         let did = ccx.shape_cx.tag_order[i];\n-        let variants = ty::tag_variants(ccx.tcx, did);\n+        let variants = ty::enum_variants(ccx.tcx, did);\n         let item_tyt = ty::lookup_item_type(ccx.tcx, did);\n         let ty_param_count = vec::len(*item_tyt.bounds);\n \n@@ -519,7 +519,7 @@ fn gen_tag_shapes(ccx: @crate_ctxt) -> ValueRef {\n     let info_sz = 0u16;\n     for did_: ast::def_id in ccx.shape_cx.tag_order {\n         let did = did_; // Satisfy alias checker.\n-        let num_variants = vec::len(*ty::tag_variants(ccx.tcx, did)) as u16;\n+        let num_variants = vec::len(*ty::enum_variants(ccx.tcx, did)) as u16;\n         add_u16(header, header_sz + info_sz);\n         info_sz += 2u16 * (num_variants + 2u16) + 3u16;\n     }\n@@ -532,7 +532,7 @@ fn gen_tag_shapes(ccx: @crate_ctxt) -> ValueRef {\n     i = 0u;\n     for did_: ast::def_id in ccx.shape_cx.tag_order {\n         let did = did_; // Satisfy alias checker.\n-        let variants = ty::tag_variants(ccx.tcx, did);\n+        let variants = ty::enum_variants(ccx.tcx, did);\n         add_u16(info, vec::len(*variants) as u16);\n \n         // Construct the largest-variants table.\n@@ -556,7 +556,7 @@ fn gen_tag_shapes(ccx: @crate_ctxt) -> ValueRef {\n         let size_align;\n         if dynamic {\n             size_align = {size: 0u16, align: 0u8};\n-        } else { size_align = compute_static_tag_size(ccx, lv, did); }\n+        } else { size_align = compute_static_enum_size(ccx, lv, did); }\n         add_u16(info, size_align.size);\n         info += [size_align.align];\n \n@@ -593,7 +593,7 @@ fn gen_resource_shapes(ccx: @crate_ctxt) -> ValueRef {\n }\n \n fn gen_shape_tables(ccx: @crate_ctxt) {\n-    let lltagstable = gen_tag_shapes(ccx);\n+    let lltagstable = gen_enum_shapes(ccx);\n     let llresourcestable = gen_resource_shapes(ccx);\n     trans_common::set_struct_body(ccx.shape_cx.llshapetablesty,\n                                   [val_ty(lltagstable),\n@@ -676,15 +676,15 @@ fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n }\n \n // Computes the size of the data part of a non-dynamically-sized enum.\n-fn static_size_of_tag(cx: @crate_ctxt, sp: span, t: ty::t)\n+fn static_size_of_enum(cx: @crate_ctxt, sp: span, t: ty::t)\n     : type_has_static_size(cx, t) -> uint {\n-    if cx.tag_sizes.contains_key(t) { ret cx.tag_sizes.get(t); }\n+    if cx.enum_sizes.contains_key(t) { ret cx.enum_sizes.get(t); }\n     alt ty::struct(cx.tcx, t) {\n-      ty::ty_tag(tid, subtys) {\n+      ty::ty_enum(tid, subtys) {\n         // Compute max(variant sizes).\n \n         let max_size = 0u;\n-        let variants = ty::tag_variants(cx.tcx, tid);\n+        let variants = ty::enum_variants(cx.tcx, tid);\n         for variant: ty::variant_info in *variants {\n             let tup_ty = simplify_type(cx, ty::mk_tup(cx.tcx, variant.args));\n             // Perform any type parameter substitutions.\n@@ -700,11 +700,12 @@ fn static_size_of_tag(cx: @crate_ctxt, sp: span, t: ty::t)\n                 llsize_of_real(cx, trans::type_of(cx, sp, tup_ty));\n             if max_size < this_size { max_size = this_size; }\n         }\n-        cx.tag_sizes.insert(t, max_size);\n+        cx.enum_sizes.insert(t, max_size);\n         ret max_size;\n       }\n       _ {\n-        cx.tcx.sess.span_fatal(sp, \"non-enum passed to static_size_of_tag()\");\n+        cx.tcx.sess.span_fatal(\n+            sp, \"non-enum passed to static_size_of_enum()\");\n       }\n     }\n }\n@@ -754,15 +755,15 @@ fn dynamic_metrics(cx: @block_ctxt, t: ty::t) -> metrics {\n         for tp in elts { tys += [tp]; }\n         align_elements(cx, tys)\n       }\n-      ty::ty_tag(tid, tps) {\n+      ty::ty_enum(tid, tps) {\n         let bcx = cx;\n         let ccx = bcx_ccx(bcx);\n \n         let compute_max_variant_size = fn@(bcx: @block_ctxt) -> result {\n             // Compute max(variant sizes).\n             let bcx = bcx;\n             let max_size: ValueRef = C_int(ccx, 0);\n-            let variants = ty::tag_variants(bcx_tcx(bcx), tid);\n+            let variants = ty::enum_variants(bcx_tcx(bcx), tid);\n             for variant: ty::variant_info in *variants {\n                 // Perform type substitution on the raw argument types.\n                 let tys = vec::map(variant.args) {|raw_ty|\n@@ -775,12 +776,12 @@ fn dynamic_metrics(cx: @block_ctxt, t: ty::t) -> metrics {\n             rslt(bcx, max_size)\n         };\n \n-        let {bcx, val: sz} = alt tag_kind(ccx, tid) {\n-          tk_unit | tk_enum { rslt(bcx, llsize_of(ccx, T_tag_variant(ccx))) }\n+        let {bcx, val: sz} = alt enum_kind(ccx, tid) {\n+          tk_unit | tk_enum { rslt(bcx, llsize_of(ccx, T_enum_variant(ccx))) }\n           tk_newtype { compute_max_variant_size(bcx) }\n           tk_complex {\n             let {bcx, val} = compute_max_variant_size(bcx);\n-            rslt(bcx, Add(bcx, val, llsize_of(ccx, T_tag_variant(ccx))))\n+            rslt(bcx, Add(bcx, val, llsize_of(ccx, T_enum_variant(ccx))))\n           }\n         };\n "}, {"sha": "b91cbd5711899275c20a23fe8656bf26ad5ceee5", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 62, "deletions": 65, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -135,7 +135,7 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n       ty::ty_uint(t) { T_uint_ty(cx, t) }\n       ty::ty_float(t) { T_float_ty(cx, t) }\n       ty::ty_str { T_ptr(T_vec(cx, T_i8())) }\n-      ty::ty_tag(did, _) { type_of_tag(cx, sp, did, t) }\n+      ty::ty_enum(did, _) { type_of_enum(cx, sp, did, t) }\n       ty::ty_box(mt) {\n         let mt_ty = mt.ty;\n         check non_ty_var(cx, mt_ty);\n@@ -213,18 +213,18 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n     ret llty;\n }\n \n-fn type_of_tag(cx: @crate_ctxt, sp: span, did: ast::def_id, t: ty::t)\n+fn type_of_enum(cx: @crate_ctxt, sp: span, did: ast::def_id, t: ty::t)\n     -> TypeRef {\n-    let degen = vec::len(*ty::tag_variants(cx.tcx, did)) == 1u;\n+    let degen = vec::len(*ty::enum_variants(cx.tcx, did)) == 1u;\n     if check type_has_static_size(cx, t) {\n-        let size = static_size_of_tag(cx, sp, t);\n-        if !degen { T_tag(cx, size) }\n-        else if size == 0u { T_struct([T_tag_variant(cx)]) }\n+        let size = static_size_of_enum(cx, sp, t);\n+        if !degen { T_enum(cx, size) }\n+        else if size == 0u { T_struct([T_enum_variant(cx)]) }\n         else { T_array(T_i8(), size) }\n     }\n     else {\n-        if degen { T_struct([T_tag_variant(cx)]) }\n-        else { T_opaque_tag(cx) }\n+        if degen { T_struct([T_enum_variant(cx)]) }\n+        else { T_opaque_enum(cx) }\n     }\n }\n \n@@ -498,16 +498,16 @@ fn simplify_type(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n }\n \n \n-// Computes the size of the data part of a non-dynamically-sized tag.\n-fn static_size_of_tag(cx: @crate_ctxt, sp: span, t: ty::t)\n+// Computes the size of the data part of a non-dynamically-sized enum.\n+fn static_size_of_enum(cx: @crate_ctxt, sp: span, t: ty::t)\n     : type_has_static_size(cx, t) -> uint {\n-    if cx.tag_sizes.contains_key(t) { ret cx.tag_sizes.get(t); }\n+    if cx.enum_sizes.contains_key(t) { ret cx.enum_sizes.get(t); }\n     alt ty::struct(cx.tcx, t) {\n-      ty::ty_tag(tid, subtys) {\n+      ty::ty_enum(tid, subtys) {\n         // Compute max(variant sizes).\n \n         let max_size = 0u;\n-        let variants = ty::tag_variants(cx.tcx, tid);\n+        let variants = ty::enum_variants(cx.tcx, tid);\n         for variant: ty::variant_info in *variants {\n             let tup_ty = simplify_type(cx, ty::mk_tup(cx.tcx, variant.args));\n             // Perform any type parameter substitutions.\n@@ -522,12 +522,9 @@ fn static_size_of_tag(cx: @crate_ctxt, sp: span, t: ty::t)\n             let this_size = llsize_of_real(cx, type_of(cx, sp, tup_ty));\n             if max_size < this_size { max_size = this_size; }\n         }\n-        cx.tag_sizes.insert(t, max_size);\n+        cx.enum_sizes.insert(t, max_size);\n         ret max_size;\n       }\n-      _ {\n-        cx.tcx.sess.span_fatal(sp, \"non-tag passed to static_size_of_tag()\");\n-      }\n     }\n }\n \n@@ -581,14 +578,14 @@ fn dynamic_size_of(cx: @block_ctxt, t: ty::t) -> result {\n         for tp in elts { tys += [tp]; }\n         ret align_elements(cx, tys);\n       }\n-      ty::ty_tag(tid, tps) {\n+      ty::ty_enum(tid, tps) {\n         let bcx = cx;\n         let ccx = bcx_ccx(bcx);\n         // Compute max(variant sizes).\n \n         let max_size: ValueRef = alloca(bcx, ccx.int_type);\n         Store(bcx, C_int(ccx, 0), max_size);\n-        let variants = ty::tag_variants(bcx_tcx(bcx), tid);\n+        let variants = ty::enum_variants(bcx_tcx(bcx), tid);\n         for variant: ty::variant_info in *variants {\n             // Perform type substitution on the raw argument types.\n \n@@ -632,7 +629,7 @@ fn dynamic_align_of(cx: @block_ctxt, t: ty::t) -> result {\n         }\n         ret rslt(bcx, a);\n       }\n-      ty::ty_tag(_, _) {\n+      ty::ty_enum(_, _) {\n         ret rslt(cx, C_int(bcx_ccx(cx), 1)); // FIXME: stub\n       }\n       ty::ty_tup(elts) {\n@@ -740,11 +737,11 @@ fn GEP_tup_like(bcx: @block_ctxt, t: ty::t, base: ValueRef, ixs: [int])\n // This function uses GEP_tup_like() above and automatically performs casts as\n // appropriate. @llblobptr is the data part of a enum value; its actual type\n // is meaningless, as it will be cast away.\n-fn GEP_tag(cx: @block_ctxt, llblobptr: ValueRef, tag_id: ast::def_id,\n+fn GEP_enum(cx: @block_ctxt, llblobptr: ValueRef, enum_id: ast::def_id,\n            variant_id: ast::def_id, ty_substs: [ty::t],\n-           ix: uint) : valid_variant_index(ix, cx, tag_id, variant_id) ->\n+           ix: uint) : valid_variant_index(ix, cx, enum_id, variant_id) ->\n    result {\n-    let variant = ty::tag_variant_with_id(bcx_tcx(cx), tag_id, variant_id);\n+    let variant = ty::enum_variant_with_id(bcx_tcx(cx), enum_id, variant_id);\n     // Synthesize a tuple type so that GEP_tup_like() can work its magic.\n     // Separately, store the type of the element we're interested in.\n \n@@ -1592,7 +1589,7 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n             let v_id = variant.id;\n             for a: ty::arg in args {\n                 check (valid_variant_index(j, cx, tid, v_id));\n-                let rslt = GEP_tag(cx, a_tup, tid, v_id, tps, j);\n+                let rslt = GEP_enum(cx, a_tup, tid, v_id, tps, j);\n                 let llfldp_a = rslt.val;\n                 cx = rslt.bcx;\n                 let ty_subst = ty::substitute_type_params(ccx.tcx, tps, a.ty);\n@@ -1639,20 +1636,20 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n         let {bcx: bcx, val: llfld_a} = GEP_tup_like(cx, tup_t, av, [0, 1]);\n         ret f(bcx, llfld_a, inner1);\n       }\n-      ty::ty_tag(tid, tps) {\n-        let variants = ty::tag_variants(bcx_tcx(cx), tid);\n+      ty::ty_enum(tid, tps) {\n+        let variants = ty::enum_variants(bcx_tcx(cx), tid);\n         let n_variants = vec::len(*variants);\n \n-        // Cast the tags to types we can GEP into.\n+        // Cast the enums to types we can GEP into.\n         if n_variants == 1u {\n             ret iter_variant(cx, av, variants[0], tps, tid, f);\n         }\n \n         let ccx = bcx_ccx(cx);\n-        let lltagty = T_opaque_tag_ptr(ccx);\n-        let av_tag = PointerCast(cx, av, lltagty);\n-        let lldiscrim_a_ptr = GEPi(cx, av_tag, [0, 0]);\n-        let llunion_a_ptr = GEPi(cx, av_tag, [0, 1]);\n+        let llenumty = T_opaque_enum_ptr(ccx);\n+        let av_enum = PointerCast(cx, av, llenumty);\n+        let lldiscrim_a_ptr = GEPi(cx, av_enum, [0, 0]);\n+        let llunion_a_ptr = GEPi(cx, av_enum, [0, 1]);\n         let lldiscrim_a = Load(cx, lldiscrim_a_ptr);\n \n         // NB: we must hit the discriminant first so that structural\n@@ -2098,7 +2095,7 @@ fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n         let {bcx, box, body} = trans_malloc_boxed(bcx, e_ty);\n         add_clean_free(bcx, box, false);\n         // Cast the body type to the type of the value. This is needed to\n-        // make tags work, since tags have a different LLVM type depending\n+        // make enums work, since enums have a different LLVM type depending\n         // on whether they're boxed or not\n         let ccx = bcx_ccx(bcx);\n         if check type_has_static_size(ccx, e_ty) {\n@@ -2262,8 +2259,8 @@ fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n             t1 = ty::substitute_type_params(ccx.tcx, tps, inner);\n             v1 = GEPi(cx, v1, [0, 1]);\n           }\n-          ty::ty_tag(did, tps) {\n-            let variants = ty::tag_variants(ccx.tcx, did);\n+          ty::ty_enum(did, tps) {\n+            let variants = ty::enum_variants(ccx.tcx, did);\n             if vec::len(*variants) != 1u ||\n                    vec::len(variants[0].args) != 1u {\n                 break;\n@@ -2644,22 +2641,22 @@ fn trans_var(cx: @block_ctxt, sp: span, def: ast::def, id: ast::node_id)\n         ret lval_static_fn(cx, did, id);\n       }\n       ast::def_variant(tid, vid) {\n-        if vec::len(ty::tag_variant_with_id(ccx.tcx, tid, vid).args) > 0u {\n+        if vec::len(ty::enum_variant_with_id(ccx.tcx, tid, vid).args) > 0u {\n             // N-ary variant.\n             ret lval_static_fn(cx, vid, id);\n         } else {\n             // Nullary variant.\n-            let tag_ty = node_id_type(ccx, id);\n-            let alloc_result = alloc_ty(cx, tag_ty);\n-            let lltagblob = alloc_result.val;\n-            let lltagty = type_of_tag(ccx, sp, tid, tag_ty);\n+            let enum_ty = node_id_type(ccx, id);\n+            let alloc_result = alloc_ty(cx, enum_ty);\n+            let llenumblob = alloc_result.val;\n+            let llenumty = type_of_enum(ccx, sp, tid, enum_ty);\n             let bcx = alloc_result.bcx;\n-            let lltagptr = PointerCast(bcx, lltagblob, T_ptr(lltagty));\n-            let lldiscrimptr = GEPi(bcx, lltagptr, [0, 0]);\n+            let llenumptr = PointerCast(bcx, llenumblob, T_ptr(llenumty));\n+            let lldiscrimptr = GEPi(bcx, llenumptr, [0, 0]);\n             let lldiscrim_gv = lookup_discriminant(bcx.fcx.lcx, vid);\n             let lldiscrim = Load(bcx, lldiscrim_gv);\n             Store(bcx, lldiscrim, lldiscrimptr);\n-            ret lval_no_env(bcx, lltagptr, temporary);\n+            ret lval_no_env(bcx, llenumptr, temporary);\n         }\n       }\n       ast::def_const(did) {\n@@ -2800,7 +2797,7 @@ fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n               ty::ty_res(_, _, _) {\n                 GEPi(sub.bcx, sub.val, [0, 1])\n               }\n-              ty::ty_tag(_, _) {\n+              ty::ty_enum(_, _) {\n                 let ety = ty::expr_ty(ccx.tcx, e);\n                 let sp = e.span;\n                 let ellty =\n@@ -2896,7 +2893,7 @@ fn trans_cast(cx: @block_ctxt, e: @ast::expr, id: ast::node_id,\n     check (type_has_static_size(ccx, t_out));\n     let ll_t_out = type_of(ccx, e.span, t_out);\n \n-    enum kind { pointer, integral, float, tag_, other, }\n+    enum kind { pointer, integral, float, enum_, other, }\n     fn t_kind(tcx: ty::ctxt, t: ty::t) -> kind {\n         ret if ty::type_is_fp(tcx, t) {\n                 float\n@@ -2905,8 +2902,8 @@ fn trans_cast(cx: @block_ctxt, e: @ast::expr, id: ast::node_id,\n                 pointer\n             } else if ty::type_is_integral(tcx, t) {\n                 integral\n-            } else if ty::type_is_tag(tcx, t) {\n-                tag_\n+            } else if ty::type_is_enum(tcx, t) {\n+                enum_\n             } else { other };\n     }\n     let k_in = t_kind(ccx.tcx, t_in);\n@@ -2940,11 +2937,11 @@ fn trans_cast(cx: @block_ctxt, e: @ast::expr, id: ast::node_id,\n           {in: pointer, out: pointer} {\n             PointerCast(e_res.bcx, e_res.val, ll_t_out)\n           }\n-          {in: tag_, out: integral} | {in: tag_, out: float} {\n+          {in: enum_, out: integral} | {in: enum_, out: float} {\n             let cx = e_res.bcx;\n-            let lltagty = T_opaque_tag_ptr(ccx);\n-            let av_tag = PointerCast(cx, e_res.val, lltagty);\n-            let lldiscrim_a_ptr = GEPi(cx, av_tag, [0, 0]);\n+            let llenumty = T_opaque_enum_ptr(ccx);\n+            let av_enum = PointerCast(cx, e_res.val, llenumty);\n+            let lldiscrim_a_ptr = GEPi(cx, av_enum, [0, 0]);\n             let lldiscrim_a = Load(cx, lldiscrim_a_ptr);\n             alt k_out {\n               integral {int_cast(e_res.bcx, ll_t_out,\n@@ -4520,7 +4517,7 @@ fn trans_res_ctor(cx: @local_ctxt, sp: span, dtor: ast::fn_decl,\n }\n \n \n-fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n+fn trans_enum_variant(cx: @local_ctxt, enum_id: ast::node_id,\n                      variant: ast::variant, disr: int, is_degen: bool,\n                      ty_params: [ast::ty_param]) {\n     let ccx = cx.ccx;\n@@ -4546,7 +4543,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n       some(x) { llfndecl = x; }\n       _ {\n         ccx.sess.span_fatal(variant.span,\n-                               \"unbound variant id in trans_tag_variant\");\n+                               \"unbound variant id in trans_enum_variant\");\n       }\n     }\n     let fcx = new_fn_ctxt(cx, variant.span, llfndecl);\n@@ -4568,18 +4565,18 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n         if is_degen {\n             fcx.llretptr\n         } else {\n-            let lltagptr =\n-                PointerCast(bcx, fcx.llretptr, T_opaque_tag_ptr(ccx));\n-            let lldiscrimptr = GEPi(bcx, lltagptr, [0, 0]);\n+            let llenumptr =\n+                PointerCast(bcx, fcx.llretptr, T_opaque_enum_ptr(ccx));\n+            let lldiscrimptr = GEPi(bcx, llenumptr, [0, 0]);\n             Store(bcx, C_int(ccx, disr), lldiscrimptr);\n-            GEPi(bcx, lltagptr, [0, 1])\n+            GEPi(bcx, llenumptr, [0, 1])\n         };\n     i = 0u;\n-    let t_id = ast_util::local_def(tag_id);\n+    let t_id = ast_util::local_def(enum_id);\n     let v_id = ast_util::local_def(variant.node.id);\n     for va: ast::variant_arg in variant.node.args {\n         check (valid_variant_index(i, bcx, t_id, v_id));\n-        let rslt = GEP_tag(bcx, llblobptr, t_id, v_id, ty_param_substs, i);\n+        let rslt = GEP_enum(bcx, llblobptr, t_id, v_id, ty_param_substs, i);\n         bcx = rslt.bcx;\n         let lldestptr = rslt.val;\n         // If this argument to this function is a enum, it'll have come in to\n@@ -4915,14 +4912,14 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n               module_path: cx.module_path + [item.ident] with *cx};\n         trans_mod(sub_cx, m);\n       }\n-      ast::item_tag(variants, tps) {\n+      ast::item_enum(variants, tps) {\n         let sub_cx = extend_path(cx, item.ident);\n         let degen = vec::len(variants) == 1u;\n-        let vi = ty::tag_variants(cx.ccx.tcx, {crate: ast::local_crate,\n+        let vi = ty::enum_variants(cx.ccx.tcx, {crate: ast::local_crate,\n                                                node: item.id});\n         let i = 0;\n         for variant: ast::variant in variants {\n-            trans_tag_variant(sub_cx, item.id, variant,\n+            trans_enum_variant(sub_cx, item.id, variant,\n                               vi[i].disr_val, degen, tps);\n             i += 1;\n         }\n@@ -5224,7 +5221,7 @@ fn collect_item(ccx: @crate_ctxt, abi: @mutable option::t<ast::native_abi>,\n         check returns_non_ty_var(ccx, t);\n         register_fn_full(ccx, i.span, new_pt, \"res_dtor\", tps, i.id, t);\n       }\n-      ast::item_tag(variants, tps) {\n+      ast::item_enum(variants, tps) {\n         for variant in variants {\n             if vec::len(variant.node.args) != 0u {\n                 register_fn(ccx, i.span, new_pt + [variant.node.name],\n@@ -5252,8 +5249,8 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item, &&pt: [str],\n     let new_pt = pt + [it.ident];\n     visit::visit_item(it, new_pt, v);\n     alt it.node {\n-      ast::item_tag(variants, _) {\n-        let vi = ty::tag_variants(ccx.tcx, {crate: ast::local_crate,\n+      ast::item_enum(variants, _) {\n+        let vi = ty::enum_variants(ccx.tcx, {crate: ast::local_crate,\n                                             node: it.id});\n         let i = 0;\n         for variant in variants {\n@@ -5517,7 +5514,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           item_symbols: new_int_hash::<str>(),\n           mutable main_fn: none::<ValueRef>,\n           link_meta: link_meta,\n-          tag_sizes: ty::new_ty_hash(),\n+          enum_sizes: ty::new_ty_hash(),\n           discrims: ast_util::new_def_id_hash::<ValueRef>(),\n           discrim_symbols: new_int_hash::<str>(),\n           consts: new_int_hash::<ValueRef>(),"}, {"sha": "dd7c09c2288f5cadc5dc4389c7915da520f8d768", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -68,7 +68,7 @@ fn trans_opt(bcx: @block_ctxt, o: opt) -> opt_result {\n // FIXME: invariant -- pat_id is bound in the def_map?\n fn variant_opt(ccx: @crate_ctxt, pat_id: ast::node_id) -> opt {\n     let vdef = ast_util::variant_def_ids(ccx.tcx.def_map.get(pat_id));\n-    let variants = ty::tag_variants(ccx.tcx, vdef.tg);\n+    let variants = ty::enum_variants(ccx.tcx, vdef.tg);\n     for v: ty::variant_info in *variants {\n         if vdef.var == v.id { ret var(v.disr_val, vdef); }\n     }\n@@ -158,13 +158,13 @@ fn enter_default(m: match, col: uint, val: ValueRef) -> match {\n     ret enter_match(m, col, val, e);\n }\n \n-fn enter_opt(ccx: @crate_ctxt, m: match, opt: opt, col: uint, tag_size: uint,\n+fn enter_opt(ccx: @crate_ctxt, m: match, opt: opt, col: uint, enum_size: uint,\n              val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     fn e(ccx: @crate_ctxt, dummy: @ast::pat, opt: opt, size: uint,\n          p: @ast::pat) -> option::t<[@ast::pat]> {\n         alt p.node {\n-          ast::pat_tag(ctor, subpats) {\n+          ast::pat_enum(ctor, subpats) {\n             ret if opt_eq(variant_opt(ccx, p.id), opt) {\n                     some(subpats)\n                 } else { none };\n@@ -178,7 +178,7 @@ fn enter_opt(ccx: @crate_ctxt, m: match, opt: opt, col: uint, tag_size: uint,\n           _ { ret some(vec::init_elt(size, dummy)); }\n         }\n     }\n-    ret enter_match(m, col, val, bind e(ccx, dummy, opt, tag_size, _));\n+    ret enter_match(m, col, val, bind e(ccx, dummy, opt, enum_size, _));\n }\n \n fn enter_rec(m: match, col: uint, fields: [ast::ident], val: ValueRef) ->\n@@ -251,7 +251,7 @@ fn get_options(ccx: @crate_ctxt, m: match, col: uint) -> [opt] {\n           ast::pat_range(l1, l2) {\n             add_to_set(found, range(l1, l2));\n           }\n-          ast::pat_tag(_, _) {\n+          ast::pat_enum(_, _) {\n             add_to_set(found, variant_opt(ccx, br.pats[col].id));\n           }\n           _ { }\n@@ -268,14 +268,14 @@ fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n     // pat_id must have the same length ty_param_substs as vdefs?\n     let ty_param_substs = ty::node_id_to_type_params(ccx.tcx, pat_id);\n     let blobptr = val;\n-    let variants = ty::tag_variants(ccx.tcx, vdefs.tg);\n+    let variants = ty::enum_variants(ccx.tcx, vdefs.tg);\n     let args = [];\n     let size =\n-        vec::len(ty::tag_variant_with_id(ccx.tcx, vdefs.tg, vdefs.var).args);\n+        vec::len(ty::enum_variant_with_id(ccx.tcx, vdefs.tg, vdefs.var).args);\n     if size > 0u && vec::len(*variants) != 1u {\n-        let tagptr =\n-            PointerCast(bcx, val, trans_common::T_opaque_tag_ptr(ccx));\n-        blobptr = GEPi(bcx, tagptr, [0, 1]);\n+        let enumptr =\n+            PointerCast(bcx, val, trans_common::T_opaque_enum_ptr(ccx));\n+        blobptr = GEPi(bcx, enumptr, [0, 1]);\n     }\n     let i = 0u;\n     let vdefs_tg = vdefs.tg;\n@@ -286,8 +286,8 @@ fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n             // invariant needed:\n             // how do we know it even makes sense to pass in ty_param_substs\n             // here? What if it's [] and the enum type has variables in it?\n-            trans::GEP_tag(bcx, blobptr, vdefs_tg, vdefs_var, ty_param_substs,\n-                           i);\n+            trans::GEP_enum(bcx, blobptr, vdefs_tg, vdefs_var,\n+                            ty_param_substs, i);\n         bcx = r.bcx;\n         args += [r.val];\n         i += 1u;\n@@ -339,7 +339,7 @@ type mk_fail = fn@() -> BasicBlockRef;\n fn pick_col(m: match) -> uint {\n     fn score(p: @ast::pat) -> uint {\n         alt p.node {\n-          ast::pat_lit(_) | ast::pat_tag(_, _) | ast::pat_range(_, _) { 1u }\n+          ast::pat_lit(_) | ast::pat_enum(_, _) | ast::pat_range(_, _) { 1u }\n           ast::pat_ident(_, some(p)) { score(p) }\n           _ { 0u }\n         }\n@@ -479,13 +479,13 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n     if vec::len(opts) > 0u {\n         alt opts[0] {\n           var(_, vdef) {\n-            if vec::len(*ty::tag_variants(ccx.tcx, vdef.tg)) == 1u {\n+            if vec::len(*ty::enum_variants(ccx.tcx, vdef.tg)) == 1u {\n                 kind = single;\n             } else {\n-                let tagptr =\n+                let enumptr =\n                     PointerCast(bcx, val,\n-                                trans_common::T_opaque_tag_ptr(ccx));\n-                let discrimptr = GEPi(bcx, tagptr, [0, 0]);\n+                                trans_common::T_opaque_enum_ptr(ccx));\n+                let discrimptr = GEPi(bcx, enumptr, [0, 0]);\n                 test_val = Load(bcx, discrimptr);\n                 kind = switch;\n             }\n@@ -725,7 +725,7 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n           _ {}\n         }\n       }\n-      ast::pat_tag(_, sub) {\n+      ast::pat_enum(_, sub) {\n         if vec::len(sub) == 0u { ret bcx; }\n         let vdefs = ast_util::variant_def_ids(ccx.tcx.def_map.get(pat.id));\n         let args = extract_variant_args(bcx, pat.id, vdefs, val);"}, {"sha": "8829c2b756e1b9a470b21a46e635872df1a6b950", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -92,7 +92,7 @@ type crate_ctxt =\n      item_symbols: hashmap<ast::node_id, str>,\n      mutable main_fn: option::t<ValueRef>,\n      link_meta: link::link_meta,\n-     tag_sizes: hashmap<ty::t, uint>,\n+     enum_sizes: hashmap<ty::t, uint>,\n      discrims: hashmap<ast::def_id, ValueRef>,\n      discrim_symbols: hashmap<ast::node_id, str>,\n      consts: hashmap<ast::node_id, ValueRef>,\n@@ -701,31 +701,31 @@ fn T_opaque_cbox_ptr(cx: @crate_ctxt) -> TypeRef {\n     ret t;\n }\n \n-fn T_tag_variant(cx: @crate_ctxt) -> TypeRef {\n+fn T_enum_variant(cx: @crate_ctxt) -> TypeRef {\n     ret cx.int_type;\n }\n \n-fn T_tag(cx: @crate_ctxt, size: uint) -> TypeRef {\n-    let s = \"tag_\" + uint::to_str(size, 10u);\n+fn T_enum(cx: @crate_ctxt, size: uint) -> TypeRef {\n+    let s = \"enum_\" + uint::to_str(size, 10u);\n     alt name_has_type(cx.tn, s) { some(t) { ret t; } _ {} }\n     let t =\n         if size == 0u {\n-            T_struct([T_tag_variant(cx)])\n-        } else { T_struct([T_tag_variant(cx), T_array(T_i8(), size)]) };\n+            T_struct([T_enum_variant(cx)])\n+        } else { T_struct([T_enum_variant(cx), T_array(T_i8(), size)]) };\n     associate_type(cx.tn, s, t);\n     ret t;\n }\n \n-fn T_opaque_tag(cx: @crate_ctxt) -> TypeRef {\n-    let s = \"opaque_tag\";\n+fn T_opaque_enum(cx: @crate_ctxt) -> TypeRef {\n+    let s = \"opaque_enum\";\n     alt name_has_type(cx.tn, s) { some(t) { ret t; } _ {} }\n-    let t = T_struct([T_tag_variant(cx), T_i8()]);\n+    let t = T_struct([T_enum_variant(cx), T_i8()]);\n     associate_type(cx.tn, s, t);\n     ret t;\n }\n \n-fn T_opaque_tag_ptr(cx: @crate_ctxt) -> TypeRef {\n-    ret T_ptr(T_opaque_tag(cx));\n+fn T_opaque_enum_ptr(cx: @crate_ctxt) -> TypeRef {\n+    ret T_ptr(T_opaque_enum(cx));\n }\n \n fn T_captured_tydescs(cx: @crate_ctxt, n: uint) -> TypeRef {\n@@ -850,15 +850,15 @@ fn C_shape(ccx: @crate_ctxt, bytes: [u8]) -> ValueRef {\n }\n \n \n-pure fn valid_variant_index(ix: uint, cx: @block_ctxt, tag_id: ast::def_id,\n+pure fn valid_variant_index(ix: uint, cx: @block_ctxt, enum_id: ast::def_id,\n                             variant_id: ast::def_id) -> bool {\n \n     // Handwaving: it's ok to pretend this code is referentially\n     // transparent, because the relevant parts of the type context don't\n     // change. (We're not adding new variants during trans.)\n     unchecked{\n         let variant =\n-            ty::tag_variant_with_id(bcx_tcx(cx), tag_id, variant_id);\n+            ty::enum_variant_with_id(bcx_tcx(cx), enum_id, variant_id);\n         ix < vec::len(variant.args)\n     }\n }"}, {"sha": "99bb750f3b768372e8950c304de29d5ad98f5f11", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -67,7 +67,7 @@ fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n       }\n       item_mod(m) { find_pre_post_mod(m); }\n       item_native_mod(nm) { find_pre_post_native_mod(nm); }\n-      item_ty(_, _) | item_tag(_, _) | item_iface(_, _) { ret; }\n+      item_ty(_, _) | item_enum(_, _) | item_iface(_, _) { ret; }\n       item_res(_, _, body, dtor_id, _) {\n         let fcx =\n             {enclosing: ccx.fm.get(dtor_id),"}, {"sha": "dc4cf70d83bad5179d0f9f997a91e72488533706", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -77,7 +77,7 @@ export mk_res;\n export mk_param;\n export mk_ptr;\n export mk_rec;\n-export mk_tag;\n+export mk_enum;\n export mk_tup;\n export mk_type;\n export mk_send_type;\n@@ -101,9 +101,9 @@ export sty;\n export substitute_type_params;\n export t;\n export new_ty_hash;\n-export tag_variants;\n+export enum_variants;\n export iface_methods, store_iface_methods, impl_iface;\n-export tag_variant_with_id;\n+export enum_variant_with_id;\n export ty_param_substs_opt_and_ty;\n export ty_param_bounds_and_ty;\n export ty_native_fn;\n@@ -128,7 +128,7 @@ export ty_res;\n export ty_param;\n export ty_ptr;\n export ty_rec;\n-export ty_tag;\n+export ty_enum;\n export ty_tup;\n export ty_type;\n export ty_send_type;\n@@ -172,7 +172,7 @@ export type_is_copyable;\n export type_is_tup_like;\n export type_is_str;\n export type_is_unique;\n-export type_is_tag;\n+export type_is_enum;\n export type_is_c_like_enum;\n export type_structurally_contains_uniques;\n export type_autoderef;\n@@ -221,7 +221,7 @@ type ctxt =\n       needs_drop_cache: hashmap<t, bool>,\n       kind_cache: hashmap<t, kind>,\n       ast_ty_to_ty_cache: hashmap<@ast::ty, option::t<t>>,\n-      tag_var_cache: hashmap<def_id, @[variant_info]>,\n+      enum_var_cache: hashmap<def_id, @[variant_info]>,\n       iface_method_cache: hashmap<def_id, @[method]>,\n       ty_param_bounds: hashmap<ast::node_id, param_bounds>};\n \n@@ -258,7 +258,7 @@ enum sty {\n     ty_uint(ast::uint_ty),\n     ty_float(ast::float_ty),\n     ty_str,\n-    ty_tag(def_id, [t]),\n+    ty_enum(def_id, [t]),\n     ty_box(mt),\n     ty_uniq(mt),\n     ty_vec(mt),\n@@ -437,7 +437,7 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n           kind_cache: new_ty_hash(),\n           ast_ty_to_ty_cache:\n               map::mk_hashmap(ast_util::hash_ty, ast_util::eq_ty),\n-          tag_var_cache: new_def_hash(),\n+          enum_var_cache: new_def_hash(),\n           iface_method_cache: new_def_hash(),\n           ty_param_bounds: map::new_int_hash()};\n     populate_type_store(cx);\n@@ -475,7 +475,7 @@ fn mk_raw_ty(cx: ctxt, st: sty) -> @raw_t {\n       }\n       ty_param(_, _) { has_params = true; }\n       ty_var(_) { has_vars = true; }\n-      ty_tag(_, tys) | ty_iface(_, tys) {\n+      ty_enum(_, tys) | ty_iface(_, tys) {\n         for tt: t in tys { derive_flags_t(cx, has_params, has_vars, tt); }\n       }\n       ty_box(m) { derive_flags_mt(cx, has_params, has_vars, m); }\n@@ -567,8 +567,8 @@ fn mk_char(_cx: ctxt) -> t { ret idx_char; }\n \n fn mk_str(_cx: ctxt) -> t { ret idx_str; }\n \n-fn mk_tag(cx: ctxt, did: ast::def_id, tys: [t]) -> t {\n-    ret gen_ty(cx, ty_tag(did, tys));\n+fn mk_enum(cx: ctxt, did: ast::def_id, tys: [t]) -> t {\n+    ret gen_ty(cx, ty_enum(did, tys));\n }\n \n fn mk_box(cx: ctxt, tm: mt) -> t { ret gen_ty(cx, ty_box(tm)); }\n@@ -685,7 +685,7 @@ fn walk_ty(cx: ctxt, walker: ty_walk, ty: t) {\n         /* no-op */\n       }\n       ty_box(tm) | ty_vec(tm) | ty_ptr(tm) { walk_ty(cx, walker, tm.ty); }\n-      ty_tag(_, subtys) | ty_iface(_, subtys) {\n+      ty_enum(_, subtys) | ty_iface(_, subtys) {\n         for subty: t in subtys { walk_ty(cx, walker, subty); }\n       }\n       ty_rec(fields) {\n@@ -748,8 +748,8 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n       ty_vec(tm) {\n         ty = mk_vec(cx, {ty: fold_ty(cx, fld, tm.ty), mut: tm.mut});\n       }\n-      ty_tag(tid, subtys) {\n-        ty = mk_tag(cx, tid, vec::map(subtys, {|t| fold_ty(cx, fld, t) }));\n+      ty_enum(tid, subtys) {\n+        ty = mk_enum(cx, tid, vec::map(subtys, {|t| fold_ty(cx, fld, t) }));\n       }\n       ty_iface(did, subtys) {\n         ty = mk_iface(cx, did, vec::map(subtys, {|t| fold_ty(cx, fld, t) }));\n@@ -826,7 +826,7 @@ fn type_is_bool(cx: ctxt, ty: t) -> bool {\n \n fn type_is_structural(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n-      ty_rec(_) | ty_tup(_) | ty_tag(_, _) | ty_fn(_) |\n+      ty_rec(_) | ty_tup(_) | ty_enum(_, _) | ty_fn(_) |\n       ty_native_fn(_, _) | ty_res(_, _, _) { true }\n       _ { false }\n     }\n@@ -954,8 +954,8 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n         for m in elts { if type_needs_drop(cx, m) { accum = true; } }\n         accum\n       }\n-      ty_tag(did, tps) {\n-        let variants = tag_variants(cx, did);\n+      ty_enum(did, tps) {\n+        let variants = enum_variants(cx, did);\n         for variant in *variants {\n             for aty in variant.args {\n                 // Perform any type parameter substitutions.\n@@ -1052,10 +1052,10 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n         for ty in tys { lowest = lower_kind(lowest, type_kind(cx, ty)); }\n         lowest\n       }\n-      // Tags lower to the lowest of their variants.\n-      ty_tag(did, tps) {\n+      // Enums lower to the lowest of their variants.\n+      ty_enum(did, tps) {\n         let lowest = kind_sendable;\n-        for variant in *tag_variants(cx, did) {\n+        for variant in *enum_variants(cx, did) {\n             for aty in variant.args {\n                 // Perform any type parameter substitutions.\n                 let arg_ty = substitute_type_params(cx, tps, aty);\n@@ -1088,8 +1088,8 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n     let sty = struct(cx, ty);\n     if test(sty) { ret true; }\n     alt sty {\n-      ty_tag(did, tps) {\n-        for variant in *tag_variants(cx, did) {\n+      ty_enum(did, tps) {\n+        for variant in *enum_variants(cx, did) {\n             for aty in variant.args {\n                 let sty = substitute_type_params(cx, tps, aty);\n                 if type_structurally_contains(cx, sty, test) { ret true; }\n@@ -1207,8 +1207,8 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_str | ty_box(_) | ty_uniq(_) | ty_vec(_) | ty_fn(_) |\n       ty_native_fn(_, _) | ty_iface(_, _) { result = false; }\n       // Structural types\n-      ty_tag(did, tps) {\n-        let variants = tag_variants(cx, did);\n+      ty_enum(did, tps) {\n+        let variants = enum_variants(cx, did);\n         for variant: variant_info in *variants {\n             let tup_ty = mk_tup(cx, variant.args);\n \n@@ -1238,9 +1238,9 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n     ret result;\n }\n \n-fn type_is_tag(cx: ctxt, ty: t) -> bool {\n+fn type_is_enum(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n-      ty_tag(_, _) { ret true; }\n+      ty_enum(_, _) { ret true; }\n       _ { ret false;}\n     }\n }\n@@ -1249,8 +1249,8 @@ fn type_is_tag(cx: ctxt, ty: t) -> bool {\n // constructors\n fn type_is_c_like_enum(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n-      ty_tag(did, tps) {\n-        let variants = tag_variants(cx, did);\n+      ty_enum(did, tps) {\n+        let variants = enum_variants(cx, did);\n         let some_n_ary = vec::any(*variants, {|v| vec::len(v.args) > 0u});\n         ret !some_n_ary;\n       }\n@@ -1287,8 +1287,8 @@ fn type_autoderef(cx: ctxt, t: ty::t) -> ty::t {\n           ty_res(_, inner, tps) {\n             t1 = substitute_type_params(cx, tps, inner);\n           }\n-          ty_tag(did, tps) {\n-            let variants = tag_variants(cx, did);\n+          ty_enum(did, tps) {\n+            let variants = enum_variants(cx, did);\n             if vec::len(*variants) != 1u || vec::len(variants[0].args) != 1u {\n                 break;\n             }\n@@ -1372,7 +1372,7 @@ fn hash_type_structure(st: sty) -> uint {\n         alt t { ast::ty_f { 13u } ast::ty_f32 { 14u } ast::ty_f64 { 15u } }\n       }\n       ty_str { ret 17u; }\n-      ty_tag(did, tys) {\n+      ty_enum(did, tys) {\n         let h = hash_def(18u, did);\n         for typ: t in tys { h += (h << 5u) + typ; }\n         ret h;\n@@ -2182,14 +2182,14 @@ mod unify {\n               _ { ret ures_err(terr_mismatch); }\n             }\n           }\n-          ty::ty_tag(expected_id, expected_tps) {\n+          ty::ty_enum(expected_id, expected_tps) {\n             alt struct(cx.tcx, actual) {\n-              ty::ty_tag(actual_id, actual_tps) {\n+              ty::ty_enum(actual_id, actual_tps) {\n                 if expected_id != actual_id {\n                     ret ures_err(terr_mismatch);\n                 }\n                 ret unify_tps(cx, expected_tps, actual_tps, variance, {|tps|\n-                    ures_ok(mk_tag(cx.tcx, expected_id, tps))\n+                    ures_ok(mk_enum(cx.tcx, expected_id, tps))\n                 });\n               }\n               _ {/* fall through */ }\n@@ -2628,23 +2628,23 @@ fn impl_iface(cx: ctxt, id: ast::def_id) -> option::t<t> {\n     }\n }\n \n-// Tag information\n+// Enum information\n type variant_info = @{args: [ty::t], ctor_ty: ty::t, name: str,\n                       id: ast::def_id, disr_val: int};\n \n-fn tag_variants(cx: ctxt, id: ast::def_id) -> @[variant_info] {\n-    alt cx.tag_var_cache.find(id) {\n+fn enum_variants(cx: ctxt, id: ast::def_id) -> @[variant_info] {\n+    alt cx.enum_var_cache.find(id) {\n       some(variants) { ret variants; }\n       _ { /* fallthrough */ }\n     }\n     let result = if ast::local_crate != id.crate {\n-        @csearch::get_tag_variants(cx, id)\n+        @csearch::get_enum_variants(cx, id)\n     } else {\n         // FIXME: Now that the variants are run through the type checker (to\n         // check the disr_expr if it exists), this code should likely be\n         // moved there to avoid having to call eval_const_expr twice.\n         alt cx.items.get(id.node) {\n-          ast_map::node_item(@{node: ast::item_tag(variants, _), _}) {\n+          ast_map::node_item(@{node: ast::item_enum(variants, _), _}) {\n             let disr_val = -1;\n             @vec::map(variants, {|variant|\n                 let ctor_ty = node_id_to_monotype(cx, variant.node.id);\n@@ -2670,22 +2670,22 @@ fn tag_variants(cx: ctxt, id: ast::def_id) -> @[variant_info] {\n           }\n         }\n     };\n-    cx.tag_var_cache.insert(id, result);\n+    cx.enum_var_cache.insert(id, result);\n     result\n }\n \n \n // Returns information about the enum variant with the given ID:\n-fn tag_variant_with_id(cx: ctxt, tag_id: ast::def_id, variant_id: ast::def_id)\n-   -> variant_info {\n-    let variants = tag_variants(cx, tag_id);\n+fn enum_variant_with_id(cx: ctxt, enum_id: ast::def_id,\n+                        variant_id: ast::def_id) -> variant_info {\n+    let variants = enum_variants(cx, enum_id);\n     let i = 0u;\n     while i < vec::len::<variant_info>(*variants) {\n         let variant = variants[i];\n         if def_eq(variant.id, variant_id) { ret variant; }\n         i += 1u;\n     }\n-    cx.sess.bug(\"tag_variant_with_id(): no variant exists with that ID\");\n+    cx.sess.bug(\"enum_variant_with_id(): no variant exists with that ID\");\n }\n \n \n@@ -2766,7 +2766,7 @@ fn is_binopable(cx: ctxt, ty: t, op: ast::binop) -> bool {\n           ty_vec(_) { tycat_vec }\n           ty_rec(_) { tycat_struct }\n           ty_tup(_) { tycat_struct }\n-          ty_tag(_, _) { tycat_struct }\n+          ty_enum(_, _) { tycat_struct }\n           ty_bot { tycat_bot }\n           _ { tycat_other }\n         }"}, {"sha": "5d0c1af173d5fe5b9eab1d0fde58b4bf0cb2feaf", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -405,10 +405,10 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n         tcx.tcache.insert(local_def(it.id), t_res);\n         ret t_res;\n       }\n-      ast::item_tag(_, tps) {\n+      ast::item_enum(_, tps) {\n         // Create a new generic polytype.\n         let {bounds, params} = mk_ty_params(tcx, tps);\n-        let t = ty::mk_named(tcx, ty::mk_tag(tcx, local_def(it.id), params),\n+        let t = ty::mk_named(tcx, ty::mk_enum(tcx, local_def(it.id), params),\n                              @it.ident);\n         let tpt = {bounds: bounds, ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n@@ -644,7 +644,7 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n mod collect {\n     type ctxt = {tcx: ty::ctxt};\n \n-    fn get_tag_variant_types(cx: @ctxt, tag_ty: ty::t,\n+    fn get_enum_variant_types(cx: @ctxt, enum_ty: ty::t,\n                              variants: [ast::variant],\n                              ty_params: [ast::ty_param]) {\n         // Create a set of parameter types shared among all the variants.\n@@ -654,7 +654,7 @@ mod collect {\n             // constructors get turned into functions.\n \n             let result_ty = if vec::len(variant.node.args) == 0u {\n-                tag_ty\n+                enum_ty\n             } else {\n                 // As above, tell ast_ty_to_ty() that trans_ty_item_to_ty()\n                 // should be called to resolve named types.\n@@ -666,7 +666,7 @@ mod collect {\n                 // FIXME: this will be different for constrained types\n                 ty::mk_fn(cx.tcx,\n                           {proto: ast::proto_box,\n-                           inputs: args, output: tag_ty,\n+                           inputs: args, output: enum_ty,\n                            ret_style: ast::return_val, constraints: []})\n             };\n             let tpt = {bounds: ty_param_bounds(cx.tcx, m_collect, ty_params),\n@@ -679,10 +679,10 @@ mod collect {\n         alt it.node {\n           // These don't define types.\n           ast::item_mod(_) | ast::item_native_mod(_) {}\n-          ast::item_tag(variants, ty_params) {\n+          ast::item_enum(variants, ty_params) {\n             let tpt = ty_of_item(cx.tcx, m_collect, it);\n             write::ty_only(cx.tcx, it.id, tpt.ty);\n-            get_tag_variant_types(cx, tpt.ty, variants, ty_params);\n+            get_enum_variant_types(cx, tpt.ty, variants, ty_params);\n           }\n           ast::item_impl(tps, ifce, selfty, ms) {\n             let i_bounds = ty_param_bounds(cx.tcx, m_collect, tps);\n@@ -826,8 +826,8 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n           ty::ty_res(_, inner, tps) {\n             t1 = ty::substitute_type_params(fcx.ccx.tcx, tps, inner);\n           }\n-          ty::ty_tag(did, tps) {\n-            let variants = ty::tag_variants(fcx.ccx.tcx, did);\n+          ty::ty_enum(did, tps) {\n+            let variants = ty::enum_variants(fcx.ccx.tcx, did);\n             if vec::len(*variants) != 1u || vec::len(variants[0].args) != 1u {\n                 ret t1;\n             }\n@@ -923,15 +923,15 @@ fn are_compatible(fcx: @fn_ctxt, expected: ty::t, actual: ty::t) -> bool {\n \n // Returns the types of the arguments to a enum variant.\n fn variant_arg_types(ccx: @crate_ctxt, _sp: span, vid: ast::def_id,\n-                     tag_ty_params: [ty::t]) -> [ty::t] {\n+                     enum_ty_params: [ty::t]) -> [ty::t] {\n     let result: [ty::t] = [];\n     let tpt = ty::lookup_item_type(ccx.tcx, vid);\n     alt ty::struct(ccx.tcx, tpt.ty) {\n       ty::ty_fn(f) {\n         // N-ary variant.\n         for arg: ty::arg in f.inputs {\n             let arg_ty =\n-                ty::substitute_type_params(ccx.tcx, tag_ty_params, arg.ty);\n+                ty::substitute_type_params(ccx.tcx, enum_ty_params, arg.ty);\n             result += [arg_ty];\n         }\n       }\n@@ -1187,7 +1187,7 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n     alt normalize_pat(fcx.ccx.tcx, pat).node {\n       ast::pat_wild {\n           alt structure_of(fcx, pat.span, expected) {\n-                  ty::ty_tag(_, expected_tps) {\n+                  ty::ty_enum(_, expected_tps) {\n                       let path_tpt = {substs: some(expected_tps),\n                                       ty: expected};\n                       write::ty_fixup(fcx, pat.id, path_tpt);\n@@ -1236,16 +1236,16 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n           _ {}\n         }\n       }\n-      ast::pat_tag(path, subpats) {\n+      ast::pat_enum(path, subpats) {\n         // Typecheck the path.\n         let v_def = lookup_def(fcx, path.span, pat.id);\n         let v_def_ids = ast_util::variant_def_ids(v_def);\n-        let tag_tpt = ty::lookup_item_type(fcx.ccx.tcx, v_def_ids.tg);\n-        let path_tpot = instantiate_path(fcx, path, tag_tpt, pat.span);\n+        let enum_tpt = ty::lookup_item_type(fcx.ccx.tcx, v_def_ids.tg);\n+        let path_tpot = instantiate_path(fcx, path, enum_tpt, pat.span);\n \n         // Take the enum type params out of `expected`.\n         alt structure_of(fcx, pat.span, expected) {\n-          ty::ty_tag(_, expected_tps) {\n+          ty::ty_enum(_, expected_tps) {\n             // Unify with the expected enum type.\n             let ctor_ty =\n                 ty::ty_param_substs_opt_and_ty_to_monotype(fcx.ccx.tcx,\n@@ -1837,12 +1837,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n               ty::ty_box(inner) { oper_t = inner.ty; }\n               ty::ty_uniq(inner) { oper_t = inner.ty; }\n               ty::ty_res(_, inner, _) { oper_t = inner; }\n-              ty::ty_tag(id, tps) {\n-                let variants = ty::tag_variants(tcx, id);\n+              ty::ty_enum(id, tps) {\n+                let variants = ty::enum_variants(tcx, id);\n                 if vec::len(*variants) != 1u ||\n                        vec::len(variants[0].args) != 1u {\n                     tcx.sess.span_fatal(expr.span,\n-                                        \"can only dereference tags \" +\n+                                        \"can only dereference enums \" +\n                                         \"with a single variant which has a \"\n                                             + \"single argument\");\n                 }\n@@ -2463,7 +2463,7 @@ fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n     demand::simple(fcx, e.span, declty, cty);\n }\n \n-fn check_tag_variants(ccx: @crate_ctxt, _sp: span, vs: [ast::variant],\n+fn check_enum_variants(ccx: @crate_ctxt, _sp: span, vs: [ast::variant],\n                       id: ast::node_id) {\n     // FIXME: this is kinda a kludge; we manufacture a fake function context\n     // and statement context for checking the initializer expression.\n@@ -2683,7 +2683,7 @@ fn check_method(ccx: @crate_ctxt, method: @ast::method) {\n fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n     alt it.node {\n       ast::item_const(_, e) { check_const(ccx, it.span, e, it.id); }\n-      ast::item_tag(vs, _) { check_tag_variants(ccx, it.span, vs, it.id); }\n+      ast::item_enum(vs, _) { check_enum_variants(ccx, it.span, vs, it.id); }\n       ast::item_fn(decl, tps, body) {\n         check_fn(ccx, ast::proto_bare, decl, body, it.id, none);\n       }"}, {"sha": "7f7f6d76bc1caa75c467092e2fbc2a1d9c573b57", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -103,12 +103,12 @@ enum pat_ {\n     // In the nullary enum case, the parser can't determine\n     // which it is. The resolver determines this, and\n     // records this pattern's node_id in an auxiliary\n-    // set (of \"pat_idents that refer to nullary tags\")\n+    // set (of \"pat_idents that refer to nullary enums\")\n     // After the resolution phase, code should never pattern-\n     // match on a pat directly! Always call pat_util::normalize_pat --\n-    // it turns any pat_idents that refer to nullary tags into pat_tags.\n+    // it turns any pat_idents that refer to nullary enums into pat_enums.\n     pat_ident(@path, option::t<@pat>),\n-    pat_tag(@path, [@pat]),\n+    pat_enum(@path, [@pat]),\n     pat_rec([field_pat], bool),\n     pat_tup([@pat]),\n     pat_box(@pat),\n@@ -440,9 +440,9 @@ enum view_item_ {\n     view_item_import_from(@simple_path, [import_ident], node_id),\n     view_item_export([ident], node_id),\n     // export foo::{}\n-    view_item_export_tag_none(ident, node_id),\n+    view_item_export_enum_none(ident, node_id),\n     // export foo::{bar, baz, blat}\n-    view_item_export_tag_some(ident, [import_ident], node_id)\n+    view_item_export_enum_some(ident, [import_ident], node_id)\n }\n \n // Meta-data associated with an item\n@@ -465,7 +465,7 @@ enum item_ {\n     item_mod(_mod),\n     item_native_mod(native_mod),\n     item_ty(@ty, [ty_param]),\n-    item_tag([variant], [ty_param]),\n+    item_enum([variant], [ty_param]),\n     item_res(fn_decl /* dtor */, [ty_param], blk,\n              node_id /* dtor id */, node_id /* ctor id */),\n     item_iface([ty_param], [ty_method]),"}, {"sha": "53fb3e094d710eb4b11f22c0df756531545c7328", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -20,7 +20,7 @@ fn path_name_i(idents: [ident]) -> str { str::connect(idents, \"::\") }\n fn local_def(id: node_id) -> def_id { ret {crate: local_crate, node: id}; }\n \n fn variant_def_ids(d: def) -> {tg: def_id, var: def_id} {\n-    alt d { def_variant(tag_id, var_id) { ret {tg: tag_id, var: var_id}; } }\n+    alt d { def_variant(enum_id, var_id) { ret {tg: enum_id, var: var_id}; } }\n }\n \n fn def_id_of_def(d: def) -> def_id {\n@@ -113,15 +113,15 @@ fn float_ty_to_str(t: float_ty) -> str {\n \n fn is_exported(i: ident, m: _mod) -> bool {\n     let nonlocal = true;\n-    let parent_tag : option<ident> = none;\n+    let parent_enum : option<ident> = none;\n     for it: @item in m.items {\n         if it.ident == i { nonlocal = false; }\n         alt it.node {\n-          item_tag(variants, _) {\n+          item_enum(variants, _) {\n             for v: variant in variants {\n                 if v.node.name == i {\n                    nonlocal = false;\n-                   parent_tag = some(it.ident);\n+                   parent_enum = some(it.ident);\n                 }\n             }\n           }\n@@ -133,24 +133,24 @@ fn is_exported(i: ident, m: _mod) -> bool {\n     for vi: @view_item in m.view_items {\n         alt vi.node {\n           view_item_export(ids, _) {\n-              // If any of ids is a tag, we want to consider\n+              // If any of ids is a enum, we want to consider\n               // all the variants to be exported\n             for id in ids {\n                 if str::eq(i, id) { ret true; }\n-                alt parent_tag {\n-                    some(parent_tag_id) {\n-                        if str::eq(id, parent_tag_id) { ret true; }\n+                alt parent_enum {\n+                    some(parent_enum_id) {\n+                        if str::eq(id, parent_enum_id) { ret true; }\n                     }\n                     _ { }\n                  }\n             }\n             count += 1u;\n           }\n-          view_item_export_tag_none(id, _) {\n+          view_item_export_enum_none(id, _) {\n               if str::eq(i, id) { ret true; }\n               count += 1u;\n           }\n-          view_item_export_tag_some(id, ids, _) {\n+          view_item_export_enum_some(id, ids, _) {\n               if str::eq(i, id) { ret true; }\n               for id in ids { if str::eq(i, id.node.name) { ret true; } }\n               count += 1u;\n@@ -278,7 +278,8 @@ fn eval_const_expr(e: @expr) -> const_val {\n               mul { const_uint(a * b) } div { const_uint(a / b) }\n               rem { const_uint(a % b) } and | bitand { const_uint(a & b) }\n               or | bitor { const_uint(a | b) } bitxor { const_uint(a ^ b) }\n-              lsl { const_int(a << b as i64) } lsr { const_int(a >> b as i64) }\n+              lsl { const_int(a << b as i64) }\n+              lsr { const_int(a >> b as i64) }\n               asr { const_int(a >>> b as i64) }\n               eq { fromb(a == b) } lt { fromb(a < b) }\n               le { fromb(a <= b) } ne { fromb(a != b) }"}, {"sha": "d2019930b4a1bbde49822730b69254d9df3a3d7f", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -226,8 +226,8 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n           item_mod(m) { item_mod(fld.fold_mod(m)) }\n           item_native_mod(nm) { item_native_mod(fld.fold_native_mod(nm)) }\n           item_ty(t, typms) { item_ty(fld.fold_ty(t), typms) }\n-          item_tag(variants, typms) {\n-            item_tag(vec::map(variants, fld.fold_variant), typms)\n+          item_enum(variants, typms) {\n+            item_enum(vec::map(variants, fld.fold_variant), typms)\n           }\n           item_impl(tps, ifce, ty, methods) {\n             item_impl(tps, option::map(ifce, fld.fold_ty), fld.fold_ty(ty),\n@@ -279,8 +279,8 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n             pat_ident(fld.fold_path(pth), option::map(sub, fld.fold_pat))\n           }\n           pat_lit(_) { p }\n-          pat_tag(pth, pats) {\n-            pat_tag(fld.fold_path(pth), vec::map(pats, fld.fold_pat))\n+          pat_enum(pth, pats) {\n+            pat_enum(fld.fold_path(pth), vec::map(pats, fld.fold_pat))\n           }\n           pat_rec(fields, etc) {\n             let fs = [];"}, {"sha": "602e209e573ca4951661277f1473db96f82f095f", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -1501,8 +1501,8 @@ fn parse_pat(p: parser) -> @ast::pat {\n             let sub = eat(p, token::AT) ? some(parse_pat(p)) : none;\n             pat = ast::pat_ident(name, sub);\n         } else {\n-            let tag_path = parse_path_and_ty_param_substs(p, true);\n-            hi = tag_path.span.hi;\n+            let enum_path = parse_path_and_ty_param_substs(p, true);\n+            hi = enum_path.span.hi;\n             let args: [@ast::pat];\n             alt p.token {\n               token::LPAREN {\n@@ -1516,11 +1516,11 @@ fn parse_pat(p: parser) -> @ast::pat {\n             }\n             // at this point, we're not sure whether it's a enum or a bind\n             if vec::len(args) == 0u &&\n-               vec::len(tag_path.node.idents) == 1u {\n-                pat = ast::pat_ident(tag_path, none);\n+               vec::len(enum_path.node.idents) == 1u {\n+                pat = ast::pat_ident(enum_path, none);\n             }\n             else {\n-                pat = ast::pat_tag(tag_path, args);\n+                pat = ast::pat_enum(enum_path, args);\n             }\n         }\n       }\n@@ -2024,7 +2024,7 @@ fn parse_item_type(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     ret mk_item(p, t.lo, hi, t.ident, ast::item_ty(ty, tps), attrs);\n }\n \n-fn parse_item_tag(p: parser, attrs: [ast::attribute]) -> @ast::item {\n+fn parse_item_enum(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.last_span.lo;\n     let id = parse_ident(p);\n     let ty_params = parse_ty_params(p);\n@@ -2044,7 +2044,7 @@ fn parse_item_tag(p: parser, attrs: [ast::attribute]) -> @ast::item {\n                      id: p.get_id(),\n                      disr_expr: none});\n         ret mk_item(p, lo, ty.span.hi, id,\n-                    ast::item_tag([variant], ty_params), attrs);\n+                    ast::item_enum([variant], ty_params), attrs);\n     }\n     expect(p, token::LBRACE);\n     let all_nullary = true, have_disr = false;\n@@ -2077,7 +2077,7 @@ fn parse_item_tag(p: parser, attrs: [ast::attribute]) -> @ast::item {\n         p.fatal(\"discriminator values can only be used with a c-like enum\");\n     }\n     ret mk_item(p, lo, p.last_span.hi, id,\n-                ast::item_tag(variants, ty_params), attrs);\n+                ast::item_enum(variants, ty_params), attrs);\n }\n \n fn parse_fn_ty_proto(p: parser) -> ast::proto {\n@@ -2134,7 +2134,7 @@ fn parse_item(p: parser, attrs: [ast::attribute]) -> option::t<@ast::item> {\n     } if eat_word(p, \"type\") {\n         ret some(parse_item_type(p, attrs));\n     } else if eat_word(p, \"enum\") {\n-        ret some(parse_item_tag(p, attrs));\n+        ret some(parse_item_enum(p, attrs));\n     } else if eat_word(p, \"iface\") {\n         ret some(parse_item_iface(p, attrs));\n     } else if eat_word(p, \"impl\") {\n@@ -2364,16 +2364,16 @@ fn parse_import(p: parser) -> ast::view_item_ {\n     }\n }\n \n-fn parse_tag_export(p:parser, tyname:ast::ident) -> ast::view_item_ {\n-    let tagnames:[ast::import_ident] =\n+fn parse_enum_export(p:parser, tyname:ast::ident) -> ast::view_item_ {\n+    let enumnames:[ast::import_ident] =\n         parse_seq(token::LBRACE, token::RBRACE,\n              seq_sep(token::COMMA), {|p| parse_import_ident(p) }, p).node;\n     let id = p.get_id();\n-    if vec::is_empty(tagnames) {\n-       ret ast::view_item_export_tag_none(tyname, id);\n+    if vec::is_empty(enumnames) {\n+       ret ast::view_item_export_enum_none(tyname, id);\n     }\n     else {\n-       ret ast::view_item_export_tag_some(tyname, tagnames, id);\n+       ret ast::view_item_export_enum_some(tyname, enumnames, id);\n     }\n }\n \n@@ -2382,7 +2382,7 @@ fn parse_export(p: parser) -> ast::view_item_ {\n     alt p.token {\n        token::MOD_SEP {\n            p.bump();\n-           ret parse_tag_export(p, first);\n+           ret parse_enum_export(p, first);\n        }\n        t {\n            if t == token::COMMA { p.bump(); }"}, {"sha": "ad6f96e9a1b957990cfa9a4439008c41fc52a477", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -412,7 +412,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n         word(s.s, \";\");\n         end(s); // end the outer ibox\n       }\n-      ast::item_tag(variants, params) {\n+      ast::item_enum(variants, params) {\n         let newtype =\n             vec::len(variants) == 1u &&\n                 str::eq(item.ident, variants[0].node.name) &&\n@@ -1081,7 +1081,7 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n           _ {}\n         }\n       }\n-      ast::pat_tag(path, args) {\n+      ast::pat_enum(path, args) {\n         print_path(s, path, true);\n         if vec::len(args) > 0u {\n             popen(s);\n@@ -1304,12 +1304,12 @@ fn print_view_item(s: ps, item: @ast::view_item) {\n         commasep(s, inconsistent, ids,\n                  fn@(s: ps, &&w: ast::ident) { word(s.s, w) });\n       }\n-      ast::view_item_export_tag_none(id, _) {\n+      ast::view_item_export_enum_none(id, _) {\n           head(s, \"export\");\n           word(s.s, id);\n           word(s.s, \"::{}\");\n       }\n-      ast::view_item_export_tag_some(id, ids, _) {\n+      ast::view_item_export_enum_some(id, ids, _) {\n           head(s, \"export\");\n           word(s.s, id);\n           word(s.s, \"::{\");"}, {"sha": "e60e5b097ea5ddfedb6fe2b776dae1bee7477f07", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -120,7 +120,7 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         v.visit_fn(fk_res(i.ident, tps), decl, body, i.span,\n                    dtor_id, e, v);\n       }\n-      item_tag(variants, tps) {\n+      item_enum(variants, tps) {\n         v.visit_ty_params(tps, e, v);\n         for vr: variant in variants {\n             for va: variant_arg in vr.node.args { v.visit_ty(va.ty, e, v); }\n@@ -187,7 +187,7 @@ fn visit_path<E>(p: @path, e: E, v: vt<E>) {\n \n fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n     alt p.node {\n-      pat_tag(path, children) {\n+      pat_enum(path, children) {\n         visit_path(path, e, v);\n         for child: @pat in children { v.visit_pat(child, e, v); }\n       }"}, {"sha": "69108be1e5517c29d4c412fe943dfe77e441393d", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aabbe99d598dc42e8e3723d98516422bd26d33/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=76aabbe99d598dc42e8e3723d98516422bd26d33", "patch": "@@ -72,7 +72,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n     alt ty_name(cx, typ) {\n       some(cs) {\n         alt struct(cx, typ) {\n-          ty_tag(_, tps) | ty_res(_, _, tps) {\n+          ty_enum(_, tps) | ty_res(_, _, tps) {\n             if vec::len(tps) > 0u {\n                 let strs = vec::map(tps, {|t| ty_to_str(cx, t)});\n                 ret *cs + \"<\" + str::connect(strs, \",\") + \">\";"}]}