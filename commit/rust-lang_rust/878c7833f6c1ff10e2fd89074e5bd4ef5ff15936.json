{"sha": "878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "node_id": "C_kwDOAAsO6NoAKDg3OGM3ODMzZjZjMWZmMTBlMmZkODkwNzRlNWJkNGVmNWZmMTU5MzY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-16T19:15:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-16T19:15:02Z"}, "message": "Auto merge of #96123 - Dylan-DPC:rollup-qjog6n1, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #94985 (Parse inner attributes on inline const block)\n - #95006 (Reject `#[thread_local]` attribute on non-static items)\n - #95426 (Include Refs in Valtree Creation)\n - #95908 (Inline `shallow_resolve_ty` into `ShallowResolver`)\n - #96058 (separate flock implementations into separate modules)\n - #96088 (Update mdbook)\n - #96118 (rustdoc: Rename `def_id` into `item_id` when the type is `ItemId` for readability)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "3775849e21447f36051ce13cbfa6620fba74fa8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3775849e21447f36051ce13cbfa6620fba74fa8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "html_url": "https://github.com/rust-lang/rust/commit/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fa9789f596dd7639e1a242d466637b53179f4d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fa9789f596dd7639e1a242d466637b53179f4d1", "html_url": "https://github.com/rust-lang/rust/commit/2fa9789f596dd7639e1a242d466637b53179f4d1"}, {"sha": "10e0db5666c15ed58abb47aca1ee453e371c406f", "url": "https://api.github.com/repos/rust-lang/rust/commits/10e0db5666c15ed58abb47aca1ee453e371c406f", "html_url": "https://github.com/rust-lang/rust/commit/10e0db5666c15ed58abb47aca1ee453e371c406f"}], "stats": {"total": 959, "additions": 540, "deletions": 419}, "files": [{"sha": "73dc7f03236d173a520edb358d0e3df736c388d2", "filename": "Cargo.lock", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -606,12 +606,22 @@ dependencies = [\n  \"atty\",\n  \"bitflags\",\n  \"indexmap\",\n+ \"lazy_static\",\n  \"os_str_bytes\",\n  \"strsim 0.10.0\",\n  \"termcolor\",\n  \"textwrap 0.14.2\",\n ]\n \n+[[package]]\n+name = \"clap_complete\"\n+version = \"3.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"df6f3613c0a3cddfd78b41b10203eb322cb29b600cbdf808a7d3db95691b8e25\"\n+dependencies = [\n+ \"clap 3.1.1\",\n+]\n+\n [[package]]\n name = \"clippy\"\n version = \"0.1.62\"\n@@ -2240,14 +2250,15 @@ dependencies = [\n \n [[package]]\n name = \"mdbook\"\n-version = \"0.4.15\"\n+version = \"0.4.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"241f10687eb3b4e0634b3b4e423f97c5f1efbd69dc9522e24a8b94583eeec3c6\"\n+checksum = \"74612ae81a3e5ee509854049dfa4c7975ae033c06f5fc4735c7dfbe60ee2a39d\"\n dependencies = [\n  \"ammonia\",\n  \"anyhow\",\n  \"chrono\",\n- \"clap 2.34.0\",\n+ \"clap 3.1.1\",\n+ \"clap_complete\",\n  \"elasticlunr-rs\",\n  \"env_logger 0.7.1\",\n  \"handlebars\",\n@@ -2911,7 +2922,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"34f197a544b0c9ab3ae46c359a7ec9cbbb5c7bf97054266fecb7ead794a181d6\"\n dependencies = [\n  \"bitflags\",\n- \"getopts\",\n  \"memchr\",\n  \"unicase\",\n ]\n@@ -3129,9 +3139,9 @@ dependencies = [\n \n [[package]]\n name = \"regex\"\n-version = \"1.5.4\"\n+version = \"1.5.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d07a8629359eb56f1e2fb1652bb04212c072a87ba68546a04065d525673ac461\"\n+checksum = \"1a11647b6b25ff05a515cb92c365cec08801e83423a235b51e231e1808747286\"\n dependencies = [\n  \"aho-corasick\",\n  \"memchr\","}, {"sha": "3c9bb81bedb1c64aec042148a23823b03ccd1ef0", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -959,7 +959,7 @@ impl<'a> State<'a> {\n                 self.word_space(\"=\");\n                 match term {\n                     Term::Ty(ty) => self.print_type(ty),\n-                    Term::Const(c) => self.print_expr_anon_const(c),\n+                    Term::Const(c) => self.print_expr_anon_const(c, &[]),\n                 }\n             }\n             ast::AssocConstraintKind::Bound { bounds } => self.print_type_bounds(\":\", &*bounds),"}, {"sha": "9de4cbbee13f068e483d0fa0ae26d055358f4e1a", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -88,10 +88,21 @@ impl<'a> State<'a> {\n         self.end();\n     }\n \n-    pub(super) fn print_expr_anon_const(&mut self, expr: &ast::AnonConst) {\n+    pub(super) fn print_expr_anon_const(\n+        &mut self,\n+        expr: &ast::AnonConst,\n+        attrs: &[ast::Attribute],\n+    ) {\n         self.ibox(INDENT_UNIT);\n         self.word(\"const\");\n-        self.print_expr(&expr.value);\n+        self.nbsp();\n+        if let ast::ExprKind::Block(block, None) = &expr.value.kind {\n+            self.cbox(0);\n+            self.ibox(0);\n+            self.print_block_with_attrs(block, attrs);\n+        } else {\n+            self.print_expr(&expr.value);\n+        }\n         self.end();\n     }\n \n@@ -275,7 +286,7 @@ impl<'a> State<'a> {\n                 self.print_expr_vec(exprs);\n             }\n             ast::ExprKind::ConstBlock(ref anon_const) => {\n-                self.print_expr_anon_const(anon_const);\n+                self.print_expr_anon_const(anon_const, attrs);\n             }\n             ast::ExprKind::Repeat(ref element, ref count) => {\n                 self.print_expr_repeat(element, count);"}, {"sha": "7cca6178ab25727c989962d841deec9e17267bda", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -188,6 +188,7 @@ pub(super) fn op_to_const<'tcx>(\n     }\n }\n \n+#[instrument(skip(tcx), level = \"debug\")]\n fn turn_into_const_value<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     constant: ConstAlloc<'tcx>,\n@@ -206,6 +207,7 @@ fn turn_into_const_value<'tcx>(\n         !is_static || cid.promoted.is_some(),\n         \"the `eval_to_const_value_raw` query should not be used for statics, use `eval_to_allocation` instead\"\n     );\n+\n     // Turn this into a proper constant.\n     op_to_const(&ecx, &mplace.into())\n }"}, {"sha": "80270f825630f079c58ec55ea4b8560b1de8ccd7", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 55, "deletions": 25, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -3,12 +3,14 @@\n use std::convert::TryFrom;\n \n use rustc_hir::Mutability;\n+use rustc_middle::ty::layout::HasTyCtxt;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_middle::{\n     mir::{self, interpret::ConstAlloc},\n     ty::ScalarInt,\n };\n use rustc_span::{source_map::DUMMY_SP, symbol::Symbol};\n+use rustc_target::abi::VariantIdx;\n \n use crate::interpret::{\n     intern_const_alloc_recursive, ConstValue, InternKind, InterpCx, InterpResult, MPlaceTy,\n@@ -55,28 +57,48 @@ pub(crate) fn const_to_valtree<'tcx>(\n     const_to_valtree_inner(&ecx, &place)\n }\n \n-fn const_to_valtree_inner<'tcx>(\n+#[instrument(skip(ecx), level = \"debug\")]\n+fn branches<'tcx>(\n     ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n     place: &MPlaceTy<'tcx>,\n+    n: usize,\n+    variant: Option<VariantIdx>,\n ) -> Option<ty::ValTree<'tcx>> {\n-    let branches = |n, variant| {\n-        let place = match variant {\n-            Some(variant) => ecx.mplace_downcast(&place, variant).unwrap(),\n-            None => *place,\n-        };\n-        let variant =\n-            variant.map(|variant| Some(ty::ValTree::Leaf(ScalarInt::from(variant.as_u32()))));\n-        let fields = (0..n).map(|i| {\n-            let field = ecx.mplace_field(&place, i).unwrap();\n-            const_to_valtree_inner(ecx, &field)\n-        });\n-        // For enums, we preped their variant index before the variant's fields so we can figure out\n-        // the variant again when just seeing a valtree.\n-        let branches = variant.into_iter().chain(fields);\n-        Some(ty::ValTree::Branch(\n-            ecx.tcx.arena.alloc_from_iter(branches.collect::<Option<Vec<_>>>()?),\n-        ))\n+    let place = match variant {\n+        Some(variant) => ecx.mplace_downcast(&place, variant).unwrap(),\n+        None => *place,\n     };\n+    let variant = variant.map(|variant| Some(ty::ValTree::Leaf(ScalarInt::from(variant.as_u32()))));\n+    debug!(?place, ?variant);\n+\n+    let fields = (0..n).map(|i| {\n+        let field = ecx.mplace_field(&place, i).unwrap();\n+        const_to_valtree_inner(ecx, &field)\n+    });\n+    // For enums, we prepend their variant index before the variant's fields so we can figure out\n+    // the variant again when just seeing a valtree.\n+    let branches = variant.into_iter().chain(fields);\n+    Some(ty::ValTree::Branch(ecx.tcx.arena.alloc_from_iter(branches.collect::<Option<Vec<_>>>()?)))\n+}\n+\n+fn slice_branches<'tcx>(\n+    ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n+    place: &MPlaceTy<'tcx>,\n+) -> Option<ty::ValTree<'tcx>> {\n+    let n = place.len(&ecx.tcx()).expect(&format!(\"expected to use len of place {:?}\", place));\n+    let branches = (0..n).map(|i| {\n+        let place_elem = ecx.mplace_index(place, i).unwrap();\n+        const_to_valtree_inner(ecx, &place_elem)\n+    });\n+\n+    Some(ty::ValTree::Branch(ecx.tcx.arena.alloc_from_iter(branches.collect::<Option<Vec<_>>>()?)))\n+}\n+\n+#[instrument(skip(ecx), level = \"debug\")]\n+fn const_to_valtree_inner<'tcx>(\n+    ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n+    place: &MPlaceTy<'tcx>,\n+) -> Option<ty::ValTree<'tcx>> {\n     match place.layout.ty.kind() {\n         ty::FnDef(..) => Some(ty::ValTree::zst()),\n         ty::Bool | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Char => {\n@@ -90,19 +112,27 @@ fn const_to_valtree_inner<'tcx>(\n         // Technically we could allow function pointers (represented as `ty::Instance`), but this is not guaranteed to\n         // agree with runtime equality tests.\n         ty::FnPtr(_) | ty::RawPtr(_) => None,\n-        ty::Ref(..) => unimplemented!(\"need to use deref_const\"),\n \n+        ty::Ref(_, _, _)  => {\n+            let derefd_place = ecx.deref_operand(&place.into()).unwrap_or_else(|e| bug!(\"couldn't deref {:?}, error: {:?}\", place, e));\n+            debug!(?derefd_place);\n+\n+            const_to_valtree_inner(ecx, &derefd_place)\n+        }\n+\n+        ty::Str | ty::Slice(_) | ty::Array(_, _) => {\n+            let valtree = slice_branches(ecx, place);\n+            debug!(?valtree);\n+\n+            valtree\n+        }\n         // Trait objects are not allowed in type level constants, as we have no concept for\n         // resolving their backing type, even if we can do that at const eval time. We may\n         // hypothetically be able to allow `dyn StructuralEq` trait objects in the future,\n         // but it is unclear if this is useful.\n         ty::Dynamic(..) => None,\n \n-        ty::Slice(_) | ty::Str => {\n-            unimplemented!(\"need to find the backing data of the slice/str and recurse on that\")\n-        }\n-        ty::Tuple(substs) => branches(substs.len(), None),\n-        ty::Array(_, len) => branches(usize::try_from(len.eval_usize(ecx.tcx.tcx, ecx.param_env)).unwrap(), None),\n+        ty::Tuple(substs) => branches(ecx, place, substs.len(), None),\n \n         ty::Adt(def, _) => {\n             if def.variants().is_empty() {\n@@ -111,7 +141,7 @@ fn const_to_valtree_inner<'tcx>(\n \n             let variant = ecx.read_discriminant(&place.into()).unwrap().1;\n \n-            branches(def.variant(variant).fields.len(), def.is_enum().then_some(variant))\n+            branches(ecx, place, def.variant(variant).fields.len(), def.is_enum().then_some(variant))\n         }\n \n         ty::Never"}, {"sha": "31da4522a1fda38ff0554920315fa39c5111e597", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -191,7 +191,7 @@ impl<'tcx, Tag: Provenance> MPlaceTy<'tcx, Tag> {\n     }\n \n     #[inline]\n-    pub(super) fn len(&self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> {\n+    pub(crate) fn len(&self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> {\n         if self.layout.is_unsized() {\n             // We need to consult `meta` metadata\n             match self.layout.ty.kind() {"}, {"sha": "e395d8dbbbf8b2dea18c1f29a3cfdab2d21ffcd5", "filename": "compiler/rustc_data_structures/src/flock.rs", "status": "modified", "additions": 10, "deletions": 215, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_data_structures%2Fsrc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_data_structures%2Fsrc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fflock.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -7,225 +7,20 @@\n #![allow(non_camel_case_types)]\n #![allow(nonstandard_style)]\n \n-use std::fs::{File, OpenOptions};\n-use std::io;\n-use std::path::Path;\n-\n cfg_if! {\n-    // We use `flock` rather than `fcntl` on Linux, because WSL1 does not support\n-    // `fcntl`-style advisory locks properly (rust-lang/rust#72157).\n-    //\n-    // For other Unix targets we still use `fcntl` because it's more portable than\n-    // `flock`.\n     if #[cfg(target_os = \"linux\")] {\n-        use std::os::unix::prelude::*;\n-\n-        #[derive(Debug)]\n-        pub struct Lock {\n-            _file: File,\n-        }\n-\n-        impl Lock {\n-            pub fn new(p: &Path,\n-                       wait: bool,\n-                       create: bool,\n-                       exclusive: bool)\n-                       -> io::Result<Lock> {\n-                let file = OpenOptions::new()\n-                    .read(true)\n-                    .write(true)\n-                    .create(create)\n-                    .mode(libc::S_IRWXU as u32)\n-                    .open(p)?;\n-\n-                let mut operation = if exclusive {\n-                    libc::LOCK_EX\n-                } else {\n-                    libc::LOCK_SH\n-                };\n-                if !wait {\n-                    operation |= libc::LOCK_NB\n-                }\n-\n-                let ret = unsafe { libc::flock(file.as_raw_fd(), operation) };\n-                if ret == -1 {\n-                    Err(io::Error::last_os_error())\n-                } else {\n-                    Ok(Lock { _file: file })\n-                }\n-            }\n-\n-            pub fn error_unsupported(err: &io::Error) -> bool {\n-                matches!(err.raw_os_error(), Some(libc::ENOTSUP) | Some(libc::ENOSYS))\n-            }\n-        }\n-\n-        // Note that we don't need a Drop impl to execute `flock(fd, LOCK_UN)`. Lock acquired by\n-        // `flock` is associated with the file descriptor and closing the file release it\n-        // automatically.\n+        mod linux;\n+        use linux as imp;\n     } else if #[cfg(unix)] {\n-        use std::mem;\n-        use std::os::unix::prelude::*;\n-\n-        #[derive(Debug)]\n-        pub struct Lock {\n-            file: File,\n-        }\n-\n-        impl Lock {\n-            pub fn new(p: &Path,\n-                       wait: bool,\n-                       create: bool,\n-                       exclusive: bool)\n-                       -> io::Result<Lock> {\n-                let file = OpenOptions::new()\n-                    .read(true)\n-                    .write(true)\n-                    .create(create)\n-                    .mode(libc::S_IRWXU as u32)\n-                    .open(p)?;\n-\n-                let lock_type = if exclusive {\n-                    libc::F_WRLCK\n-                } else {\n-                    libc::F_RDLCK\n-                };\n-\n-                let mut flock: libc::flock = unsafe { mem::zeroed() };\n-                flock.l_type = lock_type as libc::c_short;\n-                flock.l_whence = libc::SEEK_SET as libc::c_short;\n-                flock.l_start = 0;\n-                flock.l_len = 0;\n-\n-                let cmd = if wait { libc::F_SETLKW } else { libc::F_SETLK };\n-                let ret = unsafe {\n-                    libc::fcntl(file.as_raw_fd(), cmd, &flock)\n-                };\n-                if ret == -1 {\n-                    Err(io::Error::last_os_error())\n-                } else {\n-                    Ok(Lock { file })\n-                }\n-            }\n-\n-            pub fn error_unsupported(err: &io::Error) -> bool {\n-                matches!(err.raw_os_error(), Some(libc::ENOTSUP) | Some(libc::ENOSYS))\n-            }\n-        }\n-\n-        impl Drop for Lock {\n-            fn drop(&mut self) {\n-                let mut flock: libc::flock = unsafe { mem::zeroed() };\n-                flock.l_type = libc::F_UNLCK as libc::c_short;\n-                flock.l_whence = libc::SEEK_SET as libc::c_short;\n-                flock.l_start = 0;\n-                flock.l_len = 0;\n-\n-                unsafe {\n-                    libc::fcntl(self.file.as_raw_fd(), libc::F_SETLK, &flock);\n-                }\n-            }\n-        }\n+        mod unix;\n+        use unix as imp;\n     } else if #[cfg(windows)] {\n-        use std::mem;\n-        use std::os::windows::prelude::*;\n-\n-        use winapi::shared::winerror::ERROR_INVALID_FUNCTION;\n-        use winapi::um::minwinbase::{OVERLAPPED, LOCKFILE_FAIL_IMMEDIATELY, LOCKFILE_EXCLUSIVE_LOCK};\n-        use winapi::um::fileapi::LockFileEx;\n-        use winapi::um::winnt::{FILE_SHARE_DELETE, FILE_SHARE_READ, FILE_SHARE_WRITE};\n-\n-        #[derive(Debug)]\n-        pub struct Lock {\n-            _file: File,\n-        }\n-\n-        impl Lock {\n-            pub fn new(p: &Path,\n-                       wait: bool,\n-                       create: bool,\n-                       exclusive: bool)\n-                       -> io::Result<Lock> {\n-                assert!(p.parent().unwrap().exists(),\n-                    \"Parent directory of lock-file must exist: {}\",\n-                    p.display());\n-\n-                let share_mode = FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE;\n-\n-                let mut open_options = OpenOptions::new();\n-                open_options.read(true)\n-                            .share_mode(share_mode);\n-\n-                if create {\n-                    open_options.create(true)\n-                                .write(true);\n-                }\n-\n-                debug!(\"attempting to open lock file `{}`\", p.display());\n-                let file = match open_options.open(p) {\n-                    Ok(file) => {\n-                        debug!(\"lock file opened successfully\");\n-                        file\n-                    }\n-                    Err(err) => {\n-                        debug!(\"error opening lock file: {}\", err);\n-                        return Err(err)\n-                    }\n-                };\n-\n-                let ret = unsafe {\n-                    let mut overlapped: OVERLAPPED = mem::zeroed();\n-\n-                    let mut dwFlags = 0;\n-                    if !wait {\n-                        dwFlags |= LOCKFILE_FAIL_IMMEDIATELY;\n-                    }\n-\n-                    if exclusive {\n-                        dwFlags |= LOCKFILE_EXCLUSIVE_LOCK;\n-                    }\n-\n-                    debug!(\"attempting to acquire lock on lock file `{}`\",\n-                           p.display());\n-                    LockFileEx(file.as_raw_handle(),\n-                               dwFlags,\n-                               0,\n-                               0xFFFF_FFFF,\n-                               0xFFFF_FFFF,\n-                               &mut overlapped)\n-                };\n-                if ret == 0 {\n-                    let err = io::Error::last_os_error();\n-                    debug!(\"failed acquiring file lock: {}\", err);\n-                    Err(err)\n-                } else {\n-                    debug!(\"successfully acquired lock\");\n-                    Ok(Lock { _file: file })\n-                }\n-            }\n-\n-            pub fn error_unsupported(err: &io::Error) -> bool {\n-                err.raw_os_error() == Some(ERROR_INVALID_FUNCTION as i32)\n-            }\n-        }\n-\n-        // Note that we don't need a Drop impl on the Windows: The file is unlocked\n-        // automatically when it's closed.\n+        mod windows;\n+        use windows as imp;\n     } else {\n-        #[derive(Debug)]\n-        pub struct Lock(());\n-\n-        impl Lock {\n-            pub fn new(_p: &Path, _wait: bool, _create: bool, _exclusive: bool)\n-                -> io::Result<Lock>\n-            {\n-                let msg = \"file locks not supported on this platform\";\n-                Err(io::Error::new(io::ErrorKind::Other, msg))\n-            }\n-\n-            pub fn error_unsupported(_err: &io::Error) -> bool {\n-                true\n-            }\n-        }\n+        mod unsupported;\n+        use unsupported as imp;\n     }\n }\n+\n+pub use imp::Lock;"}, {"sha": "bb3ecfbc370c0b3bc0242259bd8191d785deb6a5", "filename": "compiler/rustc_data_structures/src/flock/linux.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Flinux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Flinux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Flinux.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -0,0 +1,40 @@\n+//! We use `flock` rather than `fcntl` on Linux, because WSL1 does not support\n+//! `fcntl`-style advisory locks properly (rust-lang/rust#72157). For other Unix\n+//! targets we still use `fcntl` because it's more portable than `flock`.\n+\n+use std::fs::{File, OpenOptions};\n+use std::io;\n+use std::os::unix::prelude::*;\n+use std::path::Path;\n+\n+#[derive(Debug)]\n+pub struct Lock {\n+    _file: File,\n+}\n+\n+impl Lock {\n+    pub fn new(p: &Path, wait: bool, create: bool, exclusive: bool) -> io::Result<Lock> {\n+        let file = OpenOptions::new()\n+            .read(true)\n+            .write(true)\n+            .create(create)\n+            .mode(libc::S_IRWXU as u32)\n+            .open(p)?;\n+\n+        let mut operation = if exclusive { libc::LOCK_EX } else { libc::LOCK_SH };\n+        if !wait {\n+            operation |= libc::LOCK_NB\n+        }\n+\n+        let ret = unsafe { libc::flock(file.as_raw_fd(), operation) };\n+        if ret == -1 { Err(io::Error::last_os_error()) } else { Ok(Lock { _file: file }) }\n+    }\n+\n+    pub fn error_unsupported(err: &io::Error) -> bool {\n+        matches!(err.raw_os_error(), Some(libc::ENOTSUP) | Some(libc::ENOSYS))\n+    }\n+}\n+\n+// Note that we don't need a Drop impl to execute `flock(fd, LOCK_UN)`. A lock acquired by\n+// `flock` is associated with the file descriptor and closing the file releases it\n+// automatically."}, {"sha": "4e5297d582e075d749a6c9e239db06ca0bd4e012", "filename": "compiler/rustc_data_structures/src/flock/unix.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Funix.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -0,0 +1,51 @@\n+use std::fs::{File, OpenOptions};\n+use std::io;\n+use std::mem;\n+use std::os::unix::prelude::*;\n+use std::path::Path;\n+\n+#[derive(Debug)]\n+pub struct Lock {\n+    file: File,\n+}\n+\n+impl Lock {\n+    pub fn new(p: &Path, wait: bool, create: bool, exclusive: bool) -> io::Result<Lock> {\n+        let file = OpenOptions::new()\n+            .read(true)\n+            .write(true)\n+            .create(create)\n+            .mode(libc::S_IRWXU as u32)\n+            .open(p)?;\n+\n+        let lock_type = if exclusive { libc::F_WRLCK } else { libc::F_RDLCK };\n+\n+        let mut flock: libc::flock = unsafe { mem::zeroed() };\n+        flock.l_type = lock_type as libc::c_short;\n+        flock.l_whence = libc::SEEK_SET as libc::c_short;\n+        flock.l_start = 0;\n+        flock.l_len = 0;\n+\n+        let cmd = if wait { libc::F_SETLKW } else { libc::F_SETLK };\n+        let ret = unsafe { libc::fcntl(file.as_raw_fd(), cmd, &flock) };\n+        if ret == -1 { Err(io::Error::last_os_error()) } else { Ok(Lock { file }) }\n+    }\n+\n+    pub fn error_unsupported(err: &io::Error) -> bool {\n+        matches!(err.raw_os_error(), Some(libc::ENOTSUP) | Some(libc::ENOSYS))\n+    }\n+}\n+\n+impl Drop for Lock {\n+    fn drop(&mut self) {\n+        let mut flock: libc::flock = unsafe { mem::zeroed() };\n+        flock.l_type = libc::F_UNLCK as libc::c_short;\n+        flock.l_whence = libc::SEEK_SET as libc::c_short;\n+        flock.l_start = 0;\n+        flock.l_len = 0;\n+\n+        unsafe {\n+            libc::fcntl(self.file.as_raw_fd(), libc::F_SETLK, &flock);\n+        }\n+    }\n+}"}, {"sha": "9245fca373dfc4de7c0fda7dc50ff3dd97d96f3f", "filename": "compiler/rustc_data_structures/src/flock/unsupported.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Funsupported.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Funsupported.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Funsupported.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -0,0 +1,16 @@\n+use std::io;\n+use std::path::Path;\n+\n+#[derive(Debug)]\n+pub struct Lock(());\n+\n+impl Lock {\n+    pub fn new(_p: &Path, _wait: bool, _create: bool, _exclusive: bool) -> io::Result<Lock> {\n+        let msg = \"file locks not supported on this platform\";\n+        Err(io::Error::new(io::ErrorKind::Other, msg))\n+    }\n+\n+    pub fn error_unsupported(_err: &io::Error) -> bool {\n+        true\n+    }\n+}"}, {"sha": "43e6caaa18dcd1d6cf96f73cf6760ed9a195708d", "filename": "compiler/rustc_data_structures/src/flock/windows.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Fwindows.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -0,0 +1,77 @@\n+use std::fs::{File, OpenOptions};\n+use std::io;\n+use std::mem;\n+use std::os::windows::prelude::*;\n+use std::path::Path;\n+\n+use winapi::shared::winerror::ERROR_INVALID_FUNCTION;\n+use winapi::um::fileapi::LockFileEx;\n+use winapi::um::minwinbase::{LOCKFILE_EXCLUSIVE_LOCK, LOCKFILE_FAIL_IMMEDIATELY, OVERLAPPED};\n+use winapi::um::winnt::{FILE_SHARE_DELETE, FILE_SHARE_READ, FILE_SHARE_WRITE};\n+\n+#[derive(Debug)]\n+pub struct Lock {\n+    _file: File,\n+}\n+\n+impl Lock {\n+    pub fn new(p: &Path, wait: bool, create: bool, exclusive: bool) -> io::Result<Lock> {\n+        assert!(\n+            p.parent().unwrap().exists(),\n+            \"Parent directory of lock-file must exist: {}\",\n+            p.display()\n+        );\n+\n+        let share_mode = FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE;\n+\n+        let mut open_options = OpenOptions::new();\n+        open_options.read(true).share_mode(share_mode);\n+\n+        if create {\n+            open_options.create(true).write(true);\n+        }\n+\n+        debug!(\"attempting to open lock file `{}`\", p.display());\n+        let file = match open_options.open(p) {\n+            Ok(file) => {\n+                debug!(\"lock file opened successfully\");\n+                file\n+            }\n+            Err(err) => {\n+                debug!(\"error opening lock file: {}\", err);\n+                return Err(err);\n+            }\n+        };\n+\n+        let ret = unsafe {\n+            let mut overlapped: OVERLAPPED = mem::zeroed();\n+\n+            let mut dwFlags = 0;\n+            if !wait {\n+                dwFlags |= LOCKFILE_FAIL_IMMEDIATELY;\n+            }\n+\n+            if exclusive {\n+                dwFlags |= LOCKFILE_EXCLUSIVE_LOCK;\n+            }\n+\n+            debug!(\"attempting to acquire lock on lock file `{}`\", p.display());\n+            LockFileEx(file.as_raw_handle(), dwFlags, 0, 0xFFFF_FFFF, 0xFFFF_FFFF, &mut overlapped)\n+        };\n+        if ret == 0 {\n+            let err = io::Error::last_os_error();\n+            debug!(\"failed acquiring file lock: {}\", err);\n+            Err(err)\n+        } else {\n+            debug!(\"successfully acquired lock\");\n+            Ok(Lock { _file: file })\n+        }\n+    }\n+\n+    pub fn error_unsupported(err: &io::Error) -> bool {\n+        err.raw_os_error() == Some(ERROR_INVALID_FUNCTION as i32)\n+    }\n+}\n+\n+// Note that we don't need a Drop impl on Windows: The file is unlocked\n+// automatically when it's closed."}, {"sha": "6ec929f98950e6a64901cb84620a2f7dd41b88dd", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 39, "deletions": 44, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -1659,49 +1659,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.tcx.const_eval_resolve(param_env_erased, unevaluated, span)\n     }\n \n-    /// If `typ` is a type variable of some kind, resolve it one level\n-    /// (but do not resolve types found in the result). If `typ` is\n-    /// not a type variable, just return it unmodified.\n-    // FIXME(eddyb) inline into `ShallowResolver::visit_ty`.\n-    fn shallow_resolve_ty(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n-        match *typ.kind() {\n-            ty::Infer(ty::TyVar(v)) => {\n-                // Not entirely obvious: if `typ` is a type variable,\n-                // it can be resolved to an int/float variable, which\n-                // can then be recursively resolved, hence the\n-                // recursion. Note though that we prevent type\n-                // variables from unifying to other type variables\n-                // directly (though they may be embedded\n-                // structurally), and we prevent cycles in any case,\n-                // so this recursion should always be of very limited\n-                // depth.\n-                //\n-                // Note: if these two lines are combined into one we get\n-                // dynamic borrow errors on `self.inner`.\n-                let known = self.inner.borrow_mut().type_variables().probe(v).known();\n-                known.map_or(typ, |t| self.shallow_resolve_ty(t))\n-            }\n-\n-            ty::Infer(ty::IntVar(v)) => self\n-                .inner\n-                .borrow_mut()\n-                .int_unification_table()\n-                .probe_value(v)\n-                .map(|v| v.to_type(self.tcx))\n-                .unwrap_or(typ),\n-\n-            ty::Infer(ty::FloatVar(v)) => self\n-                .inner\n-                .borrow_mut()\n-                .float_unification_table()\n-                .probe_value(v)\n-                .map(|v| v.to_type(self.tcx))\n-                .unwrap_or(typ),\n-\n-            _ => typ,\n-        }\n-    }\n-\n     /// `ty_or_const_infer_var_changed` is equivalent to one of these two:\n     ///   * `shallow_resolve(ty) != ty` (where `ty.kind = ty::Infer(_)`)\n     ///   * `shallow_resolve(ct) != ct` (where `ct.kind = ty::ConstKind::Infer(_)`)\n@@ -1831,8 +1788,46 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n+    /// If `ty` is a type variable of some kind, resolve it one level\n+    /// (but do not resolve types found in the result). If `typ` is\n+    /// not a type variable, just return it unmodified.\n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.infcx.shallow_resolve_ty(ty)\n+        match *ty.kind() {\n+            ty::Infer(ty::TyVar(v)) => {\n+                // Not entirely obvious: if `typ` is a type variable,\n+                // it can be resolved to an int/float variable, which\n+                // can then be recursively resolved, hence the\n+                // recursion. Note though that we prevent type\n+                // variables from unifying to other type variables\n+                // directly (though they may be embedded\n+                // structurally), and we prevent cycles in any case,\n+                // so this recursion should always be of very limited\n+                // depth.\n+                //\n+                // Note: if these two lines are combined into one we get\n+                // dynamic borrow errors on `self.inner`.\n+                let known = self.infcx.inner.borrow_mut().type_variables().probe(v).known();\n+                known.map_or(ty, |t| self.fold_ty(t))\n+            }\n+\n+            ty::Infer(ty::IntVar(v)) => self\n+                .infcx\n+                .inner\n+                .borrow_mut()\n+                .int_unification_table()\n+                .probe_value(v)\n+                .map_or(ty, |v| v.to_type(self.infcx.tcx)),\n+\n+            ty::Infer(ty::FloatVar(v)) => self\n+                .infcx\n+                .inner\n+                .borrow_mut()\n+                .float_unification_table()\n+                .probe_value(v)\n+                .map_or(ty, |v| v.to_type(self.infcx.tcx)),\n+\n+            _ => ty,\n+        }\n     }\n \n     fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {"}, {"sha": "195760c059081bf607e54c26a33dfec44e4dbb77", "filename": "compiler/rustc_middle/src/ty/consts/valtree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -1,5 +1,5 @@\n use super::ScalarInt;\n-use rustc_macros::HashStable;\n+use rustc_macros::{HashStable, TyDecodable, TyEncodable};\n \n #[derive(Copy, Clone, Debug, Hash, TyEncodable, TyDecodable, Eq, PartialEq, Ord, PartialOrd)]\n #[derive(HashStable)]"}, {"sha": "cb6be8f412cf54cf7cd9d2ddb4deecae119f9f14", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -1125,13 +1125,13 @@ impl<'a> Parser<'a> {\n             self.sess.gated_spans.gate(sym::inline_const, span);\n         }\n         self.eat_keyword(kw::Const);\n-        let blk = self.parse_block()?;\n+        let (attrs, blk) = self.parse_inner_attrs_and_block()?;\n         let anon_const = AnonConst {\n             id: DUMMY_NODE_ID,\n             value: self.mk_expr(blk.span, ExprKind::Block(blk, None), AttrVec::new()),\n         };\n         let blk_span = anon_const.value.span;\n-        Ok(self.mk_expr(span.to(blk_span), ExprKind::ConstBlock(anon_const), AttrVec::new()))\n+        Ok(self.mk_expr(span.to(blk_span), ExprKind::ConstBlock(anon_const), AttrVec::from(attrs)))\n     }\n \n     /// Parses mutability (`mut` or nothing)."}, {"sha": "a9444972130a85a0bef02baaf23bffb0189ef75b", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -80,6 +80,7 @@ impl CheckAttrVisitor<'_> {\n                     self.check_rustc_must_implement_one_of(attr, span, target)\n                 }\n                 sym::target_feature => self.check_target_feature(hir_id, attr, span, target),\n+                sym::thread_local => self.check_thread_local(attr, span, target),\n                 sym::track_caller => {\n                     self.check_track_caller(hir_id, attr.span, attrs, span, target)\n                 }\n@@ -523,6 +524,21 @@ impl CheckAttrVisitor<'_> {\n         }\n     }\n \n+    /// Checks if the `#[thread_local]` attribute on `item` is valid. Returns `true` if valid.\n+    fn check_thread_local(&self, attr: &Attribute, span: Span, target: Target) -> bool {\n+        match target {\n+            Target::ForeignStatic | Target::Static => true,\n+            _ => {\n+                self.tcx\n+                    .sess\n+                    .struct_span_err(attr.span, \"attribute should be applied to a static\")\n+                    .span_label(span, \"not a static\")\n+                    .emit();\n+                false\n+            }\n+        }\n+    }\n+\n     fn doc_attr_str_error(&self, meta: &NestedMetaItem, attr_name: &str) {\n         self.tcx\n             .sess"}, {"sha": "fffd94992093b22d9cb1a20555bc90efb98ee13d", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -116,7 +116,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             name: None,\n             attrs: Default::default(),\n             visibility: Inherited,\n-            def_id: ItemId::Auto { trait_: trait_def_id, for_: item_def_id },\n+            item_id: ItemId::Auto { trait_: trait_def_id, for_: item_def_id },\n             kind: box ImplItem(Impl {\n                 unsafety: hir::Unsafety::Normal,\n                 generics: new_generics,"}, {"sha": "f0d87f7ce4cd582908f9a7211ea4b520f5fff928", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                         name: None,\n                         attrs: Default::default(),\n                         visibility: Inherited,\n-                        def_id: ItemId::Blanket { impl_id: impl_def_id, for_: item_def_id },\n+                        item_id: ItemId::Blanket { impl_id: impl_def_id, for_: item_def_id },\n                         kind: box ImplItem(Impl {\n                             unsafety: hir::Unsafety::Normal,\n                             generics: clean_ty_generics("}, {"sha": "261eb39bf723d3aaf22da9a1c3238fe3dab8dbdf", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -534,7 +534,7 @@ fn build_module(\n                 items.push(clean::Item {\n                     name: None,\n                     attrs: box clean::Attributes::default(),\n-                    def_id: ItemId::Primitive(prim_ty, did.krate),\n+                    item_id: ItemId::Primitive(prim_ty, did.krate),\n                     visibility: clean::Public,\n                     kind: box clean::ImportItem(clean::Import::new_simple(\n                         item.ident.name,"}, {"sha": "21016afbf5f99369e253d179dede250e40882a7d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -2009,7 +2009,7 @@ fn clean_extern_crate(\n     vec![Item {\n         name: Some(name),\n         attrs: box attrs.clean(cx),\n-        def_id: crate_def_id.into(),\n+        item_id: crate_def_id.into(),\n         visibility: ty_vis.clean(cx),\n         kind: box ExternCrateItem { src: orig_name },\n         cfg: attrs.cfg(cx.tcx, &cx.cache.hidden_cfg),"}, {"sha": "4b473df155f588c925defb7a20d5062ef77d00d4", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -366,7 +366,7 @@ crate struct Item {\n     /// Information about this item that is specific to what kind of item it is.\n     /// E.g., struct vs enum vs function.\n     crate kind: Box<ItemKind>,\n-    crate def_id: ItemId,\n+    crate item_id: ItemId,\n \n     crate cfg: Option<Arc<Cfg>>,\n }\n@@ -380,7 +380,7 @@ impl fmt::Debug for Item {\n         let mut fmt = f.debug_struct(\"Item\");\n         fmt.field(\"name\", &self.name)\n             .field(\"visibility\", &self.visibility)\n-            .field(\"def_id\", &self.def_id);\n+            .field(\"item_id\", &self.item_id);\n         // allow printing the full item if someone really wants to\n         if alternate {\n             fmt.field(\"attrs\", &self.attrs).field(\"kind\", &self.kind).field(\"cfg\", &self.cfg);\n@@ -408,19 +408,19 @@ crate fn rustc_span(def_id: DefId, tcx: TyCtxt<'_>) -> Span {\n \n impl Item {\n     crate fn stability<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<Stability> {\n-        self.def_id.as_def_id().and_then(|did| tcx.lookup_stability(did))\n+        self.item_id.as_def_id().and_then(|did| tcx.lookup_stability(did))\n     }\n \n     crate fn const_stability<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<ConstStability> {\n-        self.def_id.as_def_id().and_then(|did| tcx.lookup_const_stability(did))\n+        self.item_id.as_def_id().and_then(|did| tcx.lookup_const_stability(did))\n     }\n \n     crate fn deprecation(&self, tcx: TyCtxt<'_>) -> Option<Deprecation> {\n-        self.def_id.as_def_id().and_then(|did| tcx.lookup_deprecation(did))\n+        self.item_id.as_def_id().and_then(|did| tcx.lookup_deprecation(did))\n     }\n \n     crate fn inner_docs(&self, tcx: TyCtxt<'_>) -> bool {\n-        self.def_id.as_def_id().map(|did| tcx.get_attrs(did).inner_docs()).unwrap_or(false)\n+        self.item_id.as_def_id().map(|did| tcx.get_attrs(did).inner_docs()).unwrap_or(false)\n     }\n \n     crate fn span(&self, tcx: TyCtxt<'_>) -> Span {\n@@ -432,14 +432,14 @@ impl Item {\n             ItemKind::ModuleItem(Module { span, .. }) => *span,\n             ItemKind::ImplItem(Impl { kind: ImplKind::Auto, .. }) => Span::dummy(),\n             ItemKind::ImplItem(Impl { kind: ImplKind::Blanket(_), .. }) => {\n-                if let ItemId::Blanket { impl_id, .. } = self.def_id {\n+                if let ItemId::Blanket { impl_id, .. } = self.item_id {\n                     rustc_span(impl_id, tcx)\n                 } else {\n                     panic!(\"blanket impl item has non-blanket ID\")\n                 }\n             }\n             _ => {\n-                self.def_id.as_def_id().map(|did| rustc_span(did, tcx)).unwrap_or_else(Span::dummy)\n+                self.item_id.as_def_id().map(|did| rustc_span(did, tcx)).unwrap_or_else(Span::dummy)\n             }\n         }\n     }\n@@ -503,7 +503,7 @@ impl Item {\n             cx.tcx.visibility(def_id).clean(cx)\n         };\n \n-        Item { def_id: def_id.into(), kind: box kind, name, attrs, visibility, cfg }\n+        Item { item_id: def_id.into(), kind: box kind, name, attrs, visibility, cfg }\n     }\n \n     /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n@@ -517,7 +517,7 @@ impl Item {\n \n         cx.cache()\n             .intra_doc_links\n-            .get(&self.def_id)\n+            .get(&self.item_id)\n             .map_or(&[][..], |v| v.as_slice())\n             .iter()\n             .filter_map(|ItemLink { link: s, link_text, did, ref fragment }| {\n@@ -547,7 +547,7 @@ impl Item {\n     crate fn link_names(&self, cache: &Cache) -> Vec<RenderedLink> {\n         cache\n             .intra_doc_links\n-            .get(&self.def_id)\n+            .get(&self.item_id)\n             .map_or(&[][..], |v| v.as_slice())\n             .iter()\n             .map(|ItemLink { link: s, link_text, .. }| RenderedLink {\n@@ -559,7 +559,7 @@ impl Item {\n     }\n \n     crate fn is_crate(&self) -> bool {\n-        self.is_mod() && self.def_id.as_def_id().map_or(false, |did| did.index == CRATE_DEF_INDEX)\n+        self.is_mod() && self.item_id.as_def_id().map_or(false, |did| did.index == CRATE_DEF_INDEX)\n     }\n     crate fn is_mod(&self) -> bool {\n         self.type_() == ItemType::Module\n@@ -695,7 +695,7 @@ impl Item {\n         }\n         let header = match *self.kind {\n             ItemKind::ForeignFunctionItem(_) => {\n-                let abi = tcx.fn_sig(self.def_id.as_def_id().unwrap()).abi();\n+                let abi = tcx.fn_sig(self.item_id.as_def_id().unwrap()).abi();\n                 hir::FnHeader {\n                     unsafety: if abi == Abi::RustIntrinsic {\n                         intrinsic_operation_unsafety(self.name.unwrap())\n@@ -708,11 +708,11 @@ impl Item {\n                 }\n             }\n             ItemKind::FunctionItem(_) | ItemKind::MethodItem(_, _) => {\n-                let def_id = self.def_id.as_def_id().unwrap();\n+                let def_id = self.item_id.as_def_id().unwrap();\n                 build_fn_header(def_id, tcx, tcx.asyncness(def_id))\n             }\n             ItemKind::TyMethodItem(_) => {\n-                build_fn_header(self.def_id.as_def_id().unwrap(), tcx, hir::IsAsync::NotAsync)\n+                build_fn_header(self.item_id.as_def_id().unwrap(), tcx, hir::IsAsync::NotAsync)\n             }\n             _ => return None,\n         };"}, {"sha": "abfc5b80a3ef0f8bda47c6216c36db0557fcd67c", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -44,9 +44,9 @@ crate fn krate(cx: &mut DocContext<'_>) -> Crate {\n                 // `#[doc(masked)]` to the injected `extern crate` because it's unstable.\n                 if it.is_extern_crate()\n                     && (it.attrs.has_doc_flag(sym::masked)\n-                        || cx.tcx.is_compiler_builtins(it.def_id.krate()))\n+                        || cx.tcx.is_compiler_builtins(it.item_id.krate()))\n                 {\n-                    cx.cache.masked_crates.insert(it.def_id.krate());\n+                    cx.cache.masked_crates.insert(it.item_id.krate());\n                 }\n             }\n         }"}, {"sha": "b9e20c41b681fbcde73f99685551116dff064070", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -113,8 +113,8 @@ impl<'tcx> DocContext<'tcx> {\n \n     /// Like `hir().local_def_id_to_hir_id()`, but skips calling it on fake DefIds.\n     /// (This avoids a slice-index-out-of-bounds panic.)\n-    crate fn as_local_hir_id(tcx: TyCtxt<'_>, def_id: ItemId) -> Option<HirId> {\n-        match def_id {\n+    crate fn as_local_hir_id(tcx: TyCtxt<'_>, item_id: ItemId) -> Option<HirId> {\n+        match item_id {\n             ItemId::DefId(real_id) => {\n                 real_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n             }\n@@ -390,7 +390,7 @@ crate fn run_global_ctxt(\n         );\n         tcx.struct_lint_node(\n             crate::lint::MISSING_CRATE_LEVEL_DOCS,\n-            DocContext::as_local_hir_id(tcx, krate.module.def_id).unwrap(),\n+            DocContext::as_local_hir_id(tcx, krate.module.item_id).unwrap(),\n             |lint| {\n                 let mut diag =\n                     lint.build(\"no documentation found for this crate's top-level module\");"}, {"sha": "e138e434c4e04f72116b0bb1e9114fb9723cc6c5", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -186,8 +186,8 @@ impl Cache {\n \n impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n-        if item.def_id.is_local() {\n-            debug!(\"folding {} \\\"{:?}\\\", id {:?}\", item.type_(), item.name, item.def_id);\n+        if item.item_id.is_local() {\n+            debug!(\"folding {} \\\"{:?}\\\", id {:?}\", item.type_(), item.name, item.item_id);\n         }\n \n         // If this is a stripped module,\n@@ -202,7 +202,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n         // If the impl is from a masked crate or references something from a\n         // masked crate then remove it completely.\n         if let clean::ImplItem(ref i) = *item.kind {\n-            if self.cache.masked_crates.contains(&item.def_id.krate())\n+            if self.cache.masked_crates.contains(&item.item_id.krate())\n                 || i.trait_\n                     .as_ref()\n                     .map_or(false, |t| self.cache.masked_crates.contains(&t.def_id().krate))\n@@ -217,7 +217,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n         // Propagate a trait method's documentation to all implementors of the\n         // trait.\n         if let clean::TraitItem(ref t) = *item.kind {\n-            self.cache.traits.entry(item.def_id.expect_def_id()).or_insert_with(|| {\n+            self.cache.traits.entry(item.item_id.expect_def_id()).or_insert_with(|| {\n                 clean::TraitWithExtraInfo {\n                     trait_: t.clone(),\n                     is_notable: item.attrs.has_doc_flag(sym::notable_trait),\n@@ -293,7 +293,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                     // A crate has a module at its root, containing all items,\n                     // which should not be indexed. The crate-item itself is\n                     // inserted later on when serializing the search-index.\n-                    if item.def_id.index().map_or(false, |idx| idx != CRATE_DEF_INDEX) {\n+                    if item.item_id.index().map_or(false, |idx| idx != CRATE_DEF_INDEX) {\n                         let desc = item.doc_value().map_or_else(String::new, |x| {\n                             short_markdown_summary(x.as_str(), &item.link_names(self.cache))\n                         });\n@@ -351,11 +351,11 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                     // `public_items` map, so we can skip inserting into the\n                     // paths map if there was already an entry present and we're\n                     // not a public item.\n-                    if !self.cache.paths.contains_key(&item.def_id.expect_def_id())\n-                        || self.cache.access_levels.is_public(item.def_id.expect_def_id())\n+                    if !self.cache.paths.contains_key(&item.item_id.expect_def_id())\n+                        || self.cache.access_levels.is_public(item.item_id.expect_def_id())\n                     {\n                         self.cache.paths.insert(\n-                            item.def_id.expect_def_id(),\n+                            item.item_id.expect_def_id(),\n                             (self.cache.stack.clone(), item.type_()),\n                         );\n                     }\n@@ -364,7 +364,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             clean::PrimitiveItem(..) => {\n                 self.cache\n                     .paths\n-                    .insert(item.def_id.expect_def_id(), (self.cache.stack.clone(), item.type_()));\n+                    .insert(item.item_id.expect_def_id(), (self.cache.stack.clone(), item.type_()));\n             }\n \n             clean::ExternCrateItem { .. }\n@@ -396,7 +396,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             | clean::StructItem(..)\n             | clean::UnionItem(..)\n             | clean::VariantItem(..) => {\n-                self.cache.parent_stack.push(item.def_id.expect_def_id());\n+                self.cache.parent_stack.push(item.item_id.expect_def_id());\n                 self.cache.parent_is_trait_impl = false;\n                 true\n             }"}, {"sha": "8e643107353ddadc1de5887ab3eeee002445157d", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -222,7 +222,7 @@ impl<'tcx> Context<'tcx> {\n                 &self.shared.style_files,\n             )\n         } else {\n-            if let Some(&(ref names, ty)) = self.cache().paths.get(&it.def_id.expect_def_id()) {\n+            if let Some(&(ref names, ty)) = self.cache().paths.get(&it.item_id.expect_def_id()) {\n                 if self.current.len() + 1 != names.len()\n                     || self.current.iter().zip(names.iter()).any(|(a, b)| a != b)\n                 {"}, {"sha": "7a4289b8e60e9eebd0caa60683b1039887c35882", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -830,7 +830,7 @@ fn assoc_const(\n         w,\n         \"{extra}{vis}const <a{href} class=\\\"constant\\\">{name}</a>: {ty}\",\n         extra = extra,\n-        vis = it.visibility.print_with_space(it.def_id, cx),\n+        vis = it.visibility.print_with_space(it.item_id, cx),\n         href = assoc_href_attr(it, link, cx),\n         name = it.name.as_ref().unwrap(),\n         ty = ty.print(cx),\n@@ -884,7 +884,7 @@ fn assoc_method(\n ) {\n     let header = meth.fn_header(cx.tcx()).expect(\"Trying to get header from a non-function item\");\n     let name = meth.name.as_ref().unwrap();\n-    let vis = meth.visibility.print_with_space(meth.def_id, cx).to_string();\n+    let vis = meth.visibility.print_with_space(meth.item_id, cx).to_string();\n     // FIXME: Once https://github.com/rust-lang/rust/issues/67792 is implemented, we can remove\n     // this condition.\n     let constness = match render_mode {\n@@ -2060,7 +2060,7 @@ fn small_url_encode(s: String) -> String {\n }\n \n fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n-    let did = it.def_id.expect_def_id();\n+    let did = it.item_id.expect_def_id();\n     let cache = cx.cache();\n \n     if let Some(v) = cache.impls.get(&did) {\n@@ -2412,7 +2412,7 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n     );\n \n     let cache = cx.cache();\n-    if let Some(implementors) = cache.implementors.get(&it.def_id.expect_def_id()) {\n+    if let Some(implementors) = cache.implementors.get(&it.item_id.expect_def_id()) {\n         let mut res = implementors\n             .iter()\n             .filter(|i| {\n@@ -2761,7 +2761,7 @@ const NUM_VISIBLE_LINES: usize = 10;\n /// Generates the HTML for example call locations generated via the --scrape-examples flag.\n fn render_call_locations(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item) {\n     let tcx = cx.tcx();\n-    let def_id = item.def_id.expect_def_id();\n+    let def_id = item.item_id.expect_def_id();\n     let key = tcx.def_path_hash(def_id);\n     let Some(call_locations) = cx.shared.call_locations.get(&key) else { return };\n "}, {"sha": "f1915920b6d05dd79832656d491f2ffb06e3198d", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -264,7 +264,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n     // (which is the position in the vector).\n     indices.dedup_by_key(|i| {\n         (\n-            items[*i].def_id,\n+            items[*i].item_id,\n             if items[*i].name.is_some() { Some(full_path(cx, &items[*i])) } else { None },\n             items[*i].type_(),\n             if items[*i].is_import() { *i } else { 0 },\n@@ -306,15 +306,15 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                     Some(src) => write!(\n                         w,\n                         \"<div class=\\\"item-left\\\"><code>{}extern crate {} as {};\",\n-                        myitem.visibility.print_with_space(myitem.def_id, cx),\n-                        anchor(myitem.def_id.expect_def_id(), src, cx),\n+                        myitem.visibility.print_with_space(myitem.item_id, cx),\n+                        anchor(myitem.item_id.expect_def_id(), src, cx),\n                         myitem.name.unwrap(),\n                     ),\n                     None => write!(\n                         w,\n                         \"<div class=\\\"item-left\\\"><code>{}extern crate {};\",\n-                        myitem.visibility.print_with_space(myitem.def_id, cx),\n-                        anchor(myitem.def_id.expect_def_id(), myitem.name.unwrap(), cx),\n+                        myitem.visibility.print_with_space(myitem.item_id, cx),\n+                        anchor(myitem.item_id.expect_def_id(), myitem.name.unwrap(), cx),\n                     ),\n                 }\n                 w.write_str(\"</code></div>\");\n@@ -328,7 +328,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n \n                     // Just need an item with the correct def_id and attrs\n                     let import_item = clean::Item {\n-                        def_id: import_def_id.into(),\n+                        item_id: import_def_id.into(),\n                         attrs: import_attrs,\n                         cfg: ast_attrs.cfg(cx.tcx(), &cx.cache().hidden_cfg),\n                         ..myitem.clone()\n@@ -352,7 +352,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                      <div class=\\\"item-right docblock-short\\\">{stab_tags}</div>\",\n                     stab = stab.unwrap_or_default(),\n                     add = add,\n-                    vis = myitem.visibility.print_with_space(myitem.def_id, cx),\n+                    vis = myitem.visibility.print_with_space(myitem.item_id, cx),\n                     imp = import.print(cx),\n                     stab_tags = stab_tags.unwrap_or_default(),\n                 );\n@@ -468,7 +468,7 @@ fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::\n     let unsafety = header.unsafety.print_with_space();\n     let abi = print_abi_with_space(header.abi).to_string();\n     let asyncness = header.asyncness.print_with_space();\n-    let visibility = it.visibility.print_with_space(it.def_id, cx).to_string();\n+    let visibility = it.visibility.print_with_space(it.item_id, cx).to_string();\n     let name = it.name.unwrap();\n \n     let generics_len = format!(\"{:#}\", f.generics.print(cx)).len();\n@@ -524,7 +524,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n             write!(\n                 w,\n                 \"{}{}{}trait {}{}{}\",\n-                it.visibility.print_with_space(it.def_id, cx),\n+                it.visibility.print_with_space(it.item_id, cx),\n                 t.unsafety.print_with_space(),\n                 if t.is_auto { \"auto \" } else { \"\" },\n                 it.name.unwrap(),\n@@ -787,10 +787,10 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    render_assoc_items(w, cx, it, it.def_id.expect_def_id(), AssocItemRender::All);\n+    render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All);\n \n     let cache = cx.cache();\n-    if let Some(implementors) = cache.implementors.get(&it.def_id.expect_def_id()) {\n+    if let Some(implementors) = cache.implementors.get(&it.item_id.expect_def_id()) {\n         // The DefId is for the first Type found with that name. The bool is\n         // if any Types with the same name but different DefId have been found.\n         let mut implementor_dups: FxHashMap<Symbol, (DefId, bool)> = FxHashMap::default();\n@@ -827,7 +827,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n             for implementor in foreign {\n                 let provided_methods = implementor.inner_impl().provided_trait_methods(cx.tcx());\n                 let assoc_link =\n-                    AssocItemLink::GotoSource(implementor.impl_item.def_id, &provided_methods);\n+                    AssocItemLink::GotoSource(implementor.impl_item.item_id, &provided_methods);\n                 render_impl(\n                     w,\n                     cx,\n@@ -902,10 +902,10 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         .take(cx.current.len())\n         .chain(std::iter::once(\"implementors\"))\n         .collect();\n-    if it.def_id.is_local() {\n+    if it.item_id.is_local() {\n         js_src_path.extend(cx.current.iter().copied());\n     } else {\n-        let (ref path, _) = cache.external_paths[&it.def_id.expect_def_id()];\n+        let (ref path, _) = cache.external_paths[&it.item_id.expect_def_id()];\n         js_src_path.extend(path[..path.len() - 1].iter().copied());\n     }\n     js_src_path.push_fmt(format_args!(\"{}.{}.js\", it.type_(), it.name.unwrap()));\n@@ -937,7 +937,7 @@ fn item_trait_alias(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clea\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id.expect_def_id(), AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All)\n }\n \n fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::OpaqueTy) {\n@@ -961,14 +961,14 @@ fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean:\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id.expect_def_id(), AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All)\n }\n \n fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n     fn write_content(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n         wrap_item(w, \"typedef\", |w| {\n             render_attributes_in_pre(w, it, \"\");\n-            write!(w, \"{}\", it.visibility.print_with_space(it.def_id, cx));\n+            write!(w, \"{}\", it.visibility.print_with_space(it.item_id, cx));\n             write!(\n                 w,\n                 \"type {}{}{where_clause} = {type_};\",\n@@ -984,7 +984,7 @@ fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::T\n \n     document(w, cx, it, None, HeadingOffset::H2);\n \n-    let def_id = it.def_id.expect_def_id();\n+    let def_id = it.item_id.expect_def_id();\n     // Render any items associated directly to this alias, as otherwise they\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n@@ -1037,7 +1037,7 @@ fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Uni\n             document(w, cx, field, Some(it), HeadingOffset::H3);\n         }\n     }\n-    let def_id = it.def_id.expect_def_id();\n+    let def_id = it.item_id.expect_def_id();\n     render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n     document_type_layout(w, cx, def_id);\n }\n@@ -1062,7 +1062,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n             write!(\n                 w,\n                 \"{}enum {}{}{}\",\n-                it.visibility.print_with_space(it.def_id, cx),\n+                it.visibility.print_with_space(it.item_id, cx),\n                 it.name.unwrap(),\n                 e.generics.print(cx),\n                 print_where_clause(&e.generics, cx, 0, true),\n@@ -1197,7 +1197,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n             document(w, cx, variant, Some(it), HeadingOffset::H4);\n         }\n     }\n-    let def_id = it.def_id.expect_def_id();\n+    let def_id = it.item_id.expect_def_id();\n     render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n     document_type_layout(w, cx, def_id);\n }\n@@ -1253,7 +1253,7 @@ fn item_proc_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, m: &clean\n \n fn item_primitive(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n     document(w, cx, it, None, HeadingOffset::H2);\n-    render_assoc_items(w, cx, it, it.def_id.expect_def_id(), AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All)\n }\n \n fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::Constant) {\n@@ -1264,7 +1264,7 @@ fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::\n             write!(\n                 w,\n                 \"{vis}const {name}: {typ}\",\n-                vis = it.visibility.print_with_space(it.def_id, cx),\n+                vis = it.visibility.print_with_space(it.item_id, cx),\n                 name = it.name.unwrap(),\n                 typ = c.type_.print(cx),\n             );\n@@ -1344,7 +1344,7 @@ fn item_struct(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n             }\n         }\n     }\n-    let def_id = it.def_id.expect_def_id();\n+    let def_id = it.item_id.expect_def_id();\n     render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n     document_type_layout(w, cx, def_id);\n }\n@@ -1356,7 +1356,7 @@ fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n             write!(\n                 w,\n                 \"{vis}static {mutability}{name}: {typ}\",\n-                vis = it.visibility.print_with_space(it.def_id, cx),\n+                vis = it.visibility.print_with_space(it.item_id, cx),\n                 mutability = s.mutability.print_with_space(),\n                 name = it.name.unwrap(),\n                 typ = s.type_.print(cx)\n@@ -1374,15 +1374,15 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n             write!(\n                 w,\n                 \"    {}type {};\\n}}\",\n-                it.visibility.print_with_space(it.def_id, cx),\n+                it.visibility.print_with_space(it.item_id, cx),\n                 it.name.unwrap(),\n             );\n         });\n     });\n \n     document(w, cx, it, None, HeadingOffset::H2);\n \n-    render_assoc_items(w, cx, it, it.def_id.expect_def_id(), AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All)\n }\n \n fn item_keyword(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n@@ -1543,7 +1543,7 @@ fn render_union(\n     tab: &str,\n     cx: &Context<'_>,\n ) {\n-    write!(w, \"{}union {}\", it.visibility.print_with_space(it.def_id, cx), it.name.unwrap());\n+    write!(w, \"{}union {}\", it.visibility.print_with_space(it.item_id, cx), it.name.unwrap());\n     if let Some(g) = g {\n         write!(w, \"{}\", g.print(cx));\n         write!(w, \"{}\", print_where_clause(g, cx, 0, true));\n@@ -1562,7 +1562,7 @@ fn render_union(\n             write!(\n                 w,\n                 \"    {}{}: {},\\n{}\",\n-                field.visibility.print_with_space(field.def_id, cx),\n+                field.visibility.print_with_space(field.item_id, cx),\n                 field.name.unwrap(),\n                 ty.print(cx),\n                 tab\n@@ -1592,7 +1592,7 @@ fn render_struct(\n     write!(\n         w,\n         \"{}{}{}\",\n-        it.visibility.print_with_space(it.def_id, cx),\n+        it.visibility.print_with_space(it.item_id, cx),\n         if structhead { \"struct \" } else { \"\" },\n         it.name.unwrap()\n     );\n@@ -1618,7 +1618,7 @@ fn render_struct(\n                         w,\n                         \"\\n{}    {}{}: {},\",\n                         tab,\n-                        field.visibility.print_with_space(field.def_id, cx),\n+                        field.visibility.print_with_space(field.item_id, cx),\n                         field.name.unwrap(),\n                         ty.print(cx),\n                     );\n@@ -1650,7 +1650,7 @@ fn render_struct(\n                         write!(\n                             w,\n                             \"{}{}\",\n-                            field.visibility.print_with_space(field.def_id, cx),\n+                            field.visibility.print_with_space(field.item_id, cx),\n                             ty.print(cx),\n                         )\n                     }"}, {"sha": "371d0e84087544d4223a3427721fd102570702a6", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -535,7 +535,7 @@ pub(super) fn write_shared(\n                 //\n                 // If the implementation is from another crate then that crate\n                 // should add it.\n-                if imp.impl_item.def_id.krate() == did.krate || !imp.impl_item.def_id.is_local() {\n+                if imp.impl_item.item_id.krate() == did.krate || !imp.impl_item.item_id.is_local() {\n                     None\n                 } else {\n                     Some(Implementor {"}, {"sha": "0b5fb480595797a3fbc96264fd079961371e0f45", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -27,7 +27,7 @@ impl JsonRenderer<'_> {\n         let links = self\n             .cache\n             .intra_doc_links\n-            .get(&item.def_id)\n+            .get(&item.item_id)\n             .into_iter()\n             .flatten()\n             .map(|clean::ItemLink { link, did, .. }| (link.clone(), from_item_id((*did).into())))\n@@ -40,14 +40,14 @@ impl JsonRenderer<'_> {\n             .map(rustc_ast_pretty::pprust::attribute_to_string)\n             .collect();\n         let span = item.span(self.tcx);\n-        let clean::Item { name, attrs: _, kind: _, visibility, def_id, cfg: _ } = item;\n+        let clean::Item { name, attrs: _, kind: _, visibility, item_id, cfg: _ } = item;\n         let inner = match *item.kind {\n             clean::StrippedItem(_) => return None,\n             _ => from_clean_item(item, self.tcx),\n         };\n         Some(Item {\n-            id: from_item_id(def_id),\n-            crate_id: def_id.krate().as_u32(),\n+            id: from_item_id(item_id),\n+            crate_id: item_id.krate().as_u32(),\n             name: name.map(|sym| sym.to_string()),\n             span: self.convert_span(span),\n             visibility: self.convert_visibility(visibility),\n@@ -174,7 +174,7 @@ impl FromWithTcx<clean::TypeBindingKind> for TypeBindingKind {\n     }\n }\n \n-crate fn from_item_id(did: ItemId) -> Id {\n+crate fn from_item_id(item_id: ItemId) -> Id {\n     struct DisplayDefId(DefId);\n \n     impl fmt::Display for DisplayDefId {\n@@ -183,7 +183,7 @@ crate fn from_item_id(did: ItemId) -> Id {\n         }\n     }\n \n-    match did {\n+    match item_id {\n         ItemId::DefId(did) => Id(format!(\"{}\", DisplayDefId(did))),\n         ItemId::Blanket { for_, impl_id } => {\n             Id(format!(\"b:{}-{}\", DisplayDefId(impl_id), DisplayDefId(for_)))\n@@ -732,5 +732,5 @@ impl FromWithTcx<ItemType> for ItemKind {\n }\n \n fn ids(items: impl IntoIterator<Item = clean::Item>) -> Vec<Id> {\n-    items.into_iter().filter(|x| !x.is_stripped()).map(|i| from_item_id(i.def_id)).collect()\n+    items.into_iter().filter(|x| !x.is_stripped()).map(|i| from_item_id(i.item_id)).collect()\n }"}, {"sha": "e6e5bba7f006745d94d8cba6ef31d283f76192bc", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -54,7 +54,7 @@ impl<'tcx> JsonRenderer<'tcx> {\n                     .map(|i| {\n                         let item = &i.impl_item;\n                         self.item(item.clone()).unwrap();\n-                        from_item_id(item.def_id)\n+                        from_item_id(item.item_id)\n                     })\n                     .collect()\n             })\n@@ -84,9 +84,9 @@ impl<'tcx> JsonRenderer<'tcx> {\n                             }\n                         }\n \n-                        if item.def_id.is_local() || is_primitive_impl {\n+                        if item.item_id.is_local() || is_primitive_impl {\n                             self.item(item.clone()).unwrap();\n-                            Some(from_item_id(item.def_id))\n+                            Some(from_item_id(item.item_id))\n                         } else {\n                             None\n                         }\n@@ -176,18 +176,18 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n         // Flatten items that recursively store other items\n         item.kind.inner_items().for_each(|i| self.item(i.clone()).unwrap());\n \n-        let id = item.def_id;\n+        let item_id = item.item_id;\n         if let Some(mut new_item) = self.convert_item(item) {\n             if let types::ItemEnum::Trait(ref mut t) = new_item.inner {\n-                t.implementations = self.get_trait_implementors(id.expect_def_id())\n+                t.implementations = self.get_trait_implementors(item_id.expect_def_id())\n             } else if let types::ItemEnum::Struct(ref mut s) = new_item.inner {\n-                s.impls = self.get_impls(id.expect_def_id())\n+                s.impls = self.get_impls(item_id.expect_def_id())\n             } else if let types::ItemEnum::Enum(ref mut e) = new_item.inner {\n-                e.impls = self.get_impls(id.expect_def_id())\n+                e.impls = self.get_impls(item_id.expect_def_id())\n             } else if let types::ItemEnum::Union(ref mut u) = new_item.inner {\n-                u.impls = self.get_impls(id.expect_def_id())\n+                u.impls = self.get_impls(item_id.expect_def_id())\n             }\n-            let removed = self.index.borrow_mut().insert(from_item_id(id), new_item.clone());\n+            let removed = self.index.borrow_mut().insert(from_item_id(item_id), new_item.clone());\n \n             // FIXME(adotinthevoid): Currently, the index is duplicated. This is a sanity check\n             // to make sure the items are unique. The main place this happens is when an item, is"}, {"sha": "1839a35a8b14bb38f24ef318a4a0ffd4ab38c14e", "filename": "src/librustdoc/passes/bare_urls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -61,7 +61,7 @@ crate fn check_bare_urls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n \n impl<'a, 'tcx> DocVisitor for BareUrlsLinter<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n-        let Some(hir_id) = DocContext::as_local_hir_id(self.cx.tcx, item.def_id)\n+        let Some(hir_id) = DocContext::as_local_hir_id(self.cx.tcx, item.item_id)\n         else {\n             // If non-local, no need to check anything.\n             return;"}, {"sha": "33d83aa339d95313441d9f47a2e6cab5285b5ac9", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -185,7 +185,7 @@ impl<'a, 'b> CoverageCalculator<'a, 'b> {\n \n impl<'a, 'b> DocVisitor for CoverageCalculator<'a, 'b> {\n     fn visit_item(&mut self, i: &clean::Item) {\n-        if !i.def_id.is_local() {\n+        if !i.item_id.is_local() {\n             // non-local items are skipped because they can be out of the users control,\n             // especially in the case of trait impls, which rustdoc eagerly inlines\n             return;\n@@ -223,7 +223,7 @@ impl<'a, 'b> DocVisitor for CoverageCalculator<'a, 'b> {\n                     .ctx\n                     .tcx\n                     .hir()\n-                    .local_def_id_to_hir_id(i.def_id.expect_def_id().expect_local());\n+                    .local_def_id_to_hir_id(i.item_id.expect_def_id().expect_local());\n                 let (level, source) = self.ctx.tcx.lint_level_at_node(MISSING_DOCS, hir_id);\n \n                 // In case we have:\n@@ -237,7 +237,7 @@ impl<'a, 'b> DocVisitor for CoverageCalculator<'a, 'b> {\n                 // there is no need to require documentation on the fields of tuple variants and\n                 // tuple structs.\n                 let should_be_ignored = i\n-                    .def_id\n+                    .item_id\n                     .as_def_id()\n                     .and_then(|def_id| self.ctx.tcx.parent(def_id))\n                     .and_then(|def_id| self.ctx.tcx.hir().get_if_local(def_id))"}, {"sha": "23d947c4d7227e74c869b64bef89eda9261588ea", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n             return;\n         }\n \n-        let Some(local_id) = item.def_id.as_def_id().and_then(|x| x.as_local())\n+        let Some(local_id) = item.item_id.as_def_id().and_then(|x| x.as_local())\n         else {\n             // We don't need to check the syntax for other crates so returning\n             // without doing anything should not be a problem.\n@@ -153,7 +153,7 @@ impl<'a, 'tcx> DocVisitor for SyntaxChecker<'a, 'tcx> {\n             let sp = item.attr_span(self.cx.tcx);\n             let extra = crate::html::markdown::ExtraInfo::new_did(\n                 self.cx.tcx,\n-                item.def_id.expect_def_id(),\n+                item.item_id.expect_def_id(),\n                 sp,\n             );\n             for code_block in markdown::rust_code_blocks(dox, &extra) {"}, {"sha": "80a2683fde7f4f87fd2cae41e2f7bfc2766c17d7", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -56,7 +56,7 @@ impl crate::doctest::Tester for Tests {\n }\n \n crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool {\n-    if !cx.cache.access_levels.is_public(item.def_id.expect_def_id())\n+    if !cx.cache.access_levels.is_public(item.item_id.expect_def_id())\n         || matches!(\n             *item.kind,\n             clean::StructFieldItem(_)\n@@ -79,7 +79,7 @@ crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> boo\n \n     // The `expect_def_id()` should be okay because `local_def_id_to_hir_id`\n     // would presumably panic if a fake `DefIndex` were passed.\n-    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(item.def_id.expect_def_id().expect_local());\n+    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(item.item_id.expect_def_id().expect_local());\n \n     // check if parent is trait impl\n     if let Some(parent_hir_id) = cx.tcx.hir().find_parent_node(hir_id) {\n@@ -107,7 +107,7 @@ crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> boo\n }\n \n crate fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item) {\n-    let Some(hir_id) = DocContext::as_local_hir_id(cx.tcx, item.def_id)\n+    let Some(hir_id) = DocContext::as_local_hir_id(cx.tcx, item.item_id)\n     else {\n         // If non-local, no need to check anything.\n         return;\n@@ -131,7 +131,7 @@ crate fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item) {\n             );\n         }\n     } else if tests.found_tests > 0\n-        && !cx.cache.access_levels.is_exported(item.def_id.expect_def_id())\n+        && !cx.cache.access_levels.is_exported(item.item_id.expect_def_id())\n     {\n         cx.tcx.struct_span_lint_hir(\n             crate::lint::PRIVATE_DOC_TESTS,"}, {"sha": "c48f8bd0c7cc5a0cced4aa8341630a5157369718", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -1025,15 +1025,15 @@ fn is_derive_trait_collision<T>(ns: &PerNS<Result<(Res, T), ResolutionFailure<'_\n impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n         let parent_node =\n-            item.def_id.as_def_id().and_then(|did| find_nearest_parent_module(self.cx.tcx, did));\n+            item.item_id.as_def_id().and_then(|did| find_nearest_parent_module(self.cx.tcx, did));\n         if parent_node.is_some() {\n-            trace!(\"got parent node for {:?} {:?}, id {:?}\", item.type_(), item.name, item.def_id);\n+            trace!(\"got parent node for {:?} {:?}, id {:?}\", item.type_(), item.name, item.item_id);\n         }\n \n         let inner_docs = item.inner_docs(self.cx.tcx);\n \n         if item.is_mod() && inner_docs {\n-            self.mod_ids.push(item.def_id.expect_def_id());\n+            self.mod_ids.push(item.item_id.expect_def_id());\n         }\n \n         // We want to resolve in the lexical scope of the documentation.\n@@ -1048,14 +1048,14 @@ impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n             for md_link in markdown_links(&doc) {\n                 let link = self.resolve_link(&item, &doc, parent_node, md_link);\n                 if let Some(link) = link {\n-                    self.cx.cache.intra_doc_links.entry(item.def_id).or_default().push(link);\n+                    self.cx.cache.intra_doc_links.entry(item.item_id).or_default().push(link);\n                 }\n             }\n         }\n \n         if item.is_mod() {\n             if !inner_docs {\n-                self.mod_ids.push(item.def_id.expect_def_id());\n+                self.mod_ids.push(item.item_id.expect_def_id());\n             }\n \n             self.visit_item_recur(item);\n@@ -1246,7 +1246,7 @@ impl LinkCollector<'_, '_> {\n \n         let (mut res, fragment) = self.resolve_with_disambiguator_cached(\n             ResolutionInfo {\n-                item_id: item.def_id,\n+                item_id: item.item_id,\n                 module_id,\n                 dis: disambiguator,\n                 path_str: path_str.to_owned(),\n@@ -1302,7 +1302,7 @@ impl LinkCollector<'_, '_> {\n                     // FIXME: it would be nice to check that the feature gate was enabled in the original crate, not just ignore it altogether.\n                     // However I'm not sure how to check that across crates.\n                     if prim == PrimitiveType::RawPointer\n-                        && item.def_id.is_local()\n+                        && item.item_id.is_local()\n                         && !self.cx.tcx.features().intra_doc_pointers\n                     {\n                         self.report_rawptr_assoc_feature_gate(dox, &ori_link, item);\n@@ -1386,7 +1386,7 @@ impl LinkCollector<'_, '_> {\n             // The `expect_def_id()` should be okay because `local_def_id_to_hir_id`\n             // would presumably panic if a fake `DefIndex` were passed.\n             .and_then(|dst_id| {\n-                item.def_id.expect_def_id().as_local().map(|src_id| (src_id, dst_id))\n+                item.item_id.expect_def_id().as_local().map(|src_id| (src_id, dst_id))\n             })\n         {\n             if self.cx.tcx.privacy_access_levels(()).is_exported(src_id)\n@@ -1864,7 +1864,7 @@ fn report_diagnostic(\n     DiagnosticInfo { item, ori_link: _, dox, link_range }: &DiagnosticInfo<'_>,\n     decorate: impl FnOnce(&mut Diagnostic, Option<rustc_span::Span>),\n ) {\n-    let Some(hir_id) = DocContext::as_local_hir_id(tcx, item.def_id)\n+    let Some(hir_id) = DocContext::as_local_hir_id(tcx, item.item_id)\n     else {\n         // If non-local, no need to check anything.\n         info!(\"ignoring warning from parent crate: {}\", msg);"}, {"sha": "65459913eeaa80d09415c56d2e78ba28f2890358", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -52,7 +52,7 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n                 // FIXME(eddyb) is this `doc(hidden)` check needed?\n                 if !cx.tcx.is_doc_hidden(def_id) {\n                     let impls = get_auto_trait_and_blanket_impls(cx, def_id);\n-                    new_items.extend(impls.filter(|i| cx.inlined.insert(i.def_id)));\n+                    new_items.extend(impls.filter(|i| cx.inlined.insert(i.item_id)));\n                 }\n             }\n         }\n@@ -176,9 +176,9 @@ impl<'a, 'tcx> DocVisitor for SyntheticImplCollector<'a, 'tcx> {\n     fn visit_item(&mut self, i: &Item) {\n         if i.is_struct() || i.is_enum() || i.is_union() {\n             // FIXME(eddyb) is this `doc(hidden)` check needed?\n-            if !self.cx.tcx.is_doc_hidden(i.def_id.expect_def_id()) {\n+            if !self.cx.tcx.is_doc_hidden(i.item_id.expect_def_id()) {\n                 self.impls\n-                    .extend(get_auto_trait_and_blanket_impls(self.cx, i.def_id.expect_def_id()));\n+                    .extend(get_auto_trait_and_blanket_impls(self.cx, i.item_id.expect_def_id()));\n             }\n         }\n \n@@ -199,7 +199,7 @@ impl ItemCollector {\n \n impl DocVisitor for ItemCollector {\n     fn visit_item(&mut self, i: &Item) {\n-        self.items.insert(i.def_id);\n+        self.items.insert(i.item_id);\n \n         self.visit_item_recur(i)\n     }\n@@ -225,7 +225,7 @@ impl<'a> BadImplStripper<'a> {\n         }\n     }\n \n-    fn keep_impl_with_def_id(&self, did: ItemId) -> bool {\n-        self.items.contains(&did)\n+    fn keep_impl_with_def_id(&self, item_id: ItemId) -> bool {\n+        self.items.contains(&item_id)\n     }\n }"}, {"sha": "044f224e7885c24727e4907977331b2faef474df", "filename": "src/librustdoc/passes/html_tags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -197,7 +197,7 @@ fn extract_tags(\n impl<'a, 'tcx> DocVisitor for InvalidHtmlTagsLinter<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n         let tcx = self.cx.tcx;\n-        let Some(hir_id) = DocContext::as_local_hir_id(tcx, item.def_id)\n+        let Some(hir_id) = DocContext::as_local_hir_id(tcx, item.item_id)\n         // If non-local, no need to check anything.\n         else { return };\n         let dox = item.attrs.collapsed_doc_value().unwrap_or_default();"}, {"sha": "6b052185bbdb84b7c7c2a0fcd6b8a881c5143159", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -53,7 +53,7 @@ impl<'a> DocFolder for Stripper<'a> {\n             }\n         } else {\n             if self.update_retained {\n-                self.retained.insert(i.def_id);\n+                self.retained.insert(i.item_id);\n             }\n         }\n         Some(self.fold_item_recur(i))"}, {"sha": "6a522bdacf997849e1fc4bd4bfbdcf3106069d5e", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -45,7 +45,8 @@ impl<'a> DocFolder for Stripper<'a> {\n             | clean::TraitAliasItem(..)\n             | clean::MacroItem(..)\n             | clean::ForeignTypeItem => {\n-                if i.def_id.is_local() && !self.access_levels.is_exported(i.def_id.expect_def_id())\n+                if i.item_id.is_local()\n+                    && !self.access_levels.is_exported(i.item_id.expect_def_id())\n                 {\n                     debug!(\"Stripper: stripping {:?} {:?}\", i.type_(), i.name);\n                     return None;\n@@ -59,7 +60,7 @@ impl<'a> DocFolder for Stripper<'a> {\n             }\n \n             clean::ModuleItem(..) => {\n-                if i.def_id.is_local() && !i.visibility.is_public() {\n+                if i.item_id.is_local() && !i.visibility.is_public() {\n                     debug!(\"Stripper: stripping module {:?}\", i.name);\n                     let old = mem::replace(&mut self.update_retained, false);\n                     let ret = strip_item(self.fold_item_recur(i));\n@@ -100,15 +101,15 @@ impl<'a> DocFolder for Stripper<'a> {\n \n         let i = if fastreturn {\n             if self.update_retained {\n-                self.retained.insert(i.def_id);\n+                self.retained.insert(i.item_id);\n             }\n             return Some(i);\n         } else {\n             self.fold_item_recur(i)\n         };\n \n         if self.update_retained {\n-            self.retained.insert(i.def_id);\n+            self.retained.insert(i.item_id);\n         }\n         Some(i)\n     }"}, {"sha": "c01379065d1cd5ded2faa70b9e0daedce9ec065e", "filename": "src/test/pretty/stmt_expr_attributes.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -1,6 +1,8 @@\n // pp-exact\n \n #![feature(box_syntax)]\n+#![feature(inline_const)]\n+#![feature(inline_const_pat)]\n #![feature(rustc_attrs)]\n #![feature(stmt_expr_attributes)]\n \n@@ -16,6 +18,7 @@ fn _1() {\n \n     #[rustc_dummy]\n     unsafe {\n+        #![rustc_dummy]\n         // code\n     }\n }\n@@ -206,6 +209,12 @@ fn _11() {\n             let _ = ();\n             ()\n         };\n+    let const {\n+                    #![rustc_dummy]\n+                } =\n+        #[rustc_dummy] const {\n+                #![rustc_dummy]\n+            };\n     let mut x = 0;\n     let _ = #[rustc_dummy] x = 15;\n     let _ = #[rustc_dummy] x += 15;"}, {"sha": "f1c4273870bffdbdd0e830c2af39e7363714386d", "filename": "src/test/ui/thread-local/non-static.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Ftest%2Fui%2Fthread-local%2Fnon-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Ftest%2Fui%2Fthread-local%2Fnon-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fthread-local%2Fnon-static.rs?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -0,0 +1,30 @@\n+// Check that #[thread_local] attribute is rejected on non-static items.\n+#![feature(thread_local)]\n+\n+#[thread_local]\n+//~^ ERROR attribute should be applied to a static\n+const A: u32 = 0;\n+\n+#[thread_local]\n+//~^ ERROR attribute should be applied to a static\n+fn main() {\n+    #[thread_local] || {};\n+    //~^ ERROR attribute should be applied to a static\n+}\n+\n+struct S {\n+    #[thread_local]\n+    //~^ ERROR attribute should be applied to a static\n+    a: String,\n+    b: String,\n+}\n+\n+#[thread_local]\n+// Static. OK.\n+static B: u32 = 0;\n+\n+extern \"C\" {\n+    #[thread_local]\n+    // Foreign static. OK.\n+    static C: u32;\n+}"}, {"sha": "09a1618d6e710362fe8b8b0578a87a624f46717e", "filename": "src/test/ui/thread-local/non-static.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Ftest%2Fui%2Fthread-local%2Fnon-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Ftest%2Fui%2Fthread-local%2Fnon-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fthread-local%2Fnon-static.stderr?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -0,0 +1,38 @@\n+error: attribute should be applied to a static\n+  --> $DIR/non-static.rs:4:1\n+   |\n+LL | #[thread_local]\n+   | ^^^^^^^^^^^^^^^\n+LL |\n+LL | const A: u32 = 0;\n+   | ----------------- not a static\n+\n+error: attribute should be applied to a static\n+  --> $DIR/non-static.rs:8:1\n+   |\n+LL |   #[thread_local]\n+   |   ^^^^^^^^^^^^^^^\n+LL |\n+LL | / fn main() {\n+LL | |     #[thread_local] || {};\n+LL | |\n+LL | | }\n+   | |_- not a static\n+\n+error: attribute should be applied to a static\n+  --> $DIR/non-static.rs:11:5\n+   |\n+LL |     #[thread_local] || {};\n+   |     ^^^^^^^^^^^^^^^ ----- not a static\n+\n+error: attribute should be applied to a static\n+  --> $DIR/non-static.rs:16:5\n+   |\n+LL |     #[thread_local]\n+   |     ^^^^^^^^^^^^^^^\n+LL |\n+LL |     a: String,\n+   |     --------- not a static\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "f074eb941dca2388e15a26d49a66b60b094de92c", "filename": "src/tools/rustbook/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Ftools%2Frustbook%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/878c7833f6c1ff10e2fd89074e5bd4ef5ff15936/src%2Ftools%2Frustbook%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2FCargo.toml?ref=878c7833f6c1ff10e2fd89074e5bd4ef5ff15936", "patch": "@@ -9,6 +9,6 @@ clap = \"2.25.0\"\n env_logger = \"0.7.1\"\n \n [dependencies.mdbook]\n-version = \"0.4.14\"\n+version = \"0.4.18\"\n default-features = false\n features = [\"search\"]"}]}