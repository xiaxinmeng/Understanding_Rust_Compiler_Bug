{"sha": "1fb08f11b75259ad4f208e25fab6c7acc1bccd89", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmYjA4ZjExYjc1MjU5YWQ0ZjIwOGUyNWZhYjZjN2FjYzFiY2NkODk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-15T04:39:11Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-16T18:41:27Z"}, "message": "libgetopts: Remove all uses of `~str` from `libgetopts`", "tree": {"sha": "0f35f3fa43ee68eb2b52535cb481e1211ada8c2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f35f3fa43ee68eb2b52535cb481e1211ada8c2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fb08f11b75259ad4f208e25fab6c7acc1bccd89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fb08f11b75259ad4f208e25fab6c7acc1bccd89", "html_url": "https://github.com/rust-lang/rust/commit/1fb08f11b75259ad4f208e25fab6c7acc1bccd89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fb08f11b75259ad4f208e25fab6c7acc1bccd89/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28bcef85e402a32cf44b740f128e5f9bbd21c0a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/28bcef85e402a32cf44b740f128e5f9bbd21c0a0", "html_url": "https://github.com/rust-lang/rust/commit/28bcef85e402a32cf44b740f128e5f9bbd21c0a0"}], "stats": {"total": 523, "additions": 275, "deletions": 248}, "files": [{"sha": "3fb354a786768250b688f9cad6e6089839766606", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1fb08f11b75259ad4f208e25fab6c7acc1bccd89/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb08f11b75259ad4f208e25fab6c7acc1bccd89/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=1fb08f11b75259ad4f208e25fab6c7acc1bccd89", "patch": "@@ -101,11 +101,7 @@ pub fn parse_config(args: Vec<StrBuf> ) -> Config {\n     }\n \n     let matches =\n-        &match getopts::getopts(args_.iter()\n-                                     .map(|x| x.to_owned())\n-                                     .collect::<Vec<_>>()\n-                                     .as_slice(),\n-                                groups.as_slice()) {\n+        &match getopts::getopts(args_.as_slice(), groups.as_slice()) {\n           Ok(m) => m,\n           Err(f) => fail!(\"{}\", f.to_err_msg())\n         };\n@@ -146,15 +142,18 @@ pub fn parse_config(args: Vec<StrBuf> ) -> Config {\n         build_base: opt_path(matches, \"build-base\"),\n         aux_base: opt_path(matches, \"aux-base\"),\n         stage_id: matches.opt_str(\"stage-id\").unwrap().to_strbuf(),\n-        mode: FromStr::from_str(matches.opt_str(\"mode\").unwrap()).expect(\"invalid mode\"),\n+        mode: FromStr::from_str(matches.opt_str(\"mode\")\n+                                       .unwrap()\n+                                       .as_slice()).expect(\"invalid mode\"),\n         run_ignored: matches.opt_present(\"ignored\"),\n         filter: filter,\n         logfile: matches.opt_str(\"logfile\").map(|s| Path::new(s)),\n         save_metrics: matches.opt_str(\"save-metrics\").map(|s| Path::new(s)),\n         ratchet_metrics:\n             matches.opt_str(\"ratchet-metrics\").map(|s| Path::new(s)),\n         ratchet_noise_percent:\n-            matches.opt_str(\"ratchet-noise-percent\").and_then(|s| from_str::<f64>(s)),\n+            matches.opt_str(\"ratchet-noise-percent\")\n+                   .and_then(|s| from_str::<f64>(s.as_slice())),\n         runtool: matches.opt_str(\"runtool\").map(|x| x.to_strbuf()),\n         host_rustcflags: matches.opt_str(\"host-rustcflags\")\n                                 .map(|x| x.to_strbuf()),"}, {"sha": "ba30e1a2e986bb12e8874627bb44a728acf316f0", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 227, "deletions": 204, "changes": 431, "blob_url": "https://github.com/rust-lang/rust/blob/1fb08f11b75259ad4f208e25fab6c7acc1bccd89/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb08f11b75259ad4f208e25fab6c7acc1bccd89/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=1fb08f11b75259ad4f208e25fab6c7acc1bccd89", "patch": "@@ -34,7 +34,7 @@\n //! use getopts::{optopt,optflag,getopts,OptGroup};\n //! use std::os;\n //!\n-//! fn do_work(inp: &str, out: Option<~str>) {\n+//! fn do_work(inp: &str, out: Option<StrBuf>) {\n //!     println!(\"{}\", inp);\n //!     match out {\n //!         Some(x) => println!(\"{}\", x),\n@@ -49,7 +49,9 @@\n //! }\n //!\n //! fn main() {\n-//!     let args = os::args();\n+//!     let args: Vec<StrBuf> = os::args().iter()\n+//!                                       .map(|x| x.to_strbuf())\n+//!                                       .collect();\n //!\n //!     let program = args.get(0).clone();\n //!\n@@ -62,17 +64,17 @@\n //!         Err(f) => { fail!(f.to_err_msg()) }\n //!     };\n //!     if matches.opt_present(\"h\") {\n-//!         print_usage(program, opts);\n+//!         print_usage(program.as_slice(), opts);\n //!         return;\n //!     }\n //!     let output = matches.opt_str(\"o\");\n-//!     let input: &str = if !matches.free.is_empty() {\n+//!     let input = if !matches.free.is_empty() {\n //!         (*matches.free.get(0)).clone()\n //!     } else {\n-//!         print_usage(program, opts);\n+//!         print_usage(program.as_slice(), opts);\n //!         return;\n //!     };\n-//!     do_work(input, output);\n+//!     do_work(input.as_slice(), output);\n //! }\n //! ~~~\n \n@@ -99,7 +101,7 @@ use std::strbuf::StrBuf;\n pub enum Name {\n     /// A string representing the long name of an option.\n     /// For example: \"help\"\n-    Long(~str),\n+    Long(StrBuf),\n     /// A char representing the short name of an option.\n     /// For example: 'h'\n     Short(char),\n@@ -145,13 +147,13 @@ pub struct Opt {\n #[deriving(Clone, Eq)]\n pub struct OptGroup {\n     /// Short Name of the `OptGroup`\n-    pub short_name: ~str,\n+    pub short_name: StrBuf,\n     /// Long Name of the `OptGroup`\n-    pub long_name: ~str,\n+    pub long_name: StrBuf,\n     /// Hint\n-    pub hint: ~str,\n+    pub hint: StrBuf,\n     /// Description\n-    pub desc: ~str,\n+    pub desc: StrBuf,\n     /// Whether it has an argument\n     pub hasarg: HasArg,\n     /// How often it can occur\n@@ -161,7 +163,7 @@ pub struct OptGroup {\n /// Describes wether an option is given at all or has a value.\n #[deriving(Clone, Eq)]\n enum Optval {\n-    Val(~str),\n+    Val(StrBuf),\n     Given,\n }\n \n@@ -174,7 +176,7 @@ pub struct Matches {\n     /// Values of the Options that matched\n     vals: Vec<Vec<Optval> > ,\n     /// Free string fragments\n-    pub free: Vec<~str>,\n+    pub free: Vec<StrBuf>,\n }\n \n /// The type returned when the command line does not conform to the\n@@ -183,15 +185,15 @@ pub struct Matches {\n #[deriving(Clone, Eq, Show)]\n pub enum Fail_ {\n     /// The option requires an argument but none was passed.\n-    ArgumentMissing(~str),\n+    ArgumentMissing(StrBuf),\n     /// The passed option is not declared among the possible options.\n-    UnrecognizedOption(~str),\n+    UnrecognizedOption(StrBuf),\n     /// A required option is not present.\n-    OptionMissing(~str),\n+    OptionMissing(StrBuf),\n     /// A single occurence option is being used multiple times.\n-    OptionDuplicated(~str),\n+    OptionDuplicated(StrBuf),\n     /// There's an argument being passed to a non-argument option.\n-    UnexpectedArgument(~str),\n+    UnexpectedArgument(StrBuf),\n }\n \n /// The type of failure that occurred.\n@@ -213,14 +215,14 @@ impl Name {\n         if nm.len() == 1u {\n             Short(nm.char_at(0u))\n         } else {\n-            Long(nm.to_owned())\n+            Long(nm.to_strbuf())\n         }\n     }\n \n-    fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> StrBuf {\n         match *self {\n-            Short(ch) => ch.to_str(),\n-            Long(ref s) => s.to_owned()\n+            Short(ch) => ch.to_str().to_strbuf(),\n+            Long(ref s) => s.to_strbuf()\n         }\n     }\n }\n@@ -246,7 +248,7 @@ impl OptGroup {\n                 aliases: Vec::new()\n             },\n             (1,0) => Opt {\n-                name: Short(short_name.char_at(0)),\n+                name: Short(short_name.as_slice().char_at(0)),\n                 hasarg: hasarg,\n                 occur: occur,\n                 aliases: Vec::new()\n@@ -257,7 +259,7 @@ impl OptGroup {\n                 occur:  occur,\n                 aliases: vec!(\n                     Opt {\n-                        name: Short(short_name.char_at(0)),\n+                        name: Short(short_name.as_slice().char_at(0)),\n                         hasarg: hasarg,\n                         occur:  occur,\n                         aliases: Vec::new()\n@@ -297,9 +299,10 @@ impl Matches {\n     }\n \n     /// Returns true if any of several options were matched.\n-    pub fn opts_present(&self, names: &[~str]) -> bool {\n+    pub fn opts_present(&self, names: &[StrBuf]) -> bool {\n         for nm in names.iter() {\n-            match find_opt(self.opts.as_slice(), Name::from_str(*nm)) {\n+            match find_opt(self.opts.as_slice(),\n+                           Name::from_str(nm.as_slice())) {\n                 Some(id) if !self.vals.get(id).is_empty() => return true,\n                 _ => (),\n             };\n@@ -308,9 +311,9 @@ impl Matches {\n     }\n \n     /// Returns the string argument supplied to one of several matching options or `None`.\n-    pub fn opts_str(&self, names: &[~str]) -> Option<~str> {\n+    pub fn opts_str(&self, names: &[StrBuf]) -> Option<StrBuf> {\n         for nm in names.iter() {\n-            match self.opt_val(*nm) {\n+            match self.opt_val(nm.as_slice()) {\n                 Some(Val(ref s)) => return Some(s.clone()),\n                 _ => ()\n             }\n@@ -322,8 +325,8 @@ impl Matches {\n     /// option.\n     ///\n     /// Used when an option accepts multiple values.\n-    pub fn opt_strs(&self, nm: &str) -> Vec<~str> {\n-        let mut acc: Vec<~str> = Vec::new();\n+    pub fn opt_strs(&self, nm: &str) -> Vec<StrBuf> {\n+        let mut acc: Vec<StrBuf> = Vec::new();\n         let r = self.opt_vals(nm);\n         for v in r.iter() {\n             match *v {\n@@ -335,10 +338,10 @@ impl Matches {\n     }\n \n     /// Returns the string argument supplied to a matching option or `None`.\n-    pub fn opt_str(&self, nm: &str) -> Option<~str> {\n+    pub fn opt_str(&self, nm: &str) -> Option<StrBuf> {\n         let vals = self.opt_vals(nm);\n         if vals.is_empty() {\n-            return None::<~str>;\n+            return None::<StrBuf>;\n         }\n         match vals.get(0) {\n             &Val(ref s) => Some((*s).clone()),\n@@ -352,12 +355,14 @@ impl Matches {\n     /// Returns none if the option was not present, `def` if the option was\n     /// present but no argument was provided, and the argument if the option was\n     /// present and an argument was provided.\n-    pub fn opt_default(&self, nm: &str, def: &str) -> Option<~str> {\n+    pub fn opt_default(&self, nm: &str, def: &str) -> Option<StrBuf> {\n         let vals = self.opt_vals(nm);\n-        if vals.is_empty() { return None; }\n+        if vals.is_empty() {\n+            return None;\n+        }\n         match vals.get(0) {\n             &Val(ref s) => Some((*s).clone()),\n-            _ => Some(def.to_owned())\n+            _ => Some(def.to_strbuf())\n         }\n     }\n \n@@ -389,10 +394,10 @@ pub fn reqopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptG\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n+        short_name: short_name.to_strbuf(),\n+        long_name: long_name.to_strbuf(),\n+        hint: hint.to_strbuf(),\n+        desc: desc.to_strbuf(),\n         hasarg: Yes,\n         occur: Req\n     }\n@@ -403,10 +408,10 @@ pub fn optopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptG\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n+        short_name: short_name.to_strbuf(),\n+        long_name: long_name.to_strbuf(),\n+        hint: hint.to_strbuf(),\n+        desc: desc.to_strbuf(),\n         hasarg: Yes,\n         occur: Optional\n     }\n@@ -417,10 +422,10 @@ pub fn optflag(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: \"\".to_owned(),\n-        desc: desc.to_owned(),\n+        short_name: short_name.to_strbuf(),\n+        long_name: long_name.to_strbuf(),\n+        hint: \"\".to_strbuf(),\n+        desc: desc.to_strbuf(),\n         hasarg: No,\n         occur: Optional\n     }\n@@ -432,10 +437,10 @@ pub fn optflagmulti(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: \"\".to_owned(),\n-        desc: desc.to_owned(),\n+        short_name: short_name.to_strbuf(),\n+        long_name: long_name.to_strbuf(),\n+        hint: \"\".to_strbuf(),\n+        desc: desc.to_strbuf(),\n         hasarg: No,\n         occur: Multi\n     }\n@@ -446,10 +451,10 @@ pub fn optflagopt(short_name: &str, long_name: &str, desc: &str, hint: &str) ->\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n+        short_name: short_name.to_strbuf(),\n+        long_name: long_name.to_strbuf(),\n+        hint: hint.to_strbuf(),\n+        desc: desc.to_strbuf(),\n         hasarg: Maybe,\n         occur: Optional\n     }\n@@ -461,10 +466,10 @@ pub fn optmulti(short_name: &str, long_name: &str, desc: &str, hint: &str) -> Op\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n+        short_name: short_name.to_strbuf(),\n+        long_name: long_name.to_strbuf(),\n+        hint: hint.to_strbuf(),\n+        desc: desc.to_strbuf(),\n         hasarg: Yes,\n         occur: Multi\n     }\n@@ -480,33 +485,33 @@ pub fn opt(short_name: &str,\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n+        short_name: short_name.to_strbuf(),\n+        long_name: long_name.to_strbuf(),\n+        hint: hint.to_strbuf(),\n+        desc: desc.to_strbuf(),\n         hasarg: hasarg,\n         occur: occur\n     }\n }\n \n impl Fail_ {\n     /// Convert a `Fail_` enum into an error string.\n-    pub fn to_err_msg(self) -> ~str {\n+    pub fn to_err_msg(self) -> StrBuf {\n         match self {\n             ArgumentMissing(ref nm) => {\n-                format!(\"Argument to option '{}' missing.\", *nm)\n+                format_strbuf!(\"Argument to option '{}' missing.\", *nm)\n             }\n             UnrecognizedOption(ref nm) => {\n-                format!(\"Unrecognized option: '{}'.\", *nm)\n+                format_strbuf!(\"Unrecognized option: '{}'.\", *nm)\n             }\n             OptionMissing(ref nm) => {\n-                format!(\"Required option '{}' missing.\", *nm)\n+                format_strbuf!(\"Required option '{}' missing.\", *nm)\n             }\n             OptionDuplicated(ref nm) => {\n-                format!(\"Option '{}' given more than once.\", *nm)\n+                format_strbuf!(\"Option '{}' given more than once.\", *nm)\n             }\n             UnexpectedArgument(ref nm) => {\n-                format!(\"Option '{}' does not take an argument.\", *nm)\n+                format_strbuf!(\"Option '{}' does not take an argument.\", *nm)\n             }\n         }\n     }\n@@ -517,44 +522,44 @@ impl Fail_ {\n /// On success returns `Ok(Opt)`. Use methods such as `opt_present`\n /// `opt_str`, etc. to interrogate results.  Returns `Err(Fail_)` on failure.\n /// Use `to_err_msg` to get an error message.\n-pub fn getopts(args: &[~str], optgrps: &[OptGroup]) -> Result {\n+pub fn getopts(args: &[StrBuf], optgrps: &[OptGroup]) -> Result {\n     let opts: Vec<Opt> = optgrps.iter().map(|x| x.long_to_short()).collect();\n     let n_opts = opts.len();\n \n     fn f(_x: uint) -> Vec<Optval> { return Vec::new(); }\n \n     let mut vals = Vec::from_fn(n_opts, f);\n-    let mut free: Vec<~str> = Vec::new();\n+    let mut free: Vec<StrBuf> = Vec::new();\n     let l = args.len();\n     let mut i = 0;\n     while i < l {\n         let cur = args[i].clone();\n         let curlen = cur.len();\n-        if !is_arg(cur) {\n+        if !is_arg(cur.as_slice()) {\n             free.push(cur);\n-        } else if cur == \"--\".to_owned() {\n+        } else if cur.as_slice() == \"--\" {\n             let mut j = i + 1;\n             while j < l { free.push(args[j].clone()); j += 1; }\n             break;\n         } else {\n             let mut names;\n             let mut i_arg = None;\n-            if cur[1] == '-' as u8 {\n-                let tail = cur.slice(2, curlen);\n+            if cur.as_slice()[1] == '-' as u8 {\n+                let tail = cur.as_slice().slice(2, curlen);\n                 let tail_eq: Vec<&str> = tail.split('=').collect();\n                 if tail_eq.len() <= 1 {\n-                    names = vec!(Long(tail.to_owned()));\n+                    names = vec!(Long(tail.to_strbuf()));\n                 } else {\n                     names =\n-                        vec!(Long((*tail_eq.get(0)).to_owned()));\n-                    i_arg = Some((*tail_eq.get(1)).to_owned());\n+                        vec!(Long((*tail_eq.get(0)).to_strbuf()));\n+                    i_arg = Some((*tail_eq.get(1)).to_strbuf());\n                 }\n             } else {\n                 let mut j = 1;\n                 let mut last_valid_opt_id = None;\n                 names = Vec::new();\n                 while j < curlen {\n-                    let range = cur.char_range_at(j);\n+                    let range = cur.as_slice().char_range_at(j);\n                     let opt = Short(range.ch);\n \n                     /* In a series of potential options (eg. -aheJ), if we\n@@ -576,7 +581,8 @@ pub fn getopts(args: &[~str], optgrps: &[OptGroup]) -> Result {\n                               No => false\n                             };\n                         if arg_follows && j < curlen {\n-                            i_arg = Some(cur.slice(j, curlen).to_owned());\n+                            i_arg = Some(cur.as_slice()\n+                                            .slice(j, curlen).to_strbuf());\n                             break;\n                         } else {\n                             last_valid_opt_id = None;\n@@ -606,8 +612,8 @@ pub fn getopts(args: &[~str], optgrps: &[OptGroup]) -> Result {\n                         vals.get_mut(optid)\n                             .push(Val((i_arg.clone())\n                             .unwrap()));\n-                    } else if name_pos < names.len() ||\n-                                  i + 1 == l || is_arg(args[i + 1]) {\n+                    } else if name_pos < names.len() || i + 1 == l ||\n+                            is_arg(args[i + 1].as_slice()) {\n                         vals.get_mut(optid).push(Given);\n                     } else {\n                         i += 1;\n@@ -653,7 +659,7 @@ pub fn getopts(args: &[~str], optgrps: &[OptGroup]) -> Result {\n }\n \n /// Derive a usage message from a set of long options.\n-pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n+pub fn usage(brief: &str, opts: &[OptGroup]) -> StrBuf {\n \n     let desc_sep = \"\\n\" + \" \".repeat(24);\n \n@@ -672,7 +678,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n             0 => {}\n             1 => {\n                 row.push_char('-');\n-                row.push_str(short_name);\n+                row.push_str(short_name.as_slice());\n                 row.push_char(' ');\n             }\n             _ => fail!(\"the short name should only be 1 ascii char long\"),\n@@ -683,18 +689,18 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n             0 => {}\n             _ => {\n                 row.push_str(\"--\");\n-                row.push_str(long_name);\n+                row.push_str(long_name.as_slice());\n                 row.push_char(' ');\n             }\n         }\n \n         // arg\n         match hasarg {\n             No => {}\n-            Yes => row.push_str(hint),\n+            Yes => row.push_str(hint.as_slice()),\n             Maybe => {\n                 row.push_char('[');\n-                row.push_str(hint);\n+                row.push_str(hint.as_slice());\n                 row.push_char(']');\n             }\n         }\n@@ -712,7 +718,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n \n         // Normalize desc to contain words separated by one space character\n         let mut desc_normalized_whitespace = StrBuf::new();\n-        for word in desc.words() {\n+        for word in desc.as_slice().words() {\n             desc_normalized_whitespace.push_str(word);\n             desc_normalized_whitespace.push_char(' ');\n         }\n@@ -730,13 +736,15 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n         // wrapped description\n         row.push_str(desc_rows.connect(desc_sep));\n \n-        row.into_owned()\n+        row\n     });\n \n-    format!(\"{}\\n\\nOptions:\\n{}\\n\", brief, rows.collect::<Vec<~str> >().connect(\"\\n\"))\n+    format_strbuf!(\"{}\\n\\nOptions:\\n{}\\n\",\n+                   brief,\n+                   rows.collect::<Vec<StrBuf>>().connect(\"\\n\"))\n }\n \n-fn format_option(opt: &OptGroup) -> ~str {\n+fn format_option(opt: &OptGroup) -> StrBuf {\n     let mut line = StrBuf::new();\n \n     if opt.occur != Req {\n@@ -746,18 +754,18 @@ fn format_option(opt: &OptGroup) -> ~str {\n     // Use short_name is possible, but fallback to long_name.\n     if opt.short_name.len() > 0 {\n         line.push_char('-');\n-        line.push_str(opt.short_name);\n+        line.push_str(opt.short_name.as_slice());\n     } else {\n         line.push_str(\"--\");\n-        line.push_str(opt.long_name);\n+        line.push_str(opt.long_name.as_slice());\n     }\n \n     if opt.hasarg != No {\n         line.push_char(' ');\n         if opt.hasarg == Maybe {\n             line.push_char('[');\n         }\n-        line.push_str(opt.hint);\n+        line.push_str(opt.hint.as_slice());\n         if opt.hasarg == Maybe {\n             line.push_char(']');\n         }\n@@ -770,14 +778,14 @@ fn format_option(opt: &OptGroup) -> ~str {\n         line.push_str(\"..\");\n     }\n \n-    line.into_owned()\n+    line\n }\n \n /// Derive a short one-line usage summary from a set of long options.\n-pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> ~str {\n-    let mut line = StrBuf::from_str(\"Usage: \" + program_name + \" \");\n-    line.push_str(opts.iter().map(format_option).collect::<Vec<~str>>().connect(\" \"));\n-    line.into_owned()\n+pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> StrBuf {\n+    let mut line = format_strbuf!(\"Usage: {} \", program_name);\n+    line.push_str(opts.iter().map(format_option).collect::<Vec<StrBuf>>().connect(\" \"));\n+    line\n }\n \n \n@@ -886,18 +894,21 @@ fn each_split_within<'a>(ss: &'a str, lim: uint, it: |&'a str| -> bool)\n \n #[test]\n fn test_split_within() {\n-    fn t(s: &str, i: uint, u: &[~str]) {\n+    fn t(s: &str, i: uint, u: &[StrBuf]) {\n         let mut v = Vec::new();\n-        each_split_within(s, i, |s| { v.push(s.to_owned()); true });\n+        each_split_within(s, i, |s| { v.push(s.to_strbuf()); true });\n         assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n     }\n     t(\"\", 0, []);\n     t(\"\", 15, []);\n-    t(\"hello\", 15, [\"hello\".to_owned()]);\n-    t(\"\\nMary had a little lamb\\nLittle lamb\\n\", 15,\n-        [\"Mary had a\".to_owned(), \"little lamb\".to_owned(), \"Little lamb\".to_owned()]);\n+    t(\"hello\", 15, [\"hello\".to_strbuf()]);\n+    t(\"\\nMary had a little lamb\\nLittle lamb\\n\", 15, [\n+        \"Mary had a\".to_strbuf(),\n+        \"little lamb\".to_strbuf(),\n+        \"Little lamb\".to_strbuf()\n+    ]);\n     t(\"\\nMary had a little lamb\\nLittle lamb\\n\", ::std::uint::MAX,\n-        [\"Mary had a little lamb\\nLittle lamb\".to_owned()]);\n+        [\"Mary had a little lamb\\nLittle lamb\".to_strbuf()]);\n }\n \n #[cfg(test)]\n@@ -920,33 +931,33 @@ mod tests {\n     // Tests for reqopt\n     #[test]\n     fn test_reqopt() {\n-        let long_args = vec!(\"--test=20\".to_owned());\n+        let long_args = vec!(\"--test=20\".to_strbuf());\n         let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_strbuf());\n             assert!(m.opt_present(\"t\"));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_strbuf());\n           }\n           _ => { fail!(\"test_reqopt failed (long arg)\"); }\n         }\n-        let short_args = vec!(\"-t\".to_owned(), \"20\".to_owned());\n+        let short_args = vec!(\"-t\".to_strbuf(), \"20\".to_strbuf());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_strbuf());\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_strbuf());\n           }\n           _ => { fail!(\"test_reqopt failed (short arg)\"); }\n         }\n     }\n \n     #[test]\n     fn test_reqopt_missing() {\n-        let args = vec!(\"blah\".to_owned());\n+        let args = vec!(\"blah\".to_strbuf());\n         let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -957,14 +968,14 @@ mod tests {\n \n     #[test]\n     fn test_reqopt_no_arg() {\n-        let long_args = vec!(\"--test\".to_owned());\n+        let long_args = vec!(\"--test\".to_strbuf());\n         let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n-        let short_args = vec!(\"-t\".to_owned());\n+        let short_args = vec!(\"-t\".to_strbuf());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n@@ -973,7 +984,7 @@ mod tests {\n \n     #[test]\n     fn test_reqopt_multi() {\n-        let args = vec!(\"--test=20\".to_owned(), \"-t\".to_owned(), \"30\".to_owned());\n+        let args = vec!(\"--test=20\".to_strbuf(), \"-t\".to_strbuf(), \"30\".to_strbuf());\n         let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -985,33 +996,33 @@ mod tests {\n     // Tests for optopt\n     #[test]\n     fn test_optopt() {\n-        let long_args = vec!(\"--test=20\".to_owned());\n+        let long_args = vec!(\"--test=20\".to_strbuf());\n         let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_strbuf());\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_strbuf());\n           }\n           _ => fail!()\n         }\n-        let short_args = vec!(\"-t\".to_owned(), \"20\".to_owned());\n+        let short_args = vec!(\"-t\".to_strbuf(), \"20\".to_strbuf());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_strbuf());\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_strbuf());\n           }\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optopt_missing() {\n-        let args = vec!(\"blah\".to_owned());\n+        let args = vec!(\"blah\".to_strbuf());\n         let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1025,14 +1036,14 @@ mod tests {\n \n     #[test]\n     fn test_optopt_no_arg() {\n-        let long_args = vec!(\"--test\".to_owned());\n+        let long_args = vec!(\"--test\".to_strbuf());\n         let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n-        let short_args = vec!(\"-t\".to_owned());\n+        let short_args = vec!(\"-t\".to_strbuf());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n@@ -1041,7 +1052,7 @@ mod tests {\n \n     #[test]\n     fn test_optopt_multi() {\n-        let args = vec!(\"--test=20\".to_owned(), \"-t\".to_owned(), \"30\".to_owned());\n+        let args = vec!(\"--test=20\".to_strbuf(), \"-t\".to_strbuf(), \"30\".to_strbuf());\n         let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1053,7 +1064,7 @@ mod tests {\n     // Tests for optflag\n     #[test]\n     fn test_optflag() {\n-        let long_args = vec!(\"--test\".to_owned());\n+        let long_args = vec!(\"--test\".to_strbuf());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1063,7 +1074,7 @@ mod tests {\n           }\n           _ => fail!()\n         }\n-        let short_args = vec!(\"-t\".to_owned());\n+        let short_args = vec!(\"-t\".to_strbuf());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n@@ -1075,7 +1086,7 @@ mod tests {\n \n     #[test]\n     fn test_optflag_missing() {\n-        let args = vec!(\"blah\".to_owned());\n+        let args = vec!(\"blah\".to_strbuf());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1089,7 +1100,7 @@ mod tests {\n \n     #[test]\n     fn test_optflag_long_arg() {\n-        let args = vec!(\"--test=20\".to_owned());\n+        let args = vec!(\"--test=20\".to_strbuf());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1103,7 +1114,7 @@ mod tests {\n \n     #[test]\n     fn test_optflag_multi() {\n-        let args = vec!(\"--test\".to_owned(), \"-t\".to_owned());\n+        let args = vec!(\"--test\".to_strbuf(), \"-t\".to_strbuf());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1114,14 +1125,14 @@ mod tests {\n \n     #[test]\n     fn test_optflag_short_arg() {\n-        let args = vec!(\"-t\".to_owned(), \"20\".to_owned());\n+        let args = vec!(\"-t\".to_strbuf(), \"20\".to_strbuf());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             // The next variable after the flag is just a free argument\n \n-            assert!(*m.free.get(0) == \"20\".to_owned());\n+            assert!(*m.free.get(0) == \"20\".to_strbuf());\n           }\n           _ => fail!()\n         }\n@@ -1130,7 +1141,7 @@ mod tests {\n     // Tests for optflagmulti\n     #[test]\n     fn test_optflagmulti_short1() {\n-        let args = vec!(\"-v\".to_owned());\n+        let args = vec!(\"-v\".to_strbuf());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1143,7 +1154,7 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_short2a() {\n-        let args = vec!(\"-v\".to_owned(), \"-v\".to_owned());\n+        let args = vec!(\"-v\".to_strbuf(), \"-v\".to_strbuf());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1156,7 +1167,7 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_short2b() {\n-        let args = vec!(\"-vv\".to_owned());\n+        let args = vec!(\"-vv\".to_strbuf());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1169,7 +1180,7 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_long1() {\n-        let args = vec!(\"--verbose\".to_owned());\n+        let args = vec!(\"--verbose\".to_strbuf());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1182,7 +1193,7 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_long2() {\n-        let args = vec!(\"--verbose\".to_owned(), \"--verbose\".to_owned());\n+        let args = vec!(\"--verbose\".to_strbuf(), \"--verbose\".to_strbuf());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1195,8 +1206,8 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_mix() {\n-        let args = vec!(\"--verbose\".to_owned(), \"-v\".to_owned(),\n-                        \"-vv\".to_owned(), \"verbose\".to_owned());\n+        let args = vec!(\"--verbose\".to_strbuf(), \"-v\".to_strbuf(),\n+                        \"-vv\".to_strbuf(), \"verbose\".to_strbuf());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1211,33 +1222,33 @@ mod tests {\n     // Tests for optmulti\n     #[test]\n     fn test_optmulti() {\n-        let long_args = vec!(\"--test=20\".to_owned());\n+        let long_args = vec!(\"--test=20\".to_strbuf());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_strbuf());\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_strbuf());\n           }\n           _ => fail!()\n         }\n-        let short_args = vec!(\"-t\".to_owned(), \"20\".to_owned());\n+        let short_args = vec!(\"-t\".to_strbuf(), \"20\".to_strbuf());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_strbuf());\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_strbuf());\n           }\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optmulti_missing() {\n-        let args = vec!(\"blah\".to_owned());\n+        let args = vec!(\"blah\".to_strbuf());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1251,14 +1262,14 @@ mod tests {\n \n     #[test]\n     fn test_optmulti_no_arg() {\n-        let long_args = vec!(\"--test\".to_owned());\n+        let long_args = vec!(\"--test\".to_strbuf());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n-        let short_args = vec!(\"-t\".to_owned());\n+        let short_args = vec!(\"-t\".to_strbuf());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n@@ -1267,33 +1278,33 @@ mod tests {\n \n     #[test]\n     fn test_optmulti_multi() {\n-        let args = vec!(\"--test=20\".to_owned(), \"-t\".to_owned(), \"30\".to_owned());\n+        let args = vec!(\"--test=20\".to_strbuf(), \"-t\".to_strbuf(), \"30\".to_strbuf());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n               assert!(m.opt_present(\"test\"));\n-              assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_owned());\n+              assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_strbuf());\n               assert!(m.opt_present(\"t\"));\n-              assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_owned());\n+              assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_strbuf());\n               let pair = m.opt_strs(\"test\");\n-              assert!(*pair.get(0) == \"20\".to_owned());\n-              assert!(*pair.get(1) == \"30\".to_owned());\n+              assert!(*pair.get(0) == \"20\".to_strbuf());\n+              assert!(*pair.get(1) == \"30\".to_strbuf());\n           }\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_unrecognized_option() {\n-        let long_args = vec!(\"--untest\".to_owned());\n+        let long_args = vec!(\"--untest\".to_strbuf());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, UnrecognizedOption_),\n           _ => fail!()\n         }\n-        let short_args = vec!(\"-u\".to_owned());\n+        let short_args = vec!(\"-u\".to_strbuf());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, UnrecognizedOption_),\n           _ => fail!()\n@@ -1303,10 +1314,22 @@ mod tests {\n     #[test]\n     fn test_combined() {\n         let args =\n-            vec!(\"prog\".to_owned(), \"free1\".to_owned(), \"-s\".to_owned(), \"20\".to_owned(),\n-            \"free2\".to_owned(), \"--flag\".to_owned(), \"--long=30\".to_owned(), \"-f\".to_owned(),\n-            \"-m\".to_owned(), \"40\".to_owned(), \"-m\".to_owned(), \"50\".to_owned(), \"-n\".to_owned(),\n-            \"-A B\".to_owned(), \"-n\".to_owned(), \"-60 70\".to_owned());\n+            vec!(\"prog\".to_strbuf(),\n+                 \"free1\".to_strbuf(),\n+                 \"-s\".to_strbuf(),\n+                 \"20\".to_strbuf(),\n+                 \"free2\".to_strbuf(),\n+                 \"--flag\".to_strbuf(),\n+                 \"--long=30\".to_strbuf(),\n+                 \"-f\".to_strbuf(),\n+                 \"-m\".to_strbuf(),\n+                 \"40\".to_strbuf(),\n+                 \"-m\".to_strbuf(),\n+                 \"50\".to_strbuf(),\n+                 \"-n\".to_strbuf(),\n+                 \"-A B\".to_strbuf(),\n+                 \"-n\".to_strbuf(),\n+                 \"-60 70\".to_strbuf());\n         let opts =\n             vec!(optopt(\"s\", \"something\", \"something\", \"SOMETHING\"),\n               optflag(\"\", \"flag\", \"a flag\"),\n@@ -1318,19 +1341,19 @@ mod tests {\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n-            assert!(*m.free.get(0) == \"prog\".to_owned());\n-            assert!(*m.free.get(1) == \"free1\".to_owned());\n-            assert_eq!(m.opt_str(\"s\").unwrap(), \"20\".to_owned());\n-            assert!(*m.free.get(2) == \"free2\".to_owned());\n+            assert!(*m.free.get(0) == \"prog\".to_strbuf());\n+            assert!(*m.free.get(1) == \"free1\".to_strbuf());\n+            assert_eq!(m.opt_str(\"s\").unwrap(), \"20\".to_strbuf());\n+            assert!(*m.free.get(2) == \"free2\".to_strbuf());\n             assert!((m.opt_present(\"flag\")));\n-            assert_eq!(m.opt_str(\"long\").unwrap(), \"30\".to_owned());\n+            assert_eq!(m.opt_str(\"long\").unwrap(), \"30\".to_strbuf());\n             assert!((m.opt_present(\"f\")));\n             let pair = m.opt_strs(\"m\");\n-            assert!(*pair.get(0) == \"40\".to_owned());\n-            assert!(*pair.get(1) == \"50\".to_owned());\n+            assert!(*pair.get(0) == \"40\".to_strbuf());\n+            assert!(*pair.get(1) == \"50\".to_strbuf());\n             let pair = m.opt_strs(\"n\");\n-            assert!(*pair.get(0) == \"-A B\".to_owned());\n-            assert!(*pair.get(1) == \"-60 70\".to_owned());\n+            assert!(*pair.get(0) == \"-A B\".to_strbuf());\n+            assert!(*pair.get(1) == \"-60 70\".to_strbuf());\n             assert!((!m.opt_present(\"notpresent\")));\n           }\n           _ => fail!()\n@@ -1343,68 +1366,68 @@ mod tests {\n                      optopt(\"\", \"encrypt\", \"encrypt\", \"ENCRYPT\"),\n                      optopt(\"f\", \"\", \"flag\", \"FLAG\"));\n \n-        let args_single = vec!(\"-e\".to_owned(), \"foo\".to_owned());\n+        let args_single = vec!(\"-e\".to_strbuf(), \"foo\".to_strbuf());\n         let matches_single = &match getopts(args_single.as_slice(),\n                                             opts.as_slice()) {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert!(matches_single.opts_present([\"e\".to_owned()]));\n-        assert!(matches_single.opts_present([\"encrypt\".to_owned(), \"e\".to_owned()]));\n-        assert!(matches_single.opts_present([\"e\".to_owned(), \"encrypt\".to_owned()]));\n-        assert!(!matches_single.opts_present([\"encrypt\".to_owned()]));\n-        assert!(!matches_single.opts_present([\"thing\".to_owned()]));\n+        assert!(matches_single.opts_present([\"e\".to_strbuf()]));\n+        assert!(matches_single.opts_present([\"encrypt\".to_strbuf(), \"e\".to_strbuf()]));\n+        assert!(matches_single.opts_present([\"e\".to_strbuf(), \"encrypt\".to_strbuf()]));\n+        assert!(!matches_single.opts_present([\"encrypt\".to_strbuf()]));\n+        assert!(!matches_single.opts_present([\"thing\".to_strbuf()]));\n         assert!(!matches_single.opts_present([]));\n \n-        assert_eq!(matches_single.opts_str([\"e\".to_owned()]).unwrap(), \"foo\".to_owned());\n-        assert_eq!(matches_single.opts_str([\"e\".to_owned(), \"encrypt\".to_owned()]).unwrap(),\n-                   \"foo\".to_owned());\n-        assert_eq!(matches_single.opts_str([\"encrypt\".to_owned(), \"e\".to_owned()]).unwrap(),\n-                   \"foo\".to_owned());\n+        assert_eq!(matches_single.opts_str([\"e\".to_strbuf()]).unwrap(), \"foo\".to_strbuf());\n+        assert_eq!(matches_single.opts_str([\"e\".to_strbuf(), \"encrypt\".to_strbuf()]).unwrap(),\n+                   \"foo\".to_strbuf());\n+        assert_eq!(matches_single.opts_str([\"encrypt\".to_strbuf(), \"e\".to_strbuf()]).unwrap(),\n+                   \"foo\".to_strbuf());\n \n-        let args_both = vec!(\"-e\".to_owned(), \"foo\".to_owned(), \"--encrypt\".to_owned(),\n-                             \"foo\".to_owned());\n+        let args_both = vec!(\"-e\".to_strbuf(), \"foo\".to_strbuf(), \"--encrypt\".to_strbuf(),\n+                             \"foo\".to_strbuf());\n         let matches_both = &match getopts(args_both.as_slice(),\n                                           opts.as_slice()) {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert!(matches_both.opts_present([\"e\".to_owned()]));\n-        assert!(matches_both.opts_present([\"encrypt\".to_owned()]));\n-        assert!(matches_both.opts_present([\"encrypt\".to_owned(), \"e\".to_owned()]));\n-        assert!(matches_both.opts_present([\"e\".to_owned(), \"encrypt\".to_owned()]));\n-        assert!(!matches_both.opts_present([\"f\".to_owned()]));\n-        assert!(!matches_both.opts_present([\"thing\".to_owned()]));\n+        assert!(matches_both.opts_present([\"e\".to_strbuf()]));\n+        assert!(matches_both.opts_present([\"encrypt\".to_strbuf()]));\n+        assert!(matches_both.opts_present([\"encrypt\".to_strbuf(), \"e\".to_strbuf()]));\n+        assert!(matches_both.opts_present([\"e\".to_strbuf(), \"encrypt\".to_strbuf()]));\n+        assert!(!matches_both.opts_present([\"f\".to_strbuf()]));\n+        assert!(!matches_both.opts_present([\"thing\".to_strbuf()]));\n         assert!(!matches_both.opts_present([]));\n \n-        assert_eq!(matches_both.opts_str([\"e\".to_owned()]).unwrap(), \"foo\".to_owned());\n-        assert_eq!(matches_both.opts_str([\"encrypt\".to_owned()]).unwrap(), \"foo\".to_owned());\n-        assert_eq!(matches_both.opts_str([\"e\".to_owned(), \"encrypt\".to_owned()]).unwrap(),\n-                   \"foo\".to_owned());\n-        assert_eq!(matches_both.opts_str([\"encrypt\".to_owned(), \"e\".to_owned()]).unwrap(),\n-                   \"foo\".to_owned());\n+        assert_eq!(matches_both.opts_str([\"e\".to_strbuf()]).unwrap(), \"foo\".to_strbuf());\n+        assert_eq!(matches_both.opts_str([\"encrypt\".to_strbuf()]).unwrap(), \"foo\".to_strbuf());\n+        assert_eq!(matches_both.opts_str([\"e\".to_strbuf(), \"encrypt\".to_strbuf()]).unwrap(),\n+                   \"foo\".to_strbuf());\n+        assert_eq!(matches_both.opts_str([\"encrypt\".to_strbuf(), \"e\".to_strbuf()]).unwrap(),\n+                   \"foo\".to_strbuf());\n     }\n \n     #[test]\n     fn test_nospace() {\n-        let args = vec!(\"-Lfoo\".to_owned(), \"-M.\".to_owned());\n+        let args = vec!(\"-Lfoo\".to_strbuf(), \"-M.\".to_strbuf());\n         let opts = vec!(optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n                      optmulti(\"M\", \"\", \"something\", \"MMMM\"));\n         let matches = &match getopts(args.as_slice(), opts.as_slice()) {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert!(matches.opts_present([\"L\".to_owned()]));\n-        assert_eq!(matches.opts_str([\"L\".to_owned()]).unwrap(), \"foo\".to_owned());\n-        assert!(matches.opts_present([\"M\".to_owned()]));\n-        assert_eq!(matches.opts_str([\"M\".to_owned()]).unwrap(), \".\".to_owned());\n+        assert!(matches.opts_present([\"L\".to_strbuf()]));\n+        assert_eq!(matches.opts_str([\"L\".to_strbuf()]).unwrap(), \"foo\".to_strbuf());\n+        assert!(matches.opts_present([\"M\".to_strbuf()]));\n+        assert_eq!(matches.opts_str([\"M\".to_strbuf()]).unwrap(), \".\".to_strbuf());\n \n     }\n \n     #[test]\n     fn test_long_to_short() {\n         let mut short = Opt {\n-            name: Long(\"banana\".to_owned()),\n+            name: Long(\"banana\".to_strbuf()),\n             hasarg: Yes,\n             occur: Req,\n             aliases: Vec::new(),\n@@ -1423,7 +1446,7 @@ mod tests {\n         let opts = vec!(\n             optflagmulti(\"a\", \"apple\", \"Desc\"));\n \n-        let args = vec!(\"-a\".to_owned(), \"--apple\".to_owned(), \"-a\".to_owned());\n+        let args = vec!(\"-a\".to_strbuf(), \"--apple\".to_strbuf(), \"-a\".to_strbuf());\n \n         let matches = getopts(args.as_slice(), opts.as_slice()).unwrap();\n         assert_eq!(3, matches.opt_count(\"a\"));\n@@ -1450,7 +1473,7 @@ Options:\n     -k --kiwi           Desc\n     -p [VAL]            Desc\n     -l VAL              Desc\n-\".to_owned();\n+\".to_strbuf();\n \n         let generated_usage = usage(\"Usage: fruits\", optgroups.as_slice());\n \n@@ -1477,7 +1500,7 @@ Options:\n     -k --kiwi           This is a long description which won't be wrapped..+..\n     -a --apple          This is a long description which _will_ be\n                         wrapped..+..\n-\".to_owned();\n+\".to_strbuf();\n \n         let usage = usage(\"Usage: fruits\", optgroups.as_slice());\n \n@@ -1503,7 +1526,7 @@ Options:\n     -a --apple          This \u201cdescription\u201d has some characters that could\n                         confuse the line wrapping; an apple costs 0.51\u20ac in\n                         some parts of Europe.\n-\".to_owned();\n+\".to_strbuf();\n \n         let usage = usage(\"Usage: fruits\", optgroups.as_slice());\n \n@@ -1522,7 +1545,7 @@ Options:\n             optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n             optmulti(\"l\", \"\", \"Desc\", \"VAL\"));\n \n-        let expected = \"Usage: fruits -b VAL [-a VAL] [-k] [-p [VAL]] [-l VAL]..\".to_owned();\n+        let expected = \"Usage: fruits -b VAL [-a VAL] [-k] [-p [VAL]] [-l VAL]..\".to_strbuf();\n         let generated_usage = short_usage(\"fruits\", optgroups.as_slice());\n \n         debug!(\"expected: <<{}>>\", expected);"}, {"sha": "02f937af90d2d3a55a6667cf8fee6aabf99b78ca", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1fb08f11b75259ad4f208e25fab6c7acc1bccd89/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb08f11b75259ad4f208e25fab6c7acc1bccd89/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=1fb08f11b75259ad4f208e25fab6c7acc1bccd89", "patch": "@@ -319,7 +319,7 @@ pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n {\n     let mut cg = basic_codegen_options();\n     for option in matches.opt_strs(\"C\").move_iter() {\n-        let mut iter = option.splitn('=', 1);\n+        let mut iter = option.as_slice().splitn('=', 1);\n         let key = iter.next().unwrap();\n         let value = iter.next();\n         let option_to_lookup = key.replace(\"-\", \"_\");\n@@ -563,7 +563,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let mut crate_types: Vec<CrateType> = Vec::new();\n     let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n     for unparsed_crate_type in unparsed_crate_types.iter() {\n-        for part in unparsed_crate_type.split(',') {\n+        for part in unparsed_crate_type.as_slice().split(',') {\n             let new_part = match part {\n                 \"lib\"       => default_lib_output(),\n                 \"rlib\"      => CrateTypeRlib,\n@@ -612,7 +612,10 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         let mut this_bit = 0;\n         for tuple in debug_map.iter() {\n             let (name, bit) = match *tuple { (ref a, _, b) => (a, b) };\n-            if *name == *debug_flag { this_bit = bit; break; }\n+            if *name == debug_flag.as_slice() {\n+                this_bit = bit;\n+                break;\n+            }\n         }\n         if this_bit == 0 {\n             early_error(format!(\"unknown debug flag: {}\", *debug_flag))\n@@ -628,7 +631,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     if !parse_only && !no_trans {\n         let unparsed_output_types = matches.opt_strs(\"emit\");\n         for unparsed_output_type in unparsed_output_types.iter() {\n-            for part in unparsed_output_type.split(',') {\n+            for part in unparsed_output_type.as_slice().split(',') {\n                 let output_type = match part.as_slice() {\n                     \"asm\"  => link::OutputTypeAssembly,\n                     \"ir\"   => link::OutputTypeLlvmAssembly,\n@@ -765,7 +768,7 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test() {\n         let matches =\n-            &match getopts([\"--test\".to_owned()], optgroups().as_slice()) {\n+            &match getopts([\"--test\".to_strbuf()], optgroups().as_slice()) {\n               Ok(m) => m,\n               Err(f) => fail!(\"test_switch_implies_cfg_test: {}\", f.to_err_msg())\n             };\n@@ -780,7 +783,7 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n-            &match getopts([\"--test\".to_owned(), \"--cfg=test\".to_owned()],\n+            &match getopts([\"--test\".to_strbuf(), \"--cfg=test\".to_strbuf()],\n                            optgroups().as_slice()) {\n               Ok(m) => m,\n               Err(f) => {"}, {"sha": "c4c145f5bd66d7adaee9184e4282ba046b1122a4", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1fb08f11b75259ad4f208e25fab6c7acc1bccd89/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb08f11b75259ad4f208e25fab6c7acc1bccd89/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=1fb08f11b75259ad4f208e25fab6c7acc1bccd89", "patch": "@@ -35,7 +35,7 @@ pub mod session;\n pub mod config;\n \n \n-pub fn main_args(args: &[~str]) -> int {\n+pub fn main_args(args: &[StrBuf]) -> int {\n     let owned_args = args.to_owned();\n     monitor(proc() run_compiler(owned_args));\n     0\n@@ -44,7 +44,7 @@ pub fn main_args(args: &[~str]) -> int {\n static BUG_REPORT_URL: &'static str =\n     \"http://static.rust-lang.org/doc/master/complement-bugreport.html\";\n \n-fn run_compiler(args: &[~str]) {\n+fn run_compiler(args: &[StrBuf]) {\n     let matches = match handle_options(Vec::from_slice(args)) {\n         Some(matches) => matches,\n         None => return\n@@ -73,7 +73,7 @@ fn run_compiler(args: &[~str]) {\n     let ofile = matches.opt_str(\"o\").map(|o| Path::new(o));\n \n     let pretty = matches.opt_default(\"pretty\", \"normal\").map(|a| {\n-        parse_pretty(&sess, a)\n+        parse_pretty(&sess, a.as_slice())\n     });\n     match pretty {\n         Some::<PpMode>(ppm) => {\n@@ -84,7 +84,7 @@ fn run_compiler(args: &[~str]) {\n     }\n \n     let r = matches.opt_strs(\"Z\");\n-    if r.contains(&(\"ls\".to_owned())) {\n+    if r.contains(&(\"ls\".to_strbuf())) {\n         match input {\n             FileInput(ref ifile) => {\n                 let mut stdout = io::stdout();\n@@ -191,17 +191,20 @@ fn describe_codegen_flags() {\n /// Process command line options. Emits messages as appropirate.If compilation\n /// should continue, returns a getopts::Matches object parsed from args, otherwise\n /// returns None.\n-pub fn handle_options(mut args: Vec<~str>) -> Option<getopts::Matches> {\n+pub fn handle_options(mut args: Vec<StrBuf>) -> Option<getopts::Matches> {\n     // Throw away the first argument, the name of the binary\n     let _binary = args.shift().unwrap();\n \n-    if args.is_empty() { usage(); return None; }\n+    if args.is_empty() {\n+        usage();\n+        return None;\n+    }\n \n     let matches =\n         match getopts::getopts(args.as_slice(), config::optgroups().as_slice()) {\n             Ok(m) => m,\n             Err(f) => {\n-                early_error(f.to_err_msg());\n+                early_error(f.to_err_msg().as_slice());\n             }\n         };\n \n@@ -212,24 +215,24 @@ pub fn handle_options(mut args: Vec<~str>) -> Option<getopts::Matches> {\n \n     let lint_flags = matches.opt_strs(\"W\").move_iter().collect::<Vec<_>>().append(\n                                     matches.opt_strs(\"warn\").as_slice());\n-    if lint_flags.iter().any(|x| x == &\"help\".to_owned()) {\n+    if lint_flags.iter().any(|x| x.as_slice() == \"help\") {\n         describe_warnings();\n         return None;\n     }\n \n     let r = matches.opt_strs(\"Z\");\n-    if r.iter().any(|x| x == &\"help\".to_owned()) {\n+    if r.iter().any(|x| x.as_slice() == \"help\") {\n         describe_debug_flags();\n         return None;\n     }\n \n     let cg_flags = matches.opt_strs(\"C\");\n-    if cg_flags.iter().any(|x| x == &\"help\".to_owned()) {\n+    if cg_flags.iter().any(|x| x.as_slice() == \"help\") {\n         describe_codegen_flags();\n         return None;\n     }\n \n-    if cg_flags.contains(&\"passes=list\".to_owned()) {\n+    if cg_flags.contains(&\"passes=list\".to_strbuf()) {\n         unsafe { ::lib::llvm::llvm::LLVMRustPrintPasses(); }\n         return None;\n     }"}, {"sha": "678d525ddcbb90b1121f4832c352cb66338423e4", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1fb08f11b75259ad4f208e25fab6c7acc1bccd89/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb08f11b75259ad4f208e25fab6c7acc1bccd89/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=1fb08f11b75259ad4f208e25fab6c7acc1bccd89", "patch": "@@ -121,5 +121,8 @@ pub mod lib {\n }\n \n pub fn main() {\n-    std::os::set_exit_status(driver::main_args(std::os::args().as_slice()));\n+    let args = std::os::args().iter()\n+                              .map(|x| x.to_strbuf())\n+                              .collect::<Vec<_>>();\n+    std::os::set_exit_status(driver::main_args(args.as_slice()));\n }"}, {"sha": "2a7808fdf77593c53c53a70278e3b964f85640e9", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1fb08f11b75259ad4f208e25fab6c7acc1bccd89/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb08f11b75259ad4f208e25fab6c7acc1bccd89/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=1fb08f11b75259ad4f208e25fab6c7acc1bccd89", "patch": "@@ -137,12 +137,7 @@ pub fn usage(argv0: &str) {\n }\n \n pub fn main_args(args: &[StrBuf]) -> int {\n-    let matches = match getopts::getopts(args.tail()\n-                                             .iter()\n-                                             .map(|x| (*x).to_owned())\n-                                             .collect::<Vec<_>>()\n-                                             .as_slice(),\n-                                         opts().as_slice()) {\n+    let matches = match getopts::getopts(args.tail(), opts().as_slice()) {\n         Ok(m) => m,\n         Err(err) => {\n             println!(\"{}\", err.to_err_msg());\n@@ -170,7 +165,7 @@ pub fn main_args(args: &[StrBuf]) -> int {\n \n     let test_args = matches.opt_strs(\"test-args\");\n     let test_args: Vec<StrBuf> = test_args.iter()\n-                                          .flat_map(|s| s.words())\n+                                          .flat_map(|s| s.as_slice().words())\n                                           .map(|s| s.to_strbuf())\n                                           .collect();\n \n@@ -199,7 +194,7 @@ pub fn main_args(args: &[StrBuf]) -> int {\n         (false, false) => {}\n     }\n \n-    if matches.opt_strs(\"passes\").as_slice() == &[\"list\".to_owned()] {\n+    if matches.opt_strs(\"passes\").as_slice() == &[\"list\".to_strbuf()] {\n         println!(\"Available passes for running rustdoc:\");\n         for &(name, _, description) in PASSES.iter() {\n             println!(\"{:>20s} - {}\", name, description);\n@@ -306,7 +301,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n                     clean::NameValue(ref x, ref value)\n                             if \"passes\" == x.as_slice() => {\n                         for pass in value.as_slice().words() {\n-                            passes.push(pass.to_owned());\n+                            passes.push(pass.to_strbuf());\n                         }\n                     }\n                     clean::NameValue(ref x, ref value)\n@@ -323,15 +318,19 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n     }\n     if default_passes {\n         for name in DEFAULT_PASSES.iter().rev() {\n-            passes.unshift(name.to_owned());\n+            passes.unshift(name.to_strbuf());\n         }\n     }\n \n     // Load all plugins/passes into a PluginManager\n-    let path = matches.opt_str(\"plugin-path\").unwrap_or(\"/tmp/rustdoc/plugins\".to_owned());\n+    let path = matches.opt_str(\"plugin-path\")\n+                      .unwrap_or(\"/tmp/rustdoc/plugins\".to_strbuf());\n     let mut pm = plugins::PluginManager::new(Path::new(path));\n     for pass in passes.iter() {\n-        let plugin = match PASSES.iter().position(|&(p, _, _)| p == *pass) {\n+        let plugin = match PASSES.iter()\n+                                 .position(|&(p, _, _)| {\n+                                     p == pass.as_slice()\n+                                 }) {\n             Some(i) => PASSES[i].val1(),\n             None => {\n                 error!(\"unknown pass {}, skipping\", *pass);"}, {"sha": "462c378617b884bc2f7ff1a8055fb1c7487fb739", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1fb08f11b75259ad4f208e25fab6c7acc1bccd89/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb08f11b75259ad4f208e25fab6c7acc1bccd89/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=1fb08f11b75259ad4f208e25fab6c7acc1bccd89", "patch": "@@ -354,11 +354,7 @@ Test Attributes:\n pub fn parse_opts(args: &[StrBuf]) -> Option<OptRes> {\n     let args_ = args.tail();\n     let matches =\n-        match getopts::getopts(args_.iter()\n-                                    .map(|x| x.to_owned())\n-                                    .collect::<Vec<_>>()\n-                                    .as_slice(),\n-                               optgroups().as_slice()) {\n+        match getopts::getopts(args_.as_slice(), optgroups().as_slice()) {\n           Ok(m) => m,\n           Err(f) => return Some(Err(f.to_err_msg().to_strbuf()))\n         };\n@@ -388,7 +384,8 @@ pub fn parse_opts(args: &[StrBuf]) -> Option<OptRes> {\n     let ratchet_metrics = ratchet_metrics.map(|s| Path::new(s));\n \n     let ratchet_noise_percent = matches.opt_str(\"ratchet-noise-percent\");\n-    let ratchet_noise_percent = ratchet_noise_percent.map(|s| from_str::<f64>(s).unwrap());\n+    let ratchet_noise_percent =\n+        ratchet_noise_percent.map(|s| from_str::<f64>(s.as_slice()).unwrap());\n \n     let save_metrics = matches.opt_str(\"save-metrics\");\n     let save_metrics = save_metrics.map(|s| Path::new(s));"}, {"sha": "313671448f8e9c71a91a82032871f9d9e2d69eaa", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fb08f11b75259ad4f208e25fab6c7acc1bccd89/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb08f11b75259ad4f208e25fab6c7acc1bccd89/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=1fb08f11b75259ad4f208e25fab6c7acc1bccd89", "patch": "@@ -55,7 +55,7 @@ struct Config {\n fn parse_opts(argv: Vec<StrBuf> ) -> Config {\n     let opts = vec!(getopts::optflag(\"\", \"stress\", \"\"));\n \n-    let argv = argv.iter().map(|x| x.to_str()).collect::<Vec<_>>();\n+    let argv = argv.iter().map(|x| x.to_strbuf()).collect::<Vec<_>>();\n     let opt_args = argv.slice(1, argv.len());\n \n     match getopts::getopts(opt_args, opts.as_slice()) {"}]}