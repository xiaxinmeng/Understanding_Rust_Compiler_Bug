{"sha": "94cbe88e8073381dbf7aeed2f0cf720b08f05785", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0Y2JlODhlODA3MzM4MWRiZjdhZWVkMmYwY2Y3MjBiMDhmMDU3ODU=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-19T21:21:18Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-27T21:26:36Z"}, "message": "Many small changes to thread management.", "tree": {"sha": "73c456fc4dd8b817201ad15196ea2480ce040720", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73c456fc4dd8b817201ad15196ea2480ce040720"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94cbe88e8073381dbf7aeed2f0cf720b08f05785", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94cbe88e8073381dbf7aeed2f0cf720b08f05785", "html_url": "https://github.com/rust-lang/rust/commit/94cbe88e8073381dbf7aeed2f0cf720b08f05785", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94cbe88e8073381dbf7aeed2f0cf720b08f05785/comments", "author": null, "committer": null, "parents": [{"sha": "75e6549c119cd0d30f764c3d8c2a742c63bc495f", "url": "https://api.github.com/repos/rust-lang/rust/commits/75e6549c119cd0d30f764c3d8c2a742c63bc495f", "html_url": "https://github.com/rust-lang/rust/commit/75e6549c119cd0d30f764c3d8c2a742c63bc495f"}], "stats": {"total": 120, "additions": 87, "deletions": 33}, "files": [{"sha": "97afbbe98f6a001973d624306b83dbd4177c501f", "filename": "src/shims/sync.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94cbe88e8073381dbf7aeed2f0cf720b08f05785/src%2Fshims%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94cbe88e8073381dbf7aeed2f0cf720b08f05785/src%2Fshims%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fsync.rs?ref=94cbe88e8073381dbf7aeed2f0cf720b08f05785", "patch": "@@ -419,7 +419,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             throw_ub_format!(\"called pthread_mutex_unlock on a mutex owned by another thread\");\n         } else if locked_count == 1 {\n             let blockset = mutex_get_or_create_blockset(this, mutex_op)?;\n-            if let Some(new_owner) = this.unblock_random_thread(blockset)? {\n+            if let Some(new_owner) = this.unblock_some_thread(blockset)? {\n                 // We have at least one thread waiting on this mutex. Transfer\n                 // ownership to it.\n                 mutex_set_owner(this, mutex_op, new_owner.to_u32_scalar())?;\n@@ -543,19 +543,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             assert_eq!(writers, 0);\n             rwlock_set_readers(this, rwlock_op, Scalar::from_u32(new_readers))?;\n             if new_readers == 0 {\n-                if let Some(_writer) = this.unblock_random_thread(writer_blockset)? {\n+                if let Some(_writer) = this.unblock_some_thread(writer_blockset)? {\n                     rwlock_set_writers(this, rwlock_op, Scalar::from_u32(1))?;\n                 }\n             }\n             Ok(0)\n         } else if writers != 0 {\n             let reader_blockset = rwlock_get_or_create_reader_blockset(this, rwlock_op)?;\n             rwlock_set_writers(this, rwlock_op, Scalar::from_u32(0))?;\n-            if let Some(_writer) = this.unblock_random_thread(writer_blockset)? {\n+            if let Some(_writer) = this.unblock_some_thread(writer_blockset)? {\n                 rwlock_set_writers(this, rwlock_op, Scalar::from_u32(1))?;\n             } else {\n                 let mut readers = 0;\n-                while let Some(_reader) = this.unblock_random_thread(reader_blockset)? {\n+                while let Some(_reader) = this.unblock_some_thread(reader_blockset)? {\n                     readers += 1;\n                 }\n                 rwlock_set_readers(this, rwlock_op, Scalar::from_u32(readers))?"}, {"sha": "5eb6560a09e64f1c764a3c819359d4d79faec53b", "filename": "src/thread.rs", "status": "modified", "additions": 83, "deletions": 29, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/94cbe88e8073381dbf7aeed2f0cf720b08f05785/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94cbe88e8073381dbf7aeed2f0cf720b08f05785/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=94cbe88e8073381dbf7aeed2f0cf720b08f05785", "patch": "@@ -31,6 +31,9 @@ pub enum SchedulingAction {\n #[derive(Clone, Copy, Debug, PartialOrd, Ord, PartialEq, Eq, Hash)]\n pub struct ThreadId(usize);\n \n+/// The main thread. When it terminates, the whole application terminates.\n+const MAIN_THREAD: ThreadId = ThreadId(0);\n+\n impl Idx for ThreadId {\n     fn new(idx: usize) -> Self {\n         ThreadId(idx)\n@@ -42,13 +45,13 @@ impl Idx for ThreadId {\n \n impl From<u64> for ThreadId {\n     fn from(id: u64) -> Self {\n-        Self(id as usize)\n+        Self(usize::try_from(id).unwrap())\n     }\n }\n \n impl From<u32> for ThreadId {\n     fn from(id: u32) -> Self {\n-        Self(id as usize)\n+        Self(usize::try_from(id).unwrap())\n     }\n }\n \n@@ -82,10 +85,10 @@ pub enum ThreadState {\n     /// The thread tried to join the specified thread and is blocked until that\n     /// thread terminates.\n     BlockedOnJoin(ThreadId),\n-    /// The thread is blocked and belongs to the given blockset..\n+    /// The thread is blocked and belongs to the given blockset.\n     Blocked(BlockSetId),\n     /// The thread has terminated its execution (we do not delete terminated\n-    /// threads.)\n+    /// threads).\n     Terminated,\n }\n \n@@ -150,6 +153,7 @@ pub struct ThreadManager<'mir, 'tcx> {\n impl<'mir, 'tcx> Default for ThreadManager<'mir, 'tcx> {\n     fn default() -> Self {\n         let mut threads = IndexVec::new();\n+        // Create the main thread and add it to the list of threads.\n         threads.push(Default::default());\n         Self {\n             active_thread: ThreadId::new(0),\n@@ -170,14 +174,13 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n \n     /// Set the allocation id as the allocation id of the given thread local\n     /// static for the active thread.\n+    ///\n+    /// Panics if a thread local is initialized twice for the same thread.\n     fn set_thread_local_alloc_id(&self, def_id: DefId, new_alloc_id: AllocId) {\n-        assert!(\n-            self.thread_local_alloc_ids\n-                .borrow_mut()\n-                .insert((def_id, self.active_thread), new_alloc_id)\n-                .is_none(),\n-            \"a thread local initialized twice for the same thread\"\n-        );\n+        self.thread_local_alloc_ids\n+            .borrow_mut()\n+            .insert((def_id, self.active_thread), new_alloc_id)\n+            .unwrap_none();\n     }\n \n     /// Borrow the stack of the active thread.\n@@ -227,15 +230,20 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n \n     /// Mark that the active thread tries to join the thread with `joined_thread_id`.\n-    fn join_thread(&mut self, joined_thread_id: ThreadId) {\n-        assert!(!self.threads[joined_thread_id].detached, \"Bug: trying to join a detached thread.\");\n-        assert_ne!(joined_thread_id, self.active_thread, \"Bug: trying to join itself\");\n-        assert!(\n-            self.threads\n-                .iter()\n-                .all(|thread| thread.state != ThreadState::BlockedOnJoin(joined_thread_id)),\n-            \"Bug: multiple threads try to join the same thread.\"\n-        );\n+    fn join_thread(&mut self, joined_thread_id: ThreadId) -> InterpResult<'tcx> {\n+        if self.threads[joined_thread_id].detached {\n+            throw_ub_format!(\"trying to join a detached thread\");\n+        }\n+        if joined_thread_id == self.active_thread {\n+            throw_ub_format!(\"trying to join itself\");\n+        }\n+        if self\n+            .threads\n+            .iter()\n+            .any(|thread| thread.state == ThreadState::BlockedOnJoin(joined_thread_id))\n+        {\n+            throw_ub_format!(\"multiple threads try to join the same thread\");\n+        }\n         if self.threads[joined_thread_id].state != ThreadState::Terminated {\n             // The joined thread is still running, we need to wait for it.\n             self.active_thread_mut().state = ThreadState::BlockedOnJoin(joined_thread_id);\n@@ -245,13 +253,23 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n                 joined_thread_id\n             );\n         }\n+        Ok(())\n     }\n \n     /// Set the name of the active thread.\n     fn set_thread_name(&mut self, new_thread_name: Vec<u8>) {\n         self.active_thread_mut().thread_name = Some(new_thread_name);\n     }\n \n+    /// Get the name of the active thread.\n+    fn get_thread_name(&mut self) -> InterpResult<'tcx, Vec<u8>> {\n+        if let Some(ref thread_name) = self.active_thread_mut().thread_name {\n+            Ok(thread_name.clone())\n+        } else {\n+            throw_ub_format!(\"thread {:?} has no name set\", self.active_thread)\n+        }\n+    }\n+\n     /// Allocate a new blockset id.\n     fn create_blockset(&mut self) -> BlockSetId {\n         self.blockset_counter = self.blockset_counter.checked_add(1).unwrap();\n@@ -267,7 +285,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n \n     /// Unblock any one thread from the given blockset if it contains at least\n     /// one. Return the id of the unblocked thread.\n-    fn unblock_random_thread(&mut self, set: BlockSetId) -> Option<ThreadId> {\n+    fn unblock_some_thread(&mut self, set: BlockSetId) -> Option<ThreadId> {\n         for (id, thread) in self.threads.iter_enumerated_mut() {\n             if thread.state == ThreadState::Blocked(set) {\n                 trace!(\"unblocking {:?} in blockset {:?}\", id, set);\n@@ -284,6 +302,11 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n \n     /// Decide which action to take next and on which thread.\n+    ///\n+    /// The currently implemented scheduling policy is the one that is commonly\n+    /// used in stateless model checkers such as Loom: run the active thread as\n+    /// long as we can and switch only when we have to (the active thread was\n+    /// blocked, terminated, or was explicitly asked to be preempted).\n     fn schedule(&mut self) -> InterpResult<'tcx, SchedulingAction> {\n         if self.threads[self.active_thread].check_terminated() {\n             // Check if we need to unblock any threads.\n@@ -295,14 +318,24 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n             }\n             return Ok(SchedulingAction::ExecuteDtors);\n         }\n+        if self.threads[MAIN_THREAD].state == ThreadState::Terminated {\n+            // The main thread terminated; stop the program.\n+            if self.threads.iter().any(|thread| thread.state != ThreadState::Terminated) {\n+                // FIXME: This check should be either configurable or just emit a warning.\n+                throw_unsup_format!(\"the main thread terminated without waiting for other threads\");\n+            }\n+            return Ok(SchedulingAction::Stop);\n+        }\n         if self.threads[self.active_thread].state == ThreadState::Enabled\n             && !self.yield_active_thread\n         {\n+            // The currently active thread is still enabled, just continue with it.\n             return Ok(SchedulingAction::ExecuteStep);\n         }\n+        // We need to pick a new thread for execution.\n         for (id, thread) in self.threads.iter_enumerated() {\n             if thread.state == ThreadState::Enabled {\n-                if !(self.yield_active_thread && id == self.active_thread) {\n+                if !self.yield_active_thread || id != self.active_thread {\n                     self.active_thread = id;\n                     break;\n                 }\n@@ -312,14 +345,16 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         if self.threads[self.active_thread].state == ThreadState::Enabled {\n             return Ok(SchedulingAction::ExecuteStep);\n         }\n+        // We have not found a thread to execute.\n         if self.threads.iter().all(|thread| thread.state == ThreadState::Terminated) {\n-            Ok(SchedulingAction::Stop)\n+            unreachable!();\n         } else {\n             throw_machine_stop!(TerminationInfo::Deadlock);\n         }\n     }\n }\n \n+// Public interface to thread management.\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     /// A workaround for thread-local statics until\n@@ -331,8 +366,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         val: &mut mir::interpret::ConstValue<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_ref();\n-        match val {\n-            mir::interpret::ConstValue::Scalar(Scalar::Ptr(ptr)) => {\n+        match *val {\n+            mir::interpret::ConstValue::Scalar(Scalar::Ptr(ref mut ptr)) => {\n                 let alloc_id = ptr.alloc_id;\n                 let alloc = this.tcx.alloc_map.lock().get(alloc_id);\n                 let tcx = this.tcx;\n@@ -407,75 +442,94 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n+    #[inline]\n     fn create_thread(&mut self) -> InterpResult<'tcx, ThreadId> {\n         let this = self.eval_context_mut();\n         Ok(this.machine.threads.create_thread())\n     }\n \n+    #[inline]\n     fn detach_thread(&mut self, thread_id: ThreadId) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         this.machine.threads.detach_thread(thread_id);\n         Ok(())\n     }\n \n+    #[inline]\n     fn join_thread(&mut self, joined_thread_id: ThreadId) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        this.machine.threads.join_thread(joined_thread_id);\n-        Ok(())\n+        this.machine.threads.join_thread(joined_thread_id)\n     }\n \n+    #[inline]\n     fn set_active_thread(&mut self, thread_id: ThreadId) -> InterpResult<'tcx, ThreadId> {\n         let this = self.eval_context_mut();\n         Ok(this.machine.threads.set_active_thread_id(thread_id))\n     }\n \n+    #[inline]\n     fn get_active_thread(&self) -> InterpResult<'tcx, ThreadId> {\n         let this = self.eval_context_ref();\n         Ok(this.machine.threads.get_active_thread_id())\n     }\n \n+    #[inline]\n     fn has_terminated(&self, thread_id: ThreadId) -> InterpResult<'tcx, bool> {\n         let this = self.eval_context_ref();\n         Ok(this.machine.threads.has_terminated(thread_id))\n     }\n \n+    #[inline]\n     fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Tag, FrameData<'tcx>>] {\n         let this = self.eval_context_ref();\n         this.machine.threads.active_thread_stack()\n     }\n \n+    #[inline]\n     fn active_thread_stack_mut(&mut self) -> &mut Vec<Frame<'mir, 'tcx, Tag, FrameData<'tcx>>> {\n         let this = self.eval_context_mut();\n         this.machine.threads.active_thread_stack_mut()\n     }\n \n+    #[inline]\n     fn set_active_thread_name(&mut self, new_thread_name: Vec<u8>) -> InterpResult<'tcx, ()> {\n         let this = self.eval_context_mut();\n         Ok(this.machine.threads.set_thread_name(new_thread_name))\n     }\n \n+    #[inline]\n+    fn get_active_thread_name(&mut self) -> InterpResult<'tcx, Vec<u8>> {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.get_thread_name()\n+    }\n+\n+    #[inline]\n     fn create_blockset(&mut self) -> InterpResult<'tcx, BlockSetId> {\n         let this = self.eval_context_mut();\n         Ok(this.machine.threads.create_blockset())\n     }\n \n+    #[inline]\n     fn block_active_thread(&mut self, set: BlockSetId) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         Ok(this.machine.threads.block_active_thread(set))\n     }\n \n-    fn unblock_random_thread(&mut self, set: BlockSetId) -> InterpResult<'tcx, Option<ThreadId>> {\n+    #[inline]\n+    fn unblock_some_thread(&mut self, set: BlockSetId) -> InterpResult<'tcx, Option<ThreadId>> {\n         let this = self.eval_context_mut();\n-        Ok(this.machine.threads.unblock_random_thread(set))\n+        Ok(this.machine.threads.unblock_some_thread(set))\n     }\n \n+    #[inline]\n     fn yield_active_thread(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         this.machine.threads.yield_active_thread();\n         Ok(())\n     }\n \n     /// Decide which action to take next and on which thread.\n+    #[inline]\n     fn schedule(&mut self) -> InterpResult<'tcx, SchedulingAction> {\n         let this = self.eval_context_mut();\n         this.machine.threads.schedule()"}]}