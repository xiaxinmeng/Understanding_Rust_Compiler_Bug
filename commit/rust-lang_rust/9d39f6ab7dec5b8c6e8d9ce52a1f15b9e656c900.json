{"sha": "9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "node_id": "C_kwDOAAsO6NoAKDlkMzlmNmFiN2RlYzViOGM2ZThkOWNlNTJhMWYxNWI5ZTY1NmM5MDA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-06T04:15:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-06T04:15:22Z"}, "message": "Auto merge of #89970 - jackh726:gats_diagnostics, r=nikomatsakis\n\nImplementation of GATs outlives lint\n\nSee #87479 for background. Closes #87479\n\nThe basic premise of this lint/error is to require the user to write where clauses on a GAT when those bounds can be implied or proven from any function on the trait returning that GAT.\n\n## Intuitive Explanation (Attempt) ##\nLet's take this trait definition as an example:\n```rust\ntrait Iterable {\n    type Item<'x>;\n    fn iter<'a>(&'a self) -> Self::Item<'a>;\n}\n```\nLet's focus on the `iter` function. The first thing to realize is that we know that `Self: 'a` because of `&'a self`. If an impl wants `Self::Item` to contain any data with references, then those references must be derived from `&'a self`. Thus, they must live only as long as `'a`. Furthermore, because of the `Self: 'a` implied bound, they must live only as long as `Self`. Since it's `'a` is used in place of `'x`, it is reasonable to assume that any value of `Self::Item<'x>`, and thus `'x`, will only be able to live as long as `Self`. Therefore, we require this bound on `Item` in the trait.\n\nAs another example:\n```rust\ntrait Deserializer<T> {\n    type Out<'x>;\n    fn deserialize<'a>(&self, input: &'a T) -> Self::Out<'a>;\n}\n```\nThe intuition is similar here, except rather than a `Self: 'a` implied bound, we have a `T: 'a` implied bound. Thus, the data on `Self::Out<'a>` is derived from `&'a T`, and thus it is reasonable to expect that the lifetime `'x` will always be less than `T`.\n\n## Implementation Algorithm ##\n* Given a GAT `<P0 as Trait<P1..Pi>>::G<Pi...Pn>` declared as `trait T<A1..Ai> for A0 { type G<Ai...An>; }` used in return type of one associated function `F`\n* Given env `E` (including implied bounds) for `F`\n* For each lifetime parameter `'a` in `P0...Pn`:\n    * For each other type parameter `Pi != 'a` in `P0...Pn`: // FIXME: this include of lifetime parameters too\n        * If `E => (P: 'a)`:\n            * Require where clause `Ai: 'a`\n\n## Follow-up questions ##\n* What should we do when we don't pass params exactly?\nFor this example:\n```rust\ntrait Des {\n    type Out<'x, D>;\n    fn des<'z, T>(&self, data: &'z Wrap<T>) -> Self::Out<'z, Wrap<T>>;\n}\n```\nShould we be requiring a `D: 'x` clause? We pass `Wrap<T>` as `D` and `'z` as `'x`, and should be able to prove that `Wrap<T>: 'z`.\n\nr? `@nikomatsakis`", "tree": {"sha": "359db033386756ffef79ce62ef1a5f1b0fa7157e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/359db033386756ffef79ce62ef1a5f1b0fa7157e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "html_url": "https://github.com/rust-lang/rust/commit/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18cae2680fff914c95a633c468f09b614f385844", "url": "https://api.github.com/repos/rust-lang/rust/commits/18cae2680fff914c95a633c468f09b614f385844", "html_url": "https://github.com/rust-lang/rust/commit/18cae2680fff914c95a633c468f09b614f385844"}, {"sha": "b6edcbd7b5db718ff5e8ba229812b35f803ddd7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6edcbd7b5db718ff5e8ba229812b35f803ddd7a", "html_url": "https://github.com/rust-lang/rust/commit/b6edcbd7b5db718ff5e8ba229812b35f803ddd7a"}], "stats": {"total": 755, "additions": 694, "deletions": 61}, "files": [{"sha": "9dae978dcde7d9b79dd59c74335b6d2529a0684c", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "patch": "@@ -1252,16 +1252,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.tainted_by_errors_flag.set(true)\n     }\n \n-    /// Process the region constraints and report any errors that\n+    /// Process the region constraints and return any any errors that\n     /// result. After this, no more unification operations should be\n     /// done -- or the compiler will panic -- but it is legal to use\n     /// `resolve_vars_if_possible` as well as `fully_resolve`.\n-    pub fn resolve_regions_and_report_errors(\n+    pub fn resolve_regions(\n         &self,\n         region_context: DefId,\n         outlives_env: &OutlivesEnvironment<'tcx>,\n         mode: RegionckMode,\n-    ) {\n+    ) -> Vec<RegionResolutionError<'tcx>> {\n         let (var_infos, data) = {\n             let mut inner = self.inner.borrow_mut();\n             let inner = &mut *inner;\n@@ -1287,6 +1287,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n         assert!(old_value.is_none());\n \n+        errors\n+    }\n+\n+    /// Process the region constraints and report any errors that\n+    /// result. After this, no more unification operations should be\n+    /// done -- or the compiler will panic -- but it is legal to use\n+    /// `resolve_vars_if_possible` as well as `fully_resolve`.\n+    pub fn resolve_regions_and_report_errors(\n+        &self,\n+        region_context: DefId,\n+        outlives_env: &OutlivesEnvironment<'tcx>,\n+        mode: RegionckMode,\n+    ) {\n+        let errors = self.resolve_regions(region_context, outlives_env, mode);\n+\n         if !self.is_tainted_by_errors() {\n             // As a heuristic, just skip reporting region errors\n             // altogether if other errors have been reported while"}, {"sha": "86d4e4d2b115b5857959bd115066bc850a5a8543", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "patch": "@@ -103,7 +103,7 @@ macro_rules! ignore_err {\n     };\n }\n \n-trait OutlivesEnvironmentExt<'tcx> {\n+pub(crate) trait OutlivesEnvironmentExt<'tcx> {\n     fn add_implied_bounds(\n         &mut self,\n         infcx: &InferCtxt<'a, 'tcx>,"}, {"sha": "06bfc427bbabcf45a912e802e11f109a40122ea1", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 368, "deletions": 4, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "patch": "@@ -1,3 +1,4 @@\n+use crate::check::regionck::OutlivesEnvironmentExt;\n use crate::check::{FnCtxt, Inherited};\n use crate::constrained_generic_params::{identify_constrained_generic_params, Parameter};\n \n@@ -11,16 +12,21 @@ use rustc_hir::intravisit::Visitor;\n use rustc_hir::itemlikevisit::ParItemLikeVisitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::ItemKind;\n+use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n+use rustc_infer::infer::outlives::obligations::TypeOutlives;\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::{self, RegionckMode, SubregionOrigin};\n use rustc_middle::hir::map as hir_map;\n-use rustc_middle::ty::subst::{InternalSubsts, Subst};\n+use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n use rustc_middle::ty::{\n-    self, AdtKind, GenericParamDefKind, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n+    self, AdtKind, GenericParamDefKind, ToPredicate, Ty, TyCtxt, TypeFoldable, TypeVisitor,\n+    WithConstness,\n };\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::{sym, Ident, Symbol};\n-use rustc_span::Span;\n-use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n+use rustc_span::{Span, DUMMY_SP};\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, WellFormedLoc};\n \n use std::convert::TryInto;\n@@ -253,6 +259,364 @@ pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                 .emit();\n         }\n     }\n+\n+    check_gat_where_clauses(tcx, trait_item, encl_trait_def_id);\n+}\n+\n+/// Require that the user writes where clauses on GATs for the implicit\n+/// outlives bounds involving trait parameters in trait functions and\n+/// lifetimes passed as GAT substs. See `self-outlives-lint` test.\n+///\n+/// This trait will be our running example. We are currently WF checking the `Item` item...\n+///\n+/// ```rust\n+/// trait LendingIterator {\n+///   type Item<'me>; // <-- WF checking this trait item\n+///\n+///   fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;\n+/// }\n+/// ```\n+fn check_gat_where_clauses(\n+    tcx: TyCtxt<'_>,\n+    trait_item: &hir::TraitItem<'_>,\n+    encl_trait_def_id: DefId,\n+) {\n+    let item = tcx.associated_item(trait_item.def_id);\n+    // If the current trait item isn't a type, it isn't a GAT\n+    if !matches!(item.kind, ty::AssocKind::Type) {\n+        return;\n+    }\n+    let generics: &ty::Generics = tcx.generics_of(trait_item.def_id);\n+    // If the current associated type doesn't have any (own) params, it's not a GAT\n+    // FIXME(jackh726): we can also warn in the more general case\n+    if generics.params.len() == 0 {\n+        return;\n+    }\n+    let associated_items: &ty::AssocItems<'_> = tcx.associated_items(encl_trait_def_id);\n+    let mut clauses: Option<FxHashSet<ty::Predicate<'_>>> = None;\n+    // For every function in this trait...\n+    // In our example, this would be the `next` method\n+    for item in\n+        associated_items.in_definition_order().filter(|item| matches!(item.kind, ty::AssocKind::Fn))\n+    {\n+        // The clauses we that we would require from this function\n+        let mut function_clauses = FxHashSet::default();\n+\n+        let id = hir::HirId::make_owner(item.def_id.expect_local());\n+        let param_env = tcx.param_env(item.def_id.expect_local());\n+\n+        let sig = tcx.fn_sig(item.def_id);\n+        // Get the signature using placeholders. In our example, this would\n+        // convert the late-bound 'a into a free region.\n+        let sig = tcx.liberate_late_bound_regions(item.def_id, sig);\n+        // Collect the arguments that are given to this GAT in the return type\n+        // of  the function signature. In our example, the GAT in the return\n+        // type is `<Self as LendingIterator>::Item<'a>`, so 'a and Self are arguments.\n+        let (regions, types) =\n+            GATSubstCollector::visit(tcx, trait_item.def_id.to_def_id(), sig.output());\n+\n+        // If both regions and types are empty, then this GAT isn't in the\n+        // return type, and we shouldn't try to do clause analysis\n+        // (particularly, doing so would end up with an empty set of clauses,\n+        // since the current method would require none, and we take the\n+        // intersection of requirements of all methods)\n+        if types.is_empty() && regions.is_empty() {\n+            continue;\n+        }\n+\n+        // The types we can assume to be well-formed. In our example, this\n+        // would be &'a mut Self, from the first argument.\n+        let mut wf_tys = FxHashSet::default();\n+        wf_tys.extend(sig.inputs());\n+\n+        // For each region argument (e.g., 'a in our example), check for a\n+        // relationship to the type arguments (e.g., Self). If there is an\n+        // outlives relationship (`Self: 'a`), then we want to ensure that is\n+        // reflected in a where clause on the GAT itself.\n+        for (region, region_idx) in &regions {\n+            for (ty, ty_idx) in &types {\n+                // In our example, requires that Self: 'a\n+                if ty_known_to_outlive(tcx, id, param_env, &wf_tys, *ty, *region) {\n+                    debug!(?ty_idx, ?region_idx);\n+                    debug!(\"required clause: {} must outlive {}\", ty, region);\n+                    // Translate into the generic parameters of the GAT. In\n+                    // our example, the type was Self, which will also be\n+                    // Self in the GAT.\n+                    let ty_param = generics.param_at(*ty_idx, tcx);\n+                    let ty_param = tcx.mk_ty(ty::Param(ty::ParamTy {\n+                        index: ty_param.index,\n+                        name: ty_param.name,\n+                    }));\n+                    // Same for the region. In our example, 'a corresponds\n+                    // to the 'me parameter.\n+                    let region_param = generics.param_at(*region_idx, tcx);\n+                    let region_param =\n+                        tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n+                            def_id: region_param.def_id,\n+                            index: region_param.index,\n+                            name: region_param.name,\n+                        }));\n+                    // The predicate we expect to see. (In our example,\n+                    // `Self: 'me`.)\n+                    let clause = ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n+                        ty_param,\n+                        region_param,\n+                    ));\n+                    let clause = tcx.mk_predicate(ty::Binder::dummy(clause));\n+                    function_clauses.insert(clause);\n+                }\n+            }\n+        }\n+\n+        // For each region argument (e.g., 'a in our example), also check for a\n+        // relationship to the other region arguments. If there is an\n+        // outlives relationship, then we want to ensure that is\n+        // reflected in a where clause on the GAT itself.\n+        for (region_a, region_a_idx) in &regions {\n+            for (region_b, region_b_idx) in &regions {\n+                if region_a == region_b {\n+                    continue;\n+                }\n+\n+                if region_known_to_outlive(tcx, id, param_env, &wf_tys, *region_a, *region_b) {\n+                    debug!(?region_a_idx, ?region_b_idx);\n+                    debug!(\"required clause: {} must outlive {}\", region_a, region_b);\n+                    // Translate into the generic parameters of the GAT.\n+                    let region_a_param = generics.param_at(*region_a_idx, tcx);\n+                    let region_a_param =\n+                        tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n+                            def_id: region_a_param.def_id,\n+                            index: region_a_param.index,\n+                            name: region_a_param.name,\n+                        }));\n+                    // Same for the region.\n+                    let region_b_param = generics.param_at(*region_b_idx, tcx);\n+                    let region_b_param =\n+                        tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n+                            def_id: region_b_param.def_id,\n+                            index: region_b_param.index,\n+                            name: region_b_param.name,\n+                        }));\n+                    // The predicate we expect to see.\n+                    let clause = ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n+                        region_a_param,\n+                        region_b_param,\n+                    ));\n+                    let clause = tcx.mk_predicate(ty::Binder::dummy(clause));\n+                    function_clauses.insert(clause);\n+                }\n+            }\n+        }\n+\n+        // Imagine we have:\n+        // ```\n+        // trait Foo {\n+        //   type Bar<'me>;\n+        //   fn gimme(&self) -> Self::Bar<'_>;\n+        //   fn gimme_default(&self) -> Self::Bar<'static>;\n+        // }\n+        // ```\n+        // We only want to require clauses on `Bar` that we can prove from *all* functions (in this\n+        // case, `'me` can be `static` from `gimme_default`)\n+        match clauses.as_mut() {\n+            Some(clauses) => {\n+                clauses.drain_filter(|p| !function_clauses.contains(p));\n+            }\n+            None => {\n+                clauses = Some(function_clauses);\n+            }\n+        }\n+    }\n+\n+    // If there are any missing clauses, emit an error\n+    let mut clauses = clauses.unwrap_or_default();\n+    debug!(?clauses);\n+    if !clauses.is_empty() {\n+        let written_predicates: ty::GenericPredicates<'_> =\n+            tcx.explicit_predicates_of(trait_item.def_id);\n+        let mut clauses: Vec<_> = clauses\n+            .drain_filter(|clause| {\n+                written_predicates.predicates.iter().find(|p| &p.0 == clause).is_none()\n+            })\n+            .map(|clause| format!(\"{}\", clause))\n+            .collect();\n+        // We sort so that order is predictable\n+        clauses.sort();\n+        if !clauses.is_empty() {\n+            let mut err = tcx.sess.struct_span_err(\n+                trait_item.span,\n+                &format!(\"Missing required bounds on {}\", trait_item.ident),\n+            );\n+\n+            let suggestion = format!(\n+                \"{} {}\",\n+                if !trait_item.generics.where_clause.predicates.is_empty() {\n+                    \",\"\n+                } else {\n+                    \" where\"\n+                },\n+                clauses.join(\", \"),\n+            );\n+            err.span_suggestion(\n+                trait_item.generics.where_clause.tail_span_for_suggestion(),\n+                \"add the required where clauses\",\n+                suggestion,\n+                Applicability::MachineApplicable,\n+            );\n+\n+            err.emit()\n+        }\n+    }\n+}\n+\n+// FIXME(jackh726): refactor some of the shared logic between the two functions below\n+\n+/// Given a known `param_env` and a set of well formed types, can we prove that\n+/// `ty` outlives `region`.\n+fn ty_known_to_outlive<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    id: hir::HirId,\n+    param_env: ty::ParamEnv<'tcx>,\n+    wf_tys: &FxHashSet<Ty<'tcx>>,\n+    ty: Ty<'tcx>,\n+    region: ty::Region<'tcx>,\n+) -> bool {\n+    // Unfortunately, we have to use a new `InferCtxt` each call, because\n+    // region constraints get added and solved there and we need to test each\n+    // call individually.\n+    tcx.infer_ctxt().enter(|infcx| {\n+        let mut outlives_environment = OutlivesEnvironment::new(param_env);\n+        outlives_environment.add_implied_bounds(&infcx, wf_tys.clone(), id, DUMMY_SP);\n+        outlives_environment.save_implied_bounds(id);\n+        let region_bound_pairs = outlives_environment.region_bound_pairs_map().get(&id).unwrap();\n+\n+        let cause = ObligationCause::new(DUMMY_SP, id, ObligationCauseCode::MiscObligation);\n+\n+        let sup_type = ty;\n+        let sub_region = region;\n+\n+        let origin = SubregionOrigin::from_obligation_cause(&cause, || {\n+            infer::RelateParamBound(cause.span, sup_type, None)\n+        });\n+\n+        let outlives = &mut TypeOutlives::new(\n+            &infcx,\n+            tcx,\n+            &region_bound_pairs,\n+            Some(infcx.tcx.lifetimes.re_root_empty),\n+            param_env,\n+        );\n+        outlives.type_must_outlive(origin, sup_type, sub_region);\n+\n+        let errors = infcx.resolve_regions(\n+            id.expect_owner().to_def_id(),\n+            &outlives_environment,\n+            RegionckMode::default(),\n+        );\n+\n+        debug!(?errors, \"errors\");\n+\n+        // If we were able to prove that the type outlives the region without\n+        // an error, it must be because of the implied or explicit bounds...\n+        errors.is_empty()\n+    })\n+}\n+\n+fn region_known_to_outlive<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    id: hir::HirId,\n+    param_env: ty::ParamEnv<'tcx>,\n+    wf_tys: &FxHashSet<Ty<'tcx>>,\n+    region_a: ty::Region<'tcx>,\n+    region_b: ty::Region<'tcx>,\n+) -> bool {\n+    // Unfortunately, we have to use a new `InferCtxt` each call, because\n+    // region constraints get added and solved there and we need to test each\n+    // call individually.\n+    tcx.infer_ctxt().enter(|infcx| {\n+        let mut outlives_environment = OutlivesEnvironment::new(param_env);\n+        outlives_environment.add_implied_bounds(&infcx, wf_tys.clone(), id, DUMMY_SP);\n+        outlives_environment.save_implied_bounds(id);\n+\n+        let cause = ObligationCause::new(DUMMY_SP, id, ObligationCauseCode::MiscObligation);\n+\n+        let origin = SubregionOrigin::from_obligation_cause(&cause, || {\n+            infer::RelateRegionParamBound(cause.span)\n+        });\n+\n+        use rustc_infer::infer::outlives::obligations::TypeOutlivesDelegate;\n+        (&infcx).push_sub_region_constraint(origin, region_a, region_b);\n+\n+        let errors = infcx.resolve_regions(\n+            id.expect_owner().to_def_id(),\n+            &outlives_environment,\n+            RegionckMode::default(),\n+        );\n+\n+        debug!(?errors, \"errors\");\n+\n+        // If we were able to prove that the type outlives the region without\n+        // an error, it must be because of the implied or explicit bounds...\n+        errors.is_empty()\n+    })\n+}\n+\n+/// TypeVisitor that looks for uses of GATs like\n+/// `<P0 as Trait<P1..Pn>>::GAT<Pn..Pm>` and adds the arguments `P0..Pm` into\n+/// the two vectors, `regions` and `types` (depending on their kind). For each\n+/// parameter `Pi` also track the index `i`.\n+struct GATSubstCollector<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    gat: DefId,\n+    // Which region appears and which parameter index its subsituted for\n+    regions: FxHashSet<(ty::Region<'tcx>, usize)>,\n+    // Which params appears and which parameter index its subsituted for\n+    types: FxHashSet<(Ty<'tcx>, usize)>,\n+}\n+\n+impl<'tcx> GATSubstCollector<'tcx> {\n+    fn visit<T: TypeFoldable<'tcx>>(\n+        tcx: TyCtxt<'tcx>,\n+        gat: DefId,\n+        t: T,\n+    ) -> (FxHashSet<(ty::Region<'tcx>, usize)>, FxHashSet<(Ty<'tcx>, usize)>) {\n+        let mut visitor = GATSubstCollector {\n+            tcx,\n+            gat,\n+            regions: FxHashSet::default(),\n+            types: FxHashSet::default(),\n+        };\n+        t.visit_with(&mut visitor);\n+        (visitor.regions, visitor.types)\n+    }\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for GATSubstCollector<'tcx> {\n+    type BreakTy = !;\n+\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        match t.kind() {\n+            ty::Projection(p) if p.item_def_id == self.gat => {\n+                for (idx, subst) in p.substs.iter().enumerate() {\n+                    match subst.unpack() {\n+                        GenericArgKind::Lifetime(lt) => {\n+                            self.regions.insert((lt, idx));\n+                        }\n+                        GenericArgKind::Type(t) => {\n+                            self.types.insert((t, idx));\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+        t.super_visit_with(self)\n+    }\n+\n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        Some(self.tcx)\n+    }\n }\n \n fn could_be_self(trait_def_id: LocalDefId, ty: &hir::Ty<'_>) -> bool {"}, {"sha": "f90cfb8849160055ab7fce45bd5f7ddfd4867123", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "patch": "@@ -70,6 +70,7 @@ This API is completely unstable and subject to change.\n #![feature(never_type)]\n #![feature(slice_partition_dedup)]\n #![feature(control_flow_enum)]\n+#![feature(hash_drain_filter)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "5b94cdee7c9c7deea6fb73f325ec198a982ee5a4", "filename": "src/test/ui/generic-associated-types/collections-project-default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollections-project-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollections-project-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollections-project-default.rs?ref=9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "patch": "@@ -8,7 +8,7 @@\n // check that we don't normalize with trait defaults.\n \n trait Collection<T> {\n-    type Iter<'iter>: Iterator<Item=&'iter T> where T: 'iter;\n+    type Iter<'iter>: Iterator<Item=&'iter T> where T: 'iter, Self: 'iter;\n     type Family: CollectionFamily;\n     // Test associated type defaults with parameters\n     type Sibling<U>: Collection<U> ="}, {"sha": "b0f2fb3f567856e8d649f1c0ed7c3e0c4612081b", "filename": "src/test/ui/generic-associated-types/collections.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollections.rs?ref=9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "patch": "@@ -8,7 +8,7 @@\n // run-pass\n \n trait Collection<T> {\n-    type Iter<'iter>: Iterator<Item=&'iter T> where T: 'iter;\n+    type Iter<'iter>: Iterator<Item=&'iter T> where T: 'iter, Self: 'iter;\n     type Family: CollectionFamily;\n     // Test associated type defaults with parameters\n     type Sibling<U>: Collection<U> ="}, {"sha": "d7c4dbda2644e68a6d31003e323d8a034d8ad1c9", "filename": "src/test/ui/generic-associated-types/generic-associated-type-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-type-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-type-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-type-bounds.rs?ref=9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "patch": "@@ -3,7 +3,7 @@\n #![feature(generic_associated_types)]\n \n pub trait X {\n-    type Y<'a>;\n+    type Y<'a> where Self: 'a;\n     fn m(&self) -> Self::Y<'_>;\n }\n "}, {"sha": "568996e1a17aa4b8b199fad7414ed6c3b688ff17", "filename": "src/test/ui/generic-associated-types/issue-70303.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70303.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70303.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70303.rs?ref=9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "patch": "@@ -3,7 +3,7 @@\n #![feature(generic_associated_types)]\n \n trait Document {\n-    type Cursor<'a>: DocCursor<'a>;\n+    type Cursor<'a>: DocCursor<'a> where Self: 'a;\n \n     fn cursor(&self) -> Self::Cursor<'_>;\n }"}, {"sha": "20c6924afa614d34d34858dd25de778fad604efa", "filename": "src/test/ui/generic-associated-types/issue-76535.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76535.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76535.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76535.rs?ref=9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "patch": "@@ -3,7 +3,7 @@\n pub trait SubTrait {}\n \n pub trait SuperTrait {\n-    type SubType<'a>: SubTrait;\n+    type SubType<'a>: SubTrait where Self: 'a;\n \n     fn get_sub<'a>(&'a mut self) -> Self::SubType<'a>;\n }"}, {"sha": "64eeec1b2fcbe39c2dfbf92460a60dac57f4ac67", "filename": "src/test/ui/generic-associated-types/issue-76535.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76535.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76535.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76535.stderr?ref=9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "patch": "@@ -7,7 +7,7 @@ LL |     let sub: Box<dyn SuperTrait<SubType = SubStruct>> = Box::new(SuperStruc\n note: associated type defined here, with 1 lifetime parameter: `'a`\n   --> $DIR/issue-76535.rs:6:10\n    |\n-LL |     type SubType<'a>: SubTrait;\n+LL |     type SubType<'a>: SubTrait where Self: 'a;\n    |          ^^^^^^^ --\n help: add missing lifetime argument\n    |\n@@ -25,7 +25,7 @@ note: for a trait to be \"object safe\" it needs to allow building a vtable to all\n    |\n LL | pub trait SuperTrait {\n    |           ---------- this trait cannot be made into an object...\n-LL |     type SubType<'a>: SubTrait;\n+LL |     type SubType<'a>: SubTrait where Self: 'a;\n    |          ^^^^^^^ ...because it contains the generic associated type `SubType`\n    = help: consider moving `SubType` to another trait\n \n@@ -40,7 +40,7 @@ note: for a trait to be \"object safe\" it needs to allow building a vtable to all\n    |\n LL | pub trait SuperTrait {\n    |           ---------- this trait cannot be made into an object...\n-LL |     type SubType<'a>: SubTrait;\n+LL |     type SubType<'a>: SubTrait where Self: 'a;\n    |          ^^^^^^^ ...because it contains the generic associated type `SubType`\n    = help: consider moving `SubType` to another trait\n    = note: required because of the requirements on the impl of `CoerceUnsized<Box<dyn SuperTrait<SubType = SubStruct<'_>>>>` for `Box<SuperStruct>`"}, {"sha": "47ef38ff45d65beadccc13496883013c7420e21d", "filename": "src/test/ui/generic-associated-types/issue-79422.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-79422.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-79422.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-79422.rs?ref=9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "patch": "@@ -17,12 +17,12 @@ impl<'a, T> RefCont<'a, T> for Box<T> {\n }\n \n trait MapLike<K, V> {\n-    type VRefCont<'a>: RefCont<'a, V>;\n+    type VRefCont<'a>: RefCont<'a, V> where Self: 'a;\n     fn get<'a>(&'a self, key: &K) -> Option<Self::VRefCont<'a>>;\n }\n \n impl<K: Ord, V: 'static> MapLike<K, V> for std::collections::BTreeMap<K, V> {\n-    type VRefCont<'a> = &'a V;\n+    type VRefCont<'a> where Self: 'a = &'a V;\n     fn get<'a>(&'a self, key: &K) -> Option<&'a V> {\n         std::collections::BTreeMap::get(self, key)\n     }"}, {"sha": "8b6f9b866e5ef1559333c848e618ffbf80fbdb32", "filename": "src/test/ui/generic-associated-types/issue-79422.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-79422.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-79422.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-79422.stderr?ref=9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "patch": "@@ -7,7 +7,7 @@ LL |         as Box<dyn MapLike<u8, u8, VRefCont = dyn RefCont<'_, u8>>>;\n note: associated type defined here, with 1 lifetime parameter: `'a`\n   --> $DIR/issue-79422.rs:20:10\n    |\n-LL |     type VRefCont<'a>: RefCont<'a, V>;\n+LL |     type VRefCont<'a>: RefCont<'a, V> where Self: 'a;\n    |          ^^^^^^^^ --\n help: add missing lifetime argument\n    |\n@@ -25,7 +25,7 @@ note: for a trait to be \"object safe\" it needs to allow building a vtable to all\n    |\n LL | trait MapLike<K, V> {\n    |       ------- this trait cannot be made into an object...\n-LL |     type VRefCont<'a>: RefCont<'a, V>;\n+LL |     type VRefCont<'a>: RefCont<'a, V> where Self: 'a;\n    |          ^^^^^^^^ ...because it contains the generic associated type `VRefCont`\n    = help: consider moving `VRefCont` to another trait\n \n@@ -40,7 +40,7 @@ note: for a trait to be \"object safe\" it needs to allow building a vtable to all\n    |\n LL | trait MapLike<K, V> {\n    |       ------- this trait cannot be made into an object...\n-LL |     type VRefCont<'a>: RefCont<'a, V>;\n+LL |     type VRefCont<'a>: RefCont<'a, V> where Self: 'a;\n    |          ^^^^^^^^ ...because it contains the generic associated type `VRefCont`\n    = help: consider moving `VRefCont` to another trait\n    = note: required because of the requirements on the impl of `CoerceUnsized<Box<dyn MapLike<u8, u8, VRefCont = (dyn RefCont<'_, u8> + 'static)>>>` for `Box<BTreeMap<u8, u8>>`"}, {"sha": "0f62f83e2563b15935bce74fc968ec97c56941f7", "filename": "src/test/ui/generic-associated-types/issue-86787.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86787.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86787.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86787.rs?ref=9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "patch": "@@ -9,6 +9,7 @@ enum Either<L, R> {\n pub trait HasChildrenOf {\n     type T;\n     type TRef<'a>;\n+    //~^ Missing required bounds\n \n     fn ref_children<'a>(&'a self) -> Vec<Self::TRef<'a>>;\n     fn take_children(self) -> Vec<Self::T>;\n@@ -20,9 +21,9 @@ where\n     Right: HasChildrenOf,\n {\n     type T = Either<Left::T, Right::T>;\n+    // We used to error below because the where clause doesn't match the trait.\n+    // Now, we error early on the trait itself.\n     type TRef<'a>\n-    //~^ `impl` associated type signature\n-    //~^^ `impl` associated type signature\n     where\n     <Left as HasChildrenOf>::T: 'a,\n     <Right as HasChildrenOf>::T: 'a"}, {"sha": "87dcd875de703b589d4be1477ed8446f9233eb1b", "filename": "src/test/ui/generic-associated-types/issue-86787.stderr", "status": "modified", "additions": 7, "deletions": 29, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86787.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86787.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86787.stderr?ref=9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "patch": "@@ -1,32 +1,10 @@\n-error: `impl` associated type signature for `TRef` doesn't match `trait` associated type signature\n-  --> $DIR/issue-86787.rs:23:5\n+error: Missing required bounds on TRef\n+  --> $DIR/issue-86787.rs:11:5\n    |\n-LL |       type TRef<'a>;\n-   |       -------------- expected\n-...\n-LL | /     type TRef<'a>\n-LL | |\n-LL | |\n-LL | |     where\n-LL | |     <Left as HasChildrenOf>::T: 'a,\n-LL | |     <Right as HasChildrenOf>::T: 'a\n-LL | |     = Either<&'a Left::T, &'a Right::T>;\n-   | |________________________________________^ found\n+LL |     type TRef<'a>;\n+   |     ^^^^^^^^^^^^^-\n+   |                  |\n+   |                  help: add the required where clauses: `where Self: 'a`\n \n-error: `impl` associated type signature for `TRef` doesn't match `trait` associated type signature\n-  --> $DIR/issue-86787.rs:23:5\n-   |\n-LL |       type TRef<'a>;\n-   |       -------------- expected\n-...\n-LL | /     type TRef<'a>\n-LL | |\n-LL | |\n-LL | |     where\n-LL | |     <Left as HasChildrenOf>::T: 'a,\n-LL | |     <Right as HasChildrenOf>::T: 'a\n-LL | |     = Either<&'a Left::T, &'a Right::T>;\n-   | |________________________________________^ found\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "df5586ed422f84f0491c3330ccc6e492b33f194c", "filename": "src/test/ui/generic-associated-types/issue-88287.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88287.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88287.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88287.rs?ref=9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "patch": "@@ -13,7 +13,8 @@ trait SearchableResource<Criteria> {\n trait SearchableResourceExt<Criteria>: SearchableResource<Criteria> {\n     type Future<'f, A: 'f + ?Sized, B: 'f>: Future<Output = Result<Vec<A::SearchResult>, ()>> + 'f\n     where\n-        A: SearchableResource<B>;\n+        A: SearchableResource<B>,\n+        Self: 'f;\n \n     fn search<'c>(&'c self, client: &'c ()) -> Self::Future<'c, Self, Criteria>;\n }\n@@ -29,6 +30,7 @@ where\n     type Future<'f, A, B: 'f>\n     where\n         A: SearchableResource<B> + ?Sized + 'f,\n+        Self: 'f,\n     = SearchFutureTy<'f, A, B>;\n \n     fn search<'c>(&'c self, _client: &'c ()) -> Self::Future<'c, Self, Criteria> {"}, {"sha": "8ee98201aba7a79ec6624e8aa626025e403d032d", "filename": "src/test/ui/generic-associated-types/issue-88360.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88360.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88360.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88360.rs?ref=9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "patch": "@@ -1,13 +1,14 @@\n #![feature(generic_associated_types)]\n \n trait GatTrait {\n-    type Gat<'a>;\n+    type Gat<'a> where Self: 'a;\n \n     fn test(&self) -> Self::Gat<'_>;\n }\n \n trait SuperTrait<T>\n where\n+    Self: 'static,\n     for<'a> Self: GatTrait<Gat<'a> = &'a T>,\n {\n     fn copy(&self) -> Self::Gat<'_> where T: Copy {"}, {"sha": "5f769d799faa16ab547dfd1d80a3abf54fbd11b5", "filename": "src/test/ui/generic-associated-types/issue-88360.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88360.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88360.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88360.stderr?ref=9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: mismatched types\n-  --> $DIR/issue-88360.rs:14:9\n+  --> $DIR/issue-88360.rs:15:9\n    |\n LL | trait SuperTrait<T>\n    |                  - this type parameter"}, {"sha": "bcbcfc18996375a47fe0dd4c6024512530ce2e18", "filename": "src/test/ui/generic-associated-types/projection-type-lifetime-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-type-lifetime-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-type-lifetime-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-type-lifetime-mismatch.rs?ref=9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "patch": "@@ -1,7 +1,7 @@\n #![feature(generic_associated_types)]\n \n pub trait X {\n-    type Y<'a>;\n+    type Y<'a> where Self: 'a;\n     fn m(&self) -> Self::Y<'_>;\n }\n "}, {"sha": "af90d158855d8c1d54ed49e8a646c69a31ce7913", "filename": "src/test/ui/generic-associated-types/self-outlives-lint.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs?ref=9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "patch": "@@ -0,0 +1,173 @@\n+#![feature(generic_associated_types)]\n+\n+// check-fail\n+\n+use std::fmt::Debug;\n+\n+// We have a `&'a self`, so we need a `Self: 'a`\n+trait Iterable {\n+    type Item<'x>;\n+    //~^ Missing required bounds\n+    fn iter<'a>(&'a self) -> Self::Item<'a>;\n+}\n+\n+/*\n+impl<T> Iterable for T {\n+    type Item<'a> = &'a T;\n+    fn iter<'a>(&'a self) -> Self::Item<'a> {\n+        self\n+    }\n+}\n+*/\n+\n+// We have a `&'a T`, so we need a `T: 'x`\n+trait Deserializer<T> {\n+    type Out<'x>;\n+    //~^ Missing required bounds\n+    fn deserialize<'a>(&self, input: &'a T) -> Self::Out<'a>;\n+}\n+\n+/*\n+impl<T> Deserializer<T> for () {\n+    type Out<'a> = &'a T;\n+    fn deserialize<'a>(&self, input: &'a T) -> Self::Out<'a> { input }\n+}\n+*/\n+\n+// We have a `&'b T` and a `'b: 'a`, so it is implied that `T: 'a`. Therefore, we need a `T: 'x`\n+trait Deserializer2<T> {\n+    type Out<'x>;\n+    //~^ Missing required bounds\n+    fn deserialize2<'a, 'b: 'a>(&self, input1: &'b T) -> Self::Out<'a>;\n+}\n+\n+// We have a `&'a T` and a `&'b U`, so we need a `T: 'x` and a `U: 'y`\n+trait Deserializer3<T, U> {\n+    type Out<'x, 'y>;\n+    //~^ Missing required bounds\n+    fn deserialize2<'a, 'b>(&self, input: &'a T, input2: &'b U) -> Self::Out<'a, 'b>;\n+}\n+\n+// `T` is a param on the function, so it can't be named by the associated type\n+trait Deserializer4 {\n+    type Out<'x>;\n+    fn deserialize<'a, T>(&self, input: &'a T) -> Self::Out<'a>;\n+}\n+\n+struct Wrap<T>(T);\n+\n+// We pass `Wrap<T>` and we see `&'z Wrap<T>`, so we require `D: 'x`\n+trait Des {\n+    type Out<'x, D>;\n+    //~^ Missing required bounds\n+    fn des<'z, T>(&self, data: &'z Wrap<T>) -> Self::Out<'z, Wrap<T>>;\n+}\n+/*\n+impl Des for () {\n+    type Out<'x, D> = &'x D; // Not okay\n+    fn des<'a, T>(&self, data: &'a Wrap<T>) -> Self::Out<'a, Wrap<T>> {\n+        data\n+    }\n+}\n+*/\n+\n+// We have `T` and `'z` as GAT substs. Because of `&'z Wrap<T>`, there is an\n+// implied bound that `T: 'z`, so we require `D: 'x`\n+trait Des2 {\n+    type Out<'x, D>;\n+    //~^ Missing required bounds\n+    fn des<'z, T>(&self, data: &'z Wrap<T>) -> Self::Out<'z, T>;\n+}\n+/*\n+impl Des2 for () {\n+    type Out<'x, D> = &'x D;\n+    fn des<'a, T>(&self, data: &'a Wrap<T>) -> Self::Out<'a, T> {\n+        &data.0\n+    }\n+}\n+*/\n+\n+// We see `&'z T`, so we require `D: 'x`\n+trait Des3 {\n+    type Out<'x, D>;\n+    //~^ Missing required bounds\n+    fn des<'z, T>(&self, data: &'z T) -> Self::Out<'z, T>;\n+}\n+/*\n+impl Des3 for () {\n+    type Out<'x, D> = &'x D;\n+    fn des<'a, T>(&self, data: &'a T) -> Self::Out<'a, T> {\n+          data\n+    }\n+}\n+*/\n+\n+// Similar case to before, except with GAT.\n+trait NoGat<'a> {\n+    type Bar;\n+    fn method(&'a self) -> Self::Bar;\n+}\n+\n+// Lifetime is not on function; except `Self: 'a`\n+// FIXME: we require two bounds (`where Self: 'a, Self: 'b`) when we should only require one\n+trait TraitLifetime<'a> {\n+    type Bar<'b>;\n+    //~^ Missing required bounds\n+    fn method(&'a self) -> Self::Bar<'a>;\n+}\n+\n+// Like above, but we have a where clause that can prove what we want\n+// FIXME: we require two bounds (`where Self: 'a, Self: 'b`) when we should only require one\n+trait TraitLifetimeWhere<'a> where Self: 'a {\n+    type Bar<'b>;\n+    //~^ Missing required bounds\n+    fn method(&'a self) -> Self::Bar<'a>;\n+}\n+\n+// Explicit bound instead of implicit; we want to still error\n+trait ExplicitBound {\n+    type Bar<'b>;\n+    //~^ Missing required bounds\n+    fn method<'b>(&self, token: &'b ()) -> Self::Bar<'b> where Self: 'b;\n+}\n+\n+// The use of the GAT here is not in the return, we don't want to error\n+trait NotInReturn {\n+    type Bar<'b>;\n+    fn method<'b>(&'b self) where Self::Bar<'b>: Debug;\n+}\n+\n+// We obviously error for `Iterator`, but we should also error for `Item`\n+trait IterableTwo {\n+    type Item<'a>;\n+    type Iterator<'a>: Iterator<Item = Self::Item<'a>>;\n+    //~^ Missing required bounds\n+    fn iter<'a>(&'a self) -> Self::Iterator<'a>;\n+}\n+\n+// We also should report region outlives clauses\n+trait RegionOutlives {\n+    type Bar<'a, 'b>;\n+    //~^ Missing required bounds\n+    fn foo<'x, 'y>(&self, input: &'x &'y ()) -> Self::Bar<'x, 'y>;\n+}\n+\n+/*\n+impl Foo for () {\n+    type Bar<'a, 'b> = &'a &'b ();\n+    fn foo<'x, 'y>(&self, input: &'x &'y ()) -> Self::Bar<'x, 'y> {\n+        input\n+    }\n+}\n+*/\n+\n+// If there are multiple methods that return the GAT, require a set of clauses\n+// that can be satisfied by *all* methods\n+trait MultipleMethods {\n+    type Bar<'me>;\n+\n+    fn gimme<'a>(&'a self) -> Self::Bar<'a>;\n+    fn gimme_default(&self) -> Self::Bar<'static>;\n+}\n+\n+fn main() {}"}, {"sha": "bf85780f69f7a7e24274ab8e98c92e7cb6620a24", "filename": "src/test/ui/generic-associated-types/self-outlives-lint.stderr", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr?ref=9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "patch": "@@ -0,0 +1,98 @@\n+error: Missing required bounds on Item\n+  --> $DIR/self-outlives-lint.rs:9:5\n+   |\n+LL |     type Item<'x>;\n+   |     ^^^^^^^^^^^^^-\n+   |                  |\n+   |                  help: add the required where clauses: `where Self: 'x`\n+\n+error: Missing required bounds on Out\n+  --> $DIR/self-outlives-lint.rs:25:5\n+   |\n+LL |     type Out<'x>;\n+   |     ^^^^^^^^^^^^-\n+   |                 |\n+   |                 help: add the required where clauses: `where T: 'x`\n+\n+error: Missing required bounds on Out\n+  --> $DIR/self-outlives-lint.rs:39:5\n+   |\n+LL |     type Out<'x>;\n+   |     ^^^^^^^^^^^^-\n+   |                 |\n+   |                 help: add the required where clauses: `where T: 'x`\n+\n+error: Missing required bounds on Out\n+  --> $DIR/self-outlives-lint.rs:46:5\n+   |\n+LL |     type Out<'x, 'y>;\n+   |     ^^^^^^^^^^^^^^^^-\n+   |                     |\n+   |                     help: add the required where clauses: `where T: 'x, U: 'y`\n+\n+error: Missing required bounds on Out\n+  --> $DIR/self-outlives-lint.rs:61:5\n+   |\n+LL |     type Out<'x, D>;\n+   |     ^^^^^^^^^^^^^^^-\n+   |                    |\n+   |                    help: add the required where clauses: `where D: 'x`\n+\n+error: Missing required bounds on Out\n+  --> $DIR/self-outlives-lint.rs:77:5\n+   |\n+LL |     type Out<'x, D>;\n+   |     ^^^^^^^^^^^^^^^-\n+   |                    |\n+   |                    help: add the required where clauses: `where D: 'x`\n+\n+error: Missing required bounds on Out\n+  --> $DIR/self-outlives-lint.rs:92:5\n+   |\n+LL |     type Out<'x, D>;\n+   |     ^^^^^^^^^^^^^^^-\n+   |                    |\n+   |                    help: add the required where clauses: `where D: 'x`\n+\n+error: Missing required bounds on Bar\n+  --> $DIR/self-outlives-lint.rs:114:5\n+   |\n+LL |     type Bar<'b>;\n+   |     ^^^^^^^^^^^^-\n+   |                 |\n+   |                 help: add the required where clauses: `where Self: 'a, Self: 'b`\n+\n+error: Missing required bounds on Bar\n+  --> $DIR/self-outlives-lint.rs:122:5\n+   |\n+LL |     type Bar<'b>;\n+   |     ^^^^^^^^^^^^-\n+   |                 |\n+   |                 help: add the required where clauses: `where Self: 'a, Self: 'b`\n+\n+error: Missing required bounds on Bar\n+  --> $DIR/self-outlives-lint.rs:129:5\n+   |\n+LL |     type Bar<'b>;\n+   |     ^^^^^^^^^^^^-\n+   |                 |\n+   |                 help: add the required where clauses: `where Self: 'b`\n+\n+error: Missing required bounds on Iterator\n+  --> $DIR/self-outlives-lint.rs:143:5\n+   |\n+LL |     type Iterator<'a>: Iterator<Item = Self::Item<'a>>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |                                                       |\n+   |                                                       help: add the required where clauses: `where Self: 'a`\n+\n+error: Missing required bounds on Bar\n+  --> $DIR/self-outlives-lint.rs:150:5\n+   |\n+LL |     type Bar<'a, 'b>;\n+   |     ^^^^^^^^^^^^^^^^-\n+   |                     |\n+   |                     help: add the required where clauses: `where 'a: 'b`\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "f83d4d7b68e48ae155a5db86ae28bf2f6486654a", "filename": "src/test/ui/generic-associated-types/streaming_iterator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fstreaming_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fstreaming_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fstreaming_iterator.rs?ref=9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "patch": "@@ -5,12 +5,12 @@\n use std::fmt::Display;\n \n trait StreamingIterator {\n-    type Item<'a>;\n+    type Item<'a> where Self: 'a;\n     // Applying the lifetime parameter `'a` to `Self::Item` inside the trait.\n     fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;\n }\n \n-struct Foo<T: StreamingIterator> {\n+struct Foo<T: StreamingIterator + 'static> {\n     // Applying a concrete lifetime to the constructor outside the trait.\n     bar: <T as StreamingIterator>::Item<'static>,\n }\n@@ -30,7 +30,7 @@ struct StreamEnumerate<I> {\n }\n \n impl<I: StreamingIterator> StreamingIterator for StreamEnumerate<I> {\n-    type Item<'a> = (usize, I::Item<'a>);\n+    type Item<'a> where Self: 'a = (usize, I::Item<'a>);\n     fn next<'a>(&'a mut self) -> Option<Self::Item<'a>> {\n         match self.iter.next() {\n             None => None,\n@@ -44,7 +44,7 @@ impl<I: StreamingIterator> StreamingIterator for StreamEnumerate<I> {\n }\n \n impl<I: Iterator> StreamingIterator for I {\n-    type Item<'a> = <I as Iterator>::Item;\n+    type Item<'a> where Self: 'a = <I as Iterator>::Item;\n     fn next(&mut self) -> Option<<I as StreamingIterator>::Item<'_>> {\n         Iterator::next(self)\n     }"}, {"sha": "7d0f7638ac89dc008a5f43305440cff3c2299bb7", "filename": "src/test/ui/generic-associated-types/variance_constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fvariance_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fvariance_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fvariance_constraints.rs?ref=9d39f6ab7dec5b8c6e8d9ce52a1f15b9e656c900", "patch": "@@ -3,7 +3,7 @@\n #![feature(generic_associated_types)]\n \n trait A {\n-    type B<'a>;\n+    type B<'a> where Self: 'a;\n \n     fn make_b<'a>(&'a self) -> Self::B<'a>;\n }"}]}