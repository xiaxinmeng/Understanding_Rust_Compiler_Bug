{"sha": "49f7550a25722fbdb779eef80afa85f6d802f7e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5Zjc1NTBhMjU3MjJmYmRiNzc5ZWVmODBhZmE4NWY2ZDgwMmY3ZTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-12T07:30:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-12T07:30:44Z"}, "message": "Auto merge of #23162 - sfackler:debug-builders, r=alexcrichton\n\nI've made some minor changes from the implementation attached to the RFC to try to minimize codegen. The methods now take `&Debug` trait objects rather than being parameterized and there are inlined stub methods that call to non-inlined methods to do the work.\r\n\r\nr? @alexcrichton \r\n\r\ncc @huonw for the `derive(Debug)` changes.", "tree": {"sha": "ea61e689eb6a17ae4766f873f095c66b2bdfa5f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea61e689eb6a17ae4766f873f095c66b2bdfa5f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49f7550a25722fbdb779eef80afa85f6d802f7e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49f7550a25722fbdb779eef80afa85f6d802f7e8", "html_url": "https://github.com/rust-lang/rust/commit/49f7550a25722fbdb779eef80afa85f6d802f7e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49f7550a25722fbdb779eef80afa85f6d802f7e8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8715a65496b557798a9ff346194991aea3581f4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8715a65496b557798a9ff346194991aea3581f4d", "html_url": "https://github.com/rust-lang/rust/commit/8715a65496b557798a9ff346194991aea3581f4d"}, {"sha": "905a611b94d1fd50f15cd06f27cd44fd4dacb131", "url": "https://api.github.com/repos/rust-lang/rust/commits/905a611b94d1fd50f15cd06f27cd44fd4dacb131", "html_url": "https://github.com/rust-lang/rust/commit/905a611b94d1fd50f15cd06f27cd44fd4dacb131"}], "stats": {"total": 932, "additions": 867, "deletions": 65}, "files": [{"sha": "07f029cc15e2f219172350e7a6c15484f32271df", "filename": "src/libcore/fmt/builders.rs", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/49f7550a25722fbdb779eef80afa85f6d802f7e8/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f7550a25722fbdb779eef80afa85f6d802f7e8/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=49f7550a25722fbdb779eef80afa85f6d802f7e8", "patch": "@@ -0,0 +1,301 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+use fmt::{self, Write, FlagV1};\n+\n+struct PadAdapter<'a, 'b: 'a> {\n+    fmt: &'a mut fmt::Formatter<'b>,\n+    on_newline: bool,\n+}\n+\n+impl<'a, 'b: 'a> PadAdapter<'a, 'b> {\n+    fn new(fmt: &'a mut fmt::Formatter<'b>) -> PadAdapter<'a, 'b> {\n+        PadAdapter {\n+            fmt: fmt,\n+            on_newline: false,\n+        }\n+    }\n+}\n+\n+impl<'a, 'b: 'a> fmt::Write for PadAdapter<'a, 'b> {\n+    fn write_str(&mut self, mut s: &str) -> fmt::Result {\n+        while !s.is_empty() {\n+            if self.on_newline {\n+                try!(self.fmt.write_str(\"    \"));\n+            }\n+\n+            let split = match s.find('\\n') {\n+                Some(pos) => {\n+                    self.on_newline = true;\n+                    pos + 1\n+                }\n+                None => {\n+                    self.on_newline = false;\n+                    s.len()\n+                }\n+            };\n+            try!(self.fmt.write_str(&s[..split]));\n+            s = &s[split..];\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+/// A struct to help with `fmt::Debug` implementations.\n+///\n+/// Constructed by the `Formatter::debug_struct` method.\n+#[must_use]\n+pub struct DebugStruct<'a, 'b: 'a> {\n+    fmt: &'a mut fmt::Formatter<'b>,\n+    result: fmt::Result,\n+    has_fields: bool,\n+}\n+\n+pub fn debug_struct_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>, name: &str)\n+                                -> DebugStruct<'a, 'b> {\n+    let result = fmt.write_str(name);\n+    DebugStruct {\n+        fmt: fmt,\n+        result: result,\n+        has_fields: false,\n+    }\n+}\n+\n+impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n+    /// Adds a new field to the generated struct output.\n+    #[unstable(feature = \"debug_builders\", reason = \"method was just created\")]\n+    pub fn field(mut self, name: &str, value: &fmt::Debug) -> DebugStruct<'a, 'b> {\n+        self.result = self.result.and_then(|_| {\n+            let prefix = if self.has_fields {\n+                \",\"\n+            } else {\n+                \" {\"\n+            };\n+\n+            if self.is_pretty() {\n+                let mut writer = PadAdapter::new(self.fmt);\n+                fmt::write(&mut writer, format_args!(\"{}\\n{}: {:#?}\", prefix, name, value))\n+            } else {\n+                write!(self.fmt, \"{} {}: {:?}\", prefix, name, value)\n+            }\n+        });\n+\n+        self.has_fields = true;\n+        self\n+    }\n+\n+    /// Consumes the `DebugStruct`, finishing output and returning any error\n+    /// encountered.\n+    #[unstable(feature = \"debug_builders\", reason = \"method was just created\")]\n+    pub fn finish(mut self) -> fmt::Result {\n+        if self.has_fields {\n+            self.result = self.result.and_then(|_| {\n+                if self.is_pretty() {\n+                    self.fmt.write_str(\"\\n}\")\n+                } else {\n+                    self.fmt.write_str(\" }\")\n+                }\n+            });\n+        }\n+        self.result\n+    }\n+\n+    fn is_pretty(&self) -> bool {\n+        self.fmt.flags() & (1 << (FlagV1::Alternate as usize)) != 0\n+    }\n+}\n+\n+/// A struct to help with `fmt::Debug` implementations.\n+///\n+/// Constructed by the `Formatter::debug_tuple` method.\n+#[must_use]\n+pub struct DebugTuple<'a, 'b: 'a> {\n+    fmt: &'a mut fmt::Formatter<'b>,\n+    result: fmt::Result,\n+    has_fields: bool,\n+}\n+\n+pub fn debug_tuple_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>, name: &str) -> DebugTuple<'a, 'b> {\n+    let result = fmt.write_str(name);\n+    DebugTuple {\n+        fmt: fmt,\n+        result: result,\n+        has_fields: false,\n+    }\n+}\n+\n+impl<'a, 'b: 'a> DebugTuple<'a, 'b> {\n+    /// Adds a new field to the generated tuple struct output.\n+    #[unstable(feature = \"debug_builders\", reason = \"method was just created\")]\n+    pub fn field(mut self, value: &fmt::Debug) -> DebugTuple<'a, 'b> {\n+        self.result = self.result.and_then(|_| {\n+            let (prefix, space) = if self.has_fields {\n+                (\",\", \" \")\n+            } else {\n+                (\"(\", \"\")\n+            };\n+\n+            if self.is_pretty() {\n+                let mut writer = PadAdapter::new(self.fmt);\n+                fmt::write(&mut writer, format_args!(\"{}\\n{:#?}\", prefix, value))\n+            } else {\n+                write!(self.fmt, \"{}{}{:?}\", prefix, space, value)\n+            }\n+        });\n+\n+        self.has_fields = true;\n+        self\n+    }\n+\n+    /// Consumes the `DebugTuple`, finishing output and returning any error\n+    /// encountered.\n+    #[unstable(feature = \"debug_builders\", reason = \"method was just created\")]\n+    pub fn finish(mut self) -> fmt::Result {\n+        if self.has_fields {\n+            self.result = self.result.and_then(|_| {\n+                if self.is_pretty() {\n+                    self.fmt.write_str(\"\\n)\")\n+                } else {\n+                    self.fmt.write_str(\")\")\n+                }\n+            });\n+        }\n+        self.result\n+    }\n+\n+    fn is_pretty(&self) -> bool {\n+        self.fmt.flags() & (1 << (FlagV1::Alternate as usize)) != 0\n+    }\n+}\n+\n+/// A struct to help with `fmt::Debug` implementations.\n+///\n+/// Constructed by the `Formatter::debug_set` method.\n+#[must_use]\n+pub struct DebugSet<'a, 'b: 'a> {\n+    fmt: &'a mut fmt::Formatter<'b>,\n+    result: fmt::Result,\n+    has_fields: bool,\n+}\n+\n+pub fn debug_set_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>, name: &str) -> DebugSet<'a, 'b> {\n+    let result = write!(fmt, \"{} {{\", name);\n+    DebugSet {\n+        fmt: fmt,\n+        result: result,\n+        has_fields: false,\n+    }\n+}\n+\n+impl<'a, 'b: 'a> DebugSet<'a, 'b> {\n+    /// Adds a new entry to the set output.\n+    #[unstable(feature = \"debug_builders\", reason = \"method was just created\")]\n+    pub fn entry(mut self, entry: &fmt::Debug) -> DebugSet<'a, 'b> {\n+        self.result = self.result.and_then(|_| {\n+            let prefix = if self.has_fields {\n+                \",\"\n+            } else {\n+                \"\"\n+            };\n+\n+            if self.is_pretty() {\n+                let mut writer = PadAdapter::new(self.fmt);\n+                fmt::write(&mut writer, format_args!(\"{}\\n{:#?}\", prefix, entry))\n+            } else {\n+                write!(self.fmt, \"{} {:?}\", prefix, entry)\n+            }\n+        });\n+\n+        self.has_fields = true;\n+        self\n+    }\n+\n+    /// Consumes the `DebugSet`, finishing output and returning any error\n+    /// encountered.\n+    #[unstable(feature = \"debug_builders\", reason = \"method was just created\")]\n+    pub fn finish(self) -> fmt::Result {\n+        self.result.and_then(|_| {\n+            let end = match (self.has_fields, self.is_pretty()) {\n+                (false, _) => \"}\",\n+                (true, false) => \" }\",\n+                (true, true) => \"\\n}\",\n+            };\n+            self.fmt.write_str(end)\n+        })\n+    }\n+\n+    fn is_pretty(&self) -> bool {\n+        self.fmt.flags() & (1 << (FlagV1::Alternate as usize)) != 0\n+    }\n+}\n+\n+/// A struct to help with `fmt::Debug` implementations.\n+///\n+/// Constructed by the `Formatter::debug_map` method.\n+#[must_use]\n+pub struct DebugMap<'a, 'b: 'a> {\n+    fmt: &'a mut fmt::Formatter<'b>,\n+    result: fmt::Result,\n+    has_fields: bool,\n+}\n+\n+pub fn debug_map_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>, name: &str) -> DebugMap<'a, 'b> {\n+    let result = write!(fmt, \"{} {{\", name);\n+    DebugMap {\n+        fmt: fmt,\n+        result: result,\n+        has_fields: false,\n+    }\n+}\n+\n+impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n+    /// Adds a new entry to the map output.\n+    #[unstable(feature = \"debug_builders\", reason = \"method was just created\")]\n+    pub fn entry(mut self, key: &fmt::Debug, value: &fmt::Debug) -> DebugMap<'a, 'b> {\n+        self.result = self.result.and_then(|_| {\n+            let prefix = if self.has_fields {\n+                \",\"\n+            } else {\n+                \"\"\n+            };\n+\n+            if self.is_pretty() {\n+                let mut writer = PadAdapter::new(self.fmt);\n+                fmt::write(&mut writer, format_args!(\"{}\\n{:#?}: {:#?}\", prefix, key, value))\n+            } else {\n+                write!(self.fmt, \"{} {:?}: {:?}\", prefix, key, value)\n+            }\n+        });\n+\n+        self.has_fields = true;\n+\n+        self\n+    }\n+\n+    /// Consumes the `DebugMap`, finishing output and returning any error\n+    /// encountered.\n+    #[unstable(feature = \"debug_builders\", reason = \"method was just created\")]\n+    pub fn finish(self) -> fmt::Result {\n+        self.result.and_then(|_| {\n+            let end = match (self.has_fields, self.is_pretty()) {\n+                (false, _) => \"}\",\n+                (true, false) => \" }\",\n+                (true, true) => \"\\n}\",\n+            };\n+            self.fmt.write_str(end)\n+        })\n+    }\n+\n+    fn is_pretty(&self) -> bool {\n+        self.fmt.flags() & (1 << (FlagV1::Alternate as usize)) != 0\n+    }\n+}"}, {"sha": "741cf7b47fa1e10236b031425a6926bc96c81b25", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 121, "deletions": 1, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/49f7550a25722fbdb779eef80afa85f6d802f7e8/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f7550a25722fbdb779eef80afa85f6d802f7e8/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=49f7550a25722fbdb779eef80afa85f6d802f7e8", "patch": "@@ -32,8 +32,11 @@ pub use self::num::radix;\n pub use self::num::Radix;\n pub use self::num::RadixFmt;\n \n+pub use self::builders::{DebugStruct, DebugTuple, DebugSet, DebugMap};\n+\n mod num;\n mod float;\n+mod builders;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(hidden)]\n@@ -425,7 +428,7 @@ impl<'a> Formatter<'a> {\n     /// # Arguments\n     ///\n     /// * is_positive - whether the original integer was positive or not.\n-    /// * prefix - if the '#' character (FlagAlternate) is provided, this\n+    /// * prefix - if the '#' character (Alternate) is provided, this\n     ///   is the prefix to put in front of the number.\n     /// * buf - the byte array that the number has been formatted into\n     ///\n@@ -614,6 +617,123 @@ impl<'a> Formatter<'a> {\n     /// Optionally specified precision for numeric types\n     #[unstable(feature = \"core\", reason = \"method was just created\")]\n     pub fn precision(&self) -> Option<usize> { self.precision }\n+\n+    /// Creates a `DebugStruct` builder designed to assist with creation of\n+    /// `fmt::Debug` implementations for structs.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo {\n+    ///     bar: i32,\n+    ///     baz: String,\n+    /// }\n+    ///\n+    /// impl fmt::Debug for Foo {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    ///         fmt.debug_struct(\"Foo\")\n+    ///             .field(\"bar\", &self.bar)\n+    ///             .field(\"baz\", &self.baz)\n+    ///             .finish()\n+    ///     }\n+    /// }\n+    ///\n+    /// // prints \"Foo { bar: 10, baz: \"Hello World\" }\"\n+    /// println!(\"{:?}\", Foo { bar: 10, baz: \"Hello World\".to_string() });\n+    /// ```\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    #[inline]\n+    pub fn debug_struct<'b>(&'b mut self, name: &str) -> DebugStruct<'b, 'a> {\n+        builders::debug_struct_new(self, name)\n+    }\n+\n+    /// Creates a `DebugTuple` builder designed to assist with creation of\n+    /// `fmt::Debug` implementations for tuple structs.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(i32, String);\n+    ///\n+    /// impl fmt::Debug for Foo {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    ///         fmt.debug_tuple(\"Foo\")\n+    ///             .field(&self.0)\n+    ///             .field(&self.1)\n+    ///             .finish()\n+    ///     }\n+    /// }\n+    ///\n+    /// // prints \"Foo(10, \"Hello World\")\"\n+    /// println!(\"{:?}\", Foo(10, \"Hello World\".to_string()));\n+    /// ```\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    #[inline]\n+    pub fn debug_tuple<'b>(&'b mut self, name: &str) -> DebugTuple<'b, 'a> {\n+        builders::debug_tuple_new(self, name)\n+    }\n+\n+    /// Creates a `DebugSet` builder designed to assist with creation of\n+    /// `fmt::Debug` implementations for set-like structures.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(Vec<i32>);\n+    ///\n+    /// impl fmt::Debug for Foo {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    ///         let mut builder = fmt.debug_set(\"Foo\");\n+    ///         for i in &self.0 {\n+    ///             builder = builder.entry(i);\n+    ///         }\n+    ///         builder.finish()\n+    ///     }\n+    /// }\n+    ///\n+    /// // prints \"Foo { 10, 11 }\"\n+    /// println!(\"{:?}\", Foo(vec![10, 11]));\n+    /// ```\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    #[inline]\n+    pub fn debug_set<'b>(&'b mut self, name: &str) -> DebugSet<'b, 'a> {\n+        builders::debug_set_new(self, name)\n+    }\n+\n+    /// Creates a `DebugMap` builder designed to assist with creation of\n+    /// `fmt::Debug` implementations for map-like structures.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(Vec<(String, i32)>);\n+    ///\n+    /// impl fmt::Debug for Foo {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    ///         let mut builder = fmt.debug_map(\"Foo\");\n+    ///         for &(ref key, ref value) in &self.0 {\n+    ///             builder = builder.entry(key, value);\n+    ///         }\n+    ///         builder.finish()\n+    ///     }\n+    /// }\n+    ///\n+    /// // prints \"Foo { \"A\": 10, \"B\": 11 }\"\n+    /// println!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)]));\n+    /// ```\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    #[inline]\n+    pub fn debug_map<'b>(&'b mut self, name: &str) -> DebugMap<'b, 'a> {\n+        builders::debug_map_new(self, name)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "b2fbc90be591423ce50d5406fbf5f72e7f931914", "filename": "src/libcoretest/fmt/builders.rs", "status": "added", "additions": 401, "deletions": 0, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/49f7550a25722fbdb779eef80afa85f6d802f7e8/src%2Flibcoretest%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f7550a25722fbdb779eef80afa85f6d802f7e8/src%2Flibcoretest%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fbuilders.rs?ref=49f7550a25722fbdb779eef80afa85f6d802f7e8", "patch": "@@ -0,0 +1,401 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod debug_struct {\n+    use std::fmt;\n+\n+    #[test]\n+    fn test_empty() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_struct(\"Foo\").finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo\", format!(\"{:?}\", Foo));\n+        assert_eq!(\"Foo\", format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_single() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_struct(\"Foo\")\n+                    .field(\"bar\", &true)\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo { bar: true }\", format!(\"{:?}\", Foo));\n+        assert_eq!(\n+\"Foo {\n+    bar: true\n+}\",\n+                   format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_multiple() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_struct(\"Foo\")\n+                    .field(\"bar\", &true)\n+                    .field(\"baz\", &format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo { bar: true, baz: 10/20 }\", format!(\"{:?}\", Foo));\n+        assert_eq!(\n+\"Foo {\n+    bar: true,\n+    baz: 10/20\n+}\",\n+                   format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_nested() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_struct(\"Foo\")\n+                    .field(\"bar\", &true)\n+                    .field(\"baz\", &format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .finish()\n+            }\n+        }\n+\n+        struct Bar;\n+\n+        impl fmt::Debug for Bar {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_struct(\"Bar\")\n+                    .field(\"foo\", &Foo)\n+                    .field(\"hello\", &\"world\")\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Bar { foo: Foo { bar: true, baz: 10/20 }, hello: \\\"world\\\" }\",\n+                   format!(\"{:?}\", Bar));\n+        assert_eq!(\n+\"Bar {\n+    foo: Foo {\n+        bar: true,\n+        baz: 10/20\n+    },\n+    hello: \\\"world\\\"\n+}\",\n+                   format!(\"{:#?}\", Bar));\n+    }\n+}\n+\n+mod debug_tuple {\n+    use std::fmt;\n+\n+    #[test]\n+    fn test_empty() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_tuple(\"Foo\").finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo\", format!(\"{:?}\", Foo));\n+        assert_eq!(\"Foo\", format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_single() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_tuple(\"Foo\")\n+                    .field(&true)\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo(true)\", format!(\"{:?}\", Foo));\n+        assert_eq!(\n+\"Foo(\n+    true\n+)\",\n+                   format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_multiple() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_tuple(\"Foo\")\n+                    .field(&true)\n+                    .field(&format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo(true, 10/20)\", format!(\"{:?}\", Foo));\n+        assert_eq!(\n+\"Foo(\n+    true,\n+    10/20\n+)\",\n+                   format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_nested() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_tuple(\"Foo\")\n+                    .field(&true)\n+                    .field(&format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .finish()\n+            }\n+        }\n+\n+        struct Bar;\n+\n+        impl fmt::Debug for Bar {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_tuple(\"Bar\")\n+                    .field(&Foo)\n+                    .field(&\"world\")\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Bar(Foo(true, 10/20), \\\"world\\\")\",\n+                   format!(\"{:?}\", Bar));\n+        assert_eq!(\n+\"Bar(\n+    Foo(\n+        true,\n+        10/20\n+    ),\n+    \\\"world\\\"\n+)\",\n+                   format!(\"{:#?}\", Bar));\n+    }\n+}\n+\n+mod debug_map {\n+    use std::fmt;\n+\n+    #[test]\n+    fn test_empty() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_map(\"Foo\").finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo {}\", format!(\"{:?}\", Foo));\n+        assert_eq!(\"Foo {}\", format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_single() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_map(\"Foo\")\n+                    .entry(&\"bar\", &true)\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo { \\\"bar\\\": true }\", format!(\"{:?}\", Foo));\n+        assert_eq!(\n+\"Foo {\n+    \\\"bar\\\": true\n+}\",\n+                   format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_multiple() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_map(\"Foo\")\n+                    .entry(&\"bar\", &true)\n+                    .entry(&10i32, &format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo { \\\"bar\\\": true, 10: 10/20 }\", format!(\"{:?}\", Foo));\n+        assert_eq!(\n+\"Foo {\n+    \\\"bar\\\": true,\n+    10: 10/20\n+}\",\n+                   format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_nested() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_map(\"Foo\")\n+                    .entry(&\"bar\", &true)\n+                    .entry(&10i32, &format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .finish()\n+            }\n+        }\n+\n+        struct Bar;\n+\n+        impl fmt::Debug for Bar {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_map(\"Bar\")\n+                    .entry(&\"foo\", &Foo)\n+                    .entry(&Foo, &\"world\")\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Bar { \\\"foo\\\": Foo { \\\"bar\\\": true, 10: 10/20 }, \\\n+                    Foo { \\\"bar\\\": true, 10: 10/20 }: \\\"world\\\" }\",\n+                   format!(\"{:?}\", Bar));\n+        assert_eq!(\n+\"Bar {\n+    \\\"foo\\\": Foo {\n+        \\\"bar\\\": true,\n+        10: 10/20\n+    },\n+    Foo {\n+        \\\"bar\\\": true,\n+        10: 10/20\n+    }: \\\"world\\\"\n+}\",\n+                   format!(\"{:#?}\", Bar));\n+    }\n+}\n+\n+mod debug_set {\n+    use std::fmt;\n+\n+    #[test]\n+    fn test_empty() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_set(\"Foo\").finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo {}\", format!(\"{:?}\", Foo));\n+        assert_eq!(\"Foo {}\", format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_single() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_set(\"Foo\")\n+                    .entry(&true)\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo { true }\", format!(\"{:?}\", Foo));\n+        assert_eq!(\n+\"Foo {\n+    true\n+}\",\n+                   format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_multiple() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_set(\"Foo\")\n+                    .entry(&true)\n+                    .entry(&format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo { true, 10/20 }\", format!(\"{:?}\", Foo));\n+        assert_eq!(\n+\"Foo {\n+    true,\n+    10/20\n+}\",\n+                   format!(\"{:#?}\", Foo));\n+    }\n+\n+    #[test]\n+    fn test_nested() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_set(\"Foo\")\n+                    .entry(&true)\n+                    .entry(&format_args!(\"{}/{}\", 10i32, 20i32))\n+                    .finish()\n+            }\n+        }\n+\n+        struct Bar;\n+\n+        impl fmt::Debug for Bar {\n+            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+                fmt.debug_set(\"Bar\")\n+                    .entry(&Foo)\n+                    .entry(&\"world\")\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(\"Bar { Foo { true, 10/20 }, \\\"world\\\" }\",\n+                   format!(\"{:?}\", Bar));\n+        assert_eq!(\n+\"Bar {\n+    Foo {\n+        true,\n+        10/20\n+    },\n+    \\\"world\\\"\n+}\",\n+                   format!(\"{:#?}\", Bar));\n+    }\n+}"}, {"sha": "cdb9c38f027f729d83c99f7c8d44e1170859c34c", "filename": "src/libcoretest/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49f7550a25722fbdb779eef80afa85f6d802f7e8/src%2Flibcoretest%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f7550a25722fbdb779eef80afa85f6d802f7e8/src%2Flibcoretest%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fmod.rs?ref=49f7550a25722fbdb779eef80afa85f6d802f7e8", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n mod num;\n+mod builders;\n \n #[test]\n fn test_format_flags() {"}, {"sha": "536bce0d05f0ba0781ab2b093e0ecac1fb199a14", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49f7550a25722fbdb779eef80afa85f6d802f7e8/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f7550a25722fbdb779eef80afa85f6d802f7e8/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=49f7550a25722fbdb779eef80afa85f6d802f7e8", "patch": "@@ -23,6 +23,7 @@\n #![feature(hash)]\n #![feature(io)]\n #![feature(collections)]\n+#![feature(debug_builders)]\n #![allow(deprecated)] // rand\n \n extern crate core;"}, {"sha": "70aab26092c440548a082bebf4d1ae230602ac6a", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49f7550a25722fbdb779eef80afa85f6d802f7e8/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f7550a25722fbdb779eef80afa85f6d802f7e8/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=49f7550a25722fbdb779eef80afa85f6d802f7e8", "patch": "@@ -848,7 +848,7 @@ impl CodeMap {\n \n                     let span_comes_from_this_expansion =\n                         info.callee.span.map_or(span == info.call_site, |mac_span| {\n-                            mac_span.lo <= span.lo && span.hi < mac_span.hi\n+                            mac_span.lo <= span.lo && span.hi <= mac_span.hi\n                         });\n \n                     debug!(\"span_allows_unstable: from this expansion? {}, allows unstable? {}\","}, {"sha": "ae9a402006095b3d08f42c13fa72ff1b03d6c860", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 40, "deletions": 62, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/49f7550a25722fbdb779eef80afa85f6d802f7e8/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f7550a25722fbdb779eef80afa85f6d802f7e8/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=49f7550a25722fbdb779eef80afa85f6d802f7e8", "patch": "@@ -11,16 +11,13 @@\n use ast;\n use ast::{MetaItem, Item, Expr,};\n use codemap::Span;\n-use ext::format;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token;\n use ptr::P;\n \n-use std::collections::HashMap;\n-\n pub fn expand_deriving_show<F>(cx: &mut ExtCtxt,\n                                span: Span,\n                                mitem: &MetaItem,\n@@ -56,14 +53,12 @@ pub fn expand_deriving_show<F>(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-/// We construct a format string and then defer to std::fmt, since that\n-/// knows what's up with formatting and so on.\n+/// We use the debug builders to do the heavy lifting here\n fn show_substructure(cx: &mut ExtCtxt, span: Span,\n                      substr: &Substructure) -> P<Expr> {\n-    // build `<name>`, `<name>({}, {}, ...)` or `<name> { <field>: {},\n-    // <field>: {}, ... }` based on the \"shape\".\n-    //\n-    // Easy start: they all start with the name.\n+    // build fmt.debug_struct(<name>).field(<fieldname>, &<fieldval>)....build()\n+    // or fmt.debug_tuple(<name>).field(&<fieldval>)....build()\n+    // based on the \"shape\".\n     let name = match *substr.fields {\n         Struct(_) => substr.type_ident,\n         EnumMatching(_, v, _) => v.node.name,\n@@ -72,70 +67,53 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n         }\n     };\n \n-    let mut format_string = String::from_str(&token::get_ident(name));\n-    // the internal fields we're actually formatting\n-    let mut exprs = Vec::new();\n+    // We want to make sure we have the expn_id set so that we can use unstable methods\n+    let span = Span { expn_id: cx.backtrace(), .. span };\n+    let name = cx.expr_lit(span, ast::Lit_::LitStr(token::get_ident(name),\n+                                                   ast::StrStyle::CookedStr));\n+    let mut expr = substr.nonself_args[0].clone();\n \n-    // Getting harder... making the format string:\n     match *substr.fields {\n-        // unit struct/nullary variant: no work necessary!\n-        Struct(ref fields) if fields.len() == 0 => {}\n-        EnumMatching(_, _, ref fields) if fields.len() == 0 => {}\n-\n         Struct(ref fields) | EnumMatching(_, _, ref fields) => {\n-            if fields[0].name.is_none() {\n+            if fields.is_empty() || fields[0].name.is_none() {\n                 // tuple struct/\"normal\" variant\n-\n-                format_string.push_str(\"(\");\n-\n-                for (i, field) in fields.iter().enumerate() {\n-                    if i != 0 { format_string.push_str(\", \"); }\n-\n-                    format_string.push_str(\"{:?}\");\n-\n-                    exprs.push(field.self_.clone());\n+                expr = cx.expr_method_call(span,\n+                                           expr,\n+                                           token::str_to_ident(\"debug_tuple\"),\n+                                           vec![name]);\n+\n+                for field in fields {\n+                    expr = cx.expr_method_call(span,\n+                                               expr,\n+                                               token::str_to_ident(\"field\"),\n+                                               vec![cx.expr_addr_of(field.span,\n+                                                                    field.self_.clone())]);\n                 }\n-\n-                format_string.push_str(\")\");\n             } else {\n                 // normal struct/struct variant\n-\n-                format_string.push_str(\" {{\");\n-\n-                for (i, field) in fields.iter().enumerate() {\n-                    if i != 0 { format_string.push_str(\",\"); }\n-\n-                    let name = token::get_ident(field.name.unwrap());\n-                    format_string.push_str(\" \");\n-                    format_string.push_str(&name);\n-                    format_string.push_str(\": {:?}\");\n-\n-                    exprs.push(field.self_.clone());\n+                expr = cx.expr_method_call(span,\n+                                           expr,\n+                                           token::str_to_ident(\"debug_struct\"),\n+                                           vec![name]);\n+\n+                for field in fields {\n+                    let name = cx.expr_lit(field.span, ast::Lit_::LitStr(\n+                            token::get_ident(field.name.clone().unwrap()),\n+                            ast::StrStyle::CookedStr));\n+                    expr = cx.expr_method_call(span,\n+                                               expr,\n+                                               token::str_to_ident(\"field\"),\n+                                               vec![name,\n+                                                    cx.expr_addr_of(field.span,\n+                                                                    field.self_.clone())]);\n                 }\n-\n-                format_string.push_str(\" }}\");\n             }\n         }\n         _ => unreachable!()\n     }\n \n-    // AST construction!\n-    // we're basically calling\n-    //\n-    // format_arg_method!(fmt, write_fmt, \"<format_string>\", exprs...)\n-    //\n-    // but doing it directly via ext::format.\n-    let formatter = substr.nonself_args[0].clone();\n-\n-    let meth = cx.ident_of(\"write_fmt\");\n-    let s = token::intern_and_get_ident(&format_string[..]);\n-    let format_string = cx.expr_str(span, s);\n-\n-    // phew, not our responsibility any more!\n-\n-    let args = vec![\n-        format::expand_preparsed_format_args(cx, span, format_string,\n-                                             exprs, vec![], HashMap::new())\n-    ];\n-    cx.expr_method_call(span, formatter, meth, args)\n+    cx.expr_method_call(span,\n+                        expr,\n+                        token::str_to_ident(\"finish\"),\n+                        vec![])\n }"}, {"sha": "6883395933ef17f151cac5ea73ac25be0be99906", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49f7550a25722fbdb779eef80afa85f6d802f7e8/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f7550a25722fbdb779eef80afa85f6d802f7e8/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=49f7550a25722fbdb779eef80afa85f6d802f7e8", "patch": "@@ -1121,7 +1121,7 @@ fn expand_annotatable(a: Annotatable,\n                         callee: NameAndSpan {\n                             name: mname.to_string(),\n                             format: MacroAttribute,\n-                            span: None,\n+                            span: Some(attr.span),\n                             // attributes can do whatever they like,\n                             // for now.\n                             allow_internal_unstable: true,"}]}