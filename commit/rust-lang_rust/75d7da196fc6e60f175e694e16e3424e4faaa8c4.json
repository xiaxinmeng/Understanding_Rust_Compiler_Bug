{"sha": "75d7da196fc6e60f175e694e16e3424e4faaa8c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ZDdkYTE5NmZjNmU2MGYxNzVlNjk0ZTE2ZTM0MjRlNGZhYWE4YzQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-07-23T15:07:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-23T15:07:10Z"}, "message": "Merge #9683\n\n9683: internal: Move out expression based `unqualified_path` completion tests r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "95736570928937208dca4a66d2780311b7e47914", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95736570928937208dca4a66d2780311b7e47914"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75d7da196fc6e60f175e694e16e3424e4faaa8c4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg+tseCRBK7hj4Ov3rIwAA8Q4IABhhMP8VOxD/OeDuAHLe3rKd\nbV6J+/2in9a+YGzMefBHFDOqYnl3KbQbdaCclIl8K8129selxE/Efe9DJ6cYg+p1\nIolRH15WqwHy1PKxysEbhO+gRJfMC8tZ1NYQJQs6aG4VU8RizHGfEOniZGla7nIJ\nWPmjWoEly1LCHSYzLBPeyik1p8Gqqjh2Fz2zLPnFHgpd/l6V8t+K3YbyXuJBtZuo\nAjfaka/VNLX3V0h87HWmSQfsaWRdDcvGIq4cN1bKZ1SLGBWYmWe1UTcSD3n8Ila5\nHZc+n3fAnQUZ6p2ALLoBwtauu/nUR95EfCGyQAvvwavVF/X1tL+QLLrVhAWeBjE=\n=OL/w\n-----END PGP SIGNATURE-----\n", "payload": "tree 95736570928937208dca4a66d2780311b7e47914\nparent 6494193adb5524e3df729b1a8b4043d25ff9db36\nparent 189440c7b55ce892fe931c42b02c4c8178a6cc0a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1627052830 +0000\ncommitter GitHub <noreply@github.com> 1627052830 +0000\n\nMerge #9683\n\n9683: internal: Move out expression based `unqualified_path` completion tests r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75d7da196fc6e60f175e694e16e3424e4faaa8c4", "html_url": "https://github.com/rust-lang/rust/commit/75d7da196fc6e60f175e694e16e3424e4faaa8c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75d7da196fc6e60f175e694e16e3424e4faaa8c4/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6494193adb5524e3df729b1a8b4043d25ff9db36", "url": "https://api.github.com/repos/rust-lang/rust/commits/6494193adb5524e3df729b1a8b4043d25ff9db36", "html_url": "https://github.com/rust-lang/rust/commit/6494193adb5524e3df729b1a8b4043d25ff9db36"}, {"sha": "189440c7b55ce892fe931c42b02c4c8178a6cc0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/189440c7b55ce892fe931c42b02c4c8178a6cc0a", "html_url": "https://github.com/rust-lang/rust/commit/189440c7b55ce892fe931c42b02c4c8178a6cc0a"}], "stats": {"total": 1001, "additions": 430, "deletions": 571}, "files": [{"sha": "6c05812bf85ce631283e88859b94b3a337cfd65b", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/75d7da196fc6e60f175e694e16e3424e4faaa8c4/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d7da196fc6e60f175e694e16e3424e4faaa8c4/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=75d7da196fc6e60f175e694e16e3424e4faaa8c4", "patch": "@@ -255,60 +255,6 @@ mod tests {\n         expect.assert_eq(&actual);\n     }\n \n-    fn check_builtin(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::BuiltinType);\n-        expect.assert_eq(&actual);\n-    }\n-\n-    #[test]\n-    fn dont_complete_primitive_in_use() {\n-        check_builtin(r#\"use self::$0;\"#, expect![[\"\"]]);\n-    }\n-\n-    #[test]\n-    fn dont_complete_primitive_in_module_scope() {\n-        check_builtin(r#\"fn foo() { self::$0 }\"#, expect![[\"\"]]);\n-    }\n-\n-    #[test]\n-    fn completes_enum_variant() {\n-        check(\n-            r#\"\n-enum E { Foo, Bar(i32) }\n-fn foo() { let _ = E::$0 }\n-\"#,\n-            expect![[r#\"\n-                ev Foo    ()\n-                ev Bar(\u2026) (i32)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_struct_associated_items() {\n-        check(\n-            r#\"\n-//- /lib.rs\n-struct S;\n-\n-impl S {\n-    fn a() {}\n-    fn b(&self) {}\n-    const C: i32 = 42;\n-    type T = i32;\n-}\n-\n-fn foo() { let _ = S::$0 }\n-\"#,\n-            expect![[r#\"\n-                fn a()  fn()\n-                me b(\u2026) fn(&self)\n-                ct C    const C: i32 = 42;\n-                ta T    type T = i32;\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn associated_item_visibility() {\n         check(\n@@ -336,21 +282,6 @@ fn foo() { let _ = S::$0 }\n         );\n     }\n \n-    #[test]\n-    fn completes_enum_associated_method() {\n-        check(\n-            r#\"\n-enum E {};\n-impl E { fn m() { } }\n-\n-fn foo() { let _ = E::$0 }\n-        \"#,\n-            expect![[r#\"\n-                fn m() fn()\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn completes_union_associated_method() {\n         check("}, {"sha": "151297042b8c9b96eb37d22c2536e499c65eec66", "filename": "crates/ide_completion/src/completions/record.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75d7da196fc6e60f175e694e16e3424e4faaa8c4/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d7da196fc6e60f175e694e16e3424e4faaa8c4/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=75d7da196fc6e60f175e694e16e3424e4faaa8c4", "patch": "@@ -47,7 +47,6 @@ pub(crate) fn complete_record(acc: &mut Completions, ctx: &CompletionContext) ->\n \n #[cfg(test)]\n mod tests {\n-\n     use crate::tests::check_edit;\n \n     #[test]"}, {"sha": "a896a759abfaf897e1b1550035e4a9ffceeb4a88", "filename": "crates/ide_completion/src/completions/snippet.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/75d7da196fc6e60f175e694e16e3424e4faaa8c4/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d7da196fc6e60f175e694e16e3424e4faaa8c4/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs?ref=75d7da196fc6e60f175e694e16e3424e4faaa8c4", "patch": "@@ -86,26 +86,3 @@ fn ${1:feature}() {\n     let item = snippet(ctx, cap, \"macro_rules\", \"macro_rules! $1 {\\n\\t($2) => {\\n\\t\\t$0\\n\\t};\\n}\");\n     item.add_to(acc);\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use expect_test::{expect, Expect};\n-\n-    use crate::{tests::filtered_completion_list, CompletionKind};\n-\n-    fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::Snippet);\n-        expect.assert_eq(&actual)\n-    }\n-\n-    #[test]\n-    fn completes_snippets_in_expressions() {\n-        check(\n-            r#\"fn foo(x: i32) { $0 }\"#,\n-            expect![[r#\"\n-                sn pd\n-                sn ppd\n-            \"#]],\n-        );\n-    }\n-}"}, {"sha": "8258026182b8b261414b60b8d525fb6fd78f4282", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 1, "deletions": 355, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/75d7da196fc6e60f175e694e16e3424e4faaa8c4/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d7da196fc6e60f175e694e16e3424e4faaa8c4/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=75d7da196fc6e60f175e694e16e3424e4faaa8c4", "patch": "@@ -87,7 +87,7 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n         if let ScopeDef::GenericParam(hir::GenericParam::LifetimeParam(_)) | ScopeDef::Label(_) =\n             res\n         {\n-            cov_mark::hit!(skip_lifetime_completion);\n+            cov_mark::hit!(unqualified_skip_lifetime_completion);\n             return;\n         }\n         let add_resolution = match res {\n@@ -135,61 +135,6 @@ mod tests {\n         expect.assert_eq(&actual)\n     }\n \n-    #[test]\n-    fn completes_bindings_from_let() {\n-        check(\n-            r#\"\n-fn quux(x: i32) {\n-    let y = 92;\n-    1 + $0;\n-    let z = ();\n-}\n-\"#,\n-            expect![[r#\"\n-                lc y       i32\n-                lc x       i32\n-                fn quux(\u2026) fn(i32)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_bindings_from_if_let() {\n-        check(\n-            r#\"\n-fn quux() {\n-    if let Some(x) = foo() {\n-        let y = 92;\n-    };\n-    if let Some(a) = bar() {\n-        let b = 62;\n-        1 + $0\n-    }\n-}\n-\"#,\n-            expect![[r#\"\n-                lc b      i32\n-                lc a\n-                fn quux() fn()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_bindings_from_for() {\n-        check(\n-            r#\"\n-fn quux() {\n-    for x in &[1, 2, 3] { $0 }\n-}\n-\"#,\n-            expect![[r#\"\n-                lc x\n-                fn quux() fn()\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn completes_if_prefix_is_keyword() {\n         cov_mark::check!(completes_if_prefix_is_keyword);\n@@ -210,51 +155,6 @@ fn main() {\n         )\n     }\n \n-    #[test]\n-    fn completes_generic_params() {\n-        check(\n-            r#\"fn quux<T>() { $0 }\"#,\n-            expect![[r#\"\n-                tp T\n-                fn quux() fn()\n-            \"#]],\n-        );\n-        check(\n-            r#\"fn quux<const C: usize>() { $0 }\"#,\n-            expect![[r#\"\n-                cp C\n-                fn quux() fn()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn does_not_complete_lifetimes() {\n-        cov_mark::check!(skip_lifetime_completion);\n-        check(\n-            r#\"fn quux<'a>() { $0 }\"#,\n-            expect![[r#\"\n-                fn quux() fn()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_module_items() {\n-        check(\n-            r#\"\n-struct S;\n-enum E {}\n-fn quux() { $0 }\n-\"#,\n-            expect![[r#\"\n-                st S\n-                fn quux() fn()\n-                en E\n-            \"#]],\n-        );\n-    }\n-\n     /// Regression test for issue #6091.\n     #[test]\n     fn correctly_completes_module_items_prefixed_with_underscore() {\n@@ -275,55 +175,6 @@ fn _alpha() {}\n         )\n     }\n \n-    #[test]\n-    fn completes_module_items_in_nested_modules() {\n-        check(\n-            r#\"\n-struct Foo;\n-mod m {\n-    struct Bar;\n-    fn quux() { $0 }\n-}\n-\"#,\n-            expect![[r#\"\n-                fn quux() fn()\n-                st Bar\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn dont_show_both_completions_for_shadowing() {\n-        check(\n-            r#\"\n-fn foo() {\n-    let bar = 92;\n-    {\n-        let bar = 62;\n-        drop($0)\n-    }\n-}\n-\"#,\n-            // FIXME: should be only one bar here\n-            expect![[r#\"\n-                lc bar   i32\n-                lc bar   i32\n-                fn foo() fn()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_self_in_methods() {\n-        check(\n-            r#\"impl S { fn foo(&self) { $0 } }\"#,\n-            expect![[r#\"\n-                lc self &{unknown}\n-                sp Self\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn completes_prelude() {\n         check(\n@@ -373,32 +224,6 @@ mod macros {\n         );\n     }\n \n-    #[test]\n-    fn does_not_complete_non_fn_macros() {\n-        check(\n-            r#\"\n-#[rustc_builtin_macro]\n-pub macro Clone {}\n-\n-fn f() {$0}\n-\"#,\n-            expect![[r#\"\n-                fn f() fn()\n-            \"#]],\n-        );\n-        check(\n-            r#\"\n-#[rustc_builtin_macro]\n-pub macro bench {}\n-\n-fn f() {$0}\n-\"#,\n-            expect![[r#\"\n-                fn f() fn()\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn completes_std_prelude_if_core_is_defined() {\n         check(\n@@ -427,183 +252,4 @@ pub mod prelude {\n             \"#]],\n         );\n     }\n-\n-    #[test]\n-    fn completes_macros_as_value() {\n-        check(\n-            r#\"\n-macro_rules! foo { () => {} }\n-\n-#[macro_use]\n-mod m1 {\n-    macro_rules! bar { () => {} }\n-}\n-\n-mod m2 {\n-    macro_rules! nope { () => {} }\n-\n-    #[macro_export]\n-    macro_rules! baz { () => {} }\n-}\n-\n-fn main() { let v = $0 }\n-\"#,\n-            expect![[r##\"\n-                md m1\n-                ma baz!(\u2026) #[macro_export] macro_rules! baz\n-                fn main()  fn()\n-                md m2\n-                ma bar!(\u2026) macro_rules! bar\n-                ma foo!(\u2026) macro_rules! foo\n-            \"##]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_both_macro_and_value() {\n-        check(\n-            r#\"\n-macro_rules! foo { () => {} }\n-fn foo() { $0 }\n-\"#,\n-            expect![[r#\"\n-                fn foo()   fn()\n-                ma foo!(\u2026) macro_rules! foo\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_macros_as_stmt() {\n-        check(\n-            r#\"\n-macro_rules! foo { () => {} }\n-fn main() { $0 }\n-\"#,\n-            expect![[r#\"\n-                fn main()  fn()\n-                ma foo!(\u2026) macro_rules! foo\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_local_item() {\n-        check(\n-            r#\"\n-fn main() {\n-    return f$0;\n-    fn frobnicate() {}\n-}\n-\"#,\n-            expect![[r#\"\n-                fn frobnicate() fn()\n-                fn main()       fn()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_in_simple_macro_1() {\n-        check(\n-            r#\"\n-macro_rules! m { ($e:expr) => { $e } }\n-fn quux(x: i32) {\n-    let y = 92;\n-    m!($0);\n-}\n-\"#,\n-            expect![[r#\"\n-                lc y       i32\n-                lc x       i32\n-                fn quux(\u2026) fn(i32)\n-                ma m!(\u2026)   macro_rules! m\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_in_simple_macro_2() {\n-        check(\n-            r\"\n-macro_rules! m { ($e:expr) => { $e } }\n-fn quux(x: i32) {\n-    let y = 92;\n-    m!(x$0);\n-}\n-\",\n-            expect![[r#\"\n-                lc y       i32\n-                lc x       i32\n-                fn quux(\u2026) fn(i32)\n-                ma m!(\u2026)   macro_rules! m\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_in_simple_macro_without_closing_parens() {\n-        check(\n-            r#\"\n-macro_rules! m { ($e:expr) => { $e } }\n-fn quux(x: i32) {\n-    let y = 92;\n-    m!(x$0\n-}\n-\"#,\n-            expect![[r#\"\n-                lc y       i32\n-                lc x       i32\n-                fn quux(\u2026) fn(i32)\n-                ma m!(\u2026)   macro_rules! m\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_unresolved_uses() {\n-        check(\n-            r#\"\n-use spam::Quux;\n-\n-fn main() { $0 }\n-\"#,\n-            expect![[r#\"\n-                fn main() fn()\n-                ?? Quux\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_enum_variant_basic_expr() {\n-        check(\n-            r#\"\n-enum Foo { Bar, Baz, Quux }\n-fn main() { let foo: Foo = Q$0 }\n-\"#,\n-            expect![[r#\"\n-                ev Foo::Bar  ()\n-                ev Foo::Baz  ()\n-                ev Foo::Quux ()\n-                en Foo\n-                fn main()    fn()\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn completes_enum_variant_from_module() {\n-        check(\n-            r#\"\n-mod m { pub enum E { V } }\n-fn f() -> m::E { V$0 }\n-\"#,\n-            expect![[r#\"\n-                ev m::E::V ()\n-                md m\n-                fn f()     fn() -> E\n-            \"#]],\n-        )\n-    }\n }"}, {"sha": "b8d60dfd2c3dbc398b6c5636c4b5007be77eb244", "filename": "crates/ide_completion/src/tests.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/75d7da196fc6e60f175e694e16e3424e4faaa8c4/crates%2Fide_completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d7da196fc6e60f175e694e16e3424e4faaa8c4/crates%2Fide_completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests.rs?ref=75d7da196fc6e60f175e694e16e3424e4faaa8c4", "patch": "@@ -1,13 +1,15 @@\n //! Tests and test utilities for completions.\n //!\n-//! Most tests live in this module or its submodules unless for very specific completions like\n-//! `attributes` or `lifetimes` where the completed concept is a distinct thing.\n-//! Notable examples for completions that are being tested in this module's submodule are paths.\n-//! Another exception are `check_edit` tests which usually live in the completion modules themselves,\n-//! as the main purpose of this test module here is to give the developer an overview of whats being\n-//! completed where, not how.\n+//! Most tests live in this module or its submodules. The tests in these submodules are \"location\"\n+//! oriented, that is they try to check completions for something like type position, param position\n+//! etc.\n+//! Tests that are more orientated towards specific completion types like visibility checks of path\n+//! completions or `check_edit` tests usually live in their respective completion modules instead.\n+//! This gives this test module and its submodules here the main purpose of giving the developer an\n+//! overview of whats being completed where, not how.\n \n mod attribute;\n+mod expression;\n mod fn_param;\n mod item_list;\n mod item;\n@@ -38,7 +40,7 @@ use test_utils::assert_eq_text;\n use crate::{item::CompletionKind, CompletionConfig, CompletionItem};\n \n /// Lots of basic item definitions\n-const BASE_FIXTURE: &str = r#\"\n+const BASE_ITEMS_FIXTURE: &str = r#\"\n enum Enum { TupleV(u32), RecordV { field: u32 }, UnitV }\n use self::Enum::TupleV;\n mod module {}\n@@ -53,6 +55,8 @@ struct Unit;\n macro_rules! makro {}\n #[rustc_builtin_macro]\n pub macro Clone {}\n+fn function() {}\n+union Union { field: i32 }\n \"#;\n \n pub(crate) const TEST_CONFIG: CompletionConfig = CompletionConfig {"}, {"sha": "cf22fb20ab1e1306576d06c132da655a9b8efa43", "filename": "crates/ide_completion/src/tests/expression.rs", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/75d7da196fc6e60f175e694e16e3424e4faaa8c4/crates%2Fide_completion%2Fsrc%2Ftests%2Fexpression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d7da196fc6e60f175e694e16e3424e4faaa8c4/crates%2Fide_completion%2Fsrc%2Ftests%2Fexpression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fexpression.rs?ref=75d7da196fc6e60f175e694e16e3424e4faaa8c4", "patch": "@@ -0,0 +1,304 @@\n+//! Completion tests for expressions.\n+use expect_test::{expect, Expect};\n+\n+use crate::tests::{completion_list, BASE_ITEMS_FIXTURE};\n+\n+fn check(ra_fixture: &str, expect: Expect) {\n+    let actual = completion_list(&format!(\"{}{}\", BASE_ITEMS_FIXTURE, ra_fixture));\n+    expect.assert_eq(&actual)\n+}\n+\n+fn check_empty(ra_fixture: &str, expect: Expect) {\n+    let actual = completion_list(ra_fixture);\n+    expect.assert_eq(&actual);\n+}\n+\n+#[test]\n+fn completes_various_bindings() {\n+    check_empty(\n+        r#\"\n+fn func(param0 @ (param1, param2): (i32, i32)) {\n+    let letlocal = 92;\n+    if let ifletlocal = 100 {\n+        match 0 {\n+            matcharm => 1 + $0,\n+            otherwise => (),\n+        }\n+    }\n+    let letlocal2 = 44;\n+}\n+\"#,\n+        expect![[r#\"\n+            kw unsafe\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw return\n+            kw self\n+            kw super\n+            kw crate\n+            lc matcharm   i32\n+            lc ifletlocal i32\n+            lc letlocal   i32\n+            lc param0     (i32, i32)\n+            lc param1     i32\n+            lc param2     i32\n+            fn func(\u2026)    fn((i32, i32))\n+            bt u32\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_all_the_things() {\n+    cov_mark::check!(unqualified_skip_lifetime_completion);\n+    check(\n+        r#\"\n+use non_existant::Unresolved;\n+mod qualified { pub enum Enum { Variant } }\n+\n+impl Unit {\n+    fn foo<'lifetime, TypeParam, const CONST_PARAM: usize>(self) {\n+        fn local_func() {}\n+        $0\n+    }\n+}\n+\"#,\n+        // `self` is in here twice, once as the module, once as the local\n+        expect![[r##\"\n+            kw unsafe\n+            kw fn\n+            kw const\n+            kw type\n+            kw impl\n+            kw extern\n+            kw use\n+            kw trait\n+            kw static\n+            kw mod\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw let\n+            kw return\n+            sn pd\n+            sn ppd\n+            kw self\n+            kw super\n+            kw crate\n+            fn local_func() fn()\n+            bt u32\n+            lc self         Unit\n+            tp TypeParam\n+            cp CONST_PARAM\n+            sp Self\n+            tt Trait\n+            en Enum\n+            st Record\n+            st Tuple\n+            md module\n+            st Unit\n+            md qualified\n+            ma makro!(\u2026)    #[macro_export] macro_rules! makro\n+            ?? Unresolved\n+            fn function()   fn()\n+            sc STATIC\n+            un Union\n+            ev TupleV(\u2026)    (u32)\n+            ct CONST\n+            ma makro!(\u2026)    #[macro_export] macro_rules! makro\n+            me self.foo()   fn(self)\n+        \"##]],\n+    );\n+    check(\n+        r#\"\n+use non_existant::Unresolved;\n+mod qualified { pub enum Enum { Variant } }\n+\n+impl Unit {\n+    fn foo<'lifetime, TypeParam, const CONST_PARAM: usize>(self) {\n+        fn local_func() {}\n+        self::$0\n+    }\n+}\n+\"#,\n+        expect![[r##\"\n+            tt Trait\n+            en Enum\n+            st Record\n+            st Tuple\n+            md module\n+            st Unit\n+            md qualified\n+            ma makro!(\u2026)  #[macro_export] macro_rules! makro\n+            ?? Unresolved\n+            fn function() fn()\n+            sc STATIC\n+            un Union\n+            ev TupleV(\u2026)  (u32)\n+            ct CONST\n+        \"##]],\n+    );\n+}\n+\n+#[test]\n+fn shadowing_shows_single_completion() {\n+    check_empty(\n+        r#\"\n+fn foo() {\n+    let bar = 92;\n+    {\n+        let bar = 62;\n+        drop($0)\n+    }\n+}\n+\"#,\n+        // FIXME: should be only one bar here\n+        expect![[r#\"\n+            kw unsafe\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw return\n+            kw self\n+            kw super\n+            kw crate\n+            lc bar       i32\n+            lc bar       i32\n+            fn foo()     fn()\n+            bt u32\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn in_macro_expr_frag() {\n+    check_empty(\n+        r#\"\n+macro_rules! m { ($e:expr) => { $e } }\n+fn quux(x: i32) {\n+    m!($0);\n+}\n+\"#,\n+        expect![[r#\"\n+            kw unsafe\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw return\n+            kw self\n+            kw super\n+            kw crate\n+            bt u32\n+            lc x         i32\n+            fn quux(\u2026)   fn(i32)\n+            ma m!(\u2026)     macro_rules! m\n+        \"#]],\n+    );\n+    check_empty(\n+        r\"\n+macro_rules! m { ($e:expr) => { $e } }\n+fn quux(x: i32) {\n+    m!(x$0);\n+}\n+\",\n+        expect![[r#\"\n+            kw unsafe\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw return\n+            kw self\n+            kw super\n+            kw crate\n+            bt u32\n+            lc x         i32\n+            fn quux(\u2026)   fn(i32)\n+            ma m!(\u2026)     macro_rules! m\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+macro_rules! m { ($e:expr) => { $e } }\n+fn quux(x: i32) {\n+    let y = 92;\n+    m!(x$0\n+}\n+\"#,\n+        expect![[r#\"\n+            kw unsafe\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw return\n+            kw self\n+            kw super\n+            kw crate\n+            lc y         i32\n+            bt u32\n+            lc x         i32\n+            fn quux(\u2026)   fn(i32)\n+            ma m!(\u2026)     macro_rules! m\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn enum_qualified() {\n+    check(\n+        r#\"\n+impl Enum {\n+    type AssocType = ();\n+    const ASSOC_CONST: () = ();\n+    fn assoc_fn() {}\n+}\n+fn func() {\n+    Enum::$0\n+}\n+\"#,\n+        expect![[r#\"\n+            ev TupleV(\u2026)   (u32)\n+            ev RecordV     { field: u32 }\n+            ev UnitV       ()\n+            ct ASSOC_CONST const ASSOC_CONST: () = ();\n+            fn assoc_fn()  fn()\n+            ta AssocType   type AssocType = ();\n+        \"#]],\n+    );\n+}"}, {"sha": "ad87bdc7513d26f18147921732a6049c26d5818a", "filename": "crates/ide_completion/src/tests/item.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/75d7da196fc6e60f175e694e16e3424e4faaa8c4/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d7da196fc6e60f175e694e16e3424e4faaa8c4/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem.rs?ref=75d7da196fc6e60f175e694e16e3424e4faaa8c4", "patch": "@@ -4,10 +4,10 @@\n //! in [crate::completions::mod_].\n use expect_test::{expect, Expect};\n \n-use crate::tests::{completion_list, BASE_FIXTURE};\n+use crate::tests::{completion_list, BASE_ITEMS_FIXTURE};\n \n fn check(ra_fixture: &str, expect: Expect) {\n-    let actual = completion_list(&format!(\"{}{}\", BASE_FIXTURE, ra_fixture));\n+    let actual = completion_list(&format!(\"{}{}\", BASE_ITEMS_FIXTURE, ra_fixture));\n     expect.assert_eq(&actual)\n }\n \n@@ -25,10 +25,11 @@ impl Tra$0\n             en Enum\n             st Record\n             st Tuple\n-            ma makro!(\u2026) #[macro_export] macro_rules! makro\n             md module\n             st Unit\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            un Union\n+            ma makro!(\u2026) #[macro_export] macro_rules! makro\n             bt u32\n         \"##]],\n     )\n@@ -48,10 +49,11 @@ impl Trait for Str$0\n             en Enum\n             st Record\n             st Tuple\n-            ma makro!(\u2026) #[macro_export] macro_rules! makro\n             md module\n             st Unit\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            un Union\n+            ma makro!(\u2026) #[macro_export] macro_rules! makro\n             bt u32\n         \"##]],\n     )"}, {"sha": "bd8df49e41e7e27c5f1737a56beb44f5c9786ded", "filename": "crates/ide_completion/src/tests/item_list.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/75d7da196fc6e60f175e694e16e3424e4faaa8c4/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d7da196fc6e60f175e694e16e3424e4faaa8c4/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem_list.rs?ref=75d7da196fc6e60f175e694e16e3424e4faaa8c4", "patch": "@@ -1,10 +1,10 @@\n //! Completion tests for item list position.\n use expect_test::{expect, Expect};\n \n-use crate::tests::{completion_list, BASE_FIXTURE};\n+use crate::tests::{completion_list, BASE_ITEMS_FIXTURE};\n \n fn check(ra_fixture: &str, expect: Expect) {\n-    let actual = completion_list(&format!(\"{}{}\", BASE_FIXTURE, ra_fixture));\n+    let actual = completion_list(&format!(\"{}{}\", BASE_ITEMS_FIXTURE, ra_fixture));\n     expect.assert_eq(&actual)\n }\n \n@@ -65,9 +65,9 @@ fn in_source_file_item_list() {\n             kw self\n             kw super\n             kw crate\n-            ma makro!(\u2026)           #[macro_export] macro_rules! makro\n             md module\n             ma makro!(\u2026)           #[macro_export] macro_rules! makro\n+            ma makro!(\u2026)           #[macro_export] macro_rules! makro\n         \"##]],\n     )\n }\n@@ -105,8 +105,8 @@ fn in_qualified_path() {\n     check(\n         r#\"crate::$0\"#,\n         expect![[r##\"\n-            ma makro!(\u2026) #[macro_export] macro_rules! makro\n             md module\n+            ma makro!(\u2026) #[macro_export] macro_rules! makro\n         \"##]],\n     )\n }\n@@ -170,9 +170,9 @@ fn in_impl_assoc_item_list() {\n             kw self\n             kw super\n             kw crate\n-            ma makro!(\u2026)  #[macro_export] macro_rules! makro\n             md module\n             ma makro!(\u2026)  #[macro_export] macro_rules! makro\n+            ma makro!(\u2026)  #[macro_export] macro_rules! makro\n         \"##]],\n     )\n }"}, {"sha": "5791921e448282f0c3282bb05e2f13b28cbb7fd6", "filename": "crates/ide_completion/src/tests/pattern.rs", "status": "modified", "additions": 36, "deletions": 61, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/75d7da196fc6e60f175e694e16e3424e4faaa8c4/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d7da196fc6e60f175e694e16e3424e4faaa8c4/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs?ref=75d7da196fc6e60f175e694e16e3424e4faaa8c4", "patch": "@@ -1,21 +1,21 @@\n //! Completion tests for pattern position.\n use expect_test::{expect, Expect};\n \n-use crate::tests::{completion_list, BASE_FIXTURE};\n+use crate::tests::{completion_list, BASE_ITEMS_FIXTURE};\n \n-fn check(ra_fixture: &str, expect: Expect) {\n+fn check_empty(ra_fixture: &str, expect: Expect) {\n     let actual = completion_list(ra_fixture);\n     expect.assert_eq(&actual)\n }\n \n-fn check_with(ra_fixture: &str, expect: Expect) {\n-    let actual = completion_list(&format!(\"{}\\n{}\", BASE_FIXTURE, ra_fixture));\n+fn check(ra_fixture: &str, expect: Expect) {\n+    let actual = completion_list(&format!(\"{}\\n{}\", BASE_ITEMS_FIXTURE, ra_fixture));\n     expect.assert_eq(&actual)\n }\n \n #[test]\n fn ident_rebind_pat() {\n-    check(\n+    check_empty(\n         r#\"\n fn quux() {\n     let en$0 @ x\n@@ -29,7 +29,7 @@ fn quux() {\n \n #[test]\n fn ident_ref_pat() {\n-    check(\n+    check_empty(\n         r#\"\n fn quux() {\n     let ref en$0\n@@ -39,7 +39,7 @@ fn quux() {\n             kw mut\n         \"#]],\n     );\n-    check(\n+    check_empty(\n         r#\"\n fn quux() {\n     let ref en$0 @ x\n@@ -54,7 +54,7 @@ fn quux() {\n #[test]\n fn ident_ref_mut_pat() {\n     // FIXME mut is already here, don't complete it again\n-    check(\n+    check_empty(\n         r#\"\n fn quux() {\n     let ref mut en$0\n@@ -64,7 +64,7 @@ fn quux() {\n             kw mut\n         \"#]],\n     );\n-    check(\n+    check_empty(\n         r#\"\n fn quux() {\n     let ref mut en$0 @ x\n@@ -78,7 +78,7 @@ fn quux() {\n \n #[test]\n fn ref_pat() {\n-    check(\n+    check_empty(\n         r#\"\n fn quux() {\n     let &en$0\n@@ -89,7 +89,7 @@ fn quux() {\n         \"#]],\n     );\n     // FIXME mut is already here, don't complete it again\n-    check(\n+    check_empty(\n         r#\"\n fn quux() {\n     let &mut en$0\n@@ -103,7 +103,7 @@ fn quux() {\n \n #[test]\n fn refutable() {\n-    check_with(\n+    check(\n         r#\"\n fn foo() {\n     if let a$0\n@@ -129,7 +129,7 @@ fn foo() {\n \n #[test]\n fn irrefutable() {\n-    check_with(\n+    check(\n         r#\"\n fn foo() {\n    let a$0\n@@ -150,7 +150,7 @@ fn foo() {\n \n #[test]\n fn in_param() {\n-    check_with(\n+    check(\n         r#\"\n fn foo(a$0) {\n }\n@@ -170,7 +170,7 @@ fn foo(a$0) {\n \n #[test]\n fn only_fn_like_macros() {\n-    check(\n+    check_empty(\n         r#\"\n macro_rules! m { ($e:expr) => { $e } }\n \n@@ -190,7 +190,7 @@ fn foo() {\n \n #[test]\n fn in_simple_macro_call() {\n-    check(\n+    check_empty(\n         r#\"\n macro_rules! m { ($e:expr) => { $e } }\n enum E { X }\n@@ -210,7 +210,7 @@ fn foo() {\n \n #[test]\n fn omits_private_fields_pat() {\n-    check(\n+    check_empty(\n         r#\"\n mod foo {\n     pub struct Record { pub field: i32, _field: i32 }\n@@ -235,32 +235,9 @@ fn outer() {\n     )\n }\n \n-// #[test]\n-// fn only_shows_ident_completion() {\n-//     check_edit(\n-//         \"Foo\",\n-//         r#\"\n-// struct Foo(i32);\n-// fn main() {\n-//     match Foo(92) {\n-//         a$0(92) => (),\n-//     }\n-// }\n-// \"#,\n-//         r#\"\n-// struct Foo(i32);\n-// fn main() {\n-//     match Foo(92) {\n-//         Foo(92) => (),\n-//     }\n-// }\n-// \"#,\n-//     );\n-// }\n-\n #[test]\n fn completes_self_pats() {\n-    check(\n+    check_empty(\n         r#\"\n struct Foo(i32);\n impl Foo {\n@@ -282,35 +259,33 @@ impl Foo {\n }\n \n #[test]\n-fn completes_qualified_variant() {\n+fn enum_qualified() {\n+    // FIXME: Don't show functions, they aren't patterns\n     check(\n         r#\"\n-enum Foo {\n-    Bar { baz: i32 }\n+impl Enum {\n+    type AssocType = ();\n+    const ASSOC_CONST: () = ();\n+    fn assoc_fn() {}\n }\n-impl Foo {\n-    fn foo() {\n-        match {Foo::Bar { baz: 0 }} {\n-            B$0\n-        }\n-    }\n+fn func() {\n+    if let Enum::$0 = unknown {}\n }\n-    \"#,\n+\"#,\n         expect![[r#\"\n-            kw mut\n-            bn Self::Bar Self::Bar { baz$1 }$0\n-            ev Self::Bar { baz: i32 }\n-            bn Foo::Bar  Foo::Bar { baz$1 }$0\n-            ev Foo::Bar  { baz: i32 }\n-            sp Self\n-            en Foo\n+            ev TupleV(\u2026)   (u32)\n+            ev RecordV     { field: u32 }\n+            ev UnitV       ()\n+            ct ASSOC_CONST const ASSOC_CONST: () = ();\n+            fn assoc_fn()  fn()\n+            ta AssocType   type AssocType = ();\n         \"#]],\n-    )\n+    );\n }\n \n #[test]\n fn completes_in_record_field_pat() {\n-    check(\n+    check_empty(\n         r#\"\n struct Foo { bar: Bar }\n struct Bar(u32);\n@@ -328,7 +303,7 @@ fn outer(Foo { bar: $0 }: Foo) {}\n \n #[test]\n fn skips_in_record_field_pat_name() {\n-    check(\n+    check_empty(\n         r#\"\n struct Foo { bar: Bar }\n struct Bar(u32);"}, {"sha": "d43e4b50b13c75778aaeb6570dfb2be667d002f5", "filename": "crates/ide_completion/src/tests/predicate.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/75d7da196fc6e60f175e694e16e3424e4faaa8c4/crates%2Fide_completion%2Fsrc%2Ftests%2Fpredicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d7da196fc6e60f175e694e16e3424e4faaa8c4/crates%2Fide_completion%2Fsrc%2Ftests%2Fpredicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fpredicate.rs?ref=75d7da196fc6e60f175e694e16e3424e4faaa8c4", "patch": "@@ -1,10 +1,10 @@\n //! Completion tests for predicates and bounds.\n use expect_test::{expect, Expect};\n \n-use crate::tests::{completion_list, BASE_FIXTURE};\n+use crate::tests::{completion_list, BASE_ITEMS_FIXTURE};\n \n fn check(ra_fixture: &str, expect: Expect) {\n-    let actual = completion_list(&format!(\"{}\\n{}\", BASE_FIXTURE, ra_fixture));\n+    let actual = completion_list(&format!(\"{}\\n{}\", BASE_ITEMS_FIXTURE, ra_fixture));\n     expect.assert_eq(&actual)\n }\n \n@@ -27,6 +27,7 @@ struct Foo<'lt, T, const C: usize> where $0 {}\n             st Foo<\u2026>\n             st Unit\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            un Union\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n             bt u32\n         \"##]],\n@@ -107,6 +108,7 @@ struct Foo<'lt, T, const C: usize> where for<'a> $0 {}\n             st Foo<\u2026>\n             st Unit\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            un Union\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n             bt u32\n         \"##]],\n@@ -130,10 +132,11 @@ impl Record {\n             en Enum\n             st Record\n             st Tuple\n-            ma makro!(\u2026) #[macro_export] macro_rules! makro\n             md module\n             st Unit\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            un Union\n+            ma makro!(\u2026) #[macro_export] macro_rules! makro\n             bt u32\n         \"##]],\n     );"}, {"sha": "88146357ca7ef5e6b54c79ae628fcac193671fb6", "filename": "crates/ide_completion/src/tests/type_pos.rs", "status": "modified", "additions": 61, "deletions": 43, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/75d7da196fc6e60f175e694e16e3424e4faaa8c4/crates%2Fide_completion%2Fsrc%2Ftests%2Ftype_pos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d7da196fc6e60f175e694e16e3424e4faaa8c4/crates%2Fide_completion%2Fsrc%2Ftests%2Ftype_pos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Ftype_pos.rs?ref=75d7da196fc6e60f175e694e16e3424e4faaa8c4", "patch": "@@ -1,35 +1,22 @@\n //! Completion tests for type position.\n use expect_test::{expect, Expect};\n \n-use crate::tests::completion_list;\n+use crate::tests::{completion_list, BASE_ITEMS_FIXTURE};\n \n-fn check_with(ra_fixture: &str, expect: Expect) {\n-    let base = r#\"\n-enum Enum { TupleV(u32), RecordV { field: u32 }, UnitV }\n-use self::Enum::TupleV;\n-mod module {}\n-\n-trait Trait {}\n-static STATIC: Unit = Unit;\n-const CONST: Unit = Unit;\n-struct Record { field: u32 }\n-struct Tuple(u32);\n-struct Unit\n-macro_rules! makro {}\n-\"#;\n-    let actual = completion_list(&format!(\"{}\\n{}\", base, ra_fixture));\n+fn check(ra_fixture: &str, expect: Expect) {\n+    let actual = completion_list(&format!(\"{}\\n{}\", BASE_ITEMS_FIXTURE, ra_fixture));\n     expect.assert_eq(&actual)\n }\n \n #[test]\n fn record_field_ty() {\n-    check_with(\n+    check(\n         r#\"\n struct Foo<'lt, T, const C: usize> {\n     f: $0\n }\n \"#,\n-        expect![[r#\"\n+        expect![[r##\"\n             kw self\n             kw super\n             kw crate\n@@ -42,19 +29,21 @@ struct Foo<'lt, T, const C: usize> {\n             md module\n             st Foo<\u2026>\n             st Unit\n-            ma makro!(\u2026) macro_rules! makro\n+            ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            un Union\n+            ma makro!(\u2026) #[macro_export] macro_rules! makro\n             bt u32\n-        \"#]],\n+        \"##]],\n     )\n }\n \n #[test]\n fn tuple_struct_field() {\n-    check_with(\n+    check(\n         r#\"\n struct Foo<'lt, T, const C: usize>(f$0);\n \"#,\n-        expect![[r#\"\n+        expect![[r##\"\n             kw pub(crate)\n             kw pub\n             kw self\n@@ -69,19 +58,21 @@ struct Foo<'lt, T, const C: usize>(f$0);\n             md module\n             st Foo<\u2026>\n             st Unit\n-            ma makro!(\u2026)  macro_rules! makro\n+            ma makro!(\u2026)  #[macro_export] macro_rules! makro\n+            un Union\n+            ma makro!(\u2026)  #[macro_export] macro_rules! makro\n             bt u32\n-        \"#]],\n+        \"##]],\n     )\n }\n \n #[test]\n fn fn_return_type() {\n-    check_with(\n+    check(\n         r#\"\n fn x<'lt, T, const C: usize>() -> $0\n \"#,\n-        expect![[r#\"\n+        expect![[r##\"\n             kw self\n             kw super\n             kw crate\n@@ -92,22 +83,24 @@ fn x<'lt, T, const C: usize>() -> $0\n             st Tuple\n             md module\n             st Unit\n-            ma makro!(\u2026) macro_rules! makro\n+            ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            un Union\n+            ma makro!(\u2026) #[macro_export] macro_rules! makro\n             bt u32\n-        \"#]],\n+        \"##]],\n     );\n }\n \n #[test]\n fn body_type_pos() {\n-    check_with(\n+    check(\n         r#\"\n fn foo<'lt, T, const C: usize>() {\n     let local = ();\n     let _: $0;\n }\n \"#,\n-        expect![[r#\"\n+        expect![[r##\"\n             kw self\n             kw super\n             kw crate\n@@ -118,39 +111,43 @@ fn foo<'lt, T, const C: usize>() {\n             st Tuple\n             md module\n             st Unit\n-            ma makro!(\u2026) macro_rules! makro\n+            ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            un Union\n+            ma makro!(\u2026) #[macro_export] macro_rules! makro\n             bt u32\n-        \"#]],\n+        \"##]],\n     );\n-    check_with(\n+    check(\n         r#\"\n fn foo<'lt, T, const C: usize>() {\n     let local = ();\n     let _: self::$0;\n }\n \"#,\n-        expect![[r#\"\n+        expect![[r##\"\n             tt Trait\n             en Enum\n             st Record\n             st Tuple\n             md module\n             st Unit\n-        \"#]],\n+            ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            un Union\n+        \"##]],\n     );\n }\n \n #[test]\n fn completes_types_and_const_in_arg_list() {\n-    check_with(\n+    check(\n         r#\"\n trait Trait2 {\n     type Foo;\n }\n \n fn foo<'lt, T: Trait2<$0>, const CONST_PARAM: usize>(_: T) {}\n \"#,\n-        expect![[r#\"\n+        expect![[r##\"\n             kw self\n             kw super\n             kw crate\n@@ -161,31 +158,52 @@ fn foo<'lt, T: Trait2<$0>, const CONST_PARAM: usize>(_: T) {}\n             en Enum\n             st Record\n             st Tuple\n-            tt Trait2\n             md module\n             st Unit\n+            ma makro!(\u2026)          #[macro_export] macro_rules! makro\n+            tt Trait2\n+            un Union\n             ct CONST\n-            ma makro!(\u2026)          macro_rules! makro\n+            ma makro!(\u2026)          #[macro_export] macro_rules! makro\n             bt u32\n-        \"#]],\n+        \"##]],\n     );\n-    check_with(\n+    check(\n         r#\"\n trait Trait2 {\n     type Foo;\n }\n \n fn foo<'lt, T: Trait2<self::$0>, const CONST_PARAM: usize>(_: T) {}\n     \"#,\n-        expect![[r#\"\n+        expect![[r##\"\n             tt Trait\n             en Enum\n             st Record\n             st Tuple\n-            tt Trait2\n             md module\n             st Unit\n+            ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            tt Trait2\n+            un Union\n             ct CONST\n+        \"##]],\n+    );\n+}\n+\n+#[test]\n+fn enum_qualified() {\n+    check(\n+        r#\"\n+impl Enum {\n+    type AssocType = ();\n+    const ASSOC_CONST: () = ();\n+    fn assoc_fn() {}\n+}\n+fn func(_: Enum::$0) {}\n+\"#,\n+        expect![[r#\"\n+            ta AssocType type AssocType = ();\n         \"#]],\n     );\n }"}]}