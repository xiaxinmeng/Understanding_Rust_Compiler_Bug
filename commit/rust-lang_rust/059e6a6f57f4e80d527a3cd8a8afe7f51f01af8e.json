{"sha": "059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1OWU2YTZmNTdmNGU4MGQ1MjdhM2NkOGE4YWZlN2Y1MWYwMWFmOGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-08T03:50:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-08T03:50:16Z"}, "message": "Auto merge of #56578 - alexreg:cosmetic-1, r=alexreg\n\nVarious minor/cosmetic improvements to code\n\nr? @Centril \ud83d\ude04", "tree": {"sha": "90e0d7a855be8202279b6bdde6cbdc95d834f07a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90e0d7a855be8202279b6bdde6cbdc95d834f07a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "html_url": "https://github.com/rust-lang/rust/commit/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a7798079608b4ff014471ae64b6c8201aa59cdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a7798079608b4ff014471ae64b6c8201aa59cdf", "html_url": "https://github.com/rust-lang/rust/commit/0a7798079608b4ff014471ae64b6c8201aa59cdf"}, {"sha": "003c5b796eae78c8c260bfddfc332a69926a6152", "url": "https://api.github.com/repos/rust-lang/rust/commits/003c5b796eae78c8c260bfddfc332a69926a6152", "html_url": "https://github.com/rust-lang/rust/commit/003c5b796eae78c8c260bfddfc332a69926a6152"}], "stats": {"total": 4421, "additions": 2187, "deletions": 2234}, "files": [{"sha": "b3682850de75836b7841345fdff66417c6c6fac6", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -793,7 +793,7 @@ impl<'a> Builder<'a> {\n         }\n \n         // Set a flag for `check` so that certain build scripts can do less work\n-        // (e.g. not building/requiring LLVM).\n+        // (e.g., not building/requiring LLVM).\n         if cmd == \"check\" {\n             cargo.env(\"RUST_CHECK\", \"1\");\n         }\n@@ -923,12 +923,12 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUSTC_FORCE_UNSTABLE\", \"1\");\n \n             // Currently the compiler depends on crates from crates.io, and\n-            // then other crates can depend on the compiler (e.g. proc-macro\n+            // then other crates can depend on the compiler (e.g., proc-macro\n             // crates). Let's say, for example that rustc itself depends on the\n             // bitflags crate. If an external crate then depends on the\n             // bitflags crate as well, we need to make sure they don't\n             // conflict, even if they pick the same version of bitflags. We'll\n-            // want to make sure that e.g. a plugin and rustc each get their\n+            // want to make sure that e.g., a plugin and rustc each get their\n             // own copy of bitflags.\n \n             // Cargo ensures that this works in general through the -C metadata"}, {"sha": "1ae494bfd44c8a45dbfefc0a69e883cc4ab00b7a", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -353,7 +353,7 @@ impl Step for Mingw {\n     /// Build the `rust-mingw` installer component.\n     ///\n     /// This contains all the bits and pieces to run the MinGW Windows targets\n-    /// without any extra installed software (e.g. we bundle gcc, libraries, etc).\n+    /// without any extra installed software (e.g., we bundle gcc, libraries, etc).\n     fn run(self, builder: &Builder) -> Option<PathBuf> {\n         let host = self.host;\n "}, {"sha": "c49da8fc734892042d4f70c03e2e8a39600461bb", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -121,11 +121,11 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\"\n         opts.optopt(\"\", \"on-fail\", \"command to run on failure\", \"CMD\");\n         opts.optflag(\"\", \"dry-run\", \"dry run; don't build anything\");\n         opts.optopt(\"\", \"stage\",\n-            \"stage to build (indicates compiler to use/test, e.g. stage 0 uses the \\\n+            \"stage to build (indicates compiler to use/test, e.g., stage 0 uses the \\\n              bootstrap compiler, stage 1 the stage 0 rustc artifacts, etc.)\",\n             \"N\");\n         opts.optmulti(\"\", \"keep-stage\", \"stage(s) to keep without recompiling \\\n-            (pass multiple times to keep e.g. both stages 0 and 1)\", \"N\");\n+            (pass multiple times to keep e.g., both stages 0 and 1)\", \"N\");\n         opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n         opts.optopt(\"j\", \"jobs\", \"number of jobs to run in parallel\", \"JOBS\");\n         opts.optflag(\"h\", \"help\", \"print this help message\");"}, {"sha": "f7b1c50f0fd67de61b24743c87b99118a331be59", "filename": "src/bootstrap/job.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fbootstrap%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fbootstrap%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fjob.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -10,7 +10,7 @@\n \n //! Job management on Windows for bootstrapping\n //!\n-//! Most of the time when you're running a build system (e.g. make) you expect\n+//! Most of the time when you're running a build system (e.g., make) you expect\n //! Ctrl-C or abnormal termination to actually terminate the entire tree of\n //! process in play, not just the one at the top. This currently works \"by\n //! default\" on Unix platforms because Ctrl-C actually sends a signal to the\n@@ -162,11 +162,11 @@ pub unsafe fn setup(build: &mut Build) {\n         return\n     }\n \n-    // If we've got a parent process (e.g. the python script that called us)\n+    // If we've got a parent process (e.g., the python script that called us)\n     // then move ownership of this job object up to them. That way if the python\n-    // script is killed (e.g. via ctrl-c) then we'll all be torn down.\n+    // script is killed (e.g., via ctrl-c) then we'll all be torn down.\n     //\n-    // If we don't have a parent (e.g. this was run directly) then we\n+    // If we don't have a parent (e.g., this was run directly) then we\n     // intentionally leak the job object handle. When our process exits\n     // (normally or abnormally) it will close the handle implicitly, causing all\n     // processes in the job to be cleaned up.\n@@ -184,7 +184,7 @@ pub unsafe fn setup(build: &mut Build) {\n \n     // If this failed, well at least we tried! An example of DuplicateHandle\n     // failing in the past has been when the wrong python2 package spawned this\n-    // build system (e.g. the `python2` package in MSYS instead of\n+    // build system (e.g., the `python2` package in MSYS instead of\n     // `mingw-w64-x86_64-python2`. Not sure why it failed, but the \"failure\n     // mode\" here is that we only clean everything up when the build system\n     // dies, not when the python parent does, so not too bad."}, {"sha": "c31db48dc7e47f93559519403601342356b01142", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -38,7 +38,7 @@\n //! However, compiletest itself tries to avoid running tests when the artifacts\n //! that are involved (mainly the compiler) haven't changed.\n //!\n-//! When you execute `x.py build`, the steps which are executed are:\n+//! When you execute `x.py build`, the steps executed are:\n //!\n //! * First, the python script is run. This will automatically download the\n //!   stage0 rustc and cargo according to `src/stage0.txt`, or use the cached"}, {"sha": "8ff175b01875688582f1aaec820d5be546b898a9", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -248,7 +248,7 @@ impl Step for Llvm {\n         configure_cmake(builder, target, &mut cfg, false);\n \n         // FIXME: we don't actually need to build all LLVM tools and all LLVM\n-        //        libraries here, e.g. we just want a few components and a few\n+        //        libraries here, e.g., we just want a few components and a few\n         //        tools. Figure out how to filter them down and only build the right\n         //        tools and libs on all platforms.\n "}, {"sha": "254286f088e8472ef565684e480baf69c1420ea7", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -970,7 +970,7 @@ impl Step for Compiletest {\n         }\n \n         if builder.no_std(target) == Some(true) {\n-            // for no_std run-make (e.g. thumb*),\n+            // for no_std run-make (e.g., thumb*),\n             // we need a host compiler which is called by cargo.\n             builder.ensure(compile::Std { compiler, target: compiler.host });\n         }\n@@ -1276,7 +1276,7 @@ impl Step for DocTest {\n \n     /// Run `rustdoc --test` for all documentation in `src/doc`.\n     ///\n-    /// This will run all tests in our markdown documentation (e.g. the book)\n+    /// This will run all tests in our markdown documentation (e.g., the book)\n     /// located in `src/doc`. The `rustdoc` that's run is the one that sits next to\n     /// `compiler`.\n     fn run(self, builder: &Builder) {"}, {"sha": "1bd4403a66ffa9aea6888d9f02f7fefd6086f77a", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -646,7 +646,7 @@ impl<'a> Builder<'a> {\n             self.cargo_out(compiler, tool.get_mode(), *host).join(\"deps\"),\n         ];\n \n-        // On MSVC a tool may invoke a C compiler (e.g. compiletest in run-make\n+        // On MSVC a tool may invoke a C compiler (e.g., compiletest in run-make\n         // mode) and that C compiler may need some extra PATH modification. Do\n         // so here.\n         if compiler.host.contains(\"msvc\") {"}, {"sha": "83adcce5c742c6f06456703c19ee10dacb60a746", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -801,7 +801,7 @@ impl<T: ?Sized> AsMut<T> for Box<T> {\n  *        safe.)\n  *      - It is in practice very useful to have Box<T> be unconditionally\n  *        Unpin because of trait objects, for which the structural auto\n- *        trait functionality does not apply (e.g. Box<dyn Foo> would\n+ *        trait functionality does not apply (e.g., Box<dyn Foo> would\n  *        otherwise not be Unpin).\n  *\n  *  Another type with the same semantics as Box but only a conditional"}, {"sha": "5dd0ea7d431a719879bb2c6d1cefbb3c940d3b55", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -858,7 +858,7 @@ impl<T: Ord> BinaryHeap<T> {\n     }\n }\n \n-/// Hole represents a hole in a slice i.e. an index without valid value\n+/// Hole represents a hole in a slice i.e., an index without valid value\n /// (because it was moved from or duplicated).\n /// In drop, `Hole` will restore the slice by filling the hole\n /// position with the value that was originally removed."}, {"sha": "fa74dce2f1f4a2c45df841078c157bc837bb9bab", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -258,7 +258,7 @@ impl<T: Ord> BTreeSet<T> {\n     }\n \n     /// Visits the values representing the difference,\n-    /// i.e. the values that are in `self` but not in `other`,\n+    /// i.e., the values that are in `self` but not in `other`,\n     /// in ascending order.\n     ///\n     /// # Examples\n@@ -286,7 +286,7 @@ impl<T: Ord> BTreeSet<T> {\n     }\n \n     /// Visits the values representing the symmetric difference,\n-    /// i.e. the values that are in `self` or in `other` but not in both,\n+    /// i.e., the values that are in `self` or in `other` but not in both,\n     /// in ascending order.\n     ///\n     /// # Examples\n@@ -316,7 +316,7 @@ impl<T: Ord> BTreeSet<T> {\n     }\n \n     /// Visits the values representing the intersection,\n-    /// i.e. the values that are both in `self` and `other`,\n+    /// i.e., the values that are both in `self` and `other`,\n     /// in ascending order.\n     ///\n     /// # Examples\n@@ -344,7 +344,7 @@ impl<T: Ord> BTreeSet<T> {\n     }\n \n     /// Visits the values representing the union,\n-    /// i.e. all the values in `self` or `other`, without duplicates,\n+    /// i.e., all the values in `self` or `other`, without duplicates,\n     /// in ascending order.\n     ///\n     /// # Examples\n@@ -455,7 +455,7 @@ impl<T: Ord> BTreeSet<T> {\n     }\n \n     /// Returns `true` if the set is a subset of another,\n-    /// i.e. `other` contains at least all the values in `self`.\n+    /// i.e., `other` contains at least all the values in `self`.\n     ///\n     /// # Examples\n     ///\n@@ -498,7 +498,7 @@ impl<T: Ord> BTreeSet<T> {\n     }\n \n     /// Returns `true` if the set is a superset of another,\n-    /// i.e. `self` contains at least all the values in `other`.\n+    /// i.e., `self` contains at least all the values in `other`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "f4674b327695e834e900d8231a005f1b9fee03f6", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -739,7 +739,7 @@ unsafe impl<#[may_dangle] T, A: Alloc> Drop for RawVec<T, A> {\n // On 64-bit we just need to check for overflow since trying to allocate\n // `> isize::MAX` bytes will surely fail. On 32-bit and 16-bit we need to add\n // an extra guard for this in case we're running on a platform which can use\n-// all 4GB in user-space. e.g. PAE or x32\n+// all 4GB in user-space. e.g., PAE or x32\n \n #[inline]\n fn alloc_guard(alloc_size: usize) -> Result<(), CollectionAllocErr> {"}, {"sha": "52ad30c411a10c0aac16a379a6a2a45642ad4852", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -276,7 +276,7 @@ struct RcBox<T: ?Sized> {\n /// See the [module-level documentation](./index.html) for more details.\n ///\n /// The inherent methods of `Rc` are all associated functions, which means\n-/// that you have to call them as e.g. [`Rc::get_mut(&mut value)`][get_mut] instead of\n+/// that you have to call them as e.g., [`Rc::get_mut(&mut value)`][get_mut] instead of\n /// `value.get_mut()`. This avoids conflicts with methods of the inner\n /// type `T`.\n ///\n@@ -1252,7 +1252,7 @@ impl<T: ?Sized> Weak<T> {\n     }\n \n     /// Return `None` when the pointer is dangling and there is no allocated `RcBox`,\n-    /// i.e. this `Weak` was created by `Weak::new`\n+    /// i.e., this `Weak` was created by `Weak::new`\n     #[inline]\n     fn inner(&self) -> Option<&RcBox<T>> {\n         if is_dangling(self.ptr) {"}, {"sha": "a8e9a2f5a390f79d96f592b1a70b1b6f7f52549a", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -177,7 +177,7 @@ mod hack {\n impl<T> [T] {\n     /// Sorts the slice.\n     ///\n-    /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n+    /// This sort is stable (i.e., does not reorder equal elements) and `O(n log n)` worst-case.\n     ///\n     /// When applicable, unstable sorting is preferred because it is generally faster than stable\n     /// sorting and it doesn't allocate auxiliary memory.\n@@ -211,7 +211,7 @@ impl<T> [T] {\n \n     /// Sorts the slice with a comparator function.\n     ///\n-    /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n+    /// This sort is stable (i.e., does not reorder equal elements) and `O(n log n)` worst-case.\n     ///\n     /// The comparator function must define a total ordering for the elements in the slice. If\n     /// the ordering is not total, the order of the elements is unspecified. An order is a\n@@ -264,7 +264,7 @@ impl<T> [T] {\n \n     /// Sorts the slice with a key extraction function.\n     ///\n-    /// This sort is stable (i.e. does not reorder equal elements) and `O(m n log(m n))`\n+    /// This sort is stable (i.e., does not reorder equal elements) and `O(m n log(m n))`\n     /// worst-case, where the key function is `O(m)`.\n     ///\n     /// When applicable, unstable sorting is preferred because it is generally faster than stable\n@@ -301,10 +301,10 @@ impl<T> [T] {\n     ///\n     /// During sorting, the key function is called only once per element.\n     ///\n-    /// This sort is stable (i.e. does not reorder equal elements) and `O(m n + n log n)`\n+    /// This sort is stable (i.e., does not reorder equal elements) and `O(m n + n log n)`\n     /// worst-case, where the key function is `O(m)`.\n     ///\n-    /// For simple key functions (e.g. functions that are property accesses or\n+    /// For simple key functions (e.g., functions that are property accesses or\n     /// basic operations), [`sort_by_key`](#method.sort_by_key) is likely to be\n     /// faster.\n     ///"}, {"sha": "111459d12a4df1dd9495d696c611f3e5eaa0d23c", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -1121,7 +1121,7 @@ impl<T: ?Sized> Weak<T> {\n     }\n \n     /// Return `None` when the pointer is dangling and there is no allocated `ArcInner`,\n-    /// i.e. this `Weak` was created by `Weak::new`\n+    /// i.e., this `Weak` was created by `Weak::new`\n     #[inline]\n     fn inner(&self) -> Option<&ArcInner<T>> {\n         if is_dangling(self.ptr) {"}, {"sha": "787e4952882e9ea097ccddfb8646292293881e5a", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -484,7 +484,7 @@ fn test_sort_stability() {\n             // create a vector like [(6, 1), (5, 1), (6, 2), ...],\n             // where the first item of each tuple is random, but\n             // the second item represents which occurrence of that\n-            // number this element is, i.e. the second elements\n+            // number this element is, i.e., the second elements\n             // will occur in sorted order.\n             let mut orig: Vec<_> = (0..len)\n                 .map(|_| {\n@@ -502,7 +502,7 @@ fn test_sort_stability() {\n             // This comparison includes the count (the second item\n             // of the tuple), so elements with equal first items\n             // will need to be ordered with increasing\n-            // counts... i.e. exactly asserting that this sort is\n+            // counts... i.e., exactly asserting that this sort is\n             // stable.\n             assert!(v.windows(2).all(|w| w[0] <= w[1]));\n \n@@ -1579,7 +1579,7 @@ macro_rules! test {\n             }).join();\n \n             // Check that the number of things dropped is exactly\n-            // what we expect (i.e. the contents of `v`).\n+            // what we expect (i.e., the contents of `v`).\n             for (i, c) in DROP_COUNTS.iter().enumerate().take(len) {\n                 let count = c.load(Relaxed);\n                 assert!(count == 1,"}, {"sha": "683ce2bf112454c7659926185be69a90784a8e96", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -1005,7 +1005,7 @@ fn test_escape_debug() {\n     // Note that there are subtleties with the number of backslashes\n     // on the left- and right-hand sides. In particular, Unicode code points\n     // are usually escaped with two backslashes on the right-hand side, as\n-    // they are escaped. However, when the character is unescaped (e.g. for\n+    // they are escaped. However, when the character is unescaped (e.g., for\n     // printable characters), only a single backslash appears (as the character\n     // itself appears in the debug string).\n     assert_eq!(\"abc\".escape_debug(), \"abc\");"}, {"sha": "63af69dda1dce8d82abb81ba401239f1279b8de2", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -213,7 +213,7 @@ use raw_vec::RawVec;\n /// about its design. This ensures that it's as low-overhead as possible in\n /// the general case, and can be correctly manipulated in primitive ways\n /// by unsafe code. Note that these guarantees refer to an unqualified `Vec<T>`.\n-/// If additional type parameters are added (e.g. to support custom allocators),\n+/// If additional type parameters are added (e.g., to support custom allocators),\n /// overriding their defaults may change the behavior.\n ///\n /// Most fundamentally, `Vec` is and always will be a (pointer, capacity, length)"}, {"sha": "8db7d33bdecaa1a3490b2c490b24ff73d4c6f639", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -69,7 +69,7 @@ impl Layout {\n     /// * `align` must be a power of two,\n     ///\n     /// * `size`, when rounded up to the nearest multiple of `align`,\n-    ///    must not overflow (i.e. the rounded value must be less than\n+    ///    must not overflow (i.e., the rounded value must be less than\n     ///    `usize::MAX`).\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n     #[inline]\n@@ -177,7 +177,7 @@ impl Layout {\n     /// to ensure that the following address will satisfy `align`\n     /// (measured in bytes).\n     ///\n-    /// E.g. if `self.size()` is 9, then `self.padding_needed_for(4)`\n+    /// e.g., if `self.size()` is 9, then `self.padding_needed_for(4)`\n     /// returns 3, because that is the minimum number of bytes of\n     /// padding required to get a 4-aligned address (assuming that the\n     /// corresponding memory block starts at a 4-aligned address).\n@@ -455,7 +455,7 @@ pub unsafe trait GlobalAlloc {\n     /// if the caller does not ensure that `layout` has non-zero size.\n     ///\n     /// (Extension subtraits might provide more specific bounds on\n-    /// behavior, e.g. guarantee a sentinel address or a null pointer\n+    /// behavior, e.g., guarantee a sentinel address or a null pointer\n     /// in response to a zero-size allocation request.)\n     ///\n     /// The allocated block of memory may or may not be initialized.\n@@ -550,10 +550,10 @@ pub unsafe trait GlobalAlloc {\n     /// * `new_size` must be greater than zero.\n     ///\n     /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`,\n-    ///   must not overflow (i.e. the rounded value must be less than `usize::MAX`).\n+    ///   must not overflow (i.e., the rounded value must be less than `usize::MAX`).\n     ///\n     /// (Extension subtraits might provide more specific bounds on\n-    /// behavior, e.g. guarantee a sentinel address or a null pointer\n+    /// behavior, e.g., guarantee a sentinel address or a null pointer\n     /// in response to a zero-size allocation request.)\n     ///\n     /// # Errors\n@@ -616,7 +616,7 @@ pub unsafe trait GlobalAlloc {\n ///   whether to return `Err`, or to return `Ok` with some pointer.\n ///\n /// * If an `Alloc` implementation chooses to return `Ok` in this\n-///   case (i.e. the pointer denotes a zero-sized inaccessible block)\n+///   case (i.e., the pointer denotes a zero-sized inaccessible block)\n ///   then that returned pointer must be considered \"currently\n ///   allocated\". On such an allocator, *all* methods that take\n ///   currently-allocated pointers as inputs must accept these\n@@ -651,7 +651,7 @@ pub unsafe trait GlobalAlloc {\n ///\n ///  * if a layout `k` fits a memory block (denoted by `ptr`)\n ///    currently allocated via an allocator `a`, then it is legal to\n-///    use that layout to deallocate it, i.e. `a.dealloc(ptr, k);`.\n+///    use that layout to deallocate it, i.e., `a.dealloc(ptr, k);`.\n ///\n /// # Unsafety\n ///\n@@ -673,7 +673,7 @@ pub unsafe trait Alloc {\n \n     // (Note: some existing allocators have unspecified but well-defined\n     // behavior in response to a zero size allocation request ;\n-    // e.g. in C, `malloc` of 0 will either return a null pointer or a\n+    // e.g., in C, `malloc` of 0 will either return a null pointer or a\n     // unique pointer, but will not have arbitrary undefined\n     // behavior.\n     // However in jemalloc for example,\n@@ -688,7 +688,7 @@ pub unsafe trait Alloc {\n     ///\n     /// The returned block of storage may or may not have its contents\n     /// initialized. (Extension subtraits might restrict this\n-    /// behavior, e.g. to ensure initialization to particular sets of\n+    /// behavior, e.g., to ensure initialization to particular sets of\n     /// bit patterns.)\n     ///\n     /// # Safety\n@@ -697,7 +697,7 @@ pub unsafe trait Alloc {\n     /// if the caller does not ensure that `layout` has non-zero size.\n     ///\n     /// (Extension subtraits might provide more specific bounds on\n-    /// behavior, e.g. guarantee a sentinel address or a null pointer\n+    /// behavior, e.g., guarantee a sentinel address or a null pointer\n     /// in response to a zero-size allocation request.)\n     ///\n     /// # Errors\n@@ -803,10 +803,10 @@ pub unsafe trait Alloc {\n     /// * `new_size` must be greater than zero.\n     ///\n     /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`,\n-    ///   must not overflow (i.e. the rounded value must be less than `usize::MAX`).\n+    ///   must not overflow (i.e., the rounded value must be less than `usize::MAX`).\n     ///\n     /// (Extension subtraits might provide more specific bounds on\n-    /// behavior, e.g. guarantee a sentinel address or a null pointer\n+    /// behavior, e.g., guarantee a sentinel address or a null pointer\n     /// in response to a zero-size allocation request.)\n     ///\n     /// # Errors"}, {"sha": "f521ab994cd9fefbafb8575409a3b5c92992df03", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -126,7 +126,7 @@ impl fmt::Debug for dyn Any {\n     }\n }\n \n-// Ensure that the result of e.g. joining a thread can be printed and\n+// Ensure that the result of e.g., joining a thread can be printed and\n // hence used with `unwrap`. May eventually no longer be needed if\n // dispatch works with upcasting.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "0a16c92928d444c46fcec8752b652d9d29f22603", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -97,7 +97,7 @@\n //! ## Implementation details of logically-immutable methods\n //!\n //! Occasionally it may be desirable not to expose in an API that there is mutation happening\n-//! \"under the hood\". This may be because logically the operation is immutable, but e.g. caching\n+//! \"under the hood\". This may be because logically the operation is immutable, but e.g., caching\n //! forces the implementation to perform mutation; or because you must employ mutation to implement\n //! a trait method that was originally defined to take `&self`.\n //!\n@@ -1227,7 +1227,7 @@ impl<T: ?Sized + fmt::Display> fmt::Display for Ref<'_, T> {\n }\n \n impl<'b, T: ?Sized> RefMut<'b, T> {\n-    /// Make a new `RefMut` for a component of the borrowed data, e.g. an enum\n+    /// Make a new `RefMut` for a component of the borrowed data, e.g., an enum\n     /// variant.\n     ///\n     /// The `RefCell` is already mutably borrowed, so this cannot fail."}, {"sha": "e07a0f5d712b03cf75332e53925cdbbc4ac2657a", "filename": "src/libcore/char/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -131,7 +131,7 @@ pub struct EscapeUnicode {\n     state: EscapeUnicodeState,\n \n     // The index of the next hex digit to be printed (0 if none),\n-    // i.e. the number of remaining hex digits to be printed;\n+    // i.e., the number of remaining hex digits to be printed;\n     // increasing from the least significant digit: 0x543210\n     hex_digit_idx: usize,\n }"}, {"sha": "225ea3de9cd686f5f40fa6e8898156218dbb05f4", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -13,7 +13,7 @@\n //! In Rust, some simple types are \"implicitly copyable\" and when you\n //! assign them or pass them as arguments, the receiver will get a copy,\n //! leaving the original value in place. These types do not require\n-//! allocation to copy and do not have finalizers (i.e. they do not\n+//! allocation to copy and do not have finalizers (i.e., they do not\n //! contain owned boxes or implement [`Drop`]), so the compiler considers\n //! them cheap and safe to copy. For other types copies must be made\n //! explicitly, by convention implementing the [`Clone`] trait and calling\n@@ -93,10 +93,10 @@\n /// In addition to the [implementors listed below][impls],\n /// the following types also implement `Clone`:\n ///\n-/// * Function item types (i.e. the distinct types defined for each function)\n-/// * Function pointer types (e.g. `fn() -> i32`)\n-/// * Array types, for all sizes, if the item type also implements `Clone` (e.g. `[i32; 123456]`)\n-/// * Tuple types, if each component also implements `Clone` (e.g. `()`, `(i32, bool)`)\n+/// * Function item types (i.e., the distinct types defined for each function)\n+/// * Function pointer types (e.g., `fn() -> i32`)\n+/// * Array types, for all sizes, if the item type also implements `Clone` (e.g., `[i32; 123456]`)\n+/// * Tuple types, if each component also implements `Clone` (e.g., `()`, `(i32, bool)`)\n /// * Closure types, if they capture no value from the environment\n ///   or if all such captured values implement `Clone` themselves.\n ///   Note that variables captured by shared reference always implement `Clone`"}, {"sha": "1dbf03923e11bc8532c2cdd05411aa4a76d08c5e", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -18,7 +18,7 @@ use ::fmt;\n ///\n /// [`!`]: ../../std/primitive.never.html\n /// [pointer]: ../../std/primitive.pointer.html\n-// NB: For LLVM to recognize the void pointer type and by extension\n+// N.B., for LLVM to recognize the void pointer type and by extension\n //     functions like malloc(), we need to have it represented as i8* in\n //     LLVM bitcode. The enum used here ensures this and prevents misuse\n //     of the \"raw\" type by only having private variants.. We need two"}, {"sha": "3e59ee1f8e5f5efdc243fc4afe5c1d3586cd9c1d", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -408,7 +408,7 @@ impl<H: Hasher + ?Sized> Hasher for &mut H {\n \n /// A trait for creating instances of [`Hasher`].\n ///\n-/// A `BuildHasher` is typically used (e.g. by [`HashMap`]) to create\n+/// A `BuildHasher` is typically used (e.g., by [`HashMap`]) to create\n /// [`Hasher`]s for each key such that they are hashed independently of one\n /// another, since [`Hasher`]s contain state.\n ///"}, {"sha": "0bfdd937abd630c1431100f9aa5139b7b6be8b0c", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -24,7 +24,7 @@ use intrinsics;\n /// therefore will eliminate all branches that reach to a call to\n /// `unreachable_unchecked()`.\n ///\n-/// Like all instances of UB, if this assumption turns out to be wrong, i.e. the\n+/// Like all instances of UB, if this assumption turns out to be wrong, i.e., the\n /// `unreachable_unchecked()` call is actually reachable among all possible\n /// control flow, the compiler will apply the wrong optimization strategy, and\n /// may sometimes even corrupt seemingly unrelated code, causing"}, {"sha": "eebb98b5e6d4580727bb8ceacab2204029e897ca", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -52,7 +52,7 @@\n pub use ptr::drop_in_place;\n \n extern \"rust-intrinsic\" {\n-    // NB: These intrinsics take raw pointers because they mutate aliased\n+    // N.B., these intrinsics take raw pointers because they mutate aliased\n     // memory, which is not valid for either `&` or `&mut`.\n \n     /// Stores a value if the current value is the same as the `old` value.\n@@ -635,7 +635,7 @@ extern \"rust-intrinsic\" {\n     /// Tells LLVM that this point in the code is not reachable, enabling\n     /// further optimizations.\n     ///\n-    /// NB: This is very different from the `unreachable!()` macro: Unlike the\n+    /// N.B., this is very different from the `unreachable!()` macro: Unlike the\n     /// macro, which panics when it is executed, it is *undefined behavior* to\n     /// reach code marked with this function.\n     ///"}, {"sha": "92a4aed4e27e586c2eced47623495fc93b40694e", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -154,7 +154,7 @@ pub trait Iterator {\n     ///\n     /// `size_hint()` is primarily intended to be used for optimizations such as\n     /// reserving space for the elements of the iterator, but must not be\n-    /// trusted to e.g. omit bounds checks in unsafe code. An incorrect\n+    /// trusted to e.g., omit bounds checks in unsafe code. An incorrect\n     /// implementation of `size_hint()` should not lead to memory safety\n     /// violations.\n     ///"}, {"sha": "45e5b614db3e0bdea9940be4ec47b57987900bcb", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -770,7 +770,7 @@ pub trait Product<A = Self>: Sized {\n     fn product<I: Iterator<Item=A>>(iter: I) -> Self;\n }\n \n-// NB: explicitly use Add and Mul here to inherit overflow checks\n+// N.B., explicitly use Add and Mul here to inherit overflow checks\n macro_rules! integer_sum_product {\n     (@impls $zero:expr, $one:expr, #[$attr:meta], $($a:ty)*) => ($(\n         #[$attr]"}, {"sha": "0d43f927115f8dd7bf20a4169bb6570a09827a48", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -274,10 +274,10 @@ pub trait Unsize<T: ?Sized> {\n /// In addition to the [implementors listed below][impls],\n /// the following types also implement `Copy`:\n ///\n-/// * Function item types (i.e. the distinct types defined for each function)\n-/// * Function pointer types (e.g. `fn() -> i32`)\n-/// * Array types, for all sizes, if the item type also implements `Copy` (e.g. `[i32; 123456]`)\n-/// * Tuple types, if each component also implements `Copy` (e.g. `()`, `(i32, bool)`)\n+/// * Function item types (i.e., the distinct types defined for each function)\n+/// * Function pointer types (e.g., `fn() -> i32`)\n+/// * Array types, for all sizes, if the item type also implements `Copy` (e.g., `[i32; 123456]`)\n+/// * Tuple types, if each component also implements `Copy` (e.g., `()`, `(i32, bool)`)\n /// * Closure types, if they capture no value from the environment\n ///   or if all such captured values implement `Copy` themselves.\n ///   Note that variables captured by shared reference always implement `Copy`"}, {"sha": "06754f17a6f6d972093501e1c366c43a30cbaf68", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -305,7 +305,7 @@ pub const fn size_of<T>() -> usize {\n /// Returns the size of the pointed-to value in bytes.\n ///\n /// This is usually the same as `size_of::<T>()`. However, when `T` *has* no\n-/// statically known size, e.g. a slice [`[T]`][slice] or a [trait object],\n+/// statically known size, e.g., a slice [`[T]`][slice] or a [trait object],\n /// then `size_of_val` can be used to get the dynamically-known size.\n ///\n /// [slice]: ../../std/primitive.slice.html\n@@ -1119,7 +1119,7 @@ impl<T> MaybeUninit<T> {\n     /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n     /// state, otherwise this will immediately cause undefined behavior.\n     // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references\n-    // to uninitialized data (e.g. in `libcore/fmt/float.rs`).  We should make\n+    // to uninitialized data (e.g., in `libcore/fmt/float.rs`).  We should make\n     // a final decision about the rules before stabilization.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]"}, {"sha": "2bfb49c0682bb1b62df46ac3a51d5d294f930207", "filename": "src/libcore/num/bignum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fbignum.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -183,7 +183,7 @@ macro_rules! define_bignum {\n                 let nonzero = &digits[..end];\n \n                 if nonzero.is_empty() {\n-                    // There are no non-zero digits, i.e. the number is zero.\n+                    // There are no non-zero digits, i.e., the number is zero.\n                     return 0;\n                 }\n                 // This could be optimized with leading_zeros() and bit shifts, but that's"}, {"sha": "c3a983d0f0e5b188408cfdb92bfc4a90204fe9ad", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -61,9 +61,9 @@ mod fpu_precision {\n     ///\n     /// The only field which is relevant for the following code is PC, Precision Control. This\n     /// field determines the precision of the operations performed by the  FPU. It can be set to:\n-    ///  - 0b00, single precision i.e. 32-bits\n-    ///  - 0b10, double precision i.e. 64-bits\n-    ///  - 0b11, double extended precision i.e. 80-bits (default state)\n+    ///  - 0b00, single precision i.e., 32-bits\n+    ///  - 0b10, double precision i.e., 64-bits\n+    ///  - 0b11, double extended precision i.e., 80-bits (default state)\n     /// The 0b01 value is reserved and should not be used.\n     pub struct FPUControlWord(u16);\n "}, {"sha": "18c30e29c796743e999be3b59e1e6bd3a55766b1", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -349,7 +349,7 @@ pub fn prev_float<T: RawFloat>(x: T) -> T {\n }\n \n // Find the smallest floating point number strictly larger than the argument.\n-// This operation is saturating, i.e. next_float(inf) == inf.\n+// This operation is saturating, i.e., next_float(inf) == inf.\n // Unlike most code in this module, this function does handle zero, subnormals, and infinities.\n // However, like all other code here, it does not deal with NaN and negative numbers.\n pub fn next_float<T: RawFloat>(x: T) -> T {"}, {"sha": "097240e58ae50b6574f87a31911009bc0f462d42", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -23,7 +23,7 @@ representation `V = 0.d[0..n-1] * 10^k` such that:\n - `d[0]` is non-zero.\n \n - It's correctly rounded when parsed back: `v - minus < V < v + plus`.\n-  Furthermore it is shortest such one, i.e. there is no representation\n+  Furthermore it is shortest such one, i.e., there is no representation\n   with less than `n` digits that is correctly rounded.\n \n - It's closest to the original value: `abs(V - v) <= 10^(k-n) / 2`. Note that\n@@ -398,7 +398,7 @@ fn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static\n /// given number of fractional digits. The result is stored to the supplied parts\n /// array while utilizing given byte buffer as a scratch. `upper` is currently\n /// unused but left for the future decision to change the case of non-finite values,\n-/// i.e. `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n+/// i.e., `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n /// (which can be an empty string if no sign is rendered).\n ///\n /// `format_shortest` should be the underlying digit-generation function.\n@@ -591,7 +591,7 @@ pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n /// given number of fractional digits. The result is stored to the supplied parts\n /// array while utilizing given byte buffer as a scratch. `upper` is currently\n /// unused but left for the future decision to change the case of non-finite values,\n-/// i.e. `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n+/// i.e., `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n /// (which can be an empty string if no sign is rendered).\n ///\n /// `format_exact` should be the underlying digit-generation function."}, {"sha": "cda0773afbd5b810da08ce6b8f928457189db848", "filename": "src/libcore/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -81,11 +81,11 @@ pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp\n     // - followed by `(mant + 2 * plus) * 2^exp` in the original type.\n     //\n     // obviously, `minus` and `plus` cannot be zero. (for infinities, we use out-of-range values.)\n-    // also we assume that at least one digit is generated, i.e. `mant` cannot be zero too.\n+    // also we assume that at least one digit is generated, i.e., `mant` cannot be zero too.\n     //\n     // this also means that any number between `low = (mant - minus) * 2^exp` and\n     // `high = (mant + plus) * 2^exp` will map to this exact floating point number,\n-    // with bounds included when the original mantissa was even (i.e. `!mant_was_odd`).\n+    // with bounds included when the original mantissa was even (i.e., `!mant_was_odd`).\n \n     assert!(d.mant > 0);\n     assert!(d.minus > 0);\n@@ -172,7 +172,7 @@ pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp\n         // - `high - v = plus / scale * 10^(k-n)`\n         //\n         // assume that `d[0..n-1]` is the shortest representation between `low` and `high`,\n-        // i.e. `d[0..n-1]` satisfies both of the following but `d[0..n-2]` doesn't:\n+        // i.e., `d[0..n-1]` satisfies both of the following but `d[0..n-2]` doesn't:\n         // - `low < d[0..n-1] * 10^(k-n) < high` (bijectivity: digits round to `v`); and\n         // - `abs(v / 10^(k-n) - d[0..n-1]) <= 1/2` (the last digit is correct).\n         //\n@@ -304,7 +304,7 @@ pub fn format_exact(d: &Decoded, buf: &mut [u8], limit: i16) -> (/*#digits*/ usi\n \n     // rounding up if we stop in the middle of digits\n     // if the following digits are exactly 5000..., check the prior digit and try to\n-    // round to even (i.e. avoid rounding up when the prior digit is even).\n+    // round to even (i.e., avoid rounding up when the prior digit is even).\n     let order = mant.cmp(scale.mul_small(5));\n     if order == Ordering::Greater || (order == Ordering::Equal &&\n                                       (len == 0 || buf[len-1] & 1 == 1)) {"}, {"sha": "3e76feca885bc1bfdaefd8aefd21609a0dd1cc0b", "filename": "src/libcore/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -242,7 +242,7 @@ pub fn format_shortest_opt(d: &Decoded,\n     //\n     // find the digit length `kappa` between `(minus1, plus1)` as per Theorem 6.2.\n     // Theorem 6.2 can be adopted to exclude `x` by requiring `y mod 10^k < y - x` instead.\n-    // (e.g. `x` = 32000, `y` = 32777; `kappa` = 2 since `y mod 10^3 = 777 < y - x = 777`.)\n+    // (e.g., `x` = 32000, `y` = 32777; `kappa` = 2 since `y mod 10^3 = 777 < y - x = 777`.)\n     // the algorithm relies on the later verification phase to exclude `y`.\n     let delta1 = plus1 - minus1;\n //  let delta1int = (delta1 >> e) as usize; // only for explanation\n@@ -362,19 +362,19 @@ pub fn format_shortest_opt(d: &Decoded,\n             // proceed, but we then have at least one valid representation known to be closest to\n             // `v + 1 ulp` anyway. we will denote them as TC1 through TC3 for brevity.\n             //\n-            // TC1: `w(n) <= v + 1 ulp`, i.e. this is the last repr that can be the closest one.\n+            // TC1: `w(n) <= v + 1 ulp`, i.e., this is the last repr that can be the closest one.\n             // this is equivalent to `plus1 - w(n) = plus1w(n) >= plus1 - (v + 1 ulp) = plus1v_up`.\n             // combined with TC2 (which checks if `w(n+1)` is valid), this prevents the possible\n             // overflow on the calculation of `plus1w(n)`.\n             //\n-            // TC2: `w(n+1) < minus1`, i.e. the next repr definitely does not round to `v`.\n+            // TC2: `w(n+1) < minus1`, i.e., the next repr definitely does not round to `v`.\n             // this is equivalent to `plus1 - w(n) + 10^kappa = plus1w(n) + 10^kappa >\n             // plus1 - minus1 = threshold`. the left hand side can overflow, but we know\n             // `threshold > plus1v`, so if TC1 is false, `threshold - plus1w(n) >\n             // threshold - (plus1v - 1 ulp) > 1 ulp` and we can safely test if\n             // `threshold - plus1w(n) < 10^kappa` instead.\n             //\n-            // TC3: `abs(w(n) - (v + 1 ulp)) <= abs(w(n+1) - (v + 1 ulp))`, i.e. the next repr is\n+            // TC3: `abs(w(n) - (v + 1 ulp)) <= abs(w(n+1) - (v + 1 ulp))`, i.e., the next repr is\n             // no closer to `v + 1 ulp` than the current repr. given `z(n) = plus1v_up - plus1w(n)`,\n             // this becomes `abs(z(n)) <= abs(z(n+1))`. again assuming that TC1 is false, we have\n             // `z(n) > 0`. we have two cases to consider:\n@@ -384,7 +384,7 @@ pub fn format_shortest_opt(d: &Decoded,\n             // - when `z(n+1) < 0`:\n             //   - TC3a: the precondition is `plus1v_up < plus1w(n) + 10^kappa`. assuming TC2 is\n             //     false, `threshold >= plus1w(n) + 10^kappa` so it cannot overflow.\n-            //   - TC3b: TC3 becomes `z(n) <= -z(n+1)`, i.e. `plus1v_up - plus1w(n) >=\n+            //   - TC3b: TC3 becomes `z(n) <= -z(n+1)`, i.e., `plus1v_up - plus1w(n) >=\n             //     plus1w(n+1) - plus1v_up = plus1w(n) + 10^kappa - plus1v_up`. the negated TC1\n             //     gives `plus1v_up > plus1w(n)`, so it cannot overflow or underflow when\n             //     combined with TC3a.\n@@ -414,7 +414,7 @@ pub fn format_shortest_opt(d: &Decoded,\n \n         // now we have the closest representation to `v` between `plus1` and `minus1`.\n         // this is too liberal, though, so we reject any `w(n)` not between `plus0` and `minus0`,\n-        // i.e. `plus1 - plus1w(n) <= minus0` or `plus1 - plus1w(n) >= plus0`. we utilize the facts\n+        // i.e., `plus1 - plus1w(n) <= minus0` or `plus1 - plus1w(n) >= plus0`. we utilize the facts\n         // that `threshold = plus1 - minus1` and `plus1 - plus0 = minus0 - minus1 = 2 ulp`.\n         if 2 * ulp <= plus1w && plus1w <= threshold - 4 * ulp {\n             Some((buf.len(), exp))\n@@ -675,7 +675,7 @@ pub fn format_exact_opt(d: &Decoded, buf: &mut [u8], limit: i16)\n             return Some((len, exp));\n         }\n \n-        // otherwise we are doomed (i.e. some values between `v - 1 ulp` and `v + 1 ulp` are\n+        // otherwise we are doomed (i.e., some values between `v - 1 ulp` and `v + 1 ulp` are\n         // rounding down and others are rounding up) and give up.\n         None\n     }"}, {"sha": "13b422162f3d600d9b119c24b56e9f85918468b1", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -1544,7 +1544,7 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_mod_euc(-1), (0, true));\n             concat!(\"Negates self, overflowing if this is equal to the minimum value.\n \n Returns a tuple of the negated version of self along with a boolean indicating whether an overflow\n-happened. If `self` is the minimum value (e.g. `i32::MIN` for values of type `i32`), then the\n+happened. If `self` is the minimum value (e.g., `i32::MIN` for values of type `i32`), then the\n minimum value will be returned again and `true` will be returned for an overflow happening.\n \n # Examples\n@@ -1621,7 +1621,7 @@ $EndFeature, \"\n             concat!(\"Computes the absolute value of `self`.\n \n Returns a tuple of the absolute version of self along with a boolean indicating whether an overflow\n-happened. If self is the minimum value (e.g. \", stringify!($SelfT), \"::MIN for values of type\n+happened. If self is the minimum value (e.g., \", stringify!($SelfT), \"::MIN for values of type\n  \", stringify!($SelfT), \"), then the minimum value will be returned again and true will be returned\n for an overflow happening.\n \n@@ -3617,7 +3617,7 @@ assert!(!10\", stringify!($SelfT), \".is_power_of_two());\", $EndFeature, \"\n         doc_comment! {\n             concat!(\"Returns the smallest power of two greater than or equal to `self`.\n \n-When return value overflows (i.e. `self > (1 << (N-1))` for type\n+When return value overflows (i.e., `self > (1 << (N-1))` for type\n `uN`), it panics in debug mode and return value is wrapped to 0 in\n release mode (the only situation in which method can return 0).\n \n@@ -4827,7 +4827,7 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, Par\n /// # Potential causes\n ///\n /// Among other causes, `ParseIntError` can be thrown because of leading or trailing whitespace\n-/// in the string e.g. when it is obtained from the standard input.\n+/// in the string e.g., when it is obtained from the standard input.\n /// Using the [`str.trim()`] method ensures that no whitespace remains before parsing.\n ///\n /// [`str.trim()`]: ../../std/primitive.str.html#method.trim"}, {"sha": "94dd657ec97c5e5295822c15b9be4b871234eb2f", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -865,7 +865,7 @@ assert!(!Wrapping(10\", stringify!($t), \").is_power_of_two());\n             doc_comment! {\n                 concat!(\"Returns the smallest power of two greater than or equal to `self`.\n \n-When return value overflows (i.e. `self > (1 << (N-1))` for type\n+When return value overflows (i.e., `self > (1 << (N-1))` for type\n `uN`), overflows to `2^N = 0`.\n \n # Examples"}, {"sha": "d1be724c3264e6c1a7430d94878bb8d1d55eee8b", "filename": "src/libcore/ops/function.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ffunction.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -26,7 +26,7 @@\n /// is expected.\n ///\n /// Use `Fn` as a bound when you want to accept a parameter of function-like\n-/// type and need to call it repeatedly and without mutating state (e.g. when\n+/// type and need to call it repeatedly and without mutating state (e.g., when\n /// calling it concurrently). If you do not need such strict requirements, use\n /// [`FnMut`] or [`FnOnce`] as bounds.\n ///\n@@ -84,7 +84,7 @@ pub trait Fn<Args> : FnMut<Args> {\n ///\n /// `FnMut` is implemented automatically by closures which take mutable\n /// references to captured variables, as well as all types that implement\n-/// [`Fn`], e.g. (safe) [function pointers][] (since `FnMut` is a supertrait of\n+/// [`Fn`], e.g., (safe) [function pointers][] (since `FnMut` is a supertrait of\n /// [`Fn`]). Additionally, for any type `F` that implements `FnMut`, `&mut F`\n /// implements `FnMut`, too.\n ///\n@@ -163,7 +163,7 @@ pub trait FnMut<Args> : FnOnce<Args> {\n /// implements `FnOnce`, it can only be called once.\n ///\n /// `FnOnce` is implemented automatically by closure that might consume captured\n-/// variables, as well as all types that implement [`FnMut`], e.g. (safe)\n+/// variables, as well as all types that implement [`FnMut`], e.g., (safe)\n /// [function pointers][] (since `FnOnce` is a supertrait of [`FnMut`]).\n ///\n /// Since both [`Fn`] and [`FnMut`] are subtraits of `FnOnce`, any instance of"}, {"sha": "785f0733df2b85eb3cdbe9023eb434b2fefc5f4f", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -27,7 +27,7 @@\n //! should have some resemblance to multiplication (and share expected\n //! properties like associativity).\n //!\n-//! Note that the `&&` and `||` operators short-circuit, i.e. they only\n+//! Note that the `&&` and `||` operators short-circuit, i.e., they only\n //! evaluate their second operand if it contributes to the result. Since this\n //! behavior is not enforceable by traits, `&&` and `||` are not supported as\n //! overloadable operators."}, {"sha": "44d632ece055c47513d2010ebb5dc102d3e8bdbc", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -62,7 +62,7 @@\n //! The following example uses [`Option`] to create an optional box of\n //! [`i32`]. Notice that in order to use the inner [`i32`] value first, the\n //! `check_optional` function needs to use pattern matching to\n-//! determine whether the box has a value (i.e. it is [`Some(...)`][`Some`]) or\n+//! determine whether the box has a value (i.e., it is [`Some(...)`][`Some`]) or\n //! not ([`None`]).\n //!\n //! ```"}, {"sha": "aa5155536c903cbca88f5554b5c8b2a2e128dfb0", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -9,7 +9,7 @@\n //!\n //! In order to prevent objects from moving, they must be pinned\n //! by wrapping a pointer to the data in the [`Pin`] type. A pointer wrapped\n-//! in a `Pin` is otherwise equivalent to its normal version, e.g. `Pin<Box<T>>`\n+//! in a `Pin` is otherwise equivalent to its normal version, e.g., `Pin<Box<T>>`\n //! and `Box<T>` work the same way except that the first is pinning the value\n //! of `T` in place.\n //!"}, {"sha": "a2d32e9d68fb5bf590bb0603066895f3db6b2277", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -103,7 +103,7 @@ pub use intrinsics::write_bytes;\n ///   dropped normally.\n ///\n /// * It is friendlier to the optimizer to do this over [`ptr::read`] when\n-///   dropping manually allocated memory (e.g. when writing Box/Rc/Vec),\n+///   dropping manually allocated memory (e.g., when writing Box/Rc/Vec),\n ///   as the compiler doesn't need to prove that it's sound to elide the\n ///   copy.\n ///\n@@ -836,7 +836,7 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n ///\n /// The compiler shouldn't change the relative order or number of volatile\n /// memory operations. However, volatile memory operations on zero-sized types\n-/// (e.g. if a zero-sized type is passed to `read_volatile`) are no-ops\n+/// (e.g., if a zero-sized type is passed to `read_volatile`) are no-ops\n /// and may be ignored.\n ///\n /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n@@ -913,7 +913,7 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n ///\n /// The compiler shouldn't change the relative order or number of volatile\n /// memory operations. However, volatile memory operations on zero-sized types\n-/// (e.g. if a zero-sized type is passed to `write_volatile`) are no-ops\n+/// (e.g., if a zero-sized type is passed to `write_volatile`) are no-ops\n /// and may be ignored.\n ///\n /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n@@ -1035,7 +1035,7 @@ impl<T: ?Sized> *const T {\n \n     /// Calculates the offset from a pointer.\n     ///\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -1089,7 +1089,7 @@ impl<T: ?Sized> *const T {\n \n     /// Calculates the offset from a pointer using wrapping arithmetic.\n     ///\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -1253,7 +1253,7 @@ impl<T: ?Sized> *const T {\n \n     /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`).\n     ///\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -1310,7 +1310,7 @@ impl<T: ?Sized> *const T {\n     /// Calculates the offset from a pointer (convenience for\n     /// `.offset((count as isize).wrapping_neg())`).\n     ///\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -1367,7 +1367,7 @@ impl<T: ?Sized> *const T {\n     /// Calculates the offset from a pointer using wrapping arithmetic.\n     /// (convenience for `.wrapping_offset(count as isize)`)\n     ///\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -1408,7 +1408,7 @@ impl<T: ?Sized> *const T {\n     /// Calculates the offset from a pointer using wrapping arithmetic.\n     /// (convenience for `.wrapping_offset((count as isize).wrapping_sub())`)\n     ///\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -1655,7 +1655,7 @@ impl<T: ?Sized> *mut T {\n \n     /// Calculates the offset from a pointer.\n     ///\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -1708,7 +1708,7 @@ impl<T: ?Sized> *mut T {\n     }\n \n     /// Calculates the offset from a pointer using wrapping arithmetic.\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -1891,7 +1891,7 @@ impl<T: ?Sized> *mut T {\n \n     /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`).\n     ///\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -1948,7 +1948,7 @@ impl<T: ?Sized> *mut T {\n     /// Calculates the offset from a pointer (convenience for\n     /// `.offset((count as isize).wrapping_neg())`).\n     ///\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -2005,7 +2005,7 @@ impl<T: ?Sized> *mut T {\n     /// Calculates the offset from a pointer using wrapping arithmetic.\n     /// (convenience for `.wrapping_offset(count as isize)`)\n     ///\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -2046,7 +2046,7 @@ impl<T: ?Sized> *mut T {\n     /// Calculates the offset from a pointer using wrapping arithmetic.\n     /// (convenience for `.wrapping_offset((count as isize).wrapping_sub())`)\n     ///\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -2375,7 +2375,7 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     fn mod_inv(x: usize, m: usize) -> usize {\n         /// Multiplicative modular inverse table modulo 2\u2074 = 16.\n         ///\n-        /// Note, that this table does not contain values where inverse does not exist (i.e. for\n+        /// Note, that this table does not contain values where inverse does not exist (i.e., for\n         /// `0\u207b\u00b9 mod 16`, `2\u207b\u00b9 mod 16`, etc.)\n         const INV_TABLE_MOD_16: [u8; 8] = [1, 11, 13, 7, 9, 3, 5, 15];\n         /// Modulo for which the `INV_TABLE_MOD_16` is intended.\n@@ -2398,7 +2398,7 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n                 // y = y * (2 - xy) mod n\n                 //\n                 // Note, that we use wrapping operations here intentionally \u2013 the original formula\n-                // uses e.g. subtraction `mod n`. It is entirely fine to do them `mod\n+                // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n                 // usize::max_value()` instead, because we take the result `mod n` at the end\n                 // anyway.\n                 inverse = inverse.wrapping_mul(\n@@ -2887,12 +2887,12 @@ pub struct NonNull<T: ?Sized> {\n }\n \n /// `NonNull` pointers are not `Send` because the data they reference may be aliased.\n-// NB: This impl is unnecessary, but should provide better error messages.\n+// N.B., this impl is unnecessary, but should provide better error messages.\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n impl<T: ?Sized> !Send for NonNull<T> { }\n \n /// `NonNull` pointers are not `Sync` because the data they reference may be aliased.\n-// NB: This impl is unnecessary, but should provide better error messages.\n+// N.B., this impl is unnecessary, but should provide better error messages.\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n impl<T: ?Sized> !Sync for NonNull<T> { }\n "}, {"sha": "4f1af8bf110e4c12987c0e326c27c768694728d1", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -24,7 +24,7 @@\n /// `Box<dyn AnotherTrait>`.\n ///\n /// `TraitObject` is guaranteed to match layouts, but it is not the\n-/// type of trait objects (e.g. the fields are not directly accessible\n+/// type of trait objects (e.g., the fields are not directly accessible\n /// on a `&SomeTrait`) nor does it control that layout (changing the\n /// definition will not change the layout of a `&SomeTrait`). It is\n /// only designed to be used by unsafe code that needs to manipulate"}, {"sha": "59c11b273293f484dd5496bf25fc75a46147ff0e", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Slice management and manipulation\n+//! Slice management and manipulation.\n //!\n //! For more details see [`std::slice`].\n //!\n@@ -1151,7 +1151,7 @@ impl<T> [T] {\n     ///\n     /// # Examples\n     ///\n-    /// Print the slice split once by numbers divisible by 3 (i.e. `[10, 40]`,\n+    /// Print the slice split once by numbers divisible by 3 (i.e., `[10, 40]`,\n     /// `[20, 60, 50]`):\n     ///\n     /// ```\n@@ -1215,7 +1215,7 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// Print the slice split once, starting from the end, by numbers divisible\n-    /// by 3 (i.e. `[50]`, `[10, 40, 30, 20]`):\n+    /// by 3 (i.e., `[50]`, `[10, 40, 30, 20]`):\n     ///\n     /// ```\n     /// let v = [10, 40, 30, 20, 60, 50];\n@@ -1471,8 +1471,8 @@ impl<T> [T] {\n \n     /// Sorts the slice, but may not preserve the order of equal elements.\n     ///\n-    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n-    /// and `O(n log n)` worst-case.\n+    /// This sort is unstable (i.e., may reorder equal elements), in-place\n+    /// (i.e., does not allocate), and `O(n log n)` worst-case.\n     ///\n     /// # Current implementation\n     ///\n@@ -1482,7 +1482,7 @@ impl<T> [T] {\n     /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n     /// deterministic behavior.\n     ///\n-    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n+    /// It is typically faster than stable sorting, except in a few special cases, e.g., when the\n     /// slice consists of several concatenated sorted sequences.\n     ///\n     /// # Examples\n@@ -1506,8 +1506,8 @@ impl<T> [T] {\n     /// Sorts the slice with a comparator function, but may not preserve the order of equal\n     /// elements.\n     ///\n-    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n-    /// and `O(n log n)` worst-case.\n+    /// This sort is unstable (i.e., may reorder equal elements), in-place\n+    /// (i.e., does not allocate), and `O(n log n)` worst-case.\n     ///\n     /// The comparator function must define a total ordering for the elements in the slice. If\n     /// the ordering is not total, the order of the elements is unspecified. An order is a\n@@ -1533,7 +1533,7 @@ impl<T> [T] {\n     /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n     /// deterministic behavior.\n     ///\n-    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n+    /// It is typically faster than stable sorting, except in a few special cases, e.g., when the\n     /// slice consists of several concatenated sorted sequences.\n     ///\n     /// # Examples\n@@ -1560,8 +1560,9 @@ impl<T> [T] {\n     /// Sorts the slice with a key extraction function, but may not preserve the order of equal\n     /// elements.\n     ///\n-    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n-    /// and `O(m n log(m n))` worst-case, where the key function is `O(m)`.\n+    /// This sort is unstable (i.e., may reorder equal elements), in-place\n+    /// (i.e., does not allocate), and `O(m n log(m n))` worst-case, where the key function is\n+    /// `O(m)`.\n     ///\n     /// # Current implementation\n     ///\n@@ -2458,13 +2459,13 @@ impl<T> SliceIndex<[T]> for usize {\n \n     #[inline]\n     fn index(self, slice: &[T]) -> &T {\n-        // NB: use intrinsic indexing\n+        // N.B., use intrinsic indexing\n         &(*slice)[self]\n     }\n \n     #[inline]\n     fn index_mut(self, slice: &mut [T]) -> &mut T {\n-        // NB: use intrinsic indexing\n+        // N.B., use intrinsic indexing\n         &mut (*slice)[self]\n     }\n }"}, {"sha": "4a22d929fede0e3db0721dad190da09780b11c0a", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -482,7 +482,7 @@ fn utf8_first_byte(byte: u8, width: u32) -> u32 { (byte & (0x7F >> width)) as u3\n #[inline]\n fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 { (ch << 6) | (byte & CONT_MASK) as u32 }\n \n-/// Checks whether the byte is a UTF-8 continuation byte (i.e. starts with the\n+/// Checks whether the byte is a UTF-8 continuation byte (i.e., starts with the\n /// bits `10`).\n #[inline]\n fn utf8_is_cont_byte(byte: u8) -> bool { (byte & !CONT_MASK) == TAG_CONT_U8 }"}, {"sha": "2059160ddfe67f914a6bc8a9100efb67e9010751", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -397,7 +397,7 @@ unsafe impl<'a> ReverseSearcher<'a> for CharSearcher<'a> {\n                     let found_char = index - shift;\n                     if let Some(slice) = haystack.get(found_char..(found_char + self.utf8_size)) {\n                         if slice == &self.utf8_encoded[0..self.utf8_size] {\n-                            // move finger to before the character found (i.e. at its start index)\n+                            // move finger to before the character found (i.e., at its start index)\n                             self.finger_back = found_char;\n                             return Some((self.finger_back, self.finger_back + self.utf8_size));\n                         }\n@@ -1016,7 +1016,7 @@ struct TwoWaySearcher {\n     It can be proven that the following is an equivalent definition of a local period\n     for a factorization (u, v): any positive integer r such that x[i] == x[i+r] for\n     all i such that |u| - r <= i <= |u| - 1 and such that both x[i] and x[i+r] are\n-    defined. (i.e. i > 0 and i + r < |x|).\n+    defined. (i.e., i > 0 and i + r < |x|).\n \n     Using the above reformulation, it is easy to prove that\n "}, {"sha": "8ea7abce67bfafaf810a0ba6a03d269a4c4cb66f", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -227,7 +227,7 @@ pub unsafe trait UnsafeWake: Send + Sync {\n     /// # Unsafety\n     ///\n     /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e. hasn't been dropped.\n+    /// value is in a consistent state, i.e., hasn't been dropped.\n     unsafe fn clone_raw(&self) -> Waker;\n \n     /// Drops this instance of `UnsafeWake`, deallocating resources\n@@ -249,7 +249,7 @@ pub unsafe trait UnsafeWake: Send + Sync {\n     /// # Unsafety\n     ///\n     /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e. hasn't been dropped.\n+    /// value is in a consistent state, i.e., hasn't been dropped.\n     unsafe fn drop_raw(&self);\n \n     /// Indicates that the associated task is ready to make progress and should\n@@ -266,7 +266,7 @@ pub unsafe trait UnsafeWake: Send + Sync {\n     /// # Unsafety\n     ///\n     /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e. hasn't been dropped.\n+    /// value is in a consistent state, i.e., hasn't been dropped.\n     unsafe fn wake(&self);\n \n     /// Indicates that the associated task is ready to make progress and should\n@@ -286,7 +286,7 @@ pub unsafe trait UnsafeWake: Send + Sync {\n     /// # Unsafety\n     ///\n     /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e. hasn't been dropped, and that the\n+    /// value is in a consistent state, i.e., hasn't been dropped, and that the\n     /// `UnsafeWake` hasn't moved from the thread on which it was created.\n     unsafe fn wake_local(&self) {\n         self.wake()"}, {"sha": "879a41b4b770d911072a5012f534a07b98a44f12", "filename": "src/libcore/tests/num/dec2flt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -17,7 +17,7 @@ mod rawfp;\n \n // Take a float literal, turn it into a string in various ways (that are all trusted\n // to be correct) and see if those strings are parsed back to the value of the literal.\n-// Requires a *polymorphic literal*, i.e. one that can serve as f64 as well as f32.\n+// Requires a *polymorphic literal*, i.e., one that can serve as f64 as well as f32.\n macro_rules! test_literal {\n     ($x: expr) => ({\n         let x32: f32 = $x;"}, {"sha": "95dfcb522e0a922537612654095449eba880d854", "filename": "src/libcore/tests/num/flt2dec/random.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -99,7 +99,7 @@ pub fn f32_exhaustive_equivalence_test<F, G>(f: F, g: G, k: usize)\n     // this is of course very stressful (and thus should be behind an `#[ignore]` attribute),\n     // but with `-C opt-level=3 -C lto` this only takes about an hour or so.\n \n-    // iterate from 0x0000_0001 to 0x7f7f_ffff, i.e. all finite ranges\n+    // iterate from 0x0000_0001 to 0x7f7f_ffff, i.e., all finite ranges\n     let (npassed, nignored) = iterate(\"f32_exhaustive_equivalence_test\",\n                                       k, 0x7f7f_ffff, f, g, |i: usize| {\n "}, {"sha": "475bb721f23f70092c75e8159cb6f5a3c8a5f331", "filename": "src/libcore/time.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -216,7 +216,7 @@ impl Duration {\n     ///\n     /// This method does **not** return the length of the duration when\n     /// represented by milliseconds. The returned number always represents a\n-    /// fractional portion of a second (i.e. it is less than one thousand).\n+    /// fractional portion of a second (i.e., it is less than one thousand).\n     ///\n     /// # Examples\n     ///\n@@ -235,7 +235,7 @@ impl Duration {\n     ///\n     /// This method does **not** return the length of the duration when\n     /// represented by microseconds. The returned number always represents a\n-    /// fractional portion of a second (i.e. it is less than one million).\n+    /// fractional portion of a second (i.e., it is less than one million).\n     ///\n     /// # Examples\n     ///\n@@ -254,7 +254,7 @@ impl Duration {\n     ///\n     /// This method does **not** return the length of the duration when\n     /// represented by nanoseconds. The returned number always represents a\n-    /// fractional portion of a second (i.e. it is less than one billion).\n+    /// fractional portion of a second (i.e., it is less than one billion).\n     ///\n     /// # Examples\n     ///"}, {"sha": "e3cf959beb8e5e019ca47919190ffce7d6515f2d", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -10,7 +10,7 @@\n \n //! Generate files suitable for use with [Graphviz](http://www.graphviz.org/)\n //!\n-//! The `render` function generates output (e.g. an `output.dot` file) for\n+//! The `render` function generates output (e.g., an `output.dot` file) for\n //! use with [Graphviz](http://www.graphviz.org/) by walking a labeled\n //! graph. (Graphviz can then automatically lay out the nodes and edges\n //! of the graph, and also optionally render the graph as an image or\n@@ -25,7 +25,7 @@\n //! expressiveness of the [DOT language](\n //! http://www.graphviz.org/doc/info/lang.html). For example, there are\n //! many [attributes](http://www.graphviz.org/content/attrs) related to\n-//! providing layout hints (e.g. left-to-right versus top-down, which\n+//! providing layout hints (e.g., left-to-right versus top-down, which\n //! algorithm to use, etc). The current intention of this library is to\n //! emit a human-readable .dot file with very regular structure suitable\n //! for easy post-processing.\n@@ -373,7 +373,7 @@ impl Style {\n // implement a Labelling service) that I have encountered is that it\n // makes it impossible to use types outside of the current crate\n // directly as Nodes/Edges; you need to wrap them in newtype'd\n-// structs. See e.g. the `No` and `Ed` structs in the examples. (In\n+// structs. See e.g., the `No` and `Ed` structs in the examples. (In\n // practice clients using a graph in some other crate would need to\n // provide some sort of adapter shim over the graph anyway to\n // interface with this library).\n@@ -400,7 +400,7 @@ impl<'a> Id<'a> {\n     /// The caller must ensure that the input conforms to an\n     /// identifier format: it must be a non-empty string made up of\n     /// alphanumeric or underscore characters, not beginning with a\n-    /// digit (i.e. the regular expression `[a-zA-Z_][a-zA-Z_0-9]*`).\n+    /// digit (i.e., the regular expression `[a-zA-Z_][a-zA-Z_0-9]*`).\n     ///\n     /// (Note: this format is a strict subset of the `ID` format\n     /// defined by the DOT language.  This function may change in the"}, {"sha": "c9ae87ade283db3f0582980581434636afbdb906", "filename": "src/libpanic_unwind/dwarf/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -32,7 +32,7 @@ impl DwarfReader {\n         DwarfReader { ptr }\n     }\n \n-    // DWARF streams are packed, so e.g. a u32 would not necessarily be aligned\n+    // DWARF streams are packed, so e.g., a u32 would not necessarily be aligned\n     // on a 4-byte boundary. This may cause problems on platforms with strict\n     // alignment requirements. By wrapping data in a \"packed\" struct, we are\n     // telling the backend to generate \"misalignment-safe\" code."}, {"sha": "441058c8d74ca7316a106e965391c199bc11e4eb", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -25,7 +25,7 @@\n //!\n //! In both phases the unwinder walks stack frames from top to bottom using\n //! information from the stack frame unwind sections of the current process's\n-//! modules (\"module\" here refers to an OS module, i.e. an executable or a\n+//! modules (\"module\" here refers to an OS module, i.e., an executable or a\n //! dynamic library).\n //!\n //! For each stack frame, it invokes the associated \"personality routine\", whose\n@@ -296,7 +296,7 @@ unsafe extern \"C\" fn rust_eh_unwind_resume(panic_ctx: *mut u8) -> ! {\n // Each module's image contains a frame unwind info section (usually\n // \".eh_frame\").  When a module is loaded/unloaded into the process, the\n // unwinder must be informed about the location of this section in memory. The\n-// methods of achieving that vary by the platform.  On some (e.g. Linux), the\n+// methods of achieving that vary by the platform.  On some (e.g., Linux), the\n // unwinder can discover unwind info sections on its own (by dynamically\n // enumerating currently loaded modules via the dl_iterate_phdr() API and\n // finding their \".eh_frame\" sections); Others, like Windows, require modules"}, {"sha": "9d24079d91e2df6f9db584faea1e4b9fc5f45734", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -12,7 +12,7 @@\n //!\n //! On Windows (currently only on MSVC), the default exception handling\n //! mechanism is Structured Exception Handling (SEH). This is quite different\n-//! than Dwarf-based exception handling (e.g. what other unix platforms use) in\n+//! than Dwarf-based exception handling (e.g., what other unix platforms use) in\n //! terms of compiler internals, so LLVM is required to have a good deal of\n //! extra support for SEH.\n //!\n@@ -304,7 +304,7 @@ pub unsafe fn cleanup(payload: [u64; 2]) -> Box<dyn Any + Send> {\n     })\n }\n \n-// This is required by the compiler to exist (e.g. it's a lang item), but\n+// This is required by the compiler to exist (e.g., it's a lang item), but\n // it's never actually called by the compiler because __C_specific_handler\n // or _except_handler3 is the personality function that is always used.\n // Hence this is just an aborting stub."}, {"sha": "f5e12713e4e72f50100b8924dda12f56b4be3509", "filename": "src/libproc_macro/bridge/client.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fclient.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -262,7 +262,7 @@ enum BridgeState<'a> {\n     Connected(Bridge<'a>),\n \n     /// Access to the bridge is being exclusively acquired\n-    /// (e.g. during `BridgeState::with`).\n+    /// (e.g., during `BridgeState::with`).\n     InUse,\n }\n \n@@ -283,7 +283,7 @@ impl BridgeState<'_> {\n     /// The state will be restored after `f` exits, even\n     /// by panic, including modifications made to it by `f`.\n     ///\n-    /// NB: while `f` is running, the thread-local state\n+    /// N.B., while `f` is running, the thread-local state\n     /// is `BridgeState::InUse`.\n     fn with<R>(f: impl FnOnce(&mut BridgeState) -> R) -> R {\n         BRIDGE_STATE.with(|state| {\n@@ -333,7 +333,7 @@ impl Bridge<'_> {\n /// which may be using a different `proc_macro` from the one\n /// used by the server, but can be interacted with compatibly.\n ///\n-/// NB: `F` must have FFI-friendly memory layout (e.g. a pointer).\n+/// N.B., `F` must have FFI-friendly memory layout (e.g., a pointer).\n /// The call ABI of function pointers used for `F` doesn't\n /// need to match between server and client, since it's only\n /// passed between them and (eventually) called by the client."}, {"sha": "edb4d3fbdaabb6208c1e0695eb1f728d19263bd0", "filename": "src/libproc_macro/bridge/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibproc_macro%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibproc_macro%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -14,7 +14,7 @@\n //! Serialization (with C ABI buffers) and unique integer handles are employed\n //! to allow safely interfacing between two copies of `proc_macro` built\n //! (from the same source) by different compilers with potentially mismatching\n-//! Rust ABIs (e.g. stage0/bin/rustc vs stage1/bin/rustc during bootstrap).\n+//! Rust ABIs (e.g., stage0/bin/rustc vs stage1/bin/rustc during bootstrap).\n \n #![deny(unsafe_code)]\n "}, {"sha": "c86d5fc309a39d491087c1a1acf5feee0c343ce1", "filename": "src/libproc_macro/bridge/scoped_cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -19,7 +19,7 @@ pub trait ApplyL<'a> {\n     type Out;\n }\n \n-/// Type lambda taking a lifetime, i.e. `Lifetime -> Type`.\n+/// Type lambda taking a lifetime, i.e., `Lifetime -> Type`.\n pub trait LambdaL: for<'a> ApplyL<'a> {}\n \n impl<T: for<'a> ApplyL<'a>> LambdaL for T {}"}, {"sha": "0c1d4f7cc5069b45002a0c18bfedeab89f352001", "filename": "src/libproc_macro/bridge/server.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibproc_macro%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibproc_macro%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fserver.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -16,7 +16,7 @@ use super::*;\n use super::client::HandleStore;\n \n /// Declare an associated item of one of the traits below, optionally\n-/// adjusting it (i.e. adding bounds to types and default bodies to methods).\n+/// adjusting it (i.e., adding bounds to types and default bodies to methods).\n macro_rules! associated_item {\n     (type TokenStream) =>\n         (type TokenStream: 'static + Clone;);"}, {"sha": "f2b85832dac31759d455051f09a42cefc5f35b39", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -110,7 +110,7 @@ impl FromStr for TokenStream {\n     }\n }\n \n-// NB: the bridge only provides `to_string`, implement `fmt::Display`\n+// N.B., the bridge only provides `to_string`, implement `fmt::Display`\n // based on it (the reverse of the usual relationship between the two).\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl ToString for TokenStream {\n@@ -196,7 +196,7 @@ pub mod token_stream {\n     use {bridge, Group, Ident, Literal, Punct, TokenTree, TokenStream};\n \n     /// An iterator over `TokenStream`'s `TokenTree`s.\n-    /// The iteration is \"shallow\", e.g. the iterator doesn't recurse into delimited groups,\n+    /// The iteration is \"shallow\", e.g., the iterator doesn't recurse into delimited groups,\n     /// and returns whole groups as token trees.\n     #[derive(Clone)]\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n@@ -426,7 +426,7 @@ impl PartialEq for SourceFile {\n #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n impl Eq for SourceFile {}\n \n-/// A single token or a delimited sequence of token trees (e.g. `[1, (), ..]`).\n+/// A single token or a delimited sequence of token trees (e.g., `[1, (), ..]`).\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n #[derive(Clone)]\n pub enum TokenTree {\n@@ -533,7 +533,7 @@ impl From<Literal> for TokenTree {\n     }\n }\n \n-// NB: the bridge only provides `to_string`, implement `fmt::Display`\n+// N.B., the bridge only provides `to_string`, implement `fmt::Display`\n // based on it (the reverse of the usual relationship between the two).\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl ToString for TokenTree {\n@@ -663,7 +663,7 @@ impl Group {\n     }\n }\n \n-// NB: the bridge only provides `to_string`, implement `fmt::Display`\n+// N.B., the bridge only provides `to_string`, implement `fmt::Display`\n // based on it (the reverse of the usual relationship between the two).\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl ToString for Group {\n@@ -711,10 +711,10 @@ impl !Sync for Punct {}\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n pub enum Spacing {\n-    /// E.g. `+` is `Alone` in `+ =`, `+ident` or `+()`.\n+    /// e.g., `+` is `Alone` in `+ =`, `+ident` or `+()`.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     Alone,\n-    /// E.g. `+` is `Joint` in `+=` or `'#`.\n+    /// e.g., `+` is `Joint` in `+=` or `'#`.\n     /// Additionally, single quote `'` can join with identifiers to form lifetimes `'ident`.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     Joint,\n@@ -765,7 +765,7 @@ impl Punct {\n     }\n }\n \n-// NB: the bridge only provides `to_string`, implement `fmt::Display`\n+// N.B., the bridge only provides `to_string`, implement `fmt::Display`\n // based on it (the reverse of the usual relationship between the two).\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl ToString for Punct {\n@@ -860,7 +860,7 @@ impl Ident {\n     }\n }\n \n-// NB: the bridge only provides `to_string`, implement `fmt::Display`\n+// N.B., the bridge only provides `to_string`, implement `fmt::Display`\n // based on it (the reverse of the usual relationship between the two).\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl ToString for Ident {\n@@ -1110,7 +1110,7 @@ impl Literal {\n     }\n }\n \n-// NB: the bridge only provides `to_string`, implement `fmt::Display`\n+// N.B., the bridge only provides `to_string`, implement `fmt::Display`\n // based on it (the reverse of the usual relationship between the two).\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl ToString for Literal {"}, {"sha": "c5d6ce24c5df4d03ec132032756ff385f7638f22", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -379,7 +379,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprKind::Index(ref l, ref r) |\n-            hir::ExprKind::Binary(_, ref l, ref r) => { // NB: && and || handled earlier\n+            hir::ExprKind::Binary(_, ref l, ref r) => { // N.B., && and || handled earlier\n                 self.straightline(expr, pred, [l, r].iter().map(|&e| &**e))\n             }\n "}, {"sha": "f0c6196412adb982ce2c12a391620d04bb021e65", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -17,7 +17,7 @@\n //! fully identify a dependency node, even across multiple compilation sessions.\n //! In other words, the value of the fingerprint does not depend on anything\n //! that is specific to a given compilation session, like an unpredictable\n-//! interning key (e.g. NodeId, DefId, Symbol) or the numeric value of a\n+//! interning key (e.g., NodeId, DefId, Symbol) or the numeric value of a\n //! pointer. The concept behind this could be compared to how git commit hashes\n //! uniquely identify a given commit and has a few advantages:\n //!\n@@ -28,7 +28,7 @@\n //! * A `Fingerprint` is just a bunch of bits, which allows `DepNode` to\n //!   implement `Copy`, `Sync`, `Send`, `Freeze`, etc.\n //! * Since we just have a bit pattern, `DepNode` can be mapped from disk into\n-//!   memory without any post-processing (e.g. \"abomination-style\" pointer\n+//!   memory without any post-processing (e.g., \"abomination-style\" pointer\n //!   reconstruction).\n //! * Because a `DepNode` is self-contained, we can instantiate `DepNodes` that\n //!   refer to things that do not exist anymore. In previous implementations\n@@ -81,7 +81,7 @@ use ty::{TyCtxt, FnSig, Instance, InstanceDef,\n use ty::subst::Substs;\n \n // erase!() just makes tokens go away. It's used to specify which macro argument\n-// is repeated (i.e. which sub-expression of the macro we are in) but don't need\n+// is repeated (i.e., which sub-expression of the macro we are in) but don't need\n // to actually use any of the arguments.\n macro_rules! erase {\n     ($x:tt) => ({})"}, {"sha": "3dc6f761ec96141f8452938a97d0ed3e8e7b1d2b", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -47,7 +47,7 @@ trait Foo where Self: Sized {\n We cannot create an object of type `Box<Foo>` or `&Foo` since in this case\n `Self` would not be `Sized`.\n \n-Generally, `Self : Sized` is used to indicate that the trait should not be used\n+Generally, `Self: Sized` is used to indicate that the trait should not be used\n as a trait object. If the trait comes from your own crate, consider removing\n this restriction.\n \n@@ -217,9 +217,9 @@ trait Trait {\n ```\n \n If this is not an option, consider replacing the type parameter with another\n-trait object (e.g. if `T: OtherTrait`, use `on: Box<OtherTrait>`). If the number\n-of types you intend to feed to this method is limited, consider manually listing\n-out the methods of different types.\n+trait object (e.g., if `T: OtherTrait`, use `on: Box<OtherTrait>`). If the\n+number of types you intend to feed to this method is limited, consider manually\n+listing out the methods of different types.\n \n ### Method has no receiver\n \n@@ -642,7 +642,7 @@ struct Foo; // error: duplicate lang item found: `arc`\n ```\n \n Lang items are already implemented in the standard library. Unless you are\n-writing a free-standing application (e.g. a kernel), you do not need to provide\n+writing a free-standing application (e.g., a kernel), you do not need to provide\n them yourself.\n \n You can build a free-standing crate by adding `#![no_std]` to the crate\n@@ -699,7 +699,7 @@ This error appears when the curly braces contain an identifier which doesn't\n match with any of the type parameters or the string `Self`. This might happen\n if you misspelled a type parameter, or if you intended to use literal curly\n braces. If it is the latter, escape the curly braces with a second curly brace\n-of the same type; e.g. a literal `{` is `{{`.\n+of the same type; e.g., a literal `{` is `{{`.\n \"##,\n \n E0231: r##\"\n@@ -832,7 +832,7 @@ extern \"C\" {\n \n E0271: r##\"\n This is because of a type mismatch between the associated type of some\n-trait (e.g. `T::Bar`, where `T` implements `trait Quux { type Bar; }`)\n+trait (e.g., `T::Bar`, where `T` implements `trait Quux { type Bar; }`)\n and another type `U` that is required to be equal to `T::Bar`, but is not.\n Examples follow.\n \n@@ -1622,7 +1622,7 @@ representation of enums isn't strictly defined in Rust, and this attribute\n won't work on enums.\n \n `#[repr(simd)]` will give a struct consisting of a homogeneous series of machine\n-types (i.e. `u8`, `i32`, etc) a representation that permits vectorization via\n+types (i.e., `u8`, `i32`, etc) a representation that permits vectorization via\n SIMD. This doesn't make much sense for enums since they don't consist of a\n single list of data.\n \"##,"}, {"sha": "fb3c3dec7c2bec8f570c51b940a8ace3fae17be4", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -46,7 +46,7 @@ pub enum NonMacroAttrKind {\n pub enum Def {\n     // Type namespace\n     Mod(DefId),\n-    Struct(DefId), // DefId refers to NodeId of the struct itself\n+    Struct(DefId), // `DefId` refers to `NodeId` of the struct itself\n     Union(DefId),\n     Enum(DefId),\n     Variant(DefId),\n@@ -63,27 +63,27 @@ pub enum Def {\n     PrimTy(hir::PrimTy),\n     TyParam(DefId),\n     SelfTy(Option<DefId> /* trait */, Option<DefId> /* impl */),\n-    ToolMod, // e.g. `rustfmt` in `#[rustfmt::skip]`\n+    ToolMod, // e.g., `rustfmt` in `#[rustfmt::skip]`\n \n     // Value namespace\n     Fn(DefId),\n     Const(DefId),\n     Static(DefId, bool /* is_mutbl */),\n-    StructCtor(DefId, CtorKind), // DefId refers to NodeId of the struct's constructor\n-    VariantCtor(DefId, CtorKind), // DefId refers to the enum variant\n-    SelfCtor(DefId /* impl */),  // DefId refers to the impl\n+    StructCtor(DefId, CtorKind), // `DefId` refers to `NodeId` of the struct's constructor\n+    VariantCtor(DefId, CtorKind), // `DefId` refers to the enum variant\n+    SelfCtor(DefId /* impl */),  // `DefId` refers to the impl\n     Method(DefId),\n     AssociatedConst(DefId),\n \n     Local(ast::NodeId),\n-    Upvar(ast::NodeId,  // node id of closed over local\n-          usize,        // index in the freevars list of the closure\n+    Upvar(ast::NodeId,  // `NodeId` of closed over local\n+          usize,        // index in the `freevars` list of the closure\n           ast::NodeId), // expr node that creates the closure\n     Label(ast::NodeId),\n \n     // Macro namespace\n     Macro(DefId, MacroKind),\n-    NonMacroAttr(NonMacroAttrKind), // e.g. `#[inline]` or `#[rustfmt::skip]`\n+    NonMacroAttr(NonMacroAttrKind), // e.g., `#[inline]` or `#[rustfmt::skip]`\n \n     // Both namespaces\n     Err,\n@@ -170,6 +170,7 @@ impl<T> PerNS<T> {\n \n impl<T> ::std::ops::Index<Namespace> for PerNS<T> {\n     type Output = T;\n+\n     fn index(&self, ns: Namespace) -> &T {\n         match ns {\n             ValueNS => &self.value_ns,\n@@ -238,6 +239,7 @@ impl CtorKind {\n             ast::VariantData::Struct(..) => CtorKind::Fictive,\n         }\n     }\n+\n     pub fn from_hir(vdata: &hir::VariantData) -> CtorKind {\n         match *vdata {\n             hir::VariantData::Tuple(..) => CtorKind::Fn,"}, {"sha": "f7e2c7036f6f8c43721280425cde7b61b96aecaf", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -131,7 +131,7 @@ impl<'this, 'tcx> NestedVisitorMap<'this, 'tcx> {\n /// Each method of the Visitor trait is a hook to be potentially\n /// overridden.  Each method's default implementation recursively visits\n /// the substructure of the input via the corresponding `walk` method;\n-/// e.g. the `visit_mod` method by default calls `intravisit::walk_mod`.\n+/// e.g., the `visit_mod` method by default calls `intravisit::walk_mod`.\n ///\n /// Note that this visitor does NOT visit nested items by default\n /// (this is why the module is called `intravisit`, to distinguish it\n@@ -493,7 +493,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                              item.id)\n         }\n         ItemKind::Mod(ref module) => {\n-            // visit_mod() takes care of visiting the Item's NodeId\n+            // `visit_mod()` takes care of visiting the `Item`'s `NodeId`.\n             visitor.visit_mod(module, item.span, item.id)\n         }\n         ItemKind::ForeignMod(ref foreign_module) => {\n@@ -518,7 +518,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         }\n         ItemKind::Enum(ref enum_definition, ref type_parameters) => {\n             visitor.visit_generics(type_parameters);\n-            // visit_enum_def() takes care of visiting the Item's NodeId\n+            // `visit_enum_def()` takes care of visiting the `Item`'s `NodeId`.\n             visitor.visit_enum_def(enum_definition, type_parameters, item.id, item.span)\n         }\n         ItemKind::Impl(\n@@ -877,7 +877,7 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n }\n \n pub fn walk_trait_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_item_ref: &'v TraitItemRef) {\n-    // NB: Deliberately force a compilation error if/when new fields are added.\n+    // N.B., deliberately force a compilation error if/when new fields are added.\n     let TraitItemRef { id, ident, ref kind, span: _, ref defaultness } = *trait_item_ref;\n     visitor.visit_nested_trait_item(id);\n     visitor.visit_ident(ident);\n@@ -886,7 +886,7 @@ pub fn walk_trait_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_item_ref:\n }\n \n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem) {\n-    // NB: Deliberately force a compilation error if/when new fields are added.\n+    // N.B., deliberately force a compilation error if/when new fields are added.\n     let ImplItem {\n         id: _,\n         hir_id: _,\n@@ -932,7 +932,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n }\n \n pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'v ImplItemRef) {\n-    // NB: Deliberately force a compilation error if/when new fields are added.\n+    // N.B., deliberately force a compilation error if/when new fields are added.\n     let ImplItemRef { id, ident, ref kind, span: _, ref vis, ref defaultness } = *impl_item_ref;\n     visitor.visit_nested_impl_item(id);\n     visitor.visit_ident(ident);"}, {"sha": "6fd0ccb49b6d7ee7ae952bfb3894fb33fc72f477", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 75, "deletions": 74, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -82,7 +82,7 @@ const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n pub struct LoweringContext<'a> {\n     crate_root: Option<&'static str>,\n \n-    // Use to assign ids to hir nodes that do not directly correspond to an ast node\n+    // Used to assign ids to HIR nodes that do not directly correspond to an AST node.\n     sess: &'a Session,\n \n     cstore: &'a dyn CrateStore,\n@@ -114,10 +114,10 @@ pub struct LoweringContext<'a> {\n     anonymous_lifetime_mode: AnonymousLifetimeMode,\n \n     // Used to create lifetime definitions from in-band lifetime usages.\n-    // e.g. `fn foo(x: &'x u8) -> &'x u8` to `fn foo<'x>(x: &'x u8) -> &'x u8`\n+    // e.g., `fn foo(x: &'x u8) -> &'x u8` to `fn foo<'x>(x: &'x u8) -> &'x u8`\n     // When a named lifetime is encountered in a function or impl header and\n     // has not been defined\n-    // (i.e. it doesn't appear in the in_scope_lifetimes list), it is added\n+    // (i.e., it doesn't appear in the in_scope_lifetimes list), it is added\n     // to this list. The results of this list are then added to the list of\n     // lifetime definitions in the corresponding impl or function generics.\n     lifetimes_to_define: Vec<(Span, ParamName)>,\n@@ -149,7 +149,7 @@ pub trait Resolver {\n         is_value: bool,\n     ) -> hir::Path;\n \n-    /// Obtain the resolution for a node id\n+    /// Obtain the resolution for a node-id.\n     fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution>;\n \n     /// Obtain the possible resolutions for the given `use` statement.\n@@ -159,8 +159,8 @@ pub trait Resolver {\n     /// This should only return `None` during testing.\n     fn definitions(&mut self) -> &mut Definitions;\n \n-    /// Given suffix [\"b\",\"c\",\"d\"], creates a HIR path for `[::crate_root]::b::c::d` and resolves\n-    /// it based on `is_value`.\n+    /// Given suffix `[\"b\", \"c\", \"d\"]`, creates a HIR path for `[::crate_root]::b::c::d` and\n+    /// resolves it based on `is_value`.\n     fn resolve_str_path(\n         &mut self,\n         span: Span,\n@@ -185,7 +185,7 @@ enum ImplTraitContext<'a> {\n     ///\n     /// We optionally store a `DefId` for the parent item here so we can look up necessary\n     /// information later. It is `None` when no information about the context should be stored,\n-    /// e.g. for consts and statics.\n+    /// e.g., for consts and statics.\n     Existential(Option<DefId>),\n \n     /// `impl Trait` is not accepted in this position.\n@@ -358,8 +358,8 @@ impl<'a> LoweringContext<'a> {\n     fn lower_crate(mut self, c: &Crate) -> hir::Crate {\n         /// Full-crate AST visitor that inserts into a fresh\n         /// `LoweringContext` any information that may be\n-        /// needed from arbitrary locations in the crate.\n-        /// E.g. The number of lifetime generic parameters\n+        /// needed from arbitrary locations in the crate,\n+        /// e.g., the number of lifetime generic parameters\n         /// declared for every type and trait definition.\n         struct MiscCollector<'lcx, 'interner: 'lcx> {\n             lctx: &'lcx mut LoweringContext<'interner>,\n@@ -512,7 +512,7 @@ impl<'a> LoweringContext<'a> {\n                 debug\n             );\n         }\n-        // Always allocate the first HirId for the owner itself\n+        // Always allocate the first `HirId` for the owner itself.\n         self.lower_node_id_with_owner(owner, owner)\n     }\n \n@@ -536,7 +536,7 @@ impl<'a> LoweringContext<'a> {\n         let existing_hir_id = self.node_id_to_hir_id[ast_node_id];\n \n         if existing_hir_id == hir::DUMMY_HIR_ID {\n-            // Generate a new HirId\n+            // Generate a new `HirId`.\n             let hir_id = alloc_hir_id(self);\n             self.node_id_to_hir_id[ast_node_id] = hir_id;\n             LoweredNodeId {\n@@ -573,12 +573,12 @@ impl<'a> LoweringContext<'a> {\n         ret\n     }\n \n-    /// This method allocates a new HirId for the given NodeId and stores it in\n-    /// the LoweringContext's NodeId => HirId map.\n-    /// Take care not to call this method if the resulting HirId is then not\n+    /// This method allocates a new `HirId` for the given `NodeId` and stores it in\n+    /// the `LoweringContext`'s `NodeId => HirId` map.\n+    /// Take care not to call this method if the resulting `HirId` is then not\n     /// actually used in the HIR, as that would trigger an assertion in the\n-    /// HirIdValidator later on, which makes sure that all NodeIds got mapped\n-    /// properly. Calling the method twice with the same NodeId is fine though.\n+    /// `HirIdValidator` later on, which makes sure that all `NodeId`s got mapped\n+    /// properly. Calling the method twice with the same `NodeId` is fine though.\n     fn lower_node_id(&mut self, ast_node_id: NodeId) -> LoweredNodeId {\n         self.lower_node_id_generic(ast_node_id, |this| {\n             let &mut (def_index, ref mut local_id_counter) =\n@@ -743,7 +743,7 @@ impl<'a> LoweringContext<'a> {\n                     ),\n                 };\n \n-                // Add a definition for the in-band lifetime def\n+                // Add a definition for the in-band lifetime def.\n                 self.resolver.definitions().create_def_with_parent(\n                     parent_id.index,\n                     def_node_id,\n@@ -1067,7 +1067,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_attr(&mut self, attr: &Attribute) -> Attribute {\n         // Note that we explicitly do not walk the path. Since we don't really\n         // lower attributes (we use the AST version) there is nowhere to keep\n-        // the HirIds. We don't actually need HIR version of attributes anyway.\n+        // the `HirId`s. We don't actually need HIR version of attributes anyway.\n         Attribute {\n             id: attr.id,\n             style: attr.style,\n@@ -1246,7 +1246,7 @@ impl<'a> LoweringContext<'a> {\n                     }\n                     ImplTraitContext::Universal(in_band_ty_params) => {\n                         self.lower_node_id(def_node_id);\n-                        // Add a definition for the in-band Param\n+                        // Add a definition for the in-band `Param`.\n                         let def_index = self\n                             .resolver\n                             .definitions()\n@@ -1257,7 +1257,7 @@ impl<'a> LoweringContext<'a> {\n                             bounds,\n                             ImplTraitContext::Universal(in_band_ty_params),\n                         );\n-                        // Set the name to `impl Bound1 + Bound2`\n+                        // Set the name to `impl Bound1 + Bound2`.\n                         let ident = Ident::from_str(&pprust::ty_to_string(t)).with_span_pos(span);\n                         in_band_ty_params.push(hir::GenericParam {\n                             id: def_node_id,\n@@ -1365,7 +1365,7 @@ impl<'a> LoweringContext<'a> {\n                 impl_trait_fn: fn_def_id,\n             });\n             let exist_ty_id = lctx.lower_node_id(exist_ty_node_id);\n-            // Generate an `existential type Foo: Trait;` declaration\n+            // Generate an `existential type Foo: Trait;` declaration.\n             trace!(\"creating existential type with id {:#?}\", exist_ty_id);\n \n             trace!(\"exist ty def index: {:#?}\", exist_ty_def_index);\n@@ -1384,7 +1384,7 @@ impl<'a> LoweringContext<'a> {\n             // does not actually exist in the AST.\n             lctx.items.insert(exist_ty_id.node_id, exist_ty_item);\n \n-            // `impl Trait` now just becomes `Foo<'a, 'b, ..>`\n+            // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n             hir::TyKind::Def(hir::ItemId { id: exist_ty_id.node_id }, lifetimes)\n         })\n     }\n@@ -1397,7 +1397,7 @@ impl<'a> LoweringContext<'a> {\n     ) -> (HirVec<hir::GenericArg>, HirVec<hir::GenericParam>) {\n         // This visitor walks over impl trait bounds and creates defs for all lifetimes which\n         // appear in the bounds, excluding lifetimes that are created within the bounds.\n-        // e.g. 'a, 'b, but not 'c in `impl for<'c> SomeTrait<'a, 'b, 'c>`\n+        // E.g., `'a`, `'b`, but not `'c` in `impl for<'c> SomeTrait<'a, 'b, 'c>`.\n         struct ImplTraitLifetimeCollector<'r, 'a: 'r> {\n             context: &'r mut LoweringContext<'a>,\n             parent: DefIndex,\n@@ -1429,7 +1429,7 @@ impl<'a> LoweringContext<'a> {\n             }\n \n             fn visit_ty(&mut self, t: &'v hir::Ty) {\n-                // Don't collect elided lifetimes used inside of `fn()` syntax\n+                // Don't collect elided lifetimes used inside of `fn()` syntax.\n                 if let hir::TyKind::BareFn(_) = t.node {\n                     let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n                     self.collect_elided_lifetimes = false;\n@@ -1459,10 +1459,10 @@ impl<'a> LoweringContext<'a> {\n             }\n \n             fn visit_generic_param(&mut self, param: &'v hir::GenericParam) {\n-                // Record the introduction of 'a in `for<'a> ...`\n+                // Record the introduction of 'a in `for<'a> ...`.\n                 if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n                     // Introduce lifetimes one at a time so that we can handle\n-                    // cases like `fn foo<'d>() -> impl for<'a, 'b: 'a, 'c: 'b + 'd>`\n+                    // cases like `fn foo<'d>() -> impl for<'a, 'b: 'a, 'c: 'b + 'd>`.\n                     let lt_name = hir::LifetimeName::Param(param.name);\n                     self.currently_bound_lifetimes.push(lt_name);\n                 }\n@@ -1475,7 +1475,7 @@ impl<'a> LoweringContext<'a> {\n                     hir::LifetimeName::Implicit | hir::LifetimeName::Underscore => {\n                         if self.collect_elided_lifetimes {\n                             // Use `'_` for both implicit and underscore lifetimes in\n-                            // `abstract type Foo<'_>: SomeTrait<'_>;`\n+                            // `abstract type Foo<'_>: SomeTrait<'_>;`.\n                             hir::LifetimeName::Underscore\n                         } else {\n                             return;\n@@ -1648,7 +1648,7 @@ impl<'a> LoweringContext<'a> {\n                         {\n                             ParenthesizedGenericArgs::Ok\n                         }\n-                        // Avoid duplicated errors\n+                        // Avoid duplicated errors.\n                         Def::Err => ParenthesizedGenericArgs::Ok,\n                         // An error\n                         Def::Struct(..)\n@@ -1689,27 +1689,27 @@ impl<'a> LoweringContext<'a> {\n         });\n \n         // Simple case, either no projections, or only fully-qualified.\n-        // E.g. `std::mem::size_of` or `<I as Iterator>::Item`.\n+        // E.g., `std::mem::size_of` or `<I as Iterator>::Item`.\n         if resolution.unresolved_segments() == 0 {\n             return hir::QPath::Resolved(qself, path);\n         }\n \n         // Create the innermost type that we're projecting from.\n         let mut ty = if path.segments.is_empty() {\n             // If the base path is empty that means there exists a\n-            // syntactical `Self`, e.g. `&i32` in `<&i32>::clone`.\n+            // syntactical `Self`, e.g., `&i32` in `<&i32>::clone`.\n             qself.expect(\"missing QSelf for <T>::...\")\n         } else {\n             // Otherwise, the base path is an implicit `Self` type path,\n-            // e.g. `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n+            // e.g., `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n             // `<I as Iterator>::Item::default`.\n             let new_id = self.next_id();\n             P(self.ty_path(new_id, p.span, hir::QPath::Resolved(qself, path)))\n         };\n \n         // Anything after the base path are associated \"extensions\",\n         // out of which all but the last one are associated types,\n-        // e.g. for `std::vec::Vec::<T>::IntoIter::Item::clone`:\n+        // e.g., for `std::vec::Vec::<T>::IntoIter::Item::clone`:\n         // * base path is `std::vec::Vec<T>`\n         // * \"extensions\" are `IntoIter`, `Item` and `clone`\n         // * type nodes are:\n@@ -1739,7 +1739,7 @@ impl<'a> LoweringContext<'a> {\n             ty = P(self.ty_path(new_id, p.span, qpath));\n         }\n \n-        // Should've returned in the for loop above.\n+        // We should've returned in the for loop above.\n         span_bug!(\n             p.span,\n             \"lower_qpath: no final extension segment in {}..{}\",\n@@ -1838,11 +1838,11 @@ impl<'a> LoweringContext<'a> {\n                 let no_bindings = generic_args.bindings.is_empty();\n                 let (incl_angl_brckt, insertion_span, suggestion) = if no_ty_args && no_bindings {\n                     // If there are no (non-implicit) generic args or associated-type\n-                    // bindings, our suggestion includes the angle brackets\n+                    // bindings, our suggestion includes the angle brackets.\n                     (true, path_span.shrink_to_hi(), format!(\"<{}>\", anon_lt_suggestion))\n                 } else {\n                     // Otherwise\u2014sorry, this is kind of gross\u2014we need to infer the\n-                    // place to splice in the `'_, ` from the generics that do exist\n+                    // place to splice in the `'_, ` from the generics that do exist.\n                     let first_generic_span = first_generic_span\n                         .expect(\"already checked that type args or bindings exist\");\n                     (false, first_generic_span.shrink_to_lo(), format!(\"{}, \", anon_lt_suggestion))\n@@ -2096,14 +2096,15 @@ impl<'a> LoweringContext<'a> {\n         return_impl_trait_id: NodeId,\n     ) -> hir::FunctionRetTy {\n         // Get lifetimes used in the input arguments to the function. Our output type must also\n-        // have the same lifetime. FIXME(cramertj) multiple different lifetimes are not allowed\n-        // because `impl Trait + 'a + 'b` doesn't allow for capture `'a` and `'b` where neither\n-        // is a subset of the other. We really want some new lifetime that is a subset of all input\n-        // lifetimes, but that doesn't exist at the moment.\n+        // have the same lifetime.\n+        // FIXME(cramertj): multiple different lifetimes are not allowed because\n+        // `impl Trait + 'a + 'b` doesn't allow for capture `'a` and `'b` where neither is a subset\n+        // of the other. We really want some new lifetime that is a subset of all input lifetimes,\n+        // but that doesn't exist at the moment.\n \n         struct AsyncFnLifetimeCollector<'r, 'a: 'r> {\n             context: &'r mut LoweringContext<'a>,\n-            // Lifetimes bound by HRTB\n+            // Lifetimes bound by HRTB.\n             currently_bound_lifetimes: Vec<hir::LifetimeName>,\n             // Whether to count elided lifetimes.\n             // Disabled inside of `Fn` or `fn` syntax.\n@@ -2133,7 +2134,7 @@ impl<'a> LoweringContext<'a> {\n             }\n \n             fn visit_ty(&mut self, t: &'v hir::Ty) {\n-                // Don't collect elided lifetimes used inside of `fn()` syntax\n+                // Don't collect elided lifetimes used inside of `fn()` syntax.\n                 if let &hir::TyKind::BareFn(_) = &t.node {\n                     let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n                     self.collect_elided_lifetimes = false;\n@@ -2424,7 +2425,7 @@ impl<'a> LoweringContext<'a> {\n             GenericParamKind::Type { ref default, .. } => {\n                 // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n                 // `rustc::ty` expects `Self` to be only used for a trait's `Self`.\n-                // Instead, use gensym(\"Self\") to create a distinct name that looks the same.\n+                // Instead, use `gensym(\"Self\")` to create a distinct name that looks the same.\n                 let ident = if param.ident.name == keywords::SelfUpper.name() {\n                     param.ident.gensym()\n                 } else {\n@@ -2467,7 +2468,7 @@ impl<'a> LoweringContext<'a> {\n         -> hir::Generics\n     {\n         // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n-        // FIXME: This could probably be done with less rightward drift. Also looks like two control\n+        // FIXME: this could probably be done with less rightward drift. Also looks like two control\n         //        paths where report_error is called are also the only paths that advance to after\n         //        the match statement, so the error reporting could probably just be moved there.\n         let mut add_bounds: NodeMap<Vec<_>> = Default::default();\n@@ -2563,7 +2564,7 @@ impl<'a> LoweringContext<'a> {\n                                 .iter()\n                                 .filter_map(|bound| match *bound {\n                                     // Ignore `?Trait` bounds.\n-                                    // Tthey were copied into type parameters already.\n+                                    // They were copied into type parameters already.\n                                     GenericBound::Trait(_, TraitBoundModifier::Maybe) => None,\n                                     _ => Some(this.lower_param_bound(\n                                         bound,\n@@ -2662,7 +2663,7 @@ impl<'a> LoweringContext<'a> {\n             id: self.lower_node_id(f.id).node_id,\n             ident: match f.ident {\n                 Some(ident) => ident,\n-                // FIXME(jseyfried) positional field hygiene\n+                // FIXME(jseyfried): positional field hygiene\n                 None => Ident::new(Symbol::intern(&index.to_string()), f.span),\n             },\n             vis: self.lower_visibility(&f.vis, None),\n@@ -2946,7 +2947,7 @@ impl<'a> LoweringContext<'a> {\n         }\n \n         // [1] `defaultness.has_value()` is never called for an `impl`, always `true` in order to\n-        //     not cause an assertion failure inside the `lower_defaultness` function\n+        //     not cause an assertion failure inside the `lower_defaultness` function.\n     }\n \n     fn lower_use_tree(\n@@ -3190,7 +3191,7 @@ impl<'a> LoweringContext<'a> {\n \n     /// Paths like the visibility path in `pub(super) use foo::{bar, baz}` are repeated\n     /// many times in the HIR tree; for each occurrence, we need to assign distinct\n-    /// node-ids. (See e.g. #56128.)\n+    /// node-ids. (See e.g., #56128.)\n     fn renumber_segment_ids(&mut self, path: &P<hir::Path>) -> P<hir::Path> {\n         debug!(\"renumber_segment_ids(path = {:?})\", path);\n         let mut path = path.clone();\n@@ -3780,7 +3781,7 @@ impl<'a> LoweringContext<'a> {\n                 let else_opt = else_opt.as_ref().map(|els| {\n                     match els.node {\n                         ExprKind::IfLet(..) => {\n-                            // wrap the if-let expr in a block\n+                            // Wrap the `if let` expr in a block.\n                             let span = els.span;\n                             let els = P(self.lower_expr(els));\n                             let LoweredNodeId { node_id, hir_id } = self.next_id();\n@@ -3871,7 +3872,7 @@ impl<'a> LoweringContext<'a> {\n                     let fn_decl = self.lower_fn_decl(&outer_decl, None, false, None);\n \n                     self.with_new_scopes(|this| {\n-                        // FIXME(cramertj) allow `async` non-`move` closures with\n+                        // FIXME(cramertj): allow `async` non-`move` closures with arguments.\n                         if capture_clause == CaptureBy::Ref &&\n                             !decl.inputs.is_empty()\n                         {\n@@ -3883,13 +3884,13 @@ impl<'a> LoweringContext<'a> {\n                                 are not currently supported\",\n                             )\n                                 .help(\"consider using `let` statements to manually capture \\\n-                                        variables by reference before entering an \\\n-                                        `async move` closure\")\n+                                       variables by reference before entering an \\\n+                                       `async move` closure\")\n                                 .emit();\n                         }\n \n                         // Transform `async |x: u8| -> X { ... }` into\n-                        // `|x: u8| future_from_generator(|| -> X { ... })`\n+                        // `|x: u8| future_from_generator(|| -> X { ... })`.\n                         let body_id = this.lower_body(Some(&outer_decl), |this| {\n                             let async_ret_ty = if let FunctionRetTy::Ty(ty) = &decl.output {\n                                 Some(&**ty)\n@@ -3972,7 +3973,7 @@ impl<'a> LoweringContext<'a> {\n             ExprKind::Index(ref el, ref er) => {\n                 hir::ExprKind::Index(P(self.lower_expr(el)), P(self.lower_expr(er)))\n             }\n-            // Desugar `<start>..=<end>` to `std::ops::RangeInclusive::new(<start>, <end>)`\n+            // Desugar `<start>..=<end>` into `std::ops::RangeInclusive::new(<start>, <end>)`.\n             ExprKind::Range(Some(ref e1), Some(ref e2), RangeLimits::Closed) => {\n                 let id = self.next_id();\n                 let e1 = self.lower_expr(e1);\n@@ -4106,11 +4107,11 @@ impl<'a> LoweringContext<'a> {\n             ),\n             ExprKind::Paren(ref ex) => {\n                 let mut ex = self.lower_expr(ex);\n-                // include parens in span, but only if it is a super-span.\n+                // Include parens in span, but only if it is a super-span.\n                 if e.span.contains(ex.span) {\n                     ex.span = e.span;\n                 }\n-                // merge attributes into the inner expression.\n+                // Merge attributes into the inner expression.\n                 let mut attrs = e.attrs.clone();\n                 attrs.extend::<Vec<_>>(ex.attrs.into());\n                 ex.attrs = attrs;\n@@ -4128,8 +4129,8 @@ impl<'a> LoweringContext<'a> {\n                 hir::ExprKind::Yield(P(expr))\n             }\n \n-            // Desugar ExprIfLet\n-            // From: `if let <pat> = <sub_expr> <body> [<else_opt>]`\n+            // Desugar `ExprIfLet`\n+            // from: `if let <pat> = <sub_expr> <body> [<else_opt>]`\n             ExprKind::IfLet(ref pats, ref sub_expr, ref body, ref else_opt) => {\n                 // to:\n                 //\n@@ -4173,8 +4174,8 @@ impl<'a> LoweringContext<'a> {\n                 )\n             }\n \n-            // Desugar ExprWhileLet\n-            // From: `[opt_ident]: while let <pat> = <sub_expr> <body>`\n+            // Desugar `ExprWhileLet`\n+            // from: `[opt_ident]: while let <pat> = <sub_expr> <body>`\n             ExprKind::WhileLet(ref pats, ref sub_expr, ref body, opt_label) => {\n                 // to:\n                 //\n@@ -4223,12 +4224,12 @@ impl<'a> LoweringContext<'a> {\n                     self.lower_label(opt_label),\n                     hir::LoopSource::WhileLet,\n                 );\n-                // add attributes to the outer returned expr node\n+                // Add attributes to the outer returned expr node.\n                 loop_expr\n             }\n \n-            // Desugar ExprForLoop\n-            // From: `[opt_ident]: for <pat> in <head> <body>`\n+            // Desugar `ExprForLoop`\n+            // from: `[opt_ident]: for <pat> in <head> <body>`\n             ExprKind::ForLoop(ref pat, ref head, ref body, opt_label) => {\n                 // to:\n                 //\n@@ -4386,21 +4387,21 @@ impl<'a> LoweringContext<'a> {\n                 ));\n \n                 // `{ let _result = ...; _result }`\n-                // underscore prevents an unused_variables lint if the head diverges\n+                // Underscore prevents an `unused_variables` lint if the head diverges.\n                 let result_ident = self.str_to_ident(\"_result\");\n                 let (let_stmt, let_stmt_binding) =\n                     self.stmt_let(e.span, false, result_ident, match_expr);\n \n                 let result = P(self.expr_ident(e.span, result_ident, let_stmt_binding));\n                 let block = P(self.block_all(e.span, hir_vec![let_stmt], Some(result)));\n-                // add the attributes to the outer returned expr node\n+                // Add the attributes to the outer returned expr node.\n                 return self.expr_block(block, e.attrs.clone());\n             }\n \n-            // Desugar ExprKind::Try\n-            // From: `<expr>?`\n+            // Desugar `ExprKind::Try`\n+            // from: `<expr>?`\n             ExprKind::Try(ref sub_expr) => {\n-                // to:\n+                // into:\n                 //\n                 // match Try::into_result(<expr>) {\n                 //     Ok(val) => #[allow(unreachable_code)] val,\n@@ -4414,7 +4415,7 @@ impl<'a> LoweringContext<'a> {\n                 let unstable_span =\n                     self.allow_internal_unstable(CompilerDesugaringKind::QuestionMark, e.span);\n \n-                // Try::into_result(<expr>)\n+                // `Try::into_result(<expr>)`\n                 let discr = {\n                     // expand <expr>\n                     let sub_expr = self.lower_expr(sub_expr);\n@@ -4425,9 +4426,9 @@ impl<'a> LoweringContext<'a> {\n                     P(self.expr_call(e.span, path, hir_vec![sub_expr]))\n                 };\n \n-                // #[allow(unreachable_code)]\n+                // `#[allow(unreachable_code)]`\n                 let attr = {\n-                    // allow(unreachable_code)\n+                    // `allow(unreachable_code)`\n                     let allow = {\n                         let allow_ident = Ident::from_str(\"allow\").with_span_pos(e.span);\n                         let uc_ident = Ident::from_str(\"unreachable_code\").with_span_pos(e.span);\n@@ -4438,7 +4439,7 @@ impl<'a> LoweringContext<'a> {\n                 };\n                 let attrs = vec![attr];\n \n-                // Ok(val) => #[allow(unreachable_code)] val,\n+                // `Ok(val) => #[allow(unreachable_code)] val,`\n                 let ok_arm = {\n                     let val_ident = self.str_to_ident(\"val\");\n                     let val_pat = self.pat_ident(e.span, val_ident);\n@@ -4453,8 +4454,8 @@ impl<'a> LoweringContext<'a> {\n                     self.arm(hir_vec![ok_pat], val_expr)\n                 };\n \n-                // Err(err) => #[allow(unreachable_code)]\n-                //             return Try::from_error(From::from(err)),\n+                // `Err(err) => #[allow(unreachable_code)]\n+                //              return Try::from_error(From::from(err)),`\n                 let err_arm = {\n                     let err_ident = self.str_to_ident(\"err\");\n                     let err_local = self.pat_ident(e.span, err_ident);\n@@ -5014,7 +5015,7 @@ impl<'a> LoweringContext<'a> {\n     /// error, depending on the mode.\n     fn elided_path_lifetimes(&mut self, span: Span, count: usize) -> P<[hir::Lifetime]> {\n         match self.anonymous_lifetime_mode {\n-            // NB. We intentionally ignore the create-parameter mode here\n+            // N.B., We intentionally ignore the create-parameter mode here\n             // and instead \"pass through\" to resolve-lifetimes, which will then\n             // report an error. This is because we don't want to support\n             // impl elision for deprecated forms like"}, {"sha": "40904eaa5db62905b76d2866f0f8e7f8162431fb", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -13,7 +13,7 @@\n //! it captures a common set of attributes that all \"function-like\n //! things\" (represented by `FnLike` instances) share.  For example,\n //! all `FnLike` instances have a type signature (be it explicit or\n-//! inferred).  And all `FnLike` instances have a body, i.e. the code\n+//! inferred).  And all `FnLike` instances have a body, i.e., the code\n //! that is run when the function-like thing it represents is invoked.\n //!\n //! With the above abstraction in place, one can treat the program\n@@ -34,7 +34,7 @@ use syntax_pos::Span;\n /// More specifically, it is one of either:\n ///\n ///   - A function item,\n-///   - A closure expr (i.e. an ExprKind::Closure), or\n+///   - A closure expr (i.e., an ExprKind::Closure), or\n ///   - The default implementation for a trait method.\n ///\n /// To construct one, use the `Code::from_node` function."}, {"sha": "d5031efae576b86a1708926aed3dceb35632e090", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -150,10 +150,9 @@ impl Decodable for DefPathTable {\n     }\n }\n \n-\n /// The definition table containing node definitions.\n-/// It holds the DefPathTable for local DefIds/DefPaths and it also stores a\n-/// mapping from NodeIds to local DefIds.\n+/// It holds the `DefPathTable` for local `DefId`s/`DefPath`s and it also stores a\n+/// mapping from `NodeId`s to local `DefId`s.\n #[derive(Clone, Default)]\n pub struct Definitions {\n     table: DefPathTable,"}, {"sha": "b98e279aef4b964080c76e42e19f3556cf08d4de", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -286,9 +286,7 @@ impl<'hir> Map<'hir> {\n \n         match node {\n             Node::Item(item) => {\n-                let def_id = || {\n-                    self.local_def_id(item.id)\n-                };\n+                let def_id = || self.local_def_id(item.id);\n \n                 match item.node {\n                     ItemKind::Static(_, m, _) => Some(Def::Static(def_id(), m == MutMutable)),\n@@ -383,23 +381,23 @@ impl<'hir> Map<'hir> {\n     pub fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem {\n         self.read(id.node_id);\n \n-        // NB: intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n         self.forest.krate.trait_item(id)\n     }\n \n     pub fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem {\n         self.read(id.node_id);\n \n-        // NB: intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n         self.forest.krate.impl_item(id)\n     }\n \n     pub fn body(&self, id: BodyId) -> &'hir Body {\n         self.read(id.node_id);\n \n-        // NB: intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n         self.forest.krate.body(id)\n     }\n@@ -413,7 +411,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// Returns the `NodeId` that corresponds to the definition of\n-    /// which this is the body of, i.e. a `fn`, `const` or `static`\n+    /// which this is the body of, i.e., a `fn`, `const` or `static`\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n     pub fn body_owner(&self, BodyId { node_id }: BodyId) -> NodeId {\n         let parent = self.get_parent_node(node_id);\n@@ -484,15 +482,15 @@ impl<'hir> Map<'hir> {\n     pub fn trait_impls(&self, trait_did: DefId) -> &'hir [NodeId] {\n         self.dep_graph.read(DepNode::new_no_params(DepKind::AllLocalTraitImpls));\n \n-        // NB: intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n         self.forest.krate.trait_impls.get(&trait_did).map_or(&[], |xs| &xs[..])\n     }\n \n     pub fn trait_auto_impl(&self, trait_did: DefId) -> Option<NodeId> {\n         self.dep_graph.read(DepNode::new_no_params(DepKind::AllLocalTraitImpls));\n \n-        // NB: intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n         self.forest.krate.trait_auto_impl.get(&trait_did).cloned()\n     }\n@@ -565,14 +563,14 @@ impl<'hir> Map<'hir> {\n         result\n     }\n \n-    /// Similar to get_parent, returns the parent node id or id if there is no\n-    /// parent. Note that the parent may be CRATE_NODE_ID, which is not itself\n+    /// Similar to `get_parent`; returns the parent node-id, or own `id` if there is\n+    /// no parent. Note that the parent may be `CRATE_NODE_ID`, which is not itself\n     /// present in the map -- so passing the return value of get_parent_node to\n     /// get may actually panic.\n     /// This function returns the immediate parent in the AST, whereas get_parent\n     /// returns the enclosing item. Note that this might not be the actual parent\n     /// node in the AST - some kinds of nodes are not in the map and these will\n-    /// never appear as the parent_node. So you can always walk the parent_nodes\n+    /// never appear as the parent_node. So you can always walk the `parent_nodes`\n     /// from a node to the root of the ast (unless you get the same id back here\n     /// that can happen if the id is not in the map itself or is just weird).\n     pub fn get_parent_node(&self, id: NodeId) -> NodeId {\n@@ -608,7 +606,7 @@ impl<'hir> Map<'hir> {\n \n     /// If there is some error when walking the parents (e.g., a node does not\n     /// have a parent in the map or a node can't be found), then we return the\n-    /// last good node id we found. Note that reaching the crate root (id == 0),\n+    /// last good node id we found. Note that reaching the crate root (`id == 0`),\n     /// is not an error, since items in the crate module have the crate root as\n     /// parent.\n     fn walk_parent_nodes<F, F2>(&self,\n@@ -644,7 +642,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    /// Retrieve the NodeId for `id`'s enclosing method, unless there's a\n+    /// Retrieve the `NodeId` for `id`'s enclosing method, unless there's a\n     /// `while` or `loop` before reaching it, as block tail returns are not\n     /// available in them.\n     ///\n@@ -691,7 +689,7 @@ impl<'hir> Map<'hir> {\n         self.walk_parent_nodes(id, match_fn, match_non_returning_block).ok()\n     }\n \n-    /// Retrieve the NodeId for `id`'s parent item, or `id` itself if no\n+    /// Retrieve the `NodeId` for `id`'s parent item, or `id` itself if no\n     /// parent item is in this map. The \"parent item\" is the closest parent node\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n@@ -708,13 +706,13 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    /// Returns the DefId of `id`'s nearest module parent, or `id` itself if no\n+    /// Returns the `DefId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub fn get_module_parent(&self, id: NodeId) -> DefId {\n         self.local_def_id(self.get_module_parent_node(id))\n     }\n \n-    /// Returns the NodeId of `id`'s nearest module parent, or `id` itself if no\n+    /// Returns the `NodeId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub fn get_module_parent_node(&self, id: NodeId) -> NodeId {\n         match self.walk_parent_nodes(id, |node| match *node {\n@@ -727,7 +725,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// Returns the nearest enclosing scope. A scope is an item or block.\n-    /// FIXME it is not clear to me that all items qualify as scopes - statics\n+    /// FIXME: it is not clear to me that all items qualify as scopes -- statics\n     /// and associated types probably shouldn't, for example. Behavior in this\n     /// regard should be expected to be highly unstable.\n     pub fn get_enclosing_scope(&self, id: NodeId) -> Option<NodeId> {"}, {"sha": "156d55b9e2fe61de4a2e97f9747fba2ed6217357", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// The Rust HIR.\n+// HIR datatypes. See the [rustc guide] for more info.\n+//!\n+//! [rustc guide]: https://rust-lang.github.io/rustc-guide/hir.html\n \n pub use self::BlockCheckMode::*;\n pub use self::CaptureClause::*;\n@@ -71,7 +73,7 @@ pub mod print;\n \n /// A HirId uniquely identifies a node in the HIR of the current crate. It is\n /// composed of the `owner`, which is the DefIndex of the directly enclosing\n-/// hir::Item, hir::TraitItem, or hir::ImplItem (i.e. the closest \"item-like\"),\n+/// hir::Item, hir::TraitItem, or hir::ImplItem (i.e., the closest \"item-like\"),\n /// and the `local_id` which is unique within the given owner.\n ///\n /// This two-level structure makes for more stable values: One can move an item\n@@ -181,7 +183,7 @@ pub enum ParamName {\n     Plain(Ident),\n \n     /// Synthetic name generated when user elided a lifetime in an impl header,\n-    /// e.g. the lifetimes in cases like these:\n+    /// e.g., the lifetimes in cases like these:\n     ///\n     ///     impl Foo for &u32\n     ///     impl Foo<'_> for u32\n@@ -197,7 +199,7 @@ pub enum ParamName {\n \n     /// Indicates an illegal name was given and an error has been\n     /// repored (so we should squelch other derived errors). Occurs\n-    /// when e.g. `'_` is used in the wrong place.\n+    /// when e.g., `'_` is used in the wrong place.\n     Error,\n }\n \n@@ -222,7 +224,7 @@ pub enum LifetimeName {\n     /// User-given names or fresh (synthetic) names.\n     Param(ParamName),\n \n-    /// User typed nothing. e.g. the lifetime in `&u32`.\n+    /// User typed nothing. e.g., the lifetime in `&u32`.\n     Implicit,\n \n     /// Indicates an error during lowering (usually `'_` in wrong place)\n@@ -351,7 +353,7 @@ pub struct PathSegment {\n     /// Whether to infer remaining type parameters, if any.\n     /// This only applies to expression and pattern paths, and\n     /// out of those only the segments with no type parameters\n-    /// to begin with, e.g. `Vec::new` is `<Vec<..>>::new::<..>`.\n+    /// to begin with, e.g., `Vec::new` is `<Vec<..>>::new::<..>`.\n     pub infer_types: bool,\n }\n \n@@ -388,7 +390,7 @@ impl PathSegment {\n     }\n \n     // FIXME: hack required because you can't create a static\n-    // GenericArgs, so you can't just return a &GenericArgs.\n+    // `GenericArgs`, so you can't just return a `&GenericArgs`.\n     pub fn with_generic_args<F, R>(&self, f: F) -> R\n         where F: FnOnce(&GenericArgs) -> R\n     {\n@@ -514,17 +516,17 @@ pub type GenericBounds = HirVec<GenericBound>;\n \n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n pub enum LifetimeParamKind {\n-    // Indicates that the lifetime definition was explicitly declared, like:\n-    // `fn foo<'a>(x: &'a u8) -> &'a u8 { x }`\n+    // Indicates that the lifetime definition was explicitly declared (e.g., in\n+    // `fn foo<'a>(x: &'a u8) -> &'a u8 { x }`).\n     Explicit,\n \n     // Indicates that the lifetime definition was synthetically added\n-    // as a result of an in-band lifetime usage like:\n-    // `fn foo(x: &'a u8) -> &'a u8 { x }`\n+    // as a result of an in-band lifetime usage (e.g., in\n+    // `fn foo(x: &'a u8) -> &'a u8 { x }`).\n     InBand,\n \n-    // Indication that the lifetime was elided like both cases here:\n-    // `fn foo(x: &u8) -> &'_ u8 { x }`\n+    // Indication that the lifetime was elided (e.g., in both cases in\n+    // `fn foo(x: &u8) -> &'_ u8 { x }`).\n     Elided,\n \n     // Indication that the lifetime name was somehow in error.\n@@ -533,7 +535,7 @@ pub enum LifetimeParamKind {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum GenericParamKind {\n-    /// A lifetime definition, eg `'a: 'b + 'c + 'd`.\n+    /// A lifetime definition (e.g., `'a: 'b + 'c + 'd`).\n     Lifetime {\n         kind: LifetimeParamKind,\n     },\n@@ -637,11 +639,11 @@ impl WhereClause {\n /// A single predicate in a `where` clause\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum WherePredicate {\n-    /// A type binding, eg `for<'c> Foo: Send+Clone+'c`\n+    /// A type binding (e.g., `for<'c> Foo: Send + Clone + 'c`).\n     BoundPredicate(WhereBoundPredicate),\n-    /// A lifetime predicate, e.g. `'a: 'b+'c`\n+    /// A lifetime predicate (e.g., `'a: 'b + 'c`).\n     RegionPredicate(WhereRegionPredicate),\n-    /// An equality predicate (unsupported)\n+    /// An equality predicate (unsupported).\n     EqPredicate(WhereEqPredicate),\n }\n \n@@ -667,15 +669,15 @@ pub struct WhereBoundPredicate {\n     pub bounds: GenericBounds,\n }\n \n-/// A lifetime predicate, e.g. `'a: 'b+'c`\n+/// A lifetime predicate, e.g., `'a: 'b+'c`\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereRegionPredicate {\n     pub span: Span,\n     pub lifetime: Lifetime,\n     pub bounds: GenericBounds,\n }\n \n-/// An equality predicate (unsupported), e.g. `T=int`\n+/// An equality predicate (unsupported), e.g., `T=int`\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereEqPredicate {\n     pub id: NodeId,\n@@ -697,7 +699,7 @@ pub struct Crate {\n     pub span: Span,\n     pub exported_macros: HirVec<MacroDef>,\n \n-    // NB: We use a BTreeMap here so that `visit_all_items` iterates\n+    // N.B., we use a BTreeMap here so that `visit_all_items` iterates\n     // over the ids in increasing order. In principle it should not\n     // matter what order we visit things in, but in *practice* it\n     // does, because it can affect the order in which errors are\n@@ -932,11 +934,11 @@ pub enum PatKind {\n \n     /// A fresh binding `ref mut binding @ OPT_SUBPATTERN`.\n     /// The `NodeId` is the canonical ID for the variable being bound,\n-    /// e.g. in `Ok(x) | Err(x)`, both `x` use the same canonical ID,\n+    /// e.g., in `Ok(x) | Err(x)`, both `x` use the same canonical ID,\n     /// which is the pattern ID of the first `x`.\n     Binding(BindingAnnotation, NodeId, Ident, Option<P<Pat>>),\n \n-    /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.\n+    /// A struct or struct variant pattern, e.g., `Variant {x, y, ..}`.\n     /// The `bool` is `true` in the presence of a `..`.\n     Struct(QPath, HirVec<Spanned<FieldPat>>, bool),\n \n@@ -954,11 +956,11 @@ pub enum PatKind {\n     Tuple(HirVec<P<Pat>>, Option<usize>),\n     /// A `box` pattern\n     Box(P<Pat>),\n-    /// A reference pattern, e.g. `&mut (a, b)`\n+    /// A reference pattern, e.g., `&mut (a, b)`\n     Ref(P<Pat>, Mutability),\n     /// A literal\n     Lit(P<Expr>),\n-    /// A range pattern, e.g. `1...2` or `1..2`\n+    /// A range pattern, e.g., `1...2` or `1..2`\n     Range(P<Expr>, P<Expr>, RangeEnd),\n     /// `[a, b, ..i, y, z]` is represented as:\n     ///     `PatKind::Slice(box [a, b], Some(i), box [y, z])`\n@@ -1319,8 +1321,8 @@ pub enum BodyOwnerKind {\n \n /// A constant (expression) that's not an item or associated item,\n /// but needs its own `DefId` for type-checking, const-eval, etc.\n-/// These are usually found nested inside types (e.g. array lengths)\n-/// or expressions (e.g. repeat counts), and also used to define\n+/// These are usually found nested inside types (e.g., array lengths)\n+/// or expressions (e.g., repeat counts), and also used to define\n /// explicit discriminant values for enum variants.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n pub struct AnonConst {\n@@ -1541,12 +1543,12 @@ pub enum QPath {\n     /// Path to a definition, optionally \"fully-qualified\" with a `Self`\n     /// type, if the path points to an associated item in a trait.\n     ///\n-    /// E.g. an unqualified path like `Clone::clone` has `None` for `Self`,\n+    /// e.g., an unqualified path like `Clone::clone` has `None` for `Self`,\n     /// while `<Vec<T> as Clone>::clone` has `Some(Vec<T>)` for `Self`,\n     /// even though they both have the same two-segment `Clone::clone` `Path`.\n     Resolved(Option<P<Ty>>, P<Path>),\n \n-    /// Type-related paths, e.g. `<T>::default` or `<T>::Output`.\n+    /// Type-related paths, e.g., `<T>::default` or `<T>::Output`.\n     /// Will be resolved by type-checking to an associated item.\n     ///\n     /// UFCS source paths can desugar into this, with `Vec::new` turning into\n@@ -1633,7 +1635,7 @@ pub enum CaptureClause {\n     CaptureByRef,\n }\n \n-// NB: If you change this, you'll probably want to change the corresponding\n+// N.B., if you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct MutTy {\n@@ -1792,14 +1794,14 @@ pub enum TyKind {\n     Ptr(MutTy),\n     /// A reference (`&'a T` or `&'a mut T`)\n     Rptr(Lifetime, MutTy),\n-    /// A bare function (e.g. `fn(usize) -> bool`)\n+    /// A bare function (e.g., `fn(usize) -> bool`)\n     BareFn(P<BareFnTy>),\n     /// The never type (`!`)\n     Never,\n     /// A tuple (`(A, B, C, D,...)`)\n     Tup(HirVec<Ty>),\n     /// A path to a type definition (`module::module::...::Type`), or an\n-    /// associated type, e.g. `<Vec<T> as Trait>::Type` or `<T>::Target`.\n+    /// associated type, e.g., `<Vec<T> as Trait>::Type` or `<T>::Target`.\n     ///\n     /// Type parameters may be stored in each `PathSegment`.\n     Path(QPath),\n@@ -1814,7 +1816,7 @@ pub enum TyKind {\n     TraitObject(HirVec<PolyTraitRef>, Lifetime),\n     /// Unused for now\n     Typeof(AnonConst),\n-    /// TyKind::Infer means the type should be inferred instead of it having been\n+    /// `TyKind::Infer` means the type should be inferred instead of it having been\n     /// specified. This can appear anywhere in a type.\n     Infer,\n     /// Placeholder for a type that has failed to be defined.\n@@ -2017,23 +2019,23 @@ pub struct VariantKind {\n     pub name: Name,\n     pub attrs: HirVec<Attribute>,\n     pub data: VariantData,\n-    /// Explicit discriminant, eg `Foo = 1`\n+    /// Explicit discriminant, e.g., `Foo = 1`\n     pub disr_expr: Option<AnonConst>,\n }\n \n pub type Variant = Spanned<VariantKind>;\n \n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n pub enum UseKind {\n-    /// One import, e.g. `use foo::bar` or `use foo::bar as baz`.\n+    /// One import, e.g., `use foo::bar` or `use foo::bar as baz`.\n     /// Also produced for each element of a list `use`, e.g.\n     // `use foo::{a, b}` lowers to `use foo::a; use foo::b;`.\n     Single,\n \n-    /// Glob import, e.g. `use foo::*`.\n+    /// Glob import, e.g., `use foo::*`.\n     Glob,\n \n-    /// Degenerate list import, e.g. `use foo::{a, b}` produces\n+    /// Degenerate list import, e.g., `use foo::{a, b}` produces\n     /// an additional `use foo::{}` for performing checks such as\n     /// unstable feature gating. May be removed in the future.\n     ListStem,\n@@ -2196,7 +2198,7 @@ pub struct FnHeader {\n pub enum ItemKind {\n     /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n     ///\n-    /// E.g. `extern crate foo` or `extern crate foo_bar as foo`\n+    /// e.g., `extern crate foo` or `extern crate foo_bar as foo`\n     ExternCrate(Option<Name>),\n \n     /// `use foo::bar::*;` or `use foo::bar::baz as quux;`\n@@ -2218,15 +2220,15 @@ pub enum ItemKind {\n     ForeignMod(ForeignMod),\n     /// Module-level inline assembly (from global_asm!)\n     GlobalAsm(P<GlobalAsm>),\n-    /// A type alias, e.g. `type Foo = Bar<u8>`\n+    /// A type alias, e.g., `type Foo = Bar<u8>`\n     Ty(P<Ty>, Generics),\n-    /// An existential type definition, e.g. `existential type Foo: Bar;`\n+    /// An existential type definition, e.g., `existential type Foo: Bar;`\n     Existential(ExistTy),\n-    /// An enum definition, e.g. `enum Foo<A, B> {C<A>, D<B>}`\n+    /// An enum definition, e.g., `enum Foo<A, B> {C<A>, D<B>}`\n     Enum(EnumDef, Generics),\n-    /// A struct definition, e.g. `struct Foo<A> {x: A}`\n+    /// A struct definition, e.g., `struct Foo<A> {x: A}`\n     Struct(VariantData, Generics),\n-    /// A union definition, e.g. `union Foo<A, B> {x: A, y: B}`\n+    /// A union definition, e.g., `union Foo<A, B> {x: A, y: B}`\n     Union(VariantData, Generics),\n     /// Represents a Trait Declaration\n     Trait(IsAuto, Unsafety, Generics, GenericBounds, HirVec<TraitItemRef>),"}, {"sha": "d6816d3b81bf79fc2f93e8d5df0ee524532ca29f", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -101,7 +101,7 @@ impl hir::Pat {\n     }\n \n     /// Checks if the pattern contains any patterns that bind something to\n-    /// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n+    /// an ident, e.g., `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n     pub fn contains_bindings(&self) -> bool {\n         let mut contains_bindings = false;\n         self.walk(|p| {\n@@ -116,7 +116,7 @@ impl hir::Pat {\n     }\n \n     /// Checks if the pattern contains any patterns that bind something to\n-    /// an ident or wildcard, e.g. `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n+    /// an ident or wildcard, e.g., `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n     pub fn contains_bindings_or_wild(&self) -> bool {\n         let mut contains_bindings = false;\n         self.walk(|p| {"}, {"sha": "a24f2fa4bc65243b36ce73887ab8587180ed9f2e", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -2448,8 +2448,8 @@ fn bin_op_to_assoc_op(op: hir::BinOpKind) -> AssocOp {\n     }\n }\n \n-/// Expressions that syntactically contain an \"exterior\" struct literal i.e. not surrounded by any\n-/// parens or other delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n+/// Expressions that syntactically contain an \"exterior\" struct literal i.e., not surrounded by any\n+/// parens or other delimiters, e.g., `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n /// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not.\n fn contains_exterior_struct_lit(value: &hir::Expr) -> bool {\n     match value.node {"}, {"sha": "2e56308daf7c25d6ad9796a722e5d13b32bf9099", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -45,7 +45,7 @@ fn compute_ignored_attr_names() -> FxHashSet<Symbol> {\n /// This is the context state available during incr. comp. hashing. It contains\n /// enough information to transform DefIds and HirIds into stable DefPaths (i.e.\n /// a reference to the TyCtxt) and it holds a few caches for speeding up various\n-/// things (e.g. each DefId/DefPath is only hashed once).\n+/// things (e.g., each DefId/DefPath is only hashed once).\n #[derive(Clone)]\n pub struct StableHashingContext<'a> {\n     sess: &'a Session,"}, {"sha": "f124623becd93ddd06dd043ee8be273379710716", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -371,7 +371,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n         if self.ambient_variance == ty::Variance::Invariant {\n             // Avoid fetching the variance if we are in an invariant\n             // context; no need, and it can induce dependency cycles\n-            // (e.g. #41849).\n+            // (e.g., #41849).\n             relate::relate_substs(self, None, a_subst, b_subst)\n         } else {\n             let opt_variances = self.tcx().variances_of(item_def_id);"}, {"sha": "27faa4587f3be937c7a3eb5edf1a9c08f78f08b2", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -47,9 +47,9 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n                           b_subst: &'tcx Substs<'tcx>)\n                           -> RelateResult<'tcx, &'tcx Substs<'tcx>>\n     {\n-        // NB: Once we are equating types, we don't care about\n+        // N.B., once we are equating types, we don't care about\n         // variance, so don't try to lookup the variance here. This\n-        // also avoids some cycles (e.g. #41849) since looking up\n+        // also avoids some cycles (e.g., #41849) since looking up\n         // variance requires computing types which can require\n         // performing trait matching (which then performs equality\n         // unification)."}, {"sha": "df0dcbed30afa1ce361d1495bd0140550dcc1f39", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -30,7 +30,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     ///    { x.push(y); }\n     /// ```\n     /// The function returns the nested type corresponding to the anonymous region\n-    /// for e.g. `&u8` and Vec<`&u8`.\n+    /// for e.g., `&u8` and Vec<`&u8`.\n     pub(super) fn find_anon_type(\n         &self,\n         region: Region<'tcx>,\n@@ -97,7 +97,7 @@ struct FindNestedTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     // associated with the anonymous region we are looking for.\n     bound_region: ty::BoundRegion,\n     // The type where the anonymous lifetime appears\n-    // for e.g. Vec<`&u8`> and <`&u8`>\n+    // for e.g., Vec<`&u8`> and <`&u8`>\n     found_type: Option<&'gcx hir::Ty>,\n     current_index: ty::DebruijnIndex,\n }"}, {"sha": "c8cd11c8198772cfc3646d58a57aedaaa75c6402", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -542,7 +542,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Pops the placeholder regions found in `placeholder_map` from the region\n     /// inference context. Whenever you create placeholder regions via\n     /// `replace_bound_vars_with_placeholders`, they must be popped before you\n-    /// commit the enclosing snapshot (if you do not commit, e.g. within a\n+    /// commit the enclosing snapshot (if you do not commit, e.g., within a\n     /// probe or as a result of an error, then this is not necessary, as\n     /// popping happens as part of the rollback).\n     ///"}, {"sha": "b1a13354b7cdbd275ce869bbaf46834a9c5449a8", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -219,7 +219,7 @@ pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     /// `UniverseIndex::root()` but grows from there as we enter\n     /// universal quantifiers.\n     ///\n-    /// NB: At present, we exclude the universal quantifiers on the\n+    /// N.B., at present, we exclude the universal quantifiers on the\n     /// item we are type-checking, and just consider those names as\n     /// part of the root universe. So this would only get incremented\n     /// when we enter into a higher-ranked (`for<..>`) type or trait\n@@ -732,7 +732,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             region_obligations_snapshot: self.region_obligations.borrow().len(),\n             universe: self.universe(),\n             was_in_snapshot: in_snapshot,\n-            // Borrow tables \"in progress\" (i.e. during typeck)\n+            // Borrow tables \"in progress\" (i.e., during typeck)\n             // to ban writes from within a snapshot to them.\n             _in_progress_tables: self.in_progress_tables.map(|tables| tables.borrow()),\n         }\n@@ -1047,7 +1047,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // type parameter definition. The substitutions are\n                 // for actual parameters that may be referred to by\n                 // the default of this type parameter, if it exists.\n-                // E.g. `struct Foo<A, B, C = (A, B)>(...);` when\n+                // e.g., `struct Foo<A, B, C = (A, B)>(...);` when\n                 // used in a path such as `Foo::<T, U>::new()` will\n                 // use an inference variable for `C` with `[T, U]`\n                 // as the substitutions for the default, `(T, U)`.\n@@ -1261,7 +1261,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n          * Where possible, replaces type/int/float variables in\n          * `value` with their final value. Note that region variables\n          * are unaffected. If a type variable has not been unified, it\n-         * is left as is.  This is an idempotent operation that does\n+         * is left as is. This is an idempotent operation that does\n          * not affect inference state in any way and so you can do it\n          * at will.\n          */\n@@ -1298,7 +1298,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         /*!\n          * Attempts to resolve all type/region variables in\n          * `value`. Region inference must have been run already (e.g.,\n-         * by calling `resolve_regions_and_report_errors`).  If some\n+         * by calling `resolve_regions_and_report_errors`). If some\n          * variable was never unified, an `Err` results.\n          *\n          * This method is idempotent, but it not typically not invoked\n@@ -1331,7 +1331,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n         debug!(\"type_error_struct_with_diag({:?}, {:?})\", sp, actual_ty);\n \n-        // Don't report an error if actual type is Error.\n+        // Don't report an error if actual type is `Error`.\n         if actual_ty.references_error() {\n             return self.tcx.sess.diagnostic().struct_dummy();\n         }"}, {"sha": "773c7129722cf7f4784a535fa05dac0c00649b27", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -15,7 +15,7 @@\n //!\n //! Here are the key differences:\n //!\n-//! - This code may choose to bypass some checks (e.g. the occurs check)\n+//! - This code may choose to bypass some checks (e.g., the occurs check)\n //!   in the case where we know that there are no unbound type inference\n //!   variables. This is the case for NLL, because at NLL time types are fully\n //!   inferred up-to regions.\n@@ -97,7 +97,7 @@ pub trait TypeRelatingDelegate<'tcx> {\n     /// region that is instantiated existentially. This creates an\n     /// inference variable, typically.\n     ///\n-    /// So e.g. if you have `for<'a> fn(..) <: for<'b> fn(..)`, then\n+    /// So e.g., if you have `for<'a> fn(..) <: for<'b> fn(..)`, then\n     /// we will invoke this method to instantiate `'a` with an\n     /// inference variable (though `'b` would be instantiated first,\n     /// as a placeholder).\n@@ -107,7 +107,7 @@ pub trait TypeRelatingDelegate<'tcx> {\n     /// higher-ranked region that is instantiated universally.\n     /// This creates a new region placeholder, typically.\n     ///\n-    /// So e.g. if you have `for<'a> fn(..) <: for<'b> fn(..)`, then\n+    /// So e.g., if you have `for<'a> fn(..) <: for<'b> fn(..)`, then\n     /// we will invoke this method to instantiate `'b` with a\n     /// placeholder region.\n     fn next_placeholder_region(&mut self, placeholder: ty::PlaceholderRegion) -> ty::Region<'tcx>;"}, {"sha": "44c5fe5acaa2b1407aeff4a53af31e56fb0aaa94", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -761,7 +761,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n         );\n \n         // Use the same type variable if the exact same Opaque appears more\n-        // than once in the return type (e.g. if it's passed to a type alias).\n+        // than once in the return type (e.g., if it's passed to a type alias).\n         if let Some(opaque_defn) = self.opaque_types.get(&def_id) {\n             return opaque_defn.concrete_ty;\n         }\n@@ -783,7 +783,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n         );\n \n         // make sure that we are in fact defining the *entire* type\n-        // e.g. `existential type Foo<T: Bound>: Bar;` needs to be\n+        // e.g., `existential type Foo<T: Bound>: Bar;` needs to be\n         // defined by a function like `fn foo<T: Bound>() -> Foo<T>`.\n         debug!(\n             \"instantiate_opaque_types: param_env: {:#?}\","}, {"sha": "7b21a6992a70ebe6cab6d14e2ee268fbe6690328", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -408,7 +408,7 @@ where\n \n         // Remove outlives bounds that we get from the environment but\n         // which are also deducable from the trait. This arises (cc\n-        // #55756) in cases where you have e.g. `<T as Foo<'a>>::Item:\n+        // #55756) in cases where you have e.g., `<T as Foo<'a>>::Item:\n         // 'a` in the environment but `trait Foo<'b> { type Item: 'b\n         // }` in the trait definition.\n         approx_env_bounds.retain(|bound| {"}, {"sha": "9cac73dfab080b13dde0d71901108338c1a1d253", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -60,7 +60,7 @@ pub struct RegionConstraintCollector<'tcx> {\n     /// which can never be rolled back.\n     undo_log: Vec<UndoLog<'tcx>>,\n \n-    /// The number of open snapshots, i.e. those that haven't been committed or\n+    /// The number of open snapshots, i.e., those that haven't been committed or\n     /// rolled back.\n     num_open_snapshots: usize,\n \n@@ -607,7 +607,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n         // never overwrite an existing (constraint, origin) - only insert one if it isn't\n         // present in the map yet. This prevents origins from outside the snapshot being\n-        // replaced with \"less informative\" origins e.g. during calls to `can_eq`\n+        // replaced with \"less informative\" origins e.g., during calls to `can_eq`\n         let in_snapshot = self.in_snapshot();\n         let undo_log = &mut self.undo_log;\n         self.data.constraints.entry(constraint).or_insert_with(|| {"}, {"sha": "b7aac23b955c6a1e03805e72967d4b5d649a43f7", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -175,7 +175,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// Creates a new type variable.\n     ///\n     /// - `diverging`: indicates if this is a \"diverging\" type\n-    ///   variable, e.g.  one created as the type of a `return`\n+    ///   variable, e.g.,  one created as the type of a `return`\n     ///   expression. The code in this module doesn't care if a\n     ///   variable is diverging, but the main Rust type-checker will\n     ///   sometimes \"unify\" such variables with the `!` or `()` types."}, {"sha": "4324cfc7b5f10424c51586dfdc3f0fde73acbe78", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -119,7 +119,7 @@ extern crate test;\n #[macro_use]\n mod macros;\n \n-// NB: This module needs to be declared first so diagnostics are\n+// N.B., this module needs to be declared first so diagnostics are\n // registered before they are used.\n pub mod diagnostics;\n "}, {"sha": "a09d167f2173cfc739d705d3ca9a74332247538e", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -174,7 +174,7 @@ declare_lint! {\n declare_lint! {\n     pub LEGACY_DIRECTORY_OWNERSHIP,\n     Deny,\n-    \"non-inline, non-`#[path]` modules (e.g. `mod foo;`) were erroneously allowed in some files \\\n+    \"non-inline, non-`#[path]` modules (e.g., `mod foo;`) were erroneously allowed in some files \\\n      not named `mod.rs`\"\n }\n \n@@ -366,7 +366,7 @@ pub mod parser {\n }\n \n /// Does nothing as a lint pass, but registers some `Lint`s\n-/// which are used by other parts of the compiler.\n+/// that are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n pub struct HardwiredLints;\n "}, {"sha": "449f8e0a2db67e73e8eefb487cdc29ca231376b7", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -1270,7 +1270,7 @@ pub fn check_ast_crate(\n     //\n     // Rustdoc runs everybody-loops before the early lints and removes\n     // function bodies, so it's totally possible for linted\n-    // node ids to not exist (e.g. macros defined within functions for the\n+    // node ids to not exist (e.g., macros defined within functions for the\n     // unused_macro lint) anymore. So we only run this check\n     // when we're not in rustdoc mode. (see issue #47639)\n     if !sess.opts.actually_rustdoc {"}, {"sha": "06e3e0bab4f1066a7d4308aab01da9b739baad7e", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -66,7 +66,7 @@ impl LintLevelSets {\n         for &(ref lint_name, level) in &sess.opts.lint_opts {\n             store.check_lint_name_cmdline(sess, &lint_name, level);\n \n-            // If the cap is less than this specified level, e.g. if we've got\n+            // If the cap is less than this specified level, e.g., if we've got\n             // `--cap-lints allow` but we've also got `-D foo` then we ignore\n             // this specification as the lint cap will set it to allow anyway.\n             let level = cmp::min(level, self.lint_cap);\n@@ -191,7 +191,7 @@ impl<'a> LintLevelsBuilder<'a> {\n     /// * It'll validate all lint-related attributes in `attrs`\n     /// * It'll mark all lint-related attributes as used\n     /// * Lint levels will be updated based on the attributes provided\n-    /// * Lint attributes are validated, e.g. a #[forbid] can't be switched to\n+    /// * Lint attributes are validated, e.g., a #[forbid] can't be switched to\n     ///   #[allow]\n     ///\n     /// Don't forget to call `pop`!"}, {"sha": "7a8aa7e362abbb0339974f986383b4c7a2db33e7", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -67,7 +67,7 @@ pub struct Lint {\n     /// `declare_lint!()` invocations to follow the convention of upper-case\n     /// statics without repeating the name.\n     ///\n-    /// The name is written with underscores, e.g. \"unused_imports\".\n+    /// The name is written with underscores, e.g., \"unused_imports\".\n     /// On the command line, underscores become dashes.\n     pub name: &'static str,\n \n@@ -76,7 +76,7 @@ pub struct Lint {\n \n     /// Description of the lint or the issue it detects.\n     ///\n-    /// e.g. \"imports that are never used\"\n+    /// e.g., \"imports that are never used\"\n     pub desc: &'static str,\n \n     /// Starting at the given edition, default to the given lint level. If this is `None`, then use\n@@ -173,7 +173,7 @@ pub type LintArray = Vec<&'static Lint>;\n pub trait LintPass {\n     /// Get descriptions of the lints this `LintPass` object can emit.\n     ///\n-    /// NB: there is no enforcement that the object only emits lints it registered.\n+    /// N.B., there is no enforcement that the object only emits lints it registered.\n     /// And some `rustc` internal `LintPass`es register lints to be emitted by other\n     /// parts of the compiler. If you want enforced access restrictions for your\n     /// `Lint`, make it a private `static` item in its own module."}, {"sha": "c7f93512cd89bf497480943b36e5247093ee77e9", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -59,7 +59,7 @@ pub enum DepKind {\n     /// A dependency that is only used for its macros.\n     MacrosOnly,\n     /// A dependency that is always injected into the dependency list and so\n-    /// doesn't need to be linked to an rlib, e.g. the injected allocator.\n+    /// doesn't need to be linked to an rlib, e.g., the injected allocator.\n     Implicit,\n     /// A dependency that is required by an rlib version of this crate.\n     /// Ordinary `extern crate`s result in `Explicit` dependencies."}, {"sha": "934d7c12be552883565e14c9b6f7dc593e34f04a", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -311,7 +311,7 @@ fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_, '_, '_>,\n     let cg_attrs = tcx.codegen_fn_attrs(def_id);\n \n     // #[used], #[no_mangle], #[export_name], etc also keeps the item alive\n-    // forcefully, e.g. for placing it in a specific section.\n+    // forcefully, e.g., for placing it in a specific section.\n     if cg_attrs.contains_extern_indicator() ||\n         cg_attrs.flags.contains(CodegenFnAttrFlags::USED) {\n         return true;"}, {"sha": "5e75f119aef9c274f31944dfe2275164ff7c958a", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -201,7 +201,7 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // static libraries.\n     //\n     // If the crate hasn't been included yet and it's not actually required\n-    // (e.g. it's an allocator) then we skip it here as well.\n+    // (e.g., it's an allocator) then we skip it here as well.\n     for &cnum in tcx.crates().iter() {\n         let src = tcx.used_crate_source(cnum);\n         if src.dylib.is_none() &&\n@@ -306,7 +306,7 @@ fn attempt_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<DependencyLis\n \n // Given a list of how to link upstream dependencies so far, ensure that an\n // injected dependency is activated. This will not do anything if one was\n-// transitively included already (e.g. via a dylib or explicitly so).\n+// transitively included already (e.g., via a dylib or explicitly so).\n //\n // If an injected dependency was not found then we're guaranteed the\n // metadata::creader module has injected that dependency (not listed as"}, {"sha": "60ddf60cde2cf766ae196ff33424b0bb1fbd4e73", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -87,7 +87,7 @@ pub fn find_entry_point(session: &Session,\n     configure_main(&mut ctxt, crate_name);\n }\n \n-// Beware, this is duplicated in libsyntax/entry.rs, make sure to keep\n+// Beware, this is duplicated in `libsyntax/entry.rs`, so make sure to keep\n // them in sync.\n fn entry_point_type(item: &Item, at_root: bool) -> EntryPointType {\n     match item.node {\n@@ -98,7 +98,7 @@ fn entry_point_type(item: &Item, at_root: bool) -> EntryPointType {\n                 EntryPointType::MainAttr\n             } else if item.name == \"main\" {\n                 if at_root {\n-                    // This is a top-level function so can be 'main'\n+                    // This is a top-level function so can be 'main'.\n                     EntryPointType::MainNamed\n                 } else {\n                     EntryPointType::OtherMain"}, {"sha": "f1bc37d03e5a1fbaef36ec34b58c6ea998f202c2", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -813,7 +813,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         self.consume_expr(&arm.body);\n     }\n \n-    /// Walks a pat that occurs in isolation (i.e. top-level of fn\n+    /// Walks a pat that occurs in isolation (i.e., top-level of fn\n     /// arg or let binding.  *Not* a match arm or nested pat.)\n     fn walk_irrefutable_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat) {\n         let mut mode = Unknown;\n@@ -851,7 +851,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     /// The core driver for walking a pattern; `match_mode` must be\n-    /// established up front, e.g. via `determine_pat_move_mode` (see\n+    /// established up front, e.g., via `determine_pat_move_mode` (see\n     /// also `walk_irrefutable_pat` for patterns that stand alone).\n     fn walk_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat, match_mode: MatchMode) {\n         debug!(\"walk_pat(cmt_discr={:?}, pat={:?})\", cmt_discr, pat);"}, {"sha": "23ec24d71d2ebc889fbf705d6e8c90c2f1c0b4db", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -13,9 +13,9 @@\n // Language items are items that represent concepts intrinsic to the language\n // itself. Examples are:\n //\n-// * Traits that specify \"kinds\"; e.g. \"Sync\", \"Send\".\n+// * Traits that specify \"kinds\"; e.g., \"Sync\", \"Send\".\n //\n-// * Traits that represent operators; e.g. \"Add\", \"Sub\", \"Index\".\n+// * Traits that represent operators; e.g., \"Add\", \"Sub\", \"Index\".\n //\n // * Functions called by the compiler itself.\n "}, {"sha": "8934c7ebb2a6f2e0314f0435fbd857cb992951e7", "filename": "src/librustc/middle/lib_features.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flib_features.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Detecting lib features (i.e. features that are not lang features).\n+// Detecting lib features (i.e., features that are not lang features).\n //\n-// These are declared using stability attributes (e.g. `#[stable (..)]`\n+// These are declared using stability attributes (e.g., `#[stable (..)]`\n // and `#[unstable (..)]`), but are not declared in one single location\n // (unlike lang features), which means we need to collect them instead.\n \n@@ -61,7 +61,7 @@ impl<'a, 'tcx> LibFeatureCollector<'a, 'tcx> {\n     fn extract(&self, attr: &Attribute) -> Option<(Symbol, Option<Symbol>, Span)> {\n         let stab_attrs = vec![\"stable\", \"unstable\", \"rustc_const_unstable\"];\n \n-        // Find a stability attribute (i.e. `#[stable (..)]`, `#[unstable (..)]`,\n+        // Find a stability attribute (i.e., `#[stable (..)]`, `#[unstable (..)]`,\n         // `#[rustc_const_unstable (..)]`).\n         if let Some(stab_attr) = stab_attrs.iter().find(|stab_attr| {\n             attr.check_name(stab_attr)"}, {"sha": "e576951417f93b27026c2dbe17169871dedf5e81", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -554,7 +554,7 @@ struct RWUTable {\n     /// 65 bits of data into 32; in the uncommon cases, it expands the 65 bits\n     /// in 96.\n     ///\n-    /// More compact representations are possible -- e.g. use only 2 bits per\n+    /// More compact representations are possible -- e.g., use only 2 bits per\n     /// packed `RWU` and make the secondary table a HashMap that maps from\n     /// indices to `RWU`s -- but this one strikes a good balance between size\n     /// and speed."}, {"sha": "a04914e9774935f686596764a1046b72e0c7f249", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -127,7 +127,7 @@ pub enum PointerKind<'tcx> {\n }\n \n // We use the term \"interior\" to mean \"something reachable from the\n-// base without a pointer dereference\", e.g. a field\n+// base without a pointer dereference\", e.g., a field\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub enum InteriorKind {\n     InteriorField(FieldIndex),\n@@ -153,8 +153,8 @@ impl Hash for FieldIndex {\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum InteriorOffsetKind {\n-    Index,   // e.g. `array_expr[index_expr]`\n-    Pattern, // e.g. `fn foo([_, a, _, _]: [A; 4]) { ... }`\n+    Index,   // e.g., `array_expr[index_expr]`\n+    Pattern, // e.g., `fn foo([_, a, _, _]: [A; 4]) { ... }`\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n@@ -961,7 +961,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         debug!(\"cat_rvalue_node: promotable = {:?}\", promotable);\n \n-        // Always promote `[T; 0]` (even when e.g. borrowed mutably).\n+        // Always promote `[T; 0]` (even when e.g., borrowed mutably).\n         let promotable = match expr_ty.sty {\n             ty::Array(_, len) if len.assert_usize(self.tcx) == Some(0) => true,\n             _ => promotable,"}, {"sha": "9977faf5b2c9e161c35d22b0b31d73ccb959fb56", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -84,7 +84,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n ///  (D9.): DestructionScope for temporaries created during M8.\n /// (R10.): Remainder scope for block `'b:`, stmt 1 (let y = ...).\n /// (D11.): DestructionScope for temporaries and bindings from block `'b:`.\n-/// (D12.): DestructionScope for temporaries created during M1 (e.g. f()).\n+/// (D12.): DestructionScope for temporaries created during M1 (e.g., f()).\n /// ```\n ///\n /// Note that while the above picture shows the destruction scopes\n@@ -155,7 +155,7 @@ pub enum ScopeData {\n ///   everything after that first `let`. (If you want a scope that\n ///   includes EXPR_1 as well, then do not use `Scope::Remainder`,\n ///   but instead another `Scope` that encompasses the whole block,\n-///   e.g. `Scope::Node`.\n+///   e.g., `Scope::Node`.\n ///\n /// * the subscope with `first_statement_index == 1` is scope of `c`,\n ///   and thus does not include EXPR_2, but covers the `...`.\n@@ -172,7 +172,7 @@ static_assert!(ASSERT_SCOPE_DATA: mem::size_of::<ScopeData>() == 4);\n impl Scope {\n     /// Returns a item-local id associated with this scope.\n     ///\n-    /// NB: likely to be replaced as API is refined; e.g. pnkfelix\n+    /// N.B., likely to be replaced as API is refined; e.g., pnkfelix\n     /// anticipates `fn entry_node_id` and `fn each_exit_node_id`.\n     pub fn item_local_id(&self) -> hir::ItemLocalId {\n         self.id\n@@ -770,10 +770,10 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n     //    }, other_argument());\n     //\n     // Each of the statements within the block is a terminating\n-    // scope, and thus a temporary (e.g. the result of calling\n+    // scope, and thus a temporary (e.g., the result of calling\n     // `bar()` in the initializer expression for `let inner = ...;`)\n     // will be cleaned up immediately after its corresponding\n-    // statement (i.e. `let inner = ...;`) executes.\n+    // statement (i.e., `let inner = ...;`) executes.\n     //\n     // On the other hand, temporaries associated with evaluating the\n     // tail expression for the block are assigned lifetimes so that\n@@ -984,7 +984,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n \n     // As an exception to the normal rules governing temporary\n     // lifetimes, initializers in a let have a temporary lifetime\n-    // of the enclosing block. This means that e.g. a program\n+    // of the enclosing block. This means that e.g., a program\n     // like the following is legal:\n     //\n     //     let ref x = HashMap::new();\n@@ -1183,7 +1183,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n         loop {\n             // Note: give all the expressions matching `ET` with the\n             // extended temporary lifetime, not just the innermost rvalue,\n-            // because in codegen if we must compile e.g. `*rvalue()`\n+            // because in codegen if we must compile e.g., `*rvalue()`\n             // into a temporary, we request the temporary scope of the\n             // outer expression.\n             visitor.scope_tree.record_rvalue_scope(expr.hir_id.local_id, blk_scope);\n@@ -1281,7 +1281,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n             // according to rvalue lifetime semantics, using the same\n             // syntactical rules used for let initializers.\n             //\n-            // E.g. in `let x = &f();`, the temporary holding the result from\n+            // e.g., in `let x = &f();`, the temporary holding the result from\n             // the `f()` call lives for the entirety of the surrounding block.\n             //\n             // Similarly, `const X: ... = &f();` would have the result of `f()`\n@@ -1292,7 +1292,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n             //\n             // However, `const Y: ... = g(&f());`, like `let y = g(&f());`,\n             // would *not* let the `f()` temporary escape into an outer scope\n-            // (i.e. `'static`), which means that after `g` returns, it drops,\n+            // (i.e., `'static`), which means that after `g` returns, it drops,\n             // and all the associated destruction scope rules apply.\n             self.cx.var_parent = None;\n             resolve_local(self, None, Some(&body.value));"}, {"sha": "571f718f905f4b881d7b5729a43745725030f3a8", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -303,14 +303,14 @@ enum Scope<'a> {\n     /// Lifetimes introduced by a fn are scoped to the call-site for that fn,\n     /// if this is a fn body, otherwise the original definitions are used.\n     /// Unspecified lifetimes are inferred, unless an elision scope is nested,\n-    /// e.g. `(&T, fn(&T) -> &T);` becomes `(&'_ T, for<'a> fn(&'a T) -> &'a T)`.\n+    /// e.g., `(&T, fn(&T) -> &T);` becomes `(&'_ T, for<'a> fn(&'a T) -> &'a T)`.\n     Body {\n         id: hir::BodyId,\n         s: ScopeRef<'a>,\n     },\n \n     /// A scope which either determines unspecified lifetimes or errors\n-    /// on them (e.g. due to ambiguity). For more details, see `Elide`.\n+    /// on them (e.g., due to ambiguity). For more details, see `Elide`.\n     Elision {\n         elide: Elide,\n         s: ScopeRef<'a>,\n@@ -622,13 +622,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     LifetimeName::Implicit => {\n                         // If the user does not write *anything*, we\n                         // use the object lifetime defaulting\n-                        // rules. So e.g. `Box<dyn Debug>` becomes\n+                        // rules. So e.g., `Box<dyn Debug>` becomes\n                         // `Box<dyn Debug + 'static>`.\n                         self.resolve_object_lifetime_default(lifetime)\n                     }\n                     LifetimeName::Underscore => {\n                         // If the user writes `'_`, we use the *ordinary* elision\n-                        // rules. So the `'_` in e.g. `Box<dyn Debug + '_>` will be\n+                        // rules. So the `'_` in e.g., `Box<dyn Debug + '_>` will be\n                         // resolved the same as the `'_` in `&'_ Foo`.\n                         //\n                         // cc #48468\n@@ -1699,7 +1699,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     {\n         insert_late_bound_lifetimes(self.map, decl, generics);\n \n-        // Find the start of nested early scopes, e.g. in methods.\n+        // Find the start of nested early scopes, e.g., in methods.\n         let mut index = 0;\n         if let Some(parent_id) = parent_id {\n             let parent = self.tcx.hir().expect_item(parent_id);"}, {"sha": "ab379c910f7764b645e45803c875497b2a99c2d4", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -14,9 +14,10 @@\n pub use self::StabilityLevel::*;\n \n use lint;\n+use hir::{self, Item, Generics, StructField, Variant, HirId};\n use hir::def::Def;\n use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n-use ty::{self, TyCtxt};\n+use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use middle::privacy::AccessLevels;\n use session::{DiagnosticMessageId, Session};\n use syntax::symbol::Symbol;\n@@ -25,12 +26,9 @@ use syntax::ast;\n use syntax::ast::{NodeId, Attribute};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::attr::{self, Stability, Deprecation};\n+use ty::{self, TyCtxt};\n use util::nodemap::{FxHashSet, FxHashMap};\n \n-use hir;\n-use hir::{Item, Generics, StructField, Variant, HirId};\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n-\n use std::mem::replace;\n use std::cmp::Ordering;\n \n@@ -474,10 +472,10 @@ pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n }\n \n /// Check whether an item marked with `deprecated(since=\"X\")` is currently\n-/// deprecated (i.e. whether X is not greater than the current rustc version).\n+/// deprecated (i.e., whether X is not greater than the current rustc version).\n pub fn deprecation_in_effect(since: &str) -> bool {\n     fn parse_version(ver: &str) -> Vec<u32> {\n-        // We ignore non-integer components of the version (e.g. \"nightly\").\n+        // We ignore non-integer components of the version (e.g., \"nightly\").\n         ver.split(|c| c == '.' || c == '-').flat_map(|s| s.parse()).collect()\n     }\n \n@@ -518,7 +516,7 @@ pub enum EvalResult {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    // (See issue #38412)\n+    // See issue #38412.\n     fn skip_stability_check_due_to_privacy(self, mut def_id: DefId) -> bool {\n         // Check if `def_id` is a trait method.\n         match self.describe_def(def_id) {\n@@ -528,8 +526,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 if let ty::TraitContainer(trait_def_id) = self.associated_item(def_id).container {\n                     // Trait methods do not declare visibility (even\n                     // for visibility info in cstore). Use containing\n-                    // trait instead, so methods of pub traits are\n-                    // themselves considered pub.\n+                    // trait instead, so methods of `pub` traits are\n+                    // themselves considered `pub`.\n                     def_id = trait_def_id;\n                 }\n             }\n@@ -539,10 +537,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let visibility = self.visibility(def_id);\n \n         match visibility {\n-            // must check stability for pub items.\n+            // Must check stability for `pub` items.\n             ty::Visibility::Public => false,\n \n-            // these are not visible outside crate; therefore\n+            // These are not visible outside crate; therefore\n             // stability markers are irrelevant, if even present.\n             ty::Visibility::Restricted(..) |\n             ty::Visibility::Invisible => true,\n@@ -628,7 +626,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             return EvalResult::Allow;\n         }\n \n-        // Issue 38412: private items lack stability markers.\n+        // Issue #38412: private items lack stability markers.\n         if self.skip_stability_check_due_to_privacy(def_id) {\n             return EvalResult::Allow;\n         }\n@@ -644,7 +642,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 // crates also pulled in from crates.io. We want to ideally be\n                 // able to compile everything without requiring upstream\n                 // modifications, so in the case that this looks like a\n-                // rustc_private crate (e.g. a compiler crate) and we also have\n+                // `rustc_private` crate (e.g., a compiler crate) and we also have\n                 // the `-Z force-unstable-if-unmarked` flag present (we're\n                 // compiling a compiler crate), then let this missing feature\n                 // annotation slide.\n@@ -794,7 +792,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-/// Given the list of enabled features that were not language features (i.e. that\n+/// Given the list of enabled features that were not language features (i.e., that\n /// were expected to be library features), and the list of features used from\n /// libraries, identify activated features that don't exist and error about them.\n pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {"}, {"sha": "289f693df244d0d43728cc2bbd9a6960a598fd42", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -378,7 +378,7 @@ impl<'tcx, O> EvalErrorKind<'tcx, O> {\n                 \"tried to read from foreign (extern) static\",\n             InvalidPointerMath =>\n                 \"attempted to do invalid arithmetic on pointers that would leak base addresses, \\\n-                e.g. comparing pointers into different allocations\",\n+                e.g., comparing pointers into different allocations\",\n             ReadUndefBytes(_) =>\n                 \"attempted to read undefined bytes\",\n             DeadLocal =>"}, {"sha": "b7a429520757791f7921827497417b1f23613026", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -556,7 +556,7 @@ pub enum BorrowKind {\n     /// Data is mutable and not aliasable.\n     Mut {\n         /// True if this borrow arose from method-call auto-ref\n-        /// (i.e. `adjustment::Adjust::Borrow`)\n+        /// (i.e., `adjustment::Adjust::Borrow`)\n         allow_two_phase_borrow: bool,\n     },\n }\n@@ -692,7 +692,7 @@ mod binding_form_impl {\n /// expression; that is, a block like `{ STMT_1; STMT_2; EXPR }`.\n ///\n /// It is used to improve diagnostics when such temporaries are\n-/// involved in borrow_check errors, e.g. explanations of where the\n+/// involved in borrow_check errors, e.g., explanations of where the\n /// temporaries come from, when their destructors are run, and/or how\n /// one might revise the code to satisfy the borrow checker's rules.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n@@ -701,7 +701,7 @@ pub struct BlockTailInfo {\n     /// expression is ignored by the block's expression context.\n     ///\n     /// Examples include `{ ...; tail };` and `let _ = { ...; tail };`\n-    /// but not e.g. `let _x = { ...; tail };`\n+    /// but not e.g., `let _x = { ...; tail };`\n     pub tail_result_is_ignored: bool,\n }\n \n@@ -756,7 +756,7 @@ pub struct LocalDecl<'tcx> {\n     pub ty: Ty<'tcx>,\n \n     /// If the user manually ascribed a type to this variable,\n-    /// e.g. via `let x: T`, then we carry that type here. The MIR\n+    /// e.g., via `let x: T`, then we carry that type here. The MIR\n     /// borrow checker needs this information since it can affect\n     /// region inference.\n     pub user_ty: UserTypeProjections<'tcx>,\n@@ -767,7 +767,7 @@ pub struct LocalDecl<'tcx> {\n     /// to generate better debuginfo.\n     pub name: Option<Name>,\n \n-    /// The *syntactic* (i.e. not visibility) source scope the local is defined\n+    /// The *syntactic* (i.e., not visibility) source scope the local is defined\n     /// in. If the local was defined in a let-statement, this\n     /// is *within* the let-statement, rather than outside\n     /// of it.\n@@ -1745,7 +1745,7 @@ pub enum StatementKind<'tcx> {\n     Assign(Place<'tcx>, Box<Rvalue<'tcx>>),\n \n     /// This represents all the reading that a pattern match may do\n-    /// (e.g. inspecting constants and discriminant values), and the\n+    /// (e.g., inspecting constants and discriminant values), and the\n     /// kind of pattern it comes from. This is in order to adapt potential\n     /// error messages to these specific patterns.\n     FakeRead(FakeReadCause, Place<'tcx>),\n@@ -2180,7 +2180,7 @@ pub enum Rvalue<'tcx> {\n \n     /// Read the discriminant of an ADT.\n     ///\n-    /// Undefined (i.e. no effort is made to make it defined, but there\u2019s no reason why it cannot\n+    /// Undefined (i.e., no effort is made to make it defined, but there\u2019s no reason why it cannot\n     /// be defined to return, say, a 0) if ADT is not an enum.\n     Discriminant(Place<'tcx>),\n \n@@ -2222,7 +2222,7 @@ pub enum AggregateKind<'tcx> {\n     /// The second field is the variant index. It's equal to 0 for struct\n     /// and union expressions. The fourth field is\n     /// active field number and is present only for union expressions\n-    /// -- e.g. for a union expression `SomeUnion { c: .. }`, the\n+    /// -- e.g., for a union expression `SomeUnion { c: .. }`, the\n     /// active field index would identity the field `c`\n     Adt(\n         &'tcx AdtDef,"}, {"sha": "c96cbd40efaf817f9013d3d776a4e36d2abd9410", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -272,7 +272,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> CodegenUnitNameBuilder<'a, 'gcx, 'tcx> {\n     ///\n     /// The '.' before `<special-suffix>` makes sure that names with a special\n     /// suffix can never collide with a name built out of regular Rust\n-    /// identifiers (e.g. module paths).\n+    /// identifiers (e.g., module paths).\n     pub fn build_cgu_name<I, C, S>(&mut self,\n                                    cnum: CrateNum,\n                                    components: I,"}, {"sha": "4424ba0a4f7a109d2715245241266450f0f631f4", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'tcx> Iterator for Postorder<'a, 'tcx> {\n /// ```\n ///\n /// A reverse postorder traversal of this graph is either `A B C D` or `A C B D`\n-/// Note that for a graph containing no loops (i.e. A DAG), this is equivalent to\n+/// Note that for a graph containing no loops (i.e., A DAG), this is equivalent to\n /// a topological sort.\n ///\n /// Construction of a `ReversePostorder` traversal requires doing a full"}, {"sha": "237f6bc9c7b45b81627c8028895eab5f95269845", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -33,7 +33,7 @@ use syntax_pos::Span;\n // in that circumstance.\n //\n // For the most part, we do not destructure things external to the\n-// MIR, e.g. types, spans, etc, but simply visit them and stop. This\n+// MIR, e.g., types, spans, etc, but simply visit them and stop. This\n // avoids duplication with other visitors like `TypeFoldable`.\n //\n // ## Updating\n@@ -997,7 +997,7 @@ pub enum NonMutatingUseContext<'tcx> {\n     ShallowBorrow(Region<'tcx>),\n     /// Unique borrow.\n     UniqueBorrow(Region<'tcx>),\n-    /// Used as base for another place, e.g. `x` in `x.y`. Will not mutate the place.\n+    /// Used as base for another place, e.g., `x` in `x.y`. Will not mutate the place.\n     /// For example, the projection `x.y` is not marked as a mutation in these cases:\n     ///\n     ///     z = x.y;\n@@ -1020,7 +1020,7 @@ pub enum MutatingUseContext<'tcx> {\n     Drop,\n     /// Mutable borrow.\n     Borrow(Region<'tcx>),\n-    /// Used as base for another place, e.g. `x` in `x.y`. Could potentially mutate the place.\n+    /// Used as base for another place, e.g., `x` in `x.y`. Could potentially mutate the place.\n     /// For example, the projection `x.y` is marked as a mutation in these cases:\n     ///\n     ///     x.y = ...;"}, {"sha": "51855ff6cc82c606842966054f03ae361bd41f4c", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -1280,7 +1280,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     dump_mir_exclude_pass_number: bool = (false, parse_bool, [UNTRACKED],\n         \"if set, exclude the pass number when dumping MIR (used in tests)\"),\n     mir_emit_retag: bool = (false, parse_bool, [TRACKED],\n-        \"emit Retagging MIR statements, interpreted e.g. by miri; implies -Zmir-opt-level=0\"),\n+        \"emit Retagging MIR statements, interpreted e.g., by miri; implies -Zmir-opt-level=0\"),\n     perf_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"print some performance-related statistics\"),\n     hir_stats: bool = (false, parse_bool, [UNTRACKED],\n@@ -1532,7 +1532,7 @@ impl RustcOptGroup {\n // adds extra rustc-specific metadata to each option; such metadata\n // is exposed by .  The public\n // functions below ending with `_u` are the functions that return\n-// *unstable* options, i.e. options that are only enabled when the\n+// *unstable* options, i.e., options that are only enabled when the\n // user also passes the `-Z unstable-options` debugging flag.\n mod opt {\n     // The `fn opt_u` etc below are written so that we can use them\n@@ -2380,7 +2380,7 @@ impl fmt::Display for CrateType {\n /// tracking are hashed into a single value that determines whether the\n /// incremental compilation cache can be re-used or not. This hashing is done\n /// via the DepTrackingHash trait defined below, since the standard Hash\n-/// implementation might not be suitable (e.g. arguments are stored in a Vec,\n+/// implementation might not be suitable (e.g., arguments are stored in a Vec,\n /// the hash of which is order dependent, but we might not want the order of\n /// arguments to make a difference for the hash).\n ///"}, {"sha": "8159c65a8bc2d187630dac0746813ed3a7acaffe", "filename": "src/librustc/session/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Ffilesearch.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -176,7 +176,7 @@ fn find_libdir(sysroot: &Path) -> Cow<'static, str> {\n     // of the directory where librustc is located, rather than where the rustc\n     // binary is.\n     // If --libdir is set during configuration to the value other than\n-    // \"lib\" (i.e. non-default), this value is used (see issue #16552).\n+    // \"lib\" (i.e., non-default), this value is used (see issue #16552).\n \n     #[cfg(target_pointer_width = \"64\")]\n     const PRIMARY_LIB_DIR: &str = \"lib64\";"}, {"sha": "d1dd745add9a4012ef15cfb2d196941fe7e00d35", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -586,7 +586,7 @@ impl Session {\n         // either return `No` or `ThinLocal`.\n \n         // If processing command line options determined that we're incompatible\n-        // with ThinLTO (e.g. `-C lto --emit llvm-ir`) then return that option.\n+        // with ThinLTO (e.g., `-C lto --emit llvm-ir`) then return that option.\n         if self.opts.cli_forced_thinlto_off {\n             return config::Lto::No;\n         }"}, {"sha": "fff77816e7535d93727c93a59f2e716002136be3", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -138,7 +138,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             // the first evaluate_predicates call.\n             //\n             // The problem is this: most of rustc, including SelectionContext and traits::project,\n-            // are designed to work with a concrete usage of a type (e.g. Vec<u8>\n+            // are designed to work with a concrete usage of a type (e.g., Vec<u8>\n             // fn<T>() { Vec<T> }. This information will generally never change - given\n             // the 'T' in fn<T>() { ... }, we'll never know anything else about 'T'.\n             // If we're unable to prove that 'T' implements a particular trait, we're done -\n@@ -289,7 +289,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     //\n     // One additional consideration is supertrait bounds. Normally, a ParamEnv is only ever\n     // constructed once for a given type. As part of the construction process, the ParamEnv will\n-    // have any supertrait bounds normalized - e.g. if we have a type 'struct Foo<T: Copy>', the\n+    // have any supertrait bounds normalized - e.g., if we have a type 'struct Foo<T: Copy>', the\n     // ParamEnv will contain 'T: Copy' and 'T: Clone', since 'Copy: Clone'. When we construct our\n     // own ParamEnv, we need to do this ourselves, through traits::elaborate_predicates, or else\n     // SelectionContext will choke on the missing predicates. However, this should never show up in\n@@ -343,7 +343,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n \n             match &result {\n                 &Ok(Some(ref vtable)) => {\n-                    // If we see an explicit negative impl (e.g. 'impl !Send for MyStruct'),\n+                    // If we see an explicit negative impl (e.g., 'impl !Send for MyStruct'),\n                     // we immediately bail out, since it's impossible for us to continue.\n                     match vtable {\n                         Vtable::VtableImpl(VtableImplData { impl_def_id, .. }) => {\n@@ -432,11 +432,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     // If we put both of these predicates in our computed ParamEnv, we'll\n     // confuse SelectionContext, since it will (correctly) view both as being applicable.\n     //\n-    // To solve this, we pick the 'more strict' lifetime bound - i.e. the HRTB\n+    // To solve this, we pick the 'more strict' lifetime bound - i.e., the HRTB\n     // Our end goal is to generate a user-visible description of the conditions\n     // under which a type implements an auto trait. A trait predicate involving\n     // a HRTB means that the type needs to work with any choice of lifetime,\n-    // not just one specific lifetime (e.g. 'static).\n+    // not just one specific lifetime (e.g., 'static).\n     fn add_user_pred<'c>(\n         &self,\n         user_computed_preds: &mut FxHashSet<ty::Predicate<'c>>,"}, {"sha": "f10f523e2b4872e696979c06b16387bd51fb956d", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -256,28 +256,28 @@ pub fn orphan_check<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n /// The current rule is that a trait-ref orphan checks in a crate C:\n ///\n /// 1. Order the parameters in the trait-ref in subst order - Self first,\n-///    others linearly (e.g. `<U as Foo<V, W>>` is U < V < W).\n+///    others linearly (e.g., `<U as Foo<V, W>>` is U < V < W).\n /// 2. Of these type parameters, there is at least one type parameter\n ///    in which, walking the type as a tree, you can reach a type local\n ///    to C where all types in-between are fundamental types. Call the\n ///    first such parameter the \"local key parameter\".\n-///     - e.g. `Box<LocalType>` is OK, because you can visit LocalType\n+///     - e.g., `Box<LocalType>` is OK, because you can visit LocalType\n ///       going through `Box`, which is fundamental.\n ///     - similarly, `FundamentalPair<Vec<()>, Box<LocalType>>` is OK for\n ///       the same reason.\n ///     - but (knowing that `Vec<T>` is non-fundamental, and assuming it's\n ///       not local), `Vec<LocalType>` is bad, because `Vec<->` is between\n ///       the local type and the type parameter.\n /// 3. Every type parameter before the local key parameter is fully known in C.\n-///     - e.g. `impl<T> T: Trait<LocalType>` is bad, because `T` might be\n+///     - e.g., `impl<T> T: Trait<LocalType>` is bad, because `T` might be\n ///       an unknown type.\n ///     - but `impl<T> LocalType: Trait<T>` is OK, because `LocalType`\n ///       occurs before `T`.\n /// 4. Every type in the local key parameter not known in C, going\n ///    through the parameter's type tree, must appear only as a subtree of\n ///    a type local to C, with only fundamental types between the type\n ///    local to C and the local key parameter.\n-///     - e.g. `Vec<LocalType<T>>>` (or equivalently `Box<Vec<LocalType<T>>>`)\n+///     - e.g., `Vec<LocalType<T>>>` (or equivalently `Box<Vec<LocalType<T>>>`)\n ///     is bad, because the only local type with `T` as a subtree is\n ///     `LocalType<T>`, and `Vec<->` is between it and the type parameter.\n ///     - similarly, `FundamentalPair<LocalType<T>, T>` is bad, because\n@@ -288,7 +288,7 @@ pub fn orphan_check<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n ///\n /// The orphan rules actually serve several different purposes:\n ///\n-/// 1. They enable link-safety - i.e. 2 mutually-unknowing crates (where\n+/// 1. They enable link-safety - i.e., 2 mutually-unknowing crates (where\n ///    every type local to one crate is unknown in the other) can't implement\n ///    the same trait-ref. This follows because it can be seen that no such\n ///    type can orphan-check in 2 such crates."}, {"sha": "4ef4f4571055582ee51dbf2febb2118dff07f1d8", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -128,7 +128,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    // returns if `cond` not occurring implies that `error` does not occur - i.e. that\n+    // returns if `cond` not occurring implies that `error` does not occur - i.e., that\n     // `error` occurring implies that `cond` occurs.\n     fn error_implies(&self,\n                      cond: &ty::Predicate<'tcx>,"}, {"sha": "8d91132a6db93cedf0a0d9da260eb549fd956f23", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -8,34 +8,49 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Trait Resolution. See [rustc guide] for more info on how this works.\n+//! Trait Resolution. See the [rustc guide] for more information on how this works.\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/traits/resolution.html\n \n-pub use self::SelectionError::*;\n-pub use self::FulfillmentErrorCode::*;\n-pub use self::Vtable::*;\n-pub use self::ObligationCauseCode::*;\n+#[allow(dead_code)]\n+pub mod auto_trait;\n+mod coherence;\n+pub mod error_reporting;\n+mod engine;\n+mod fulfill;\n+mod project;\n+mod object_safety;\n+mod on_unimplemented;\n+mod select;\n+mod specialize;\n+mod structural_impls;\n+pub mod codegen;\n+mod util;\n+pub mod query;\n \n use chalk_engine;\n use hir;\n use hir::def_id::DefId;\n-use infer::SuppressRegionErrors;\n+use infer::{InferCtxt, SuppressRegionErrors};\n use infer::outlives::env::OutlivesEnvironment;\n use middle::region;\n use mir::interpret::ErrorHandled;\n+use rustc_data_structures::sync::Lrc;\n+use syntax::ast;\n+use syntax_pos::{Span, DUMMY_SP};\n use ty::subst::Substs;\n use ty::{self, AdtKind, List, Ty, TyCtxt, GenericParamDefKind, ToPredicate};\n use ty::error::{ExpectedFound, TypeError};\n use ty::fold::{TypeFolder, TypeFoldable, TypeVisitor};\n-use infer::{InferCtxt};\n use util::common::ErrorReported;\n \n-use rustc_data_structures::sync::Lrc;\n use std::fmt::Debug;\n use std::rc::Rc;\n-use syntax::ast;\n-use syntax_pos::{Span, DUMMY_SP};\n+\n+pub use self::SelectionError::*;\n+pub use self::FulfillmentErrorCode::*;\n+pub use self::Vtable::*;\n+pub use self::ObligationCauseCode::*;\n \n pub use self::coherence::{orphan_check, overlapping_impls, OrphanCheckErr, OverlapResult};\n pub use self::fulfill::{FulfillmentContext, PendingPredicateObligation};\n@@ -51,25 +66,13 @@ pub use self::specialize::{OverlapError, specialization_graph, translate_substs}\n pub use self::specialize::find_associated_item;\n pub use self::engine::{TraitEngine, TraitEngineExt};\n pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n-pub use self::util::{supertraits, supertrait_def_ids, Supertraits, SupertraitDefIds};\n-pub use self::util::transitive_bounds;\n+pub use self::util::{supertraits, supertrait_def_ids, transitive_bounds,\n+                     Supertraits, SupertraitDefIds};\n \n-#[allow(dead_code)]\n-pub mod auto_trait;\n-mod coherence;\n-pub mod error_reporting;\n-mod engine;\n-mod fulfill;\n-mod project;\n-mod object_safety;\n-mod on_unimplemented;\n-mod select;\n-mod specialize;\n-mod structural_impls;\n-pub mod codegen;\n-mod util;\n-\n-pub mod query;\n+pub use self::ObligationCauseCode::*;\n+pub use self::FulfillmentErrorCode::*;\n+pub use self::SelectionError::*;\n+pub use self::Vtable::*;\n \n // Whether to enable bug compatibility with issue #43355\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -91,7 +94,7 @@ pub enum TraitQueryMode {\n     Canonical,\n }\n \n-/// An `Obligation` represents some trait reference (e.g. `int:Eq`) for\n+/// An `Obligation` represents some trait reference (e.g., `int:Eq`) for\n /// which the vtable must be found.  The process of finding a vtable is\n /// called \"resolving\" the `Obligation`. This process consists of\n /// either identifying an `impl` (e.g., `impl Eq for int`) that\n@@ -955,7 +958,7 @@ fn substitute_normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n \n /// Given a trait `trait_ref`, iterates the vtable entries\n /// that come from `trait_ref`, including its supertraits.\n-#[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n+#[inline] // FIXME(#35870): avoid closures being unexported due to `impl Trait`.\n fn vtable_methods<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>)"}, {"sha": "4b2f817cfa91ade43a055af24fc8e511fa576090", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -36,7 +36,7 @@ pub enum ObjectSafetyViolation {\n     SizedSelf,\n \n     /// Supertrait reference references `Self` an in illegal location\n-    /// (e.g. `trait Foo : Bar<Self>`)\n+    /// (e.g., `trait Foo : Bar<Self>`)\n     SupertraitSelf,\n \n     /// Method has something illegal\n@@ -81,7 +81,7 @@ pub enum MethodViolationCode {\n     /// e.g., `fn foo(&self, x: Self)` or `fn foo(&self) -> Self`\n     ReferencesSelf,\n \n-    /// e.g. `fn foo(&self) where Self: Clone`\n+    /// e.g., `fn foo(&self) where Self: Clone`\n     WhereClauseReferencesSelf(Span),\n \n     /// e.g., `fn foo<A>()`\n@@ -343,7 +343,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n                     }\n                 };\n \n-                // e.g. Rc<()>\n+                // e.g., Rc<()>\n                 let unit_receiver_ty = self.receiver_for_self_ty(\n                     receiver_ty, self.mk_unit(), method.def_id\n                 );\n@@ -357,7 +357,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n                     trait_def_id, self.mk_region(ty::ReStatic)\n                 );\n \n-                // e.g. Rc<dyn Trait>\n+                // e.g., Rc<dyn Trait>\n                 let trait_object_receiver = self.receiver_for_self_ty(\n                     receiver_ty, trait_object_ty, method.def_id\n                 );\n@@ -376,7 +376,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     }\n \n     /// performs a type substitution to produce the version of receiver_ty when `Self = self_ty`\n-    /// e.g. for receiver_ty = `Rc<Self>` and self_ty = `Foo`, returns `Rc<Foo>`\n+    /// e.g., for receiver_ty = `Rc<Self>` and self_ty = `Foo`, returns `Rc<Foo>`\n     fn receiver_for_self_ty(\n         self, receiver_ty: Ty<'tcx>, self_ty: Ty<'tcx>, method_def_id: DefId\n     ) -> Ty<'tcx> {\n@@ -451,7 +451,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     ///\n     /// The only case where the receiver is not dispatchable, but is still a valid receiver\n     /// type (just not object-safe), is when there is more than one level of pointer indirection.\n-    /// e.g. `self: &&Self`, `self: &Rc<Self>`, `self: Box<Box<Self>>`. In these cases, there\n+    /// e.g., `self: &&Self`, `self: &Rc<Self>`, `self: Box<Box<Self>>`. In these cases, there\n     /// is no way, or at least no inexpensive way, to coerce the receiver from the version where\n     /// `Self = dyn Trait` to the version where `Self = T`, where `T` is the unknown erased type\n     /// contained by the trait object, because the object that needs to be coerced is behind"}, {"sha": "5717a76f1cf0f149fd8339502351f60fa96a2d63", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -70,7 +70,7 @@ pub enum Reveal {\n     /// be observable directly by the user, `Reveal::All`\n     /// should not be used by checks which may expose\n     /// type equality or type contents to the user.\n-    /// There are some exceptions, e.g. around OIBITS and\n+    /// There are some exceptions, e.g., around OIBITS and\n     /// transmute-checking, which expose some details, but\n     /// not the whole concrete type of the `impl Trait`.\n     All,\n@@ -608,7 +608,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             // created (and hence the new ones will quickly be\n             // discarded as duplicated). But when doing trait\n             // evaluation this is not the case, and dropping the trait\n-            // evaluations can causes ICEs (e.g. #43132).\n+            // evaluations can causes ICEs (e.g., #43132).\n             debug!(\"opt_normalize_projection_type: \\\n                     found normalized ty `{:?}`\",\n                    ty);\n@@ -1589,7 +1589,7 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n /// When working with a fulfillment context, the derived obligations of each\n /// projection cache entry will be registered on the fulfillcx, so any users\n /// that can wait for a fulfillcx fixed point need not care about this. However,\n-/// users that don't wait for a fixed point (e.g. trait evaluation) have to\n+/// users that don't wait for a fixed point (e.g., trait evaluation) have to\n /// resolve the obligations themselves to make sure the projected result is\n /// ok and avoid issues like #43132.\n ///\n@@ -1637,7 +1637,7 @@ enum ProjectionCacheEntry<'tcx> {\n     NormalizedTy(NormalizedTy<'tcx>),\n }\n \n-// NB: intentionally not Clone\n+// N.B., intentionally not Clone\n pub struct ProjectionCacheSnapshot {\n     snapshot: Snapshot,\n }"}, {"sha": "c438542106c9e3150777441db11e77c66f19b8ef", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! See [rustc guide] for more info on how this works.\n+//! Candidate selection. See the [rustc guide] for more information on how this works.\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/traits/resolution.html#selection\n \n@@ -69,18 +69,18 @@ pub struct SelectionContext<'cx, 'gcx: 'cx + 'tcx, 'tcx: 'cx> {\n     /// require themselves.\n     freshener: TypeFreshener<'cx, 'gcx, 'tcx>,\n \n-    /// If true, indicates that the evaluation should be conservative\n+    /// If `true`, indicates that the evaluation should be conservative\n     /// and consider the possibility of types outside this crate.\n     /// This comes up primarily when resolving ambiguity. Imagine\n-    /// there is some trait reference `$0 : Bar` where `$0` is an\n+    /// there is some trait reference `$0: Bar` where `$0` is an\n     /// inference variable. If `intercrate` is true, then we can never\n     /// say for sure that this reference is not implemented, even if\n     /// there are *no impls at all for `Bar`*, because `$0` could be\n     /// bound to some type that in a downstream crate that implements\n     /// `Bar`. This is the suitable mode for coherence. Elsewhere,\n     /// though, we set this to false, because we are only interested\n     /// in types that the user could actually have written --- in\n-    /// other words, we consider `$0 : Bar` to be unimplemented if\n+    /// other words, we consider `$0: Bar` to be unimplemented if\n     /// there is no type that the user could *actually name* that\n     /// would satisfy it. This avoids crippling inference, basically.\n     intercrate: Option<IntercrateMode>,\n@@ -1170,7 +1170,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     //\n     // The selection process begins by examining all in-scope impls,\n     // caller obligations, and so forth and assembling a list of\n-    // candidates. See [rustc guide] for more details.\n+    // candidates. See the [rustc guide] for more details.\n     //\n     // [rustc guide]:\n     // https://rust-lang.github.io/rustc-guide/traits/resolution.html#candidate-assembly\n@@ -1615,7 +1615,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         };\n \n         if obligation.predicate.skip_binder().self_ty().is_ty_var() {\n-            // Self is a type variable (e.g. `_: AsRef<str>`).\n+            // Self is a type variable (e.g., `_: AsRef<str>`).\n             //\n             // This is somewhat problematic, as the current scheme can't really\n             // handle it turning to be a projection. This does end up as truly\n@@ -1664,7 +1664,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n         } else {\n             if lang_items.clone_trait() == Some(def_id) {\n-                // Same builtin conditions as `Copy`, i.e. every type which has builtin support\n+                // Same builtin conditions as `Copy`, i.e., every type which has builtin support\n                 // for `Copy` also has builtin support for `Clone`, + tuples and arrays of `Clone`\n                 // types have builtin support for `Clone`.\n                 let clone_conditions = self.copy_clone_conditions(obligation);\n@@ -2023,7 +2023,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     {\n                         candidates.vec.push(ImplCandidate(impl_def_id));\n \n-                        // NB: we can safely drop the placeholder map\n+                        // N.B., we can safely drop the placeholder map\n                         // since we are in a probe.\n                         mem::drop(placeholder_map);\n                     }\n@@ -2069,7 +2069,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     // that this obligation holds. That could be a\n                     // where-clause or, in the case of an object type,\n                     // it could be that the object type lists the\n-                    // trait (e.g. `Foo+Send : Send`). See\n+                    // trait (e.g., `Foo+Send : Send`). See\n                     // `compile-fail/typeck-default-trait-impl-send-param.rs`\n                     // for an example of a test case that exercises\n                     // this path.\n@@ -2097,7 +2097,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         );\n \n         self.probe(|this, _snapshot| {\n-            // the code below doesn't care about regions, and the\n+            // The code below doesn't care about regions, and the\n             // self-ty here doesn't escape this probe, so just erase\n             // any LBR.\n             let self_ty = this.tcx().erase_late_bound_regions(&obligation.self_ty());\n@@ -2145,7 +2145,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 .count();\n \n             if upcast_trait_refs > 1 {\n-                // can be upcast in many ways; need more type information\n+                // Can be upcast in many ways; need more type information.\n                 candidates.ambiguous = true;\n             } else if upcast_trait_refs == 1 {\n                 candidates.vec.push(ObjectCandidate);\n@@ -2197,8 +2197,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n                 // Upcasts permit two things:\n                 //\n-                // 1. Dropping builtin bounds, e.g. `Foo+Send` to `Foo`\n-                // 2. Tightening the region bound, e.g. `Foo+'a` to `Foo+'b` if `'a : 'b`\n+                // 1. Dropping builtin bounds, e.g., `Foo+Send` to `Foo`\n+                // 2. Tightening the region bound, e.g., `Foo+'a` to `Foo+'b` if `'a : 'b`\n                 //\n                 // Note that neither of these changes requires any\n                 // change at runtime.  Eventually this will be\n@@ -2354,7 +2354,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ImplCandidate(other_def) => {\n                 // See if we can toss out `victim` based on specialization.\n                 // This requires us to know *for sure* that the `other` impl applies\n-                // i.e. EvaluatedToOk:\n+                // i.e., EvaluatedToOk:\n                 if other.evaluation == EvaluatedToOk {\n                     match victim.candidate {\n                         ImplCandidate(victim_def) => {\n@@ -2717,7 +2717,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     //\n     // Confirmation unifies the output type parameters of the trait\n     // with the values found in the obligation, possibly yielding a\n-    // type error.  See [rustc guide] for more details.\n+    // type error.  See the [rustc guide] for more details.\n     //\n     // [rustc guide]:\n     // https://rust-lang.github.io/rustc-guide/traits/resolution.html#confirmation\n@@ -3003,7 +3003,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // are sufficient to determine the impl substs, without\n         // relying on projections in the impl-trait-ref.\n         //\n-        // e.g. `impl<U: Tr, V: Iterator<Item=U>> Foo<<U as Tr>::T> for V`\n+        // e.g., `impl<U: Tr, V: Iterator<Item=U>> Foo<<U as Tr>::T> for V`\n         impl_obligations.append(&mut substs.obligations);\n \n         VtableImplData {"}, {"sha": "96bb545f25c643442fb27fde267007515265ea8a", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -19,22 +19,21 @@\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/traits/specialization.html\n \n-use super::{SelectionContext, FulfillmentContext};\n-use super::util::impl_trait_ref_and_oblig;\n+pub mod specialization_graph;\n \n-use rustc_data_structures::fx::FxHashSet;\n use hir::def_id::DefId;\n use infer::{InferCtxt, InferOk};\n-use ty::subst::{Subst, Substs};\n+use lint;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::sync::Lrc;\n+use syntax_pos::DUMMY_SP;\n use traits::{self, ObligationCause, TraitEngine};\n use traits::select::IntercrateAmbiguityCause;\n use ty::{self, TyCtxt, TypeFoldable};\n-use syntax_pos::DUMMY_SP;\n-use rustc_data_structures::sync::Lrc;\n-\n-use lint;\n+use ty::subst::{Subst, Substs};\n \n-pub mod specialization_graph;\n+use super::{SelectionContext, FulfillmentContext};\n+use super::util::impl_trait_ref_and_oblig;\n \n /// Information pertinent to an overlapping impl error.\n pub struct OverlapError {\n@@ -184,7 +183,7 @@ pub(super) fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     //\n     // See RFC 1210 for more details and justification.\n \n-    // Currently we do not allow e.g. a negative impl to specialize a positive one\n+    // Currently we do not allow e.g., a negative impl to specialize a positive one\n     if tcx.impl_polarity(impl1_def_id) != tcx.impl_polarity(impl2_def_id) {\n         return false;\n     }\n@@ -295,17 +294,18 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n // Query provider for `specialization_graph_of`.\n-pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                      trait_id: DefId)\n-                                                      -> Lrc<specialization_graph::Graph> {\n+pub(super) fn specialization_graph_provider<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    trait_id: DefId,\n+) -> Lrc<specialization_graph::Graph> {\n     let mut sg = specialization_graph::Graph::new();\n \n     let mut trait_impls = tcx.all_impls(trait_id);\n \n     // The coherence checking implementation seems to rely on impls being\n     // iterated over (roughly) in definition order, so we are sorting by\n-    // negated CrateNum (so remote definitions are visited first) and then\n-    // by a flattened version of the DefIndex.\n+    // negated `CrateNum` (so remote definitions are visited first) and then\n+    // by a flattened version of the `DefIndex`.\n     trait_impls.sort_unstable_by_key(|def_id| {\n         (-(def_id.krate.as_u32() as i64),\n          def_id.index.address_space().index(),"}, {"sha": "22221e0a3d93d87dbe182ec68b0652e1ad210539", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -29,7 +29,7 @@ use util::nodemap::{DefIdMap, FxHashMap};\n ///\n /// The graph provides two key services:\n ///\n-/// - Construction, which implicitly checks for overlapping impls (i.e., impls\n+/// - Construction. This implicitly checks for overlapping impls (i.e., impls\n ///   that overlap but where neither specializes the other -- an artifact of the\n ///   simple \"chain\" rule.\n ///\n@@ -39,11 +39,11 @@ use util::nodemap::{DefIdMap, FxHashMap};\n ///   has at most one parent.\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Graph {\n-    // all impls have a parent; the \"root\" impls have as their parent the def_id\n-    // of the trait\n+    // All impls have a parent; the \"root\" impls have as their parent the `def_id`\n+    // of the trait.\n     parent: DefIdMap<DefId>,\n \n-    // the \"root\" impls are found by looking up the trait's def_id.\n+    // The \"root\" impls are found by looking up the trait's def_id.\n     children: DefIdMap<Children>,\n }\n \n@@ -81,7 +81,7 @@ enum Inserted {\n }\n \n impl<'a, 'gcx, 'tcx> Children {\n-    /// Insert an impl into this set of children without comparing to any existing impls\n+    /// Insert an impl into this set of children without comparing to any existing impls.\n     fn insert_blindly(&mut self,\n                       tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                       impl_def_id: DefId) {\n@@ -144,13 +144,13 @@ impl<'a, 'gcx, 'tcx> Children {\n             );\n \n             let overlap_error = |overlap: traits::coherence::OverlapResult<'_>| {\n-                // overlap, but no specialization; error out\n+                // Found overlap, but no specialization; error out.\n                 let trait_ref = overlap.impl_header.trait_ref.unwrap();\n                 let self_ty = trait_ref.self_ty();\n                 OverlapError {\n                     with_impl: possible_sibling,\n                     trait_desc: trait_ref.to_string(),\n-                    // only report the Self type if it has at least\n+                    // Only report the `Self` type if it has at least\n                     // some outer concrete shell; otherwise, it's\n                     // not adding much information.\n                     self_desc: if self_ty.has_concrete_skeleton() {\n@@ -189,7 +189,7 @@ impl<'a, 'gcx, 'tcx> Children {\n                 debug!(\"descending as child of TraitRef {:?}\",\n                        tcx.impl_trait_ref(possible_sibling).unwrap());\n \n-                // the impl specializes possible_sibling\n+                // The impl specializes `possible_sibling`.\n                 return Ok(Inserted::ShouldRecurseOn(possible_sibling));\n             } else if ge && !le {\n                 debug!(\"placing as parent of TraitRef {:?}\",\n@@ -216,7 +216,7 @@ impl<'a, 'gcx, 'tcx> Children {\n             return Ok(Inserted::ReplaceChildren(replace_children));\n         }\n \n-        // no overlap with any potential siblings, so add as a new sibling\n+        // No overlap with any potential siblings, so add as a new sibling.\n         debug!(\"placing as new sibling\");\n         self.insert_blindly(tcx, impl_def_id);\n         Ok(Inserted::BecameNewSibling(last_lint))\n@@ -256,7 +256,7 @@ impl<'a, 'gcx, 'tcx> Graph {\n         debug!(\"insert({:?}): inserting TraitRef {:?} into specialization graph\",\n                impl_def_id, trait_ref);\n \n-        // if the reference itself contains an earlier error (e.g., due to a\n+        // If the reference itself contains an earlier error (e.g., due to a\n         // resolution failure), then we just insert the impl at the top level of\n         // the graph and claim that there's no overlap (in order to suppress\n         // bogus errors).\n@@ -275,7 +275,7 @@ impl<'a, 'gcx, 'tcx> Graph {\n         let mut last_lint = None;\n         let simplified = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false);\n \n-        // Descend the specialization tree, where `parent` is the current parent node\n+        // Descend the specialization tree, where `parent` is the current parent node.\n         loop {\n             use self::Inserted::*;\n \n@@ -313,7 +313,7 @@ impl<'a, 'gcx, 'tcx> Graph {\n                         siblings.insert_blindly(tcx, impl_def_id);\n                     }\n \n-                    // Set G's parent to N and N's parent to P\n+                    // Set G's parent to N and N's parent to P.\n                     for &grand_child_to_be in &grand_children_to_be {\n                         self.parent.insert(grand_child_to_be, impl_def_id);\n                     }\n@@ -429,7 +429,8 @@ impl<T> NodeItem<T> {\n impl<'a, 'gcx, 'tcx> Ancestors {\n     /// Search the items from the given ancestors, returning each definition\n     /// with the given name and the given kind.\n-    #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n+    // FIXME(#35870): avoid closures being unexported due to `impl Trait`.\n+    #[inline]\n     pub fn defs(\n         self,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,"}, {"sha": "48db72c1f5615bc73dd13383997ed2ef64ea852c", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use hir;\n use hir::def_id::DefId;\n-use ty::subst::{Kind, Subst, Substs};\n+use traits::specialize::specialization_graph::NodeItem;\n use ty::{self, Ty, TyCtxt, ToPredicate, ToPolyTraitRef};\n use ty::outlives::Component;\n+use ty::subst::{Kind, Subst, Substs};\n use util::nodemap::FxHashSet;\n-use hir::{self};\n-use traits::specialize::specialization_graph::NodeItem;\n \n use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext, Normalized};\n "}, {"sha": "d91ae7e120f6604ffe2417f547d02977b7fbfd11", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -83,7 +83,7 @@ pub enum Adjust<'tcx> {\n     /// Take the address and produce either a `&` or `*` pointer.\n     Borrow(AutoBorrow<'tcx>),\n \n-    /// Unsize a pointer/reference value, e.g. `&[T; n]` to\n+    /// Unsize a pointer/reference value, e.g., `&[T; n]` to\n     /// `&[T]`. Note that the source could be a thin or fat pointer.\n     /// This will do things like convert thin pointers to fat\n     /// pointers, or convert structs containing thin pointers to"}, {"sha": "5ad7d247fe4594b9d59e25431926246cde8510ea", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -92,7 +92,7 @@ pub fn encode_with_shorthand<E, T, M>(encoder: &mut E,\n     let leb128_bits = len * 7;\n \n     // Check that the shorthand is a not longer than the\n-    // full encoding itself, i.e. it's an obvious win.\n+    // full encoding itself, i.e., it's an obvious win.\n     if leb128_bits >= 64 || (shorthand as u64) < (1 << leb128_bits) {\n         cache(encoder).insert(value.clone(), shorthand);\n     }"}, {"sha": "a3db3a02aad92c81572076b1d75bd80b8170898d", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -587,7 +587,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     // auto-ref.  The type returned by this function does not consider such\n     // adjustments.  See `expr_ty_adjusted()` instead.\n     //\n-    // NB (2): This type doesn't provide type parameter substitutions; e.g. if you\n+    // NB (2): This type doesn't provide type parameter substitutions; e.g., if you\n     // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&isize) -> isize\"\n     // instead of \"fn(ty) -> T with T = isize\".\n     pub fn expr_ty(&self, expr: &hir::Expr) -> Ty<'tcx> {\n@@ -1654,7 +1654,7 @@ impl<'gcx: 'tcx, 'tcx> GlobalCtxt<'gcx> {\n /// For Ty, None can be returned if either the type interner doesn't\n /// contain the TyKind key or if the address of the interned\n /// pointer differs. The latter case is possible if a primitive type,\n-/// e.g. `()` or `u8`, was interned in a different context.\n+/// e.g., `()` or `u8`, was interned in a different context.\n pub trait Lift<'tcx>: fmt::Debug {\n     type Lifted: fmt::Debug + 'tcx;\n     fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted>;\n@@ -2232,7 +2232,7 @@ impl<'tcx, T: 'tcx+?Sized> Clone for Interned<'tcx, T> {\n }\n impl<'tcx, T: 'tcx+?Sized> Copy for Interned<'tcx, T> {}\n \n-// NB: An Interned<Ty> compares and hashes as a sty.\n+// N.B., an `Interned<Ty>` compares and hashes as a sty.\n impl<'tcx> PartialEq for Interned<'tcx, TyS<'tcx>> {\n     fn eq(&self, other: &Interned<'tcx, TyS<'tcx>>) -> bool {\n         self.0.sty == other.0.sty\n@@ -2253,7 +2253,7 @@ impl<'tcx: 'lcx, 'lcx> Borrow<TyKind<'lcx>> for Interned<'tcx, TyS<'tcx>> {\n     }\n }\n \n-// NB: An Interned<List<T>> compares and hashes as its elements.\n+// N.B., an `Interned<List<T>>` compares and hashes as its elements.\n impl<'tcx, T: PartialEq> PartialEq for Interned<'tcx, List<T>> {\n     fn eq(&self, other: &Interned<'tcx, List<T>>) -> bool {\n         self.0[..] == other.0[..]\n@@ -2464,7 +2464,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// Given a closure signature `sig`, returns an equivalent `fn`\n     /// type with the same signature. Detuples and so forth -- so\n-    /// e.g. if we have a sig with `Fn<(u32, i32)>` then you would get\n+    /// e.g., if we have a sig with `Fn<(u32, i32)>` then you would get\n     /// a `fn(u32, i32)`.\n     pub fn coerce_closure_fn_ty(self, sig: PolyFnSig<'tcx>) -> Ty<'tcx> {\n         let converted_sig = sig.map_bound(|s| {\n@@ -2869,11 +2869,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn lint_hir_note<S: Into<MultiSpan>>(self,\n-                                              lint: &'static Lint,\n-                                              hir_id: HirId,\n-                                              span: S,\n-                                              msg: &str,\n-                                              note: &str) {\n+                                             lint: &'static Lint,\n+                                             hir_id: HirId,\n+                                             span: S,\n+                                             msg: &str,\n+                                             note: &str) {\n         let mut err = self.struct_span_lint_hir(lint, hir_id, span.into(), msg);\n         err.note(note);\n         err.emit()\n@@ -3016,9 +3016,9 @@ impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n }\n \n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n-    // FIXME(#44234) - almost all of these queries have no sub-queries and\n+    // FIXME(#44234): almost all of these queries have no sub-queries and\n     // therefore no actual inputs, they're just reading tables calculated in\n-    // resolve! Does this work? Unsure! That's what the issue is about\n+    // resolve! Does this work? Unsure! That's what the issue is about.\n     providers.in_scope_traits_map = |tcx, id| tcx.gcx.trait_map.get(&id).cloned();\n     providers.module_exports = |tcx, id| tcx.gcx.export_map.get(&id).cloned();\n     providers.crate_name = |tcx, id| {"}, {"sha": "a361ad057c74a0e8c730c4641fd2205b9f694e1f", "filename": "src/librustc/ty/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferase_regions.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -19,7 +19,7 @@ pub(super) fn provide(providers: &mut ty::query::Providers<'_>) {\n }\n \n fn erase_regions_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    // NB: use `super_fold_with` here. If we used `fold_with`, it\n+    // N.B., use `super_fold_with` here. If we used `fold_with`, it\n     // could invoke the `erase_regions_ty` query recursively.\n     ty.super_fold_with(&mut RegionEraserVisitor { tcx })\n }"}, {"sha": "7005e14c26c4245f242e91e9f2fe01a729c830d8", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -110,7 +110,7 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                 // anything. when lazy normalization happens, this\n                 // will change. It would still be nice to have a way\n                 // to deal with known-not-to-unify-with-anything\n-                // projections (e.g. the likes of <__S as Encoder>::Error).\n+                // projections (e.g., the likes of <__S as Encoder>::Error).\n                 Some(ParameterSimplifiedType)\n             } else {\n                 None"}, {"sha": "a40e1df14f8e829621517752ec9ef18479f0ab44", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -887,7 +887,7 @@ struct LateBoundRegionsCollector {\n \n     /// If true, we only want regions that are known to be\n     /// \"constrained\" when you equate this type with another type. In\n-    /// particular, if you have e.g. `&'a u32` and `&'b u32`, equating\n+    /// particular, if you have e.g., `&'a u32` and `&'b u32`, equating\n     /// them constraints `'a == 'b`.  But if you have `<&'a u32 as\n     /// Trait>::Foo` and `<&'b u32 as Trait>::Foo`, normalizing those\n     /// types may mean that `'a` and `'b` don't appear in the results,"}, {"sha": "a39eb004fd7864bd711cd998955921968616d35d", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -317,7 +317,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             // Unclear if there is any value in distinguishing these.\n             // Probably eventually (and maybe we would even want\n-            // finer-grained distinctions, e.g. between enum/struct).\n+            // finer-grained distinctions, e.g., between enum/struct).\n             data @ DefPathData::Misc |\n             data @ DefPathData::TypeNs(..) |\n             data @ DefPathData::Trait(..) |"}, {"sha": "87d745e5cea77200c82b32185b236248215d3402", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -248,7 +248,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             AlwaysSized,\n             /// A univariant, the last field of which may be coerced to unsized.\n             MaybeUnsized,\n-            /// A univariant, but with a prefix of an arbitrary size & alignment (e.g. enum tag).\n+            /// A univariant, but with a prefix of an arbitrary size & alignment (e.g., enum tag).\n             Prefixed(Size, Align),\n         }\n \n@@ -748,7 +748,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n                 // A variant is absent if it's uninhabited and only has ZST fields.\n                 // Present uninhabited variants only require space for their fields,\n-                // but *not* an encoding of the discriminant (e.g. a tag value).\n+                // but *not* an encoding of the discriminant (e.g., a tag value).\n                 // See issue #49298 for more details on the need to leave space\n                 // for non-ZST uninhabited data (mostly partial initialization).\n                 let absent = |fields: &[TyLayout<'_>]| {\n@@ -1252,7 +1252,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }).collect();\n \n             session::VariantInfo {\n-                name: n.map(|n|n.to_string()),\n+                name: n.map(|n| n.to_string()),\n                 kind: if layout.is_unsized() {\n                     session::SizeKind::Min\n                 } else {\n@@ -1311,7 +1311,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n     }\n }\n \n-/// Type size \"skeleton\", i.e. the only information determining a type's size.\n+/// Type size \"skeleton\", i.e., the only information determining a type's size.\n /// While this is conservative, (aside from constant sizes, only pointers,\n /// newtypes thereof and null pointer optimized enums are allowed), it is\n /// enough to statically check common use cases of transmute.\n@@ -1522,7 +1522,7 @@ impl<'a, 'tcx> LayoutOf for LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             details\n         };\n \n-        // NB: This recording is normally disabled; when enabled, it\n+        // N.B., this recording is normally disabled; when enabled, it\n         // can however trigger recursive invocations of `layout_of`.\n         // Therefore, we execute it *after* the main query has\n         // completed, to avoid problems around recursive structures\n@@ -1549,7 +1549,7 @@ impl<'a, 'tcx> LayoutOf for LayoutCx<'tcx, ty::query::TyCtxtAt<'a, 'tcx, 'tcx>>\n             details\n         };\n \n-        // NB: This recording is normally disabled; when enabled, it\n+        // N.B., this recording is normally disabled; when enabled, it\n         // can however trigger recursive invocations of `layout_of`.\n         // Therefore, we execute it *after* the main query has\n         // completed, to avoid problems around recursive structures\n@@ -1660,7 +1660,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                 assert!(i < this.fields.count());\n \n                 // Reuse the fat *T type as its own thin pointer data field.\n-                // This provides information about e.g. DST struct pointees\n+                // This provides information about e.g., DST struct pointees\n                 // (which may have no non-DST form), and will work as long\n                 // as the `Abi` or `FieldPlacement` is checked by users.\n                 if i == 0 {"}, {"sha": "a1fc949137ddef79016c88f53ad6fe337cd5a4a6", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -125,7 +125,7 @@ mod sty;\n /// The complete set of all analyses described in this module. This is\n /// produced by the driver and fed to codegen and later passes.\n ///\n-/// NB: These contents are being migrated into queries using the\n+/// N.B., these contents are being migrated into queries using the\n /// *on-demand* infrastructure.\n #[derive(Clone)]\n pub struct CrateAnalysis {\n@@ -505,15 +505,15 @@ pub struct TyS<'tcx> {\n     ///     by some sub-binder.\n     ///\n     /// So, for a type without any late-bound things, like `u32`, this\n-    /// will be INNERMOST, because that is the innermost binder that\n+    /// will be *innermost*, because that is the innermost binder that\n     /// captures nothing. But for a type `&'D u32`, where `'D` is a\n-    /// late-bound region with debruijn index D, this would be D+1 --\n-    /// the binder itself does not capture D, but D is captured by an\n-    /// inner binder.\n+    /// late-bound region with debruijn index `D`, this would be `D + 1`\n+    /// -- the binder itself does not capture `D`, but `D` is captured\n+    /// by an inner binder.\n     ///\n-    /// We call this concept an \"exclusive\" binder D (because all\n+    /// We call this concept an \"exclusive\" binder `D` because all\n     /// debruijn indices within the type are contained within `0..D`\n-    /// (exclusive)).\n+    /// (exclusive).\n     outer_exclusive_binder: ty::DebruijnIndex,\n }\n \n@@ -900,10 +900,10 @@ pub struct GenericParamCount {\n }\n \n /// Information about the formal type/lifetime parameters associated\n-/// with an item or method. Analogous to hir::Generics.\n+/// with an item or method. Analogous to `hir::Generics`.\n ///\n-/// The ordering of parameters is the same as in Subst (excluding child generics):\n-/// Self (optionally), Lifetime params..., Type params...\n+/// The ordering of parameters is the same as in `Subst` (excluding child generics):\n+/// `Self` (optionally), `Lifetime` params..., `Type` params...\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct Generics {\n     pub parent: Option<DefId>,\n@@ -1681,7 +1681,7 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// pair it with the empty environment. This improves caching and is generally\n     /// invisible.\n     ///\n-    /// NB: We preserve the environment when type-checking because it\n+    /// N.B., we preserve the environment when type-checking because it\n     /// is possible for the user to have wacky where-clauses like\n     /// `where Box<u32>: Copy`, which are clearly never\n     /// satisfiable. We generally want to behave as if they were true,\n@@ -1778,8 +1778,8 @@ bitflags! {\n \n #[derive(Debug)]\n pub struct VariantDef {\n-    /// The variant's DefId. If this is a tuple-like struct,\n-    /// this is the DefId of the struct's ctor.\n+    /// The variant's `DefId`. If this is a tuple-like struct,\n+    /// this is the `DefId` of the struct's ctor.\n     pub did: DefId,\n     pub name: Name, // struct's name if this is a struct\n     pub discr: VariantDiscr,\n@@ -1798,7 +1798,7 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n     ///\n     /// Note that we *could* use the constructor DefId, because the constructor attributes\n     /// redirect to the base attributes, but compiling a small crate requires\n-    /// loading the AdtDefs for all the structs in the universe (e.g. coherence for any\n+    /// loading the AdtDefs for all the structs in the universe (e.g., coherence for any\n     /// built-in trait), and we do not want to load attributes twice.\n     ///\n     /// If someone speeds up attribute loading to not be a performance concern, they can\n@@ -1847,7 +1847,7 @@ impl_stable_hash_for!(struct VariantDef {\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum VariantDiscr {\n-    /// Explicit value for this variant, i.e. `X = 123`.\n+    /// Explicit value for this variant, i.e., `X = 123`.\n     /// The `DefId` corresponds to the embedded constant.\n     Explicit(DefId),\n \n@@ -1865,9 +1865,9 @@ pub struct FieldDef {\n     pub vis: Visibility,\n }\n \n-/// The definition of an abstract data type - a struct or enum.\n+/// The definition of an abstract data type -- a struct or enum.\n ///\n-/// These are all interned (by intern_adt_def) into the adt_defs\n+/// These are all interned (by `intern_adt_def`) into the `adt_defs`\n /// table.\n pub struct AdtDef {\n     pub did: DefId,\n@@ -2367,7 +2367,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     /// Self would prevent its containing ADT from being Sized.\n     ///\n     /// Due to normalization being eager, this applies even if\n-    /// the associated type is behind a pointer, e.g. issue #31299.\n+    /// the associated type is behind a pointer, e.g., issue #31299.\n     pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx [Ty<'tcx>] {\n         match tcx.try_adt_sized_constraint(DUMMY_SP, self.did) {\n             Ok(tys) => tys,"}, {"sha": "5cd06fb8a52c015c4418dbd3b0f87974407eda53", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -166,21 +166,21 @@ define_queries! { <'tcx>\n         ) -> Result<DtorckConstraint<'tcx>, NoSolution>,\n \n         /// True if this is a const fn, use the `is_const_fn` to know whether your crate actually\n-        /// sees it as const fn (e.g. the const-fn-ness might be unstable and you might not have\n+        /// sees it as const fn (e.g., the const-fn-ness might be unstable and you might not have\n         /// the feature gate active)\n         ///\n-        /// DO NOT CALL MANUALLY, it is only meant to cache the base data for the `is_const_fn`\n-        /// function\n+        /// **Do not call this function manually.** It is only meant to cache the base data for the\n+        /// `is_const_fn` function.\n         [] fn is_const_fn_raw: IsConstFn(DefId) -> bool,\n \n \n         /// Returns true if calls to the function may be promoted\n         ///\n-        /// This is either because the function is e.g. a tuple-struct or tuple-variant constructor,\n-        /// or because it has the `#[rustc_promotable]` attribute. The attribute should be removed\n-        /// in the future in favour of some form of check which figures out whether the function\n-        /// does not inspect the bits of any of its arguments (so is essentially just a constructor\n-        /// function)\n+        /// This is either because the function is e.g., a tuple-struct or tuple-variant\n+        /// constructor, or because it has the `#[rustc_promotable]` attribute. The attribute should\n+        /// be removed in the future in favour of some form of check which figures out whether the\n+        /// function does not inspect the bits of any of its arguments (so is essentially just a\n+        /// constructor function).\n         [] fn is_promotable_const_fn: IsPromotableConstFn(DefId) -> bool,\n \n         /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n@@ -539,7 +539,7 @@ define_queries! { <'tcx>\n         [] fn all_crate_nums: all_crate_nums_node(CrateNum) -> Lrc<Vec<CrateNum>>,\n \n         /// A vector of every trait accessible in the whole crate\n-        /// (i.e. including those from subcrates). This is used only for\n+        /// (i.e., including those from subcrates). This is used only for\n         /// error reporting.\n         [] fn all_traits: all_traits_node(CrateNum) -> Lrc<Vec<DefId>>,\n     },"}, {"sha": "7ad4fd58273ee679f0554678f4a0b880cfbd6892", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Generalized type relating mechanism. A type relation R relates a\n-//! pair of values (A, B). A and B are usually types or regions but\n-//! can be other things. Examples of type relations are subtyping,\n-//! type equality, etc.\n+//! Generalized type relating mechanism.\n+//!\n+//! A type relation `R` relates a pair of values `(A, B)`. `A and B` are usually\n+//! types or regions but can be other things. Examples of type relations are\n+//! subtyping, type equality, etc.\n \n use hir::def_id::DefId;\n use mir::interpret::ConstValue;"}, {"sha": "f757f48e987d8233f66f3fe152f232a1f528ee36", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! This module contains TyKind and its major components\n+//! This module contains `TyKind` and its major components.\n \n+use hir;\n use hir::def_id::DefId;\n use infer::canonical::Canonical;\n use mir::interpret::ConstValue;\n@@ -30,9 +31,6 @@ use syntax::ast::{self, Ident};\n use syntax::symbol::{keywords, InternedString};\n \n use serialize;\n-\n-use hir;\n-\n use self::InferTy::*;\n use self::TyKind::*;\n \n@@ -91,7 +89,7 @@ impl BoundRegion {\n     }\n }\n \n-/// N.B., If you change this, you'll probably want to change the corresponding\n+/// N.B., if you change this, you'll probably want to change the corresponding\n /// AST structure in `libsyntax/ast.rs` as well.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum TyKind<'tcx> {\n@@ -531,11 +529,11 @@ impl<'tcx> UpvarSubsts<'tcx> {\n \n #[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Ord, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum ExistentialPredicate<'tcx> {\n-    /// e.g. Iterator\n+    /// e.g., Iterator\n     Trait(ExistentialTraitRef<'tcx>),\n-    /// e.g. Iterator::Item = T\n+    /// e.g., Iterator::Item = T\n     Projection(ExistentialProjection<'tcx>),\n-    /// e.g. Send\n+    /// e.g., Send\n     AutoTrait(DefId),\n }\n \n@@ -784,7 +782,7 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n /// Binder<TraitRef>`). Note that when we instantiate,\n /// erase, or otherwise \"discharge\" these bound vars, we change the\n /// type from `Binder<T>` to just `T` (see\n-/// e.g. `liberate_late_bound_regions`).\n+/// e.g., `liberate_late_bound_regions`).\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct Binder<T>(T);\n \n@@ -1099,12 +1097,12 @@ pub type Region<'tcx> = &'tcx RegionKind;\n /// with some concrete region before being used. There are 2 kind of\n /// bound regions: early-bound, which are bound in an item's Generics,\n /// and are substituted by a Substs,  and late-bound, which are part of\n-/// higher-ranked types (e.g. `for<'a> fn(&'a ())`) and are substituted by\n+/// higher-ranked types (e.g., `for<'a> fn(&'a ())`) and are substituted by\n /// the likes of `liberate_late_bound_regions`. The distinction exists\n /// because higher-ranked lifetimes aren't supported in all places. See [1][2].\n ///\n /// Unlike Param-s, bound regions are not supposed to exist \"in the wild\"\n-/// outside their binder, e.g. in types passed to type inference, and\n+/// outside their binder, e.g., in types passed to type inference, and\n /// should first be substituted (by placeholder regions, free regions,\n /// or region variables).\n ///\n@@ -1160,7 +1158,7 @@ pub enum RegionKind {\n     ReFree(FreeRegion),\n \n     /// A concrete region naming some statically determined scope\n-    /// (e.g. an expression or sequence of statements) within the\n+    /// (e.g., an expression or sequence of statements) within the\n     /// current function.\n     ReScope(region::Scope),\n \n@@ -1324,15 +1322,15 @@ impl<'a, 'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n \n impl DebruijnIndex {\n     /// Returns the resulting index when this value is moved into\n-    /// `amount` number of new binders. So e.g. if you had\n+    /// `amount` number of new binders. So e.g., if you had\n     ///\n     ///    for<'a> fn(&'a x)\n     ///\n     /// and you wanted to change to\n     ///\n     ///    for<'a> fn(for<'b> fn(&'a x))\n     ///\n-    /// you would need to shift the index for `'a` into 1 new binder.\n+    /// you would need to shift the index for `'a` into a new binder.\n     #[must_use]\n     pub fn shifted_in(self, amount: u32) -> DebruijnIndex {\n         DebruijnIndex::from_u32(self.as_u32() + amount)\n@@ -1809,10 +1807,10 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    /// Returns the type and mutability of *ty.\n+    /// Returns the type and mutability of `*ty`.\n     ///\n     /// The parameter `explicit` indicates if this is an *explicit* dereference.\n-    /// Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n+    /// Some types -- notably unsafe ptrs -- can only be dereferenced explicitly.\n     pub fn builtin_deref(&self, explicit: bool) -> Option<TypeAndMut<'tcx>> {\n         match self.sty {\n             Adt(def, _) if def.is_box() => {"}, {"sha": "cda281e053a3453013ee90e21b986fa12b9b7ff4", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -316,10 +316,10 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     /// Transform from substitutions for a child of `source_ancestor`\n-    /// (e.g. a trait or impl) to substitutions for the same child\n+    /// (e.g., a trait or impl) to substitutions for the same child\n     /// in a different item, with `target_substs` as the base for\n     /// the target impl/trait, with the source child-specific\n-    /// parameters (e.g. method parameters) on top of that base.\n+    /// parameters (e.g., method parameters) on top of that base.\n     pub fn rebase_onto(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                        source_ancestor: DefId,\n                        target_substs: &Substs<'tcx>)"}, {"sha": "f9ce228a30c2311150aeeb417d8bbb379e90151c", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -344,7 +344,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// themselves. This should really be a unique type; `FreshTy(0)` is a\n     /// popular choice.\n     ///\n-    /// NB: in some cases, particularly around higher-ranked bounds,\n+    /// N.B., in some cases, particularly around higher-ranked bounds,\n     /// this function returns a kind of conservative approximation.\n     /// That is, all regions returned by this function are definitely\n     /// required, but there may be other region bounds that are not\n@@ -451,9 +451,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // destructor will not access borrowed data,\n         // even if such data is otherwise reachable.\n         //\n-        // Such access can be in plain sight (e.g. dereferencing\n+        // Such access can be in plain sight (e.g., dereferencing\n         // `*foo.0` of `Foo<'a>(&'a u32)`) or indirectly hidden\n-        // (e.g. calling `foo.0.clone()` of `Foo<T:Clone>`).\n+        // (e.g., calling `foo.0.clone()` of `Foo<T:Clone>`).\n         if self.has_attr(dtor, \"unsafe_destructor_blind_to_params\") {\n             debug!(\"destructor_constraint({:?}) - blind\", def.did);\n             return vec![];\n@@ -656,7 +656,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n     /// If `ty.needs_drop(...)` returns `true`, then `ty` is definitely\n     /// non-copy and *might* have a destructor attached; if it returns\n-    /// `false`, then `ty` definitely has no destructor (i.e. no drop glue).\n+    /// `false`, then `ty` definitely has no destructor (i.e., no drop glue).\n     ///\n     /// (Note that this implies that if `ty` has a destructor attached,\n     /// then `needs_drop` will definitely return `true` for `ty`.)"}, {"sha": "68e197849b03e701deaed92afd13465b5c58d6d3", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -342,7 +342,7 @@ pub trait MemoizationMap {\n     /// If `key` is present in the map, return the value,\n     /// otherwise invoke `op` and store the value in the map.\n     ///\n-    /// NB: if the receiver is a `DepTrackingMap`, special care is\n+    /// N.B., if the receiver is a `DepTrackingMap`, special care is\n     /// needed in the `op` to ensure that the correct edges are\n     /// added into the dep graph. See the `DepTrackingMap` impl for\n     /// more details!"}, {"sha": "60ddac1abfd46f10c2efda39c983c1571c772092", "filename": "src/librustc_apfloat/ieee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_apfloat%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_apfloat%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fieee.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -926,7 +926,7 @@ impl<S: Semantics> Float for IeeeFloat<S> {\n \n         // In case MSB resides at the left-hand side of radix point, shift the\n         // mantissa right by some amount to make sure the MSB reside right before\n-        // the radix point (i.e. \"MSB . rest-significant-bits\").\n+        // the radix point (i.e., \"MSB . rest-significant-bits\").\n         if omsb > S::PRECISION {\n             let bits = omsb - S::PRECISION;\n             loss = sig::shift_right(&mut wide_sig, &mut self.exp, bits).combine(loss);\n@@ -2674,7 +2674,7 @@ mod sig {\n \n         // In case MSB resides at the left-hand side of radix point, shift the\n         // mantissa right by some amount to make sure the MSB reside right before\n-        // the radix point (i.e. \"MSB . rest-significant-bits\").\n+        // the radix point (i.e., \"MSB . rest-significant-bits\").\n         //\n         // Note that the result is not normalized when \"omsb < precision\". So, the\n         // caller needs to call IeeeFloat::normalize() if normalized value is"}, {"sha": "c90191716010b7d59784b10ef3ff7db2e54941fb", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -26,8 +26,8 @@\n //! Comments have been preserved where possible, only slightly adapted.\n //!\n //! Instead of keeping a pointer to a configuration struct and inspecting it\n-//! dynamically on every operation, types (e.g. `ieee::Double`), traits\n-//! (e.g. `ieee::Semantics`) and associated constants are employed for\n+//! dynamically on every operation, types (e.g., `ieee::Double`), traits\n+//! (e.g., `ieee::Semantics`) and associated constants are employed for\n //! increased type safety and performance.\n //!\n //! On-heap bigints are replaced everywhere (except in decimal conversion),\n@@ -179,7 +179,7 @@ pub struct ParseError(pub &'static str);\n /// implemented operations. Currently implemented operations are add, subtract,\n /// multiply, divide, fused-multiply-add, conversion-to-float,\n /// conversion-to-integer and conversion-from-integer. New rounding modes\n-/// (e.g. away from zero) can be added with three or four lines of code.\n+/// (e.g., away from zero) can be added with three or four lines of code.\n ///\n /// Four formats are built-in: IEEE single precision, double precision,\n /// quadruple precision, and x87 80-bit extended double (when operating with\n@@ -589,7 +589,7 @@ pub trait Float\n pub trait FloatConvert<T: Float>: Float {\n     /// Convert a value of one floating point type to another.\n     /// The return value corresponds to the IEEE754 exceptions. *loses_info\n-    /// records whether the transformation lost information, i.e. whether\n+    /// records whether the transformation lost information, i.e., whether\n     /// converting the result back to the original type will produce the\n     /// original value (this is almost the same as return value==Status::OK,\n     /// but there are edge cases where this is not so)."}, {"sha": "aaf6b29a99e8cb23b4c6485b18423bc1607be7c0", "filename": "src/librustc_apfloat/ppc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_apfloat%2Fppc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_apfloat%2Fppc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fppc.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -288,7 +288,7 @@ where\n         //   \\   /\n         //   Normal\n         //\n-        // e.g. NaN * NaN = NaN\n+        // e.g., NaN * NaN = NaN\n         //      Zero * Inf = NaN\n         //      Normal * Zero = Zero\n         //      Normal * Inf = Inf"}, {"sha": "7ed4d4910d71d8d130e2a6adc6ee3fa2a0d0c234", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -286,7 +286,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                                                 lp);\n             }\n             None => {\n-                // This can occur with e.g. `*foo() = 5`.  In such\n+                // This can occur with e.g., `*foo() = 5`.  In such\n                 // cases, there is no need to check for conflicts\n                 // with moves etc, just ignore.\n             }"}, {"sha": "cb1200f462fb635c894b72a004f63cc2c5872ae3", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -217,7 +217,7 @@ fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tc\n }\n \n /// Accessor for introspective clients inspecting `AnalysisData` and\n-/// the `BorrowckCtxt` itself , e.g. the flowgraph visualizer.\n+/// the `BorrowckCtxt` itself , e.g., the flowgraph visualizer.\n pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     body_id: hir::BodyId,"}, {"sha": "d12c22109c681d3321faaf2fb474af083b0ced9a", "filename": "src/librustc_borrowck/dataflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdataflow.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -71,7 +71,7 @@ pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n     scope_kills: Vec<usize>,\n \n     /// bits killed as we exit the cfg node directly; if it is jumped\n-    /// over, e.g. via `break`, the kills are not reflected in the\n+    /// over, e.g., via `break`, the kills are not reflected in the\n     /// jump's effects. Updated by `add_kill(KillFrom::Execution)`.\n     action_kills: Vec<usize>,\n \n@@ -172,7 +172,7 @@ fn build_local_id_to_index(body: Option<&hir::Body>,\n     let mut index = FxHashMap::default();\n \n     // FIXME(#15020) Would it be better to fold formals from decl\n-    // into cfg itself?  i.e. introduce a fn-based flow-graph in\n+    // into cfg itself?  i.e., introduce a fn-based flow-graph in\n     // addition to the current block-based flow-graph, rather than\n     // have to put traversals like this here?\n     if let Some(body) = body {\n@@ -430,7 +430,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                 for offset in 0..usize_bits {\n                     let bit = 1 << offset;\n                     if (word & bit) != 0 {\n-                        // NB: we round up the total number of bits\n+                        // N.B., we round up the total number of bits\n                         // that we store in any given bit set so that\n                         // it is an even multiple of usize::BITS.  This\n                         // means that there may be some stray bits at"}, {"sha": "b8954dee794f7bba2bdcbc60423d0763c44ba6b1", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -185,7 +185,7 @@ pub trait ArgTypeExt<'ll, 'tcx> {\n \n impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n     /// Get the LLVM type for a place of the original Rust type of\n-    /// this argument/return, i.e. the result of `type_of::type_of`.\n+    /// this argument/return, i.e., the result of `type_of::type_of`.\n     fn memory_ty(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type {\n         self.layout.llvm_type(cx)\n     }"}, {"sha": "ffe5e123f9b8b597e697aea2974618d0a038a334", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -71,7 +71,7 @@ pub fn set_optimize_for_size(val: &'ll Value, optimize: bool) {\n     Attribute::OptimizeForSize.toggle_llfn(Function, val, optimize);\n }\n \n-/// Tell LLVM if this function should be 'naked', i.e. skip the epilogue and prologue.\n+/// Tell LLVM if this function should be 'naked', i.e., skip the epilogue and prologue.\n #[inline]\n pub fn naked(val: &'ll Value, is_naked: bool) {\n     Attribute::Naked.toggle_llfn(Function, val, is_naked);\n@@ -147,7 +147,7 @@ pub fn non_lazy_bind(sess: &Session, llfn: &'ll Value) {\n     }\n }\n \n-/// Composite function which sets LLVM attributes for function depending on its AST (#[attribute])\n+/// Composite function which sets LLVM attributes for function depending on its AST (`#[attribute]`)\n /// attributes.\n pub fn from_fn_attrs(\n     cx: &CodegenCx<'ll, '_>,"}, {"sha": "9e100a1427fc4179fe4d729a14c30383b1e0eac7", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -994,7 +994,7 @@ fn link_args(cmd: &mut dyn Linker,\n     //\n     // The rationale behind this ordering is that those items lower down in the\n     // list can't depend on items higher up in the list. For example nothing can\n-    // depend on what we just generated (e.g. that'd be a circular dependency).\n+    // depend on what we just generated (e.g., that'd be a circular dependency).\n     // Upstream rust libraries are not allowed to depend on our local native\n     // libraries as that would violate the structure of the DAG, in that\n     // scenario they are required to link to them as well in a shared fashion.\n@@ -1003,7 +1003,7 @@ fn link_args(cmd: &mut dyn Linker,\n     // well, but they also can't depend on what we just started to add to the\n     // link line. And finally upstream native libraries can't depend on anything\n     // in this DAG so far because they're only dylibs and dylibs can only depend\n-    // on other dylibs (e.g. other native deps).\n+    // on other dylibs (e.g., other native deps).\n     add_local_native_libraries(cmd, sess, codegen_results);\n     add_upstream_rust_crates(cmd, sess, codegen_results, crate_type, tmpdir);\n     add_upstream_native_libraries(cmd, sess, codegen_results, crate_type);\n@@ -1205,7 +1205,7 @@ fn add_upstream_rust_crates(cmd: &mut dyn Linker,\n     // compiler-builtins are always placed last to ensure that they're\n     // linked correctly.\n     // We must always link the `compiler_builtins` crate statically. Even if it\n-    // was already \"included\" in a dylib (e.g. `libstd` when `-C prefer-dynamic`\n+    // was already \"included\" in a dylib (e.g., `libstd` when `-C prefer-dynamic`\n     // is used)\n     if let Some(cnum) = compiler_builtins {\n         add_static_crate(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n@@ -1385,7 +1385,7 @@ fn add_upstream_rust_crates(cmd: &mut dyn Linker,\n             // because a `dylib` can be reused as an intermediate artifact.\n             //\n             // Note, though, that we don't want to include the whole of a\n-            // compiler-builtins crate (e.g. compiler-rt) because it'll get\n+            // compiler-builtins crate (e.g., compiler-rt) because it'll get\n             // repeatedly linked anyway.\n             if crate_type == config::CrateType::Dylib &&\n                 codegen_results.crate_info.compiler_builtins != Some(cnum) {"}, {"sha": "78a3b6907a63d3ac9c06c25066c3feb8976a2272", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -782,7 +782,7 @@ fn create_msvc_imps(\n     }\n     // The x86 ABI seems to require that leading underscores are added to symbol\n     // names, so we need an extra underscore on 32-bit. There's also a leading\n-    // '\\x01' here which disables LLVM's symbol mangling (e.g. no extra\n+    // '\\x01' here which disables LLVM's symbol mangling (e.g., no extra\n     // underscores added in front).\n     let prefix = if cgcx.target_pointer_width == \"32\" {\n         \"\\x01__imp__\""}, {"sha": "55f286eb0beed0cdc72658f650fe22719f096e05", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -63,7 +63,7 @@ pub use context::CodegenCx;\n ///\n /// Each `Block` may contain an instance of this, indicating whether the block\n /// is part of a landing pad or not. This is used to make decision about whether\n-/// to emit `invoke` instructions (e.g. in a landing pad we don't continue to\n+/// to emit `invoke` instructions (e.g., in a landing pad we don't continue to\n /// use `invoke`) and also about various function call metadata.\n ///\n /// For GNU exceptions (`landingpad` + `resume` instructions) this structure is"}, {"sha": "086fb1f5a93ccc9f2407e63247d6c8f10e25426e", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -295,7 +295,7 @@ impl CodegenCx<'ll, 'tcx> {\n                             self.tcx.sess.opts.cg.prefer_dynamic));\n \n             if needs_dll_storage_attr {\n-                // This item is external but not foreign, i.e. it originates from an external Rust\n+                // This item is external but not foreign, i.e., it originates from an external Rust\n                 // crate. Since we don't know whether this crate will be linked dynamically or\n                 // statically in the final application, we always mark such symbols as 'dllimport'.\n                 // If final linkage happens to be static, we rely on compiler-emitted __imp_ stubs\n@@ -426,7 +426,7 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                 //\n                 // By default a global's alignment can be freely increased.\n                 // This allows LLVM to generate more performant instructions\n-                // e.g. using load-aligned into a SIMD register.\n+                // e.g., using load-aligned into a SIMD register.\n                 //\n                 // However, on macOS 10.10 or below, the dynamic linker does not\n                 // respect any alignment given on the TLS (radar 24221680)."}, {"sha": "6c90937de3f9baa897b9dd3d1adcd336d8474bc0", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -233,7 +233,7 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n         // they're not available to be linked against. This poses a few problems\n         // for the compiler, some of which are somewhat fundamental, but we use\n         // the `use_dll_storage_attrs` variable below to attach the `dllexport`\n-        // attribute to all LLVM functions that are exported e.g. they're\n+        // attribute to all LLVM functions that are exported e.g., they're\n         // already tagged with external linkage). This is suboptimal for a few\n         // reasons:\n         //"}, {"sha": "5e2476e0918ffaf9a8c474971970ad686ca4e593", "filename": "src/librustc_codegen_llvm/debuginfo/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fdoc.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -166,7 +166,7 @@\n //!\n //! (3) Tuple-, pointer and function types are structurally identified, which\n //!     means that they are equivalent if their component types are equivalent\n-//!     (i.e. (i32, i32) is the same regardless in which crate it is used).\n+//!     (i.e., (i32, i32) is the same regardless in which crate it is used).\n //!\n //! This algorithm also provides a stable ID for types that are defined in one\n //! crate but instantiated from metadata within another crate. We just have to"}, {"sha": "d263b4e1237808e6ebd59e2288b721cd49dd3f77", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -509,7 +509,7 @@ pub fn type_metadata(\n             },\n             None => {\n                 // The Ty is not in the TypeMap but maybe we have already seen\n-                // an equivalent type (e.g. only differing in region arguments).\n+                // an equivalent type (e.g., only differing in region arguments).\n                 // In order to find out, generate the unique type id and look\n                 // that up.\n                 let unique_type_id = type_map.get_unique_type_id_of_type(cx, t);"}, {"sha": "5b65b1fdda64eaa6fa747833d742d2b94941a812", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -488,7 +488,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                     );\n \n                     // Only \"class\" methods are generally understood by LLVM,\n-                    // so avoid methods on other types (e.g. `<*mut T>::null`).\n+                    // so avoid methods on other types (e.g., `<*mut T>::null`).\n                     match impl_self_ty.sty {\n                         ty::Adt(def, ..) if !def.is_box() => {\n                             Some(type_metadata(cx, impl_self_ty, syntax_pos::DUMMY_SP))"}, {"sha": "2e827cc6d0601f6e81b3a2aaee94e15dbae26442", "filename": "src/librustc_codegen_llvm/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -19,9 +19,9 @@ use rustc_codegen_ssa::traits::*;\n use rustc::hir;\n \n // Compute the name of the type as it should be stored in debuginfo. Does not do\n-// any caching, i.e. calling the function twice with the same type will also do\n+// any caching, i.e., calling the function twice with the same type will also do\n // the work twice. The `qualified` parameter only affects the first level of the\n-// type name, further levels (i.e. type parameters) are always fully qualified.\n+// type name, further levels (i.e., type parameters) are always fully qualified.\n pub fn compute_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                              t: Ty<'tcx>,\n                                              qualified: bool)"}, {"sha": "4b6ef30b1385c6261546d72ba117ccec77b7a9f4", "filename": "src/librustc_codegen_llvm/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -26,7 +26,7 @@ use syntax_pos::{self, Span};\n pub fn is_node_local_to_unit(cx: &CodegenCx, def_id: DefId) -> bool\n {\n     // The is_local_to_unit flag indicates whether a function is local to the\n-    // current compilation unit (i.e. if it is *static* in the C-sense). The\n+    // current compilation unit (i.e., if it is *static* in the C-sense). The\n     // *reachable* set should provide a good approximation of this, as it\n     // contains everything that might leak out of the current crate (by being\n     // externally visible or by being inlined into something externally"}, {"sha": "59608b119397624313a30fe7dc1228e6b83815e6", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -732,7 +732,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                             // We found a tuple that needs squishing! So\n                             // run over the tuple and load each field.\n                             //\n-                            // This assumes the type is \"simple\", i.e. no\n+                            // This assumes the type is \"simple\", i.e., no\n                             // destructors, and the contents are SIMD\n                             // etc.\n                             assert!(!bx.type_needs_drop(arg.layout.ty));\n@@ -997,7 +997,7 @@ fn codegen_msvc_try(\n }\n \n // Definition of the standard \"try\" function for Rust using the GNU-like model\n-// of exceptions (e.g. the normal semantics of LLVM's landingpad and invoke\n+// of exceptions (e.g., the normal semantics of LLVM's landingpad and invoke\n // instructions).\n //\n // This codegen is a little surprising because we always call a shim"}, {"sha": "3764c122dea29343083bfe9a125063c7da05ff60", "filename": "src/librustc_codegen_llvm/llvm/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -125,7 +125,7 @@ pub fn SetFunctionCallConv(fn_: &'a Value, cc: CallConv) {\n // example happen for generics when using multiple codegen units. This function simply uses the\n // value's name as the comdat value to make sure that it is in a 1-to-1 relationship to the\n // function.\n-// For more details on COMDAT sections see e.g. http://www.airs.com/blog/archives/52\n+// For more details on COMDAT sections see e.g., http://www.airs.com/blog/archives/52\n pub fn SetUniqueComdat(llmod: &Module, val: &'a Value) {\n     unsafe {\n         LLVMRustSetComdat(llmod, val, LLVMGetValueName(val));"}, {"sha": "1d5bcc4ba3986ea97c27b5107b9f381279a3deca", "filename": "src/librustc_codegen_llvm/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmono_item.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -63,7 +63,7 @@ impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             llvm::SetUniqueComdat(self.llmod, lldecl);\n         }\n \n-        // If we're compiling the compiler-builtins crate, e.g. the equivalent of\n+        // If we're compiling the compiler-builtins crate, e.g., the equivalent of\n         // compiler-rt, then we want to implicitly compile everything with hidden\n         // visibility as we're going to link this object all over the place but\n         // don't want the symbols to get exported."}, {"sha": "313ab1f974fdebff30c357620707ce8a33b05b3b", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -255,7 +255,7 @@ impl Type {\n         }\n     }\n \n-    // Creates an integer type with the given number of bits, e.g. i24\n+    // Creates an integer type with the given number of bits, e.g., i24\n     pub fn ix_llcx(\n         llcx: &llvm::Context,\n         num_bits: u64"}, {"sha": "52b560c6625405f3dab9d3af5af57a659f3adea2", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -15,8 +15,8 @@ use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n use rustc_target::abi::FloatTy;\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n-use type_::Type;\n use rustc_codegen_ssa::traits::*;\n+use type_::Type;\n \n use std::fmt::Write;\n \n@@ -84,10 +84,10 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             let packed = false;\n             match name {\n                 None => {\n-                    cx.type_struct( &[fill], packed)\n+                    cx.type_struct(&[fill], packed)\n                 }\n                 Some(ref name) => {\n-                    let llty = cx.type_named_struct( name);\n+                    let llty = cx.type_named_struct(name);\n                     cx.set_struct_body(llty, &[fill], packed);\n                     llty\n                 }\n@@ -236,7 +236,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         }\n     }\n \n-    /// Get the LLVM type corresponding to a Rust type, i.e. `rustc::ty::Ty`.\n+    /// Get the LLVM type corresponding to a Rust type, i.e., `rustc::ty::Ty`.\n     /// The pointee type of the pointer in `PlaceRef` is always this type.\n     /// For sized types, it is also the right LLVM type for an `alloca`\n     /// containing a value of that type, and most immediates (except `bool`).\n@@ -470,9 +470,9 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                         // (according to its type), or null (which the\n                         // niche field's scalar validity range encodes).\n                         // This allows using `dereferenceable_or_null`\n-                        // for e.g. `Option<&T>`, and this will continue\n+                        // for e.g., `Option<&T>`, and this will continue\n                         // to work as long as we don't start using more\n-                        // niches than just null (e.g. the first page\n+                        // niches than just null (e.g., the first page\n                         // of the address space, or unaligned pointers).\n                         if self.fields.offset(0) == offset {\n                             Some(self.for_variant(cx, dataful_variant))"}, {"sha": "2f92c427f657cdde4595a81427ae1fb829068a2c", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -107,7 +107,7 @@ impl LinkerInfo {\n /// This trait is the total list of requirements needed by `back::link` and\n /// represents the meaning of each option being passed down. This trait is then\n /// used to dispatch on whether a GNU-like linker (generally `ld.exe`) or an\n-/// MSVC linker (e.g. `link.exe`) is being used.\n+/// MSVC linker (e.g., `link.exe`) is being used.\n pub trait Linker {\n     fn link_dylib(&mut self, lib: &str);\n     fn link_rust_dylib(&mut self, lib: &str, path: &Path);"}, {"sha": "a17a00ddb29ff7470aeb755a0133b6328e293303", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -85,7 +85,7 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // categories:\n             //\n             // 1. Those that are included statically via a static library\n-            // 2. Those included otherwise (e.g. dynamically or via a framework)\n+            // 2. Those included otherwise (e.g., dynamically or via a framework)\n             //\n             // Although our LLVM module is not literally emitting code for the\n             // statically included symbols, it's an export of our library which"}, {"sha": "8a5b8bd2babbbc439919941aba86d3ee4770414a", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -268,7 +268,7 @@ pub fn coerce_unsized_into<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n         let (base, info) = match bx.load_operand(src).val {\n             OperandValue::Pair(base, info) => {\n                 // fat-ptr to fat-ptr unsize preserves the vtable\n-                // i.e. &'a fmt::Debug+Send => &'a fmt::Debug\n+                // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n                 // So we need to pointercast the base to ensure\n                 // the types match up.\n                 let thin_ptr = dst.layout.field(bx.cx(), FAT_PTR_ADDR);"}, {"sha": "70b7729b78b40d11323ce86e61233e5abe6005e8", "filename": "src/librustc_codegen_ssa/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcommon.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -158,7 +158,7 @@ pub fn langcall(tcx: TyCtxt,\n }\n \n // To avoid UB from LLVM, these two functions mask RHS with an\n-// appropriate mask unconditionally (i.e. the fallback behavior for\n+// appropriate mask unconditionally (i.e., the fallback behavior for\n // all shifts). For 32- and 64-bit types, this matches the semantics\n // of Java. (See related discussion on #1877 and #10183.)\n "}, {"sha": "d0cdb8924dfffcfea7bc63bbb1352c378500a14e", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -61,7 +61,7 @@ use rustc_data_structures::svh::Svh;\n use rustc::middle::cstore::{LibSource, CrateSource, NativeLibrary};\n use syntax_pos::symbol::Symbol;\n \n-// NB: This module needs to be declared first so diagnostics are\n+// N.B., this module needs to be declared first so diagnostics are\n // registered before they are used.\n mod diagnostics;\n "}, {"sha": "81da7f5fb5cac041992bb0d93e56647ef47be451", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -43,7 +43,7 @@ pub fn non_ssa_locals<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n             // These sorts of types require an alloca. Note that\n             // is_llvm_immediate() may *still* be true, particularly\n             // for newtypes, but we currently force some types\n-            // (e.g. structs) into an alloca unconditionally, just so\n+            // (e.g., structs) into an alloca unconditionally, just so\n             // that we don't have to deal with having two pathways\n             // (gep vs extractvalue etc).\n             analyzer.not_ssa(mir::Local::new(index));\n@@ -227,9 +227,9 @@ impl<'mir, 'a: 'mir, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n \n             PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n             PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) => {\n-                // Reads from uninitialized variables (e.g. in dead code, after\n+                // Reads from uninitialized variables (e.g., in dead code, after\n                 // optimizations) require locals to be in (uninitialized) memory.\n-                // NB: there can be uninitialized reads of a local visited after\n+                // N.B., there can be uninitialized reads of a local visited after\n                 // an assignment to that local, if they happen on disjoint paths.\n                 let ssa_read = match self.first_assignment(local) {\n                     Some(assignment_location) => {"}, {"sha": "750de1c660cf347c3d411c724a4e3f8993be6e68", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -467,7 +467,7 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n         };\n \n         if Some(local) == mir.spread_arg {\n-            // This argument (e.g. the last argument in the \"rust-call\" ABI)\n+            // This argument (e.g., the last argument in the \"rust-call\" ABI)\n             // is a tuple that was spread at the ABI level and now we have\n             // to reconstruct it into a tuple local variable, from multiple\n             // individual LLVM function arguments.\n@@ -614,7 +614,7 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n             // because that's what the llvm.dbg.declare intrinsic expects.\n \n             // FIXME(eddyb) this shouldn't be necessary but SROA seems to\n-            // mishandle DW_OP_plus not preceded by DW_OP_deref, i.e. it\n+            // mishandle DW_OP_plus not preceded by DW_OP_deref, i.e., it\n             // doesn't actually strip the offset when splitting the closure\n             // environment into its components so it ends up out of bounds.\n             // (cuviper) It seems to be fine without the alloca on LLVM 6 and later."}, {"sha": "90aa9f6cbc763c7269502a938ae5d0ee8aece15e", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -229,9 +229,9 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n             layout::Variants::Tagged { ref tag, .. } => {\n                 let signed = match tag.value {\n                     // We use `i1` for bytes that are always `0` or `1`,\n-                    // e.g. `#[repr(i8)] enum E { A, B }`, but we can't\n+                    // e.g., `#[repr(i8)] enum E { A, B }`, but we can't\n                     // let LLVM interpret the `i1` as signed, because\n-                    // then `i1 1` (i.e. E::B) is effectively `i8 -1`.\n+                    // then `i1 1` (i.e., E::B) is effectively `i8 -1`.\n                     layout::Int(_, signed) => !tag.is_bool() && signed,\n                     _ => false\n                 };"}, {"sha": "c932ffd1c1bdab27489ad1445e0fff4672026def", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -319,9 +319,9 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         if let layout::Abi::Scalar(ref scalar) = operand.layout.abi {\n                             if let layout::Int(_, s) = scalar.value {\n                                 // We use `i1` for bytes that are always `0` or `1`,\n-                                // e.g. `#[repr(i8)] enum E { A, B }`, but we can't\n+                                // e.g., `#[repr(i8)] enum E { A, B }`, but we can't\n                                 // let LLVM interpret the `i1` as signed, because\n-                                // then `i1 1` (i.e. E::B) is effectively `i8 -1`.\n+                                // then `i1 1` (i.e., E::B) is effectively `i8 -1`.\n                                 signed = !scalar.is_bool() && s;\n \n                                 let er = scalar.valid_range_exclusive(bx.cx());"}, {"sha": "611e5f758a7811ceeaadf86ad29a96e275bdb036", "filename": "src/librustc_codegen_ssa/traits/declare.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -41,7 +41,7 @@ pub trait DeclareMethods<'tcx>: BackendTypes {\n     /// Use this function when you intend to define a global. This function will\n     /// return None if the name already has a definition associated with it. In that\n     /// case an error should be reported to the user, because it usually happens due\n-    /// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n+    /// to user\u2019s fault (e.g., misuse of #[no_mangle] or #[export_name] attributes).\n     fn define_global(&self, name: &str, ty: Self::Type) -> Option<Self::Value>;\n \n     /// Declare a private global"}, {"sha": "ed53c8fffa7aa1ad41c4650ab8d5e72a8823c8eb", "filename": "src/librustc_codegen_ssa/traits/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -32,7 +32,7 @@ pub trait BaseTypeMethods<'tcx>: Backend<'tcx> {\n     fn type_i64(&self) -> Self::Type;\n     fn type_i128(&self) -> Self::Type;\n \n-    // Creates an integer type with the given number of bits, e.g. i24\n+    // Creates an integer type with the given number of bits, e.g., i24\n     fn type_ix(&self, num_bits: u64) -> Self::Type;\n     fn type_isize(&self) -> Self::Type;\n "}, {"sha": "d5b95e77b1a8aa437ab18c46d70493cbd42e23ed", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -71,7 +71,7 @@\n //! order to also avoid inter-crate conflicts two more measures are taken:\n //!\n //! - The name of the crate containing the symbol is prepended to the symbol\n-//!   name, i.e. symbols are \"crate qualified\". For example, a function `foo` in\n+//!   name, i.e., symbols are \"crate qualified\". For example, a function `foo` in\n //!   module `bar` in crate `baz` would get a symbol name like\n //!   `baz::bar::foo::{hash}` instead of just `bar::foo::{hash}`. This avoids\n //!   simple conflicts between functions from different crates."}, {"sha": "2a1958357e0e6d54393f056a5c6fe4568109ee73", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -531,7 +531,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n     /// indices. Cannot be used during a transaction.\n     ///\n     /// Beforehand, all nodes must be marked as `Done` and no cycles\n-    /// on these nodes may be present. This is done by e.g. `process_cycles`.\n+    /// on these nodes may be present. This is done by e.g., `process_cycles`.\n     #[inline(never)]\n     fn compress(&mut self, do_completed: DoCompleted) -> Option<Vec<O>> {\n         let nodes_len = self.nodes.len();"}, {"sha": "0b126e5c572ed8453431e9f47875e5aff556c8c9", "filename": "src/librustc_data_structures/owning_ref/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -215,7 +215,7 @@ fn main() {\n ## Mutable reference\n \n When the owned container implements `DerefMut`, it is also possible to make\n-a _mutable owning reference_. (E.g. with `Box`, `RefMut`, `MutexGuard`)\n+a _mutable owning reference_. (e.g., with `Box`, `RefMut`, `MutexGuard`)\n \n ```\n extern crate owning_ref;\n@@ -452,7 +452,7 @@ impl<O, T: ?Sized> OwningRef<O, T> {\n     /// use owning_ref::{OwningRef, Erased};\n     ///\n     /// fn main() {\n-    ///     // NB: Using the concrete types here for explicitness.\n+    ///     // N.B., using the concrete types here for explicitness.\n     ///     // For less verbose code type aliases like `BoxRef` are provided.\n     ///\n     ///     let owning_ref_a: OwningRef<Box<[i32; 4]>, [i32; 4]>\n@@ -722,7 +722,7 @@ impl<O, T: ?Sized> OwningRefMut<O, T> {\n     /// use owning_ref::{OwningRefMut, Erased};\n     ///\n     /// fn main() {\n-    ///     // NB: Using the concrete types here for explicitness.\n+    ///     // N.B., using the concrete types here for explicitness.\n     ///     // For less verbose code type aliases like `BoxRef` are provided.\n     ///\n     ///     let owning_ref_mut_a: OwningRefMut<Box<[i32; 4]>, [i32; 4]>\n@@ -1124,8 +1124,8 @@ impl<T: 'static> ToHandleMut for RefCell<T> {\n     unsafe fn to_handle_mut(x: *const Self) -> Self::HandleMut { (*x).borrow_mut() }\n }\n \n-// NB: Implementing ToHandle{,Mut} for Mutex and RwLock requires a decision\n-// about which handle creation to use (i.e. read() vs try_read()) as well as\n+// N.B., implementing ToHandle{,Mut} for Mutex and RwLock requires a decision\n+// about which handle creation to use (i.e., read() vs try_read()) as well as\n // what to do with error results.\n \n /// Typedef of a owning reference that uses a `Box` as the owner."}, {"sha": "5b7ea161b289778a2cec70770add3b33594ae7c3", "filename": "src/librustc_data_structures/thin_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_data_structures%2Fthin_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_data_structures%2Fthin_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fthin_vec.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// A vector type optimized for cases where this size is usually 0 (c.f. `SmallVector`).\n+/// A vector type optimized for cases where this size is usually 0 (cf. `SmallVector`).\n /// The `Option<Box<..>>` wrapping allows us to represent a zero sized vector with `None`,\n /// which uses only a single (null) pointer.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]"}, {"sha": "250dad8136e1434530bded1693115018a26be72b", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -304,7 +304,7 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n     ///\n     /// The intuition is that this moves \"one step up\" through a lattice\n     /// (where the relation is encoding the `<=` relation for the lattice).\n-    /// So e.g. if the relation is `->` and we have\n+    /// So e.g., if the relation is `->` and we have\n     ///\n     /// ```\n     /// a -> b -> d -> f"}, {"sha": "f2edcdc1bac35de2311d6194729609bbde1eaf88", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -9,36 +9,47 @@\n // except according to those terms.\n \n use rustc::dep_graph::DepGraph;\n-use rustc::hir::{self, map as hir_map};\n+use rustc::hir;\n use rustc::hir::lowering::lower_crate;\n-use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::stable_hasher::StableHasher;\n-use rustc_mir as mir;\n-use rustc::session::{CompileResult, CrateDisambiguator, Session};\n-use rustc::session::CompileIncomplete;\n-use rustc::session::config::{self, Input, OutputFilenames, OutputType};\n-use rustc::session::search_paths::PathKind;\n+use rustc::hir::map as hir_map;\n use rustc::lint;\n use rustc::middle::{self, reachable, resolve_lifetime, stability};\n use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, AllArenas, Resolutions, TyCtxt};\n use rustc::traits;\n use rustc::util::common::{install_panic_hook, time, ErrorReported};\n use rustc::util::profiling::ProfileCategory;\n+use rustc::session::{CompileResult, CrateDisambiguator, Session};\n+use rustc::session::CompileIncomplete;\n+use rustc::session::config::{self, Input, OutputFilenames, OutputType};\n+use rustc::session::search_paths::PathKind;\n use rustc_allocator as allocator;\n use rustc_borrowck as borrowck;\n+use rustc_codegen_utils::codegen_backend::CodegenBackend;\n+use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::stable_hasher::StableHasher;\n+use rustc_data_structures::sync::{self, Lrc, Lock};\n use rustc_incremental;\n-use rustc_resolve::{MakeGlobMap, Resolver, ResolverArenas};\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::{self, CStore};\n+use rustc_mir as mir;\n+use rustc_passes::{self, ast_validation, hir_stats, loops, rvalue_promotion};\n+use rustc_plugin as plugin;\n+use rustc_plugin::registry::Registry;\n+use rustc_privacy;\n+use rustc_resolve::{MakeGlobMap, Resolver, ResolverArenas};\n use rustc_traits;\n-use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_typeck as typeck;\n-use rustc_privacy;\n-use rustc_plugin::registry::Registry;\n-use rustc_plugin as plugin;\n-use rustc_passes::{self, ast_validation, hir_stats, loops, rvalue_promotion};\n-use super::Compilation;\n+use syntax::{self, ast, attr, diagnostics, visit};\n+use syntax::early_buffered_lints::BufferedEarlyLint;\n+use syntax::ext::base::ExtCtxt;\n+use syntax::fold::Folder;\n+use syntax::parse::{self, PResult};\n+use syntax::util::node_count::NodeCounter;\n+use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax::symbol::Symbol;\n+use syntax_pos::{FileName, hygiene};\n+use syntax_ext;\n \n use serialize::json;\n \n@@ -49,23 +60,12 @@ use std::fs;\n use std::io::{self, Write};\n use std::iter;\n use std::path::{Path, PathBuf};\n-use rustc_data_structures::sync::{self, Lrc, Lock};\n use std::sync::mpsc;\n-use syntax::{self, ast, attr, diagnostics, visit};\n-use syntax::early_buffered_lints::BufferedEarlyLint;\n-use syntax::ext::base::ExtCtxt;\n-use syntax::fold::Folder;\n-use syntax::parse::{self, PResult};\n-use syntax::util::node_count::NodeCounter;\n-use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax::symbol::Symbol;\n-use syntax_pos::{FileName, hygiene};\n-use syntax_ext;\n \n-use proc_macro_decls;\n use pretty::ReplaceBodyWithLoop;\n-\n+use proc_macro_decls;\n use profile;\n+use super::Compilation;\n \n #[cfg(not(parallel_queries))]\n pub fn spawn_thread_pool<F: FnOnce(config::Options) -> R + sync::Send, R: sync::Send>("}, {"sha": "b41b0d081ced978b8368c9c4be0bf0b3c61617dd", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -8,25 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! The various pretty print routines.\n+//! The various pretty-printing routines.\n \n-pub use self::UserIdentifiedItem::*;\n-pub use self::PpSourceMode::*;\n-pub use self::PpMode::*;\n-use self::NodesMatchingUII::*;\n-\n-use {abort_on_err, driver};\n-\n-use rustc::ty::{self, TyCtxt, Resolutions, AllArenas};\n use rustc::cfg;\n use rustc::cfg::graphviz::LabelledCFG;\n+use rustc::hir;\n+use rustc::hir::map as hir_map;\n+use rustc::hir::map::blocks;\n+use rustc::hir::print as pprust_hir;\n use rustc::session::Session;\n use rustc::session::config::{Input, OutputFilenames};\n+use rustc::ty::{self, TyCtxt, Resolutions, AllArenas};\n use rustc_borrowck as borrowck;\n use rustc_borrowck::graphviz as borrowck_dot;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_metadata::cstore::CStore;\n-\n use rustc_mir::util::{write_mir_pretty, write_mir_graphviz};\n \n use syntax::ast::{self, BlockCheckMode};\n@@ -47,10 +43,11 @@ use std::path::Path;\n use std::str::FromStr;\n use std::mem;\n \n-use rustc::hir::map as hir_map;\n-use rustc::hir::map::blocks;\n-use rustc::hir;\n-use rustc::hir::print as pprust_hir;\n+pub use self::UserIdentifiedItem::*;\n+pub use self::PpSourceMode::*;\n+pub use self::PpMode::*;\n+use self::NodesMatchingUII::*;\n+use {abort_on_err, driver};\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum PpSourceMode {"}, {"sha": "f9d49f03ee044ff2ed31e6f6814c9b639e3e6954", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -10,13 +10,11 @@\n \n //! # Standalone Tests for the Inference Module\n \n-use std::path::PathBuf;\n-use std::sync::mpsc;\n-\n use driver;\n use errors;\n use errors::emitter::Emitter;\n use errors::{DiagnosticBuilder, Level};\n+use rustc::hir;\n use rustc::hir::map as hir_map;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::infer::type_variable::TypeVariableOrigin;\n@@ -40,7 +38,8 @@ use syntax::source_map::{FileName, FilePathMapping, SourceMap};\n use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;\n \n-use rustc::hir;\n+use std::path::PathBuf;\n+use std::sync::mpsc;\n \n struct Env<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a infer::InferCtxt<'a, 'gcx, 'tcx>,\n@@ -155,7 +154,7 @@ fn test_env_with_pool<F>(\n     let arenas = ty::AllArenas::new();\n     let hir_map = hir_map::map_crate(&sess, &cstore, &mut hir_forest, &defs);\n \n-    // run just enough stuff to build a tcx:\n+    // Run just enough stuff to build a tcx.\n     let (tx, _rx) = mpsc::channel();\n     let outputs = OutputFilenames {\n         out_directory: PathBuf::new(),\n@@ -228,8 +227,8 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn create_simple_region_hierarchy(&mut self) {\n-        // creates a region hierarchy where 1 is root, 10 and 11 are\n-        // children of 1, etc\n+        // Creates a region hierarchy where 1 is root, 10 and 11 are\n+        // children of 1, etc.\n \n         let dscope = region::Scope {\n             id: hir::ItemLocalId::from_u32(1),\n@@ -434,7 +433,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n                 obligations,\n                 value: (),\n             }) => {\n-                // None of these tests should require nested obligations:\n+                // None of these tests should require nested obligations.\n                 assert!(obligations.is_empty());\n             }\n             Err(ref e) => {\n@@ -476,7 +475,7 @@ fn contravariant_region_ptr_err() {\n         env.assert_eq(t_rptr1, t_rptr1);\n         env.assert_eq(t_rptr10, t_rptr10);\n \n-        // will cause an error when regions are resolved\n+        // This will cause an error when regions are resolved.\n         env.make_subtype(t_rptr10, t_rptr1);\n     })\n }\n@@ -487,7 +486,7 @@ fn sub_free_bound_false() {\n     //!\n     //!     fn(&'a isize) <: for<'b> fn(&'b isize)\n     //!\n-    //! does NOT hold.\n+    //! *does not* hold.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         env.create_simple_region_hierarchy();\n@@ -506,7 +505,7 @@ fn sub_bound_free_true() {\n     //!\n     //!     for<'a> fn(&'a isize) <: fn(&'b isize)\n     //!\n-    //! DOES hold.\n+    //! *does* hold.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         env.create_simple_region_hierarchy();\n@@ -578,11 +577,11 @@ fn subst_ty_renumber_bound() {\n fn subst_ty_renumber_some_bounds() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         // Situation:\n-        // Theta = [A -> &'a foo]\n+        // `Theta = [A -> &'a foo]`\n \n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n \n-        // t_source = (A, fn(A))\n+        // `t_source = (A, fn(A))`\n         let t_source = {\n             let t_param = env.t_param(0);\n             env.t_pair(t_param, env.t_fn(&[t_param], env.t_nil()))\n@@ -591,9 +590,9 @@ fn subst_ty_renumber_some_bounds() {\n         let substs = env.infcx.tcx.intern_substs(&[t_rptr_bound1.into()]);\n         let t_substituted = t_source.subst(env.infcx.tcx, substs);\n \n-        // t_expected = (&'a isize, fn(&'a isize))\n+        // `t_expected = (&'a isize, fn(&'a isize))`\n         //\n-        // but not that the Debruijn index is different in the different cases.\n+        // However, note that the Debruijn index is different in the different cases.\n         let t_expected = {\n             let t_rptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, d2());\n             env.t_pair(t_rptr_bound1, env.t_fn(&[t_rptr_bound2], env.t_nil()))\n@@ -613,7 +612,7 @@ fn subst_ty_renumber_some_bounds() {\n fn escaping() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         // Situation:\n-        // Theta = [A -> &'a foo]\n+        // `Theta = [A -> &'a foo]`\n         env.create_simple_region_hierarchy();\n \n         assert!(!env.t_nil().has_escaping_bound_vars());\n@@ -627,7 +626,7 @@ fn escaping() {\n         let t_rptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, d2());\n         assert!(t_rptr_bound2.has_escaping_bound_vars());\n \n-        // t_fn = fn(A)\n+        // `t_fn = fn(A)`\n         let t_param = env.t_param(0);\n         assert!(!t_param.has_escaping_bound_vars());\n         let t_fn = env.t_fn(&[t_param], env.t_nil());\n@@ -642,7 +641,7 @@ fn subst_region_renumber_region() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let re_bound1 = env.re_late_bound_with_debruijn(1, d1());\n \n-        // type t_source<'a> = fn(&'a isize)\n+        // `type t_source<'a> = fn(&'a isize)`\n         let t_source = {\n             let re_early = env.re_early_bound(0, \"'a\");\n             env.t_fn(&[env.t_rptr(re_early)], env.t_nil())\n@@ -651,7 +650,7 @@ fn subst_region_renumber_region() {\n         let substs = env.infcx.tcx.intern_substs(&[re_bound1.into()]);\n         let t_substituted = t_source.subst(env.infcx.tcx, substs);\n \n-        // t_expected = fn(&'a isize)\n+        // `t_expected = fn(&'a isize)`\n         //\n         // but not that the Debruijn index is different in the different cases.\n         let t_expected = {"}, {"sha": "e17663c41e5944385df819fb2febf94ef94977bc", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -78,7 +78,7 @@ const BASE_IMPL: &[&str] = &[\n ];\n \n /// DepNodes for MirValidated/Optimized, which is relevant in \"executable\"\n-/// code, i.e. functions+methods\n+/// code, i.e., functions+methods\n const BASE_MIR: &[&str] = &[\n     label_strs::MirOptimized,\n     label_strs::MirValidated,\n@@ -364,16 +364,16 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n                     // Module-level inline assembly (from global_asm!)\n                     HirItem::GlobalAsm(..) => (\"ItemGlobalAsm\", LABELS_HIR_ONLY),\n \n-                    // A type alias, e.g. `type Foo = Bar<u8>`\n+                    // A type alias, e.g., `type Foo = Bar<u8>`\n                     HirItem::Ty(..) => (\"ItemTy\", LABELS_HIR_ONLY),\n \n-                    // An enum definition, e.g. `enum Foo<A, B> {C<A>, D<B>}`\n+                    // An enum definition, e.g., `enum Foo<A, B> {C<A>, D<B>}`\n                     HirItem::Enum(..) => (\"ItemEnum\", LABELS_ADT),\n \n-                    // A struct definition, e.g. `struct Foo<A> {x: A}`\n+                    // A struct definition, e.g., `struct Foo<A> {x: A}`\n                     HirItem::Struct(..) => (\"ItemStruct\", LABELS_ADT),\n \n-                    // A union definition, e.g. `union Foo<A, B> {x: A, y: B}`\n+                    // A union definition, e.g., `union Foo<A, B> {x: A, y: B}`\n                     HirItem::Union(..) => (\"ItemUnion\", LABELS_ADT),\n \n                     // Represents a Trait Declaration"}, {"sha": "e0e790e9f2302240d5264de111bde89ae350f9cd", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -1573,7 +1573,7 @@ impl EarlyLintPass for KeywordIdents {\n                 }\n             }\n \n-            // no new keywords yet for 2018 edition and beyond\n+            // There are no new keywords yet for the 2018 edition and beyond.\n             // However, `await` is a \"false\" keyword in the 2018 edition,\n             // and can only be used if the `async_await` feature is enabled.\n             // Otherwise, we emit an error."}, {"sha": "b1e44ea761c8664e4d2d1c72b36328ac4988b78e", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Lints in the Rust compiler.\n+//! # Lints in the Rust compiler\n //!\n //! This currently only contains the definitions and implementations\n //! of most of the lints that `rustc` supports directly, it does not\n //! contain the infrastructure for defining/registering lints. That is\n //! available in `rustc::lint` and `rustc_plugin` respectively.\n //!\n-//! # Note\n+//! ## Note\n //!\n //! This API is completely unstable and subject to change.\n \n@@ -40,6 +40,12 @@ extern crate rustc_target;\n extern crate syntax_pos;\n extern crate rustc_data_structures;\n \n+mod diagnostics;\n+mod nonstandard_style;\n+pub mod builtin;\n+mod types;\n+mod unused;\n+\n use rustc::lint;\n use rustc::lint::{LateContext, LateLintPass, LintPass, LintArray};\n use rustc::lint::builtin::{\n@@ -54,19 +60,13 @@ use rustc::util;\n use rustc::hir;\n \n use syntax::ast;\n+use syntax::edition::Edition;\n use syntax_pos::Span;\n \n use session::Session;\n-use syntax::edition::Edition;\n use lint::LintId;\n use lint::FutureIncompatibleInfo;\n \n-mod diagnostics;\n-mod nonstandard_style;\n-pub mod builtin;\n-mod types;\n-mod unused;\n-\n use nonstandard_style::*;\n use builtin::*;\n use types::*;\n@@ -212,8 +212,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n     //   and include the full URL, sort items in ascending order of issue numbers.\n     // - Later, change lint to error\n     // - Eventually, remove lint\n-    store.register_future_incompatible(sess,\n-                                       vec![\n+    store.register_future_incompatible(sess, vec![\n         FutureIncompatibleInfo {\n             id: LintId::of(PRIVATE_IN_PUBLIC),\n             reference: \"issue #34537 <https://github.com/rust-lang/rust/issues/34537>\",\n@@ -333,7 +332,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n         },\n         ]);\n \n-    // Register renamed and removed lints\n+    // Register renamed and removed lints.\n     store.register_renamed(\"single_use_lifetime\", \"single_use_lifetimes\");\n     store.register_renamed(\"elided_lifetime_in_path\", \"elided_lifetimes_in_paths\");\n     store.register_renamed(\"bare_trait_object\", \"bare_trait_objects\");\n@@ -344,10 +343,10 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n     store.register_removed(\"unsigned_negation\", \"replaced by negate_unsigned feature gate\");\n     store.register_removed(\"negate_unsigned\", \"cast a signed value instead\");\n     store.register_removed(\"raw_pointer_derive\", \"using derive with raw pointers is ok\");\n-    // Register lint group aliases\n+    // Register lint group aliases.\n     store.register_group_alias(\"nonstandard_style\", \"bad_style\");\n-    // This was renamed to raw_pointer_derive, which was then removed,\n-    // so it is also considered removed\n+    // This was renamed to `raw_pointer_derive`, which was then removed,\n+    // so it is also considered removed.\n     store.register_removed(\"raw_pointer_deriving\", \"using derive with raw pointers is ok\");\n     store.register_removed(\"drop_with_repr_extern\", \"drop flags have been removed\");\n     store.register_removed(\"fat_ptr_transmutes\", \"was accidentally removed back in 2014\");"}, {"sha": "13be50ef01f62433e02f1be394e2658646d9b85f", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -8,19 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc::hir::{self, GenericParamKind, PatKind};\n use rustc::hir::def::Def;\n+use rustc::hir::intravisit::FnKind;\n use rustc::ty;\n+use rustc_target::spec::abi::Abi;\n use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass};\n-\n-use rustc_target::spec::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n use syntax_pos::Span;\n \n-use rustc::hir::{self, GenericParamKind, PatKind};\n-use rustc::hir::intravisit::FnKind;\n-\n #[derive(PartialEq)]\n pub enum MethodLateContext {\n     TraitAutoImpl,"}, {"sha": "10f35e5598b2bb5f72650479f31aea1d8e61b922", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -22,7 +22,7 @@ extern crate rustc_cratesio_shim;\n // NOTE: This crate only exists to allow linking on mingw targets.\n \n /// Initialize targets enabled by the build script via `cfg(llvm_component = \"...\")`.\n-/// NB: this function can't be moved to `rustc_codegen_llvm` because of the `cfg`s.\n+/// N.B., this function can't be moved to `rustc_codegen_llvm` because of the `cfg`s.\n pub fn initialize_available_targets() {\n     macro_rules! init_target(\n         ($cfg:meta, $($method:ident),*) => { {"}, {"sha": "f650db5aafa01c2ade13f7fa3b6b108eba96c048", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -56,7 +56,7 @@ pub struct CrateMetadata {\n     /// Original name of the crate.\n     pub name: Symbol,\n \n-    /// Name of the crate as imported.  I.e. if imported with\n+    /// Name of the crate as imported.  I.e., if imported with\n     /// `extern crate foo as bar;` this will be `bar`.\n     pub imported_name: Symbol,\n "}, {"sha": "da2ba392c5eb1f48283191b044bac7317cf24cb4", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -307,7 +307,7 @@ pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n             Lrc::new(link_args::collect(tcx))\n         },\n \n-        // Returns a map from a sufficiently visible external item (i.e. an\n+        // Returns a map from a sufficiently visible external item (i.e., an\n         // external item that is visible from at least one local module) to a\n         // sufficiently visible parent (considering modules that re-export the\n         // external item to be parents)."}, {"sha": "1f298f6d2d3a5502b5f2893bb0ec88c3d2789b65", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -661,7 +661,7 @@ impl<'a> Context<'a> {\n             // Ok so at this point we've determined that `(lib, kind)` above is\n             // a candidate crate to load, and that `slot` is either none (this\n             // is the first crate of its kind) or if some the previous path has\n-            // the exact same hash (e.g. it's the exact same crate).\n+            // the exact same hash (e.g., it's the exact same crate).\n             //\n             // In principle these two candidate crates are exactly the same so\n             // we can choose either of them to link. As a stupidly gross hack,"}, {"sha": "1ae3f0a12bdd0ae912a66ab9b9087001eac722e1", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -40,7 +40,7 @@ pub fn rustc_version() -> String {\n }\n \n /// Metadata encoding version.\n-/// NB: increment this if you change the format of metadata such that\n+/// N.B., increment this if you change the format of metadata such that\n /// the rustc version can't be found to compare with `rustc_version()`.\n pub const METADATA_VERSION: u8 = 4;\n "}, {"sha": "598c2f810beb76958c76a5ffe1180240e7cdd046", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -1249,7 +1249,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// (part of) a non-`mut` local that occurs potentially after that\n     /// local has already been initialized. `place` is the path being\n     /// assigned; `err_place` is a place providing a reason why\n-    /// `place` is not mutable (e.g. the non-`mut` local `x` in an\n+    /// `place` is not mutable (e.g., the non-`mut` local `x` in an\n     /// assignment to `x.f`).\n     pub(super) fn report_illegal_reassignment(\n         &mut self,"}, {"sha": "e3029c6a19d499d057268af5c690546fcf731554", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -1526,7 +1526,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n               // ancestors; dataflow recurs on children when parents\n               // move (to support partial (re)inits).\n               //\n-              // (I.e. querying parents breaks scenario 7; but may want\n+              // (I.e., querying parents breaks scenario 7; but may want\n               // to do such a query based on partial-init feature-gate.)\n         }\n     }\n@@ -1562,7 +1562,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         //\n         // (Distinct from handling of scenarios 1+2+4 above because\n         // `place` does not interfere with suffixes of its prefixes,\n-        // e.g. `a.b.c` does not interfere with `a.b.d`)\n+        // e.g., `a.b.c` does not interfere with `a.b.d`)\n         //\n         // This code covers scenario 1.\n \n@@ -1735,7 +1735,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             //\n             // This does not use check_if_path_or_subpath_is_moved,\n             // because we want to *allow* reinitializations of fields:\n-            // e.g. want to allow\n+            // e.g., want to allow\n             //\n             // `let mut s = ...; drop(s.x); s.x=Val;`\n             //\n@@ -2166,7 +2166,7 @@ enum Overlap {\n     /// `u.a.x` and `a.b.y` are.\n     Arbitrary,\n     /// The places have the same type, and are either completely disjoint\n-    /// or equal - i.e. they can't \"partially\" overlap as can occur with\n+    /// or equal - i.e., they can't \"partially\" overlap as can occur with\n     /// unions. This is the \"base case\" on which we recur for extensions\n     /// of the place.\n     EqualOrDisjoint,"}, {"sha": "db60017185a95319e45a5da3f351fa817eb100f2", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -40,7 +40,7 @@ use util::borrowck_errors::{BorrowckErrors, Origin};\n #[derive(Debug)]\n enum GroupedMoveError<'tcx> {\n     // Place expression can't be moved from,\n-    // e.g. match x[0] { s => (), } where x: &[String]\n+    // e.g., match x[0] { s => (), } where x: &[String]\n     MovesFromPlace {\n         original_path: Place<'tcx>,\n         span: Span,\n@@ -49,7 +49,7 @@ enum GroupedMoveError<'tcx> {\n         binds_to: Vec<Local>,\n     },\n     // Part of a value expression can't be moved from,\n-    // e.g. match &String::new() { &x => (), }\n+    // e.g., match &String::new() { &x => (), }\n     MovesFromValue {\n         original_path: Place<'tcx>,\n         span: Span,"}, {"sha": "bfac33b34c7dccd942cfb3955494906002c9b983", "filename": "src/librustc_mir/borrow_check/nll/constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -40,7 +40,7 @@ impl ConstraintSet {\n     /// Constructs a \"normal\" graph from the constraint set; the graph makes it\n     /// easy to find the constraints affecting a particular region.\n     ///\n-    /// NB: This graph contains a \"frozen\" view of the current\n+    /// N.B., this graph contains a \"frozen\" view of the current\n     /// constraints.  any new constraints added to the `ConstraintSet`\n     /// after the graph is built will not be present in the graph.\n     crate fn graph(&self, num_region_vars: usize) -> graph::NormalConstraintGraph {"}, {"sha": "0c0504b7b316de94c7fac6a4889b758af9c00662", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/var_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -95,7 +95,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Search the argument types for one that references fr (which should be a free region).\n     /// Returns Some(_) with the index of the input if one is found.\n     ///\n-    /// NB: In the case of a closure, the index is indexing into the signature as seen by the\n+    /// N.B., in the case of a closure, the index is indexing into the signature as seen by the\n     /// user - in particular, index 0 is not the implicit self parameter.\n     crate fn get_argument_index_for_region(\n         &self,"}, {"sha": "cbd1e666284cf8aae61de6de2a98ddc41ab2fb9b", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -119,7 +119,7 @@ struct RegionDefinition<'tcx> {\n     external_name: Option<ty::Region<'tcx>>,\n }\n \n-/// NB: The variants in `Cause` are intentionally ordered. Lower\n+/// N.B., the variants in `Cause` are intentionally ordered. Lower\n /// values are preferred when it comes to error messages. Do not\n /// reorder willy nilly.\n #[derive(Copy, Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n@@ -657,7 +657,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     .buffer(errors_buffer);\n             } else {\n                 // FIXME. We should handle this case better. It\n-                // indicates that we have e.g. some region variable\n+                // indicates that we have e.g., some region variable\n                 // whose value is like `'a+'b` where `'a` and `'b` are\n                 // distinct unrelated univesal regions that are not\n                 // known to outlive one another. It'd be nice to have"}, {"sha": "4f5829f34069cd6e6783bb26a390c06a431d56f0", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -313,7 +313,7 @@ impl<N: Idx> RegionValues<N> {\n         self.points.insert_all_into_row(r);\n     }\n \n-    /// Add all elements in `r_from` to `r_to` (because e.g. `r_to:\n+    /// Add all elements in `r_from` to `r_to` (because e.g., `r_to:\n     /// r_from`).\n     crate fn add_region(&mut self, r_to: N, r_from: N) -> bool {\n         self.points.union_rows(r_from, r_to)"}, {"sha": "bb890e65b53e6a7ce7d414c589f03dd77073ea2a", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -40,7 +40,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         // If the user explicitly annotated the input types, extract\n         // those.\n         //\n-        // e.g. `|x: FxHashMap<_, &'static u32>| ...`\n+        // e.g., `|x: FxHashMap<_, &'static u32>| ...`\n         let user_provided_sig;\n         if !self.tcx().is_closure(self.mir_def_id) {\n             user_provided_sig = None;\n@@ -50,7 +50,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 None => None,\n                 Some(user_provided_poly_sig) => {\n                     // Instantiate the canonicalized variables from\n-                    // user-provided signature (e.g. the `_` in the code\n+                    // user-provided signature (e.g., the `_` in the code\n                     // above) with fresh variables.\n                     let (poly_sig, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars(\n                         mir.span,"}, {"sha": "320422c9d332298166d9dd92a3d603ae905a2343", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/local_use_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -23,7 +23,7 @@ crate struct LocalUseMap<'me> {\n     liveness_map: &'me NllLivenessMap,\n \n     /// Head of a linked list of **definitions** of each variable --\n-    /// definition in this context means assignment, e.g. `x` is\n+    /// definition in this context means assignment, e.g., `x` is\n     /// defined in `x = y` but not `y`; that first def is the head of\n     /// a linked list that lets you enumerate all places the variable\n     /// is assigned."}, {"sha": "4807abe2bdd19c08dbedbb476ad9b884c2e3311c", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n //! This pass type-checks the MIR to ensure it is not broken.\n+\n #![allow(unreachable_code)]\n \n use borrow_check::borrow_set::BorrowSet;"}, {"sha": "eeac915cff37eb79b6a33619917d96f057016454", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -128,10 +128,10 @@ fn place_components_conflict<'gcx, 'tcx>(\n                         //\n                         // There is no *easy* way of comparing the fields\n                         // further on, because they might have different types\n-                        // (e.g. borrows of `u.a.0` and `u.b.y` where `.0` and\n+                        // (e.g., borrows of `u.a.0` and `u.b.y` where `.0` and\n                         // `.y` come from different structs).\n                         //\n-                        // We could try to do some things here - e.g. count\n+                        // We could try to do some things here - e.g., count\n                         // dereferences - but that's probably not a good\n                         // idea, at least for now, so just give up and\n                         // report a conflict. This is unsafe code anyway so\n@@ -175,14 +175,14 @@ fn place_components_conflict<'gcx, 'tcx>(\n                         // borrowed place (at least in MIR as it is\n                         // currently.)\n                         //\n-                        // e.g. a (mutable) borrow of `a[5]` while we read the\n+                        // e.g., a (mutable) borrow of `a[5]` while we read the\n                         // array length of `a`.\n                         debug!(\"borrow_conflicts_with_place: implicit field\");\n                         return false;\n                     }\n \n                     (ProjectionElem::Deref, _, Shallow(None)) => {\n-                        // e.g. a borrow of `*x.y` while we shallowly access `x.y` or some\n+                        // e.g., a borrow of `*x.y` while we shallowly access `x.y` or some\n                         // prefix thereof - the shallow access can't touch anything behind\n                         // the pointer.\n                         debug!(\"borrow_conflicts_with_place: shallow access behind ptr\");\n@@ -216,7 +216,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n                     | (ProjectionElem::Downcast { .. }, _, _) => {\n                         // Recursive case. This can still be disjoint on a\n                         // further iteration if this a shallow access and\n-                        // there's a deref later on, e.g. a borrow\n+                        // there's a deref later on, e.g., a borrow\n                         // of `*x.y` while accessing `x`.\n                     }\n                 }\n@@ -251,7 +251,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n /// the place `a` with a \"next\" pointer to `a.b`).  Created by\n /// `unroll_place`.\n ///\n-/// NB: This particular impl strategy is not the most obvious.  It was\n+/// N.B., this particular impl strategy is not the most obvious.  It was\n /// chosen because it makes a measurable difference to NLL\n /// performance, as this code (`borrow_conflicts_with_place`) is somewhat hot.\n struct PlaceComponents<'p, 'tcx: 'p> {\n@@ -277,7 +277,7 @@ impl<'p, 'tcx> PlaceComponents<'p, 'tcx> {\n /// Iterator over components; see `PlaceComponents::iter` for more\n /// information.\n ///\n-/// NB: This is not a *true* Rust iterator -- the code above just\n+/// N.B., this is not a *true* Rust iterator -- the code above just\n /// manually invokes `next`. This is because we (sometimes) want to\n /// keep executing even after `None` has been returned.\n struct PlaceComponentsIter<'p, 'tcx: 'p> {\n@@ -384,13 +384,13 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n         (Place::Projection(pi1), Place::Projection(pi2)) => {\n             match (&pi1.elem, &pi2.elem) {\n                 (ProjectionElem::Deref, ProjectionElem::Deref) => {\n-                    // derefs (e.g. `*x` vs. `*x`) - recur.\n+                    // derefs (e.g., `*x` vs. `*x`) - recur.\n                     debug!(\"place_element_conflict: DISJOINT-OR-EQ-DEREF\");\n                     Overlap::EqualOrDisjoint\n                 }\n                 (ProjectionElem::Field(f1, _), ProjectionElem::Field(f2, _)) => {\n                     if f1 == f2 {\n-                        // same field (e.g. `a.y` vs. `a.y`) - recur.\n+                        // same field (e.g., `a.y` vs. `a.y`) - recur.\n                         debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n                         Overlap::EqualOrDisjoint\n                     } else {"}, {"sha": "b759e0416e566509554592cb896247a758300843", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -91,7 +91,7 @@ impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n \n         // Post-processing `place`: Enqueue any remaining\n         // work. Also, `place` may not be a prefix itself, but\n-        // may hold one further down (e.g. we never return\n+        // may hold one further down (e.g., we never return\n         // downcasts here, but may return a base of a downcast).\n \n         'cursor: loop {"}, {"sha": "4df8d66e2fb5d6e7966bf4231aa1961d2e9d3774", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -117,7 +117,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     };\n                     this.block_context.push(BlockFrame::Statement { ignores_expr_result });\n \n-                    // Enter the remainder scope, i.e. the bindings' destruction scope.\n+                    // Enter the remainder scope, i.e., the bindings' destruction scope.\n                     this.push_scope((remainder_scope, source_info));\n                     let_scope_stack.push(remainder_scope);\n "}, {"sha": "a476165462a2fe906cbae884c168cafd9b917d0d", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! See docs in build/expr/mod.rs\n+//! See docs in `build/expr/mod.rs`.\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;"}, {"sha": "0e7305e076edeb3f39f3de319b5b8c3787aaa99d", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -414,7 +414,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                     // must be handled above or else we get an\n                     // infinite loop in the builder; see\n-                    // e.g. `ExprKind::VarRef` above\n+                    // e.g., `ExprKind::VarRef` above\n                     Category::Place => false,\n \n                     _ => true,"}, {"sha": "0e9f81bbe95601b22657bb0c2a242c7b2e3fe121", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -16,7 +16,7 @@ use rustc::mir::*;\n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Builds a block of MIR statements to evaluate the HAIR `expr`.\n     /// If the original expression was an AST statement,\n-    /// (e.g. `some().code(&here());`) then `opt_stmt_span` is the\n+    /// (e.g., `some().code(&here());`) then `opt_stmt_span` is the\n     /// span of that statement (including its semicolon, if any).\n     /// Diagnostics use this span (which may be larger than that of\n     /// `expr`) to identify when statement temporaries are dropped."}, {"sha": "3e57c4acb4288d07d62b00e5a7ee6a282b96e6a4", "filename": "src/librustc_mir/build/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Finto.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -11,7 +11,7 @@\n //! In general, there are a number of things for which it's convenient\n //! to just call `builder.into` and have it emit its result into a\n //! given location. This is basically for expressions or things that can be\n-//! wrapped up as expressions (e.g. blocks). To make this ergonomic, we use this\n+//! wrapped up as expressions (e.g., blocks). To make this ergonomic, we use this\n //! latter `EvalInto` trait.\n \n use build::{BlockAnd, Builder};"}, {"sha": "7e7c0b15555f838fa292cf11089ea5ee238ce781", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -111,7 +111,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // pattern, which means there may be more than one candidate\n         // *per arm*. These candidates are kept sorted such that the\n         // highest priority candidate comes first in the list.\n-        // (i.e. same order as in source)\n+        // (i.e., same order as in source)\n \n         let candidates: Vec<_> = arms.iter()\n             .enumerate()\n@@ -1384,7 +1384,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // Tricky business: For `ref id` and `ref mut id`\n                     // patterns, we want `id` within the guard to\n                     // correspond to a temp of type `& &T` or `& &mut\n-                    // T` (i.e. a \"borrow of a borrow\") that is\n+                    // T` (i.e., a \"borrow of a borrow\") that is\n                     // implicitly dereferenced.\n                     //\n                     // To borrow a borrow, we need that inner borrow"}, {"sha": "3ac7bd3fc68dc62f6894afb889cb256dfc664ab1", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -22,7 +22,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Add a new temporary value of type `ty` storing the result of\n     /// evaluating `expr`.\n     ///\n-    /// NB: **No cleanup is scheduled for this temporary.** You should\n+    /// N.B., **No cleanup is scheduled for this temporary.** You should\n     /// call `schedule_drop` once the temporary is initialized.\n     pub fn temp(&mut self, ty: Ty<'tcx>, span: Span) -> Place<'tcx> {\n         let temp = self.local_decls.push(LocalDecl::new_temp(ty, span));"}, {"sha": "8c948766314e8fb988a6db2d5dfe0e9fd145d5da", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -152,7 +152,7 @@ struct DropData<'tcx> {\n pub(crate) struct CachedBlock {\n     /// The cached block for the cleanups-on-diverge path. This block\n     /// contains code to run the current drop and all the preceding\n-    /// drops (i.e. those having lower index in Drop\u2019s Scope drop\n+    /// drops (i.e., those having lower index in Drop\u2019s Scope drop\n     /// array)\n     unwind: Option<BasicBlock>,\n \n@@ -182,7 +182,7 @@ pub struct BreakableScope<'tcx> {\n     /// Block to branch into when the loop or block terminates (either by being `break`-en out\n     /// from, or by having its condition to become false)\n     pub break_block: BasicBlock,\n-    /// The destination of the loop/block expression itself (i.e. where to put the result of a\n+    /// The destination of the loop/block expression itself (i.e., where to put the result of a\n     /// `break` expression)\n     pub break_destination: Place<'tcx>,\n }\n@@ -737,7 +737,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             //\n             // Note that this code iterates scopes from the inner-most to the outer-most,\n             // invalidating caches of each scope visited. This way bare minimum of the\n-            // caches gets invalidated. i.e. if a new drop is added into the middle scope, the\n+            // caches gets invalidated. i.e., if a new drop is added into the middle scope, the\n             // cache of outer scpoe stays intact.\n             scope.invalidate_cache(!needs_drop, this_scope);\n             if this_scope {"}, {"sha": "52eae5815287425f4f882ed0bbf99ee7bfeb929b", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -67,7 +67,7 @@ pub trait FlowsAtLocation {\n /// effects at any point in the control-flow graph by starting with\n /// the state at the start of the basic block (`reset_to_entry_of`)\n /// and then replaying the effects of statements and terminators\n-/// (e.g. via `reconstruct_statement_effect` and\n+/// (e.g., via `reconstruct_statement_effect` and\n /// `reconstruct_terminator_effect`; don't forget to call\n /// `apply_local_effect`).\n pub struct FlowAtLocation<BD>"}, {"sha": "5e78ef03c2c6b4e7197699b8c478377f9322bf79", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -267,7 +267,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                         Place::Local(..) | Place::Static(..) => {} // okay\n                         Place::Projection(..) => {\n                             // ... can assign into projections,\n-                            // e.g. `box (&mut _)`. Current\n+                            // e.g., `box (&mut _)`. Current\n                             // conservative solution: force\n                             // immediate activation here.\n                             sets.gen(*index);"}, {"sha": "c29a855b1d2ebbc9041b1432443c2dde9b525d84", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -488,7 +488,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n                 //\n                 // FIXME(#46525): We *need* to do this for StorageLive as well as\n                 // StorageDead, because lifetimes of match bindings with guards are\n-                // weird - i.e. this code\n+                // weird - i.e., this code\n                 //\n                 // ```\n                 //     fn main() {"}, {"sha": "bd842669a1f9b4538c3b7ca8693c0c320efa78af", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -290,7 +290,7 @@ impl<'a, 'tcx: 'a, BD> DataflowBuilder<'a, 'tcx, BD> where BD: BitDenotation\n /// It abstracts over the FlowState and also completely hides the\n /// underlying flow analysis results, because it needs to handle cases\n /// where we are combining the results of *multiple* flow analyses\n-/// (e.g. borrows + inits + uninits).\n+/// (e.g., borrows + inits + uninits).\n pub(crate) trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n     type FlowState: FlowsAtLocation;\n \n@@ -553,7 +553,7 @@ impl<E:Idx> AllSets<E> {\n /// Parameterization for the precise form of data flow that is used.\n /// `InitialFlow` handles initializing the bitvectors before any\n /// code is inspected by the analysis. Analyses that need more nuanced\n-/// initialization (e.g. they need to consult the results of some other\n+/// initialization (e.g., they need to consult the results of some other\n /// dataflow analysis to set up the initial bitvectors) should not\n /// implement this.\n pub trait InitialFlow {\n@@ -592,7 +592,7 @@ pub trait BitDenotation: BitSetOperator {\n \n     /// A name describing the dataflow analysis that this\n     /// BitDenotation is supporting.  The name should be something\n-    /// suitable for plugging in as part of a filename e.g. avoid\n+    /// suitable for plugging in as part of a filename e.g., avoid\n     /// space-characters or other things that tend to look bad on a\n     /// file system, like slashes or periods. It is also better for\n     /// the name to be reasonably short, again because it will be\n@@ -739,7 +739,7 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n     /// To reflect this, the `propagate_call_return` method of the\n     /// `BitDenotation` mutates `in_out` when propagating `in_out` via\n     /// a call terminator; such mutation is performed *last*, to\n-    /// ensure its side-effects do not leak elsewhere (e.g. into\n+    /// ensure its side-effects do not leak elsewhere (e.g., into\n     /// unwind target).\n     fn propagate_bits_into_graph_successors_of(\n         &mut self,"}, {"sha": "186e5f5f5f0ad6d6e47cec940399e9cdfed9a64e", "filename": "src/librustc_mir/dataflow/move_paths/abs_domain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -10,7 +10,7 @@\n \n //! The move-analysis portion of borrowck needs to work in an abstract\n //! domain of lifted Places.  Most of the Place variants fall into a\n-//! one-to-one mapping between the concrete and abstract (e.g. a\n+//! one-to-one mapping between the concrete and abstract (e.g., a\n //! field-deref on a local-variable, `x.field`, has the same meaning\n //! in both domains). Indexed-Projections are the exception: `a[x]`\n //! needs to be treated as mapping to the same move path as `a[y]` as"}, {"sha": "a1471adac6050dcc92401d93a8c59b67438aa36a", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -181,7 +181,7 @@ fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n             // To ensure that both implicit and explicit coercions are\n             // handled the same way, we insert an extra layer of indirection here.\n-            // For explicit casts (e.g. 'foo as *const T'), the source of the 'Use'\n+            // For explicit casts (e.g., 'foo as *const T'), the source of the 'Use'\n             // will be an ExprKind::Hair with the appropriate cast expression. Here,\n             // we make our Use source the generated Cast from the original coercion.\n             //\n@@ -1212,7 +1212,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     }\n }\n \n-/// Converts a list of named fields (i.e. for struct-like struct/enum ADTs) into FieldExprRef.\n+/// Converts a list of named fields (i.e., for struct-like struct/enum ADTs) into FieldExprRef.\n fn field_refs<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                               fields: &'tcx [hir::Field])\n                               -> Vec<FieldExprRef<'tcx>> {"}, {"sha": "e80ef38a6170fb3a9fdcc7978cac09cf7a7c9b7f", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -29,9 +29,9 @@\n ///\n /// If we have this predicate, then we can easily compute both exhaustiveness of an\n /// entire set of patterns and the individual usefulness of each one.\n-/// (a) the set of patterns is exhaustive iff `U(P, _)` is false (i.e. adding a wildcard\n+/// (a) the set of patterns is exhaustive iff `U(P, _)` is false (i.e., adding a wildcard\n /// match doesn't increase the number of values we're matching)\n-/// (b) a pattern `p_i` is not useful if `U(P[0..=(i-1), p_i)` is false (i.e. adding a\n+/// (b) a pattern `p_i` is not useful if `U(P[0..=(i-1), p_i)` is false (i.e., adding a\n /// pattern to those that have come before it doesn't increase the number of values\n /// we're matching).\n ///\n@@ -90,17 +90,17 @@\n ///\n /// The algorithm for computing `U`\n /// -------------------------------\n-/// The algorithm is inductive (on the number of columns: i.e. components of tuple patterns).\n+/// The algorithm is inductive (on the number of columns: i.e., components of tuple patterns).\n /// That means we're going to check the components from left-to-right, so the algorithm\n /// operates principally on the first component of the matrix and new pattern `p_{m + 1}`.\n /// This algorithm is realised in the `is_useful` function.\n ///\n-/// Base case. (`n = 0`, i.e. an empty tuple pattern)\n-///     - If `P` already contains an empty pattern (i.e. if the number of patterns `m > 0`),\n+/// Base case. (`n = 0`, i.e., an empty tuple pattern)\n+///     - If `P` already contains an empty pattern (i.e., if the number of patterns `m > 0`),\n ///       then `U(P, p_{m + 1})` is false.\n ///     - Otherwise, `P` must be empty, so `U(P, p_{m + 1})` is true.\n ///\n-/// Inductive step. (`n > 0`, i.e. whether there's at least one column\n+/// Inductive step. (`n > 0`, i.e., whether there's at least one column\n ///                  [which may then be expanded into further columns later])\n ///     We're going to match on the new pattern, `p_{m + 1}`.\n ///         - If `p_{m + 1} == c(r_1, .., r_a)`, then we have a constructor pattern.\n@@ -113,7 +113,7 @@\n ///             + All the constructors of the first component of the type exist within\n ///               all the rows (after having expanded OR-patterns). In this case:\n ///               `U(P, p_{m + 1}) := \u2228(k \u03f5 constructors) U(S(k, P), S(k, p_{m + 1}))`\n-///               I.e. the pattern `p_{m + 1}` is only useful when all the constructors are\n+///               I.e., the pattern `p_{m + 1}` is only useful when all the constructors are\n ///               present *if* its later components are useful for the respective constructors\n ///               covered by `p_{m + 1}` (usually a single constructor, but all in the case of `_`).\n ///             + Some constructors are not present in the existing rows (after having expanded\n@@ -156,14 +156,14 @@\n /// - When we're testing for usefulness of a pattern and the pattern's first component is a\n ///   wildcard.\n ///     + If all the constructors appear in the matrix, we have a slight complication. By default,\n-///       the behaviour (i.e. a disjunction over specialised matrices for each constructor) is\n+///       the behaviour (i.e., a disjunction over specialised matrices for each constructor) is\n ///       invalid, because we want a disjunction over every *integer* in each range, not just a\n ///       disjunction over every range. This is a bit more tricky to deal with: essentially we need\n ///       to form equivalence classes of subranges of the constructor range for which the behaviour\n ///       of the matrix `P` and new pattern `p_{m + 1}` are the same. This is described in more\n ///       detail in `split_grouped_constructors`.\n ///     + If some constructors are missing from the matrix, it turns out we don't need to do\n-///       anything special (because we know none of the integers are actually wildcards: i.e. we\n+///       anything special (because we know none of the integers are actually wildcards: i.e., we\n ///       can't span wildcards using ranges).\n \n use self::Constructor::*;\n@@ -371,7 +371,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n #[derive(Clone, Debug, PartialEq)]\n pub enum Constructor<'tcx> {\n     /// The constructor of all patterns that don't vary by constructor,\n-    /// e.g. struct patterns and fixed-length arrays.\n+    /// e.g., struct patterns and fixed-length arrays.\n     Single,\n     /// Enum variants.\n     Variant(DefId),\n@@ -488,7 +488,7 @@ impl<'tcx> Witness<'tcx> {\n     /// patterns expanded by the specialization step.\n     ///\n     /// When a pattern P is discovered to be useful, this function is used bottom-up\n-    /// to reconstruct a complete witness, e.g. a pattern P' that covers a subset\n+    /// to reconstruct a complete witness, e.g., a pattern P' that covers a subset\n     /// of values, V, where each value in that set is not covered by any previously\n     /// used patterns and is covered by the pattern P'. Examples:\n     ///\n@@ -763,7 +763,7 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n /// straightforward. See `signed_bias` for details.\n ///\n /// `IntRange` is never used to encode an empty range or a \"range\" that wraps\n-/// around the (offset) space: i.e. `range.lo <= range.hi`.\n+/// around the (offset) space: i.e., `range.lo <= range.hi`.\n #[derive(Clone)]\n struct IntRange<'tcx> {\n     pub range: RangeInclusive<u128>,\n@@ -854,7 +854,7 @@ impl<'tcx> IntRange<'tcx> {\n     }\n \n     /// Return a collection of ranges that spans the values covered by `ranges`, subtracted\n-    /// by the values covered by `self`: i.e. `ranges \\ self` (in set notation).\n+    /// by the values covered by `self`: i.e., `ranges \\ self` (in set notation).\n     fn subtract_from(self,\n                      tcx: TyCtxt<'_, 'tcx, 'tcx>,\n                      ranges: Vec<Constructor<'tcx>>)\n@@ -1122,7 +1122,7 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                     //\n                     // There are 2 ways we can report a witness here.\n                     // Commonly, we can report all the \"free\"\n-                    // constructors as witnesses, e.g. if we have:\n+                    // constructors as witnesses, e.g., if we have:\n                     //\n                     // ```\n                     //     enum Direction { N, S, E, W }\n@@ -1137,7 +1137,7 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                     // 1) If the user is matching against a non-exhaustive\n                     // enum, there is no point in enumerating all possible\n                     // variants, because the user can't actually match\n-                    // against them himself, e.g. in an example like:\n+                    // against them himself, e.g., in an example like:\n                     // ```\n                     //     let err: io::ErrorKind = ...;\n                     //     match err {\n@@ -1151,7 +1151,7 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                     // case).\n                     //\n                     // 2) If the user didn't actually specify a constructor\n-                    // in this arm, e.g. in\n+                    // in this arm, e.g., in\n                     // ```\n                     //     let x: (Direction, Direction, bool) = ...;\n                     //     let (_, _, false) = x;\n@@ -1197,7 +1197,7 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     }\n }\n \n-/// A shorthand for the `U(S(c, P), S(c, q))` operation from the paper. I.e. `is_useful` applied\n+/// A shorthand for the `U(S(c, P), S(c, q))` operation from the paper. I.e., `is_useful` applied\n /// to the specialised version of both the pattern matrix `P` and the new pattern `q`.\n fn is_useful_specialized<'p, 'a:'p, 'tcx: 'a>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n@@ -1413,7 +1413,7 @@ fn should_treat_range_exhaustively(tcx: TyCtxt<'_, 'tcx, 'tcx>, ctor: &Construct\n /// the groups (the ranges). Thus we need to split the groups up. Splitting them up na\u00efvely would\n /// mean creating a separate constructor for every single value in the range, which is clearly\n /// impractical. However, observe that for some ranges of integers, the specialisation will be\n-/// identical across all values in that range (i.e. there are equivalence classes of ranges of\n+/// identical across all values in that range (i.e., there are equivalence classes of ranges of\n /// constructors based on their `is_useful_specialized` outcome). These classes are grouped by\n /// the patterns that apply to them (in the matrix `P`). We can split the range whenever the\n /// patterns that apply to that range (specifically: the patterns that *intersect* with that range)\n@@ -1422,7 +1422,7 @@ fn should_treat_range_exhaustively(tcx: TyCtxt<'_, 'tcx, 'tcx>, ctor: &Construct\n /// the group of intersecting patterns changes (using the method described below).\n /// And voil\u00e0! We're testing precisely those ranges that we need to, without any exhaustive matching\n /// on actual integers. The nice thing about this is that the number of subranges is linear in the\n-/// number of rows in the matrix (i.e. the number of cases in the `match` statement), so we don't\n+/// number of rows in the matrix (i.e., the number of cases in the `match` statement), so we don't\n /// need to be worried about matching over gargantuan ranges.\n ///\n /// Essentially, given the first column of a matrix representing ranges, looking like the following:"}, {"sha": "9fb3a09e3c11e91de327febcff6a37a07ddcbf5e", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -188,7 +188,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n \n             // Third, perform some lints.\n             for pat in &arm.pats {\n-                check_for_bindings_named_the_same_as_variants(self, pat);\n+                check_for_bindings_named_same_as_variants(self, pat);\n             }\n         }\n \n@@ -309,7 +309,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n     }\n }\n \n-fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n+fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n     pat.walk(|p| {\n         if let PatKind::Binding(_, _, ident, None) = p.node {\n             if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {"}, {"sha": "d695a64f62a08e1e2a1a1a211996e5807529cb5f", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -228,7 +228,7 @@ pub enum PatternKind<'tcx> {\n \n     /// matches against a slice, checking the length and extracting elements.\n     /// irrefutable when there is a slice pattern and both `prefix` and `suffix` are empty.\n-    /// e.g. `&[ref xs..]`.\n+    /// e.g., `&[ref xs..]`.\n     Slice {\n         prefix: Vec<Pattern<'tcx>>,\n         slice: Option<Pattern<'tcx>>,"}, {"sha": "4c7aa887045c718ef2b2c899e4fc27090ab9fc20", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -81,7 +81,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     type FrameExtra;\n \n     /// Extra data stored in memory.  A reference to this is available when `AllocExtra`\n-    /// gets initialized, so you can e.g. have an `Rc` here if there is global state you\n+    /// gets initialized, so you can e.g., have an `Rc` here if there is global state you\n     /// need access to in the `AllocExtra` hooks.\n     type MemoryExtra: Default;\n "}, {"sha": "e32abb92e21157e2fdcf02dfc06c73274870ce87", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -55,7 +55,7 @@ impl<T: MayLeak> MayLeak for MemoryKind<T> {\n }\n \n // `Memory` has to depend on the `Machine` because some of its operations\n-// (e.g. `get`) call a `Machine` hook.\n+// (e.g., `get`) call a `Machine` hook.\n pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n     /// Allocations local to this instance of the miri engine.  The kind\n     /// helps ensure that the same mechanism is used for allocation and"}, {"sha": "bae670bf2b4b3b1b7e6dc6cc67a55b061430d32b", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -35,7 +35,7 @@ pub struct MemPlace<Tag=(), Id=AllocId> {\n     pub align: Align,\n     /// Metadata for unsized places.  Interpretation is up to the type.\n     /// Must not be present for sized types, but can be missing for unsized types\n-    /// (e.g. `extern type`).\n+    /// (e.g., `extern type`).\n     pub meta: Option<Scalar<Tag, Id>>,\n }\n \n@@ -236,7 +236,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n             }\n         } else {\n             // Go through the layout.  There are lots of types that support a length,\n-            // e.g. SIMD types.\n+            // e.g., SIMD types.\n             match self.layout.fields {\n                 layout::FieldPlacement::Array { count, .. } => Ok(count),\n                 _ => bug!(\"len not supported on sized type {:?}\", self.layout.ty),\n@@ -908,7 +908,7 @@ where\n                         // a fake pointer?  Are we even called for ZST?\n \n                         // We need the layout of the local.  We can NOT use the layout we got,\n-                        // that might e.g. be an inner field of a struct with `Scalar` layout,\n+                        // that might e.g., be an inner field of a struct with `Scalar` layout,\n                         // that has different alignment than the outer field.\n                         let local_layout = self.layout_of_local(&self.stack[frame], local)?;\n                         let ptr = self.allocate(local_layout, MemoryKind::Stack)?;"}, {"sha": "a6835e4f167380ed0cb5c525675cfb2b768cfafc", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -18,7 +18,7 @@ use rustc::mir::interpret::{EvalResult, Scalar, PointerArithmetic};\n \n use super::{EvalContext, Machine};\n \n-/// Classify whether an operator is \"left-homogeneous\", i.e. the LHS has the\n+/// Classify whether an operator is \"left-homogeneous\", i.e., the LHS has the\n /// same type as the result.\n #[inline]\n fn binop_left_homogeneous(op: mir::BinOp) -> bool {\n@@ -31,7 +31,7 @@ fn binop_left_homogeneous(op: mir::BinOp) -> bool {\n             false,\n     }\n }\n-/// Classify whether an operator is \"right-homogeneous\", i.e. the RHS has the\n+/// Classify whether an operator is \"right-homogeneous\", i.e., the RHS has the\n /// same type as the LHS.\n #[inline]\n fn binop_right_homogeneous(op: mir::BinOp) -> bool {\n@@ -85,7 +85,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n         use rustc::mir::StatementKind::*;\n \n-        // Some statements (e.g. box) push new stack frames.\n+        // Some statements (e.g., box) push new stack frames.\n         // We have to record the stack frame number *before* executing the statement.\n         let frame_idx = self.cur_frame();\n         self.tcx.span = stmt.source_info.span;"}, {"sha": "4a672f195d240cfbf8db53839bf33b68716b707f", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -252,7 +252,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     return err!(FunctionAbiMismatch(caller_abi, Abi::RustIntrinsic));\n                 }\n                 // The intrinsic itself cannot diverge, so if we got here without a return\n-                // place... (can happen e.g. for transmute returning `!`)\n+                // place... (can happen e.g., for transmute returning `!`)\n                 let dest = match dest {\n                     Some(dest) => dest,\n                     None => return err!(Unreachable)"}, {"sha": "4f1737354ca62e39da39bdc31465ea1403b753c1", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -408,7 +408,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     // Check if we have encountered this pointer+layout combination\n                     // before.  Proceed recursively even for integer pointers, no\n                     // reason to skip them! They are (recursively) valid for some ZST,\n-                    // but not for others (e.g. `!` is a ZST).\n+                    // but not for others (e.g., `!` is a ZST).\n                     let op = place.into();\n                     if ref_tracking.seen.insert(op) {\n                         trace!(\"Recursing below ptr {:#?}\", *op);\n@@ -548,7 +548,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                 // NOTE: Keep this in sync with the handling of integer and float\n                 // types above, in `visit_primitive`.\n                 // In run-time mode, we accept pointers in here.  This is actually more\n-                // permissive than a per-element check would be, e.g. we accept\n+                // permissive than a per-element check would be, e.g., we accept\n                 // an &[u8] that contains a pointer even though bytewise checking would\n                 // reject it.  However, that's good: We don't inherently want\n                 // to reject those pointers, we just do not have the machinery to"}, {"sha": "4773f5627d716db0238f6b3d9ac616b20d8eb140", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -272,7 +272,7 @@ macro_rules! make_value_visitor {\n                 // is very relevant for `NonNull` and similar structs: We need to visit them\n                 // at their scalar layout *before* descending into their fields.\n                 // FIXME: We could avoid some redundant checks here. For newtypes wrapping\n-                // scalars, we do the same check on every \"level\" (e.g. first we check\n+                // scalars, we do the same check on every \"level\" (e.g., first we check\n                 // MyNewtype and then the scalar in there).\n                 match v.layout().abi {\n                     layout::Abi::Uninhabited => {"}, {"sha": "775431e5cbd6bc2902eae5ee17fda11202b989a3", "filename": "src/librustc_mir/lints.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flints.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -39,11 +39,11 @@ fn check_fn_for_unconditional_recursion(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     //FIXME(#54444) rewrite this lint to use the dataflow framework\n \n     // Walk through this function (say `f`) looking to see if\n-    // every possible path references itself, i.e. the function is\n+    // every possible path references itself, i.e., the function is\n     // called recursively unconditionally. This is done by trying\n     // to find a path from the entry node to the exit node that\n     // *doesn't* call `f` by traversing from the entry while\n-    // pretending that calls of `f` are sinks (i.e. ignoring any\n+    // pretending that calls of `f` are sinks (i.e., ignoring any\n     // exit edges from them).\n     //\n     // NB. this has an edge case with non-returning statements,\n@@ -62,7 +62,7 @@ fn check_fn_for_unconditional_recursion(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // considers this to be an error for two reasons, (a) it is\n     // easier to implement, and (b) it seems rare to actually want\n     // to have behaviour like the above, rather than\n-    // e.g. accidentally recursing after an assert.\n+    // e.g., accidentally recursing after an assert.\n \n     let basic_blocks = mir.basic_blocks();\n     let mut reachable_without_self_call_queue = vec![mir::START_BLOCK];\n@@ -135,7 +135,7 @@ fn check_fn_for_unconditional_recursion(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     // Check the number of self calls because a function that\n-    // doesn't return (e.g. calls a `-> !` function or `loop { /*\n+    // doesn't return (e.g., calls a `-> !` function or `loop { /*\n     // no break */ }`) shouldn't be linted unless it actually\n     // recurs.\n     if !reached_exit_without_self_call && !self_call_locations.is_empty() {"}, {"sha": "c962a2416f554f24c7fb4e19e907aa76baeb0810", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -821,7 +821,7 @@ fn should_monomorphize_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance:\n /// Again, we want this `find_vtable_types_for_unsizing()` to provide the pair\n /// `(SomeStruct, SomeTrait)`.\n ///\n-/// Finally, there is also the case of custom unsizing coercions, e.g. for\n+/// Finally, there is also the case of custom unsizing coercions, e.g., for\n /// smart pointers such as `Rc` and `Arc`.\n fn find_vtable_types_for_unsizing<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             source_ty: Ty<'tcx>,"}, {"sha": "00974d4a5b250977cc9b9f278528f7739a5a0a85", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -51,7 +51,7 @@\n //!\n //! - There are two codegen units for every source-level module:\n //! - One for \"stable\", that is non-generic, code\n-//! - One for more \"volatile\" code, i.e. monomorphized instances of functions\n+//! - One for more \"volatile\" code, i.e., monomorphized instances of functions\n //!   defined in that module\n //!\n //! In order to see why this heuristic makes sense, let's take a look at when a"}, {"sha": "6af29b74c1c4fab1e535a8b8ee492e47202b66ad", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -497,7 +497,7 @@ fn unsafety_check_result<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n {\n     debug!(\"unsafety_violations({:?})\", def_id);\n \n-    // NB: this borrow is valid because all the consumers of\n+    // N.B., this borrow is valid because all the consumers of\n     // `mir_built` force this.\n     let mir = &tcx.mir_built(def_id).borrow();\n "}, {"sha": "acae03f7f94f5ca05ad6046ddba442fd7faeccb5", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -289,7 +289,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                     })?;\n                     Some((res, span))\n                 },\n-                // We could get more projections by using e.g. `operand_projection`,\n+                // We could get more projections by using e.g., `operand_projection`,\n                 // but we do not even have the stack frame set up properly so\n                 // an `Index` projection would throw us off-track.\n                 _ => None,"}, {"sha": "afe0066df1f28dbc6e2ca85bd4d2849c480fbf4d", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -575,10 +575,10 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             // The `tmp0`, `tmp1`, and `tmp2` in our example abonve.\n             let tuple_tmp_args =\n                 tuple_tys.iter().enumerate().map(|(i, ty)| {\n-                    // This is e.g. `tuple_tmp.0` in our example above.\n+                    // This is e.g., `tuple_tmp.0` in our example above.\n                     let tuple_field = Operand::Move(tuple.clone().field(Field::new(i), ty));\n \n-                    // Spill to a local to make e.g. `tmp0`.\n+                    // Spill to a local to make e.g., `tmp0`.\n                     self.create_temp_if_necessary(tuple_field, callsite, caller_mir)\n                 });\n "}, {"sha": "7f8dfc111a4bde777ed23af81866d7a21ea859b3", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -123,7 +123,7 @@ impl<'tcx> Visitor<'tcx> for TempCollector<'tcx> {\n             }\n         } else if let TempState::Defined { ref mut uses, .. } = *temp {\n             // We always allow borrows, even mutable ones, as we need\n-            // to promote mutable borrows of some ZSTs e.g. `&mut []`.\n+            // to promote mutable borrows of some ZSTs e.g., `&mut []`.\n             let allowed_use = context.is_borrow() || context.is_nonmutating_use();\n             debug!(\"visit_local: allowed_use={:?}\", allowed_use);\n             if allowed_use {"}, {"sha": "5f08dee87285928dc6d7361a9b7d681a741792ba", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -17,6 +17,8 @@\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::sync::Lrc;\n+use rustc_target::spec::abi::Abi;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::mir::interpret::ConstValue;\n@@ -28,13 +30,12 @@ use rustc::mir::*;\n use rustc::mir::traversal::ReversePostorder;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n use rustc::middle::lang_items;\n-use rustc_target::spec::abi::Abi;\n+use rustc::session::config::nightly_options;\n use syntax::ast::LitKind;\n use syntax::feature_gate::{UnstableFeatures, feature_err, emit_feature_err, GateIssue};\n use syntax_pos::{Span, DUMMY_SP};\n \n use std::fmt;\n-use rustc_data_structures::sync::Lrc;\n use std::usize;\n \n use transform::{MirPass, MirSource};\n@@ -639,7 +640,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                         self.add(qualif);\n \n                         // Just in case the type is more specific than\n-                        // the definition, e.g. impl associated const\n+                        // the definition, e.g., impl associated const\n                         // with type parameters, take it into account.\n                         self.qualif.restrict(constant.literal.ty, self.tcx, self.param_env);\n                     }\n@@ -952,30 +953,30 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                             }\n                         }\n                         _ => {\n-                            // in normal functions we only care about promotion\n+                            // In normal functions we only care about promotion.\n                             if self.mode == Mode::Fn {\n-                                // never promote const fn calls of\n-                                // functions without #[rustc_promotable]\n+                                // Never promote const fn calls of\n+                                // functions without `#[rustc_promotable]`.\n                                 if self.tcx.is_promotable_const_fn(def_id) {\n                                     is_const_fn = true;\n                                     is_promotable_const_fn = true;\n                                 } else if self.tcx.is_const_fn(def_id) {\n                                     is_const_fn = true;\n                                 }\n                             } else {\n-                                // stable const fn or unstable const fns with their feature gate\n+                                // stable const fns or unstable const fns with their feature gate\n                                 // active\n                                 if self.tcx.is_const_fn(def_id) {\n                                     is_const_fn = true;\n                                 } else if self.is_const_panic_fn(def_id) {\n-                                    // check the const_panic feature gate\n+                                    // Check the const_panic feature gate.\n                                     // FIXME: cannot allow this inside `allow_internal_unstable`\n                                     // because that would make `panic!` insta stable in constants,\n-                                    // since the macro is marked with the attr\n+                                    // since the macro is marked with the attribute.\n                                     if self.tcx.features().const_panic {\n                                         is_const_fn = true;\n                                     } else {\n-                                        // don't allow panics in constants without the feature gate\n+                                        // Don't allow panics in constants without the feature gate.\n                                         emit_feature_err(\n                                             &self.tcx.sess.parse_sess,\n                                             \"const_panic\",\n@@ -984,25 +985,28 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                                             &format!(\"panicking in {}s is unstable\", self.mode),\n                                         );\n                                     }\n-                                } else if let Some(feat) = self.tcx.is_unstable_const_fn(def_id) {\n-                                    // check `#[unstable]` const fns or `#[rustc_const_unstable]`\n-                                    // functions without the feature gate active in this crate to\n-                                    // report a better error message than the one below\n+                                } else if let Some(feature)\n+                                              = self.tcx.is_unstable_const_fn(def_id) {\n+                                    // Check `#[unstable]` const fns or `#[rustc_const_unstable]`\n+                                    // functions without the feature gate active in this crate in\n+                                    // order to report a better error message than the one below.\n                                     if self.span.allows_unstable() {\n-                                        // `allow_internal_unstable` can make such calls stable\n+                                        // `allow_internal_unstable` can make such calls stable.\n                                         is_const_fn = true;\n                                     } else {\n                                         let mut err = self.tcx.sess.struct_span_err(self.span,\n                                             &format!(\"`{}` is not yet stable as a const fn\",\n                                                     self.tcx.item_path_str(def_id)));\n-                                        help!(&mut err,\n-                                            \"in Nightly builds, add `#![feature({})]` \\\n-                                            to the crate attributes to enable\",\n-                                            feat);\n+                                        if nightly_options::is_nightly_build() {\n+                                            help!(&mut err,\n+                                                  \"add `#![feature({})]` to the \\\n+                                                   crate attributes to enable\",\n+                                                  feature);\n+                                        }\n                                         err.emit();\n                                     }\n                                 } else {\n-                                    // FIXME(#24111) Remove this check when const fn stabilizes\n+                                    // FIXME(#24111): remove this check when const fn stabilizes.\n                                     let (msg, note) = if let UnstableFeatures::Disallow =\n                                             self.tcx.sess.opts.unstable_features {\n                                         (format!(\"calls in {}s are limited to \\\n@@ -1081,7 +1085,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     // we care about constness, not promotability.\n                     // If we checked for promotability, we'd miss out on\n                     // the results of function calls (which are never promoted\n-                    // in runtime code)\n+                    // in runtime code).\n                     // This is not a problem, because the argument explicitly\n                     // requests constness, in contrast to regular promotion\n                     // which happens even without the user requesting it.\n@@ -1098,7 +1102,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 });\n             }\n \n-            // non-const fn calls.\n+            // non-const fn calls\n             if !is_const_fn {\n                 self.qualif = Qualif::NOT_CONST;\n                 if self.mode != Mode::Fn {\n@@ -1131,7 +1135,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n             // Deny *any* live drops anywhere other than functions.\n             if self.mode != Mode::Fn {\n-                // HACK(eddyb) Emulate a bit of dataflow analysis,\n+                // HACK(eddyb): emulate a bit of dataflow analysis,\n                 // conservatively, that drop elaboration will do.\n                 let needs_drop = if let Place::Local(local) = *place {\n                     if self.local_qualif[local].map_or(true, |q| q.contains(Qualif::NEEDS_DROP)) {\n@@ -1259,7 +1263,7 @@ pub fn provide(providers: &mut Providers) {\n fn mir_const_qualif<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               def_id: DefId)\n                               -> (u8, Lrc<BitSet<Local>>) {\n-    // NB: This `borrow()` is guaranteed to be valid (i.e., the value\n+    // N.B., this `borrow()` is guaranteed to be valid (i.e., the value\n     // cannot yet be stolen), because `mir_validated()`, which steals\n     // from `mir_const(), forces this query to execute before\n     // performing the steal."}, {"sha": "81b010e7dcec9ba8f7bad43a4bd95ad102cf351d", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -58,7 +58,7 @@ impl RemoveNoopLandingPads {\n                 }\n \n                 StatementKind::Assign(Place::Local(_), box Rvalue::Use(_)) => {\n-                    // Writing to a local (e.g. a drop flag) does not\n+                    // Writing to a local (e.g., a drop flag) does not\n                     // turn a landing pad to a non-nop\n                 }\n "}, {"sha": "4f381e0a3d23e2eb3c3674959b9c5c81ecf7cbde", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -24,8 +24,8 @@ use std::u32;\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone)]\n pub enum DropFlagState {\n-    Present, // i.e. initialized\n-    Absent, // i.e. deinitialized or \"moved\"\n+    Present, // i.e., initialized\n+    Absent, // i.e., deinitialized or \"moved\"\n }\n \n impl DropFlagState {"}, {"sha": "22554acc6adaad0486acfd32471f518fc09d4cbf", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -29,7 +29,7 @@\n //! ```\n //!\n //! This means that users of this analysis still have to check whether\n-//! pre-existing references can be used to access the value (e.g. at movable\n+//! pre-existing references can be used to access the value (e.g., at movable\n //! generator yield points, all pre-existing references are invalidated, so this\n //! doesn't matter).\n "}, {"sha": "9a35721e3e1c4a6dca9178da02d2c68236dd7dc5", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -404,7 +404,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 }\n             }\n             ItemKind::Mod(_) => {\n-                // Ensure that `path` attributes on modules are recorded as used (c.f. #35584).\n+                // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n                 attr::first_attr_value_str_by_name(&item.attrs, \"path\");\n                 if attr::contains_name(&item.attrs, \"warn_directory_ownership\") {\n                     let lint = lint::builtin::LEGACY_DIRECTORY_OWNERSHIP;\n@@ -529,7 +529,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n }\n \n-// Bans nested `impl Trait`, e.g. `impl Into<impl Debug>`.\n+// Bans nested `impl Trait`, e.g., `impl Into<impl Debug>`.\n // Nested `impl Trait` _is_ allowed in associated type position,\n // e.g `impl Iterator<Item=impl Debug>`\n struct NestedImplTraitVisitor<'a> {"}, {"sha": "bfe8b677a5e806803ac8072533ab0cda0cc29910", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -383,7 +383,7 @@ fn check_expr_kind<'a, 'tcx>(\n                         NotPromotable\n                     };\n                     // Just in case the type is more specific than the definition,\n-                    // e.g. impl associated const with type parameters, check it.\n+                    // e.g., impl associated const with type parameters, check it.\n                     // Also, trait associated consts are relaxed by this.\n                     promotable | v.type_promotability(node_ty)\n                 }"}, {"sha": "ad55672fb47de7d8a3699f74e5dc436342a15c28", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -144,7 +144,7 @@ impl<'a> PluginLoader<'a> {\n \n             // Intentionally leak the dynamic library. We can't ever unload it\n             // since the library can make things that will live arbitrarily long\n-            // (e.g. an @-box cycle or a thread).\n+            // (e.g., an @-box cycle or a thread).\n             mem::forget(lib);\n \n             registrar"}, {"sha": "86e3b231fc7ff3803d53308b263efcb5b19ad625", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 76, "deletions": 79, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -23,8 +23,7 @@ extern crate rustc_typeck;\n extern crate syntax_pos;\n extern crate rustc_data_structures;\n \n-use rustc::hir::{self, PatKind};\n-use hir::Node;\n+use rustc::hir::{self, Node, PatKind};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n@@ -36,14 +35,14 @@ use rustc::ty::fold::TypeVisitor;\n use rustc::ty::query::Providers;\n use rustc::ty::subst::UnpackedKind;\n use rustc::util::nodemap::NodeSet;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::sync::Lrc;\n use syntax::ast::{self, CRATE_NODE_ID, Ident};\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n use std::cmp;\n use std::mem::replace;\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::sync::Lrc;\n \n mod diagnostics;\n \n@@ -74,11 +73,11 @@ impl<'a, 'tcx> Visitor<'tcx> for PubRestrictedVisitor<'a, 'tcx> {\n struct EmbargoVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n-    // Accessibility levels for reachable nodes\n+    // Accessibility levels for reachable nodes.\n     access_levels: AccessLevels,\n-    // Previous accessibility level, None means unreachable\n+    // Previous accessibility level; `None` means unreachable.\n     prev_level: Option<AccessLevel>,\n-    // Have something changed in the level map?\n+    // Has something changed in the level map?\n     changed: bool,\n }\n \n@@ -117,10 +116,10 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n         self.access_levels.map.get(&id).cloned()\n     }\n \n-    // Updates node level and returns the updated level\n+    // Updates node level and returns the updated level.\n     fn update(&mut self, id: ast::NodeId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n         let old_level = self.get(id);\n-        // Accessibility levels can only grow\n+        // Accessibility levels can only grow.\n         if level > old_level {\n             self.access_levels.map.insert(id, level.unwrap());\n             self.changed = true;\n@@ -149,16 +148,16 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let inherited_item_level = match item.node {\n-            // Impls inherit level from their types and traits\n+            // Impls inherit level from their types and traits.\n             hir::ItemKind::Impl(..) => {\n                 let def_id = self.tcx.hir().local_def_id(item.id);\n                 cmp::min(self.item_ty_level(def_id), self.impl_trait_level(def_id))\n             }\n-            // Foreign mods inherit level from parents\n+            // Foreign modules inherit level from parents.\n             hir::ItemKind::ForeignMod(..) => {\n                 self.prev_level\n             }\n-            // Other `pub` items inherit levels from parents\n+            // Other `pub` items inherit levels from parents.\n             hir::ItemKind::Const(..) | hir::ItemKind::Enum(..) | hir::ItemKind::ExternCrate(..) |\n             hir::ItemKind::GlobalAsm(..) | hir::ItemKind::Fn(..) | hir::ItemKind::Mod(..) |\n             hir::ItemKind::Static(..) | hir::ItemKind::Struct(..) |\n@@ -169,10 +168,10 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             }\n         };\n \n-        // Update level of the item itself\n+        // Update level of the item itself.\n         let item_level = self.update(item.id, inherited_item_level);\n \n-        // Update levels of nested things\n+        // Update levels of nested things.\n         match item.node {\n             hir::ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n@@ -240,23 +239,23 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n         // reachability level through interfaces and children.\n         let orig_level = replace(&mut self.prev_level, item_level);\n \n-        // Mark all items in interfaces of reachable items as reachable\n+        // Mark all items in interfaces of reachable items as reachable.\n         match item.node {\n-            // The interface is empty\n+            // The interface is empty.\n             hir::ItemKind::ExternCrate(..) => {}\n-            // All nested items are checked by visit_item\n+            // All nested items are checked by `visit_item`.\n             hir::ItemKind::Mod(..) => {}\n-            // Re-exports are handled in visit_mod\n+            // Re-exports are handled in `visit_mod`.\n             hir::ItemKind::Use(..) => {}\n-            // The interface is empty\n+            // The interface is empty.\n             hir::ItemKind::GlobalAsm(..) => {}\n             hir::ItemKind::Existential(hir::ExistTy { impl_trait_fn: Some(_), .. }) => {\n                 if item_level.is_some() {\n-                    // Reach the (potentially private) type and the API being exposed\n+                    // Reach the (potentially private) type and the API being exposed.\n                     self.reach(item.id).ty().predicates();\n                 }\n             }\n-            // Visit everything\n+            // Visit everything.\n             hir::ItemKind::Const(..) | hir::ItemKind::Static(..) |\n             hir::ItemKind::Existential(..) |\n             hir::ItemKind::Fn(..) | hir::ItemKind::Ty(..) => {\n@@ -286,7 +285,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                     self.reach(item.id).generics().predicates();\n                 }\n             }\n-            // Visit everything except for private impl items\n+            // Visit everything except for private impl items.\n             hir::ItemKind::Impl(.., ref trait_ref, _, ref impl_item_refs) => {\n                 if item_level.is_some() {\n                     self.reach(item.id).generics().predicates().impl_trait_ref();\n@@ -300,7 +299,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                 }\n             }\n \n-            // Visit everything, but enum variants have their own levels\n+            // Visit everything, but enum variants have their own levels.\n             hir::ItemKind::Enum(ref def, _) => {\n                 if item_level.is_some() {\n                     self.reach(item.id).generics().predicates();\n@@ -316,15 +315,15 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            // Visit everything, but foreign items have their own levels\n+            // Visit everything, but foreign items have their own levels.\n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     if self.get(foreign_item.id).is_some() {\n                         self.reach(foreign_item.id).generics().predicates().ty();\n                     }\n                 }\n             }\n-            // Visit everything except for private fields\n+            // Visit everything except for private fields.\n             hir::ItemKind::Struct(ref struct_def, _) |\n             hir::ItemKind::Union(ref struct_def, _) => {\n                 if item_level.is_some() {\n@@ -348,7 +347,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n \n         // Blocks can have public items, for example impls, but they always\n         // start as completely private regardless of publicity of a function,\n-        // constant, type, field, etc. in which this block resides\n+        // constant, type, field, etc., in which this block resides.\n         intravisit::walk_block(self, b);\n \n         self.prev_level = orig_level;\n@@ -524,10 +523,10 @@ struct NamePrivacyVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n     // Checks that a field in a struct constructor (expression or pattern) is accessible.\n     fn check_field(&mut self,\n-                   use_ctxt: Span, // Syntax context of the field name at the use site\n-                   span: Span, // Span of the field pattern, e.g. `x: 0`\n-                   def: &'tcx ty::AdtDef, // Definition of the struct or enum\n-                   field: &'tcx ty::FieldDef) { // Definition of the field\n+                   use_ctxt: Span, // syntax context of the field name at the use site\n+                   span: Span, // span of the field pattern, e.g., `x: 0`\n+                   def: &'tcx ty::AdtDef, // definition of the struct or enum\n+                   field: &'tcx ty::FieldDef) { // definition of the field\n         let ident = Ident::new(keywords::Invalid.name(), use_ctxt);\n         let def_id = self.tcx.adjust_ident(ident, def.did, self.current_item).1;\n         if !def.is_enum() && !field.vis.is_accessible_from(def_id, self.tcx) {\n@@ -539,8 +538,8 @@ impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n     }\n }\n \n-// Set the correct TypeckTables for the given `item_id` (or an empty table if\n-// there is no TypeckTables for the item).\n+// Set the correct `TypeckTables` for the given `item_id` (or an empty table if\n+// there is no `TypeckTables` for the item).\n fn update_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            item_id: ast::NodeId,\n                            tables: &mut &'a ty::TypeckTables<'tcx>,\n@@ -710,7 +709,7 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n         self.def_id_visibility(did).is_accessible_from(self.current_item, self.tcx)\n     }\n \n-    // Take node ID of an expression or pattern and check its type for privacy.\n+    // Take node-id of an expression or pattern and check its type for privacy.\n     fn check_expr_pat_type(&mut self, id: hir::HirId, span: Span) -> bool {\n         self.span = span;\n         if self.tables.node_id_to_type(id).visit_with(self) {\n@@ -862,7 +861,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_qpath(self, qpath, id, span);\n     }\n \n-    // Check types of patterns\n+    // Check types of patterns.\n     fn visit_pat(&mut self, pattern: &'tcx hir::Pat) {\n         if self.check_expr_pat_type(pattern.hir_id, pattern.span) {\n             // Do not check nested patterns if the error already happened.\n@@ -883,7 +882,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_local(self, local);\n     }\n \n-    // Check types in item interfaces\n+    // Check types in item interfaces.\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let orig_current_item = self.current_item;\n         let orig_tables = update_tables(self.tcx,\n@@ -1015,18 +1014,18 @@ struct ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     access_levels: &'a AccessLevels,\n     in_variant: bool,\n-    // set of errors produced by this obsolete visitor\n+    // Set of errors produced by this obsolete visitor.\n     old_error_set: NodeSet,\n }\n \n struct ObsoleteCheckTypeForPrivatenessVisitor<'a, 'b: 'a, 'tcx: 'b> {\n     inner: &'a ObsoleteVisiblePrivateTypesVisitor<'b, 'tcx>,\n-    /// whether the type refers to private types.\n+    /// Whether the type refers to private types.\n     contains_private: bool,\n-    /// whether we've recurred at all (i.e. if we're pointing at the\n-    /// first type on which visit_ty was called).\n+    /// Whether we've recurred at all (i.e., if we're pointing at the\n+    /// first type on which `visit_ty` was called).\n     at_outer_type: bool,\n-    // whether that first type is a public path.\n+    /// Whether that first type is a public path.\n     outer_type_is_public_path: bool,\n }\n \n@@ -1041,7 +1040,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         // it's in this crate...\n         if let Some(node_id) = self.tcx.hir().as_local_node_id(did) {\n             // .. and it corresponds to a private type in the AST (this returns\n-            // None for type parameters)\n+            // `None` for type parameters).\n             match self.tcx.hir().find(node_id) {\n                 Some(Node::Item(ref item)) => !item.vis.node.is_pub(),\n                 Some(_) | None => false,\n@@ -1053,7 +1052,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n \n     fn trait_is_public(&self, trait_id: ast::NodeId) -> bool {\n         // FIXME: this would preferably be using `exported_items`, but all\n-        // traits are exported currently (see `EmbargoVisitor.exported_trait`)\n+        // traits are exported currently (see `EmbargoVisitor.exported_trait`).\n         self.access_levels.is_public(trait_id)\n     }\n \n@@ -1079,8 +1078,7 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for ObsoleteCheckTypeForPrivatenessVisitor<'a\n         if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = ty.node {\n             if self.inner.path_is_private_type(path) {\n                 self.contains_private = true;\n-                // found what we're looking for so let's stop\n-                // working.\n+                // Found what we're looking for, so let's stop working.\n                 return\n             }\n         }\n@@ -1093,7 +1091,7 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for ObsoleteCheckTypeForPrivatenessVisitor<'a\n         intravisit::walk_ty(self, ty)\n     }\n \n-    // don't want to recurse into [, .. expr]\n+    // Don't want to recurse into `[, .. expr]`.\n     fn visit_expr(&mut self, _: &hir::Expr) {}\n }\n \n@@ -1106,7 +1104,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n-            // contents of a private mod can be re-exported, so we need\n+            // Contents of a private mod can be re-exported, so we need\n             // to check internals.\n             hir::ItemKind::Mod(_) => {}\n \n@@ -1124,19 +1122,19 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                 }\n             }\n \n-            // impls need some special handling to try to offer useful\n+            // Impls need some special handling to try to offer useful\n             // error messages without (too many) false positives\n-            // (i.e. we could just return here to not check them at\n+            // (i.e., we could just return here to not check them at\n             // all, or some worse estimation of whether an impl is\n             // publicly visible).\n             hir::ItemKind::Impl(.., ref g, ref trait_ref, ref self_, ref impl_item_refs) => {\n                 // `impl [... for] Private` is never visible.\n                 let self_contains_private;\n-                // impl [... for] Public<...>, but not `impl [... for]\n-                // Vec<Public>` or `(Public,)` etc.\n+                // `impl [... for] Public<...>`, but not `impl [... for]\n+                // Vec<Public>` or `(Public,)`, etc.\n                 let self_is_public_path;\n \n-                // check the properties of the Self type:\n+                // Check the properties of the `Self` type:\n                 {\n                     let mut visitor = ObsoleteCheckTypeForPrivatenessVisitor {\n                         inner: self,\n@@ -1149,7 +1147,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                     self_is_public_path = visitor.outer_type_is_public_path;\n                 }\n \n-                // miscellaneous info about the impl\n+                // Miscellaneous info about the impl:\n \n                 // `true` iff this is `impl Private for ...`.\n                 let not_private_trait =\n@@ -1242,7 +1240,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                         }\n                     }\n                 } else if trait_ref.is_none() && self_is_public_path {\n-                    // impl Public<Private> { ... }. Any public static\n+                    // `impl Public<Private> { ... }`. Any public static\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n                     for impl_item_ref in impl_item_refs {\n@@ -1272,7 +1270,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             // we're introducing a new name.\n             hir::ItemKind::Ty(..) => return,\n \n-            // not at all public, so we don't care\n+            // Not at all public, so we don't care.\n             _ if !self.item_is_public(&item.id, &item.vis) => {\n                 return;\n             }\n@@ -1282,7 +1280,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n \n         // We've carefully constructed it so that if we're here, then\n         // any `visit_ty`'s will be called on things that are in\n-        // public signatures, i.e. things that we're interested in for\n+        // public signatures, i.e., things that we're interested in for\n         // this visitor.\n         intravisit::walk_item(self, item);\n     }\n@@ -1340,7 +1338,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    // we don't need to introspect into these at all: an\n+    // We don't need to introspect into these at all: an\n     // expression/block context can't possibly contain exported things.\n     // (Making them no-ops stops us from traversing the whole AST without\n     // having to be super careful about our `walk_...` calls above.)\n@@ -1359,9 +1357,9 @@ struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     item_def_id: DefId,\n     span: Span,\n-    /// The visitor checks that each component type is at least this visible\n+    /// The visitor checks that each component type is at least this visible.\n     required_visibility: ty::Visibility,\n-    /// The visibility of the least visible component that has been visited\n+    /// The visibility of the least visible component that has been visited.\n     min_visibility: ty::Visibility,\n     has_pub_restricted: bool,\n     has_old_errors: bool,\n@@ -1384,7 +1382,7 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     }\n \n     fn predicates(&mut self) -> &mut Self {\n-        // NB: We use `explicit_predicates_of` and not `predicates_of`\n+        // N.B., we use `explicit_predicates_of` and not `predicates_of`\n         // because we don't want to report privacy errors due to where\n         // clauses that the compiler inferred. We only want to\n         // consider the ones that the user wrote. This is important\n@@ -1429,7 +1427,7 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     }\n \n     fn check_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) {\n-        // Non-local means public (private items can't leave their crate, modulo bugs)\n+        // Non-local means public (private items can't leave their crate, modulo bugs).\n         if let Some(node_id) = self.tcx.hir().as_local_node_id(trait_ref.def_id) {\n             let item = self.tcx.hir().expect_item(node_id);\n             let vis = ty::Visibility::from_hir(&item.vis, node_id, self.tcx);\n@@ -1478,7 +1476,7 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n         };\n \n         if let Some(def_id) = ty_def_id {\n-            // Non-local means public (private items can't leave their crate, modulo bugs)\n+            // Non-local means public (private items can't leave their crate, modulo bugs).\n             if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n                 let hir_vis = match self.tcx.hir().find(node_id) {\n                     Some(Node::Item(item)) => &item.vis,\n@@ -1579,30 +1577,29 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n         let item_visibility = ty::Visibility::from_hir(&item.vis, item.id, tcx);\n \n         match item.node {\n-            // Crates are always public\n+            // Crates are always public.\n             hir::ItemKind::ExternCrate(..) => {}\n-            // All nested items are checked by visit_item\n+            // All nested items are checked by `visit_item`.\n             hir::ItemKind::Mod(..) => {}\n-            // Checked in resolve\n+            // Checked in resolve.\n             hir::ItemKind::Use(..) => {}\n-            // No subitems\n+            // No subitems.\n             hir::ItemKind::GlobalAsm(..) => {}\n             hir::ItemKind::Existential(hir::ExistTy { impl_trait_fn: Some(_), .. }) => {\n                 // Check the traits being exposed, as they're separate,\n-                // e.g. `impl Iterator<Item=T>` has two predicates,\n+                // e.g., `impl Iterator<Item=T>` has two predicates,\n                 // `X: Iterator` and `<X as Iterator>::Item == T`,\n                 // where `X` is the `impl Iterator<Item=T>` itself,\n                 // stored in `predicates_of`, not in the `Ty` itself.\n-\n                 self.check(item.id, item_visibility).predicates();\n             }\n-            // Subitems of these items have inherited publicity\n+            // Subitems of these items have inherited publicity.\n             hir::ItemKind::Const(..) | hir::ItemKind::Static(..) | hir::ItemKind::Fn(..) |\n             hir::ItemKind::Existential(..) |\n             hir::ItemKind::Ty(..) => {\n                 self.check(item.id, item_visibility).generics().predicates().ty();\n \n-                // Recurse for e.g. `impl Trait` (see `visit_ty`).\n+                // Recurse for e.g., `impl Trait` (see `visit_ty`).\n                 self.inner_visibility = item_visibility;\n                 intravisit::walk_item(self, item);\n             }\n@@ -1634,14 +1631,14 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                     }\n                 }\n             }\n-            // Subitems of foreign modules have their own publicity\n+            // Subitems of foreign modules have their own publicity.\n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     let vis = ty::Visibility::from_hir(&foreign_item.vis, item.id, tcx);\n                     self.check(foreign_item.id, vis).generics().predicates().ty();\n                 }\n             }\n-            // Subitems of structs and unions have their own publicity\n+            // Subitems of structs and unions have their own publicity.\n             hir::ItemKind::Struct(ref struct_def, _) |\n             hir::ItemKind::Union(ref struct_def, _) => {\n                 self.check(item.id, item_visibility).generics().predicates();\n@@ -1652,7 +1649,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                 }\n             }\n             // An inherent impl is public when its type is public\n-            // Subitems of inherent impls have their own publicity\n+            // Subitems of inherent impls have their own publicity.\n             hir::ItemKind::Impl(.., None, _, ref impl_item_refs) => {\n                 let ty_vis =\n                     self.check(item.id, ty::Visibility::Invisible).ty().min_visibility;\n@@ -1665,13 +1662,13 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                     check.in_assoc_ty = impl_item_ref.kind == hir::AssociatedItemKind::Type;\n                     check.generics().predicates().ty();\n \n-                    // Recurse for e.g. `impl Trait` (see `visit_ty`).\n+                    // Recurse for e.g., `impl Trait` (see `visit_ty`).\n                     self.inner_visibility = impl_item_vis;\n                     intravisit::walk_impl_item(self, impl_item);\n                 }\n             }\n             // A trait impl is public when both its type and its trait are public\n-            // Subitems of trait impls have inherited publicity\n+            // Subitems of trait impls have inherited publicity.\n             hir::ItemKind::Impl(.., Some(_), _, ref impl_item_refs) => {\n                 let vis = self.check(item.id, ty::Visibility::Invisible)\n                               .ty().impl_trait_ref().min_visibility;\n@@ -1682,7 +1679,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                     check.in_assoc_ty = impl_item_ref.kind == hir::AssociatedItemKind::Type;\n                     check.generics().predicates().ty();\n \n-                    // Recurse for e.g. `impl Trait` (see `visit_ty`).\n+                    // Recurse for e.g., `impl Trait` (see `visit_ty`).\n                     self.inner_visibility = vis;\n                     intravisit::walk_impl_item(self, impl_item);\n                 }\n@@ -1691,12 +1688,12 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n     }\n \n     fn visit_impl_item(&mut self, _impl_item: &'tcx hir::ImplItem) {\n-        // handled in `visit_item` above\n+        // Handled in `visit_item` above.\n     }\n \n-    // Don't recurse into expressions in array sizes or const initializers\n+    // Don't recurse into expressions in array sizes or const initializers.\n     fn visit_expr(&mut self, _: &'tcx hir::Expr) {}\n-    // Don't recurse into patterns in function arguments\n+    // Don't recurse into patterns in function arguments.\n     fn visit_pat(&mut self, _: &'tcx hir::Pat) {}\n }\n \n@@ -1778,7 +1775,7 @@ fn privacy_access_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             pub_restricted_visitor.has_pub_restricted\n         };\n \n-        // Check for private types and traits in public interfaces\n+        // Check for private types and traits in public interfaces.\n         let mut visitor = PrivateItemsInPublicInterfacesVisitor {\n             tcx,\n             has_pub_restricted,"}, {"sha": "ebd2c87fa4642e9ff385d26d53a61b630fcae121", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -84,7 +84,7 @@ use rustc_data_structures::sync::Lrc;\n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n use macros::{InvocationData, LegacyBinding, ParentScope};\n \n-// NB: This module needs to be declared first so diagnostics are\n+// N.B., this module needs to be declared first so diagnostics are\n // registered before they are used.\n mod diagnostics;\n mod error_reporting;\n@@ -638,7 +638,7 @@ impl<'a> PathSource<'a> {\n \n // A minimal representation of a path segment. We use this in resolve because\n // we synthesize 'path segments' which don't have the rest of an AST or HIR\n-// PathSegment.\n+// `PathSegment`.\n #[derive(Clone, Copy, Debug)]\n pub struct Segment {\n     ident: Ident,\n@@ -2608,7 +2608,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         result\n     }\n \n-    /// This is called to resolve a trait reference from an `impl` (i.e. `impl Trait for Foo`)\n+    /// This is called to resolve a trait reference from an `impl` (i.e., `impl Trait for Foo`)\n     fn with_optional_trait_ref<T, F>(&mut self, opt_trait_ref: Option<&TraitRef>, f: F) -> T\n         where F: FnOnce(&mut Resolver, Option<DefId>) -> T\n     {\n@@ -2890,7 +2890,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             self.resolve_pattern(&pattern, PatternSource::Match, &mut bindings_list);\n         }\n \n-        // This has to happen *after* we determine which pat_idents are variants\n+        // This has to happen *after* we determine which pat_idents are variants.\n         self.check_consistent_bindings(&arm.pats);\n \n         if let Some(ast::Guard::If(ref expr)) = arm.guard {\n@@ -3032,8 +3032,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                             Def::StructCtor(..) | Def::VariantCtor(..) |\n                             Def::Const(..) | Def::Static(..) => {\n                                 // This is unambiguously a fresh binding, either syntactically\n-                                // (e.g. `IDENT @ PAT` or `ref IDENT`) or because `IDENT` resolves\n-                                // to something unusable as a pattern (e.g. constructor function),\n+                                // (e.g., `IDENT @ PAT` or `ref IDENT`) or because `IDENT` resolves\n+                                // to something unusable as a pattern (e.g., constructor function),\n                                 // but we still conservatively report an error, see\n                                 // issues/33118#issuecomment-233962221 for one reason why.\n                                 resolve_error(\n@@ -3209,9 +3209,9 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 for (sp, variant_path, enum_path) in enum_candidates {\n                     if sp.is_dummy() {\n                         let msg = format!(\"there is an enum variant `{}`, \\\n-                                        try using `{}`?\",\n-                                        variant_path,\n-                                        enum_path);\n+                                           try using `{}`?\",\n+                                          variant_path,\n+                                          enum_path);\n                         err.help(&msg);\n                     } else {\n                         err.span_suggestion_with_applicability(\n@@ -3263,7 +3263,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n             let mut levenshtein_worked = false;\n \n-            // Try Levenshtein.\n+            // Try Levenshtein algorithm.\n             if let Some(candidate) = this.lookup_typo_candidate(path, ns, is_expected, span) {\n                 err.span_label(ident_span, format!(\"did you mean `{}`?\", candidate));\n                 levenshtein_worked = true;\n@@ -4325,7 +4325,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     for pat in pats {\n                         this.resolve_pattern(pat, PatternSource::WhileLet, &mut bindings_list);\n                     }\n-                    // This has to happen *after* we determine which pat_idents are variants\n+                    // This has to happen *after* we determine which pat_idents are variants.\n                     this.check_consistent_bindings(pats);\n                     this.visit_block(block);\n                     this.ribs[ValueNS].pop();\n@@ -4611,7 +4611,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     /// When name resolution fails, this method can be used to look up candidate\n     /// entities with the expected name. It allows filtering them using the\n     /// supplied predicate (which should be used to only accept the types of\n-    /// definitions expected e.g. traits). The lookup spans across all crates.\n+    /// definitions expected e.g., traits). The lookup spans across all crates.\n     ///\n     /// NOTE: The method does not look into imports, but this is not a problem,\n     /// since we report the definitions (thus, the de-aliased imports)."}, {"sha": "3f57c74c2c3c58fe52547c511a9db4bbc22f7c0b", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -359,7 +359,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     }\n                 } else {\n                     // Not only attributes, but anything in macro namespace can result in\n-                    // `Def::NonMacroAttr` definition (e.g. `inline!()`), so we must report\n+                    // `Def::NonMacroAttr` definition (e.g., `inline!()`), so we must report\n                     // an error for those cases.\n                     let msg = format!(\"expected a macro, found {}\", def.kind_name());\n                     self.session.span_err(path.span, &msg);\n@@ -436,7 +436,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n     // Resolve an identifier in lexical scope.\n     // This is a variation of `fn resolve_ident_in_lexical_scope` that can be run during\n     // expansion and import resolution (perhaps they can be merged in the future).\n-    // The function is used for resolving initial segments of macro paths (e.g. `foo` in\n+    // The function is used for resolving initial segments of macro paths (e.g., `foo` in\n     // `foo::bar!(); or `foo!();`) and also for import paths on 2018 edition.\n     crate fn early_resolve_ident_in_lexical_scope(\n         &mut self,"}, {"sha": "f130895e236f51e992f1a4813cc83d627fd7221a", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -430,7 +430,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n     crate fn import(&self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)\n                     -> &'a NameBinding<'a> {\n         let vis = if binding.pseudo_vis().is_at_least(directive.vis.get(), self) ||\n-                     // c.f. `PUB_USE_OF_PRIVATE_EXTERN_CRATE`\n+                     // cf. `PUB_USE_OF_PRIVATE_EXTERN_CRATE`\n                      !directive.is_glob() && binding.is_extern_crate() {\n             directive.vis.get()\n         } else {\n@@ -1011,7 +1011,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                                 NameBindingKind::Import { binding, .. } => {\n                                     match binding.kind {\n                                         // Never suggest the name that has binding error\n-                                        // i.e. the name that cannot be previously resolved\n+                                        // i.e., the name that cannot be previously resolved\n                                         NameBindingKind::Def(Def::Err, _) => return None,\n                                         _ => Some(&i.name),\n                                     }"}, {"sha": "e0acc150ee39893260889d5f17f3e2633d09d39d", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -110,7 +110,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    // Returns path to the compilation output (e.g. libfoo-12345678.rmeta)\n+    // Returns path to the compilation output (e.g., libfoo-12345678.rmeta)\n     pub fn compilation_output(&self, crate_name: &str) -> PathBuf {\n         let sess = &self.tcx.sess;\n         // Save-analysis is emitted per whole session, not per each crate type"}, {"sha": "1c3763c6e37f455c4d3c85742e691fe876ccada6", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -164,7 +164,7 @@ impl Reg {\n }\n \n /// An argument passed entirely registers with the\n-/// same kind (e.g. HFA / HVA on PPC64 and AArch64).\n+/// same kind (e.g., HFA / HVA on PPC64 and AArch64).\n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub struct Uniform {\n     pub unit: Reg,\n@@ -173,7 +173,7 @@ pub struct Uniform {\n     /// * equal to `unit.size` (one scalar/vector)\n     /// * a multiple of `unit.size` (an array of scalar/vectors)\n     /// * if `unit.kind` is `Integer`, the last element\n-    ///   can be shorter, i.e. `{ i64, i64, i32 }` for\n+    ///   can be shorter, i.e., `{ i64, i64, i32 }` for\n     ///   64-bit integers with a total size of 20 bytes\n     pub total: Size,\n }"}, {"sha": "fe1c8751792f4743af4e2f7571ffd8f31a2c2745", "filename": "src/librustc_target/abi/call/s390x.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_target%2Fabi%2Fcall%2Fs390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_target%2Fabi%2Fcall%2Fs390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fs390x.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME: The assumes we're using the non-vector ABI, i.e. compiling\n+// FIXME: The assumes we're using the non-vector ABI, i.e., compiling\n // for a pre-z13 machine or using -mno-vx.\n \n use abi::call::{FnType, ArgType, Reg};"}, {"sha": "0f27300dc3bac869b7eaa5a601921f202fe282a1", "filename": "src/librustc_target/abi/call/x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -15,7 +15,7 @@ use abi::call::{ArgType, CastTarget, FnType, Reg, RegKind};\n use abi::{self, Abi, HasDataLayout, LayoutOf, Size, TyLayout, TyLayoutMethods};\n \n /// Classification of \"eightbyte\" components.\n-// NB: the order of the variants is from general to specific,\n+// N.B., the order of the variants is from general to specific,\n // such that `unify(a, b)` is the \"smaller\" of `a` and `b`.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n enum Class {"}, {"sha": "5912da9d3aa2fa3551c41b24e1b1810eaa7f1c7d", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -409,7 +409,7 @@ impl Align {\n     /// Compute the best alignment possible for the given offset\n     /// (the largest power of two that the offset is a multiple of).\n     ///\n-    /// NB: for an offset of `0`, this happens to return `2^64`.\n+    /// N.B., for an offset of `0`, this happens to return `2^64`.\n     pub fn max_for_offset(offset: Size) -> Align {\n         Align {\n             pow2: offset.bytes().trailing_zeros() as u8,\n@@ -639,7 +639,7 @@ pub struct Scalar {\n     ///\n     /// This is intended specifically to mirror LLVM\u2019s `!range` metadata,\n     /// semantics.\n-    // FIXME(eddyb) always use the shortest range, e.g. by finding\n+    // FIXME(eddyb) always use the shortest range, e.g., by finding\n     // the largest space between two consecutive valid values and\n     // taking everything else as the (shortest) valid range.\n     pub valid_range: RangeInclusive<u128>,\n@@ -887,12 +887,12 @@ impl LayoutDetails {\n }\n \n /// The details of the layout of a type, alongside the type itself.\n-/// Provides various type traversal APIs (e.g. recursing into fields).\n+/// Provides various type traversal APIs (e.g., recursing into fields).\n ///\n /// Note that the details are NOT guaranteed to always be identical\n /// to those obtained from `layout_of(ty)`, as we need to produce\n /// layouts for which Rust types do not exist, such as enum variants\n-/// or synthetic fields of enums (i.e. discriminants) and fat pointers.\n+/// or synthetic fields of enums (i.e., discriminants) and fat pointers.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub struct TyLayout<'a, Ty> {\n     pub ty: Ty,"}, {"sha": "919744fe046e758be63292dd4ee29d5c1b5e3131", "filename": "src/librustc_target/spec/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_target%2Fspec%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_target%2Fspec%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fabi.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -12,7 +12,7 @@ use std::fmt;\n \n #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Clone, Copy, Debug)]\n pub enum Abi {\n-    // NB: This ordering MUST match the AbiDatas array below.\n+    // N.B., this ordering MUST match the AbiDatas array below.\n     // (This is ensured by the test indices_are_correct().)\n \n     // Single platform ABIs"}, {"sha": "d8e8477f3d06b44a067783cdb7c1628f01aacdd6", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -605,7 +605,7 @@ pub struct TargetOptions {\n     /// `eh_unwind_resume` lang item.\n     pub custom_unwind_resume: bool,\n \n-    /// Flag indicating whether ELF TLS (e.g. #[thread_local]) is available for\n+    /// Flag indicating whether ELF TLS (e.g., #[thread_local]) is available for\n     /// this target.\n     pub has_elf_tls: bool,\n     // This is mainly for easy compatibility with emscripten."}, {"sha": "d760f5bf1f7ed550e5afea246818a81413274c7b", "filename": "src/librustc_target/spec/thumb_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_target%2Fspec%2Fthumb_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_target%2Fspec%2Fthumb_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fthumb_base.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -20,7 +20,7 @@\n // - Cortex-M23\n // - Cortex-M33\n //\n-// We have opted for these instead of one target per processor (e.g. `cortex-m0`, `cortex-m3`,\n+// We have opted for these instead of one target per processor (e.g., `cortex-m0`, `cortex-m3`,\n // etc) because the differences between some processors like the cortex-m0 and cortex-m1 are almost\n // non-existent from the POV of codegen so it doesn't make sense to have separate targets for them.\n // And if differences exist between two processors under the same target, rustc flags can be used to"}, {"sha": "d46ce8b10b988b3046efbb2588b81b67d208866c", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -77,7 +77,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n         let obligations =\n             wf::obligations(infcx, param_env, DUMMY_NODE_ID, ty, DUMMY_SP).unwrap_or(vec![]);\n \n-        // NB: All of these predicates *ought* to be easily proven\n+        // N.B., all of these predicates *ought* to be easily proven\n         // true. In fact, their correctness is (mostly) implied by\n         // other parts of the program. However, in #42552, we had\n         // an annoying scenario where:"}, {"sha": "473eebbde78626d9b3d1f461ef6bcb639bd602a7", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -43,7 +43,7 @@ crate fn provide(p: &mut Providers) {\n }\n \n crate trait Lower<T> {\n-    /// Lower a rustc construct (e.g. `ty::TraitPredicate`) to a chalk-like type.\n+    /// Lower a rustc construct (e.g., `ty::TraitPredicate`) to a chalk-like type.\n     fn lower(&self) -> T;\n }\n \n@@ -90,9 +90,9 @@ where\n }\n \n /// `ty::Binder` is used for wrapping a rustc construction possibly containing generic\n-/// lifetimes, e.g. `for<'a> T: Fn(&'a i32)`. Instead of representing higher-ranked things\n-/// in that leaf-form (i.e. `Holds(Implemented(Binder<TraitPredicate>))` in the previous\n-/// example), we model them with quantified domain goals, e.g. as for the previous example:\n+/// lifetimes, e.g., `for<'a> T: Fn(&'a i32)`. Instead of representing higher-ranked things\n+/// in that leaf-form (i.e., `Holds(Implemented(Binder<TraitPredicate>))` in the previous\n+/// example), we model them with quantified domain goals, e.g., as for the previous example:\n /// `forall<'a> { T: Fn(&'a i32) }` which corresponds to something like\n /// `Binder<Holds(Implemented(TraitPredicate))>`.\n impl<'tcx, T> Lower<PolyDomainGoal<'tcx>> for ty::Binder<T>\n@@ -248,7 +248,7 @@ fn program_clauses_for_trait<'a, 'tcx>(\n                 // and that named bound regions have a def-id, it is safe\n                 // to just inject `hypotheses` (which contains named vars bound at index `0`)\n                 // into this binding level. This may change if we ever allow where clauses\n-                // to bind types (e.g. for GATs things), because bound types only use a `BoundVar`\n+                // to bind types (e.g., for GATs things), because bound types only use a `BoundVar`\n                 // index (no def-id).\n                 hypotheses,\n \n@@ -560,7 +560,7 @@ pub fn program_clauses_for_associated_type_value<'a, 'tcx>(\n     // ```\n     //\n     // FIXME: For the moment, we don't account for where clauses written on the associated\n-    // ty definition (i.e. in the trait def, as in `type AssocType<T> where T: Sized`).\n+    // ty definition (i.e., in the trait def, as in `type AssocType<T> where T: Sized`).\n     // ```\n     // forall<P0..Pm> {\n     //   forall<Pn+1..Pm> {"}, {"sha": "43e7aee1b124ef45b2b46f6a22a1c4d2dada001e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 35, "deletions": 38, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -8,38 +8,38 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Conversion from AST representation of types to the `ty.rs`\n-//! representation.  The main routine here is `ast_ty_to_ty()`: each use\n-//! is parameterized by an instance of `AstConv`.\n+//! Conversion from AST representation of types to the `ty.rs` representation.\n+//! The main routine here is `ast_ty_to_ty()`; each use is is parameterized by\n+//! an instance of `AstConv`.\n \n-use smallvec::SmallVec;\n+use errors::{Applicability, FatalError, DiagnosticId};\n use hir::{self, GenericArg, GenericArgs};\n use hir::def::Def;\n use hir::def_id::DefId;\n use hir::HirVec;\n+use lint;\n use middle::resolve_lifetime as rl;\n use namespace::Namespace;\n-use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::{GenericParamDef, GenericParamDefKind};\n+use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::ty::wf::object_region_bounds;\n use rustc_data_structures::sync::Lrc;\n use rustc_target::spec::abi;\n-use std::collections::BTreeSet;\n-use std::slice;\n use require_c_abi_if_variadic;\n-use util::common::ErrorReported;\n-use util::nodemap::FxHashMap;\n-use errors::{Applicability, FatalError, DiagnosticId};\n-use lint;\n-\n-use std::iter;\n+use smallvec::SmallVec;\n use syntax::ast;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{DUMMY_SP, Span, MultiSpan};\n+use util::common::ErrorReported;\n+use util::nodemap::FxHashMap;\n+\n+use std::collections::BTreeSet;\n+use std::iter;\n+use std::slice;\n \n pub trait AstConv<'gcx, 'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n@@ -80,7 +80,7 @@ pub trait AstConv<'gcx, 'tcx> {\n     fn normalize_ty(&self, span: Span, ty: Ty<'tcx>) -> Ty<'tcx>;\n \n     /// Invoked when we encounter an error from some prior pass\n-    /// (e.g. resolve) that is translated into a ty-error. This is\n+    /// (e.g., resolve) that is translated into a ty-error. This is\n     /// used to help suppress derived errors typeck might otherwise\n     /// report.\n     fn set_tainted_by_errors(&self);\n@@ -97,7 +97,7 @@ struct ConvertedBinding<'tcx> {\n #[derive(PartialEq)]\n enum GenericArgPosition {\n     Type,\n-    Value, // e.g. functions\n+    Value, // e.g., functions\n     MethodCall,\n }\n \n@@ -106,7 +106,7 @@ enum GenericArgPosition {\n /// This type must not appear anywhere in other converted types.\n const TRAIT_OBJECT_DUMMY_SELF: ty::TyKind<'static> = ty::Infer(ty::FreshTy(0));\n \n-impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n+impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     pub fn ast_region_to_region(&self,\n         lifetime: &hir::Lifetime,\n         def: Option<&ty::GenericParamDef>)\n@@ -321,8 +321,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                                 provided,\n                                 offset| {\n             // We enforce the following: `required` <= `provided` <= `permitted`.\n-            // For kinds without defaults (i.e. lifetimes), `required == permitted`.\n-            // For other kinds (i.e. types), `permitted` may be greater than `required`.\n+            // For kinds without defaults (i.e., lifetimes), `required == permitted`.\n+            // For other kinds (i.e., types), `permitted` may be greater than `required`.\n             if required <= provided && provided <= permitted {\n                 return (false, None);\n             }\n@@ -411,24 +411,24 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n     /// creating the substitutions for, and a partial set of\n     /// substitutions `parent_substs`. In general, the substitutions\n     /// for an item begin with substitutions for all the \"parents\" of\n-    /// that item -- so e.g. for a method it might include the\n+    /// that item -- e.g., for a method it might include the\n     /// parameters from the impl.\n     ///\n     /// Therefore, the method begins by walking down these parents,\n     /// starting with the outermost parent and proceed inwards until\n-    /// it reaches `def_id`. For each parent P, it will check `parent_substs`\n+    /// it reaches `def_id`. For each parent `P`, it will check `parent_substs`\n     /// first to see if the parent's substitutions are listed in there. If so,\n     /// we can append those and move on. Otherwise, it invokes the\n     /// three callback functions:\n     ///\n-    /// - `args_for_def_id`: given the def-id P, supplies back the\n+    /// - `args_for_def_id`: given the def-id `P`, supplies back the\n     ///   generic arguments that were given to that parent from within\n-    ///   the path; so e.g. if you have `<T as Foo>::Bar`, the def-id\n+    ///   the path; so e.g., if you have `<T as Foo>::Bar`, the def-id\n     ///   might refer to the trait `Foo`, and the arguments might be\n     ///   `[T]`. The boolean value indicates whether to infer values\n     ///   for arguments whose values were not explicitly provided.\n     /// - `provided_kind`: given the generic parameter and the value from `args_for_def_id`,\n-    ///   instantiate a `Kind`\n+    ///   instantiate a `Kind`.\n     /// - `inferred_kind`: if no parameter was provided, and inference is enabled, then\n     ///   creates a suitable inference variable.\n     pub fn create_substs_for_generic_args<'a, 'b>(\n@@ -441,7 +441,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         provided_kind: impl Fn(&GenericParamDef, &GenericArg) -> Kind<'tcx>,\n         inferred_kind: impl Fn(Option<&[Kind<'tcx>]>, &GenericParamDef, bool) -> Kind<'tcx>,\n     ) -> &'tcx Substs<'tcx> {\n-        // Collect the segments of the path: we need to substitute arguments\n+        // Collect the segments of the path; we need to substitute arguments\n         // for parameters throughout the entire path (wherever there are\n         // generic parameters).\n         let mut parent_defs = tcx.generics_of(def_id);\n@@ -453,8 +453,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         }\n \n         // We manually build up the substitution, rather than using convenience\n-        // methods in `subst.rs` so that we can iterate over the arguments and\n-        // parameters in lock-step linearly, rather than trying to match each pair.\n+        // methods in `subst.rs`, so that we can iterate over the arguments and\n+        // parameters in lock-step linearly, instead of trying to match each pair.\n         let mut substs: SmallVec<[Kind<'tcx>; 8]> = SmallVec::with_capacity(count);\n \n         // Iterate over each segment of the path.\n@@ -1087,13 +1087,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 }\n             }\n             if !suggestions.is_empty() {\n-                let msg = if suggestions.len() == 1 {\n-                    \"if you meant to specify the associated type, write\"\n-                } else {\n-                    \"if you meant to specify the associated types, write\"\n-                };\n+                let msg = format!(\"if you meant to specify the associated {}, write\",\n+                    if suggestions.len() == 1 { \"type\" } else { \"types\" });\n                 err.multipart_suggestion_with_applicability(\n-                    msg,\n+                    &msg,\n                     suggestions,\n                     Applicability::MaybeIncorrect,\n                 );\n@@ -1279,7 +1276,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         // item is declared.\n         let bound = match (&ty.sty, ty_path_def) {\n             (_, Def::SelfTy(Some(_), Some(impl_def_id))) => {\n-                // `Self` in an impl of a trait - we have a concrete `self` type and a\n+                // `Self` in an impl of a trait -- we have a concrete `self` type and a\n                 // trait reference.\n                 let trait_ref = match tcx.impl_trait_ref(impl_def_id) {\n                     Some(trait_ref) => trait_ref,\n@@ -1787,8 +1784,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n     }\n }\n \n-/// Divides a list of general trait bounds into two groups: auto traits (e.g. Sync and Send) and the\n-/// remaining general trait bounds.\n+/// Divides a list of general trait bounds into two groups: auto traits (e.g., Sync and Send) and\n+/// the remaining general trait bounds.\n fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                          trait_bounds: &'b [hir::PolyTraitRef])\n     -> (Vec<DefId>, Vec<&'b hir::PolyTraitRef>)\n@@ -1828,7 +1825,7 @@ impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n     pub fn predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, param_ty: Ty<'tcx>)\n                       -> Vec<(ty::Predicate<'tcx>, Span)>\n     {\n-        // If it could be sized, and is, add the sized predicate\n+        // If it could be sized, and is, add the sized predicate.\n         let sized_predicate = self.implicitly_sized.and_then(|span| {\n             tcx.lang_items().sized_trait().map(|sized| {\n                 let trait_ref = ty::TraitRef {\n@@ -1841,8 +1838,8 @@ impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n \n         sized_predicate.into_iter().chain(\n             self.region_bounds.iter().map(|&(region_bound, span)| {\n-                // account for the binder being introduced below; no need to shift `param_ty`\n-                // because, at present at least, it can only refer to early-bound regions\n+                // Account for the binder being introduced below; no need to shift `param_ty`\n+                // because, at present at least, it can only refer to early-bound regions.\n                 let region_bound = ty::fold::shift_region(tcx, region_bound, 1);\n                 let outlives = ty::OutlivesPredicate(param_ty, region_bound);\n                 (ty::Binder::dummy(outlives).to_predicate(), span)"}, {"sha": "87ee903cf4302534164f84bf196b16045508097d", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -8,24 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use check::{FnCtxt, Expectation, Diverges, Needs};\n+use check::coercion::CoerceMany;\n use rustc::hir::{self, PatKind};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::infer;\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::ObligationCauseCode;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use check::{FnCtxt, Expectation, Diverges, Needs};\n-use check::coercion::CoerceMany;\n-use util::nodemap::FxHashMap;\n-\n-use std::collections::hash_map::Entry::{Occupied, Vacant};\n-use std::cmp;\n use syntax::ast;\n use syntax::source_map::Spanned;\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n+use util::nodemap::FxHashMap;\n+\n+use std::collections::hash_map::Entry::{Occupied, Vacant};\n+use std::cmp;\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// The `is_arg` argument indicates whether this pattern is the\n@@ -545,7 +545,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         // the \"discriminant type\" (issue #23116).\n         //\n         // arielb1 [writes here in this comment thread][c] that there\n-        // is certainly *some* potential danger, e.g. for an example\n+        // is certainly *some* potential danger, e.g., for an example\n         // like:\n         //\n         // [c]: https://github.com/rust-lang/rust/pull/43399#discussion_r130223956\n@@ -729,10 +729,10 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             return self.tcx.types.err;\n         };\n \n-        // Type check the path.\n+        // Type-check the path.\n         self.demand_eqtype(pat.span, expected, pat_ty);\n \n-        // Type check subpatterns.\n+        // Type-check subpatterns.\n         if self.check_struct_pat_fields(pat_ty, pat.id, pat.span, variant, fields, etc, def_bm) {\n             pat_ty\n         } else {\n@@ -771,7 +771,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             _ => bug!(\"unexpected pattern definition: {:?}\", def)\n         }\n \n-        // Type check the path.\n+        // Type-check the path.\n         let pat_ty = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.id).0;\n         self.demand_suptype(pat.span, expected, pat_ty);\n         pat_ty\n@@ -808,7 +808,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             return self.tcx.types.err;\n         }\n \n-        // Type check the path.\n+        // Type-check the path.\n         let (pat_ty, def) = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.id);\n         if !pat_ty.is_fn() {\n             report_unexpected_def(def);\n@@ -838,7 +838,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n \n         self.demand_eqtype(pat.span, expected, pat_ty);\n \n-        // Type check subpatterns.\n+        // Type-check subpatterns.\n         if subpats.len() == variant.fields.len() ||\n                 subpats.len() < variant.fields.len() && ddpos.is_some() {\n             let substs = match pat_ty.sty {"}, {"sha": "1b594342c9a7179944fc9f42c7c2fec7f6a476b5", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -203,7 +203,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n     }\n \n     /// also dereference through raw pointer types\n-    /// e.g. assuming ptr_to_Foo is the type `*const Foo`\n+    /// e.g., assuming ptr_to_Foo is the type `*const Foo`\n     /// fcx.autoderef(span, ptr_to_Foo)  => [*const Foo]\n     /// fcx.autoderef(span, ptr_to_Foo).include_raw_ptrs() => [*const Foo, Foo]\n     pub fn include_raw_pointers(mut self) -> Self {"}, {"sha": "e4ce04916ce6428322bee28fccd7fd0345e9dccf", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -38,7 +38,7 @@ pub fn check_legal_trait_for_method_call(tcx: TyCtxt, span: Span, trait_id: DefI\n enum CallStep<'tcx> {\n     Builtin(Ty<'tcx>),\n     DeferredClosure(ty::FnSig<'tcx>),\n-    /// e.g. enum variant constructors\n+    /// e.g., enum variant constructors\n     Overloaded(MethodCallee<'tcx>),\n }\n "}, {"sha": "51271f0f351202246b74bf1cb974380d269edf99", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -27,7 +27,7 @@\n //!\n //! where `&.T` and `*T` are references of either mutability,\n //! and where pointer_kind(`T`) is the kind of the unsize info\n-//! in `T` - the vtable for a trait definition (e.g. `fmt::Display` or\n+//! in `T` - the vtable for a trait definition (e.g., `fmt::Display` or\n //! `Iterator`, not `Iterator<Item=u8>`) or a length (or `()` if `T: Sized`).\n //!\n //! Note that lengths are not adjusted when casting raw slices -"}, {"sha": "be15503e47906e7e68ba5452b51010627f453628", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -266,7 +266,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::ObjectSafe(..) => None,\n                     ty::Predicate::ConstEvaluatable(..) => None,\n \n-                    // NB: This predicate is created by breaking down a\n+                    // N.B., this predicate is created by breaking down a\n                     // `ClosureType: FnFoo()` predicate, where\n                     // `ClosureType` represents some `Closure`. It can't\n                     // possibly be referring to the current closure,"}, {"sha": "8d844fe3a69e4e18d40fb34aed13b9fd4c958652", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -336,7 +336,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             //   the decision to region inference (and regionck, which will add\n             //   some more edges to this variable). However, this can wind up\n             //   creating a crippling number of variables in some cases --\n-            //   e.g. #32278 -- so we optimize one particular case [3].\n+            //   e.g., #32278 -- so we optimize one particular case [3].\n             //   Let me try to explain with some examples:\n             //   - The \"running example\" above represents the simple case,\n             //     where we have one `&` reference at the outer level and\n@@ -809,7 +809,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Special-case that coercion alone cannot handle:\n         // Two function item types of differing IDs or Substs.\n         if let (&ty::FnDef(..), &ty::FnDef(..)) = (&prev_ty.sty, &new_ty.sty) {\n-            // Don't reify if the function types have a LUB, i.e. they\n+            // Don't reify if the function types have a LUB, i.e., they\n             // are the same function and their parameters have a LUB.\n             let lub_ty = self.commit_if_ok(|_| {\n                 self.at(cause, self.param_env)"}, {"sha": "f4f6b3d661697898756ef90e650ec73792118a77", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -91,7 +91,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     // Checks that the type of `expr` can be coerced to `expected`.\n     //\n-    // NB: This code relies on `self.diverges` to be accurate. In\n+    // N.B., this code relies on `self.diverges` to be accurate. In\n     // particular, assignments to `!` will be permitted if the\n     // diverges flag is currently \"always\".\n     pub fn demand_coerce_diag(&self,"}, {"sha": "f59bc2d0c2dca929b4a06d5bc5362ece131e787c", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -32,7 +32,7 @@ use syntax_pos::Span;\n ///    coherence),\n ///\n /// 2. The generic region/type parameters of the impl's self-type must\n-///    all be parameters of the Drop impl itself (i.e. no\n+///    all be parameters of the Drop impl itself (i.e., no\n ///    specialization like `impl Drop for Foo<i32>`), and,\n ///\n /// 3. Any bounds on the generic parameters must be reflected in the\n@@ -180,7 +180,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n     //\n     //     self_to_impl_substs = {'c => 'z, 'b => 'y, 'a => 'x}\n     //\n-    // Applying this to the predicates (i.e. assumptions) provided by the item\n+    // Applying this to the predicates (i.e., assumptions) provided by the item\n     // definition yields the instantiated assumptions:\n     //\n     //     ['y : 'z]"}, {"sha": "5c0eef5b1f332818c60c5619379d7c6a1a0ac580", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -505,7 +505,7 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n // walk the expected type and the actual type in lock step, checking they're\n-// the same, in a kinda-structural way, i.e. `Vector`s have to be simd structs with\n+// the same, in a kinda-structural way, i.e., `Vector`s have to be simd structs with\n // exactly the right element type\n fn match_intrinsic_type_to_type<'a, 'tcx>(\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "11fb3889a748df933ec3e656108aeb82abf4662a", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -395,7 +395,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // Instantiate late-bound regions and substitute the trait\n         // parameters into the method type to get the actual method type.\n         //\n-        // NB: Instantiate late-bound regions first so that\n+        // N.B., instantiate late-bound regions first so that\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n         let method_sig = self.replace_bound_vars_with_fresh_vars(&sig);"}, {"sha": "858d8c742dfd9e11213058bf40cc967b6c3ab4b0", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -12,32 +12,29 @@\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/method-lookup.html\n \n+mod confirm;\n+pub mod probe;\n+mod suggest;\n+\n+pub use self::MethodError::*;\n+pub use self::CandidateSource::*;\n+pub use self::suggest::TraitInfo;\n+\n use check::FnCtxt;\n-use hir::def::Def;\n-use hir::def_id::DefId;\n use namespace::Namespace;\n-use rustc::ty::subst::Substs;\n+use rustc_data_structures::sync::Lrc;\n+use rustc::hir;\n+use rustc::hir::def::Def;\n+use rustc::hir::def_id::DefId;\n use rustc::traits;\n+use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, ToPredicate, ToPolyTraitRef, TraitRef, TypeFoldable};\n use rustc::ty::GenericParamDefKind;\n use rustc::ty::subst::Subst;\n use rustc::infer::{self, InferOk};\n-\n use syntax::ast;\n use syntax_pos::Span;\n \n-use rustc::hir;\n-\n-use rustc_data_structures::sync::Lrc;\n-\n-pub use self::MethodError::*;\n-pub use self::CandidateSource::*;\n-pub use self::suggest::TraitInfo;\n-\n-mod confirm;\n-pub mod probe;\n-mod suggest;\n-\n use self::probe::{IsSuggestion, ProbeScope};\n \n pub fn provide(providers: &mut ty::query::Providers) {\n@@ -50,7 +47,7 @@ pub struct MethodCallee<'tcx> {\n     pub def_id: DefId,\n     pub substs: &'tcx Substs<'tcx>,\n \n-    /// Instantiated method signature, i.e. it has been\n+    /// Instantiated method signature, i.e., it has been\n     /// substituted, normalized, and has had late-bound\n     /// lifetimes replaced with inference variables.\n     pub sig: ty::FnSig<'tcx>,\n@@ -107,8 +104,7 @@ impl<'tcx> NoMatchData<'tcx> {\n #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n pub enum CandidateSource {\n     ImplSource(DefId),\n-    TraitSource(// trait id\n-                DefId),\n+    TraitSource(DefId /* trait id */),\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n@@ -174,7 +170,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let import_def_id = self.tcx.hir().local_def_id(import_id);\n             debug!(\"used_trait_import: {:?}\", import_def_id);\n             Lrc::get_mut(&mut self.tables.borrow_mut().used_trait_imports)\n-                                        .unwrap().insert(import_def_id);\n+                .unwrap().insert(import_def_id);\n         }\n \n         self.tcx.check_stability(pick.item.def_id, Some(call_expr.id), span);\n@@ -239,7 +235,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// an obligation for a particular trait with the given self-type and checks\n     /// whether that trait is implemented.\n     ///\n-    /// FIXME(#18741) -- It seems likely that we can consolidate some of this\n+    /// FIXME(#18741): it seems likely that we can consolidate some of this\n     /// code with the other method-lookup code. In particular, the second half\n     /// of this method is basically the same as confirmation.\n     pub fn lookup_method_in_trait(&self,\n@@ -307,7 +303,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Instantiate late-bound regions and substitute the trait\n         // parameters into the method type to get the actual method type.\n         //\n-        // NB: Instantiate late-bound regions first so that\n+        // N.B., instantiate late-bound regions first so that\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n         let fn_sig = tcx.fn_sig(def_id);\n@@ -324,7 +320,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        // Register obligations for the parameters.  This will include the\n+        // Register obligations for the parameters. This will include the\n         // `Self` parameter, which in turn has a bound of the main trait,\n         // so this also effectively registers `obligation` as well.  (We\n         // used to register `obligation` explicitly, but that resulted in"}, {"sha": "dd3c022d53bb3ce45c622f2650250382b3b48004", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -41,7 +41,7 @@ use self::CandidateKind::*;\n pub use self::PickKind::*;\n \n /// Boolean flag used to indicate if this search is for a suggestion\n-/// or not.  If true, we can allow ambiguity and so forth.\n+/// or not. If true, we can allow ambiguity and so forth.\n #[derive(Clone, Copy)]\n pub struct IsSuggestion(pub bool);\n "}, {"sha": "b76c9101eae02b66f7aa9f565d5af1a4605f0149", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 95, "deletions": 100, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -12,29 +12,23 @@\n //! found or is otherwise invalid.\n \n use check::FnCtxt;\n-use rustc::hir::map as hir_map;\n-use hir::Node;\n-use rustc_data_structures::sync::Lrc;\n-use rustc::ty::{self, Ty, TyCtxt, ToPolyTraitRef, ToPredicate, TypeFoldable};\n-use rustc::ty::item_path::with_crate_prefix;\n-use hir::def::Def;\n-use hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use errors::{Applicability, DiagnosticBuilder};\n use middle::lang_items::FnOnceTraitLangItem;\n use namespace::Namespace;\n+use rustc_data_structures::sync::Lrc;\n+use rustc::hir::{self, Node};\n+use rustc::hir::def::Def;\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n+use rustc::hir::map as hir_map;\n+use rustc::hir::print;\n+use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::Obligation;\n+use rustc::ty::{self, Adt, Ty, TyCtxt, ToPolyTraitRef, ToPredicate, TypeFoldable};\n+use rustc::ty::item_path::with_crate_prefix;\n use util::nodemap::FxHashSet;\n-\n+use syntax_pos::{Span, FileName};\n use syntax::ast;\n use syntax::util::lev_distance::find_best_match_for_name;\n-use errors::{Applicability, DiagnosticBuilder};\n-use syntax_pos::{Span, FileName};\n-\n-\n-use rustc::hir::def_id::LOCAL_CRATE;\n-use rustc::hir;\n-use rustc::hir::print;\n-use rustc::infer::type_variable::TypeVariableOrigin;\n-use rustc::ty::Adt;\n \n use std::cmp::Ordering;\n \n@@ -45,12 +39,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn is_fn_ty(&self, ty: &Ty<'tcx>, span: Span) -> bool {\n         let tcx = self.tcx;\n         match ty.sty {\n-            // Not all of these (e.g. unsafe fns) implement FnOnce\n-            // so we look for these beforehand\n+            // Not all of these (e.g., unsafe fns) implement `FnOnce`,\n+            // so we look for these beforehand.\n             ty::Closure(..) |\n             ty::FnDef(..) |\n             ty::FnPtr(_) => true,\n-            // If it's not a simple function, look for things which implement FnOnce\n+            // If it's not a simple function, look for things which implement `FnOnce`.\n             _ => {\n                 let fn_once = match tcx.lang_items().require(FnOnceTraitLangItem) {\n                     Ok(fn_once) => fn_once,\n@@ -83,7 +77,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                rcvr_expr: Option<&hir::Expr>,\n                                error: MethodError<'tcx>,\n                                args: Option<&'gcx [hir::Expr]>) {\n-        // avoid suggestions when we don't know what's going on.\n+        // Avoid suggestions when we don't know what's going on.\n         if rcvr_ty.references_error() {\n             return;\n         }\n@@ -194,7 +188,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let tcx = self.tcx;\n \n                 let actual = self.resolve_type_vars_if_possible(&rcvr_ty);\n-                let ty_string = self.ty_to_string(actual);\n+                let ty_str = self.ty_to_string(actual);\n                 let is_method = mode == Mode::MethodCall;\n                 let mut suggestion = None;\n                 let item_kind = if is_method {\n@@ -239,15 +233,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             \"can't call {} `{}` on ambiguous numeric type `{}`\",\n                             item_kind,\n                             item_name,\n-                            ty_string\n+                            ty_str\n                         );\n                         let concrete_type = if actual.is_integral() {\n                             \"i32\"\n                         } else {\n                             \"f32\"\n                         };\n                         match expr.node {\n-                            hir::ExprKind::Lit(ref lit) => { // numeric literal\n+                            hir::ExprKind::Lit(ref lit) => {\n+                                // numeric literal\n                                 let snippet = tcx.sess.source_map().span_to_snippet(lit.span)\n                                     .unwrap_or_else(|_| \"<numeric literal>\".to_owned());\n \n@@ -262,7 +257,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                     Applicability::MaybeIncorrect,\n                                 );\n                             }\n-                            hir::ExprKind::Path(ref qpath) => {  // local binding\n+                            hir::ExprKind::Path(ref qpath) => {\n+                                // local binding\n                                 if let &hir::QPath::Resolved(_, ref path) = &qpath {\n                                     if let hir::def::Def::Local(node_id) = path.def {\n                                         let span = tcx.hir().span(node_id);\n@@ -313,10 +309,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             \"no {} named `{}` found for type `{}` in the current scope\",\n                             item_kind,\n                             item_name,\n-                            ty_string\n+                            ty_str\n                         );\n                         if let Some(suggestion) = suggestion {\n-                            err.note(&format!(\"did you mean `{}::{}`?\", ty_string, suggestion));\n+                            err.note(&format!(\"did you mean `{}::{}`?\", ty_str, suggestion));\n                         }\n                         err\n                     }\n@@ -339,7 +335,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 // If the method name is the name of a field with a function or closure type,\n-                // give a helping note that it has to be called as (x.f)(...).\n+                // give a helping note that it has to be called as `(x.f)(...)`.\n                 if let Some(expr) = rcvr_expr {\n                     for (ty, _) in self.autoderef(span, rcvr_ty) {\n                         if let ty::Adt(def, substs) = ty.sty {\n@@ -351,8 +347,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     let expr_string = match snippet {\n                                         Ok(expr_string) => expr_string,\n                                         _ => \"s\".into(), // Default to a generic placeholder for the\n-                                        // expression when we can't generate a\n-                                        // string snippet\n+                                                         // expression when we can't generate a\n+                                                         // string snippet.\n                                     };\n \n                                     let field_ty = field.ty(tcx, substs);\n@@ -380,7 +376,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                 } else {\n-                    err.span_label(span, format!(\"{} not found in `{}`\", item_kind, ty_string));\n+                    err.span_label(span, format!(\"{} not found in `{}`\", item_kind, ty_str));\n                 }\n \n                 if self.is_fn_ty(&rcvr_ty, span) {\n@@ -424,7 +420,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                     report_candidates(&mut err, static_sources);\n                 } else if static_sources.len() > 1 {\n-\n                     report_candidates(&mut err, static_sources);\n                 }\n \n@@ -509,7 +504,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let (span, found_use) = UsePlacementFinder::check(self.tcx, krate, module_id);\n         if let Some(span) = span {\n             let path_strings = candidates.iter().map(|did| {\n-                // produce an additional newline to separate the new use statement\n+                // Produce an additional newline to separate the new use statement\n                 // from the directly following item.\n                 let additional_newline = if found_use {\n                     \"\"\n@@ -597,15 +592,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let type_is_local = self.type_derefs_to_local(span, rcvr_ty, rcvr_expr);\n \n-        // there's no implemented traits, so lets suggest some traits to\n+        // There are no traits implemented, so lets suggest some traits to\n         // implement, by finding ones that have the item name, and are\n         // legal to implement.\n         let mut candidates = all_traits(self.tcx)\n             .into_iter()\n             .filter(|info| {\n-                // we approximate the coherence rules to only suggest\n+                // We approximate the coherence rules to only suggest\n                 // traits that are legal to implement by requiring that\n-                // either the type or trait is local. Multidispatch means\n+                // either the type or trait is local. Multi-dispatch means\n                 // this isn't perfect (that is, there are cases when\n                 // implementing a trait would be legal but is rejected\n                 // here).\n@@ -620,11 +615,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             .collect::<Vec<_>>();\n \n         if !candidates.is_empty() {\n-            // sort from most relevant to least relevant\n+            // Sort from most relevant to least relevant.\n             candidates.sort_by(|a, b| a.cmp(b).reverse());\n             candidates.dedup();\n \n-            // FIXME #21673 this help message could be tuned to the case\n+            // FIXME #21673: this help message could be tuned to the case\n             // of a type parameter: suggest adding a trait bound rather\n             // than implementing.\n             err.help(\"items from traits can only be used if the trait is implemented and in scope\");\n@@ -656,8 +651,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn type_derefs_to_local(&self,\n                             span: Span,\n                             rcvr_ty: Ty<'tcx>,\n-                            rcvr_expr: Option<&hir::Expr>)\n-                            -> bool {\n+                            rcvr_expr: Option<&hir::Expr>) -> bool {\n         fn is_local(ty: Ty) -> bool {\n             match ty.sty {\n                 ty::Adt(def, _) => def.did.is_local(),\n@@ -667,8 +661,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 ty::Param(_) => true,\n \n-                // everything else (primitive types etc.) is effectively\n-                // non-local (there are \"edge\" cases, e.g. (LocalType,), but\n+                // Everything else (primitive types, etc.) is effectively\n+                // non-local (there are \"edge\" cases, e.g., `(LocalType,)`, but\n                 // the noise from these sort of types is usually just really\n                 // annoying, rather than any sort of help).\n                 _ => false,\n@@ -703,8 +697,8 @@ impl PartialOrd for TraitInfo {\n }\n impl Ord for TraitInfo {\n     fn cmp(&self, other: &TraitInfo) -> Ordering {\n-        // local crates are more important than remote ones (local:\n-        // cnum == 0), and otherwise we throw in the defid for totality\n+        // Local crates are more important than remote ones (local:\n+        // `cnum == 0`), and otherwise we throw in the defid for totality.\n \n         let lhs = (other.def_id.krate, other.def_id);\n         let rhs = (self.def_id.krate, self.def_id);\n@@ -719,65 +713,65 @@ pub fn all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<TraitInfo>\n \n /// Compute all traits in this crate and any dependent crates.\n fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId> {\n-        use rustc::hir::itemlikevisit;\n+    use hir::itemlikevisit;\n \n-        let mut traits = vec![];\n+    let mut traits = vec![];\n \n-        // Crate-local:\n-        //\n-        // meh.\n-        struct Visitor<'a, 'tcx: 'a> {\n-            map: &'a hir_map::Map<'tcx>,\n-            traits: &'a mut Vec<DefId>,\n-        }\n-        impl<'v, 'a, 'tcx> itemlikevisit::ItemLikeVisitor<'v> for Visitor<'a, 'tcx> {\n-            fn visit_item(&mut self, i: &'v hir::Item) {\n-                if let hir::ItemKind::Trait(..) = i.node {\n-                    let def_id = self.map.local_def_id(i.id);\n-                    self.traits.push(def_id);\n-                }\n-            }\n+    // Crate-local:\n \n-            fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n-            }\n+    struct Visitor<'a, 'tcx: 'a> {\n+        map: &'a hir_map::Map<'tcx>,\n+        traits: &'a mut Vec<DefId>,\n+    }\n \n-            fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    impl<'v, 'a, 'tcx> itemlikevisit::ItemLikeVisitor<'v> for Visitor<'a, 'tcx> {\n+        fn visit_item(&mut self, i: &'v hir::Item) {\n+            if let hir::ItemKind::Trait(..) = i.node {\n+                let def_id = self.map.local_def_id(i.id);\n+                self.traits.push(def_id);\n             }\n         }\n-        tcx.hir().krate().visit_all_item_likes(&mut Visitor {\n-            map: &tcx.hir(),\n-            traits: &mut traits,\n-        });\n-\n-        // Cross-crate:\n-        let mut external_mods = FxHashSet::default();\n-        fn handle_external_def(tcx: TyCtxt,\n-                               traits: &mut Vec<DefId>,\n-                               external_mods: &mut FxHashSet<DefId>,\n-                               def: Def) {\n-            let def_id = def.def_id();\n-            match def {\n-                Def::Trait(..) => {\n-                    traits.push(def_id);\n+\n+        fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {}\n+\n+        fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {}\n+    }\n+\n+    tcx.hir().krate().visit_all_item_likes(&mut Visitor {\n+        map: &tcx.hir(),\n+        traits: &mut traits,\n+    });\n+\n+    // Cross-crate:\n+\n+    let mut external_mods = FxHashSet::default();\n+    fn handle_external_def(tcx: TyCtxt,\n+                           traits: &mut Vec<DefId>,\n+                           external_mods: &mut FxHashSet<DefId>,\n+                           def: Def) {\n+        let def_id = def.def_id();\n+        match def {\n+            Def::Trait(..) => {\n+                traits.push(def_id);\n+            }\n+            Def::Mod(..) => {\n+                if !external_mods.insert(def_id) {\n+                    return;\n                 }\n-                Def::Mod(..) => {\n-                    if !external_mods.insert(def_id) {\n-                        return;\n-                    }\n-                    for child in tcx.item_children(def_id).iter() {\n-                        handle_external_def(tcx, traits, external_mods, child.def)\n-                    }\n+                for child in tcx.item_children(def_id).iter() {\n+                    handle_external_def(tcx, traits, external_mods, child.def)\n                 }\n-                _ => {}\n             }\n+            _ => {}\n         }\n-        for &cnum in tcx.crates().iter() {\n-            let def_id = DefId {\n-                krate: cnum,\n-                index: CRATE_DEF_INDEX,\n-            };\n-            handle_external_def(tcx, &mut traits, &mut external_mods, Def::Mod(def_id));\n-        }\n+    }\n+    for &cnum in tcx.crates().iter() {\n+        let def_id = DefId {\n+            krate: cnum,\n+            index: CRATE_DEF_INDEX,\n+        };\n+        handle_external_def(tcx, &mut traits, &mut external_mods, Def::Mod(def_id));\n+    }\n \n     traits\n }\n@@ -827,29 +821,29 @@ impl<'a, 'tcx, 'gcx> hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'a, '\n             hir::intravisit::walk_mod(self, module, node_id);\n             return;\n         }\n-        // find a use statement\n+        // Find a `use` statement.\n         for item_id in &module.item_ids {\n             let item = self.tcx.hir().expect_item(item_id.id);\n             match item.node {\n                 hir::ItemKind::Use(..) => {\n-                    // don't suggest placing a use before the prelude\n-                    // import or other generated ones\n+                    // Don't suggest placing a `use` before the prelude\n+                    // import or other generated ones.\n                     if item.span.ctxt().outer().expn_info().is_none() {\n                         self.span = Some(item.span.shrink_to_lo());\n                         self.found_use = true;\n                         return;\n                     }\n                 },\n-                // don't place use before extern crate\n+                // Don't place `use` before `extern crate`...\n                 hir::ItemKind::ExternCrate(_) => {}\n-                // but place them before the first other item\n+                // ...but do place them before the first other item.\n                 _ => if self.span.map_or(true, |span| item.span < span ) {\n                     if item.span.ctxt().outer().expn_info().is_none() {\n-                        // don't insert between attributes and an item\n+                        // Don't insert between attributes and an item.\n                         if item.attrs.is_empty() {\n                             self.span = Some(item.span.shrink_to_lo());\n                         } else {\n-                            // find the first attribute on the item\n+                            // Find the first attribute on the item.\n                             for attr in &item.attrs {\n                                 if self.span.map_or(true, |span| attr.span < span) {\n                                     self.span = Some(attr.span.shrink_to_lo());\n@@ -861,6 +855,7 @@ impl<'a, 'tcx, 'gcx> hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'a, '\n             }\n         }\n     }\n+\n     fn nested_visit_map<'this>(\n         &'this mut self\n     ) -> hir::intravisit::NestedVisitorMap<'this, 'tcx> {"}, {"sha": "8901f4b6b291bdf2f68b08d88e60fb166999d129", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 69, "deletions": 74, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*\n+/*!\n \n # check.rs\n \n Within the check phase of type check, we check each item one at a time\n (bodies of function expressions are checked as part of the containing\n-function).  Inference is used to supply types wherever they are\n-unknown.\n+function). Inference is used to supply types wherever they are unknown.\n \n By far the most complex case is checking the body of a function. This\n can be broken down into several distinct phases:\n@@ -65,7 +64,7 @@ nodes within the function.\n The types of top-level items, which never contain unbound type\n variables, are stored directly into the `tcx` tables.\n \n-N.B.: A type variable is not the same thing as a type parameter.  A\n+N.B., a type variable is not the same thing as a type parameter.  A\n type variable is rather an \"instance\" of a type parameter: that is,\n given a generic function `fn foo<T>(t: T)`: while checking the\n function `foo`, the type `ty_param(0)` refers to the type `T`, which\n@@ -76,20 +75,36 @@ type parameter).\n \n */\n \n-pub use self::Expectation::*;\n-use self::autoderef::Autoderef;\n-use self::callee::DeferredCallResolution;\n-use self::coercion::{CoerceMany, DynamicCoerceMany};\n-pub use self::compare_method::{compare_impl_method, compare_const_impl};\n-use self::method::MethodCallee;\n-use self::TupleArgumentsFlag::*;\n+mod autoderef;\n+pub mod dropck;\n+pub mod _match;\n+pub mod writeback;\n+mod regionck;\n+pub mod coercion;\n+pub mod demand;\n+pub mod method;\n+mod upvar;\n+mod wfcheck;\n+mod cast;\n+mod closure;\n+mod callee;\n+mod compare_method;\n+mod generator_interior;\n+mod intrinsic;\n+mod op;\n \n use astconv::AstConv;\n-use hir::GenericArg;\n-use hir::def::Def;\n-use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use std::slice;\n+use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n+use rustc::hir::{self, GenericArg, Node, ItemKind, PatKind};\n+use rustc::hir::def::Def;\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use middle::lang_items;\n use namespace::Namespace;\n+use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::sync::Lrc;\n+use rustc_target::spec::abi::Abi;\n use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin};\n use rustc::infer::opaque_types::OpaqueTypeDecl;\n use rustc::infer::type_variable::{TypeVariableOrigin};\n@@ -104,58 +119,38 @@ use rustc::ty::fold::TypeFoldable;\n use rustc::ty::query::Providers;\n use rustc::ty::util::{Representability, IntTypeExt, Discr};\n use rustc::ty::layout::VariantIdx;\n-use rustc_data_structures::indexed_vec::Idx;\n-use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n-\n-use require_c_abi_if_variadic;\n-use session::{CompileIncomplete, config, Session};\n-use TypeAndSubsts;\n-use lint;\n-use util::common::{ErrorReported, indenter};\n-use util::nodemap::{DefIdMap, DefIdSet, FxHashMap, FxHashSet, NodeMap};\n+use syntax_pos::{self, BytePos, Span, MultiSpan};\n+use syntax::ast;\n+use syntax::attr;\n+use syntax::feature_gate::{GateIssue, emit_feature_err};\n+use syntax::ptr::P;\n+use syntax::source_map::{DUMMY_SP, original_sp};\n+use syntax::symbol::{Symbol, LocalInternedString, keywords};\n+use syntax::util::lev_distance::find_best_match_for_name;\n \n use std::cell::{Cell, RefCell, Ref, RefMut};\n-use rustc_data_structures::sync::Lrc;\n use std::collections::hash_map::Entry;\n use std::cmp;\n use std::fmt::Display;\n use std::iter;\n use std::mem::replace;\n use std::ops::{self, Deref};\n-use rustc_target::spec::abi::Abi;\n-use syntax::ast;\n-use syntax::attr;\n-use syntax::source_map::DUMMY_SP;\n-use syntax::source_map::original_sp;\n-use syntax::feature_gate::{GateIssue, emit_feature_err};\n-use syntax::ptr::P;\n-use syntax::symbol::{Symbol, LocalInternedString, keywords};\n-use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax_pos::{self, BytePos, Span, MultiSpan};\n+use std::slice;\n \n-use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::hir::Node;\n-use rustc::hir::{self, PatKind, ItemKind};\n-use rustc::middle::lang_items;\n+use require_c_abi_if_variadic;\n+use session::{CompileIncomplete, config, Session};\n+use TypeAndSubsts;\n+use lint;\n+use util::common::{ErrorReported, indenter};\n+use util::nodemap::{DefIdMap, DefIdSet, FxHashMap, FxHashSet, NodeMap};\n \n-mod autoderef;\n-pub mod dropck;\n-pub mod _match;\n-pub mod writeback;\n-mod regionck;\n-pub mod coercion;\n-pub mod demand;\n-pub mod method;\n-mod upvar;\n-mod wfcheck;\n-mod cast;\n-mod closure;\n-mod callee;\n-mod compare_method;\n-mod generator_interior;\n-mod intrinsic;\n-mod op;\n+pub use self::Expectation::*;\n+use self::autoderef::Autoderef;\n+use self::callee::DeferredCallResolution;\n+use self::coercion::{CoerceMany, DynamicCoerceMany};\n+pub use self::compare_method::{compare_impl_method, compare_const_impl};\n+use self::method::MethodCallee;\n+use self::TupleArgumentsFlag::*;\n \n /// The type of a local binding, including the revealed type for anon types.\n #[derive(Copy, Clone)]\n@@ -2858,10 +2853,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                formal_tys.iter().map(|t| self.ty_to_string(*t)).collect::<Vec<String>>());\n \n         // Check the arguments.\n-        // We do this in a pretty awful way: first we typecheck any arguments\n-        // that are not closures, then we typecheck the closures. This is so\n+        // We do this in a pretty awful way: first we type-check any arguments\n+        // that are not closures, then we type-check the closures. This is so\n         // that we have more information about the types of arguments when we\n-        // typecheck the functions. This isn't really the right way to do this.\n+        // type-check the functions. This isn't really the right way to do this.\n         for &check_closures in &[false, true] {\n             debug!(\"check_closures={}\", check_closures);\n \n@@ -2885,7 +2880,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             for (i, arg) in args.iter().take(t).enumerate() {\n                 // Warn only for the first loop (the \"no closures\" one).\n                 // Closure arguments themselves can't be diverging, but\n-                // a previous argument can, e.g. `foo(panic!(), || {})`.\n+                // a previous argument can, e.g., `foo(panic!(), || {})`.\n                 if !check_closures {\n                     self.warn_if_unreachable(arg.id, arg.span, \"expression\");\n                 }\n@@ -3092,9 +3087,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.check_expr_with_expectation_and_needs(expr, NoExpectation, needs)\n     }\n \n-    // determine the `self` type, using fresh variables for all variables\n+    // Determine the `Self` type, using fresh variables for all variables\n     // declared on the impl declaration e.g., `impl<A,B> for Vec<(A,B)>`\n-    // would return ($0, $1) where $0 and $1 are freshly instantiated type\n+    // would return `($0, $1)` where `$0` and `$1` are freshly instantiated type\n     // variables.\n     pub fn impl_self_ty(&self,\n                         span: Span, // (potential) receiver for this impl\n@@ -3539,16 +3534,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let mut error_happened = false;\n \n-        // Typecheck each field.\n+        // Type-check each field.\n         for field in ast_fields {\n             let ident = tcx.adjust_ident(field.ident, variant.did, self.body_id).0;\n             let field_type = if let Some((i, v_field)) = remaining_fields.remove(&ident) {\n                 seen_fields.insert(ident, field.span);\n                 self.write_field_index(field.id, i);\n \n-                // we don't look at stability attributes on\n+                // We don't look at stability attributes on\n                 // struct-like enums (yet...), but it's definitely not\n-                // a bug to have construct one.\n+                // a bug to have constructed one.\n                 if adt_kind != ty::AdtKind::Enum {\n                     tcx.check_stability(v_field.did, Some(expr_id), field.span);\n                 }\n@@ -3575,7 +3570,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             // Make sure to give a type to the field even if there's\n-            // an error, so we can continue typechecking\n+            // an error, so we can continue type-checking.\n             self.check_expr_coercable_to_type(&field.expr, field_type);\n         }\n \n@@ -3707,7 +3702,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::QPath::TypeRelative(ref qself, _) => qself.span\n         };\n \n-        // Prohibit struct expressions when non exhaustive flag is set.\n+        // Prohibit struct expressions when non-exhaustive flag is set.\n         let adt = adt_ty.ty_adt_def().expect(\"`check_struct_path` returned non-ADT type\");\n         if !adt.did.is_local() && variant.is_field_list_non_exhaustive() {\n             span_err!(self.tcx.sess, expr.span, E0639,\n@@ -3760,7 +3755,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                              expr: &'gcx hir::Expr,\n                                              expected: Expectation<'tcx>,\n                                              needs: Needs) -> Ty<'tcx> {\n-        debug!(\">> typechecking: expr={:?} expected={:?}\",\n+        debug!(\">> type-checking: expr={:?} expected={:?}\",\n                expr, expected);\n \n         // Warn for expressions after diverging siblings.\n@@ -3962,7 +3957,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if !tcx.features().unsized_locals {\n                         // We want to remove some Sized bounds from std functions,\n                         // but don't want to expose the removal to stable Rust.\n-                        // i.e. we don't want to allow\n+                        // i.e., we don't want to allow\n                         //\n                         // ```rust\n                         // drop as fn(str);\n@@ -4086,7 +4081,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             }\n                         }\n                     }\n-                    // There was an error, make typecheck fail\n+                    // There was an error; make type-check fail.\n                     tcx.types.err\n                 }\n \n@@ -4095,7 +4090,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if destination.target_id.is_ok() {\n                     tcx.types.never\n                 } else {\n-                    // There was an error, make typecheck fail\n+                    // There was an error; make type-check fail.\n                     tcx.types.err\n                 }\n             }\n@@ -4413,7 +4408,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 }\n                                 if needs_note {\n                                     err.help(\"to access tuple elements, use tuple indexing \\\n-                                              syntax (e.g. `tuple.0`)\");\n+                                              syntax (e.g., `tuple.0`)\");\n                                 }\n                             }\n                             err.emit();\n@@ -5249,7 +5244,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         assert!(!substs.has_escaping_bound_vars());\n         assert!(!ty.has_escaping_bound_vars());\n \n-        // Write the \"user substs\" down first thing for later.\n+        // First, store the \"user substs\" for later.\n         let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n         self.write_user_substs_from_substs(hir_id, substs, user_self_ty);\n "}, {"sha": "c40789ce8bae0b3242f5e462852ea2cd598963f1", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -170,7 +170,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // Find a suitable supertype of the LHS expression's type, by coercing to\n                 // a type variable, to pass as the `Self` to the trait, avoiding invariant\n                 // trait matching creating lifetime constraints that are too strict.\n-                // E.g. adding `&'a T` and `&'b T`, given `&'x T: Add<&'x T>`, will result\n+                // e.g., adding `&'a T` and `&'b T`, given `&'x T: Add<&'x T>`, will result\n                 // in `&'a T <: &'x T` and `&'b T <: &'x T`, instead of `'a = 'b = 'x`.\n                 let lhs_ty = self.check_expr_with_needs(lhs_expr, Needs::None);\n                 let fresh_var = self.next_ty_var(TypeVariableOrigin::MiscVariable(lhs_expr.span));\n@@ -186,7 +186,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n         let lhs_ty = self.resolve_type_vars_with_obligations(lhs_ty);\n \n-        // NB: As we have not yet type-checked the RHS, we don't have the\n+        // N.B., as we have not yet type-checked the RHS, we don't have the\n         // type at hand. Make a variable to represent it. The whole reason\n         // for this indirection is so that, below, we can check the expr\n         // using this variable as the expected type, which sometimes lets\n@@ -318,7 +318,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     self.check_str_addition(expr, lhs_expr, rhs_expr, lhs_ty,\n                                                             rhs_ty, &mut err, true) {\n                                     // This has nothing here because it means we did string\n-                                    // concatenation (e.g. \"Hello \" += \"World!\"). This means\n+                                    // concatenation (e.g., \"Hello \" += \"World!\"). This means\n                                     // we don't want the note in the else clause to be emitted\n                                 } else if let ty::Param(_) = lhs_ty.sty {\n                                     // FIXME: point to span of param\n@@ -392,7 +392,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     self.check_str_addition(expr, lhs_expr, rhs_expr, lhs_ty,\n                                                             rhs_ty, &mut err, false) {\n                                     // This has nothing here because it means we did string\n-                                    // concatenation (e.g. \"Hello \" + \"World!\"). This means\n+                                    // concatenation (e.g., \"Hello \" + \"World!\"). This means\n                                     // we don't want the note in the else clause to be emitted\n                                 } else if let ty::Param(_) = lhs_ty.sty {\n                                     // FIXME: point to span of param\n@@ -682,7 +682,7 @@ enum Op {\n     Unary(hir::UnOp, Span),\n }\n \n-/// Returns true if this is a built-in arithmetic operation (e.g. u32\n+/// Returns true if this is a built-in arithmetic operation (e.g., u32\n /// + u32, i16x4 == i16x4) and false if these types would have to be\n /// overloaded to be legal. There are two reasons that we distinguish\n /// builtin operations from overloaded ones (vs trying to drive"}, {"sha": "2d5dcf0ec1b6dbe311f45260eebcfc5ba9634992", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -469,15 +469,15 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n                         // variance where possible. (This is because\n                         // we may have to evaluate constraint\n                         // expressions in the course of execution.)\n-                        // See e.g. #41936.\n+                        // See e.g., #41936.\n                         if let Ok(ok) = infcx.at(&cause, param_env).eq(a, b) {\n                             if ok.obligations.is_empty() {\n                                 return None;\n                             }\n                         }\n \n                         // Collect up all fields that were significantly changed\n-                        // i.e. those that contain T in coerce_unsized T -> U\n+                        // i.e., those that contain T in coerce_unsized T -> U\n                         Some((i, a, b))\n                     })\n                     .collect::<Vec<_>>();"}, {"sha": "0360617be3c491776b5f3d94245367e74ff6108d", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -40,7 +40,7 @@ fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n                tcx.item_path_str(impl_def_id));\n \n         // Skip impls where one of the self type is an error type.\n-        // This occurs with e.g. resolve failures (#30589).\n+        // This occurs with e.g., resolve failures (#30589).\n         if trait_ref.references_error() {\n             return;\n         }"}, {"sha": "131413eb402d4ad3fc6d9a99592dc9e39635266a", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -60,7 +60,7 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                                      sp,\n                                      E0210,\n                                      \"type parameter `{}` must be used as the type parameter \\\n-                                      for some local type (e.g. `MyStruct<{}>`)\",\n+                                      for some local type (e.g., `MyStruct<{}>`)\",\n                                      param_ty,\n                                      param_ty)\n                         .span_label(sp,"}, {"sha": "3b8b6d47d913085d873533b22e1dbf90200dc374", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -97,7 +97,7 @@ pub fn provide(providers: &mut Providers) {\n /// AstConv. It has information about the predicates that are defined\n /// on the trait. Unfortunately, this predicate information is\n /// available in various different forms at various points in the\n-/// process. So we can't just store a pointer to e.g. the AST or the\n+/// process. So we can't just store a pointer to e.g., the AST or the\n /// parsed ty form, we have to be more flexible. To this end, the\n /// `ItemCtxt` is parameterized by a `DefId` that it uses to satisfy\n /// `get_type_parameter_bounds` requests, drawing the information from\n@@ -704,16 +704,16 @@ fn super_predicates_of<'a, 'tcx>(\n \n     let icx = ItemCtxt::new(tcx, trait_def_id);\n \n-    // Convert the bounds that follow the colon, e.g. `Bar + Zed` in `trait Foo : Bar + Zed`.\n+    // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo : Bar + Zed`.\n     let self_param_ty = tcx.mk_self_type();\n     let superbounds1 = compute_bounds(&icx, self_param_ty, bounds, SizedByDefault::No, item.span);\n \n     let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n \n     // Convert any explicit superbounds in the where clause,\n-    // e.g. `trait Foo where Self : Bar`.\n+    // e.g., `trait Foo where Self : Bar`.\n     // In the case of trait aliases, however, we include all bounds in the where clause,\n-    // so e.g. `trait Foo = where u32: PartialEq<Self>` would include `u32: PartialEq<Self>`\n+    // so e.g., `trait Foo = where u32: PartialEq<Self>` would include `u32: PartialEq<Self>`\n     // as one of its \"superpredicates\".\n     let is_trait_alias = ty::is_trait_alias(tcx, trait_def_id);\n     let superbounds2 = icx.type_parameter_bounds_in_generics(\n@@ -1715,7 +1715,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n                 let substs = Substs::identity_for_item(tcx, def_id);\n                 let opaque_ty = tcx.mk_opaque(def_id, substs);\n \n-                // Collect the bounds, i.e. the `A+B+'c` in `impl A+B+'c`.\n+                // Collect the bounds, i.e., the `A+B+'c` in `impl A+B+'c`.\n                 let bounds = compute_bounds(\n                     &icx,\n                     opaque_ty,\n@@ -1760,7 +1760,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n                     let substs = Substs::identity_for_item(tcx, def_id);\n                     let opaque_ty = tcx.mk_opaque(def_id, substs);\n \n-                    // Collect the bounds, i.e. the `A+B+'c` in `impl A+B+'c`.\n+                    // Collect the bounds, i.e., the `A+B+'c` in `impl A+B+'c`.\n                     let bounds = compute_bounds(\n                         &icx,\n                         opaque_ty,"}, {"sha": "25fa33ef9fa4e5f0467ae6bce22aa4b20a621c89", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -37,7 +37,7 @@ pub fn parameters_for_impl<'tcx>(impl_self_ty: Ty<'tcx>,\n }\n \n /// If `include_projections` is false, returns the list of parameters that are\n-/// constrained by `t` - i.e. the value of each parameter in the list is\n+/// constrained by `t` - i.e., the value of each parameter in the list is\n /// uniquely determined by `t` (see RFC 447). If it is true, return the list\n /// of parameters whose values are needed in order to constrain `ty` - these\n /// differ, with the latter being a superset, in the presence of projections."}, {"sha": "a0dbaf5ad504bcd60ddf74fa038a3caf94f71628", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -655,7 +655,7 @@ For example, a function like:\n fn f(a: u16, b: &str) {}\n ```\n \n-Must always be called with exactly two arguments, e.g. `f(2, \"test\")`.\n+Must always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n \n Note that Rust does not have a notion of optional function arguments or\n variadic functions (except for its C-FFI).\n@@ -1610,7 +1610,7 @@ it has been disabled for now.\n \n E0185: r##\"\n An associated function for a trait was defined to be static, but an\n-implementation of the trait declared the same function to be a method (i.e. to\n+implementation of the trait declared the same function to be a method (i.e., to\n take a `self` parameter).\n \n Here's an example of this error:\n@@ -1631,7 +1631,7 @@ impl Foo for Bar {\n \"##,\n \n E0186: r##\"\n-An associated function for a trait was defined to be a method (i.e. to take a\n+An associated function for a trait was defined to be a method (i.e., to take a\n `self` parameter), but an implementation of the trait declared the same function\n to be static.\n "}, {"sha": "8d6fb8b7f39485c43e938887e94391c8afdc40f5", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 32, "deletions": 34, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -10,24 +10,24 @@\n \n /*!\n \n-typeck.rs, an introduction\n+# typeck.rs\n \n The type checker is responsible for:\n \n-1. Determining the type of each expression\n-2. Resolving methods and traits\n-3. Guaranteeing that most type rules are met (\"most?\", you say, \"why most?\"\n+1. Determining the type of each expression.\n+2. Resolving methods and traits.\n+3. Guaranteeing that most type rules are met. (\"Most?\", you say, \"why most?\"\n    Well, dear reader, read on)\n \n-The main entry point is `check_crate()`.  Type checking operates in\n+The main entry point is `check_crate()`. Type checking operates in\n several major phases:\n \n 1. The collect phase first passes over all items and determines their\n    type, without examining their \"innards\".\n \n-2. Variance inference then runs to compute the variance of each parameter\n+2. Variance inference then runs to compute the variance of each parameter.\n \n-3. Coherence checks for overlapping or orphaned impls\n+3. Coherence checks for overlapping or orphaned impls.\n \n 4. Finally, the check phase then checks function bodies and so forth.\n    Within the check phase, we check each function body one at a time\n@@ -41,12 +41,12 @@ The type checker is defined into various submodules which are documented\n independently:\n \n - astconv: converts the AST representation of types\n-  into the `ty` representation\n+  into the `ty` representation.\n \n - collect: computes the types of each top-level item and enters them into\n-  the `tcx.types` table for later use\n+  the `tcx.types` table for later use.\n \n-- coherence: enforces coherence rules, builds some tables\n+- coherence: enforces coherence rules, builds some tables.\n \n - variance: variance inference\n \n@@ -59,7 +59,7 @@ independently:\n   all subtyping and assignment constraints are met.  In essence, the check\n   module specifies the constraints, and the infer module solves them.\n \n-# Note\n+## Note\n \n This API is completely unstable and subject to change.\n \n@@ -97,29 +97,7 @@ extern crate rustc_errors as errors;\n extern crate rustc_target;\n extern crate smallvec;\n \n-use rustc::hir;\n-use rustc::lint;\n-use rustc::middle;\n-use rustc::session;\n-use rustc::util;\n-\n-use hir::Node;\n-use rustc::infer::InferOk;\n-use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::query::Providers;\n-use rustc::traits::{ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt};\n-use rustc::util::profiling::ProfileCategory;\n-use session::{CompileIncomplete, config};\n-use util::common::time;\n-\n-use syntax::ast;\n-use rustc_target::spec::abi::Abi;\n-use syntax_pos::Span;\n-\n-use std::iter;\n-\n-// NB: This module needs to be declared first so diagnostics are\n+// N.B., this module needs to be declared first so diagnostics are\n // registered before they are used.\n mod diagnostics;\n \n@@ -135,6 +113,26 @@ mod namespace;\n mod outlives;\n mod variance;\n \n+use hir::Node;\n+use rustc_target::spec::abi::Abi;\n+use rustc::hir;\n+use rustc::infer::InferOk;\n+use rustc::lint;\n+use rustc::middle;\n+use rustc::session;\n+use rustc::traits::{ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt};\n+use rustc::ty::subst::Substs;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::query::Providers;\n+use rustc::util;\n+use rustc::util::profiling::ProfileCategory;\n+use session::{CompileIncomplete, config};\n+use syntax_pos::Span;\n+use syntax::ast;\n+use util::common::time;\n+\n+use std::iter;\n+\n pub struct TypeAndSubsts<'tcx> {\n     substs: &'tcx Substs<'tcx>,\n     ty: Ty<'tcx>,"}, {"sha": "315e5feea3fcfb4e55d256d903789b6a0523b7b2", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -314,7 +314,7 @@ pub fn check_explicit_predicates<'tcx>(\n         // case that `substs` come from a `dyn Trait` type, our caller will have\n         // included `Self = usize` as the value for `Self`. If we were\n         // to apply the substs, and not filter this predicate, we might then falsely\n-        // conclude that e.g. `X: 'x` was a reasonable inferred requirement.\n+        // conclude that e.g., `X: 'x` was a reasonable inferred requirement.\n         //\n         // Another similar case is where we have a inferred\n         // requirement like `<Self as Trait>::Foo: 'b`. We presently"}, {"sha": "6ea919469e04bf7fe1e5a9f821f2e3d421264d80", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -44,7 +44,7 @@ pub struct Constraint<'a> {\n }\n \n /// To build constraints, we visit one item (type, trait) at a time\n-/// and look at its contents. So e.g. if we have\n+/// and look at its contents. So e.g., if we have\n ///\n ///     struct Foo<T> {\n ///         b: Bar<T>"}, {"sha": "75ff5bb0c5405ebf7e77df274d74af4f2fb147c7", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -125,7 +125,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n         let newly_added = self.inferred_starts.insert(id, InferredIndex(start)).is_none();\n         assert!(newly_added);\n \n-        // NB: In the code below for writing the results back into the\n+        // N.B., in the code below for writing the results back into the\n         // `CrateVariancesMap`, we rely on the fact that all inferreds\n         // for a particular item are assigned continuous indices.\n "}, {"sha": "ac9680b4570c69eaa58b26dc4b878911e5ddfd6b", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -255,7 +255,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n     // handle_lifetimes determines what *needs be* true in order for an impl to hold.\n     // lexical_region_resolve, along with much of the rest of the compiler, is concerned\n     // with determining if a given set up constraints/predicates *are* met, given some\n-    // starting conditions (e.g. user-provided code). For this reason, it's easier\n+    // starting conditions (e.g., user-provided code). For this reason, it's easier\n     // to perform the calculations we need on our own, rather than trying to make\n     // existing inference/solver code do what we want.\n     fn handle_lifetimes<'cx>(\n@@ -274,7 +274,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n         // Flattening is done in two parts. First, we insert all of the constraints\n         // into a map. Each RegionTarget (either a RegionVid or a Region) maps\n         // to its smaller and larger regions. Note that 'larger' regions correspond\n-        // to sub-regions in Rust code (e.g. in 'a: 'b, 'a is the larger region).\n+        // to sub-regions in Rust code (e.g., in 'a: 'b, 'a is the larger region).\n         for constraint in regions.constraints.keys() {\n             match constraint {\n                 &Constraint::VarSubVar(r1, r2) => {\n@@ -524,7 +524,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n     // display on the docs page. Cleaning the Predicates produces sub-optimal WherePredicate's,\n     // so we fix them up:\n     //\n-    // * Multiple bounds for the same type are coalesced into one: e.g. 'T: Copy', 'T: Debug'\n+    // * Multiple bounds for the same type are coalesced into one: e.g., 'T: Copy', 'T: Debug'\n     // becomes 'T: Copy + Debug'\n     // * Fn bounds are handled specially - instead of leaving it as 'T: Fn(), <T as Fn::Output> =\n     // K', we use the dedicated syntax 'T: Fn() -> K'\n@@ -545,7 +545,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n         );\n \n         // The `Sized` trait must be handled specially, since we only only display it when\n-        // it is *not* required (i.e. '?Sized')\n+        // it is *not* required (i.e., '?Sized')\n         let sized_trait = self.cx\n             .tcx\n             .require_lang_item(lang_items::SizedTraitLangItem);\n@@ -629,7 +629,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n                         let is_fn = match &mut b {\n                             &mut GenericBound::TraitBound(ref mut p, _) => {\n                                 // Insert regions into the for_generics hash map first, to ensure\n-                                // that we don't end up with duplicate bounds (e.g. for<'b, 'b>)\n+                                // that we don't end up with duplicate bounds (e.g., for<'b, 'b>)\n                                 for_generics.extend(p.generic_params.clone());\n                                 p.generic_params = for_generics.into_iter().collect();\n                                 self.is_fn_ty(&tcx, &p.trait_)\n@@ -737,7 +737,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n                                         hir::TraitBoundModifier::None,\n                                     ));\n \n-                                    // Remove any existing 'plain' bound (e.g. 'T: Iterator`) so\n+                                    // Remove any existing 'plain' bound (e.g., 'T: Iterator`) so\n                                     // that we don't see a\n                                     // duplicate bound like `T: Iterator + Iterator<Item=u8>`\n                                     // on the docs page.\n@@ -837,7 +837,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n     // auto-trait impls always render in exactly the same way.\n     //\n     // Using the Debug implementation for sorting prevents us from needing to\n-    // write quite a bit of almost entirely useless code (e.g. how should two\n+    // write quite a bit of almost entirely useless code (e.g., how should two\n     // Types be sorted relative to each other). It also allows us to solve the\n     // problem for both WherePredicates and GenericBounds at the same time. This\n     // approach is probably somewhat slower, but the small number of items"}, {"sha": "847786d123efc5cd28919880d9534309aeb7f673", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -31,13 +31,13 @@ pub enum Cfg {\n     True,\n     /// Denies all configurations.\n     False,\n-    /// A generic configuration option, e.g. `test` or `target_os = \"linux\"`.\n+    /// A generic configuration option, e.g., `test` or `target_os = \"linux\"`.\n     Cfg(Symbol, Option<Symbol>),\n-    /// Negate a configuration requirement, i.e. `not(x)`.\n+    /// Negate a configuration requirement, i.e., `not(x)`.\n     Not(Box<Cfg>),\n-    /// Union of a list of configuration requirements, i.e. `any(...)`.\n+    /// Union of a list of configuration requirements, i.e., `any(...)`.\n     Any(Vec<Cfg>),\n-    /// Intersection of a list of configuration requirements, i.e. `all(...)`.\n+    /// Intersection of a list of configuration requirements, i.e., `all(...)`.\n     All(Vec<Cfg>),\n }\n \n@@ -61,7 +61,7 @@ impl Cfg {\n \n     /// Parses a `MetaItem` into a `Cfg`.\n     ///\n-    /// The `MetaItem` should be the content of the `#[cfg(...)]`, e.g. `unix` or\n+    /// The `MetaItem` should be the content of the `#[cfg(...)]`, e.g., `unix` or\n     /// `target_os = \"redox\"`.\n     ///\n     /// If the content is not properly formatted, it will return an error indicating what and where"}, {"sha": "64f66d55fc63d94fab7ff2c6c1f4bb991efae94f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -11,47 +11,46 @@\n //! This module contains the \"cleaned\" pieces of the AST, and the functions\n //! that clean them.\n \n-pub use self::Type::*;\n-pub use self::Mutability::*;\n-pub use self::ItemEnum::*;\n-pub use self::SelfTy::*;\n-pub use self::FunctionRetTy::*;\n-pub use self::Visibility::{Public, Inherited};\n+pub mod inline;\n+pub mod cfg;\n+mod simplify;\n+mod auto_trait;\n+mod blanket_impl;\n+pub mod def_ctor;\n \n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use rustc_data_structures::sync::Lrc;\n use rustc_target::spec::abi::Abi;\n-use syntax::ast::{self, AttrStyle, Ident};\n-use syntax::attr;\n-use syntax::ext::base::MacroKind;\n-use syntax::source_map::{dummy_spanned, Spanned};\n-use syntax::ptr::P;\n-use syntax::symbol::keywords::{self, Keyword};\n-use syntax::symbol::InternedString;\n-use syntax_pos::{self, DUMMY_SP, Pos, FileName};\n-\n+use rustc_typeck::hir_ty_to_ty;\n+use rustc::infer::region_constraints::{RegionConstraintData, Constraint};\n use rustc::mir::interpret::ConstValue;\n use rustc::middle::resolve_lifetime as rl;\n-use rustc::ty::fold::TypeFolder;\n use rustc::middle::lang_items;\n+use rustc::middle::stability;\n use rustc::mir::interpret::GlobalId;\n use rustc::hir::{self, GenericArg, HirVec};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, TyCtxt, Region, RegionVid, Ty, AdtKind};\n+use rustc::ty::fold::TypeFolder;\n use rustc::ty::layout::VariantIdx;\n-use rustc::middle::stability;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n-use rustc_typeck::hir_ty_to_ty;\n-use rustc::infer::region_constraints::{RegionConstraintData, Constraint};\n-use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use syntax::ast::{self, AttrStyle, Ident};\n+use syntax::attr;\n+use syntax::ext::base::MacroKind;\n+use syntax::source_map::{dummy_spanned, Spanned};\n+use syntax::ptr::P;\n+use syntax::symbol::keywords::{self, Keyword};\n+use syntax::symbol::InternedString;\n+use syntax_pos::{self, DUMMY_SP, Pos, FileName};\n \n use std::collections::hash_map::Entry;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::default::Default;\n use std::{mem, slice, vec};\n use std::iter::{FromIterator, once};\n-use rustc_data_structures::sync::Lrc;\n use std::rc::Rc;\n use std::str::FromStr;\n use std::cell::RefCell;\n@@ -66,17 +65,17 @@ use visit_ast;\n use html::render::{cache, ExternalLocation};\n use html::item_type::ItemType;\n \n-pub mod inline;\n-pub mod cfg;\n-mod simplify;\n-mod auto_trait;\n-mod blanket_impl;\n-pub mod def_ctor;\n-\n use self::cfg::Cfg;\n use self::auto_trait::AutoTraitFinder;\n use self::blanket_impl::BlanketImplFinder;\n \n+pub use self::Type::*;\n+pub use self::Mutability::*;\n+pub use self::ItemEnum::*;\n+pub use self::SelfTy::*;\n+pub use self::FunctionRetTy::*;\n+pub use self::Visibility::{Public, Inherited};\n+\n thread_local!(pub static MAX_DEF_ID: RefCell<FxHashMap<CrateNum, DefId>> = Default::default());\n \n const FN_OUTPUT_NAME: &'static str = \"Output\";\n@@ -1621,7 +1620,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n         }\n \n         // It would be nice to collect all of the bounds on a type and recombine\n-        // them if possible, to avoid e.g. `where T: Foo, T: Bar, T: Sized, T: 'a`\n+        // them if possible, to avoid e.g., `where T: Foo, T: Bar, T: Sized, T: 'a`\n         // and instead see `where T: Foo + Bar + Sized + 'a`\n \n         Generics {\n@@ -3899,7 +3898,7 @@ impl Clean<Deprecation> for attr::Deprecation {\n     }\n }\n \n-/// An equality constraint on an associated type, e.g. `A=Bar` in `Foo<A=Bar>`\n+/// An equality constraint on an associated type, e.g., `A=Bar` in `Foo<A=Bar>`\n #[derive(Clone, PartialEq, Eq, RustcDecodable, RustcEncodable, Debug, Hash)]\n pub struct TypeBinding {\n     pub name: String,"}, {"sha": "81608b380d0576eaf8bf36d603e6080aab78f26a", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -12,7 +12,7 @@\n //! more canonical form.\n //!\n //! Currently all cross-crate-inlined function use `rustc::ty` to reconstruct\n-//! the AST (e.g. see all of `clean::inline`), but this is not always a\n+//! the AST (e.g., see all of `clean::inline`), but this is not always a\n //! non-lossy transformation. The current format of storage for where clauses\n //! for functions and such is simply a list of predicates. One example of this\n //! is that the AST predicate of: `where T: Trait<Foo=Bar>` is encoded as:"}, {"sha": "6ce02c313ee050365ac36fa0703c681046287566", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -130,7 +130,7 @@ pub fn render<T: fmt::Display, S: fmt::Display>(\n             <div class=\\\"infos\\\">\\\n                 <h2>Search Tricks</h2>\\\n                 <p>\\\n-                    Prefix searches with a type followed by a colon (e.g. \\\n+                    Prefix searches with a type followed by a colon (e.g., \\\n                     <code>fn:</code>) to restrict the search to a given type.\\\n                 </p>\\\n                 <p>\\\n@@ -140,11 +140,11 @@ pub fn render<T: fmt::Display, S: fmt::Display>(\n                     and <code>const</code>.\\\n                 </p>\\\n                 <p>\\\n-                    Search functions by type signature (e.g. \\\n+                    Search functions by type signature (e.g., \\\n                     <code>vec -> usize</code> or <code>* -> vec</code>)\\\n                 </p>\\\n                 <p>\\\n-                    Search multiple things at once by splitting your query with comma (e.g. \\\n+                    Search multiple things at once by splitting your query with comma (e.g., \\\n                     <code>str,u8</code> or <code>String,struct:Vec,test</code>)\\\n                 </p>\\\n             </div>\\"}, {"sha": "8d7942a14669c696d46a2e93faf9ee9a405fb781", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -2071,7 +2071,7 @@ impl Context {\n     fn item<F>(&mut self, item: clean::Item, all: &mut AllTypes, mut f: F) -> Result<(), Error>\n         where F: FnMut(&mut Context, clean::Item),\n     {\n-        // Stripped modules survive the rustdoc passes (i.e. `strip-private`)\n+        // Stripped modules survive the rustdoc passes (i.e., `strip-private`)\n         // if they contain impls for public types. These modules can also\n         // contain items such as publicly re-exported structures.\n         //"}, {"sha": "45bd6990fabbaec16c6e266d856bfd394c645ea4", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -52,7 +52,7 @@ pub struct TocEntry {\n pub struct TocBuilder {\n     top_level: Toc,\n     /// The current hierarchy of parent headings, the levels are\n-    /// strictly increasing (i.e. chain[0].level < chain[1].level <\n+    /// strictly increasing (i.e., chain[0].level < chain[1].level <\n     /// ...) with each entry being the most recent occurrence of a\n     /// heading with that level (it doesn't include the most recent\n     /// occurrences of every level, just, if it *is* in `chain` then\n@@ -76,7 +76,7 @@ impl TocBuilder {\n     }\n \n     /// Collapse the chain until the first heading more important than\n-    /// `level` (i.e. lower level)\n+    /// `level` (i.e., lower level)\n     ///\n     /// Example:\n     ///\n@@ -91,7 +91,7 @@ impl TocBuilder {\n     /// ### H\n     /// ```\n     ///\n-    /// If we are considering H (i.e. level 3), then A and B are in\n+    /// If we are considering H (i.e., level 3), then A and B are in\n     /// self.top_level, D is in C.children, and C, E, F, G are in\n     /// self.chain.\n     ///\n@@ -102,7 +102,7 @@ impl TocBuilder {\n     ///\n     /// This leaves us looking at E, which does have a smaller level,\n     /// and, by construction, it's the most recent thing with smaller\n-    /// level, i.e. it's the immediate parent of H.\n+    /// level, i.e., it's the immediate parent of H.\n     fn fold_until(&mut self, level: u32) {\n         let mut this = None;\n         loop {\n@@ -133,7 +133,7 @@ impl TocBuilder {\n         assert!(level >= 1);\n \n         // collapse all previous sections into their parents until we\n-        // get to relevant heading (i.e. the first one with a smaller\n+        // get to relevant heading (i.e., the first one with a smaller\n         // level than us)\n         self.fold_until(level);\n \n@@ -150,7 +150,7 @@ impl TocBuilder {\n                     (entry.level, &entry.children)\n                 }\n             };\n-            // fill in any missing zeros, e.g. for\n+            // fill in any missing zeros, e.g., for\n             // # Foo (1)\n             // ### Bar (1.0.1)\n             for _ in toc_level..level - 1 {"}, {"sha": "b0045e41f5057bc09fdc62002eff3e210dba5b20", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -276,7 +276,7 @@ fn opts() -> Vec<RustcOptGroup> {\n         unstable(\"resource-suffix\", |o| {\n             o.optopt(\"\",\n                      \"resource-suffix\",\n-                     \"suffix to add to CSS and JavaScript files, e.g. \\\"light.css\\\" will become \\\n+                     \"suffix to add to CSS and JavaScript files, e.g., \\\"light.css\\\" will become \\\n                       \\\"light-suffix.css\\\"\",\n                      \"PATH\")\n         }),"}, {"sha": "e0e0be717b284aaaebe249462f969d1e20709770", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -46,8 +46,8 @@ fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n     (metadata, \"\")\n }\n \n-/// Render `input` (e.g. \"foo.md\") into an HTML file in `output`\n-/// (e.g. output = \"bar\" => \"bar/foo.html\").\n+/// Render `input` (e.g., \"foo.md\") into an HTML file in `output`\n+/// (e.g., output = \"bar\" => \"bar/foo.html\").\n pub fn render(input: PathBuf, options: RenderOptions, diag: &errors::Handler) -> isize {\n     let mut output = options.output;\n     output.push(input.file_stem().unwrap());"}, {"sha": "426d3f3eeeaa2869e02c0c5267a98787e78edeee", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use clean::*;\n-\n use rustc::lint as lint;\n use rustc::hir;\n use rustc::hir::def::Def;\n@@ -26,6 +24,7 @@ use core::DocContext;\n use fold::DocFolder;\n use html::markdown::markdown_links;\n \n+use clean::*;\n use passes::{look_for_tests, Pass};\n \n pub const COLLECT_INTRA_DOC_LINKS: Pass =\n@@ -44,13 +43,13 @@ pub fn collect_intra_doc_links(krate: Crate, cx: &DocContext) -> Crate {\n \n #[derive(Debug)]\n enum PathKind {\n-    /// can be either value or type, not a macro\n+    /// Either a value or type, but not a macro\n     Unknown,\n-    /// macro\n+    /// Macro\n     Macro,\n-    /// values, functions, consts, statics, everything in the value namespace\n+    /// Values, functions, consts, statics (everything in the value namespace)\n     Value,\n-    /// types, traits, everything in the type namespace\n+    /// Types, traits (everything in the type namespace)\n     Type,\n }\n \n@@ -71,7 +70,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> LinkCollector<'a, 'tcx, 'rcx, 'cstore> {\n \n     /// Resolve a given string as a path, along with whether or not it is\n     /// in the value namespace. Also returns an optional URL fragment in the case\n-    /// of variants and methods\n+    /// of variants and methods.\n     fn resolve(&self,\n                path_str: &str,\n                is_val: bool,\n@@ -82,9 +81,9 @@ impl<'a, 'tcx, 'rcx, 'cstore> LinkCollector<'a, 'tcx, 'rcx, 'cstore> {\n         let cx = self.cx;\n \n         // In case we're in a module, try to resolve the relative\n-        // path\n+        // path.\n         if let Some(id) = parent_id.or(self.mod_ids.last().cloned()) {\n-            // FIXME: `with_scope` requires the NodeId of a module\n+            // FIXME: `with_scope` requires the `NodeId` of a module.\n             let result = cx.resolver.borrow_mut()\n                                     .with_scope(id,\n                 |resolver| {\n@@ -94,12 +93,12 @@ impl<'a, 'tcx, 'rcx, 'cstore> LinkCollector<'a, 'tcx, 'rcx, 'cstore> {\n \n             if let Ok(result) = result {\n                 // In case this is a trait item, skip the\n-                // early return and try looking for the trait\n+                // early return and try looking for the trait.\n                 let value = match result.def {\n                     Def::Method(_) | Def::AssociatedConst(_) => true,\n                     Def::AssociatedTy(_) => false,\n                     Def::Variant(_) => return handle_variant(cx, result.def),\n-                    // not a trait item, just return what we found\n+                    // Not a trait item; just return what we found.\n                     _ => return Ok((result.def, None))\n                 };\n \n@@ -111,13 +110,13 @@ impl<'a, 'tcx, 'rcx, 'cstore> LinkCollector<'a, 'tcx, 'rcx, 'cstore> {\n             } else {\n                 // If resolution failed, it may still be a method\n                 // because methods are not handled by the resolver\n-                // If so, bail when we're not looking for a value\n+                // If so, bail when we're not looking for a value.\n                 if !is_val {\n                     return Err(())\n                 }\n             }\n \n-            // Try looking for methods and associated items\n+            // Try looking for methods and associated items.\n             let mut split = path_str.rsplitn(2, \"::\");\n             let item_name = if let Some(first) = split.next() {\n                 first\n@@ -137,7 +136,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> LinkCollector<'a, 'tcx, 'rcx, 'cstore> {\n                 }\n             }\n \n-            // FIXME: `with_scope` requires the NodeId of a module\n+            // FIXME: `with_scope` requires the `NodeId` of a module.\n             let ty = cx.resolver.borrow_mut()\n                                 .with_scope(id,\n                 |resolver| {\n@@ -227,10 +226,10 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n             None\n         };\n \n-        // FIXME: get the resolver to work with non-local resolve scopes\n+        // FIXME: get the resolver to work with non-local resolve scopes.\n         let parent_node = self.cx.as_local_node_id(item.def_id).and_then(|node_id| {\n             // FIXME: this fails hard for impls in non-module scope, but is necessary for the\n-            // current resolve() implementation\n+            // current `resolve()` implementation.\n             match self.cx.tcx.hir().get_module_parent_node(node_id) {\n                 id if id != node_id => Some(id),\n                 _ => None,\n@@ -252,7 +251,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n                 } else {\n                     match parent_node.or(self.mod_ids.last().cloned()) {\n                         Some(parent) if parent != NodeId::from_u32(0) => {\n-                            //FIXME: can we pull the parent module's name from elsewhere?\n+                            // FIXME: can we pull the parent module's name from elsewhere?\n                             Some(self.cx.tcx.hir().name(parent).to_string())\n                         }\n                         _ => None,\n@@ -262,7 +261,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n             ImplItem(Impl { ref for_, .. }) => {\n                 for_.def_id().map(|did| self.cx.tcx.item_name(did).to_string())\n             }\n-            // we don't display docs on `extern crate` items anyway, so don't process them\n+            // we don't display docs on `extern crate` items anyway, so don't process them.\n             ExternCrateItem(..) => return self.fold_item_recur(item),\n             ImportItem(Import::Simple(ref name, ..)) => Some(name.clone()),\n             MacroItem(..) => None,\n@@ -283,7 +282,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n         }\n \n         for (ori_link, link_range) in markdown_links(&dox) {\n-            // bail early for real links\n+            // Bail early for real links.\n             if ori_link.contains('/') {\n                 continue;\n             }\n@@ -327,9 +326,9 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n                             def\n                         } else {\n                             resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n-                            // this could just be a normal link or a broken link\n+                            // This could just be a normal link or a broken link\n                             // we could potentially check if something is\n-                            // \"intra-doc-link-like\" and warn in that case\n+                            // \"intra-doc-link-like\" and warn in that case.\n                             continue;\n                         }\n                     }\n@@ -338,12 +337,12 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n                             def\n                         } else {\n                             resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n-                            // this could just be a normal link\n+                            // This could just be a normal link.\n                             continue;\n                         }\n                     }\n                     PathKind::Unknown => {\n-                        // try everything!\n+                        // Try everything!\n                         if let Some(macro_def) = macro_resolve(cx, path_str) {\n                             if let Ok(type_def) =\n                                 self.resolve(path_str, false, &current_item, parent_node)\n@@ -371,8 +370,8 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n                         {\n                             // It is imperative we search for not-a-value first\n                             // Otherwise we will find struct ctors for when we are looking\n-                            // for structs, and the link won't work.\n-                            // if there is something in both namespaces\n+                            // for structs, and the link won't work if there is something in\n+                            // both namespaces.\n                             if let Ok(value_def) =\n                                 self.resolve(path_str, true, &current_item, parent_node)\n                             {\n@@ -432,7 +431,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n     }\n }\n \n-/// Resolve a string as a macro\n+/// Resolve a string as a macro.\n fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n     use syntax::ext::base::{MacroKind, SyntaxExtension};\n     let segment = ast::PathSegment::from_ident(Ident::from_str(path_str));\n@@ -482,19 +481,19 @@ fn resolution_failure(\n         let mut diag;\n         if dox.lines().count() == code_dox.lines().count() {\n             let line_offset = dox[..link_range.start].lines().count();\n-            // The span starts in the `///`, so we don't have to account for the leading whitespace\n+            // The span starts in the `///`, so we don't have to account for the leading whitespace.\n             let code_dox_len = if line_offset <= 1 {\n                 doc_comment_padding\n             } else {\n-                // The first `///`\n+                // The first `///`.\n                 doc_comment_padding +\n-                    // Each subsequent leading whitespace and `///`\n+                    // Each subsequent leading whitespace and `///`.\n                     code_dox.lines().skip(1).take(line_offset - 1).fold(0, |sum, line| {\n                         sum + doc_comment_padding + line.len() - line.trim_start().len()\n                     })\n             };\n \n-            // Extract the specific span\n+            // Extract the specific span.\n             let sp = sp.from_inner_byte_pos(\n                 link_range.start + code_dox_len,\n                 link_range.end + code_dox_len,\n@@ -514,7 +513,7 @@ fn resolution_failure(\n             let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n             let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n \n-            // Print the line containing the `link_range` and manually mark it with '^'s\n+            // Print the line containing the `link_range` and manually mark it with '^'s.\n             diag.note(&format!(\n                 \"the link appears in this line:\\n\\n{line}\\n\\\n                  {indicator: <before$}{indicator:^<found$}\",\n@@ -555,13 +554,13 @@ fn ambiguity_error(cx: &DocContext, attrs: &Attributes,\n }\n \n /// Given a def, returns its name and disambiguator\n-/// for a value namespace\n+/// for a value namespace.\n ///\n-/// Returns None for things which cannot be ambiguous since\n-/// they exist in both namespaces (structs and modules)\n+/// Returns `None` for things which cannot be ambiguous since\n+/// they exist in both namespaces (structs and modules).\n fn value_ns_kind(def: Def, path_str: &str) -> Option<(&'static str, String)> {\n     match def {\n-        // structs, variants, and mods exist in both namespaces. skip them\n+        // Structs, variants, and mods exist in both namespaces; skip them.\n         Def::StructCtor(..) | Def::Mod(..) | Def::Variant(..) |\n         Def::VariantCtor(..) | Def::SelfCtor(..)\n             => None,\n@@ -578,10 +577,10 @@ fn value_ns_kind(def: Def, path_str: &str) -> Option<(&'static str, String)> {\n }\n \n /// Given a def, returns its name, the article to be used, and a disambiguator\n-/// for the type namespace\n+/// for the type namespace.\n fn type_ns_kind(def: Def, path_str: &str) -> (&'static str, &'static str, String) {\n     let (kind, article) = match def {\n-        // we can still have non-tuple structs\n+        // We can still have non-tuple structs.\n         Def::Struct(..) => (\"struct\", \"a\"),\n         Def::Enum(..) => (\"enum\", \"an\"),\n         Def::Trait(..) => (\"trait\", \"a\"),\n@@ -591,7 +590,7 @@ fn type_ns_kind(def: Def, path_str: &str) -> (&'static str, &'static str, String\n     (kind, article, format!(\"{}@{}\", kind, path_str))\n }\n \n-/// Given an enum variant's def, return the def of its enum and the associated fragment\n+/// Given an enum variant's def, return the def of its enum and the associated fragment.\n fn handle_variant(cx: &DocContext, def: Def) -> Result<(Def, Option<String>), ()> {\n     use rustc::ty::DefIdTree;\n "}, {"sha": "be9327ced26e9f3d1fdc4ef69fe9de96d9c9dd02", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -8,38 +8,38 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::env;\n-use std::ffi::OsString;\n-use std::io::prelude::*;\n-use std::io;\n-use std::path::PathBuf;\n-use std::panic::{self, AssertUnwindSafe};\n-use std::process::Command;\n-use std::str;\n+use errors;\n+use errors::emitter::ColorConfig;\n use rustc_data_structures::sync::Lrc;\n-use std::sync::{Arc, Mutex};\n-\n-use testing;\n use rustc_lint;\n+use rustc_driver::{self, driver, target_features, Compilation};\n+use rustc_driver::driver::phase_2_configure_and_expand;\n+use rustc_metadata::cstore::CStore;\n+use rustc_metadata::dynamic_lib::DynamicLibrary;\n+use rustc_resolve::MakeGlobMap;\n use rustc::hir;\n use rustc::hir::intravisit;\n use rustc::session::{self, CompileIncomplete, config};\n use rustc::session::config::{OutputType, OutputTypes, Externs, CodegenOptions};\n use rustc::session::search_paths::{SearchPaths, PathKind};\n-use rustc_metadata::dynamic_lib::DynamicLibrary;\n-use tempfile::Builder as TempFileBuilder;\n-use rustc_driver::{self, driver, target_features, Compilation};\n-use rustc_driver::driver::phase_2_configure_and_expand;\n-use rustc_metadata::cstore::CStore;\n-use rustc_resolve::MakeGlobMap;\n use syntax::ast;\n use syntax::source_map::SourceMap;\n use syntax::edition::Edition;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::with_globals;\n use syntax_pos::{BytePos, DUMMY_SP, Pos, Span, FileName};\n-use errors;\n-use errors::emitter::ColorConfig;\n+use tempfile::Builder as TempFileBuilder;\n+use testing;\n+\n+use std::env;\n+use std::ffi::OsString;\n+use std::io::prelude::*;\n+use std::io;\n+use std::path::PathBuf;\n+use std::panic::{self, AssertUnwindSafe};\n+use std::process::Command;\n+use std::str;\n+use std::sync::{Arc, Mutex};\n \n use clean::Attributes;\n use config::Options;\n@@ -153,7 +153,7 @@ pub fn run(mut options: Options) -> isize {\n     })\n }\n \n-// Look for #![doc(test(no_crate_inject))], used by crates in the std facade\n+// Look for `#![doc(test(no_crate_inject))]`, used by crates in the std facade.\n fn scrape_test_config(krate: &::rustc::hir::Crate) -> TestOptions {\n     use syntax::print::pprust;\n \n@@ -192,12 +192,11 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n             should_panic: bool, no_run: bool, as_test_harness: bool,\n             compile_fail: bool, mut error_codes: Vec<String>, opts: &TestOptions,\n             maybe_sysroot: Option<PathBuf>, linker: Option<PathBuf>, edition: Edition) {\n-    // the test harness wants its own `main` & top level functions, so\n-    // never wrap the test in `fn main() { ... }`\n+    // The test harness wants its own `main` and top-level functions, so\n+    // never wrap the test in `fn main() { ... }`.\n     let (test, line_offset) = make_test(test, Some(cratename), as_test_harness, opts);\n     // FIXME(#44940): if doctests ever support path remapping, then this filename\n-    // needs to be the result of SourceMap::span_to_unmapped_path\n-\n+    // needs to be the result of `SourceMap::span_to_unmapped_path`.\n     let path = match filename {\n         FileName::Real(path) => path.clone(),\n         _ => PathBuf::from(r\"doctest.rs\"),\n@@ -408,8 +407,8 @@ pub fn make_test(s: &str,\n         let filename = FileName::anon_source_code(s);\n         let source = crates + &everything_else;\n \n-        // any errors in parsing should also appear when the doctest is compiled for real, so just\n-        // send all the errors that libsyntax emits directly into a Sink instead of stderr\n+        // Any errors in parsing should also appear when the doctest is compiled for real, so just\n+        // send all the errors that libsyntax emits directly into a `Sink` instead of stderr.\n         let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         let emitter = EmitterWriter::new(box io::sink(), None, false, false);\n         let handler = Handler::with_emitter(false, false, box emitter);\n@@ -537,10 +536,10 @@ pub struct Collector {\n     // The name of the test displayed to the user, separated by `::`.\n     //\n     // In tests from Rust source, this is the path to the item\n-    // e.g. `[\"std\", \"vec\", \"Vec\", \"push\"]`.\n+    // e.g., `[\"std\", \"vec\", \"Vec\", \"push\"]`.\n     //\n     // In tests from a markdown file, this is the titles of all headers (h1~h6)\n-    // of the sections that contain the code block, e.g. if the markdown file is\n+    // of the sections that contain the code block, e.g., if the markdown file is\n     // written as:\n     //\n     // ``````markdown\n@@ -689,7 +688,7 @@ impl Tester for Collector {\n \n     fn register_header(&mut self, name: &str, level: u32) {\n         if self.use_headers {\n-            // we use these headings as test names, so it's good if\n+            // We use these headings as test names, so it's good if\n             // they're valid identifiers.\n             let name = name.chars().enumerate().map(|(i, c)| {\n                     if (i == 0 && c.is_xid_start()) ||\n@@ -703,7 +702,7 @@ impl Tester for Collector {\n             // Here we try to efficiently assemble the header titles into the\n             // test name in the form of `h1::h2::h3::h4::h5::h6`.\n             //\n-            // Suppose originally `self.names` contains `[h1, h2, h3]`...\n+            // Suppose that originally `self.names` contains `[h1, h2, h3]`...\n             let level = level as usize;\n             if level <= self.names.len() {\n                 // ... Consider `level == 2`. All headers in the lower levels\n@@ -752,8 +751,8 @@ impl<'a, 'hir> HirCollector<'a, 'hir> {\n \n         attrs.collapse_doc_comments();\n         attrs.unindent_doc_comments();\n-        // the collapse-docs pass won't combine sugared/raw doc attributes, or included files with\n-        // anything else, this will combine them for us\n+        // The collapse-docs pass won't combine sugared/raw doc attributes, or included files with\n+        // anything else, this will combine them for us.\n         if let Some(doc) = attrs.collapsed_doc_value() {\n             self.collector.set_position(attrs.span.unwrap_or(DUMMY_SP));\n             let res = markdown::find_testable_code(&doc, self.collector, self.codes);\n@@ -847,8 +846,8 @@ assert_eq!(2+2, 4);\n \n     #[test]\n     fn make_test_crate_name_no_use() {\n-        //if you give a crate name but *don't* use it within the test, it won't bother inserting\n-        //the `extern crate` statement\n+        // If you give a crate name but *don't* use it within the test, it won't bother inserting\n+        // the `extern crate` statement.\n         let opts = TestOptions::default();\n         let input =\n \"assert_eq!(2+2, 4);\";\n@@ -863,8 +862,8 @@ assert_eq!(2+2, 4);\n \n     #[test]\n     fn make_test_crate_name() {\n-        //if you give a crate name and use it within the test, it will insert an `extern crate`\n-        //statement before `fn main`\n+        // If you give a crate name and use it within the test, it will insert an `extern crate`\n+        // statement before `fn main`.\n         let opts = TestOptions::default();\n         let input =\n \"use asdf::qwop;\n@@ -882,8 +881,8 @@ assert_eq!(2+2, 4);\n \n     #[test]\n     fn make_test_no_crate_inject() {\n-        //even if you do use the crate within the test, setting `opts.no_crate_inject` will skip\n-        //adding it anyway\n+        // Even if you do use the crate within the test, setting `opts.no_crate_inject` will skip\n+        // adding it anyway.\n         let opts = TestOptions {\n             no_crate_inject: true,\n             display_warnings: false,\n@@ -904,8 +903,9 @@ assert_eq!(2+2, 4);\n \n     #[test]\n     fn make_test_ignore_std() {\n-        //even if you include a crate name, and use it in the doctest, we still won't include an\n-        //`extern crate` statement if the crate is \"std\" - that's included already by the compiler!\n+        // Even if you include a crate name, and use it in the doctest, we still won't include an\n+        // `extern crate` statement if the crate is \"std\" -- that's included already by the\n+        // compiler!\n         let opts = TestOptions::default();\n         let input =\n \"use std::*;\n@@ -922,8 +922,8 @@ assert_eq!(2+2, 4);\n \n     #[test]\n     fn make_test_manual_extern_crate() {\n-        //when you manually include an `extern crate` statement in your doctest, make_test assumes\n-        //you've included one for your own crate too\n+        // When you manually include an `extern crate` statement in your doctest, `make_test`\n+        // assumes you've included one for your own crate too.\n         let opts = TestOptions::default();\n         let input =\n \"extern crate asdf;\n@@ -960,8 +960,8 @@ assert_eq!(2+2, 4);\n \n     #[test]\n     fn make_test_opts_attrs() {\n-        //if you supplied some doctest attributes with #![doc(test(attr(...)))], it will use those\n-        //instead of the stock #![allow(unused)]\n+        // If you supplied some doctest attributes with `#![doc(test(attr(...)))]`, it will use\n+        // those instead of the stock `#![allow(unused)]`.\n         let mut opts = TestOptions::default();\n         opts.attrs.push(\"feature(sick_rad)\".to_string());\n         let input =\n@@ -977,7 +977,7 @@ assert_eq!(2+2, 4);\n         let output = make_test(input, Some(\"asdf\"), false, &opts);\n         assert_eq!(output, (expected, 3));\n \n-        //adding more will also bump the returned line offset\n+        // Adding more will also bump the returned line offset.\n         opts.attrs.push(\"feature(hella_dope)\".to_string());\n         let expected =\n \"#![feature(sick_rad)]\n@@ -993,8 +993,8 @@ assert_eq!(2+2, 4);\n \n     #[test]\n     fn make_test_crate_attrs() {\n-        //including inner attributes in your doctest will apply them to the whole \"crate\", pasting\n-        //them outside the generated main function\n+        // Including inner attributes in your doctest will apply them to the whole \"crate\", pasting\n+        // them outside the generated main function.\n         let opts = TestOptions::default();\n         let input =\n \"#![feature(sick_rad)]\n@@ -1011,7 +1011,7 @@ assert_eq!(2+2, 4);\n \n     #[test]\n     fn make_test_with_main() {\n-        //including your own `fn main` wrapper lets the test use it verbatim\n+        // Including your own `fn main` wrapper lets the test use it verbatim.\n         let opts = TestOptions::default();\n         let input =\n \"fn main() {\n@@ -1028,7 +1028,7 @@ fn main() {\n \n     #[test]\n     fn make_test_fake_main() {\n-        //...but putting it in a comment will still provide a wrapper\n+        // ... but putting it in a comment will still provide a wrapper.\n         let opts = TestOptions::default();\n         let input =\n \"//Ceci n'est pas une `fn main`\n@@ -1045,7 +1045,7 @@ assert_eq!(2+2, 4);\n \n     #[test]\n     fn make_test_dont_insert_main() {\n-        //even with that, if you set `dont_insert_main`, it won't create the `fn main` wrapper\n+        // Even with that, if you set `dont_insert_main`, it won't create the `fn main` wrapper.\n         let opts = TestOptions::default();\n         let input =\n \"//Ceci n'est pas une `fn main`\n@@ -1060,7 +1060,7 @@ assert_eq!(2+2, 4);\".to_string();\n \n     #[test]\n     fn make_test_display_warnings() {\n-        //if the user is asking to display doctest warnings, suppress the default allow(unused)\n+        // If the user is asking to display doctest warnings, suppress the default `allow(unused)`.\n         let mut opts = TestOptions::default();\n         opts.display_warnings = true;\n         let input ="}, {"sha": "004be1cfe39c42e0793ac71bdc33264e26181774", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -8,44 +8,41 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Rust AST Visitor. Extracts useful information and massages it into a form\n-//! usable for clean\n-\n-use std::mem;\n+//! The Rust AST Visitor. Extracts useful information and massages it into a form\n+//! usable for `clean`.\n \n+use rustc::hir::{self, Node};\n+use rustc::hir::def::Def;\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::middle::privacy::AccessLevel;\n+use rustc::util::nodemap::{FxHashSet, FxHashMap};\n use syntax::ast;\n use syntax::attr;\n use syntax::ext::base::MacroKind;\n use syntax::source_map::Spanned;\n use syntax_pos::{self, Span};\n \n-use rustc::hir::Node;\n-use rustc::hir::def::Def;\n-use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc::middle::privacy::AccessLevel;\n-use rustc::util::nodemap::{FxHashSet, FxHashMap};\n-\n-use rustc::hir;\n+use std::mem;\n \n use core;\n use clean::{self, AttributesExt, NestedAttributesExt, def_id_to_path};\n use doctree::*;\n \n-// looks to me like the first two of these are actually\n+// Looks to me like the first two of these are actually\n // output parameters, maybe only mutated once; perhaps\n // better simply to have the visit method return a tuple\n // containing them?\n \n-// also, is there some reason that this doesn't use the 'visit'\n-// framework from syntax?\n+// Also, is there some reason that this doesn't use the 'visit'\n+// framework from syntax?.\n \n pub struct RustdocVisitor<'a, 'tcx: 'a, 'rcx: 'a, 'cstore: 'rcx> {\n     pub module: Module,\n     pub attrs: hir::HirVec<ast::Attribute>,\n     pub cx: &'a core::DocContext<'a, 'tcx, 'rcx, 'cstore>,\n     view_item_stack: FxHashSet<ast::NodeId>,\n     inlining: bool,\n-    /// Is the current module and all of its parents public?\n+    /// Are the current module and all of its parents public?\n     inside_public_path: bool,\n     exact_paths: Option<FxHashMap<DefId, Vec<String>>>,\n }\n@@ -69,8 +66,8 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n     }\n \n     fn store_path(&mut self, did: DefId) {\n-        // We can't use the entry api, as that keeps the mutable borrow of self active\n-        // when we try to use cx\n+        // We can't use the entry API, as that keeps the mutable borrow of `self` active\n+        // when we try to use `cx`.\n         let exact_paths = self.exact_paths.as_mut().unwrap();\n         if exact_paths.get(&did).is_none() {\n             let path = def_id_to_path(self.cx, did, self.cx.crate_name.clone());\n@@ -98,7 +95,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n                                               ast::CRATE_NODE_ID,\n                                               &krate.module,\n                                               None);\n-        // attach the crate's exported macros to the top-level module:\n+        // Attach the crate's exported macros to the top-level module:\n         let macro_exports: Vec<_> =\n             krate.exported_macros.iter().map(|def| self.visit_local_macro(def, None)).collect();\n         self.module.macros.extend(macro_exports);\n@@ -303,14 +300,14 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n         let def_did = def.def_id();\n \n         let use_attrs = tcx.hir().attrs(id);\n-        // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n+        // Don't inline `doc(hidden)` imports so they can be stripped at a later stage.\n         let is_no_inline = use_attrs.lists(\"doc\").has_word(\"no_inline\") ||\n                            use_attrs.lists(\"doc\").has_word(\"hidden\");\n \n         // For cross-crate impl inlining we need to know whether items are\n-        // reachable in documentation - a previously nonreachable item can be\n+        // reachable in documentation -- a previously nonreachable item can be\n         // made reachable by cross-crate inlining which we're checking here.\n-        // (this is done here because we need to know this upfront)\n+        // (this is done here because we need to know this upfront).\n         if !def_did.is_local() && !is_no_inline {\n             let attrs = clean::inline::load_attrs(self.cx, def_did);\n             let self_is_hidden = attrs.lists(\"doc\").has_word(\"hidden\");\n@@ -342,7 +339,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n         let is_private = !self.cx.renderinfo.borrow().access_levels.is_public(def_did);\n         let is_hidden = inherits_doc_hidden(self.cx, def_node_id);\n \n-        // Only inline if requested or if the item would otherwise be stripped\n+        // Only inline if requested or if the item would otherwise be stripped.\n         if (!please_inline && !is_private && !is_hidden) || is_no_inline {\n             return false\n         }\n@@ -366,7 +363,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n                 true\n             }\n             Node::ForeignItem(it) if !glob => {\n-                // generate a fresh `extern {}` block if we want to inline a foreign item.\n+                // Generate a fresh `extern {}` block if we want to inline a foreign item.\n                 om.foreigns.push(hir::ForeignMod {\n                     abi: tcx.hir().get_foreign_abi(it.id),\n                     items: vec![hir::ForeignItem {\n@@ -427,7 +424,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n             hir::ItemKind::Use(ref path, kind) => {\n                 let is_glob = kind == hir::UseKind::Glob;\n \n-                // struct and variant constructors always show up alongside their definitions, we've\n+                // Struct and variant constructors always show up alongside their definitions, we've\n                 // already processed them so just discard these.\n                 match path.def {\n                     Def::StructCtor(..) | Def::VariantCtor(..) | Def::SelfCtor(..) => return,\n@@ -596,7 +593,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n         }\n     }\n \n-    // convert each exported_macro into a doc item\n+    // Convert each `exported_macro` into a doc item.\n     fn visit_local_macro(\n         &self,\n         def: &hir::MacroDef,"}, {"sha": "f64334a821981ce81bf55851ceed8e7c804d2c44", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -21,7 +21,7 @@ use clean::{AttributesExt, NestedAttributesExt};\n // FIXME: this may not be exhaustive, but is sufficient for rustdocs current uses\n \n /// Similar to `librustc_privacy::EmbargoVisitor`, but also takes\n-/// specific rustdoc annotations into account (i.e. `doc(hidden)`)\n+/// specific rustdoc annotations into account (i.e., `doc(hidden)`)\n pub struct LibEmbargoVisitor<'a, 'tcx: 'a, 'rcx: 'a, 'cstore: 'rcx> {\n     cx: &'a ::core::DocContext<'a, 'tcx, 'rcx, 'cstore>,\n     // Accessibility levels for reachable nodes"}, {"sha": "d3267e4e8015a7fd07d1dc2b9e420a531d4402c9", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -342,7 +342,7 @@ impl<T, S> HashSet<T, S>\n     }\n \n     /// Visits the values representing the difference,\n-    /// i.e. the values that are in `self` but not in `other`.\n+    /// i.e., the values that are in `self` but not in `other`.\n     ///\n     /// # Examples\n     ///\n@@ -373,7 +373,7 @@ impl<T, S> HashSet<T, S>\n     }\n \n     /// Visits the values representing the symmetric difference,\n-    /// i.e. the values that are in `self` or in `other` but not in both.\n+    /// i.e., the values that are in `self` or in `other` but not in both.\n     ///\n     /// # Examples\n     ///\n@@ -401,7 +401,7 @@ impl<T, S> HashSet<T, S>\n     }\n \n     /// Visits the values representing the intersection,\n-    /// i.e. the values that are both in `self` and `other`.\n+    /// i.e., the values that are both in `self` and `other`.\n     ///\n     /// # Examples\n     ///\n@@ -427,7 +427,7 @@ impl<T, S> HashSet<T, S>\n     }\n \n     /// Visits the values representing the union,\n-    /// i.e. all the values in `self` or `other`, without duplicates.\n+    /// i.e., all the values in `self` or `other`, without duplicates.\n     ///\n     /// # Examples\n     ///\n@@ -598,7 +598,7 @@ impl<T, S> HashSet<T, S>\n     }\n \n     /// Returns `true` if the set is a subset of another,\n-    /// i.e. `other` contains at least all the values in `self`.\n+    /// i.e., `other` contains at least all the values in `self`.\n     ///\n     /// # Examples\n     ///\n@@ -620,7 +620,7 @@ impl<T, S> HashSet<T, S>\n     }\n \n     /// Returns `true` if the set is a superset of another,\n-    /// i.e. `self` contains at least all the values in `other`.\n+    /// i.e., `self` contains at least all the values in `other`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "a9b27115261a07c9a5aa6cb99a550cf86edeed64", "filename": "src/libstd/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -36,12 +36,12 @@ use str;\n use string;\n \n /// `Error` is a trait representing the basic expectations for error values,\n-/// i.e. values of type `E` in [`Result<T, E>`]. Errors must describe\n+/// i.e., values of type `E` in [`Result<T, E>`]. Errors must describe\n /// themselves through the [`Display`] and [`Debug`] traits, and may provide\n /// cause chain information:\n ///\n /// The [`cause`] method is generally used when errors cross \"abstraction\n-/// boundaries\", i.e.  when a one module must report an error that is \"caused\"\n+/// boundaries\", i.e.,  when a one module must report an error that is \"caused\"\n /// by an error from a lower-level module. This setup makes it possible for the\n /// high-level module to provide its own errors that do not commit to any\n /// particular implementation, but also reveal some of its implementation for"}, {"sha": "c800763167fcbb40ed42fcc697ecfbf2684da77f", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -888,7 +888,7 @@ impl f64 {\n     }\n \n     // Solaris/Illumos requires a wrapper around log, log2, and log10 functions\n-    // because of their non-standard behavior (e.g. log(-n) returns -Inf instead\n+    // because of their non-standard behavior (e.g., log(-n) returns -Inf instead\n     // of expected NaN).\n     fn log_wrapper<F: Fn(f64) -> f64>(self, log_fn: F) -> f64 {\n         if !cfg!(target_os = \"solaris\") {"}, {"sha": "768998b235ee9003b21e565fda97615087042439", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -372,7 +372,7 @@ impl CString {\n     /// # Safety\n     ///\n     /// This should only ever be called with a pointer that was earlier\n-    /// obtained by calling [`into_raw`] on a `CString`. Other usage (e.g. trying to take\n+    /// obtained by calling [`into_raw`] on a `CString`. Other usage (e.g., trying to take\n     /// ownership of a string that was allocated by foreign code) is likely to lead\n     /// to undefined behavior or allocator corruption.\n     ///\n@@ -1167,8 +1167,8 @@ impl CStr {\n     /// ```\n     #[stable(feature = \"cstr_to_str\", since = \"1.4.0\")]\n     pub fn to_str(&self) -> Result<&str, str::Utf8Error> {\n-        // NB: When CStr is changed to perform the length check in .to_bytes()\n-        // instead of in from_ptr(), it may be worth considering if this should\n+        // N.B., when `CStr` is changed to perform the length check in `.to_bytes()`\n+        // instead of in `from_ptr()`, it may be worth considering if this should\n         // be rewritten to do the UTF-8 check inline with the length calculation\n         // instead of doing it afterwards.\n         str::from_utf8(self.to_bytes())"}, {"sha": "99da73adc63e97a64e508b09813f82f9253ec2ca", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -21,7 +21,7 @@\n //! Rust represents owned strings with the [`String`] type, and\n //! borrowed slices of strings with the [`str`] primitive. Both are\n //! always in UTF-8 encoding, and may contain nul bytes in the middle,\n-//! i.e. if you look at the bytes that make up the string, there may\n+//! i.e., if you look at the bytes that make up the string, there may\n //! be a `\\0` among them. Both `String` and `str` store their length\n //! explicitly; there are no nul terminators at the end of strings\n //! like in C.\n@@ -44,7 +44,7 @@\n //! code point]'.\n //!\n //! * **Nul terminators and implicit string lengths** - Often, C\n-//! strings are nul-terminated, i.e. they have a `\\0` character at the\n+//! strings are nul-terminated, i.e., they have a `\\0` character at the\n //! end. The length of a string buffer is not stored, but has to be\n //! calculated; to compute the length of a string, C code must\n //! manually call a function like `strlen()` for `char`-based strings,"}, {"sha": "828972187eefcc533e533a467324345cf0592f63", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -36,7 +36,7 @@ use sys_common::{AsInner, IntoInner, FromInner};\n /// and platform-native string values, and in particular allowing a Rust string\n /// to be converted into an \"OS\" string with no cost if possible.  A consequence\n /// of this is that `OsString` instances are *not* `NUL` terminated; in order\n-/// to pass to e.g. Unix system call, you should create a [`CStr`].\n+/// to pass to e.g., Unix system call, you should create a [`CStr`].\n ///\n /// `OsString` is to [`&OsStr`] as [`String`] is to [`&str`]: the former\n /// in each pair are owned strings; the latter are borrowed"}, {"sha": "b6a0ce6372086efe51c523fa96e5cc55792688b2", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -1406,7 +1406,7 @@ impl AsInner<fs_imp::DirEntry> for DirEntry {\n /// Removes a file from the filesystem.\n ///\n /// Note that there is no\n-/// guarantee that the file is immediately deleted (e.g. depending on\n+/// guarantee that the file is immediately deleted (e.g., depending on\n /// platform, other open file descriptors may prevent immediate removal).\n ///\n /// # Platform-specific behavior"}, {"sha": "f7a90333ef239c2098544a716472e05e29617a90", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -90,7 +90,7 @@ pub struct Cursor<T> {\n impl<T> Cursor<T> {\n     /// Creates a new cursor wrapping the provided underlying in-memory buffer.\n     ///\n-    /// Cursor initial position is `0` even if underlying buffer (e.g. `Vec`)\n+    /// Cursor initial position is `0` even if underlying buffer (e.g., `Vec`)\n     /// is not empty. So writing to cursor starts with overwriting `Vec`\n     /// content, not with appending to it.\n     ///"}, {"sha": "8c03f355848e2423612a8ce9b8778a543dc851af", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -131,7 +131,7 @@ fn handle_ebadf<T>(r: io::Result<T>, default: T) -> io::Result<T> {\n ///\n /// Each handle is a shared reference to a global buffer of input data to this\n /// process. A handle can be `lock`'d to gain full access to [`BufRead`] methods\n-/// (e.g. `.lines()`). Reads to this handle are otherwise locked with respect\n+/// (e.g., `.lines()`). Reads to this handle are otherwise locked with respect\n /// to other reads.\n ///\n /// This handle implements the `Read` trait, but beware that concurrent reads\n@@ -269,7 +269,7 @@ impl Stdin {\n     ///\n     /// You can run the example one of two ways:\n     ///\n-    /// - Pipe some text to it, e.g. `printf foo | path/to/executable`\n+    /// - Pipe some text to it, e.g., `printf foo | path/to/executable`\n     /// - Give it text interactively by running the executable directly,\n     ///   in which case it will wait for the Enter key to be pressed before\n     ///   continuing"}, {"sha": "12b60313725beb6a81f6252c1918a01f11420a2b", "filename": "src/libstd/keyword_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkeyword_docs.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -188,7 +188,7 @@ mod enum_keyword { }\n /// For external connections in Rust code.\n ///\n /// The `extern` keyword is used in two places in Rust. One is in conjunction with the [`crate`]\n-/// keyword to make your Rust code aware of other Rust crates in your project, i.e. `extern crate\n+/// keyword to make your Rust code aware of other Rust crates in your project, i.e., `extern crate\n /// lazy_static;`. The other use is in foreign function interfaces (FFI).\n ///\n /// `extern` is used in two different contexts within FFI. The first is in the form of external"}, {"sha": "21def5d93b76f15c3f916aa6f14d8b16ba9ff04e", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -703,7 +703,7 @@ impl hash::Hash for SocketAddrV6 {\n /// the other: for simple uses a string like `\"localhost:12345\"` is much nicer\n /// than manual construction of the corresponding [`SocketAddr`], but sometimes\n /// [`SocketAddr`] value is *the* main source of the address, and converting it to\n-/// some other type (e.g. a string) just for it to be converted back to\n+/// some other type (e.g., a string) just for it to be converted back to\n /// [`SocketAddr`] in constructor methods is pointless.\n ///\n /// Addresses returned by the operating system that are not IP addresses are"}, {"sha": "5aa043b0fcb2c37769e976b507c4de9453ac7a1a", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=059e6a6f57f4e80d527a3cd8a8afe7f51f01af8e", "patch": "@@ -530,7 +530,7 @@ impl TcpStream {\n     /// Moves this TCP stream into or out of nonblocking mode.\n     ///\n     /// This will result in `read`, `write`, `recv` and `send` operations\n-    /// becoming nonblocking, i.e. immediately returning from their calls.\n+    /// becoming nonblocking, i.e., immediately returning from their calls.\n     /// If the IO operation is successful, `Ok` is returned and no further\n     /// action is required. If the IO operation could not be completed and needs\n     /// to be retried, an error with kind [`io::ErrorKind::WouldBlock`] is\n@@ -840,7 +840,7 @@ impl TcpListener {\n     /// Moves this TCP stream into or out of nonblocking mode.\n     ///\n     /// This will result in the `accept` operation becoming nonblocking,\n-    /// i.e. immediately returning from their calls. If the IO operation is\n+    /// i.e., immediately returning from their calls. If the IO operation is\n     /// successful, `Ok` is returned and no further action is required. If the\n     /// IO operation could not be completed and needs to be retried, an error\n     /// with kind [`io::ErrorKind::WouldBlock`] is returned."}]}