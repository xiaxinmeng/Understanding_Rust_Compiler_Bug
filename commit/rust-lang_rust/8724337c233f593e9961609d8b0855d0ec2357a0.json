{"sha": "8724337c233f593e9961609d8b0855d0ec2357a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MjQzMzdjMjMzZjU5M2U5OTYxNjA5ZDhiMDg1NWQwZWMyMzU3YTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-07T13:12:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-07T13:12:15Z"}, "message": "Auto merge of #47039 - ollie27:rustdoc_trait_impl_src, r=GuillaumeGomez\n\nrustdoc: Add missing src links for generic impls on trait pages\n\n`implementor2item` would return `None` for generic impls so instead this clones the entire `clean::Item` into the `implementors` map which simplifies some code.", "tree": {"sha": "97d9acdde36eb48860b3e7e145c676a90063bbd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97d9acdde36eb48860b3e7e145c676a90063bbd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8724337c233f593e9961609d8b0855d0ec2357a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8724337c233f593e9961609d8b0855d0ec2357a0", "html_url": "https://github.com/rust-lang/rust/commit/8724337c233f593e9961609d8b0855d0ec2357a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8724337c233f593e9961609d8b0855d0ec2357a0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69f17d1a0a3c860e3f5d7e643a6c3f8aa2b638a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/69f17d1a0a3c860e3f5d7e643a6c3f8aa2b638a6", "html_url": "https://github.com/rust-lang/rust/commit/69f17d1a0a3c860e3f5d7e643a6c3f8aa2b638a6"}, {"sha": "3d11d201d9f31074bd5954fff0f6933689d6c8f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d11d201d9f31074bd5954fff0f6933689d6c8f2", "html_url": "https://github.com/rust-lang/rust/commit/3d11d201d9f31074bd5954fff0f6933689d6c8f2"}], "stats": {"total": 95, "additions": 35, "deletions": 60}, "files": [{"sha": "7449c08fcd290b857c038317b13def01b823db43", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 30, "deletions": 60, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/8724337c233f593e9961609d8b0855d0ec2357a0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8724337c233f593e9961609d8b0855d0ec2357a0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=8724337c233f593e9961609d8b0855d0ec2357a0", "patch": "@@ -173,14 +173,7 @@ pub enum ExternalLocation {\n     Unknown,\n }\n \n-/// Metadata about an implementor of a trait.\n-pub struct Implementor {\n-    pub def_id: DefId,\n-    pub stability: Option<clean::Stability>,\n-    pub impl_: clean::Impl,\n-}\n-\n-/// Metadata about implementations for a type.\n+/// Metadata about implementations for a type or trait.\n #[derive(Clone)]\n pub struct Impl {\n     pub impl_item: clean::Item,\n@@ -279,7 +272,7 @@ pub struct Cache {\n     /// When rendering traits, it's often useful to be able to list all\n     /// implementors of the trait, and this mapping is exactly, that: a mapping\n     /// of trait ids to the list of known implementors of the trait\n-    pub implementors: FxHashMap<DefId, Vec<Implementor>>,\n+    pub implementors: FxHashMap<DefId, Vec<Impl>>,\n \n     /// Cache of where external crate documentation can be found.\n     pub extern_locations: FxHashMap<CrateNum, (String, PathBuf, ExternalLocation)>,\n@@ -971,12 +964,12 @@ fn write_shared(cx: &Context,\n             // there's no need to emit information about it (there's inlining\n             // going on). If they're in different crates then the crate defining\n             // the trait will be interested in our implementation.\n-            if imp.def_id.krate == did.krate { continue }\n+            if imp.impl_item.def_id.krate == did.krate { continue }\n             // If the implementation is from another crate then that crate\n             // should add it.\n-            if !imp.def_id.is_local() { continue }\n+            if !imp.impl_item.def_id.is_local() { continue }\n             have_impls = true;\n-            write!(implementors, \"{},\", as_json(&imp.impl_.to_string())).unwrap();\n+            write!(implementors, \"{},\", as_json(&imp.inner_impl().to_string())).unwrap();\n         }\n         implementors.push_str(\"];\");\n \n@@ -1208,10 +1201,8 @@ impl DocFolder for Cache {\n             if !self.masked_crates.contains(&item.def_id.krate) {\n                 if let Some(did) = i.trait_.def_id() {\n                     if i.for_.def_id().map_or(true, |d| !self.masked_crates.contains(&d.krate)) {\n-                        self.implementors.entry(did).or_insert(vec![]).push(Implementor {\n-                            def_id: item.def_id,\n-                            stability: item.stability.clone(),\n-                            impl_: i.clone(),\n+                        self.implementors.entry(did).or_insert(vec![]).push(Impl {\n+                            impl_item: item.clone(),\n                         });\n                     }\n                 }\n@@ -2338,18 +2329,6 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     document(w, cx, it)\n }\n \n-fn implementor2item<'a>(cache: &'a Cache, imp : &Implementor) -> Option<&'a clean::Item> {\n-    if let Some(t_did) = imp.impl_.for_.def_id() {\n-        if let Some(impl_item) = cache.impls.get(&t_did).and_then(|i| i.iter()\n-            .find(|i| i.impl_item.def_id == imp.def_id))\n-        {\n-            let i = &impl_item.impl_item;\n-            return Some(i);\n-        }\n-    }\n-    None\n-}\n-\n fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n               t: &clean::Trait) -> fmt::Result {\n     let mut bounds = String::new();\n@@ -2533,7 +2512,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         // if any Types with the same name but different DefId have been found.\n         let mut implementor_dups: FxHashMap<&str, (DefId, bool)> = FxHashMap();\n         for implementor in implementors {\n-            match implementor.impl_.for_ {\n+            match implementor.inner_impl().for_ {\n                 clean::ResolvedPath { ref path, did, is_generic: false, .. } |\n                 clean::BorrowedRef {\n                     type_: box clean::ResolvedPath { ref path, did, is_generic: false, .. },\n@@ -2550,7 +2529,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         }\n \n         let (local, foreign) = implementors.iter()\n-            .partition::<Vec<_>, _>(|i| i.impl_.for_.def_id()\n+            .partition::<Vec<_>, _>(|i| i.inner_impl().for_.def_id()\n                                          .map_or(true, |d| cache.paths.contains_key(&d)));\n \n         if !foreign.is_empty() {\n@@ -2561,42 +2540,37 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             \")?;\n \n             for implementor in foreign {\n-                if let Some(i) = implementor2item(&cache, implementor) {\n-                    let impl_ = Impl { impl_item: i.clone() };\n-                    let assoc_link = AssocItemLink::GotoSource(\n-                        i.def_id, &implementor.impl_.provided_trait_methods\n-                    );\n-                    render_impl(w, cx, &impl_, assoc_link,\n-                                RenderMode::Normal, i.stable_since(), false)?;\n-                }\n+                let assoc_link = AssocItemLink::GotoSource(\n+                    implementor.impl_item.def_id, &implementor.inner_impl().provided_trait_methods\n+                );\n+                render_impl(w, cx, &implementor, assoc_link,\n+                            RenderMode::Normal, implementor.impl_item.stable_since(), false)?;\n             }\n         }\n \n         write!(w, \"{}\", impl_header)?;\n \n         for implementor in local {\n             write!(w, \"<li>\")?;\n-            if let Some(item) = implementor2item(&cache, implementor) {\n-                if let Some(l) = (Item { cx, item }).src_href() {\n-                    write!(w, \"<div class='out-of-band'>\")?;\n-                    write!(w, \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n-                                l, \"goto source code\")?;\n-                    write!(w, \"</div>\")?;\n-                }\n+            if let Some(l) = (Item { cx, item: &implementor.impl_item }).src_href() {\n+                write!(w, \"<div class='out-of-band'>\")?;\n+                write!(w, \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n+                            l, \"goto source code\")?;\n+                write!(w, \"</div>\")?;\n             }\n             write!(w, \"<code>\")?;\n             // If there's already another implementor that has the same abbridged name, use the\n             // full path, for example in `std::iter::ExactSizeIterator`\n-            let use_absolute = match implementor.impl_.for_ {\n+            let use_absolute = match implementor.inner_impl().for_ {\n                 clean::ResolvedPath { ref path, is_generic: false, .. } |\n                 clean::BorrowedRef {\n                     type_: box clean::ResolvedPath { ref path, is_generic: false, .. },\n                     ..\n                 } => implementor_dups[path.last_name()].1,\n                 _ => false,\n             };\n-            fmt_impl_for_trait_page(&implementor.impl_, w, use_absolute)?;\n-            for it in &implementor.impl_.items {\n+            fmt_impl_for_trait_page(&implementor.inner_impl(), w, use_absolute)?;\n+            for it in &implementor.inner_impl().items {\n                 if let clean::TypedefItem(ref tydef, _) = it.inner {\n                     write!(w, \"<span class=\\\"where fmt-newline\\\">  \")?;\n                     assoc_type(w, it, &vec![], Some(&tydef.type_), AssocItemLink::Anchor(None))?;\n@@ -3886,20 +3860,16 @@ fn sidebar_trait(fmt: &mut fmt::Formatter, it: &clean::Item,\n \n     if let Some(implementors) = c.implementors.get(&it.def_id) {\n         let res = implementors.iter()\n-                              .filter(|i| i.impl_.for_.def_id()\n-                                                      .map_or(false, |d| !c.paths.contains_key(&d)))\n+                              .filter(|i| i.inner_impl().for_.def_id()\n+                                           .map_or(false, |d| !c.paths.contains_key(&d)))\n                               .filter_map(|i| {\n-                                  if let Some(item) = implementor2item(&c, i) {\n-                                      match extract_for_impl_name(&item) {\n-                                          Some((ref name, ref url)) => {\n-                                              Some(format!(\"<a href=\\\"#impl-{}\\\">{}</a>\",\n-                                                           small_url_encode(url),\n-                                                           Escape(name)))\n-                                          }\n-                                          _ => None,\n+                                  match extract_for_impl_name(&i.impl_item) {\n+                                      Some((ref name, ref url)) => {\n+                                          Some(format!(\"<a href=\\\"#impl-{}\\\">{}</a>\",\n+                                                      small_url_encode(url),\n+                                                      Escape(name)))\n                                       }\n-                                  } else {\n-                                      None\n+                                      _ => None,\n                                   }\n                               })\n                               .collect::<String>();"}, {"sha": "a5e343ade38637da0d5dc82176bc7bf169464a10", "filename": "src/test/rustdoc/issue-43893.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8724337c233f593e9961609d8b0855d0ec2357a0/src%2Ftest%2Frustdoc%2Fissue-43893.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8724337c233f593e9961609d8b0855d0ec2357a0/src%2Ftest%2Frustdoc%2Fissue-43893.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-43893.rs?ref=8724337c233f593e9961609d8b0855d0ec2357a0", "patch": "@@ -22,3 +22,8 @@ impl SomeTrait for usize {}\n impl SomeTrait for SomeStruct {\n     // deliberately multi-line impl\n }\n+\n+pub trait AnotherTrait {}\n+\n+// @has foo/trait.AnotherTrait.html '//a/@href' '../src/foo/issue-43893.rs.html#29'\n+impl<T> AnotherTrait for T {}"}]}