{"sha": "1ac8e8885bb1917f71ce432dcf181253b47f0bca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhYzhlODg4NWJiMTkxN2Y3MWNlNDMyZGNmMTgxMjUzYjQ3ZjBiY2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-03T13:56:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-03T13:56:05Z"}, "message": "auto merge of #8884 : blake2-ppc/rust/exact-size-hint, r=huonw\n\nThe message of the first commit explains (edited for changed trait name):\r\n\r\nThe trait `ExactSize` is introduced to solve a few small niggles:\r\n\r\n* We can't reverse (`.invert()`) an enumeration iterator\r\n* for a vector, we have `v.iter().position(f)` but `v.rposition(f)`.\r\n* We can't reverse `Zip` even if both iterators are from vectors\r\n\r\n`ExactSize` is an empty trait that is intended to indicate that an\r\niterator, for example `VecIterator`, knows its exact finite size and\r\nreports it correctly using `.size_hint()`. Only adaptors that preserve\r\nthis at all times, can expose this trait further. (Where here we say\r\nfinite for fitting in uint).\r\n\r\n---\r\n\r\nIt may seem complicated just to solve these small \"niggles\",\r\n(It's really the reversible enumerate case that's the most interesting)\r\nbut only a few core iterators need to implement this trait.\r\n\r\nWhile we gain more capabilities generically for some iterators,\r\nit becomes a tad more complicated to figure out if a type has\r\nthe right trait impls for it.", "tree": {"sha": "35276fcd4e7a3c376c0a71123c1e77dcb160d235", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35276fcd4e7a3c376c0a71123c1e77dcb160d235"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ac8e8885bb1917f71ce432dcf181253b47f0bca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ac8e8885bb1917f71ce432dcf181253b47f0bca", "html_url": "https://github.com/rust-lang/rust/commit/1ac8e8885bb1917f71ce432dcf181253b47f0bca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ac8e8885bb1917f71ce432dcf181253b47f0bca/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7048e05d5fb6aae8647494148a89bd902e5a913f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7048e05d5fb6aae8647494148a89bd902e5a913f", "html_url": "https://github.com/rust-lang/rust/commit/7048e05d5fb6aae8647494148a89bd902e5a913f"}, {"sha": "7c369ee7337cee50f8ef05b9d2833e2aa30d802e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c369ee7337cee50f8ef05b9d2833e2aa30d802e", "html_url": "https://github.com/rust-lang/rust/commit/7c369ee7337cee50f8ef05b9d2833e2aa30d802e"}], "stats": {"total": 223, "additions": 160, "deletions": 63}, "files": [{"sha": "03588d984d916f57031e6eb3b7a0c78cfe998632", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8e8885bb1917f71ce432dcf181253b47f0bca/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8e8885bb1917f71ce432dcf181253b47f0bca/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=1ac8e8885bb1917f71ce432dcf181253b47f0bca", "patch": "@@ -608,6 +608,8 @@ impl<'self> DoubleEndedIterator<bool> for BitvIterator<'self> {\n     }\n }\n \n+impl<'self> ExactSize<bool> for BitvIterator<'self> {}\n+\n impl<'self> RandomAccessIterator<bool> for BitvIterator<'self> {\n     #[inline]\n     fn indexable(&self) -> uint {"}, {"sha": "64bb17a6271db7c79443effd21ba10f7a6b65496", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8e8885bb1917f71ce432dcf181253b47f0bca/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8e8885bb1917f71ce432dcf181253b47f0bca/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=1ac8e8885bb1917f71ce432dcf181253b47f0bca", "patch": "@@ -472,6 +472,8 @@ impl<'self, A> DoubleEndedIterator<&'self A> for DListIterator<'self, A> {\n     }\n }\n \n+impl<'self, A> ExactSize<&'self A> for DListIterator<'self, A> {}\n+\n impl<'self, A> Iterator<&'self mut A> for MutDListIterator<'self, A> {\n     #[inline]\n     fn next(&mut self) -> Option<&'self mut A> {\n@@ -508,6 +510,7 @@ impl<'self, A> DoubleEndedIterator<&'self mut A> for MutDListIterator<'self, A>\n     }\n }\n \n+impl<'self, A> ExactSize<&'self mut A> for MutDListIterator<'self, A> {}\n \n /// Allow mutating the DList while iterating\n pub trait ListInsertion<A> {"}, {"sha": "cb76422815530686b23e5f562edeab5f15be9fef", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8e8885bb1917f71ce432dcf181253b47f0bca/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8e8885bb1917f71ce432dcf181253b47f0bca/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=1ac8e8885bb1917f71ce432dcf181253b47f0bca", "patch": "@@ -525,7 +525,7 @@ impl BigUint {\n     #[inline]\n     pub fn new(v: ~[BigDigit]) -> BigUint {\n         // omit trailing zeros\n-        let new_len = v.rposition(|n| *n != 0).map_move_default(0, |p| p + 1);\n+        let new_len = v.iter().rposition(|n| *n != 0).map_move_default(0, |p| p + 1);\n \n         if new_len == v.len() { return BigUint { data: v }; }\n         let mut v = v;"}, {"sha": "9ae9b47e2076e98f1954bd0009ff9dad71624bde", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8e8885bb1917f71ce432dcf181253b47f0bca/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8e8885bb1917f71ce432dcf181253b47f0bca/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=1ac8e8885bb1917f71ce432dcf181253b47f0bca", "patch": "@@ -243,6 +243,8 @@ pub struct RingBufIterator<'self, T> {\n iterator!{impl RingBufIterator -> &'self T, get_ref}\n iterator_rev!{impl RingBufIterator -> &'self T, get_ref}\n \n+impl<'self, T> ExactSize<&'self T> for RingBufIterator<'self, T> {}\n+\n impl<'self, T> RandomAccessIterator<&'self T> for RingBufIterator<'self, T> {\n     #[inline]\n     fn indexable(&self) -> uint { self.rindex - self.index }\n@@ -268,6 +270,8 @@ pub struct RingBufMutIterator<'self, T> {\n iterator!{impl RingBufMutIterator -> &'self mut T, get_mut_ref}\n iterator_rev!{impl RingBufMutIterator -> &'self mut T, get_mut_ref}\n \n+impl<'self, T> ExactSize<&'self mut T> for RingBufMutIterator<'self, T> {}\n+\n /// Grow is only called on full elts, so nelts is also len(elts), unlike\n /// elsewhere.\n fn grow<T>(nelts: uint, loptr: &mut uint, elts: &mut ~[Option<T>]) {"}, {"sha": "db67a624a9b35d6ef33b31270e857e733fd37c24", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 133, "deletions": 1, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8e8885bb1917f71ce432dcf181253b47f0bca/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8e8885bb1917f71ce432dcf181253b47f0bca/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=1ac8e8885bb1917f71ce432dcf181253b47f0bca", "patch": "@@ -18,7 +18,7 @@ implementing the `Iterator` trait.\n */\n \n use cmp;\n-use num::{Zero, One, Integer, CheckedAdd, Saturating};\n+use num::{Zero, One, Integer, CheckedAdd, CheckedSub, Saturating};\n use option::{Option, Some, None};\n use ops::{Add, Mul, Sub};\n use cmp::Ord;\n@@ -641,6 +641,7 @@ impl<'self, A, T: DoubleEndedIterator<&'self mut A>> MutableDoubleEndedIterator\n     }\n }\n \n+\n /// An object implementing random access indexing by `uint`\n ///\n /// A `RandomAccessIterator` should be either infinite or a `DoubleEndedIterator`.\n@@ -653,6 +654,48 @@ pub trait RandomAccessIterator<A>: Iterator<A> {\n     fn idx(&self, index: uint) -> Option<A>;\n }\n \n+/// An iterator that knows its exact length\n+///\n+/// This trait is a helper for iterators like the vector iterator, so that\n+/// it can support double-ended enumeration.\n+///\n+/// `Iterator::size_hint` *must* return the exact size of the iterator.\n+/// Note that the size must fit in `uint`.\n+pub trait ExactSize<A> : DoubleEndedIterator<A> {\n+    /// Return the index of the last element satisfying the specified predicate\n+    ///\n+    /// If no element matches, None is returned.\n+    #[inline]\n+    fn rposition(&mut self, predicate: &fn(A) -> bool) -> Option<uint> {\n+        let (lower, upper) = self.size_hint();\n+        assert!(upper == Some(lower));\n+        let mut i = lower;\n+        loop {\n+            match self.next_back() {\n+                None => break,\n+                Some(x) => {\n+                    i = match i.checked_sub(&1) {\n+                        Some(x) => x,\n+                        None => fail!(\"rposition: incorrect ExactSize\")\n+                    };\n+                    if predicate(x) {\n+                        return Some(i)\n+                    }\n+                }\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+// All adaptors that preserve the size of the wrapped iterator are fine\n+// Adaptors that may overflow in `size_hint` are not, i.e. `Chain`.\n+impl<A, T: ExactSize<A>> ExactSize<(uint, A)> for Enumerate<T> {}\n+impl<'self, A, T: ExactSize<A>> ExactSize<A> for Inspect<'self, A, T> {}\n+impl<A, T: ExactSize<A>> ExactSize<A> for Invert<T> {}\n+impl<'self, A, B, T: ExactSize<A>> ExactSize<B> for Map<'self, A, B, T> {}\n+impl<A, B, T: ExactSize<A>, U: ExactSize<B>> ExactSize<(A, B)> for Zip<T, U> {}\n+\n /// An double-ended iterator with the direction inverted\n #[deriving(Clone)]\n pub struct Invert<T> {\n@@ -956,6 +999,29 @@ impl<A, B, T: Iterator<A>, U: Iterator<B>> Iterator<(A, B)> for Zip<T, U> {\n     }\n }\n \n+impl<A, B, T: ExactSize<A>, U: ExactSize<B>> DoubleEndedIterator<(A, B)>\n+for Zip<T, U> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(A, B)> {\n+        let (a_sz, a_upper) = self.a.size_hint();\n+        let (b_sz, b_upper) = self.b.size_hint();\n+        assert!(a_upper == Some(a_sz));\n+        assert!(b_upper == Some(b_sz));\n+        if a_sz < b_sz {\n+            for _ in range(0, b_sz - a_sz) { self.b.next_back(); }\n+        } else if a_sz > b_sz {\n+            for _ in range(0, a_sz - b_sz) { self.a.next_back(); }\n+        }\n+        let (a_sz, _) = self.a.size_hint();\n+        let (b_sz, _) = self.b.size_hint();\n+        assert!(a_sz == b_sz);\n+        match (self.a.next_back(), self.b.next_back()) {\n+            (Some(x), Some(y)) => Some((x, y)),\n+            _ => None\n+        }\n+    }\n+}\n+\n impl<A, B, T: RandomAccessIterator<A>, U: RandomAccessIterator<B>>\n RandomAccessIterator<(A, B)> for Zip<T, U> {\n     #[inline]\n@@ -1137,6 +1203,20 @@ impl<A, T: Iterator<A>> Iterator<(uint, A)> for Enumerate<T> {\n     }\n }\n \n+impl<A, T: ExactSize<A>> DoubleEndedIterator<(uint, A)> for Enumerate<T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(uint, A)> {\n+        match self.iter.next_back() {\n+            Some(a) => {\n+                let (lower, upper) = self.iter.size_hint();\n+                assert!(upper == Some(lower));\n+                Some((self.count + lower, a))\n+            }\n+            _ => None\n+        }\n+    }\n+}\n+\n impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<(uint, A)> for Enumerate<T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -2331,6 +2411,33 @@ mod tests {\n         assert_eq!(it.next(), None);\n     }\n \n+    #[test]\n+    fn test_double_ended_enumerate() {\n+        let xs = [1, 2, 3, 4, 5, 6];\n+        let mut it = xs.iter().map(|&x| x).enumerate();\n+        assert_eq!(it.next(), Some((0, 1)));\n+        assert_eq!(it.next(), Some((1, 2)));\n+        assert_eq!(it.next_back(), Some((5, 6)));\n+        assert_eq!(it.next_back(), Some((4, 5)));\n+        assert_eq!(it.next_back(), Some((3, 4)));\n+        assert_eq!(it.next_back(), Some((2, 3)));\n+        assert_eq!(it.next(), None);\n+    }\n+\n+    #[test]\n+    fn test_double_ended_zip() {\n+        let xs = [1, 2, 3, 4, 5, 6];\n+        let ys = [1, 2, 3, 7];\n+        let a = xs.iter().map(|&x| x);\n+        let b = ys.iter().map(|&x| x);\n+        let mut it = a.zip(b);\n+        assert_eq!(it.next(), Some((1, 1)));\n+        assert_eq!(it.next(), Some((2, 2)));\n+        assert_eq!(it.next_back(), Some((4, 7)));\n+        assert_eq!(it.next_back(), Some((3, 3)));\n+        assert_eq!(it.next(), None);\n+    }\n+\n     #[test]\n     fn test_double_ended_filter() {\n         let xs = [1, 2, 3, 4, 5, 6];\n@@ -2367,6 +2474,31 @@ mod tests {\n         assert_eq!(it.next_back(), None)\n     }\n \n+    #[test]\n+    fn test_rposition() {\n+        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n+        fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n+        let v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n+\n+        assert_eq!(v.iter().rposition(f), Some(3u));\n+        assert!(v.iter().rposition(g).is_none());\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_rposition_fail() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do v.iter().rposition |_elt| {\n+            if i == 2 {\n+                fail!()\n+            }\n+            i += 1;\n+            false\n+        };\n+    }\n+\n+\n     #[cfg(test)]\n     fn check_randacc_iter<A: Eq, T: Clone + RandomAccessIterator<A>>(a: T, len: uint)\n     {"}, {"sha": "dd66630187db934b5d3616d065d348cc2f8b01d2", "filename": "src/libstd/option.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8e8885bb1917f71ce432dcf181253b47f0bca/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8e8885bb1917f71ce432dcf181253b47f0bca/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=1ac8e8885bb1917f71ce432dcf181253b47f0bca", "patch": "@@ -46,7 +46,7 @@ use cmp::{Eq,Ord};\n use util;\n use num::Zero;\n use iterator;\n-use iterator::{Iterator, DoubleEndedIterator};\n+use iterator::{Iterator, DoubleEndedIterator, ExactSize};\n use str::{StrSlice, OwnedStr};\n use to_str::ToStr;\n use clone::DeepClone;\n@@ -402,6 +402,8 @@ impl<A> DoubleEndedIterator<A> for OptionIterator<A> {\n     }\n }\n \n+impl<A> ExactSize<A> for OptionIterator<A> {}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "8f202ee85312ffaf80d45515963bdf4f3ea84f85", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8e8885bb1917f71ce432dcf181253b47f0bca/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8e8885bb1917f71ce432dcf181253b47f0bca/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=1ac8e8885bb1917f71ce432dcf181253b47f0bca", "patch": "@@ -52,7 +52,7 @@ pub use hash::Hash;\n pub use num::Times;\n pub use iterator::{FromIterator, Extendable};\n pub use iterator::{Iterator, DoubleEndedIterator, RandomAccessIterator, ClonableIterator};\n-pub use iterator::{OrdIterator, MutableDoubleEndedIterator};\n+pub use iterator::{OrdIterator, MutableDoubleEndedIterator, ExactSize};\n pub use num::{Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n pub use num::{Orderable, Signed, Unsigned, Round};\n pub use num::{Algebraic, Trigonometric, Exponential, Hyperbolic};"}, {"sha": "9f4fd8db78847881fc627bef172e1a0075643559", "filename": "src/libstd/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8e8885bb1917f71ce432dcf181253b47f0bca/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8e8885bb1917f71ce432dcf181253b47f0bca/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=1ac8e8885bb1917f71ce432dcf181253b47f0bca", "patch": "@@ -11,7 +11,7 @@\n use cell::Cell;\n use comm;\n use container::Container;\n-use iterator::Iterator;\n+use iterator::{Iterator, DoubleEndedIterator};\n use option::*;\n // use either::{Either, Left, Right};\n // use rt::kill::BlockedTask;\n@@ -87,7 +87,7 @@ pub fn select<A: Select>(ports: &mut [A]) -> uint {\n     // Task resumes. Now unblock ourselves from all the ports we blocked on.\n     // If the success index wasn't reset, 'take' will just take all of them.\n     // Iterate in reverse so the 'earliest' index that's ready gets returned.\n-    for (index, port) in ports.mut_slice(0, ready_index).mut_rev_iter().enumerate() {\n+    for (index, port) in ports.mut_slice(0, ready_index).mut_iter().enumerate().invert() {\n         if port.unblock_from() {\n             ready_index = index;\n         }"}, {"sha": "e4d1b324e7368683fdde3d8bb17f7c2f4bfd1193", "filename": "src/libstd/str.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8e8885bb1917f71ce432dcf181253b47f0bca/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8e8885bb1917f71ce432dcf181253b47f0bca/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=1ac8e8885bb1917f71ce432dcf181253b47f0bca", "patch": "@@ -24,7 +24,7 @@ use container::{Container, Mutable};\n use num::Times;\n use iterator::{Iterator, FromIterator, Extendable};\n use iterator::{Filter, AdditiveIterator, Map};\n-use iterator::{Invert, DoubleEndedIterator};\n+use iterator::{Invert, DoubleEndedIterator, ExactSize};\n use libc;\n use num::{Saturating};\n use option::{None, Option, Some};\n@@ -484,9 +484,8 @@ for CharSplitIterator<'self, Sep> {\n         let mut next_split = None;\n \n         if self.only_ascii {\n-            for (j, byte) in self.string.byte_rev_iter().enumerate() {\n+            for (idx, byte) in self.string.byte_iter().enumerate().invert() {\n                 if self.sep.matches(byte as char) && byte < 128u8 {\n-                    let idx = len - j - 1;\n                     next_split = Some((idx, idx + 1));\n                     break;\n                 }\n@@ -2006,16 +2005,13 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// or `None` if there is no match\n     fn find<C: CharEq>(&self, search: C) -> Option<uint> {\n         if search.only_ascii() {\n-            for (i, b) in self.byte_iter().enumerate() {\n-                if search.matches(b as char) { return Some(i) }\n-            }\n+            self.byte_iter().position(|b| search.matches(b as char))\n         } else {\n             for (index, c) in self.char_offset_iter() {\n                 if search.matches(c) { return Some(index); }\n             }\n+            None\n         }\n-\n-        None\n     }\n \n     /// Returns the byte index of the last character of `self` that matches `search`\n@@ -2026,18 +2022,13 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// or `None` if there is no match\n     fn rfind<C: CharEq>(&self, search: C) -> Option<uint> {\n         if search.only_ascii() {\n-            let mut index = self.len();\n-            for b in self.byte_rev_iter() {\n-                index -= 1;\n-                if search.matches(b as char) { return Some(index); }\n-            }\n+            self.byte_iter().rposition(|b| search.matches(b as char))\n         } else {\n             for (index, c) in self.char_offset_rev_iter() {\n                 if search.matches(c) { return Some(index); }\n             }\n+            None\n         }\n-\n-        None\n     }\n \n     /// Returns the byte index of the first matching substring"}, {"sha": "f607d1612ad81905c0a0b27cb4b2f28adfcd904e", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 5, "deletions": 42, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8e8885bb1917f71ce432dcf181253b47f0bca/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8e8885bb1917f71ce432dcf181253b47f0bca/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=1ac8e8885bb1917f71ce432dcf181253b47f0bca", "patch": "@@ -274,7 +274,7 @@ impl<'self, T> Iterator<&'self [T]> for RSplitIterator<'self, T> {\n             return Some(self.v);\n         }\n \n-        match self.v.rposition(|x| (self.pred)(x)) {\n+        match self.v.iter().rposition(|x| (self.pred)(x)) {\n             None => {\n                 self.finished = true;\n                 Some(self.v)\n@@ -832,7 +832,6 @@ pub trait ImmutableVector<'self, T> {\n     fn initn(&self, n: uint) -> &'self [T];\n     fn last(&self) -> &'self T;\n     fn last_opt(&self) -> Option<&'self T>;\n-    fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n     fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n     unsafe fn unsafe_ref(&self, index: uint) -> *T;\n \n@@ -1048,21 +1047,6 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n             if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n     }\n \n-    /**\n-     * Find the last index matching some predicate\n-     *\n-     * Apply function `f` to each element of `v` in reverse order.  When\n-     * function `f` returns true then an option containing the index is\n-     * returned. If `f` matches no elements then None is returned.\n-     */\n-    #[inline]\n-    fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint> {\n-        for (i, t) in self.rev_iter().enumerate() {\n-            if f(t) { return Some(self.len() - i - 1); }\n-        }\n-        None\n-    }\n-\n     /**\n      * Apply a function to each element of a vector and return a concatenation\n      * of each result vector\n@@ -1145,7 +1129,7 @@ impl<'self,T:Eq> ImmutableEqVector<T> for &'self [T] {\n     /// Find the last index containing a matching value\n     #[inline]\n     fn rposition_elem(&self, t: &T) -> Option<uint> {\n-        self.rposition(|x| *x == *t)\n+        self.iter().rposition(|x| *x == *t)\n     }\n \n     /// Return true if a vector contains an element with the given value\n@@ -2319,6 +2303,9 @@ iterator!{impl VecIterator -> &'self T}\n double_ended_iterator!{impl VecIterator -> &'self T}\n pub type RevIterator<'self, T> = Invert<VecIterator<'self, T>>;\n \n+impl<'self, T> ExactSize<&'self T> for VecIterator<'self, T> {}\n+impl<'self, T> ExactSize<&'self mut T> for VecMutIterator<'self, T> {}\n+\n impl<'self, T> Clone for VecIterator<'self, T> {\n     fn clone(&self) -> VecIterator<'self, T> { *self }\n }\n@@ -2923,16 +2910,6 @@ mod tests {\n         assert!(v1.position_elem(&4).is_none());\n     }\n \n-    #[test]\n-    fn test_rposition() {\n-        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n-        fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n-        let v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n-\n-        assert_eq!(v.rposition(f), Some(3u));\n-        assert!(v.rposition(g).is_none());\n-    }\n-\n     #[test]\n     fn test_bsearch_elem() {\n         assert_eq!([1,2,3,4,5].bsearch_elem(&5), Some(4));\n@@ -3212,20 +3189,6 @@ mod tests {\n         };\n     }\n \n-    #[test]\n-    #[should_fail]\n-    fn test_rposition_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do v.rposition |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-            false\n-        };\n-    }\n-\n     #[test]\n     #[should_fail]\n     fn test_permute_fail() {"}]}