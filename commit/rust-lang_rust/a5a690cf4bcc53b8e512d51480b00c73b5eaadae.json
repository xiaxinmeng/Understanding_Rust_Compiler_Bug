{"sha": "a5a690cf4bcc53b8e512d51480b00c73b5eaadae", "node_id": "C_kwDOAAsO6NoAKGE1YTY5MGNmNGJjYzUzYjhlNTEyZDUxNDgwYjAwYzczYjVlYWFkYWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-02T12:17:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-02T12:17:52Z"}, "message": "Auto merge of #109008 - clubby789:drop-elaborate-array, r=davidtwco\n\nDrop array patterns using subslices\n\nFixes #109004\nDrops contiguous subslices of an array when moving elements out with a pattern, which improves perf for large arrays\nr? `@compiler-errors`", "tree": {"sha": "2124c9d547eff55e78dc89dc340b175d09290cb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2124c9d547eff55e78dc89dc340b175d09290cb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5a690cf4bcc53b8e512d51480b00c73b5eaadae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5a690cf4bcc53b8e512d51480b00c73b5eaadae", "html_url": "https://github.com/rust-lang/rust/commit/a5a690cf4bcc53b8e512d51480b00c73b5eaadae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5a690cf4bcc53b8e512d51480b00c73b5eaadae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11cd4ff34db4dca57acd4782a78a5987bb153608", "url": "https://api.github.com/repos/rust-lang/rust/commits/11cd4ff34db4dca57acd4782a78a5987bb153608", "html_url": "https://github.com/rust-lang/rust/commit/11cd4ff34db4dca57acd4782a78a5987bb153608"}, {"sha": "ce2d52841b30616b3258685439ab13b03520ae10", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce2d52841b30616b3258685439ab13b03520ae10", "html_url": "https://github.com/rust-lang/rust/commit/ce2d52841b30616b3258685439ab13b03520ae10"}], "stats": {"total": 88, "additions": 70, "deletions": 18}, "files": [{"sha": "7ef3d41ac48c4fa1e05493c89afed510eaef3601", "filename": "compiler/rustc_mir_dataflow/src/elaborate_drops.rs", "status": "modified", "additions": 54, "deletions": 18, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a5a690cf4bcc53b8e512d51480b00c73b5eaadae/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5a690cf4bcc53b8e512d51480b00c73b5eaadae/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs?ref=a5a690cf4bcc53b8e512d51480b00c73b5eaadae", "patch": "@@ -729,23 +729,59 @@ where\n         let tcx = self.tcx();\n \n         if let Some(size) = opt_size {\n-            let fields: Vec<(Place<'tcx>, Option<D::Path>)> = (0..size)\n-                .map(|i| {\n-                    (\n-                        tcx.mk_place_elem(\n-                            self.place,\n-                            ProjectionElem::ConstantIndex {\n-                                offset: i,\n-                                min_length: size,\n-                                from_end: false,\n-                            },\n-                        ),\n-                        self.elaborator.array_subpath(self.path, i, size),\n-                    )\n-                })\n-                .collect();\n-\n-            if fields.iter().any(|(_, path)| path.is_some()) {\n+            enum ProjectionKind<Path> {\n+                Drop(std::ops::Range<u64>),\n+                Keep(u64, Path),\n+            }\n+            // Previously, we'd make a projection for every element in the array and create a drop\n+            // ladder if any `array_subpath` was `Some`, i.e. moving out with an array pattern.\n+            // This caused huge memory usage when generating the drops for large arrays, so we instead\n+            // record the *subslices* which are dropped and the *indexes* which are kept\n+            let mut drop_ranges = vec![];\n+            let mut dropping = true;\n+            let mut start = 0;\n+            for i in 0..size {\n+                let path = self.elaborator.array_subpath(self.path, i, size);\n+                if dropping && path.is_some() {\n+                    drop_ranges.push(ProjectionKind::Drop(start..i));\n+                    dropping = false;\n+                } else if !dropping && path.is_none() {\n+                    dropping = true;\n+                    start = i;\n+                }\n+                if let Some(path) = path {\n+                    drop_ranges.push(ProjectionKind::Keep(i, path));\n+                }\n+            }\n+            if !drop_ranges.is_empty() {\n+                if dropping {\n+                    drop_ranges.push(ProjectionKind::Drop(start..size));\n+                }\n+                let fields = drop_ranges\n+                    .iter()\n+                    .rev()\n+                    .map(|p| {\n+                        let (project, path) = match p {\n+                            ProjectionKind::Drop(r) => (\n+                                ProjectionElem::Subslice {\n+                                    from: r.start,\n+                                    to: r.end,\n+                                    from_end: false,\n+                                },\n+                                None,\n+                            ),\n+                            &ProjectionKind::Keep(offset, path) => (\n+                                ProjectionElem::ConstantIndex {\n+                                    offset,\n+                                    min_length: size,\n+                                    from_end: false,\n+                                },\n+                                Some(path),\n+                            ),\n+                        };\n+                        (tcx.mk_place_elem(self.place, project), path)\n+                    })\n+                    .collect::<Vec<_>>();\n                 let (succ, unwind) = self.drop_ladder_bottom();\n                 return self.drop_ladder(fields, succ, unwind).0;\n             }\n@@ -824,7 +860,7 @@ where\n                 let size = size.try_eval_target_usize(self.tcx(), self.elaborator.param_env());\n                 self.open_drop_for_array(*ety, size)\n             }\n-            ty::Slice(ety) => self.open_drop_for_array(*ety, None),\n+            ty::Slice(ety) => self.drop_loop_pair(*ety),\n \n             _ => span_bug!(self.source_info.span, \"open drop from non-ADT `{:?}`\", ty),\n         }"}, {"sha": "5e3361cef6e364872de23a6bed0038820388a2f8", "filename": "tests/ui/mir/issue-109004-drop-large-array.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a5a690cf4bcc53b8e512d51480b00c73b5eaadae/tests%2Fui%2Fmir%2Fissue-109004-drop-large-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5a690cf4bcc53b8e512d51480b00c73b5eaadae/tests%2Fui%2Fmir%2Fissue-109004-drop-large-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmir%2Fissue-109004-drop-large-array.rs?ref=a5a690cf4bcc53b8e512d51480b00c73b5eaadae", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+\n+const SZ: usize = 64_000_000;\n+type BigDrop = [String; SZ];\n+\n+fn f(_dropme: BigDrop) {}\n+\n+fn f2(_moveme: BigDrop) -> String {\n+    let [a, ..] = _moveme;\n+    a\n+}\n+\n+fn main() {\n+    f(std::array::from_fn(|_| String::new()));\n+    f2(std::array::from_fn(|_| String::new()));\n+}"}]}