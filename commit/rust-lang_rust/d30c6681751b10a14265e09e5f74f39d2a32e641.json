{"sha": "d30c6681751b10a14265e09e5f74f39d2a32e641", "node_id": "C_kwDOAAsO6NoAKGQzMGM2NjgxNzUxYjEwYTE0MjY1ZTA5ZTVmNzRmMzlkMmEzMmU2NDE", "commit": {"author": {"name": "Deadbeef", "email": "ent3rm4n@gmail.com", "date": "2023-04-28T15:28:52Z"}, "committer": {"name": "Deadbeef", "email": "ent3rm4n@gmail.com", "date": "2023-05-02T10:32:08Z"}, "message": "make cook generic", "tree": {"sha": "c2ec2a09ab6a0e568a0e430148790a080ca9024d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2ec2a09ab6a0e568a0e430148790a080ca9024d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d30c6681751b10a14265e09e5f74f39d2a32e641", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d30c6681751b10a14265e09e5f74f39d2a32e641", "html_url": "https://github.com/rust-lang/rust/commit/d30c6681751b10a14265e09e5f74f39d2a32e641", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d30c6681751b10a14265e09e5f74f39d2a32e641/comments", "author": {"login": "fee1-dead", "id": 43851243, "node_id": "MDQ6VXNlcjQzODUxMjQz", "avatar_url": "https://avatars.githubusercontent.com/u/43851243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fee1-dead", "html_url": "https://github.com/fee1-dead", "followers_url": "https://api.github.com/users/fee1-dead/followers", "following_url": "https://api.github.com/users/fee1-dead/following{/other_user}", "gists_url": "https://api.github.com/users/fee1-dead/gists{/gist_id}", "starred_url": "https://api.github.com/users/fee1-dead/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fee1-dead/subscriptions", "organizations_url": "https://api.github.com/users/fee1-dead/orgs", "repos_url": "https://api.github.com/users/fee1-dead/repos", "events_url": "https://api.github.com/users/fee1-dead/events{/privacy}", "received_events_url": "https://api.github.com/users/fee1-dead/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fee1-dead", "id": 43851243, "node_id": "MDQ6VXNlcjQzODUxMjQz", "avatar_url": "https://avatars.githubusercontent.com/u/43851243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fee1-dead", "html_url": "https://github.com/fee1-dead", "followers_url": "https://api.github.com/users/fee1-dead/followers", "following_url": "https://api.github.com/users/fee1-dead/following{/other_user}", "gists_url": "https://api.github.com/users/fee1-dead/gists{/gist_id}", "starred_url": "https://api.github.com/users/fee1-dead/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fee1-dead/subscriptions", "organizations_url": "https://api.github.com/users/fee1-dead/orgs", "repos_url": "https://api.github.com/users/fee1-dead/repos", "events_url": "https://api.github.com/users/fee1-dead/events{/privacy}", "received_events_url": "https://api.github.com/users/fee1-dead/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d905a8cc14783bc577dc0534d2516d16ef3e43b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d905a8cc14783bc577dc0534d2516d16ef3e43b", "html_url": "https://github.com/rust-lang/rust/commit/6d905a8cc14783bc577dc0534d2516d16ef3e43b"}], "stats": {"total": 64, "additions": 27, "deletions": 37}, "files": [{"sha": "9d0037b8a808386d058582aa55e60f3385dc4c4f", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 27, "deletions": 37, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d30c6681751b10a14265e09e5f74f39d2a32e641/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d30c6681751b10a14265e09e5f74f39d2a32e641/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=d30c6681751b10a14265e09e5f74f39d2a32e641", "patch": "@@ -1,3 +1,5 @@\n+use std::ops::Range;\n+\n use crate::errors;\n use crate::lexer::unicode_chars::UNICODE_ARRAY;\n use crate::make_unclosed_delims_error;\n@@ -6,7 +8,7 @@ use rustc_ast::token::{self, CommentKind, Delimiter, Token, TokenKind};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::util::unicode::contains_text_flow_control_chars;\n use rustc_errors::{error_code, Applicability, Diagnostic, DiagnosticBuilder, StashKey};\n-use rustc_lexer::unescape::{self, Mode};\n+use rustc_lexer::unescape::{self, EscapeError, Mode};\n use rustc_lexer::Cursor;\n use rustc_lexer::{Base, DocStyle, RawStrError};\n use rustc_session::lint::builtin::{\n@@ -670,20 +672,21 @@ impl<'a> StringReader<'a> {\n         self.sess.emit_fatal(errors::TooManyHashes { span: self.mk_sp(start, self.pos), num });\n     }\n \n-    fn cook_quoted(\n+    fn cook_common(\n         &self,\n         kind: token::LitKind,\n         mode: Mode,\n         start: BytePos,\n         end: BytePos,\n         prefix_len: u32,\n         postfix_len: u32,\n+        unescape: fn(&str, Mode, &mut dyn FnMut(Range<usize>, Result<(), EscapeError>)),\n     ) -> (token::LitKind, Symbol) {\n         let mut has_fatal_err = false;\n         let content_start = start + BytePos(prefix_len);\n         let content_end = end - BytePos(postfix_len);\n         let lit_content = self.str_from_to(content_start, content_end);\n-        unescape::unescape_literal(lit_content, mode, &mut |range, result| {\n+        unescape(lit_content, mode, &mut |range, result| {\n             // Here we only check for errors. The actual unescaping is done later.\n             if let Err(err) = result {\n                 let span_with_quotes = self.mk_sp(start, end);\n@@ -715,7 +718,7 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n-    fn cook_c_string(\n+    fn cook_quoted(\n         &self,\n         kind: token::LitKind,\n         mode: Mode,\n@@ -724,40 +727,27 @@ impl<'a> StringReader<'a> {\n         prefix_len: u32,\n         postfix_len: u32,\n     ) -> (token::LitKind, Symbol) {\n-        let mut has_fatal_err = false;\n-        let content_start = start + BytePos(prefix_len);\n-        let content_end = end - BytePos(postfix_len);\n-        let lit_content = self.str_from_to(content_start, content_end);\n-        unescape::unescape_c_string(lit_content, mode, &mut |range, result| {\n-            // Here we only check for errors. The actual unescaping is done later.\n-            if let Err(err) = result {\n-                let span_with_quotes = self.mk_sp(start, end);\n-                let (start, end) = (range.start as u32, range.end as u32);\n-                let lo = content_start + BytePos(start);\n-                let hi = lo + BytePos(end - start);\n-                let span = self.mk_sp(lo, hi);\n-                if err.is_fatal() {\n-                    has_fatal_err = true;\n-                }\n-                emit_unescape_error(\n-                    &self.sess.span_diagnostic,\n-                    lit_content,\n-                    span_with_quotes,\n-                    span,\n-                    mode,\n-                    range,\n-                    err,\n-                );\n-            }\n-        });\n+        self.cook_common(kind, mode, start, end, prefix_len, postfix_len, |src, mode, callback| {\n+            unescape::unescape_literal(src, mode, &mut |span, result| {\n+                callback(span, result.map(drop))\n+            })\n+        })\n+    }\n \n-        // We normally exclude the quotes for the symbol, but for errors we\n-        // include it because it results in clearer error messages.\n-        if !has_fatal_err {\n-            (kind, Symbol::intern(lit_content))\n-        } else {\n-            (token::Err, self.symbol_from_to(start, end))\n-        }\n+    fn cook_c_string(\n+        &self,\n+        kind: token::LitKind,\n+        mode: Mode,\n+        start: BytePos,\n+        end: BytePos,\n+        prefix_len: u32,\n+        postfix_len: u32,\n+    ) -> (token::LitKind, Symbol) {\n+        self.cook_common(kind, mode, start, end, prefix_len, postfix_len, |src, mode, callback| {\n+            unescape::unescape_c_string(src, mode, &mut |span, result| {\n+                callback(span, result.map(drop))\n+            })\n+        })\n     }\n }\n "}]}