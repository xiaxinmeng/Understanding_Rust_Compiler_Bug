{"sha": "b69b72973ad267086b92cac9dfb1e1f16820ddb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2OWI3Mjk3M2FkMjY3MDg2YjkyY2FjOWRmYjFlMWYxNjgyMGRkYjI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-04-22T12:48:56Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-04-24T19:13:23Z"}, "message": "Generate simple debuginfo for arguments", "tree": {"sha": "28d438a44fa0caf3c029d4a3883458c49bac38af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28d438a44fa0caf3c029d4a3883458c49bac38af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b69b72973ad267086b92cac9dfb1e1f16820ddb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b69b72973ad267086b92cac9dfb1e1f16820ddb2", "html_url": "https://github.com/rust-lang/rust/commit/b69b72973ad267086b92cac9dfb1e1f16820ddb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b69b72973ad267086b92cac9dfb1e1f16820ddb2/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "169140506366d5aa96967a71b6af98563a9c2988", "url": "https://api.github.com/repos/rust-lang/rust/commits/169140506366d5aa96967a71b6af98563a9c2988", "html_url": "https://github.com/rust-lang/rust/commit/169140506366d5aa96967a71b6af98563a9c2988"}], "stats": {"total": 74, "additions": 67, "deletions": 7}, "files": [{"sha": "fe56367292654ec281ce1165b47926ffb526ff0a", "filename": "src/debuginfo/mod.rs", "status": "modified", "additions": 67, "deletions": 7, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b69b72973ad267086b92cac9dfb1e1f16820ddb2/src%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b69b72973ad267086b92cac9dfb1e1f16820ddb2/src%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fmod.rs?ref=b69b72973ad267086b92cac9dfb1e1f16820ddb2", "patch": "@@ -35,6 +35,7 @@ pub(crate) struct DebugContext<'tcx> {\n     dwarf: DwarfUnit,\n     unit_range_list: RangeList,\n \n+    clif_types: FxHashMap<Type, UnitEntryId>,\n     types: FxHashMap<Ty<'tcx>, UnitEntryId>,\n }\n \n@@ -116,10 +117,45 @@ impl<'tcx> DebugContext<'tcx> {\n             dwarf,\n             unit_range_list: RangeList(Vec::new()),\n \n+            clif_types: FxHashMap::default(),\n             types: FxHashMap::default(),\n         }\n     }\n \n+    fn dwarf_ty_for_clif_ty(&mut self, ty: Type) -> UnitEntryId {\n+        if let Some(type_id) = self.clif_types.get(&ty) {\n+            return *type_id;\n+        }\n+\n+        let new_entry = |dwarf: &mut DwarfUnit, tag| dwarf.unit.add(dwarf.unit.root(), tag);\n+\n+        let primitive = |dwarf: &mut DwarfUnit, ate| {\n+            let type_id = new_entry(dwarf, gimli::DW_TAG_base_type);\n+            let type_entry = dwarf.unit.get_mut(type_id);\n+            type_entry.set(gimli::DW_AT_encoding, AttributeValue::Encoding(ate));\n+            type_id\n+        };\n+\n+        let type_id = if ty.is_bool() {\n+            primitive(&mut self.dwarf, gimli::DW_ATE_boolean)\n+        } else if ty.is_int() {\n+            primitive(&mut self.dwarf, gimli::DW_ATE_address)\n+        } else if ty.is_float() {\n+            primitive(&mut self.dwarf, gimli::DW_ATE_float)\n+        } else {\n+            new_entry(&mut self.dwarf, gimli::DW_TAG_structure_type)\n+        };\n+\n+        let type_entry = self.dwarf.unit.get_mut(type_id);\n+        type_entry.set(gimli::DW_AT_name, AttributeValue::String(format!(\"{}\", ty).replace('i', \"u\").into_bytes()));\n+        type_entry.set(\n+            gimli::DW_AT_byte_size,\n+            AttributeValue::Udata(u64::from(ty.bytes())),\n+        );\n+\n+        type_id\n+    }\n+\n     fn dwarf_ty(&mut self, ty: Ty<'tcx>) -> UnitEntryId {\n         if let Some(type_id) = self.types.get(ty) {\n             return *type_id;\n@@ -249,11 +285,6 @@ impl<'a, 'tcx> FunctionDebugContext<'a, 'tcx> {\n     }\n \n     fn define_local(&mut self, name: String, ty: Ty<'tcx>) -> UnitEntryId {\n-        let ty = self.debug_context.tcx.subst_and_normalize_erasing_regions(\n-            self.instance.substs,\n-            ty::ParamEnv::reveal_all(),\n-            &ty,\n-        );\n         let dw_ty = self.debug_context.dwarf_ty(ty);\n \n         let var_id = self\n@@ -290,15 +321,44 @@ impl<'a, 'tcx> FunctionDebugContext<'a, 'tcx> {\n                     symbol: self.symbol,\n                     addend: 0,\n                 },\n-                length: end as u64,\n+                length: u64::from(end),\n             });\n \n+        // FIXME Remove once actual debuginfo for locals works.\n+        for (i, (param, &val)) in context.func.signature.params.iter().zip(context.func.dfg.block_params(context.func.layout.entry_block().unwrap())).enumerate() {\n+            use cranelift_codegen::ir::ArgumentPurpose;\n+            let base_name = match param.purpose {\n+                ArgumentPurpose::Normal => \"arg\",\n+                ArgumentPurpose::StructReturn => \"sret\",\n+                ArgumentPurpose::Link | ArgumentPurpose::FramePointer | ArgumentPurpose::CalleeSaved => continue,\n+                ArgumentPurpose::VMContext | ArgumentPurpose::SignatureId | ArgumentPurpose::StackLimit => unreachable!(),\n+            };\n+            let name = format!(\"{}{}\", base_name, i);\n+\n+            let dw_ty = self.debug_context.dwarf_ty_for_clif_ty(param.value_type);\n+            let loc = Expression(\n+                translate_loc(isa, context.func.locations[val], &context.func.stack_slots).unwrap(),\n+            );\n+\n+            let arg_id = self.debug_context.dwarf.unit.add(self.entry_id, gimli::DW_TAG_formal_parameter);\n+            let var_entry = self.debug_context.dwarf.unit.get_mut(arg_id);\n+\n+            var_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n+            var_entry.set(gimli::DW_AT_type, AttributeValue::ThisUnitEntryRef(dw_ty));\n+            var_entry.set(gimli::DW_AT_location, AttributeValue::Exprloc(loc));\n+        }\n+\n         // FIXME make it more reliable and implement scopes before re-enabling this.\n         if false {\n             let value_labels_ranges = context.build_value_labels_ranges(isa).unwrap();\n \n             for (local, _local_decl) in self.mir.local_decls.iter_enumerated() {\n-                let var_id = self.define_local(format!(\"{:?}\", local), &self.mir.local_decls[local].ty);\n+                let ty = self.debug_context.tcx.subst_and_normalize_erasing_regions(\n+                    self.instance.substs,\n+                    ty::ParamEnv::reveal_all(),\n+                    &self.mir.local_decls[local].ty,\n+                );\n+                let var_id = self.define_local(format!(\"{:?}\", local), ty);\n \n                 let location = place_location(\n                     self,"}]}