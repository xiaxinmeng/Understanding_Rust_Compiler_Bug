{"sha": "b26daf3a67a4e283a5e2c49227b60a2321434de0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNmRhZjNhNjdhNGUyODNhNWUyYzQ5MjI3YjYwYTIzMjE0MzRkZTA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-28T18:29:56Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-29T22:11:16Z"}, "message": "std: Second pass stabilization for `string`\n\nThis commit performs a second pass over the `std::string` module, performing the\nfollowing actions:\n\n* The name `std::string` is now stable.\n* The `String::from_utf8` function is now stable after having been altered to\n  return a new `FromUtf8Error` structure. The `FromUtf8Error` structure is now\n  stable as well as its `into_bytes` and `utf8_error` methods.\n* The `String::from_utf8_lossy` function is now stable.\n* The `String::from_chars` method is now deprecated in favor of `.collect()`\n* The `String::from_raw_parts` method is now stable\n* The `String::from_str` function remains experimental\n* The `String::from_raw_buf` function remains experimental\n* The `String::from_raw_buf_len` function remains experimental\n* The `String::from_utf8_unchecked` function is now stable\n* The `String::from_char` function is now deprecated in favor of\n  `repeat(c).take(n).collect()`\n* The `String::grow` function is now deprecated in favor of\n  `.extend(repeat(c).take(n)`\n* The `String::capacity` method is now stable\n* The `String::reserve` method is now stable\n* The `String::reserve_exact` method is now stable\n* The `String::shrink_to_fit` method is now stable\n* The `String::pop` method is now stable\n* The `String::as_mut_vec` method is now stable\n* The `String::is_empty` method is now stable\n* The `IntoString` trait is now deprecated (there are no implementors)\n* The `String::truncate` method is now stable\n* The `String::insert` method is now stable\n* The `String::remove` method is now stable\n* The `String::push` method is now stable\n* The `String::push_str` method is now stable\n* The `String::from_utf16` function is now stable after its error type has now\n  become an opaque structure to carry more semantic information in the future.\n\nA number of these changes are breaking changes, but the migrations should be\nfairly straightforward on a case-by-case basis (outlined above where possible).\n\n[breaking-change]", "tree": {"sha": "9528d05be2a4e20a4d7b76ad76b3e930c6a6b636", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9528d05be2a4e20a4d7b76ad76b3e930c6a6b636"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b26daf3a67a4e283a5e2c49227b60a2321434de0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b26daf3a67a4e283a5e2c49227b60a2321434de0", "html_url": "https://github.com/rust-lang/rust/commit/b26daf3a67a4e283a5e2c49227b60a2321434de0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b26daf3a67a4e283a5e2c49227b60a2321434de0/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3dcc409fac18a258ba2a8af4345d9566ec8eebad", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dcc409fac18a258ba2a8af4345d9566ec8eebad", "html_url": "https://github.com/rust-lang/rust/commit/3dcc409fac18a258ba2a8af4345d9566ec8eebad"}], "stats": {"total": 197, "additions": 124, "deletions": 73}, "files": [{"sha": "e6e9ce64198ace6938517c6e7a8f32f2435086e2", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b26daf3a67a4e283a5e2c49227b60a2321434de0/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26daf3a67a4e283a5e2c49227b60a2321434de0/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=b26daf3a67a4e283a5e2c49227b60a2321434de0", "patch": "@@ -87,8 +87,6 @@ pub use core::str::Str;\n pub use core::str::{from_utf8_unchecked, from_c_str};\n pub use unicode::str::{Words, Graphemes, GraphemeIndices};\n \n-// FIXME(conventions): ensure bit/char conventions are followed by str's API\n-\n /*\n Section: Creating a string\n */"}, {"sha": "51ad0b52b81892455e569be41b33d7a655d98f5d", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 107, "deletions": 64, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/b26daf3a67a4e283a5e2c49227b60a2321434de0/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26daf3a67a4e283a5e2c49227b60a2321434de0/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=b26daf3a67a4e283a5e2c49227b60a2321434de0", "patch": "@@ -12,6 +12,8 @@\n \n //! An owned, growable string that enforces that its contents are valid UTF-8.\n \n+#![stable]\n+\n use core::prelude::*;\n \n use core::borrow::{Cow, IntoCow};\n@@ -36,6 +38,18 @@ pub struct String {\n     vec: Vec<u8>,\n }\n \n+/// A possible error value from the `String::from_utf8` function.\n+#[stable]\n+pub struct FromUtf8Error {\n+    bytes: Vec<u8>,\n+    error: Utf8Error,\n+}\n+\n+/// A possible error value from the `String::from_utf16` function.\n+#[stable]\n+#[allow(missing_copy_implementations)]\n+pub struct FromUtf16Error(());\n+\n impl String {\n     /// Creates a new string buffer initialized with the empty string.\n     ///\n@@ -98,19 +112,20 @@ impl String {\n     /// use std::str::Utf8Error;\n     ///\n     /// let hello_vec = vec![104, 101, 108, 108, 111];\n-    /// let s = String::from_utf8(hello_vec);\n-    /// assert_eq!(s, Ok(\"hello\".to_string()));\n+    /// let s = String::from_utf8(hello_vec).unwrap();\n+    /// assert_eq!(s, \"hello\");\n     ///\n     /// let invalid_vec = vec![240, 144, 128];\n-    /// let s = String::from_utf8(invalid_vec);\n-    /// assert_eq!(s, Err((vec![240, 144, 128], Utf8Error::TooShort)));\n+    /// let s = String::from_utf8(invalid_vec).err().unwrap();\n+    /// assert_eq!(s.utf8_error(), Utf8Error::TooShort);\n+    /// assert_eq!(s.into_bytes(), vec![240, 144, 128]);\n     /// ```\n     #[inline]\n-    #[unstable = \"error type may change\"]\n-    pub fn from_utf8(vec: Vec<u8>) -> Result<String, (Vec<u8>, Utf8Error)> {\n+    #[stable]\n+    pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> {\n         match str::from_utf8(vec.as_slice()) {\n             Ok(..) => Ok(String { vec: vec }),\n-            Err(e) => Err((vec, e))\n+            Err(e) => Err(FromUtf8Error { bytes: vec, error: e })\n         }\n     }\n \n@@ -124,7 +139,7 @@ impl String {\n     /// let output = String::from_utf8_lossy(input);\n     /// assert_eq!(output.as_slice(), \"Hello \\u{FFFD}World\");\n     /// ```\n-    #[unstable = \"return type may change\"]\n+    #[stable]\n     pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> CowString<'a> {\n         match str::from_utf8(v) {\n             Ok(s) => return Cow::Borrowed(s),\n@@ -251,22 +266,23 @@ impl String {\n     /// // \ud834\udd1emusic\n     /// let mut v = &mut [0xD834, 0xDD1E, 0x006d, 0x0075,\n     ///                   0x0073, 0x0069, 0x0063];\n-    /// assert_eq!(String::from_utf16(v), Some(\"\ud834\udd1emusic\".to_string()));\n+    /// assert_eq!(String::from_utf16(v).unwrap(),\n+    ///            \"\ud834\udd1emusic\".to_string());\n     ///\n     /// // \ud834\udd1emu<invalid>ic\n     /// v[4] = 0xD800;\n-    /// assert_eq!(String::from_utf16(v), None);\n+    /// assert!(String::from_utf16(v).is_err());\n     /// ```\n-    #[unstable = \"error value in return may change\"]\n-    pub fn from_utf16(v: &[u16]) -> Option<String> {\n+    #[stable]\n+    pub fn from_utf16(v: &[u16]) -> Result<String, FromUtf16Error> {\n         let mut s = String::with_capacity(v.len());\n         for c in unicode_str::utf16_items(v) {\n             match c {\n                 Utf16Item::ScalarValue(c) => s.push(c),\n-                Utf16Item::LoneSurrogate(_) => return None\n+                Utf16Item::LoneSurrogate(_) => return Err(FromUtf16Error(())),\n             }\n         }\n-        Some(s)\n+        Ok(s)\n     }\n \n     /// Decode a UTF-16 encoded vector `v` into a string, replacing\n@@ -293,12 +309,13 @@ impl String {\n     /// # Examples\n     ///\n     /// ```rust\n+    /// # #![allow(deprecated)]\n     /// let chars = &['h', 'e', 'l', 'l', 'o'];\n     /// let s = String::from_chars(chars);\n     /// assert_eq!(s.as_slice(), \"hello\");\n     /// ```\n     #[inline]\n-    #[unstable = \"may be removed in favor of .collect()\"]\n+    #[deprecated = \"use .collect() instead\"]\n     pub fn from_chars(chs: &[char]) -> String {\n         chs.iter().map(|c| *c).collect()\n     }\n@@ -309,7 +326,7 @@ impl String {\n     /// * We call `Vec::from_raw_parts` to get a `Vec<u8>`;\n     /// * We assume that the `Vec` contains valid UTF-8.\n     #[inline]\n-    #[unstable = \"function just moved from string::raw\"]\n+    #[stable]\n     pub unsafe fn from_raw_parts(buf: *mut u8, length: uint, capacity: uint) -> String {\n         String {\n             vec: Vec::from_raw_parts(buf, length, capacity),\n@@ -344,7 +361,7 @@ impl String {\n     /// it contains valid UTF-8. This is unsafe because it assumes that\n     /// the UTF-8-ness of the vector has already been validated.\n     #[inline]\n-    #[unstable = \"awaiting stabilization\"]\n+    #[stable]\n     pub unsafe fn from_utf8_unchecked(bytes: Vec<u8>) -> String {\n         String { vec: bytes }\n     }\n@@ -369,12 +386,12 @@ impl String {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// let s = String::from_char(5, 'a');\n     /// assert_eq!(s.as_slice(), \"aaaaa\");\n     /// ```\n     #[inline]\n-    #[unstable = \"may be replaced with iterators, questionable usability, and \\\n-                  the name may change\"]\n+    #[deprecated = \"use repeat(ch).take(length).collect() instead\"]\n     pub fn from_char(length: uint, ch: char) -> String {\n         if length == 0 {\n             return String::new()\n@@ -400,7 +417,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"foobar\");\n     /// ```\n     #[inline]\n-    #[unstable = \"extra variants of `push`, could possibly be based on iterators\"]\n+    #[stable]\n     pub fn push_str(&mut self, string: &str) {\n         self.vec.push_all(string.as_bytes())\n     }\n@@ -410,19 +427,21 @@ impl String {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// let mut s = String::from_str(\"foo\");\n     /// s.grow(5, 'Z');\n     /// assert_eq!(s.as_slice(), \"fooZZZZZ\");\n     /// ```\n     #[inline]\n-    #[unstable = \"duplicate of iterator-based functionality\"]\n+    #[deprecated = \"deprecated in favor of .extend(repeat(ch).take(count))\"]\n     pub fn grow(&mut self, count: uint, ch: char) {\n         for _ in range(0, count) {\n             self.push(ch)\n         }\n     }\n \n-    /// Returns the number of bytes that this string buffer can hold without reallocating.\n+    /// Returns the number of bytes that this string buffer can hold without\n+    /// reallocating.\n     ///\n     /// # Examples\n     ///\n@@ -431,7 +450,7 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn capacity(&self) -> uint {\n         self.vec.capacity()\n     }\n@@ -442,8 +461,9 @@ impl String {\n         self.vec.reserve(extra)\n     }\n \n-    /// Reserves capacity for at least `additional` more bytes to be inserted in the given\n-    /// `String`. The collection may reserve more space to avoid frequent reallocations.\n+    /// Reserves capacity for at least `additional` more bytes to be inserted\n+    /// in the given `String`. The collection may reserve more space to avoid\n+    /// frequent reallocations.\n     ///\n     /// # Panics\n     ///\n@@ -457,17 +477,18 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn reserve(&mut self, additional: uint) {\n         self.vec.reserve(additional)\n     }\n \n-    /// Reserves the minimum capacity for exactly `additional` more bytes to be inserted in the\n-    /// given `String`. Does nothing if the capacity is already sufficient.\n+    /// Reserves the minimum capacity for exactly `additional` more bytes to be\n+    /// inserted in the given `String`. Does nothing if the capacity is already\n+    /// sufficient.\n     ///\n-    /// Note that the allocator may give the collection more space than it requests. Therefore\n-    /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n-    /// insertions are expected.\n+    /// Note that the allocator may give the collection more space than it\n+    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// minimal. Prefer `reserve` if future insertions are expected.\n     ///\n     /// # Panics\n     ///\n@@ -481,7 +502,7 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         self.vec.reserve_exact(additional)\n     }\n@@ -498,7 +519,7 @@ impl String {\n     /// assert_eq!(s.capacity(), 3);\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn shrink_to_fit(&mut self) {\n         self.vec.shrink_to_fit()\n     }\n@@ -515,7 +536,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"abc123\");\n     /// ```\n     #[inline]\n-    #[stable = \"function just renamed from push_char\"]\n+    #[stable]\n     pub fn push(&mut self, ch: char) {\n         if (ch as u32) < 0x80 {\n             self.vec.push(ch as u8);\n@@ -568,7 +589,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"he\");\n     /// ```\n     #[inline]\n-    #[unstable = \"the panic conventions for strings are under development\"]\n+    #[stable]\n     pub fn truncate(&mut self, new_len: uint) {\n         assert!(self.is_char_boundary(new_len));\n         self.vec.truncate(new_len)\n@@ -587,7 +608,7 @@ impl String {\n     /// assert_eq!(s.pop(), None);\n     /// ```\n     #[inline]\n-    #[unstable = \"this function was just renamed from pop_char\"]\n+    #[stable]\n     pub fn pop(&mut self) -> Option<char> {\n         let len = self.len();\n         if len == 0 {\n@@ -602,7 +623,7 @@ impl String {\n     }\n \n     /// Removes the character from the string buffer at byte position `idx` and\n-    /// returns it. Returns `None` if `idx` is out of bounds.\n+    /// returns it.\n     ///\n     /// # Warning\n     ///\n@@ -611,23 +632,21 @@ impl String {\n     ///\n     /// # Panics\n     ///\n-    /// If `idx` does not lie on a character boundary, then this function will\n-    /// panic.\n+    /// If `idx` does not lie on a character boundary, or if it is out of\n+    /// bounds, then this function will panic.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// let mut s = String::from_str(\"foo\");\n-    /// assert_eq!(s.remove(0), Some('f'));\n-    /// assert_eq!(s.remove(1), Some('o'));\n-    /// assert_eq!(s.remove(0), Some('o'));\n-    /// assert_eq!(s.remove(0), None);\n+    /// assert_eq!(s.remove(0), 'f');\n+    /// assert_eq!(s.remove(1), 'o');\n+    /// assert_eq!(s.remove(0), 'o');\n     /// ```\n-    #[unstable = \"the panic semantics of this function and return type \\\n-                  may change\"]\n-    pub fn remove(&mut self, idx: uint) -> Option<char> {\n+    #[stable]\n+    pub fn remove(&mut self, idx: uint) -> char {\n         let len = self.len();\n-        if idx >= len { return None }\n+        assert!(idx <= len);\n \n         let CharRange { ch, next } = self.char_range_at(idx);\n         unsafe {\n@@ -636,7 +655,7 @@ impl String {\n                              len - next);\n             self.vec.set_len(len - (next - idx));\n         }\n-        Some(ch)\n+        ch\n     }\n \n     /// Insert a character into the string buffer at byte position `idx`.\n@@ -650,7 +669,7 @@ impl String {\n     ///\n     /// If `idx` does not lie on a character boundary or is out of bounds, then\n     /// this function will panic.\n-    #[unstable = \"the panic semantics of this function are uncertain\"]\n+    #[stable]\n     pub fn insert(&mut self, idx: uint, ch: char) {\n         let len = self.len();\n         assert!(idx <= len);\n@@ -686,7 +705,7 @@ impl String {\n     /// }\n     /// assert_eq!(s.as_slice(), \"olleh\");\n     /// ```\n-    #[unstable = \"the name of this method may be changed\"]\n+    #[stable]\n     pub unsafe fn as_mut_vec<'a>(&'a mut self) -> &'a mut Vec<u8> {\n         &mut self.vec\n     }\n@@ -713,6 +732,7 @@ impl String {\n     /// v.push('a');\n     /// assert!(!v.is_empty());\n     /// ```\n+    #[stable]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Truncates the string, returning it to 0 length.\n@@ -731,6 +751,29 @@ impl String {\n     }\n }\n \n+impl FromUtf8Error {\n+    /// Consume this error, returning the bytes that were attempted to make a\n+    /// `String` with.\n+    #[stable]\n+    pub fn into_bytes(self) -> Vec<u8> { self.bytes }\n+\n+    /// Access the underlying UTF8-error that was the cause of this error.\n+    #[stable]\n+    pub fn utf8_error(&self) -> Utf8Error { self.error }\n+}\n+\n+impl fmt::Show for FromUtf8Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.error.fmt(f)\n+    }\n+}\n+\n+impl fmt::Show for FromUtf16Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"invalid utf-16: lone surrogate found\".fmt(f)\n+    }\n+}\n+\n #[experimental = \"waiting on FromIterator stabilization\"]\n impl FromIterator<char> for String {\n     fn from_iter<I:Iterator<char>>(iterator: I) -> String {\n@@ -933,6 +976,7 @@ impl FromStr for String {\n }\n \n /// Trait for converting a type to a string, consuming it in the process.\n+#[deprecated = \"trait will be removed\"]\n pub trait IntoString {\n     /// Consume and convert to a string.\n     fn into_string(self) -> String;\n@@ -1057,16 +1101,17 @@ mod tests {\n     #[test]\n     fn test_from_utf8() {\n         let xs = b\"hello\".to_vec();\n-        assert_eq!(String::from_utf8(xs),\n-                   Ok(String::from_str(\"hello\")));\n+        assert_eq!(String::from_utf8(xs).unwrap(),\n+                   String::from_str(\"hello\"));\n \n         let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes().to_vec();\n-        assert_eq!(String::from_utf8(xs),\n-                   Ok(String::from_str(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\")));\n+        assert_eq!(String::from_utf8(xs).unwrap(),\n+                   String::from_str(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n \n         let xs = b\"hello\\xFF\".to_vec();\n-        assert_eq!(String::from_utf8(xs),\n-                   Err((b\"hello\\xFF\".to_vec(), Utf8Error::TooShort)));\n+        let err = String::from_utf8(xs).err().unwrap();\n+        assert_eq!(err.utf8_error(), Utf8Error::TooShort);\n+        assert_eq!(err.into_bytes(), b\"hello\\xff\".to_vec());\n     }\n \n     #[test]\n@@ -1171,15 +1216,15 @@ mod tests {\n     fn test_utf16_invalid() {\n         // completely positive cases tested above.\n         // lead + eof\n-        assert_eq!(String::from_utf16(&[0xD800]), None);\n+        assert!(String::from_utf16(&[0xD800]).is_err());\n         // lead + lead\n-        assert_eq!(String::from_utf16(&[0xD800, 0xD800]), None);\n+        assert!(String::from_utf16(&[0xD800, 0xD800]).is_err());\n \n         // isolated trail\n-        assert_eq!(String::from_utf16(&[0x0061, 0xDC00]), None);\n+        assert!(String::from_utf16(&[0x0061, 0xDC00]).is_err());\n \n         // general\n-        assert_eq!(String::from_utf16(&[0xD800, 0xd801, 0xdc8b, 0xD800]), None);\n+        assert!(String::from_utf16(&[0xD800, 0xd801, 0xdc8b, 0xD800]).is_err());\n     }\n \n     #[test]\n@@ -1312,12 +1357,10 @@ mod tests {\n     #[test]\n     fn remove() {\n         let mut s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; foobar\".to_string();;\n-        assert_eq!(s.remove(0), Some('\u0e28'));\n+        assert_eq!(s.remove(0), '\u0e28');\n         assert_eq!(s.len(), 33);\n         assert_eq!(s, \"\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; foobar\");\n-        assert_eq!(s.remove(33), None);\n-        assert_eq!(s.remove(300), None);\n-        assert_eq!(s.remove(17), Some('\u1ec7'));\n+        assert_eq!(s.remove(17), '\u1ec7');\n         assert_eq!(s, \"\u0e44\u0e17\u0e22\u4e2d\u534eVit Nam; foobar\");\n     }\n "}, {"sha": "86c02de76dcc6b146839d378ee3473d264c9e814", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b26daf3a67a4e283a5e2c49227b60a2321434de0/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26daf3a67a4e283a5e2c49227b60a2321434de0/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=b26daf3a67a4e283a5e2c49227b60a2321434de0", "patch": "@@ -519,8 +519,8 @@ impl<'a> Parser<'a> {\n             };\n         self.chari = closer;\n         let greed = try!(self.get_next_greedy());\n-        let inner = String::from_chars(\n-            self.chars[start+1..closer]);\n+        let inner = self.chars[start+1..closer].iter().cloned()\n+                                               .collect::<String>();\n \n         // Parse the min and max values from the regex.\n         let (mut min, mut max): (uint, Option<uint>);\n@@ -954,7 +954,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn slice(&self, start: uint, end: uint) -> String {\n-        String::from_chars(self.chars[start..end])\n+        self.chars[start..end].iter().cloned().collect()\n     }\n }\n "}, {"sha": "c2992a81d208334d8d55154f6fb22940be885d6f", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b26daf3a67a4e283a5e2c49227b60a2321434de0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26daf3a67a4e283a5e2c49227b60a2321434de0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=b26daf3a67a4e283a5e2c49227b60a2321434de0", "patch": "@@ -25,7 +25,7 @@ use middle::ty::*;\n use middle::ty;\n use std::fmt;\n use std::iter::AdditiveIterator;\n-use std::iter::range_inclusive;\n+use std::iter::{range_inclusive, repeat};\n use std::num::Float;\n use std::slice;\n use syntax::ast::{mod, DUMMY_NODE_ID, NodeId, Pat};\n@@ -76,7 +76,7 @@ impl<'a> fmt::Show for Matrix<'a> {\n         }).collect();\n \n         let total_width = column_widths.iter().map(|n| *n).sum() + column_count * 3 + 1;\n-        let br = String::from_char(total_width, '+');\n+        let br = repeat('+').take(total_width).collect::<String>();\n         try!(write!(f, \"{}\\n\", br));\n         for row in pretty_printed_matrix.into_iter() {\n             try!(write!(f, \"+\"));"}, {"sha": "9a46a500a4b4799199ccc73edbdaf75106aef405", "filename": "src/libstd/error.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b26daf3a67a4e283a5e2c49227b60a2321434de0/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26daf3a67a4e283a5e2c49227b60a2321434de0/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=b26daf3a67a4e283a5e2c49227b60a2321434de0", "patch": "@@ -81,6 +81,7 @@\n use prelude::*;\n \n use str::Utf8Error;\n+use string::{FromUtf8Error, FromUtf16Error};\n \n /// Base functionality for all errors in Rust.\n pub trait Error: Send {\n@@ -117,3 +118,12 @@ impl Error for Utf8Error {\n \n     fn detail(&self) -> Option<String> { Some(self.to_string()) }\n }\n+\n+impl Error for FromUtf8Error {\n+    fn description(&self) -> &str { \"invalid utf-8\" }\n+    fn detail(&self) -> Option<String> { Some(self.to_string()) }\n+}\n+\n+impl Error for FromUtf16Error {\n+    fn description(&self) -> &str { \"invalid utf-16\" }\n+}"}, {"sha": "00833ce868ea55f1329a18e03c2f9532df340856", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b26daf3a67a4e283a5e2c49227b60a2321434de0/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26daf3a67a4e283a5e2c49227b60a2321434de0/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=b26daf3a67a4e283a5e2c49227b60a2321434de0", "patch": "@@ -21,7 +21,7 @@ use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n use hash;\n use io::Writer;\n use iter::{AdditiveIterator, DoubleEndedIteratorExt, Extend};\n-use iter::{Iterator, IteratorExt, Map};\n+use iter::{Iterator, IteratorExt, Map, repeat};\n use mem;\n use option::Option;\n use option::Option::{Some, None};\n@@ -777,7 +777,7 @@ impl Path {\n                             }\n                         }\n                     } else if is_abs && comps.is_empty() {\n-                        Some(String::from_char(1, SEP))\n+                        Some(repeat(SEP).take(1).collect())\n                     } else {\n                         let prefix_ = s[0..prefix_len(prefix)];\n                         let n = prefix_.len() +"}]}