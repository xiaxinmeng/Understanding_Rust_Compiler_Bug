{"sha": "7e3d1157246a13a7830431ce0253368029c8ee3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlM2QxMTU3MjQ2YTEzYTc4MzA0MzFjZTAyNTMzNjgwMjljOGVlM2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-04T07:51:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-04T07:51:06Z"}, "message": "auto merge of #20462 : alexcrichton/rust/remove-deprecated, r=aturon\n\nThis removes a large array of deprecated functionality, regardless of how\r\nrecently it was deprecated. The purpose of this commit is to clean out the\r\nstandard libraries and compiler for the upcoming alpha release.\r\n\r\nSome notable compiler changes were to enable warnings for all now-deprecated\r\ncommand line arguments (previously the deprecated versions were silently\r\naccepted) as well as removing deriving(Zero) entirely (the trait was removed).\r\n\r\nThe distribution no longer contains the libtime or libregex_macros crates. Both\r\nof these have been deprecated for some time and are available externally.", "tree": {"sha": "eda093ca208286fd8679da8de9f3597b7a024c50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eda093ca208286fd8679da8de9f3597b7a024c50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e3d1157246a13a7830431ce0253368029c8ee3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e3d1157246a13a7830431ce0253368029c8ee3e", "html_url": "https://github.com/rust-lang/rust/commit/7e3d1157246a13a7830431ce0253368029c8ee3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e3d1157246a13a7830431ce0253368029c8ee3e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "470118f3e915cdc8f936aca0640b28a7a3d8dc6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/470118f3e915cdc8f936aca0640b28a7a3d8dc6c", "html_url": "https://github.com/rust-lang/rust/commit/470118f3e915cdc8f936aca0640b28a7a3d8dc6c"}, {"sha": "7d8d06f86b48520814596bd5363d2b82bc619774", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d8d06f86b48520814596bd5363d2b82bc619774", "html_url": "https://github.com/rust-lang/rust/commit/7d8d06f86b48520814596bd5363d2b82bc619774"}], "stats": {"total": 8564, "additions": 1104, "deletions": 7460}, "files": [{"sha": "cea92e19a26827298f50d91aaa66e832e289e238", "filename": "mk/crates.mk", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -50,12 +50,12 @@\n ################################################################################\n \n TARGET_CRATES := libc std flate arena term \\\n-                 serialize getopts collections test time rand \\\n+                 serialize getopts collections test rand \\\n                  log regex graphviz core rbml alloc \\\n                  unicode\n RUSTC_CRATES := rustc rustc_typeck rustc_borrowck rustc_resolve rustc_driver \\\n                 rustc_trans rustc_back rustc_llvm\n-HOST_CRATES := syntax $(RUSTC_CRATES) rustdoc regex_macros fmt_macros\n+HOST_CRATES := syntax $(RUSTC_CRATES) rustdoc fmt_macros\n CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc\n \n@@ -75,11 +75,11 @@ DEPS_rustc_typeck := rustc syntax\n DEPS_rustc_borrowck := rustc log graphviz syntax\n DEPS_rustc_resolve := rustc log syntax\n DEPS_rustc := syntax flate arena serialize getopts rbml \\\n-              time log graphviz rustc_llvm rustc_back\n+              log graphviz rustc_llvm rustc_back\n DEPS_rustc_llvm := native:rustllvm libc std\n DEPS_rustc_back := std syntax rustc_llvm flate log libc\n DEPS_rustdoc := rustc rustc_driver native:hoedown serialize getopts \\\n-                test time\n+                test\n DEPS_flate := std native:miniz\n DEPS_arena := std\n DEPS_graphviz := std\n@@ -90,12 +90,10 @@ DEPS_term := std log\n DEPS_getopts := std\n DEPS_collections := core alloc unicode\n DEPS_num := std\n-DEPS_test := std getopts serialize rbml term time regex native:rust_test_helpers\n-DEPS_time := std serialize\n+DEPS_test := std getopts serialize rbml term regex native:rust_test_helpers\n DEPS_rand := core\n DEPS_log := std regex\n DEPS_regex := std\n-DEPS_regex_macros = rustc syntax std regex\n DEPS_fmt_macros = std\n \n TOOL_DEPS_compiletest := test getopts\n@@ -124,10 +122,8 @@ DOC_CRATES := $(filter-out rustc, \\\n               $(filter-out rustc_driver, \\\n               $(filter-out log, \\\n               $(filter-out regex, \\\n-              $(filter-out regex_macros, \\\n               $(filter-out getopts, \\\n-              $(filter-out time, \\\n-              $(filter-out syntax, $(CRATES)))))))))))))\n+              $(filter-out syntax, $(CRATES)))))))))))\n COMPILER_DOC_CRATES := rustc rustc_trans rustc_borrowck rustc_resolve \\\n                        rustc_typeck rustc_driver syntax\n "}, {"sha": "93e40302f51768e997f96a0e17810cfc32b23518", "filename": "mk/grammar.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/mk%2Fgrammar.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/mk%2Fgrammar.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fgrammar.mk?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -37,7 +37,7 @@ $(BG)RustLexer.class: $(BG) $(SG)RustLexer.g4\n check-build-lexer-verifier: $(BG)verify\n \n ifeq ($(NO_REBUILD),)\n-VERIFY_DEPS :=  rustc-stage2-H-$(CFG_BUILD) $(LD)stamp.regex_macros $(LD)stamp.rustc\n+VERIFY_DEPS :=  rustc-stage2-H-$(CFG_BUILD) $(LD)stamp.rustc\n else\n VERIFY_DEPS :=\n endif"}, {"sha": "714a9f890054793f5f316571898583ee38599ae1", "filename": "mk/tests.mk", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -373,15 +373,6 @@ TESTDEP_$(1)_$(2)_$(3)_$(4) = $$(SREQ$(1)_T_$(2)_H_$(3)) \\\n \t\t\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$$(crate)) \\\n \t\t\t\t$$(CRATE_FULLDEPS_$(1)_T_$(2)_H_$(3)_$(4))\n \n-# The regex crate depends on the regex_macros crate during testing, but it\n-# notably depend on the *host* regex_macros crate, not the target version.\n-# Additionally, this is not a dependency in stage1, only in stage2.\n-ifeq ($(4),regex)\n-ifneq ($(1),1)\n-TESTDEP_$(1)_$(2)_$(3)_$(4) += $$(TLIB$(1)_T_$(3)_H_$(3))/stamp.regex_macros\n-endif\n-endif\n-\n else\n TESTDEP_$(1)_$(2)_$(3)_$(4) = $$(RSINPUTS_$(4))\n endif\n@@ -843,27 +834,8 @@ else\n CRATEDOCTESTDEP_$(1)_$(2)_$(3)_$(4) = $$(RSINPUTS_$(4))\n endif\n \n-# (Issues #13732, #13983, #14000) The doc for the regex crate includes\n-# uses of the `regex!` macro from the regex_macros crate.  There is\n-# normally a dependence injected that makes the target's regex depend\n-# upon the host's regex_macros (see #13845), but that dependency\n-# injection is currently skipped for stage1 as a special case.\n-#\n-# Therefore, as a further special case, this conditional skips\n-# attempting to run the doc tests for the regex crate atop stage1,\n-# (since there is no regex_macros crate for the stage1 rustc to load).\n-#\n-# (Another approach for solving this would be to inject the desired\n-# dependence for stage1 as well, by setting things up to generate a\n-# regex_macros crate that was compatible with the stage1 rustc and\n-# thus re-enable our ability to run this test.)\n-ifeq (stage$(1)-crate-$(4),stage1-crate-regex)\n-check-stage$(1)-T-$(2)-H-$(3)-doc-crate-$(4)-exec:\n-\t@$$(call E, skipping doc-crate-$(4) as it uses macros and cannot run at stage$(1))\n-else\n check-stage$(1)-T-$(2)-H-$(3)-doc-crate-$(4)-exec: \\\n \t$$(call TEST_OK_FILE,$(1),$(2),$(3),doc-crate-$(4))\n-endif\n \n ifeq ($(2),$$(CFG_BUILD))\n $$(call TEST_OK_FILE,$(1),$(2),$(3),doc-crate-$(4)): $$(CRATEDOCTESTDEP_$(1)_$(2)_$(3)_$(4))"}, {"sha": "350a10ce4832a9debfe68b687f3e2dc578cba0ab", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -22,7 +22,7 @@ extern crate regex;\n use std::os;\n use std::io;\n use std::io::fs;\n-use std::str::{FromStr, from_str};\n+use std::str::FromStr;\n use std::thunk::Thunk;\n use getopts::{optopt, optflag, reqopt};\n use common::Config;"}, {"sha": "d7930285260523858d4164b846cf9a82f39a78cc", "filename": "src/doc/reference.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -1478,19 +1478,19 @@ Constants should in general be preferred over statics, unless large amounts of\n data are being stored, or single-address and mutability properties are required.\n \n ```\n-use std::sync::atomic;\n+use std::sync::atomic::{AtomicUint, Ordering, ATOMIC_UINT_INIT};;\n \n // Note that ATOMIC_UINT_INIT is a *const*, but it may be used to initialize a\n // static. This static can be modified, so it is not placed in read-only memory.\n-static COUNTER: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n+static COUNTER: AtomicUint = ATOMIC_UINT_INIT;\n \n // This table is a candidate to be placed in read-only memory.\n static TABLE: &'static [uint] = &[1, 2, 3, /* ... */];\n \n for slot in TABLE.iter() {\n     println!(\"{}\", slot);\n }\n-COUNTER.fetch_add(1, atomic::SeqCst);\n+COUNTER.fetch_add(1, Ordering::SeqCst);\n ```\n \n #### Mutable statics"}, {"sha": "db26ca6ffa5d5407589e26460bcecf403658f466", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -19,10 +19,9 @@ extern crate regex;\n #[phase(link, plugin)]\n extern crate log;\n \n-#[phase(plugin)] extern crate regex_macros;\n-\n use std::collections::HashMap;\n use std::io::File;\n+use regex::Regex;\n \n use syntax::parse;\n use syntax::parse::lexer;\n@@ -168,9 +167,9 @@ fn count(lit: &str) -> uint {\n }\n \n fn parse_antlr_token(s: &str, tokens: &HashMap<String, token::Token>) -> TokenAndSpan {\n-    let re = regex!(\n+    let re = Regex::new(\n       r\"\\[@(?P<seq>\\d+),(?P<start>\\d+):(?P<end>\\d+)='(?P<content>.+?)',<(?P<toknum>-?\\d+)>,\\d+:\\d+]\"\n-    );\n+    ).unwrap();\n \n     let m = re.captures(s).expect(format!(\"The regex didn't match {}\", s).as_slice());\n     let start = m.name(\"start\").unwrap_or(\"\");"}, {"sha": "88f02d6573eac788f930391f1c393873cb7b1c52", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -600,11 +600,9 @@ mod tests {\n     use std::ops::Drop;\n     use std::option::Option;\n     use std::option::Option::{Some, None};\n-    use std::str::Str;\n     use std::sync::atomic;\n     use std::sync::atomic::Ordering::{Acquire, SeqCst};\n-    use std::task;\n-    use std::kinds::Send;\n+    use std::thread::Thread;\n     use std::vec::Vec;\n     use super::{Arc, Weak, weak_count, strong_count};\n     use std::sync::Mutex;\n@@ -631,7 +629,7 @@ mod tests {\n \n         let (tx, rx) = channel();\n \n-        task::spawn(move || {\n+        let _t = Thread::spawn(move || {\n             let arc_v: Arc<Vec<int>> = rx.recv().unwrap();\n             assert_eq!((*arc_v)[3], 4);\n         });"}, {"sha": "d040f8ff86390f327c3d589c0c3ac045142bea87", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -77,12 +77,6 @@ extern crate libc;\n #[cfg(test)] #[phase(plugin, link)] extern crate std;\n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n \n-// The deprecated name of the boxed module\n-\n-#[deprecated = \"use boxed instead\"]\n-#[cfg(not(test))]\n-pub use boxed as owned;\n-\n // Heaps provided for low-level allocation strategies\n \n pub mod heap;"}, {"sha": "c7164b8199cc341d6f563321e13c2430312889f9", "filename": "src/libcollections/bench.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbench.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -68,7 +68,8 @@ pub fn find_rand_n<M, T, I, F>(n: uint,\n {\n     // setup\n     let mut rng = rand::weak_rng();\n-    let mut keys = Vec::from_fn(n, |_| rng.gen::<uint>() % n);\n+    let mut keys = range(0, n).map(|_| rng.gen::<uint>() % n)\n+                              .collect::<Vec<_>>();\n \n     for k in keys.iter() {\n         insert(map, *k);"}, {"sha": "5e7089bb7aca2ebae6cde8d03b137fc9de2c2ee3", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 3, "deletions": 26, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -685,12 +685,6 @@ impl Bitv {\n         ).collect()\n     }\n \n-    /// Deprecated: Use `iter().collect()`.\n-    #[deprecated = \"Use `iter().collect()`\"]\n-    pub fn to_bools(&self) -> Vec<bool> {\n-        self.iter().collect()\n-    }\n-\n     /// Compares a `Bitv` to a slice of `bool`s.\n     /// Both the `Bitv` and slice must have the same length.\n     ///\n@@ -935,18 +929,6 @@ impl Bitv {\n     }\n }\n \n-/// Deprecated: Now a static method on Bitv.\n-#[deprecated = \"Now a static method on Bitv\"]\n-pub fn from_bytes(bytes: &[u8]) -> Bitv {\n-    Bitv::from_bytes(bytes)\n-}\n-\n-/// Deprecated: Now a static method on Bitv.\n-#[deprecated = \"Now a static method on Bitv\"]\n-pub fn from_fn<F>(len: uint, f: F) -> Bitv where F: FnMut(uint) -> bool {\n-    Bitv::from_fn(len, f)\n-}\n-\n #[stable]\n impl Default for Bitv {\n     #[inline]\n@@ -1907,14 +1889,9 @@ impl<'a> Iterator for SymmetricDifference<'a> {\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n-    use core::iter::range_step;\n     use core::u32;\n-    use std::rand;\n-    use std::rand::Rng;\n-    use test::{Bencher, black_box};\n \n-    use super::{Bitv, BitvSet, from_fn, from_bytes};\n-    use bitv;\n+    use super::Bitv;\n \n     #[test]\n     fn test_to_str() {\n@@ -1928,7 +1905,7 @@ mod tests {\n     #[test]\n     fn test_0_elements() {\n         let act = Bitv::new();\n-        let exp = Vec::from_elem(0u, false);\n+        let exp = Vec::new();\n         assert!(act.eq_vec(exp.as_slice()));\n         assert!(act.none() && act.all());\n     }\n@@ -2318,7 +2295,7 @@ mod tests {\n \n         assert_eq!(bitv.iter().collect::<Vec<bool>>(), bools);\n \n-        let long = Vec::from_fn(10000, |i| i % 2 == 0);\n+        let long = range(0, 10000).map(|i| i % 2 == 0).collect::<Vec<_>>();\n         let bitv: Bitv = long.iter().map(|n| *n).collect();\n         assert_eq!(bitv.iter().collect::<Vec<bool>>(), long)\n     }"}, {"sha": "3a722178bc02c90aa91de7e3486db4a85cb590f7", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -187,12 +187,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         for _ in mem::replace(self, BTreeMap::with_b(b)).into_iter() {};\n     }\n \n-    /// Deprecated: renamed to `get`.\n-    #[deprecated = \"renamed to `get`\"]\n-    pub fn find(&self, key: &K) -> Option<&V> {\n-        self.get(key)\n-    }\n-\n     // Searching in a B-Tree is pretty straightforward.\n     //\n     // Start at the root. Try to find the key in the current node. If we find it, return it.\n@@ -253,12 +247,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         self.get(key).is_some()\n     }\n \n-    /// Deprecated: renamed to `get_mut`.\n-    #[deprecated = \"renamed to `get_mut`\"]\n-    pub fn find_mut(&mut self, key: &K) -> Option<&mut V> {\n-        self.get_mut(key)\n-    }\n-\n     /// Returns a mutable reference to the value corresponding to the key.\n     ///\n     /// The key may be any borrowed form of the map's key type, but the ordering\n@@ -297,12 +285,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         }\n     }\n \n-    /// Deprecated: renamed to `insert`.\n-    #[deprecated = \"renamed to `insert`\"]\n-    pub fn swap(&mut self, key: K, value: V) -> Option<V> {\n-        self.insert(key, value)\n-    }\n-\n     // Insertion in a B-Tree is a bit complicated.\n     //\n     // First we do the same kind of search described in `find`. But we need to maintain a stack of\n@@ -438,12 +420,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     //      the underflow handling process on the parent. If merging merges the last two children\n     //      of the root, then we replace the root with the merged node.\n \n-    /// Deprecated: renamed to `remove`.\n-    #[deprecated = \"renamed to `remove`\"]\n-    pub fn pop(&mut self, key: &K) -> Option<V> {\n-        self.remove(key)\n-    }\n-\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     ///\n@@ -1506,7 +1482,7 @@ mod test {\n         let size = 10000u;\n \n         // Forwards\n-        let mut map: BTreeMap<uint, uint> = Vec::from_fn(size, |i| (i, i)).into_iter().collect();\n+        let mut map: BTreeMap<uint, uint> = range(0, size).map(|i| (i, i)).collect();\n \n         {\n             let mut iter = map.iter();\n@@ -1545,7 +1521,7 @@ mod test {\n         let size = 10000u;\n \n         // Forwards\n-        let mut map: BTreeMap<uint, uint> = Vec::from_fn(size, |i| (i, i)).into_iter().collect();\n+        let mut map: BTreeMap<uint, uint> = range(0, size).map(|i| (i, i)).collect();\n \n         {\n             let mut iter = map.iter().rev();"}, {"sha": "ca8e75ac43c8d6f84ebe1f3d6331b2b3d251e542", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 37, "deletions": 225, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -219,22 +219,6 @@ impl<T> DList<T> {\n         DList{list_head: None, list_tail: Rawlink::none(), length: 0}\n     }\n \n-    /// Deprecated: Not clearly useful enough; use split and append when available.\n-    #[deprecated = \"Not clearly useful enough; use split and append when available\"]\n-    pub fn rotate_forward(&mut self) {\n-        self.pop_back_node().map(|tail| {\n-            self.push_front_node(tail)\n-        });\n-    }\n-\n-    /// Deprecated: Not clearly useful enough; use split and append when available.\n-    #[deprecated = \"Not clearly useful enough; use split and append when available\"]\n-    pub fn rotate_backward(&mut self) {\n-        self.pop_front_node().map(|head| {\n-            self.push_back_node(head)\n-        });\n-    }\n-\n     /// Adds all elements from `other` to the end of the list.\n     ///\n     /// This operation should compute in O(1) time.\n@@ -277,49 +261,6 @@ impl<T> DList<T> {\n         }\n     }\n \n-    /// Deprecated: Use append and a swap instead.\n-    #[deprecated = \"Use append and a swap instead\"]\n-    pub fn prepend(&mut self, mut other: DList<T>) {\n-        mem::swap(self, &mut other);\n-        self.append(other);\n-    }\n-\n-    /// Deprecated: Use custom methods on IterMut.\n-    #[deprecated = \"Use custom methods on IterMut\"]\n-    pub fn insert_when<F>(&mut self, elt: T, mut f: F) where F: FnMut(&T, &T) -> bool {\n-        let mut it = self.iter_mut();\n-        loop {\n-            match it.peek_next() {\n-                None => break,\n-                Some(x) => if f(x, &elt) { break }\n-            }\n-            it.next();\n-        }\n-        it.insert_next(elt);\n-    }\n-\n-    /// Deprecated: Use custom methods on IterMut.\n-    #[deprecated = \"Use custom methods on IterMut\"]\n-    pub fn merge<F>(&mut self, mut other: DList<T>, mut f: F) where F: FnMut(&T, &T) -> bool {\n-        {\n-            let mut it = self.iter_mut();\n-            loop {\n-                let take_a = match (it.peek_next(), other.front()) {\n-                    (_   , None) => return,\n-                    (None, _   ) => break,\n-                    (Some(ref mut x), Some(y)) => f(*x, y),\n-                };\n-                if take_a {\n-                    it.next();\n-                } else {\n-                    it.insert_next_node(other.pop_front_node().unwrap());\n-                }\n-            }\n-        }\n-        self.append(other);\n-    }\n-\n-\n     /// Provides a forward iterator.\n     #[inline]\n     #[stable]\n@@ -426,12 +367,6 @@ impl<T> DList<T> {\n         self.pop_front_node().map(|box Node{value, ..}| value)\n     }\n \n-    /// Deprecated: Renamed to `push_back`.\n-    #[deprecated = \"Renamed to `push_back`\"]\n-    pub fn push(&mut self, elt: T) {\n-        self.push_back(elt)\n-    }\n-\n     /// Appends an element to the back of a list\n     ///\n     /// # Examples\n@@ -449,12 +384,6 @@ impl<T> DList<T> {\n         self.push_back_node(box Node::new(elt))\n     }\n \n-    /// Deprecated: Renamed to `pop_back`.\n-    #[deprecated = \"Renamed to `pop_back`\"]\n-    pub fn pop(&mut self) -> Option<T> {\n-        self.pop_back()\n-    }\n-\n     /// Removes the last element from a list and returns it, or `None` if\n     /// it is empty.\n     ///\n@@ -475,15 +404,6 @@ impl<T> DList<T> {\n     }\n }\n \n-impl<T: Ord> DList<T> {\n-    /// Deprecated: Why are you maintaining a sorted DList?\n-    #[deprecated = \"Why are you maintaining a sorted DList?\"]\n-    #[allow(deprecated)]\n-    pub fn insert_ordered(&mut self, elt: T) {\n-        self.insert_when(elt, |a, b| a >= b)\n-    }\n-}\n-\n #[unsafe_destructor]\n #[stable]\n impl<T> Drop for DList<T> {\n@@ -589,19 +509,6 @@ impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n #[stable]\n impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n \n-/// Allows mutating a `DList` while iterating.\n-#[deprecated = \"Trait is deprecated, use inherent methods on the iterator instead\"]\n-pub trait ListInsertion<A> {\n-    /// Inserts `elt` just after to the element most recently returned by\n-    /// `.next()`\n-    ///\n-    /// The inserted element does not appear in the iteration.\n-    fn insert_next(&mut self, elt: A);\n-\n-    /// Provides a reference to the next element, without changing the iterator\n-    fn peek_next<'a>(&'a mut self) -> Option<&'a mut A>;\n-}\n-\n // private methods for IterMut\n impl<'a, A> IterMut<'a, A> {\n     fn insert_next_node(&mut self, mut ins_node: Box<Node<A>>) {\n@@ -780,7 +687,7 @@ mod tests {\n     use prelude::*;\n     use std::rand;\n     use std::hash;\n-    use std::task::spawn;\n+    use std::thread::Thread;\n     use test::Bencher;\n     use test;\n \n@@ -868,88 +775,6 @@ mod tests {\n         v.iter().map(|x| (*x).clone()).collect()\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_append() {\n-        {\n-            let mut m = DList::new();\n-            let mut n = DList::new();\n-            n.push_back(2i);\n-            m.append(n);\n-            assert_eq!(m.len(), 1);\n-            assert_eq!(m.pop_back(), Some(2));\n-            check_links(&m);\n-        }\n-        {\n-            let mut m = DList::new();\n-            let n = DList::new();\n-            m.push_back(2i);\n-            m.append(n);\n-            assert_eq!(m.len(), 1);\n-            assert_eq!(m.pop_back(), Some(2));\n-            check_links(&m);\n-        }\n-\n-        let v = vec![1i,2,3,4,5];\n-        let u = vec![9i,8,1,2,3,4,5];\n-        let mut m = list_from(v.as_slice());\n-        m.append(list_from(u.as_slice()));\n-        check_links(&m);\n-        let mut sum = v;\n-        sum.push_all(u.as_slice());\n-        assert_eq!(sum.len(), m.len());\n-        for elt in sum.into_iter() {\n-            assert_eq!(m.pop_front(), Some(elt))\n-        }\n-    }\n-\n-    #[test]\n-    fn test_prepend() {\n-        {\n-            let mut m = DList::new();\n-            let mut n = DList::new();\n-            n.push_back(2i);\n-            m.prepend(n);\n-            assert_eq!(m.len(), 1);\n-            assert_eq!(m.pop_back(), Some(2));\n-            check_links(&m);\n-        }\n-\n-        let v = vec![1i,2,3,4,5];\n-        let mut u = vec![9i,8,1,2,3,4,5];\n-        let mut m = list_from(v.as_slice());\n-        m.prepend(list_from(u.as_slice()));\n-        check_links(&m);\n-        u.extend(v.iter().map(|&b| b));\n-        assert_eq!(u.len(), m.len());\n-        for elt in u.into_iter() {\n-            assert_eq!(m.pop_front(), Some(elt))\n-        }\n-    }\n-\n-    #[test]\n-    fn test_rotate() {\n-        let mut n: DList<int> = DList::new();\n-        n.rotate_backward(); check_links(&n);\n-        assert_eq!(n.len(), 0);\n-        n.rotate_forward(); check_links(&n);\n-        assert_eq!(n.len(), 0);\n-\n-        let v = vec![1i,2,3,4,5];\n-        let mut m = list_from(v.as_slice());\n-        m.rotate_backward(); check_links(&m);\n-        m.rotate_forward(); check_links(&m);\n-        assert_eq!(v.iter().collect::<Vec<&int>>(), m.iter().collect::<Vec<_>>());\n-        m.rotate_forward(); check_links(&m);\n-        m.rotate_forward(); check_links(&m);\n-        m.pop_front(); check_links(&m);\n-        m.rotate_forward(); check_links(&m);\n-        m.rotate_backward(); check_links(&m);\n-        m.push_front(9); check_links(&m);\n-        m.rotate_forward(); check_links(&m);\n-        assert_eq!(vec![3i,9,5,1,2], m.into_iter().collect::<Vec<_>>());\n-    }\n-\n     #[test]\n     fn test_iterator() {\n         let m = generate_test();\n@@ -1080,33 +905,6 @@ mod tests {\n         assert_eq!(m.into_iter().collect::<Vec<int>>(), vec![-2,0,1,2,3,4,5,6,7,8,9,0,1]);\n     }\n \n-    #[test]\n-    fn test_merge() {\n-        let mut m = list_from(&[0i, 1, 3, 5, 6, 7, 2]);\n-        let n = list_from(&[-1i, 0, 0, 7, 7, 9]);\n-        let len = m.len() + n.len();\n-        m.merge(n, |a, b| a <= b);\n-        assert_eq!(m.len(), len);\n-        check_links(&m);\n-        let res = m.into_iter().collect::<Vec<int>>();\n-        assert_eq!(res, vec![-1, 0, 0, 0, 1, 3, 5, 6, 7, 2, 7, 7, 9]);\n-    }\n-\n-    #[test]\n-    fn test_insert_ordered() {\n-        let mut n = DList::new();\n-        n.insert_ordered(1i);\n-        assert_eq!(n.len(), 1);\n-        assert_eq!(n.pop_front(), Some(1));\n-\n-        let mut m = DList::new();\n-        m.push_back(2i);\n-        m.push_back(4);\n-        m.insert_ordered(3);\n-        check_links(&m);\n-        assert_eq!(vec![2,3,4], m.into_iter().collect::<Vec<int>>());\n-    }\n-\n     #[test]\n     fn test_mut_rev_iter() {\n         let mut m = generate_test();\n@@ -1124,11 +922,11 @@ mod tests {\n     #[test]\n     fn test_send() {\n         let n = list_from(&[1i,2,3]);\n-        spawn(move || {\n+        Thread::spawn(move || {\n             check_links(&n);\n             let a: &[_] = &[&1,&2,&3];\n             assert_eq!(a, n.iter().collect::<Vec<&int>>());\n-        });\n+        }).join().ok().unwrap();\n     }\n \n     #[test]\n@@ -1265,6 +1063,40 @@ mod tests {\n         assert_eq!(i, v.len());\n     }\n \n+    #[allow(deprecated)]\n+    fn test_append() {\n+        {\n+            let mut m = DList::new();\n+            let mut n = DList::new();\n+            n.push_back(2i);\n+            m.append(n);\n+            assert_eq!(m.len(), 1);\n+            assert_eq!(m.pop_back(), Some(2));\n+            check_links(&m);\n+        }\n+        {\n+            let mut m = DList::new();\n+            let n = DList::new();\n+            m.push_back(2i);\n+            m.append(n);\n+            assert_eq!(m.len(), 1);\n+            assert_eq!(m.pop_back(), Some(2));\n+            check_links(&m);\n+        }\n+\n+        let v = vec![1i,2,3,4,5];\n+        let u = vec![9i,8,1,2,3,4,5];\n+        let mut m = list_from(v.as_slice());\n+        m.append(list_from(u.as_slice()));\n+        check_links(&m);\n+        let mut sum = v;\n+        sum.push_all(u.as_slice());\n+        assert_eq!(sum.len(), m.len());\n+        for elt in sum.into_iter() {\n+            assert_eq!(m.pop_front(), Some(elt))\n+        }\n+    }\n+\n     #[bench]\n     fn bench_collect_into(b: &mut test::Bencher) {\n         let v = &[0i; 64];\n@@ -1307,26 +1139,6 @@ mod tests {\n         })\n     }\n \n-    #[bench]\n-    fn bench_rotate_forward(b: &mut test::Bencher) {\n-        let mut m: DList<int> = DList::new();\n-        m.push_front(0i);\n-        m.push_front(1);\n-        b.iter(|| {\n-            m.rotate_forward();\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_rotate_backward(b: &mut test::Bencher) {\n-        let mut m: DList<int> = DList::new();\n-        m.push_front(0i);\n-        m.push_front(1);\n-        b.iter(|| {\n-            m.rotate_backward();\n-        })\n-    }\n-\n     #[bench]\n     fn bench_iter(b: &mut test::Bencher) {\n         let v = &[0i; 128];"}, {"sha": "4b94348e87ae3c3713dd99ab97e97e8a7310bdf7", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -81,12 +81,6 @@ fn bit<E:CLike>(e: &E) -> uint {\n }\n \n impl<E:CLike> EnumSet<E> {\n-    /// Deprecated: Renamed to `new`.\n-    #[deprecated = \"Renamed to `new`\"]\n-    pub fn empty() -> EnumSet<E> {\n-        EnumSet::new()\n-    }\n-\n     /// Returns an empty `EnumSet`.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> EnumSet<E> {\n@@ -109,13 +103,6 @@ impl<E:CLike> EnumSet<E> {\n         self.bits = 0;\n     }\n \n-    /// Returns `true` if the `EnumSet` contains any enum of the given `EnumSet`.\n-    /// Deprecated: Use `is_disjoint`.\n-    #[deprecated = \"Use `is_disjoint`\"]\n-    pub fn intersects(&self, e: EnumSet<E>) -> bool {\n-        !self.is_disjoint(&e)\n-    }\n-\n     /// Returns `false` if the `EnumSet` contains any enum of the given `EnumSet`.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_disjoint(&self, other: &EnumSet<E>) -> bool {\n@@ -144,12 +131,6 @@ impl<E:CLike> EnumSet<E> {\n         EnumSet {bits: self.bits & e.bits}\n     }\n \n-    /// Deprecated: Use `insert`.\n-    #[deprecated = \"Use `insert`\"]\n-    pub fn add(&mut self, e: E) {\n-        self.insert(e);\n-    }\n-\n     /// Adds an enum to the `EnumSet`, and returns `true` if it wasn't there before\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn insert(&mut self, e: E) -> bool {\n@@ -166,12 +147,6 @@ impl<E:CLike> EnumSet<E> {\n         result\n     }\n \n-    /// Deprecated: use `contains`.\n-    #[deprecated = \"use `contains\"]\n-    pub fn contains_elem(&self, e: E) -> bool {\n-        self.contains(&e)\n-    }\n-\n     /// Returns `true` if an `EnumSet` contains a given enum.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn contains(&self, e: &E) -> bool {"}, {"sha": "944b224fed8546d6c9b6ed5e7522baabf21c5bcc", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -66,7 +66,7 @@ pub mod vec;\n pub mod vec_map;\n \n pub mod bitv {\n-    pub use bit::{Bitv, Iter, from_fn, from_bytes};\n+    pub use bit::{Bitv, Iter};\n }\n \n pub mod bitv_set {\n@@ -105,7 +105,7 @@ mod prelude {\n     pub use core::borrow::IntoCow;\n     pub use core::char::Char;\n     pub use core::clone::Clone;\n-    pub use core::cmp::{PartialEq, Eq, Equiv, PartialOrd, Ord};\n+    pub use core::cmp::{PartialEq, Eq, PartialOrd, Ord};\n     pub use core::cmp::Ordering::{Less, Equal, Greater};\n     pub use core::iter::range;\n     pub use core::iter::{FromIterator, Extend, IteratorExt};\n@@ -123,15 +123,14 @@ mod prelude {\n \n     // in core and collections (may differ).\n     pub use slice::{AsSlice, SliceExt};\n-    pub use str::{from_str, Str, StrExt};\n+    pub use str::{Str, StrExt};\n \n     // from other crates.\n     pub use alloc::boxed::Box;\n     pub use unicode::char::UnicodeChar;\n \n     // from collections.\n     pub use slice::SliceConcatExt;\n-    pub use str::IntoMaybeOwned;\n     pub use string::{String, ToString};\n     pub use vec::Vec;\n }"}, {"sha": "e86c40bed212f90b71f79c96fd9cadba8bad205f", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -681,12 +681,6 @@ impl<T> RingBuf<T> {\n         unsafe { self.buffer_write(tail, t); }\n     }\n \n-    /// Deprecated: Renamed to `push_back`.\n-    #[deprecated = \"Renamed to `push_back`\"]\n-    pub fn push(&mut self, t: T) {\n-        self.push_back(t)\n-    }\n-\n     /// Appends an element to the back of a buffer\n     ///\n     /// # Examples\n@@ -711,12 +705,6 @@ impl<T> RingBuf<T> {\n         unsafe { self.buffer_write(head, t) }\n     }\n \n-    /// Deprecated: Renamed to `pop_back`.\n-    #[deprecated = \"Renamed to `pop_back`\"]\n-    pub fn pop(&mut self) -> Option<T> {\n-        self.pop_back()\n-    }\n-\n     /// Removes the last element from a buffer and returns it, or `None` if\n     /// it is empty.\n     ///\n@@ -1452,7 +1440,6 @@ mod tests {\n     use self::Taggy::*;\n     use self::Taggypar::*;\n     use prelude::*;\n-    use core::cmp;\n     use core::iter;\n     use std::fmt::Show;\n     use std::hash;"}, {"sha": "3602bfc10c3079b5b67a5914a7074b9c465f8c48", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 47, "deletions": 206, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -92,7 +92,7 @@ use core::borrow::{BorrowFrom, BorrowFromMut, ToOwned};\n use core::clone::Clone;\n use core::cmp::Ordering::{self, Greater, Less};\n use core::cmp::{self, Ord, PartialEq};\n-use core::iter::{Iterator, IteratorExt, IteratorCloneExt};\n+use core::iter::{Iterator, IteratorExt};\n use core::iter::{range, range_step, MultiplicativeIterator};\n use core::kinds::Sized;\n use core::mem::size_of;\n@@ -114,12 +114,6 @@ pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n pub use core::slice::{bytes, mut_ref_slice, ref_slice};\n pub use core::slice::{from_raw_buf, from_raw_mut_buf};\n \n-#[deprecated = \"use Iter instead\"]\n-pub type Items<'a, T:'a> = Iter<'a, T>;\n-\n-#[deprecated = \"use IterMut instead\"]\n-pub type MutItems<'a, T:'a> = IterMut<'a, T>;\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Basic slice extension methods\n ////////////////////////////////////////////////////////////////////////////////\n@@ -287,10 +281,6 @@ pub trait SliceExt for Sized? {\n     #[stable]\n     fn first(&self) -> Option<&Self::Item>;\n \n-    /// Deprecated: renamed to `first`.\n-    #[deprecated = \"renamed to `first`\"]\n-    fn head(&self) -> Option<&Self::Item> { self.first() }\n-\n     /// Returns all but the first element of a slice.\n     #[experimental = \"likely to be renamed\"]\n     fn tail(&self) -> &[Self::Item];\n@@ -308,12 +298,6 @@ pub trait SliceExt for Sized? {\n     #[stable]\n     unsafe fn get_unchecked(&self, index: uint) -> &Self::Item;\n \n-    /// Deprecated: renamed to `get_unchecked`.\n-    #[deprecated = \"renamed to get_unchecked\"]\n-    unsafe fn unsafe_get(&self, index: uint) -> &Self::Item {\n-        self.get_unchecked(index)\n-    }\n-\n     /// Returns an unsafe pointer to the slice's buffer\n     ///\n     /// The caller must ensure that the slice outlives the pointer this\n@@ -425,12 +409,6 @@ pub trait SliceExt for Sized? {\n     #[stable]\n     fn first_mut(&mut self) -> Option<&mut Self::Item>;\n \n-    /// Depreated: renamed to `first_mut`.\n-    #[deprecated = \"renamed to first_mut\"]\n-    fn head_mut(&mut self) -> Option<&mut Self::Item> {\n-        self.first_mut()\n-    }\n-\n     /// Returns all but the first element of a mutable slice\n     #[experimental = \"likely to be renamed or removed\"]\n     fn tail_mut(&mut self) -> &mut [Self::Item];\n@@ -549,12 +527,6 @@ pub trait SliceExt for Sized? {\n     #[stable]\n     unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut Self::Item;\n \n-    /// Deprecated: renamed to `get_unchecked_mut`.\n-    #[deprecated = \"renamed to get_unchecked_mut\"]\n-    unsafe fn unchecked_mut(&mut self, index: uint) -> &mut Self::Item {\n-        self.get_unchecked_mut(index)\n-    }\n-\n     /// Return an unsafe mutable pointer to the slice's buffer.\n     ///\n     /// The caller must ensure that the slice outlives the pointer this\n@@ -570,12 +542,6 @@ pub trait SliceExt for Sized? {\n     #[stable]\n     fn to_vec(&self) -> Vec<Self::Item> where Self::Item: Clone;\n \n-    /// Deprecated: use `iter().cloned().partition(f)` instead.\n-    #[deprecated = \"use iter().cloned().partition(f) instead\"]\n-    fn partitioned<F>(&self, f: F) -> (Vec<Self::Item>, Vec<Self::Item>) where\n-        Self::Item: Clone,\n-        F: FnMut(&Self::Item) -> bool;\n-\n     /// Creates an iterator that yields every possible permutation of the\n     /// vector in succession.\n     ///\n@@ -960,12 +926,6 @@ impl<T> SliceExt for [T] {\n         vector\n     }\n \n-\n-    #[inline]\n-    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool, T: Clone {\n-        self.iter().cloned().partition(f)\n-    }\n-\n     /// Returns an iterator over all permutations of a vector.\n     fn permutations(&self) -> Permutations<T> where T: Clone {\n         Permutations{\n@@ -1034,20 +994,10 @@ pub trait SliceConcatExt<Sized? T, U> for Sized? {\n     #[stable]\n     fn concat(&self) -> U;\n \n-    #[deprecated = \"renamed to concat\"]\n-    fn concat_vec(&self) -> U {\n-        self.concat()\n-    }\n-\n     /// Flattens a slice of `T` into a single value `U`, placing a\n     /// given seperator between each.\n     #[stable]\n     fn connect(&self, sep: &T) -> U;\n-\n-    #[deprecated = \"renamed to connect\"]\n-    fn connect_vec(&self, sep: &T) -> U {\n-        self.connect(sep)\n-    }\n }\n \n impl<T: Clone, V: AsSlice<T>> SliceConcatExt<T, Vec<T>> for [V] {\n@@ -1438,21 +1388,12 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n     }\n }\n \n-/// Deprecated, unsafe operations\n-#[deprecated]\n-pub mod raw {\n-    pub use core::slice::raw::{buf_as_slice, mut_buf_as_slice};\n-    pub use core::slice::raw::{shift_ptr, pop_ptr};\n-}\n-\n #[cfg(test)]\n mod tests {\n-    use std::boxed::Box;\n     use prelude::{Some, None, range, Vec, ToString, Clone, Greater, Less, Equal};\n     use prelude::{SliceExt, Iterator, IteratorExt};\n     use prelude::AsSlice;\n     use prelude::{RandomAccessIterator, Ord, SliceConcatExt};\n-    use core::cell::Cell;\n     use core::default::Default;\n     use core::mem;\n     use std::rand::{Rng, thread_rng};\n@@ -1466,7 +1407,7 @@ mod tests {\n     #[test]\n     fn test_from_fn() {\n         // Test on-stack from_fn.\n-        let mut v = Vec::from_fn(3u, square);\n+        let mut v = range(0, 3).map(square).collect::<Vec<_>>();\n         {\n             let v = v.as_slice();\n             assert_eq!(v.len(), 3u);\n@@ -1476,7 +1417,7 @@ mod tests {\n         }\n \n         // Test on-heap from_fn.\n-        v = Vec::from_fn(5u, square);\n+        v = range(0, 5).map(square).collect::<Vec<_>>();\n         {\n             let v = v.as_slice();\n             assert_eq!(v.len(), 5u);\n@@ -1491,7 +1432,7 @@ mod tests {\n     #[test]\n     fn test_from_elem() {\n         // Test on-stack from_elem.\n-        let mut v = Vec::from_elem(2u, 10u);\n+        let mut v = vec![10u, 10u];\n         {\n             let v = v.as_slice();\n             assert_eq!(v.len(), 2u);\n@@ -1500,7 +1441,7 @@ mod tests {\n         }\n \n         // Test on-heap from_elem.\n-        v = Vec::from_elem(6u, 20u);\n+        v = vec![20u, 20u, 20u, 20u, 20u, 20u];\n         {\n             let v = v.as_slice();\n             assert_eq!(v[0], 20u);\n@@ -1542,23 +1483,23 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_head() {\n+    fn test_first() {\n         let mut a = vec![];\n-        assert_eq!(a.as_slice().head(), None);\n+        assert_eq!(a.as_slice().first(), None);\n         a = vec![11i];\n-        assert_eq!(a.as_slice().head().unwrap(), &11);\n+        assert_eq!(a.as_slice().first().unwrap(), &11);\n         a = vec![11i, 12];\n-        assert_eq!(a.as_slice().head().unwrap(), &11);\n+        assert_eq!(a.as_slice().first().unwrap(), &11);\n     }\n \n     #[test]\n-    fn test_head_mut() {\n+    fn test_first_mut() {\n         let mut a = vec![];\n-        assert_eq!(a.head_mut(), None);\n+        assert_eq!(a.first_mut(), None);\n         a = vec![11i];\n-        assert_eq!(*a.head_mut().unwrap(), 11);\n+        assert_eq!(*a.first_mut().unwrap(), 11);\n         a = vec![11i, 12];\n-        assert_eq!(*a.head_mut().unwrap(), 11);\n+        assert_eq!(*a.first_mut().unwrap(), 11);\n     }\n \n     #[test]\n@@ -1762,42 +1703,6 @@ mod tests {\n         assert_eq!(v.as_slice()[1], 2);\n     }\n \n-    #[test]\n-    fn test_grow() {\n-        // Test on-stack grow().\n-        let mut v = vec![];\n-        v.grow(2u, 1i);\n-        {\n-            let v = v.as_slice();\n-            assert_eq!(v.len(), 2u);\n-            assert_eq!(v[0], 1);\n-            assert_eq!(v[1], 1);\n-        }\n-\n-        // Test on-heap grow().\n-        v.grow(3u, 2i);\n-        {\n-            let v = v.as_slice();\n-            assert_eq!(v.len(), 5u);\n-            assert_eq!(v[0], 1);\n-            assert_eq!(v[1], 1);\n-            assert_eq!(v[2], 2);\n-            assert_eq!(v[3], 2);\n-            assert_eq!(v[4], 2);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_grow_fn() {\n-        let mut v = vec![];\n-        v.grow_fn(3u, square);\n-        let v = v.as_slice();\n-        assert_eq!(v.len(), 3u);\n-        assert_eq!(v[0], 0u);\n-        assert_eq!(v[1], 1u);\n-        assert_eq!(v[2], 4u);\n-    }\n-\n     #[test]\n     fn test_truncate() {\n         let mut v = vec![box 6i,box 5,box 4];\n@@ -2130,22 +2035,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    fn test_partition() {\n-        assert_eq!((vec![]).partition(|x: &int| *x < 3), (vec![], vec![]));\n-        assert_eq!((vec![1i, 2, 3]).partition(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n-        assert_eq!((vec![1i, 2, 3]).partition(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n-        assert_eq!((vec![1i, 2, 3]).partition(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n-    }\n-\n-    #[test]\n-    fn test_partitioned() {\n-        assert_eq!(([]).partitioned(|x: &int| *x < 3), (vec![], vec![]));\n-        assert_eq!(([1i, 2, 3]).partitioned(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n-        assert_eq!(([1i, 2, 3]).partitioned(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n-        assert_eq!(([1i, 2, 3]).partitioned(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n-    }\n-\n     #[test]\n     fn test_concat() {\n         let v: [Vec<int>; 0] = [];\n@@ -2163,14 +2052,14 @@ mod tests {\n     #[test]\n     fn test_connect() {\n         let v: [Vec<int>; 0] = [];\n-        assert_eq!(v.connect_vec(&0), vec![]);\n-        assert_eq!([vec![1i], vec![2i, 3]].connect_vec(&0), vec![1, 0, 2, 3]);\n-        assert_eq!([vec![1i], vec![2i], vec![3i]].connect_vec(&0), vec![1, 0, 2, 0, 3]);\n+        assert_eq!(v.connect(&0), vec![]);\n+        assert_eq!([vec![1i], vec![2i, 3]].connect(&0), vec![1, 0, 2, 3]);\n+        assert_eq!([vec![1i], vec![2i], vec![3i]].connect(&0), vec![1, 0, 2, 0, 3]);\n \n         let v: [&[int]; 2] = [&[1], &[2, 3]];\n-        assert_eq!(v.connect_vec(&0), vec![1, 0, 2, 3]);\n+        assert_eq!(v.connect(&0), vec![1, 0, 2, 3]);\n         let v: [&[int]; 3] = [&[1], &[2], &[3]];\n-        assert_eq!(v.connect_vec(&0), vec![1, 0, 2, 0, 3]);\n+        assert_eq!(v.connect(&0), vec![1, 0, 2, 0, 3]);\n     }\n \n     #[test]\n@@ -2243,55 +2132,6 @@ mod tests {\n         assert_eq!(v[1], 3);\n     }\n \n-\n-    #[test]\n-    #[should_fail]\n-    fn test_from_fn_fail() {\n-        Vec::from_fn(100, |v| {\n-            if v == 50 { panic!() }\n-            box 0i\n-        });\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_from_elem_fail() {\n-\n-        struct S {\n-            f: Cell<int>,\n-            boxes: (Box<int>, Rc<int>)\n-        }\n-\n-        impl Clone for S {\n-            fn clone(&self) -> S {\n-                self.f.set(self.f.get() + 1);\n-                if self.f.get() == 10 { panic!() }\n-                S {\n-                    f: self.f.clone(),\n-                    boxes: self.boxes.clone(),\n-                }\n-            }\n-        }\n-\n-        let s = S {\n-            f: Cell::new(0),\n-            boxes: (box 0, Rc::new(0)),\n-        };\n-        let _ = Vec::from_elem(100, s);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_grow_fn_fail() {\n-        let mut v = vec![];\n-        v.grow_fn(100, |i| {\n-            if i == 50 {\n-                panic!()\n-            }\n-            (box 0i, Rc::new(0i))\n-        })\n-    }\n-\n     #[test]\n     #[should_fail]\n     fn test_permute_fail() {\n@@ -2880,14 +2720,15 @@ mod bench {\n     use prelude::*;\n     use core::mem;\n     use core::ptr;\n+    use core::iter::repeat;\n     use std::rand::{weak_rng, Rng};\n     use test::{Bencher, black_box};\n \n     #[bench]\n     fn iterator(b: &mut Bencher) {\n         // peculiar numbers to stop LLVM from optimising the summation\n         // out.\n-        let v = Vec::from_fn(100, |i| i ^ (i << 1) ^ (i >> 1));\n+        let v = range(0u, 100).map(|i| i ^ (i << 1) ^ (i >> 1)).collect::<Vec<_>>();\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -2901,7 +2742,7 @@ mod bench {\n \n     #[bench]\n     fn mut_iterator(b: &mut Bencher) {\n-        let mut v = Vec::from_elem(100, 0i);\n+        let mut v = repeat(0i).take(100).collect::<Vec<_>>();\n \n         b.iter(|| {\n             let mut i = 0i;\n@@ -2915,7 +2756,7 @@ mod bench {\n     #[bench]\n     fn concat(b: &mut Bencher) {\n         let xss: Vec<Vec<uint>> =\n-            Vec::from_fn(100, |i| range(0u, i).collect());\n+            range(0, 100u).map(|i| range(0, i).collect()).collect();\n         b.iter(|| {\n             xss.as_slice().concat();\n         });\n@@ -2924,9 +2765,9 @@ mod bench {\n     #[bench]\n     fn connect(b: &mut Bencher) {\n         let xss: Vec<Vec<uint>> =\n-            Vec::from_fn(100, |i| range(0u, i).collect());\n+            range(0, 100u).map(|i| range(0, i).collect()).collect();\n         b.iter(|| {\n-            xss.as_slice().connect_vec(&0)\n+            xss.as_slice().connect(&0)\n         });\n     }\n \n@@ -2941,7 +2782,7 @@ mod bench {\n \n     #[bench]\n     fn starts_with_same_vector(b: &mut Bencher) {\n-        let vec: Vec<uint> = Vec::from_fn(100, |i| i);\n+        let vec: Vec<uint> = range(0, 100).collect();\n         b.iter(|| {\n             vec.as_slice().starts_with(vec.as_slice())\n         })\n@@ -2957,8 +2798,8 @@ mod bench {\n \n     #[bench]\n     fn starts_with_diff_one_element_at_end(b: &mut Bencher) {\n-        let vec: Vec<uint> = Vec::from_fn(100, |i| i);\n-        let mut match_vec: Vec<uint> = Vec::from_fn(99, |i| i);\n+        let vec: Vec<uint> = range(0, 100).collect();\n+        let mut match_vec: Vec<uint> = range(0, 99).collect();\n         match_vec.push(0);\n         b.iter(|| {\n             vec.as_slice().starts_with(match_vec.as_slice())\n@@ -2967,7 +2808,7 @@ mod bench {\n \n     #[bench]\n     fn ends_with_same_vector(b: &mut Bencher) {\n-        let vec: Vec<uint> = Vec::from_fn(100, |i| i);\n+        let vec: Vec<uint> = range(0, 100).collect();\n         b.iter(|| {\n             vec.as_slice().ends_with(vec.as_slice())\n         })\n@@ -2983,8 +2824,8 @@ mod bench {\n \n     #[bench]\n     fn ends_with_diff_one_element_at_beginning(b: &mut Bencher) {\n-        let vec: Vec<uint> = Vec::from_fn(100, |i| i);\n-        let mut match_vec: Vec<uint> = Vec::from_fn(100, |i| i);\n+        let vec: Vec<uint> = range(0, 100).collect();\n+        let mut match_vec: Vec<uint> = range(0, 100).collect();\n         match_vec.as_mut_slice()[0] = 200;\n         b.iter(|| {\n             vec.as_slice().starts_with(match_vec.as_slice())\n@@ -2993,7 +2834,7 @@ mod bench {\n \n     #[bench]\n     fn contains_last_element(b: &mut Bencher) {\n-        let vec: Vec<uint> = Vec::from_fn(100, |i| i);\n+        let vec: Vec<uint> = range(0, 100).collect();\n         b.iter(|| {\n             vec.contains(&99u)\n         })\n@@ -3002,7 +2843,7 @@ mod bench {\n     #[bench]\n     fn zero_1kb_from_elem(b: &mut Bencher) {\n         b.iter(|| {\n-            Vec::from_elem(1024, 0u8)\n+            repeat(0u8).take(1024).collect::<Vec<_>>()\n         });\n     }\n \n@@ -3050,24 +2891,24 @@ mod bench {\n     fn random_inserts(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-                let mut v = Vec::from_elem(30, (0u, 0u));\n-                for _ in range(0u, 100) {\n-                    let l = v.len();\n-                    v.insert(rng.gen::<uint>() % (l + 1),\n-                             (1, 1));\n-                }\n-            })\n+            let mut v = repeat((0u, 0u)).take(30).collect::<Vec<_>>();\n+            for _ in range(0u, 100) {\n+                let l = v.len();\n+                v.insert(rng.gen::<uint>() % (l + 1),\n+                         (1, 1));\n+            }\n+        })\n     }\n     #[bench]\n     fn random_removes(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-                let mut v = Vec::from_elem(130, (0u, 0u));\n-                for _ in range(0u, 100) {\n-                    let l = v.len();\n-                    v.remove(rng.gen::<uint>() % l);\n-                }\n-            })\n+            let mut v = repeat((0u, 0u)).take(130).collect::<Vec<_>>();\n+            for _ in range(0u, 100) {\n+                let l = v.len();\n+                v.remove(rng.gen::<uint>() % l);\n+            }\n+        })\n     }\n \n     #[bench]\n@@ -3102,7 +2943,7 @@ mod bench {\n \n     #[bench]\n     fn sort_sorted(b: &mut Bencher) {\n-        let mut v = Vec::from_fn(10000, |i| i);\n+        let mut v = range(0u, 10000).collect::<Vec<_>>();\n         b.iter(|| {\n             v.sort();\n         });\n@@ -3146,7 +2987,7 @@ mod bench {\n \n     #[bench]\n     fn sort_big_sorted(b: &mut Bencher) {\n-        let mut v = Vec::from_fn(10000u, |i| (i, i, i, i));\n+        let mut v = range(0, 10000u).map(|i| (i, i, i, i)).collect::<Vec<_>>();\n         b.iter(|| {\n             v.sort();\n         });"}, {"sha": "ed6a957d2acfacbbecfe4de8238e9c85e92f25e3", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 75, "deletions": 561, "changes": 636, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -51,20 +51,14 @@\n \n #![doc(primitive = \"str\")]\n \n-use self::MaybeOwned::*;\n use self::RecompositionState::*;\n use self::DecompositionType::*;\n \n-use core::borrow::{BorrowFrom, Cow, ToOwned};\n+use core::borrow::{BorrowFrom, ToOwned};\n use core::char::Char;\n use core::clone::Clone;\n-use core::cmp::{Equiv, PartialEq, Eq, PartialOrd, Ord, Ordering};\n-use core::cmp;\n-use core::default::Default;\n-use core::fmt;\n-use core::hash;\n use core::iter::AdditiveIterator;\n-use core::iter::{self, range, Iterator, IteratorExt};\n+use core::iter::{range, Iterator, IteratorExt};\n use core::kinds::Sized;\n use core::ops;\n use core::option::Option::{self, Some, None};\n@@ -79,16 +73,13 @@ use unicode;\n use vec::Vec;\n use slice::SliceConcatExt;\n \n-pub use core::str::{from_utf8, CharEq, Chars, CharIndices};\n-pub use core::str::{Bytes, CharSplits, is_utf8};\n-pub use core::str::{CharSplitsN, Lines, LinesAny, MatchIndices, StrSplits, SplitStr};\n-pub use core::str::{CharRange};\n-pub use core::str::{FromStr, from_str, Utf8Error};\n-pub use core::str::Str;\n-pub use core::str::{from_utf8_unchecked, from_c_str};\n-pub use unicode::str::{Words, Graphemes, GraphemeIndices};\n+pub use core::str::{FromStr, Utf8Error, Str};\n+pub use core::str::{Lines, LinesAny, MatchIndices, SplitStr, CharRange};\n pub use core::str::{Split, SplitTerminator};\n pub use core::str::{SplitN, RSplitN};\n+pub use core::str::{from_utf8, CharEq, Chars, CharIndices, Bytes};\n+pub use core::str::{from_utf8_unchecked, from_c_str};\n+pub use unicode::str::{Words, Graphemes, GraphemeIndices};\n \n /*\n Section: Creating a string\n@@ -371,32 +362,6 @@ impl<'a> Iterator for Utf16Units<'a> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.encoder.size_hint() }\n }\n \n-/// Replaces all occurrences of one string with another.\n-///\n-/// # Arguments\n-///\n-/// * s - The string containing substrings to replace\n-/// * from - The string to replace\n-/// * to - The replacement string\n-///\n-/// # Return value\n-///\n-/// The original string with all occurrences of `from` replaced with `to`.\n-///\n-/// # Examples\n-///\n-/// ```rust\n-/// # #![allow(deprecated)]\n-/// use std::str;\n-/// let string = \"orange\";\n-/// let new_string = str::replace(string, \"or\", \"str\");\n-/// assert_eq!(new_string.as_slice(), \"strange\");\n-/// ```\n-#[deprecated = \"call the inherent method instead\"]\n-pub fn replace(s: &str, from: &str, to: &str) -> String {\n-    s.replace(from, to)\n-}\n-\n /*\n Section: Misc\n */\n@@ -413,215 +378,6 @@ macro_rules! utf8_acc_cont_byte {\n     ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as u32)\n }\n \n-/*\n-Section: MaybeOwned\n-*/\n-\n-/// A string type that can hold either a `String` or a `&str`.\n-/// This can be useful as an optimization when an allocation is sometimes\n-/// needed but not always.\n-#[deprecated = \"use std::string::CowString\"]\n-pub enum MaybeOwned<'a> {\n-    /// A borrowed string.\n-    Slice(&'a str),\n-    /// An owned string.\n-    Owned(String)\n-}\n-\n-/// A specialization of `CowString` to be sendable.\n-#[deprecated = \"use std::string::CowString<'static>\"]\n-pub type SendStr = CowString<'static>;\n-\n-#[deprecated = \"use std::string::CowString\"]\n-impl<'a> MaybeOwned<'a> {\n-    /// Returns `true` if this `MaybeOwned` wraps an owned string.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ``` ignore\n-    /// let string = String::from_str(\"orange\");\n-    /// let maybe_owned_string = string.into_maybe_owned();\n-    /// assert_eq!(true, maybe_owned_string.is_owned());\n-    /// ```\n-    #[inline]\n-    pub fn is_owned(&self) -> bool {\n-        match *self {\n-            Slice(_) => false,\n-            Owned(_) => true\n-        }\n-    }\n-\n-    /// Returns `true` if this `MaybeOwned` wraps a borrowed string.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ``` ignore\n-    /// let string = \"orange\";\n-    /// let maybe_owned_string = string.as_slice().into_maybe_owned();\n-    /// assert_eq!(true, maybe_owned_string.is_slice());\n-    /// ```\n-    #[inline]\n-    pub fn is_slice(&self) -> bool {\n-        match *self {\n-            Slice(_) => true,\n-            Owned(_) => false\n-        }\n-    }\n-\n-    /// Return the number of bytes in this string.\n-    #[inline]\n-    #[allow(deprecated)]\n-    pub fn len(&self) -> uint { self.as_slice().len() }\n-\n-    /// Returns true if the string contains no bytes\n-    #[allow(deprecated)]\n-    #[inline]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n-}\n-\n-#[deprecated = \"use std::borrow::IntoCow\"]\n-/// Trait for moving into a `MaybeOwned`.\n-pub trait IntoMaybeOwned<'a> {\n-    /// Moves `self` into a `MaybeOwned`.\n-    fn into_maybe_owned(self) -> MaybeOwned<'a>;\n-}\n-\n-#[deprecated = \"use std::borrow::IntoCow\"]\n-#[allow(deprecated)]\n-impl<'a> IntoMaybeOwned<'a> for String {\n-    /// # Examples\n-    ///\n-    /// ``` ignore\n-    /// let owned_string = String::from_str(\"orange\");\n-    /// let maybe_owned_string = owned_string.into_maybe_owned();\n-    /// assert_eq!(true, maybe_owned_string.is_owned());\n-    /// ```\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn into_maybe_owned(self) -> MaybeOwned<'a> {\n-        Owned(self)\n-    }\n-}\n-\n-#[deprecated = \"use std::borrow::IntoCow\"]\n-#[allow(deprecated)]\n-impl<'a> IntoMaybeOwned<'a> for &'a str {\n-    /// # Examples\n-    ///\n-    /// ``` ignore\n-    /// let string = \"orange\";\n-    /// let maybe_owned_str = string.as_slice().into_maybe_owned();\n-    /// assert_eq!(false, maybe_owned_str.is_owned());\n-    /// ```\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn into_maybe_owned(self) -> MaybeOwned<'a> { Slice(self) }\n-}\n-\n-#[allow(deprecated)]\n-#[deprecated = \"use std::borrow::IntoCow\"]\n-impl<'a> IntoMaybeOwned<'a> for MaybeOwned<'a> {\n-    /// # Examples\n-    ///\n-    /// ``` ignore\n-    /// let str = \"orange\";\n-    /// let maybe_owned_str = str.as_slice().into_maybe_owned();\n-    /// let maybe_maybe_owned_str = maybe_owned_str.into_maybe_owned();\n-    /// assert_eq!(false, maybe_maybe_owned_str.is_owned());\n-    /// ```\n-    #[inline]\n-    fn into_maybe_owned(self) -> MaybeOwned<'a> { self }\n-}\n-\n-#[deprecated = \"use std::string::CowString\"]\n-#[allow(deprecated)]\n-impl<'a> PartialEq for MaybeOwned<'a> {\n-    #[inline]\n-    fn eq(&self, other: &MaybeOwned) -> bool {\n-        self.as_slice() == other.as_slice()\n-    }\n-}\n-\n-#[deprecated = \"use std::string::CowString\"]\n-impl<'a> Eq for MaybeOwned<'a> {}\n-\n-#[deprecated = \"use std::string::CowString\"]\n-impl<'a> PartialOrd for MaybeOwned<'a> {\n-    #[inline]\n-    fn partial_cmp(&self, other: &MaybeOwned) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-#[deprecated = \"use std::string::CowString\"]\n-impl<'a> Ord for MaybeOwned<'a> {\n-    #[inline]\n-    #[allow(deprecated)]\n-    fn cmp(&self, other: &MaybeOwned) -> Ordering {\n-        self.as_slice().cmp(other.as_slice())\n-    }\n-}\n-\n-#[allow(deprecated)]\n-#[deprecated = \"use std::string::CowString\"]\n-impl<'a, S: Str> Equiv<S> for MaybeOwned<'a> {\n-    #[inline]\n-    fn equiv(&self, other: &S) -> bool {\n-        self.as_slice() == other.as_slice()\n-    }\n-}\n-\n-#[deprecated = \"use std::string::CowString\"]\n-#[allow(deprecated)]\n-impl<'a> Str for MaybeOwned<'a> {\n-    #[inline]\n-    fn as_slice<'b>(&'b self) -> &'b str {\n-        match *self {\n-            Slice(s) => s,\n-            Owned(ref s) => s.as_slice()\n-        }\n-    }\n-}\n-\n-#[deprecated = \"use std::string::CowString\"]\n-impl<'a> Clone for MaybeOwned<'a> {\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn clone(&self) -> MaybeOwned<'a> {\n-        match *self {\n-            Slice(s) => Slice(s),\n-            Owned(ref s) => Owned(String::from_str(s.as_slice()))\n-        }\n-    }\n-}\n-\n-#[deprecated = \"use std::string::CowString\"]\n-impl<'a> Default for MaybeOwned<'a> {\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn default() -> MaybeOwned<'a> { Slice(\"\") }\n-}\n-\n-#[deprecated = \"use std::string::CowString\"]\n-#[allow(deprecated)]\n-impl<'a, H: hash::Writer> hash::Hash<H> for MaybeOwned<'a> {\n-    #[inline]\n-    fn hash(&self, hasher: &mut H) {\n-        self.as_slice().hash(hasher)\n-    }\n-}\n-\n-#[deprecated = \"use std::string::CowString\"]\n-impl<'a> fmt::Show for MaybeOwned<'a> {\n-    #[inline]\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Slice(ref s) => s.fmt(f),\n-            Owned(ref s) => s.fmt(f)\n-        }\n-    }\n-}\n-\n #[unstable = \"trait is unstable\"]\n impl BorrowFrom<String> for str {\n     fn borrow_from(owned: &String) -> &str { owned[] }\n@@ -636,21 +392,10 @@ impl ToOwned<String> for str {\n     }\n }\n \n-/// Unsafe string operations.\n-#[deprecated]\n-pub mod raw {\n-    pub use core::str::raw::{from_utf8, c_str_to_static_slice, slice_bytes};\n-    pub use core::str::raw::{slice_unchecked};\n-}\n-\n /*\n Section: CowString\n */\n \n-/// A clone-on-write string\n-#[deprecated = \"use std::string::CowString instead\"]\n-pub type CowString<'a> = Cow<'a, String, str>;\n-\n /*\n Section: Trait implementations\n */\n@@ -706,46 +451,6 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n         result\n     }\n \n-    /// Given a string, makes a new string with repeated copies of it.\n-    #[deprecated = \"use repeat(self).take(n).collect() instead\"]\n-    fn repeat(&self, nn: uint) -> String {\n-        iter::repeat(self[]).take(nn).collect()\n-    }\n-\n-    /// Returns the Levenshtein Distance between two strings.\n-    #[deprecated = \"this function will be removed\"]\n-    fn lev_distance(&self, t: &str) -> uint {\n-        let me = self[];\n-        if me.is_empty() { return t.chars().count(); }\n-        if t.is_empty() { return me.chars().count(); }\n-\n-        let mut dcol: Vec<_> = range(0, t.len() + 1).collect();\n-        let mut t_last = 0;\n-\n-        for (i, sc) in me.chars().enumerate() {\n-\n-            let mut current = i;\n-            dcol[0] = current + 1;\n-\n-            for (j, tc) in t.chars().enumerate() {\n-\n-                let next = dcol[j + 1];\n-\n-                if sc == tc {\n-                    dcol[j + 1] = current;\n-                } else {\n-                    dcol[j + 1] = cmp::min(current, next);\n-                    dcol[j + 1] = cmp::min(dcol[j + 1], dcol[j]) + 1;\n-                }\n-\n-                current = next;\n-                t_last = j;\n-            }\n-        }\n-\n-        dcol[t_last + 1]\n-    }\n-\n     /// Returns an iterator over the string in Unicode Normalization Form D\n     /// (canonical decomposition).\n     #[inline]\n@@ -1002,7 +707,7 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n     /// assert_eq!(v, vec![\"1\", \"\", \"2\"]);\n     /// ```\n     #[unstable = \"might get removed in the future in favor of a more generic split()\"]\n-    fn split_str<'a>(&'a self, pat: &'a str) -> StrSplits<'a> {\n+    fn split_str<'a>(&'a self, pat: &'a str) -> SplitStr<'a> {\n         core_str::StrExt::split_str(self[], pat)\n     }\n \n@@ -1038,43 +743,6 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n         core_str::StrExt::lines_any(self[])\n     }\n \n-    /// Returns the number of Unicode code points (`char`) that a\n-    /// string holds.\n-    ///\n-    /// This does not perform any normalization, and is `O(n)`, since\n-    /// UTF-8 is a variable width encoding of code points.\n-    ///\n-    /// *Warning*: The number of code points in a string does not directly\n-    /// correspond to the number of visible characters or width of the\n-    /// visible text due to composing characters, and double- and\n-    /// zero-width ones.\n-    ///\n-    /// See also `.len()` for the byte length.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![allow(deprecated)]\n-    /// // composed forms of `\u00f6` and `\u00e9`\n-    /// let c = \"L\u00f6we \u8001\u864e L\u00e9opard\"; // German, Simplified Chinese, French\n-    /// // decomposed forms of `\u00f6` and `\u00e9`\n-    /// let d = \"Lo\\u{0308}we \u8001\u864e Le\\u{0301}opard\";\n-    ///\n-    /// assert_eq!(c.char_len(), 15);\n-    /// assert_eq!(d.char_len(), 17);\n-    ///\n-    /// assert_eq!(c.len(), 21);\n-    /// assert_eq!(d.len(), 23);\n-    ///\n-    /// // the two strings *look* the same\n-    /// println!(\"{}\", c);\n-    /// println!(\"{}\", d);\n-    /// ```\n-    #[deprecated = \"call .chars().count() instead\"]\n-    fn char_len(&self) -> uint {\n-        core_str::StrExt::char_len(self[])\n-    }\n-\n     /// Returns a slice of the given string from the byte range\n     /// [`begin`..`end`).\n     ///\n@@ -1220,12 +888,6 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n         core_str::StrExt::trim_matches(self[], pat)\n     }\n \n-    /// Deprecated\n-    #[deprecated = \"Replaced by `trim_matches`\"]\n-    fn trim_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str {\n-        self.trim_matches(to_trim)\n-    }\n-\n     /// Returns a string with all prefixes that match\n     /// the pattern `pat` repeatedly removed.\n     ///\n@@ -1246,12 +908,6 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n         core_str::StrExt::trim_left_matches(self[], pat)\n     }\n \n-    /// Deprecated\n-    #[deprecated = \"Replaced by `trim_left_matches`\"]\n-    fn trim_left_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str {\n-        self.trim_left_matches(to_trim)\n-    }\n-\n     /// Returns a string with all suffixes that match\n     /// the pattern `pat` repeatedly removed.\n     ///\n@@ -1272,12 +928,6 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n         core_str::StrExt::trim_right_matches(self[], pat)\n     }\n \n-    /// Deprecated\n-    #[deprecated = \"Replaced by `trim_right_matches`\"]\n-    fn trim_right_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str {\n-        self.trim_right_matches(to_trim)\n-    }\n-\n     /// Check that `index`-th byte lies at the start and/or end of a\n     /// UTF-8 code point sequence.\n     ///\n@@ -1599,7 +1249,7 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n     #[inline]\n     #[unstable = \"this method was just created\"]\n     fn parse<F: FromStr>(&self) -> Option<F> {\n-        FromStr::from_str(self[])\n+        core_str::StrExt::parse(self[])\n     }\n \n     /// Returns an iterator over the\n@@ -1657,43 +1307,6 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n         UnicodeStr::words(self[])\n     }\n \n-    /// Returns true if the string contains only whitespace.\n-    ///\n-    /// Whitespace characters are determined by `char::is_whitespace`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![allow(deprecated)]\n-    /// assert!(\" \\t\\n\".is_whitespace());\n-    /// assert!(\"\".is_whitespace());\n-    ///\n-    /// assert!( !\"abc\".is_whitespace());\n-    /// ```\n-    #[deprecated = \"use .chars().all(|c| c.is_whitespace())\"]\n-    fn is_whitespace(&self) -> bool {\n-        UnicodeStr::is_whitespace(self[])\n-    }\n-\n-    /// Returns true if the string contains only alphanumeric code\n-    /// points.\n-    ///\n-    /// Alphanumeric characters are determined by `char::is_alphanumeric`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![allow(deprecated)]\n-    /// assert!(\"L\u00f6we\u8001\u864eL\u00e9opard123\".is_alphanumeric());\n-    /// assert!(\"\".is_alphanumeric());\n-    ///\n-    /// assert!( !\" &*~\".is_alphanumeric());\n-    /// ```\n-    #[deprecated = \"use .chars().all(|c| c.is_alphanumeric())\"]\n-    fn is_alphanumeric(&self) -> bool {\n-        UnicodeStr::is_alphanumeric(self[])\n-    }\n-\n     /// Returns a string's displayed width in columns, treating control\n     /// characters as zero-width.\n     ///\n@@ -1725,13 +1338,6 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n     fn trim_right(&self) -> &str {\n         UnicodeStr::trim_right(self[])\n     }\n-\n-    /// Deprecated, call `.to_owned()` instead from the `std::borrow::ToOwned`\n-    /// trait.\n-    #[deprecated = \"call `.to_owned()` on `std::borrow::ToOwned` instead\"]\n-    fn into_string(&self) -> String {\n-        self[].to_owned()\n-    }\n }\n \n impl StrExt for str {}\n@@ -1740,10 +1346,8 @@ impl StrExt for str {}\n mod tests {\n     use prelude::*;\n \n-    use core::default::Default;\n     use core::iter::AdditiveIterator;\n-    use super::{from_utf8, is_utf8, raw};\n-    use super::MaybeOwned::{Owned, Slice};\n+    use super::from_utf8;\n     use super::Utf8Error;\n \n     #[test]\n@@ -1764,14 +1368,14 @@ mod tests {\n         assert_eq!(\"\\u{2620}\".len(), 3u);\n         assert_eq!(\"\\u{1d11e}\".len(), 4u);\n \n-        assert_eq!(\"\".char_len(), 0u);\n-        assert_eq!(\"hello world\".char_len(), 11u);\n-        assert_eq!(\"\\x63\".char_len(), 1u);\n-        assert_eq!(\"\\u{a2}\".char_len(), 1u);\n-        assert_eq!(\"\\u{3c0}\".char_len(), 1u);\n-        assert_eq!(\"\\u{2620}\".char_len(), 1u);\n-        assert_eq!(\"\\u{1d11e}\".char_len(), 1u);\n-        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".char_len(), 19u);\n+        assert_eq!(\"\".chars().count(), 0u);\n+        assert_eq!(\"hello world\".chars().count(), 11u);\n+        assert_eq!(\"\\x63\".chars().count(), 1u);\n+        assert_eq!(\"\\u{a2}\".chars().count(), 1u);\n+        assert_eq!(\"\\u{3c0}\".chars().count(), 1u);\n+        assert_eq!(\"\\u{2620}\".chars().count(), 1u);\n+        assert_eq!(\"\\u{1d11e}\".chars().count(), 1u);\n+        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".chars().count(), 19u);\n \n         assert_eq!(\"\uff48\uff45\uff4c\uff4c\uff4f\".width(false), 10u);\n         assert_eq!(\"\uff48\uff45\uff4c\uff4c\uff4f\".width(true), 10u);\n@@ -1854,7 +1458,7 @@ mod tests {\n     #[test]\n     fn test_slice_chars() {\n         fn t(a: &str, b: &str, start: uint) {\n-            assert_eq!(a.slice_chars(start, start + b.char_len()), b);\n+            assert_eq!(a.slice_chars(start, start + b.chars().count()), b);\n         }\n         t(\"\", \"\", 0);\n         t(\"hello\", \"llo\", 2);\n@@ -1864,7 +1468,7 @@ mod tests {\n         assert_eq!(\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\", \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".slice_chars(2, 8));\n     }\n \n-    fn s(x: &str) -> String { x.into_string() }\n+    fn s(x: &str) -> String { x.to_string() }\n \n     macro_rules! test_concat {\n         ($expected: expr, $string: expr) => {\n@@ -1904,7 +1508,7 @@ mod tests {\n     #[test]\n     fn test_connect_for_different_types() {\n         test_connect!(\"a-b\", [\"a\", \"b\"], \"-\");\n-        let hyphen = \"-\".into_string();\n+        let hyphen = \"-\".to_string();\n         test_connect!(\"a-b\", [s(\"a\"), s(\"b\")], hyphen.as_slice());\n         test_connect!(\"a-b\", vec![\"a\", \"b\"], hyphen.as_slice());\n         test_connect!(\"a-b\", vec![\"a\", \"b\"].as_slice(), \"-\");\n@@ -1920,20 +1524,11 @@ mod tests {\n         test_connect!(\"-a-bc\", [\"\", \"a\", \"bc\"], \"-\");\n     }\n \n-    #[test]\n-    fn test_repeat() {\n-        assert_eq!(\"x\".repeat(4), String::from_str(\"xxxx\"));\n-        assert_eq!(\"hi\".repeat(4), String::from_str(\"hihihihi\"));\n-        assert_eq!(\"\u0e44\u0e17\u534e\".repeat(3), String::from_str(\"\u0e44\u0e17\u534e\u0e44\u0e17\u534e\u0e44\u0e17\u534e\"));\n-        assert_eq!(\"\".repeat(4), String::from_str(\"\"));\n-        assert_eq!(\"hi\".repeat(0), String::from_str(\"\"));\n-    }\n-\n     #[test]\n     fn test_unsafe_slice() {\n-        assert_eq!(\"ab\", unsafe {raw::slice_bytes(\"abc\", 0, 2)});\n-        assert_eq!(\"bc\", unsafe {raw::slice_bytes(\"abc\", 1, 3)});\n-        assert_eq!(\"\", unsafe {raw::slice_bytes(\"abc\", 1, 1)});\n+        assert_eq!(\"ab\", unsafe {\"abc\".slice_unchecked(0, 2)});\n+        assert_eq!(\"bc\", unsafe {\"abc\".slice_unchecked(1, 3)});\n+        assert_eq!(\"\", unsafe {\"abc\".slice_unchecked(1, 1)});\n         fn a_million_letter_a() -> String {\n             let mut i = 0u;\n             let mut rs = String::new();\n@@ -1954,7 +1549,7 @@ mod tests {\n         }\n         let letters = a_million_letter_a();\n         assert!(half_a_million_letter_a() ==\n-            unsafe {String::from_str(raw::slice_bytes(letters.as_slice(),\n+            unsafe {String::from_str(letters.slice_unchecked(\n                                      0u,\n                                      500000))});\n     }\n@@ -2120,48 +1715,48 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_trim_left_chars() {\n+    fn test_trim_left_matches() {\n         let v: &[char] = &[];\n-        assert_eq!(\" *** foo *** \".trim_left_chars(v), \" *** foo *** \");\n+        assert_eq!(\" *** foo *** \".trim_left_matches(v), \" *** foo *** \");\n         let chars: &[char] = &['*', ' '];\n-        assert_eq!(\" *** foo *** \".trim_left_chars(chars), \"foo *** \");\n-        assert_eq!(\" ***  *** \".trim_left_chars(chars), \"\");\n-        assert_eq!(\"foo *** \".trim_left_chars(chars), \"foo *** \");\n+        assert_eq!(\" *** foo *** \".trim_left_matches(chars), \"foo *** \");\n+        assert_eq!(\" ***  *** \".trim_left_matches(chars), \"\");\n+        assert_eq!(\"foo *** \".trim_left_matches(chars), \"foo *** \");\n \n-        assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\");\n+        assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n         let chars: &[char] = &['1', '2'];\n-        assert_eq!(\"12foo1bar12\".trim_left_chars(chars), \"foo1bar12\");\n-        assert_eq!(\"123foo1bar123\".trim_left_chars(|&: c: char| c.is_numeric()), \"foo1bar123\");\n+        assert_eq!(\"12foo1bar12\".trim_left_matches(chars), \"foo1bar12\");\n+        assert_eq!(\"123foo1bar123\".trim_left_matches(|&: c: char| c.is_numeric()), \"foo1bar123\");\n     }\n \n     #[test]\n-    fn test_trim_right_chars() {\n+    fn test_trim_right_matches() {\n         let v: &[char] = &[];\n-        assert_eq!(\" *** foo *** \".trim_right_chars(v), \" *** foo *** \");\n+        assert_eq!(\" *** foo *** \".trim_right_matches(v), \" *** foo *** \");\n         let chars: &[char] = &['*', ' '];\n-        assert_eq!(\" *** foo *** \".trim_right_chars(chars), \" *** foo\");\n-        assert_eq!(\" ***  *** \".trim_right_chars(chars), \"\");\n-        assert_eq!(\" *** foo\".trim_right_chars(chars), \" *** foo\");\n+        assert_eq!(\" *** foo *** \".trim_right_matches(chars), \" *** foo\");\n+        assert_eq!(\" ***  *** \".trim_right_matches(chars), \"\");\n+        assert_eq!(\" *** foo\".trim_right_matches(chars), \" *** foo\");\n \n-        assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\");\n+        assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n         let chars: &[char] = &['1', '2'];\n-        assert_eq!(\"12foo1bar12\".trim_right_chars(chars), \"12foo1bar\");\n-        assert_eq!(\"123foo1bar123\".trim_right_chars(|&: c: char| c.is_numeric()), \"123foo1bar\");\n+        assert_eq!(\"12foo1bar12\".trim_right_matches(chars), \"12foo1bar\");\n+        assert_eq!(\"123foo1bar123\".trim_right_matches(|&: c: char| c.is_numeric()), \"123foo1bar\");\n     }\n \n     #[test]\n-    fn test_trim_chars() {\n+    fn test_trim_matches() {\n         let v: &[char] = &[];\n-        assert_eq!(\" *** foo *** \".trim_chars(v), \" *** foo *** \");\n+        assert_eq!(\" *** foo *** \".trim_matches(v), \" *** foo *** \");\n         let chars: &[char] = &['*', ' '];\n-        assert_eq!(\" *** foo *** \".trim_chars(chars), \"foo\");\n-        assert_eq!(\" ***  *** \".trim_chars(chars), \"\");\n-        assert_eq!(\"foo\".trim_chars(chars), \"foo\");\n+        assert_eq!(\" *** foo *** \".trim_matches(chars), \"foo\");\n+        assert_eq!(\" ***  *** \".trim_matches(chars), \"\");\n+        assert_eq!(\"foo\".trim_matches(chars), \"foo\");\n \n-        assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\");\n+        assert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\n         let chars: &[char] = &['1', '2'];\n-        assert_eq!(\"12foo1bar12\".trim_chars(chars), \"foo1bar\");\n-        assert_eq!(\"123foo1bar123\".trim_chars(|&: c: char| c.is_numeric()), \"foo1bar\");\n+        assert_eq!(\"12foo1bar12\".trim_matches(chars), \"foo1bar\");\n+        assert_eq!(\"123foo1bar123\".trim_matches(|&: c: char| c.is_numeric()), \"foo1bar\");\n     }\n \n     #[test]\n@@ -2196,11 +1791,11 @@ mod tests {\n \n     #[test]\n     fn test_is_whitespace() {\n-        assert!(\"\".is_whitespace());\n-        assert!(\" \".is_whitespace());\n-        assert!(\"\\u{2009}\".is_whitespace()); // Thin space\n-        assert!(\"  \\n\\t   \".is_whitespace());\n-        assert!(!\"   _   \".is_whitespace());\n+        assert!(\"\".chars().all(|c| c.is_whitespace()));\n+        assert!(\" \".chars().all(|c| c.is_whitespace()));\n+        assert!(\"\\u{2009}\".chars().all(|c| c.is_whitespace())); // Thin space\n+        assert!(\"  \\n\\t   \".chars().all(|c| c.is_whitespace()));\n+        assert!(!\"   _   \".chars().all(|c| c.is_whitespace()));\n     }\n \n     #[test]\n@@ -2218,26 +1813,26 @@ mod tests {\n     #[test]\n     fn test_is_utf8() {\n         // deny overlong encodings\n-        assert!(!is_utf8(&[0xc0, 0x80]));\n-        assert!(!is_utf8(&[0xc0, 0xae]));\n-        assert!(!is_utf8(&[0xe0, 0x80, 0x80]));\n-        assert!(!is_utf8(&[0xe0, 0x80, 0xaf]));\n-        assert!(!is_utf8(&[0xe0, 0x81, 0x81]));\n-        assert!(!is_utf8(&[0xf0, 0x82, 0x82, 0xac]));\n-        assert!(!is_utf8(&[0xf4, 0x90, 0x80, 0x80]));\n+        assert!(from_utf8(&[0xc0, 0x80]).is_err());\n+        assert!(from_utf8(&[0xc0, 0xae]).is_err());\n+        assert!(from_utf8(&[0xe0, 0x80, 0x80]).is_err());\n+        assert!(from_utf8(&[0xe0, 0x80, 0xaf]).is_err());\n+        assert!(from_utf8(&[0xe0, 0x81, 0x81]).is_err());\n+        assert!(from_utf8(&[0xf0, 0x82, 0x82, 0xac]).is_err());\n+        assert!(from_utf8(&[0xf4, 0x90, 0x80, 0x80]).is_err());\n \n         // deny surrogates\n-        assert!(!is_utf8(&[0xED, 0xA0, 0x80]));\n-        assert!(!is_utf8(&[0xED, 0xBF, 0xBF]));\n+        assert!(from_utf8(&[0xED, 0xA0, 0x80]).is_err());\n+        assert!(from_utf8(&[0xED, 0xBF, 0xBF]).is_err());\n \n-        assert!(is_utf8(&[0xC2, 0x80]));\n-        assert!(is_utf8(&[0xDF, 0xBF]));\n-        assert!(is_utf8(&[0xE0, 0xA0, 0x80]));\n-        assert!(is_utf8(&[0xED, 0x9F, 0xBF]));\n-        assert!(is_utf8(&[0xEE, 0x80, 0x80]));\n-        assert!(is_utf8(&[0xEF, 0xBF, 0xBF]));\n-        assert!(is_utf8(&[0xF0, 0x90, 0x80, 0x80]));\n-        assert!(is_utf8(&[0xF4, 0x8F, 0xBF, 0xBF]));\n+        assert!(from_utf8(&[0xC2, 0x80]).is_ok());\n+        assert!(from_utf8(&[0xDF, 0xBF]).is_ok());\n+        assert!(from_utf8(&[0xE0, 0xA0, 0x80]).is_ok());\n+        assert!(from_utf8(&[0xED, 0x9F, 0xBF]).is_ok());\n+        assert!(from_utf8(&[0xEE, 0x80, 0x80]).is_ok());\n+        assert!(from_utf8(&[0xEF, 0xBF, 0xBF]).is_ok());\n+        assert!(from_utf8(&[0xF0, 0x90, 0x80, 0x80]).is_ok());\n+        assert!(from_utf8(&[0xF4, 0x8F, 0xBF, 0xBF]).is_ok());\n     }\n \n     #[test]\n@@ -2411,7 +2006,7 @@ mod tests {\n         let mut pos = 0;\n         for ch in v.iter() {\n             assert!(s.char_at(pos) == *ch);\n-            pos += String::from_char(1, *ch).len();\n+            pos += ch.to_string().len();\n         }\n     }\n \n@@ -2422,7 +2017,7 @@ mod tests {\n         let mut pos = s.len();\n         for ch in v.iter().rev() {\n             assert!(s.char_at_reverse(pos) == *ch);\n-            pos -= String::from_char(1, *ch).len();\n+            pos -= ch.to_string().len();\n         }\n     }\n \n@@ -3213,66 +2808,6 @@ mod tests {\n         let xs = b\"hello\\xFF\";\n         assert_eq!(from_utf8(xs), Err(Utf8Error::TooShort));\n     }\n-\n-    #[test]\n-    fn test_maybe_owned_traits() {\n-        let s = Slice(\"abcde\");\n-        assert_eq!(s.len(), 5);\n-        assert_eq!(s.as_slice(), \"abcde\");\n-        assert_eq!(String::from_str(s.as_slice()).as_slice(), \"abcde\");\n-        assert_eq!(format!(\"{}\", s).as_slice(), \"abcde\");\n-        assert!(s.lt(&Owned(String::from_str(\"bcdef\"))));\n-        assert_eq!(Slice(\"\"), Default::default());\n-\n-        let o = Owned(String::from_str(\"abcde\"));\n-        assert_eq!(o.len(), 5);\n-        assert_eq!(o.as_slice(), \"abcde\");\n-        assert_eq!(String::from_str(o.as_slice()).as_slice(), \"abcde\");\n-        assert_eq!(format!(\"{}\", o).as_slice(), \"abcde\");\n-        assert!(o.lt(&Slice(\"bcdef\")));\n-        assert_eq!(Owned(String::from_str(\"\")), Default::default());\n-\n-        assert!(s.cmp(&o) == Equal);\n-        assert!(s.equiv(&o));\n-\n-        assert!(o.cmp(&s) == Equal);\n-        assert!(o.equiv(&s));\n-    }\n-\n-    #[test]\n-    fn test_maybe_owned_methods() {\n-        let s = Slice(\"abcde\");\n-        assert!(s.is_slice());\n-        assert!(!s.is_owned());\n-\n-        let o = Owned(String::from_str(\"abcde\"));\n-        assert!(!o.is_slice());\n-        assert!(o.is_owned());\n-    }\n-\n-    #[test]\n-    fn test_maybe_owned_clone() {\n-        assert_eq!(Owned(String::from_str(\"abcde\")), Slice(\"abcde\").clone());\n-        assert_eq!(Owned(String::from_str(\"abcde\")), Owned(String::from_str(\"abcde\")).clone());\n-        assert_eq!(Slice(\"abcde\"), Slice(\"abcde\").clone());\n-        assert_eq!(Slice(\"abcde\"), Owned(String::from_str(\"abcde\")).clone());\n-    }\n-\n-    #[test]\n-    fn test_maybe_owned_into_string() {\n-        assert_eq!(Slice(\"abcde\").to_string(), String::from_str(\"abcde\"));\n-        assert_eq!(Owned(String::from_str(\"abcde\")).to_string(),\n-                   String::from_str(\"abcde\"));\n-    }\n-\n-    #[test]\n-    fn test_into_maybe_owned() {\n-        assert_eq!(\"abcde\".into_maybe_owned(), Slice(\"abcde\"));\n-        assert_eq!((String::from_str(\"abcde\")).into_maybe_owned(), Slice(\"abcde\"));\n-        assert_eq!(\"abcde\".into_maybe_owned(), Owned(String::from_str(\"abcde\")));\n-        assert_eq!((String::from_str(\"abcde\")).into_maybe_owned(),\n-                   Owned(String::from_str(\"abcde\")));\n-    }\n }\n \n #[cfg(test)]\n@@ -3329,15 +2864,15 @@ mod bench {\n     #[bench]\n     fn char_indicesator(b: &mut Bencher) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-        let len = s.char_len();\n+        let len = s.chars().count();\n \n         b.iter(|| assert_eq!(s.char_indices().count(), len));\n     }\n \n     #[bench]\n     fn char_indicesator_rev(b: &mut Bencher) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-        let len = s.char_len();\n+        let len = s.chars().count();\n \n         b.iter(|| assert_eq!(s.char_indices().rev().count(), len));\n     }\n@@ -3416,27 +2951,6 @@ mod bench {\n         b.iter(|| assert_eq!(s.split(c).count(), len));\n     }\n \n-    #[bench]\n-    fn is_utf8_100_ascii(b: &mut Bencher) {\n-\n-        let s = b\"Hello there, the quick brown fox jumped over the lazy dog! \\\n-                  Lorem ipsum dolor sit amet, consectetur. \";\n-\n-        assert_eq!(100, s.len());\n-        b.iter(|| {\n-            is_utf8(s)\n-        });\n-    }\n-\n-    #[bench]\n-    fn is_utf8_100_multibyte(b: &mut Bencher) {\n-        let s = \"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\".as_bytes();\n-        assert_eq!(100, s.len());\n-        b.iter(|| {\n-            is_utf8(s)\n-        });\n-    }\n-\n     #[bench]\n     fn bench_connect(b: &mut Bencher) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";"}, {"sha": "e7451331908aed9e8fdf2fefb3ed60790b63e9dc", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 8, "deletions": 142, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -17,7 +17,6 @@\n use core::prelude::*;\n \n use core::borrow::{Cow, IntoCow};\n-use core::cmp::Equiv;\n use core::default::Default;\n use core::fmt;\n use core::hash;\n@@ -109,7 +108,6 @@ impl String {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// # #![allow(deprecated)]\n     /// use std::str::Utf8Error;\n     ///\n     /// let hello_vec = vec![104, 101, 108, 108, 111];\n@@ -309,22 +307,6 @@ impl String {\n         unicode_str::utf16_items(v).map(|c| c.to_char_lossy()).collect()\n     }\n \n-    /// Convert a vector of `char`s to a `String`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// # #![allow(deprecated)]\n-    /// let chars = &['h', 'e', 'l', 'l', 'o'];\n-    /// let s = String::from_chars(chars);\n-    /// assert_eq!(s.as_slice(), \"hello\");\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"use .collect() instead\"]\n-    pub fn from_chars(chs: &[char]) -> String {\n-        chs.iter().map(|c| *c).collect()\n-    }\n-\n     /// Creates a new `String` from a length, capacity, and pointer.\n     ///\n     /// This is unsafe because:\n@@ -386,32 +368,6 @@ impl String {\n         self.vec\n     }\n \n-    /// Creates a string buffer by repeating a character `length` times.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let s = String::from_char(5, 'a');\n-    /// assert_eq!(s.as_slice(), \"aaaaa\");\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"use repeat(ch).take(length).collect() instead\"]\n-    pub fn from_char(length: uint, ch: char) -> String {\n-        if length == 0 {\n-            return String::new()\n-        }\n-\n-        let mut buf = String::new();\n-        buf.push(ch);\n-        let size = buf.len() * (length - 1);\n-        buf.reserve_exact(size);\n-        for _ in range(1, length) {\n-            buf.push(ch)\n-        }\n-        buf\n-    }\n-\n     /// Pushes the given string onto this string buffer.\n     ///\n     /// # Examples\n@@ -427,24 +383,6 @@ impl String {\n         self.vec.push_all(string.as_bytes())\n     }\n \n-    /// Pushes `ch` onto the given string `count` times.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let mut s = String::from_str(\"foo\");\n-    /// s.grow(5, 'Z');\n-    /// assert_eq!(s.as_slice(), \"fooZZZZZ\");\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"deprecated in favor of .extend(repeat(ch).take(count))\"]\n-    pub fn grow(&mut self, count: uint, ch: char) {\n-        for _ in range(0, count) {\n-            self.push(ch)\n-        }\n-    }\n-\n     /// Returns the number of bytes that this string buffer can hold without\n     /// reallocating.\n     ///\n@@ -460,12 +398,6 @@ impl String {\n         self.vec.capacity()\n     }\n \n-    /// Deprecated: Renamed to `reserve`.\n-    #[deprecated = \"Renamed to `reserve`\"]\n-    pub fn reserve_additional(&mut self, extra: uint) {\n-        self.vec.reserve(extra)\n-    }\n-\n     /// Reserves capacity for at least `additional` more bytes to be inserted\n     /// in the given `String`. The collection may reserve more space to avoid\n     /// frequent reallocations.\n@@ -869,7 +801,6 @@ impl<'a, 'b> PartialEq<CowString<'a>> for &'b str {\n }\n \n #[experimental = \"waiting on Str stabilization\"]\n-#[allow(deprecated)]\n impl Str for String {\n     #[inline]\n     #[stable]\n@@ -901,15 +832,6 @@ impl<H: hash::Writer> hash::Hash<H> for String {\n     }\n }\n \n-#[allow(deprecated)]\n-#[deprecated = \"Use overloaded `core::cmp::PartialEq`\"]\n-impl<'a, S: Str> Equiv<S> for String {\n-    #[inline]\n-    fn equiv(&self, other: &S) -> bool {\n-        self.as_slice() == other.as_slice()\n-    }\n-}\n-\n #[experimental = \"waiting on Add stabilization\"]\n impl<'a> Add<&'a str> for String {\n     type Output = String;\n@@ -991,13 +913,6 @@ impl FromStr for String {\n     }\n }\n \n-/// Trait for converting a type to a string, consuming it in the process.\n-#[deprecated = \"trait will be removed\"]\n-pub trait IntoString {\n-    /// Consume and convert to a string.\n-    fn into_string(self) -> String;\n-}\n-\n /// A generic trait for converting a value to a string\n pub trait ToString {\n     /// Converts the value of `self` to an owned string\n@@ -1026,59 +941,10 @@ impl<'a> IntoCow<'a, String, str> for &'a str {\n     }\n }\n \n-/// Unsafe operations\n-#[deprecated]\n-pub mod raw {\n-    use super::String;\n-    use vec::Vec;\n-\n-    /// Creates a new `String` from a length, capacity, and pointer.\n-    ///\n-    /// This is unsafe because:\n-    /// * We call `Vec::from_raw_parts` to get a `Vec<u8>`;\n-    /// * We assume that the `Vec` contains valid UTF-8.\n-    #[inline]\n-    #[deprecated = \"renamed to String::from_raw_parts\"]\n-    pub unsafe fn from_parts(buf: *mut u8, length: uint, capacity: uint) -> String {\n-        String::from_raw_parts(buf, length, capacity)\n-    }\n-\n-    /// Creates a `String` from a `*const u8` buffer of the given length.\n-    ///\n-    /// This function is unsafe because of two reasons:\n-    ///\n-    /// * A raw pointer is dereferenced and transmuted to `&[u8]`;\n-    /// * The slice is not checked to see whether it contains valid UTF-8.\n-    #[deprecated = \"renamed to String::from_raw_buf_len\"]\n-    pub unsafe fn from_buf_len(buf: *const u8, len: uint) -> String {\n-        String::from_raw_buf_len(buf, len)\n-    }\n-\n-    /// Creates a `String` from a null-terminated `*const u8` buffer.\n-    ///\n-    /// This function is unsafe because we dereference memory until we find the NUL character,\n-    /// which is not guaranteed to be present. Additionally, the slice is not checked to see\n-    /// whether it contains valid UTF-8\n-    #[deprecated = \"renamed to String::from_raw_buf\"]\n-    pub unsafe fn from_buf(buf: *const u8) -> String {\n-        String::from_raw_buf(buf)\n-    }\n-\n-    /// Converts a vector of bytes to a new `String` without checking if\n-    /// it contains valid UTF-8. This is unsafe because it assumes that\n-    /// the UTF-8-ness of the vector has already been validated.\n-    #[inline]\n-    #[deprecated = \"renamed to String::from_utf8_unchecked\"]\n-    pub unsafe fn from_utf8(bytes: Vec<u8>) -> String {\n-        String::from_utf8_unchecked(bytes)\n-    }\n-}\n-\n /// A clone-on-write string\n #[stable]\n pub type CowString<'a> = Cow<'a, String, str>;\n \n-#[allow(deprecated)]\n impl<'a> Str for CowString<'a> {\n     #[inline]\n     fn as_slice<'b>(&'b self) -> &'b str {\n@@ -1099,8 +965,8 @@ mod tests {\n     use test::Bencher;\n \n     use str::Utf8Error;\n-    use str;\n-    use super::as_string;\n+    use core::iter::repeat;\n+    use super::{as_string, CowString};\n \n     #[test]\n     fn test_as_string() {\n@@ -1110,7 +976,7 @@ mod tests {\n \n     #[test]\n     fn test_from_str() {\n-      let owned: Option<::std::string::String> = from_str(\"string\");\n+      let owned: Option<::std::string::String> = \"string\".parse();\n       assert_eq!(owned.as_ref().map(|s| s.as_slice()), Some(\"string\"));\n     }\n \n@@ -1133,11 +999,11 @@ mod tests {\n     #[test]\n     fn test_from_utf8_lossy() {\n         let xs = b\"hello\";\n-        let ys: str::CowString = \"hello\".into_cow();\n+        let ys: CowString = \"hello\".into_cow();\n         assert_eq!(String::from_utf8_lossy(xs), ys);\n \n         let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes();\n-        let ys: str::CowString = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".into_cow();\n+        let ys: CowString = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".into_cow();\n         assert_eq!(String::from_utf8_lossy(xs), ys);\n \n         let xs = b\"Hello\\xC2 There\\xFF Goodbye\";\n@@ -1264,7 +1130,7 @@ mod tests {\n     fn test_from_buf_len() {\n         unsafe {\n             let a = vec![65u8, 65, 65, 65, 65, 65, 65, 0];\n-            assert_eq!(super::raw::from_buf_len(a.as_ptr(), 3), String::from_str(\"AAA\"));\n+            assert_eq!(String::from_raw_buf_len(a.as_ptr(), 3), String::from_str(\"AAA\"));\n         }\n     }\n \n@@ -1273,7 +1139,7 @@ mod tests {\n         unsafe {\n             let a = vec![65, 65, 65, 65, 65, 65, 65, 0];\n             let b = a.as_ptr();\n-            let c = super::raw::from_buf(b);\n+            let c = String::from_raw_buf(b);\n             assert_eq!(c, String::from_str(\"AAAAAAA\"));\n         }\n     }\n@@ -1530,7 +1396,7 @@ mod tests {\n \n     #[bench]\n     fn from_utf8_lossy_100_invalid(b: &mut Bencher) {\n-        let s = Vec::from_elem(100, 0xF5u8);\n+        let s = repeat(0xf5u8).take(100).collect::<Vec<_>>();\n         b.iter(|| {\n             let _ = String::from_utf8_lossy(s.as_slice());\n         });"}, {"sha": "b8f97799c971872b1245b2ed15e0110afa35d54d", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 20, "deletions": 124, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -50,7 +50,7 @@ use alloc::boxed::Box;\n use alloc::heap::{EMPTY, allocate, reallocate, deallocate};\n use core::borrow::{Cow, IntoCow};\n use core::cmp::max;\n-use core::cmp::{Equiv, Ordering};\n+use core::cmp::{Ordering};\n use core::default::Default;\n use core::fmt;\n use core::hash::{self, Hash};\n@@ -207,13 +207,6 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Deprecated: use `iter::range(0, length).map(op).collect()` instead\n-    #[inline]\n-    #[deprecated = \"use iter::range(0, length).map(op).collect() instead\"]\n-    pub fn from_fn<F>(length: uint, op: F) -> Vec<T> where F: FnMut(uint) -> T {\n-        range(0, length).map(op).collect()\n-    }\n-\n     /// Creates a `Vec<T>` directly from the raw components of another vector.\n     ///\n     /// This is highly unsafe, due to the number of invariants that aren't checked.\n@@ -268,13 +261,6 @@ impl<T> Vec<T> {\n         dst\n     }\n \n-    /// Deprecated: use `into_iter().partition(f)` instead.\n-    #[inline]\n-    #[deprecated = \"use into_iter().partition(f) instead\"]\n-    pub fn partition<F>(self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n-        self.into_iter().partition(f)\n-    }\n-\n     /// Returns the number of elements the vector can hold without\n     /// reallocating.\n     ///\n@@ -290,12 +276,6 @@ impl<T> Vec<T> {\n         self.cap\n     }\n \n-    /// Deprecated: Renamed to `reserve`.\n-    #[deprecated = \"Renamed to `reserve`\"]\n-    pub fn reserve_additional(&mut self, extra: uint) {\n-        self.reserve(extra)\n-    }\n-\n     /// Reserves capacity for at least `additional` more elements to be inserted in the given\n     /// `Vec<T>`. The collection may reserve more space to avoid frequent reallocations.\n     ///\n@@ -635,12 +615,6 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Deprecated: use `extend(range(0, n).map(f))` instead.\n-    #[deprecated = \"use extend(range(0, n).map(f)) instead\"]\n-    pub fn grow_fn<F>(&mut self, n: uint, f: F) where F: FnMut(uint) -> T {\n-        self.extend(range(0, n).map(f));\n-    }\n-\n     /// Appends an element to the back of a collection.\n     ///\n     /// # Panics\n@@ -979,13 +953,6 @@ impl<T> Vec<T> {\n }\n \n impl<T: Clone> Vec<T> {\n-    /// Deprecated: use `repeat(value).take(length).collect()` instead.\n-    #[inline]\n-    #[deprecated = \"use repeat(value).take(length).collect() instead\"]\n-    pub fn from_elem(length: uint, value: T) -> Vec<T> {\n-        repeat(value).take(length).collect()\n-    }\n-\n     /// Resizes the `Vec` in-place so that `len()` is equal to `new_len`.\n     ///\n     /// Calls either `extend()` or `truncate()` depending on whether `new_len`\n@@ -1044,18 +1011,6 @@ impl<T: Clone> Vec<T> {\n             }\n         }\n     }\n-\n-    /// Deprecated: use `extend(repeat(value).take(n))` instead\n-    #[deprecated = \"use extend(repeat(value).take(n)) instead\"]\n-    pub fn grow(&mut self, n: uint, value: T) {\n-        self.extend(repeat(value).take(n))\n-    }\n-\n-    /// Deprecated: use `iter().cloned().partition(f)` instead.\n-    #[deprecated = \"use iter().cloned().partition(f) instead\"]\n-    pub fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n-        self.iter().cloned().partition(f)\n-    }\n }\n \n impl<T: PartialEq> Vec<T> {\n@@ -1158,16 +1113,6 @@ impl<T: PartialEq> Vec<T> {\n     }\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Public free fns\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// Deprecated: use `unzip` directly on the iterator instead.\n-#[deprecated = \"use unzip directly on the iterator instead\"]\n-pub fn unzip<T, U, V: Iterator<Item=(T, U)>>(iter: V) -> (Vec<T>, Vec<U>) {\n-    iter.unzip()\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Internal methods and functions\n ////////////////////////////////////////////////////////////////////////////////\n@@ -1438,13 +1383,6 @@ impl<T: PartialOrd> PartialOrd for Vec<T> {\n #[unstable = \"waiting on Eq stability\"]\n impl<T: Eq> Eq for Vec<T> {}\n \n-#[allow(deprecated)]\n-#[deprecated = \"Use overloaded `core::cmp::PartialEq`\"]\n-impl<T: PartialEq, Sized? V: AsSlice<T>> Equiv<V> for Vec<T> {\n-    #[inline]\n-    fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n-}\n-\n #[unstable = \"waiting on Ord stability\"]\n impl<T: Ord> Ord for Vec<T> {\n     #[inline]\n@@ -1563,9 +1501,6 @@ pub struct IntoIter<T> {\n     end: *const T\n }\n \n-#[deprecated = \"use IntoIter instead\"]\n-pub type MoveItems<T> = IntoIter<T>;\n-\n impl<T> IntoIter<T> {\n     #[inline]\n     /// Drops all items that have not yet been moved and returns the empty vector.\n@@ -1578,10 +1513,6 @@ impl<T> IntoIter<T> {\n             Vec { ptr: NonZero::new(allocation), cap: cap, len: 0 }\n         }\n     }\n-\n-    /// Deprecated, use .into_inner() instead\n-    #[deprecated = \"use .into_inner() instead\"]\n-    pub fn unwrap(self) -> Vec<T> { self.into_inner() }\n }\n \n impl<T> Iterator for IntoIter<T> {\n@@ -1780,26 +1711,6 @@ pub fn as_vec<'a, T>(x: &'a [T]) -> DerefVec<'a, T> {\n     }\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Raw module (deprecated)\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// Unsafe vector operations.\n-#[deprecated]\n-pub mod raw {\n-    use super::Vec;\n-\n-    /// Constructs a vector from an unsafe pointer to a buffer.\n-    ///\n-    /// The elements of the buffer are copied into the vector without cloning,\n-    /// as if `ptr::read()` were called on them.\n-    #[inline]\n-    #[deprecated = \"renamed to Vec::from_raw_buf\"]\n-    pub unsafe fn from_buf<T>(ptr: *const T, elts: uint) -> Vec<T> {\n-        Vec::from_raw_buf(ptr, elts)\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Partial vec, used for map_in_place\n ////////////////////////////////////////////////////////////////////////////////\n@@ -1879,8 +1790,9 @@ impl<T,U> Drop for PartialVecZeroSized<T,U> {\n mod tests {\n     use prelude::*;\n     use core::mem::size_of;\n+    use core::iter::repeat;\n     use test::Bencher;\n-    use super::{as_vec, unzip, raw};\n+    use super::as_vec;\n \n     struct DropCounter<'a> {\n         count: &'a mut int\n@@ -2069,13 +1981,6 @@ mod tests {\n         assert_eq!(v, three)\n     }\n \n-    #[test]\n-    fn test_grow_fn() {\n-        let mut v = vec![0u, 1];\n-        v.grow_fn(3, |i| i);\n-        assert!(v == vec![0u, 1, 0, 1, 2]);\n-    }\n-\n     #[test]\n     fn test_retain() {\n         let mut vec = vec![1u, 2, 3, 4];\n@@ -2116,25 +2021,17 @@ mod tests {\n \n     #[test]\n     fn test_partition() {\n-        assert_eq!(vec![].partition(|x: &int| *x < 3), (vec![], vec![]));\n-        assert_eq!(vec![1i, 2, 3].partition(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n-        assert_eq!(vec![1i, 2, 3].partition(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n-        assert_eq!(vec![1i, 2, 3].partition(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n-    }\n-\n-    #[test]\n-    fn test_partitioned() {\n-        assert_eq!(vec![].partitioned(|x: &int| *x < 3), (vec![], vec![]));\n-        assert_eq!(vec![1i, 2, 3].partitioned(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n-        assert_eq!(vec![1i, 2, 3].partitioned(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n-        assert_eq!(vec![1i, 2, 3].partitioned(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n+        assert_eq!(vec![].into_iter().partition(|x: &int| *x < 3), (vec![], vec![]));\n+        assert_eq!(vec![1i, 2, 3].into_iter().partition(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n+        assert_eq!(vec![1i, 2, 3].into_iter().partition(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n+        assert_eq!(vec![1i, 2, 3].into_iter().partition(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n     }\n \n     #[test]\n     fn test_zip_unzip() {\n         let z1 = vec![(1i, 4i), (2, 5), (3, 6)];\n \n-        let (left, right) = unzip(z1.iter().map(|&x| x));\n+        let (left, right): (Vec<_>, Vec<_>) = z1.iter().map(|&x| x).unzip();\n \n         assert_eq!((1, 4), (left[0], right[0]));\n         assert_eq!((2, 5), (left[1], right[1]));\n@@ -2147,13 +2044,13 @@ mod tests {\n             // Test on-stack copy-from-buf.\n             let a = [1i, 2, 3];\n             let ptr = a.as_ptr();\n-            let b = raw::from_buf(ptr, 3u);\n+            let b = Vec::from_raw_buf(ptr, 3u);\n             assert_eq!(b, vec![1, 2, 3]);\n \n             // Test on-heap copy-from-buf.\n             let c = vec![1i, 2, 3, 4, 5];\n             let ptr = c.as_ptr();\n-            let d = raw::from_buf(ptr, 5u);\n+            let d = Vec::from_raw_buf(ptr, 5u);\n             assert_eq!(d, vec![1, 2, 3, 4, 5]);\n         }\n     }\n@@ -2254,7 +2151,7 @@ mod tests {\n         vec.push(1);\n         vec.push(2);\n         let ptr = vec.as_ptr();\n-        vec = vec.into_iter().unwrap();\n+        vec = vec.into_iter().into_inner();\n         assert_eq!(vec.as_ptr(), ptr);\n         assert_eq!(vec.capacity(), 7);\n         assert_eq!(vec.len(), 0);\n@@ -2283,8 +2180,7 @@ mod tests {\n \n     #[test]\n     fn test_map_in_place_zero_drop_count() {\n-        use std::sync::atomic;\n-        use std::sync::atomic::AtomicUint;\n+        use std::sync::atomic::{AtomicUint, Ordering, ATOMIC_UINT_INIT};\n \n         #[derive(Clone, PartialEq, Show)]\n         struct Nothing;\n@@ -2294,20 +2190,20 @@ mod tests {\n         struct ZeroSized;\n         impl Drop for ZeroSized {\n             fn drop(&mut self) {\n-                DROP_COUNTER.fetch_add(1, atomic::Relaxed);\n+                DROP_COUNTER.fetch_add(1, Ordering::Relaxed);\n             }\n         }\n         const NUM_ELEMENTS: uint = 2;\n-        static DROP_COUNTER: AtomicUint = atomic::ATOMIC_UINT_INIT;\n+        static DROP_COUNTER: AtomicUint = ATOMIC_UINT_INIT;\n \n-        let v = Vec::from_elem(NUM_ELEMENTS, Nothing);\n+        let v = repeat(Nothing).take(NUM_ELEMENTS).collect::<Vec<_>>();\n \n-        DROP_COUNTER.store(0, atomic::Relaxed);\n+        DROP_COUNTER.store(0, Ordering::Relaxed);\n \n         let v = v.map_in_place(|_| ZeroSized);\n-        assert_eq!(DROP_COUNTER.load(atomic::Relaxed), 0);\n+        assert_eq!(DROP_COUNTER.load(Ordering::Relaxed), 0);\n         drop(v);\n-        assert_eq!(DROP_COUNTER.load(atomic::Relaxed), NUM_ELEMENTS);\n+        assert_eq!(DROP_COUNTER.load(Ordering::Relaxed), NUM_ELEMENTS);\n     }\n \n     #[test]\n@@ -2423,7 +2319,7 @@ mod tests {\n         b.bytes = src_len as u64;\n \n         b.iter(|| {\n-            let dst = Vec::from_fn(src_len, |i| i);\n+            let dst = range(0, src_len).collect::<Vec<_>>();\n             assert_eq!(dst.len(), src_len);\n             assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n         })\n@@ -2453,7 +2349,7 @@ mod tests {\n         b.bytes = src_len as u64;\n \n         b.iter(|| {\n-            let dst: Vec<uint> = Vec::from_elem(src_len, 5);\n+            let dst: Vec<uint> = repeat(5).take(src_len).collect();\n             assert_eq!(dst.len(), src_len);\n             assert!(dst.iter().all(|x| *x == 5));\n         })"}, {"sha": "ab6c6b7ca55bf55397f287d94d4b8faebe98f079", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -343,12 +343,6 @@ impl<V> VecMap<V> {\n     #[stable]\n     pub fn clear(&mut self) { self.v.clear() }\n \n-    /// Deprecated: Renamed to `get`.\n-    #[deprecated = \"Renamed to `get`\"]\n-    pub fn find(&self, key: &uint) -> Option<&V> {\n-        self.get(key)\n-    }\n-\n     /// Returns a reference to the value corresponding to the key.\n     ///\n     /// # Examples\n@@ -391,12 +385,6 @@ impl<V> VecMap<V> {\n         self.get(key).is_some()\n     }\n \n-    /// Deprecated: Renamed to `get_mut`.\n-    #[deprecated = \"Renamed to `get_mut`\"]\n-    pub fn find_mut(&mut self, key: &uint) -> Option<&mut V> {\n-        self.get_mut(key)\n-    }\n-\n     /// Returns a mutable reference to the value corresponding to the key.\n     ///\n     /// # Examples\n@@ -424,12 +412,6 @@ impl<V> VecMap<V> {\n         }\n     }\n \n-    /// Deprecated: Renamed to `insert`.\n-    #[deprecated = \"Renamed to `insert`\"]\n-    pub fn swap(&mut self, key: uint, value: V) -> Option<V> {\n-        self.insert(key, value)\n-    }\n-\n     /// Inserts a key-value pair from the map. If the key already had a value\n     /// present in the map, that value is returned. Otherwise, `None` is returned.\n     ///\n@@ -455,12 +437,6 @@ impl<V> VecMap<V> {\n         replace(&mut self.v[key], Some(value))\n     }\n \n-    /// Deprecated: Renamed to `remove`.\n-    #[deprecated = \"Renamed to `remove`\"]\n-    pub fn pop(&mut self, key: &uint) -> Option<V> {\n-        self.remove(key)\n-    }\n-\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     ///\n@@ -483,27 +459,6 @@ impl<V> VecMap<V> {\n     }\n }\n \n-impl<V:Clone> VecMap<V> {\n-    /// Deprecated: Use the entry API when available; shouldn't matter anyway, access is cheap.\n-    #[deprecated = \"Use the entry API when available; shouldn't matter anyway, access is cheap\"]\n-    #[allow(deprecated)]\n-    pub fn update<F>(&mut self, key: uint, newval: V, ff: F) -> bool where F: FnOnce(V, V) -> V {\n-        self.update_with_key(key, newval, move |_k, v, v1| ff(v,v1))\n-    }\n-\n-    /// Deprecated: Use the entry API when available; shouldn't matter anyway, access is cheap.\n-    #[deprecated = \"Use the entry API when available; shouldn't matter anyway, access is cheap\"]\n-    pub fn update_with_key<F>(&mut self, key: uint, val: V, ff: F) -> bool where\n-        F: FnOnce(uint, V, V) -> V\n-    {\n-        let new_val = match self.get(&key) {\n-            None => val,\n-            Some(orig) => ff(key, (*orig).clone(), val)\n-        };\n-        self.insert(key, new_val).is_none()\n-    }\n-}\n-\n #[stable]\n impl<V: PartialEq> PartialEq for VecMap<V> {\n     fn eq(&self, other: &VecMap<V>) -> bool {\n@@ -824,36 +779,6 @@ mod test_map {\n         assert!(map.get(&14).is_none());\n     }\n \n-    #[test]\n-    fn test_insert_with_key() {\n-        let mut map = VecMap::new();\n-\n-        // given a new key, initialize it with this new count,\n-        // given an existing key, add more to its count\n-        fn add_more_to_count(_k: uint, v0: uint, v1: uint) -> uint {\n-            v0 + v1\n-        }\n-\n-        fn add_more_to_count_simple(v0: uint, v1: uint) -> uint {\n-            v0 + v1\n-        }\n-\n-        // count integers\n-        map.update(3, 1, add_more_to_count_simple);\n-        map.update_with_key(9, 1, add_more_to_count);\n-        map.update(3, 7, add_more_to_count_simple);\n-        map.update_with_key(5, 3, add_more_to_count);\n-        map.update_with_key(3, 2, add_more_to_count);\n-\n-        // check the total counts\n-        assert_eq!(map.get(&3).unwrap(), &10);\n-        assert_eq!(map.get(&5).unwrap(), &3);\n-        assert_eq!(map.get(&9).unwrap(), &1);\n-\n-        // sadly, no sevens were counted\n-        assert!(map.get(&7).is_none());\n-    }\n-\n     #[test]\n     fn test_insert() {\n         let mut m = VecMap::new();"}, {"sha": "0ac0dc396cc1a304c566ca8fe41bb56c3696649c", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 118, "deletions": 60, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,7 +8,65 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Core atomic primitives\n+//! Atomic types\n+//!\n+//! Atomic types provide primitive shared-memory communication between\n+//! threads, and are the building blocks of other concurrent\n+//! types.\n+//!\n+//! This module defines atomic versions of a select number of primitive\n+//! types, including `AtomicBool`, `AtomicInt`, `AtomicUint`, and `AtomicOption`.\n+//! Atomic types present operations that, when used correctly, synchronize\n+//! updates between threads.\n+//!\n+//! Each method takes an `Ordering` which represents the strength of\n+//! the memory barrier for that operation. These orderings are the\n+//! same as [C++11 atomic orderings][1].\n+//!\n+//! [1]: http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync\n+//!\n+//! Atomic variables are safe to share between threads (they implement `Sync`)\n+//! but they do not themselves provide the mechanism for sharing. The most\n+//! common way to share an atomic variable is to put it into an `Arc` (an\n+//! atomically-reference-counted shared pointer).\n+//!\n+//! Most atomic types may be stored in static variables, initialized using\n+//! the provided static initializers like `INIT_ATOMIC_BOOL`. Atomic statics\n+//! are often used for lazy global initialization.\n+//!\n+//!\n+//! # Examples\n+//!\n+//! A simple spinlock:\n+//!\n+//! ```\n+//! use std::sync::Arc;\n+//! use std::sync::atomic::{AtomicUint, Ordering};\n+//! use std::thread::Thread;\n+//!\n+//! fn main() {\n+//!     let spinlock = Arc::new(AtomicUint::new(1));\n+//!\n+//!     let spinlock_clone = spinlock.clone();\n+//!     Thread::spawn(move|| {\n+//!         spinlock_clone.store(0, Ordering::SeqCst);\n+//!     }).detach();\n+//!\n+//!     // Wait for the other task to release the lock\n+//!     while spinlock.load(Ordering::SeqCst) != 0 {}\n+//! }\n+//! ```\n+//!\n+//! Keep a global count of live tasks:\n+//!\n+//! ```\n+//! use std::sync::atomic::{AtomicUint, Ordering, ATOMIC_UINT_INIT};\n+//!\n+//! static GLOBAL_TASK_COUNT: AtomicUint = ATOMIC_UINT_INIT;\n+//!\n+//! let old_task_count = GLOBAL_TASK_COUNT.fetch_add(1, Ordering::SeqCst);\n+//! println!(\"live tasks: {}\", old_task_count + 1);\n+//! ```\n \n #![stable]\n \n@@ -235,19 +293,19 @@ impl AtomicBool {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicBool, SeqCst};\n+    /// use std::sync::atomic::{AtomicBool, Ordering};\n     ///\n     /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_and(false, SeqCst));\n-    /// assert_eq!(false, foo.load(SeqCst));\n+    /// assert_eq!(true, foo.fetch_and(false, Ordering::SeqCst));\n+    /// assert_eq!(false, foo.load(Ordering::SeqCst));\n     ///\n     /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_and(true, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n+    /// assert_eq!(true, foo.fetch_and(true, Ordering::SeqCst));\n+    /// assert_eq!(true, foo.load(Ordering::SeqCst));\n     ///\n     /// let foo = AtomicBool::new(false);\n-    /// assert_eq!(false, foo.fetch_and(false, SeqCst));\n-    /// assert_eq!(false, foo.load(SeqCst));\n+    /// assert_eq!(false, foo.fetch_and(false, Ordering::SeqCst));\n+    /// assert_eq!(false, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n     #[stable]\n@@ -267,20 +325,20 @@ impl AtomicBool {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicBool, SeqCst};\n+    /// use std::sync::atomic::{AtomicBool, Ordering};\n     ///\n     /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_nand(false, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n+    /// assert_eq!(true, foo.fetch_nand(false, Ordering::SeqCst));\n+    /// assert_eq!(true, foo.load(Ordering::SeqCst));\n     ///\n     /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_nand(true, SeqCst));\n-    /// assert_eq!(0, foo.load(SeqCst) as int);\n-    /// assert_eq!(false, foo.load(SeqCst));\n+    /// assert_eq!(true, foo.fetch_nand(true, Ordering::SeqCst));\n+    /// assert_eq!(0, foo.load(Ordering::SeqCst) as int);\n+    /// assert_eq!(false, foo.load(Ordering::SeqCst));\n     ///\n     /// let foo = AtomicBool::new(false);\n-    /// assert_eq!(false, foo.fetch_nand(false, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n+    /// assert_eq!(false, foo.fetch_nand(false, Ordering::SeqCst));\n+    /// assert_eq!(true, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n     #[stable]\n@@ -300,19 +358,19 @@ impl AtomicBool {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicBool, SeqCst};\n+    /// use std::sync::atomic::{AtomicBool, Ordering};\n     ///\n     /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_or(false, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n+    /// assert_eq!(true, foo.fetch_or(false, Ordering::SeqCst));\n+    /// assert_eq!(true, foo.load(Ordering::SeqCst));\n     ///\n     /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_or(true, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n+    /// assert_eq!(true, foo.fetch_or(true, Ordering::SeqCst));\n+    /// assert_eq!(true, foo.load(Ordering::SeqCst));\n     ///\n     /// let foo = AtomicBool::new(false);\n-    /// assert_eq!(false, foo.fetch_or(false, SeqCst));\n-    /// assert_eq!(false, foo.load(SeqCst));\n+    /// assert_eq!(false, foo.fetch_or(false, Ordering::SeqCst));\n+    /// assert_eq!(false, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n     #[stable]\n@@ -332,19 +390,19 @@ impl AtomicBool {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicBool, SeqCst};\n+    /// use std::sync::atomic::{AtomicBool, Ordering};\n     ///\n     /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_xor(false, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n+    /// assert_eq!(true, foo.fetch_xor(false, Ordering::SeqCst));\n+    /// assert_eq!(true, foo.load(Ordering::SeqCst));\n     ///\n     /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_xor(true, SeqCst));\n-    /// assert_eq!(false, foo.load(SeqCst));\n+    /// assert_eq!(true, foo.fetch_xor(true, Ordering::SeqCst));\n+    /// assert_eq!(false, foo.load(Ordering::SeqCst));\n     ///\n     /// let foo = AtomicBool::new(false);\n-    /// assert_eq!(false, foo.fetch_xor(false, SeqCst));\n-    /// assert_eq!(false, foo.load(SeqCst));\n+    /// assert_eq!(false, foo.fetch_xor(false, Ordering::SeqCst));\n+    /// assert_eq!(false, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n     #[stable]\n@@ -463,11 +521,11 @@ impl AtomicInt {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicInt, SeqCst};\n+    /// use std::sync::atomic::{AtomicInt, Ordering};\n     ///\n     /// let foo = AtomicInt::new(0);\n-    /// assert_eq!(0, foo.fetch_add(10, SeqCst));\n-    /// assert_eq!(10, foo.load(SeqCst));\n+    /// assert_eq!(0, foo.fetch_add(10, Ordering::SeqCst));\n+    /// assert_eq!(10, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n     #[stable]\n@@ -480,11 +538,11 @@ impl AtomicInt {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicInt, SeqCst};\n+    /// use std::sync::atomic::{AtomicInt, Ordering};\n     ///\n     /// let foo = AtomicInt::new(0);\n-    /// assert_eq!(0, foo.fetch_sub(10, SeqCst));\n-    /// assert_eq!(-10, foo.load(SeqCst));\n+    /// assert_eq!(0, foo.fetch_sub(10, Ordering::SeqCst));\n+    /// assert_eq!(-10, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n     #[stable]\n@@ -497,11 +555,11 @@ impl AtomicInt {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicInt, SeqCst};\n+    /// use std::sync::atomic::{AtomicInt, Ordering};\n     ///\n     /// let foo = AtomicInt::new(0b101101);\n-    /// assert_eq!(0b101101, foo.fetch_and(0b110011, SeqCst));\n-    /// assert_eq!(0b100001, foo.load(SeqCst));\n+    /// assert_eq!(0b101101, foo.fetch_and(0b110011, Ordering::SeqCst));\n+    /// assert_eq!(0b100001, foo.load(Ordering::SeqCst));\n     #[inline]\n     #[stable]\n     pub fn fetch_and(&self, val: int, order: Ordering) -> int {\n@@ -513,11 +571,11 @@ impl AtomicInt {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicInt, SeqCst};\n+    /// use std::sync::atomic::{AtomicInt, Ordering};\n     ///\n     /// let foo = AtomicInt::new(0b101101);\n-    /// assert_eq!(0b101101, foo.fetch_or(0b110011, SeqCst));\n-    /// assert_eq!(0b111111, foo.load(SeqCst));\n+    /// assert_eq!(0b101101, foo.fetch_or(0b110011, Ordering::SeqCst));\n+    /// assert_eq!(0b111111, foo.load(Ordering::SeqCst));\n     #[inline]\n     #[stable]\n     pub fn fetch_or(&self, val: int, order: Ordering) -> int {\n@@ -529,11 +587,11 @@ impl AtomicInt {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicInt, SeqCst};\n+    /// use std::sync::atomic::{AtomicInt, Ordering};\n     ///\n     /// let foo = AtomicInt::new(0b101101);\n-    /// assert_eq!(0b101101, foo.fetch_xor(0b110011, SeqCst));\n-    /// assert_eq!(0b011110, foo.load(SeqCst));\n+    /// assert_eq!(0b101101, foo.fetch_xor(0b110011, Ordering::SeqCst));\n+    /// assert_eq!(0b011110, foo.load(Ordering::SeqCst));\n     #[inline]\n     #[stable]\n     pub fn fetch_xor(&self, val: int, order: Ordering) -> int {\n@@ -649,11 +707,11 @@ impl AtomicUint {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicUint, SeqCst};\n+    /// use std::sync::atomic::{AtomicUint, Ordering};\n     ///\n     /// let foo = AtomicUint::new(0);\n-    /// assert_eq!(0, foo.fetch_add(10, SeqCst));\n-    /// assert_eq!(10, foo.load(SeqCst));\n+    /// assert_eq!(0, foo.fetch_add(10, Ordering::SeqCst));\n+    /// assert_eq!(10, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n     #[stable]\n@@ -666,11 +724,11 @@ impl AtomicUint {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicUint, SeqCst};\n+    /// use std::sync::atomic::{AtomicUint, Ordering};\n     ///\n     /// let foo = AtomicUint::new(10);\n-    /// assert_eq!(10, foo.fetch_sub(10, SeqCst));\n-    /// assert_eq!(0, foo.load(SeqCst));\n+    /// assert_eq!(10, foo.fetch_sub(10, Ordering::SeqCst));\n+    /// assert_eq!(0, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n     #[stable]\n@@ -683,11 +741,11 @@ impl AtomicUint {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicUint, SeqCst};\n+    /// use std::sync::atomic::{AtomicUint, Ordering};\n     ///\n     /// let foo = AtomicUint::new(0b101101);\n-    /// assert_eq!(0b101101, foo.fetch_and(0b110011, SeqCst));\n-    /// assert_eq!(0b100001, foo.load(SeqCst));\n+    /// assert_eq!(0b101101, foo.fetch_and(0b110011, Ordering::SeqCst));\n+    /// assert_eq!(0b100001, foo.load(Ordering::SeqCst));\n     #[inline]\n     #[stable]\n     pub fn fetch_and(&self, val: uint, order: Ordering) -> uint {\n@@ -699,11 +757,11 @@ impl AtomicUint {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicUint, SeqCst};\n+    /// use std::sync::atomic::{AtomicUint, Ordering};\n     ///\n     /// let foo = AtomicUint::new(0b101101);\n-    /// assert_eq!(0b101101, foo.fetch_or(0b110011, SeqCst));\n-    /// assert_eq!(0b111111, foo.load(SeqCst));\n+    /// assert_eq!(0b101101, foo.fetch_or(0b110011, Ordering::SeqCst));\n+    /// assert_eq!(0b111111, foo.load(Ordering::SeqCst));\n     #[inline]\n     #[stable]\n     pub fn fetch_or(&self, val: uint, order: Ordering) -> uint {\n@@ -715,11 +773,11 @@ impl AtomicUint {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::sync::atomic::{AtomicUint, SeqCst};\n+    /// use std::sync::atomic::{AtomicUint, Ordering};\n     ///\n     /// let foo = AtomicUint::new(0b101101);\n-    /// assert_eq!(0b101101, foo.fetch_xor(0b110011, SeqCst));\n-    /// assert_eq!(0b011110, foo.load(SeqCst));\n+    /// assert_eq!(0b101101, foo.fetch_xor(0b110011, Ordering::SeqCst));\n+    /// assert_eq!(0b011110, foo.load(Ordering::SeqCst));\n     #[inline]\n     #[stable]\n     pub fn fetch_xor(&self, val: uint, order: Ordering) -> uint {"}, {"sha": "eb772388dce220834d000638830ab1986f8a27d5", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -267,10 +267,6 @@ impl<T> RefCell<T> {\n         unsafe { self.value.into_inner() }\n     }\n \n-    /// Deprecated, use into_inner() instead\n-    #[deprecated = \"renamed to into_inner()\"]\n-    pub fn unwrap(self) -> T { self.into_inner() }\n-\n     /// Attempts to immutably borrow the wrapped value.\n     ///\n     /// The borrow lasts until the returned `Ref` exits scope. Multiple\n@@ -569,8 +565,4 @@ impl<T> UnsafeCell<T> {\n     #[inline]\n     #[stable]\n     pub unsafe fn into_inner(self) -> T { self.value }\n-\n-    /// Deprecated, use into_inner() instead\n-    #[deprecated = \"renamed to into_inner()\"]\n-    pub unsafe fn unwrap(self) -> T { self.into_inner() }\n }"}, {"sha": "3423e76ea640832f3c1afc553b7456b0ab0d2987", "filename": "src/libcore/char.rs", "status": "modified", "additions": 0, "deletions": 121, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -17,7 +17,6 @@\n \n use iter::Iterator;\n use mem::transmute;\n-use ops::FnMut;\n use option::Option::{None, Some};\n use option::Option;\n use slice::SliceExt;\n@@ -80,51 +79,6 @@ pub fn from_u32(i: u32) -> Option<char> {\n     }\n }\n \n-///\n-/// Checks if a `char` parses as a numeric digit in the given radix\n-///\n-/// Compared to `is_numeric()`, this function only recognizes the\n-/// characters `0-9`, `a-z` and `A-Z`.\n-///\n-/// # Return value\n-///\n-/// Returns `true` if `c` is a valid digit under `radix`, and `false`\n-/// otherwise.\n-///\n-/// # Panics\n-///\n-/// Panics if given a `radix` > 36.\n-///\n-/// # Note\n-///\n-/// This just wraps `to_digit()`.\n-///\n-#[inline]\n-#[deprecated = \"use the Char::is_digit method\"]\n-pub fn is_digit_radix(c: char, radix: uint) -> bool {\n-    c.is_digit(radix)\n-}\n-\n-///\n-/// Converts a `char` to the corresponding digit\n-///\n-/// # Return value\n-///\n-/// If `c` is between '0' and '9', the corresponding value\n-/// between 0 and 9. If `c` is 'a' or 'A', 10. If `c` is\n-/// 'b' or 'B', 11, etc. Returns none if the `char` does not\n-/// refer to a digit in the given radix.\n-///\n-/// # Panics\n-///\n-/// Panics if given a `radix` outside the range `[0..36]`.\n-///\n-#[inline]\n-#[deprecated = \"use the Char::to_digit method\"]\n-pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n-    c.to_digit(radix)\n-}\n-\n ///\n /// Converts a number to the character representing it\n ///\n@@ -156,48 +110,9 @@ pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     }\n }\n \n-/// Deprecated, call the escape_unicode method instead.\n-#[deprecated = \"use the Char::escape_unicode method\"]\n-pub fn escape_unicode<F>(c: char, mut f: F) where F: FnMut(char) {\n-    for char in c.escape_unicode() {\n-        f(char);\n-    }\n-}\n-\n-/// Deprecated, call the escape_default method instead.\n-#[deprecated = \"use the Char::escape_default method\"]\n-pub fn escape_default<F>(c: char, mut f: F) where F: FnMut(char) {\n-    for c in c.escape_default() {\n-        f(c);\n-    }\n-}\n-\n-/// Returns the amount of bytes this `char` would need if encoded in UTF-8\n-#[inline]\n-#[deprecated = \"use the Char::len_utf8 method\"]\n-pub fn len_utf8_bytes(c: char) -> uint {\n-    c.len_utf8()\n-}\n-\n /// Basic `char` manipulations.\n #[experimental = \"trait organization may change\"]\n pub trait Char {\n-    /// Checks if a `char` parses as a numeric digit in the given radix.\n-    ///\n-    /// Compared to `is_numeric()`, this function only recognizes the characters\n-    /// `0-9`, `a-z` and `A-Z`.\n-    ///\n-    /// # Return value\n-    ///\n-    /// Returns `true` if `c` is a valid digit under `radix`, and `false`\n-    /// otherwise.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if given a radix > 36.\n-    #[deprecated = \"use is_digit\"]\n-    fn is_digit_radix(self, radix: uint) -> bool;\n-\n     /// Checks if a `char` parses as a numeric digit in the given radix.\n     ///\n     /// Compared to `is_numeric()`, this function only recognizes the characters\n@@ -228,23 +143,6 @@ pub trait Char {\n     #[unstable = \"pending error conventions, trait organization\"]\n     fn to_digit(self, radix: uint) -> Option<uint>;\n \n-    /// Converts a number to the character representing it.\n-    ///\n-    /// # Return value\n-    ///\n-    /// Returns `Some(char)` if `num` represents one digit under `radix`,\n-    /// using one character of `0-9` or `a-z`, or `None` if it doesn't.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if given a radix > 36.\n-    #[deprecated = \"use the char::from_digit free function\"]\n-    fn from_digit(num: uint, radix: uint) -> Option<Self>;\n-\n-    /// Converts from `u32` to a `char`\n-    #[deprecated = \"use the char::from_u32 free function\"]\n-    fn from_u32(i: u32) -> Option<char>;\n-\n     /// Returns an iterator that yields the hexadecimal Unicode escape\n     /// of a character, as `char`s.\n     ///\n@@ -269,11 +167,6 @@ pub trait Char {\n     #[unstable = \"pending error conventions, trait organization\"]\n     fn escape_default(self) -> EscapeDefault;\n \n-    /// Returns the amount of bytes this character would need if encoded in\n-    /// UTF-8.\n-    #[deprecated = \"use len_utf8\"]\n-    fn len_utf8_bytes(self) -> uint;\n-\n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-8.\n     #[unstable = \"pending trait organization\"]\n@@ -303,9 +196,6 @@ pub trait Char {\n \n #[experimental = \"trait is experimental\"]\n impl Char for char {\n-    #[deprecated = \"use is_digit\"]\n-    fn is_digit_radix(self, radix: uint) -> bool { self.is_digit(radix) }\n-\n     #[unstable = \"pending trait organization\"]\n     fn is_digit(self, radix: uint) -> bool {\n         match self.to_digit(radix) {\n@@ -329,13 +219,6 @@ impl Char for char {\n         else { None }\n     }\n \n-    #[deprecated = \"use the char::from_digit free function\"]\n-    fn from_digit(num: uint, radix: uint) -> Option<char> { from_digit(num, radix) }\n-\n-    #[inline]\n-    #[deprecated = \"use the char::from_u32 free function\"]\n-    fn from_u32(i: u32) -> Option<char> { from_u32(i) }\n-\n     #[unstable = \"pending error conventions, trait organization\"]\n     fn escape_unicode(self) -> EscapeUnicode {\n         EscapeUnicode { c: self, state: EscapeUnicodeState::Backslash }\n@@ -356,10 +239,6 @@ impl Char for char {\n         EscapeDefault { state: init_state }\n     }\n \n-    #[inline]\n-    #[deprecated = \"use len_utf8\"]\n-    fn len_utf8_bytes(self) -> uint { self.len_utf8() }\n-\n     #[inline]\n     #[unstable = \"pending trait organization\"]\n     fn len_utf8(self) -> uint {"}, {"sha": "13f9f5ccee9161b180ca4904abeb2af2c92b02bf", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -271,16 +271,6 @@ pub trait PartialOrd<Sized? Rhs = Self> for Sized?: PartialEq<Rhs> {\n     }\n }\n \n-/// The equivalence relation. Two values may be equivalent even if they are\n-/// of different types. The most common use case for this relation is\n-/// container types; e.g. it is often desirable to be able to use `&str`\n-/// values to look up entries in a container with `String` keys.\n-#[deprecated = \"Use overloaded core::cmp::PartialEq\"]\n-pub trait Equiv<Sized? T> for Sized? {\n-    /// Implement this function to decide equivalent values.\n-    fn equiv(&self, other: &T) -> bool;\n-}\n-\n /// Compare and return the minimum of two values.\n #[inline]\n #[stable]"}, {"sha": "62bfa381c445eabb1fe031794b72e7c0392888fd", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -68,8 +68,6 @@ use option::Option::{Some, None};\n use std::kinds::Sized;\n use uint;\n \n-#[deprecated = \"renamed to Extend\"] pub use self::Extend as Extendable;\n-\n /// An interface for dealing with \"external iterators\". These types of iterators\n /// can be resumed at any time as all state is stored internally as opposed to\n /// being located on the call stack.\n@@ -2781,15 +2779,6 @@ pub struct Repeat<A> {\n     element: A\n }\n \n-impl<A: Clone> Repeat<A> {\n-    /// Create a new `Repeat` that endlessly repeats the element `elt`.\n-    #[inline]\n-    #[deprecated = \"use iter::repeat instead\"]\n-    pub fn new(elt: A) -> Repeat<A> {\n-        Repeat{element: elt}\n-    }\n-}\n-\n #[unstable = \"trait is unstable\"]\n impl<A: Clone> Iterator for Repeat<A> {\n     type Item = A;"}, {"sha": "aab28ae9c4738f8720340bd4e648c09875cf3a08", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -20,7 +20,6 @@ use intrinsics;\n use mem;\n use num::Float;\n use num::FpCategory as Fp;\n-use num::from_str_radix;\n use option::Option;\n \n #[stable]\n@@ -314,14 +313,6 @@ impl Float for f32 {\n         unsafe { intrinsics::powf32(self, n) }\n     }\n \n-    /// sqrt(2.0)\n-    #[inline]\n-    fn sqrt2() -> f32 { consts::SQRT2 }\n-\n-    /// 1.0 / sqrt(2.0)\n-    #[inline]\n-    fn frac_1_sqrt2() -> f32 { consts::FRAC_1_SQRT2 }\n-\n     #[inline]\n     fn sqrt(self) -> f32 {\n         if self < 0.0 {\n@@ -334,66 +325,6 @@ impl Float for f32 {\n     #[inline]\n     fn rsqrt(self) -> f32 { self.sqrt().recip() }\n \n-    /// Archimedes' constant\n-    #[inline]\n-    fn pi() -> f32 { consts::PI }\n-\n-    /// 2.0 * pi\n-    #[inline]\n-    fn two_pi() -> f32 { consts::PI_2 }\n-\n-    /// pi / 2.0\n-    #[inline]\n-    fn frac_pi_2() -> f32 { consts::FRAC_PI_2 }\n-\n-    /// pi / 3.0\n-    #[inline]\n-    fn frac_pi_3() -> f32 { consts::FRAC_PI_3 }\n-\n-    /// pi / 4.0\n-    #[inline]\n-    fn frac_pi_4() -> f32 { consts::FRAC_PI_4 }\n-\n-    /// pi / 6.0\n-    #[inline]\n-    fn frac_pi_6() -> f32 { consts::FRAC_PI_6 }\n-\n-    /// pi / 8.0\n-    #[inline]\n-    fn frac_pi_8() -> f32 { consts::FRAC_PI_8 }\n-\n-    /// 1.0 / pi\n-    #[inline]\n-    fn frac_1_pi() -> f32 { consts::FRAC_1_PI }\n-\n-    /// 2.0 / pi\n-    #[inline]\n-    fn frac_2_pi() -> f32 { consts::FRAC_2_PI }\n-\n-    /// 2.0 / sqrt(pi)\n-    #[inline]\n-    fn frac_2_sqrtpi() -> f32 { consts::FRAC_2_SQRTPI }\n-\n-    /// Euler's number\n-    #[inline]\n-    fn e() -> f32 { consts::E }\n-\n-    /// log2(e)\n-    #[inline]\n-    fn log2_e() -> f32 { consts::LOG2_E }\n-\n-    /// log10(e)\n-    #[inline]\n-    fn log10_e() -> f32 { consts::LOG10_E }\n-\n-    /// ln(2.0)\n-    #[inline]\n-    fn ln_2() -> f32 { consts::LN_2 }\n-\n-    /// ln(10.0)\n-    #[inline]\n-    fn ln_10() -> f32 { consts::LN_10 }\n-\n     /// Returns the exponential of the number.\n     #[inline]\n     fn exp(self) -> f32 {\n@@ -439,10 +370,3 @@ impl Float for f32 {\n         self * (value / 180.0f32)\n     }\n }\n-\n-#[inline]\n-#[allow(missing_docs)]\n-#[deprecated=\"Use `FromStrRadix::from_str_radix(src, 16)`\"]\n-pub fn from_str_hex(src: &str) -> Option<f32> {\n-    from_str_radix(src, 16)\n-}"}, {"sha": "d6d9c3446e98bbf8ffa8e602058fe9d7da9e7043", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -20,7 +20,6 @@ use intrinsics;\n use mem;\n use num::Float;\n use num::FpCategory as Fp;\n-use num::from_str_radix;\n use option::Option;\n \n // FIXME(#5527): These constants should be deprecated once associated\n@@ -322,14 +321,6 @@ impl Float for f64 {\n         unsafe { intrinsics::powif64(self, n) }\n     }\n \n-    /// sqrt(2.0)\n-    #[inline]\n-    fn sqrt2() -> f64 { consts::SQRT2 }\n-\n-    /// 1.0 / sqrt(2.0)\n-    #[inline]\n-    fn frac_1_sqrt2() -> f64 { consts::FRAC_1_SQRT2 }\n-\n     #[inline]\n     fn sqrt(self) -> f64 {\n         if self < 0.0 {\n@@ -342,66 +333,6 @@ impl Float for f64 {\n     #[inline]\n     fn rsqrt(self) -> f64 { self.sqrt().recip() }\n \n-    /// Archimedes' constant\n-    #[inline]\n-    fn pi() -> f64 { consts::PI }\n-\n-    /// 2.0 * pi\n-    #[inline]\n-    fn two_pi() -> f64 { consts::PI_2 }\n-\n-    /// pi / 2.0\n-    #[inline]\n-    fn frac_pi_2() -> f64 { consts::FRAC_PI_2 }\n-\n-    /// pi / 3.0\n-    #[inline]\n-    fn frac_pi_3() -> f64 { consts::FRAC_PI_3 }\n-\n-    /// pi / 4.0\n-    #[inline]\n-    fn frac_pi_4() -> f64 { consts::FRAC_PI_4 }\n-\n-    /// pi / 6.0\n-    #[inline]\n-    fn frac_pi_6() -> f64 { consts::FRAC_PI_6 }\n-\n-    /// pi / 8.0\n-    #[inline]\n-    fn frac_pi_8() -> f64 { consts::FRAC_PI_8 }\n-\n-    /// 1.0 / pi\n-    #[inline]\n-    fn frac_1_pi() -> f64 { consts::FRAC_1_PI }\n-\n-    /// 2.0 / pi\n-    #[inline]\n-    fn frac_2_pi() -> f64 { consts::FRAC_2_PI }\n-\n-    /// 2.0 / sqrt(pi)\n-    #[inline]\n-    fn frac_2_sqrtpi() -> f64 { consts::FRAC_2_SQRTPI }\n-\n-    /// Euler's number\n-    #[inline]\n-    fn e() -> f64 { consts::E }\n-\n-    /// log2(e)\n-    #[inline]\n-    fn log2_e() -> f64 { consts::LOG2_E }\n-\n-    /// log10(e)\n-    #[inline]\n-    fn log10_e() -> f64 { consts::LOG10_E }\n-\n-    /// ln(2.0)\n-    #[inline]\n-    fn ln_2() -> f64 { consts::LN_2 }\n-\n-    /// ln(10.0)\n-    #[inline]\n-    fn ln_10() -> f64 { consts::LN_10 }\n-\n     /// Returns the exponential of the number.\n     #[inline]\n     fn exp(self) -> f64 {\n@@ -447,10 +378,3 @@ impl Float for f64 {\n         self * (value / 180.0)\n     }\n }\n-\n-#[inline]\n-#[allow(missing_docs)]\n-#[deprecated=\"Use `FromStrRadix::from_str_radix(src, 16)`\"]\n-pub fn from_str_hex(src: &str) -> Option<f64> {\n-    from_str_radix(src, 16)\n-}"}, {"sha": "6c3b153c00057ce3b9a17ca6f91d21a6f2300191", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 4, "deletions": 205, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -15,9 +15,6 @@\n #![stable]\n #![allow(missing_docs)]\n \n-use {int, i8, i16, i32, i64};\n-use {uint, u8, u16, u32, u64};\n-use {f32, f64};\n use char::Char;\n use clone::Clone;\n use cmp::{PartialEq, Eq};\n@@ -30,21 +27,7 @@ use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n use option::Option;\n use option::Option::{Some, None};\n-use str::{FromStr, from_str, StrExt};\n-\n-/// Simultaneous division and remainder\n-#[inline]\n-#[deprecated = \"use division and remainder directly\"]\n-pub fn div_rem<T: Clone + Div<Output=T> + Rem<Output=T>>(x: T, y: T) -> (T, T) {\n-    (x.clone() / y.clone(), x % y)\n-}\n-\n-/// Raises a `base` to the power of `exp`, using exponentiation by squaring.\n-#[inline]\n-#[deprecated = \"Use Int::pow() instead, as in 2i.pow(4)\"]\n-pub fn pow<T: Int>(base: T, exp: uint) -> T {\n-    base.pow(exp)\n-}\n+use str::{FromStr, StrExt};\n \n /// A built-in signed or unsigned integer.\n #[unstable = \"recently settled as part of numerics reform\"]\n@@ -1345,65 +1328,13 @@ pub trait Float\n     /// Raise a number to a floating point power.\n     fn powf(self, n: Self) -> Self;\n \n-    /// sqrt(2.0).\n-    fn sqrt2() -> Self;\n-    /// 1.0 / sqrt(2.0).\n-    fn frac_1_sqrt2() -> Self;\n-\n     /// Take the square root of a number.\n     ///\n     /// Returns NaN if `self` is a negative number.\n     fn sqrt(self) -> Self;\n     /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n     fn rsqrt(self) -> Self;\n \n-    /// Archimedes' constant.\n-    #[deprecated = \"use f32::consts or f64::consts instead\"]\n-    fn pi() -> Self;\n-    /// 2.0 * pi.\n-    #[deprecated = \"use f32::consts or f64::consts instead\"]\n-    fn two_pi() -> Self;\n-    /// pi / 2.0.\n-    #[deprecated = \"use f32::consts or f64::consts instead\"]\n-    fn frac_pi_2() -> Self;\n-    /// pi / 3.0.\n-    #[deprecated = \"use f32::consts or f64::consts instead\"]\n-    fn frac_pi_3() -> Self;\n-    /// pi / 4.0.\n-    #[deprecated = \"use f32::consts or f64::consts instead\"]\n-    fn frac_pi_4() -> Self;\n-    /// pi / 6.0.\n-    #[deprecated = \"use f32::consts or f64::consts instead\"]\n-    fn frac_pi_6() -> Self;\n-    /// pi / 8.0.\n-    #[deprecated = \"use f32::consts or f64::consts instead\"]\n-    fn frac_pi_8() -> Self;\n-    /// 1.0 / pi.\n-    #[deprecated = \"use f32::consts or f64::consts instead\"]\n-    fn frac_1_pi() -> Self;\n-    /// 2.0 / pi.\n-    #[deprecated = \"use f32::consts or f64::consts instead\"]\n-    fn frac_2_pi() -> Self;\n-    /// 2.0 / sqrt(pi).\n-    #[deprecated = \"use f32::consts or f64::consts instead\"]\n-    fn frac_2_sqrtpi() -> Self;\n-\n-    /// Euler's number.\n-    #[deprecated = \"use f32::consts or f64::consts instead\"]\n-    fn e() -> Self;\n-    /// log2(e).\n-    #[deprecated = \"use f32::consts or f64::consts instead\"]\n-    fn log2_e() -> Self;\n-    /// log10(e).\n-    #[deprecated = \"use f32::consts or f64::consts instead\"]\n-    fn log10_e() -> Self;\n-    /// ln(2.0).\n-    #[deprecated = \"use f32::consts or f64::consts instead\"]\n-    fn ln_2() -> Self;\n-    /// ln(10.0).\n-    #[deprecated = \"use f32::consts or f64::consts instead\"]\n-    fn ln_10() -> Self;\n-\n     /// Returns `e^(self)`, (the exponential function).\n     fn exp(self) -> Self;\n     /// Returns 2 raised to the power of the number, `2^(self)`.\n@@ -1609,9 +1540,9 @@ macro_rules! from_str_radix_float_impl {\n                         // Parse the exponent as decimal integer\n                         let src = src[offset..];\n                         let (is_positive, exp) = match src.slice_shift_char() {\n-                            Some(('-', src)) => (false, from_str::<uint>(src)),\n-                            Some(('+', src)) => (true,  from_str::<uint>(src)),\n-                            Some((_, _))     => (true,  from_str::<uint>(src)),\n+                            Some(('-', src)) => (false, src.parse::<uint>()),\n+                            Some(('+', src)) => (true,  src.parse::<uint>()),\n+                            Some((_, _))     => (true,  src.parse::<uint>()),\n                             None             => return None,\n                         };\n \n@@ -1706,135 +1637,3 @@ from_str_radix_int_impl! { u8 }\n from_str_radix_int_impl! { u16 }\n from_str_radix_int_impl! { u32 }\n from_str_radix_int_impl! { u64 }\n-\n-// DEPRECATED\n-\n-macro_rules! trait_impl {\n-    ($name:ident for $($t:ty)*) => {\n-        $(#[allow(deprecated)] impl $name for $t {})*\n-    };\n-}\n-\n-#[deprecated = \"Generalised numbers are no longer supported\"]\n-#[allow(deprecated)]\n-pub trait Num: PartialEq + Zero + One\n-             + Neg<Output=Self>\n-             + Add<Output=Self>\n-             + Sub<Output=Self>\n-             + Mul<Output=Self>\n-             + Div<Output=Self>\n-             + Rem<Output=Self> {}\n-trait_impl! { Num for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n-\n-#[deprecated = \"Generalised unsigned numbers are no longer supported\"]\n-#[allow(deprecated)]\n-pub trait Unsigned: Num {}\n-trait_impl! { Unsigned for uint u8 u16 u32 u64 }\n-\n-#[deprecated = \"Use `Float` or `Int`\"]\n-#[allow(deprecated)]\n-pub trait Primitive: Copy + Clone + Num + NumCast + PartialOrd {}\n-trait_impl! { Primitive for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n-\n-#[deprecated = \"The generic `Zero` trait will be removed soon.\"]\n-pub trait Zero: Add<Output=Self> {\n-    #[deprecated = \"Use `Int::zero()` or `Float::zero()`.\"]\n-    fn zero() -> Self;\n-    #[deprecated = \"Use `x == Int::zero()` or `x == Float::zero()`.\"]\n-    fn is_zero(&self) -> bool;\n-}\n-#[deprecated = \"Use `Int::zero()` or `Float::zero()`.\"]\n-#[allow(deprecated)]\n-pub fn zero<T: Zero>() -> T { Zero::zero() }\n-macro_rules! zero_impl {\n-    ($t:ty, $v:expr) => {\n-        impl Zero for $t {\n-            fn zero() -> $t { $v }\n-            fn is_zero(&self) -> bool { *self == $v }\n-        }\n-    }\n-}\n-zero_impl! { uint, 0u }\n-zero_impl! { u8,   0u8 }\n-zero_impl! { u16,  0u16 }\n-zero_impl! { u32,  0u32 }\n-zero_impl! { u64,  0u64 }\n-zero_impl! { int, 0i }\n-zero_impl! { i8,  0i8 }\n-zero_impl! { i16, 0i16 }\n-zero_impl! { i32, 0i32 }\n-zero_impl! { i64, 0i64 }\n-zero_impl! { f32, 0.0f32 }\n-zero_impl! { f64, 0.0f64 }\n-\n-#[deprecated = \"The generic `One` trait will be removed soon.\"]\n-pub trait One: Mul<Output=Self> {\n-    #[deprecated = \"Use `Int::one()` or `Float::one()`.\"]\n-    fn one() -> Self;\n-}\n-#[deprecated = \"Use `Int::one()` or `Float::one()`.\"]\n-#[allow(deprecated)]\n-pub fn one<T: One>() -> T { One::one() }\n-macro_rules! one_impl {\n-    ($t:ty, $v:expr) => {\n-        impl One for $t {\n-            fn one() -> $t { $v }\n-        }\n-    }\n-}\n-one_impl! { uint, 1u }\n-one_impl! { u8,  1u8 }\n-one_impl! { u16, 1u16 }\n-one_impl! { u32, 1u32 }\n-one_impl! { u64, 1u64 }\n-one_impl! { int, 1i }\n-one_impl! { i8,  1i8 }\n-one_impl! { i16, 1i16 }\n-one_impl! { i32, 1i32 }\n-one_impl! { i64, 1i64 }\n-one_impl! { f32, 1.0f32 }\n-one_impl! { f64, 1.0f64 }\n-\n-#[deprecated = \"Use `UnsignedInt::next_power_of_two`\"]\n-pub fn next_power_of_two<T: UnsignedInt>(n: T) -> T {\n-    n.next_power_of_two()\n-}\n-#[deprecated = \"Use `UnsignedInt::is_power_of_two`\"]\n-pub fn is_power_of_two<T: UnsignedInt>(n: T) -> bool {\n-    n.is_power_of_two()\n-}\n-#[deprecated = \"Use `UnsignedInt::checked_next_power_of_two`\"]\n-pub fn checked_next_power_of_two<T: UnsignedInt>(n: T) -> Option<T> {\n-    n.checked_next_power_of_two()\n-}\n-\n-#[deprecated = \"Generalised bounded values are no longer supported\"]\n-pub trait Bounded {\n-    #[deprecated = \"Use `Int::min_value` or `Float::min_value`\"]\n-    fn min_value() -> Self;\n-    #[deprecated = \"Use `Int::max_value` or `Float::max_value`\"]\n-    fn max_value() -> Self;\n-}\n-macro_rules! bounded_impl {\n-    ($T:ty, $min:expr, $max:expr) => {\n-        impl Bounded for $T {\n-            #[inline]\n-            fn min_value() -> $T { $min }\n-\n-            #[inline]\n-            fn max_value() -> $T { $max }\n-        }\n-    };\n-}\n-bounded_impl! { uint, uint::MIN, uint::MAX }\n-bounded_impl! { u8, u8::MIN, u8::MAX }\n-bounded_impl! { u16, u16::MIN, u16::MAX }\n-bounded_impl! { u32, u32::MIN, u32::MAX }\n-bounded_impl! { u64, u64::MIN, u64::MAX }\n-bounded_impl! { int, int::MIN, int::MAX }\n-bounded_impl! { i8, i8::MIN, i8::MAX }\n-bounded_impl! { i16, i16::MIN, i16::MAX }\n-bounded_impl! { i32, i32::MIN, i32::MAX }\n-bounded_impl! { i64, i64::MIN, i64::MAX }\n-bounded_impl! { f32, f32::MIN_VALUE, f32::MAX_VALUE }\n-bounded_impl! { f64, f64::MIN_VALUE, f64::MAX_VALUE }"}, {"sha": "0b77f3456b2f5afad528d7092fc1c75eecd9aa10", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 46, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -94,7 +94,7 @@ use intrinsics;\n use option::Option::{self, Some, None};\n use kinds::{Send, Sized, Sync};\n \n-use cmp::{PartialEq, Eq, Ord, PartialOrd, Equiv};\n+use cmp::{PartialEq, Eq, Ord, PartialOrd};\n use cmp::Ordering::{self, Less, Equal, Greater};\n \n // FIXME #19649: instrinsic docs don't render, so these have no docs :(\n@@ -246,22 +246,10 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n pub trait PtrExt: Sized {\n     type Target;\n \n-    /// Returns the null pointer.\n-    #[deprecated = \"call ptr::null instead\"]\n-    fn null() -> Self;\n-\n     /// Returns true if the pointer is null.\n     #[stable]\n     fn is_null(self) -> bool;\n \n-    /// Returns true if the pointer is not equal to the null pointer.\n-    #[deprecated = \"use !p.is_null() instead\"]\n-    fn is_not_null(self) -> bool { !self.is_null() }\n-\n-    /// Returns true if the pointer is not null.\n-    #[deprecated = \"use `as uint` instead\"]\n-    fn to_uint(self) -> uint;\n-\n     /// Returns `None` if the pointer is null, or else returns a reference to\n     /// the value wrapped in `Some`.\n     ///\n@@ -308,18 +296,10 @@ pub trait MutPtrExt {\n impl<T> PtrExt for *const T {\n     type Target = T;\n \n-    #[inline]\n-    #[deprecated = \"call ptr::null instead\"]\n-    fn null() -> *const T { null() }\n-\n     #[inline]\n     #[stable]\n     fn is_null(self) -> bool { self as uint == 0 }\n \n-    #[inline]\n-    #[deprecated = \"use `as uint` instead\"]\n-    fn to_uint(self) -> uint { self as uint }\n-\n     #[inline]\n     #[stable]\n     unsafe fn offset(self, count: int) -> *const T {\n@@ -342,18 +322,10 @@ impl<T> PtrExt for *const T {\n impl<T> PtrExt for *mut T {\n     type Target = T;\n \n-    #[inline]\n-    #[deprecated = \"call ptr::null instead\"]\n-    fn null() -> *mut T { null_mut() }\n-\n     #[inline]\n     #[stable]\n     fn is_null(self) -> bool { self as uint == 0 }\n \n-    #[inline]\n-    #[deprecated = \"use `as uint` instead\"]\n-    fn to_uint(self) -> uint { self as uint }\n-\n     #[inline]\n     #[stable]\n     unsafe fn offset(self, count: int) -> *mut T {\n@@ -415,23 +387,6 @@ impl<T> PartialEq for *mut T {\n #[stable]\n impl<T> Eq for *mut T {}\n \n-// Equivalence for pointers\n-#[allow(deprecated)]\n-#[deprecated = \"Use overloaded `core::cmp::PartialEq`\"]\n-impl<T> Equiv<*mut T> for *const T {\n-    fn equiv(&self, other: &*mut T) -> bool {\n-        self.to_uint() == other.to_uint()\n-    }\n-}\n-\n-#[allow(deprecated)]\n-#[deprecated = \"Use overloaded `core::cmp::PartialEq`\"]\n-impl<T> Equiv<*const T> for *mut T {\n-    fn equiv(&self, other: &*const T) -> bool {\n-        self.to_uint() == other.to_uint()\n-    }\n-}\n-\n #[stable]\n impl<T> Clone for *const T {\n     #[inline]"}, {"sha": "f17a775cf42407e2981e45b440793cf783c5a33c", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 1, "deletions": 77, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -36,7 +36,7 @@\n \n use mem::transmute;\n use clone::Clone;\n-use cmp::{Ordering, PartialEq, PartialOrd, Eq, Ord, Equiv};\n+use cmp::{Ordering, PartialEq, PartialOrd, Eq, Ord};\n use cmp::Ordering::{Less, Equal, Greater};\n use cmp;\n use default::Default;\n@@ -1369,68 +1369,6 @@ pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: uint) -> &'a mut [T] {\n // Submodules\n //\n \n-/// Unsafe operations\n-#[deprecated]\n-pub mod raw {\n-    use mem::transmute;\n-    use ptr::PtrExt;\n-    use raw::Slice;\n-    use ops::FnOnce;\n-    use option::Option;\n-    use option::Option::{None, Some};\n-\n-    /// Form a slice from a pointer and length (as a number of units,\n-    /// not bytes).\n-    #[inline]\n-    #[deprecated = \"renamed to slice::from_raw_buf\"]\n-    pub unsafe fn buf_as_slice<T, U, F>(p: *const T, len: uint, f: F) -> U where\n-        F: FnOnce(&[T]) -> U,\n-    {\n-        f(transmute(Slice {\n-            data: p,\n-            len: len\n-        }))\n-    }\n-\n-    /// Form a slice from a pointer and length (as a number of units,\n-    /// not bytes).\n-    #[inline]\n-    #[deprecated = \"renamed to slice::from_raw_mut_buf\"]\n-    pub unsafe fn mut_buf_as_slice<T, U, F>(p: *mut T, len: uint, f: F) -> U where\n-        F: FnOnce(&mut [T]) -> U,\n-    {\n-        f(transmute(Slice {\n-            data: p as *const T,\n-            len: len\n-        }))\n-    }\n-\n-    /// Returns a pointer to first element in slice and adjusts\n-    /// slice so it no longer contains that element. Returns None\n-    /// if the slice is empty. O(1).\n-    #[inline]\n-    #[deprecated = \"inspect `Slice::{data, len}` manually (increment data by 1)\"]\n-    pub unsafe fn shift_ptr<T>(slice: &mut Slice<T>) -> Option<*const T> {\n-        if slice.len == 0 { return None; }\n-        let head: *const T = slice.data;\n-        slice.data = slice.data.offset(1);\n-        slice.len -= 1;\n-        Some(head)\n-    }\n-\n-    /// Returns a pointer to last element in slice and adjusts\n-    /// slice so it no longer contains that element. Returns None\n-    /// if the slice is empty. O(1).\n-    #[inline]\n-    #[deprecated = \"inspect `Slice::{data, len}` manually (decrement len by 1)\"]\n-    pub unsafe fn pop_ptr<T>(slice: &mut Slice<T>) -> Option<*const T> {\n-        if slice.len == 0 { return None; }\n-        let tail: *const T = slice.data.offset((slice.len - 1) as int);\n-        slice.len -= 1;\n-        Some(tail)\n-    }\n-}\n-\n /// Operations on `[u8]`.\n #[experimental = \"needs review\"]\n pub mod bytes {\n@@ -1490,20 +1428,6 @@ impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n #[stable]\n impl<T: Eq> Eq for [T] {}\n \n-#[allow(deprecated)]\n-#[deprecated = \"Use overloaded `core::cmp::PartialEq`\"]\n-impl<T: PartialEq, Sized? V: AsSlice<T>> Equiv<V> for [T] {\n-    #[inline]\n-    fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n-}\n-\n-#[allow(deprecated)]\n-#[deprecated = \"Use overloaded `core::cmp::PartialEq`\"]\n-impl<'a,T:PartialEq, Sized? V: AsSlice<T>> Equiv<V> for &'a mut [T] {\n-    #[inline]\n-    fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n-}\n-\n #[stable]\n impl<T: Ord> Ord for [T] {\n     fn cmp(&self, other: &[T]) -> Ordering {"}, {"sha": "d069744f8da54f109bba4c957240999bbbfa8258", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 8, "deletions": 111, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -114,12 +114,6 @@ pub trait FromStr {\n     fn from_str(s: &str) -> Option<Self>;\n }\n \n-/// A utility function that just calls FromStr::from_str\n-#[deprecated = \"call the .parse() method on the string instead\"]\n-pub fn from_str<A: FromStr>(s: &str) -> Option<A> {\n-    FromStr::from_str(s)\n-}\n-\n impl FromStr for bool {\n     /// Parse a `bool` from a string.\n     ///\n@@ -427,8 +421,7 @@ impl<'a> Fn(&'a u8) -> u8 for BytesDeref {\n \n /// An iterator over the substrings of a string, separated by `sep`.\n #[derive(Clone)]\n-#[deprecated = \"Type is now named `Split` or `SplitTerminator`\"]\n-pub struct CharSplits<'a, Sep> {\n+struct CharSplits<'a, Sep> {\n     /// The slice remaining to be iterated\n     string: &'a str,\n     sep: Sep,\n@@ -441,8 +434,7 @@ pub struct CharSplits<'a, Sep> {\n /// An iterator over the substrings of a string, separated by `sep`,\n /// splitting at most `count` times.\n #[derive(Clone)]\n-#[deprecated = \"Type is now named `SplitN` or `RSplitN`\"]\n-pub struct CharSplitsN<'a, Sep> {\n+struct CharSplitsN<'a, Sep> {\n     iter: CharSplits<'a, Sep>,\n     /// The number of splits remaining\n     count: uint,\n@@ -873,10 +865,6 @@ pub struct SplitStr<'a> {\n     finished: bool\n }\n \n-/// Deprecated\n-#[deprecated = \"Type is now named `SplitStr`\"]\n-pub type StrSplits<'a> = SplitStr<'a>;\n-\n impl<'a> Iterator for MatchIndices<'a> {\n     type Item = (uint, uint);\n \n@@ -1027,22 +1015,6 @@ fn run_utf8_validation_iterator(iter: &mut slice::Iter<u8>)\n     }\n }\n \n-/// Determines if a vector of bytes contains valid UTF-8.\n-#[deprecated = \"call from_utf8 instead\"]\n-pub fn is_utf8(v: &[u8]) -> bool {\n-    run_utf8_validation_iterator(&mut v.iter()).is_ok()\n-}\n-\n-/// Deprecated function\n-#[deprecated = \"this function will be removed\"]\n-pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n-    match v.iter().position(|c| *c == 0) {\n-        // don't include the 0\n-        Some(i) => v[..i],\n-        None => v\n-    }\n-}\n-\n // https://tools.ietf.org/html/rfc3629\n static UTF8_CHAR_WIDTH: [u8; 256] = [\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n@@ -1063,13 +1035,6 @@ static UTF8_CHAR_WIDTH: [u8; 256] = [\n 4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0, // 0xFF\n ];\n \n-/// Given a first byte, determine how many bytes are in this UTF-8 character\n-#[inline]\n-#[deprecated = \"this function has moved to libunicode\"]\n-pub fn utf8_char_width(b: u8) -> uint {\n-    return UTF8_CHAR_WIDTH[b as uint] as uint;\n-}\n-\n /// Struct that contains a `char` and the index of the first byte of\n /// the next `char` in a string.  This can be used as a data structure\n /// for iterating over the UTF-8 bytes of a string.\n@@ -1087,78 +1052,19 @@ const CONT_MASK: u8 = 0b0011_1111u8;\n /// Value of the tag bits (tag mask is !CONT_MASK) of a continuation byte\n const TAG_CONT_U8: u8 = 0b1000_0000u8;\n \n-/// Unsafe operations\n-#[deprecated]\n-pub mod raw {\n-    use ptr::PtrExt;\n-    use raw::Slice;\n-    use slice::SliceExt;\n-    use str::StrExt;\n-\n-    /// Converts a slice of bytes to a string slice without checking\n-    /// that the string contains valid UTF-8.\n-    #[deprecated = \"renamed to str::from_utf8_unchecked\"]\n-    pub unsafe fn from_utf8<'a>(v: &'a [u8]) -> &'a str {\n-        super::from_utf8_unchecked(v)\n-    }\n-\n-    /// Form a slice from a C string. Unsafe because the caller must ensure the\n-    /// C string has the static lifetime, or else the return value may be\n-    /// invalidated later.\n-    #[deprecated = \"renamed to str::from_c_str\"]\n-    pub unsafe fn c_str_to_static_slice(s: *const i8) -> &'static str {\n-        let s = s as *const u8;\n-        let mut curr = s;\n-        let mut len = 0u;\n-        while *curr != 0u8 {\n-            len += 1u;\n-            curr = s.offset(len as int);\n-        }\n-        let v = Slice { data: s, len: len };\n-        super::from_utf8(::mem::transmute(v)).unwrap()\n-    }\n-\n-    /// Takes a bytewise (not UTF-8) slice from a string.\n-    ///\n-    /// Returns the substring from [`begin`..`end`).\n-    ///\n-    /// # Panics\n-    ///\n-    /// If begin is greater than end.\n-    /// If end is greater than the length of the string.\n-    #[inline]\n-    #[deprecated = \"call the slice_unchecked method instead\"]\n-    pub unsafe fn slice_bytes<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n-        assert!(begin <= end);\n-        assert!(end <= s.len());\n-        s.slice_unchecked(begin, end)\n-    }\n-\n-    /// Takes a bytewise (not UTF-8) slice from a string.\n-    ///\n-    /// Returns the substring from [`begin`..`end`).\n-    ///\n-    /// Caller must check slice boundaries!\n-    #[inline]\n-    #[deprecated = \"this has moved to a method on `str` directly\"]\n-    pub unsafe fn slice_unchecked<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n-        s.slice_unchecked(begin, end)\n-    }\n-}\n-\n /*\n Section: Trait implementations\n */\n \n #[allow(missing_docs)]\n pub mod traits {\n-    use cmp::{Ordering, Ord, PartialEq, PartialOrd, Equiv, Eq};\n+    use cmp::{Ordering, Ord, PartialEq, PartialOrd, Eq};\n     use cmp::Ordering::{Less, Equal, Greater};\n     use iter::IteratorExt;\n     use option::Option;\n     use option::Option::Some;\n     use ops;\n-    use str::{Str, StrExt, eq_slice};\n+    use str::{StrExt, eq_slice};\n \n     #[stable]\n     impl Ord for str {\n@@ -1197,13 +1103,6 @@ pub mod traits {\n         }\n     }\n \n-    #[allow(deprecated)]\n-    #[deprecated = \"Use overloaded `core::cmp::PartialEq`\"]\n-    impl<S: Str> Equiv<S> for str {\n-        #[inline]\n-        fn equiv(&self, other: &S) -> bool { eq_slice(self, other.as_slice()) }\n-    }\n-\n     impl ops::Slice<uint, str> for str {\n         #[inline]\n         fn as_slice_<'a>(&'a self) -> &'a str {\n@@ -1236,13 +1135,11 @@ pub trait Str for Sized? {\n     fn as_slice<'a>(&'a self) -> &'a str;\n }\n \n-#[allow(deprecated)]\n impl Str for str {\n     #[inline]\n     fn as_slice<'a>(&'a self) -> &'a str { self }\n }\n \n-#[allow(deprecated)]\n impl<'a, Sized? S> Str for &'a S where S: Str {\n     #[inline]\n     fn as_slice(&self) -> &str { Str::as_slice(*self) }\n@@ -1316,6 +1213,7 @@ pub trait StrExt for Sized? {\n     fn as_ptr(&self) -> *const u8;\n     fn len(&self) -> uint;\n     fn is_empty(&self) -> bool;\n+    fn parse<T: FromStr>(&self) -> Option<T>;\n }\n \n #[inline(never)]\n@@ -1352,7 +1250,6 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    #[allow(deprecated)] // For using CharSplits\n     fn split<P: CharEq>(&self, pat: P) -> Split<P> {\n         Split(CharSplits {\n             string: self,\n@@ -1364,7 +1261,6 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    #[allow(deprecated)] // For using CharSplitsN\n     fn splitn<P: CharEq>(&self, count: uint, pat: P) -> SplitN<P> {\n         SplitN(CharSplitsN {\n             iter: self.split(pat).0,\n@@ -1374,7 +1270,6 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    #[allow(deprecated)] // For using CharSplits\n     fn split_terminator<P: CharEq>(&self, pat: P) -> SplitTerminator<P> {\n         SplitTerminator(CharSplits {\n             allow_trailing_empty: false,\n@@ -1383,7 +1278,6 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    #[allow(deprecated)] // For using CharSplitsN\n     fn rsplitn<P: CharEq>(&self, count: uint, pat: P) -> RSplitN<P> {\n         RSplitN(CharSplitsN {\n             iter: self.split(pat).0,\n@@ -1681,6 +1575,9 @@ impl StrExt for str {\n \n     #[inline]\n     fn is_empty(&self) -> bool { self.len() == 0 }\n+\n+    #[inline]\n+    fn parse<T: FromStr>(&self) -> Option<T> { FromStr::from_str(self) }\n }\n \n #[stable]"}, {"sha": "4aca830cb941390c7846d491a1f9bb847b19dbf9", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -58,44 +58,6 @@ macro_rules! tuple_impls {\n         }\n     )+) => {\n         $(\n-            #[allow(missing_docs)]\n-            #[deprecated]\n-            pub trait $Tuple<$($T),+> {\n-                $(\n-                    #[deprecated = \"use tuple indexing: `tuple.N`\"]\n-                    fn $valN(self) -> $T;\n-                    #[deprecated = \"use tuple indexing: `&tuple.N`\"]\n-                    fn $refN<'a>(&'a self) -> &'a $T;\n-                    #[deprecated = \"use tuple indexing: `&mut tuple.N`\"]\n-                    fn $mutN<'a>(&'a mut self) -> &'a mut $T;\n-                 )+\n-            }\n-\n-            impl<$($T),+> $Tuple<$($T),+> for ($($T,)+) {\n-                $(\n-                    #[inline]\n-                    #[allow(unused_variables)]\n-                    #[deprecated = \"use tuple indexing: `tuple.N`\"]\n-                    fn $valN(self) -> $T {\n-                        e!(self.$idx)\n-                    }\n-\n-                    #[inline]\n-                    #[allow(unused_variables)]\n-                    #[deprecated = \"use tuple indexing: `&tuple.N`\"]\n-                    fn $refN<'a>(&'a self) -> &'a $T {\n-                        e!(&self.$idx)\n-                    }\n-\n-                    #[inline]\n-                    #[allow(unused_variables)]\n-                    #[deprecated = \"use tuple indexing: &mut tuple.N\"]\n-                    fn $mutN<'a>(&'a mut self) -> &'a mut $T {\n-                        e!(&mut self.$idx)\n-                    }\n-                )+\n-            }\n-\n             #[stable]\n             impl<$($T:Clone),+> Clone for ($($T,)+) {\n                 fn clone(&self) -> ($($T,)+) {"}, {"sha": "b581cdbd710934982effc6a83d0415376edce861", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 29, "deletions": 33, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -10,8 +10,6 @@\n //\n // ignore-lexer-test FIXME #15679\n \n-use core::char::{escape_unicode, escape_default};\n-\n #[test]\n fn test_is_lowercase() {\n     assert!('a'.is_lowercase());\n@@ -33,12 +31,12 @@ fn test_is_uppercase() {\n #[test]\n fn test_is_whitespace() {\n     assert!(' '.is_whitespace());\n-    assert!('\\u2007'.is_whitespace());\n+    assert!('\\u{2007}'.is_whitespace());\n     assert!('\\t'.is_whitespace());\n     assert!('\\n'.is_whitespace());\n     assert!(!'a'.is_whitespace());\n     assert!(!'_'.is_whitespace());\n-    assert!(!'\\u0000'.is_whitespace());\n+    assert!(!'\\u{0}'.is_whitespace());\n }\n \n #[test]\n@@ -92,15 +90,15 @@ fn test_to_uppercase() {\n \n #[test]\n fn test_is_control() {\n-    assert!('\\u0000'.is_control());\n-    assert!('\\u0003'.is_control());\n-    assert!('\\u0006'.is_control());\n-    assert!('\\u0009'.is_control());\n-    assert!('\\u007f'.is_control());\n-    assert!('\\u0092'.is_control());\n-    assert!(!'\\u0020'.is_control());\n-    assert!(!'\\u0055'.is_control());\n-    assert!(!'\\u0068'.is_control());\n+    assert!('\\u{0}'.is_control());\n+    assert!('\\u{3}'.is_control());\n+    assert!('\\u{6}'.is_control());\n+    assert!('\\u{9}'.is_control());\n+    assert!('\\u{7f}'.is_control());\n+    assert!('\\u{92}'.is_control());\n+    assert!(!'\\u{20}'.is_control());\n+    assert!(!'\\u{55}'.is_control());\n+    assert!(!'\\u{68}'.is_control());\n }\n \n #[test]\n@@ -116,9 +114,7 @@ fn test_is_digit() {\n #[test]\n fn test_escape_default() {\n     fn string(c: char) -> String {\n-        let mut result = String::new();\n-        escape_default(c, |c| { result.push(c); });\n-        return result;\n+        c.escape_default().collect()\n     }\n     let s = string('\\n');\n     assert_eq!(s, \"\\\\n\");\n@@ -175,9 +171,9 @@ fn test_encode_utf8() {\n     }\n \n     check('x', &[0x78]);\n-    check('\\u00e9', &[0xc3, 0xa9]);\n-    check('\\ua66e', &[0xea, 0x99, 0xae]);\n-    check('\\U0001f4a9', &[0xf0, 0x9f, 0x92, 0xa9]);\n+    check('\\u{e9}', &[0xc3, 0xa9]);\n+    check('\\u{a66e}', &[0xea, 0x99, 0xae]);\n+    check('\\u{1f4a9}', &[0xf0, 0x9f, 0x92, 0xa9]);\n }\n \n #[test]\n@@ -189,17 +185,17 @@ fn test_encode_utf16() {\n     }\n \n     check('x', &[0x0078]);\n-    check('\\u00e9', &[0x00e9]);\n-    check('\\ua66e', &[0xa66e]);\n-    check('\\U0001f4a9', &[0xd83d, 0xdca9]);\n+    check('\\u{e9}', &[0x00e9]);\n+    check('\\u{a66e}', &[0xa66e]);\n+    check('\\u{1f4a9}', &[0xd83d, 0xdca9]);\n }\n \n #[test]\n fn test_len_utf16() {\n     assert!('x'.len_utf16() == 1);\n-    assert!('\\u00e9'.len_utf16() == 1);\n-    assert!('\\ua66e'.len_utf16() == 1);\n-    assert!('\\U0001f4a9'.len_utf16() == 2);\n+    assert!('\\u{e9}'.len_utf16() == 1);\n+    assert!('\\u{a66e}'.len_utf16() == 1);\n+    assert!('\\u{1f4a9}'.len_utf16() == 2);\n }\n \n #[test]\n@@ -216,15 +212,15 @@ fn test_width() {\n     assert_eq!('\uff48'.width(false),Some(2));\n     assert_eq!('\uff48'.width(true),Some(2));\n \n-    assert_eq!('\\u00AD'.width(false),Some(1));\n-    assert_eq!('\\u00AD'.width(true),Some(1));\n+    assert_eq!('\\u{AD}'.width(false),Some(1));\n+    assert_eq!('\\u{AD}'.width(true),Some(1));\n \n-    assert_eq!('\\u1160'.width(false),Some(0));\n-    assert_eq!('\\u1160'.width(true),Some(0));\n+    assert_eq!('\\u{1160}'.width(false),Some(0));\n+    assert_eq!('\\u{1160}'.width(true),Some(0));\n \n-    assert_eq!('\\u00a1'.width(false),Some(1));\n-    assert_eq!('\\u00a1'.width(true),Some(2));\n+    assert_eq!('\\u{a1}'.width(false),Some(1));\n+    assert_eq!('\\u{a1}'.width(true),Some(2));\n \n-    assert_eq!('\\u0300'.width(false),Some(0));\n-    assert_eq!('\\u0300'.width(true),Some(0));\n+    assert_eq!('\\u{300}'.width(false),Some(0));\n+    assert_eq!('\\u{300}'.width(true),Some(0));\n }"}, {"sha": "2aa2a229f90fa16a322610e8965cdb69d266f09f", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -103,7 +103,7 @@ fn test_iterator_chain() {\n \n #[test]\n fn test_filter_map() {\n-    let mut it = count(0u, 1u).take(10)\n+    let it = count(0u, 1u).take(10)\n         .filter_map(|x| if x % 2 == 0 { Some(x*x) } else { None });\n     assert!(it.collect::<Vec<uint>>() == vec![0*0, 2*2, 4*4, 6*6, 8*8]);\n }"}, {"sha": "ab2f6da1cf7d9e6c061b5ccbdb294d8307141eb7", "filename": "src/libcoretest/nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcoretest%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcoretest%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnonzero.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -92,7 +92,7 @@ fn test_match_option_empty_string() {\n \n #[test]\n fn test_match_option_string() {\n-    let five = \"Five\".into_string();\n+    let five = \"Five\".to_string();\n     match Some(five) {\n         Some(s) => assert_eq!(s, \"Five\"),\n         None => panic!(\"unexpected None while matching on Some(String { ... })\")"}, {"sha": "8885d3a52082cd3571fb59e89ea682cbbe01c01a", "filename": "src/libcoretest/num/int_macros.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint_macros.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -16,7 +16,6 @@ mod tests {\n     use core::$T_i::*;\n     use core::int;\n     use core::num::{FromStrRadix, Int, SignedInt};\n-    use core::str::from_str;\n     use core::ops::{Shl, Shr, Not, BitXor, BitAnd, BitOr};\n     use num;\n \n@@ -161,6 +160,9 @@ mod tests {\n \n     #[test]\n     fn test_from_str() {\n+        fn from_str<T: ::std::str::FromStr>(t: &str) -> Option<T> {\n+            ::std::str::FromStr::from_str(t)\n+        }\n         assert_eq!(from_str::<$T>(\"0\"), Some(0 as $T));\n         assert_eq!(from_str::<$T>(\"3\"), Some(3 as $T));\n         assert_eq!(from_str::<$T>(\"10\"), Some(10 as $T));"}, {"sha": "651e8640e912a399ac3f7e6a343af4a81e1b7357", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -13,7 +13,6 @@ use core::fmt::Show;\n use core::num::{NumCast, cast};\n use core::ops::{Add, Sub, Mul, Div, Rem};\n use core::kinds::Copy;\n-use std::str::from_str;\n \n mod int_macros;\n mod i8;\n@@ -55,7 +54,6 @@ mod test {\n     use core::option::Option::{Some, None};\n     use core::num::Float;\n     use core::num::from_str_radix;\n-    use core::str::from_str;\n \n     #[test]\n     fn from_str_issue7588() {\n@@ -88,35 +86,35 @@ mod test {\n     #[test]\n     fn test_int_from_str_overflow() {\n         let mut i8_val: i8 = 127_i8;\n-        assert_eq!(from_str::<i8>(\"127\"), Some(i8_val));\n-        assert_eq!(from_str::<i8>(\"128\"), None);\n+        assert_eq!(\"127\".parse::<i8>(), Some(i8_val));\n+        assert_eq!(\"128\".parse::<i8>(), None);\n \n         i8_val += 1 as i8;\n-        assert_eq!(from_str::<i8>(\"-128\"), Some(i8_val));\n-        assert_eq!(from_str::<i8>(\"-129\"), None);\n+        assert_eq!(\"-128\".parse::<i8>(), Some(i8_val));\n+        assert_eq!(\"-129\".parse::<i8>(), None);\n \n         let mut i16_val: i16 = 32_767_i16;\n-        assert_eq!(from_str::<i16>(\"32767\"), Some(i16_val));\n-        assert_eq!(from_str::<i16>(\"32768\"), None);\n+        assert_eq!(\"32767\".parse::<i16>(), Some(i16_val));\n+        assert_eq!(\"32768\".parse::<i16>(), None);\n \n         i16_val += 1 as i16;\n-        assert_eq!(from_str::<i16>(\"-32768\"), Some(i16_val));\n-        assert_eq!(from_str::<i16>(\"-32769\"), None);\n+        assert_eq!(\"-32768\".parse::<i16>(), Some(i16_val));\n+        assert_eq!(\"-32769\".parse::<i16>(), None);\n \n         let mut i32_val: i32 = 2_147_483_647_i32;\n-        assert_eq!(from_str::<i32>(\"2147483647\"), Some(i32_val));\n-        assert_eq!(from_str::<i32>(\"2147483648\"), None);\n+        assert_eq!(\"2147483647\".parse::<i32>(), Some(i32_val));\n+        assert_eq!(\"2147483648\".parse::<i32>(), None);\n \n         i32_val += 1 as i32;\n-        assert_eq!(from_str::<i32>(\"-2147483648\"), Some(i32_val));\n-        assert_eq!(from_str::<i32>(\"-2147483649\"), None);\n+        assert_eq!(\"-2147483648\".parse::<i32>(), Some(i32_val));\n+        assert_eq!(\"-2147483649\".parse::<i32>(), None);\n \n         let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-        assert_eq!(from_str::<i64>(\"9223372036854775807\"), Some(i64_val));\n-        assert_eq!(from_str::<i64>(\"9223372036854775808\"), None);\n+        assert_eq!(\"9223372036854775807\".parse::<i64>(), Some(i64_val));\n+        assert_eq!(\"9223372036854775808\".parse::<i64>(), None);\n \n         i64_val += 1 as i64;\n-        assert_eq!(from_str::<i64>(\"-9223372036854775808\"), Some(i64_val));\n-        assert_eq!(from_str::<i64>(\"-9223372036854775809\"), None);\n+        assert_eq!(\"-9223372036854775808\".parse::<i64>(), Some(i64_val));\n+        assert_eq!(\"-9223372036854775809\".parse::<i64>(), None);\n     }\n }"}, {"sha": "875affe0ac780fe185b3bac3c38921023132a527", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -10,6 +10,7 @@\n \n use core::ptr::*;\n use core::mem;\n+use std::iter::repeat;\n \n #[test]\n fn test() {\n@@ -56,19 +57,15 @@ fn test() {\n fn test_is_null() {\n     let p: *const int = null();\n     assert!(p.is_null());\n-    assert!(!p.is_not_null());\n \n     let q = unsafe { p.offset(1) };\n     assert!(!q.is_null());\n-    assert!(q.is_not_null());\n \n     let mp: *mut int = null_mut();\n     assert!(mp.is_null());\n-    assert!(!mp.is_not_null());\n \n     let mq = unsafe { mp.offset(1) };\n     assert!(!mq.is_null());\n-    assert!(mq.is_not_null());\n }\n \n #[test]\n@@ -116,7 +113,7 @@ fn test_as_mut() {\n #[test]\n fn test_ptr_addition() {\n     unsafe {\n-        let xs = Vec::from_elem(16, 5i);\n+        let xs = repeat(5i).take(16).collect::<Vec<_>>();\n         let mut ptr = xs.as_ptr();\n         let end = ptr.offset(16);\n \n@@ -134,7 +131,7 @@ fn test_ptr_addition() {\n             m_ptr = m_ptr.offset(1);\n         }\n \n-        assert!(xs_mut == Vec::from_elem(16, 10i));\n+        assert!(xs_mut == repeat(10i).take(16).collect::<Vec<_>>());\n     }\n }\n "}, {"sha": "1c0af55370d399e9c298d1ab5035ae9424d140e5", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::str::from_str;\n-\n #[test]\n fn test_bool_from_str() {\n-    assert_eq!(from_str::<bool>(\"true\"), Some(true));\n-    assert_eq!(from_str::<bool>(\"false\"), Some(false));\n-    assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n+    assert_eq!(\"true\".parse(), Some(true));\n+    assert_eq!(\"false\".parse(), Some(false));\n+    assert_eq!(\"not even a boolean\".parse::<bool>(), None);\n }\n \n fn check_contains_all_substrings(s: &str) {\n@@ -120,6 +118,6 @@ fn test_rev_split_char_iterator_no_trailing() {\n #[test]\n fn test_utf16_code_units() {\n     use unicode::str::Utf16Encoder;\n-    assert_eq!(Utf16Encoder::new(vec!['\u00e9', '\\U0001F4A9'].into_iter()).collect::<Vec<u16>>(),\n+    assert_eq!(Utf16Encoder::new(vec!['\u00e9', '\\u{1F4A9}'].into_iter()).collect::<Vec<u16>>(),\n                vec![0xE9, 0xD83D, 0xDCA9])\n }"}, {"sha": "f151102f28629992e50f398ffdd034bce1ee8e0e", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -278,7 +278,7 @@ pub use self::LabelText::*;\n \n use std::borrow::IntoCow;\n use std::io;\n-use std::str::CowString;\n+use std::string::CowString;\n use std::vec::CowVec;\n \n pub mod maybe_owned_vec;\n@@ -589,8 +589,8 @@ mod tests {\n     use super::{Id, LabelText, LabelStr, EscStr, Labeller};\n     use super::{Nodes, Edges, GraphWalk, render};\n     use std::io::IoResult;\n-    use std::str;\n     use std::borrow::IntoCow;\n+    use std::iter::repeat;\n \n     /// each node is an index in a vector in the graph.\n     type Node = uint;\n@@ -638,7 +638,7 @@ mod tests {\n         fn to_opt_strs(self) -> Vec<Option<&'static str>> {\n             match self {\n                 UnlabelledNodes(len)\n-                    => Vec::from_elem(len, None).into_iter().collect(),\n+                    => repeat(None).take(len).collect(),\n                 AllNodesLabelled(lbls)\n                     => lbls.into_iter().map(\n                         |l|Some(l)).collect(),"}, {"sha": "04aa6d1649538019d2ba85b10824ff0641fa1cd4", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -12,7 +12,7 @@\n \n pub use self::MaybeOwnedVector::*;\n \n-use std::cmp::{Equiv, Ordering};\n+use std::cmp::Ordering;\n use std::default::Default;\n use std::fmt;\n use std::iter::FromIterator;\n@@ -97,13 +97,6 @@ impl<'a, T: Ord> Ord for MaybeOwnedVector<'a, T> {\n     }\n }\n \n-#[allow(deprecated)]\n-impl<'a, T: PartialEq> Equiv<[T]> for MaybeOwnedVector<'a, T> {\n-    fn equiv(&self, other: &[T]) -> bool {\n-        self.as_slice() == other\n-    }\n-}\n-\n // The `Vector` trait is provided in the prelude and is implemented on\n // both `&'a [T]` and `Vec<T>`, so it makes sense to try to support it\n // seamlessly.  The other vector related traits from the prelude do"}, {"sha": "71ce882e98ca99c2f5d4a602f788221aad9ae53c", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -249,14 +249,14 @@ mod test {\n         let seed : &[_] = &[0u32; 8];\n         let mut ra: ChaChaRng = SeedableRng::from_seed(seed);\n \n-        let v = Vec::from_fn(16, |_| ra.next_u32());\n+        let v = range(0, 16).map(|_| ra.next_u32()).collect::<Vec<_>>();\n         assert_eq!(v,\n                    vec!(0xade0b876, 0x903df1a0, 0xe56a5d40, 0x28bd8653,\n                         0xb819d2bd, 0x1aed8da0, 0xccef36a8, 0xc70d778b,\n                         0x7c5941da, 0x8d485751, 0x3fe02477, 0x374ad8b8,\n                         0xf4b8436a, 0x1ca11815, 0x69b687c3, 0x8665eeb2));\n \n-        let v = Vec::from_fn(16, |_| ra.next_u32());\n+        let v = range(0, 16).map(|_| ra.next_u32()).collect::<Vec<_>>();\n         assert_eq!(v,\n                    vec!(0xbee7079f, 0x7a385155, 0x7c97ba98, 0x0d082d73,\n                         0xa0290fcb, 0x6965e348, 0x3e53c612, 0xed7aee32,"}, {"sha": "53ae242c5e245e1050fa85d965b04e7a2fbbdcfd", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -555,7 +555,7 @@ mod test {\n         let seed: &[_] = &[1, 23, 456, 7890, 12345];\n         let mut ra: IsaacRng = SeedableRng::from_seed(seed);\n         // Regression test that isaac is actually using the above vector\n-        let v = Vec::from_fn(10, |_| ra.next_u32());\n+        let v = range(0, 10).map(|_| ra.next_u32()).collect::<Vec<_>>();\n         assert_eq!(v,\n                    vec!(2558573138, 873787463, 263499565, 2103644246, 3595684709,\n                         4203127393, 264982119, 2765226902, 2737944514, 3900253796));\n@@ -565,7 +565,7 @@ mod test {\n         // skip forward to the 10000th number\n         for _ in range(0u, 10000) { rb.next_u32(); }\n \n-        let v = Vec::from_fn(10, |_| rb.next_u32());\n+        let v = range(0, 10).map(|_| rb.next_u32()).collect::<Vec<_>>();\n         assert_eq!(v,\n                    vec!(3676831399, 3183332890, 2834741178, 3854698763, 2717568474,\n                         1576568959, 3507990155, 179069555, 141456972, 2478885421));\n@@ -575,7 +575,7 @@ mod test {\n         let seed: &[_] = &[1, 23, 456, 7890, 12345];\n         let mut ra: Isaac64Rng = SeedableRng::from_seed(seed);\n         // Regression test that isaac is actually using the above vector\n-        let v = Vec::from_fn(10, |_| ra.next_u64());\n+        let v = range(0, 10).map(|_| ra.next_u64()).collect::<Vec<_>>();\n         assert_eq!(v,\n                    vec!(547121783600835980, 14377643087320773276, 17351601304698403469,\n                         1238879483818134882, 11952566807690396487, 13970131091560099343,\n@@ -587,7 +587,7 @@ mod test {\n         // skip forward to the 10000th number\n         for _ in range(0u, 10000) { rb.next_u64(); }\n \n-        let v = Vec::from_fn(10, |_| rb.next_u64());\n+        let v = range(0, 10).map(|_| rb.next_u64()).collect::<Vec<_>>();\n         assert_eq!(v,\n                    vec!(18143823860592706164, 8491801882678285927, 2699425367717515619,\n                         17196852593171130876, 2606123525235546165, 15790932315217671084,"}, {"sha": "63de49ac5cd8184741ed180a86b5311daf050813", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -151,7 +151,7 @@ impl Default for ReseedWithDefault {\n mod test {\n     use std::prelude::v1::*;\n \n-    use core::iter::order;\n+    use core::iter::{order, repeat};\n     use super::{ReseedingRng, ReseedWithDefault};\n     use std::default::Default;\n     use {SeedableRng, Rng};\n@@ -215,7 +215,7 @@ mod test {\n     static FILL_BYTES_V_LEN: uint = 13579;\n     #[test]\n     fn test_rng_fill_bytes() {\n-        let mut v = Vec::from_elem(FILL_BYTES_V_LEN, 0u8);\n+        let mut v = repeat(0u8).take(FILL_BYTES_V_LEN).collect::<Vec<_>>();\n         ::test::rng().fill_bytes(v.as_mut_slice());\n \n         // Sanity test: if we've gotten here, `fill_bytes` has not infinitely"}, {"sha": "de06471e65ed9e62f2caf40dae9691a1fb2ea875", "filename": "src/librbml/io.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -133,6 +133,7 @@ mod tests {\n     extern crate test;\n     use super::SeekableMemWriter;\n     use std::io;\n+    use std::iter::repeat;\n     use test::Bencher;\n \n     #[test]\n@@ -183,7 +184,7 @@ mod tests {\n     }\n \n     fn do_bench_seekable_mem_writer(b: &mut Bencher, times: uint, len: uint) {\n-        let src: Vec<u8> = Vec::from_elem(len, 5);\n+        let src: Vec<u8> = repeat(5).take(len).collect();\n \n         b.bytes = (times * len) as u64;\n         b.iter(|| {"}, {"sha": "f7d5bfcd117d65a0e9f7a1218224217efa1bae9b", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -1165,12 +1165,12 @@ mod bench {\n \n     #[bench]\n     pub fn vuint_at_A_aligned(b: &mut Bencher) {\n-        let data = Vec::from_fn(4*100, |i| {\n+        let data = range(0, 4*100).map(|i| {\n             match i % 2 {\n               0 => 0x80u8,\n               _ => i as u8,\n             }\n-        });\n+        }).collect::<Vec<_>>();\n         let mut sum = 0u;\n         b.iter(|| {\n             let mut i = 0;\n@@ -1183,12 +1183,12 @@ mod bench {\n \n     #[bench]\n     pub fn vuint_at_A_unaligned(b: &mut Bencher) {\n-        let data = Vec::from_fn(4*100+1, |i| {\n+        let data = range(0, 4*100+1).map(|i| {\n             match i % 2 {\n               1 => 0x80u8,\n               _ => i as u8\n             }\n-        });\n+        }).collect::<Vec<_>>();\n         let mut sum = 0u;\n         b.iter(|| {\n             let mut i = 1;\n@@ -1201,13 +1201,13 @@ mod bench {\n \n     #[bench]\n     pub fn vuint_at_D_aligned(b: &mut Bencher) {\n-        let data = Vec::from_fn(4*100, |i| {\n+        let data = range(0, 4*100).map(|i| {\n             match i % 4 {\n               0 => 0x10u8,\n               3 => i as u8,\n               _ => 0u8\n             }\n-        });\n+        }).collect::<Vec<_>>();\n         let mut sum = 0u;\n         b.iter(|| {\n             let mut i = 0;\n@@ -1220,13 +1220,13 @@ mod bench {\n \n     #[bench]\n     pub fn vuint_at_D_unaligned(b: &mut Bencher) {\n-        let data = Vec::from_fn(4*100+1, |i| {\n+        let data = range(0, 4*100+1).map(|i| {\n             match i % 4 {\n               1 => 0x10u8,\n               0 => i as u8,\n               _ => 0u8\n             }\n-        });\n+        }).collect::<Vec<_>>();\n         let mut sum = 0u;\n         b.iter(|| {\n             let mut i = 1;"}, {"sha": "b3807d313145d0e13a7e78e96ff04e2a1a102c00", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 2, "deletions": 349, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -10,356 +10,9 @@\n //\n // ignore-lexer-test FIXME #15679\n \n-//! This crate provides a native implementation of regular expressions that is\n-//! heavily based on RE2 both in syntax and in implementation. Notably,\n-//! backreferences and arbitrary lookahead/lookbehind assertions are not\n-//! provided. In return, regular expression searching provided by this package\n-//! has excellent worst case performance. The specific syntax supported is\n-//! documented further down.\n+//! Regular expressions implemented in Rust\n //!\n-//! This crate's documentation provides some simple examples, describes Unicode\n-//! support and exhaustively lists the supported syntax. For more specific\n-//! details on the API, please see the documentation for the `Regex` type.\n-//!\n-//! # First example: find a date\n-//!\n-//! General use of regular expressions in this package involves compiling an\n-//! expression and then using it to search, split or replace text. For example,\n-//! to confirm that some text resembles a date:\n-//!\n-//! ```rust\n-//! use regex::Regex;\n-//! let re = match Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}$\") {\n-//!     Ok(re) => re,\n-//!     Err(err) => panic!(\"{}\", err),\n-//! };\n-//! assert_eq!(re.is_match(\"2014-01-01\"), true);\n-//! ```\n-//!\n-//! Notice the use of the `^` and `$` anchors. In this crate, every expression\n-//! is executed with an implicit `.*?` at the beginning and end, which allows\n-//! it to match anywhere in the text. Anchors can be used to ensure that the\n-//! full text matches an expression.\n-//!\n-//! This example also demonstrates the utility of [raw\n-//! strings](../reference.html#character-and-string-literals) in Rust, which\n-//! are just like regular strings except they are prefixed with an `r` and do\n-//! not process any escape sequences. For example, `\"\\\\d\"` is the same\n-//! expression as `r\"\\d\"`.\n-//!\n-//! # The `regex!` macro\n-//!\n-//! Rust's compile time meta-programming facilities provide a way to write a\n-//! `regex!` macro which compiles regular expressions *when your program\n-//! compiles*. Said differently, if you only use `regex!` to build regular\n-//! expressions in your program, then your program cannot compile with an\n-//! invalid regular expression. Moreover, the `regex!` macro compiles the\n-//! given expression to native Rust code, which makes it much faster for\n-//! searching text.\n-//!\n-//! Since `regex!` provides compiled regular expressions that are both safer\n-//! and faster to use, you should use them whenever possible. The only\n-//! requirement for using them is that you have a string literal corresponding\n-//! to your expression. Otherwise, it is indistinguishable from an expression\n-//! compiled at runtime with `Regex::new`.\n-//!\n-//! To use the `regex!` macro, you must enable the `phase` feature and import\n-//! the `regex_macros` crate as a syntax extension:\n-//!\n-//! ```rust\n-//! #![feature(phase)]\n-//! #[phase(plugin)]\n-//! extern crate regex_macros;\n-//! extern crate regex;\n-//!\n-//! fn main() {\n-//!     let re = regex!(r\"^\\d{4}-\\d{2}-\\d{2}$\");\n-//!     assert_eq!(re.is_match(\"2014-01-01\"), true);\n-//! }\n-//! ```\n-//!\n-//! There are a few things worth mentioning about using the `regex!` macro.\n-//! Firstly, the `regex!` macro *only* accepts string *literals*.\n-//! Secondly, the `regex` crate *must* be linked with the name `regex` since\n-//! the generated code depends on finding symbols in the `regex` crate.\n-//!\n-//! The only downside of using the `regex!` macro is that it can increase the\n-//! size of your program's binary since it generates specialized Rust code.\n-//! The extra size probably won't be significant for a small number of\n-//! expressions, but 100+ calls to `regex!` will probably result in a\n-//! noticeably bigger binary.\n-//!\n-//! # Example: iterating over capture groups\n-//!\n-//! This crate provides convenient iterators for matching an expression\n-//! repeatedly against a search string to find successive non-overlapping\n-//! matches. For example, to find all dates in a string and be able to access\n-//! them by their component pieces:\n-//!\n-//! ```rust\n-//! # #![feature(phase)]\n-//! # extern crate regex; #[phase(plugin)] extern crate regex_macros;\n-//! # fn main() {\n-//! let re = regex!(r\"(\\d{4})-(\\d{2})-(\\d{2})\");\n-//! let text = \"2012-03-14, 2013-01-01 and 2014-07-05\";\n-//! for cap in re.captures_iter(text) {\n-//!     println!(\"Month: {} Day: {} Year: {}\",\n-//!              cap.at(2).unwrap_or(\"\"), cap.at(3).unwrap_or(\"\"),\n-//!              cap.at(1).unwrap_or(\"\"));\n-//! }\n-//! // Output:\n-//! // Month: 03 Day: 14 Year: 2012\n-//! // Month: 01 Day: 01 Year: 2013\n-//! // Month: 07 Day: 05 Year: 2014\n-//! # }\n-//! ```\n-//!\n-//! Notice that the year is in the capture group indexed at `1`. This is\n-//! because the *entire match* is stored in the capture group at index `0`.\n-//!\n-//! # Example: replacement with named capture groups\n-//!\n-//! Building on the previous example, perhaps we'd like to rearrange the date\n-//! formats. This can be done with text replacement. But to make the code\n-//! clearer, we can *name*  our capture groups and use those names as variables\n-//! in our replacement text:\n-//!\n-//! ```rust\n-//! # #![feature(phase)]\n-//! # extern crate regex; #[phase(plugin)] extern crate regex_macros;\n-//! # fn main() {\n-//! let re = regex!(r\"(?P<y>\\d{4})-(?P<m>\\d{2})-(?P<d>\\d{2})\");\n-//! let before = \"2012-03-14, 2013-01-01 and 2014-07-05\";\n-//! let after = re.replace_all(before, \"$m/$d/$y\");\n-//! assert_eq!(after.as_slice(), \"03/14/2012, 01/01/2013 and 07/05/2014\");\n-//! # }\n-//! ```\n-//!\n-//! The `replace` methods are actually polymorphic in the replacement, which\n-//! provides more flexibility than is seen here. (See the documentation for\n-//! `Regex::replace` for more details.)\n-//!\n-//! # Pay for what you use\n-//!\n-//! With respect to searching text with a regular expression, there are three\n-//! questions that can be asked:\n-//!\n-//! 1. Does the text match this expression?\n-//! 2. If so, where does it match?\n-//! 3. Where are the submatches?\n-//!\n-//! Generally speaking, this crate could provide a function to answer only #3,\n-//! which would subsume #1 and #2 automatically. However, it can be\n-//! significantly more expensive to compute the location of submatches, so it's\n-//! best not to do it if you don't need to.\n-//!\n-//! Therefore, only use what you need. For example, don't use `find` if you\n-//! only need to test if an expression matches a string. (Use `is_match`\n-//! instead.)\n-//!\n-//! # Unicode\n-//!\n-//! This implementation executes regular expressions **only** on sequences of\n-//! Unicode code points while exposing match locations as byte indices into the\n-//! search string.\n-//!\n-//! Currently, only naive case folding is supported. Namely, when matching\n-//! case insensitively, the characters are first converted to their uppercase\n-//! forms and then compared.\n-//!\n-//! Regular expressions themselves are also **only** interpreted as a sequence\n-//! of Unicode code points. This means you can use Unicode characters\n-//! directly in your expression:\n-//!\n-//! ```rust\n-//! # #![feature(phase)]\n-//! # extern crate regex; #[phase(plugin)] extern crate regex_macros;\n-//! # fn main() {\n-//! let re = regex!(r\"(?i)\u0394+\");\n-//! assert_eq!(re.find(\"\u0394\u03b4\u0394\"), Some((0, 6)));\n-//! # }\n-//! ```\n-//!\n-//! Finally, Unicode general categories and scripts are available as character\n-//! classes. For example, you can match a sequence of numerals, Greek or\n-//! Cherokee letters:\n-//!\n-//! ```rust\n-//! # #![feature(phase)]\n-//! # extern crate regex; #[phase(plugin)] extern crate regex_macros;\n-//! # fn main() {\n-//! let re = regex!(r\"[\\pN\\p{Greek}\\p{Cherokee}]+\");\n-//! assert_eq!(re.find(\"abc\u0394\u13a0\u03b2\u2160\u13f4\u03b3\u03b4\u2161xyz\"), Some((3, 23)));\n-//! # }\n-//! ```\n-//!\n-//! # Syntax\n-//!\n-//! The syntax supported in this crate is almost in an exact correspondence\n-//! with the syntax supported by RE2.\n-//!\n-//! ## Matching one character\n-//!\n-//! <pre class=\"rust\">\n-//! .           any character except new line (includes new line with s flag)\n-//! [xyz]       A character class matching either x, y or z.\n-//! [^xyz]      A character class matching any character except x, y and z.\n-//! [a-z]       A character class matching any character in range a-z.\n-//! \\d          Perl character class ([0-9])\n-//! \\D          Negated Perl character class ([^0-9])\n-//! [:alpha:]   ASCII character class ([A-Za-z])\n-//! [:^alpha:]  Negated ASCII character class ([^A-Za-z])\n-//! \\pN         One letter name Unicode character class\n-//! \\p{Greek}   Unicode character class (general category or script)\n-//! \\PN         Negated one letter name Unicode character class\n-//! \\P{Greek}   negated Unicode character class (general category or script)\n-//! </pre>\n-//!\n-//! Any named character class may appear inside a bracketed `[...]` character\n-//! class. For example, `[\\p{Greek}\\pN]` matches any Greek or numeral\n-//! character.\n-//!\n-//! ## Composites\n-//!\n-//! <pre class=\"rust\">\n-//! xy    concatenation (x followed by y)\n-//! x|y   alternation (x or y, prefer x)\n-//! </pre>\n-//!\n-//! ## Repetitions\n-//!\n-//! <pre class=\"rust\">\n-//! x*        zero or more of x (greedy)\n-//! x+        one or more of x (greedy)\n-//! x?        zero or one of x (greedy)\n-//! x*?       zero or more of x (ungreedy)\n-//! x+?       one or more of x (ungreedy)\n-//! x??       zero or one of x (ungreedy)\n-//! x{n,m}    at least n x and at most m x (greedy)\n-//! x{n,}     at least n x (greedy)\n-//! x{n}      exactly n x\n-//! x{n,m}?   at least n x and at most m x (ungreedy)\n-//! x{n,}?    at least n x (ungreedy)\n-//! x{n}?     exactly n x\n-//! </pre>\n-//!\n-//! ## Empty matches\n-//!\n-//! <pre class=\"rust\">\n-//! ^     the beginning of text (or start-of-line with multi-line mode)\n-//! $     the end of text (or end-of-line with multi-line mode)\n-//! \\A    only the beginning of text (even with multi-line mode enabled)\n-//! \\z    only the end of text (even with multi-line mode enabled)\n-//! \\b    a Unicode word boundary (\\w on one side and \\W, \\A, or \\z on other)\n-//! \\B    not a Unicode word boundary\n-//! </pre>\n-//!\n-//! ## Grouping and flags\n-//!\n-//! <pre class=\"rust\">\n-//! (exp)          numbered capture group (indexed by opening parenthesis)\n-//! (?P&lt;name&gt;exp)  named (also numbered) capture group (allowed chars: [_0-9a-zA-Z])\n-//! (?:exp)        non-capturing group\n-//! (?flags)       set flags within current group\n-//! (?flags:exp)   set flags for exp (non-capturing)\n-//! </pre>\n-//!\n-//! Flags are each a single character. For example, `(?x)` sets the flag `x`\n-//! and `(?-x)` clears the flag `x`. Multiple flags can be set or cleared at\n-//! the same time: `(?xy)` sets both the `x` and `y` flags and `(?x-y)` sets\n-//! the `x` flag and clears the `y` flag.\n-//!\n-//! All flags are by default disabled. They are:\n-//!\n-//! <pre class=\"rust\">\n-//! i     case insensitive\n-//! m     multi-line mode: ^ and $ match begin/end of line\n-//! s     allow . to match \\n\n-//! U     swap the meaning of x* and x*?\n-//! </pre>\n-//!\n-//! Here's an example that matches case insensitively for only part of the\n-//! expression:\n-//!\n-//! ```rust\n-//! # #![feature(phase)]\n-//! # extern crate regex; #[phase(plugin)] extern crate regex_macros;\n-//! # fn main() {\n-//! let re = regex!(r\"(?i)a+(?-i)b+\");\n-//! let cap = re.captures(\"AaAaAbbBBBb\").unwrap();\n-//! assert_eq!(cap.at(0), Some(\"AaAaAbb\"));\n-//! # }\n-//! ```\n-//!\n-//! Notice that the `a+` matches either `a` or `A`, but the `b+` only matches\n-//! `b`.\n-//!\n-//! ## Escape sequences\n-//!\n-//! <pre class=\"rust\">\n-//! \\*         literal *, works for any punctuation character: \\.+*?()|[]{}^$\n-//! \\a         bell (\\x07)\n-//! \\f         form feed (\\x0C)\n-//! \\t         horizontal tab\n-//! \\n         new line\n-//! \\r         carriage return\n-//! \\v         vertical tab (\\x0B)\n-//! \\123       octal character code (up to three digits)\n-//! \\x7F       hex character code (exactly two digits)\n-//! \\x{10FFFF} any hex character code corresponding to a Unicode code point\n-//! </pre>\n-//!\n-//! ## Perl character classes (Unicode friendly)\n-//!\n-//! These classes are based on the definitions provided in\n-//! [UTS#18](http://www.unicode.org/reports/tr18/#Compatibility_Properties):\n-//!\n-//! <pre class=\"rust\">\n-//! \\d     digit (\\p{Nd})\n-//! \\D     not digit\n-//! \\s     whitespace (\\p{White_Space})\n-//! \\S     not whitespace\n-//! \\w     word character (\\p{Alphabetic} + \\p{M} + \\d + \\p{Pc} + \\p{Join_Control})\n-//! \\W     not word character\n-//! </pre>\n-//!\n-//! ## ASCII character classes\n-//!\n-//! <pre class=\"rust\">\n-//! [:alnum:]    alphanumeric ([0-9A-Za-z])\n-//! [:alpha:]    alphabetic ([A-Za-z])\n-//! [:ascii:]    ASCII ([\\x00-\\x7F])\n-//! [:blank:]    blank ([\\t ])\n-//! [:cntrl:]    control ([\\x00-\\x1F\\x7F])\n-//! [:digit:]    digits ([0-9])\n-//! [:graph:]    graphical ([!-~])\n-//! [:lower:]    lower case ([a-z])\n-//! [:print:]    printable ([ -~])\n-//! [:punct:]    punctuation ([!-/:-@[-`{-~])\n-//! [:space:]    whitespace ([\\t\\n\\v\\f\\r ])\n-//! [:upper:]    upper case ([A-Z])\n-//! [:word:]     word characters ([0-9A-Za-z_])\n-//! [:xdigit:]   hex digit ([0-9A-Fa-f])\n-//! </pre>\n-//!\n-//! # Untrusted input\n-//!\n-//! There are two factors to consider here: untrusted regular expressions and\n-//! untrusted search text.\n-//!\n-//! Currently, there are no counter-measures in place to prevent a malicious\n-//! user from writing an expression that may use a lot of resources. One such\n-//! example is to repeat counted repetitions: `((a{100}){100}){100}` will try\n-//! to repeat the `a` instruction `100^3` times. Essentially, this means it's\n-//! very easy for an attacker to exhaust your system's memory if they are\n-//! allowed to execute arbitrary regular expressions. A possible solution to\n-//! this is to impose a hard limit on the size of a compiled expression, but it\n-//! does not yet exist.\n-//!\n-//! The story is a bit better with untrusted search text, since this crate's\n-//! implementation provides `O(nm)` search where `n` is the number of\n-//! characters in the search text and `m` is the number of instructions in a\n-//! compiled expression.\n+//! For official documentation, see the rust-lang/regex crate\n \n #![crate_name = \"regex\"]\n #![crate_type = \"rlib\"]"}, {"sha": "1840a3343e63c424294a4d214ef83d27159bf2a2", "filename": "src/libregex/re.rs", "status": "modified", "additions": 1, "deletions": 269, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -14,7 +14,7 @@ pub use self::Regex::*;\n use std::borrow::IntoCow;\n use std::collections::HashMap;\n use std::fmt;\n-use std::str::CowString;\n+use std::string::CowString;\n \n use compile::Program;\n use parse;\n@@ -51,59 +51,6 @@ pub fn is_match(regex: &str, text: &str) -> Result<bool, parse::Error> {\n }\n \n /// A compiled regular expression\n-///\n-/// It is represented as either a sequence of bytecode instructions (dynamic)\n-/// or as a specialized Rust function (native). It can be used to search, split\n-/// or replace text. All searching is done with an implicit `.*?` at the\n-/// beginning and end of an expression. To force an expression to match the\n-/// whole string (or a prefix or a suffix), you must use an anchor like `^` or\n-/// `$` (or `\\A` and `\\z`).\n-///\n-/// While this crate will handle Unicode strings (whether in the regular\n-/// expression or in the search text), all positions returned are **byte\n-/// indices**. Every byte index is guaranteed to be at a Unicode code point\n-/// boundary.\n-///\n-/// The lifetimes `'r` and `'t` in this crate correspond to the lifetime of a\n-/// compiled regular expression and text to search, respectively.\n-///\n-/// The only methods that allocate new strings are the string replacement\n-/// methods. All other methods (searching and splitting) return borrowed\n-/// pointers into the string given.\n-///\n-/// # Examples\n-///\n-/// Find the location of a US phone number:\n-///\n-/// ```rust\n-/// # use regex::Regex;\n-/// let re = match Regex::new(\"[0-9]{3}-[0-9]{3}-[0-9]{4}\") {\n-///     Ok(re) => re,\n-///     Err(err) => panic!(\"{}\", err),\n-/// };\n-/// assert_eq!(re.find(\"phone: 111-222-3333\"), Some((7, 19)));\n-/// ```\n-///\n-/// You can also use the `regex!` macro to compile a regular expression when\n-/// you compile your program:\n-///\n-/// ```rust\n-/// #![feature(phase)]\n-/// extern crate regex;\n-/// #[phase(plugin)] extern crate regex_macros;\n-///\n-/// fn main() {\n-///     let re = regex!(r\"\\d+\");\n-///     assert_eq!(re.find(\"123 abc\"), Some((0, 3)));\n-/// }\n-/// ```\n-///\n-/// Given an incorrect regular expression, `regex!` will cause the Rust\n-/// compiler to produce a compile time error.\n-/// Note that `regex!` will compile the expression to native Rust code, which\n-/// makes it much faster when searching text.\n-/// More details about the `regex!` macro can be found in the `regex` crate\n-/// documentation.\n #[derive(Clone)]\n pub enum Regex {\n     // The representation of `Regex` is exported to support the `regex!`\n@@ -169,46 +116,12 @@ impl Regex {\n     }\n \n     /// Returns true if and only if the regex matches the string given.\n-    ///\n-    /// # Example\n-    ///\n-    /// Test if some text contains at least one word with exactly 13\n-    /// characters:\n-    ///\n-    /// ```rust\n-    /// # #![feature(phase)]\n-    /// # extern crate regex; #[phase(plugin)] extern crate regex_macros;\n-    /// # fn main() {\n-    /// let text = \"I categorically deny having triskaidekaphobia.\";\n-    /// let matched = regex!(r\"\\b\\w{13}\\b\").is_match(text);\n-    /// assert!(matched);\n-    /// # }\n-    /// ```\n     pub fn is_match(&self, text: &str) -> bool {\n         has_match(&exec(self, Exists, text))\n     }\n \n     /// Returns the start and end byte range of the leftmost-first match in\n     /// `text`. If no match exists, then `None` is returned.\n-    ///\n-    /// Note that this should only be used if you want to discover the position\n-    /// of the match. Testing the existence of a match is faster if you use\n-    /// `is_match`.\n-    ///\n-    /// # Example\n-    ///\n-    /// Find the start and end location of the first word with exactly 13\n-    /// characters:\n-    ///\n-    /// ```rust\n-    /// # #![feature(phase)]\n-    /// # extern crate regex; #[phase(plugin)] extern crate regex_macros;\n-    /// # fn main() {\n-    /// let text = \"I categorically deny having triskaidekaphobia.\";\n-    /// let pos = regex!(r\"\\b\\w{13}\\b\").find(text);\n-    /// assert_eq!(pos, Some((2, 15)));\n-    /// # }\n-    /// ```\n     pub fn find(&self, text: &str) -> Option<(uint, uint)> {\n         let caps = exec(self, Location, text);\n         if has_match(&caps) {\n@@ -221,27 +134,6 @@ impl Regex {\n     /// Returns an iterator for each successive non-overlapping match in\n     /// `text`, returning the start and end byte indices with respect to\n     /// `text`.\n-    ///\n-    /// # Example\n-    ///\n-    /// Find the start and end location of every word with exactly 13\n-    /// characters:\n-    ///\n-    /// ```rust\n-    /// # #![feature(phase)]\n-    /// # extern crate regex; #[phase(plugin)] extern crate regex_macros;\n-    /// # fn main() {\n-    /// let text = \"Retroactively relinquishing remunerations is reprehensible.\";\n-    /// for pos in regex!(r\"\\b\\w{13}\\b\").find_iter(text) {\n-    ///     println!(\"{}\", pos);\n-    /// }\n-    /// // Output:\n-    /// // (0, 13)\n-    /// // (14, 27)\n-    /// // (28, 41)\n-    /// // (45, 58)\n-    /// # }\n-    /// ```\n     pub fn find_iter<'r, 't>(&'r self, text: &'t str) -> FindMatches<'r, 't> {\n         FindMatches {\n             re: self,\n@@ -258,51 +150,6 @@ impl Regex {\n     /// You should only use `captures` if you need access to submatches.\n     /// Otherwise, `find` is faster for discovering the location of the overall\n     /// match.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Say you have some text with movie names and their release years,\n-    /// like \"'Citizen Kane' (1941)\". It'd be nice if we could search for text\n-    /// looking like that, while also extracting the movie name and its release\n-    /// year separately.\n-    ///\n-    /// ```rust\n-    /// # #![feature(phase)]\n-    /// # extern crate regex; #[phase(plugin)] extern crate regex_macros;\n-    /// # fn main() {\n-    /// let re = regex!(r\"'([^']+)'\\s+\\((\\d{4})\\)\");\n-    /// let text = \"Not my favorite movie: 'Citizen Kane' (1941).\";\n-    /// let caps = re.captures(text).unwrap();\n-    /// assert_eq!(caps.at(1), Some(\"Citizen Kane\"));\n-    /// assert_eq!(caps.at(2), Some(\"1941\"));\n-    /// assert_eq!(caps.at(0), Some(\"'Citizen Kane' (1941)\"));\n-    /// # }\n-    /// ```\n-    ///\n-    /// Note that the full match is at capture group `0`. Each subsequent\n-    /// capture group is indexed by the order of its opening `(`.\n-    ///\n-    /// We can make this example a bit clearer by using *named* capture groups:\n-    ///\n-    /// ```rust\n-    /// # #![feature(phase)]\n-    /// # extern crate regex; #[phase(plugin)] extern crate regex_macros;\n-    /// # fn main() {\n-    /// let re = regex!(r\"'(?P<title>[^']+)'\\s+\\((?P<year>\\d{4})\\)\");\n-    /// let text = \"Not my favorite movie: 'Citizen Kane' (1941).\";\n-    /// let caps = re.captures(text).unwrap();\n-    /// assert_eq!(caps.name(\"title\"), Some(\"Citizen Kane\"));\n-    /// assert_eq!(caps.name(\"year\"), Some(\"1941\"));\n-    /// assert_eq!(caps.at(0), Some(\"'Citizen Kane' (1941)\"));\n-    /// # }\n-    /// ```\n-    ///\n-    /// Here we name the capture groups, which we can access with the `name`\n-    /// method. Note that the named capture groups are still accessible with\n-    /// `at`.\n-    ///\n-    /// The `0`th capture group is always unnamed, so it must always be\n-    /// accessed with `at(0)`.\n     pub fn captures<'t>(&self, text: &'t str) -> Option<Captures<'t>> {\n         let caps = exec(self, Submatches, text);\n         Captures::new(self, text, caps)\n@@ -311,27 +158,6 @@ impl Regex {\n     /// Returns an iterator over all the non-overlapping capture groups matched\n     /// in `text`. This is operationally the same as `find_iter` (except it\n     /// yields information about submatches).\n-    ///\n-    /// # Example\n-    ///\n-    /// We can use this to find all movie titles and their release years in\n-    /// some text, where the movie is formatted like \"'Title' (xxxx)\":\n-    ///\n-    /// ```rust\n-    /// # #![feature(phase)]\n-    /// # extern crate regex; #[phase(plugin)] extern crate regex_macros;\n-    /// # fn main() {\n-    /// let re = regex!(r\"'(?P<title>[^']+)'\\s+\\((?P<year>\\d{4})\\)\");\n-    /// let text = \"'Citizen Kane' (1941), 'The Wizard of Oz' (1939), 'M' (1931).\";\n-    /// for caps in re.captures_iter(text) {\n-    ///     println!(\"Movie: {}, Released: {}\", caps.name(\"title\"), caps.name(\"year\"));\n-    /// }\n-    /// // Output:\n-    /// // Movie: Citizen Kane, Released: 1941\n-    /// // Movie: The Wizard of Oz, Released: 1939\n-    /// // Movie: M, Released: 1931\n-    /// # }\n-    /// ```\n     pub fn captures_iter<'r, 't>(&'r self, text: &'t str)\n                                 -> FindCaptures<'r, 't> {\n         FindCaptures {\n@@ -348,20 +174,6 @@ impl Regex {\n     /// matched by the regular expression.\n     ///\n     /// This method will *not* copy the text given.\n-    ///\n-    /// # Example\n-    ///\n-    /// To split a string delimited by arbitrary amounts of spaces or tabs:\n-    ///\n-    /// ```rust\n-    /// # #![feature(phase)]\n-    /// # extern crate regex; #[phase(plugin)] extern crate regex_macros;\n-    /// # fn main() {\n-    /// let re = regex!(r\"[ \\t]+\");\n-    /// let fields: Vec<&str> = re.split(\"a b \\t  c\\td    e\").collect();\n-    /// assert_eq!(fields, vec!(\"a\", \"b\", \"c\", \"d\", \"e\"));\n-    /// # }\n-    /// ```\n     pub fn split<'r, 't>(&'r self, text: &'t str) -> RegexSplits<'r, 't> {\n         RegexSplits {\n             finder: self.find_iter(text),\n@@ -378,20 +190,6 @@ impl Regex {\n     /// in the iterator.\n     ///\n     /// This method will *not* copy the text given.\n-    ///\n-    /// # Example\n-    ///\n-    /// Get the first two words in some text:\n-    ///\n-    /// ```rust\n-    /// # #![feature(phase)]\n-    /// # extern crate regex; #[phase(plugin)] extern crate regex_macros;\n-    /// # fn main() {\n-    /// let re = regex!(r\"\\W+\");\n-    /// let fields: Vec<&str> = re.splitn(\"Hey! How are you?\", 3).collect();\n-    /// assert_eq!(fields, vec!(\"Hey\", \"How\", \"are you?\"));\n-    /// # }\n-    /// ```\n     pub fn splitn<'r, 't>(&'r self, text: &'t str, limit: uint)\n                          -> RegexSplitsN<'r, 't> {\n         RegexSplitsN {\n@@ -407,72 +205,6 @@ impl Regex {\n     /// `Captures` and returns the replaced string.\n     ///\n     /// If no match is found, then a copy of the string is returned unchanged.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Note that this function is polymorphic with respect to the replacement.\n-    /// In typical usage, this can just be a normal string:\n-    ///\n-    /// ```rust\n-    /// # #![feature(phase)]\n-    /// # extern crate regex; #[phase(plugin)] extern crate regex_macros;\n-    /// # fn main() {\n-    /// let re = regex!(\"[^01]+\");\n-    /// assert_eq!(re.replace(\"1078910\", \"\"), \"1010\");\n-    /// # }\n-    /// ```\n-    ///\n-    /// But anything satisfying the `Replacer` trait will work. For example,\n-    /// a closure of type `|&Captures| -> String` provides direct access to the\n-    /// captures corresponding to a match. This allows one to access\n-    /// submatches easily:\n-    ///\n-    /// ```rust\n-    /// # #![feature(phase)]\n-    /// # #![feature(unboxed_closures)]\n-    /// # extern crate regex; #[phase(plugin)] extern crate regex_macros;\n-    /// # use regex::Captures; fn main() {\n-    /// let re = regex!(r\"([^,\\s]+),\\s+(\\S+)\");\n-    /// let result = re.replace(\"Springsteen, Bruce\", |&: caps: &Captures| {\n-    ///     format!(\"{} {}\", caps.at(2).unwrap_or(\"\"), caps.at(1).unwrap_or(\"\"))\n-    /// });\n-    /// assert_eq!(result, \"Bruce Springsteen\");\n-    /// # }\n-    /// ```\n-    ///\n-    /// But this is a bit cumbersome to use all the time. Instead, a simple\n-    /// syntax is supported that expands `$name` into the corresponding capture\n-    /// group. Here's the last example, but using this expansion technique\n-    /// with named capture groups:\n-    ///\n-    /// ```rust\n-    /// # #![feature(phase)]\n-    /// # extern crate regex; #[phase(plugin)] extern crate regex_macros;\n-    /// # fn main() {\n-    /// let re = regex!(r\"(?P<last>[^,\\s]+),\\s+(?P<first>\\S+)\");\n-    /// let result = re.replace(\"Springsteen, Bruce\", \"$first $last\");\n-    /// assert_eq!(result, \"Bruce Springsteen\");\n-    /// # }\n-    /// ```\n-    ///\n-    /// Note that using `$2` instead of `$first` or `$1` instead of `$last`\n-    /// would produce the same result. To write a literal `$` use `$$`.\n-    ///\n-    /// Finally, sometimes you just want to replace a literal string with no\n-    /// submatch expansion. This can be done by wrapping a string with\n-    /// `NoExpand`:\n-    ///\n-    /// ```rust\n-    /// # #![feature(phase)]\n-    /// # extern crate regex; #[phase(plugin)] extern crate regex_macros;\n-    /// # fn main() {\n-    /// use regex::NoExpand;\n-    ///\n-    /// let re = regex!(r\"(?P<last>[^,\\s]+),\\s+(\\S+)\");\n-    /// let result = re.replace(\"Springsteen, Bruce\", NoExpand(\"$2 $last\"));\n-    /// assert_eq!(result, \"$2 $last\");\n-    /// # }\n-    /// ```\n     pub fn replace<R: Replacer>(&self, text: &str, rep: R) -> String {\n         self.replacen(text, 1, rep)\n     }"}, {"sha": "48cc35aa5d93cfda8f7bd1ac347acf715d6d23ec", "filename": "src/libregex/test/mod.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibregex%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibregex%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fmod.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,24 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[cfg(not(stage1))]\n-#[phase(plugin)]\n-extern crate regex_macros;\n-\n-#[cfg(not(stage1))]\n-#[path = \"bench.rs\"]\n-mod native_bench;\n-\n-#[cfg(not(stage1))]\n-#[path = \"tests.rs\"]\n-mod native_tests;\n-\n-#[cfg(not(stage1))]\n-mod native_static;\n-\n-// Due to macro scoping rules, this definition only applies for the modules\n-// defined below. Effectively, it allows us to use the same tests for both\n-// native and dynamic regexes.\n macro_rules! regex {\n     ($re:expr) => (\n         match ::regex::Regex::new($re) {"}, {"sha": "ebd1cc7e166d71e17cb7e4335c693f8c18b0c0c1", "filename": "src/libregex_macros/lib.rs", "status": "removed", "additions": 0, "deletions": 643, "changes": 643, "blob_url": "https://github.com/rust-lang/rust/blob/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=470118f3e915cdc8f936aca0640b28a7a3d8dc6c", "patch": "@@ -1,643 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! This crate provides the `regex!` macro. Its use is documented in the\n-//! `regex` crate.\n-\n-#![crate_name = \"regex_macros\"]\n-#![crate_type = \"dylib\"]\n-#![experimental = \"use the crates.io `regex_macros` library instead\"]\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-\n-#![feature(plugin_registrar, quote)]\n-#![feature(unboxed_closures)]\n-\n-extern crate regex;\n-extern crate syntax;\n-extern crate rustc;\n-\n-use std::rc::Rc;\n-\n-use syntax::ast;\n-use syntax::codemap;\n-use syntax::ext::build::AstBuilder;\n-use syntax::ext::base::{ExtCtxt, MacResult, MacExpr, DummyResult};\n-use syntax::parse::token;\n-use syntax::print::pprust;\n-use syntax::fold::Folder;\n-use syntax::ptr::P;\n-\n-use rustc::plugin::Registry;\n-\n-use regex::Regex;\n-use regex::native::{\n-    OneChar, CharClass, Any, Save, Jump, Split,\n-    Match, EmptyBegin, EmptyEnd, EmptyWordBoundary,\n-    Program, Dynamic, ExDynamic, Native,\n-    FLAG_NOCASE, FLAG_MULTI, FLAG_DOTNL, FLAG_NEGATED,\n-};\n-\n-/// For the `regex!` syntax extension. Do not use.\n-#[plugin_registrar]\n-#[doc(hidden)]\n-pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_macro(\"regex\", native);\n-}\n-\n-/// Generates specialized code for the Pike VM for a particular regular\n-/// expression.\n-///\n-/// There are two primary differences between the code generated here and the\n-/// general code in vm.rs.\n-///\n-/// 1. All heap allocation is removed. Sized vector types are used instead.\n-///    Care must be taken to make sure that these vectors are not copied\n-///    gratuitously. (If you're not sure, run the benchmarks. They will yell\n-///    at you if you do.)\n-/// 2. The main `match instruction { ... }` expressions are replaced with more\n-///    direct `match pc { ... }`. The generators can be found in\n-///    `step_insts` and `add_insts`.\n-///\n-/// Other more minor changes include eliding code when possible (although this\n-/// isn't completely thorough at the moment), and translating character class\n-/// matching from using a binary search to a simple `match` expression (see\n-/// `match_class`).\n-///\n-/// It is strongly recommended to read the dynamic implementation in vm.rs\n-/// first before trying to understand the code generator. The implementation\n-/// strategy is identical and vm.rs has comments and will be easier to follow.\n-#[allow(experimental)]\n-fn native(cx: &mut ExtCtxt, sp: codemap::Span, tts: &[ast::TokenTree])\n-          -> Box<MacResult+'static> {\n-    let regex = match parse(cx, tts) {\n-        Some(r) => r,\n-        // error is logged in 'parse' with cx.span_err\n-        None => return DummyResult::any(sp),\n-    };\n-    let re = match Regex::new(regex.as_slice()) {\n-        Ok(re) => re,\n-        Err(err) => {\n-            cx.span_err(sp, err.to_string().as_slice());\n-            return DummyResult::any(sp)\n-        }\n-    };\n-    let prog = match re {\n-        Dynamic(ExDynamic { ref prog, .. }) => prog.clone(),\n-        Native(_) => unreachable!(),\n-    };\n-\n-    let mut gen = NfaGen {\n-        cx: &*cx, sp: sp, prog: prog,\n-        names: re.names_iter().collect(), original: re.as_str().to_string(),\n-    };\n-    MacExpr::new(gen.code())\n-}\n-\n-struct NfaGen<'a> {\n-    cx: &'a ExtCtxt<'a>,\n-    sp: codemap::Span,\n-    prog: Program,\n-    names: Vec<Option<String>>,\n-    original: String,\n-}\n-\n-impl<'a> NfaGen<'a> {\n-    fn code(&mut self) -> P<ast::Expr> {\n-        // Most or all of the following things are used in the quasiquoted\n-        // expression returned.\n-        let num_cap_locs = 2 * self.prog.num_captures();\n-        let num_insts = self.prog.insts.len();\n-        let cap_names = self.vec_expr(self.names.iter(),\n-            |cx, name| match *name {\n-                Some(ref name) => {\n-                    let name = name.as_slice();\n-                    quote_expr!(cx, Some($name))\n-                }\n-                None => cx.expr_none(self.sp),\n-            }\n-        );\n-        let prefix_anchor =\n-            match self.prog.insts[1] {\n-                EmptyBegin(flags) if flags & FLAG_MULTI == 0 => true,\n-                _ => false,\n-            };\n-        let init_groups = self.vec_expr(range(0, num_cap_locs),\n-                                        |cx, _| cx.expr_none(self.sp));\n-\n-        let prefix_lit = Rc::new(self.prog.prefix.as_bytes().to_vec());\n-        let prefix_bytes = self.cx.expr_lit(self.sp, ast::LitBinary(prefix_lit));\n-\n-        let check_prefix = self.check_prefix();\n-        let step_insts = self.step_insts();\n-        let add_insts = self.add_insts();\n-        let regex = self.original.as_slice();\n-\n-        quote_expr!(self.cx, {\n-// When `regex!` is bound to a name that is not used, we have to make sure\n-// that dead_code warnings don't bubble up to the user from the generated\n-// code. Therefore, we suppress them by allowing dead_code. The effect is that\n-// the user is only warned about *their* unused variable/code, and not the\n-// unused code generated by regex!. See #14185 for an example.\n-#[allow(dead_code)]\n-static CAP_NAMES: &'static [Option<&'static str>] = &$cap_names;\n-\n-#[allow(dead_code)]\n-fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n-            start: uint, end: uint) -> Vec<Option<uint>> {\n-    #![allow(unused_imports)]\n-    #![allow(unused_mut)]\n-\n-    use regex::native::{\n-        MatchKind, Exists, Location, Submatches,\n-        StepState, StepMatchEarlyReturn, StepMatch, StepContinue,\n-        CharReader, find_prefix,\n-    };\n-\n-    return Nfa {\n-        which: which,\n-        input: input,\n-        ic: 0,\n-        chars: CharReader::new(input),\n-    }.run(start, end);\n-\n-    type Captures = [Option<uint>; $num_cap_locs];\n-\n-    struct Nfa<'t> {\n-        which: MatchKind,\n-        input: &'t str,\n-        ic: uint,\n-        chars: CharReader<'t>,\n-    }\n-\n-    impl<'t> Nfa<'t> {\n-        #[allow(unused_variables)]\n-        fn run(&mut self, start: uint, end: uint) -> Vec<Option<uint>> {\n-            let mut matched = false;\n-            let prefix_bytes: &[u8] = $prefix_bytes;\n-            let mut clist = &mut Threads::new(self.which);\n-            let mut nlist = &mut Threads::new(self.which);\n-\n-            let mut groups = $init_groups;\n-\n-            self.ic = start;\n-            let mut next_ic = self.chars.set(start);\n-            while self.ic <= end {\n-                if clist.size == 0 {\n-                    if matched {\n-                        break\n-                    }\n-                    $check_prefix\n-                }\n-                if clist.size == 0 || (!$prefix_anchor && !matched) {\n-                    self.add(clist, 0, &mut groups)\n-                }\n-\n-                self.ic = next_ic;\n-                next_ic = self.chars.advance();\n-\n-                for i in range(0, clist.size) {\n-                    let pc = clist.pc(i);\n-                    let step_state = self.step(&mut groups, nlist,\n-                                               clist.groups(i), pc);\n-                    match step_state {\n-                        StepMatchEarlyReturn =>\n-                            return vec![Some(0u), Some(0u)],\n-                        StepMatch => { matched = true; break },\n-                        StepContinue => {},\n-                    }\n-                }\n-                ::std::mem::swap(&mut clist, &mut nlist);\n-                nlist.empty();\n-            }\n-            match self.which {\n-                Exists if matched     => vec![Some(0u), Some(0u)],\n-                Exists                => vec![None, None],\n-                Location | Submatches => groups.iter().map(|x| *x).collect(),\n-            }\n-        }\n-\n-        // Sometimes `nlist` is never used (for empty regexes).\n-        #[allow(unused_variables)]\n-        #[inline]\n-        fn step(&self, groups: &mut Captures, nlist: &mut Threads,\n-                caps: &mut Captures, pc: uint) -> StepState {\n-            $step_insts\n-            StepContinue\n-        }\n-\n-        fn add(&self, nlist: &mut Threads, pc: uint,\n-               groups: &mut Captures) {\n-            if nlist.contains(pc) {\n-                return\n-            }\n-            $add_insts\n-        }\n-    }\n-\n-    struct Thread {\n-        pc: uint,\n-        groups: Captures,\n-    }\n-\n-    struct Threads {\n-        which: MatchKind,\n-        queue: [Thread; $num_insts],\n-        sparse: [uint; $num_insts],\n-        size: uint,\n-    }\n-\n-    impl Threads {\n-        fn new(which: MatchKind) -> Threads {\n-            Threads {\n-                which: which,\n-                // These unsafe blocks are used for performance reasons, as it\n-                // gives us a zero-cost initialization of a sparse set. The\n-                // trick is described in more detail here:\n-                // http://research.swtch.com/sparse\n-                // The idea here is to avoid initializing threads that never\n-                // need to be initialized, particularly for larger regexs with\n-                // a lot of instructions.\n-                queue: unsafe { ::std::mem::uninitialized() },\n-                sparse: unsafe { ::std::mem::uninitialized() },\n-                size: 0,\n-            }\n-        }\n-\n-        #[inline]\n-        fn add(&mut self, pc: uint, groups: &Captures) {\n-            let t = &mut self.queue[self.size];\n-            t.pc = pc;\n-            match self.which {\n-                Exists => {},\n-                Location => {\n-                    t.groups[0] = groups[0];\n-                    t.groups[1] = groups[1];\n-                }\n-                Submatches => {\n-                    for (slot, val) in t.groups.iter_mut().zip(groups.iter()) {\n-                        *slot = *val;\n-                    }\n-                }\n-            }\n-            self.sparse[pc] = self.size;\n-            self.size += 1;\n-        }\n-\n-        #[inline]\n-        fn add_empty(&mut self, pc: uint) {\n-            self.queue[self.size].pc = pc;\n-            self.sparse[pc] = self.size;\n-            self.size += 1;\n-        }\n-\n-        #[inline]\n-        fn contains(&self, pc: uint) -> bool {\n-            let s = self.sparse[pc];\n-            s < self.size && self.queue[s].pc == pc\n-        }\n-\n-        #[inline]\n-        fn empty(&mut self) {\n-            self.size = 0;\n-        }\n-\n-        #[inline]\n-        fn pc(&self, i: uint) -> uint {\n-            self.queue[i].pc\n-        }\n-\n-        #[inline]\n-        fn groups<'r>(&'r mut self, i: uint) -> &'r mut Captures {\n-            &mut self.queue[i].groups\n-        }\n-    }\n-}\n-\n-::regex::native::Native(::regex::native::ExNative {\n-    original: $regex,\n-    names: &CAP_NAMES,\n-    prog: exec,\n-})\n-        })\n-    }\n-\n-    // Generates code for the `add` method, which is responsible for adding\n-    // zero-width states to the next queue of states to visit.\n-    fn add_insts(&self) -> P<ast::Expr> {\n-        let arms = self.prog.insts.iter().enumerate().map(|(pc, inst)| {\n-            let nextpc = pc + 1;\n-            let body = match *inst {\n-                EmptyBegin(flags) => {\n-                    let cond =\n-                        if flags & FLAG_MULTI > 0 {\n-                            quote_expr!(self.cx,\n-                                self.chars.is_begin()\n-                                || self.chars.prev == Some('\\n')\n-                            )\n-                        } else {\n-                            quote_expr!(self.cx, self.chars.is_begin())\n-                        };\n-                    quote_expr!(self.cx, {\n-                        nlist.add_empty($pc);\n-                        if $cond { self.add(nlist, $nextpc, &mut *groups) }\n-                    })\n-                }\n-                EmptyEnd(flags) => {\n-                    let cond =\n-                        if flags & FLAG_MULTI > 0 {\n-                            quote_expr!(self.cx,\n-                                self.chars.is_end()\n-                                || self.chars.cur == Some('\\n')\n-                            )\n-                        } else {\n-                            quote_expr!(self.cx, self.chars.is_end())\n-                        };\n-                    quote_expr!(self.cx, {\n-                        nlist.add_empty($pc);\n-                        if $cond { self.add(nlist, $nextpc, &mut *groups) }\n-                    })\n-                }\n-                EmptyWordBoundary(flags) => {\n-                    let cond =\n-                        if flags & FLAG_NEGATED > 0 {\n-                            quote_expr!(self.cx, !self.chars.is_word_boundary())\n-                        } else {\n-                            quote_expr!(self.cx, self.chars.is_word_boundary())\n-                        };\n-                    quote_expr!(self.cx, {\n-                        nlist.add_empty($pc);\n-                        if $cond { self.add(nlist, $nextpc, &mut *groups) }\n-                    })\n-                }\n-                Save(slot) => {\n-                    let save = quote_expr!(self.cx, {\n-                        let old = groups[$slot];\n-                        groups[$slot] = Some(self.ic);\n-                        self.add(nlist, $nextpc, &mut *groups);\n-                        groups[$slot] = old;\n-                    });\n-                    let add = quote_expr!(self.cx, {\n-                        self.add(nlist, $nextpc, &mut *groups);\n-                    });\n-                    // If this is saving a submatch location but we request\n-                    // existence or only full match location, then we can skip\n-                    // right over it every time.\n-                    if slot > 1 {\n-                        quote_expr!(self.cx, {\n-                            nlist.add_empty($pc);\n-                            match self.which {\n-                                Submatches => $save,\n-                                Exists | Location => $add,\n-                            }\n-                        })\n-                    } else {\n-                        quote_expr!(self.cx, {\n-                            nlist.add_empty($pc);\n-                            match self.which {\n-                                Submatches | Location => $save,\n-                                Exists => $add,\n-                            }\n-                        })\n-                    }\n-                }\n-                Jump(to) => {\n-                    quote_expr!(self.cx, {\n-                        nlist.add_empty($pc);\n-                        self.add(nlist, $to, &mut *groups);\n-                    })\n-                }\n-                Split(x, y) => {\n-                    quote_expr!(self.cx, {\n-                        nlist.add_empty($pc);\n-                        self.add(nlist, $x, &mut *groups);\n-                        self.add(nlist, $y, &mut *groups);\n-                    })\n-                }\n-                // For Match, OneChar, CharClass, Any\n-                _ => quote_expr!(self.cx, nlist.add($pc, &*groups)),\n-            };\n-            self.arm_inst(pc, body)\n-        }).collect::<Vec<ast::Arm>>();\n-\n-        self.match_insts(arms)\n-    }\n-\n-    // Generates the code for the `step` method, which processes all states\n-    // in the current queue that consume a single character.\n-    fn step_insts(&self) -> P<ast::Expr> {\n-        let arms = self.prog.insts.iter().enumerate().map(|(pc, inst)| {\n-            let nextpc = pc + 1;\n-            let body = match *inst {\n-                Match => {\n-                    quote_expr!(self.cx, {\n-                        match self.which {\n-                            Exists => {\n-                                return StepMatchEarlyReturn\n-                            }\n-                            Location => {\n-                                groups[0] = caps[0];\n-                                groups[1] = caps[1];\n-                                return StepMatch\n-                            }\n-                            Submatches => {\n-                                for (slot, val) in groups.iter_mut().zip(caps.iter()) {\n-                                    *slot = *val;\n-                                }\n-                                return StepMatch\n-                            }\n-                        }\n-                    })\n-                }\n-                OneChar(c, flags) => {\n-                    if flags & FLAG_NOCASE > 0 {\n-                        let upc = c.to_uppercase();\n-                        quote_expr!(self.cx, {\n-                            let upc = self.chars.prev.map(|c| c.to_uppercase());\n-                            if upc == Some($upc) {\n-                                self.add(nlist, $nextpc, caps);\n-                            }\n-                        })\n-                    } else {\n-                        quote_expr!(self.cx, {\n-                            if self.chars.prev == Some($c) {\n-                                self.add(nlist, $nextpc, caps);\n-                            }\n-                        })\n-                    }\n-                }\n-                CharClass(ref ranges, flags) => {\n-                    let negate = flags & FLAG_NEGATED > 0;\n-                    let casei = flags & FLAG_NOCASE > 0;\n-                    let get_char =\n-                        if casei {\n-                            quote_expr!(self.cx, self.chars.prev.unwrap().to_uppercase())\n-                        } else {\n-                            quote_expr!(self.cx, self.chars.prev.unwrap())\n-                        };\n-                    let negcond =\n-                        if negate {\n-                            quote_expr!(self.cx, !found)\n-                        } else {\n-                            quote_expr!(self.cx, found)\n-                        };\n-                    let mranges = self.match_class(casei, ranges.as_slice());\n-                    quote_expr!(self.cx, {\n-                        if self.chars.prev.is_some() {\n-                            let c = $get_char;\n-                            let found = $mranges;\n-                            if $negcond {\n-                                self.add(nlist, $nextpc, caps);\n-                            }\n-                        }\n-                    })\n-                }\n-                Any(flags) => {\n-                    if flags & FLAG_DOTNL > 0 {\n-                        quote_expr!(self.cx, self.add(nlist, $nextpc, caps))\n-                    } else {\n-                        quote_expr!(self.cx, {\n-                            if self.chars.prev != Some('\\n') {\n-                                self.add(nlist, $nextpc, caps)\n-                            }\n-                            ()\n-                        })\n-                    }\n-                }\n-                // EmptyBegin, EmptyEnd, EmptyWordBoundary, Save, Jump, Split\n-                _ => self.empty_block(),\n-            };\n-            self.arm_inst(pc, body)\n-        }).collect::<Vec<ast::Arm>>();\n-\n-        self.match_insts(arms)\n-    }\n-\n-    // Translates a character class into a match expression.\n-    // This avoids a binary search (and is hopefully replaced by a jump\n-    // table).\n-    fn match_class(&self, casei: bool, ranges: &[(char, char)]) -> P<ast::Expr> {\n-        let mut arms = ranges.iter().map(|&(mut start, mut end)| {\n-            if casei {\n-                start = start.to_uppercase();\n-                end = end.to_uppercase();\n-            }\n-            let pat = self.cx.pat(self.sp, ast::PatRange(quote_expr!(self.cx, $start),\n-                                                         quote_expr!(self.cx, $end)));\n-            self.cx.arm(self.sp, vec!(pat), quote_expr!(self.cx, true))\n-        }).collect::<Vec<ast::Arm>>();\n-\n-        arms.push(self.wild_arm_expr(quote_expr!(self.cx, false)));\n-\n-        let match_on = quote_expr!(self.cx, c);\n-        self.cx.expr_match(self.sp, match_on, arms)\n-    }\n-\n-    // Generates code for checking a literal prefix of the search string.\n-    // The code is only generated if the regex *has* a literal prefix.\n-    // Otherwise, a no-op is returned.\n-    fn check_prefix(&self) -> P<ast::Expr> {\n-        if self.prog.prefix.len() == 0 {\n-            self.empty_block()\n-        } else {\n-            quote_expr!(self.cx,\n-                if clist.size == 0 {\n-                    let haystack = self.input.as_bytes()[self.ic..];\n-                    match find_prefix(prefix_bytes, haystack) {\n-                        None => break,\n-                        Some(i) => {\n-                            self.ic += i;\n-                            next_ic = self.chars.set(self.ic);\n-                        }\n-                    }\n-                }\n-            )\n-        }\n-    }\n-\n-    // Builds a `match pc { ... }` expression from a list of arms, specifically\n-    // for matching the current program counter with an instruction.\n-    // A wild-card arm is automatically added that executes a no-op. It will\n-    // never be used, but is added to satisfy the compiler complaining about\n-    // non-exhaustive patterns.\n-    fn match_insts(&self, mut arms: Vec<ast::Arm>) -> P<ast::Expr> {\n-        arms.push(self.wild_arm_expr(self.empty_block()));\n-        self.cx.expr_match(self.sp, quote_expr!(self.cx, pc), arms)\n-    }\n-\n-    fn empty_block(&self) -> P<ast::Expr> {\n-        quote_expr!(self.cx, {})\n-    }\n-\n-    // Creates a match arm for the instruction at `pc` with the expression\n-    // `body`.\n-    fn arm_inst(&self, pc: uint, body: P<ast::Expr>) -> ast::Arm {\n-        let pc_pat = self.cx.pat_lit(self.sp, quote_expr!(self.cx, $pc));\n-\n-        self.cx.arm(self.sp, vec!(pc_pat), body)\n-    }\n-\n-    // Creates a wild-card match arm with the expression `body`.\n-    fn wild_arm_expr(&self, body: P<ast::Expr>) -> ast::Arm {\n-        ast::Arm {\n-            attrs: vec!(),\n-            pats: vec!(P(ast::Pat{\n-                id: ast::DUMMY_NODE_ID,\n-                span: self.sp,\n-                node: ast::PatWild(ast::PatWildSingle),\n-            })),\n-            guard: None,\n-            body: body,\n-        }\n-    }\n-\n-\n-    // Converts `xs` to a `[x1, x2, .., xN]` expression by calling `to_expr`\n-    // on each element in `xs`.\n-    fn vec_expr<T, It, F>(&self, xs: It, mut to_expr: F) -> P<ast::Expr> where\n-        It: Iterator<Item=T>,\n-        F: FnMut(&ExtCtxt, T) -> P<ast::Expr>,\n-    {\n-        let exprs = xs.map(|x| to_expr(self.cx, x)).collect();\n-        self.cx.expr_vec(self.sp, exprs)\n-    }\n-}\n-\n-/// Looks for a single string literal and returns it.\n-/// Otherwise, logs an error with cx.span_err and returns None.\n-fn parse(cx: &mut ExtCtxt, tts: &[ast::TokenTree]) -> Option<String> {\n-    let mut parser = cx.new_parser_from_tts(tts);\n-    let entry = cx.expander().fold_expr(parser.parse_expr());\n-    let regex = match entry.node {\n-        ast::ExprLit(ref lit) => {\n-            match lit.node {\n-                ast::LitStr(ref s, _) => s.to_string(),\n-                _ => {\n-                    cx.span_err(entry.span, format!(\n-                        \"expected string literal but got `{}`\",\n-                        pprust::lit_to_string(&**lit)).as_slice());\n-                    return None\n-                }\n-            }\n-        }\n-        _ => {\n-            cx.span_err(entry.span, format!(\n-                \"expected string literal but got `{}`\",\n-                pprust::expr_to_string(&*entry)).as_slice());\n-            return None\n-        }\n-    };\n-    if !parser.eat(&token::Eof) {\n-        cx.span_err(parser.span, \"only one string literal allowed\");\n-        return None;\n-    }\n-    Some(regex)\n-}"}, {"sha": "2bf32e7bdaedee05b6d5f7e0a41b2c8ccfa1182b", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -29,7 +29,7 @@ use util::ppaux::Repr;\n use std::collections::hash_map::Entry::Vacant;\n use std::io::{self, File};\n use std::os;\n-use std::sync::atomic;\n+use std::sync::atomic::{AtomicBool, Ordering, ATOMIC_BOOL_INIT};\n use syntax::ast;\n \n fn print_help_message() {\n@@ -73,10 +73,10 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n     let output_path = {\n         let output_template = match requested_output {\n             Some(ref s) if s.as_slice() == \"help\" => {\n-                static PRINTED_YET : atomic::AtomicBool = atomic::ATOMIC_BOOL_INIT;\n-                if !PRINTED_YET.load(atomic::SeqCst) {\n+                static PRINTED_YET: AtomicBool = ATOMIC_BOOL_INIT;\n+                if !PRINTED_YET.load(Ordering::SeqCst) {\n                     print_help_message();\n-                    PRINTED_YET.store(true, atomic::SeqCst);\n+                    PRINTED_YET.store(true, Ordering::SeqCst);\n                 }\n                 return;\n             }"}, {"sha": "1480ff016b53ddbed73e5bead8c540f6fa8eec9d", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -18,7 +18,7 @@ pub use self::OptLevel::*;\n pub use self::OutputType::*;\n pub use self::DebugInfoLevel::*;\n \n-use session::{early_error, Session};\n+use session::{early_error, early_warn, Session};\n use session::search_paths::SearchPaths;\n \n use rustc_back::target::Target;\n@@ -394,7 +394,6 @@ macro_rules! cgoptions {\n \n     mod cgsetters {\n         use super::{CodegenOptions, Passes, SomePasses, AllPasses};\n-        use std::str::from_str;\n \n         $(\n             pub fn $opt(cg: &mut CodegenOptions, v: Option<&str>) -> bool {\n@@ -456,15 +455,15 @@ macro_rules! cgoptions {\n         }\n \n         fn parse_uint(slot: &mut uint, v: Option<&str>) -> bool {\n-            match v.and_then(from_str) {\n+            match v.and_then(|s| s.parse()) {\n                 Some(i) => { *slot = i; true },\n                 None => false\n             }\n         }\n \n         fn parse_opt_uint(slot: &mut Option<uint>, v: Option<&str>) -> bool {\n             match v {\n-                Some(s) => { *slot = from_str(s); slot.is_some() }\n+                Some(s) => { *slot = s.parse(); slot.is_some() }\n                 None => { *slot = None; true }\n             }\n         }\n@@ -879,22 +878,22 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     }\n \n     let parse_only = if matches.opt_present(\"parse-only\") {\n-        // FIXME(acrichto) uncomment deprecation warning\n-        // early_warn(\"--parse-only is deprecated in favor of -Z parse-only\");\n+        // FIXME(acrichto) remove this eventually\n+        early_warn(\"--parse-only is deprecated in favor of -Z parse-only\");\n         true\n     } else {\n         debugging_opts & PARSE_ONLY != 0\n     };\n     let no_trans = if matches.opt_present(\"no-trans\") {\n-        // FIXME(acrichto) uncomment deprecation warning\n-        // early_warn(\"--no-trans is deprecated in favor of -Z no-trans\");\n+        // FIXME(acrichto) remove this eventually\n+        early_warn(\"--no-trans is deprecated in favor of -Z no-trans\");\n         true\n     } else {\n         debugging_opts & NO_TRANS != 0\n     };\n     let no_analysis = if matches.opt_present(\"no-analysis\") {\n-        // FIXME(acrichto) uncomment deprecation warning\n-        // early_warn(\"--no-analysis is deprecated in favor of -Z no-analysis\");\n+        // FIXME(acrichto) remove this eventually\n+        early_warn(\"--no-analysis is deprecated in favor of -Z no-analysis\");\n         true\n     } else {\n         debugging_opts & NO_ANALYSIS != 0\n@@ -946,8 +945,8 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             }\n             Default\n         } else if matches.opt_present(\"opt-level\") {\n-            // FIXME(acrichto) uncomment deprecation warning\n-            // early_warn(\"--opt-level=N is deprecated in favor of -C opt-level=N\");\n+            // FIXME(acrichto) remove this eventually\n+            early_warn(\"--opt-level=N is deprecated in favor of -C opt-level=N\");\n             match matches.opt_str(\"opt-level\").as_ref().map(|s| s.as_slice()) {\n                 None      |\n                 Some(\"0\") => No,\n@@ -985,8 +984,8 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         }\n         FullDebugInfo\n     } else if matches.opt_present(\"debuginfo\") {\n-        // FIXME(acrichto) uncomment deprecation warning\n-        // early_warn(\"--debuginfo=N is deprecated in favor of -C debuginfo=N\");\n+        // FIXME(acrichto) remove this eventually\n+        early_warn(\"--debuginfo=N is deprecated in favor of -C debuginfo=N\");\n         match matches.opt_str(\"debuginfo\").as_ref().map(|s| s.as_slice()) {\n             Some(\"0\") => NoDebugInfo,\n             Some(\"1\") => LimitedDebugInfo,\n@@ -1054,8 +1053,8 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let cfg = parse_cfgspecs(matches.opt_strs(\"cfg\"));\n     let test = matches.opt_present(\"test\");\n     let write_dependency_info = if matches.opt_present(\"dep-info\") {\n-        // FIXME(acrichto) uncomment deprecation warning\n-        // early_warn(\"--dep-info has been deprecated in favor of --emit\");\n+        // FIXME(acrichto) remove this eventually\n+        early_warn(\"--dep-info has been deprecated in favor of --emit\");\n         (true, matches.opt_str(\"dep-info\").map(|p| Path::new(p)))\n     } else {\n         (output_types.contains(&OutputTypeDepInfo), None)\n@@ -1072,22 +1071,21 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         }\n     }).collect::<Vec<_>>();\n     if matches.opt_present(\"print-crate-name\") {\n-        // FIXME(acrichto) uncomment deprecation warning\n-        // early_warn(\"--print-crate-name has been deprecated in favor of \\\n-        //             --print crate-name\");\n+        // FIXME(acrichto) remove this eventually\n+        early_warn(\"--print-crate-name has been deprecated in favor of \\\n+                    --print crate-name\");\n         prints.push(PrintRequest::CrateName);\n     }\n     if matches.opt_present(\"print-file-name\") {\n-        // FIXME(acrichto) uncomment deprecation warning\n-        // early_warn(\"--print-file-name has been deprecated in favor of \\\n-        //             --print file-names\");\n+        // FIXME(acrichto) remove this eventually\n+        early_warn(\"--print-file-name has been deprecated in favor of \\\n+                    --print file-names\");\n         prints.push(PrintRequest::FileNames);\n     }\n \n     if !cg.remark.is_empty() && debuginfo == NoDebugInfo {\n-        // FIXME(acrichto) uncomment deprecation warning\n-        // early_warn(\"-C remark will not show source locations without \\\n-        //             --debuginfo\");\n+        early_warn(\"-C remark will not show source locations without \\\n+                    --debuginfo\");\n     }\n \n     let color = match matches.opt_str(\"color\").as_ref().map(|s| s[]) {"}, {"sha": "79bd0d4e306e452a3dd0100fff9dd84cff00d8dc", "filename": "src/librustc/util/lev_distance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibrustc%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibrustc%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Flev_distance.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -47,7 +47,7 @@ fn test_lev_distance() {\n     // Test bytelength agnosticity\n     for c in range(0u32, MAX as u32)\n              .filter_map(|i| from_u32(i))\n-             .map(|i| String::from_char(1, i)) {\n+             .map(|i| i.to_string()) {\n         assert_eq!(lev_distance(c[], c[]), 0);\n     }\n "}, {"sha": "451dbce568ee0efbd308026781511516c8952965", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -14,7 +14,6 @@\n //! module's count includes its children's.\n \n use std::cmp::Ordering;\n-use std::num::Zero;\n use std::ops::Add;\n \n use syntax::attr::{Deprecated, Experimental, Unstable, Stable, Frozen, Locked};\n@@ -26,7 +25,7 @@ use clean::{TypeTraitItem, ViewItemItem, PrimitiveItem, Stability};\n \n use html::render::cache;\n \n-#[derive(Zero, RustcEncodable, RustcDecodable, PartialEq, Eq)]\n+#[derive(RustcEncodable, RustcDecodable, PartialEq, Eq)]\n /// The counts for each stability level.\n #[derive(Copy)]\n pub struct Counts {"}, {"sha": "44bf5f89778703b90b629e34a53985f9ac53afe1", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -396,7 +396,7 @@ mod tests {\n \n         for _ in range(0u, 1000) {\n             let times = thread_rng().gen_range(1u, 100);\n-            let v = Vec::from_fn(times, |_| random::<u8>());\n+            let v = thread_rng().gen_iter::<u8>().take(times).collect::<Vec<_>>();\n             assert_eq!(v.to_base64(STANDARD)\n                         .from_base64()\n                         .unwrap(),"}, {"sha": "e31d8157332c98f5fc1c8470144208970717e72d", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -2052,7 +2052,7 @@ macro_rules! read_primitive {\n                 Json::F64(f) => Err(ExpectedError(\"Integer\".to_string(), format!(\"{}\", f))),\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n                 // is going to have a string here, as per JSON spec.\n-                Json::String(s) => match std::str::from_str(s.as_slice()) {\n+                Json::String(s) => match s.parse() {\n                     Some(f) => Ok(f),\n                     None => Err(ExpectedError(\"Number\".to_string(), s)),\n                 },"}, {"sha": "bcd87f6786d35dd3e80162865a3c307134b8125b", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -13,7 +13,6 @@\n //! Operations on ASCII strings and characters\n \n #![unstable = \"unsure about placement and naming\"]\n-#![allow(deprecated)]\n \n use core::kinds::Sized;\n use iter::IteratorExt;"}, {"sha": "9c96a9cac78310d5c0d91a3253599b4ea08abd85", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -266,10 +266,6 @@ impl CString {\n         self.buf\n     }\n \n-    /// Deprecated, use into_inner() instead\n-    #[deprecated = \"renamed to into_inner()\"]\n-    pub unsafe fn unwrap(self) -> *const libc::c_char { self.into_inner() }\n-\n     /// Return the number of bytes in the CString (not including the NUL\n     /// terminator).\n     #[inline]"}, {"sha": "4a20208f31a6ae49ad7c7a80f71eb62bcfc293c4", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -150,10 +150,6 @@ impl<T> CVec<T> {\n         self.base\n     }\n \n-    /// Deprecated, use into_inner() instead\n-    #[deprecated = \"renamed to into_inner()\"]\n-    pub unsafe fn unwrap(self) -> *mut T { self.into_inner() }\n-\n     /// Returns the number of items in this vector.\n     pub fn len(&self) -> uint { self.len }\n "}, {"sha": "651f31b205da8170b28f15ab78ba6d51d3eb03e9", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 4, "deletions": 132, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -16,7 +16,7 @@ use self::VacantEntryState::*;\n \n use borrow::BorrowFrom;\n use clone::Clone;\n-use cmp::{max, Eq, Equiv, PartialEq};\n+use cmp::{max, Eq, PartialEq};\n use default::Default;\n use fmt::{self, Show};\n use hash::{Hash, Hasher, RandomSipHasher};\n@@ -444,20 +444,6 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         table::make_hash(&self.hasher, x)\n     }\n \n-    #[allow(deprecated)]\n-    fn search_equiv<'a, Sized? Q: Hash<S> + Equiv<K>>(&'a self, q: &Q)\n-                    -> Option<FullBucketImm<'a, K, V>> {\n-        let hash = self.make_hash(q);\n-        search_hashed(&self.table, hash, |k| q.equiv(k)).into_option()\n-    }\n-\n-    #[allow(deprecated)]\n-    fn search_equiv_mut<'a, Sized? Q: Hash<S> + Equiv<K>>(&'a mut self, q: &Q)\n-                    -> Option<FullBucketMut<'a, K, V>> {\n-        let hash = self.make_hash(q);\n-        search_hashed(&mut self.table, hash, |k| q.equiv(k)).into_option()\n-    }\n-\n     /// Search for a key, yielding the index if it's found in the hashtable.\n     /// If you already have the hash for the key lying around, use\n     /// search_hashed.\n@@ -807,30 +793,6 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n-    /// Deprecated: use `contains_key` and `BorrowFrom` instead.\n-    #[deprecated = \"use contains_key and BorrowFrom instead\"]\n-    pub fn contains_key_equiv<Sized? Q: Hash<S> + Equiv<K>>(&self, key: &Q) -> bool {\n-        self.search_equiv(key).is_some()\n-    }\n-\n-    /// Deprecated: use `get` and `BorrowFrom` instead.\n-    #[deprecated = \"use get and BorrowFrom instead\"]\n-    pub fn find_equiv<'a, Sized? Q: Hash<S> + Equiv<K>>(&'a self, k: &Q) -> Option<&'a V> {\n-        self.search_equiv(k).map(|bucket| bucket.into_refs().1)\n-    }\n-\n-    /// Deprecated: use `remove` and `BorrowFrom` instead.\n-    #[deprecated = \"use remove and BorrowFrom instead\"]\n-    pub fn pop_equiv<Sized? Q:Hash<S> + Equiv<K>>(&mut self, k: &Q) -> Option<V> {\n-        if self.table.size() == 0 {\n-            return None\n-        }\n-\n-        self.reserve(1);\n-\n-        self.search_equiv_mut(k).map(|bucket| pop_internal(bucket).1)\n-    }\n-\n     /// An iterator visiting all keys in arbitrary order.\n     /// Iterator element type is `&'a K`.\n     ///\n@@ -1047,12 +1009,6 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         self.drain();\n     }\n \n-    /// Deprecated: Renamed to `get`.\n-    #[deprecated = \"Renamed to `get`\"]\n-    pub fn find(&self, k: &K) -> Option<&V> {\n-        self.get(k)\n-    }\n-\n     /// Returns a reference to the value corresponding to the key.\n     ///\n     /// The key may be any borrowed form of the map's key type, but\n@@ -1099,12 +1055,6 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         self.search(k).is_some()\n     }\n \n-    /// Deprecated: Renamed to `get_mut`.\n-    #[deprecated = \"Renamed to `get_mut`\"]\n-    pub fn find_mut(&mut self, k: &K) -> Option<&mut V> {\n-        self.get_mut(k)\n-    }\n-\n     /// Returns a mutable reference to the value corresponding to the key.\n     ///\n     /// The key may be any borrowed form of the map's key type, but\n@@ -1131,12 +1081,6 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         self.search_mut(k).map(|bucket| bucket.into_mut_refs().1)\n     }\n \n-    /// Deprecated: Renamed to `insert`.\n-    #[deprecated = \"Renamed to `insert`\"]\n-    pub fn swap(&mut self, k: K, v: V) -> Option<V> {\n-        self.insert(k, v)\n-    }\n-\n     /// Inserts a key-value pair from the map. If the key already had a value\n     /// present in the map, that value is returned. Otherwise, `None` is returned.\n     ///\n@@ -1165,12 +1109,6 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         retval\n     }\n \n-    /// Deprecated: Renamed to `remove`.\n-    #[deprecated = \"Renamed to `remove`\"]\n-    pub fn pop(&mut self, k: &K) -> Option<V> {\n-        self.remove(k)\n-    }\n-\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     ///\n@@ -1246,24 +1184,6 @@ fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHas\n     }\n }\n \n-impl<K: Eq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n-    /// Deprecated: Use `map.get(k).cloned()`.\n-    ///\n-    /// Return a copy of the value corresponding to the key.\n-    #[deprecated = \"Use `map.get(k).cloned()`\"]\n-    pub fn find_copy(&self, k: &K) -> Option<V> {\n-        self.get(k).cloned()\n-    }\n-\n-    /// Deprecated: Use `map[k].clone()`.\n-    ///\n-    /// Return a copy of the value corresponding to the key.\n-    #[deprecated = \"Use `map[k].clone()`\"]\n-    pub fn get_copy(&self, k: &K) -> V {\n-        self[*k].clone()\n-    }\n-}\n-\n #[stable]\n impl<K: Eq + Hash<S>, V: PartialEq, S, H: Hasher<S>> PartialEq for HashMap<K, V, H> {\n     fn eq(&self, other: &HashMap<K, V, H>) -> bool {\n@@ -1574,30 +1494,12 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Extend<(K, V)> for HashMap<K\n mod test_map {\n     use prelude::v1::*;\n \n-    use cmp::Equiv;\n     use super::HashMap;\n     use super::Entry::{Occupied, Vacant};\n-    use hash;\n-    use iter::{range_inclusive, range_step_inclusive};\n+    use iter::{range_inclusive, range_step_inclusive, repeat};\n     use cell::RefCell;\n     use rand::{weak_rng, Rng};\n \n-    struct KindaIntLike(int);\n-\n-    #[allow(deprecated)]\n-    impl Equiv<int> for KindaIntLike {\n-        fn equiv(&self, other: &int) -> bool {\n-            let KindaIntLike(this) = *self;\n-            this == *other\n-        }\n-    }\n-    impl<S: hash::Writer> hash::Hash<S> for KindaIntLike {\n-        fn hash(&self, state: &mut S) {\n-            let KindaIntLike(this) = *self;\n-            this.hash(state)\n-        }\n-    }\n-\n     #[test]\n     fn test_create_capacity_zero() {\n         let mut m = HashMap::with_capacity(0);\n@@ -1654,7 +1556,7 @@ mod test_map {\n     #[test]\n     fn test_drops() {\n         DROP_VECTOR.with(|slot| {\n-            *slot.borrow_mut() = Vec::from_elem(200, 0i);\n+            *slot.borrow_mut() = repeat(0i).take(200).collect();\n         });\n \n         {\n@@ -1713,7 +1615,7 @@ mod test_map {\n     #[test]\n     fn test_move_iter_drops() {\n         DROP_VECTOR.with(|v| {\n-            *v.borrow_mut() = Vec::from_elem(200, 0i);\n+            *v.borrow_mut() = repeat(0).take(200).collect();\n         });\n \n         let hm = {\n@@ -1911,15 +1813,6 @@ mod test_map {\n         assert_eq!(m.remove(&1), None);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_pop_equiv() {\n-        let mut m = HashMap::new();\n-        m.insert(1i, 2i);\n-        assert_eq!(m.pop_equiv(&KindaIntLike(1)), Some(2));\n-        assert_eq!(m.pop_equiv(&KindaIntLike(1)), None);\n-    }\n-\n     #[test]\n     fn test_iterate() {\n         let mut m = HashMap::with_capacity(4);\n@@ -1970,27 +1863,6 @@ mod test_map {\n         }\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_find_copy() {\n-        let mut m = HashMap::new();\n-        assert!(m.get(&1i).is_none());\n-\n-        for i in range(1i, 10000) {\n-            m.insert(i, i + 7);\n-            match m.find_copy(&i) {\n-                None => panic!(),\n-                Some(v) => assert_eq!(v, i + 7)\n-            }\n-            for j in range(1i, i/100) {\n-                match m.find_copy(&j) {\n-                    None => panic!(),\n-                    Some(v) => assert_eq!(v, j + 7)\n-                }\n-            }\n-        }\n-    }\n-\n     #[test]\n     fn test_eq() {\n         let mut m1 = HashMap::new();"}, {"sha": "b1824db93aad120faec507751c130125ad431919", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -12,7 +12,7 @@\n \n use borrow::BorrowFrom;\n use clone::Clone;\n-use cmp::{Eq, Equiv, PartialEq};\n+use cmp::{Eq, PartialEq};\n use core::kinds::Sized;\n use default::Default;\n use fmt::Show;\n@@ -228,13 +228,6 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n         self.map.shrink_to_fit()\n     }\n \n-    /// Deprecated: use `contains` and `BorrowFrom`.\n-    #[deprecated = \"use contains and BorrowFrom\"]\n-    #[allow(deprecated)]\n-    pub fn contains_equiv<Sized? Q: Hash<S> + Equiv<T>>(&self, value: &Q) -> bool {\n-      self.map.contains_key_equiv(value)\n-    }\n-\n     /// An iterator visiting all elements in arbitrary order.\n     /// Iterator element type is &'a T.\n     ///"}, {"sha": "4be83bfc6646d3ac7fa2becd36c7454964e34330", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -314,17 +314,9 @@\n pub use core_collections::{BinaryHeap, Bitv, BitvSet, BTreeMap, BTreeSet};\n pub use core_collections::{DList, RingBuf, VecMap};\n \n-/// Deprecated: Moved to collect-rs: https://github.com/Gankro/collect-rs/\n-#[deprecated = \"Moved to collect-rs: https://github.com/Gankro/collect-rs/\"]\n-pub use core_collections::EnumSet;\n-\n pub use core_collections::{binary_heap, bitv, bitv_set, btree_map, btree_set};\n pub use core_collections::{dlist, ring_buf, vec_map};\n \n-/// Deprecated: Moved to collect-rs: https://github.com/Gankro/collect-rs/\n-#[deprecated = \"Moved to collect-rs: https://github.com/Gankro/collect-rs/\"]\n-pub use core_collections::enum_set;\n-\n pub use self::hash_map::HashMap;\n pub use self::hash_set::HashSet;\n "}, {"sha": "c56acd38e810f2f89c380c58af5948ce4f02c4d0", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -89,10 +89,6 @@ impl<R: Reader> BufferedReader<R> {\n     ///\n     /// Note that any leftover data in the internal buffer is lost.\n     pub fn into_inner(self) -> R { self.inner }\n-\n-    /// Deprecated, use into_inner() instead\n-    #[deprecated = \"renamed to into_inner()\"]\n-    pub fn unwrap(self) -> R { self.into_inner() }\n }\n \n impl<R: Reader> Buffer for BufferedReader<R> {\n@@ -198,10 +194,6 @@ impl<W: Writer> BufferedWriter<W> {\n         self.flush_buf().unwrap();\n         self.inner.take().unwrap()\n     }\n-\n-    /// Deprecated, use into_inner() instead\n-    #[deprecated = \"renamed to into_inner()\"]\n-    pub fn unwrap(self) -> W { self.into_inner() }\n }\n \n impl<W: Writer> Writer for BufferedWriter<W> {\n@@ -262,10 +254,6 @@ impl<W: Writer> LineBufferedWriter<W> {\n     ///\n     /// The internal buffer is flushed before returning the writer.\n     pub fn into_inner(self) -> W { self.inner.into_inner() }\n-\n-    /// Deprecated, use into_inner() instead\n-    #[deprecated = \"renamed to into_inner()\"]\n-    pub fn unwrap(self) -> W { self.into_inner() }\n }\n \n impl<W: Writer> Writer for LineBufferedWriter<W> {\n@@ -374,10 +362,6 @@ impl<S: Stream> BufferedStream<S> {\n         let InternalBufferedWriter(w) = self.inner.inner;\n         w.into_inner()\n     }\n-\n-    /// Deprecated, use into_inner() instead\n-    #[deprecated = \"renamed to into_inner()\"]\n-    pub fn unwrap(self) -> S { self.into_inner() }\n }\n \n impl<S: Stream> Buffer for BufferedStream<S> {"}, {"sha": "af08eea210e7f982124be0a110ceb46b49df8d4b", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -518,7 +518,7 @@ mod bench {\n         ({\n             use super::u64_from_be_bytes;\n \n-            let data = Vec::from_fn($stride*100+$start_index, |i| i as u8);\n+            let data = range(0u8, $stride*100+$start_index).collect::<Vec<_>>();\n             let mut sum = 0u64;\n             $b.iter(|| {\n                 let mut i = $start_index;"}, {"sha": "5c17644a1ace7834e118dfdd53cd0d00534d2471", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -12,8 +12,6 @@\n \n //! Readers and Writers for in-memory buffers\n \n-#![allow(deprecated)]\n-\n use cmp::min;\n use option::Option::None;\n use result::Result::{Err, Ok};\n@@ -70,6 +68,7 @@ pub struct MemWriter {\n     buf: Vec<u8>,\n }\n \n+#[allow(deprecated)]\n impl MemWriter {\n     /// Create a new `MemWriter`.\n     #[inline]\n@@ -96,10 +95,6 @@ impl MemWriter {\n     /// Unwraps this `MemWriter`, returning the underlying buffer\n     #[inline]\n     pub fn into_inner(self) -> Vec<u8> { self.buf }\n-\n-    /// Deprecated, use into_inner() instead\n-    #[deprecated = \"renamed to into_inner()\"]\n-    pub fn unwrap(self) -> Vec<u8> { self.into_inner() }\n }\n \n impl Writer for MemWriter {\n@@ -155,10 +150,6 @@ impl MemReader {\n     /// Unwraps this `MemReader`, returning the underlying buffer\n     #[inline]\n     pub fn into_inner(self) -> Vec<u8> { self.buf }\n-\n-    /// Deprecated, use into_inner() instead\n-    #[deprecated = \"renamed to into_inner()\"]\n-    pub fn unwrap(self) -> Vec<u8> { self.into_inner() }\n }\n \n impl Reader for MemReader {\n@@ -401,10 +392,11 @@ mod test {\n     extern crate \"test\" as test_crate;\n     use prelude::v1::*;\n \n-    use super::*;\n     use io::{SeekSet, SeekCur, SeekEnd};\n     use io;\n+    use iter::repeat;\n     use self::test_crate::Bencher;\n+    use super::*;\n \n     #[test]\n     fn test_vec_writer() {\n@@ -664,7 +656,7 @@ mod test {\n     }\n \n     fn do_bench_mem_writer(b: &mut Bencher, times: uint, len: uint) {\n-        let src: Vec<u8> = Vec::from_elem(len, 5);\n+        let src: Vec<u8> = repeat(5).take(len).collect();\n \n         b.bytes = (times * len) as u64;\n         b.iter(|| {\n@@ -673,7 +665,7 @@ mod test {\n                 wr.write(src.as_slice()).unwrap();\n             }\n \n-            let v = wr.unwrap();\n+            let v = wr.into_inner();\n             assert_eq!(v.len(), times * len);\n             assert!(v.iter().all(|x| *x == 5));\n         });"}, {"sha": "ae401a04a96f0a23db4d662ee0fd5658a755745a", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -263,7 +263,6 @@ pub use self::timer::Timer;\n pub use self::net::ip::IpAddr;\n pub use self::net::tcp::TcpListener;\n pub use self::net::tcp::TcpStream;\n-pub use self::net::udp::UdpStream;\n pub use self::pipe::PipeStream;\n pub use self::process::{Process, Command};\n pub use self::tempfile::TempDir;\n@@ -862,23 +861,6 @@ pub trait Reader {\n     }\n }\n \n-/// A reader which can be converted to a RefReader.\n-#[deprecated = \"use ByRefReader instead\"]\n-pub trait AsRefReader {\n-    /// Creates a wrapper around a mutable reference to the reader.\n-    ///\n-    /// This is useful to allow applying adaptors while still\n-    /// retaining ownership of the original value.\n-    fn by_ref<'a>(&'a mut self) -> RefReader<'a, Self>;\n-}\n-\n-#[allow(deprecated)]\n-impl<T: Reader> AsRefReader for T {\n-    fn by_ref<'a>(&'a mut self) -> RefReader<'a, T> {\n-        RefReader { inner: self }\n-    }\n-}\n-\n /// A reader which can be converted to a RefReader.\n pub trait ByRefReader {\n     /// Creates a wrapper around a mutable reference to the reader.\n@@ -1242,24 +1224,6 @@ pub trait Writer {\n     }\n }\n \n-/// A writer which can be converted to a RefWriter.\n-#[deprecated = \"use ByRefWriter instead\"]\n-pub trait AsRefWriter {\n-    /// Creates a wrapper around a mutable reference to the writer.\n-    ///\n-    /// This is useful to allow applying wrappers while still\n-    /// retaining ownership of the original value.\n-    #[inline]\n-    fn by_ref<'a>(&'a mut self) -> RefWriter<'a, Self>;\n-}\n-\n-#[allow(deprecated)]\n-impl<T: Writer> AsRefWriter for T {\n-    fn by_ref<'a>(&'a mut self) -> RefWriter<'a, T> {\n-        RefWriter { inner: self }\n-    }\n-}\n-\n /// A writer which can be converted to a RefWriter.\n pub trait ByRefWriter {\n     /// Creates a wrapper around a mutable reference to the writer.\n@@ -1847,64 +1811,6 @@ bitflags! {\n \n         #[doc = \"All possible permissions enabled.\"]\n         const ALL_PERMISSIONS = USER_RWX.bits | GROUP_RWX.bits | OTHER_RWX.bits,\n-\n-        // Deprecated names\n-        #[allow(non_upper_case_globals)]\n-        #[deprecated = \"use USER_READ instead\"]\n-        const UserRead     = USER_READ.bits,\n-        #[allow(non_upper_case_globals)]\n-        #[deprecated = \"use USER_WRITE instead\"]\n-        const UserWrite    = USER_WRITE.bits,\n-        #[allow(non_upper_case_globals)]\n-        #[deprecated = \"use USER_EXECUTE instead\"]\n-        const UserExecute  = USER_EXECUTE.bits,\n-        #[allow(non_upper_case_globals)]\n-        #[deprecated = \"use GROUP_READ instead\"]\n-        const GroupRead    = GROUP_READ.bits,\n-        #[allow(non_upper_case_globals)]\n-        #[deprecated = \"use GROUP_WRITE instead\"]\n-        const GroupWrite   = GROUP_WRITE.bits,\n-        #[allow(non_upper_case_globals)]\n-        #[deprecated = \"use GROUP_EXECUTE instead\"]\n-        const GroupExecute = GROUP_EXECUTE.bits,\n-        #[allow(non_upper_case_globals)]\n-        #[deprecated = \"use OTHER_READ instead\"]\n-        const OtherRead    = OTHER_READ.bits,\n-        #[allow(non_upper_case_globals)]\n-        #[deprecated = \"use OTHER_WRITE instead\"]\n-        const OtherWrite   = OTHER_WRITE.bits,\n-        #[allow(non_upper_case_globals)]\n-        #[deprecated = \"use OTHER_EXECUTE instead\"]\n-        const OtherExecute = OTHER_EXECUTE.bits,\n-\n-        #[allow(non_upper_case_globals)]\n-        #[deprecated = \"use USER_RWX instead\"]\n-        const UserRWX  = USER_RWX.bits,\n-        #[allow(non_upper_case_globals)]\n-        #[deprecated = \"use GROUP_RWX instead\"]\n-        const GroupRWX = GROUP_RWX.bits,\n-        #[allow(non_upper_case_globals)]\n-        #[deprecated = \"use OTHER_RWX instead\"]\n-        const OtherRWX = OTHER_RWX.bits,\n-\n-        #[doc = \"Deprecated: use `USER_FILE` instead.\"]\n-        #[allow(non_upper_case_globals)]\n-        #[deprecated = \"use USER_FILE instead\"]\n-        const UserFile = USER_FILE.bits,\n-\n-        #[doc = \"Deprecated: use `USER_DIR` instead.\"]\n-        #[allow(non_upper_case_globals)]\n-        #[deprecated = \"use USER_DIR instead\"]\n-        const UserDir  = USER_DIR.bits,\n-        #[doc = \"Deprecated: use `USER_EXEC` instead.\"]\n-        #[allow(non_upper_case_globals)]\n-        #[deprecated = \"use USER_EXEC instead\"]\n-        const UserExec = USER_EXEC.bits,\n-\n-        #[doc = \"Deprecated: use `ALL_PERMISSIONS` instead\"]\n-        #[allow(non_upper_case_globals)]\n-        #[deprecated = \"use ALL_PERMISSIONS instead\"]\n-        const AllPermissions = ALL_PERMISSIONS.bits,\n     }\n }\n "}, {"sha": "a4db0d4f5de773ef4967800b5f25cbd0634c8a42", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 1, "deletions": 156, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -17,10 +17,8 @@\n \n use clone::Clone;\n use io::net::ip::{SocketAddr, IpAddr, ToSocketAddr};\n-use io::{Reader, Writer, IoResult};\n-use ops::FnOnce;\n+use io::IoResult;\n use option::Option;\n-use result::Result::{Ok, Err};\n use sys::udp::UdpSocket as UdpSocketImp;\n use sys_common;\n \n@@ -88,21 +86,6 @@ impl UdpSocket {\n         super::with_addresses(addr, |addr| self.inner.send_to(buf, addr))\n     }\n \n-    /// Creates a `UdpStream`, which allows use of the `Reader` and `Writer`\n-    /// traits to receive and send data from the same address. This transfers\n-    /// ownership of the socket to the stream.\n-    ///\n-    /// Note that this call does not perform any actual network communication,\n-    /// because UDP is a datagram protocol.\n-    #[deprecated = \"`UdpStream` has been deprecated\"]\n-    #[allow(deprecated)]\n-    pub fn connect(self, other: SocketAddr) -> UdpStream {\n-        UdpStream {\n-            socket: self,\n-            connected_to: other,\n-        }\n-    }\n-\n     /// Returns the socket address that this socket was created from.\n     pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n         self.inner.socket_name()\n@@ -192,59 +175,6 @@ impl sys_common::AsInner<UdpSocketImp> for UdpSocket {\n     }\n }\n \n-/// A type that allows convenient usage of a UDP stream connected to one\n-/// address via the `Reader` and `Writer` traits.\n-///\n-/// # Note\n-///\n-/// This structure has been deprecated because `Reader` is a stream-oriented API but UDP\n-/// is a packet-oriented protocol. Every `Reader` method will read a whole packet and\n-/// throw all superfluous bytes away so that they are no longer available for further\n-/// method calls.\n-#[deprecated]\n-pub struct UdpStream {\n-    socket: UdpSocket,\n-    connected_to: SocketAddr\n-}\n-\n-impl UdpStream {\n-    /// Allows access to the underlying UDP socket owned by this stream. This\n-    /// is useful to, for example, use the socket to send data to hosts other\n-    /// than the one that this stream is connected to.\n-    pub fn as_socket<T, F>(&mut self, f: F) -> T where\n-        F: FnOnce(&mut UdpSocket) -> T,\n-    {\n-        f(&mut self.socket)\n-    }\n-\n-    /// Consumes this UDP stream and returns out the underlying socket.\n-    pub fn disconnect(self) -> UdpSocket {\n-        self.socket\n-    }\n-}\n-\n-impl Reader for UdpStream {\n-    /// Returns the next non-empty message from the specified address.\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        let peer = self.connected_to;\n-        self.as_socket(|sock| {\n-            loop {\n-                let (nread, src) = try!(sock.recv_from(buf));\n-                if nread > 0 && src == peer {\n-                    return Ok(nread);\n-                }\n-            }\n-        })\n-    }\n-}\n-\n-impl Writer for UdpStream {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let connected_to = self.connected_to;\n-        self.as_socket(|sock| sock.send_to(buf, connected_to))\n-    }\n-}\n-\n #[cfg(test)]\n #[allow(experimental)]\n mod test {\n@@ -337,91 +267,6 @@ mod test {\n         }\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn stream_smoke_test_ip4() {\n-        let server_ip = next_test_ip4();\n-        let client_ip = next_test_ip4();\n-        let dummy_ip = next_test_ip4();\n-        let (tx1, rx1) = channel();\n-        let (tx2, rx2) = channel();\n-\n-        let _t = Thread::spawn(move|| {\n-            let send_as = |&:ip, val: &[u8]| {\n-                match UdpSocket::bind(ip) {\n-                    Ok(client) => {\n-                        let client = box client;\n-                        let mut stream = client.connect(server_ip);\n-                        stream.write(val).unwrap();\n-                    }\n-                    Err(..) => panic!()\n-                }\n-            };\n-            rx1.recv().unwrap();\n-            send_as(dummy_ip, &[98]);\n-            send_as(client_ip, &[99]);\n-            tx2.send(()).unwrap();\n-        });\n-\n-        match UdpSocket::bind(server_ip) {\n-            Ok(server) => {\n-                let server = box server;\n-                let mut stream = server.connect(client_ip);\n-                tx1.send(()).unwrap();\n-                let mut buf = [0];\n-                match stream.read(&mut buf) {\n-                    Ok(nread) => {\n-                        assert_eq!(nread, 1);\n-                        assert_eq!(buf[0], 99);\n-                    }\n-                    Err(..) => panic!(),\n-                }\n-            }\n-            Err(..) => panic!()\n-        }\n-        rx2.recv().unwrap();\n-    }\n-\n-    #[test]\n-    #[allow(deprecated)]\n-    fn stream_smoke_test_ip6() {\n-        let server_ip = next_test_ip6();\n-        let client_ip = next_test_ip6();\n-        let (tx1, rx1) = channel();\n-        let (tx2, rx2) = channel();\n-\n-        let _t = Thread::spawn(move|| {\n-            match UdpSocket::bind(client_ip) {\n-                Ok(client) => {\n-                    let client = box client;\n-                    let mut stream = client.connect(server_ip);\n-                    rx1.recv().unwrap();\n-                    stream.write(&[99]).unwrap();\n-                }\n-                Err(..) => panic!()\n-            }\n-            tx2.send(()).unwrap();\n-        });\n-\n-        match UdpSocket::bind(server_ip) {\n-            Ok(server) => {\n-                let server = box server;\n-                let mut stream = server.connect(client_ip);\n-                tx1.send(()).unwrap();\n-                let mut buf = [0];\n-                match stream.read(&mut buf) {\n-                    Ok(nread) => {\n-                        assert_eq!(nread, 1);\n-                        assert_eq!(buf[0], 99);\n-                    }\n-                    Err(..) => panic!()\n-                }\n-            }\n-            Err(..) => panic!()\n-        }\n-        rx2.recv().unwrap();\n-    }\n-\n     pub fn socket_name(addr: SocketAddr) {\n         let server = UdpSocket::bind(addr);\n "}, {"sha": "45e0dd4e8e5dfd7fa5871871a59e21dd89c39f85", "filename": "src/libstd/io/tempfile.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fio%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fio%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftempfile.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -19,7 +19,7 @@ use option::Option::{None, Some};\n use os;\n use path::{Path, GenericPath};\n use result::Result::{Ok, Err};\n-use sync::atomic;\n+use sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n \n /// A wrapper for a path to temporary directory implementing automatic\n /// scope-based deletion.\n@@ -90,14 +90,14 @@ impl TempDir {\n             return TempDir::new_in(&abs_tmpdir, suffix);\n         }\n \n-        static CNT: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n+        static CNT: AtomicUint = ATOMIC_UINT_INIT;\n \n         let mut attempts = 0u;\n         loop {\n             let filename =\n                 format!(\"rs-{}-{}-{}\",\n                         unsafe { libc::getpid() },\n-                        CNT.fetch_add(1, atomic::SeqCst),\n+                        CNT.fetch_add(1, Ordering::SeqCst),\n                         suffix);\n             let p = tmpdir.join(filename);\n             match fs::mkdir(&p, io::USER_RWX) {\n@@ -129,10 +129,6 @@ impl TempDir {\n         tmpdir.path.take().unwrap()\n     }\n \n-    /// Deprecated, use into_inner() instead\n-    #[deprecated = \"renamed to into_inner()\"]\n-    pub fn unwrap(self) -> Path { self.into_inner() }\n-\n     /// Access the wrapped `std::path::Path` to the temporary directory.\n     pub fn path<'a>(&'a self) -> &'a Path {\n         self.path.as_ref().unwrap()"}, {"sha": "3ce56c907b33d0dc2eceb49ca917fefcbeaa0cb7", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -17,12 +17,12 @@ use prelude::v1::*;\n use libc;\n use os;\n use std::io::net::ip::*;\n-use sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Relaxed};\n+use sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n \n /// Get a port number, starting at 9600, for use in tests\n pub fn next_test_port() -> u16 {\n     static NEXT_OFFSET: AtomicUint = ATOMIC_UINT_INIT;\n-    base_port() + NEXT_OFFSET.fetch_add(1, Relaxed) as u16\n+    base_port() + NEXT_OFFSET.fetch_add(1, Ordering::Relaxed) as u16\n }\n \n /// Get a temporary path which could be the location of a unix socket\n@@ -34,7 +34,7 @@ pub fn next_test_unix() -> Path {\n     let string = format!(\"rust-test-unix-path-{}-{}-{}\",\n                          base_port(),\n                          unsafe {libc::getpid()},\n-                         COUNT.fetch_add(1, Relaxed));\n+                         COUNT.fetch_add(1, Ordering::Relaxed));\n     if cfg!(unix) {\n         os::tmpdir().join(string)\n     } else {"}, {"sha": "86fa68d63ac899ac1db577153a3915fce49bc415", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -30,10 +30,6 @@ impl<R: Reader> LimitReader<R> {\n     /// Consumes the `LimitReader`, returning the underlying `Reader`.\n     pub fn into_inner(self) -> R { self.inner }\n \n-    /// Deprecated, use into_inner() instead\n-    #[deprecated = \"renamed to into_inner\"]\n-    pub fn unwrap(self) -> R { self.into_inner() }\n-\n     /// Returns the number of bytes that can be read before the `LimitReader`\n     /// will return EOF.\n     ///\n@@ -219,10 +215,6 @@ impl<R: Reader, W: Writer> TeeReader<R, W> {\n         let TeeReader { reader, writer } = self;\n         (reader, writer)\n     }\n-\n-    /// Deprecated, use into_inner() instead\n-    #[deprecated = \"renamed to into_inner\"]\n-    pub fn unwrap(self) -> (R, W) { self.into_inner() }\n }\n \n impl<R: Reader, W: Writer> Reader for TeeReader<R, W> {"}, {"sha": "608ad9882b97719fe487fdcd08b510d49fb82c73", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -226,7 +226,6 @@ pub mod hash;\n \n /* Threads and communication */\n \n-pub mod task;\n pub mod thread;\n pub mod sync;\n "}, {"sha": "c126eb1d6cf17cd5fbe81fbf41d8f51a2250965a", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -21,12 +21,8 @@\n #[cfg(test)] use ops::{Add, Sub, Mul, Div, Rem};\n #[cfg(test)] use kinds::Copy;\n \n-pub use core::num::{Num, div_rem, Zero, zero, One, one};\n-pub use core::num::{Unsigned, pow, Bounded};\n-pub use core::num::{Primitive, Int, SignedInt, UnsignedInt};\n+pub use core::num::{Int, SignedInt, UnsignedInt};\n pub use core::num::{cast, FromPrimitive, NumCast, ToPrimitive};\n-pub use core::num::{next_power_of_two, is_power_of_two};\n-pub use core::num::{checked_next_power_of_two};\n pub use core::num::{from_int, from_i8, from_i16, from_i32, from_i64};\n pub use core::num::{from_uint, from_u8, from_u16, from_u32, from_u64};\n pub use core::num::{from_f32, from_f64};\n@@ -118,11 +114,6 @@ pub trait FloatMath: Float {\n \n // DEPRECATED\n \n-#[deprecated = \"Use `FloatMath::abs_sub`\"]\n-pub fn abs_sub<T: FloatMath>(x: T, y: T) -> T {\n-    x.abs_sub(y)\n-}\n-\n /// Helper function for testing numeric operations\n #[cfg(test)]\n pub fn test_num<T>(ten: T, two: T) where\n@@ -804,7 +795,7 @@ mod bench {\n \n     #[bench]\n     fn bench_pow_function(b: &mut Bencher) {\n-        let v = Vec::from_fn(1024u, |n| n);\n+        let v = range(0, 1024u).collect::<Vec<_>>();\n         b.iter(|| {v.iter().fold(0u, |old, new| old.pow(*new));});\n     }\n }"}, {"sha": "7cb6a8ffe077c4f99539a41a4dafaa20f2b53da9", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -15,6 +15,4 @@\n \n pub use core::u16::{BITS, BYTES, MIN, MAX};\n \n-use ops::FnOnce;\n-\n uint_module! { u16 }"}, {"sha": "43b01ddb16bd0f4cc4e9f1facd5b21d79cf75482", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -15,6 +15,4 @@\n \n pub use core::u32::{BITS, BYTES, MIN, MAX};\n \n-use ops::FnOnce;\n-\n uint_module! { u32 }"}, {"sha": "79e7f2370517447fc0835bb5f4d475eace0b0364", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -15,6 +15,4 @@\n \n pub use core::u64::{BITS, BYTES, MIN, MAX};\n \n-use ops::FnOnce;\n-\n uint_module! { u64 }"}, {"sha": "3da2fabe3f2525775dd1d6ab9470c9fbd42e5e9f", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -15,6 +15,4 @@\n \n pub use core::u8::{BITS, BYTES, MIN, MAX};\n \n-use ops::FnOnce;\n-\n uint_module! { u8 }"}, {"sha": "0fbc0953b20a2c023ff987cb4e490be599f5b4c3", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -15,6 +15,4 @@\n \n pub use core::uint::{BITS, BYTES, MIN, MAX};\n \n-use ops::FnOnce;\n-\n uint_module! { uint }"}, {"sha": "7818f4a053497e22f607bca64dbb5e724d22e74e", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 4, "deletions": 31, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -17,41 +17,14 @@ macro_rules! uint_module { ($T:ty) => (\n \n // String conversion functions and impl num -> str\n \n-/// Convert to a string as a byte slice in a given base.\n-///\n-/// Use in place of x.to_string() when you do not need to store the string permanently\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![allow(deprecated)]\n-///\n-/// std::uint::to_str_bytes(123, 10, |v| {\n-///     assert!(v == \"123\".as_bytes());\n-/// });\n-/// ```\n-#[inline]\n-#[deprecated = \"just use .to_string(), or a BufWriter with write! if you mustn't allocate\"]\n-pub fn to_str_bytes<U, F>(n: $T, radix: uint, f: F) -> U where\n-    F: FnOnce(&[u8]) -> U,\n-{\n-    use io::{Writer, Seek};\n-    // The radix can be as low as 2, so we need at least 64 characters for a\n-    // base 2 number, and then we need another for a possible '-' character.\n-    let mut buf = [0u8; 65];\n-    let amt = {\n-        let mut wr = ::io::BufWriter::new(&mut buf);\n-        (write!(&mut wr, \"{}\", ::fmt::radix(n, radix as u8))).unwrap();\n-        wr.tell().unwrap() as uint\n-    };\n-    f(buf[..amt])\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::v1::*;\n     use num::FromStrRadix;\n-    use str::from_str;\n+\n+    fn from_str<T: ::str::FromStr>(t: &str) -> Option<T> {\n+        ::str::FromStr::from_str(t)\n+    }\n \n     #[test]\n     pub fn test_from_str() {"}, {"sha": "be8f82349c2224496729c0adb2060dc888ff5a35", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -54,7 +54,7 @@ use result::Result::{Err, Ok};\n use slice::{AsSlice, SliceExt};\n use str::{Str, StrExt};\n use string::{String, ToString};\n-use sync::atomic::{AtomicInt, ATOMIC_INT_INIT, SeqCst};\n+use sync::atomic::{AtomicInt, ATOMIC_INT_INIT, Ordering};\n use vec::Vec;\n \n #[cfg(unix)] use c_str::ToCStr;\n@@ -606,13 +606,13 @@ static EXIT_STATUS: AtomicInt = ATOMIC_INT_INIT;\n ///\n /// Note that this is not synchronized against modifications of other threads.\n pub fn set_exit_status(code: int) {\n-    EXIT_STATUS.store(code, SeqCst)\n+    EXIT_STATUS.store(code, Ordering::SeqCst)\n }\n \n /// Fetches the process's current exit code. This defaults to 0 and can change\n /// by calling `set_exit_status`.\n pub fn get_exit_status() -> int {\n-    EXIT_STATUS.load(SeqCst)\n+    EXIT_STATUS.load(Ordering::SeqCst)\n }\n \n #[cfg(target_os = \"macos\")]"}, {"sha": "bf9ffbffe7d508b1f26bd331875b71493222943c", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -69,9 +69,9 @@ use iter::IteratorExt;\n use option::Option;\n use option::Option::{None, Some};\n use str;\n-use str::{CowString, MaybeOwned, Str, StrExt};\n-use string::String;\n-use slice::{AsSlice, SliceExt};\n+use str::StrExt;\n+use string::{String, CowString};\n+use slice::SliceExt;\n use vec::Vec;\n \n /// Typedef for POSIX file paths.\n@@ -896,20 +896,6 @@ impl BytesContainer for CString {\n     }\n }\n \n-#[allow(deprecated)]\n-impl<'a> BytesContainer for str::MaybeOwned<'a> {\n-    #[inline]\n-    fn container_as_bytes<'b>(&'b self) -> &'b [u8] {\n-        self.as_slice().as_bytes()\n-    }\n-    #[inline]\n-    fn container_as_str<'b>(&'b self) -> Option<&'b str> {\n-        Some(self.as_slice())\n-    }\n-    #[inline]\n-    fn is_str(_: Option<&str::MaybeOwned>) -> bool { true }\n-}\n-\n impl<'a, Sized? T: BytesContainer> BytesContainer for &'a T {\n     #[inline]\n     fn container_as_bytes(&self) -> &[u8] {"}, {"sha": "aa28c8266d193ff059562f9c7509b933ee454c92", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -421,7 +421,7 @@ pub fn sample<T, I: Iterator<Item=T>, R: Rng>(rng: &mut R,\n mod test {\n     use prelude::v1::*;\n     use super::{Rng, thread_rng, random, SeedableRng, StdRng, sample};\n-    use iter::order;\n+    use iter::{order, repeat};\n \n     struct ConstRng { i: u64 }\n     impl Rng for ConstRng {\n@@ -439,7 +439,7 @@ mod test {\n         let lengths = [0, 1, 2, 3, 4, 5, 6, 7,\n                        80, 81, 82, 83, 84, 85, 86, 87];\n         for &n in lengths.iter() {\n-            let mut v = Vec::from_elem(n, 0u8);\n+            let mut v = repeat(0u8).take(n).collect::<Vec<_>>();\n             r.fill_bytes(v.as_mut_slice());\n \n             // use this to get nicer error messages."}, {"sha": "6ae6a238c952afb21c3b4af4247b5b68cd1b1409", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -93,12 +93,12 @@ mod imp {\n                   target_arch = \"arm\",\n                   target_arch = \"aarch64\")))]\n     fn is_getrandom_available() -> bool {\n-        use sync::atomic::{AtomicBool, ATOMIC_BOOL_INIT, Relaxed};\n+        use sync::atomic::{AtomicBool, ATOMIC_BOOL_INIT, Ordering};\n \n         static GETRANDOM_CHECKED: AtomicBool = ATOMIC_BOOL_INIT;\n         static GETRANDOM_AVAILABLE: AtomicBool = ATOMIC_BOOL_INIT;\n \n-        if !GETRANDOM_CHECKED.load(Relaxed) {\n+        if !GETRANDOM_CHECKED.load(Ordering::Relaxed) {\n             let mut buf: [u8; 0] = [];\n             let result = getrandom(&mut buf);\n             let available = if result == -1 {\n@@ -107,11 +107,11 @@ mod imp {\n             } else {\n                 true\n             };\n-            GETRANDOM_AVAILABLE.store(available, Relaxed);\n-            GETRANDOM_CHECKED.store(true, Relaxed);\n+            GETRANDOM_AVAILABLE.store(available, Ordering::Relaxed);\n+            GETRANDOM_CHECKED.store(true, Ordering::Relaxed);\n             available\n         } else {\n-            GETRANDOM_AVAILABLE.load(Relaxed)\n+            GETRANDOM_AVAILABLE.load(Ordering::Relaxed)\n         }\n     }\n "}, {"sha": "578239c9cc42ee7237980ca00a840d6888e28414", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -15,15 +15,15 @@\n use prelude::v1::*;\n \n use os;\n-use sync::atomic;\n+use sync::atomic::{mod, Ordering};\n \n pub use sys::backtrace::write;\n \n // For now logging is turned off by default, and this function checks to see\n // whether the magical environment variable is present to see if it's turned on.\n pub fn log_enabled() -> bool {\n     static ENABLED: atomic::AtomicInt = atomic::ATOMIC_INT_INIT;\n-    match ENABLED.load(atomic::SeqCst) {\n+    match ENABLED.load(Ordering::SeqCst) {\n         1 => return false,\n         2 => return true,\n         _ => {}\n@@ -33,7 +33,7 @@ pub fn log_enabled() -> bool {\n         Some(..) => 2,\n         None => 1,\n     };\n-    ENABLED.store(val, atomic::SeqCst);\n+    ENABLED.store(val, Ordering::SeqCst);\n     val == 2\n }\n "}, {"sha": "a48a8edd82f60224e86a8cb53e14976c1ca069ae", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -67,7 +67,7 @@ use fmt;\n use intrinsics;\n use libc::c_void;\n use mem;\n-use sync::atomic;\n+use sync::atomic::{mod, Ordering};\n use sync::{Once, ONCE_INIT};\n \n use rt::libunwind as uw;\n@@ -543,11 +543,11 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n     // callback. Additionally, CALLBACK_CNT may briefly be higher than\n     // MAX_CALLBACKS, so we're sure to clamp it as necessary.\n     let callbacks = {\n-        let amt = CALLBACK_CNT.load(atomic::SeqCst);\n+        let amt = CALLBACK_CNT.load(Ordering::SeqCst);\n         CALLBACKS[..cmp::min(amt, MAX_CALLBACKS)]\n     };\n     for cb in callbacks.iter() {\n-        match cb.load(atomic::SeqCst) {\n+        match cb.load(Ordering::SeqCst) {\n             0 => {}\n             n => {\n                 let f: Callback = unsafe { mem::transmute(n) };\n@@ -584,18 +584,18 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n /// currently possible to unregister a callback once it has been registered.\n #[experimental]\n pub unsafe fn register(f: Callback) -> bool {\n-    match CALLBACK_CNT.fetch_add(1, atomic::SeqCst) {\n+    match CALLBACK_CNT.fetch_add(1, Ordering::SeqCst) {\n         // The invocation code has knowledge of this window where the count has\n         // been incremented, but the callback has not been stored. We're\n         // guaranteed that the slot we're storing into is 0.\n         n if n < MAX_CALLBACKS => {\n-            let prev = CALLBACKS[n].swap(mem::transmute(f), atomic::SeqCst);\n+            let prev = CALLBACKS[n].swap(mem::transmute(f), Ordering::SeqCst);\n             rtassert!(prev == 0);\n             true\n         }\n         // If we accidentally bumped the count too high, pull it back.\n         _ => {\n-            CALLBACK_CNT.store(MAX_CALLBACKS, atomic::SeqCst);\n+            CALLBACK_CNT.store(MAX_CALLBACKS, Ordering::SeqCst);\n             false\n         }\n     }"}, {"sha": "883a01fa31801bebb237d1c6de79b64a6c32ff13", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -19,7 +19,7 @@ use libc::{self, uintptr_t};\n use os;\n use slice;\n use str;\n-use sync::atomic;\n+use sync::atomic::{mod, Ordering};\n \n /// Dynamically inquire about whether we're running under V.\n /// You should usually not use this unless your test definitely\n@@ -47,15 +47,15 @@ pub fn limit_thread_creation_due_to_osx_and_valgrind() -> bool {\n \n pub fn min_stack() -> uint {\n     static MIN: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n-    match MIN.load(atomic::SeqCst) {\n+    match MIN.load(Ordering::SeqCst) {\n         0 => {}\n         n => return n - 1,\n     }\n     let amt = os::getenv(\"RUST_MIN_STACK\").and_then(|s| s.parse());\n     let amt = amt.unwrap_or(2 * 1024 * 1024);\n     // 0 is our sentinel value, so ensure that we'll never see 0 after\n     // initialization has run\n-    MIN.store(amt + 1, atomic::SeqCst);\n+    MIN.store(amt + 1, Ordering::SeqCst);\n     return amt;\n }\n "}, {"sha": "3652b45ce973b38a5954727006b253152c48ebe4", "filename": "src/libstd/sync/atomic.rs", "status": "removed", "additions": 0, "deletions": 227, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Flibstd%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Flibstd%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomic.rs?ref=470118f3e915cdc8f936aca0640b28a7a3d8dc6c", "patch": "@@ -1,227 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Atomic types\n-//!\n-//! Atomic types provide primitive shared-memory communication between\n-//! threads, and are the building blocks of other concurrent\n-//! types.\n-//!\n-//! This module defines atomic versions of a select number of primitive\n-//! types, including `AtomicBool`, `AtomicInt`, `AtomicUint`, and `AtomicOption`.\n-//! Atomic types present operations that, when used correctly, synchronize\n-//! updates between threads.\n-//!\n-//! Each method takes an `Ordering` which represents the strength of\n-//! the memory barrier for that operation. These orderings are the\n-//! same as [C++11 atomic orderings][1].\n-//!\n-//! [1]: http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync\n-//!\n-//! Atomic variables are safe to share between threads (they implement `Sync`)\n-//! but they do not themselves provide the mechanism for sharing. The most\n-//! common way to share an atomic variable is to put it into an `Arc` (an\n-//! atomically-reference-counted shared pointer).\n-//!\n-//! Most atomic types may be stored in static variables, initialized using\n-//! the provided static initializers like `INIT_ATOMIC_BOOL`. Atomic statics\n-//! are often used for lazy global initialization.\n-//!\n-//!\n-//! # Examples\n-//!\n-//! A simple spinlock:\n-//!\n-//! ```\n-//! use std::sync::Arc;\n-//! use std::sync::atomic::{AtomicUint, SeqCst};\n-//! use std::thread::Thread;\n-//!\n-//! fn main() {\n-//!     let spinlock = Arc::new(AtomicUint::new(1));\n-//!\n-//!     let spinlock_clone = spinlock.clone();\n-//!     Thread::spawn(move|| {\n-//!         spinlock_clone.store(0, SeqCst);\n-//!     }).detach();\n-//!\n-//!     // Wait for the other task to release the lock\n-//!     while spinlock.load(SeqCst) != 0 {}\n-//! }\n-//! ```\n-//!\n-//! Transferring a heap object with `AtomicOption`:\n-//!\n-//! ```\n-//! use std::sync::Arc;\n-//! use std::sync::atomic::{AtomicOption, SeqCst};\n-//! use std::thread::Thread;\n-//!\n-//! fn main() {\n-//!     struct BigObject;\n-//!\n-//!     let shared_big_object = Arc::new(AtomicOption::empty());\n-//!\n-//!     let shared_big_object_clone = shared_big_object.clone();\n-//!     Thread::spawn(move|| {\n-//!         let unwrapped_big_object = shared_big_object_clone.take(SeqCst);\n-//!         if unwrapped_big_object.is_some() {\n-//!             println!(\"got a big object from another task\");\n-//!         } else {\n-//!             println!(\"other task hasn't sent big object yet\");\n-//!         }\n-//!     }).detach();\n-//!\n-//!     shared_big_object.swap(box BigObject, SeqCst);\n-//! }\n-//! ```\n-//!\n-//! Keep a global count of live tasks:\n-//!\n-//! ```\n-//! use std::sync::atomic::{AtomicUint, SeqCst, ATOMIC_UINT_INIT};\n-//!\n-//! static GLOBAL_TASK_COUNT: AtomicUint = ATOMIC_UINT_INIT;\n-//!\n-//! let old_task_count = GLOBAL_TASK_COUNT.fetch_add(1, SeqCst);\n-//! println!(\"live tasks: {}\", old_task_count + 1);\n-//! ```\n-\n-#![stable]\n-\n-use alloc::boxed::Box;\n-use core::mem;\n-use core::prelude::{Send, Drop, None, Option, Some};\n-\n-pub use core::atomic::{AtomicBool, AtomicInt, AtomicUint, AtomicPtr};\n-pub use core::atomic::{INIT_ATOMIC_BOOL, INIT_ATOMIC_INT, INIT_ATOMIC_UINT};\n-pub use core::atomic::{ATOMIC_BOOL_INIT, ATOMIC_INT_INIT, ATOMIC_UINT_INIT};\n-pub use core::atomic::fence;\n-pub use core::atomic::Ordering::{self, Relaxed, Release, Acquire, AcqRel, SeqCst};\n-\n-/// An atomic, nullable unique pointer\n-///\n-/// This can be used as the concurrency primitive for operations that transfer\n-/// owned heap objects across tasks.\n-#[unsafe_no_drop_flag]\n-#[deprecated = \"no longer used; will eventually be replaced by a higher-level\\\n-                concept like MVar\"]\n-pub struct AtomicOption<T> {\n-    p: AtomicUint,\n-}\n-\n-#[allow(deprecated)]\n-impl<T: Send> AtomicOption<T> {\n-    /// Create a new `AtomicOption`\n-    pub fn new(p: Box<T>) -> AtomicOption<T> {\n-        unsafe { AtomicOption { p: AtomicUint::new(mem::transmute(p)) } }\n-    }\n-\n-    /// Create a new `AtomicOption` that doesn't contain a value\n-    pub fn empty() -> AtomicOption<T> { AtomicOption { p: AtomicUint::new(0) } }\n-\n-    /// Store a value, returning the old value\n-    #[inline]\n-    pub fn swap(&self, val: Box<T>, order: Ordering) -> Option<Box<T>> {\n-        let val = unsafe { mem::transmute(val) };\n-\n-        match self.p.swap(val, order) {\n-            0 => None,\n-            n => Some(unsafe { mem::transmute(n) }),\n-        }\n-    }\n-\n-    /// Remove the value, leaving the `AtomicOption` empty.\n-    #[inline]\n-    pub fn take(&self, order: Ordering) -> Option<Box<T>> {\n-        unsafe { self.swap(mem::transmute(0u), order) }\n-    }\n-\n-    /// Replace an empty value with a non-empty value.\n-    ///\n-    /// Succeeds if the option is `None` and returns `None` if so. If\n-    /// the option was already `Some`, returns `Some` of the rejected\n-    /// value.\n-    #[inline]\n-    pub fn fill(&self, val: Box<T>, order: Ordering) -> Option<Box<T>> {\n-        unsafe {\n-            let val = mem::transmute(val);\n-            let expected = mem::transmute(0u);\n-            let oldval = self.p.compare_and_swap(expected, val, order);\n-            if oldval == expected {\n-                None\n-            } else {\n-                Some(mem::transmute(val))\n-            }\n-        }\n-    }\n-\n-    /// Returns `true` if the `AtomicOption` is empty.\n-    ///\n-    /// Be careful: The caller must have some external method of ensuring the\n-    /// result does not get invalidated by another task after this returns.\n-    #[inline]\n-    pub fn is_empty(&self, order: Ordering) -> bool {\n-        self.p.load(order) as uint == 0\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<T: Send> Drop for AtomicOption<T> {\n-    fn drop(&mut self) {\n-        let _ = self.take(SeqCst);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::v1::*;\n-    use super::*;\n-\n-    #[test]\n-    fn option_empty() {\n-        let option: AtomicOption<()> = AtomicOption::empty();\n-        assert!(option.is_empty(SeqCst));\n-    }\n-\n-    #[test]\n-    fn option_swap() {\n-        let p = AtomicOption::new(box 1i);\n-        let a = box 2i;\n-\n-        let b = p.swap(a, SeqCst);\n-\n-        assert!(b == Some(box 1));\n-        assert!(p.take(SeqCst) == Some(box 2));\n-    }\n-\n-    #[test]\n-    fn option_take() {\n-        let p = AtomicOption::new(box 1i);\n-\n-        assert!(p.take(SeqCst) == Some(box 1));\n-        assert!(p.take(SeqCst) == None);\n-\n-        let p2 = box 2i;\n-        p.swap(p2, SeqCst);\n-\n-        assert!(p.take(SeqCst) == Some(box 2));\n-    }\n-\n-    #[test]\n-    fn option_fill() {\n-        let p = AtomicOption::new(box 1i);\n-        assert!(p.fill(box 2i, SeqCst).is_some()); // should fail; shouldn't leak!\n-        assert!(p.take(SeqCst) == Some(box 1));\n-\n-        assert!(p.fill(box 2i, SeqCst).is_none()); // shouldn't fail\n-        assert!(p.take(SeqCst) == Some(box 2));\n-    }\n-}"}, {"sha": "7734f655ed2936c5f1cc3be2f646e906ca7b97a6", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -10,7 +10,7 @@\n \n use prelude::v1::*;\n \n-use sync::atomic::{self, AtomicUint};\n+use sync::atomic::{AtomicUint, Ordering, ATOMIC_UINT_INIT};\n use sync::poison::{self, LockResult};\n use sys_common::condvar as sys;\n use sys_common::mutex as sys_mutex;\n@@ -88,7 +88,7 @@ unsafe impl Sync for StaticCondvar {}\n #[unstable = \"may be merged with Condvar in the future\"]\n pub const CONDVAR_INIT: StaticCondvar = StaticCondvar {\n     inner: sys::CONDVAR_INIT,\n-    mutex: atomic::ATOMIC_UINT_INIT,\n+    mutex: ATOMIC_UINT_INIT,\n };\n \n impl Condvar {\n@@ -260,7 +260,7 @@ impl StaticCondvar {\n \n     fn verify(&self, mutex: &sys_mutex::Mutex) {\n         let addr = mutex as *const _ as uint;\n-        match self.mutex.compare_and_swap(0, addr, atomic::SeqCst) {\n+        match self.mutex.compare_and_swap(0, addr, Ordering::SeqCst) {\n             // If we got out 0, then we have successfully bound the mutex to\n             // this cvar.\n             0 => {}"}, {"sha": "4c6adcc04f67cc33da0b404aa97a7d46eb4e9a56", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -65,10 +65,6 @@ impl<A> Future<A> {\n         }\n     }\n \n-    /// Deprecated, use into_inner() instead\n-    #[deprecated = \"renamed to into_inner()\"]\n-    pub fn unwrap(self) -> A { self.into_inner() }\n-\n     pub fn get_ref<'a>(&'a mut self) -> &'a A {\n         /*!\n         * Executes the future's closure and then returns a reference"}, {"sha": "6ce278726e9deac24598f0a9020bbefd99c05dd7", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -18,6 +18,7 @@\n #![experimental]\n \n pub use alloc::arc::{Arc, Weak};\n+pub use core::atomic;\n \n pub use self::mutex::{Mutex, MutexGuard, StaticMutex};\n pub use self::mutex::MUTEX_INIT;\n@@ -32,7 +33,6 @@ pub use self::poison::{PoisonError, TryLockError, TryLockResult, LockResult};\n pub use self::future::Future;\n pub use self::task_pool::TaskPool;\n \n-pub mod atomic;\n pub mod mpsc;\n \n mod barrier;"}, {"sha": "8f85dc6e043e20de7bc859204ece37fac4f5553b", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -48,7 +48,7 @@ use alloc::boxed::Box;\n use core::mem;\n use core::cell::UnsafeCell;\n \n-use sync::atomic::{AtomicPtr, Release, Acquire, AcqRel, Relaxed};\n+use sync::atomic::{AtomicPtr, Ordering};\n \n /// A result of the `pop` function.\n pub enum PopResult<T> {\n@@ -103,8 +103,8 @@ impl<T: Send> Queue<T> {\n     pub fn push(&self, t: T) {\n         unsafe {\n             let n = Node::new(Some(t));\n-            let prev = self.head.swap(n, AcqRel);\n-            (*prev).next.store(n, Release);\n+            let prev = self.head.swap(n, Ordering::AcqRel);\n+            (*prev).next.store(n, Ordering::Release);\n         }\n     }\n \n@@ -121,7 +121,7 @@ impl<T: Send> Queue<T> {\n     pub fn pop(&self) -> PopResult<T> {\n         unsafe {\n             let tail = *self.tail.get();\n-            let next = (*tail).next.load(Acquire);\n+            let next = (*tail).next.load(Ordering::Acquire);\n \n             if !next.is_null() {\n                 *self.tail.get() = next;\n@@ -132,7 +132,7 @@ impl<T: Send> Queue<T> {\n                 return Data(ret);\n             }\n \n-            if self.head.load(Acquire) == tail {Empty} else {Inconsistent}\n+            if self.head.load(Ordering::Acquire) == tail {Empty} else {Inconsistent}\n         }\n     }\n }\n@@ -143,7 +143,7 @@ impl<T: Send> Drop for Queue<T> {\n         unsafe {\n             let mut cur = *self.tail.get();\n             while !cur.is_null() {\n-                let next = (*cur).next.load(Relaxed);\n+                let next = (*cur).next.load(Ordering::Relaxed);\n                 let _: Box<Node<T>> = mem::transmute(cur);\n                 cur = next;\n             }"}, {"sha": "5c2331d0f2e9306b97762cfe5e48fc4ddb4aef6a", "filename": "src/libstd/sync/mpsc/oneshot.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -42,7 +42,7 @@ use core::prelude::*;\n use sync::mpsc::Receiver;\n use sync::mpsc::blocking::{self, SignalToken};\n use core::mem;\n-use sync::atomic;\n+use sync::atomic::{AtomicUint, Ordering};\n \n // Various states you can find a port in.\n const EMPTY: uint = 0;          // initial state: no data, no blocked reciever\n@@ -56,7 +56,7 @@ const DISCONNECTED: uint = 2;   // channel is disconnected OR upgraded\n \n pub struct Packet<T> {\n     // Internal state of the chan/port pair (stores the blocked task as well)\n-    state: atomic::AtomicUint,\n+    state: AtomicUint,\n     // One-shot data slot location\n     data: Option<T>,\n     // when used for the second time, a oneshot channel must be upgraded, and\n@@ -93,7 +93,7 @@ impl<T: Send> Packet<T> {\n         Packet {\n             data: None,\n             upgrade: NothingSent,\n-            state: atomic::AtomicUint::new(EMPTY),\n+            state: AtomicUint::new(EMPTY),\n         }\n     }\n \n@@ -107,7 +107,7 @@ impl<T: Send> Packet<T> {\n         self.data = Some(t);\n         self.upgrade = SendUsed;\n \n-        match self.state.swap(DATA, atomic::SeqCst) {\n+        match self.state.swap(DATA, Ordering::SeqCst) {\n             // Sent the data, no one was waiting\n             EMPTY => Ok(()),\n \n@@ -141,14 +141,14 @@ impl<T: Send> Packet<T> {\n     pub fn recv(&mut self) -> Result<T, Failure<T>> {\n         // Attempt to not block the task (it's a little expensive). If it looks\n         // like we're not empty, then immediately go through to `try_recv`.\n-        if self.state.load(atomic::SeqCst) == EMPTY {\n+        if self.state.load(Ordering::SeqCst) == EMPTY {\n             let (wait_token, signal_token) = blocking::tokens();\n             let ptr = unsafe { signal_token.cast_to_uint() };\n \n             // race with senders to enter the blocking state\n-            if self.state.compare_and_swap(EMPTY, ptr, atomic::SeqCst) == EMPTY {\n+            if self.state.compare_and_swap(EMPTY, ptr, Ordering::SeqCst) == EMPTY {\n                 wait_token.wait();\n-                debug_assert!(self.state.load(atomic::SeqCst) != EMPTY);\n+                debug_assert!(self.state.load(Ordering::SeqCst) != EMPTY);\n             } else {\n                 // drop the signal token, since we never blocked\n                 drop(unsafe { SignalToken::cast_from_uint(ptr) });\n@@ -159,7 +159,7 @@ impl<T: Send> Packet<T> {\n     }\n \n     pub fn try_recv(&mut self) -> Result<T, Failure<T>> {\n-        match self.state.load(atomic::SeqCst) {\n+        match self.state.load(Ordering::SeqCst) {\n             EMPTY => Err(Empty),\n \n             // We saw some data on the channel, but the channel can be used\n@@ -169,7 +169,7 @@ impl<T: Send> Packet<T> {\n             // the state changes under our feet we'd rather just see that state\n             // change.\n             DATA => {\n-                self.state.compare_and_swap(DATA, EMPTY, atomic::SeqCst);\n+                self.state.compare_and_swap(DATA, EMPTY, Ordering::SeqCst);\n                 match self.data.take() {\n                     Some(data) => Ok(data),\n                     None => unreachable!(),\n@@ -209,7 +209,7 @@ impl<T: Send> Packet<T> {\n         };\n         self.upgrade = GoUp(up);\n \n-        match self.state.swap(DISCONNECTED, atomic::SeqCst) {\n+        match self.state.swap(DISCONNECTED, Ordering::SeqCst) {\n             // If the channel is empty or has data on it, then we're good to go.\n             // Senders will check the data before the upgrade (in case we\n             // plastered over the DATA state).\n@@ -225,7 +225,7 @@ impl<T: Send> Packet<T> {\n     }\n \n     pub fn drop_chan(&mut self) {\n-        match self.state.swap(DISCONNECTED, atomic::SeqCst) {\n+        match self.state.swap(DISCONNECTED, Ordering::SeqCst) {\n             DATA | DISCONNECTED | EMPTY => {}\n \n             // If someone's waiting, we gotta wake them up\n@@ -236,7 +236,7 @@ impl<T: Send> Packet<T> {\n     }\n \n     pub fn drop_port(&mut self) {\n-        match self.state.swap(DISCONNECTED, atomic::SeqCst) {\n+        match self.state.swap(DISCONNECTED, Ordering::SeqCst) {\n             // An empty channel has nothing to do, and a remotely disconnected\n             // channel also has nothing to do b/c we're about to run the drop\n             // glue\n@@ -259,7 +259,7 @@ impl<T: Send> Packet<T> {\n     // If Ok, the value is whether this port has data, if Err, then the upgraded\n     // port needs to be checked instead of this one.\n     pub fn can_recv(&mut self) -> Result<bool, Receiver<T>> {\n-        match self.state.load(atomic::SeqCst) {\n+        match self.state.load(Ordering::SeqCst) {\n             EMPTY => Ok(false), // Welp, we tried\n             DATA => Ok(true),   // we have some un-acquired data\n             DISCONNECTED if self.data.is_some() => Ok(true), // we have data\n@@ -284,7 +284,7 @@ impl<T: Send> Packet<T> {\n     // because there is data, or fail because there is an upgrade pending.\n     pub fn start_selection(&mut self, token: SignalToken) -> SelectionResult<T> {\n         let ptr = unsafe { token.cast_to_uint() };\n-        match self.state.compare_and_swap(EMPTY, ptr, atomic::SeqCst) {\n+        match self.state.compare_and_swap(EMPTY, ptr, Ordering::SeqCst) {\n             EMPTY => SelSuccess,\n             DATA => {\n                 drop(unsafe { SignalToken::cast_from_uint(ptr) });\n@@ -322,7 +322,7 @@ impl<T: Send> Packet<T> {\n     //\n     // The return value indicates whether there's data on this port.\n     pub fn abort_selection(&mut self) -> Result<bool, Receiver<T>> {\n-        let state = match self.state.load(atomic::SeqCst) {\n+        let state = match self.state.load(Ordering::SeqCst) {\n             // Each of these states means that no further activity will happen\n             // with regard to abortion selection\n             s @ EMPTY |\n@@ -331,7 +331,7 @@ impl<T: Send> Packet<T> {\n \n             // If we've got a blocked task, then use an atomic to gain ownership\n             // of it (may fail)\n-            ptr => self.state.compare_and_swap(ptr, EMPTY, atomic::SeqCst)\n+            ptr => self.state.compare_and_swap(ptr, EMPTY, Ordering::SeqCst)\n         };\n \n         // Now that we've got ownership of our state, figure out what to do\n@@ -370,6 +370,6 @@ impl<T: Send> Packet<T> {\n #[unsafe_destructor]\n impl<T: Send> Drop for Packet<T> {\n     fn drop(&mut self) {\n-        assert_eq!(self.state.load(atomic::SeqCst), DISCONNECTED);\n+        assert_eq!(self.state.load(Ordering::SeqCst), DISCONNECTED);\n     }\n }"}, {"sha": "4295d116aed91a48fc571a2d85ebcbffacbe06c0", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 48, "deletions": 47, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -25,11 +25,12 @@ use core::prelude::*;\n use core::cmp;\n use core::int;\n \n-use sync::{atomic, Mutex, MutexGuard};\n-use sync::mpsc::mpsc_queue as mpsc;\n+use sync::atomic::{AtomicUint, AtomicInt, AtomicBool, Ordering};\n use sync::mpsc::blocking::{self, SignalToken};\n-use sync::mpsc::select::StartResult;\n+use sync::mpsc::mpsc_queue as mpsc;\n use sync::mpsc::select::StartResult::*;\n+use sync::mpsc::select::StartResult;\n+use sync::{Mutex, MutexGuard};\n use thread::Thread;\n \n const DISCONNECTED: int = int::MIN;\n@@ -41,17 +42,17 @@ const MAX_STEALS: int = 1 << 20;\n \n pub struct Packet<T> {\n     queue: mpsc::Queue<T>,\n-    cnt: atomic::AtomicInt, // How many items are on this channel\n+    cnt: AtomicInt, // How many items are on this channel\n     steals: int, // How many times has a port received without blocking?\n-    to_wake: atomic::AtomicUint, // SignalToken for wake up\n+    to_wake: AtomicUint, // SignalToken for wake up\n \n     // The number of channels which are currently using this packet.\n-    channels: atomic::AtomicInt,\n+    channels: AtomicInt,\n \n     // See the discussion in Port::drop and the channel send methods for what\n     // these are used for\n-    port_dropped: atomic::AtomicBool,\n-    sender_drain: atomic::AtomicInt,\n+    port_dropped: AtomicBool,\n+    sender_drain: AtomicInt,\n \n     // this lock protects various portions of this implementation during\n     // select()\n@@ -69,12 +70,12 @@ impl<T: Send> Packet<T> {\n     pub fn new() -> Packet<T> {\n         let p = Packet {\n             queue: mpsc::Queue::new(),\n-            cnt: atomic::AtomicInt::new(0),\n+            cnt: AtomicInt::new(0),\n             steals: 0,\n-            to_wake: atomic::AtomicUint::new(0),\n-            channels: atomic::AtomicInt::new(2),\n-            port_dropped: atomic::AtomicBool::new(false),\n-            sender_drain: atomic::AtomicInt::new(0),\n+            to_wake: AtomicUint::new(0),\n+            channels: AtomicInt::new(2),\n+            port_dropped: AtomicBool::new(false),\n+            sender_drain: AtomicInt::new(0),\n             select_lock: Mutex::new(()),\n         };\n         return p;\n@@ -98,10 +99,10 @@ impl<T: Send> Packet<T> {\n                            token: Option<SignalToken>,\n                            guard: MutexGuard<()>) {\n         token.map(|token| {\n-            assert_eq!(self.cnt.load(atomic::SeqCst), 0);\n-            assert_eq!(self.to_wake.load(atomic::SeqCst), 0);\n-            self.to_wake.store(unsafe { token.cast_to_uint() }, atomic::SeqCst);\n-            self.cnt.store(-1, atomic::SeqCst);\n+            assert_eq!(self.cnt.load(Ordering::SeqCst), 0);\n+            assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n+            self.to_wake.store(unsafe { token.cast_to_uint() }, Ordering::SeqCst);\n+            self.cnt.store(-1, Ordering::SeqCst);\n \n             // This store is a little sketchy. What's happening here is that\n             // we're transferring a blocker from a oneshot or stream channel to\n@@ -134,7 +135,7 @@ impl<T: Send> Packet<T> {\n \n     pub fn send(&mut self, t: T) -> Result<(), T> {\n         // See Port::drop for what's going on\n-        if self.port_dropped.load(atomic::SeqCst) { return Err(t) }\n+        if self.port_dropped.load(Ordering::SeqCst) { return Err(t) }\n \n         // Note that the multiple sender case is a little trickier\n         // semantically than the single sender case. The logic for\n@@ -161,12 +162,12 @@ impl<T: Send> Packet<T> {\n         // preflight check serves as the definitive \"this will never be\n         // received\". Once we get beyond this check, we have permanently\n         // entered the realm of \"this may be received\"\n-        if self.cnt.load(atomic::SeqCst) < DISCONNECTED + FUDGE {\n+        if self.cnt.load(Ordering::SeqCst) < DISCONNECTED + FUDGE {\n             return Err(t)\n         }\n \n         self.queue.push(t);\n-        match self.cnt.fetch_add(1, atomic::SeqCst) {\n+        match self.cnt.fetch_add(1, Ordering::SeqCst) {\n             -1 => {\n                 self.take_to_wake().signal();\n             }\n@@ -183,9 +184,9 @@ impl<T: Send> Packet<T> {\n             n if n < DISCONNECTED + FUDGE => {\n                 // see the comment in 'try' for a shared channel for why this\n                 // window of \"not disconnected\" is ok.\n-                self.cnt.store(DISCONNECTED, atomic::SeqCst);\n+                self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n \n-                if self.sender_drain.fetch_add(1, atomic::SeqCst) == 0 {\n+                if self.sender_drain.fetch_add(1, Ordering::SeqCst) == 0 {\n                     loop {\n                         // drain the queue, for info on the thread yield see the\n                         // discussion in try_recv\n@@ -198,7 +199,7 @@ impl<T: Send> Packet<T> {\n                         }\n                         // maybe we're done, if we're not the last ones\n                         // here, then we need to go try again.\n-                        if self.sender_drain.fetch_sub(1, atomic::SeqCst) == 1 {\n+                        if self.sender_drain.fetch_sub(1, Ordering::SeqCst) == 1 {\n                             break\n                         }\n                     }\n@@ -239,15 +240,15 @@ impl<T: Send> Packet<T> {\n     // Essentially the exact same thing as the stream decrement function.\n     // Returns true if blocking should proceed.\n     fn decrement(&mut self, token: SignalToken) -> StartResult {\n-        assert_eq!(self.to_wake.load(atomic::SeqCst), 0);\n+        assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n         let ptr = unsafe { token.cast_to_uint() };\n-        self.to_wake.store(ptr, atomic::SeqCst);\n+        self.to_wake.store(ptr, Ordering::SeqCst);\n \n         let steals = self.steals;\n         self.steals = 0;\n \n-        match self.cnt.fetch_sub(1 + steals, atomic::SeqCst) {\n-            DISCONNECTED => { self.cnt.store(DISCONNECTED, atomic::SeqCst); }\n+        match self.cnt.fetch_sub(1 + steals, Ordering::SeqCst) {\n+            DISCONNECTED => { self.cnt.store(DISCONNECTED, Ordering::SeqCst); }\n             // If we factor in our steals and notice that the channel has no\n             // data, we successfully sleep\n             n => {\n@@ -256,7 +257,7 @@ impl<T: Send> Packet<T> {\n             }\n         }\n \n-        self.to_wake.store(0, atomic::SeqCst);\n+        self.to_wake.store(0, Ordering::SeqCst);\n         drop(unsafe { SignalToken::cast_from_uint(ptr) });\n         Abort\n     }\n@@ -297,9 +298,9 @@ impl<T: Send> Packet<T> {\n             // might decrement steals.\n             Some(data) => {\n                 if self.steals > MAX_STEALS {\n-                    match self.cnt.swap(0, atomic::SeqCst) {\n+                    match self.cnt.swap(0, Ordering::SeqCst) {\n                         DISCONNECTED => {\n-                            self.cnt.store(DISCONNECTED, atomic::SeqCst);\n+                            self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n                         }\n                         n => {\n                             let m = cmp::min(n, self.steals);\n@@ -316,7 +317,7 @@ impl<T: Send> Packet<T> {\n             // See the discussion in the stream implementation for why we try\n             // again.\n             None => {\n-                match self.cnt.load(atomic::SeqCst) {\n+                match self.cnt.load(Ordering::SeqCst) {\n                     n if n != DISCONNECTED => Err(Empty),\n                     _ => {\n                         match self.queue.pop() {\n@@ -334,20 +335,20 @@ impl<T: Send> Packet<T> {\n     // Prepares this shared packet for a channel clone, essentially just bumping\n     // a refcount.\n     pub fn clone_chan(&mut self) {\n-        self.channels.fetch_add(1, atomic::SeqCst);\n+        self.channels.fetch_add(1, Ordering::SeqCst);\n     }\n \n     // Decrement the reference count on a channel. This is called whenever a\n     // Chan is dropped and may end up waking up a receiver. It's the receiver's\n     // responsibility on the other end to figure out that we've disconnected.\n     pub fn drop_chan(&mut self) {\n-        match self.channels.fetch_sub(1, atomic::SeqCst) {\n+        match self.channels.fetch_sub(1, Ordering::SeqCst) {\n             1 => {}\n             n if n > 1 => return,\n             n => panic!(\"bad number of channels left {}\", n),\n         }\n \n-        match self.cnt.swap(DISCONNECTED, atomic::SeqCst) {\n+        match self.cnt.swap(DISCONNECTED, Ordering::SeqCst) {\n             -1 => { self.take_to_wake().signal(); }\n             DISCONNECTED => {}\n             n => { assert!(n >= 0); }\n@@ -357,10 +358,10 @@ impl<T: Send> Packet<T> {\n     // See the long discussion inside of stream.rs for why the queue is drained,\n     // and why it is done in this fashion.\n     pub fn drop_port(&mut self) {\n-        self.port_dropped.store(true, atomic::SeqCst);\n+        self.port_dropped.store(true, Ordering::SeqCst);\n         let mut steals = self.steals;\n         while {\n-            let cnt = self.cnt.compare_and_swap(steals, DISCONNECTED, atomic::SeqCst);\n+            let cnt = self.cnt.compare_and_swap(steals, DISCONNECTED, Ordering::SeqCst);\n             cnt != DISCONNECTED && cnt != steals\n         } {\n             // See the discussion in 'try_recv' for why we yield\n@@ -376,8 +377,8 @@ impl<T: Send> Packet<T> {\n \n     // Consumes ownership of the 'to_wake' field.\n     fn take_to_wake(&mut self) -> SignalToken {\n-        let ptr = self.to_wake.load(atomic::SeqCst);\n-        self.to_wake.store(0, atomic::SeqCst);\n+        let ptr = self.to_wake.load(Ordering::SeqCst);\n+        self.to_wake.store(0, Ordering::SeqCst);\n         assert!(ptr != 0);\n         unsafe { SignalToken::cast_from_uint(ptr) }\n     }\n@@ -392,15 +393,15 @@ impl<T: Send> Packet<T> {\n     // This is different than the stream version because there's no need to peek\n     // at the queue, we can just look at the local count.\n     pub fn can_recv(&mut self) -> bool {\n-        let cnt = self.cnt.load(atomic::SeqCst);\n+        let cnt = self.cnt.load(Ordering::SeqCst);\n         cnt == DISCONNECTED || cnt - self.steals > 0\n     }\n \n     // increment the count on the channel (used for selection)\n     fn bump(&mut self, amt: int) -> int {\n-        match self.cnt.fetch_add(amt, atomic::SeqCst) {\n+        match self.cnt.fetch_add(amt, Ordering::SeqCst) {\n             DISCONNECTED => {\n-                self.cnt.store(DISCONNECTED, atomic::SeqCst);\n+                self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n                 DISCONNECTED\n             }\n             n => n\n@@ -444,21 +445,21 @@ impl<T: Send> Packet<T> {\n         // the channel count and figure out what we should do to make it\n         // positive.\n         let steals = {\n-            let cnt = self.cnt.load(atomic::SeqCst);\n+            let cnt = self.cnt.load(Ordering::SeqCst);\n             if cnt < 0 && cnt != DISCONNECTED {-cnt} else {0}\n         };\n         let prev = self.bump(steals + 1);\n \n         if prev == DISCONNECTED {\n-            assert_eq!(self.to_wake.load(atomic::SeqCst), 0);\n+            assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n             true\n         } else {\n             let cur = prev + steals + 1;\n             assert!(cur >= 0);\n             if prev < 0 {\n                 drop(self.take_to_wake());\n             } else {\n-                while self.to_wake.load(atomic::SeqCst) != 0 {\n+                while self.to_wake.load(Ordering::SeqCst) != 0 {\n                     Thread::yield_now();\n                 }\n             }\n@@ -479,8 +480,8 @@ impl<T: Send> Drop for Packet<T> {\n         // disconnection, but also a proper fence before the read of\n         // `to_wake`, so this assert cannot be removed with also removing\n         // the `to_wake` assert.\n-        assert_eq!(self.cnt.load(atomic::SeqCst), DISCONNECTED);\n-        assert_eq!(self.to_wake.load(atomic::SeqCst), 0);\n-        assert_eq!(self.channels.load(atomic::SeqCst), 0);\n+        assert_eq!(self.cnt.load(Ordering::SeqCst), DISCONNECTED);\n+        assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n+        assert_eq!(self.channels.load(Ordering::SeqCst), 0);\n     }\n }"}, {"sha": "e8d6e380be5de0280e6e2d4bb0f463ba7352233a", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -41,7 +41,7 @@ use alloc::boxed::Box;\n use core::mem;\n use core::cell::UnsafeCell;\n \n-use sync::atomic::{AtomicPtr, Relaxed, AtomicUint, Acquire, Release};\n+use sync::atomic::{AtomicPtr, AtomicUint, Ordering};\n \n // Node within the linked list queue of messages to send\n struct Node<T> {\n@@ -109,7 +109,7 @@ impl<T: Send> Queue<T> {\n     pub unsafe fn new(bound: uint) -> Queue<T> {\n         let n1 = Node::new();\n         let n2 = Node::new();\n-        (*n1).next.store(n2, Relaxed);\n+        (*n1).next.store(n2, Ordering::Relaxed);\n         Queue {\n             tail: UnsafeCell::new(n2),\n             tail_prev: AtomicPtr::new(n1),\n@@ -131,8 +131,8 @@ impl<T: Send> Queue<T> {\n             let n = self.alloc();\n             assert!((*n).value.is_none());\n             (*n).value = Some(t);\n-            (*n).next.store(0 as *mut Node<T>, Relaxed);\n-            (**self.head.get()).next.store(n, Release);\n+            (*n).next.store(0 as *mut Node<T>, Ordering::Relaxed);\n+            (**self.head.get()).next.store(n, Ordering::Release);\n             *self.head.get() = n;\n         }\n     }\n@@ -144,23 +144,23 @@ impl<T: Send> Queue<T> {\n         // only one subtracting from the cache).\n         if *self.first.get() != *self.tail_copy.get() {\n             if self.cache_bound > 0 {\n-                let b = self.cache_subtractions.load(Relaxed);\n-                self.cache_subtractions.store(b + 1, Relaxed);\n+                let b = self.cache_subtractions.load(Ordering::Relaxed);\n+                self.cache_subtractions.store(b + 1, Ordering::Relaxed);\n             }\n             let ret = *self.first.get();\n-            *self.first.get() = (*ret).next.load(Relaxed);\n+            *self.first.get() = (*ret).next.load(Ordering::Relaxed);\n             return ret;\n         }\n         // If the above fails, then update our copy of the tail and try\n         // again.\n-        *self.tail_copy.get() = self.tail_prev.load(Acquire);\n+        *self.tail_copy.get() = self.tail_prev.load(Ordering::Acquire);\n         if *self.first.get() != *self.tail_copy.get() {\n             if self.cache_bound > 0 {\n-                let b = self.cache_subtractions.load(Relaxed);\n-                self.cache_subtractions.store(b + 1, Relaxed);\n+                let b = self.cache_subtractions.load(Ordering::Relaxed);\n+                self.cache_subtractions.store(b + 1, Ordering::Relaxed);\n             }\n             let ret = *self.first.get();\n-            *self.first.get() = (*ret).next.load(Relaxed);\n+            *self.first.get() = (*ret).next.load(Ordering::Relaxed);\n             return ret;\n         }\n         // If all of that fails, then we have to allocate a new node\n@@ -177,25 +177,26 @@ impl<T: Send> Queue<T> {\n             // tail's next field and see if we can use it. If we do a pop, then\n             // the current tail node is a candidate for going into the cache.\n             let tail = *self.tail.get();\n-            let next = (*tail).next.load(Acquire);\n+            let next = (*tail).next.load(Ordering::Acquire);\n             if next.is_null() { return None }\n             assert!((*next).value.is_some());\n             let ret = (*next).value.take();\n \n             *self.tail.get() = next;\n             if self.cache_bound == 0 {\n-                self.tail_prev.store(tail, Release);\n+                self.tail_prev.store(tail, Ordering::Release);\n             } else {\n                 // FIXME: this is dubious with overflow.\n-                let additions = self.cache_additions.load(Relaxed);\n-                let subtractions = self.cache_subtractions.load(Relaxed);\n+                let additions = self.cache_additions.load(Ordering::Relaxed);\n+                let subtractions = self.cache_subtractions.load(Ordering::Relaxed);\n                 let size = additions - subtractions;\n \n                 if size < self.cache_bound {\n-                    self.tail_prev.store(tail, Release);\n-                    self.cache_additions.store(additions + 1, Relaxed);\n+                    self.tail_prev.store(tail, Ordering::Release);\n+                    self.cache_additions.store(additions + 1, Ordering::Relaxed);\n                 } else {\n-                    (*self.tail_prev.load(Relaxed)).next.store(next, Relaxed);\n+                    (*self.tail_prev.load(Ordering::Relaxed))\n+                          .next.store(next, Ordering::Relaxed);\n                     // We have successfully erased all references to 'tail', so\n                     // now we can safely drop it.\n                     let _: Box<Node<T>> = mem::transmute(tail);\n@@ -217,7 +218,7 @@ impl<T: Send> Queue<T> {\n         // stripped out.\n         unsafe {\n             let tail = *self.tail.get();\n-            let next = (*tail).next.load(Acquire);\n+            let next = (*tail).next.load(Ordering::Acquire);\n             if next.is_null() { return None }\n             return (*next).value.as_mut();\n         }\n@@ -230,7 +231,7 @@ impl<T: Send> Drop for Queue<T> {\n         unsafe {\n             let mut cur = *self.first.get();\n             while !cur.is_null() {\n-                let next = (*cur).next.load(Relaxed);\n+                let next = (*cur).next.load(Ordering::Relaxed);\n                 let _n: Box<Node<T>> = mem::transmute(cur);\n                 cur = next;\n             }"}, {"sha": "bd1e74a33902e15c306732bc8da3abf49f48208a", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -28,10 +28,10 @@ use core::cmp;\n use core::int;\n use thread::Thread;\n \n+use sync::atomic::{AtomicInt, AtomicUint, Ordering, AtomicBool};\n+use sync::mpsc::Receiver;\n use sync::mpsc::blocking::{self, SignalToken};\n use sync::mpsc::spsc_queue as spsc;\n-use sync::mpsc::Receiver;\n-use sync::atomic;\n \n const DISCONNECTED: int = int::MIN;\n #[cfg(test)]\n@@ -42,11 +42,11 @@ const MAX_STEALS: int = 1 << 20;\n pub struct Packet<T> {\n     queue: spsc::Queue<Message<T>>, // internal queue for all message\n \n-    cnt: atomic::AtomicInt, // How many items are on this channel\n+    cnt: AtomicInt, // How many items are on this channel\n     steals: int, // How many times has a port received without blocking?\n-    to_wake: atomic::AtomicUint, // SignalToken for the blocked thread to wake up\n+    to_wake: AtomicUint, // SignalToken for the blocked thread to wake up\n \n-    port_dropped: atomic::AtomicBool, // flag if the channel has been destroyed.\n+    port_dropped: AtomicBool, // flag if the channel has been destroyed.\n }\n \n pub enum Failure<T> {\n@@ -79,19 +79,19 @@ impl<T: Send> Packet<T> {\n         Packet {\n             queue: unsafe { spsc::Queue::new(128) },\n \n-            cnt: atomic::AtomicInt::new(0),\n+            cnt: AtomicInt::new(0),\n             steals: 0,\n-            to_wake: atomic::AtomicUint::new(0),\n+            to_wake: AtomicUint::new(0),\n \n-            port_dropped: atomic::AtomicBool::new(false),\n+            port_dropped: AtomicBool::new(false),\n         }\n     }\n \n     pub fn send(&mut self, t: T) -> Result<(), T> {\n         // If the other port has deterministically gone away, then definitely\n         // must return the data back up the stack. Otherwise, the data is\n         // considered as being sent.\n-        if self.port_dropped.load(atomic::SeqCst) { return Err(t) }\n+        if self.port_dropped.load(Ordering::SeqCst) { return Err(t) }\n \n         match self.do_send(Data(t)) {\n             UpSuccess | UpDisconnected => {},\n@@ -103,14 +103,14 @@ impl<T: Send> Packet<T> {\n     pub fn upgrade(&mut self, up: Receiver<T>) -> UpgradeResult {\n         // If the port has gone away, then there's no need to proceed any\n         // further.\n-        if self.port_dropped.load(atomic::SeqCst) { return UpDisconnected }\n+        if self.port_dropped.load(Ordering::SeqCst) { return UpDisconnected }\n \n         self.do_send(GoUp(up))\n     }\n \n     fn do_send(&mut self, t: Message<T>) -> UpgradeResult {\n         self.queue.push(t);\n-        match self.cnt.fetch_add(1, atomic::SeqCst) {\n+        match self.cnt.fetch_add(1, Ordering::SeqCst) {\n             // As described in the mod's doc comment, -1 == wakeup\n             -1 => UpWoke(self.take_to_wake()),\n             // As as described before, SPSC queues must be >= -2\n@@ -124,7 +124,7 @@ impl<T: Send> Packet<T> {\n             // will never remove this data. We can only have at most one item to\n             // drain (the port drains the rest).\n             DISCONNECTED => {\n-                self.cnt.store(DISCONNECTED, atomic::SeqCst);\n+                self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n                 let first = self.queue.pop();\n                 let second = self.queue.pop();\n                 assert!(second.is_none());\n@@ -143,8 +143,8 @@ impl<T: Send> Packet<T> {\n \n     // Consumes ownership of the 'to_wake' field.\n     fn take_to_wake(&mut self) -> SignalToken {\n-        let ptr = self.to_wake.load(atomic::SeqCst);\n-        self.to_wake.store(0, atomic::SeqCst);\n+        let ptr = self.to_wake.load(Ordering::SeqCst);\n+        self.to_wake.store(0, Ordering::SeqCst);\n         assert!(ptr != 0);\n         unsafe { SignalToken::cast_from_uint(ptr) }\n     }\n@@ -153,15 +153,15 @@ impl<T: Send> Packet<T> {\n     // back if it shouldn't sleep. Note that this is the location where we take\n     // steals into account.\n     fn decrement(&mut self, token: SignalToken) -> Result<(), SignalToken> {\n-        assert_eq!(self.to_wake.load(atomic::SeqCst), 0);\n+        assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n         let ptr = unsafe { token.cast_to_uint() };\n-        self.to_wake.store(ptr, atomic::SeqCst);\n+        self.to_wake.store(ptr, Ordering::SeqCst);\n \n         let steals = self.steals;\n         self.steals = 0;\n \n-        match self.cnt.fetch_sub(1 + steals, atomic::SeqCst) {\n-            DISCONNECTED => { self.cnt.store(DISCONNECTED, atomic::SeqCst); }\n+        match self.cnt.fetch_sub(1 + steals, Ordering::SeqCst) {\n+            DISCONNECTED => { self.cnt.store(DISCONNECTED, Ordering::SeqCst); }\n             // If we factor in our steals and notice that the channel has no\n             // data, we successfully sleep\n             n => {\n@@ -170,7 +170,7 @@ impl<T: Send> Packet<T> {\n             }\n         }\n \n-        self.to_wake.store(0, atomic::SeqCst);\n+        self.to_wake.store(0, Ordering::SeqCst);\n         Err(unsafe { SignalToken::cast_from_uint(ptr) })\n     }\n \n@@ -217,9 +217,9 @@ impl<T: Send> Packet<T> {\n             // adding back in whatever we couldn't factor into steals.\n             Some(data) => {\n                 if self.steals > MAX_STEALS {\n-                    match self.cnt.swap(0, atomic::SeqCst) {\n+                    match self.cnt.swap(0, Ordering::SeqCst) {\n                         DISCONNECTED => {\n-                            self.cnt.store(DISCONNECTED, atomic::SeqCst);\n+                            self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n                         }\n                         n => {\n                             let m = cmp::min(n, self.steals);\n@@ -237,7 +237,7 @@ impl<T: Send> Packet<T> {\n             }\n \n             None => {\n-                match self.cnt.load(atomic::SeqCst) {\n+                match self.cnt.load(Ordering::SeqCst) {\n                     n if n != DISCONNECTED => Err(Empty),\n \n                     // This is a little bit of a tricky case. We failed to pop\n@@ -266,7 +266,7 @@ impl<T: Send> Packet<T> {\n     pub fn drop_chan(&mut self) {\n         // Dropping a channel is pretty simple, we just flag it as disconnected\n         // and then wakeup a blocker if there is one.\n-        match self.cnt.swap(DISCONNECTED, atomic::SeqCst) {\n+        match self.cnt.swap(DISCONNECTED, Ordering::SeqCst) {\n             -1 => { self.take_to_wake().signal(); }\n             DISCONNECTED => {}\n             n => { assert!(n >= 0); }\n@@ -293,7 +293,7 @@ impl<T: Send> Packet<T> {\n         // sends are gated on this flag, so we're immediately guaranteed that\n         // there are a bounded number of active sends that we'll have to deal\n         // with.\n-        self.port_dropped.store(true, atomic::SeqCst);\n+        self.port_dropped.store(true, Ordering::SeqCst);\n \n         // Now that we're guaranteed to deal with a bounded number of senders,\n         // we need to drain the queue. This draining process happens atomically\n@@ -306,7 +306,7 @@ impl<T: Send> Packet<T> {\n         let mut steals = self.steals;\n         while {\n             let cnt = self.cnt.compare_and_swap(\n-                            steals, DISCONNECTED, atomic::SeqCst);\n+                            steals, DISCONNECTED, Ordering::SeqCst);\n             cnt != DISCONNECTED && cnt != steals\n         } {\n             loop {\n@@ -351,9 +351,9 @@ impl<T: Send> Packet<T> {\n \n     // increment the count on the channel (used for selection)\n     fn bump(&mut self, amt: int) -> int {\n-        match self.cnt.fetch_add(amt, atomic::SeqCst) {\n+        match self.cnt.fetch_add(amt, Ordering::SeqCst) {\n             DISCONNECTED => {\n-                self.cnt.store(DISCONNECTED, atomic::SeqCst);\n+                self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n                 DISCONNECTED\n             }\n             n => n\n@@ -403,7 +403,7 @@ impl<T: Send> Packet<T> {\n         // of time until the data is actually sent.\n         if was_upgrade {\n             assert_eq!(self.steals, 0);\n-            assert_eq!(self.to_wake.load(atomic::SeqCst), 0);\n+            assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n             return Ok(true)\n         }\n \n@@ -416,7 +416,7 @@ impl<T: Send> Packet<T> {\n         // If we were previously disconnected, then we know for sure that there\n         // is no task in to_wake, so just keep going\n         let has_data = if prev == DISCONNECTED {\n-            assert_eq!(self.to_wake.load(atomic::SeqCst), 0);\n+            assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n             true // there is data, that data is that we're disconnected\n         } else {\n             let cur = prev + steals + 1;\n@@ -439,7 +439,7 @@ impl<T: Send> Packet<T> {\n             if prev < 0 {\n                 drop(self.take_to_wake());\n             } else {\n-                while self.to_wake.load(atomic::SeqCst) != 0 {\n+                while self.to_wake.load(Ordering::SeqCst) != 0 {\n                     Thread::yield_now();\n                 }\n             }\n@@ -478,7 +478,7 @@ impl<T: Send> Drop for Packet<T> {\n         // disconnection, but also a proper fence before the read of\n         // `to_wake`, so this assert cannot be removed with also removing\n         // the `to_wake` assert.\n-        assert_eq!(self.cnt.load(atomic::SeqCst), DISCONNECTED);\n-        assert_eq!(self.to_wake.load(atomic::SeqCst), 0);\n+        assert_eq!(self.cnt.load(Ordering::SeqCst), DISCONNECTED);\n+        assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n     }\n }"}, {"sha": "6836888e67e5528c3136268974a5ba05070e6b09", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -41,14 +41,15 @@ use self::Blocker::*;\n use vec::Vec;\n use core::mem;\n \n-use sync::{atomic, Mutex, MutexGuard};\n+use sync::atomic::{Ordering, AtomicUint};\n use sync::mpsc::blocking::{self, WaitToken, SignalToken};\n use sync::mpsc::select::StartResult::{self, Installed, Abort};\n+use sync::{Mutex, MutexGuard};\n \n pub struct Packet<T> {\n     /// Only field outside of the mutex. Just done for kicks, but mainly because\n     /// the other shared channel already had the code implemented\n-    channels: atomic::AtomicUint,\n+    channels: AtomicUint,\n \n     lock: Mutex<State<T>>,\n }\n@@ -137,7 +138,7 @@ fn wakeup<T>(token: SignalToken, guard: MutexGuard<State<T>>) {\n impl<T: Send> Packet<T> {\n     pub fn new(cap: uint) -> Packet<T> {\n         Packet {\n-            channels: atomic::AtomicUint::new(1),\n+            channels: AtomicUint::new(1),\n             lock: Mutex::new(State {\n                 disconnected: false,\n                 blocker: NoneBlocked,\n@@ -304,12 +305,12 @@ impl<T: Send> Packet<T> {\n     // Prepares this shared packet for a channel clone, essentially just bumping\n     // a refcount.\n     pub fn clone_chan(&self) {\n-        self.channels.fetch_add(1, atomic::SeqCst);\n+        self.channels.fetch_add(1, Ordering::SeqCst);\n     }\n \n     pub fn drop_chan(&self) {\n         // Only flag the channel as disconnected if we're the last channel\n-        match self.channels.fetch_sub(1, atomic::SeqCst) {\n+        match self.channels.fetch_sub(1, Ordering::SeqCst) {\n             1 => {}\n             _ => return\n         }\n@@ -412,7 +413,7 @@ impl<T: Send> Packet<T> {\n #[unsafe_destructor]\n impl<T: Send> Drop for Packet<T> {\n     fn drop(&mut self) {\n-        assert_eq!(self.channels.load(atomic::SeqCst), 0);\n+        assert_eq!(self.channels.load(Ordering::SeqCst), 0);\n         let mut guard = self.lock.lock().unwrap();\n         assert!(guard.queue.dequeue().is_none());\n         assert!(guard.canceled.is_none());"}, {"sha": "08e323c9cb4c3da2e45fcfcebef7c64e20c0c84e", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -17,7 +17,7 @@ use int;\n use kinds::Sync;\n use mem::drop;\n use ops::FnOnce;\n-use sync::atomic;\n+use sync::atomic::{AtomicInt, Ordering, ATOMIC_INT_INIT};\n use sync::{StaticMutex, MUTEX_INIT};\n \n /// A synchronization primitive which can be used to run a one-time global\n@@ -39,8 +39,8 @@ use sync::{StaticMutex, MUTEX_INIT};\n #[stable]\n pub struct Once {\n     mutex: StaticMutex,\n-    cnt: atomic::AtomicInt,\n-    lock_cnt: atomic::AtomicInt,\n+    cnt: AtomicInt,\n+    lock_cnt: AtomicInt,\n }\n \n unsafe impl Sync for Once {}\n@@ -49,8 +49,8 @@ unsafe impl Sync for Once {}\n #[stable]\n pub const ONCE_INIT: Once = Once {\n     mutex: MUTEX_INIT,\n-    cnt: atomic::ATOMIC_INT_INIT,\n-    lock_cnt: atomic::ATOMIC_INT_INIT,\n+    cnt: ATOMIC_INT_INIT,\n+    lock_cnt: ATOMIC_INT_INIT,\n };\n \n impl Once {\n@@ -66,7 +66,7 @@ impl Once {\n     #[stable]\n     pub fn call_once<F>(&'static self, f: F) where F: FnOnce() {\n         // Optimize common path: load is much cheaper than fetch_add.\n-        if self.cnt.load(atomic::SeqCst) < 0 {\n+        if self.cnt.load(Ordering::SeqCst) < 0 {\n             return\n         }\n \n@@ -97,27 +97,27 @@ impl Once {\n         // calling `call_once` will return immediately before the initialization\n         // has completed.\n \n-        let prev = self.cnt.fetch_add(1, atomic::SeqCst);\n+        let prev = self.cnt.fetch_add(1, Ordering::SeqCst);\n         if prev < 0 {\n             // Make sure we never overflow, we'll never have int::MIN\n             // simultaneous calls to `call_once` to make this value go back to 0\n-            self.cnt.store(int::MIN, atomic::SeqCst);\n+            self.cnt.store(int::MIN, Ordering::SeqCst);\n             return\n         }\n \n         // If the count is negative, then someone else finished the job,\n         // otherwise we run the job and record how many people will try to grab\n         // this lock\n         let guard = self.mutex.lock();\n-        if self.cnt.load(atomic::SeqCst) > 0 {\n+        if self.cnt.load(Ordering::SeqCst) > 0 {\n             f();\n-            let prev = self.cnt.swap(int::MIN, atomic::SeqCst);\n-            self.lock_cnt.store(prev, atomic::SeqCst);\n+            let prev = self.cnt.swap(int::MIN, Ordering::SeqCst);\n+            self.lock_cnt.store(prev, Ordering::SeqCst);\n         }\n         drop(guard);\n \n         // Last one out cleans up after everyone else, no leaks!\n-        if self.lock_cnt.fetch_add(-1, atomic::SeqCst) == 1 {\n+        if self.lock_cnt.fetch_add(-1, Ordering::SeqCst) == 1 {\n             unsafe { self.mutex.destroy() }\n         }\n     }"}, {"sha": "e9af796c6745c9e24599c9301528c53a336c5dd2", "filename": "src/libstd/sys/common/thread_local.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -58,7 +58,7 @@\n \n use prelude::v1::*;\n \n-use sync::atomic::{self, AtomicUint};\n+use sync::atomic::{self, AtomicUint, Ordering};\n use sync::{Mutex, Once, ONCE_INIT};\n \n use sys::thread_local as imp;\n@@ -166,15 +166,15 @@ impl StaticKey {\n     /// Note that this does *not* run the user-provided destructor if one was\n     /// specified at definition time. Doing so must be done manually.\n     pub unsafe fn destroy(&self) {\n-        match self.inner.key.swap(0, atomic::SeqCst) {\n+        match self.inner.key.swap(0, Ordering::SeqCst) {\n             0 => {}\n             n => { imp::destroy(n as imp::Key) }\n         }\n     }\n \n     #[inline]\n     unsafe fn key(&self) -> imp::Key {\n-        match self.inner.key.load(atomic::Relaxed) {\n+        match self.inner.key.load(Ordering::Relaxed) {\n             0 => self.lazy_init() as imp::Key,\n             n => n as imp::Key\n         }\n@@ -199,7 +199,7 @@ impl StaticKey {\n             key2\n         };\n         assert!(key != 0);\n-        match self.inner.key.compare_and_swap(0, key as uint, atomic::SeqCst) {\n+        match self.inner.key.compare_and_swap(0, key as uint, Ordering::SeqCst) {\n             // The CAS succeeded, so we've created the actual key\n             0 => key as uint,\n             // If someone beat us to the punch, use their key instead"}, {"sha": "181b8fdd0f8a11af8e610cd751b1aebc6d72da48", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -20,7 +20,6 @@ use libc::{self, c_int, c_char, c_void};\n use os;\n use path::{BytesContainer};\n use ptr;\n-use sync::atomic::{AtomicInt, SeqCst};\n use sys::fs::FileDesc;\n \n use os::TMPBUF_SZ;"}, {"sha": "9063fbc2ba955b9466f3b12b9b9164f8a9397b36", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -13,7 +13,8 @@ use prelude::v1::*;\n use libc;\n use c_str::CString;\n use mem;\n-use sync::{atomic, Arc, Mutex};\n+use sync::{Arc, Mutex};\n+use sync::atomic::{AtomicBool, Ordering};\n use io::{self, IoResult, IoError};\n \n use sys::{self, timer, retry, c, set_nonblocking, wouldblock};\n@@ -242,7 +243,7 @@ impl UnixListener {\n                         listener: self,\n                         reader: reader,\n                         writer: writer,\n-                        closed: atomic::AtomicBool::new(false),\n+                        closed: AtomicBool::new(false),\n                     }),\n                     deadline: 0,\n                 })\n@@ -260,7 +261,7 @@ struct AcceptorInner {\n     listener: UnixListener,\n     reader: FileDesc,\n     writer: FileDesc,\n-    closed: atomic::AtomicBool,\n+    closed: AtomicBool,\n }\n \n impl UnixAcceptor {\n@@ -269,7 +270,7 @@ impl UnixAcceptor {\n     pub fn accept(&mut self) -> IoResult<UnixStream> {\n         let deadline = if self.deadline == 0 {None} else {Some(self.deadline)};\n \n-        while !self.inner.closed.load(atomic::SeqCst) {\n+        while !self.inner.closed.load(Ordering::SeqCst) {\n             unsafe {\n                 let mut storage: libc::sockaddr_storage = mem::zeroed();\n                 let storagep = &mut storage as *mut libc::sockaddr_storage;\n@@ -297,7 +298,7 @@ impl UnixAcceptor {\n     }\n \n     pub fn close_accept(&mut self) -> IoResult<()> {\n-        self.inner.closed.store(true, atomic::SeqCst);\n+        self.inner.closed.store(true, Ordering::SeqCst);\n         let fd = FileDesc::new(self.inner.writer.fd(), false);\n         match fd.write(&[0]) {\n             Ok(..) => Ok(()),"}, {"sha": "59eebd3f28eca5d1203fe6eefc0eff9586cca123", "filename": "src/libstd/sys/unix/tcp.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -16,7 +16,8 @@ use libc;\n use mem;\n use ptr;\n use super::{last_error, last_net_error, retry, sock_t};\n-use sync::{Arc, atomic};\n+use sync::Arc;\n+use sync::atomic::{AtomicBool, Ordering};\n use sys::fs::FileDesc;\n use sys::{set_nonblocking, wouldblock};\n use sys;\n@@ -74,7 +75,7 @@ impl TcpListener {\n                         listener: self,\n                         reader: reader,\n                         writer: writer,\n-                        closed: atomic::AtomicBool::new(false),\n+                        closed: AtomicBool::new(false),\n                     }),\n                     deadline: 0,\n                 })\n@@ -96,7 +97,7 @@ struct AcceptorInner {\n     listener: TcpListener,\n     reader: FileDesc,\n     writer: FileDesc,\n-    closed: atomic::AtomicBool,\n+    closed: AtomicBool,\n }\n \n unsafe impl Sync for AcceptorInner {}\n@@ -121,7 +122,7 @@ impl TcpAcceptor {\n         // self-pipe is never written to unless close_accept() is called.\n         let deadline = if self.deadline == 0 {None} else {Some(self.deadline)};\n \n-        while !self.inner.closed.load(atomic::SeqCst) {\n+        while !self.inner.closed.load(Ordering::SeqCst) {\n             match retry(|| unsafe {\n                 libc::accept(self.fd(), ptr::null_mut(), ptr::null_mut())\n             }) {\n@@ -145,7 +146,7 @@ impl TcpAcceptor {\n     }\n \n     pub fn close_accept(&mut self) -> IoResult<()> {\n-        self.inner.closed.store(true, atomic::SeqCst);\n+        self.inner.closed.store(true, Ordering::SeqCst);\n         let fd = FileDesc::new(self.inner.writer.fd(), false);\n         match fd.write(&[0]) {\n             Ok(..) => Ok(()),"}, {"sha": "11f29232a925d0e3625a607a9ee1d7c978e5f5db", "filename": "src/libstd/sys/unix/timer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -54,7 +54,7 @@ use libc;\n use mem;\n use os;\n use ptr;\n-use sync::atomic;\n+use sync::atomic::{mod, Ordering};\n use sync::mpsc::{channel, Sender, Receiver, TryRecvError};\n use sys::c;\n use sys::fs::FileDesc;\n@@ -212,7 +212,7 @@ impl Timer {\n         HELPER.boot(|| {}, helper);\n \n         static ID: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n-        let id = ID.fetch_add(1, atomic::Relaxed);\n+        let id = ID.fetch_add(1, Ordering::Relaxed);\n         Ok(Timer {\n             id: id,\n             inner: Some(box Inner {"}, {"sha": "1def99a374198d544c9e09131e8578485ef7b933", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -10,17 +10,17 @@\n \n use prelude::v1::*;\n \n-use sync::atomic;\n+use sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n use alloc::{self, heap};\n \n use libc::DWORD;\n use sys::sync as ffi;\n \n const SPIN_COUNT: DWORD = 4000;\n \n-pub struct Mutex { inner: atomic::AtomicUint }\n+pub struct Mutex { inner: AtomicUint }\n \n-pub const MUTEX_INIT: Mutex = Mutex { inner: atomic::ATOMIC_UINT_INIT };\n+pub const MUTEX_INIT: Mutex = Mutex { inner: ATOMIC_UINT_INIT };\n \n unsafe impl Sync for Mutex {}\n \n@@ -32,7 +32,7 @@ pub unsafe fn raw(m: &Mutex) -> ffi::LPCRITICAL_SECTION {\n impl Mutex {\n     #[inline]\n     pub unsafe fn new() -> Mutex {\n-        Mutex { inner: atomic::AtomicUint::new(init_lock() as uint) }\n+        Mutex { inner: AtomicUint::new(init_lock() as uint) }\n     }\n     #[inline]\n     pub unsafe fn lock(&self) {\n@@ -47,22 +47,22 @@ impl Mutex {\n         ffi::LeaveCriticalSection(self.get())\n     }\n     pub unsafe fn destroy(&self) {\n-        let lock = self.inner.swap(0, atomic::SeqCst);\n+        let lock = self.inner.swap(0, Ordering::SeqCst);\n         if lock != 0 { free_lock(lock as ffi::LPCRITICAL_SECTION) }\n     }\n \n     unsafe fn get(&self) -> ffi::LPCRITICAL_SECTION {\n-        match self.inner.load(atomic::SeqCst) {\n+        match self.inner.load(Ordering::SeqCst) {\n             0 => {}\n             n => return n as ffi::LPCRITICAL_SECTION\n         }\n         let lock = init_lock();\n-        match self.inner.compare_and_swap(0, lock as uint, atomic::SeqCst) {\n+        match self.inner.compare_and_swap(0, lock as uint, Ordering::SeqCst) {\n             0 => return lock as ffi::LPCRITICAL_SECTION,\n             _ => {}\n         }\n         free_lock(lock);\n-        return self.inner.load(atomic::SeqCst) as ffi::LPCRITICAL_SECTION;\n+        return self.inner.load(Ordering::SeqCst) as ffi::LPCRITICAL_SECTION;\n     }\n }\n "}, {"sha": "9057515cad294c51f849a0fff470004e77745c97", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -90,7 +90,8 @@ use libc;\n use c_str::CString;\n use mem;\n use ptr;\n-use sync::{atomic, Arc, Mutex};\n+use sync::{Arc, Mutex};\n+use sync::atomic::{AtomicBool, Ordering};\n use io::{self, IoError, IoResult};\n \n use sys_common::{self, eof};\n@@ -126,17 +127,17 @@ impl Drop for Event {\n struct Inner {\n     handle: libc::HANDLE,\n     lock: Mutex<()>,\n-    read_closed: atomic::AtomicBool,\n-    write_closed: atomic::AtomicBool,\n+    read_closed: AtomicBool,\n+    write_closed: AtomicBool,\n }\n \n impl Inner {\n     fn new(handle: libc::HANDLE) -> Inner {\n         Inner {\n             handle: handle,\n             lock: Mutex::new(()),\n-            read_closed: atomic::AtomicBool::new(false),\n-            write_closed: atomic::AtomicBool::new(false),\n+            read_closed: AtomicBool::new(false),\n+            write_closed: AtomicBool::new(false),\n         }\n     }\n }\n@@ -334,11 +335,11 @@ impl UnixStream {\n     pub fn handle(&self) -> libc::HANDLE { self.inner.handle }\n \n     fn read_closed(&self) -> bool {\n-        self.inner.read_closed.load(atomic::SeqCst)\n+        self.inner.read_closed.load(Ordering::SeqCst)\n     }\n \n     fn write_closed(&self) -> bool {\n-        self.inner.write_closed.load(atomic::SeqCst)\n+        self.inner.write_closed.load(Ordering::SeqCst)\n     }\n \n     fn cancel_io(&self) -> IoResult<()> {\n@@ -517,14 +518,14 @@ impl UnixStream {\n         // and 2 with a lock with respect to close_read(), we're guaranteed that\n         // no thread will erroneously sit in a read forever.\n         let _guard = unsafe { self.inner.lock.lock() };\n-        self.inner.read_closed.store(true, atomic::SeqCst);\n+        self.inner.read_closed.store(true, Ordering::SeqCst);\n         self.cancel_io()\n     }\n \n     pub fn close_write(&mut self) -> IoResult<()> {\n         // see comments in close_read() for why this lock is necessary\n         let _guard = unsafe { self.inner.lock.lock() };\n-        self.inner.write_closed.store(true, atomic::SeqCst);\n+        self.inner.write_closed.store(true, Ordering::SeqCst);\n         self.cancel_io()\n     }\n \n@@ -586,7 +587,7 @@ impl UnixListener {\n             deadline: 0,\n             inner: Arc::new(AcceptorState {\n                 abort: try!(Event::new(true, false)),\n-                closed: atomic::AtomicBool::new(false),\n+                closed: AtomicBool::new(false),\n             }),\n         })\n     }\n@@ -614,7 +615,7 @@ unsafe impl Sync for UnixAcceptor {}\n \n struct AcceptorState {\n     abort: Event,\n-    closed: atomic::AtomicBool,\n+    closed: AtomicBool,\n }\n \n unsafe impl Send for AcceptorState {}\n@@ -658,7 +659,7 @@ impl UnixAcceptor {\n \n         // If we've had an artificial call to close_accept, be sure to never\n         // proceed in accepting new clients in the future\n-        if self.inner.closed.load(atomic::SeqCst) { return Err(eof()) }\n+        if self.inner.closed.load(Ordering::SeqCst) { return Err(eof()) }\n \n         let name = try!(to_utf16(self.listener.name.as_str()));\n \n@@ -734,7 +735,7 @@ impl UnixAcceptor {\n     }\n \n     pub fn close_accept(&mut self) -> IoResult<()> {\n-        self.inner.closed.store(true, atomic::SeqCst);\n+        self.inner.closed.store(true, Ordering::SeqCst);\n         let ret = unsafe {\n             c::SetEvent(self.inner.abort.handle())\n         };"}, {"sha": "77139b52efa149541c301d72bfde0b33648f0070", "filename": "src/libstd/sys/windows/tcp.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -15,7 +15,8 @@ use mem;\n use ptr;\n use prelude::v1::*;\n use super::{last_error, last_net_error, retry, sock_t};\n-use sync::{Arc, atomic};\n+use sync::Arc;\n+use sync::atomic::{AtomicBool, Ordering};\n use sys::fs::FileDesc;\n use sys::{self, c, set_nonblocking, wouldblock, timer};\n use sys_common::{self, timeout, eof, net};\n@@ -91,7 +92,7 @@ impl TcpListener {\n                         listener: self,\n                         abort: try!(Event::new()),\n                         accept: accept,\n-                        closed: atomic::AtomicBool::new(false),\n+                        closed: AtomicBool::new(false),\n                     }),\n                     deadline: 0,\n                 })\n@@ -122,7 +123,7 @@ struct AcceptorInner {\n     listener: TcpListener,\n     abort: Event,\n     accept: Event,\n-    closed: atomic::AtomicBool,\n+    closed: AtomicBool,\n }\n \n unsafe impl Send for AcceptorInner {}\n@@ -154,7 +155,7 @@ impl TcpAcceptor {\n         // stolen, so we do all of this in a loop as well.\n         let events = [self.inner.abort.handle(), self.inner.accept.handle()];\n \n-        while !self.inner.closed.load(atomic::SeqCst) {\n+        while !self.inner.closed.load(Ordering::SeqCst) {\n             let ms = if self.deadline == 0 {\n                 c::WSA_INFINITE as u64\n             } else {\n@@ -214,7 +215,7 @@ impl TcpAcceptor {\n     }\n \n     pub fn close_accept(&mut self) -> IoResult<()> {\n-        self.inner.closed.store(true, atomic::SeqCst);\n+        self.inner.closed.store(true, Ordering::SeqCst);\n         let ret = unsafe { c::WSASetEvent(self.inner.abort.handle()) };\n         if ret == libc::TRUE {\n             Ok(())"}, {"sha": "0f08108fee547744a2a459253d61e93b7fc03667", "filename": "src/libstd/task.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=470118f3e915cdc8f936aca0640b28a7a3d8dc6c", "patch": "@@ -1,44 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Deprecated in favor of `thread`.\n-\n-#![deprecated = \"use std::thread instead\"]\n-\n-use any::Any;\n-use boxed::Box;\n-use thread;\n-use kinds::Send;\n-use result::Result;\n-use ops::FnOnce;\n-\n-/// Deprecate: use `std::thread::Builder` instead.\n-#[deprecated = \"use std::thread::Builder instead\"]\n-pub type TaskBuilder = thread::Builder;\n-\n-/// Deprecated: use `std::thread::Thread::spawn` and `detach` instead.\n-#[deprecated = \"use std::thread::Thread::spawn and detach instead\"]\n-pub fn spawn<F>(f: F) where F: FnOnce(), F: Send {\n-    thread::Thread::spawn(f).detach();\n-}\n-\n-/// Deprecated: use `std::thread::Thread::spawn` and `join` instead.\n-#[deprecated = \"use std::thread::Thread::spawn and join instead\"]\n-pub fn try<T, F>(f: F) -> Result<T, Box<Any + Send>> where\n-    T: Send, F: FnOnce() -> T, F: Send\n-{\n-    thread::Thread::spawn(f).join()\n-}\n-\n-/// Deprecated: use `std::thread::Thread::yield_now instead`.\n-#[deprecated = \"use std::thread::Thread::yield_now instead\"]\n-pub fn deschedule() {\n-    thread::Thread::yield_now()\n-}"}, {"sha": "1d6f49b04a3f510bfcd6d2eb233bba589e859385", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -125,7 +125,6 @@\n //! * It can be implemented highly efficiently on many platforms.\n \n use any::Any;\n-use borrow::IntoCow;\n use boxed::Box;\n use cell::UnsafeCell;\n use clone::Clone;\n@@ -175,12 +174,6 @@ impl Builder {\n         self\n     }\n \n-    /// Deprecated: use `name` instead\n-    #[deprecated = \"use name instead\"]\n-    pub fn named<T: IntoCow<'static, String, str>>(self, name: T) -> Builder {\n-        self.name(name.into_cow().into_owned())\n-    }\n-\n     /// Set the size of the stack for the new thread.\n     pub fn stack_size(mut self, size: uint) -> Builder {\n         self.stack_size = Some(size);"}, {"sha": "f40b62182d42c73bbb1fbcbd11c215a51501711f", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -35,17 +35,6 @@\n //!\n //! # Examples\n //!\n-//! Using fields:\n-//!\n-//! ```\n-//! #[allow(deprecated)]\n-//! # fn main() {\n-//! let pair = (\"pi\", 3.14f64);\n-//! assert_eq!(pair.0, \"pi\");\n-//! assert_eq!(pair.1, 3.14f64);\n-//! # }\n-//! ```\n-//!\n //! Using traits implemented for tuples:\n //!\n //! ```"}, {"sha": "14b19fee3df5e6963e152921a85cae0cd136dfc6", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -25,7 +25,6 @@ pub mod decodable;\n pub mod hash;\n pub mod rand;\n pub mod show;\n-pub mod zero;\n pub mod default;\n pub mod primitive;\n \n@@ -110,7 +109,6 @@ pub fn expand_meta_derive(cx: &mut ExtCtxt,\n \n                             \"Show\" => expand!(show::expand_deriving_show),\n \n-                            \"Zero\" => expand!(zero::expand_deriving_zero),\n                             \"Default\" => expand!(default::expand_deriving_default),\n \n                             \"FromPrimitive\" => expand!(primitive::expand_deriving_from_primitive),"}, {"sha": "73331f06aa4ee53a3bd6e74cc887c39a2971de52", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=470118f3e915cdc8f936aca0640b28a7a3d8dc6c", "patch": "@@ -1,102 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use ast::{MetaItem, Item, Expr};\n-use codemap::Span;\n-use ext::base::ExtCtxt;\n-use ext::build::AstBuilder;\n-use ext::deriving::generic::*;\n-use ext::deriving::generic::ty::*;\n-use parse::token::InternedString;\n-use ptr::P;\n-\n-pub fn expand_deriving_zero<F>(cx: &mut ExtCtxt,\n-                               span: Span,\n-                               mitem: &MetaItem,\n-                               item: &Item,\n-                               push: F) where\n-    F: FnOnce(P<Item>),\n-{\n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-    let attrs = vec!(cx.attribute(span, inline));\n-    let trait_def = TraitDef {\n-        span: span,\n-        attributes: Vec::new(),\n-        path: Path::new(vec!(\"std\", \"num\", \"Zero\")),\n-        additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n-        methods: vec!(\n-            MethodDef {\n-                name: \"zero\",\n-                generics: LifetimeBounds::empty(),\n-                explicit_self: None,\n-                args: Vec::new(),\n-                ret_ty: Self,\n-                attributes: attrs.clone(),\n-                combine_substructure: combine_substructure(|a, b, c| {\n-                    zero_substructure(a, b, c)\n-                })\n-            },\n-            MethodDef {\n-                name: \"is_zero\",\n-                generics: LifetimeBounds::empty(),\n-                explicit_self: borrowed_explicit_self(),\n-                args: Vec::new(),\n-                ret_ty: Literal(Path::new(vec!(\"bool\"))),\n-                attributes: attrs,\n-                combine_substructure: combine_substructure(|cx, span, substr| {\n-                    cs_and(|cx, span, _, _| cx.span_bug(span,\n-                                                        \"Non-matching enum \\\n-                                                         variant in \\\n-                                                         deriving(Zero)\"),\n-                           cx, span, substr)\n-                })\n-            }\n-        )\n-    };\n-    trait_def.expand(cx, mitem, item, push)\n-}\n-\n-fn zero_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {\n-    let zero_ident = vec!(\n-        cx.ident_of(\"std\"),\n-        cx.ident_of(\"num\"),\n-        cx.ident_of(\"Zero\"),\n-        cx.ident_of(\"zero\")\n-    );\n-    let zero_call = |&: span| cx.expr_call_global(span, zero_ident.clone(), Vec::new());\n-\n-    return match *substr.fields {\n-        StaticStruct(_, ref summary) => {\n-            match *summary {\n-                Unnamed(ref fields) => {\n-                    if fields.is_empty() {\n-                        cx.expr_ident(trait_span, substr.type_ident)\n-                    } else {\n-                        let exprs = fields.iter().map(|sp| zero_call(*sp)).collect();\n-                        cx.expr_call_ident(trait_span, substr.type_ident, exprs)\n-                    }\n-                }\n-                Named(ref fields) => {\n-                    let zero_fields = fields.iter().map(|&(ident, span)| {\n-                        cx.field_imm(span, ident, zero_call(span))\n-                    }).collect();\n-                    cx.expr_struct_ident(trait_span, substr.type_ident, zero_fields)\n-                }\n-            }\n-        }\n-        StaticEnum(..) => {\n-            cx.span_err(trait_span, \"`Zero` cannot be derived for enums, only structs\");\n-            // let compilation continue\n-            cx.expr_uint(trait_span, 0)\n-        }\n-        _ => cx.bug(\"Non-static method in `deriving(Zero)`\")\n-    };\n-}"}, {"sha": "a50b97142c2ef1d98d23e38106d1d10759573b7e", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -23,6 +23,7 @@ use std::mem::replace;\n use std::num;\n use std::rc::Rc;\n use std::str;\n+use std::string::CowString;\n \n pub use ext::tt::transcribe::{TtReader, new_tt_reader};\n \n@@ -277,7 +278,7 @@ impl<'a> StringReader<'a> {\n \n     /// Converts CRLF to LF in the given string, raising an error on bare CR.\n     fn translate_crlf<'b>(&self, start: BytePos,\n-                          s: &'b str, errmsg: &'b str) -> str::CowString<'b> {\n+                          s: &'b str, errmsg: &'b str) -> CowString<'b> {\n         let mut i = 0u;\n         while i < s.len() {\n             let str::CharRange { ch, next } = s.char_range_at(i);"}, {"sha": "37ac86a33242e54e26ec80233add9c034ccf902f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -89,7 +89,6 @@ use std::mem;\n use std::num::Float;\n use std::rc::Rc;\n use std::slice;\n-use std::str::from_str;\n \n bitflags! {\n     flags Restrictions: u8 {"}, {"sha": "4bfcc94a083d4c03f29fc6a118a4dbf1b75ab888", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -22,7 +22,6 @@ use util::interner::{RcStr, StrInterner};\n use util::interner;\n \n use serialize::{Decodable, Decoder, Encodable, Encoder};\n-use std::cmp::Equiv;\n use std::fmt;\n use std::mem;\n use std::ops::Deref;\n@@ -632,13 +631,6 @@ impl fmt::Show for InternedString {\n     }\n }\n \n-#[allow(deprecated)]\n-impl<'a> Equiv<&'a str> for InternedString {\n-    fn equiv(&self, other: & &'a str) -> bool {\n-        (*other) == self.string[]\n-    }\n-}\n-\n impl<'a> PartialEq<&'a str> for InternedString {\n     #[inline(always)]\n     fn eq(&self, other: & &'a str) -> bool {"}, {"sha": "4bac20dd67c06a5ec1af2ae13728387b520bfb6c", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -71,7 +71,7 @@ use std::io;\n use std::iter::repeat;\n use std::num::{Float, FloatMath, Int};\n use std::os;\n-use std::str::{FromStr, from_str};\n+use std::str::FromStr;\n use std::sync::mpsc::{channel, Sender};\n use std::thread::{self, Thread};\n use std::thunk::{Thunk, Invoke};"}, {"sha": "35af0e763d7dd0711d8b3bfa8020c7fffcaed900", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -1066,7 +1066,7 @@ mod bench {\n     #[bench]\n     pub fn sum_many_f64(b: &mut Bencher) {\n         let nums = [-1e30f64, 1e60, 1e30, 1.0, -1e60];\n-        let v = Vec::from_fn(500, |i| nums[i%5]);\n+        let v = range(0, 500).map(|i| nums[i%5]).collect::<Vec<_>>();\n \n         b.iter(|| {\n             v.as_slice().sum();"}, {"sha": "0dc1524a7cb6b2d6c69dc5b3dbcc15e82e713281", "filename": "src/libtime/lib.rs", "status": "removed", "additions": 0, "deletions": 1773, "changes": 1773, "blob_url": "https://github.com/rust-lang/rust/blob/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=470118f3e915cdc8f936aca0640b28a7a3d8dc6c", "patch": "@@ -1,1773 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Simple time handling.\n-\n-#![crate_name = \"time\"]\n-#![deprecated = \"use the http://github.com/rust-lang/time crate instead\"]\n-#![allow(deprecated)]\n-\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"http://play.rust-lang.org/\")]\n-\n-#![allow(unknown_features)]\n-#![feature(phase, globs)]\n-#![feature(old_orphan_check)]\n-#![feature(associated_types)]\n-#![feature(default_type_params)]\n-\n-#[cfg(test)] #[phase(plugin, link)] extern crate log;\n-\n-extern crate \"serialize\" as rustc_serialize;\n-extern crate libc;\n-\n-pub use self::ParseError::*;\n-use self::Fmt::*;\n-\n-use std::fmt::{self, Show};\n-use std::num::SignedInt;\n-use std::ops::{Add, Sub};\n-use std::time::Duration;\n-\n-static NSEC_PER_SEC: i32 = 1_000_000_000_i32;\n-\n-mod rustrt {\n-    use super::Tm;\n-\n-    extern {\n-        pub fn rust_tzset();\n-        pub fn rust_gmtime(sec: i64, nsec: i32, result: &mut Tm);\n-        pub fn rust_localtime(sec: i64, nsec: i32, result: &mut Tm);\n-        pub fn rust_timegm(tm: &Tm) -> i64;\n-        pub fn rust_mktime(tm: &Tm) -> i64;\n-    }\n-}\n-\n-#[cfg(all(unix, not(target_os = \"macos\"), not(target_os = \"ios\")))]\n-mod imp {\n-    use libc::{c_int, timespec};\n-\n-    // Apparently android provides this in some other library?\n-    #[cfg(not(target_os = \"android\"))]\n-    #[link(name = \"rt\")]\n-    extern {}\n-\n-    extern {\n-        pub fn clock_gettime(clk_id: c_int, tp: *mut timespec) -> c_int;\n-    }\n-\n-}\n-#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-mod imp {\n-    use libc::{timeval, timezone, c_int, mach_timebase_info};\n-\n-    extern {\n-        pub fn gettimeofday(tp: *mut timeval, tzp: *mut timezone) -> c_int;\n-        pub fn mach_absolute_time() -> u64;\n-        pub fn mach_timebase_info(info: *mut mach_timebase_info) -> c_int;\n-    }\n-}\n-\n-/// A record specifying a time value in seconds and nanoseconds.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable,\n-           RustcDecodable, Show, Copy)]\n-pub struct Timespec {\n-    pub sec: i64,\n-    pub nsec: i32,\n-}\n-\n-/*\n- * Timespec assumes that pre-epoch Timespecs have negative sec and positive\n- * nsec fields. Darwin's and Linux's struct timespec functions handle pre-\n- * epoch timestamps using a \"two steps back, one step forward\" representation,\n- * though the man pages do not actually document this. For example, the time\n- * -1.2 seconds before the epoch is represented by `Timespec { sec: -2_i64,\n- * nsec: 800_000_000_i32 }`.\n- */\n-impl Timespec {\n-    pub fn new(sec: i64, nsec: i32) -> Timespec {\n-        assert!(nsec >= 0 && nsec < NSEC_PER_SEC);\n-        Timespec { sec: sec, nsec: nsec }\n-    }\n-}\n-\n-impl Add<Duration> for Timespec {\n-    type Output = Timespec;\n-\n-    fn add(self, other: Duration) -> Timespec {\n-        let d_sec = other.num_seconds();\n-        // It is safe to unwrap the nanoseconds, because there cannot be\n-        // more than one second left, which fits in i64 and in i32.\n-        let d_nsec = (other - Duration::seconds(d_sec))\n-                     .num_nanoseconds().unwrap() as i32;\n-        let mut sec = self.sec + d_sec;\n-        let mut nsec = self.nsec + d_nsec;\n-        if nsec >= NSEC_PER_SEC {\n-            nsec -= NSEC_PER_SEC;\n-            sec += 1;\n-        } else if nsec < 0 {\n-            nsec += NSEC_PER_SEC;\n-            sec -= 1;\n-        }\n-        Timespec::new(sec, nsec)\n-    }\n-}\n-\n-impl Sub for Timespec {\n-    type Output = Duration;\n-\n-    fn sub(self, other: Timespec) -> Duration {\n-        let sec = self.sec - other.sec;\n-        let nsec = self.nsec - other.nsec;\n-        Duration::seconds(sec) + Duration::nanoseconds(nsec as i64)\n-    }\n-}\n-\n-/// Returns the current time as a `timespec` containing the seconds and\n-/// nanoseconds since 1970-01-01T00:00:00Z.\n-pub fn get_time() -> Timespec {\n-    unsafe {\n-        let (sec, nsec) = os_get_time();\n-        return Timespec::new(sec, nsec);\n-    }\n-\n-    #[cfg(windows)]\n-    unsafe fn os_get_time() -> (i64, i32) {\n-        static NANOSECONDS_FROM_1601_TO_1970: u64 = 11644473600000000;\n-\n-        let mut time = libc::FILETIME {\n-            dwLowDateTime: 0,\n-            dwHighDateTime: 0,\n-        };\n-        libc::GetSystemTimeAsFileTime(&mut time);\n-\n-        // A FILETIME contains a 64-bit value representing the number of\n-        // hectonanosecond (100-nanosecond) intervals since 1601-01-01T00:00:00Z.\n-        // http://support.microsoft.com/kb/167296/en-us\n-        let ns_since_1601 = (((time.dwHighDateTime as u64) << 32) |\n-                             ((time.dwLowDateTime  as u64) <<  0)) / 10;\n-        let ns_since_1970 = ns_since_1601 - NANOSECONDS_FROM_1601_TO_1970;\n-\n-        ((ns_since_1970 / 1000000) as i64,\n-         ((ns_since_1970 % 1000000) * 1000) as i32)\n-    }\n-\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-    unsafe fn os_get_time() -> (i64, i32) {\n-        use std::ptr;\n-        let mut tv = libc::timeval { tv_sec: 0, tv_usec: 0 };\n-        imp::gettimeofday(&mut tv, ptr::null_mut());\n-        (tv.tv_sec as i64, tv.tv_usec * 1000)\n-    }\n-\n-    #[cfg(not(any(target_os = \"macos\", target_os = \"ios\", windows)))]\n-    unsafe fn os_get_time() -> (i64, i32) {\n-        let mut tv = libc::timespec { tv_sec: 0, tv_nsec: 0 };\n-        imp::clock_gettime(libc::CLOCK_REALTIME, &mut tv);\n-        (tv.tv_sec as i64, tv.tv_nsec as i32)\n-    }\n-}\n-\n-\n-/// Returns the current value of a high-resolution performance counter\n-/// in nanoseconds since an unspecified epoch.\n-pub fn precise_time_ns() -> u64 {\n-    return os_precise_time_ns();\n-\n-    #[cfg(windows)]\n-    fn os_precise_time_ns() -> u64 {\n-        let mut ticks_per_s = 0;\n-        assert_eq!(unsafe {\n-            libc::QueryPerformanceFrequency(&mut ticks_per_s)\n-        }, 1);\n-        let ticks_per_s = if ticks_per_s == 0 {1} else {ticks_per_s};\n-        let mut ticks = 0;\n-        assert_eq!(unsafe {\n-            libc::QueryPerformanceCounter(&mut ticks)\n-        }, 1);\n-\n-        return (ticks as u64 * 1000000000) / (ticks_per_s as u64);\n-    }\n-\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-    fn os_precise_time_ns() -> u64 {\n-        static mut TIMEBASE: libc::mach_timebase_info = libc::mach_timebase_info { numer: 0,\n-                                                                                   denom: 0 };\n-        static ONCE: std::sync::Once = std::sync::ONCE_INIT;\n-        unsafe {\n-            ONCE.call_once(|| {\n-                imp::mach_timebase_info(&mut TIMEBASE);\n-            });\n-            let time = imp::mach_absolute_time();\n-            time * TIMEBASE.numer as u64 / TIMEBASE.denom as u64\n-        }\n-    }\n-\n-    #[cfg(not(any(windows, target_os = \"macos\", target_os = \"ios\")))]\n-    fn os_precise_time_ns() -> u64 {\n-        let mut ts = libc::timespec { tv_sec: 0, tv_nsec: 0 };\n-        unsafe {\n-            imp::clock_gettime(libc::CLOCK_MONOTONIC, &mut ts);\n-        }\n-        return (ts.tv_sec as u64) * 1000000000 + (ts.tv_nsec as u64)\n-    }\n-}\n-\n-\n-/// Returns the current value of a high-resolution performance counter\n-/// in seconds since an unspecified epoch.\n-pub fn precise_time_s() -> f64 {\n-    return (precise_time_ns() as f64) / 1000000000.;\n-}\n-\n-pub fn tzset() {\n-    unsafe {\n-        rustrt::rust_tzset();\n-    }\n-}\n-\n-/// Holds a calendar date and time broken down into its components (year, month, day, and so on),\n-/// also called a broken-down time value.\n-// FIXME: use c_int instead of i32?\n-#[repr(C)]\n-#[derive(Clone, Copy, PartialEq, Eq, Show)]\n-pub struct Tm {\n-    /// Seconds after the minute - [0, 60]\n-    pub tm_sec: i32,\n-\n-    /// Minutes after the hour - [0, 59]\n-    pub tm_min: i32,\n-\n-    /// Hours after midnight - [0, 23]\n-    pub tm_hour: i32,\n-\n-    /// Day of the month - [1, 31]\n-    pub tm_mday: i32,\n-\n-    /// Months since January - [0, 11]\n-    pub tm_mon: i32,\n-\n-    /// Years since 1900\n-    pub tm_year: i32,\n-\n-    /// Days since Sunday - [0, 6]. 0 = Sunday, 1 = Monday, ..., 6 = Saturday.\n-    pub tm_wday: i32,\n-\n-    /// Days since January 1 - [0, 365]\n-    pub tm_yday: i32,\n-\n-    /// Daylight Saving Time flag.\n-    ///\n-    /// This value is positive if Daylight Saving Time is in effect, zero if Daylight Saving Time\n-    /// is not in effect, and negative if this information is not available.\n-    pub tm_isdst: i32,\n-\n-    /// Identifies the time zone that was used to compute this broken-down time value, including any\n-    /// adjustment for Daylight Saving Time. This is the number of seconds east of UTC. For example,\n-    /// for U.S. Pacific Daylight Time, the value is -7*60*60 = -25200.\n-    pub tm_gmtoff: i32,\n-\n-    /// Nanoseconds after the second - [0, 10<sup>9</sup> - 1]\n-    pub tm_nsec: i32,\n-}\n-\n-pub fn empty_tm() -> Tm {\n-    Tm {\n-        tm_sec: 0_i32,\n-        tm_min: 0_i32,\n-        tm_hour: 0_i32,\n-        tm_mday: 0_i32,\n-        tm_mon: 0_i32,\n-        tm_year: 0_i32,\n-        tm_wday: 0_i32,\n-        tm_yday: 0_i32,\n-        tm_isdst: 0_i32,\n-        tm_gmtoff: 0_i32,\n-        tm_nsec: 0_i32,\n-    }\n-}\n-\n-/// Returns the specified time in UTC\n-pub fn at_utc(clock: Timespec) -> Tm {\n-    unsafe {\n-        let Timespec { sec, nsec } = clock;\n-        let mut tm = empty_tm();\n-        rustrt::rust_gmtime(sec, nsec, &mut tm);\n-        tm\n-    }\n-}\n-\n-/// Returns the current time in UTC\n-pub fn now_utc() -> Tm {\n-    at_utc(get_time())\n-}\n-\n-/// Returns the specified time in the local timezone\n-pub fn at(clock: Timespec) -> Tm {\n-    unsafe {\n-        let Timespec { sec, nsec } = clock;\n-        let mut tm = empty_tm();\n-        rustrt::rust_localtime(sec, nsec, &mut tm);\n-        tm\n-    }\n-}\n-\n-/// Returns the current time in the local timezone\n-pub fn now() -> Tm {\n-    at(get_time())\n-}\n-\n-impl Tm {\n-    /// Convert time to the seconds from January 1, 1970\n-    pub fn to_timespec(&self) -> Timespec {\n-        unsafe {\n-            let sec = match self.tm_gmtoff {\n-                0_i32 => rustrt::rust_timegm(self),\n-                _     => rustrt::rust_mktime(self)\n-            };\n-\n-            Timespec::new(sec, self.tm_nsec)\n-        }\n-    }\n-\n-    /// Convert time to the local timezone\n-    pub fn to_local(&self) -> Tm {\n-        at(self.to_timespec())\n-    }\n-\n-    /// Convert time to the UTC\n-    pub fn to_utc(&self) -> Tm {\n-        at_utc(self.to_timespec())\n-    }\n-\n-    /// Returns a TmFmt that outputs according to the `asctime` format in ISO\n-    /// C, in the local timezone.\n-    ///\n-    /// Example: \"Thu Jan  1 00:00:00 1970\"\n-    pub fn ctime(&self) -> TmFmt {\n-        TmFmt {\n-            tm: self,\n-            format: FmtCtime,\n-        }\n-    }\n-\n-    /// Returns a TmFmt that outputs according to the `asctime` format in ISO\n-    /// C.\n-    ///\n-    /// Example: \"Thu Jan  1 00:00:00 1970\"\n-    pub fn asctime(&self) -> TmFmt {\n-        TmFmt {\n-            tm: self,\n-            format: FmtStr(\"%c\"),\n-        }\n-    }\n-\n-    /// Formats the time according to the format string.\n-    pub fn strftime<'a>(&'a self, format: &'a str) -> Result<TmFmt<'a>, ParseError> {\n-        validate_format(TmFmt {\n-            tm: self,\n-            format: FmtStr(format),\n-        })\n-    }\n-\n-    /// Returns a TmFmt that outputs according to RFC 822.\n-    ///\n-    /// local: \"Thu, 22 Mar 2012 07:53:18 PST\"\n-    /// utc:   \"Thu, 22 Mar 2012 14:53:18 GMT\"\n-    pub fn rfc822(&self) -> TmFmt {\n-        if self.tm_gmtoff == 0_i32 {\n-            TmFmt {\n-                tm: self,\n-                format: FmtStr(\"%a, %d %b %Y %T GMT\"),\n-            }\n-        } else {\n-            TmFmt {\n-                tm: self,\n-                format: FmtStr(\"%a, %d %b %Y %T %Z\"),\n-            }\n-        }\n-    }\n-\n-    /// Returns a TmFmt that outputs according to RFC 822 with Zulu time.\n-    ///\n-    /// local: \"Thu, 22 Mar 2012 07:53:18 -0700\"\n-    /// utc:   \"Thu, 22 Mar 2012 14:53:18 -0000\"\n-    pub fn rfc822z(&self) -> TmFmt {\n-        TmFmt {\n-            tm: self,\n-            format: FmtStr(\"%a, %d %b %Y %T %z\"),\n-        }\n-    }\n-\n-    /// Returns a TmFmt that outputs according to RFC 3339. RFC 3339 is\n-    /// compatible with ISO 8601.\n-    ///\n-    /// local: \"2012-02-22T07:53:18-07:00\"\n-    /// utc:   \"2012-02-22T14:53:18Z\"\n-    pub fn rfc3339<'a>(&'a self) -> TmFmt {\n-        TmFmt {\n-            tm: self,\n-            format: FmtRfc3339,\n-        }\n-    }\n-}\n-\n-#[derive(Copy, PartialEq)]\n-pub enum ParseError {\n-    InvalidSecond,\n-    InvalidMinute,\n-    InvalidHour,\n-    InvalidDay,\n-    InvalidMonth,\n-    InvalidYear,\n-    InvalidDayOfWeek,\n-    InvalidDayOfMonth,\n-    InvalidDayOfYear,\n-    InvalidZoneOffset,\n-    InvalidTime,\n-    MissingFormatConverter,\n-    InvalidFormatSpecifier(char),\n-    UnexpectedCharacter(char, char),\n-}\n-\n-impl Show for ParseError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            InvalidSecond => write!(f, \"Invalid second.\"),\n-            InvalidMinute => write!(f, \"Invalid minute.\"),\n-            InvalidHour => write!(f, \"Invalid hour.\"),\n-            InvalidDay => write!(f, \"Invalid day.\"),\n-            InvalidMonth => write!(f, \"Invalid month.\"),\n-            InvalidYear => write!(f, \"Invalid year.\"),\n-            InvalidDayOfWeek => write!(f, \"Invalid day of the week.\"),\n-            InvalidDayOfMonth => write!(f, \"Invalid day of the month.\"),\n-            InvalidDayOfYear => write!(f, \"Invalid day of the year.\"),\n-            InvalidZoneOffset => write!(f, \"Invalid zone offset.\"),\n-            InvalidTime => write!(f, \"Invalid time.\"),\n-            MissingFormatConverter => write!(f, \"Missing format converter after `%`\"),\n-            InvalidFormatSpecifier(ch) => write!(f, \"Invalid format specifier: %{}\", ch),\n-            UnexpectedCharacter(a, b) => write!(f, \"Expected: {}, found: {}.\", a, b),\n-        }\n-    }\n-}\n-\n-/// A wrapper around a `Tm` and format string that implements Show.\n-pub struct TmFmt<'a> {\n-    tm: &'a Tm,\n-    format: Fmt<'a>\n-}\n-\n-enum Fmt<'a> {\n-    FmtStr(&'a str),\n-    FmtRfc3339,\n-    FmtCtime,\n-}\n-\n-fn validate_format<'a>(fmt: TmFmt<'a>) -> Result<TmFmt<'a>, ParseError> {\n-\n-    match (fmt.tm.tm_wday, fmt.tm.tm_mon) {\n-        (0...6, 0...11) => (),\n-        (_wday, 0...11) => return Err(InvalidDayOfWeek),\n-        (0...6, _mon) => return Err(InvalidMonth),\n-        _ => return Err(InvalidDay)\n-    }\n-    match fmt.format {\n-        FmtStr(ref s) => {\n-            let mut chars = s.chars();\n-            loop {\n-                match chars.next() {\n-                    Some('%') => {\n-                        match chars.next() {\n-                            Some('A') |\n-                            Some('a') |\n-                            Some('B') |\n-                            Some('b') |\n-                            Some('C') |\n-                            Some('c') |\n-                            Some('D') |\n-                            Some('d') |\n-                            Some('e') |\n-                            Some('F') |\n-                            Some('f') |\n-                            Some('G') |\n-                            Some('g') |\n-                            Some('H') |\n-                            Some('h') |\n-                            Some('I') |\n-                            Some('j') |\n-                            Some('k') |\n-                            Some('l') |\n-                            Some('M') |\n-                            Some('m') |\n-                            Some('n') |\n-                            Some('P') |\n-                            Some('p') |\n-                            Some('R') |\n-                            Some('r') |\n-                            Some('S') |\n-                            Some('s') |\n-                            Some('T') |\n-                            Some('t') |\n-                            Some('U') |\n-                            Some('u') |\n-                            Some('V') |\n-                            Some('v') |\n-                            Some('W') |\n-                            Some('w') |\n-                            Some('X') |\n-                            Some('x') |\n-                            Some('Y') |\n-                            Some('y') |\n-                            Some('Z') |\n-                            Some('z') |\n-                            Some('+') |\n-                            Some('%')\n-                                => (),\n-                            Some(c) => return Err(InvalidFormatSpecifier(c)),\n-                            None => return Err(MissingFormatConverter),\n-                        }\n-                    },\n-                    None => break,\n-                    _ => ()\n-                }\n-            }\n-        },\n-        _ => ()\n-    }\n-    Ok(fmt)\n-}\n-\n-impl<'a> fmt::Show for TmFmt<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        fn days_in_year(year: int) -> i32 {\n-            if (year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0)) {\n-                366    /* Days in a leap year */\n-            } else {\n-                365    /* Days in a non-leap year */\n-            }\n-        }\n-\n-        fn iso_week_days(yday: i32, wday: i32) -> int {\n-            /* The number of days from the first day of the first ISO week of this\n-            * year to the year day YDAY with week day WDAY.\n-            * ISO weeks start on Monday. The first ISO week has the year's first\n-            * Thursday.\n-            * YDAY may be as small as yday_minimum.\n-            */\n-            let yday: int = yday as int;\n-            let wday: int = wday as int;\n-            let iso_week_start_wday: int = 1;                     /* Monday */\n-            let iso_week1_wday: int = 4;                          /* Thursday */\n-            let yday_minimum: int = 366;\n-            /* Add enough to the first operand of % to make it nonnegative. */\n-            let big_enough_multiple_of_7: int = (yday_minimum / 7 + 2) * 7;\n-\n-            yday - (yday - wday + iso_week1_wday + big_enough_multiple_of_7) % 7\n-                + iso_week1_wday - iso_week_start_wday\n-        }\n-\n-        fn iso_week(fmt: &mut fmt::Formatter, ch:char, tm: &Tm) -> fmt::Result {\n-            let mut year: int = tm.tm_year as int + 1900;\n-            let mut days: int = iso_week_days (tm.tm_yday, tm.tm_wday);\n-\n-            if days < 0 {\n-                /* This ISO week belongs to the previous year. */\n-                year -= 1;\n-                days = iso_week_days (tm.tm_yday + (days_in_year(year)), tm.tm_wday);\n-            } else {\n-                let d: int = iso_week_days (tm.tm_yday - (days_in_year(year)),\n-                                            tm.tm_wday);\n-                if 0 <= d {\n-                    /* This ISO week belongs to the next year. */\n-                    year += 1;\n-                    days = d;\n-                }\n-            }\n-\n-            match ch {\n-                'G' => write!(fmt, \"{}\", year),\n-                'g' => write!(fmt, \"{:02}\", (year % 100 + 100) % 100),\n-                'V' => write!(fmt, \"{:02}\", days / 7 + 1),\n-                _ => Ok(())\n-            }\n-        }\n-\n-        fn parse_type(fmt: &mut fmt::Formatter, ch: char, tm: &Tm) -> fmt::Result {\n-            let die = |&:| {\n-                unreachable!()\n-            };\n-            match ch {\n-              'A' => match tm.tm_wday as int {\n-                0 => \"Sunday\",\n-                1 => \"Monday\",\n-                2 => \"Tuesday\",\n-                3 => \"Wednesday\",\n-                4 => \"Thursday\",\n-                5 => \"Friday\",\n-                6 => \"Saturday\",\n-                _ => return die()\n-              },\n-             'a' => match tm.tm_wday as int {\n-                0 => \"Sun\",\n-                1 => \"Mon\",\n-                2 => \"Tue\",\n-                3 => \"Wed\",\n-                4 => \"Thu\",\n-                5 => \"Fri\",\n-                6 => \"Sat\",\n-                _ => return die()\n-              },\n-              'B' => match tm.tm_mon as int {\n-                0 => \"January\",\n-                1 => \"February\",\n-                2 => \"March\",\n-                3 => \"April\",\n-                4 => \"May\",\n-                5 => \"June\",\n-                6 => \"July\",\n-                7 => \"August\",\n-                8 => \"September\",\n-                9 => \"October\",\n-                10 => \"November\",\n-                11 => \"December\",\n-                _ => return die()\n-              },\n-              'b' | 'h' => match tm.tm_mon as int {\n-                0 => \"Jan\",\n-                1 => \"Feb\",\n-                2 => \"Mar\",\n-                3 => \"Apr\",\n-                4 => \"May\",\n-                5 => \"Jun\",\n-                6 => \"Jul\",\n-                7 => \"Aug\",\n-                8 => \"Sep\",\n-                9 => \"Oct\",\n-                10 => \"Nov\",\n-                11 => \"Dec\",\n-                _  => return die()\n-              },\n-              'C' => return write!(fmt, \"{:02}\", (tm.tm_year as int + 1900) / 100),\n-              'c' => {\n-                    try!(parse_type(fmt, 'a', tm));\n-                    try!(' '.fmt(fmt));\n-                    try!(parse_type(fmt, 'b', tm));\n-                    try!(' '.fmt(fmt));\n-                    try!(parse_type(fmt, 'e', tm));\n-                    try!(' '.fmt(fmt));\n-                    try!(parse_type(fmt, 'T', tm));\n-                    try!(' '.fmt(fmt));\n-                    return parse_type(fmt, 'Y', tm);\n-              }\n-              'D' | 'x' => {\n-                    try!(parse_type(fmt, 'm', tm));\n-                    try!('/'.fmt(fmt));\n-                    try!(parse_type(fmt, 'd', tm));\n-                    try!('/'.fmt(fmt));\n-                    return parse_type(fmt, 'y', tm);\n-              }\n-              'd' => return write!(fmt, \"{:02}\", tm.tm_mday),\n-              'e' => return write!(fmt, \"{:2}\", tm.tm_mday),\n-              'f' => return write!(fmt, \"{:09}\", tm.tm_nsec),\n-              'F' => {\n-                    try!(parse_type(fmt, 'Y', tm));\n-                    try!('-'.fmt(fmt));\n-                    try!(parse_type(fmt, 'm', tm));\n-                    try!('-'.fmt(fmt));\n-                    return parse_type(fmt, 'd', tm);\n-              }\n-              'G' => return iso_week(fmt, 'G', tm),\n-              'g' => return iso_week(fmt, 'g', tm),\n-              'H' => return write!(fmt, \"{:02}\", tm.tm_hour),\n-              'I' => {\n-                let mut h = tm.tm_hour;\n-                if h == 0 { h = 12 }\n-                if h > 12 { h -= 12 }\n-                return write!(fmt, \"{:02}\", h)\n-              }\n-              'j' => return write!(fmt, \"{:03}\", tm.tm_yday + 1),\n-              'k' => return write!(fmt, \"{:2}\", tm.tm_hour),\n-              'l' => {\n-                let mut h = tm.tm_hour;\n-                if h == 0 { h = 12 }\n-                if h > 12 { h -= 12 }\n-                return write!(fmt, \"{:2}\", h)\n-              }\n-              'M' => return write!(fmt, \"{:02}\", tm.tm_min),\n-              'm' => return write!(fmt, \"{:02}\", tm.tm_mon + 1),\n-              'n' => \"\\n\",\n-              'P' => if (tm.tm_hour as int) < 12 { \"am\" } else { \"pm\" },\n-              'p' => if (tm.tm_hour as int) < 12 { \"AM\" } else { \"PM\" },\n-              'R' => {\n-                    try!(parse_type(fmt, 'H', tm));\n-                    try!(':'.fmt(fmt));\n-                    return parse_type(fmt, 'M', tm);\n-              }\n-              'r' => {\n-                    try!(parse_type(fmt, 'I', tm));\n-                    try!(':'.fmt(fmt));\n-                    try!(parse_type(fmt, 'M', tm));\n-                    try!(':'.fmt(fmt));\n-                    try!(parse_type(fmt, 'S', tm));\n-                    try!(' '.fmt(fmt));\n-                    return parse_type(fmt, 'p', tm);\n-              }\n-              'S' => return write!(fmt, \"{:02}\", tm.tm_sec),\n-              's' => return write!(fmt, \"{}\", tm.to_timespec().sec),\n-              'T' | 'X' => {\n-                    try!(parse_type(fmt, 'H', tm));\n-                    try!(':'.fmt(fmt));\n-                    try!(parse_type(fmt, 'M', tm));\n-                    try!(':'.fmt(fmt));\n-                    return parse_type(fmt, 'S', tm);\n-              }\n-              't' => \"\\t\",\n-              'U' => return write!(fmt, \"{:02}\", (tm.tm_yday - tm.tm_wday + 7) / 7),\n-              'u' => {\n-                let i = tm.tm_wday as int;\n-                return (if i == 0 { 7 } else { i }).fmt(fmt);\n-              }\n-              'V' => return iso_week(fmt, 'V', tm),\n-              'v' => {\n-                  try!(parse_type(fmt, 'e', tm));\n-                  try!('-'.fmt(fmt));\n-                  try!(parse_type(fmt, 'b', tm));\n-                  try!('-'.fmt(fmt));\n-                  return parse_type(fmt, 'Y', tm);\n-              }\n-              'W' => {\n-                  return write!(fmt, \"{:02}\",\n-                                 (tm.tm_yday - (tm.tm_wday - 1 + 7) % 7 + 7) / 7)\n-              }\n-              'w' => return (tm.tm_wday as int).fmt(fmt),\n-              'Y' => return (tm.tm_year as int + 1900).fmt(fmt),\n-              'y' => return write!(fmt, \"{:02}\", (tm.tm_year as int + 1900) % 100),\n-              'Z' => if tm.tm_gmtoff == 0_i32 { \"GMT\"} else { \"\" }, // FIXME (#2350): support locale\n-              'z' => {\n-                let sign = if tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n-                let mut m = tm.tm_gmtoff.abs() / 60_i32;\n-                let h = m / 60_i32;\n-                m -= h * 60_i32;\n-                return write!(fmt, \"{}{:02}{:02}\", sign, h, m);\n-              }\n-              '+' => return tm.rfc3339().fmt(fmt),\n-              '%' => \"%\",\n-              _   => return die()\n-            }.fmt(fmt)\n-        }\n-\n-        match self.format {\n-            FmtStr(ref s) => {\n-                let mut chars = s.chars();\n-                loop {\n-                    match chars.next() {\n-                        Some('%') => {\n-                            // we've already validated that % always precedes another char\n-                            try!(parse_type(fmt, chars.next().unwrap(), self.tm));\n-                        }\n-                        Some(ch) => try!(ch.fmt(fmt)),\n-                        None => break,\n-                    }\n-                }\n-\n-                Ok(())\n-            }\n-            FmtCtime => {\n-                self.tm.to_local().asctime().fmt(fmt)\n-            }\n-            FmtRfc3339 => {\n-                if self.tm.tm_gmtoff == 0_i32 {\n-                    TmFmt {\n-                        tm: self.tm,\n-                        format: FmtStr(\"%Y-%m-%dT%H:%M:%SZ\"),\n-                    }.fmt(fmt)\n-                } else {\n-                    let s = TmFmt {\n-                        tm: self.tm,\n-                        format: FmtStr(\"%Y-%m-%dT%H:%M:%S\"),\n-                    };\n-                    let sign = if self.tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n-                    let mut m = self.tm.tm_gmtoff.abs() / 60_i32;\n-                    let h = m / 60_i32;\n-                    m -= h * 60_i32;\n-                    write!(fmt, \"{}{}{:02}:{:02}\", s, sign, h as int, m as int)\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-/// Parses the time from the string according to the format string.\n-pub fn strptime(s: &str, format: &str) -> Result<Tm, ParseError> {\n-    fn match_str(s: &str, pos: uint, needle: &str) -> bool {\n-        s.slice_from(pos).starts_with(needle)\n-    }\n-\n-    fn match_strs(ss: &str, pos: uint, strs: &[(&str, i32)])\n-      -> Option<(i32, uint)> {\n-        for &(needle, value) in strs.iter() {\n-            if match_str(ss, pos, needle) {\n-                return Some((value, pos + needle.len()));\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    fn match_digits(ss: &str, pos: uint, digits: uint, ws: bool)\n-      -> Option<(i32, uint)> {\n-        let mut pos = pos;\n-        let len = ss.len();\n-        let mut value = 0_i32;\n-\n-        let mut i = 0u;\n-        while i < digits {\n-            if pos >= len {\n-                return None;\n-            }\n-            let range = ss.char_range_at(pos);\n-            pos = range.next;\n-\n-            match range.ch {\n-              '0' ... '9' => {\n-                value = value * 10_i32 + (range.ch as i32 - '0' as i32);\n-              }\n-              ' ' if ws => (),\n-              _ => return None\n-            }\n-            i += 1u;\n-        }\n-\n-        Some((value, pos))\n-    }\n-\n-    fn match_fractional_seconds(ss: &str, pos: uint) -> (i32, uint) {\n-        let len = ss.len();\n-        let mut value = 0_i32;\n-        let mut multiplier = NSEC_PER_SEC / 10;\n-        let mut pos = pos;\n-\n-        loop {\n-            if pos >= len {\n-                break;\n-            }\n-            let range = ss.char_range_at(pos);\n-\n-            match range.ch {\n-                '0' ... '9' => {\n-                    pos = range.next;\n-                    // This will drop digits after the nanoseconds place\n-                    let digit = range.ch as i32 - '0' as i32;\n-                    value += digit * multiplier;\n-                    multiplier /= 10;\n-                }\n-                _ => break\n-            }\n-        }\n-\n-        (value, pos)\n-    }\n-\n-    fn match_digits_in_range(ss: &str, pos: uint, digits: uint, ws: bool,\n-                             min: i32, max: i32) -> Option<(i32, uint)> {\n-        match match_digits(ss, pos, digits, ws) {\n-          Some((val, pos)) if val >= min && val <= max => {\n-            Some((val, pos))\n-          }\n-          _ => None\n-        }\n-    }\n-\n-    fn parse_char(s: &str, pos: uint, c: char) -> Result<uint, ParseError> {\n-        let range = s.char_range_at(pos);\n-\n-        if c == range.ch {\n-            Ok(range.next)\n-        } else {\n-            Err(UnexpectedCharacter(c, range.ch))\n-        }\n-    }\n-\n-    fn parse_type(s: &str, pos: uint, ch: char, tm: &mut Tm)\n-      -> Result<uint, ParseError> {\n-        match ch {\n-          'A' => match match_strs(s, pos, &[\n-              (\"Sunday\", 0_i32),\n-              (\"Monday\", 1_i32),\n-              (\"Tuesday\", 2_i32),\n-              (\"Wednesday\", 3_i32),\n-              (\"Thursday\", 4_i32),\n-              (\"Friday\", 5_i32),\n-              (\"Saturday\", 6_i32)\n-          ]) {\n-            Some(item) => { let (v, pos) = item; tm.tm_wday = v; Ok(pos) }\n-            None => Err(InvalidDay)\n-          },\n-          'a' => match match_strs(s, pos, &[\n-              (\"Sun\", 0_i32),\n-              (\"Mon\", 1_i32),\n-              (\"Tue\", 2_i32),\n-              (\"Wed\", 3_i32),\n-              (\"Thu\", 4_i32),\n-              (\"Fri\", 5_i32),\n-              (\"Sat\", 6_i32)\n-          ]) {\n-            Some(item) => { let (v, pos) = item; tm.tm_wday = v; Ok(pos) }\n-            None => Err(InvalidDay)\n-          },\n-          'B' => match match_strs(s, pos, &[\n-              (\"January\", 0_i32),\n-              (\"February\", 1_i32),\n-              (\"March\", 2_i32),\n-              (\"April\", 3_i32),\n-              (\"May\", 4_i32),\n-              (\"June\", 5_i32),\n-              (\"July\", 6_i32),\n-              (\"August\", 7_i32),\n-              (\"September\", 8_i32),\n-              (\"October\", 9_i32),\n-              (\"November\", 10_i32),\n-              (\"December\", 11_i32)\n-          ]) {\n-            Some(item) => { let (v, pos) = item; tm.tm_mon = v; Ok(pos) }\n-            None => Err(InvalidMonth)\n-          },\n-          'b' | 'h' => match match_strs(s, pos, &[\n-              (\"Jan\", 0_i32),\n-              (\"Feb\", 1_i32),\n-              (\"Mar\", 2_i32),\n-              (\"Apr\", 3_i32),\n-              (\"May\", 4_i32),\n-              (\"Jun\", 5_i32),\n-              (\"Jul\", 6_i32),\n-              (\"Aug\", 7_i32),\n-              (\"Sep\", 8_i32),\n-              (\"Oct\", 9_i32),\n-              (\"Nov\", 10_i32),\n-              (\"Dec\", 11_i32)\n-          ]) {\n-            Some(item) => { let (v, pos) = item; tm.tm_mon = v; Ok(pos) }\n-            None => Err(InvalidMonth)\n-          },\n-          'C' => match match_digits_in_range(s, pos, 2u, false, 0_i32,\n-                                             99_i32) {\n-            Some(item) => {\n-                let (v, pos) = item;\n-                  tm.tm_year += (v * 100_i32) - 1900_i32;\n-                  Ok(pos)\n-              }\n-            None => Err(InvalidYear)\n-          },\n-          'c' => {\n-            parse_type(s, pos, 'a', &mut *tm)\n-                .and_then(|pos| parse_char(s, pos, ' '))\n-                .and_then(|pos| parse_type(s, pos, 'b', &mut *tm))\n-                .and_then(|pos| parse_char(s, pos, ' '))\n-                .and_then(|pos| parse_type(s, pos, 'e', &mut *tm))\n-                .and_then(|pos| parse_char(s, pos, ' '))\n-                .and_then(|pos| parse_type(s, pos, 'T', &mut *tm))\n-                .and_then(|pos| parse_char(s, pos, ' '))\n-                .and_then(|pos| parse_type(s, pos, 'Y', &mut *tm))\n-          }\n-          'D' | 'x' => {\n-            parse_type(s, pos, 'm', &mut *tm)\n-                .and_then(|pos| parse_char(s, pos, '/'))\n-                .and_then(|pos| parse_type(s, pos, 'd', &mut *tm))\n-                .and_then(|pos| parse_char(s, pos, '/'))\n-                .and_then(|pos| parse_type(s, pos, 'y', &mut *tm))\n-          }\n-          'd' => match match_digits_in_range(s, pos, 2u, false, 1_i32,\n-                                             31_i32) {\n-            Some(item) => { let (v, pos) = item; tm.tm_mday = v; Ok(pos) }\n-            None => Err(InvalidDayOfMonth)\n-          },\n-          'e' => match match_digits_in_range(s, pos, 2u, true, 1_i32,\n-                                             31_i32) {\n-            Some(item) => { let (v, pos) = item; tm.tm_mday = v; Ok(pos) }\n-            None => Err(InvalidDayOfMonth)\n-          },\n-          'f' => {\n-            let (val, pos) = match_fractional_seconds(s, pos);\n-            tm.tm_nsec = val;\n-            Ok(pos)\n-          }\n-          'F' => {\n-            parse_type(s, pos, 'Y', &mut *tm)\n-                .and_then(|pos| parse_char(s, pos, '-'))\n-                .and_then(|pos| parse_type(s, pos, 'm', &mut *tm))\n-                .and_then(|pos| parse_char(s, pos, '-'))\n-                .and_then(|pos| parse_type(s, pos, 'd', &mut *tm))\n-          }\n-          'H' => {\n-            match match_digits_in_range(s, pos, 2u, false, 0_i32, 23_i32) {\n-              Some(item) => { let (v, pos) = item; tm.tm_hour = v; Ok(pos) }\n-              None => Err(InvalidHour)\n-            }\n-          }\n-          'I' => {\n-            match match_digits_in_range(s, pos, 2u, false, 1_i32, 12_i32) {\n-              Some(item) => {\n-                  let (v, pos) = item;\n-                  tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n-                  Ok(pos)\n-              }\n-              None => Err(InvalidHour)\n-            }\n-          }\n-          'j' => {\n-            match match_digits_in_range(s, pos, 3u, false, 1_i32, 366_i32) {\n-              Some(item) => {\n-                let (v, pos) = item;\n-                tm.tm_yday = v - 1_i32;\n-                Ok(pos)\n-              }\n-              None => Err(InvalidDayOfYear)\n-            }\n-          }\n-          'k' => {\n-            match match_digits_in_range(s, pos, 2u, true, 0_i32, 23_i32) {\n-              Some(item) => { let (v, pos) = item; tm.tm_hour = v; Ok(pos) }\n-              None => Err(InvalidHour)\n-            }\n-          }\n-          'l' => {\n-            match match_digits_in_range(s, pos, 2u, true, 1_i32, 12_i32) {\n-              Some(item) => {\n-                  let (v, pos) = item;\n-                  tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n-                  Ok(pos)\n-              }\n-              None => Err(InvalidHour)\n-            }\n-          }\n-          'M' => {\n-            match match_digits_in_range(s, pos, 2u, false, 0_i32, 59_i32) {\n-              Some(item) => { let (v, pos) = item; tm.tm_min = v; Ok(pos) }\n-              None => Err(InvalidMinute)\n-            }\n-          }\n-          'm' => {\n-            match match_digits_in_range(s, pos, 2u, false, 1_i32, 12_i32) {\n-              Some(item) => {\n-                let (v, pos) = item;\n-                tm.tm_mon = v - 1_i32;\n-                Ok(pos)\n-              }\n-              None => Err(InvalidMonth)\n-            }\n-          }\n-          'n' => parse_char(s, pos, '\\n'),\n-          'P' => match match_strs(s, pos,\n-                                  &[(\"am\", 0_i32), (\"pm\", 12_i32)]) {\n-\n-            Some(item) => { let (v, pos) = item; tm.tm_hour += v; Ok(pos) }\n-            None => Err(InvalidHour)\n-          },\n-          'p' => match match_strs(s, pos,\n-                                  &[(\"AM\", 0_i32), (\"PM\", 12_i32)]) {\n-\n-            Some(item) => { let (v, pos) = item; tm.tm_hour += v; Ok(pos) }\n-            None => Err(InvalidHour)\n-          },\n-          'R' => {\n-            parse_type(s, pos, 'H', &mut *tm)\n-                .and_then(|pos| parse_char(s, pos, ':'))\n-                .and_then(|pos| parse_type(s, pos, 'M', &mut *tm))\n-          }\n-          'r' => {\n-            parse_type(s, pos, 'I', &mut *tm)\n-                .and_then(|pos| parse_char(s, pos, ':'))\n-                .and_then(|pos| parse_type(s, pos, 'M', &mut *tm))\n-                .and_then(|pos| parse_char(s, pos, ':'))\n-                .and_then(|pos| parse_type(s, pos, 'S', &mut *tm))\n-                .and_then(|pos| parse_char(s, pos, ' '))\n-                .and_then(|pos| parse_type(s, pos, 'p', &mut *tm))\n-          }\n-          'S' => {\n-            match match_digits_in_range(s, pos, 2u, false, 0_i32, 60_i32) {\n-              Some(item) => {\n-                let (v, pos) = item;\n-                tm.tm_sec = v;\n-                Ok(pos)\n-              }\n-              None => Err(InvalidSecond)\n-            }\n-          }\n-          //'s' {}\n-          'T' | 'X' => {\n-            parse_type(s, pos, 'H', &mut *tm)\n-                .and_then(|pos| parse_char(s, pos, ':'))\n-                .and_then(|pos| parse_type(s, pos, 'M', &mut *tm))\n-                .and_then(|pos| parse_char(s, pos, ':'))\n-                .and_then(|pos| parse_type(s, pos, 'S', &mut *tm))\n-          }\n-          't' => parse_char(s, pos, '\\t'),\n-          'u' => {\n-            match match_digits_in_range(s, pos, 1u, false, 1_i32, 7_i32) {\n-              Some(item) => {\n-                let (v, pos) = item;\n-                tm.tm_wday = if v == 7 { 0 } else { v };\n-                Ok(pos)\n-              }\n-              None => Err(InvalidDayOfWeek)\n-            }\n-          }\n-          'v' => {\n-            parse_type(s, pos, 'e', &mut *tm)\n-                .and_then(|pos|  parse_char(s, pos, '-'))\n-                .and_then(|pos| parse_type(s, pos, 'b', &mut *tm))\n-                .and_then(|pos| parse_char(s, pos, '-'))\n-                .and_then(|pos| parse_type(s, pos, 'Y', &mut *tm))\n-          }\n-          //'W' {}\n-          'w' => {\n-            match match_digits_in_range(s, pos, 1u, false, 0_i32, 6_i32) {\n-              Some(item) => { let (v, pos) = item; tm.tm_wday = v; Ok(pos) }\n-              None => Err(InvalidDayOfWeek)\n-            }\n-          }\n-          'Y' => {\n-            match match_digits(s, pos, 4u, false) {\n-              Some(item) => {\n-                let (v, pos) = item;\n-                tm.tm_year = v - 1900_i32;\n-                Ok(pos)\n-              }\n-              None => Err(InvalidYear)\n-            }\n-          }\n-          'y' => {\n-            match match_digits_in_range(s, pos, 2u, false, 0_i32, 99_i32) {\n-              Some(item) => {\n-                let (v, pos) = item;\n-                tm.tm_year = v;\n-                Ok(pos)\n-              }\n-              None => Err(InvalidYear)\n-            }\n-          }\n-          'Z' => {\n-            if match_str(s, pos, \"UTC\") || match_str(s, pos, \"GMT\") {\n-                tm.tm_gmtoff = 0_i32;\n-                Ok(pos + 3u)\n-            } else {\n-                // It's odd, but to maintain compatibility with c's\n-                // strptime we ignore the timezone.\n-                let mut pos = pos;\n-                let len = s.len();\n-                while pos < len {\n-                    let range = s.char_range_at(pos);\n-                    pos = range.next;\n-                    if range.ch == ' ' { break; }\n-                }\n-\n-                Ok(pos)\n-            }\n-          }\n-          'z' => {\n-            let range = s.char_range_at(pos);\n-\n-            if range.ch == '+' || range.ch == '-' {\n-                match match_digits(s, range.next, 4u, false) {\n-                  Some(item) => {\n-                    let (v, pos) = item;\n-                    if v == 0_i32 {\n-                        tm.tm_gmtoff = 0_i32;\n-                    }\n-\n-                    Ok(pos)\n-                  }\n-                  None => Err(InvalidZoneOffset)\n-                }\n-            } else {\n-                Err(InvalidZoneOffset)\n-            }\n-          }\n-          '%' => parse_char(s, pos, '%'),\n-          ch => Err(InvalidFormatSpecifier(ch))\n-        }\n-    }\n-\n-    let mut rdr: &[u8] = format.as_bytes();\n-    let mut tm = Tm {\n-        tm_sec: 0_i32,\n-        tm_min: 0_i32,\n-        tm_hour: 0_i32,\n-        tm_mday: 0_i32,\n-        tm_mon: 0_i32,\n-        tm_year: 0_i32,\n-        tm_wday: 0_i32,\n-        tm_yday: 0_i32,\n-        tm_isdst: 0_i32,\n-        tm_gmtoff: 0_i32,\n-        tm_nsec: 0_i32,\n-    };\n-    let mut pos = 0u;\n-    let len = s.len();\n-    let mut result = Err(InvalidTime);\n-\n-    while pos < len {\n-        let range = s.char_range_at(pos);\n-        let ch = range.ch;\n-        let next = range.next;\n-\n-        let mut buf = [0];\n-        let c = match (&mut rdr).read(&mut buf) {\n-            Ok(..) => buf[0] as char,\n-            Err(..) => break\n-        };\n-        match c {\n-            '%' => {\n-                let ch = match (&mut rdr).read(&mut buf) {\n-                    Ok(..) => buf[0] as char,\n-                    Err(..) => break\n-                };\n-                match parse_type(s, pos, ch, &mut tm) {\n-                    Ok(next) => pos = next,\n-                    Err(e) => { result = Err(e); break; }\n-                }\n-            },\n-            c => {\n-                if c != ch { break }\n-                pos = next;\n-            }\n-        }\n-    }\n-\n-    if pos == len && (&mut rdr).is_empty() {\n-        Ok(Tm {\n-            tm_sec: tm.tm_sec,\n-            tm_min: tm.tm_min,\n-            tm_hour: tm.tm_hour,\n-            tm_mday: tm.tm_mday,\n-            tm_mon: tm.tm_mon,\n-            tm_year: tm.tm_year,\n-            tm_wday: tm.tm_wday,\n-            tm_yday: tm.tm_yday,\n-            tm_isdst: tm.tm_isdst,\n-            tm_gmtoff: tm.tm_gmtoff,\n-            tm_nsec: tm.tm_nsec,\n-        })\n-    } else { result }\n-}\n-\n-/// Formats the time according to the format string.\n-pub fn strftime(format: &str, tm: &Tm) -> Result<String, ParseError> {\n-    tm.strftime(format).map(|fmt| fmt.to_string())\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    extern crate test;\n-    use super::{Timespec, InvalidTime, InvalidYear, get_time, precise_time_ns,\n-                precise_time_s, tzset, at_utc, at, strptime, MissingFormatConverter,\n-                InvalidFormatSpecifier};\n-\n-    use std::f64;\n-    use std::result::Result::{Err, Ok};\n-    use std::time::Duration;\n-    use self::test::Bencher;\n-\n-    #[cfg(windows)]\n-    fn set_time_zone() {\n-        use libc;\n-        use std::c_str::ToCStr;\n-        // Windows crt doesn't see any environment variable set by\n-        // `SetEnvironmentVariable`, which `os::setenv` internally uses.\n-        // It is why we use `putenv` here.\n-        extern {\n-            fn _putenv(envstring: *const libc::c_char) -> libc::c_int;\n-        }\n-\n-        unsafe {\n-            // Windows does not understand \"America/Los_Angeles\".\n-            // PST+08 may look wrong, but not! \"PST\" indicates\n-            // the name of timezone. \"+08\" means UTC = local + 08.\n-            \"TZ=PST+08\".with_c_str(|env| {\n-                _putenv(env);\n-            })\n-        }\n-        tzset();\n-    }\n-    #[cfg(not(windows))]\n-    fn set_time_zone() {\n-        use std::os;\n-        os::setenv(\"TZ\", \"America/Los_Angeles\");\n-        tzset();\n-    }\n-\n-    fn test_get_time() {\n-        static SOME_RECENT_DATE: i64 = 1325376000i64; // 2012-01-01T00:00:00Z\n-        static SOME_FUTURE_DATE: i64 = 1577836800i64; // 2020-01-01T00:00:00Z\n-\n-        let tv1 = get_time();\n-        debug!(\"tv1={} sec + {} nsec\", tv1.sec as uint, tv1.nsec as uint);\n-\n-        assert!(tv1.sec > SOME_RECENT_DATE);\n-        assert!(tv1.nsec < 1000000000i32);\n-\n-        let tv2 = get_time();\n-        debug!(\"tv2={} sec + {} nsec\", tv2.sec as uint, tv2.nsec as uint);\n-\n-        assert!(tv2.sec >= tv1.sec);\n-        assert!(tv2.sec < SOME_FUTURE_DATE);\n-        assert!(tv2.nsec < 1000000000i32);\n-        if tv2.sec == tv1.sec {\n-            assert!(tv2.nsec >= tv1.nsec);\n-        }\n-    }\n-\n-    fn test_precise_time() {\n-        let s0 = precise_time_s();\n-        debug!(\"s0={} sec\", f64::to_str_digits(s0, 9u));\n-        assert!(s0 > 0.);\n-\n-        let ns0 = precise_time_ns();\n-        let ns1 = precise_time_ns();\n-        debug!(\"ns0={} ns\", ns0);\n-        debug!(\"ns1={} ns\", ns1);\n-        assert!(ns1 >= ns0);\n-\n-        let ns2 = precise_time_ns();\n-        debug!(\"ns2={} ns\", ns2);\n-        assert!(ns2 >= ns1);\n-    }\n-\n-    fn test_at_utc() {\n-        set_time_zone();\n-\n-        let time = Timespec::new(1234567890, 54321);\n-        let utc = at_utc(time);\n-\n-        assert_eq!(utc.tm_sec, 30_i32);\n-        assert_eq!(utc.tm_min, 31_i32);\n-        assert_eq!(utc.tm_hour, 23_i32);\n-        assert_eq!(utc.tm_mday, 13_i32);\n-        assert_eq!(utc.tm_mon, 1_i32);\n-        assert_eq!(utc.tm_year, 109_i32);\n-        assert_eq!(utc.tm_wday, 5_i32);\n-        assert_eq!(utc.tm_yday, 43_i32);\n-        assert_eq!(utc.tm_isdst, 0_i32);\n-        assert_eq!(utc.tm_gmtoff, 0_i32);\n-        assert_eq!(utc.tm_nsec, 54321_i32);\n-    }\n-\n-    fn test_at() {\n-        set_time_zone();\n-\n-        let time = Timespec::new(1234567890, 54321);\n-        let local = at(time);\n-\n-        debug!(\"time_at: {}\", local);\n-\n-        assert_eq!(local.tm_sec, 30_i32);\n-        assert_eq!(local.tm_min, 31_i32);\n-        assert_eq!(local.tm_hour, 15_i32);\n-        assert_eq!(local.tm_mday, 13_i32);\n-        assert_eq!(local.tm_mon, 1_i32);\n-        assert_eq!(local.tm_year, 109_i32);\n-        assert_eq!(local.tm_wday, 5_i32);\n-        assert_eq!(local.tm_yday, 43_i32);\n-        assert_eq!(local.tm_isdst, 0_i32);\n-        assert_eq!(local.tm_gmtoff, -28800_i32);\n-        assert_eq!(local.tm_nsec, 54321_i32);\n-    }\n-\n-    fn test_to_timespec() {\n-        set_time_zone();\n-\n-        let time = Timespec::new(1234567890, 54321);\n-        let utc = at_utc(time);\n-\n-        assert_eq!(utc.to_timespec(), time);\n-        assert_eq!(utc.to_local().to_timespec(), time);\n-    }\n-\n-    fn test_conversions() {\n-        set_time_zone();\n-\n-        let time = Timespec::new(1234567890, 54321);\n-        let utc = at_utc(time);\n-        let local = at(time);\n-\n-        assert!(local.to_local() == local);\n-        assert!(local.to_utc() == utc);\n-        assert!(local.to_utc().to_local() == local);\n-        assert!(utc.to_utc() == utc);\n-        assert!(utc.to_local() == local);\n-        assert!(utc.to_local().to_utc() == utc);\n-    }\n-\n-    fn test_strptime() {\n-        set_time_zone();\n-\n-        match strptime(\"\", \"\") {\n-          Ok(ref tm) => {\n-            assert!(tm.tm_sec == 0_i32);\n-            assert!(tm.tm_min == 0_i32);\n-            assert!(tm.tm_hour == 0_i32);\n-            assert!(tm.tm_mday == 0_i32);\n-            assert!(tm.tm_mon == 0_i32);\n-            assert!(tm.tm_year == 0_i32);\n-            assert!(tm.tm_wday == 0_i32);\n-            assert!(tm.tm_isdst == 0_i32);\n-            assert!(tm.tm_gmtoff == 0_i32);\n-            assert!(tm.tm_nsec == 0_i32);\n-          }\n-          Err(_) => ()\n-        }\n-\n-        let format = \"%a %b %e %T.%f %Y\";\n-        assert_eq!(strptime(\"\", format), Err(InvalidTime));\n-        assert!(strptime(\"Fri Feb 13 15:31:30\", format)\n-            == Err(InvalidTime));\n-\n-        match strptime(\"Fri Feb 13 15:31:30.01234 2009\", format) {\n-          Err(e) => panic!(e),\n-          Ok(ref tm) => {\n-            assert!(tm.tm_sec == 30_i32);\n-            assert!(tm.tm_min == 31_i32);\n-            assert!(tm.tm_hour == 15_i32);\n-            assert!(tm.tm_mday == 13_i32);\n-            assert!(tm.tm_mon == 1_i32);\n-            assert!(tm.tm_year == 109_i32);\n-            assert!(tm.tm_wday == 5_i32);\n-            assert!(tm.tm_yday == 0_i32);\n-            assert!(tm.tm_isdst == 0_i32);\n-            assert!(tm.tm_gmtoff == 0_i32);\n-            assert!(tm.tm_nsec == 12340000_i32);\n-          }\n-        }\n-\n-        fn test(s: &str, format: &str) -> bool {\n-            match strptime(s, format) {\n-              Ok(ref tm) => {\n-                tm.strftime(format).unwrap().to_string() == s.to_string()\n-              },\n-              Err(e) => panic!(e)\n-            }\n-        }\n-\n-        let days = [\n-            \"Sunday\".to_string(),\n-            \"Monday\".to_string(),\n-            \"Tuesday\".to_string(),\n-            \"Wednesday\".to_string(),\n-            \"Thursday\".to_string(),\n-            \"Friday\".to_string(),\n-            \"Saturday\".to_string()\n-        ];\n-        for day in days.iter() {\n-            assert!(test(day.as_slice(), \"%A\"));\n-        }\n-\n-        let days = [\n-            \"Sun\".to_string(),\n-            \"Mon\".to_string(),\n-            \"Tue\".to_string(),\n-            \"Wed\".to_string(),\n-            \"Thu\".to_string(),\n-            \"Fri\".to_string(),\n-            \"Sat\".to_string()\n-        ];\n-        for day in days.iter() {\n-            assert!(test(day.as_slice(), \"%a\"));\n-        }\n-\n-        let months = [\n-            \"January\".to_string(),\n-            \"February\".to_string(),\n-            \"March\".to_string(),\n-            \"April\".to_string(),\n-            \"May\".to_string(),\n-            \"June\".to_string(),\n-            \"July\".to_string(),\n-            \"August\".to_string(),\n-            \"September\".to_string(),\n-            \"October\".to_string(),\n-            \"November\".to_string(),\n-            \"December\".to_string()\n-        ];\n-        for day in months.iter() {\n-            assert!(test(day.as_slice(), \"%B\"));\n-        }\n-\n-        let months = [\n-            \"Jan\".to_string(),\n-            \"Feb\".to_string(),\n-            \"Mar\".to_string(),\n-            \"Apr\".to_string(),\n-            \"May\".to_string(),\n-            \"Jun\".to_string(),\n-            \"Jul\".to_string(),\n-            \"Aug\".to_string(),\n-            \"Sep\".to_string(),\n-            \"Oct\".to_string(),\n-            \"Nov\".to_string(),\n-            \"Dec\".to_string()\n-        ];\n-        for day in months.iter() {\n-            assert!(test(day.as_slice(), \"%b\"));\n-        }\n-\n-        assert!(test(\"19\", \"%C\"));\n-        assert!(test(\"Fri Feb 13 23:31:30 2009\", \"%c\"));\n-        assert!(test(\"02/13/09\", \"%D\"));\n-        assert!(test(\"03\", \"%d\"));\n-        assert!(test(\"13\", \"%d\"));\n-        assert!(test(\" 3\", \"%e\"));\n-        assert!(test(\"13\", \"%e\"));\n-        assert!(test(\"2009-02-13\", \"%F\"));\n-        assert!(test(\"03\", \"%H\"));\n-        assert!(test(\"13\", \"%H\"));\n-        assert!(test(\"03\", \"%I\")); // FIXME (#2350): flesh out\n-        assert!(test(\"11\", \"%I\")); // FIXME (#2350): flesh out\n-        assert!(test(\"044\", \"%j\"));\n-        assert!(test(\" 3\", \"%k\"));\n-        assert!(test(\"13\", \"%k\"));\n-        assert!(test(\" 1\", \"%l\"));\n-        assert!(test(\"11\", \"%l\"));\n-        assert!(test(\"03\", \"%M\"));\n-        assert!(test(\"13\", \"%M\"));\n-        assert!(test(\"\\n\", \"%n\"));\n-        assert!(test(\"am\", \"%P\"));\n-        assert!(test(\"pm\", \"%P\"));\n-        assert!(test(\"AM\", \"%p\"));\n-        assert!(test(\"PM\", \"%p\"));\n-        assert!(test(\"23:31\", \"%R\"));\n-        assert!(test(\"11:31:30 AM\", \"%r\"));\n-        assert!(test(\"11:31:30 PM\", \"%r\"));\n-        assert!(test(\"03\", \"%S\"));\n-        assert!(test(\"13\", \"%S\"));\n-        assert!(test(\"15:31:30\", \"%T\"));\n-        assert!(test(\"\\t\", \"%t\"));\n-        assert!(test(\"1\", \"%u\"));\n-        assert!(test(\"7\", \"%u\"));\n-        assert!(test(\"13-Feb-2009\", \"%v\"));\n-        assert!(test(\"0\", \"%w\"));\n-        assert!(test(\"6\", \"%w\"));\n-        assert!(test(\"2009\", \"%Y\"));\n-        assert!(test(\"09\", \"%y\"));\n-        assert!(strptime(\"-0000\", \"%z\").unwrap().tm_gmtoff ==\n-            0);\n-        assert!(strptime(\"-0800\", \"%z\").unwrap().tm_gmtoff ==\n-            0);\n-        assert!(test(\"%\", \"%%\"));\n-\n-        // Test for #7256\n-        assert_eq!(strptime(\"360\", \"%Y-%m-%d\"), Err(InvalidYear));\n-    }\n-\n-    fn test_asctime() {\n-        set_time_zone();\n-\n-        let time = Timespec::new(1234567890, 54321);\n-        let utc   = at_utc(time);\n-        let local = at(time);\n-\n-        debug!(\"test_ctime: {} {}\", utc.asctime(), local.asctime());\n-\n-        assert_eq!(utc.asctime().to_string(), \"Fri Feb 13 23:31:30 2009\");\n-        assert_eq!(local.asctime().to_string(), \"Fri Feb 13 15:31:30 2009\");\n-    }\n-\n-    fn test_ctime() {\n-        set_time_zone();\n-\n-        let time = Timespec::new(1234567890, 54321);\n-        let utc   = at_utc(time);\n-        let local = at(time);\n-\n-        debug!(\"test_ctime: {} {}\", utc.ctime(), local.ctime());\n-\n-        assert_eq!(utc.ctime().to_string(), \"Fri Feb 13 15:31:30 2009\");\n-        assert_eq!(local.ctime().to_string(), \"Fri Feb 13 15:31:30 2009\");\n-    }\n-\n-    fn test_strftime() {\n-        set_time_zone();\n-\n-        let time = Timespec::new(1234567890, 54321);\n-        let utc = at_utc(time);\n-        let local = at(time);\n-\n-        assert_eq!(local.strftime(\"\").unwrap().to_string(), \"\");\n-        assert_eq!(local.strftime(\"%A\").unwrap().to_string(), \"Friday\");\n-        assert_eq!(local.strftime(\"%a\").unwrap().to_string(), \"Fri\");\n-        assert_eq!(local.strftime(\"%B\").unwrap().to_string(), \"February\");\n-        assert_eq!(local.strftime(\"%b\").unwrap().to_string(), \"Feb\");\n-        assert_eq!(local.strftime(\"%C\").unwrap().to_string(), \"20\");\n-        assert_eq!(local.strftime(\"%c\").unwrap().to_string(),\n-                   \"Fri Feb 13 15:31:30 2009\");\n-        assert_eq!(local.strftime(\"%D\").unwrap().to_string(), \"02/13/09\");\n-        assert_eq!(local.strftime(\"%d\").unwrap().to_string(), \"13\");\n-        assert_eq!(local.strftime(\"%e\").unwrap().to_string(), \"13\");\n-        assert_eq!(local.strftime(\"%F\").unwrap().to_string(), \"2009-02-13\");\n-        assert_eq!(local.strftime(\"%f\").unwrap().to_string(), \"000054321\");\n-        assert_eq!(local.strftime(\"%G\").unwrap().to_string(), \"2009\");\n-        assert_eq!(local.strftime(\"%g\").unwrap().to_string(), \"09\");\n-        assert_eq!(local.strftime(\"%H\").unwrap().to_string(), \"15\");\n-        assert_eq!(local.strftime(\"%h\").unwrap().to_string(), \"Feb\");\n-        assert_eq!(local.strftime(\"%I\").unwrap().to_string(), \"03\");\n-        assert_eq!(local.strftime(\"%j\").unwrap().to_string(), \"044\");\n-        assert_eq!(local.strftime(\"%k\").unwrap().to_string(), \"15\");\n-        assert_eq!(local.strftime(\"%l\").unwrap().to_string(), \" 3\");\n-        assert_eq!(local.strftime(\"%M\").unwrap().to_string(), \"31\");\n-        assert_eq!(local.strftime(\"%m\").unwrap().to_string(), \"02\");\n-        assert_eq!(local.strftime(\"%n\").unwrap().to_string(), \"\\n\");\n-        assert_eq!(local.strftime(\"%P\").unwrap().to_string(), \"pm\");\n-        assert_eq!(local.strftime(\"%p\").unwrap().to_string(), \"PM\");\n-        assert_eq!(local.strftime(\"%R\").unwrap().to_string(), \"15:31\");\n-        assert_eq!(local.strftime(\"%r\").unwrap().to_string(), \"03:31:30 PM\");\n-        assert_eq!(local.strftime(\"%S\").unwrap().to_string(), \"30\");\n-        assert_eq!(local.strftime(\"%s\").unwrap().to_string(), \"1234567890\");\n-        assert_eq!(local.strftime(\"%T\").unwrap().to_string(), \"15:31:30\");\n-        assert_eq!(local.strftime(\"%t\").unwrap().to_string(), \"\\t\");\n-        assert_eq!(local.strftime(\"%U\").unwrap().to_string(), \"06\");\n-        assert_eq!(local.strftime(\"%u\").unwrap().to_string(), \"5\");\n-        assert_eq!(local.strftime(\"%V\").unwrap().to_string(), \"07\");\n-        assert_eq!(local.strftime(\"%v\").unwrap().to_string(), \"13-Feb-2009\");\n-        assert_eq!(local.strftime(\"%W\").unwrap().to_string(), \"06\");\n-        assert_eq!(local.strftime(\"%w\").unwrap().to_string(), \"5\");\n-        // FIXME (#2350): support locale\n-        assert_eq!(local.strftime(\"%X\").unwrap().to_string(), \"15:31:30\");\n-        // FIXME (#2350): support locale\n-        assert_eq!(local.strftime(\"%x\").unwrap().to_string(), \"02/13/09\");\n-        assert_eq!(local.strftime(\"%Y\").unwrap().to_string(), \"2009\");\n-        assert_eq!(local.strftime(\"%y\").unwrap().to_string(), \"09\");\n-        // FIXME (#2350): support locale\n-        assert_eq!(local.strftime(\"%Z\").unwrap().to_string(), \"\");\n-        assert_eq!(local.strftime(\"%z\").unwrap().to_string(), \"-0800\");\n-        assert_eq!(local.strftime(\"%+\").unwrap().to_string(),\n-                   \"2009-02-13T15:31:30-08:00\");\n-        assert_eq!(local.strftime(\"%%\").unwrap().to_string(), \"%\");\n-\n-         let invalid_specifiers = [\"%E\", \"%J\", \"%K\", \"%L\", \"%N\", \"%O\", \"%o\", \"%Q\", \"%q\"];\n-        for &sp in invalid_specifiers.iter() {\n-            assert_eq!(local.strftime(sp).unwrap_err(), InvalidFormatSpecifier(sp.char_at(1)));\n-        }\n-        assert_eq!(local.strftime(\"%\").unwrap_err(), MissingFormatConverter);\n-        assert_eq!(local.strftime(\"%A %\").unwrap_err(), MissingFormatConverter);\n-\n-        assert_eq!(local.asctime().to_string(), \"Fri Feb 13 15:31:30 2009\");\n-        assert_eq!(local.ctime().to_string(), \"Fri Feb 13 15:31:30 2009\");\n-        assert_eq!(local.rfc822z().to_string(), \"Fri, 13 Feb 2009 15:31:30 -0800\");\n-        assert_eq!(local.rfc3339().to_string(), \"2009-02-13T15:31:30-08:00\");\n-\n-        assert_eq!(utc.asctime().to_string(), \"Fri Feb 13 23:31:30 2009\");\n-        assert_eq!(utc.ctime().to_string(), \"Fri Feb 13 15:31:30 2009\");\n-        assert_eq!(utc.rfc822().to_string(), \"Fri, 13 Feb 2009 23:31:30 GMT\");\n-        assert_eq!(utc.rfc822z().to_string(), \"Fri, 13 Feb 2009 23:31:30 -0000\");\n-        assert_eq!(utc.rfc3339().to_string(), \"2009-02-13T23:31:30Z\");\n-    }\n-\n-    fn test_timespec_eq_ord() {\n-        let a = &Timespec::new(-2, 1);\n-        let b = &Timespec::new(-1, 2);\n-        let c = &Timespec::new(1, 2);\n-        let d = &Timespec::new(2, 1);\n-        let e = &Timespec::new(2, 1);\n-\n-        assert!(d.eq(e));\n-        assert!(c.ne(e));\n-\n-        assert!(a.lt(b));\n-        assert!(b.lt(c));\n-        assert!(c.lt(d));\n-\n-        assert!(a.le(b));\n-        assert!(b.le(c));\n-        assert!(c.le(d));\n-        assert!(d.le(e));\n-        assert!(e.le(d));\n-\n-        assert!(b.ge(a));\n-        assert!(c.ge(b));\n-        assert!(d.ge(c));\n-        assert!(e.ge(d));\n-        assert!(d.ge(e));\n-\n-        assert!(b.gt(a));\n-        assert!(c.gt(b));\n-        assert!(d.gt(c));\n-    }\n-\n-    fn test_timespec_add() {\n-        let a = Timespec::new(1, 2);\n-        let b = Duration::seconds(2) + Duration::nanoseconds(3);\n-        let c = a + b;\n-        assert_eq!(c.sec, 3);\n-        assert_eq!(c.nsec, 5);\n-\n-        let p = Timespec::new(1, super::NSEC_PER_SEC - 2);\n-        let q = Duration::seconds(2) + Duration::nanoseconds(2);\n-        let r = p + q;\n-        assert_eq!(r.sec, 4);\n-        assert_eq!(r.nsec, 0);\n-\n-        let u = Timespec::new(1, super::NSEC_PER_SEC - 2);\n-        let v = Duration::seconds(2) + Duration::nanoseconds(3);\n-        let w = u + v;\n-        assert_eq!(w.sec, 4);\n-        assert_eq!(w.nsec, 1);\n-\n-        let k = Timespec::new(1, 0);\n-        let l = Duration::nanoseconds(-1);\n-        let m = k + l;\n-        assert_eq!(m.sec, 0);\n-        assert_eq!(m.nsec, 999_999_999);\n-    }\n-\n-    fn test_timespec_sub() {\n-        let a = Timespec::new(2, 3);\n-        let b = Timespec::new(1, 2);\n-        let c = a - b;\n-        assert_eq!(c.num_nanoseconds(), Some(super::NSEC_PER_SEC as i64 + 1));\n-\n-        let p = Timespec::new(2, 0);\n-        let q = Timespec::new(1, 2);\n-        let r = p - q;\n-        assert_eq!(r.num_nanoseconds(), Some(super::NSEC_PER_SEC as i64 - 2));\n-\n-        let u = Timespec::new(1, 2);\n-        let v = Timespec::new(2, 3);\n-        let w = u - v;\n-        assert_eq!(w.num_nanoseconds(), Some(-super::NSEC_PER_SEC as i64 - 1));\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_os = \"android\", ignore)] // FIXME #10958\n-    fn run_tests() {\n-        // The tests race on tzset. So instead of having many independent\n-        // tests, we will just call the functions now.\n-        test_get_time();\n-        test_precise_time();\n-        test_at_utc();\n-        test_at();\n-        test_to_timespec();\n-        test_conversions();\n-        test_strptime();\n-        test_asctime();\n-        test_ctime();\n-        test_strftime();\n-        test_timespec_eq_ord();\n-        test_timespec_add();\n-        test_timespec_sub();\n-    }\n-\n-    #[bench]\n-    fn bench_precise_time_ns(b: &mut Bencher) {\n-        b.iter(|| precise_time_ns())\n-    }\n-}"}, {"sha": "72e9ce2bcafe64fb9b8e9e3825f1db2ef8cd43e1", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -58,19 +58,16 @@ mod u_str;\n /// however the converse is not always true due to the above range limits\n /// and, as such, should be performed via the `from_u32` function..\n pub mod char {\n-    pub use core::char::{MAX, from_u32, is_digit_radix, to_digit};\n-    pub use core::char::{from_digit, escape_unicode, escape_default};\n-    pub use core::char::{len_utf8_bytes, Char};\n+    pub use core::char::{MAX, from_u32};\n+    pub use core::char::{from_digit};\n+    pub use core::char::Char;\n \n     pub use normalize::{decompose_canonical, decompose_compatible, compose};\n \n     pub use tables::normalization::canonical_combining_class;\n     pub use tables::UNICODE_VERSION;\n \n-    pub use u_char::{is_alphabetic, is_XID_start, is_XID_continue};\n-    pub use u_char::{is_lowercase, is_uppercase, is_whitespace};\n-    pub use u_char::{is_alphanumeric, is_control, is_digit};\n-    pub use u_char::{to_uppercase, to_lowercase, width, UnicodeChar};\n+    pub use u_char::UnicodeChar;\n }\n \n pub mod str {"}, {"sha": "9c356801604dd44fd95c671eb127f511c526255d", "filename": "src/libunicode/u_char.rs", "status": "modified", "additions": 0, "deletions": 161, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibunicode%2Fu_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Flibunicode%2Fu_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_char.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -16,158 +16,13 @@\n use core::option::Option;\n use tables::{derived_property, property, general_category, conversions, charwidth};\n \n-/// Returns whether the specified `char` is considered a Unicode alphabetic\n-/// code point\n-#[deprecated = \"use UnicodeChar::is_alphabetic\"]\n-pub fn is_alphabetic(c: char) -> bool {\n-    c.is_alphabetic()\n-}\n-\n-/// Returns whether the specified `char` satisfies the 'XID_Start' Unicode property\n-///\n-/// 'XID_Start' is a Unicode Derived Property specified in\n-/// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n-/// mostly similar to ID_Start but modified for closure under NFKx.\n-#[allow(non_snake_case)]\n-#[deprecated = \"use UnicodeChar::is_XID_start\"]\n-pub fn is_XID_start(c: char) -> bool    { derived_property::XID_Start(c) }\n-\n-/// Returns whether the specified `char` satisfies the 'XID_Continue' Unicode property\n-///\n-/// 'XID_Continue' is a Unicode Derived Property specified in\n-/// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n-/// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n-#[allow(non_snake_case)]\n-#[deprecated = \"use UnicodeChar::is_XID_continue\"]\n-pub fn is_XID_continue(c: char) -> bool { derived_property::XID_Continue(c) }\n-\n-///\n-/// Indicates whether a `char` is in lower case\n-///\n-/// This is defined according to the terms of the Unicode Derived Core Property 'Lowercase'.\n-///\n-#[inline]\n-#[deprecated = \"use UnicodeChar::is_lowercase\"]\n-pub fn is_lowercase(c: char) -> bool {\n-    c.is_lowercase()\n-}\n-\n-///\n-/// Indicates whether a `char` is in upper case\n-///\n-/// This is defined according to the terms of the Unicode Derived Core Property 'Uppercase'.\n-///\n-#[inline]\n-#[deprecated = \"use UnicodeChar::is_uppercase\"]\n-pub fn is_uppercase(c: char) -> bool {\n-    c.is_uppercase()\n-}\n-\n-///\n-/// Indicates whether a `char` is whitespace\n-///\n-/// Whitespace is defined in terms of the Unicode Property 'White_Space'.\n-///\n-#[inline]\n-#[deprecated = \"use UnicodeChar::is_whitespace\"]\n-pub fn is_whitespace(c: char) -> bool {\n-    c.is_whitespace()\n-}\n-\n-///\n-/// Indicates whether a `char` is alphanumeric\n-///\n-/// Alphanumericness is defined in terms of the Unicode General Categories\n-/// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n-///\n-#[inline]\n-#[deprecated = \"use UnicodeChar::is_alphanumeric\"]\n-pub fn is_alphanumeric(c: char) -> bool {\n-    c.is_alphanumeric()\n-}\n-\n-///\n-/// Indicates whether a `char` is a control code point\n-///\n-/// Control code points are defined in terms of the Unicode General Category\n-/// 'Cc'.\n-///\n-#[inline]\n-#[deprecated = \"use UnicodeChar::is_control\"]\n-pub fn is_control(c: char) -> bool { general_category::Cc(c) }\n-\n-/// Indicates whether the `char` is numeric (Nd, Nl, or No)\n-#[inline]\n-#[deprecated = \"use UnicodeChar::is_numeric\"]\n-pub fn is_digit(c: char) -> bool {\n-    c.is_numeric()\n-}\n-\n-/// Convert a char to its uppercase equivalent\n-///\n-/// The case-folding performed is the common or simple mapping:\n-/// it maps one Unicode codepoint (one char in Rust) to its uppercase equivalent according\n-/// to the Unicode database at ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n-/// The additional SpecialCasing.txt is not considered here, as it expands to multiple\n-/// codepoints in some cases.\n-///\n-/// A full reference can be found here\n-/// http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992\n-///\n-/// # Return value\n-///\n-/// Returns the char itself if no conversion was made\n-#[inline]\n-#[deprecated = \"use UnicodeChar::to_uppercase\"]\n-pub fn to_uppercase(c: char) -> char {\n-    conversions::to_upper(c)\n-}\n-\n-/// Convert a char to its lowercase equivalent\n-///\n-/// The case-folding performed is the common or simple mapping\n-/// see `to_uppercase` for references and more information\n-///\n-/// # Return value\n-///\n-/// Returns the char itself if no conversion if possible\n-#[inline]\n-#[deprecated = \"use UnicodeChar::to_lowercase\"]\n-pub fn to_lowercase(c: char) -> char {\n-    conversions::to_lower(c)\n-}\n-\n-/// Returns this character's displayed width in columns, or `None` if it is a\n-/// control character other than `'\\x00'`.\n-///\n-/// `is_cjk` determines behavior for characters in the Ambiguous category:\n-/// if `is_cjk` is `true`, these are 2 columns wide; otherwise, they are 1.\n-/// In CJK contexts, `is_cjk` should be `true`, else it should be `false`.\n-/// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n-/// recommends that these characters be treated as 1 column (i.e.,\n-/// `is_cjk` = `false`) if the context cannot be reliably determined.\n-#[deprecated = \"use UnicodeChar::width\"]\n-pub fn width(c: char, is_cjk: bool) -> Option<uint> {\n-    charwidth::width(c, is_cjk)\n-}\n-\n /// Useful functions for Unicode characters.\n #[experimental = \"pending prelude organization\"]\n pub trait UnicodeChar {\n     /// Returns whether the specified character is considered a Unicode\n     /// alphabetic code point.\n     fn is_alphabetic(self) -> bool;\n \n-    /// Returns whether the specified character satisfies the 'XID_Start'\n-    /// Unicode property.\n-    ///\n-    /// 'XID_Start' is a Unicode Derived Property specified in\n-    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n-    /// mostly similar to ID_Start but modified for closure under NFKx.\n-    #[allow(non_snake_case)]\n-    #[deprecated = \"use is_xid_start\"]\n-    fn is_XID_start(self) -> bool;\n-\n     /// Returns whether the specified character satisfies the 'XID_Start'\n     /// Unicode property.\n     ///\n@@ -176,16 +31,6 @@ pub trait UnicodeChar {\n     /// mostly similar to ID_Start but modified for closure under NFKx.\n     fn is_xid_start(self) -> bool;\n \n-    /// Returns whether the specified `char` satisfies the 'XID_Continue'\n-    /// Unicode property.\n-    ///\n-    /// 'XID_Continue' is a Unicode Derived Property specified in\n-    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n-    /// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n-    #[allow(non_snake_case)]\n-    #[deprecated = \"use is_xid_continue\"]\n-    fn is_XID_continue(self) -> bool;\n-\n     /// Returns whether the specified `char` satisfies the 'XID_Continue'\n     /// Unicode property.\n     ///\n@@ -282,12 +127,6 @@ impl UnicodeChar for char {\n         }\n     }\n \n-    #[deprecated = \"use is_xid_start\"]\n-    fn is_XID_start(self) -> bool { derived_property::XID_Start(self) }\n-\n-    #[deprecated = \"use is_xid_continue\"]\n-    fn is_XID_continue(self) -> bool { derived_property::XID_Continue(self) }\n-\n     fn is_xid_start(self) -> bool { derived_property::XID_Start(self) }\n \n     fn is_xid_continue(self) -> bool { derived_property::XID_Continue(self) }"}, {"sha": "ec4c0281d5597071b97ec23867ef915e16e5ddc6", "filename": "src/test/auxiliary/cci_capture_clause.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n use std::sync::mpsc::{Receiver, channel};\n \n pub fn foo<T:Send + Clone>(x: T) -> Receiver<T> {\n     let (tx, rx) = channel();\n-    task::spawn(move|| {\n+    Thread::spawn(move|| {\n         tx.send(x.clone());\n-    });\n+    }).detach();\n     rx\n }"}, {"sha": "1b18571cf8c252b82fbcaf30a8dd0314a83a75d2", "filename": "src/test/auxiliary/static-methods-crate.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -12,15 +12,14 @@\n #![crate_type = \"lib\"]\n \n use std::int;\n-use std::str::from_str;\n \n pub trait read {\n     fn readMaybe(s: String) -> Option<Self>;\n }\n \n impl read for int {\n     fn readMaybe(s: String) -> Option<int> {\n-        from_str::<int>(s.as_slice())\n+        s.parse()\n     }\n }\n "}, {"sha": "c978046e3910f2e2830b76ed37acbcc24de6cd96", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -13,7 +13,6 @@\n use std::collections::{BTreeMap, HashMap, HashSet};\n use std::os;\n use std::rand::{Rng, IsaacRng, SeedableRng};\n-use std::str::from_str;\n use std::time::Duration;\n use std::uint;\n \n@@ -107,7 +106,7 @@ fn main() {\n     let args = args.as_slice();\n     let n_keys = {\n         if args.len() == 2 {\n-            from_str::<uint>(args[1].as_slice()).unwrap()\n+            args[1].parse::<uint>().unwrap()\n         } else {\n             1000000\n         }"}, {"sha": "491d910f3517d7853742b2501aefa546d54aad84", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -20,7 +20,6 @@ use std::collections::BitvSet;\n use std::collections::HashSet;\n use std::hash::Hash;\n use std::os;\n-use std::str::from_str;\n use std::time::Duration;\n use std::uint;\n \n@@ -181,7 +180,7 @@ fn main() {\n     let args = args.as_slice();\n     let num_keys = {\n         if args.len() == 2 {\n-            from_str::<uint>(args[1].as_slice()).unwrap()\n+            args[1].parse::<uint>().unwrap()\n         } else {\n             100 // woefully inadequate for any real measurement\n         }"}, {"sha": "ee7c442da195c5a9b6a3cbc4f0e286aeebeeb706", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -15,6 +15,7 @@\n #![feature(unboxed_closures)]\n \n use std::io::File;\n+use std::iter::repeat;\n use std::mem::swap;\n use std::os;\n use std::rand::Rng;\n@@ -61,7 +62,7 @@ fn maybe_run_test<F>(argv: &[String], name: String, test: F) where F: FnOnce() {\n }\n \n fn shift_push() {\n-    let mut v1 = Vec::from_elem(30000, 1i);\n+    let mut v1 = repeat(1i).take(30000).collect::<Vec<_>>();\n     let mut v2 = Vec::new();\n \n     while v1.len() > 0 {\n@@ -88,7 +89,7 @@ fn vec_plus() {\n     let mut v = Vec::new();\n     let mut i = 0;\n     while i < 1500 {\n-        let rv = Vec::from_elem(r.gen_range(0u, i + 1), i);\n+        let rv = repeat(i).take(r.gen_range(0u, i + 1)).collect::<Vec<_>>();\n         if r.gen() {\n             v.extend(rv.into_iter());\n         } else {\n@@ -106,7 +107,7 @@ fn vec_append() {\n     let mut v = Vec::new();\n     let mut i = 0;\n     while i < 1500 {\n-        let rv = Vec::from_elem(r.gen_range(0u, i + 1), i);\n+        let rv = repeat(i).take(r.gen_range(0u, i + 1)).collect::<Vec<_>>();\n         if r.gen() {\n             let mut t = v.clone();\n             t.push_all(rv.as_slice());\n@@ -126,7 +127,7 @@ fn vec_push_all() {\n \n     let mut v = Vec::new();\n     for i in range(0u, 1500) {\n-        let mut rv = Vec::from_elem(r.gen_range(0u, i + 1), i);\n+        let mut rv = repeat(i).take(r.gen_range(0u, i + 1)).collect::<Vec<_>>();\n         if r.gen() {\n             v.push_all(rv.as_slice());\n         }\n@@ -141,8 +142,8 @@ fn is_utf8_ascii() {\n     let mut v : Vec<u8> = Vec::new();\n     for _ in range(0u, 20000) {\n         v.push('b' as u8);\n-        if !str::is_utf8(v.as_slice()) {\n-            panic!(\"is_utf8 panicked\");\n+        if str::from_utf8(v.as_slice()).is_err() {\n+            panic!(\"from_utf8 panicked\");\n         }\n     }\n }\n@@ -152,8 +153,8 @@ fn is_utf8_multibyte() {\n     let mut v : Vec<u8> = Vec::new();\n     for _ in range(0u, 5000) {\n         v.push_all(s.as_bytes());\n-        if !str::is_utf8(v.as_slice()) {\n-            panic!(\"is_utf8 panicked\");\n+        if str::from_utf8(v.as_slice()).is_err() {\n+            panic!(\"from_utf8 panicked\");\n         }\n     }\n }"}, {"sha": "0235482ca2c48006c641abeab03c5aaf9587022f", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use std::os;\n-use std::str::from_str;\n use std::uint;\n \n fn main() {\n@@ -22,7 +21,7 @@ fn main() {\n         args.into_iter().collect()\n     };\n \n-    let n = from_str::<uint>(args[1].as_slice()).unwrap();\n+    let n = args[1].parse().unwrap();\n \n     for i in range(0u, n) {\n         let x = i.to_string();"}, {"sha": "d1126e742527375d82948e0f4e3065f2f62678c4", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -20,7 +20,6 @@\n \n use std::sync::mpsc::{channel, Sender, Receiver};\n use std::os;\n-use std::str::from_str;\n use std::thread::Thread;\n use std::time::Duration;\n use std::uint;\n@@ -55,8 +54,8 @@ fn run(args: &[String]) {\n     let (to_parent, from_child) = channel();\n     let (to_child, from_parent) = channel();\n \n-    let size = from_str::<uint>(args[1].as_slice()).unwrap();\n-    let workers = from_str::<uint>(args[2].as_slice()).unwrap();\n+    let size = args[1].parse::<uint>().unwrap();\n+    let workers = args[2].parse::<uint>().unwrap();\n     let num_bytes = 100;\n     let mut result = None;\n     let mut p = Some((to_child, to_parent, from_parent));"}, {"sha": "ef5e8f3f4bbf4e4f7cc24826e4570b7dd5ae7136", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -19,7 +19,6 @@\n // ignore-lexer-test FIXME #15679\n \n use std::os;\n-use std::str::from_str;\n use std::sync::{Arc, Future, Mutex, Condvar};\n use std::time::Duration;\n use std::uint;\n@@ -74,8 +73,8 @@ fn main() {\n         args.clone().into_iter().collect()\n     };\n \n-    let num_tasks = from_str::<uint>(args[1].as_slice()).unwrap();\n-    let msg_per_task = from_str::<uint>(args[2].as_slice()).unwrap();\n+    let num_tasks = args[1].parse::<uint>().unwrap();\n+    let msg_per_task = args[2].parse::<uint>().unwrap();\n \n     let (mut num_chan, num_port) = init();\n "}, {"sha": "a3f1bc74b44fc07c4a65962ab5dd6a1f26e15a42", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -19,7 +19,6 @@\n \n use std::sync::mpsc::channel;\n use std::os;\n-use std::str::from_str;\n use std::thread::Thread;\n use std::uint;\n \n@@ -66,13 +65,13 @@ fn main() {\n     let args = os::args();\n     let args = args.as_slice();\n     let n = if args.len() == 3 {\n-        from_str::<uint>(args[1].as_slice()).unwrap()\n+        args[1].parse::<uint>().unwrap()\n     } else {\n         10000\n     };\n \n     let m = if args.len() == 3 {\n-        from_str::<uint>(args[2].as_slice()).unwrap()\n+        args[2].parse::<uint>().unwrap()\n     } else {\n         4\n     };"}, {"sha": "e66fffd04e358716502aba947385406b5db051ad", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use std::os;\n-use std::str::from_str;\n \n fn ack(m: int, n: int) -> int {\n     if m == 0 {\n@@ -32,6 +31,6 @@ fn main() {\n     } else {\n         args.into_iter().collect()\n     };\n-    let n = from_str::<int>(args[1].as_slice()).unwrap();\n+    let n = args[1].parse().unwrap();\n     println!(\"Ack(3,{}): {}\\n\", n, ack(3, n));\n }"}, {"sha": "96bca25d1c455a031b74620871dded052d323fc4", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -43,7 +43,6 @@\n use self::Color::{Red, Yellow, Blue};\n use std::sync::mpsc::{channel, Sender, Receiver};\n use std::fmt;\n-use std::str::from_str;\n use std::thread::Thread;\n \n fn print_complements() {\n@@ -235,8 +234,8 @@ fn main() {\n     } else {\n         std::os::args().as_slice()\n                        .get(1)\n-                       .and_then(|arg| from_str(arg.as_slice()))\n-                       .unwrap_or(600)\n+                       .and_then(|arg| arg.parse())\n+                       .unwrap_or(600u)\n     };\n \n     print_complements();"}, {"sha": "bbbfb0051f99bd069805fdf9fe3bae753d0c9ecb", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -42,9 +42,9 @@\n \n use std::cmp::min;\n use std::io::{stdout, IoResult};\n+use std::iter::repeat;\n use std::os;\n use std::slice::bytes::copy_memory;\n-use std::str::from_str;\n \n const LINE_LEN: uint = 60;\n const LOOKUP_SIZE: uint = 4 * 1024;\n@@ -124,7 +124,7 @@ impl<'a, W: Writer> RepeatFasta<'a, W> {\n \n     fn make(&mut self, n: uint) -> IoResult<()> {\n         let alu_len = self.alu.len();\n-        let mut buf = Vec::from_elem(alu_len + LINE_LEN, 0u8);\n+        let mut buf = repeat(0u8).take(alu_len + LINE_LEN).collect::<Vec<_>>();\n         let alu: &[u8] = self.alu.as_bytes();\n \n         copy_memory(buf.as_mut_slice(), alu);\n@@ -214,7 +214,7 @@ fn main() {\n     let args = os::args();\n     let args = args.as_slice();\n     let n = if args.len() > 1 {\n-        from_str::<uint>(args[1].as_slice()).unwrap()\n+        args[1].parse::<uint>().unwrap()\n     } else {\n         5\n     };"}, {"sha": "8777fa9689f94778b195373810aacc32b2e320f5", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -45,7 +45,6 @@ use std::io::{BufferedWriter, File};\n use std::io;\n use std::num::Float;\n use std::os;\n-use std::str::from_str;\n \n const LINE_LENGTH: uint = 60;\n const IM: u32 = 139968;\n@@ -113,7 +112,7 @@ fn run<W: Writer>(writer: &mut W) -> std::io::IoResult<()> {\n     } else if args.len() <= 1u {\n         1000\n     } else {\n-        from_str(args[1].as_slice()).unwrap()\n+        args[1].parse().unwrap()\n     };\n \n     let rng = &mut MyRandom::new();"}, {"sha": "36854728ebf209abf8e0f183919aa34f631ff2c5", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use std::os;\n-use std::str::from_str;\n \n fn fib(n: int) -> int {\n     if n < 2 {\n@@ -28,6 +27,6 @@ fn main() {\n     } else {\n         args.into_iter().collect()\n     };\n-    let n = from_str::<int>(args[1].as_slice()).unwrap();\n+    let n = args[1].parse().unwrap();\n     println!(\"{}\\n\", fib(n));\n }"}, {"sha": "8c0ec667332d39ce46a7afe65d80e32910970e36", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -15,17 +15,14 @@\n \n #![feature(slicing_syntax)]\n \n-extern crate collections;\n-\n use std::ascii::{AsciiExt, OwnedAsciiExt};\n use std::cmp::Ordering::{self, Less, Greater, Equal};\n use std::collections::HashMap;\n-use std::sync::mpsc::{channel, Sender, Receiver};\n use std::mem::replace;\n use std::num::Float;\n use std::option;\n use std::os;\n-use std::string::IntoString;\n+use std::sync::mpsc::{channel, Sender, Receiver};\n use std::thread::Thread;\n \n fn f64_cmp(x: f64, y: f64) -> Ordering {\n@@ -87,7 +84,7 @@ fn find(mm: &HashMap<Vec<u8> , uint>, key: String) -> uint {\n // given a map, increment the counter for a key\n fn update_freq(mm: &mut HashMap<Vec<u8> , uint>, key: &[u8]) {\n     let key = key.to_vec();\n-    let newval = match mm.pop(&key) {\n+    let newval = match mm.remove(&key) {\n         Some(v) => v + 1,\n         None => 1\n     };\n@@ -142,7 +139,7 @@ fn make_sequence_processor(sz: uint,\n         _ => { \"\".to_string() }\n    };\n \n-    to_parent.send(buffer);\n+    to_parent.send(buffer).unwrap();\n }\n \n // given a FASTA file on stdin, process sequence THREE\n@@ -159,7 +156,9 @@ fn main() {\n \n     // initialize each sequence sorter\n     let sizes = vec!(1u,2,3,4,6,12,18);\n-    let mut streams = Vec::from_fn(sizes.len(), |_| Some(channel::<String>()));\n+    let mut streams = range(0, sizes.len()).map(|_| {\n+        Some(channel::<String>())\n+    }).collect::<Vec<_>>();\n     let mut from_child = Vec::new();\n     let to_child  = sizes.iter().zip(streams.iter_mut()).map(|(sz, stream_ref)| {\n         let sz = *sz;\n@@ -206,7 +205,7 @@ fn main() {\n \n                for (ii, _sz) in sizes.iter().enumerate() {\n                    let lb = line_bytes.to_vec();\n-                   to_child[ii].send(lb);\n+                   to_child[ii].send(lb).unwrap();\n                }\n            }\n \n@@ -217,7 +216,7 @@ fn main() {\n \n    // finish...\n    for (ii, _sz) in sizes.iter().enumerate() {\n-       to_child[ii].send(Vec::new());\n+       to_child[ii].send(Vec::new()).unwrap();\n    }\n \n    // now fetch and print result messages"}, {"sha": "359f06d0cf5f9eb50b0a9996fd91f11502cb2986", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -43,8 +43,10 @@\n #![feature(associated_types, slicing_syntax)]\n \n use std::ascii::OwnedAsciiExt;\n+use std::iter::repeat;\n use std::slice;\n-use std::sync::{Arc, Future};\n+use std::sync::Arc;\n+use std::thread::Thread;\n \n static TABLE: [u8;4] = [ 'A' as u8, 'C' as u8, 'G' as u8, 'T' as u8 ];\n static TABLE_SIZE: uint = 2 << 16;\n@@ -136,7 +138,7 @@ struct Items<'a> {\n impl Table {\n     fn new() -> Table {\n         Table {\n-            items: Vec::from_fn(TABLE_SIZE, |_| None),\n+            items: range(0, TABLE_SIZE).map(|_| None).collect()\n         }\n     }\n \n@@ -300,19 +302,19 @@ fn main() {\n     };\n     let input = Arc::new(input);\n \n-    let nb_freqs: Vec<(uint, Future<Table>)> = range(1u, 3).map(|i| {\n+    let nb_freqs: Vec<_> = range(1u, 3).map(|i| {\n         let input = input.clone();\n-        (i, Future::spawn(move|| generate_frequencies(input.as_slice(), i)))\n+        (i, Thread::spawn(move|| generate_frequencies(input.as_slice(), i)))\n     }).collect();\n-    let occ_freqs: Vec<Future<Table>> = OCCURRENCES.iter().map(|&occ| {\n+    let occ_freqs: Vec<_> = OCCURRENCES.iter().map(|&occ| {\n         let input = input.clone();\n-        Future::spawn(move|| generate_frequencies(input.as_slice(), occ.len()))\n+        Thread::spawn(move|| generate_frequencies(input.as_slice(), occ.len()))\n     }).collect();\n \n     for (i, freq) in nb_freqs.into_iter() {\n-        print_frequencies(&freq.unwrap(), i);\n+        print_frequencies(&freq.join().ok().unwrap(), i);\n     }\n     for (&occ, freq) in OCCURRENCES.iter().zip(occ_freqs.into_iter()) {\n-        print_occurrences(&mut freq.unwrap(), occ);\n+        print_occurrences(&mut freq.join().ok().unwrap(), occ);\n     }\n }"}, {"sha": "4e8e0d64d52cebdb169773ddafcaaa6d2e2cf598", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -47,8 +47,8 @@\n use std::io;\n use std::os;\n use std::simd::f64x2;\n-use std::str::from_str;\n-use std::sync::{Arc, Future};\n+use std::sync::Arc;\n+use std::thread::Thread;\n \n const ITER: int = 50;\n const LIMIT: f64 = 2.0;\n@@ -82,8 +82,8 @@ fn mandelbrot<W: io::Writer>(w: uint, mut out: W) -> io::IoResult<()> {\n     let mut precalc_r = Vec::with_capacity(w);\n     let mut precalc_i = Vec::with_capacity(h);\n \n-    let precalc_futures = Vec::from_fn(WORKERS, |i| {\n-        Future::spawn(move|| {\n+    let precalc_futures = range(0, WORKERS).map(|i| {\n+        Thread::spawn(move|| {\n             let mut rs = Vec::with_capacity(w / WORKERS);\n             let mut is = Vec::with_capacity(w / WORKERS);\n \n@@ -106,10 +106,10 @@ fn mandelbrot<W: io::Writer>(w: uint, mut out: W) -> io::IoResult<()> {\n \n             (rs, is)\n         })\n-    });\n+    }).collect::<Vec<_>>();\n \n     for res in precalc_futures.into_iter() {\n-        let (rs, is) = res.unwrap();\n+        let (rs, is) = res.join().ok().unwrap();\n         precalc_r.extend(rs.into_iter());\n         precalc_i.extend(is.into_iter());\n     }\n@@ -120,11 +120,11 @@ fn mandelbrot<W: io::Writer>(w: uint, mut out: W) -> io::IoResult<()> {\n     let arc_init_r = Arc::new(precalc_r);\n     let arc_init_i = Arc::new(precalc_i);\n \n-    let data = Vec::from_fn(WORKERS, |i| {\n+    let data = range(0, WORKERS).map(|i| {\n         let vec_init_r = arc_init_r.clone();\n         let vec_init_i = arc_init_i.clone();\n \n-        Future::spawn(move|| {\n+        Thread::spawn(move|| {\n             let mut res: Vec<u8> = Vec::with_capacity((chunk_size * w) / 8);\n             let init_r_slice = vec_init_r.as_slice();\n \n@@ -141,11 +141,11 @@ fn mandelbrot<W: io::Writer>(w: uint, mut out: W) -> io::IoResult<()> {\n \n             res\n         })\n-    });\n+    }).collect::<Vec<_>>();\n \n     try!(writeln!(&mut out as &mut Writer, \"P4\\n{} {}\", w, h));\n     for res in data.into_iter() {\n-        try!(out.write(res.unwrap().as_slice()));\n+        try!(out.write(res.join().ok().unwrap().as_slice()));\n     }\n     out.flush()\n }\n@@ -206,7 +206,7 @@ fn main() {\n                   which interferes with the test runner.\");\n         mandelbrot(1000, io::util::NullWriter)\n     } else {\n-        mandelbrot(from_str(args[1].as_slice()).unwrap(), io::stdout())\n+        mandelbrot(args[1].parse().unwrap(), io::stdout())\n     };\n     res.unwrap();\n }"}, {"sha": "438775d8ba0a405f1686e52ad6e65c7c369e9780", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -42,8 +42,9 @@\n \n #![feature(associated_types)]\n \n-use std::sync::mpsc::channel;\n+use std::iter::repeat;\n use std::sync::Arc;\n+use std::sync::mpsc::channel;\n use std::thread::Thread;\n \n //\n@@ -220,7 +221,7 @@ fn get_id(m: u64) -> u8 {\n \n // Converts a list of mask to a Vec<u8>.\n fn to_vec(raw_sol: &List<u64>) -> Vec<u8> {\n-    let mut sol = Vec::from_elem(50, '.' as u8);\n+    let mut sol = repeat('.' as u8).take(50).collect::<Vec<_>>();\n     for &m in raw_sol.iter() {\n         let id = '0' as u8 + get_id(m);\n         for i in range(0u, 50) {"}, {"sha": "7973af3722de4eb9893752ed990f65d0021ab409", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -39,7 +39,6 @@\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n use std::num::Float;\n-use std::str::from_str;\n \n const PI: f64 = 3.141592653589793;\n const SOLAR_MASS: f64 = 4.0 * PI * PI;\n@@ -176,7 +175,7 @@ fn main() {\n         5000000\n     } else {\n         std::os::args().as_slice().get(1)\n-            .and_then(|arg| from_str(arg.as_slice()))\n+            .and_then(|arg| arg.parse())\n             .unwrap_or(1000)\n     };\n     let mut bodies = BODIES;"}, {"sha": "84ceb432048bc674996125967ac7e21b636b42fa", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -23,7 +23,6 @@ extern crate getopts;\n use std::sync::mpsc::{channel, Sender};\n use std::os;\n use std::result::Result::{Ok, Err};\n-use std::str::from_str;\n use std::thread::Thread;\n use std::time::Duration;\n \n@@ -103,7 +102,7 @@ fn main() {\n     if opts.stress {\n         stress(2);\n     } else {\n-        let max = from_str::<uint>(args[1].as_slice()).unwrap() as int;\n+        let max = args[1].parse::<int>().unwrap();\n \n         let num_trials = 10;\n "}, {"sha": "4f87171f5d3fab49c1f20de70c6aabaac1f702b6", "filename": "src/test/bench/shootout-regex-dna.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -44,12 +44,15 @@\n #![feature(macro_rules, phase, slicing_syntax)]\n \n extern crate regex;\n-#[phase(plugin)]extern crate regex_macros;\n \n use std::io;\n use regex::{NoExpand, Regex};\n use std::sync::{Arc, Future};\n \n+macro_rules! regex {\n+    ($e:expr) => (Regex::new($e).unwrap())\n+}\n+\n fn count_matches(seq: &str, variant: &Regex) -> int {\n     let mut n = 0;\n     for _ in variant.find_iter(seq) {"}, {"sha": "bbbd7aebd547538d61f875204bc3485f049e405b", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -46,7 +46,6 @@ extern crate libc;\n \n use std::io::stdio::{stdin_raw, stdout_raw};\n use std::io::{IoResult, EndOfFile};\n-use std::num::{div_rem};\n use std::ptr::{copy_memory, Unique};\n use std::thread::Thread;\n \n@@ -189,7 +188,8 @@ fn reverse_complement(seq: &mut [u8], tables: &Tables) {\n         i += LINE_LEN + 1;\n     }\n \n-    let (div, rem) = div_rem(len, 4);\n+    let div = len / 4;\n+    let rem = len % 4;\n     unsafe {\n         let mut left = seq.as_mut_ptr() as *mut u16;\n         // This is slow if len % 2 != 0 but still faster than bytewise operations."}, {"sha": "f3a593472256aacc0cc1358a8f15b25ac5abf2d7", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -43,14 +43,13 @@\n #![allow(non_snake_case)]\n #![feature(unboxed_closures)]\n \n-use std::iter::AdditiveIterator;\n+use std::iter::{repeat, AdditiveIterator};\n use std::thread::Thread;\n use std::mem;\n use std::num::Float;\n use std::os;\n use std::raw::Repr;\n use std::simd::f64x2;\n-use std::str::from_str;\n \n fn main() {\n     let args = os::args();\n@@ -59,16 +58,16 @@ fn main() {\n     } else if args.len() < 2 {\n         2000\n     } else {\n-        from_str(args[1].as_slice()).unwrap()\n+        args[1].parse().unwrap()\n     });\n     println!(\"{:.9}\", answer);\n }\n \n fn spectralnorm(n: uint) -> f64 {\n     assert!(n % 2 == 0, \"only even lengths are accepted\");\n-    let mut u = Vec::from_elem(n, 1.0);\n-    let mut v = Vec::from_elem(n, 1.0);\n-    let mut tmp = Vec::from_elem(n, 1.0);\n+    let mut u = repeat(1.0).take(n).collect::<Vec<_>>();\n+    let mut v = u.clone();\n+    let mut tmp = v.clone();\n     for _ in range(0u, 10) {\n         mult_AtAv(u.as_slice(), v.as_mut_slice(), tmp.as_mut_slice());\n         mult_AtAv(v.as_slice(), u.as_mut_slice(), tmp.as_mut_slice());"}, {"sha": "9dd1003785051e4c7a21c7e300554288d241dd56", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -39,7 +39,6 @@\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n use std::sync::mpsc::{channel, Sender, Receiver};\n-use std::str::from_str;\n use std::thread::Thread;\n \n fn start(n_tasks: int, token: int) {\n@@ -69,10 +68,10 @@ fn main() {\n     let token = if std::os::getenv(\"RUST_BENCH\").is_some() {\n         2000000\n     } else {\n-        args.get(1).and_then(|arg| from_str(arg.as_slice())).unwrap_or(1000)\n+        args.get(1).and_then(|arg| arg.parse()).unwrap_or(1000)\n     };\n     let n_tasks = args.get(2)\n-                      .and_then(|arg| from_str(arg.as_slice()))\n+                      .and_then(|arg| arg.parse())\n                       .unwrap_or(503);\n \n     start(n_tasks, token);"}, {"sha": "c2e657151f099cd941737cd5737a6ba7d04fe092", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -12,7 +12,6 @@\n \n use std::collections::VecMap;\n use std::os;\n-use std::str::from_str;\n use std::time::Duration;\n use std::uint;\n \n@@ -37,8 +36,8 @@ fn main() {\n     } else {\n         args.into_iter().collect()\n     };\n-    let max = from_str::<uint>(args[1].as_slice()).unwrap();\n-    let rep = from_str::<uint>(args[2].as_slice()).unwrap();\n+    let max = args[1].parse::<uint>().unwrap();\n+    let rep = args[2].parse::<uint>().unwrap();\n \n     let mut checkf = Duration::seconds(0);\n     let mut appendf = Duration::seconds(0);"}, {"sha": "85e8288b5cde52cb583c6c771167c29126f5e03a", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -15,9 +15,9 @@\n use std::io::BufferedReader;\n use std::io::stdio::StdReader;\n use std::io;\n+use std::iter::repeat;\n use std::num::Int;\n use std::os;\n-use std::str::from_str;\n \n // Computes a single solution to a given 9x9 sudoku\n //\n@@ -48,9 +48,9 @@ impl Sudoku {\n     }\n \n     pub fn from_vec(vec: &[[u8;9];9]) -> Sudoku {\n-        let g = Vec::from_fn(9u, |i| {\n-            Vec::from_fn(9u, |j| { vec[i][j] })\n-        });\n+        let g = range(0, 9u).map(|i| {\n+            range(0, 9u).map(|j| { vec[i][j] }).collect()\n+        }).collect();\n         return Sudoku::new(g)\n     }\n \n@@ -70,7 +70,8 @@ impl Sudoku {\n         /* assert first line is exactly \"9,9\" */\n         assert!(reader.read_line().unwrap() == \"9,9\".to_string());\n \n-        let mut g = Vec::from_fn(10u, { |_i| vec!(0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8) });\n+        let mut g = repeat(vec![0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8])\n+                          .take(10).collect::<Vec<_>>();\n         for line in reader.lines() {\n             let line = line.unwrap();\n             let comps: Vec<&str> = line.as_slice()\n@@ -79,10 +80,9 @@ impl Sudoku {\n                                        .collect();\n \n             if comps.len() == 3u {\n-                let row     = from_str::<uint>(comps[0]).unwrap() as u8;\n-                let col     = from_str::<uint>(comps[1]).unwrap() as u8;\n-                g[row as uint][col as uint] =\n-                    from_str::<uint>(comps[2]).unwrap() as u8;\n+                let row = comps[0].parse::<u8>().unwrap();\n+                let col = comps[1].parse::<u8>().unwrap();\n+                g[row as uint][col as uint] = comps[2].parse().unwrap();\n             }\n             else {\n                 panic!(\"Invalid sudoku file\");"}, {"sha": "9e78ede74ca917ef9df1b119cda056e1c29bb76e", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -11,7 +11,7 @@\n #![feature(unsafe_destructor)]\n \n use std::os;\n-use std::task;\n+use std::thread::Thread;\n use std::time::Duration;\n \n #[derive(Clone)]\n@@ -36,9 +36,9 @@ fn main() {\n fn run(repeat: int, depth: int) {\n     for _ in range(0, repeat) {\n         let dur = Duration::span(|| {\n-            task::try(move|| {\n+            let _ = Thread::spawn(move|| {\n                 recurse_or_panic(depth, None)\n-            });\n+            }).join();\n         });\n         println!(\"iter: {}\", dur);\n     }"}, {"sha": "30918d49090350fc28142d902c5898e1aec9bfa4", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -19,8 +19,6 @@\n \n use std::sync::mpsc::{channel, Sender};\n use std::os;\n-use std::str::from_str;\n-use std::task;\n use std::thread::Thread;\n use std::uint;\n \n@@ -30,7 +28,7 @@ fn child_generation(gens_left: uint, tx: Sender<()>) {\n     // alive at a time,\n     Thread::spawn(move|| {\n         if gens_left & 1 == 1 {\n-            task::deschedule(); // shake things up a bit\n+            Thread::yield_now(); // shake things up a bit\n         }\n         if gens_left > 0 {\n             child_generation(gens_left - 1, tx); // recurse\n@@ -51,7 +49,7 @@ fn main() {\n     };\n \n     let (tx, rx) = channel();\n-    child_generation(from_str::<uint>(args[1].as_slice()).unwrap(), tx);\n+    child_generation(args[1].parse().unwrap(), tx);\n     if rx.recv().is_err() {\n         panic!(\"it happened when we slumbered\");\n     }"}, {"sha": "488a5ec9edada04ef3cdd8848b28031956e32e06", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -9,14 +9,13 @@\n // except according to those terms.\n \n use std::os;\n-use std::task;\n use std::uint;\n-use std::str::from_str;\n+use std::thread::Thread;\n \n fn f(n: uint) {\n     let mut i = 0u;\n     while i < n {\n-        task::try(move|| g());\n+        let _ = Thread::spawn(move|| g()).join();\n         i += 1u;\n     }\n }\n@@ -32,7 +31,7 @@ fn main() {\n     } else {\n         args.into_iter().collect()\n     };\n-    let n = from_str::<uint>(args[1].as_slice()).unwrap();\n+    let n = args[1].parse().unwrap();\n     let mut i = 0u;\n-    while i < n { task::spawn(move|| f(n) ); i += 1u; }\n+    while i < n { Thread::spawn(move|| f(n) ).detach(); i += 1u; }\n }"}, {"sha": "32e0bff19918b34c65f2d20fe6408e5e9626edaa", "filename": "src/test/compile-fail-fulldeps/syntax-extension-regex-invalid.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-regex-invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-regex-invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-regex-invalid.rs?ref=470118f3e915cdc8f936aca0640b28a7a3d8dc6c", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-stage1\n-\n-#![feature(phase)]\n-\n-extern crate regex;\n-#[phase(plugin)] extern crate regex_macros;\n-\n-// Tests to make sure that `regex!` will produce a compile error when given\n-// an invalid regular expression.\n-// More exhaustive failure tests for the parser are done with the traditional\n-// unit testing infrastructure, since both dynamic and native regexes use the\n-// same parser.\n-\n-fn main() {\n-    let _ = regex!(\"(\"); //~ ERROR Regex syntax error\n-}"}, {"sha": "8f83c9ec94fbd86c0b60e8b931a5f17a38afe710", "filename": "src/test/compile-fail-fulldeps/syntax-extension-regex-unused-static.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-regex-unused-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-regex-unused-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-regex-unused-static.rs?ref=470118f3e915cdc8f936aca0640b28a7a3d8dc6c", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-stage1\n-\n-#![feature(phase)]\n-\n-extern crate regex;\n-#[phase(plugin)] extern crate regex_macros;\n-\n-#[deny(unused_variables)]\n-#[deny(dead_code)]\n-#[allow(non_upper_case_globals)]\n-\n-// Tests to make sure that extraneous dead code warnings aren't emitted from\n-// the code generated by regex!.\n-//\n-// The warning used for `static` items seems to be dead_code, which is why this\n-// is a distinct test from using a normal let binding (which generates an\n-// unused variable warning).\n-\n-fn main() {\n-    static fubar: regex::Regex = regex!(\"abc\"); //~ ERROR static item is never used: `fubar`\n-}"}, {"sha": "b4dda05f42d2b3e5820db2c16498bf22a89a9009", "filename": "src/test/compile-fail-fulldeps/syntax-extension-regex-unused.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-regex-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-regex-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-regex-unused.rs?ref=470118f3e915cdc8f936aca0640b28a7a3d8dc6c", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-stage1\n-\n-#![feature(phase)]\n-\n-extern crate regex;\n-#[phase(plugin)] extern crate regex_macros;\n-\n-#[deny(unused_variables)]\n-#[deny(dead_code)]\n-\n-// Tests to make sure that extraneous dead code warnings aren't emitted from\n-// the code generated by regex!.\n-\n-fn main() {\n-    let fubar = regex!(\"abc\"); //~ ERROR unused variable: `fubar`\n-}"}, {"sha": "15c726be2fd231f58c9eb9f3d73776159e7d63f0", "filename": "src/test/compile-fail/atomicoption-not-send-ref.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Ftest%2Fcompile-fail%2Fatomicoption-not-send-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Ftest%2Fcompile-fail%2Fatomicoption-not-send-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fatomicoption-not-send-ref.rs?ref=470118f3e915cdc8f936aca0640b28a7a3d8dc6c", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::sync::atomic::AtomicOption;\n-\n-fn main() {\n-    let x = 0u;\n-    AtomicOption::new(box &x);  //~ ERROR `x` does not live long enough\n-}"}, {"sha": "df3ebf530df99fee859c41206ba372b2cf0b05eb", "filename": "src/test/compile-fail/atomicoption-not-send.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Ftest%2Fcompile-fail%2Fatomicoption-not-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Ftest%2Fcompile-fail%2Fatomicoption-not-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fatomicoption-not-send.rs?ref=470118f3e915cdc8f936aca0640b28a7a3d8dc6c", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::kinds::marker;\n-use std::sync::atomic::AtomicOption;\n-\n-fn main() {\n-    AtomicOption::new(box marker::NoSend);  //~ ERROR `core::kinds::Send` is not implemented\n-}"}, {"sha": "cb673f9be34fc98a68fe3c8d10106f4c6a66e0c1", "filename": "src/test/compile-fail/borrowck-for-loop-head-linkage.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::iter::repeat;\n+\n fn main() {\n     let mut vector = vec![1u, 2];\n     for &x in vector.iter() {\n         let cap = vector.capacity();\n-        vector.grow(cap, 0u);      //~ ERROR cannot borrow\n+        vector.extend(repeat(0));      //~ ERROR cannot borrow\n         vector[1u] = 5u;   //~ ERROR cannot borrow\n     }\n }"}, {"sha": "9bd2d48b29a8587c8b6a00108950396ca1cead28", "filename": "src/test/compile-fail/borrowck-loan-blocks-move-cc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n \n fn borrow(v: &int, f: |x: &int|) {\n     f(v);\n@@ -17,7 +17,7 @@ fn borrow(v: &int, f: |x: &int|) {\n fn box_imm() {\n     let v = box 3i;\n     let _w = &v;\n-    task::spawn(move|| {\n+    Thread::spawn(move|| {\n         println!(\"v={}\", *v);\n         //~^ ERROR cannot move `v` into closure\n     });\n@@ -26,7 +26,7 @@ fn box_imm() {\n fn box_imm_explicit() {\n     let v = box 3i;\n     let _w = &v;\n-    task::spawn(move|| {\n+    Thread::spawn(move|| {\n         println!(\"v={}\", *v);\n         //~^ ERROR cannot move\n     });"}, {"sha": "2a26ff7d4a162ee9a48cc6a7ae514cd7c56f8fcc", "filename": "src/test/compile-fail/borrowck-multiple-captures.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fborrowck-multiple-captures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fborrowck-multiple-captures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-multiple-captures.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n \n fn borrow<T>(_: &T) { }\n \n@@ -17,7 +17,7 @@ fn different_vars_after_borrows() {\n     let p1 = &x1;\n     let x2 = box 2i;\n     let p2 = &x2;\n-    task::spawn(move|| {\n+    Thread::spawn(move|| {\n         drop(x1); //~ ERROR cannot move `x1` into closure because it is borrowed\n         drop(x2); //~ ERROR cannot move `x2` into closure because it is borrowed\n     });\n@@ -30,7 +30,7 @@ fn different_vars_after_moves() {\n     drop(x1);\n     let x2 = box 2i;\n     drop(x2);\n-    task::spawn(move|| {\n+    Thread::spawn(move|| {\n         drop(x1); //~ ERROR capture of moved value: `x1`\n         drop(x2); //~ ERROR capture of moved value: `x2`\n     });\n@@ -39,7 +39,7 @@ fn different_vars_after_moves() {\n fn same_var_after_borrow() {\n     let x = box 1i;\n     let p = &x;\n-    task::spawn(move|| {\n+    Thread::spawn(move|| {\n         drop(x); //~ ERROR cannot move `x` into closure because it is borrowed\n         drop(x); //~ ERROR use of moved value: `x`\n     });\n@@ -49,7 +49,7 @@ fn same_var_after_borrow() {\n fn same_var_after_move() {\n     let x = box 1i;\n     drop(x);\n-    task::spawn(move|| {\n+    Thread::spawn(move|| {\n         drop(x); //~ ERROR capture of moved value: `x`\n         drop(x); //~ ERROR use of moved value: `x`\n     });"}, {"sha": "6b09c365235413fdbd9a0ba453b706b626986504", "filename": "src/test/compile-fail/deriving-span-Zero-struct.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-struct.rs?ref=470118f3e915cdc8f936aca0640b28a7a3d8dc6c", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n-\n-extern crate rand;\n-\n-\n-struct Error;\n-\n-#[derive(Zero)]   //~ ERROR not implemented\n-struct Struct {\n-    x: Error\n-}\n-\n-fn main() {}"}, {"sha": "c11af72f5c983ec692df8da063d4965162b8821f", "filename": "src/test/compile-fail/deriving-span-Zero-tuple-struct.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-tuple-struct.rs?ref=470118f3e915cdc8f936aca0640b28a7a3d8dc6c", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n-\n-extern crate rand;\n-\n-\n-struct Error;\n-\n-#[derive(Zero)]   //~ ERROR not implemented\n-struct Struct(\n-    Error\n-);\n-\n-fn main() {}"}, {"sha": "6a5bde365b42978b5fb1cd1669451298a985f71d", "filename": "src/test/compile-fail/future_not_copyable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Ffuture_not_copyable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Ffuture_not_copyable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffuture_not_copyable.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -13,5 +13,5 @@ use std::sync::Future;\n fn main() {\n     let f = Future::from_value(());\n     let g = f;\n-    f.unwrap(); //~ ERROR use of moved value\n+    f.into_inner(); //~ ERROR use of moved value\n }"}, {"sha": "edd57477d7699d19202402a92b9670094666007f", "filename": "src/test/compile-fail/hashmap-lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fhashmap-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fhashmap-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhashmap-lifetimes.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -13,5 +13,5 @@ fn main() {\n     my_stuff.insert(0i, 42i);\n \n     let mut it = my_stuff.iter();\n-    my_stuff.swap(1, 43); //~ ERROR cannot borrow\n+    my_stuff.insert(1, 43); //~ ERROR cannot borrow\n }"}, {"sha": "6b048528a996e698aaee2895249e9d648806b67f", "filename": "src/test/compile-fail/issue-11374.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fissue-11374.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fissue-11374.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11374.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -32,6 +32,6 @@ pub fn for_stdin<'a>() -> Container<'a> {\n \n fn main() {\n     let mut c = for_stdin();\n-    let mut v = vec::Vec::from_elem(10, 0u8);\n+    let mut v = Vec::new();\n     c.read_to(v.as_mut_slice());\n }"}, {"sha": "f3e7a65db481e6f3d821b45829b7f1124718f475", "filename": "src/test/compile-fail/issue-15783.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fissue-15783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fissue-15783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15783.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn foo(params: Option<&[&str]>) -> uint {\n-    params.unwrap().head().unwrap().len()\n+    params.unwrap().first().unwrap().len()\n }\n \n fn main() {"}, {"sha": "ac2eb735637fa405782dda2c5e69f55a906d2496", "filename": "src/test/compile-fail/issue-17728.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -20,7 +20,7 @@ trait HasInventory {\n trait TraversesWorld {\n     fn attemptTraverse(&self, room: &Room, directionStr: &str) -> Result<&Room, &str> {\n         let direction = str_to_direction(directionStr);\n-        let maybe_room = room.direction_to_room.find(&direction);\n+        let maybe_room = room.direction_to_room.get(&direction);\n         //~^ ERROR cannot infer an appropriate lifetime for autoref due to conflicting requirements\n         match maybe_room {\n             Some(entry) => Ok(entry),"}, {"sha": "dc90994fcc102e3c2455050dcb88a44538f8c5db", "filename": "src/test/compile-fail/moves-based-on-type-capture-clause-bad.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-capture-clause-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-capture-clause-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-capture-clause-bad.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n \n fn main() {\n     let x = \"Hello world!\".to_string();\n-    task::spawn(move|| {\n+    Thread::spawn(move|| {\n         println!(\"{}\", x);\n     });\n     println!(\"{}\", x); //~ ERROR use of moved value"}, {"sha": "9a09448ff01fed54bb8cbd0e862bdebbb542ce24", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -11,13 +11,13 @@\n // error-pattern: use of moved value\n \n use std::sync::Arc;\n-use std::task;\n+use std::thread::Thread;\n \n fn main() {\n     let v = vec!(1i, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n     let arc_v = Arc::new(v);\n \n-    task::spawn(move|| {\n+    Thread::spawn(move|| {\n         assert_eq!((*arc_v)[3], 4);\n     });\n "}, {"sha": "de23074368576d6476a48abad347d4076d03af13", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n \n use std::sync::Arc;\n-use std::task;\n+use std::thread::Thread;\n \n fn main() {\n     let v = vec!(1i, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n     let arc_v = Arc::new(v);\n \n-    task::spawn(move|| {\n+    Thread::spawn(move|| {\n         assert_eq!((*arc_v)[3], 4);\n     });\n "}, {"sha": "9e56b27a05b6b5280d9cd583cc193eb5e8580724", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(unsafe_destructor)]\n \n-use std::task;\n+use std::thread::Thread;\n use std::rc::Rc;\n \n #[derive(Show)]\n@@ -35,7 +35,7 @@ fn main() {\n \n     let x = foo(Port(Rc::new(())));\n \n-    task::spawn(move|| {\n+    Thread::spawn(move|| {\n         //~^ ERROR `core::kinds::Send` is not implemented\n         //~^^ ERROR `core::kinds::Send` is not implemented\n         let y = x;"}, {"sha": "6cc45090b9024a70b73bb0273e326a1c57838ec2", "filename": "src/test/compile-fail/spawn-non-nil-fn.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Ftest%2Fcompile-fail%2Fspawn-non-nil-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Ftest%2Fcompile-fail%2Fspawn-non-nil-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspawn-non-nil-fn.rs?ref=470118f3e915cdc8f936aca0640b28a7a3d8dc6c", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::task;\n-\n-fn main() {\n-    // We get an error because return type is `->int` and not `->()`.\n-    task::spawn(|| -> int { 10 });\n-    //~^ ERROR type mismatch\n-}"}, {"sha": "a97a3e61678191f4e0367472cb901c2e016678e5", "filename": "src/test/compile-fail/std-uncopyable-atomics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -24,6 +24,4 @@ fn main() {\n     let x = *&x; //~ ERROR: cannot move out of dereference\n     let x: AtomicPtr<uint> = AtomicPtr::new(ptr::null_mut());\n     let x = *&x; //~ ERROR: cannot move out of dereference\n-    let x: AtomicOption<uint> = AtomicOption::empty();\n-    let x = *&x; //~ ERROR: cannot move out of dereference\n }"}, {"sha": "972c85e376e51075b8a6ac17d7aa9412be37ce8a", "filename": "src/test/run-fail/rt-set-exit-status-panic2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -13,7 +13,7 @@\n #![feature(phase)]\n #[phase(plugin, link)] extern crate log;\n use std::os;\n-use std::task;\n+use std::thread::Thread;\n \n struct r {\n   x:int,\n@@ -36,7 +36,7 @@ fn r(x:int) -> r {\n \n fn main() {\n     error!(\"whatever\");\n-    task::spawn(move|| {\n+    let _t = Thread::spawn(move|| {\n       let _i = r(5);\n     });\n     panic!();"}, {"sha": "8aade64163056e1c26ec7349f91e43dfd4930dea", "filename": "src/test/run-fail/task-spawn-barefn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -10,12 +10,12 @@\n \n // error-pattern:Ensure that the child task runs by panicking\n \n-use std::task;\n+use std::thread::Thread;\n \n fn main() {\n     // the purpose of this test is to make sure that task::spawn()\n     // works when provided with a bare function:\n-    let r = task::try(startfn);\n+    let r = Thread::spawn(startfn).join();\n     if r.is_err() {\n         panic!()\n     }"}, {"sha": "2028710cbd2bc49f230aeb5897d9c06fe56743a9", "filename": "src/test/run-make/lto-syntax-extension/main.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-make%2Flto-syntax-extension%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-make%2Flto-syntax-extension%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flto-syntax-extension%2Fmain.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -11,9 +11,6 @@\n #![feature(phase)]\n \n extern crate lib;\n-extern crate regex;\n-#[phase(plugin)] extern crate regex_macros;\n+#[phase(plugin, link)] extern crate log;\n \n-fn main() {\n-    regex!(\"1234\");\n-}\n+fn main() {}"}, {"sha": "faac858e76e0b34aca046641d6fa04ecb821c18e", "filename": "src/test/run-make/static-unwinding/main.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-make%2Fstatic-unwinding%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-make%2Fstatic-unwinding%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fstatic-unwinding%2Fmain.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -10,7 +10,7 @@\n \n extern crate lib;\n \n-use std::task;\n+use std::thread::Thread;\n \n static mut statik: int = 0;\n \n@@ -22,11 +22,11 @@ impl Drop for A {\n }\n \n fn main() {\n-    task::try(move|| {\n+    Thread::spawn(move|| {\n         let _a = A;\n         lib::callback(|| panic!());\n         1i\n-    });\n+    }).join().err().unwrap();\n \n     unsafe {\n         assert!(lib::statik == 1);"}, {"sha": "ae638399450c9c7dce53e462c850f477859c24c9", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,9 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::{char, os};\n use std::io::{File, Command};\n+use std::iter::repeat;\n use std::rand::{thread_rng, Rng};\n+use std::{char, os};\n \n // creates a file with `fn main() { <random ident> }` and checks the\n // compiler emits a span of the appropriate length (for the\n@@ -60,7 +61,8 @@ fn main() {\n         let err = String::from_utf8_lossy(result.error.as_slice());\n \n         // the span should end the line (e.g no extra ~'s)\n-        let expected_span = format!(\"^{}\\n\", \"~\".repeat(n - 1));\n+        let expected_span = format!(\"^{}\\n\", repeat(\"~\").take(n - 1)\n+                                                        .collect::<String>());\n         assert!(err.as_slice().contains(expected_span.as_slice()));\n     }\n }"}, {"sha": "39af96a58e6e3b10b38504eeae868dcfbbcb534f", "filename": "src/test/run-pass/child-outlives-parent.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -10,10 +10,10 @@\n \n // Reported as issue #126, child leaks the string.\n \n-use std::task;\n+use std::thread::Thread;\n \n fn child2(_s: String) { }\n \n pub fn main() {\n-    let _x = task::spawn(move|| child2(\"hi\".to_string()));\n+    let _x = Thread::spawn(move|| child2(\"hi\".to_string()));\n }"}, {"sha": "cb495859708b6e821664b9f52cc9e2b821816784", "filename": "src/test/run-pass/clone-with-exterior.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task::spawn;\n+use std::thread::Thread;\n \n struct Pair {\n     a: int,\n@@ -18,7 +18,7 @@ struct Pair {\n pub fn main() {\n     let z = box Pair { a : 10, b : 12};\n \n-    spawn(move|| {\n+    let _t = Thread::spawn(move|| {\n         assert_eq!(z.a, 10);\n         assert_eq!(z.b, 12);\n     });"}, {"sha": "16a21adc3fcf90067067a902b385128f267b4869", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n use std::sync::mpsc::{channel, Sender};\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    let _t = task::spawn(move|| { child(&tx) });\n+    let _t = Thread::spawn(move|| { child(&tx) });\n     let y = rx.recv().unwrap();\n     println!(\"received\");\n     println!(\"{}\", y);"}, {"sha": "5e028d3774fc50d4c7c06edd1bc204e8a5600ae2", "filename": "src/test/run-pass/const-str-ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -18,13 +18,13 @@ const C: *const u8 = B as *const u8;\n pub fn main() {\n     unsafe {\n         let foo = &A as *const u8;\n-        assert_eq!(str::raw::from_utf8(&A), \"hi\");\n-        assert_eq!(string::raw::from_buf_len(foo, A.len()), \"hi\".to_string());\n-        assert_eq!(string::raw::from_buf_len(C, B.len()), \"hi\".to_string());\n+        assert_eq!(str::from_utf8_unchecked(&A), \"hi\");\n+        assert_eq!(String::from_raw_buf_len(foo, A.len()), \"hi\".to_string());\n+        assert_eq!(String::from_raw_buf_len(C, B.len()), \"hi\".to_string());\n         assert!(*C == A[0]);\n         assert!(*(&B[0] as *const u8) == A[0]);\n \n-        let bar = str::raw::from_utf8(&A).to_c_str();\n+        let bar = str::from_utf8_unchecked(&A).to_c_str();\n         assert_eq!(bar.as_str(), \"hi\".to_c_str().as_str());\n     }\n }"}, {"sha": "442c330b277863adb57427343e3287b6d68d415f", "filename": "src/test/run-pass/deriving-zero.rs", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470118f3e915cdc8f936aca0640b28a7a3d8dc6c/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-zero.rs?ref=470118f3e915cdc8f936aca0640b28a7a3d8dc6c", "patch": "@@ -1,71 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(associated_types)]\n-\n-use std::num::Zero;\n-use std::ops::Add;\n-\n-#[derive(Zero)]\n-struct Vector2<T>(T, T);\n-\n-impl<T: Add<Output=T>> Add for Vector2<T> {\n-    type Output = Vector2<T>;\n-\n-    fn add(self, other: Vector2<T>) -> Vector2<T> {\n-        match (self, other) {\n-            (Vector2(x0, y0), Vector2(x1, y1)) => {\n-                Vector2(x0 + x1, y0 + y1)\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Zero)]\n-struct Vector3<T> {\n-    x: T, y: T, z: T,\n-}\n-\n-impl<T: Add<Output=T>> Add for Vector3<T> {\n-    type Output = Vector3<T>;\n-\n-    fn add(self, other: Vector3<T>) -> Vector3<T> {\n-        Vector3 {\n-            x: self.x + other.x,\n-            y: self.y + other.y,\n-            z: self.z + other.z,\n-        }\n-    }\n-}\n-\n-#[derive(Zero)]\n-struct Matrix3x2<T> {\n-    x: Vector2<T>,\n-    y: Vector2<T>,\n-    z: Vector2<T>,\n-}\n-\n-impl<T: Add<Output=T>> Add for Matrix3x2<T> {\n-    type Output = Matrix3x2<T>;\n-\n-    fn add(self, other: Matrix3x2<T>) -> Matrix3x2<T> {\n-        Matrix3x2 {\n-            x: self.x + other.x,\n-            y: self.y + other.y,\n-            z: self.z + other.z,\n-        }\n-    }\n-}\n-\n-pub fn main() {\n-    let _: Vector2<int> = Zero::zero();\n-    let _: Vector3<f64> = Zero::zero();\n-    let _: Matrix3x2<u8> = Zero::zero();\n-}"}, {"sha": "f1cc4fb172409e20050ba03420e8732c87bce634", "filename": "src/test/run-pass/drop-trait-enum.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fdrop-trait-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fdrop-trait-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-trait-enum.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n use std::sync::mpsc::{channel, Sender};\n \n #[derive(PartialEq, Show)]\n@@ -66,23 +66,23 @@ pub fn main() {\n     assert_eq!(receiver.recv().ok(), None);\n \n     let (sender, receiver) = channel();\n-    task::spawn(move|| {\n+    let _t = Thread::spawn(move|| {\n         let v = Foo::FailingVariant { on_drop: SendOnDrop { sender: sender } };\n     });\n     assert_eq!(receiver.recv().unwrap(), Message::Dropped);\n     assert_eq!(receiver.recv().ok(), None);\n \n     let (sender, receiver) = channel();\n-    {\n-        task::spawn(move|| {\n+    let _t = {\n+        Thread::spawn(move|| {\n             let mut v = Foo::NestedVariant(box 42u, SendOnDrop {\n                 sender: sender.clone()\n             }, sender.clone());\n             v = Foo::NestedVariant(box 42u, SendOnDrop { sender: sender.clone() }, sender.clone());\n             v = Foo::SimpleVariant(sender.clone());\n             v = Foo::FailingVariant { on_drop: SendOnDrop { sender: sender } };\n-        });\n-    }\n+        })\n+    };\n     assert_eq!(receiver.recv().unwrap(), Message::DestructorRan);\n     assert_eq!(receiver.recv().unwrap(), Message::Dropped);\n     assert_eq!(receiver.recv().unwrap(), Message::DestructorRan);"}, {"sha": "3c4c1da52ea95c7e4c6ba90f18a56966b233ca50", "filename": "src/test/run-pass/extern-call-deep2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n extern crate libc;\n-use std::task;\n+use std::thread::Thread;\n \n mod rustrt {\n     extern crate libc;\n@@ -40,7 +40,7 @@ fn count(n: libc::uintptr_t) -> libc::uintptr_t {\n pub fn main() {\n     // Make sure we're on a task with small Rust stacks (main currently\n     // has a large stack)\n-    task::spawn(move|| {\n+    let _t = Thread::spawn(move|| {\n         let result = count(1000);\n         println!(\"result = {}\", result);\n         assert_eq!(result, 1000);"}, {"sha": "0dca7514dc5cf1cfed2e426fead18ad0b1f56359", "filename": "src/test/run-pass/extern-call-scrub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -13,7 +13,7 @@\n // directions\n \n extern crate libc;\n-use std::task;\n+use std::thread::Thread;\n \n mod rustrt {\n     extern crate libc;\n@@ -44,7 +44,7 @@ fn count(n: libc::uintptr_t) -> libc::uintptr_t {\n pub fn main() {\n     // Make sure we're on a task with small Rust stacks (main currently\n     // has a large stack)\n-    task::spawn(move|| {\n+    let _t = Thread::spawn(move|| {\n         let result = count(12);\n         println!(\"result = {}\", result);\n         assert_eq!(result, 2048);"}, {"sha": "bb9e94073828a811d7f850894bf37d6afaf14fd9", "filename": "src/test/run-pass/extern-stress.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-stress.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -12,7 +12,7 @@\n // while holding onto C stacks\n \n extern crate libc;\n-use std::task;\n+use std::thread::Thread;\n \n mod rustrt {\n     extern crate libc;\n@@ -29,7 +29,7 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     if data == 1 {\n         data\n     } else {\n-        task::deschedule();\n+        Thread::yield_now();\n         count(data - 1) + count(data - 1)\n     }\n }\n@@ -41,9 +41,9 @@ fn count(n: libc::uintptr_t) -> libc::uintptr_t {\n }\n \n pub fn main() {\n-    for _ in range(0u, 100) {\n-        task::spawn(move|| {\n+    range(0u, 100).map(|_| {\n+        Thread::spawn(move|| {\n             assert_eq!(count(5), 16);\n-        });\n-    }\n+        })\n+    }).collect::<Vec<_>>();\n }"}, {"sha": "46829e9ba6ef8f3286b18c42ef6a3549bc3ad6e4", "filename": "src/test/run-pass/extern-yield.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-yield.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n extern crate libc;\n-use std::task;\n+use std::thread::Thread;\n \n mod rustrt {\n     extern crate libc;\n@@ -32,17 +32,17 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n \n fn count(n: libc::uintptr_t) -> libc::uintptr_t {\n     unsafe {\n-        task::deschedule();\n+        Thread::yield_now();\n         rustrt::rust_dbg_call(cb, n)\n     }\n }\n \n pub fn main() {\n-    for _ in range(0, 10u) {\n-        task::spawn(move|| {\n+    range(0, 10u).map(|i| {\n+        Thread::spawn(move|| {\n             let result = count(5);\n             println!(\"result = {}\", result);\n             assert_eq!(result, 16);\n-        });\n-    }\n+        })\n+    }).collect::<Vec<_>>();\n }"}, {"sha": "7fd8ca1fd8a9e3ac975ccbbe4d241d89da153fcf", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -23,7 +23,7 @@ mod map_reduce {\n     use std::collections::HashMap;\n     use std::sync::mpsc::{channel, Sender};\n     use std::str;\n-    use std::task;\n+    use std::thread::Thread;\n \n     pub type putter<'a> = |String, String|: 'a;\n \n@@ -35,7 +35,7 @@ mod map_reduce {\n         for i in inputs.iter() {\n             let ctrl = ctrl.clone();\n             let i = i.clone();\n-            task::spawn(move|| map_task(ctrl.clone(), i.clone()) );\n+            Thread::spawn(move|| map_task(ctrl.clone(), i.clone()) ).detach();\n         }\n     }\n "}, {"sha": "b7cd8a901127631c646e145b1344169d164bb66a", "filename": "src/test/run-pass/issue-13323.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fissue-13323.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fissue-13323.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13323.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -14,7 +14,7 @@ struct StrWrap {\n \n impl StrWrap {\n     fn new(s: &str) -> StrWrap {\n-        StrWrap { s: s.into_string() }\n+        StrWrap { s: s.to_string() }\n     }\n \n     fn get_s<'a>(&'a self) -> &'a str {"}, {"sha": "57dc6fd75f08c603c1b1471cb0362720130cdf4c", "filename": "src/test/run-pass/issue-15149.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fissue-15149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fissue-15149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15149.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -10,7 +10,6 @@\n \n use std::io::{TempDir, Command, fs};\n use std::os;\n-use std::task::TaskBuilder;\n \n fn main() {\n     // If we're the child, make sure we were invoked correctly"}, {"sha": "44cf0dd8b8ee8fe23267ce25d4a87205fa47104c", "filename": "src/test/run-pass/issue-17718.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fissue-17718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fissue-17718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17718.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -12,10 +12,10 @@\n \n extern crate \"issue-17718\" as other;\n \n-use std::sync::atomic;\n+use std::sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n \n const C1: uint = 1;\n-const C2: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n+const C2: AtomicUint = ATOMIC_UINT_INIT;\n const C3: fn() = foo;\n const C4: uint = C1 * C1 + C1 / C1;\n const C5: &'static uint = &C4;\n@@ -25,7 +25,7 @@ const C6: uint = {\n };\n \n static S1: uint = 3;\n-static S2: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n+static S2: AtomicUint = ATOMIC_UINT_INIT;\n \n mod test {\n     static A: uint = 4;\n@@ -38,14 +38,14 @@ fn foo() {}\n fn main() {\n     assert_eq!(C1, 1);\n     assert_eq!(C3(), ());\n-    assert_eq!(C2.fetch_add(1, atomic::SeqCst), 0);\n-    assert_eq!(C2.fetch_add(1, atomic::SeqCst), 0);\n+    assert_eq!(C2.fetch_add(1, Ordering::SeqCst), 0);\n+    assert_eq!(C2.fetch_add(1, Ordering::SeqCst), 0);\n     assert_eq!(C4, 2);\n     assert_eq!(*C5, 2);\n     assert_eq!(C6, 3);\n     assert_eq!(S1, 3);\n-    assert_eq!(S2.fetch_add(1, atomic::SeqCst), 0);\n-    assert_eq!(S2.fetch_add(1, atomic::SeqCst), 1);\n+    assert_eq!(S2.fetch_add(1, Ordering::SeqCst), 0);\n+    assert_eq!(S2.fetch_add(1, Ordering::SeqCst), 1);\n \n     match 1 {\n         C1 => {}\n@@ -62,13 +62,13 @@ fn main() {\n \n     assert_eq!(other::C1, 1);\n     assert_eq!(other::C3(), ());\n-    assert_eq!(other::C2.fetch_add(1, atomic::SeqCst), 0);\n-    assert_eq!(other::C2.fetch_add(1, atomic::SeqCst), 0);\n+    assert_eq!(other::C2.fetch_add(1, Ordering::SeqCst), 0);\n+    assert_eq!(other::C2.fetch_add(1, Ordering::SeqCst), 0);\n     assert_eq!(other::C4, 2);\n     assert_eq!(*other::C5, 2);\n     assert_eq!(other::S1, 3);\n-    assert_eq!(other::S2.fetch_add(1, atomic::SeqCst), 0);\n-    assert_eq!(other::S2.fetch_add(1, atomic::SeqCst), 1);\n+    assert_eq!(other::S2.fetch_add(1, Ordering::SeqCst), 0);\n+    assert_eq!(other::S2.fetch_add(1, Ordering::SeqCst), 1);\n \n     let _a = other::C1;\n     let _a = other::C2;"}, {"sha": "94bff890820ddc2e1ddfbcfb760988140401378f", "filename": "src/test/run-pass/issue-2383.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fissue-2383.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fissue-2383.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2383.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -14,5 +14,5 @@ use std::collections::RingBuf;\n \n pub fn main() {\n     let mut q = RingBuf::new();\n-    q.push(10i);\n+    q.push_front(10i);\n }"}, {"sha": "f414606340924b82c3b87b0ae8efefce2711230a", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -22,7 +22,7 @@ pub mod pipes {\n     use std::mem::{forget, transmute};\n     use std::mem::{replace, swap};\n     use std::mem;\n-    use std::task;\n+    use std::thread::Thread;\n     use std::kinds::Send;\n \n     pub struct Stuff<T> {\n@@ -116,7 +116,7 @@ pub mod pipes {\n             let old_state = swap_state_acq(&mut (*p).state,\n                                            blocked);\n             match old_state {\n-              empty | blocked => { task::deschedule(); }\n+              empty | blocked => { Thread::yield_now(); }\n               full => {\n                 let payload = replace(&mut p.payload, None);\n                 return Some(payload.unwrap())"}, {"sha": "25b933b8f96fe01041012509adcb5402abdfd21b", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -23,7 +23,7 @@ enum object {\n \n fn lookup(table: json::Object, key: String, default: String) -> String\n {\n-    match table.find(&key.to_string()) {\n+    match table.get(&key) {\n         option::Option::Some(&Json::String(ref s)) => {\n             s.to_string()\n         }"}, {"sha": "bef082569b9c634f423332be01a0469424ad25c1", "filename": "src/test/run-pass/issue-2989.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fissue-2989.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fissue-2989.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2989.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -14,19 +14,19 @@ trait methods {\n \n impl methods for () {\n     fn to_bytes(&self) -> Vec<u8> {\n-        Vec::from_elem(0, 0u8)\n+        Vec::new()\n     }\n }\n \n // the position of this function is significant! - if it comes before methods\n // then it works, if it comes after it then it doesn't!\n fn to_bools(bitv: Storage) -> Vec<bool> {\n-    Vec::from_fn(8, |i| {\n+    range(0, 8).map(|i| {\n         let w = i / 64;\n         let b = i % 64;\n         let x = 1u64 & (bitv.storage[w] >> b);\n         x == 1u64\n-    })\n+    }).collect()\n }\n \n struct Storage { storage: Vec<u64> }"}, {"sha": "a3903128b65397b871e649341aeb8387e0080d24", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,20 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ASCII art shape renderer.\n-// Demonstrates traits, impls, operator overloading, non-copyable struct, unit testing.\n-// To run execute: rustc --test shapes.rs && ./shapes\n+// ASCII art shape renderer.  Demonstrates traits, impls, operator overloading,\n+// non-copyable struct, unit testing.  To run execute: rustc --test shapes.rs &&\n+// ./shapes\n \n-// Rust's std library is tightly bound to the language itself so it is automatically linked in.\n-// However the extra library is designed to be optional (for code that must run on constrained\n-//  environments like embedded devices or special environments like kernel code) so it must\n-// be explicitly linked in.\n+// Rust's std library is tightly bound to the language itself so it is\n+// automatically linked in.  However the extra library is designed to be\n+// optional (for code that must run on constrained environments like embedded\n+// devices or special environments like kernel code) so it must be explicitly\n+// linked in.\n \n-// Extern mod controls linkage. Use controls the visibility of names to modules that are\n-// already linked in. Using WriterUtil allows us to use the write_line method.\n+// Extern mod controls linkage. Use controls the visibility of names to modules\n+// that are already linked in. Using WriterUtil allows us to use the write_line\n+// method.\n \n-use std::slice;\n use std::fmt;\n+use std::iter::repeat;\n+use std::slice;\n \n // Represents a position on a canvas.\n struct Point {\n@@ -70,7 +73,7 @@ fn AsciiArt(width: uint, height: uint, fill: char) -> AsciiArt {\n     // blank characters for each position in our canvas.\n     let mut lines = Vec::new();\n     for _ in range(0, height) {\n-        lines.push(Vec::from_elem(width, '.'));\n+        lines.push(repeat('.').take(width).collect::<Vec<_>>());\n     }\n \n     // Rust code often returns values by omitting the trailing semi-colon\n@@ -105,7 +108,7 @@ impl fmt::Show for AsciiArt {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // Convert each line into a string.\n         let lines = self.lines.iter()\n-                              .map(|line| String::from_chars(line.as_slice()))\n+                              .map(|line| line.iter().cloned().collect())\n                               .collect::<Vec<String>>();\n \n         // Concatenate the lines together using a new-line."}, {"sha": "b89ee81a7274fdf026f5415f7aed924e4253dd2d", "filename": "src/test/run-pass/issue-3609.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3609.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(default_type_params)]\n \n-use std::task;\n+use std::thread::Thread;\n use std::sync::mpsc::Sender;\n use std::thunk::Invoke;\n \n@@ -23,7 +23,7 @@ enum Msg\n }\n \n fn foo(name: String, samples_chan: Sender<Msg>) {\n-    task::spawn(move|| {\n+    let _t = Thread::spawn(move|| {\n         let mut samples_chan = samples_chan;\n \n         // `box() (...)` syntax is needed to make pretty printer converge in one try:"}, {"sha": "3d5e32972e7247ef548c3b2e90e350faec1a7336", "filename": "src/test/run-pass/issue-8460.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8460.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -9,27 +9,27 @@\n // except according to those terms.\n \n use std::{int, i8, i16, i32, i64};\n-use std::task;\n+use std::thread::Thread;\n \n fn main() {\n-    assert!(task::try(move|| int::MIN / -1).is_err());\n-    assert!(task::try(move|| i8::MIN / -1).is_err());\n-    assert!(task::try(move|| i16::MIN / -1).is_err());\n-    assert!(task::try(move|| i32::MIN / -1).is_err());\n-    assert!(task::try(move|| i64::MIN / -1).is_err());\n-    assert!(task::try(move|| 1i / 0).is_err());\n-    assert!(task::try(move|| 1i8 / 0).is_err());\n-    assert!(task::try(move|| 1i16 / 0).is_err());\n-    assert!(task::try(move|| 1i32 / 0).is_err());\n-    assert!(task::try(move|| 1i64 / 0).is_err());\n-    assert!(task::try(move|| int::MIN % -1).is_err());\n-    assert!(task::try(move|| i8::MIN % -1).is_err());\n-    assert!(task::try(move|| i16::MIN % -1).is_err());\n-    assert!(task::try(move|| i32::MIN % -1).is_err());\n-    assert!(task::try(move|| i64::MIN % -1).is_err());\n-    assert!(task::try(move|| 1i % 0).is_err());\n-    assert!(task::try(move|| 1i8 % 0).is_err());\n-    assert!(task::try(move|| 1i16 % 0).is_err());\n-    assert!(task::try(move|| 1i32 % 0).is_err());\n-    assert!(task::try(move|| 1i64 % 0).is_err());\n+    assert!(Thread::spawn(move|| int::MIN / -1).join().is_err());\n+    assert!(Thread::spawn(move|| i8::MIN / -1).join().is_err());\n+    assert!(Thread::spawn(move|| i16::MIN / -1).join().is_err());\n+    assert!(Thread::spawn(move|| i32::MIN / -1).join().is_err());\n+    assert!(Thread::spawn(move|| i64::MIN / -1).join().is_err());\n+    assert!(Thread::spawn(move|| 1i / 0).join().is_err());\n+    assert!(Thread::spawn(move|| 1i8 / 0).join().is_err());\n+    assert!(Thread::spawn(move|| 1i16 / 0).join().is_err());\n+    assert!(Thread::spawn(move|| 1i32 / 0).join().is_err());\n+    assert!(Thread::spawn(move|| 1i64 / 0).join().is_err());\n+    assert!(Thread::spawn(move|| int::MIN % -1).join().is_err());\n+    assert!(Thread::spawn(move|| i8::MIN % -1).join().is_err());\n+    assert!(Thread::spawn(move|| i16::MIN % -1).join().is_err());\n+    assert!(Thread::spawn(move|| i32::MIN % -1).join().is_err());\n+    assert!(Thread::spawn(move|| i64::MIN % -1).join().is_err());\n+    assert!(Thread::spawn(move|| 1i % 0).join().is_err());\n+    assert!(Thread::spawn(move|| 1i8 % 0).join().is_err());\n+    assert!(Thread::spawn(move|| 1i16 % 0).join().is_err());\n+    assert!(Thread::spawn(move|| 1i32 % 0).join().is_err());\n+    assert!(Thread::spawn(move|| 1i64 % 0).join().is_err());\n }"}, {"sha": "dd38a5f8b3ba7b23906bc3b11dede3688d8cfb41", "filename": "src/test/run-pass/ivec-tag.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-tag.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n use std::sync::mpsc::{channel, Sender};\n \n fn producer(tx: &Sender<Vec<u8>>) {\n@@ -19,7 +19,7 @@ fn producer(tx: &Sender<Vec<u8>>) {\n \n pub fn main() {\n     let (tx, rx) = channel::<Vec<u8>>();\n-    let _prod = task::spawn(move|| {\n+    let _prod = Thread::spawn(move|| {\n         producer(&tx)\n     });\n "}, {"sha": "f2d509ee61ddd4cb2f4054ce918d3cfdfd3616fa", "filename": "src/test/run-pass/kindck-implicit-close-over-mut-var.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n \n fn user(_i: int) {}\n \n fn foo() {\n     // Here, i is *copied* into the proc (heap closure).\n     // Requires allocation.  The proc's copy is not mutable.\n     let mut i = 0;\n-    task::spawn(move|| {\n+    let _t = Thread::spawn(move|| {\n         user(i);\n         println!(\"spawned {}\", i)\n     });\n@@ -29,7 +29,7 @@ fn bar() {\n     // mutable outside of the proc.\n     let mut i = 0;\n     while i < 10 {\n-        task::spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             user(i);\n         });\n         i += 1;\n@@ -40,7 +40,7 @@ fn car() {\n     // Here, i must be shadowed in the proc to be mutable.\n     let mut i = 0;\n     while i < 10 {\n-        task::spawn(move|| {\n+        let _t = Thread::spawn(move|| {\n             let mut i = i;\n             i += 1;\n             user(i);"}, {"sha": "a1537e63e57b2482262356581d033b3827ba7b19", "filename": "src/test/run-pass/match-with-ret-arm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fmatch-with-ret-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fmatch-with-ret-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-with-ret-arm.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -9,13 +9,12 @@\n // except according to those terms.\n \n use std::uint;\n-use std::str::from_str;\n \n pub fn main() {\n     // sometimes we have had trouble finding\n     // the right type for f, as we unified\n     // bot and u32 here\n-    let f = match from_str::<uint>(\"1234\") {\n+    let f = match \"1234\".parse::<uint>() {\n         None => return (),\n         Some(num) => num as u32\n     };"}, {"sha": "f03ec7b6f3e125a00595214df670d4a4ea4176ec", "filename": "src/test/run-pass/mod-view-items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fmod-view-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fmod-view-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmod-view-items.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -16,7 +16,7 @@\n // begin failing.\n \n mod m {\n-    pub fn f() -> Vec<int> { Vec::from_elem(1u, 0i) }\n+    pub fn f() -> Vec<int> { Vec::new() }\n }\n \n pub fn main() { let _x = m::f(); }"}, {"sha": "3596fa1a0063ffb5b31fcdeb2b91a1689730d95d", "filename": "src/test/run-pass/moves-based-on-type-capture-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-capture-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-capture-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-capture-clause.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n \n pub fn main() {\n     let x = \"Hello world!\".to_string();\n-    task::spawn(move|| {\n+    let _t = Thread::spawn(move|| {\n         println!(\"{}\", x);\n     });\n }"}, {"sha": "6b1553cd9f600d924efa784fde15fb7ec8196f8d", "filename": "src/test/run-pass/no-landing-pads.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fno-landing-pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fno-landing-pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fno-landing-pads.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -10,7 +10,7 @@\n \n // compile-flags: -Z no-landing-pads\n \n-use std::task;\n+use std::thread::Thread;\n \n static mut HIT: bool = false;\n \n@@ -23,9 +23,9 @@ impl Drop for A {\n }\n \n fn main() {\n-    task::try(move|| -> () {\n+    Thread::spawn(move|| -> () {\n         let _a = A;\n         panic!();\n-    });\n+    }).join().unwrap_err();\n     assert!(unsafe { !HIT });\n }"}, {"sha": "5c692bf8801815ba5d38c406becc663e77bb5df5", "filename": "src/test/run-pass/panic-in-dtor-drops-fields.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fpanic-in-dtor-drops-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fpanic-in-dtor-drops-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-in-dtor-drops-fields.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n \n static mut dropped: bool = false;\n \n@@ -33,9 +33,9 @@ impl Drop for B {\n }\n \n pub fn main() {\n-    let ret = task::try(move|| {\n+    let ret = Thread::spawn(move|| {\n         let _a = A { b: B { foo: 3 } };\n-    });\n+    }).join();\n     assert!(ret.is_err());\n     unsafe { assert!(dropped); }\n }"}, {"sha": "80ee735be706ecc652d18c852df8f49d17848740", "filename": "src/test/run-pass/realloc-16687.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frealloc-16687.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -17,6 +17,7 @@ extern crate alloc;\n \n use alloc::heap;\n use std::ptr;\n+use std::iter::repeat;\n \n fn main() {\n     unsafe {\n@@ -26,7 +27,7 @@ fn main() {\n \n unsafe fn test_triangle() -> bool {\n     static COUNT : uint = 16;\n-    let mut ascend = Vec::from_elem(COUNT, ptr::null_mut());\n+    let mut ascend = repeat(ptr::null_mut()).take(COUNT).collect::<Vec<_>>();\n     let ascend = ascend.as_mut_slice();\n     static ALIGN : uint = 1;\n "}, {"sha": "fc53737bb445a587e5feee24febe5bb4e823aafe", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -33,9 +33,9 @@ fn start(argc: int, argv: *const *const u8) -> int {\n     }\n \n     let args = unsafe {\n-        Vec::from_fn(argc as uint, |i| {\n+        range(0, argc as uint).map(|i| {\n             String::from_raw_buf(*argv.offset(i as int)).into_bytes()\n-        })\n+        }).collect::<Vec<_>>()\n     };\n     let me = args[0].as_slice();\n "}, {"sha": "a920d76e7ca1b75bc942e2f58e421501036082af", "filename": "src/test/run-pass/send-resource.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-resource.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n use std::sync::mpsc::channel;\n \n struct test {\n@@ -28,7 +28,7 @@ fn test(f: int) -> test {\n pub fn main() {\n     let (tx, rx) = channel();\n \n-    task::spawn(move|| {\n+    let _t = Thread::spawn(move|| {\n         let (tx2, rx2) = channel();\n         tx.send(tx2).unwrap();\n "}, {"sha": "c58654670d1a3f4bb4b90e9956595fb19893df48", "filename": "src/test/run-pass/send_str_hashmap.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -11,8 +11,9 @@\n extern crate collections;\n \n use std::collections::HashMap;\n-use std::str::SendStr;\n-use std::borrow::IntoCow;\n+use std::borrow::{Cow, IntoCow};\n+\n+type SendStr = Cow<'static, String, str>;\n \n pub fn main() {\n     let mut map: HashMap<SendStr, uint> = HashMap::new();"}, {"sha": "438724a2b06bfc97ffa19d8cfe64719c18d1aa4c", "filename": "src/test/run-pass/send_str_treemap.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -11,8 +11,9 @@\n extern crate collections;\n \n use self::collections::BTreeMap;\n-use std::str::SendStr;\n-use std::borrow::IntoCow;\n+use std::borrow::{Cow, IntoCow};\n+\n+type SendStr = Cow<'static, String, str>;\n \n pub fn main() {\n     let mut map: BTreeMap<SendStr, uint> = BTreeMap::new();"}, {"sha": "3ed835dc5bdf9d6907442b65ce701df61c0a448c", "filename": "src/test/run-pass/sendfn-spawn-with-fn-arg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n \n pub fn main() { test05(); }\n \n@@ -22,7 +22,7 @@ fn test05() {\n         println!(\"{}\", *three + n); // will copy x into the closure\n         assert_eq!(*three, 3);\n     };\n-    task::spawn(move|| {\n+    Thread::spawn(move|| {\n         test05_start(fn_to_send);\n-    });\n+    }).join().ok().unwrap();\n }"}, {"sha": "246957a4f46087d62f440207ed06869e9f787af2", "filename": "src/test/run-pass/sepcomp-unwind.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fsepcomp-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fsepcomp-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsepcomp-unwind.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -19,6 +19,8 @@\n // In any case, this test should let us know if enabling parallel codegen ever\n // breaks unwinding.\n \n+use std::thread::Thread;\n+\n fn pad() -> uint { 0 }\n \n mod a {\n@@ -34,5 +36,5 @@ mod b {\n }\n \n fn main() {\n-    std::task::try(move|| { ::b::g() }).unwrap_err();\n+    Thread::spawn(move|| { ::b::g() }).join().unwrap_err();\n }"}, {"sha": "13f2971871ba89ae218b0ae0a25e71da9cf1beb7", "filename": "src/test/run-pass/slice-panic-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fslice-panic-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fslice-panic-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-panic-1.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -12,7 +12,7 @@\n \n #![feature(slicing_syntax)]\n \n-use std::task;\n+use std::thread::Thread;\n \n struct Foo;\n \n@@ -28,6 +28,6 @@ fn foo() {\n }\n \n fn main() {\n-    let _ = task::try(move|| foo());\n+    let _ = Thread::spawn(move|| foo()).join();\n     unsafe { assert!(DTOR_COUNT == 2); }\n }"}, {"sha": "ccbb33d7768c4bff3a30df226d43f4ce87391cf3", "filename": "src/test/run-pass/slice-panic-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fslice-panic-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fslice-panic-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-panic-2.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -12,7 +12,7 @@\n \n #![feature(slicing_syntax)]\n \n-use std::task;\n+use std::thread::Thread;\n \n struct Foo;\n \n@@ -32,6 +32,6 @@ fn foo() {\n }\n \n fn main() {\n-    let _ = task::try(move|| foo());\n+    let _ = Thread::spawn(move|| foo()).join();\n     unsafe { assert!(DTOR_COUNT == 2); }\n }"}, {"sha": "c8fe400c4c3c617bbb4203aac35a6a88c51a4777", "filename": "src/test/run-pass/spawn-fn.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-fn.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,21 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n \n fn x(s: String, n: int) {\n     println!(\"{}\", s);\n     println!(\"{}\", n);\n }\n \n pub fn main() {\n-    task::spawn(move|| x(\"hello from first spawned fn\".to_string(), 65) );\n-    task::spawn(move|| x(\"hello from second spawned fn\".to_string(), 66) );\n-    task::spawn(move|| x(\"hello from third spawned fn\".to_string(), 67) );\n+    let _t = Thread::spawn(|| x(\"hello from first spawned fn\".to_string(), 65) );\n+    let _t = Thread::spawn(|| x(\"hello from second spawned fn\".to_string(), 66) );\n+    let _t = Thread::spawn(|| x(\"hello from third spawned fn\".to_string(), 67) );\n     let mut i: int = 30;\n     while i > 0 {\n         i = i - 1;\n         println!(\"parent sleeping\");\n-        task::deschedule();\n+        Thread::yield_now();\n     }\n }"}, {"sha": "bb9de7cecc98c4fb53b021efea3430ab06b1c33f", "filename": "src/test/run-pass/spawn-types.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-types.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -14,7 +14,7 @@\n   Arnold.\n  */\n \n-use std::task;\n+use std::thread::Thread;\n use std::sync::mpsc::{channel, Sender};\n \n type ctx = Sender<int>;\n@@ -25,5 +25,6 @@ fn iotask(_tx: &ctx, ip: String) {\n \n pub fn main() {\n     let (tx, _rx) = channel::<int>();\n-    task::spawn(move|| iotask(&tx, \"localhost\".to_string()) );\n+    let t = Thread::spawn(move|| iotask(&tx, \"localhost\".to_string()) );\n+    t.join().ok().unwrap();\n }"}, {"sha": "820dd49142ac695ac99588d578d66ba89033af63", "filename": "src/test/run-pass/spawn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n \n pub fn main() {\n-    task::spawn(move|| child(10) );\n+    Thread::spawn(move|| child(10)).join().ok().unwrap();\n }\n \n fn child(i: int) { println!(\"{}\", i); assert!((i == 10)); }"}, {"sha": "50c2d79132ef5dee706a58ee14b362e721e27f8a", "filename": "src/test/run-pass/spawn2.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fspawn2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fspawn2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn2.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,9 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n \n-pub fn main() { task::spawn(move|| child((10, 20, 30, 40, 50, 60, 70, 80, 90)) ); }\n+pub fn main() {\n+    let t = Thread::spawn(move|| child((10, 20, 30, 40, 50, 60, 70, 80, 90)) );\n+    t.join().ok().unwrap();\n+}\n \n fn child(args: (int, int, int, int, int, int, int, int, int)) {\n     let (i1, i2, i3, i4, i5, i6, i7, i8, i9) = args;"}, {"sha": "78826666f53ffc0407aa796ee2c97cd68158c2ad", "filename": "src/test/run-pass/task-comm-0.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n use std::sync::mpsc::{channel, Sender};\n \n pub fn main() { test05(); }\n@@ -24,7 +24,7 @@ fn test05_start(tx : &Sender<int>) {\n \n fn test05() {\n     let (tx, rx) = channel();\n-    task::spawn(move|| { test05_start(&tx) });\n+    let _t = Thread::spawn(move|| { test05_start(&tx) });\n     let mut value: int = rx.recv().unwrap();\n     println!(\"{}\", value);\n     value = rx.recv().unwrap();"}, {"sha": "966bb6aa7358bce2e9f400c7dfe02955577c3d7d", "filename": "src/test/run-pass/task-comm-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n \n pub fn main() { test00(); }\n \n fn start() { println!(\"Started / Finished task.\"); }\n \n fn test00() {\n-    task::try(move|| start() );\n+    let _ = Thread::spawn(move|| start() ).join();\n     println!(\"Completing.\");\n }"}, {"sha": "60af3afec2b3d9b77fcb4ec4cf913752e26289f8", "filename": "src/test/run-pass/task-comm-10.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n use std::sync::mpsc::{channel, Sender};\n \n fn start(tx: &Sender<Sender<String>>) {\n@@ -27,10 +27,10 @@ fn start(tx: &Sender<Sender<String>>) {\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    let _child = task::spawn(move|| { start(&tx) });\n+    let _child = Thread::spawn(move|| { start(&tx) });\n \n     let mut c = rx.recv().unwrap();\n     c.send(\"A\".to_string()).unwrap();\n     c.send(\"B\".to_string()).unwrap();\n-    task::deschedule();\n+    Thread::yield_now();\n }"}, {"sha": "1740c49c7720b347636f95cd6c21b74c42b22c72", "filename": "src/test/run-pass/task-comm-11.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -9,17 +9,17 @@\n // except according to those terms.\n \n use std::sync::mpsc::{channel, Sender};\n-use std::task;\n+use std::thread::Thread;\n \n fn start(tx: &Sender<Sender<int>>) {\n     let (tx2, _rx) = channel();\n-    tx.send(tx2);\n+    tx.send(tx2).unwrap();\n }\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    let _child = task::spawn(move|| {\n+    let _child = Thread::spawn(move|| {\n         start(&tx)\n     });\n-    let _tx = rx.recv();\n+    let _tx = rx.recv().unwrap();\n }"}, {"sha": "50667d375a13c0f53345331709f1dfc2efcd9c8b", "filename": "src/test/run-pass/task-comm-13.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -9,16 +9,16 @@\n // except according to those terms.\n \n use std::sync::mpsc::{channel, Sender};\n-use std::task;\n+use std::thread::Thread;\n \n fn start(tx: &Sender<int>, start: int, number_of_messages: int) {\n     let mut i: int = 0;\n-    while i < number_of_messages { tx.send(start + i); i += 1; }\n+    while i< number_of_messages { tx.send(start + i).unwrap(); i += 1; }\n }\n \n pub fn main() {\n     println!(\"Check that we don't deadlock.\");\n     let (tx, rx) = channel();\n-    task::try(move|| { start(&tx, 0, 10) });\n+    let _ = Thread::spawn(move|| { start(&tx, 0, 10) }).join();\n     println!(\"Joined task\");\n }"}, {"sha": "82e4bd8f6d2a1688b30007e09e85b44c858acc2b", "filename": "src/test/run-pass/task-comm-14.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::sync::mpsc::{channel, Sender};\n-use std::task;\n+use std::thread::Thread;\n \n pub fn main() {\n     let (tx, rx) = channel();\n@@ -19,7 +19,7 @@ pub fn main() {\n     while (i > 0) {\n         println!(\"{}\", i);\n         let tx = tx.clone();\n-        task::spawn({let i = i; move|| { child(i, &tx) }});\n+        Thread::spawn({let i = i; move|| { child(i, &tx) }}).detach();\n         i = i - 1;\n     }\n \n@@ -29,7 +29,7 @@ pub fn main() {\n     i = 10;\n     while (i > 0) {\n         println!(\"{}\", i);\n-        rx.recv();\n+        rx.recv().unwrap();\n         i = i - 1;\n     }\n \n@@ -38,5 +38,5 @@ pub fn main() {\n \n fn child(x: int, tx: &Sender<int>) {\n     println!(\"{}\", x);\n-    tx.send(x);\n+    tx.send(x).unwrap();\n }"}, {"sha": "28eea784f361cac61a813bbc1aa1f3e50175e0ab", "filename": "src/test/run-pass/task-comm-15.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n use std::sync::mpsc::{channel, Sender};\n-use std::task;\n+use std::thread::Thread;\n \n fn start(tx: &Sender<int>, i0: int) {\n     let mut i = i0;\n     while i > 0 {\n-        tx.send(0);\n+        tx.send(0).unwrap();\n         i = i - 1;\n     }\n }\n@@ -25,7 +25,7 @@ pub fn main() {\n     // the child's point of view the receiver may die. We should\n     // drop messages on the floor in this case, and not crash!\n     let (tx, rx) = channel();\n-    task::spawn(move|| {\n+    let _t = Thread::spawn(move|| {\n         start(&tx, 10)\n     });\n     rx.recv();"}, {"sha": "e9f7cdf96a83a4a37a379d61cbf80d2e221fca9b", "filename": "src/test/run-pass/task-comm-17.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -12,11 +12,11 @@\n \n // This test is specifically about spawning temporary closures.\n \n-use std::task;\n+use std::thread::Thread;\n \n fn f() {\n }\n \n pub fn main() {\n-    task::spawn(move|| f() );\n+    let _t = Thread::spawn(move|| f() ).join();\n }"}, {"sha": "6f3b47b8bfa7a607e870496ce87d9636194a43b6", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -11,7 +11,7 @@\n #![allow(dead_assignment)]\n \n use std::sync::mpsc::{channel, Sender};\n-use std::task;\n+use std::thread::Thread;\n \n pub fn main() { test00(); }\n \n@@ -28,19 +28,19 @@ fn test00() {\n     let number_of_messages: int = 10;\n \n     let tx2 = tx.clone();\n-    task::spawn(move|| {\n+    let _t = Thread::spawn(move|| {\n         test00_start(&tx2, number_of_messages * 0, number_of_messages);\n     });\n     let tx2 = tx.clone();\n-    task::spawn(move|| {\n+    let _t = Thread::spawn(move|| {\n         test00_start(&tx2, number_of_messages * 1, number_of_messages);\n     });\n     let tx2 = tx.clone();\n-    task::spawn(move|| {\n+    let _t = Thread::spawn(move|| {\n         test00_start(&tx2, number_of_messages * 2, number_of_messages);\n     });\n     let tx2 = tx.clone();\n-    task::spawn(move|| {\n+    let _t = Thread::spawn(move|| {\n         test00_start(&tx2, number_of_messages * 3, number_of_messages);\n     });\n "}, {"sha": "3f229926480a95ef300ace0bbd599e9eb4d7b339", "filename": "src/test/run-pass/task-life-0.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-life-0.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n \n pub fn main() {\n-    task::spawn(move|| child(\"Hello\".to_string()) );\n+    let _t = Thread::spawn(move|| child(\"Hello\".to_string()) );\n }\n \n fn child(_s: String) {"}, {"sha": "b2bcf395783ae1ec89771e7c3749ed3739673cc8", "filename": "src/test/run-pass/task-spawn-move-and-copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n use std::sync::mpsc::channel;\n \n pub fn main() {\n@@ -17,7 +17,7 @@ pub fn main() {\n     let x = box 1;\n     let x_in_parent = &(*x) as *const int as uint;\n \n-    task::spawn(move || {\n+    let _t = Thread::spawn(move || {\n         let x_in_child = &(*x) as *const int as uint;\n         tx.send(x_in_child).unwrap();\n     });"}, {"sha": "3e6158ca82193e3c6c309e08b35d5d6f12ae0c05", "filename": "src/test/run-pass/tcp-accept-stress.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -13,9 +13,10 @@\n //              quite quickly and it takes a few seconds for the sockets to get\n //              recycled.\n \n-use std::sync::mpsc::channel;\n use std::io::{TcpListener, Listener, Acceptor, EndOfFile, TcpStream};\n-use std::sync::{atomic, Arc};\n+use std::sync::Arc;\n+use std::sync::atomic::{AtomicUint, Ordering};\n+use std::sync::mpsc::channel;\n use std::thread::Thread;\n \n static N: uint = 8;\n@@ -29,7 +30,7 @@ fn test() {\n     let mut l = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n     let addr = l.socket_name().unwrap();\n     let mut a = l.listen().unwrap();\n-    let cnt = Arc::new(atomic::AtomicUint::new(0));\n+    let cnt = Arc::new(AtomicUint::new(0));\n \n     let (srv_tx, srv_rx) = channel();\n     let (cli_tx, cli_rx) = channel();\n@@ -42,7 +43,7 @@ fn test() {\n             loop {\n                 match a.accept() {\n                     Ok(..) => {\n-                        if cnt.fetch_add(1, atomic::SeqCst) == N * M - 1 {\n+                        if cnt.fetch_add(1, Ordering::SeqCst) == N * M - 1 {\n                             break\n                         }\n                     }\n@@ -81,5 +82,5 @@ fn test() {\n     assert_eq!(srv_rx.iter().take(N - 1).count(), N - 1);\n \n     // Everything should have been accepted.\n-    assert_eq!(cnt.load(atomic::SeqCst), N * M);\n+    assert_eq!(cnt.load(Ordering::SeqCst), N * M);\n }"}, {"sha": "6812255d82ca0f4e8c0a8a2f97a257443fcb932c", "filename": "src/test/run-pass/tcp-connect-timeouts.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -27,14 +27,15 @@ use std::io::test::*;\n use std::io;\n use std::time::Duration;\n use std::sync::mpsc::channel;\n+use std::thread::Thread;\n \n #[cfg_attr(target_os = \"freebsd\", ignore)]\n fn eventual_timeout() {\n     let addr = next_test_ip4();\n \n     let (tx1, rx1) = channel();\n     let (_tx2, rx2) = channel::<()>();\n-    std::task::spawn(move|| {\n+    let _t = Thread::spawn(move|| {\n         let _l = TcpListener::bind(addr).unwrap().listen();\n         tx1.send(()).unwrap();\n         let _ = rx2.recv();"}, {"sha": "8fda8a951693f2a67c20428a8f63adfec97babfb", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -22,8 +22,8 @@ use std::io::fs::PathExtensions;\n use std::io::{fs, TempDir};\n use std::io;\n use std::os;\n-use std::task;\n use std::sync::mpsc::channel;\n+use std::thread::Thread;\n \n fn test_tempdir() {\n     let path = {\n@@ -42,7 +42,7 @@ fn test_rm_tempdir() {\n         tx.send(tmp.path().clone()).unwrap();\n         panic!(\"panic to unwind past `tmp`\");\n     };\n-    task::try(f);\n+    let _ = Thread::spawn(f).join();\n     let path = rx.recv().unwrap();\n     assert!(!path.exists());\n \n@@ -52,15 +52,15 @@ fn test_rm_tempdir() {\n         let _tmp = tmp;\n         panic!(\"panic to unwind past `tmp`\");\n     };\n-    task::try(f);\n+    let _ = Thread::spawn(f).join();\n     assert!(!path.exists());\n \n     let path;\n     {\n         let f = move|:| {\n             TempDir::new(\"test_rm_tempdir\").unwrap()\n         };\n-        let tmp = task::try(f).ok().expect(\"test_rm_tmdir\");\n+        let tmp = Thread::spawn(f).join().ok().expect(\"test_rm_tmdir\");\n         path = tmp.path().clone();\n         assert!(path.exists());\n     }\n@@ -69,7 +69,7 @@ fn test_rm_tempdir() {\n     let path;\n     {\n         let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n-        path = tmp.unwrap();\n+        path = tmp.into_inner();\n     }\n     assert!(path.exists());\n     fs::rmdir_recursive(&path);\n@@ -84,7 +84,7 @@ fn test_rm_tempdir_close() {\n         tmp.close();\n         panic!(\"panic when unwinding past `tmp`\");\n     };\n-    task::try(f);\n+    let _ = Thread::spawn(f).join();\n     let path = rx.recv().unwrap();\n     assert!(!path.exists());\n \n@@ -95,15 +95,15 @@ fn test_rm_tempdir_close() {\n         tmp.close();\n         panic!(\"panic when unwinding past `tmp`\");\n     };\n-    task::try(f);\n+    let _ = Thread::spawn(f).join();\n     assert!(!path.exists());\n \n     let path;\n     {\n         let f = move|:| {\n             TempDir::new(\"test_rm_tempdir\").unwrap()\n         };\n-        let tmp = task::try(f).ok().expect(\"test_rm_tmdir\");\n+        let tmp = Thread::spawn(f).join().ok().expect(\"test_rm_tmdir\");\n         path = tmp.path().clone();\n         assert!(path.exists());\n         tmp.close();\n@@ -113,7 +113,7 @@ fn test_rm_tempdir_close() {\n     let path;\n     {\n         let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n-        path = tmp.unwrap();\n+        path = tmp.into_inner();\n     }\n     assert!(path.exists());\n     fs::rmdir_recursive(&path);\n@@ -177,15 +177,15 @@ pub fn test_rmdir_recursive_ok() {\n }\n \n pub fn dont_double_panic() {\n-    let r: Result<(), _> = task::try(move|| {\n+    let r: Result<(), _> = Thread::spawn(move|| {\n         let tmpdir = TempDir::new(\"test\").unwrap();\n         // Remove the temporary directory so that TempDir sees\n         // an error on drop\n         fs::rmdir(tmpdir.path());\n         // Panic. If TempDir panics *again* due to the rmdir\n         // error then the process will abort.\n         panic!();\n-    });\n+    }).join();\n     assert!(r.is_err());\n }\n "}, {"sha": "4270ecc7450921713404b199c210dcccfdcc3da4", "filename": "src/test/run-pass/terminate-in-initializer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fterminate-in-initializer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fterminate-in-initializer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fterminate-in-initializer.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -12,7 +12,7 @@\n // Issue #787\n // Don't try to clean up uninitialized locals\n \n-use std::task;\n+use std::thread::Thread;\n \n fn test_break() { loop { let _x: Box<int> = break; } }\n \n@@ -22,13 +22,13 @@ fn test_ret() { let _x: Box<int> = return; }\n \n fn test_panic() {\n     fn f() { let _x: Box<int> = panic!(); }\n-    task::try(move|| f() );\n+    Thread::spawn(move|| f() ).join().err().unwrap();\n }\n \n fn test_panic_indirect() {\n     fn f() -> ! { panic!(); }\n     fn g() { let _x: Box<int> = f(); }\n-    task::try(move|| g() );\n+    Thread::spawn(move|| g() ).join().err().unwrap();\n }\n \n pub fn main() {"}, {"sha": "02817a285ddf5bbd007d4105747ea72d74163dcf", "filename": "src/test/run-pass/threads.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthreads.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,11 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n \n pub fn main() {\n     let mut i = 10;\n-    while i > 0 { task::spawn({let i = i; move|| child(i)}); i = i - 1; }\n+    while i > 0 {\n+        Thread::spawn({let i = i; move|| child(i)}).detach();\n+        i = i - 1;\n+    }\n     println!(\"main thread exiting\");\n }\n "}, {"sha": "c8abfcaa721de9b72f388602a569b7e4aab85b5d", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -13,7 +13,7 @@\n \n use std::sync::Arc;\n use std::sync::mpsc::channel;\n-use std::task;\n+use std::thread::Thread;\n \n trait Pet {\n     fn name(&self, blk: |&str|);\n@@ -77,13 +77,13 @@ pub fn main() {\n                             box dogge2 as Box<Pet+Sync+Send>));\n     let (tx1, rx1) = channel();\n     let arc1 = arc.clone();\n-    task::spawn(move|| { check_legs(arc1); tx1.send(()); });\n+    let _t1 = Thread::spawn(move|| { check_legs(arc1); tx1.send(()); });\n     let (tx2, rx2) = channel();\n     let arc2 = arc.clone();\n-    task::spawn(move|| { check_names(arc2); tx2.send(()); });\n+    let _t2 = Thread::spawn(move|| { check_names(arc2); tx2.send(()); });\n     let (tx3, rx3) = channel();\n     let arc3 = arc.clone();\n-    task::spawn(move|| { check_pedigree(arc3); tx3.send(()); });\n+    let _t3 = Thread::spawn(move|| { check_pedigree(arc3); tx3.send(()); });\n     rx1.recv();\n     rx2.recv();\n     rx3.recv();"}, {"sha": "bd4143348b8867660d7af9c27fb86eb0e3d4cbfa", "filename": "src/test/run-pass/unique-send-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send-2.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n use std::sync::mpsc::{channel, Sender};\n+use std::thread::Thread;\n \n fn child(tx: &Sender<Box<uint>>, i: uint) {\n     tx.send(box i).unwrap();\n@@ -21,9 +21,9 @@ pub fn main() {\n     let mut expected = 0u;\n     for i in range(0u, n) {\n         let tx = tx.clone();\n-        task::spawn(move|| {\n+        Thread::spawn(move|| {\n             child(&tx, i)\n-        });\n+        }).detach();\n         expected += i;\n     }\n "}, {"sha": "9aeb5b10cf5f8d40b9b4c88639d48524fde69e6f", "filename": "src/test/run-pass/unit-like-struct-drop-run.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -11,7 +11,7 @@\n // Make sure the destructor is run for unit-like structs.\n \n use std::boxed::BoxAny;\n-use std::task;\n+use std::thread::Thread;\n \n struct Foo;\n \n@@ -22,9 +22,9 @@ impl Drop for Foo {\n }\n \n pub fn main() {\n-    let x = task::try(move|| {\n+    let x = Thread::spawn(move|| {\n         let _b = Foo;\n-    });\n+    }).join();\n \n     let s = x.unwrap_err().downcast::<&'static str>().unwrap();\n     assert_eq!(s.as_slice(), \"This panic should happen.\");"}, {"sha": "3f59b2c6c7641279e7e6b6bde4ec12f16baa6fcc", "filename": "src/test/run-pass/unwind-resource.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::sync::mpsc::{channel, Sender};\n-use std::task;\n+use std::thread::Thread;\n \n struct complainer {\n     tx: Sender<bool>,\n@@ -37,7 +37,7 @@ fn f(tx: Sender<bool>) {\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    task::spawn(move|| f(tx.clone()));\n+    let _t = Thread::spawn(move|| f(tx.clone()));\n     println!(\"hiiiiiiiii\");\n     assert!(rx.recv().unwrap());\n }"}, {"sha": "554a08ea64460a5107a7d7ffa1f8bbd75f7427c6", "filename": "src/test/run-pass/unwind-unique.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Funwind-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Funwind-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-unique.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n \n fn f() {\n     let _a = box 0i;\n     panic!();\n }\n \n pub fn main() {\n-    task::spawn(f);\n+    let _t = Thread::spawn(f);\n }"}, {"sha": "1b2aa88cabe53a0601e0a19f7953b5ac0b3ff311", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -15,29 +15,29 @@ use std::str;\n pub fn main() {\n     // Chars of 1, 2, 3, and 4 bytes\n     let chs: Vec<char> = vec!('e', '\u00e9', '\u20ac', '\\U00010000');\n-    let s: String = String::from_chars(chs.as_slice()).to_string();\n-    let schs: Vec<char> = s.as_slice().chars().collect();\n+    let s: String = chs.iter().cloned().collect();\n+    let schs: Vec<char> = s.chars().collect();\n \n     assert!(s.len() == 10u);\n-    assert!(s.as_slice().char_len() == 4u);\n+    assert!(s.chars().count() == 4u);\n     assert!(schs.len() == 4u);\n-    assert!(String::from_chars(schs.as_slice()) == s);\n-    assert!(s.as_slice().char_at(0u) == 'e');\n-    assert!(s.as_slice().char_at(1u) == '\u00e9');\n+    assert!(schs.iter().cloned().collect::<String>() == s);\n+    assert!(s.char_at(0u) == 'e');\n+    assert!(s.char_at(1u) == '\u00e9');\n \n-    assert!((str::is_utf8(s.as_bytes())));\n+    assert!((str::from_utf8(s.as_bytes()).is_ok()));\n     // invalid prefix\n-    assert!((!str::is_utf8(&[0x80_u8])));\n+    assert!((!str::from_utf8(&[0x80_u8]).is_ok()));\n     // invalid 2 byte prefix\n-    assert!((!str::is_utf8(&[0xc0_u8])));\n-    assert!((!str::is_utf8(&[0xc0_u8, 0x10_u8])));\n+    assert!((!str::from_utf8(&[0xc0_u8]).is_ok()));\n+    assert!((!str::from_utf8(&[0xc0_u8, 0x10_u8]).is_ok()));\n     // invalid 3 byte prefix\n-    assert!((!str::is_utf8(&[0xe0_u8])));\n-    assert!((!str::is_utf8(&[0xe0_u8, 0x10_u8])));\n-    assert!((!str::is_utf8(&[0xe0_u8, 0xff_u8, 0x10_u8])));\n+    assert!((!str::from_utf8(&[0xe0_u8]).is_ok()));\n+    assert!((!str::from_utf8(&[0xe0_u8, 0x10_u8]).is_ok()));\n+    assert!((!str::from_utf8(&[0xe0_u8, 0xff_u8, 0x10_u8]).is_ok()));\n     // invalid 4 byte prefix\n-    assert!((!str::is_utf8(&[0xf0_u8])));\n-    assert!((!str::is_utf8(&[0xf0_u8, 0x10_u8])));\n-    assert!((!str::is_utf8(&[0xf0_u8, 0xff_u8, 0x10_u8])));\n-    assert!((!str::is_utf8(&[0xf0_u8, 0xff_u8, 0xff_u8, 0x10_u8])));\n+    assert!((!str::from_utf8(&[0xf0_u8]).is_ok()));\n+    assert!((!str::from_utf8(&[0xf0_u8, 0x10_u8]).is_ok()));\n+    assert!((!str::from_utf8(&[0xf0_u8, 0xff_u8, 0x10_u8]).is_ok()));\n+    assert!((!str::from_utf8(&[0xf0_u8, 0xff_u8, 0xff_u8, 0x10_u8]).is_ok()));\n }"}, {"sha": "bdd62995e0a31c5dd2cb58a9fd2951ec17e51fa9", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n-use std::sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Relaxed};\n+use std::sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n use std::rand::{thread_rng, Rng, Rand};\n+use std::thread::Thread;\n \n const REPEATS: uint = 5;\n const MAX_LEN: uint = 32;\n@@ -36,7 +36,7 @@ struct DropCounter { x: uint, creation_id: uint }\n impl Rand for DropCounter {\n     fn rand<R: Rng>(rng: &mut R) -> DropCounter {\n         // (we're not using this concurrently, so Relaxed is fine.)\n-        let num = creation_count.fetch_add(1, Relaxed);\n+        let num = creation_count.fetch_add(1, Ordering::Relaxed);\n         DropCounter {\n             x: rng.gen(),\n             creation_id: num\n@@ -46,7 +46,7 @@ impl Rand for DropCounter {\n \n impl Drop for DropCounter {\n     fn drop(&mut self) {\n-        drop_counts[self.creation_id].fetch_add(1, Relaxed);\n+        drop_counts[self.creation_id].fetch_add(1, Ordering::Relaxed);\n     }\n }\n \n@@ -57,7 +57,7 @@ pub fn main() {\n         for _ in range(0, REPEATS) {\n             // reset the count for these new DropCounters, so their\n             // IDs start from 0.\n-            creation_count.store(0, Relaxed);\n+            creation_count.store(0, Ordering::Relaxed);\n \n             let main = thread_rng().gen_iter::<DropCounter>()\n                                  .take(len)\n@@ -72,27 +72,27 @@ pub fn main() {\n             for panic_countdown in range(0i, count) {\n                 // refresh the counters.\n                 for c in drop_counts.iter() {\n-                    c.store(0, Relaxed);\n+                    c.store(0, Ordering::Relaxed);\n                 }\n \n                 let v = main.clone();\n \n-                let _ = task::try(move|| {\n-                        let mut v = v;\n-                        let mut panic_countdown = panic_countdown;\n-                        v.as_mut_slice().sort_by(|a, b| {\n-                                if panic_countdown == 0 {\n-                                    panic!()\n-                                }\n-                                panic_countdown -= 1;\n-                                a.cmp(b)\n-                            })\n-                    });\n+                let _ = Thread::spawn(move|| {\n+                    let mut v = v;\n+                    let mut panic_countdown = panic_countdown;\n+                    v.as_mut_slice().sort_by(|a, b| {\n+                        if panic_countdown == 0 {\n+                            panic!()\n+                        }\n+                        panic_countdown -= 1;\n+                        a.cmp(b)\n+                    })\n+                }).join();\n \n                 // check that the number of things dropped is exactly\n                 // what we expect (i.e. the contents of `v`).\n                 for (i, c) in drop_counts.iter().enumerate().take(len) {\n-                    let count = c.load(Relaxed);\n+                    let count = c.load(Ordering::Relaxed);\n                     assert!(count == 1,\n                             \"found drop count == {} for i == {}, len == {}\",\n                             count, i, len);"}, {"sha": "eb7205b5e0a83f4b6ccdfc4e48cbc0dbed082b8f", "filename": "src/test/run-pass/wait-forked-but-failed-child.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -11,8 +11,6 @@\n extern crate libc;\n \n use std::io::process::Command;\n-use std::iter::IteratorExt;\n-use std::str::from_str;\n \n use libc::funcs::posix88::unistd;\n \n@@ -41,9 +39,10 @@ fn find_zombies() {\n \n     for (line_no, line) in ps_output.split('\\n').enumerate() {\n         if 0 < line_no && 0 < line.len() &&\n-           my_pid == from_str(line.split(' ').filter(|w| 0 < w.len()).nth(1)\n-               .expect(\"1st column should be PPID\")\n-               ).expect(\"PPID string into integer\") &&\n+           my_pid == line.split(' ').filter(|w| 0 < w.len()).nth(1)\n+                         .expect(\"1st column should be PPID\")\n+                         .parse()\n+                         .expect(\"PPID string into integer\") &&\n            line.contains(\"defunct\") {\n             panic!(\"Zombie child {}\", line);\n         }\n@@ -56,12 +55,12 @@ fn find_zombies() { }\n fn main() {\n     let too_long = format!(\"/NoSuchCommand{:0300}\", 0u8);\n \n-    let _failures = Vec::from_fn(100, |_i| {\n+    let _failures = range(0, 100).map(|_| {\n         let cmd = Command::new(too_long.as_slice());\n         let failed = cmd.spawn();\n         assert!(failed.is_err(), \"Make sure the command fails to spawn(): {}\", cmd);\n         failed\n-    });\n+    }).collect::<Vec<_>>();\n \n     find_zombies();\n     // then _failures goes out of scope"}, {"sha": "08dac5c7c82da904382e5ce5bfac3e94efa87c4d", "filename": "src/test/run-pass/weak-lang-item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fweak-lang-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fweak-lang-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fweak-lang-item.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -12,10 +12,10 @@\n \n extern crate \"weak-lang-items\" as other;\n \n-use std::task;\n+use std::thread::Thread;\n \n fn main() {\n-    let _ = task::try(move|| {\n+    let _ = Thread::spawn(move|| {\n         other::foo()\n     });\n }"}, {"sha": "66ad7de0296b1e03ea6f2f8475d0b4c9da955d88", "filename": "src/test/run-pass/yield2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fyield2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3d1157246a13a7830431ce0253368029c8ee3e/src%2Ftest%2Frun-pass%2Fyield2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield2.rs?ref=7e3d1157246a13a7830431ce0253368029c8ee3e", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n+use std::thread::Thread;\n \n pub fn main() {\n     let mut i: int = 0;\n-    while i < 100 { i = i + 1; println!(\"{}\", i); task::deschedule(); }\n+    while i < 100 { i = i + 1; println!(\"{}\", i); Thread::yield_now(); }\n }"}]}