{"sha": "f34909d68f1410c89e3a97bdee04d7e6e7cfbe5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzNDkwOWQ2OGYxNDEwYzg5ZTNhOTdiZGVlMDRkN2U2ZTdjZmJlNWU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2021-08-27T20:30:45Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2021-08-27T20:30:45Z"}, "message": "simplify the logic and document", "tree": {"sha": "05fefee612c1223f1a52c80f48c05c9e24e82ec9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05fefee612c1223f1a52c80f48c05c9e24e82ec9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f34909d68f1410c89e3a97bdee04d7e6e7cfbe5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f34909d68f1410c89e3a97bdee04d7e6e7cfbe5e", "html_url": "https://github.com/rust-lang/rust/commit/f34909d68f1410c89e3a97bdee04d7e6e7cfbe5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f34909d68f1410c89e3a97bdee04d7e6e7cfbe5e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "110a9b3b1ca1fddd34a3ecb8ec47fd8bb5ca7424", "url": "https://api.github.com/repos/rust-lang/rust/commits/110a9b3b1ca1fddd34a3ecb8ec47fd8bb5ca7424", "html_url": "https://github.com/rust-lang/rust/commit/110a9b3b1ca1fddd34a3ecb8ec47fd8bb5ca7424"}], "stats": {"total": 68, "additions": 32, "deletions": 36}, "files": [{"sha": "d999c17b579bb353b1b5b9d7b66df909b0742fe5", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 32, "deletions": 36, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f34909d68f1410c89e3a97bdee04d7e6e7cfbe5e/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34909d68f1410c89e3a97bdee04d7e6e7cfbe5e/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=f34909d68f1410c89e3a97bdee04d7e6e7cfbe5e", "patch": "@@ -2,6 +2,7 @@\n //! normal visitor, which just walks the entire body in one shot, the\n //! `ExprUseVisitor` determines how expressions are being used.\n \n+use hir::def::DefKind;\n // Export these here so that Clippy can use them.\n pub use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, Projection};\n \n@@ -14,7 +15,7 @@ use rustc_index::vec::Idx;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::hir::place::ProjectionKind;\n use rustc_middle::mir::FakeReadCause;\n-use rustc_middle::ty::{self, adjustment, TyCtxt};\n+use rustc_middle::ty::{self, adjustment, Ty, TyCtxt};\n use rustc_target::abi::VariantIdx;\n use std::iter;\n \n@@ -251,43 +252,34 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                                     needs_to_be_read = true;\n                                 }\n                             }\n-                            PatKind::TupleStruct(..)\n-                            | PatKind::Path(..)\n-                            | PatKind::Struct(..)\n-                            | PatKind::Tuple(..) => {\n-                                // If the PatKind is a TupleStruct, Path, Struct or Tuple then we want to check\n-                                // whether the Variant is a MultiVariant or a SingleVariant. We only want\n-                                // to borrow discr if it is a MultiVariant.\n-                                // If it is a SingleVariant and creates a binding we will handle that when\n-                                // this callback gets called again.\n-\n-                                // Get the type of the Place after all projections have been applied\n-                                let place_ty = place.place.ty();\n-\n-                                if let ty::Adt(def, _) = place_ty.kind() {\n-                                    if def.variants.len() > 1 {\n+                            PatKind::Path(qpath) => {\n+                                // A `Path` pattern is just a name like `Foo`. This is either a\n+                                // named constant or else it refers to an ADT variant\n+\n+                                let res = self.mc.typeck_results.qpath_res(qpath, pat.hir_id);\n+                                match res {\n+                                    Res::Def(DefKind::Const, _)\n+                                    | Res::Def(DefKind::AssocConst, _) => {\n+                                        // Named constants have to be equated with the value\n+                                        // being matched, so that's a read of the value being matched.\n                                         needs_to_be_read = true;\n-                                    } else if let Some(variant) = def.variants.iter().next() {\n-                                        // We need to handle `const` in match arms slightly differently\n-                                        // as they are not processed the same way as other match arms.\n-                                        // Consider this const `const OP1: Opcode = Opcode(0x1)`, this\n-                                        // will generate a pattern with kind Path while if use Opcode(0x1)\n-                                        // this will generate pattern TupleStruct and Lit.\n-                                        // When dealing with pat kind Path we need to make additional checks\n-                                        // to ensure we have all the info needed to make a decision on whether\n-                                        // to borrow discr.\n-                                        //\n-                                        // If the pat kind is a Path we want to check whether the\n-                                        // variant contains at least one field. If that's the case,\n-                                        // we want to borrow discr.\n-                                        if matches!(pat.kind, PatKind::Path(..))\n-                                            && variant.fields.len() > 0\n-                                        {\n-                                            needs_to_be_read = true;\n-                                        }\n                                     }\n-                                } else {\n-                                    // If it is not ty::Adt, then it should be read\n+                                    _ => {\n+                                        // Otherwise, this is a struct/enum variant, and so it's\n+                                        // only a read if we need to read the discriminant.\n+                                        needs_to_be_read = is_multivariant_adt(place.place.ty());\n+                                    }\n+                                }\n+                            }\n+                            PatKind::TupleStruct(..) | PatKind::Struct(..) | PatKind::Tuple(..) => {\n+                                // For `Foo(..)`, `Foo { ... }` and `(...)` patterns, check if we are matching\n+                                // against a multivariant enum or struct. In that case, we have to read\n+                                // the discriminant. Otherwise this kind of pattern doesn't actually\n+                                // read anything (we'll get invoked for the `...`, which may indeed\n+                                // perform some reads).\n+\n+                                let place_ty = place.place.ty();\n+                                if is_multivariant_adt(place_ty) {\n                                     needs_to_be_read = true;\n                                 }\n                             }\n@@ -854,3 +846,7 @@ fn delegate_consume<'a, 'tcx>(\n         }\n     }\n }\n+\n+fn is_multivariant_adt(ty: Ty<'tcx>) -> bool {\n+    if let ty::Adt(def, _) = ty.kind() { def.variants.len() > 1 } else { false }\n+}"}]}