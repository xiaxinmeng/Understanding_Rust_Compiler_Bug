{"sha": "80fe0bb76e601054398eb3c4763a6e9125d8101c", "node_id": "C_kwDOAAsO6NoAKDgwZmUwYmI3NmU2MDEwNTQzOThlYjNjNDc2M2E2ZTkxMjVkODEwMWM", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2021-10-05T14:20:43Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2021-10-15T08:58:18Z"}, "message": "add a `rustc::query_stability` lint", "tree": {"sha": "b11b709e8ccff3595a889a05818f61c17d8abfa0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b11b709e8ccff3595a889a05818f61c17d8abfa0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80fe0bb76e601054398eb3c4763a6e9125d8101c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80fe0bb76e601054398eb3c4763a6e9125d8101c", "html_url": "https://github.com/rust-lang/rust/commit/80fe0bb76e601054398eb3c4763a6e9125d8101c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80fe0bb76e601054398eb3c4763a6e9125d8101c/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f7915347dce231e0adc3cd8b95c1d6d977cab6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f7915347dce231e0adc3cd8b95c1d6d977cab6b", "html_url": "https://github.com/rust-lang/rust/commit/7f7915347dce231e0adc3cd8b95c1d6d977cab6b"}], "stats": {"total": 311, "additions": 246, "deletions": 65}, "files": [{"sha": "8e91c651a31104bf58873d55667e4fe5dd76b0d8", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/80fe0bb76e601054398eb3c4763a6e9125d8101c/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80fe0bb76e601054398eb3c4763a6e9125d8101c/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=80fe0bb76e601054398eb3c4763a6e9125d8101c", "patch": "@@ -460,6 +460,9 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // Prevents field reads in the marked trait or method to be considered\n     // during dead code analysis.\n     rustc_attr!(rustc_trivial_field_reads, Normal, template!(Word), INTERNAL_UNSTABLE),\n+    // Used by the `rustc::potential_query_instability` lint to warn methods which\n+    // might not be stable during incremental compilation.\n+    rustc_attr!(rustc_lint_query_instability, Normal, template!(Word), INTERNAL_UNSTABLE),\n \n     // ==========================================================================\n     // Internal attributes, Const related:"}, {"sha": "93823aca8ec24a3fb1bfe62aeba1751fa308263c", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/80fe0bb76e601054398eb3c4763a6e9125d8101c/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80fe0bb76e601054398eb3c4763a6e9125d8101c/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=80fe0bb76e601054398eb3c4763a6e9125d8101c", "patch": "@@ -5,10 +5,7 @@ use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext}\n use rustc_ast as ast;\n use rustc_errors::Applicability;\n use rustc_hir::def::Res;\n-use rustc_hir::{\n-    GenericArg, HirId, Item, ItemKind, MutTy, Mutability, Node, Path, PathSegment, QPath, Ty,\n-    TyKind,\n-};\n+use rustc_hir::*;\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n@@ -51,6 +48,45 @@ impl LateLintPass<'_> for DefaultHashTypes {\n     }\n }\n \n+declare_tool_lint! {\n+    pub rustc::POTENTIAL_QUERY_INSTABILITY,\n+    Allow,\n+    \"require explicit opt-in when using potentially unstable methods or functions\",\n+    report_in_external_macro: true\n+}\n+\n+declare_lint_pass!(QueryStability => [POTENTIAL_QUERY_INSTABILITY]);\n+\n+impl LateLintPass<'_> for QueryStability {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        let (def_id, span) = match expr.kind {\n+            ExprKind::Path(ref path) if let Some(def_id) = cx.qpath_res(path, expr.hir_id).opt_def_id() => {\n+                (def_id, expr.span)\n+            }\n+            ExprKind::MethodCall(_, span, _, _) if let Some(def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id) => {\n+                (def_id, span)\n+            },\n+            _ => return,\n+        };\n+\n+        let substs = cx.typeck_results().node_substs(expr.hir_id);\n+        if let Ok(Some(instance)) = ty::Instance::resolve(cx.tcx, cx.param_env, def_id, substs) {\n+            let def_id = instance.def_id();\n+            if cx.tcx.has_attr(def_id, sym::rustc_lint_query_instability) {\n+                cx.struct_span_lint(POTENTIAL_QUERY_INSTABILITY, span, |lint| {\n+                    let msg = format!(\n+                        \"using `{}` can result in unstable query results\",\n+                        cx.tcx.item_name(def_id)\n+                    );\n+                    lint.build(&msg)\n+                        .note(\"if you believe this case to be fine, allow this lint and add a comment explaining your rationale\")\n+                        .emit();\n+                })\n+            }\n+        }\n+    }\n+}\n+\n declare_tool_lint! {\n     pub rustc::USAGE_OF_TY_TYKIND,\n     Allow,"}, {"sha": "7a3d99068012f990716d4f776f323a611f903250", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80fe0bb76e601054398eb3c4763a6e9125d8101c/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80fe0bb76e601054398eb3c4763a6e9125d8101c/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=80fe0bb76e601054398eb3c4763a6e9125d8101c", "patch": "@@ -31,6 +31,7 @@\n #![feature(box_patterns)]\n #![feature(crate_visibility_modifier)]\n #![feature(format_args_capture)]\n+#![feature(if_let_guard)]\n #![feature(iter_order_by)]\n #![feature(iter_zip)]\n #![feature(never_type)]\n@@ -484,6 +485,8 @@ fn register_internals(store: &mut LintStore) {\n     store.register_early_pass(|| Box::new(LintPassImpl));\n     store.register_lints(&DefaultHashTypes::get_lints());\n     store.register_late_pass(|| Box::new(DefaultHashTypes));\n+    store.register_lints(&QueryStability::get_lints());\n+    store.register_late_pass(|| Box::new(QueryStability));\n     store.register_lints(&ExistingDocKeyword::get_lints());\n     store.register_late_pass(|| Box::new(ExistingDocKeyword));\n     store.register_lints(&TyTyKind::get_lints());\n@@ -494,6 +497,7 @@ fn register_internals(store: &mut LintStore) {\n         None,\n         vec![\n             LintId::of(DEFAULT_HASH_TYPES),\n+            LintId::of(POTENTIAL_QUERY_INSTABILITY),\n             LintId::of(USAGE_OF_TY_TYKIND),\n             LintId::of(LINT_PASS_IMPL_WITHOUT_MACRO),\n             LintId::of(TY_PASS_BY_REFERENCE),"}, {"sha": "92d9e89c3a383ed10a4f21413240db53bd1771cb", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 83, "deletions": 61, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/80fe0bb76e601054398eb3c4763a6e9125d8101c/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80fe0bb76e601054398eb3c4763a6e9125d8101c/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=80fe0bb76e601054398eb3c4763a6e9125d8101c", "patch": "@@ -62,7 +62,7 @@ impl CheckAttrVisitor<'tcx> {\n     fn check_attributes(\n         &self,\n         hir_id: HirId,\n-        span: &Span,\n+        span: Span,\n         target: Target,\n         item: Option<ItemLike<'_>>,\n     ) {\n@@ -78,7 +78,7 @@ impl CheckAttrVisitor<'tcx> {\n                 sym::marker => self.check_marker(hir_id, attr, span, target),\n                 sym::target_feature => self.check_target_feature(hir_id, attr, span, target),\n                 sym::track_caller => {\n-                    self.check_track_caller(hir_id, &attr.span, attrs, span, target)\n+                    self.check_track_caller(hir_id, attr.span, attrs, span, target)\n                 }\n                 sym::doc => self.check_doc_attrs(\n                     attr,\n@@ -103,6 +103,9 @@ impl CheckAttrVisitor<'tcx> {\n                 sym::rustc_legacy_const_generics => {\n                     self.check_rustc_legacy_const_generics(&attr, span, target, item)\n                 }\n+                sym::rustc_lint_query_instability => {\n+                    self.check_rustc_lint_query_instability(&attr, span, target)\n+                }\n                 sym::rustc_clean\n                 | sym::rustc_dirty\n                 | sym::rustc_if_this_changed\n@@ -230,7 +233,7 @@ impl CheckAttrVisitor<'tcx> {\n     }\n \n     /// Checks if an `#[inline]` is applied to a function or a closure. Returns `true` if valid.\n-    fn check_inline(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) -> bool {\n+    fn check_inline(&self, hir_id: HirId, attr: &Attribute, span: Span, target: Target) -> bool {\n         match target {\n             Target::Fn\n             | Target::Closure\n@@ -273,7 +276,7 @@ impl CheckAttrVisitor<'tcx> {\n                     E0518,\n                     \"attribute should be applied to function or closure\",\n                 )\n-                .span_label(*span, \"not a function or closure\")\n+                .span_label(span, \"not a function or closure\")\n                 .emit();\n                 false\n             }\n@@ -312,7 +315,7 @@ impl CheckAttrVisitor<'tcx> {\n     }\n \n     /// Checks if `#[naked]` is applied to a function definition.\n-    fn check_naked(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) -> bool {\n+    fn check_naked(&self, hir_id: HirId, attr: &Attribute, span: Span, target: Target) -> bool {\n         match target {\n             Target::Fn\n             | Target::Method(MethodKind::Trait { body: true } | MethodKind::Inherent) => true,\n@@ -331,15 +334,15 @@ impl CheckAttrVisitor<'tcx> {\n                         attr.span,\n                         \"attribute should be applied to a function definition\",\n                     )\n-                    .span_label(*span, \"not a function definition\")\n+                    .span_label(span, \"not a function definition\")\n                     .emit();\n                 false\n             }\n         }\n     }\n \n     /// Checks if `#[cmse_nonsecure_entry]` is applied to a function definition.\n-    fn check_cmse_nonsecure_entry(&self, attr: &Attribute, span: &Span, target: Target) -> bool {\n+    fn check_cmse_nonsecure_entry(&self, attr: &Attribute, span: Span, target: Target) -> bool {\n         match target {\n             Target::Fn\n             | Target::Method(MethodKind::Trait { body: true } | MethodKind::Inherent) => true,\n@@ -350,7 +353,7 @@ impl CheckAttrVisitor<'tcx> {\n                         attr.span,\n                         \"attribute should be applied to a function definition\",\n                     )\n-                    .span_label(*span, \"not a function definition\")\n+                    .span_label(span, \"not a function definition\")\n                     .emit();\n                 false\n             }\n@@ -361,16 +364,16 @@ impl CheckAttrVisitor<'tcx> {\n     fn check_track_caller(\n         &self,\n         hir_id: HirId,\n-        attr_span: &Span,\n+        attr_span: Span,\n         attrs: &'hir [Attribute],\n-        span: &Span,\n+        span: Span,\n         target: Target,\n     ) -> bool {\n         match target {\n             _ if attrs.iter().any(|attr| attr.has_name(sym::naked)) => {\n                 struct_span_err!(\n                     self.tcx.sess,\n-                    *attr_span,\n+                    attr_span,\n                     E0736,\n                     \"cannot use `#[track_caller]` with `#[naked]`\",\n                 )\n@@ -391,11 +394,11 @@ impl CheckAttrVisitor<'tcx> {\n             _ => {\n                 struct_span_err!(\n                     self.tcx.sess,\n-                    *attr_span,\n+                    attr_span,\n                     E0739,\n                     \"attribute should be applied to function\"\n                 )\n-                .span_label(*span, \"not a function\")\n+                .span_label(span, \"not a function\")\n                 .emit();\n                 false\n             }\n@@ -407,7 +410,7 @@ impl CheckAttrVisitor<'tcx> {\n         &self,\n         hir_id: HirId,\n         attr: &Attribute,\n-        span: &Span,\n+        span: Span,\n         target: Target,\n     ) -> bool {\n         match target {\n@@ -427,15 +430,15 @@ impl CheckAttrVisitor<'tcx> {\n                     E0701,\n                     \"attribute can only be applied to a struct or enum\"\n                 )\n-                .span_label(*span, \"not a struct or enum\")\n+                .span_label(span, \"not a struct or enum\")\n                 .emit();\n                 false\n             }\n         }\n     }\n \n     /// Checks if the `#[marker]` attribute on an `item` is valid. Returns `true` if valid.\n-    fn check_marker(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) -> bool {\n+    fn check_marker(&self, hir_id: HirId, attr: &Attribute, span: Span, target: Target) -> bool {\n         match target {\n             Target::Trait => true,\n             // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n@@ -450,7 +453,7 @@ impl CheckAttrVisitor<'tcx> {\n                 self.tcx\n                     .sess\n                     .struct_span_err(attr.span, \"attribute can only be applied to a trait\")\n-                    .span_label(*span, \"not a trait\")\n+                    .span_label(span, \"not a trait\")\n                     .emit();\n                 false\n             }\n@@ -462,7 +465,7 @@ impl CheckAttrVisitor<'tcx> {\n         &self,\n         hir_id: HirId,\n         attr: &Attribute,\n-        span: &Span,\n+        span: Span,\n         target: Target,\n     ) -> bool {\n         match target {\n@@ -478,7 +481,7 @@ impl CheckAttrVisitor<'tcx> {\n                              being phased out; it will become a hard error in \\\n                              a future release!\",\n                         )\n-                        .span_label(*span, \"not a function\")\n+                        .span_label(span, \"not a function\")\n                         .emit();\n                 });\n                 true\n@@ -495,7 +498,7 @@ impl CheckAttrVisitor<'tcx> {\n                 self.tcx\n                     .sess\n                     .struct_span_err(attr.span, \"attribute should be applied to a function\")\n-                    .span_label(*span, \"not a function\")\n+                    .span_label(span, \"not a function\")\n                     .emit();\n                 false\n             }\n@@ -1047,22 +1050,22 @@ impl CheckAttrVisitor<'tcx> {\n     }\n \n     /// Checks if `#[must_not_suspend]` is applied to a function. Returns `true` if valid.\n-    fn check_must_not_suspend(&self, attr: &Attribute, span: &Span, target: Target) -> bool {\n+    fn check_must_not_suspend(&self, attr: &Attribute, span: Span, target: Target) -> bool {\n         match target {\n             Target::Struct | Target::Enum | Target::Union | Target::Trait => true,\n             _ => {\n                 self.tcx\n                     .sess\n                     .struct_span_err(attr.span, \"`must_not_suspend` attribute should be applied to a struct, enum, or trait\")\n-                        .span_label(*span, \"is not a struct, enum, or trait\")\n+                        .span_label(span, \"is not a struct, enum, or trait\")\n                         .emit();\n                 false\n             }\n         }\n     }\n \n     /// Checks if `#[cold]` is applied to a non-function. Returns `true` if valid.\n-    fn check_cold(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) {\n+    fn check_cold(&self, hir_id: HirId, attr: &Attribute, span: Span, target: Target) {\n         match target {\n             Target::Fn | Target::Method(..) | Target::ForeignFn | Target::Closure => {}\n             // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n@@ -1082,15 +1085,15 @@ impl CheckAttrVisitor<'tcx> {\n                              being phased out; it will become a hard error in \\\n                              a future release!\",\n                         )\n-                        .span_label(*span, \"not a function\")\n+                        .span_label(span, \"not a function\")\n                         .emit();\n                 });\n             }\n         }\n     }\n \n     /// Checks if `#[link_name]` is applied to an item other than a foreign function or static.\n-    fn check_link_name(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) {\n+    fn check_link_name(&self, hir_id: HirId, attr: &Attribute, span: Span, target: Target) {\n         match target {\n             Target::ForeignFn | Target::ForeignStatic => {}\n             // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n@@ -1124,15 +1127,15 @@ impl CheckAttrVisitor<'tcx> {\n                         }\n                     }\n \n-                    diag.span_label(*span, \"not a foreign function or static\");\n+                    diag.span_label(span, \"not a foreign function or static\");\n                     diag.emit();\n                 });\n             }\n         }\n     }\n \n     /// Checks if `#[no_link]` is applied to an `extern crate`. Returns `true` if valid.\n-    fn check_no_link(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) -> bool {\n+    fn check_no_link(&self, hir_id: HirId, attr: &Attribute, span: Span, target: Target) -> bool {\n         match target {\n             Target::ExternCrate => true,\n             // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n@@ -1150,7 +1153,7 @@ impl CheckAttrVisitor<'tcx> {\n                         attr.span,\n                         \"attribute should be applied to an `extern crate` item\",\n                     )\n-                    .span_label(*span, \"not an `extern crate` item\")\n+                    .span_label(span, \"not an `extern crate` item\")\n                     .emit();\n                 false\n             }\n@@ -1166,7 +1169,7 @@ impl CheckAttrVisitor<'tcx> {\n         &self,\n         hir_id: HirId,\n         attr: &Attribute,\n-        span: &Span,\n+        span: Span,\n         target: Target,\n     ) -> bool {\n         match target {\n@@ -1187,7 +1190,7 @@ impl CheckAttrVisitor<'tcx> {\n                         attr.span,\n                         \"attribute should be applied to a free function, impl method or static\",\n                     )\n-                    .span_label(*span, \"not a free function, impl method or static\")\n+                    .span_label(span, \"not a free function, impl method or static\")\n                     .emit();\n                 false\n             }\n@@ -1197,14 +1200,14 @@ impl CheckAttrVisitor<'tcx> {\n     fn check_rustc_layout_scalar_valid_range(\n         &self,\n         attr: &Attribute,\n-        span: &Span,\n+        span: Span,\n         target: Target,\n     ) -> bool {\n         if target != Target::Struct {\n             self.tcx\n                 .sess\n                 .struct_span_err(attr.span, \"attribute should be applied to a struct\")\n-                .span_label(*span, \"not a struct\")\n+                .span_label(span, \"not a struct\")\n                 .emit();\n             return false;\n         }\n@@ -1229,7 +1232,7 @@ impl CheckAttrVisitor<'tcx> {\n     fn check_rustc_legacy_const_generics(\n         &self,\n         attr: &Attribute,\n-        span: &Span,\n+        span: Span,\n         target: Target,\n         item: Option<ItemLike<'_>>,\n     ) -> bool {\n@@ -1238,7 +1241,7 @@ impl CheckAttrVisitor<'tcx> {\n             self.tcx\n                 .sess\n                 .struct_span_err(attr.span, \"attribute should be applied to a function\")\n-                .span_label(*span, \"not a function\")\n+                .span_label(span, \"not a function\")\n                 .emit();\n             return false;\n         }\n@@ -1324,6 +1327,25 @@ impl CheckAttrVisitor<'tcx> {\n         }\n     }\n \n+    fn check_rustc_lint_query_instability(\n+        &self,\n+        attr: &Attribute,\n+        span: Span,\n+        target: Target,\n+    ) -> bool {\n+        let is_function = matches!(target, Target::Fn | Target::Method(..));\n+        if !is_function {\n+            self.tcx\n+                .sess\n+                .struct_span_err(attr.span, \"attribute should be applied to a function\")\n+                .span_label(span, \"not a function\")\n+                .emit();\n+            false\n+        } else {\n+            true\n+        }\n+    }\n+\n     /// Checks that the dep-graph debugging attributes are only present when the query-dep-graph\n     /// option is passed to the compiler.\n     fn check_rustc_dirty_clean(&self, attr: &Attribute) -> bool {\n@@ -1339,7 +1361,7 @@ impl CheckAttrVisitor<'tcx> {\n     }\n \n     /// Checks if `#[link_section]` is applied to a function or static.\n-    fn check_link_section(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) {\n+    fn check_link_section(&self, hir_id: HirId, attr: &Attribute, span: Span, target: Target) {\n         match target {\n             Target::Static | Target::Fn | Target::Method(..) => {}\n             // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n@@ -1359,15 +1381,15 @@ impl CheckAttrVisitor<'tcx> {\n                              being phased out; it will become a hard error in \\\n                              a future release!\",\n                         )\n-                        .span_label(*span, \"not a function or static\")\n+                        .span_label(span, \"not a function or static\")\n                         .emit();\n                 });\n             }\n         }\n     }\n \n     /// Checks if `#[no_mangle]` is applied to a function or static.\n-    fn check_no_mangle(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) {\n+    fn check_no_mangle(&self, hir_id: HirId, attr: &Attribute, span: Span, target: Target) {\n         match target {\n             Target::Static | Target::Fn => {}\n             Target::Method(..) if self.is_impl_item(hir_id) => {}\n@@ -1397,7 +1419,7 @@ impl CheckAttrVisitor<'tcx> {\n                             being phased out; it will become a hard error in \\\n                             a future release!\",\n                     )\n-                    .span_label(*span, format!(\"foreign {}\", foreign_item_kind))\n+                    .span_label(span, format!(\"foreign {}\", foreign_item_kind))\n                     .note(\"symbol names in extern blocks are not mangled\")\n                     .span_suggestion(\n                         attr.span,\n@@ -1420,7 +1442,7 @@ impl CheckAttrVisitor<'tcx> {\n                          being phased out; it will become a hard error in \\\n                          a future release!\",\n                     )\n-                    .span_label(*span, \"not a free function, impl method or static\")\n+                    .span_label(span, \"not a free function, impl method or static\")\n                     .emit();\n                 });\n             }\n@@ -1431,7 +1453,7 @@ impl CheckAttrVisitor<'tcx> {\n     fn check_repr(\n         &self,\n         attrs: &'hir [Attribute],\n-        span: &Span,\n+        span: Span,\n         target: Target,\n         item: Option<ItemLike<'_>>,\n         hir_id: HirId,\n@@ -1565,7 +1587,7 @@ impl CheckAttrVisitor<'tcx> {\n                 \"{}\",\n                 &format!(\"attribute should be applied to {} {}\", article, allowed_targets)\n             )\n-            .span_label(*span, &format!(\"not {} {}\", article, allowed_targets))\n+            .span_label(span, &format!(\"not {} {}\", article, allowed_targets))\n             .emit();\n         }\n \n@@ -1628,7 +1650,7 @@ impl CheckAttrVisitor<'tcx> {\n         &self,\n         hir_id: HirId,\n         attr: &Attribute,\n-        span: &Span,\n+        span: Span,\n         target: Target,\n         attrs: &[Attribute],\n     ) -> bool {\n@@ -1661,7 +1683,7 @@ impl CheckAttrVisitor<'tcx> {\n                 self.tcx\n                     .sess\n                     .struct_span_err(attr.span, \"attribute should be applied to a macro\")\n-                    .span_label(*span, \"not a macro\")\n+                    .span_label(span, \"not a macro\")\n                     .emit();\n                 false\n             }\n@@ -1674,7 +1696,7 @@ impl CheckAttrVisitor<'tcx> {\n         &self,\n         hir_id: HirId,\n         attr: &Attribute,\n-        span: &Span,\n+        span: Span,\n         target: Target,\n     ) -> bool {\n         match target {\n@@ -1695,7 +1717,7 @@ impl CheckAttrVisitor<'tcx> {\n                 self.tcx\n                     .sess\n                     .struct_span_err(attr.span, \"attribute should be applied to `const fn`\")\n-                    .span_label(*span, \"not a `const fn`\")\n+                    .span_label(span, \"not a `const fn`\")\n                     .emit();\n                 false\n             }\n@@ -1706,7 +1728,7 @@ impl CheckAttrVisitor<'tcx> {\n     fn check_default_method_body_is_const(\n         &self,\n         attr: &Attribute,\n-        span: &Span,\n+        span: Span,\n         target: Target,\n     ) -> bool {\n         match target {\n@@ -1718,14 +1740,14 @@ impl CheckAttrVisitor<'tcx> {\n                         attr.span,\n                         \"attribute should be applied to a trait method with body\",\n                     )\n-                    .span_label(*span, \"not a trait method or missing a body\")\n+                    .span_label(span, \"not a trait method or missing a body\")\n                     .emit();\n                 false\n             }\n         }\n     }\n \n-    fn check_stability_promotable(&self, attr: &Attribute, _span: &Span, target: Target) -> bool {\n+    fn check_stability_promotable(&self, attr: &Attribute, _span: Span, target: Target) -> bool {\n         match target {\n             Target::Expression => {\n                 self.tcx\n@@ -1738,7 +1760,7 @@ impl CheckAttrVisitor<'tcx> {\n         }\n     }\n \n-    fn check_deprecated(&self, hir_id: HirId, attr: &Attribute, _span: &Span, target: Target) {\n+    fn check_deprecated(&self, hir_id: HirId, attr: &Attribute, _span: Span, target: Target) {\n         match target {\n             Target::Closure | Target::Expression | Target::Statement | Target::Arm => {\n                 self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n@@ -1810,37 +1832,37 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n         }\n \n         let target = Target::from_item(item);\n-        self.check_attributes(item.hir_id(), &item.span, target, Some(ItemLike::Item(item)));\n+        self.check_attributes(item.hir_id(), item.span, target, Some(ItemLike::Item(item)));\n         intravisit::walk_item(self, item)\n     }\n \n     fn visit_generic_param(&mut self, generic_param: &'tcx hir::GenericParam<'tcx>) {\n         let target = Target::from_generic_param(generic_param);\n-        self.check_attributes(generic_param.hir_id, &generic_param.span, target, None);\n+        self.check_attributes(generic_param.hir_id, generic_param.span, target, None);\n         intravisit::walk_generic_param(self, generic_param)\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx TraitItem<'tcx>) {\n         let target = Target::from_trait_item(trait_item);\n-        self.check_attributes(trait_item.hir_id(), &trait_item.span, target, None);\n+        self.check_attributes(trait_item.hir_id(), trait_item.span, target, None);\n         intravisit::walk_trait_item(self, trait_item)\n     }\n \n     fn visit_field_def(&mut self, struct_field: &'tcx hir::FieldDef<'tcx>) {\n-        self.check_attributes(struct_field.hir_id, &struct_field.span, Target::Field, None);\n+        self.check_attributes(struct_field.hir_id, struct_field.span, Target::Field, None);\n         intravisit::walk_field_def(self, struct_field);\n     }\n \n     fn visit_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) {\n-        self.check_attributes(arm.hir_id, &arm.span, Target::Arm, None);\n+        self.check_attributes(arm.hir_id, arm.span, Target::Arm, None);\n         intravisit::walk_arm(self, arm);\n     }\n \n     fn visit_foreign_item(&mut self, f_item: &'tcx ForeignItem<'tcx>) {\n         let target = Target::from_foreign_item(f_item);\n         self.check_attributes(\n             f_item.hir_id(),\n-            &f_item.span,\n+            f_item.span,\n             target,\n             Some(ItemLike::ForeignItem(f_item)),\n         );\n@@ -1849,14 +1871,14 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         let target = target_from_impl_item(self.tcx, impl_item);\n-        self.check_attributes(impl_item.hir_id(), &impl_item.span, target, None);\n+        self.check_attributes(impl_item.hir_id(), impl_item.span, target, None);\n         intravisit::walk_impl_item(self, impl_item)\n     }\n \n     fn visit_stmt(&mut self, stmt: &'tcx hir::Stmt<'tcx>) {\n         // When checking statements ignore expressions, they will be checked later.\n         if let hir::StmtKind::Local(ref l) = stmt.kind {\n-            self.check_attributes(l.hir_id, &stmt.span, Target::Statement, None);\n+            self.check_attributes(l.hir_id, stmt.span, Target::Statement, None);\n         }\n         intravisit::walk_stmt(self, stmt)\n     }\n@@ -1867,7 +1889,7 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n             _ => Target::Expression,\n         };\n \n-        self.check_attributes(expr.hir_id, &expr.span, target, None);\n+        self.check_attributes(expr.hir_id, expr.span, target, None);\n         intravisit::walk_expr(self, expr)\n     }\n \n@@ -1877,12 +1899,12 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n         generics: &'tcx hir::Generics<'tcx>,\n         item_id: HirId,\n     ) {\n-        self.check_attributes(variant.id, &variant.span, Target::Variant, None);\n+        self.check_attributes(variant.id, variant.span, Target::Variant, None);\n         intravisit::walk_variant(self, variant, generics, item_id)\n     }\n \n     fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n-        self.check_attributes(param.hir_id, &param.span, Target::Param, None);\n+        self.check_attributes(param.hir_id, param.span, Target::Param, None);\n \n         intravisit::walk_param(self, param);\n     }\n@@ -1950,7 +1972,7 @@ fn check_mod_attrs(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     let check_attr_visitor = &mut CheckAttrVisitor { tcx };\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut check_attr_visitor.as_deep_visitor());\n     if module_def_id.is_top_level_module() {\n-        check_attr_visitor.check_attributes(CRATE_HIR_ID, &DUMMY_SP, Target::Mod, None);\n+        check_attr_visitor.check_attributes(CRATE_HIR_ID, DUMMY_SP, Target::Mod, None);\n         check_invalid_crate_level_attr(tcx, tcx.hir().krate_attrs());\n     }\n }"}, {"sha": "eba9f386af7db064afe09bfd7e2ca6ef9d1f4b19", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80fe0bb76e601054398eb3c4763a6e9125d8101c/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80fe0bb76e601054398eb3c4763a6e9125d8101c/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=80fe0bb76e601054398eb3c4763a6e9125d8101c", "patch": "@@ -1115,6 +1115,7 @@ symbols! {\n         rustc_layout_scalar_valid_range_end,\n         rustc_layout_scalar_valid_range_start,\n         rustc_legacy_const_generics,\n+        rustc_lint_query_instability,\n         rustc_macro_transparency,\n         rustc_main,\n         rustc_mir,"}, {"sha": "d36a3eaea92575923010ff705d2d2583d8654d0e", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/80fe0bb76e601054398eb3c4763a6e9125d8101c/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80fe0bb76e601054398eb3c4763a6e9125d8101c/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=80fe0bb76e601054398eb3c4763a6e9125d8101c", "patch": "@@ -414,6 +414,7 @@ impl<K, V, S> HashMap<K, V, S> {\n     ///     println!(\"key: {} val: {}\", key, val);\n     /// }\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_lint_query_instability)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<'_, K, V> {\n         Iter { base: self.base.iter() }\n@@ -442,6 +443,7 @@ impl<K, V, S> HashMap<K, V, S> {\n     ///     println!(\"key: {} val: {}\", key, val);\n     /// }\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_lint_query_instability)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n         IterMut { base: self.base.iter_mut() }\n@@ -502,6 +504,7 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// assert!(a.is_empty());\n     /// ```\n     #[inline]\n+    #[cfg_attr(not(bootstrap), rustc_lint_query_instability)]\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain(&mut self) -> Drain<'_, K, V> {\n         Drain { base: self.base.drain() }\n@@ -543,6 +546,7 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// assert_eq!(odds, vec![1, 3, 5, 7]);\n     /// ```\n     #[inline]\n+    #[cfg_attr(not(bootstrap), rustc_lint_query_instability)]\n     #[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n     pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, K, V, F>\n     where\n@@ -949,6 +953,7 @@ where\n     /// assert_eq!(map.len(), 4);\n     /// ```\n     #[inline]\n+    #[cfg_attr(not(bootstrap), rustc_lint_query_instability)]\n     #[stable(feature = \"retain_hash_collection\", since = \"1.18.0\")]\n     pub fn retain<F>(&mut self, f: F)\n     where\n@@ -978,6 +983,7 @@ where\n     /// assert_eq!(vec, [\"a\", \"b\", \"c\"]);\n     /// ```\n     #[inline]\n+    #[cfg_attr(not(bootstrap), rustc_lint_query_instability)]\n     #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n     pub fn into_keys(self) -> IntoKeys<K, V> {\n         IntoKeys { inner: self.into_iter() }\n@@ -1004,6 +1010,7 @@ where\n     /// assert_eq!(vec, [1, 2, 3]);\n     /// ```\n     #[inline]\n+    #[cfg_attr(not(bootstrap), rustc_lint_query_instability)]\n     #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n     pub fn into_values(self) -> IntoValues<K, V> {\n         IntoValues { inner: self.into_iter() }\n@@ -1969,6 +1976,7 @@ impl<'a, K, V, S> IntoIterator for &'a HashMap<K, V, S> {\n     type IntoIter = Iter<'a, K, V>;\n \n     #[inline]\n+    #[cfg_attr(not(bootstrap), rustc_lint_query_instability)]\n     fn into_iter(self) -> Iter<'a, K, V> {\n         self.iter()\n     }\n@@ -1980,6 +1988,7 @@ impl<'a, K, V, S> IntoIterator for &'a mut HashMap<K, V, S> {\n     type IntoIter = IterMut<'a, K, V>;\n \n     #[inline]\n+    #[cfg_attr(not(bootstrap), rustc_lint_query_instability)]\n     fn into_iter(self) -> IterMut<'a, K, V> {\n         self.iter_mut()\n     }\n@@ -2008,6 +2017,7 @@ impl<K, V, S> IntoIterator for HashMap<K, V, S> {\n     /// let vec: Vec<(&str, i32)> = map.into_iter().collect();\n     /// ```\n     #[inline]\n+    #[cfg_attr(not(bootstrap), rustc_lint_query_instability)]\n     fn into_iter(self) -> IntoIter<K, V> {\n         IntoIter { base: self.base.into_iter() }\n     }"}, {"sha": "f3bfa87bbde572463bf54d7f905fbeefe472e3cc", "filename": "library/std/src/collections/hash/set.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/80fe0bb76e601054398eb3c4763a6e9125d8101c/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80fe0bb76e601054398eb3c4763a6e9125d8101c/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs?ref=80fe0bb76e601054398eb3c4763a6e9125d8101c", "patch": "@@ -185,6 +185,7 @@ impl<T, S> HashSet<T, S> {\n     /// }\n     /// ```\n     #[inline]\n+    #[cfg_attr(not(bootstrap), rustc_lint_query_instability)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<'_, T> {\n         Iter { base: self.base.iter() }\n@@ -244,6 +245,7 @@ impl<T, S> HashSet<T, S> {\n     /// assert!(set.is_empty());\n     /// ```\n     #[inline]\n+    #[cfg_attr(not(bootstrap), rustc_lint_query_instability)]\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain(&mut self) -> Drain<'_, T> {\n         Drain { base: self.base.drain() }\n@@ -282,6 +284,7 @@ impl<T, S> HashSet<T, S> {\n     /// assert_eq!(odds, vec![1, 3, 5, 7]);\n     /// ```\n     #[inline]\n+    #[cfg_attr(not(bootstrap), rustc_lint_query_instability)]\n     #[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n     pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, T, F>\n     where\n@@ -506,6 +509,7 @@ where\n     /// assert_eq!(diff, [4].iter().collect());\n     /// ```\n     #[inline]\n+    #[cfg_attr(not(bootstrap), rustc_lint_query_instability)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a HashSet<T, S>) -> Difference<'a, T, S> {\n         Difference { iter: self.iter(), other }\n@@ -533,6 +537,7 @@ where\n     /// assert_eq!(diff1, [1, 4].iter().collect());\n     /// ```\n     #[inline]\n+    #[cfg_attr(not(bootstrap), rustc_lint_query_instability)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn symmetric_difference<'a>(\n         &'a self,\n@@ -560,6 +565,7 @@ where\n     /// assert_eq!(intersection, [2, 3].iter().collect());\n     /// ```\n     #[inline]\n+    #[cfg_attr(not(bootstrap), rustc_lint_query_instability)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a HashSet<T, S>) -> Intersection<'a, T, S> {\n         if self.len() <= other.len() {\n@@ -588,6 +594,7 @@ where\n     /// assert_eq!(union, [1, 2, 3, 4].iter().collect());\n     /// ```\n     #[inline]\n+    #[cfg_attr(not(bootstrap), rustc_lint_query_instability)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a HashSet<T, S>) -> Union<'a, T, S> {\n         if self.len() >= other.len() {\n@@ -922,6 +929,7 @@ where\n     /// set.retain(|&k| k % 2 == 0);\n     /// assert_eq!(set.len(), 3);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_lint_query_instability)]\n     #[stable(feature = \"retain_hash_collection\", since = \"1.18.0\")]\n     pub fn retain<F>(&mut self, f: F)\n     where\n@@ -1403,6 +1411,7 @@ impl<'a, T, S> IntoIterator for &'a HashSet<T, S> {\n     type IntoIter = Iter<'a, T>;\n \n     #[inline]\n+    #[cfg_attr(not(bootstrap), rustc_lint_query_instability)]\n     fn into_iter(self) -> Iter<'a, T> {\n         self.iter()\n     }\n@@ -1434,6 +1443,7 @@ impl<T, S> IntoIterator for HashSet<T, S> {\n     /// }\n     /// ```\n     #[inline]\n+    #[cfg_attr(not(bootstrap), rustc_lint_query_instability)]\n     fn into_iter(self) -> IntoIter<T> {\n         IntoIter { base: self.base.into_iter() }\n     }"}, {"sha": "560675b448608a31ef1130b38e476afa69fec9d9", "filename": "src/test/ui-fulldeps/internal-lints/query_stability.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/80fe0bb76e601054398eb3c4763a6e9125d8101c/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fquery_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80fe0bb76e601054398eb3c4763a6e9125d8101c/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fquery_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fquery_stability.rs?ref=80fe0bb76e601054398eb3c4763a6e9125d8101c", "patch": "@@ -0,0 +1,24 @@\n+// compile-flags: -Z unstable-options\n+\n+#![feature(rustc_private)]\n+#![deny(rustc::potential_query_instability)]\n+\n+extern crate rustc_data_structures;\n+\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+\n+fn main() {\n+    let mut x = FxHashMap::<u32, i32>::default();\n+\n+    for _ in x.drain() {}\n+    //~^ ERROR using `drain` can result in unstable\n+\n+    for _ in x.iter() {}\n+    //~^ ERROR using `iter`\n+\n+    for _ in Some(&mut x).unwrap().iter_mut() {}\n+    //~^ ERROR using `iter_mut`\n+\n+    for _ in x {}\n+    //~^ ERROR using `into_iter`\n+}"}, {"sha": "7e8b448f41a9119911d9f5bd8a7ec58a5fcc7b95", "filename": "src/test/ui-fulldeps/internal-lints/query_stability.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/80fe0bb76e601054398eb3c4763a6e9125d8101c/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fquery_stability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/80fe0bb76e601054398eb3c4763a6e9125d8101c/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fquery_stability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fquery_stability.stderr?ref=80fe0bb76e601054398eb3c4763a6e9125d8101c", "patch": "@@ -0,0 +1,39 @@\n+error: using `drain` can result in unstable query results\n+  --> $DIR/query_stability.rs:13:16\n+   |\n+LL |     for _ in x.drain() {}\n+   |                ^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/query_stability.rs:4:9\n+   |\n+LL | #![deny(rustc::potential_query_instability)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: if you believe this case to be fine, allow this lint and add a comment explaining your rationale\n+\n+error: using `iter` can result in unstable query results\n+  --> $DIR/query_stability.rs:16:16\n+   |\n+LL |     for _ in x.iter() {}\n+   |                ^^^^\n+   |\n+   = note: if you believe this case to be fine, allow this lint and add a comment explaining your rationale\n+\n+error: using `iter_mut` can result in unstable query results\n+  --> $DIR/query_stability.rs:19:36\n+   |\n+LL |     for _ in Some(&mut x).unwrap().iter_mut() {}\n+   |                                    ^^^^^^^^\n+   |\n+   = note: if you believe this case to be fine, allow this lint and add a comment explaining your rationale\n+\n+error: using `into_iter` can result in unstable query results\n+  --> $DIR/query_stability.rs:22:14\n+   |\n+LL |     for _ in x {}\n+   |              ^\n+   |\n+   = note: if you believe this case to be fine, allow this lint and add a comment explaining your rationale\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "f478b73329eb76f0e446594dc32a85142e000470", "filename": "src/test/ui-fulldeps/internal-lints/query_stability_incorrect.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/80fe0bb76e601054398eb3c4763a6e9125d8101c/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fquery_stability_incorrect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80fe0bb76e601054398eb3c4763a6e9125d8101c/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fquery_stability_incorrect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fquery_stability_incorrect.rs?ref=80fe0bb76e601054398eb3c4763a6e9125d8101c", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags: -Z unstable-options\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_lint_query_instability]\n+//~^ ERROR attribute should be applied to a function\n+struct Foo;\n+\n+impl Foo {\n+    #[rustc_lint_query_instability(a)]\n+    //~^ ERROR malformed `rustc_lint_query_instability`\n+    fn bar() {}\n+}\n+\n+fn main() {}"}, {"sha": "b5156f2ac5905551077f73b3265e75c7d5d14410", "filename": "src/test/ui-fulldeps/internal-lints/query_stability_incorrect.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/80fe0bb76e601054398eb3c4763a6e9125d8101c/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fquery_stability_incorrect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/80fe0bb76e601054398eb3c4763a6e9125d8101c/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fquery_stability_incorrect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fquery_stability_incorrect.stderr?ref=80fe0bb76e601054398eb3c4763a6e9125d8101c", "patch": "@@ -0,0 +1,17 @@\n+error: malformed `rustc_lint_query_instability` attribute input\n+  --> $DIR/query_stability_incorrect.rs:10:5\n+   |\n+LL |     #[rustc_lint_query_instability(a)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[rustc_lint_query_instability]`\n+\n+error: attribute should be applied to a function\n+  --> $DIR/query_stability_incorrect.rs:5:1\n+   |\n+LL | #[rustc_lint_query_instability]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | struct Foo;\n+   | ----------- not a function\n+\n+error: aborting due to 2 previous errors\n+"}]}