{"sha": "4b9f4b221b92193c7e95b1beb502c6eb32c3b613", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiOWY0YjIyMWI5MjE5M2M3ZTk1YjFiZWI1MDJjNmViMzJjM2I2MTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-26T15:24:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-26T15:24:01Z"}, "message": "Auto merge of #88308 - eddyb:cooked-layouts, r=nagisa\n\nMorph `layout_raw` query into `layout_of`.\n\nBefore this PR, `LayoutCx::layout_of` wrapped the `layout_raw` query, to:\n* normalize the type, before attempting to compute the layout\n* pass the layout to `record_layout_for_printing`, for `-Zprint-type-sizes`\n\nMoving those two responsibilities into the query may reduce overhead (due to cached calls skipping those steps), but I want to do a perf run to know.\n\nOne of the changes I had to make was changing the return type of the query, to be able to both get out the type produced by normalizing inside the query *and* to match the signature of the old `TyCtxt::layout_of`. This change may be worse, perf-wise, so that's another reason I want to check.\n\nr? `@nagisa` cc `@oli-obk`", "tree": {"sha": "d2ecb2a06dba763092dedb6af14ff1315f108969", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2ecb2a06dba763092dedb6af14ff1315f108969"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b9f4b221b92193c7e95b1beb502c6eb32c3b613", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b9f4b221b92193c7e95b1beb502c6eb32c3b613", "html_url": "https://github.com/rust-lang/rust/commit/4b9f4b221b92193c7e95b1beb502c6eb32c3b613", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b9f4b221b92193c7e95b1beb502c6eb32c3b613/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20997f6ad81721542e9ef97bb2f58190903a34d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/20997f6ad81721542e9ef97bb2f58190903a34d8", "html_url": "https://github.com/rust-lang/rust/commit/20997f6ad81721542e9ef97bb2f58190903a34d8"}, {"sha": "edb4b2d8c2a9eafc3bdfdb97d5b676afc3f31248", "url": "https://api.github.com/repos/rust-lang/rust/commits/edb4b2d8c2a9eafc3bdfdb97d5b676afc3f31248", "html_url": "https://github.com/rust-lang/rust/commit/edb4b2d8c2a9eafc3bdfdb97d5b676afc3f31248"}], "stats": {"total": 148, "additions": 54, "deletions": 94}, "files": [{"sha": "d52ff3b73b2ba9034d3629dd88596749d8ece703", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b9f4b221b92193c7e95b1beb502c6eb32c3b613/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9f4b221b92193c7e95b1beb502c6eb32c3b613/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=4b9f4b221b92193c7e95b1beb502c6eb32c3b613", "patch": "@@ -1100,10 +1100,12 @@ rustc_queries! {\n         cache_on_disk_if { false }\n     }\n \n-    query layout_raw(\n-        env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n-    ) -> Result<&'tcx rustc_target::abi::Layout, ty::layout::LayoutError<'tcx>> {\n-        desc { \"computing layout of `{}`\", env.value }\n+    /// Computes the layout of a type. Note that this implicitly\n+    /// executes in \"reveal all\" mode, and will normalize the input type.\n+    query layout_of(\n+        key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n+    ) -> Result<ty::layout::TyAndLayout<'tcx>, ty::layout::LayoutError<'tcx>> {\n+        desc { \"computing layout of `{}`\", key.value }\n     }\n \n     query dylib_dependency_formats(_: CrateNum)"}, {"sha": "1429769e8f2bc2e45ecc07746792b26c40c704b6", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 33, "deletions": 75, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/4b9f4b221b92193c7e95b1beb502c6eb32c3b613/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9f4b221b92193c7e95b1beb502c6eb32c3b613/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=4b9f4b221b92193c7e95b1beb502c6eb32c3b613", "patch": "@@ -205,10 +205,10 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n     }\n }\n \n-fn layout_raw<'tcx>(\n+fn layout_of<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n-) -> Result<&'tcx Layout, LayoutError<'tcx>> {\n+) -> Result<TyAndLayout<'tcx>, LayoutError<'tcx>> {\n     ty::tls::with_related_context(tcx, move |icx| {\n         let (param_env, ty) = query.into_parts();\n \n@@ -220,21 +220,33 @@ fn layout_raw<'tcx>(\n         let icx = ty::tls::ImplicitCtxt { layout_depth: icx.layout_depth + 1, ..icx.clone() };\n \n         ty::tls::enter_context(&icx, |_| {\n+            let param_env = param_env.with_reveal_all_normalized(tcx);\n+            let unnormalized_ty = ty;\n+            let ty = tcx.normalize_erasing_regions(param_env, ty);\n+            if ty != unnormalized_ty {\n+                // Ensure this layout is also cached for the normalized type.\n+                return tcx.layout_of(param_env.and(ty));\n+            }\n+\n             let cx = LayoutCx { tcx, param_env };\n-            let layout = cx.layout_raw_uncached(ty);\n+\n+            let layout = cx.layout_of_uncached(ty)?;\n+            let layout = TyAndLayout { ty, layout };\n+\n+            cx.record_layout_for_printing(layout);\n+\n             // Type-level uninhabitedness should always imply ABI uninhabitedness.\n-            if let Ok(layout) = layout {\n-                if tcx.conservative_is_privately_uninhabited(param_env.and(ty)) {\n-                    assert!(layout.abi.is_uninhabited());\n-                }\n+            if tcx.conservative_is_privately_uninhabited(param_env.and(ty)) {\n+                assert!(layout.abi.is_uninhabited());\n             }\n-            layout\n+\n+            Ok(layout)\n         })\n     })\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {\n-    *providers = ty::query::Providers { layout_raw, ..*providers };\n+    *providers = ty::query::Providers { layout_of, ..*providers };\n }\n \n pub struct LayoutCx<'tcx, C> {\n@@ -492,7 +504,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         })\n     }\n \n-    fn layout_raw_uncached(&self, ty: Ty<'tcx>) -> Result<&'tcx Layout, LayoutError<'tcx>> {\n+    fn layout_of_uncached(&self, ty: Ty<'tcx>) -> Result<&'tcx Layout, LayoutError<'tcx>> {\n         let tcx = self.tcx;\n         let param_env = self.param_env;\n         let dl = self.data_layout();\n@@ -889,7 +901,9 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 let present_first = match present_first {\n                     Some(present_first) => present_first,\n                     // Uninhabited because it has no variants, or only absent ones.\n-                    None if def.is_enum() => return tcx.layout_raw(param_env.and(tcx.types.never)),\n+                    None if def.is_enum() => {\n+                        return Ok(tcx.layout_of(param_env.and(tcx.types.never))?.layout);\n+                    }\n                     // If it's a struct, still compute a layout so that we can still compute the\n                     // field offsets.\n                     None => VariantIdx::new(0),\n@@ -1368,11 +1382,9 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n             // Types with no meaningful known layout.\n             ty::Projection(_) | ty::Opaque(..) => {\n-                let normalized = tcx.normalize_erasing_regions(param_env, ty);\n-                if ty == normalized {\n-                    return Err(LayoutError::Unknown(ty));\n-                }\n-                tcx.layout_raw(param_env.and(normalized))?\n+                // NOTE(eddyb) `layout_of` query should've normalized these away,\n+                // if that was possible, so there's no reason to try again here.\n+                return Err(LayoutError::Unknown(ty));\n             }\n \n             ty::Placeholder(..) | ty::GeneratorWitness(..) | ty::Infer(_) => {\n@@ -1712,7 +1724,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         Ok(layout)\n     }\n \n-    /// This is invoked by the `layout_raw` query to record the final\n+    /// This is invoked by the `layout_of` query to record the final\n     /// layout of each type.\n     #[inline(always)]\n     fn record_layout_for_printing(&self, layout: TyAndLayout<'tcx>) {\n@@ -2040,22 +2052,9 @@ impl<'tcx> LayoutOf for LayoutCx<'tcx, TyCtxt<'tcx>> {\n     type TyAndLayout = Result<TyAndLayout<'tcx>, LayoutError<'tcx>>;\n \n     /// Computes the layout of a type. Note that this implicitly\n-    /// executes in \"reveal all\" mode.\n+    /// executes in \"reveal all\" mode, and will normalize the input type.\n     fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n-        let param_env = self.param_env.with_reveal_all_normalized(self.tcx);\n-        let ty = self.tcx.normalize_erasing_regions(param_env, ty);\n-        let layout = self.tcx.layout_raw(param_env.and(ty))?;\n-        let layout = TyAndLayout { ty, layout };\n-\n-        // N.B., this recording is normally disabled; when enabled, it\n-        // can however trigger recursive invocations of `layout_of`.\n-        // Therefore, we execute it *after* the main query has\n-        // completed, to avoid problems around recursive structures\n-        // and the like. (Admittedly, I wasn't able to reproduce a problem\n-        // here, but it seems like the right thing to do. -nmatsakis)\n-        self.record_layout_for_printing(layout);\n-\n-        Ok(layout)\n+        self.tcx.layout_of(self.param_env.and(ty))\n     }\n }\n \n@@ -2064,50 +2063,9 @@ impl LayoutOf for LayoutCx<'tcx, ty::query::TyCtxtAt<'tcx>> {\n     type TyAndLayout = Result<TyAndLayout<'tcx>, LayoutError<'tcx>>;\n \n     /// Computes the layout of a type. Note that this implicitly\n-    /// executes in \"reveal all\" mode.\n+    /// executes in \"reveal all\" mode, and will normalize the input type.\n     fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n-        let param_env = self.param_env.with_reveal_all_normalized(*self.tcx);\n-        let ty = self.tcx.normalize_erasing_regions(param_env, ty);\n-        let layout = self.tcx.layout_raw(param_env.and(ty))?;\n-        let layout = TyAndLayout { ty, layout };\n-\n-        // N.B., this recording is normally disabled; when enabled, it\n-        // can however trigger recursive invocations of `layout_of`.\n-        // Therefore, we execute it *after* the main query has\n-        // completed, to avoid problems around recursive structures\n-        // and the like. (Admittedly, I wasn't able to reproduce a problem\n-        // here, but it seems like the right thing to do. -nmatsakis)\n-        let cx = LayoutCx { tcx: *self.tcx, param_env: self.param_env };\n-        cx.record_layout_for_printing(layout);\n-\n-        Ok(layout)\n-    }\n-}\n-\n-// Helper (inherent) `layout_of` methods to avoid pushing `LayoutCx` to users.\n-impl TyCtxt<'tcx> {\n-    /// Computes the layout of a type. Note that this implicitly\n-    /// executes in \"reveal all\" mode.\n-    #[inline]\n-    pub fn layout_of(\n-        self,\n-        param_env_and_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    ) -> Result<TyAndLayout<'tcx>, LayoutError<'tcx>> {\n-        let cx = LayoutCx { tcx: self, param_env: param_env_and_ty.param_env };\n-        cx.layout_of(param_env_and_ty.value)\n-    }\n-}\n-\n-impl ty::query::TyCtxtAt<'tcx> {\n-    /// Computes the layout of a type. Note that this implicitly\n-    /// executes in \"reveal all\" mode.\n-    #[inline]\n-    pub fn layout_of(\n-        self,\n-        param_env_and_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    ) -> Result<TyAndLayout<'tcx>, LayoutError<'tcx>> {\n-        let cx = LayoutCx { tcx: self.at(self.span), param_env: param_env_and_ty.param_env };\n-        cx.layout_of(param_env_and_ty.value)\n+        self.tcx.layout_of(self.param_env.and(ty))\n     }\n }\n "}, {"sha": "73adc60577bfcf41e43f243ba057f77256c8d112", "filename": "compiler/rustc_mir/src/util/alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9f4b221b92193c7e95b1beb502c6eb32c3b613/compiler%2Frustc_mir%2Fsrc%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9f4b221b92193c7e95b1beb502c6eb32c3b613/compiler%2Frustc_mir%2Fsrc%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Falignment.rs?ref=4b9f4b221b92193c7e95b1beb502c6eb32c3b613", "patch": "@@ -24,7 +24,7 @@ where\n     };\n \n     let ty = place.ty(local_decls, tcx).ty;\n-    match tcx.layout_raw(param_env.and(ty)) {\n+    match tcx.layout_of(param_env.and(ty)) {\n         Ok(layout) if layout.align.abi <= pack => {\n             // If the packed alignment is greater or equal to the field alignment, the type won't be\n             // further disaligned."}, {"sha": "00b1b595022056f3378d6bca142f3544c88156df", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9f4b221b92193c7e95b1beb502c6eb32c3b613/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9f4b221b92193c7e95b1beb502c6eb32c3b613/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=4b9f4b221b92193c7e95b1beb502c6eb32c3b613", "patch": "@@ -1139,7 +1139,7 @@ impl Layout {\n /// to that obtained from `layout_of(ty)`, as we need to produce\n /// layouts for which Rust types do not exist, such as enum variants\n /// or synthetic fields of enums (i.e., discriminants) and fat pointers.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, HashStable_Generic)]\n pub struct TyAndLayout<'a, Ty> {\n     pub ty: Ty,\n     pub layout: &'a Layout,"}, {"sha": "ae6bebcf727d18b0c46dbe3b06971c60b96fc2c3", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9f4b221b92193c7e95b1beb502c6eb32c3b613/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9f4b221b92193c7e95b1beb502c6eb32c3b613/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=4b9f4b221b92193c7e95b1beb502c6eb32c3b613", "patch": "@@ -1481,7 +1481,7 @@ fn restrict_repr_packed_field_ref_capture<'tcx>(\n         match p.kind {\n             ProjectionKind::Field(..) => match ty.kind() {\n                 ty::Adt(def, _) if def.repr.packed() => {\n-                    match tcx.layout_raw(param_env.and(p.ty)) {\n+                    match tcx.layout_of(param_env.and(p.ty)) {\n                         Ok(layout) if layout.align.abi.bytes() == 1 => {\n                             // if the alignment is 1, the type can't be further\n                             // disaligned."}, {"sha": "1067eb003f7c765ad92b045730a3f2254fba575f", "filename": "src/test/ui/consts/const-size_of-cycle.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b9f4b221b92193c7e95b1beb502c6eb32c3b613/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9f4b221b92193c7e95b1beb502c6eb32c3b613/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr?ref=4b9f4b221b92193c7e95b1beb502c6eb32c3b613", "patch": "@@ -15,6 +15,7 @@ note: ...which requires const-evaluating + checking `Foo::bytes::{constant#0}`..\n LL |     bytes: [u8; std::mem::size_of::<Foo>()]\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which requires computing layout of `Foo`...\n+   = note: ...which requires computing layout of `[u8; _]`...\n    = note: ...which requires normalizing `[u8; _]`...\n    = note: ...which again requires simplifying constant for the type system `Foo::bytes::{constant#0}`, completing the cycle\n note: cycle used when checking that `Foo` is well-formed"}, {"sha": "9e3db5ce9a402ce3cdce028910d1d27821be98c5", "filename": "src/test/ui/consts/issue-44415.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b9f4b221b92193c7e95b1beb502c6eb32c3b613/src%2Ftest%2Fui%2Fconsts%2Fissue-44415.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9f4b221b92193c7e95b1beb502c6eb32c3b613/src%2Ftest%2Fui%2Fconsts%2Fissue-44415.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-44415.stderr?ref=4b9f4b221b92193c7e95b1beb502c6eb32c3b613", "patch": "@@ -15,6 +15,7 @@ note: ...which requires const-evaluating + checking `Foo::bytes::{constant#0}`..\n LL |     bytes: [u8; unsafe { intrinsics::size_of::<Foo>() }],\n    |                 ^^^^^^\n    = note: ...which requires computing layout of `Foo`...\n+   = note: ...which requires computing layout of `[u8; _]`...\n    = note: ...which requires normalizing `[u8; _]`...\n    = note: ...which again requires simplifying constant for the type system `Foo::bytes::{constant#0}`, completing the cycle\n note: cycle used when checking that `Foo` is well-formed"}, {"sha": "03cb3e24b7dbff0c49ca7c063aa2370779e8deda", "filename": "src/test/ui/recursion/issue-26548-recursion-via-normalize.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4b9f4b221b92193c7e95b1beb502c6eb32c3b613/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9f4b221b92193c7e95b1beb502c6eb32c3b613/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.rs?ref=4b9f4b221b92193c7e95b1beb502c6eb32c3b613", "patch": "@@ -1,6 +1,8 @@\n-//~ ERROR cycle detected when computing layout of\n-//~| NOTE ...which requires computing layout of\n-//~| NOTE ...which again requires computing layout of\n+//~ ERROR cycle detected when computing layout of `S`\n+//~| NOTE ...which requires computing layout of `std::option::Option<<S as Mirror>::It>`...\n+//~| NOTE ...which requires computing layout of `std::option::Option<S>`...\n+//~| NOTE ...which again requires computing layout of `S`, completing the cycle\n+//~| NOTE cycle used when computing layout of `std::option::Option<S>`\n \n // build-fail\n \n@@ -13,6 +15,5 @@ impl<T: ?Sized> Mirror for T {\n struct S(Option<<S as Mirror>::It>);\n \n fn main() {\n-    //~^ NOTE cycle used when optimizing MIR for `main`\n     let _s = S(None);\n }"}, {"sha": "21c0e1e6de5f34b05f0704995dbda5d3e1d6ce88", "filename": "src/test/ui/recursion/issue-26548-recursion-via-normalize.stderr", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4b9f4b221b92193c7e95b1beb502c6eb32c3b613/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9f4b221b92193c7e95b1beb502c6eb32c3b613/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.stderr?ref=4b9f4b221b92193c7e95b1beb502c6eb32c3b613", "patch": "@@ -1,12 +1,9 @@\n-error[E0391]: cycle detected when computing layout of `std::option::Option<S>`\n+error[E0391]: cycle detected when computing layout of `S`\n    |\n-   = note: ...which requires computing layout of `S`...\n-   = note: ...which again requires computing layout of `std::option::Option<S>`, completing the cycle\n-note: cycle used when optimizing MIR for `main`\n-  --> $DIR/issue-26548-recursion-via-normalize.rs:15:1\n-   |\n-LL | fn main() {\n-   | ^^^^^^^^^\n+   = note: ...which requires computing layout of `std::option::Option<<S as Mirror>::It>`...\n+   = note: ...which requires computing layout of `std::option::Option<S>`...\n+   = note: ...which again requires computing layout of `S`, completing the cycle\n+   = note: cycle used when computing layout of `std::option::Option<S>`\n \n error: aborting due to previous error\n "}]}