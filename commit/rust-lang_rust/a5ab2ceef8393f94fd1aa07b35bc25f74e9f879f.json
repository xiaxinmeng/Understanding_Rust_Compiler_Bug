{"sha": "a5ab2ceef8393f94fd1aa07b35bc25f74e9f879f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1YWIyY2VlZjgzOTNmOTRmZDFhYTA3YjM1YmMyNWY3NGU5Zjg3OWY=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-12T15:15:00Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-20T17:23:59Z"}, "message": "Fix a few errors introduced during rebase.", "tree": {"sha": "a790614bc4921675385157edbac2a3d024b04eb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a790614bc4921675385157edbac2a3d024b04eb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5ab2ceef8393f94fd1aa07b35bc25f74e9f879f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5ab2ceef8393f94fd1aa07b35bc25f74e9f879f", "html_url": "https://github.com/rust-lang/rust/commit/a5ab2ceef8393f94fd1aa07b35bc25f74e9f879f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5ab2ceef8393f94fd1aa07b35bc25f74e9f879f/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7435b52a93d96c47a84e505f9eb6a505d6037b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7435b52a93d96c47a84e505f9eb6a505d6037b5", "html_url": "https://github.com/rust-lang/rust/commit/c7435b52a93d96c47a84e505f9eb6a505d6037b5"}], "stats": {"total": 185, "additions": 122, "deletions": 63}, "files": [{"sha": "5d7400ab9ae8ac4f0d4af0ac52f42e0c0d195766", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5ab2ceef8393f94fd1aa07b35bc25f74e9f879f/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ab2ceef8393f94fd1aa07b35bc25f74e9f879f/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=a5ab2ceef8393f94fd1aa07b35bc25f74e9f879f", "patch": "@@ -192,8 +192,9 @@ impl<'a> Builder<'a> {\n         impl<'a> Step<'a> for Libdir<'a> {\n             type Output = PathBuf;\n             fn run(self, builder: &Builder) -> PathBuf {\n+                let compiler = self.compiler;\n                 let lib = if compiler.stage >= 2 && builder.build.config.libdir_relative.is_some() {\n-                    builder.build.config.libdir_relative.cloned().unwrap()\n+                    builder.build.config.libdir_relative.clone().unwrap()\n                 } else {\n                     PathBuf::from(\"lib\")\n                 };"}, {"sha": "e4cfe884295626540cdd5b855a9fb1c8742e3505", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 49, "deletions": 26, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/a5ab2ceef8393f94fd1aa07b35bc25f74e9f879f/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ab2ceef8393f94fd1aa07b35bc25f74e9f879f/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=a5ab2ceef8393f94fd1aa07b35bc25f74e9f879f", "patch": "@@ -753,40 +753,63 @@ impl<'a> Step<'a> for Compiletest<'a> {\n     }\n }\n \n+#[derive(Serialize)]\n+pub struct Docs<'a> {\n+    compiler: Compiler<'a>,\n+}\n+\n // rules.test(\"check-docs\", \"src/doc\")\n //     .dep(|s| s.name(\"libtest\"))\n //     .default(true)\n //     .host(true)\n //     .run(move |s| check::docs(build, &s.compiler()));\n-/// Run `rustdoc --test` for all documentation in `src/doc`.\n-///\n-/// This will run all tests in our markdown documentation (e.g. the book)\n-/// located in `src/doc`. The `rustdoc` that's run is the one that sits next to\n-/// `compiler`.\n-pub fn docs(build: &Build, compiler: &Compiler) {\n-    // Do a breadth-first traversal of the `src/doc` directory and just run\n-    // tests for all files that end in `*.md`\n-    let mut stack = vec![build.src.join(\"src/doc\")];\n-    let _time = util::timeit();\n-    let _folder = build.fold_output(|| \"test_docs\");\n-\n-    while let Some(p) = stack.pop() {\n-        if p.is_dir() {\n-            stack.extend(t!(p.read_dir()).map(|p| t!(p).path()));\n-            continue\n-        }\n+impl<'a> Step<'a> for Docs<'a> {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n \n-        if p.extension().and_then(|s| s.to_str()) != Some(\"md\") {\n-            continue;\n-        }\n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"src/doc\")\n+    }\n \n-        // The nostarch directory in the book is for no starch, and so isn't\n-        // guaranteed to build. We don't care if it doesn't build, so skip it.\n-        if p.to_str().map_or(false, |p| p.contains(\"nostarch\")) {\n-            continue;\n-        }\n+    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, _target: &str) {\n+        builder.ensure(Docs {\n+            compiler: builder.compiler(builder.top_stage, host),\n+        });\n+    }\n+\n+    /// Run `rustdoc --test` for all documentation in `src/doc`.\n+    ///\n+    /// This will run all tests in our markdown documentation (e.g. the book)\n+    /// located in `src/doc`. The `rustdoc` that's run is the one that sits next to\n+    /// `compiler`.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = self.compiler;\n+        // Do a breadth-first traversal of the `src/doc` directory and just run\n+        // tests for all files that end in `*.md`\n+        let mut stack = vec![build.src.join(\"src/doc\")];\n+        let _time = util::timeit();\n+        let _folder = build.fold_output(|| \"test_docs\");\n \n-        markdown_test(build, compiler, &p);\n+        while let Some(p) = stack.pop() {\n+            if p.is_dir() {\n+                stack.extend(t!(p.read_dir()).map(|p| t!(p).path()));\n+                continue\n+            }\n+\n+            if p.extension().and_then(|s| s.to_str()) != Some(\"md\") {\n+                continue;\n+            }\n+\n+            // The nostarch directory in the book is for no starch, and so isn't\n+            // guaranteed to build. We don't care if it doesn't build, so skip it.\n+            if p.to_str().map_or(false, |p| p.contains(\"nostarch\")) {\n+                continue;\n+            }\n+\n+            markdown_test(builder, compiler, &p);\n+        }\n     }\n }\n "}, {"sha": "c419f8bb7211b9823140beeed8543cd6779635ad", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 70, "deletions": 23, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/a5ab2ceef8393f94fd1aa07b35bc25f74e9f879f/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ab2ceef8393f94fd1aa07b35bc25f74e9f879f/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=a5ab2ceef8393f94fd1aa07b35bc25f74e9f879f", "patch": "@@ -553,29 +553,76 @@ impl<'a> Step<'a> for DebuggerScripts<'a> {\n //      .dep(move |s| tool_rust_installer(build, s))\n //      .run(move |s| dist::std(build, &s.compiler(), s.target));\n \n-    let name = pkgname(build, \"rust-std\");\n-    let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n-    let _ = fs::remove_dir_all(&image);\n-\n-    let dst = image.join(\"lib/rustlib\").join(target);\n-    t!(fs::create_dir_all(&dst));\n-    let mut src = build.sysroot_libdir(compiler, target);\n-    src.pop(); // Remove the trailing /lib folder from the sysroot_libdir\n-    cp_r(&src, &dst);\n-\n-    let mut cmd = rust_installer(build);\n-    cmd.arg(\"generate\")\n-       .arg(\"--product-name=Rust\")\n-       .arg(\"--rel-manifest-dir=rustlib\")\n-       .arg(\"--success-message=std-is-standing-at-the-ready.\")\n-       .arg(\"--image-dir\").arg(&image)\n-       .arg(\"--work-dir\").arg(&tmpdir(build))\n-       .arg(\"--output-dir\").arg(&distdir(build))\n-       .arg(format!(\"--package-name={}-{}\", name, target))\n-       .arg(format!(\"--component-name=rust-std-{}\", target))\n-       .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-    build.run(&mut cmd);\n-    t!(fs::remove_dir_all(&image));\n+#[derive(Serialize)]\n+pub struct Std<'a> {\n+    pub compiler: Compiler<'a>,\n+    pub target: &'a str,\n+}\n+\n+impl<'a> Step<'a> for Std<'a> {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_BUILD_TARGETS: bool = true;\n+\n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"src/libstd\")\n+    }\n+\n+    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, target: &str) {\n+        builder.ensure(Std {\n+            compiler: builder.compiler(builder.top_stage, host),\n+            target: target,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = self.compiler;\n+        let target = self.target;\n+\n+        println!(\"Dist std stage{} ({} -> {})\", compiler.stage, compiler.host,\n+                 target);\n+\n+        // The only true set of target libraries came from the build triple, so\n+        // let's reduce redundant work by only producing archives from that host.\n+        if compiler.host != build.build {\n+            println!(\"\\tskipping, not a build host\");\n+            return\n+        }\n+\n+        // We want to package up as many target libraries as possible\n+        // for the `rust-std` package, so if this is a host target we\n+        // depend on librustc and otherwise we just depend on libtest.\n+        if build.config.host.iter().any(|t| t == target) {\n+            builder.ensure(compile::Rustc { compiler, target });\n+        } else {\n+            builder.ensure(compile::Test { compiler, target });\n+        }\n+\n+        let name = pkgname(build, \"rust-std\");\n+        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n+        let _ = fs::remove_dir_all(&image);\n+\n+        let dst = image.join(\"lib/rustlib\").join(target);\n+        t!(fs::create_dir_all(&dst));\n+        let mut src = builder.sysroot_libdir(compiler, target);\n+        src.pop(); // Remove the trailing /lib folder from the sysroot_libdir\n+        cp_r(&src, &dst);\n+\n+        let mut cmd = rust_installer(builder);\n+        cmd.arg(\"generate\")\n+           .arg(\"--product-name=Rust\")\n+           .arg(\"--rel-manifest-dir=rustlib\")\n+           .arg(\"--success-message=std-is-standing-at-the-ready.\")\n+           .arg(\"--image-dir\").arg(&image)\n+           .arg(\"--work-dir\").arg(&tmpdir(build))\n+           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(format!(\"--package-name={}-{}\", name, target))\n+           .arg(format!(\"--component-name=rust-std-{}\", target))\n+           .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n+        build.run(&mut cmd);\n+        t!(fs::remove_dir_all(&image));\n+    }\n }\n \n /// The path to the complete rustc-src tarball"}, {"sha": "d7f1570ba80a0933994def5b594ef870a511a1cd", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a5ab2ceef8393f94fd1aa07b35bc25f74e9f879f/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ab2ceef8393f94fd1aa07b35bc25f74e9f879f/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=a5ab2ceef8393f94fd1aa07b35bc25f74e9f879f", "patch": "@@ -114,6 +114,7 @@\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n #![deny(warnings)]\n+#![allow(stable_features)]\n #![feature(associated_consts)]\n #![feature(core_intrinsics)]\n \n@@ -441,19 +442,6 @@ impl Build {\n         self.out.join(compiler.host).join(format!(\"stage{}-incremental\", compiler.stage))\n     }\n \n-    /// Returns the libdir where the standard library and other artifacts are\n-    /// found for a compiler's sysroot.\n-    fn sysroot_libdir(&self, compiler: &Compiler, target: &str) -> PathBuf {\n-        if compiler.stage >= 2 {\n-            if let Some(ref libdir_relative) = self.config.libdir_relative {\n-                return self.sysroot(compiler).join(libdir_relative)\n-                    .join(\"rustlib\").join(target).join(\"lib\")\n-            }\n-        }\n-       self.sysroot(compiler).join(\"lib\").join(\"rustlib\")\n-           .join(target).join(\"lib\")\n-    }\n-\n     /// Returns the root directory for all output generated in a particular\n     /// stage when running with a particular host compiler.\n     ///"}]}