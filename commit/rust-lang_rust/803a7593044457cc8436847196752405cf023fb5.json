{"sha": "803a7593044457cc8436847196752405cf023fb5", "node_id": "C_kwDOAAsO6NoAKDgwM2E3NTkzMDQ0NDU3Y2M4NDM2ODQ3MTk2NzUyNDA1Y2YwMjNmYjU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-08T22:06:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-08T22:06:07Z"}, "message": "Auto merge of #94751 - Dylan-DPC:rollup-zr7viw0, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #94689 (Use impl substs in `#[rustc_on_unimplemented]`)\n - #94714 (Enable `close_read_wakes_up` test on Windows)\n - #94723 (Add core::hint::must_use)\n - #94724 (unix: Avoid name conversions in `remove_dir_all_recursive`)\n - #94730 (Reverted atomic_mut_ptr feature removal causing compilation break)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "444aaffe43b9ee4d51c8cd098602137213d1e4a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/444aaffe43b9ee4d51c8cd098602137213d1e4a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/803a7593044457cc8436847196752405cf023fb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/803a7593044457cc8436847196752405cf023fb5", "html_url": "https://github.com/rust-lang/rust/commit/803a7593044457cc8436847196752405cf023fb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/803a7593044457cc8436847196752405cf023fb5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1eb72580d076935a3e590deb6e5813a5aef3eca4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1eb72580d076935a3e590deb6e5813a5aef3eca4", "html_url": "https://github.com/rust-lang/rust/commit/1eb72580d076935a3e590deb6e5813a5aef3eca4"}, {"sha": "5629026e90f2bd9f345bea1d4834e41f80308d80", "url": "https://api.github.com/repos/rust-lang/rust/commits/5629026e90f2bd9f345bea1d4834e41f80308d80", "html_url": "https://github.com/rust-lang/rust/commit/5629026e90f2bd9f345bea1d4834e41f80308d80"}], "stats": {"total": 315, "additions": 262, "deletions": 53}, "files": [{"sha": "8b0e7794f92ace6b3af4ba94c24d2f41e311cc40", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/803a7593044457cc8436847196752405cf023fb5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803a7593044457cc8436847196752405cf023fb5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=803a7593044457cc8436847196752405cf023fb5", "patch": "@@ -977,7 +977,6 @@ impl<'tcx> TraitRef<'tcx> {\n         substs: SubstsRef<'tcx>,\n     ) -> ty::TraitRef<'tcx> {\n         let defs = tcx.generics_of(trait_id);\n-\n         ty::TraitRef { def_id: trait_id, substs: tcx.intern_substs(&substs[..defs.params.len()]) }\n     }\n }"}, {"sha": "6dfbdace8e2a0f9a76262c2c17a67778578434a8", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/803a7593044457cc8436847196752405cf023fb5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803a7593044457cc8436847196752405cf023fb5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=803a7593044457cc8436847196752405cf023fb5", "patch": "@@ -4,7 +4,7 @@ use super::{\n use crate::infer::InferCtxt;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::subst::Subst;\n+use rustc_middle::ty::subst::{Subst, SubstsRef};\n use rustc_middle::ty::{self, GenericParamDefKind};\n use rustc_span::symbol::sym;\n use std::iter;\n@@ -17,7 +17,7 @@ crate trait InferCtxtExt<'tcx> {\n         &self,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n-    ) -> Option<DefId>;\n+    ) -> Option<(DefId, SubstsRef<'tcx>)>;\n \n     /*private*/\n     fn describe_enclosure(&self, hir_id: hir::HirId) -> Option<&'static str>;\n@@ -34,7 +34,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n-    ) -> Option<DefId> {\n+    ) -> Option<(DefId, SubstsRef<'tcx>)> {\n         let tcx = self.tcx;\n         let param_env = obligation.param_env;\n         let trait_ref = tcx.erase_late_bound_regions(trait_ref);\n@@ -50,28 +50,29 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             let impl_self_ty = impl_trait_ref.self_ty();\n \n             if let Ok(..) = self.can_eq(param_env, trait_self_ty, impl_self_ty) {\n-                self_match_impls.push(def_id);\n+                self_match_impls.push((def_id, impl_substs));\n \n                 if iter::zip(\n                     trait_ref.substs.types().skip(1),\n                     impl_trait_ref.substs.types().skip(1),\n                 )\n                 .all(|(u, v)| self.fuzzy_match_tys(u, v, false).is_some())\n                 {\n-                    fuzzy_match_impls.push(def_id);\n+                    fuzzy_match_impls.push((def_id, impl_substs));\n                 }\n             }\n         });\n \n-        let impl_def_id = if self_match_impls.len() == 1 {\n+        let impl_def_id_and_substs = if self_match_impls.len() == 1 {\n             self_match_impls[0]\n         } else if fuzzy_match_impls.len() == 1 {\n             fuzzy_match_impls[0]\n         } else {\n             return None;\n         };\n \n-        tcx.has_attr(impl_def_id, sym::rustc_on_unimplemented).then_some(impl_def_id)\n+        tcx.has_attr(impl_def_id_and_substs.0, sym::rustc_on_unimplemented)\n+            .then_some(impl_def_id_and_substs)\n     }\n \n     /// Used to set on_unimplemented's `ItemContext`\n@@ -120,8 +121,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         trait_ref: ty::PolyTraitRef<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> OnUnimplementedNote {\n-        let def_id =\n-            self.impl_similar_to(trait_ref, obligation).unwrap_or_else(|| trait_ref.def_id());\n+        let (def_id, substs) = self\n+            .impl_similar_to(trait_ref, obligation)\n+            .unwrap_or_else(|| (trait_ref.def_id(), trait_ref.skip_binder().substs));\n         let trait_ref = trait_ref.skip_binder();\n \n         let mut flags = vec![(\n@@ -176,15 +178,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             for param in generics.params.iter() {\n                 let value = match param.kind {\n                     GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n-                        trait_ref.substs[param.index as usize].to_string()\n+                        substs[param.index as usize].to_string()\n                     }\n                     GenericParamDefKind::Lifetime => continue,\n                 };\n                 let name = param.name;\n                 flags.push((name, Some(value)));\n \n                 if let GenericParamDefKind::Type { .. } = param.kind {\n-                    let param_ty = trait_ref.substs[param.index as usize].expect_ty();\n+                    let param_ty = substs[param.index as usize].expect_ty();\n                     if let Some(def) = param_ty.ty_adt_def() {\n                         // We also want to be able to select the parameter's\n                         // original signature with no type arguments resolved\n@@ -229,9 +231,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         });\n \n-        if let Ok(Some(command)) =\n-            OnUnimplementedDirective::of_item(self.tcx, trait_ref.def_id, def_id)\n-        {\n+        if let Ok(Some(command)) = OnUnimplementedDirective::of_item(self.tcx, def_id) {\n             command.evaluate(self.tcx, trait_ref, &flags)\n         } else {\n             OnUnimplementedNote::default()"}, {"sha": "2f697c1fa27b79e3eb4f7d2a902a9a24f520fb5f", "filename": "compiler/rustc_trait_selection/src/traits/on_unimplemented.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/803a7593044457cc8436847196752405cf023fb5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803a7593044457cc8436847196752405cf023fb5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs?ref=803a7593044457cc8436847196752405cf023fb5", "patch": "@@ -54,7 +54,7 @@ fn parse_error(\n impl<'tcx> OnUnimplementedDirective {\n     fn parse(\n         tcx: TyCtxt<'tcx>,\n-        trait_def_id: DefId,\n+        item_def_id: DefId,\n         items: &[NestedMetaItem],\n         span: Span,\n         is_root: bool,\n@@ -63,7 +63,7 @@ impl<'tcx> OnUnimplementedDirective {\n         let mut item_iter = items.iter();\n \n         let parse_value = |value_str| {\n-            OnUnimplementedFormatString::try_parse(tcx, trait_def_id, value_str, span).map(Some)\n+            OnUnimplementedFormatString::try_parse(tcx, item_def_id, value_str, span).map(Some)\n         };\n \n         let condition = if is_root {\n@@ -135,7 +135,7 @@ impl<'tcx> OnUnimplementedDirective {\n             {\n                 if let Some(items) = item.meta_item_list() {\n                     if let Ok(subcommand) =\n-                        Self::parse(tcx, trait_def_id, &items, item.span(), false)\n+                        Self::parse(tcx, item_def_id, &items, item.span(), false)\n                     {\n                         subcommands.push(subcommand);\n                     } else {\n@@ -178,27 +178,23 @@ impl<'tcx> OnUnimplementedDirective {\n         }\n     }\n \n-    pub fn of_item(\n-        tcx: TyCtxt<'tcx>,\n-        trait_def_id: DefId,\n-        impl_def_id: DefId,\n-    ) -> Result<Option<Self>, ErrorGuaranteed> {\n-        let attrs = tcx.get_attrs(impl_def_id);\n+    pub fn of_item(tcx: TyCtxt<'tcx>, item_def_id: DefId) -> Result<Option<Self>, ErrorGuaranteed> {\n+        let attrs = tcx.get_attrs(item_def_id);\n \n         let Some(attr) = tcx.sess.find_by_name(&attrs, sym::rustc_on_unimplemented) else {\n             return Ok(None);\n         };\n \n         let result = if let Some(items) = attr.meta_item_list() {\n-            Self::parse(tcx, trait_def_id, &items, attr.span, true).map(Some)\n+            Self::parse(tcx, item_def_id, &items, attr.span, true).map(Some)\n         } else if let Some(value) = attr.value_str() {\n             Ok(Some(OnUnimplementedDirective {\n                 condition: None,\n                 message: None,\n                 subcommands: vec![],\n                 label: Some(OnUnimplementedFormatString::try_parse(\n                     tcx,\n-                    trait_def_id,\n+                    item_def_id,\n                     value,\n                     attr.span,\n                 )?),\n@@ -209,7 +205,7 @@ impl<'tcx> OnUnimplementedDirective {\n         } else {\n             return Err(ErrorGuaranteed);\n         };\n-        debug!(\"of_item({:?}/{:?}) = {:?}\", trait_def_id, impl_def_id, result);\n+        debug!(\"of_item({:?}) = {:?}\", item_def_id, result);\n         result\n     }\n \n@@ -280,23 +276,29 @@ impl<'tcx> OnUnimplementedDirective {\n impl<'tcx> OnUnimplementedFormatString {\n     fn try_parse(\n         tcx: TyCtxt<'tcx>,\n-        trait_def_id: DefId,\n+        item_def_id: DefId,\n         from: Symbol,\n         err_sp: Span,\n     ) -> Result<Self, ErrorGuaranteed> {\n         let result = OnUnimplementedFormatString(from);\n-        result.verify(tcx, trait_def_id, err_sp)?;\n+        result.verify(tcx, item_def_id, err_sp)?;\n         Ok(result)\n     }\n \n     fn verify(\n         &self,\n         tcx: TyCtxt<'tcx>,\n-        trait_def_id: DefId,\n+        item_def_id: DefId,\n         span: Span,\n     ) -> Result<(), ErrorGuaranteed> {\n-        let name = tcx.item_name(trait_def_id);\n-        let generics = tcx.generics_of(trait_def_id);\n+        let trait_def_id = if tcx.is_trait(item_def_id) {\n+            item_def_id\n+        } else {\n+            tcx.trait_id_of_impl(item_def_id)\n+                .expect(\"expected `on_unimplemented` to correspond to a trait\")\n+        };\n+        let trait_name = tcx.item_name(trait_def_id);\n+        let generics = tcx.generics_of(item_def_id);\n         let s = self.0.as_str();\n         let parser = Parser::new(s, None, None, false, ParseMode::Format);\n         let mut result = Ok(());\n@@ -307,7 +309,7 @@ impl<'tcx> OnUnimplementedFormatString {\n                     // `{Self}` is allowed\n                     Position::ArgumentNamed(s, _) if s == kw::SelfUpper => (),\n                     // `{ThisTraitsName}` is allowed\n-                    Position::ArgumentNamed(s, _) if s == name => (),\n+                    Position::ArgumentNamed(s, _) if s == trait_name => (),\n                     // `{from_method}` is allowed\n                     Position::ArgumentNamed(s, _) if s == sym::from_method => (),\n                     // `{from_desugaring}` is allowed\n@@ -329,9 +331,13 @@ impl<'tcx> OnUnimplementedFormatString {\n                                     tcx.sess,\n                                     span,\n                                     E0230,\n-                                    \"there is no parameter `{}` on trait `{}`\",\n+                                    \"there is no parameter `{}` on {}\",\n                                     s,\n-                                    name\n+                                    if trait_def_id == item_def_id {\n+                                        format!(\"trait `{}`\", trait_name)\n+                                    } else {\n+                                        \"impl\".to_string()\n+                                    }\n                                 )\n                                 .emit();\n                                 result = Err(ErrorGuaranteed);"}, {"sha": "7c3594175b85508ed4c10ac92fc306d6cbf79d52", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/803a7593044457cc8436847196752405cf023fb5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803a7593044457cc8436847196752405cf023fb5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=803a7593044457cc8436847196752405cf023fb5", "patch": "@@ -742,12 +742,11 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n                     impl_trait_ref,\n                     &impl_.items,\n                 );\n-                let trait_def_id = impl_trait_ref.def_id;\n-                check_on_unimplemented(tcx, trait_def_id, it);\n+                check_on_unimplemented(tcx, it);\n             }\n         }\n         hir::ItemKind::Trait(_, _, _, _, ref items) => {\n-            check_on_unimplemented(tcx, it.def_id.to_def_id(), it);\n+            check_on_unimplemented(tcx, it);\n \n             for item in items.iter() {\n                 let item = tcx.hir().trait_item(item.id);\n@@ -857,9 +856,9 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n     }\n }\n \n-pub(super) fn check_on_unimplemented(tcx: TyCtxt<'_>, trait_def_id: DefId, item: &hir::Item<'_>) {\n+pub(super) fn check_on_unimplemented(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n     // an error would be reported if this fails.\n-    let _ = traits::OnUnimplementedDirective::of_item(tcx, trait_def_id, item.def_id.to_def_id());\n+    let _ = traits::OnUnimplementedDirective::of_item(tcx, item.def_id.to_def_id());\n }\n \n pub(super) fn check_specialization_validity<'tcx>("}, {"sha": "58ea109c735b67afbde616c0d21cb46ce1890ca0", "filename": "library/core/src/hint.rs", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/803a7593044457cc8436847196752405cf023fb5/library%2Fcore%2Fsrc%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803a7593044457cc8436847196752405cf023fb5/library%2Fcore%2Fsrc%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhint.rs?ref=803a7593044457cc8436847196752405cf023fb5", "patch": "@@ -173,3 +173,126 @@ pub fn spin_loop() {\n pub const fn black_box<T>(dummy: T) -> T {\n     crate::intrinsics::black_box(dummy)\n }\n+\n+/// An identity function that causes an `unused_must_use` warning to be\n+/// triggered if the given value is not used (returned, stored in a variable,\n+/// etc) by the caller.\n+///\n+/// This is primarily intended for use in macro-generated code, in which a\n+/// [`#[must_use]` attribute][must_use] either on a type or a function would not\n+/// be convenient.\n+///\n+/// [must_use]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n+///\n+/// # Example\n+///\n+/// ```\n+/// #![feature(hint_must_use)]\n+///\n+/// use core::fmt;\n+///\n+/// pub struct Error(/* ... */);\n+///\n+/// #[macro_export]\n+/// macro_rules! make_error {\n+///     ($($args:expr),*) => {\n+///         core::hint::must_use({\n+///             let error = $crate::make_error(core::format_args!($($args),*));\n+///             error\n+///         })\n+///     };\n+/// }\n+///\n+/// // Implementation detail of make_error! macro.\n+/// #[doc(hidden)]\n+/// pub fn make_error(args: fmt::Arguments<'_>) -> Error {\n+///     Error(/* ... */)\n+/// }\n+///\n+/// fn demo() -> Option<Error> {\n+///     if true {\n+///         // Oops, meant to write `return Some(make_error!(\"...\"));`\n+///         Some(make_error!(\"...\"));\n+///     }\n+///     None\n+/// }\n+/// #\n+/// # // Make rustdoc not wrap the whole snippet in fn main, so that $crate::make_error works\n+/// # fn main() {}\n+/// ```\n+///\n+/// In the above example, we'd like an `unused_must_use` lint to apply to the\n+/// value created by `make_error!`. However, neither `#[must_use]` on a struct\n+/// nor `#[must_use]` on a function is appropriate here, so the macro expands\n+/// using `core::hint::must_use` instead.\n+///\n+/// - We wouldn't want `#[must_use]` on the `struct Error` because that would\n+///   make the following unproblematic code trigger a warning:\n+///\n+///   ```\n+///   # struct Error;\n+///   #\n+///   fn f(arg: &str) -> Result<(), Error>\n+///   # { Ok(()) }\n+///\n+///   #[test]\n+///   fn t() {\n+///       // Assert that `f` returns error if passed an empty string.\n+///       // A value of type `Error` is unused here but that's not a problem.\n+///       f(\"\").unwrap_err();\n+///   }\n+///   ```\n+///\n+/// - Using `#[must_use]` on `fn make_error` can't help because the return value\n+///   *is* used, as the right-hand side of a `let` statement. The `let`\n+///   statement looks useless but is in fact necessary for ensuring that\n+///   temporaries within the `format_args` expansion are not kept alive past the\n+///   creation of the `Error`, as keeping them alive past that point can cause\n+///   autotrait issues in async code:\n+///\n+///   ```\n+///   # #![feature(hint_must_use)]\n+///   #\n+///   # struct Error;\n+///   #\n+///   # macro_rules! make_error {\n+///   #     ($($args:expr),*) => {\n+///   #         core::hint::must_use({\n+///   #             // If `let` isn't used, then `f()` produces a non-Send future.\n+///   #             let error = make_error(core::format_args!($($args),*));\n+///   #             error\n+///   #         })\n+///   #     };\n+///   # }\n+///   #\n+///   # fn make_error(args: core::fmt::Arguments<'_>) -> Error {\n+///   #     Error\n+///   # }\n+///   #\n+///   async fn f() {\n+///       // Using `let` inside the make_error expansion causes temporaries like\n+///       // `unsync()` to drop at the semicolon of that `let` statement, which\n+///       // is prior to the await point. They would otherwise stay around until\n+///       // the semicolon on *this* statement, which is after the await point,\n+///       // and the enclosing Future would not implement Send.\n+///       log(make_error!(\"look: {:p}\", unsync())).await;\n+///   }\n+///\n+///   async fn log(error: Error) {/* ... */}\n+///\n+///   // Returns something without a Sync impl.\n+///   fn unsync() -> *const () {\n+///       0 as *const ()\n+///   }\n+///   #\n+///   # fn test() {\n+///   #     fn assert_send(_: impl Send) {}\n+///   #     assert_send(f());\n+///   # }\n+///   ```\n+#[unstable(feature = \"hint_must_use\", issue = \"94745\")]\n+#[rustc_const_unstable(feature = \"hint_must_use\", issue = \"94745\")]\n+#[must_use] // <-- :)\n+pub const fn must_use<T>(value: T) -> T {\n+    value\n+}"}, {"sha": "c35389d44f9fc927d70d235678e127dbfae0369d", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/803a7593044457cc8436847196752405cf023fb5/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803a7593044457cc8436847196752405cf023fb5/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=803a7593044457cc8436847196752405cf023fb5", "patch": "@@ -231,6 +231,7 @@\n #![feature(assert_matches)]\n #![feature(associated_type_bounds)]\n #![feature(async_iterator)]\n+#![feature(atomic_mut_ptr)]\n #![feature(bench_black_box)]\n #![feature(box_syntax)]\n #![feature(c_unwind)]"}, {"sha": "959fe6943f6ee6d982c28f8466e4748a742df053", "filename": "library/std/src/net/tcp/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/803a7593044457cc8436847196752405cf023fb5/library%2Fstd%2Fsrc%2Fnet%2Ftcp%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803a7593044457cc8436847196752405cf023fb5/library%2Fstd%2Fsrc%2Fnet%2Ftcp%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Ftcp%2Ftests.rs?ref=803a7593044457cc8436847196752405cf023fb5", "patch": "@@ -508,7 +508,6 @@ fn close_readwrite_smoke() {\n }\n \n #[test]\n-#[cfg(unix)] // test doesn't work on Windows, see #31657\n fn close_read_wakes_up() {\n     each_ip(&mut |addr| {\n         let a = t!(TcpListener::bind(&addr));"}, {"sha": "4a48be5cda69598725feecf7dbb769717cdc62a3", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/803a7593044457cc8436847196752405cf023fb5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803a7593044457cc8436847196752405cf023fb5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=803a7593044457cc8436847196752405cf023fb5", "patch": "@@ -1604,17 +1604,15 @@ mod remove_dir_impl {\n         }\n     }\n \n-    fn remove_dir_all_recursive(parent_fd: Option<RawFd>, p: &Path) -> io::Result<()> {\n-        let pcstr = cstr(p)?;\n-\n+    fn remove_dir_all_recursive(parent_fd: Option<RawFd>, path: &CStr) -> io::Result<()> {\n         // try opening as directory\n-        let fd = match openat_nofollow_dironly(parent_fd, &pcstr) {\n+        let fd = match openat_nofollow_dironly(parent_fd, &path) {\n             Err(err) if err.raw_os_error() == Some(libc::ENOTDIR) => {\n                 // not a directory - don't traverse further\n                 return match parent_fd {\n                     // unlink...\n                     Some(parent_fd) => {\n-                        cvt(unsafe { unlinkat(parent_fd, pcstr.as_ptr(), 0) }).map(drop)\n+                        cvt(unsafe { unlinkat(parent_fd, path.as_ptr(), 0) }).map(drop)\n                     }\n                     // ...unless this was supposed to be the deletion root directory\n                     None => Err(err),\n@@ -1627,26 +1625,27 @@ mod remove_dir_impl {\n         let (dir, fd) = fdreaddir(fd)?;\n         for child in dir {\n             let child = child?;\n+            let child_name = child.name_cstr();\n             match is_dir(&child) {\n                 Some(true) => {\n-                    remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n+                    remove_dir_all_recursive(Some(fd), child_name)?;\n                 }\n                 Some(false) => {\n-                    cvt(unsafe { unlinkat(fd, child.name_cstr().as_ptr(), 0) })?;\n+                    cvt(unsafe { unlinkat(fd, child_name.as_ptr(), 0) })?;\n                 }\n                 None => {\n                     // POSIX specifies that calling unlink()/unlinkat(..., 0) on a directory can succeed\n                     // if the process has the appropriate privileges. This however can causing orphaned\n                     // directories requiring an fsck e.g. on Solaris and Illumos. So we try recursing\n                     // into it first instead of trying to unlink() it.\n-                    remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n+                    remove_dir_all_recursive(Some(fd), child_name)?;\n                 }\n             }\n         }\n \n         // unlink the directory after removing its contents\n         cvt(unsafe {\n-            unlinkat(parent_fd.unwrap_or(libc::AT_FDCWD), pcstr.as_ptr(), libc::AT_REMOVEDIR)\n+            unlinkat(parent_fd.unwrap_or(libc::AT_FDCWD), path.as_ptr(), libc::AT_REMOVEDIR)\n         })?;\n         Ok(())\n     }\n@@ -1659,7 +1658,7 @@ mod remove_dir_impl {\n         if attr.file_type().is_symlink() {\n             crate::fs::remove_file(p)\n         } else {\n-            remove_dir_all_recursive(None, p)\n+            remove_dir_all_recursive(None, &cstr(p)?)\n         }\n     }\n "}, {"sha": "0604aab3bcd2cfcda041008fa606bcc9dcff6c71", "filename": "src/test/ui/consts/issue-94675.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/803a7593044457cc8436847196752405cf023fb5/src%2Ftest%2Fui%2Fconsts%2Fissue-94675.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803a7593044457cc8436847196752405cf023fb5/src%2Ftest%2Fui%2Fconsts%2Fissue-94675.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-94675.rs?ref=803a7593044457cc8436847196752405cf023fb5", "patch": "@@ -0,0 +1,16 @@\n+#![feature(const_trait_impl, const_mut_refs)]\n+\n+struct Foo<'a> {\n+    bar: &'a mut Vec<usize>,\n+}\n+\n+impl<'a> Foo<'a> {\n+    const fn spam(&mut self, baz: &mut Vec<u32>) {\n+        self.bar[0] = baz.len();\n+        //~^ ERROR cannot call non-const fn `Vec::<u32>::len` in constant functions\n+        //~| ERROR the trait bound `Vec<usize>: ~const IndexMut<usize>` is not satisfied\n+        //~| ERROR cannot call non-const operator in constant functions\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "6665e42835b7109d39b2eb30b1c8b449756f7faa", "filename": "src/test/ui/consts/issue-94675.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/803a7593044457cc8436847196752405cf023fb5/src%2Ftest%2Fui%2Fconsts%2Fissue-94675.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/803a7593044457cc8436847196752405cf023fb5/src%2Ftest%2Fui%2Fconsts%2Fissue-94675.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-94675.stderr?ref=803a7593044457cc8436847196752405cf023fb5", "patch": "@@ -0,0 +1,38 @@\n+error[E0015]: cannot call non-const fn `Vec::<u32>::len` in constant functions\n+  --> $DIR/issue-94675.rs:9:27\n+   |\n+LL |         self.bar[0] = baz.len();\n+   |                           ^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+\n+error[E0277]: the trait bound `Vec<usize>: ~const IndexMut<usize>` is not satisfied\n+  --> $DIR/issue-94675.rs:9:9\n+   |\n+LL |         self.bar[0] = baz.len();\n+   |         ^^^^^^^^^^^ vector indices are of type `usize` or ranges of `usize`\n+   |\n+   = help: the trait `~const IndexMut<usize>` is not implemented for `Vec<usize>`\n+note: the trait `IndexMut<usize>` is implemented for `Vec<usize>`, but that implementation is not `const`\n+  --> $DIR/issue-94675.rs:9:9\n+   |\n+LL |         self.bar[0] = baz.len();\n+   |         ^^^^^^^^^^^\n+\n+error[E0015]: cannot call non-const operator in constant functions\n+  --> $DIR/issue-94675.rs:9:9\n+   |\n+LL |         self.bar[0] = baz.len();\n+   |         ^^^^^^^^^^^\n+   |\n+note: impl defined here, but it is not `const`\n+  --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n+   |\n+LL | impl<T, I: SliceIndex<[T]>, A: Allocator> IndexMut<I> for Vec<T, A> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0015, E0277.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "26e9e2c8f91cf67409f196878302ee80dfcfa51a", "filename": "src/test/ui/issues/issue-87707.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/803a7593044457cc8436847196752405cf023fb5/src%2Ftest%2Fui%2Fissues%2Fissue-87707.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803a7593044457cc8436847196752405cf023fb5/src%2Ftest%2Fui%2Fissues%2Fissue-87707.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-87707.rs?ref=803a7593044457cc8436847196752405cf023fb5", "patch": "@@ -1,6 +1,7 @@\n // test for #87707\n // edition:2018\n // run-fail\n+// exec-env:RUST_BACKTRACE=0\n // check-run-results\n \n use std::sync::Once;"}, {"sha": "e6c9ea0eb53c39033cca72cfa11f927268799a73", "filename": "src/test/ui/issues/issue-87707.run.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/803a7593044457cc8436847196752405cf023fb5/src%2Ftest%2Fui%2Fissues%2Fissue-87707.run.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/803a7593044457cc8436847196752405cf023fb5/src%2Ftest%2Fui%2Fissues%2Fissue-87707.run.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-87707.run.stderr?ref=803a7593044457cc8436847196752405cf023fb5", "patch": "@@ -1,3 +1,3 @@\n-thread 'main' panicked at 'Here Once instance is poisoned.', $DIR/issue-87707.rs:12:24\n+thread 'main' panicked at 'Here Once instance is poisoned.', $DIR/issue-87707.rs:13:24\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n-thread 'main' panicked at 'Once instance has previously been poisoned', $DIR/issue-87707.rs:14:7\n+thread 'main' panicked at 'Once instance has previously been poisoned', $DIR/issue-87707.rs:15:7"}, {"sha": "fe9c50ec3d4a2cf34e92d3c09e8c50a0659d6e27", "filename": "src/test/ui/on-unimplemented/impl-substs.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/803a7593044457cc8436847196752405cf023fb5/src%2Ftest%2Fui%2Fon-unimplemented%2Fimpl-substs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803a7593044457cc8436847196752405cf023fb5/src%2Ftest%2Fui%2Fon-unimplemented%2Fimpl-substs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fimpl-substs.rs?ref=803a7593044457cc8436847196752405cf023fb5", "patch": "@@ -0,0 +1,15 @@\n+#![feature(rustc_attrs)]\n+\n+trait Foo<A> {\n+    fn foo(self);\n+}\n+\n+#[rustc_on_unimplemented = \"an impl did not match: {A} {B} {C}\"]\n+impl<A, B, C> Foo<A> for (A, B, C) {\n+    fn foo(self) {}\n+}\n+\n+fn main() {\n+    Foo::<usize>::foo((1i32, 1i32, 1i32));\n+    //~^ ERROR the trait bound `(i32, i32, i32): Foo<usize>` is not satisfied\n+}"}, {"sha": "db66ab0bfaec1a61edd1a84bd7779eb5bfc8a133", "filename": "src/test/ui/on-unimplemented/impl-substs.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/803a7593044457cc8436847196752405cf023fb5/src%2Ftest%2Fui%2Fon-unimplemented%2Fimpl-substs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/803a7593044457cc8436847196752405cf023fb5/src%2Ftest%2Fui%2Fon-unimplemented%2Fimpl-substs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fimpl-substs.stderr?ref=803a7593044457cc8436847196752405cf023fb5", "patch": "@@ -0,0 +1,13 @@\n+error[E0277]: the trait bound `(i32, i32, i32): Foo<usize>` is not satisfied\n+  --> $DIR/impl-substs.rs:13:23\n+   |\n+LL |     Foo::<usize>::foo((1i32, 1i32, 1i32));\n+   |     ----------------- ^^^^^^^^^^^^^^^^^^ an impl did not match: usize _ _\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = help: the trait `Foo<usize>` is not implemented for `(i32, i32, i32)`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}