{"sha": "32e30aaa00d098d81fd269d48845cbfd95d20710", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyZTMwYWFhMDBkMDk4ZDgxZmQyNjlkNDg4NDVjYmZkOTVkMjA3MTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-21T01:04:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-21T01:04:39Z"}, "message": "auto merge of #6576 : nikomatsakis/rust/issue-5362-tuple-indices, r=graydon\n\nr? @pcwalton", "tree": {"sha": "1fff0162538f8f39c5a1f574874adc8fe1684923", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fff0162538f8f39c5a1f574874adc8fe1684923"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32e30aaa00d098d81fd269d48845cbfd95d20710", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32e30aaa00d098d81fd269d48845cbfd95d20710", "html_url": "https://github.com/rust-lang/rust/commit/32e30aaa00d098d81fd269d48845cbfd95d20710", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32e30aaa00d098d81fd269d48845cbfd95d20710/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24609675ebeff66f6299e98e4687618a48cf47e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/24609675ebeff66f6299e98e4687618a48cf47e7", "html_url": "https://github.com/rust-lang/rust/commit/24609675ebeff66f6299e98e4687618a48cf47e7"}, {"sha": "5ca383b777d3fd406ff9ded4681d385f0668b2df", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ca383b777d3fd406ff9ded4681d385f0668b2df", "html_url": "https://github.com/rust-lang/rust/commit/5ca383b777d3fd406ff9ded4681d385f0668b2df"}], "stats": {"total": 327, "additions": 246, "deletions": 81}, "files": [{"sha": "67cc99042d76718f970054b8e66e2215de3299f4", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32e30aaa00d098d81fd269d48845cbfd95d20710/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e30aaa00d098d81fd269d48845cbfd95d20710/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=32e30aaa00d098d81fd269d48845cbfd95d20710", "patch": "@@ -343,6 +343,7 @@ pub impl<'self> CheckLoanCtxt<'self> {\n                         cmt = b;\n                     }\n \n+                    mc::cat_downcast(b) |\n                     mc::cat_interior(b, _) => {\n                         if cmt.mutbl == mc::McInherited {\n                             cmt = b;"}, {"sha": "f91fdfe232c23173d2c2645d08be4e24005b9ce2", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32e30aaa00d098d81fd269d48845cbfd95d20710/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e30aaa00d098d81fd269d48845cbfd95d20710/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=32e30aaa00d098d81fd269d48845cbfd95d20710", "patch": "@@ -104,6 +104,7 @@ impl GuaranteeLifetimeContext {\n                 }\n             }\n \n+            mc::cat_downcast(base) |\n             mc::cat_deref(base, _, mc::uniq_ptr(*)) |\n             mc::cat_interior(base, _) => {\n                 self.check(base, discr_scope)\n@@ -302,6 +303,7 @@ impl GuaranteeLifetimeContext {\n             mc::cat_deref(*) => {\n                 false\n             }\n+            r @ mc::cat_downcast(*) |\n             r @ mc::cat_interior(*) |\n             r @ mc::cat_stack_upvar(*) |\n             r @ mc::cat_discr(*) => {\n@@ -339,6 +341,7 @@ impl GuaranteeLifetimeContext {\n             mc::cat_deref(_, _, mc::region_ptr(_, r)) => {\n                 r\n             }\n+            mc::cat_downcast(cmt) |\n             mc::cat_deref(cmt, _, mc::uniq_ptr(*)) |\n             mc::cat_deref(cmt, _, mc::gc_ptr(*)) |\n             mc::cat_interior(cmt, _) |"}, {"sha": "ff6ad87846c7d0475af892d423750476e40cf76b", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/32e30aaa00d098d81fd269d48845cbfd95d20710/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e30aaa00d098d81fd269d48845cbfd95d20710/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=32e30aaa00d098d81fd269d48845cbfd95d20710", "patch": "@@ -79,24 +79,17 @@ impl RestrictionsContext {\n                                           set: restrictions}])\n             }\n \n-            mc::cat_interior(cmt_base, i @ mc::interior_variant(_)) => {\n+            mc::cat_downcast(cmt_base) => {\n                 // When we borrow the interior of an enum, we have to\n                 // ensure the enum itself is not mutated, because that\n                 // could cause the type of the memory to change.\n-                let result = self.compute(cmt_base, restrictions | RESTR_MUTATE);\n-                self.extend(result, cmt.mutbl, LpInterior(i), restrictions)\n+                self.compute(cmt_base, restrictions | RESTR_MUTATE)\n             }\n \n-            mc::cat_interior(cmt_base, i @ mc::interior_tuple) |\n-            mc::cat_interior(cmt_base, i @ mc::interior_anon_field) |\n-            mc::cat_interior(cmt_base, i @ mc::interior_field(*)) |\n-            mc::cat_interior(cmt_base, i @ mc::interior_index(*)) => {\n-                // For all of these cases, overwriting the base would\n-                // not change the type of the memory, so no additional\n-                // restrictions are needed.\n-                //\n-                // FIXME(#5397) --- Mut fields are not treated soundly\n-                //                  (hopefully they will just get phased out)\n+            mc::cat_interior(cmt_base, i) => {\n+                // Overwriting the base would not change the type of\n+                // the memory, so no additional restrictions are\n+                // needed.\n                 let result = self.compute(cmt_base, restrictions);\n                 self.extend(result, cmt.mutbl, LpInterior(i), restrictions)\n             }"}, {"sha": "940a671388b103abc068a06a0066531d41930c44", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/32e30aaa00d098d81fd269d48845cbfd95d20710/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e30aaa00d098d81fd269d48845cbfd95d20710/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=32e30aaa00d098d81fd269d48845cbfd95d20710", "patch": "@@ -232,8 +232,8 @@ pub enum LoanPath {\n \n #[deriving(Eq)]\n pub enum LoanPathElem {\n-    LpDeref,                      // `*LV` in doc.rs\n-    LpInterior(mc::interior_kind) // `LV.f` in doc.rs\n+    LpDeref,                     // `*LV` in doc.rs\n+    LpInterior(mc::InteriorKind) // `LV.f` in doc.rs\n }\n \n pub impl LoanPath {\n@@ -276,6 +276,7 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n                 |&lp| @LpExtend(lp, cmt.mutbl, LpInterior(ik)))\n         }\n \n+        mc::cat_downcast(cmt_base) |\n         mc::cat_stack_upvar(cmt_base) |\n         mc::cat_discr(cmt_base, _) => {\n             opt_loan_path(cmt_base)\n@@ -612,24 +613,25 @@ pub impl BorrowckCtxt {\n                 }\n             }\n \n-            LpExtend(lp_base, _, LpInterior(mc::interior_field(fld))) => {\n+            LpExtend(lp_base, _, LpInterior(mc::InteriorField(fname))) => {\n                 self.append_loan_path_to_str_from_interior(lp_base, out);\n-                str::push_char(out, '.');\n-                str::push_str(out, *self.tcx.sess.intr().get(fld));\n+                match fname {\n+                    mc::NamedField(fname) => {\n+                        str::push_char(out, '.');\n+                        str::push_str(out, *self.tcx.sess.intr().get(fname));\n+                    }\n+                    mc::PositionalField(idx) => {\n+                        str::push_char(out, '#'); // invent a notation here\n+                        str::push_str(out, idx.to_str());\n+                    }\n+                }\n             }\n \n-            LpExtend(lp_base, _, LpInterior(mc::interior_index(*))) => {\n+            LpExtend(lp_base, _, LpInterior(mc::InteriorElement(_))) => {\n                 self.append_loan_path_to_str_from_interior(lp_base, out);\n                 str::push_str(out, \"[]\");\n             }\n \n-            LpExtend(lp_base, _, LpInterior(mc::interior_tuple)) |\n-            LpExtend(lp_base, _, LpInterior(mc::interior_anon_field)) |\n-            LpExtend(lp_base, _, LpInterior(mc::interior_variant(_))) => {\n-                self.append_loan_path_to_str_from_interior(lp_base, out);\n-                str::push_str(out, \".(tuple)\");\n-            }\n-\n             LpExtend(lp_base, _, LpDeref) => {\n                 str::push_char(out, '*');\n                 self.append_loan_path_to_str(lp_base, out);"}, {"sha": "c9ec10ed30aa439058dfae7026048af8399ba272", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 106, "deletions": 55, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/32e30aaa00d098d81fd269d48845cbfd95d20710/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e30aaa00d098d81fd269d48845cbfd95d20710/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=32e30aaa00d098d81fd269d48845cbfd95d20710", "patch": "@@ -66,9 +66,12 @@ pub enum categorization {\n     cat_local(ast::node_id),           // local variable\n     cat_arg(ast::node_id),             // formal argument\n     cat_deref(cmt, uint, ptr_kind),    // deref of a ptr\n-    cat_interior(cmt, interior_kind),  // something interior\n+    cat_interior(cmt, InteriorKind),   // something interior: field, tuple, etc\n+    cat_downcast(cmt),                 // selects a particular enum variant (*)\n     cat_discr(cmt, ast::node_id),      // match discriminant (see preserve())\n     cat_self(ast::node_id),            // explicit `self`\n+\n+    // (*) downcast is only required if the enum has more than one variant\n }\n \n #[deriving(Eq)]\n@@ -89,14 +92,15 @@ pub enum ptr_kind {\n // We use the term \"interior\" to mean \"something reachable from the\n // base without a pointer dereference\", e.g. a field\n #[deriving(Eq)]\n-pub enum interior_kind {\n-    interior_tuple,                  // elt in a tuple\n-    interior_anon_field,             // anonymous field (in e.g.\n-                                     // struct Foo(int, int);\n-    interior_variant(ast::def_id),   // internals to a variant of given enum\n-    interior_field(ast::ident),      // name of field\n-    interior_index(ty::t,            // type of vec/str/etc being deref'd\n-                   ast::mutability)  // mutability of vec content\n+pub enum InteriorKind {\n+    InteriorField(FieldName),\n+    InteriorElement(ty::t),    // ty::t is the type of the vec/str\n+}\n+\n+#[deriving(Eq)]\n+pub enum FieldName {\n+    NamedField(ast::ident),\n+    PositionalField(uint)\n }\n \n #[deriving(Eq)]\n@@ -134,7 +138,10 @@ pub type cmt = @cmt_;\n \n // We pun on *T to mean both actual deref of a ptr as well\n // as accessing of components:\n-pub enum deref_kind {deref_ptr(ptr_kind), deref_interior(interior_kind)}\n+pub enum deref_kind {\n+    deref_ptr(ptr_kind),\n+    deref_interior(InteriorKind),\n+}\n \n // Categorizes a derefable type.  Note that we include vectors and strings as\n // derefable (we model an index as the combination of a deref and then a\n@@ -176,20 +183,14 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n             Some(deref_ptr(unsafe_ptr))\n         }\n \n-        ty::ty_enum(did, _) => {\n-            Some(deref_interior(interior_variant(did)))\n-        }\n-\n-        ty::ty_struct(_, _) => {\n-            Some(deref_interior(interior_anon_field))\n-        }\n-\n-        ty::ty_evec(mt, ty::vstore_fixed(_)) => {\n-            Some(deref_interior(interior_index(t, mt.mutbl)))\n+        ty::ty_enum(*) |\n+        ty::ty_struct(*) => { // newtype\n+            Some(deref_interior(InteriorField(PositionalField(0))))\n         }\n \n+        ty::ty_evec(_, ty::vstore_fixed(_)) |\n         ty::ty_estr(ty::vstore_fixed(_)) => {\n-            Some(deref_interior(interior_index(t, m_imm)))\n+            Some(deref_interior(InteriorElement(t)))\n         }\n \n         _ => None\n@@ -579,7 +580,7 @@ pub impl mem_categorization_ctxt {\n         @cmt_ {\n             id: node.id(),\n             span: node.span(),\n-            cat: cat_interior(base_cmt, interior_field(f_name)),\n+            cat: cat_interior(base_cmt, InteriorField(NamedField(f_name))),\n             mutbl: base_cmt.mutbl.inherit(),\n             ty: f_ty\n         }\n@@ -737,15 +738,16 @@ pub impl mem_categorization_ctxt {\n           }\n         };\n \n-        fn interior<N: ast_node>(elt: N, of_cmt: cmt,\n-                                 vect: ty::t, mutbl: MutabilityCategory,\n+        fn interior<N: ast_node>(elt: N,\n+                                 of_cmt: cmt,\n+                                 vec_ty: ty::t,\n+                                 mutbl: MutabilityCategory,\n                                  mt: ty::mt) -> cmt\n         {\n-            let interior = interior_index(vect, mt.mutbl);\n             @cmt_ {\n                 id:elt.id(),\n                 span:elt.span(),\n-                cat:cat_interior(of_cmt, interior),\n+                cat:cat_interior(of_cmt, InteriorElement(vec_ty)),\n                 mutbl:mutbl,\n                 ty:mt.ty\n             }\n@@ -756,7 +758,7 @@ pub impl mem_categorization_ctxt {\n                                     node: N,\n                                     base_cmt: cmt,\n                                     interior_ty: ty::t,\n-                                    interior: interior_kind) -> cmt {\n+                                    interior: InteriorKind) -> cmt {\n         @cmt_ {\n             id: node.id(),\n             span: node.span(),\n@@ -766,6 +768,19 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n+    fn cat_downcast<N:ast_node>(&self,\n+                                node: N,\n+                                base_cmt: cmt,\n+                                downcast_ty: ty::t) -> cmt {\n+        @cmt_ {\n+            id: node.id(),\n+            span: node.span(),\n+            cat: cat_downcast(base_cmt),\n+            mutbl: base_cmt.mutbl.inherit(),\n+            ty: downcast_ty\n+        }\n+    }\n+\n     fn cat_pattern(&self,\n                    cmt: cmt,\n                    pat: @ast::pat,\n@@ -835,21 +850,34 @@ pub impl mem_categorization_ctxt {\n             match self.tcx.def_map.find(&pat.id) {\n                 Some(&ast::def_variant(enum_did, _)) => {\n                     // variant(x, y, z)\n-                    for subpats.each |&subpat| {\n+\n+                    let downcast_cmt = {\n+                        if ty::enum_is_univariant(tcx, enum_did) {\n+                            cmt // univariant, no downcast needed\n+                        } else {\n+                            self.cat_downcast(pat, cmt, cmt.ty)\n+                        }\n+                    };\n+\n+                    for subpats.eachi |i, &subpat| {\n                         let subpat_ty = self.pat_ty(subpat); // see (*)\n+\n                         let subcmt =\n-                            self.cat_imm_interior(pat, cmt, subpat_ty,\n-                                                  interior_variant(enum_did));\n+                            self.cat_imm_interior(\n+                                pat, downcast_cmt, subpat_ty,\n+                                InteriorField(PositionalField(i)));\n+\n                         self.cat_pattern(subcmt, subpat, op);\n                     }\n                 }\n                 Some(&ast::def_fn(*)) |\n                 Some(&ast::def_struct(*)) => {\n-                    for subpats.each |&subpat| {\n+                    for subpats.eachi |i, &subpat| {\n                         let subpat_ty = self.pat_ty(subpat); // see (*)\n                         let cmt_field =\n-                            self.cat_imm_interior(pat, cmt, subpat_ty,\n-                                                  interior_anon_field);\n+                            self.cat_imm_interior(\n+                                pat, cmt, subpat_ty,\n+                                InteriorField(PositionalField(i)));\n                         self.cat_pattern(cmt_field, subpat, op);\n                     }\n                 }\n@@ -885,10 +913,12 @@ pub impl mem_categorization_ctxt {\n \n           ast::pat_tup(ref subpats) => {\n             // (p1, ..., pN)\n-            for subpats.each |&subpat| {\n+            for subpats.eachi |i, &subpat| {\n                 let subpat_ty = self.pat_ty(subpat); // see (*)\n-                let subcmt = self.cat_imm_interior(pat, cmt, subpat_ty,\n-                                                   interior_tuple);\n+                let subcmt =\n+                    self.cat_imm_interior(\n+                        pat, cmt, subpat_ty,\n+                        InteriorField(PositionalField(i)));\n                 self.cat_pattern(subcmt, subpat, op);\n             }\n           }\n@@ -931,22 +961,37 @@ pub impl mem_categorization_ctxt {\n \n     fn cmt_to_str(&self, cmt: cmt) -> ~str {\n         match cmt.cat {\n-          cat_static_item => ~\"static item\",\n-          cat_implicit_self => ~\"self reference\",\n+          cat_static_item => {\n+              ~\"static item\"\n+          }\n+          cat_implicit_self => {\n+              ~\"self reference\"\n+          }\n           cat_copied_upvar(_) => {\n               ~\"captured outer variable in a heap closure\"\n           }\n-          cat_rvalue => ~\"non-lvalue\",\n-          cat_local(_) => ~\"local variable\",\n-          cat_self(_) => ~\"self value\",\n-          cat_arg(*) => ~\"argument\",\n-          cat_deref(_, _, pk) => fmt!(\"dereference of %s pointer\",\n-                                      ptr_sigil(pk)),\n-          cat_interior(_, interior_field(*)) => ~\"field\",\n-          cat_interior(_, interior_tuple) => ~\"tuple content\",\n-          cat_interior(_, interior_anon_field) => ~\"anonymous field\",\n-          cat_interior(_, interior_variant(_)) => ~\"enum content\",\n-          cat_interior(_, interior_index(t, _)) => {\n+          cat_rvalue => {\n+              ~\"non-lvalue\"\n+          }\n+          cat_local(_) => {\n+              ~\"local variable\"\n+          }\n+          cat_self(_) => {\n+              ~\"self value\"\n+          }\n+          cat_arg(*) => {\n+              ~\"argument\"\n+          }\n+          cat_deref(_, _, pk) => {\n+              fmt!(\"dereference of %s pointer\", ptr_sigil(pk))\n+          }\n+          cat_interior(_, InteriorField(NamedField(_))) => {\n+              ~\"field\"\n+          }\n+          cat_interior(_, InteriorField(PositionalField(_))) => {\n+              ~\"anonymous field\"\n+          }\n+          cat_interior(_, InteriorElement(t)) => {\n             match ty::get(t).sty {\n               ty::ty_evec(*) => ~\"vec content\",\n               ty::ty_estr(*) => ~\"str content\",\n@@ -959,6 +1004,9 @@ pub impl mem_categorization_ctxt {\n           cat_discr(cmt, _) => {\n             self.cmt_to_str(cmt)\n           }\n+          cat_downcast(cmt) => {\n+            self.cmt_to_str(cmt)\n+          }\n         }\n     }\n \n@@ -1027,6 +1075,7 @@ pub impl cmt_ {\n             cat_deref(_, _, region_ptr(*)) => {\n                 self\n             }\n+            cat_downcast(b) |\n             cat_stack_upvar(b) |\n             cat_discr(b, _) |\n             cat_interior(b, _) |\n@@ -1075,6 +1124,7 @@ pub impl cmt_ {\n                 Some(AliasableBorrowed(m))\n             }\n \n+            cat_downcast(b) |\n             cat_stack_upvar(b) |\n             cat_deref(b, _, uniq_ptr(*)) |\n             cat_interior(b, _) |\n@@ -1114,6 +1164,9 @@ impl Repr for categorization {\n                      cmt.cat.repr(tcx),\n                      interior.repr(tcx))\n             }\n+            cat_downcast(cmt) => {\n+                fmt!(\"%s->(enum)\", cmt.cat.repr(tcx))\n+            }\n             cat_stack_upvar(cmt) |\n             cat_discr(cmt, _) => cmt.cat.repr(tcx)\n         }\n@@ -1129,14 +1182,12 @@ pub fn ptr_sigil(ptr: ptr_kind) -> ~str {\n     }\n }\n \n-impl Repr for interior_kind {\n+impl Repr for InteriorKind {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {\n-            interior_field(fld) => copy *tcx.sess.str_of(fld),\n-            interior_index(*) => ~\"[]\",\n-            interior_tuple => ~\"()\",\n-            interior_anon_field => ~\"<anonymous field>\",\n-            interior_variant(_) => ~\"<enum>\"\n+            InteriorField(NamedField(fld)) => copy *tcx.sess.str_of(fld),\n+            InteriorField(PositionalField(i)) => fmt!(\"#%?\", i),\n+            InteriorElement(_) => ~\"[]\",\n         }\n     }\n }"}, {"sha": "45a26068d8285db4da968f0c96a3d79c637b2ae8", "filename": "src/test/compile-fail/borrowck-anon-fields-struct.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/32e30aaa00d098d81fd269d48845cbfd95d20710/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e30aaa00d098d81fd269d48845cbfd95d20710/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-struct.rs?ref=32e30aaa00d098d81fd269d48845cbfd95d20710", "patch": "@@ -0,0 +1,37 @@\n+// Tests that we are able to distinguish when loans borrow different\n+// anonymous fields of an tuple vs the same anonymous field.\n+\n+struct Y(uint, uint);\n+\n+fn distinct_variant() {\n+    let mut y = Y(1, 2);\n+\n+    let a = match y {\n+        Y(ref mut a, _) => a\n+    };\n+\n+    let b = match y {\n+        Y(_, ref mut b) => b\n+    };\n+\n+    *a += 1;\n+    *b += 1;\n+}\n+\n+fn same_variant() {\n+    let mut y = Y(1, 2);\n+\n+    let a = match y {\n+        Y(ref mut a, _) => a\n+    };\n+\n+    let b = match y {\n+        Y(ref mut b, _) => b //~ ERROR cannot borrow\n+    };\n+\n+    *a += 1;\n+    *b += 1;\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "ae02245c97f52629d6a4d688a088cd0bd542fe9d", "filename": "src/test/compile-fail/borrowck-anon-fields-tuple.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/32e30aaa00d098d81fd269d48845cbfd95d20710/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e30aaa00d098d81fd269d48845cbfd95d20710/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-tuple.rs?ref=32e30aaa00d098d81fd269d48845cbfd95d20710", "patch": "@@ -0,0 +1,35 @@\n+// Tests that we are able to distinguish when loans borrow different\n+// anonymous fields of a tuple vs the same anonymous field.\n+\n+fn distinct_variant() {\n+    let mut y = (1, 2);\n+\n+    let a = match y {\n+        (ref mut a, _) => a\n+    };\n+\n+    let b = match y {\n+        (_, ref mut b) => b\n+    };\n+\n+    *a += 1;\n+    *b += 1;\n+}\n+\n+fn same_variant() {\n+    let mut y = (1, 2);\n+\n+    let a = match y {\n+        (ref mut a, _) => a\n+    };\n+\n+    let b = match y {\n+        (ref mut b, _) => b //~ ERROR cannot borrow\n+    };\n+\n+    *a += 1;\n+    *b += 1;\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "3d9738df059ca6c9bbf3488bb83ce4c64846944d", "filename": "src/test/compile-fail/borrowck-anon-fields-variant.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/32e30aaa00d098d81fd269d48845cbfd95d20710/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e30aaa00d098d81fd269d48845cbfd95d20710/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-variant.rs?ref=32e30aaa00d098d81fd269d48845cbfd95d20710", "patch": "@@ -0,0 +1,43 @@\n+// Tests that we are able to distinguish when loans borrow different\n+// anonymous fields of an enum variant vs the same anonymous field.\n+\n+enum Foo {\n+    X, Y(uint, uint)\n+}\n+\n+fn distinct_variant() {\n+    let mut y = Y(1, 2);\n+\n+    let a = match y {\n+      Y(ref mut a, _) => a,\n+      X => fail!()\n+    };\n+\n+    let b = match y {\n+      Y(_, ref mut b) => b,\n+      X => fail!()\n+    };\n+\n+    *a += 1;\n+    *b += 1;\n+}\n+\n+fn same_variant() {\n+    let mut y = Y(1, 2);\n+\n+    let a = match y {\n+      Y(ref mut a, _) => a,\n+      X => fail!()\n+    };\n+\n+    let b = match y {\n+      Y(ref mut b, _) => b, //~ ERROR cannot borrow\n+      X => fail!()\n+    };\n+\n+    *a += 1;\n+    *b += 1;\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}]}