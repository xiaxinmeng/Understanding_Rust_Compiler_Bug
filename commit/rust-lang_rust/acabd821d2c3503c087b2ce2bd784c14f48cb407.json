{"sha": "acabd821d2c3503c087b2ce2bd784c14f48cb407", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjYWJkODIxZDJjMzUwM2MwODdiMmNlMmJkNzg0YzE0ZjQ4Y2I0MDc=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-02-14T19:22:31Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-02-14T19:22:31Z"}, "message": "Merge pull request #1831 from killerswan/str_fixes\n\n(core::str) changes to find / find_bytes", "tree": {"sha": "37a4cc745eb6d2e1da75a5174f1c02c993ee2344", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37a4cc745eb6d2e1da75a5174f1c02c993ee2344"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/acabd821d2c3503c087b2ce2bd784c14f48cb407", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/acabd821d2c3503c087b2ce2bd784c14f48cb407", "html_url": "https://github.com/rust-lang/rust/commit/acabd821d2c3503c087b2ce2bd784c14f48cb407", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/acabd821d2c3503c087b2ce2bd784c14f48cb407/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0cae213801d0c42c999ed9bb122e61db553b4d5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cae213801d0c42c999ed9bb122e61db553b4d5e", "html_url": "https://github.com/rust-lang/rust/commit/0cae213801d0c42c999ed9bb122e61db553b4d5e"}, {"sha": "69834646d2efd2170236b1f8db3a71c77e378c5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/69834646d2efd2170236b1f8db3a71c77e378c5b", "html_url": "https://github.com/rust-lang/rust/commit/69834646d2efd2170236b1f8db3a71c77e378c5b"}], "stats": {"total": 212, "additions": 129, "deletions": 83}, "files": [{"sha": "3d345c1a2508a4cea759c795b5bb9f64c1d8656b", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/acabd821d2c3503c087b2ce2bd784c14f48cb407/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acabd821d2c3503c087b2ce2bd784c14f48cb407/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=acabd821d2c3503c087b2ce2bd784c14f48cb407", "patch": "@@ -568,10 +568,11 @@ fn link_binary(sess: session,\n     // Converts a library file name into a cc -l argument\n     fn unlib(config: @session::config, filename: str) -> str unsafe {\n         let rmlib = fn@(filename: str) -> str {\n+            let found = str::find_bytes(filename, \"lib\");\n             if config.os == session::os_macos ||\n                 (config.os == session::os_linux ||\n                  config.os == session::os_freebsd) &&\n-                str::find(filename, \"lib\") == 0 {\n+                option::is_some(found) && option::get(found) == 0u {\n                 ret str::unsafe::slice_bytes(filename, 3u,\n                                str::len_bytes(filename));\n             } else { ret filename; }"}, {"sha": "62cffd970993136d54da4977033a3512976414df", "filename": "src/comp/driver/driver.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/acabd821d2c3503c087b2ce2bd784c14f48cb407/src%2Fcomp%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acabd821d2c3503c087b2ce2bd784c14f48cb407/src%2Fcomp%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdriver.rs?ref=acabd821d2c3503c087b2ce2bd784c14f48cb407", "patch": "@@ -269,28 +269,28 @@ fn pretty_print_input(sess: session, cfg: ast::crate_cfg, input: str,\n }\n \n fn get_os(triple: str) -> option<session::os> {\n-    ret if str::find(triple, \"win32\") >= 0 ||\n-               str::find(triple, \"mingw32\") >= 0 {\n+    ret if str::contains(triple, \"win32\") ||\n+               str::contains(triple, \"mingw32\") {\n             some(session::os_win32)\n-        } else if str::find(triple, \"darwin\") >= 0 {\n+        } else if str::contains(triple, \"darwin\") {\n             some(session::os_macos)\n-        } else if str::find(triple, \"linux\") >= 0 {\n+        } else if str::contains(triple, \"linux\") {\n             some(session::os_linux)\n-        } else if str::find(triple, \"freebsd\") >= 0 {\n+        } else if str::contains(triple, \"freebsd\") {\n             some(session::os_freebsd)\n         } else { none };\n }\n \n fn get_arch(triple: str) -> option<session::arch> {\n-    ret if str::find(triple, \"i386\") >= 0 || str::find(triple, \"i486\") >= 0 ||\n-               str::find(triple, \"i586\") >= 0 ||\n-               str::find(triple, \"i686\") >= 0 ||\n-               str::find(triple, \"i786\") >= 0 {\n+    ret if str::contains(triple, \"i386\") || str::contains(triple, \"i486\") ||\n+               str::contains(triple, \"i586\") ||\n+               str::contains(triple, \"i686\") ||\n+               str::contains(triple, \"i786\") {\n             some(session::arch_x86)\n-        } else if str::find(triple, \"x86_64\") >= 0 {\n+        } else if str::contains(triple, \"x86_64\") {\n             some(session::arch_x86_64)\n-        } else if str::find(triple, \"arm\") >= 0 ||\n-                      str::find(triple, \"xscale\") >= 0 {\n+        } else if str::contains(triple, \"arm\") ||\n+                      str::contains(triple, \"xscale\") {\n             some(session::arch_arm)\n         } else { none };\n }"}, {"sha": "f6b32e2fd311b3edc6102e85a1b32a91282a13a3", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/acabd821d2c3503c087b2ce2bd784c14f48cb407/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acabd821d2c3503c087b2ce2bd784c14f48cb407/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=acabd821d2c3503c087b2ce2bd784c14f48cb407", "patch": "@@ -24,9 +24,11 @@ fn load_errors(testfile: str) -> [expected_error] {\n \n fn parse_expected(line_num: uint, line: str) -> [expected_error] unsafe {\n     let error_tag = \"//!\";\n-    let idx0 = str::find(line, error_tag);\n-    if idx0 < 0 { ret []; }\n-    let idx = (idx0 as uint) + str::len_bytes(error_tag);\n+    let idx;\n+    alt str::find_bytes(line, error_tag) {\n+         option::none { ret []; }\n+         option::some(nn) { idx = (nn as uint) + str::len_bytes(error_tag); }\n+    }\n \n     // \"//!^^^ kind msg\" denotes a message expected\n     // three lines above current line:"}, {"sha": "a976c5fb98c7c50bf9ec7d215b0544e4f2367460", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/acabd821d2c3503c087b2ce2bd784c14f48cb407/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acabd821d2c3503c087b2ce2bd784c14f48cb407/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=acabd821d2c3503c087b2ce2bd784c14f48cb407", "patch": "@@ -100,18 +100,21 @@ fn parse_pp_exact(line: str, testfile: str) -> option<str> {\n }\n \n fn parse_name_directive(line: str, directive: str) -> bool {\n-    str::find(line, directive) >= 0\n+    str::contains(line, directive)\n }\n \n fn parse_name_value_directive(line: str,\n                               directive: str) -> option<str> unsafe {\n     let keycolon = directive + \":\";\n-    if str::find(line, keycolon) >= 0 {\n-        let colon = str::find(line, keycolon) as uint;\n-        let value =\n-            str::unsafe::slice_bytes(line, colon + str::len_bytes(keycolon),\n-                       str::len_bytes(line));\n-        #debug(\"%s: %s\", directive,  value);\n-        option::some(value)\n-    } else { option::none }\n+    alt str::find_bytes(line, keycolon) {\n+        option::some(colon) {\n+            let value =\n+                str::unsafe::slice_bytes(line,\n+                                         colon + str::len_bytes(keycolon),\n+                                         str::len_bytes(line));\n+            #debug(\"%s: %s\", directive,  value);\n+            option::some(value)\n+        }\n+        option::none { option::none }\n+    }\n }"}, {"sha": "5fb0bca25fa938755617a64607ee581369bef4bb", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acabd821d2c3503c087b2ce2bd784c14f48cb407/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acabd821d2c3503c087b2ce2bd784c14f48cb407/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=acabd821d2c3503c087b2ce2bd784c14f48cb407", "patch": "@@ -199,7 +199,7 @@ fn check_error_patterns(props: test_props,\n     let next_err_idx = 0u;\n     let next_err_pat = props.error_patterns[next_err_idx];\n     for line: str in str::split_byte(procres.stderr, '\\n' as u8) {\n-        if str::find(line, next_err_pat) > 0 {\n+        if str::contains(line, next_err_pat) {\n             #debug(\"found error pattern %s\", next_err_pat);\n             next_err_idx += 1u;\n             if next_err_idx == vec::len(props.error_patterns) {"}, {"sha": "40d218640214fe70202358ee9e88ec8b8e3f56f2", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acabd821d2c3503c087b2ce2bd784c14f48cb407/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acabd821d2c3503c087b2ce2bd784c14f48cb407/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=acabd821d2c3503c087b2ce2bd784c14f48cb407", "patch": "@@ -16,7 +16,7 @@ fn write_file(filename: str, content: str) {\n }\n \n fn contains(haystack: str, needle: str) -> bool {\n-    str::find(haystack, needle) != -1\n+    str::contains(haystack, needle)\n }\n \n fn find_rust_files(&files: [str], path: str) {"}, {"sha": "ed2b52cd9d00a877db44b21c1711d757e84e76e1", "filename": "src/libcore/str.rs", "status": "modified", "additions": 90, "deletions": 50, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/acabd821d2c3503c087b2ce2bd784c14f48cb407/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acabd821d2c3503c087b2ce2bd784c14f48cb407/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=acabd821d2c3503c087b2ce2bd784c14f48cb407", "patch": "@@ -70,6 +70,7 @@ export\n    index,\n    rindex,\n    find,\n+   find_bytes,\n    contains,\n    starts_with,\n    ends_with,\n@@ -661,9 +662,10 @@ fn replace(s: str, from: str, to: str) : is_not_empty(from) -> str unsafe {\n                      unsafe::slice_bytes(s, len_bytes(from), len_bytes(s)),\n                                        from, to);\n     } else {\n-        let idx = find(s, from);\n-        if idx == -1 {\n-            ret s;\n+        let idx;\n+        alt find_bytes(s, from) {\n+            option::some(x) { idx = x; }\n+            option::none { ret s; }\n         }\n         let before = unsafe::slice_bytes(s, 0u, idx as uint);\n         let after  = unsafe::slice_bytes(s, idx as uint + len_bytes(from),\n@@ -872,38 +874,62 @@ fn rindex(ss: str, cc: char) -> option<uint> {\n     ret option::none;\n }\n \n-/*\n-Function: find\n+//Function: find_bytes\n+//\n+// Find the char position of the first instance of one string\n+// within another, or return option::none\n+//\n+// FIXME: Boyer-Moore should be significantly faster\n+fn find_bytes(haystack: str, needle: str) -> option<uint> {\n+    let haystack_len = len_bytes(haystack);\n+    let needle_len   = len_bytes(needle);\n \n-Finds the index of the first matching substring.\n-Returns -1 if `haystack` does not contain `needle`.\n+    if needle_len == 0u { ret option::some(0u); }\n+    if needle_len > haystack_len { ret option::none; }\n \n-Parameters:\n+    fn match_at(haystack: str, needle: str, ii: uint) -> bool {\n+        let jj = ii;\n+        for c: u8 in needle { if haystack[jj] != c { ret false; } jj += 1u; }\n+        ret true;\n+    }\n \n-haystack - The string to look in\n-needle - The string to look for\n+    let ii = 0u;\n+    while ii <= haystack_len - needle_len {\n+        if match_at(haystack, needle, ii) { ret option::some(ii); }\n+        ii += 1u;\n+    }\n \n-Returns:\n+    ret option::none;\n+}\n \n-The index of the first occurance of `needle`, or -1 if not found.\n+// Function: find\n+//\n+// Find the char position of the first instance of one string\n+// within another, or return option::none\n+fn find(haystack: str, needle: str) -> option<uint> {\n+   alt find_bytes(haystack, needle) {\n+      option::none { ret option::none; }\n+      option::some(nn) { ret option::some(b2c_pos(haystack, nn)); }\n+   }\n+}\n \n-FIXME: return an option<char position uint> instead\n-*/\n-fn find(haystack: str, needle: str) -> int {\n-    let haystack_len: int = len_bytes(haystack) as int;\n-    let needle_len: int = len_bytes(needle) as int;\n-    if needle_len == 0 { ret 0; }\n-    fn match_at(haystack: str, needle: str, i: int) -> bool {\n-        let j: int = i;\n-        for c: u8 in needle { if haystack[j] != c { ret false; } j += 1; }\n-        ret true;\n-    }\n-    let i: int = 0;\n-    while i <= haystack_len - needle_len {\n-        if match_at(haystack, needle, i) { ret i; }\n-        i += 1;\n-    }\n-    ret -1;\n+// Function: b2c_pos\n+//\n+// Convert a byte position into a char position\n+// within a given string\n+fn b2c_pos(ss: str, bpos: uint) -> uint {\n+   assert bpos == 0u || bpos < len_bytes(ss);\n+\n+   let ii = 0u;\n+   let cpos = 0u;\n+\n+   while ii < bpos {\n+      let sz = utf8_char_width(ss[ii]);\n+      ii += sz;\n+      cpos += 1u;\n+   }\n+\n+   ret cpos;\n }\n \n /*\n@@ -917,7 +943,7 @@ haystack - The string to look in\n needle - The string to look for\n */\n fn contains(haystack: str, needle: str) -> bool {\n-    0 <= find(haystack, needle)\n+    option::is_some(find_bytes(haystack, needle))\n }\n \n /*\n@@ -930,12 +956,12 @@ Parameters:\n haystack - The string to look in\n needle - The string to look for\n */\n-fn starts_with(haystack: str, needle: str) -> bool {\n-    let haystack_len: uint = len(haystack);\n-    let needle_len: uint = len(needle);\n+fn starts_with(haystack: str, needle: str) -> bool unsafe {\n+    let haystack_len: uint = len_bytes(haystack);\n+    let needle_len: uint = len_bytes(needle);\n     if needle_len == 0u { ret true; }\n     if needle_len > haystack_len { ret false; }\n-    ret eq(substr(haystack, 0u, needle_len), needle);\n+    ret eq(unsafe::slice_bytes(haystack, 0u, needle_len), needle);\n }\n \n /*\n@@ -1694,26 +1720,40 @@ mod tests {\n         assert [] == words(\"\");\n     }\n \n+    #[test]\n+    fn test_find_bytes() {\n+        // byte positions\n+        assert (find_bytes(\"banana\", \"apple pie\") == option::none);\n+        assert (find_bytes(\"\", \"\") == option::some(0u));\n+\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        assert (find_bytes(data, \"\")     == option::some(0u));\n+        assert (find_bytes(data, \"\u0e1b\u0e23\u0e30\u0e40\") == option::some( 0u));\n+        assert (find_bytes(data, \"\u0e30\u0e40\")   == option::some( 6u));\n+        assert (find_bytes(data, \"\u4e2d\u534e\") == option::some(27u));\n+        assert (find_bytes(data, \"\u0e44\u0e17\u534e\") == option::none);\n+    }\n+\n     #[test]\n     fn test_find() {\n-        fn t(haystack: str, needle: str, i: int) {\n-            let j: int = find(haystack, needle);\n-            log(debug, \"searched for \" + needle);\n-            log(debug, j);\n-            assert (i == j);\n-        }\n-        t(\"this is a simple\", \"is a\", 5);\n-        t(\"this is a simple\", \"is z\", -1);\n-        t(\"this is a simple\", \"\", 0);\n-        t(\"this is a simple\", \"simple\", 10);\n-        t(\"this\", \"simple\", -1);\n+        // char positions\n+        assert (find(\"banana\", \"apple pie\") == option::none);\n+        assert (find(\"\", \"\") == option::some(0u));\n \n-        // FIXME: return option<char> position instead\n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert (find(data, \"\u0e1b\u0e23\u0e30\u0e40\") ==  0);\n-        assert (find(data, \"\u0e30\u0e40\")   ==  6); // byte position\n-        assert (find(data, \"\u4e2d\u534e\") ==  27); // byte position\n-        assert (find(data, \"\u0e44\u0e17\u534e\") == -1);\n+        assert (find(data, \"\")     == option::some(0u));\n+        assert (find(data, \"\u0e1b\u0e23\u0e30\u0e40\") == option::some(0u));\n+        assert (find(data, \"\u0e30\u0e40\")   == option::some(2u));\n+        assert (find(data, \"\u4e2d\u534e\") == option::some(9u));\n+        assert (find(data, \"\u0e44\u0e17\u534e\") == option::none);\n+    }\n+\n+    #[test]\n+    fn test_b2c_pos() {\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        assert 0u == b2c_pos(data, 0u);\n+        assert 2u == b2c_pos(data, 6u);\n+        assert 9u == b2c_pos(data, 27u);\n     }\n \n     #[test]"}, {"sha": "5fd4d59f74da4fa1f1573a59c9e2baae6c334bcb", "filename": "src/libstd/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acabd821d2c3503c087b2ce2bd784c14f48cb407/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acabd821d2c3503c087b2ce2bd784c14f48cb407/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=acabd821d2c3503c087b2ce2bd784c14f48cb407", "patch": "@@ -258,7 +258,7 @@ fn filter_tests(opts: test_opts,\n \n         fn filter_fn(test: test_desc, filter_str: str) ->\n             option<test_desc> {\n-            if str::find(test.name, filter_str) >= 0 {\n+            if str::contains(test.name, filter_str) {\n                 ret option::some(test);\n             } else { ret option::none; }\n         }"}, {"sha": "21a7e68cd2087d8116202cbaf9674dd792aa0536", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/acabd821d2c3503c087b2ce2bd784c14f48cb407/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acabd821d2c3503c087b2ce2bd784c14f48cb407/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=acabd821d2c3503c087b2ce2bd784c14f48cb407", "patch": "@@ -56,10 +56,10 @@ fn should_write_modules_last() {\n          fn d() { }\"\n     );\n \n-    let idx_a = str::find(markdown, \"# Module `a`\");\n-    let idx_b = str::find(markdown, \"## Function `b`\");\n-    let idx_c = str::find(markdown, \"# Module `c`\");\n-    let idx_d = str::find(markdown, \"## Function `d`\");\n+    let idx_a = option::get(str::find_bytes(markdown, \"# Module `a`\"));\n+    let idx_b = option::get(str::find_bytes(markdown, \"## Function `b`\"));\n+    let idx_c = option::get(str::find_bytes(markdown, \"# Module `c`\"));\n+    let idx_d = option::get(str::find_bytes(markdown, \"## Function `d`\"));\n \n     assert idx_b < idx_d;\n     assert idx_d < idx_a;\n@@ -854,4 +854,4 @@ mod test {\n         let markdown = render(\"mod morp { }\");\n         assert str::contains(markdown, \"Module `morp`\\n\\n\");\n     }\n-}\n\\ No newline at end of file\n+}"}]}