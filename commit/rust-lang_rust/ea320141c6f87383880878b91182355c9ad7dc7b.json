{"sha": "ea320141c6f87383880878b91182355c9ad7dc7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhMzIwMTQxYzZmODczODM4ODA4NzhiOTExODIzNTVjOWFkN2RjN2I=", "commit": {"author": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2020-09-12T14:14:17Z"}, "committer": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2020-10-02T09:42:39Z"}, "message": "Add postfix completion for format-like string literals", "tree": {"sha": "50e1ee50690c1ecea60caa01d6c6f7fbee983bfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50e1ee50690c1ecea60caa01d6c6f7fbee983bfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea320141c6f87383880878b91182355c9ad7dc7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea320141c6f87383880878b91182355c9ad7dc7b", "html_url": "https://github.com/rust-lang/rust/commit/ea320141c6f87383880878b91182355c9ad7dc7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea320141c6f87383880878b91182355c9ad7dc7b/comments", "author": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c01cd6e3ed0763f8e773c34dc76db0e39396133d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c01cd6e3ed0763f8e773c34dc76db0e39396133d", "html_url": "https://github.com/rust-lang/rust/commit/c01cd6e3ed0763f8e773c34dc76db0e39396133d"}], "stats": {"total": 377, "additions": 376, "deletions": 1}, "files": [{"sha": "73a5f14394e786b34d72e189fa12d6dd833b357e", "filename": "crates/ide/src/completion/complete_postfix.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ea320141c6f87383880878b91182355c9ad7dc7b/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea320141c6f87383880878b91182355c9ad7dc7b/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs?ref=ea320141c6f87383880878b91182355c9ad7dc7b", "patch": "@@ -6,6 +6,7 @@ use syntax::{\n };\n use text_edit::TextEdit;\n \n+use self::format_like::add_format_like_completions;\n use crate::{\n     completion::{\n         completion_config::SnippetCap,\n@@ -15,6 +16,8 @@ use crate::{\n     CompletionItem, CompletionItemKind,\n };\n \n+mod format_like;\n+\n pub(super) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n     if !ctx.config.enable_postfix_completions {\n         return;\n@@ -207,6 +210,10 @@ pub(super) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n         &format!(\"${{1}}({})\", receiver_text),\n     )\n     .add_to(acc);\n+\n+    if ctx.is_string_literal {\n+        add_format_like_completions(acc, ctx, &dot_receiver, cap, &receiver_text);\n+    }\n }\n \n fn get_receiver_text(receiver: &ast::Expr, receiver_is_ambiguous_float_literal: bool) -> String {\n@@ -392,4 +399,53 @@ fn main() {\n         check_edit(\"dbg\", r#\"fn main() { &&42.<|> }\"#, r#\"fn main() { dbg!(&&42) }\"#);\n         check_edit(\"refm\", r#\"fn main() { &&42.<|> }\"#, r#\"fn main() { &&&mut 42 }\"#);\n     }\n+\n+    #[test]\n+    fn postfix_completion_for_format_like_strings() {\n+        check_edit(\n+            \"fmt\",\n+            r#\"fn main() { \"{some_var:?}\".<|> }\"#,\n+            r#\"fn main() { format!(\"{:?}\", some_var) }\"#,\n+        );\n+        check_edit(\n+            \"panic\",\n+            r#\"fn main() { \"Panic with {a}\".<|> }\"#,\n+            r#\"fn main() { panic!(\"Panic with {}\", a) }\"#,\n+        );\n+        check_edit(\n+            \"println\",\n+            r#\"fn main() { \"{ 2+2 } { SomeStruct { val: 1, other: 32 } :?}\".<|> }\"#,\n+            r#\"fn main() { println!(\"{} {:?}\", 2+2, SomeStruct { val: 1, other: 32 }) }\"#,\n+        );\n+        check_edit(\n+            \"loge\",\n+            r#\"fn main() { \"{2+2}\".<|> }\"#,\n+            r#\"fn main() { log::error!(\"{}\", 2+2) }\"#,\n+        );\n+        check_edit(\n+            \"logt\",\n+            r#\"fn main() { \"{2+2}\".<|> }\"#,\n+            r#\"fn main() { log::trace!(\"{}\", 2+2) }\"#,\n+        );\n+        check_edit(\n+            \"logd\",\n+            r#\"fn main() { \"{2+2}\".<|> }\"#,\n+            r#\"fn main() { log::debug!(\"{}\", 2+2) }\"#,\n+        );\n+        check_edit(\n+            \"logi\",\n+            r#\"fn main() { \"{2+2}\".<|> }\"#,\n+            r#\"fn main() { log::info!(\"{}\", 2+2) }\"#,\n+        );\n+        check_edit(\n+            \"logw\",\n+            r#\"fn main() { \"{2+2}\".<|> }\"#,\n+            r#\"fn main() { log::warn!(\"{}\", 2+2) }\"#,\n+        );\n+        check_edit(\n+            \"loge\",\n+            r#\"fn main() { \"{2+2}\".<|> }\"#,\n+            r#\"fn main() { log::error!(\"{}\", 2+2) }\"#,\n+        );\n+    }\n }"}, {"sha": "93211a35f957fe91b2031a5d880916f0a797fc3c", "filename": "crates/ide/src/completion/complete_postfix/format_like.rs", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/ea320141c6f87383880878b91182355c9ad7dc7b/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_postfix%2Fformat_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea320141c6f87383880878b91182355c9ad7dc7b/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_postfix%2Fformat_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_postfix%2Fformat_like.rs?ref=ea320141c6f87383880878b91182355c9ad7dc7b", "patch": "@@ -0,0 +1,310 @@\n+//! Postfix completion for `format`-like strings.\n+//!\n+//! `\"Result {result} is {2 + 2}\"` is expanded to the `\"Result {} is {}\", result, 2 + 2`.\n+//!\n+//! The following postfix snippets are available:\n+//!\n+//! - `format` -> `format!(...)`\n+//! - `println` -> `println!(...)`\n+//! - `log`:\n+//!   + `logd` -> `log::debug!(...)`\n+//!   + `logt` -> `log::trace!(...)`\n+//!   + `logi` -> `log::info!(...)`\n+//!   + `logw` -> `log::warn!(...)`\n+//!   + `loge` -> `log::error!(...)`\n+\n+use super::postfix_snippet;\n+use crate::completion::{\n+    completion_config::SnippetCap, completion_context::CompletionContext,\n+    completion_item::Completions,\n+};\n+use syntax::ast;\n+\n+pub(super) fn add_format_like_completions(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    dot_receiver: &ast::Expr,\n+    cap: SnippetCap,\n+    receiver_text: &str,\n+) {\n+    assert!(receiver_text.len() >= 2);\n+    let input = &receiver_text[1..receiver_text.len() - 1];\n+\n+    let mut parser = FormatStrParser::new(input);\n+\n+    if parser.parse().is_ok() {\n+        for kind in PostfixKind::all_suggestions() {\n+            let snippet = parser.into_suggestion(*kind);\n+            let (label, detail) = kind.into_description();\n+\n+            postfix_snippet(ctx, cap, &dot_receiver, label, detail, &snippet).add_to(acc);\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct FormatStrParser {\n+    input: String,\n+    output: String,\n+    extracted_expressions: Vec<String>,\n+    state: State,\n+    parsed: bool,\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+pub enum PostfixKind {\n+    Format,\n+    Panic,\n+    Println,\n+    LogDebug,\n+    LogTrace,\n+    LogInfo,\n+    LogWarn,\n+    LogError,\n+}\n+\n+impl PostfixKind {\n+    pub fn all_suggestions() -> &'static [PostfixKind] {\n+        &[\n+            Self::Format,\n+            Self::Panic,\n+            Self::Println,\n+            Self::LogDebug,\n+            Self::LogTrace,\n+            Self::LogInfo,\n+            Self::LogWarn,\n+            Self::LogError,\n+        ]\n+    }\n+\n+    pub fn into_description(self) -> (&'static str, &'static str) {\n+        match self {\n+            Self::Format => (\"fmt\", \"format!\"),\n+            Self::Panic => (\"panic\", \"panic!\"),\n+            Self::Println => (\"println\", \"println!\"),\n+            Self::LogDebug => (\"logd\", \"log::debug!\"),\n+            Self::LogTrace => (\"logt\", \"log::trace!\"),\n+            Self::LogInfo => (\"logi\", \"log::info!\"),\n+            Self::LogWarn => (\"logw\", \"log::warn!\"),\n+            Self::LogError => (\"loge\", \"log::error!\"),\n+        }\n+    }\n+\n+    pub fn into_macro_name(self) -> &'static str {\n+        match self {\n+            Self::Format => \"format!\",\n+            Self::Panic => \"panic!\",\n+            Self::Println => \"println!\",\n+            Self::LogDebug => \"log::debug!\",\n+            Self::LogTrace => \"log::trace!\",\n+            Self::LogInfo => \"log::info!\",\n+            Self::LogWarn => \"log::warn!\",\n+            Self::LogError => \"log::error!\",\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq)]\n+enum State {\n+    NotExpr,\n+    MaybeExpr,\n+    Expr,\n+    MaybeIncorrect,\n+    FormatOpts,\n+}\n+\n+impl FormatStrParser {\n+    pub fn new(input: impl Into<String>) -> Self {\n+        Self {\n+            input: input.into(),\n+            output: String::new(),\n+            extracted_expressions: Vec::new(),\n+            state: State::NotExpr,\n+            parsed: false,\n+        }\n+    }\n+\n+    pub fn parse(&mut self) -> Result<(), ()> {\n+        let mut current_expr = String::new();\n+\n+        let mut placeholders_count = 0;\n+\n+        // Count of open braces inside of an expression.\n+        // We assume that user knows what they're doing, thus we treat it like a correct pattern, e.g.\n+        // \"{MyStruct { val_a: 0, val_b: 1 }}\".\n+        let mut inexpr_open_count = 0;\n+\n+        for chr in self.input.chars() {\n+            match (self.state, chr) {\n+                (State::NotExpr, '{') => {\n+                    self.output.push(chr);\n+                    self.state = State::MaybeExpr;\n+                }\n+                (State::NotExpr, '}') => {\n+                    self.output.push(chr);\n+                    self.state = State::MaybeIncorrect;\n+                }\n+                (State::NotExpr, _) => {\n+                    self.output.push(chr);\n+                }\n+                (State::MaybeIncorrect, '}') => {\n+                    // It's okay, we met \"}}\".\n+                    self.output.push(chr);\n+                    self.state = State::NotExpr;\n+                }\n+                (State::MaybeIncorrect, _) => {\n+                    // Error in the string.\n+                    return Err(());\n+                }\n+                (State::MaybeExpr, '{') => {\n+                    self.output.push(chr);\n+                    self.state = State::NotExpr;\n+                }\n+                (State::MaybeExpr, '}') => {\n+                    // This is an empty sequence '{}'. Replace it with placeholder.\n+                    self.output.push(chr);\n+                    self.extracted_expressions.push(format!(\"${}\", placeholders_count));\n+                    placeholders_count += 1;\n+                    self.state = State::NotExpr;\n+                }\n+                (State::MaybeExpr, _) => {\n+                    current_expr.push(chr);\n+                    self.state = State::Expr;\n+                }\n+                (State::Expr, '}') => {\n+                    if inexpr_open_count == 0 {\n+                        self.output.push(chr);\n+                        self.extracted_expressions.push(current_expr.trim().into());\n+                        current_expr = String::new();\n+                        self.state = State::NotExpr;\n+                    } else {\n+                        // We're closing one brace met before inside of the expression.\n+                        current_expr.push(chr);\n+                        inexpr_open_count -= 1;\n+                    }\n+                }\n+                (State::Expr, ':') => {\n+                    if inexpr_open_count == 0 {\n+                        // We're outside of braces, thus assume that it's a specifier, like \"{Some(value):?}\"\n+                        self.output.push(chr);\n+                        self.extracted_expressions.push(current_expr.trim().into());\n+                        current_expr = String::new();\n+                        self.state = State::FormatOpts;\n+                    } else {\n+                        // We're inside of braced expression, assume that it's a struct field name/value delimeter.\n+                        current_expr.push(chr);\n+                    }\n+                }\n+                (State::Expr, '{') => {\n+                    current_expr.push(chr);\n+                    inexpr_open_count += 1;\n+                }\n+                (State::Expr, _) => {\n+                    current_expr.push(chr);\n+                }\n+                (State::FormatOpts, '}') => {\n+                    self.output.push(chr);\n+                    self.state = State::NotExpr;\n+                }\n+                (State::FormatOpts, _) => {\n+                    self.output.push(chr);\n+                }\n+            }\n+        }\n+\n+        if self.state != State::NotExpr {\n+            return Err(());\n+        }\n+\n+        self.parsed = true;\n+        Ok(())\n+    }\n+\n+    pub fn into_suggestion(&self, kind: PostfixKind) -> String {\n+        assert!(self.parsed, \"Attempt to get a suggestion from not parsed expression\");\n+\n+        let mut output = format!(r#\"{}(\"{}\"\"#, kind.into_macro_name(), self.output);\n+        for expr in &self.extracted_expressions {\n+            output += \", \";\n+            output += expr;\n+        }\n+        output.push(')');\n+\n+        output\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn format_str_parser() {\n+        let test_vector = &[\n+            (\"no expressions\", Some((\"no expressions\", vec![]))),\n+            (\"{expr} is {2 + 2}\", Some((\"{} is {}\", vec![\"expr\", \"2 + 2\"]))),\n+            (\"{expr:?}\", Some((\"{:?}\", vec![\"expr\"]))),\n+            (\"{malformed\", None),\n+            (\"malformed}\", None),\n+            (\"{{correct\", Some((\"{{correct\", vec![]))),\n+            (\"correct}}\", Some((\"correct}}\", vec![]))),\n+            (\"{correct}}}\", Some((\"{}}}\", vec![\"correct\"]))),\n+            (\"{correct}}}}}\", Some((\"{}}}}}\", vec![\"correct\"]))),\n+            (\"{incorrect}}\", None),\n+            (\"placeholders {} {}\", Some((\"placeholders {} {}\", vec![\"$0\", \"$1\"]))),\n+            (\"mixed {} {2 + 2} {}\", Some((\"mixed {} {} {}\", vec![\"$0\", \"2 + 2\", \"$1\"]))),\n+            (\n+                \"{SomeStruct { val_a: 0, val_b: 1 }}\",\n+                Some((\"{}\", vec![\"SomeStruct { val_a: 0, val_b: 1 }\"])),\n+            ),\n+            (\"{expr:?} is {2.32f64:.5}\", Some((\"{:?} is {:.5}\", vec![\"expr\", \"2.32f64\"]))),\n+            (\n+                \"{SomeStruct { val_a: 0, val_b: 1 }:?}\",\n+                Some((\"{:?}\", vec![\"SomeStruct { val_a: 0, val_b: 1 }\"])),\n+            ),\n+            (\"{     2 + 2        }\", Some((\"{}\", vec![\"2 + 2\"]))),\n+        ];\n+\n+        for (input, output) in test_vector {\n+            let mut parser = FormatStrParser::new(*input);\n+            let outcome = parser.parse();\n+\n+            if let Some((result_str, result_args)) = output {\n+                assert!(\n+                    outcome.is_ok(),\n+                    \"Outcome is error for input: {}, but the expected outcome is {:?}\",\n+                    input,\n+                    output\n+                );\n+                assert_eq!(parser.output, *result_str);\n+                assert_eq!(&parser.extracted_expressions, result_args);\n+            } else {\n+                assert!(\n+                    outcome.is_err(),\n+                    \"Outcome is OK for input: {}, but the expected outcome is error\",\n+                    input\n+                );\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_into_suggestion() {\n+        let test_vector = &[\n+            (PostfixKind::Println, \"{}\", r#\"println!(\"{}\", $0)\"#),\n+            (\n+                PostfixKind::LogInfo,\n+                \"{} {expr} {} {2 + 2}\",\n+                r#\"log::info!(\"{} {} {} {}\", $0, expr, $1, 2 + 2)\"#,\n+            ),\n+            (PostfixKind::Format, \"{expr:?}\", r#\"format!(\"{:?}\", expr)\"#),\n+        ];\n+\n+        for (kind, input, output) in test_vector {\n+            let mut parser = FormatStrParser::new(*input);\n+            parser.parse().expect(\"Parsing must succeed\");\n+\n+            assert_eq!(&parser.into_suggestion(*kind), output);\n+        }\n+    }\n+}"}, {"sha": "842d1987c32509fcbcb7b58a376790e3a4f70694", "filename": "crates/ide/src/completion/completion_context.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ea320141c6f87383880878b91182355c9ad7dc7b/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea320141c6f87383880878b91182355c9ad7dc7b/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=ea320141c6f87383880878b91182355c9ad7dc7b", "patch": "@@ -74,6 +74,8 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) is_pattern_call: bool,\n     /// If this is a macro call, i.e. the () are already there.\n     pub(super) is_macro_call: bool,\n+    /// If this is a string literal, like \"lorem ipsum\".\n+    pub(super) is_string_literal: bool,\n     pub(super) is_path_type: bool,\n     pub(super) has_type_args: bool,\n     pub(super) attribute_under_caret: Option<ast::Attr>,\n@@ -156,6 +158,7 @@ impl<'a> CompletionContext<'a> {\n             is_call: false,\n             is_pattern_call: false,\n             is_macro_call: false,\n+            is_string_literal: false,\n             is_path_type: false,\n             has_type_args: false,\n             dot_receiver_is_ambiguous_float_literal: false,\n@@ -469,7 +472,13 @@ impl<'a> CompletionContext<'a> {\n                     }\n                 } else {\n                     false\n-                }\n+                };\n+\n+            self.is_string_literal = if let Some(ast::Expr::Literal(l)) = &self.dot_receiver {\n+                matches!(l.kind(), ast::LiteralKind::String { .. })\n+            } else {\n+                false\n+            };\n         }\n         if let Some(method_call_expr) = ast::MethodCallExpr::cast(parent) {\n             // As above"}]}