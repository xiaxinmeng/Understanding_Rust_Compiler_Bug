{"sha": "ced5a701ffd1ba3ff153c811ff81577f28d67785", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlZDVhNzAxZmZkMWJhM2ZmMTUzYzgxMWZmODE1NzdmMjhkNjc3ODU=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-12-01T11:32:51Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-12-13T21:48:15Z"}, "message": "New `ActiveBorrows` dataflow for two-phase `&mut`; not yet borrowed-checked.\n\nHigh-level picture: The old `Borrows` analysis is now called\n`Reservations` (implemented as a newtype wrapper around `Borrows`);\nthis continues to compute whether a `Rvalue::Ref` can reach a\nstatement without an intervening `EndRegion`. In addition, we also\ntrack what `Place` each such `Rvalue::Ref` was immediately assigned\nto in a given borrow (yay for MIR-structural properties!).\n\nThe new `ActiveBorrows` analysis then tracks the initial use of any of\nthose assigned `Places` for a given borrow. I.e. a borrow becomes\n\"active\" immediately after it starts being \"used\" in some way. (This\nis conservative in the sense that we will treat a copy `x = y;` as a\nuse of `y`; in principle one might further delay activation in such\ncases.)\n\nThe new `ActiveBorrows` analysis needs to take the `Reservations`\nresults as an initial input, because the reservation state influences\nthe gen/kill sets for `ActiveBorrows`. In particular, a use of `a`\nactivates a borrow `a = &b` if and only if there exists a path (in the\ncontrol flow graph) from the borrow to that use. So we need to know if\nthe borrow reaches a given use to know if it really gets a gen-bit or\nnot.\n\n * Incorporating the output from one dataflow analysis into the input\n   of another required more changes to the infrastructure than I had\n   expected, and even after those changes, the resulting code is still\n   a bit subtle.\n\n * In particular, Since we need to know the intrablock reservation\n   state, we need to dynamically update a bitvector for the\n   reservations as we are also trying to compute the gen/kills\n   bitvector for the active borrows.\n\n * The way I ended up deciding to do this (after also toying with at\n   least two other designs) is to put both the reservation state and\n   the active borrow state into a single bitvector. That is why we now\n   have separate (but related) `BorrowIndex` and\n   `ReserveOrActivateIndex`: each borrow index maps to a pair of\n   neighboring reservation and activation indexes.\n\nAs noted above, these changes are solely adding the active borrows\ndataflow analysis (and updating the existing code to cope with the\nswitch from `Borrows` to `Reservations`). The code to process the\nbitvector in the borrow checker currently just skips over all of the\nactive borrow bits.\n\nBut atop this commit, one *can* observe the analysis results by\nlooking at the graphviz output, e.g. via\n\n```rust\n #[rustc_mir(borrowck_graphviz_preflow=\"pre_two_phase.dot\",\n             borrowck_graphviz_postflow=\"post_two_phase.dot\")]\n```\n\nIncludes doc for `FindPlaceUses`, as well as `Reservations` and\n`ActiveBorrows` structs, which are wrappers are the `Borrows` struct\nthat dictate which flow analysis should be performed.", "tree": {"sha": "9e47c7a82cac83f3822e8a54748f8c6d3ca4c8b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e47c7a82cac83f3822e8a54748f8c6d3ca4c8b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ced5a701ffd1ba3ff153c811ff81577f28d67785", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ced5a701ffd1ba3ff153c811ff81577f28d67785", "html_url": "https://github.com/rust-lang/rust/commit/ced5a701ffd1ba3ff153c811ff81577f28d67785", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ced5a701ffd1ba3ff153c811ff81577f28d67785/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef64ace8aa16f05968fd46e8ee3eaa3308240d54", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef64ace8aa16f05968fd46e8ee3eaa3308240d54", "html_url": "https://github.com/rust-lang/rust/commit/ef64ace8aa16f05968fd46e8ee3eaa3308240d54"}], "stats": {"total": 703, "additions": 552, "deletions": 151}, "files": [{"sha": "8f07c73b5eecf0ee2381475f0f3644a0abc41570", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ced5a701ffd1ba3ff153c811ff81577f28d67785/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced5a701ffd1ba3ff153c811ff81577f28d67785/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=ced5a701ffd1ba3ff153c811ff81577f28d67785", "patch": "@@ -19,7 +19,7 @@ use std::rc::Rc;\n \n use super::{MirBorrowckCtxt, Context};\n use super::{InitializationRequiringAction, PrefixSet};\n-use dataflow::{BorrowData, Borrows, FlowAtLocation, MovingOutStatements};\n+use dataflow::{ActiveBorrows, BorrowData, FlowAtLocation, MovingOutStatements};\n use dataflow::move_paths::MovePathIndex;\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n@@ -324,10 +324,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         _: Context,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n-        borrows: &Borrows<'cx, 'gcx, 'tcx>\n+        borrows: &ActiveBorrows<'cx, 'gcx, 'tcx>\n     ) {\n         let end_span = borrows.opt_region_end_span(&borrow.region);\n-        let scope_tree = borrows.scope_tree();\n+        let scope_tree = borrows.0.scope_tree();\n         let root_place = self.prefixes(&borrow.borrowed_place, PrefixSet::All).last().unwrap();\n \n         match root_place {"}, {"sha": "69a08c7a30df3daf838d87bf1bb4c41f0b3655aa", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ced5a701ffd1ba3ff153c811ff81577f28d67785/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced5a701ffd1ba3ff153c811ff81577f28d67785/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=ced5a701ffd1ba3ff153c811ff81577f28d67785", "patch": "@@ -17,13 +17,13 @@ use rustc::mir::{BasicBlock, Location};\n \n use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use dataflow::{EverInitializedLvals, MovingOutStatements};\n-use dataflow::{Borrows, FlowAtLocation, FlowsAtLocation};\n+use dataflow::{ActiveBorrows, FlowAtLocation, FlowsAtLocation};\n use dataflow::move_paths::HasMoveData;\n use std::fmt;\n \n // (forced to be `pub` due to its use as an associated type below.)\n-pub struct Flows<'b, 'gcx: 'tcx, 'tcx: 'b> {\n-    pub borrows: FlowAtLocation<Borrows<'b, 'gcx, 'tcx>>,\n+pub(crate) struct Flows<'b, 'gcx: 'tcx, 'tcx: 'b> {\n+    pub borrows: FlowAtLocation<ActiveBorrows<'b, 'gcx, 'tcx>>,\n     pub inits: FlowAtLocation<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n     pub uninits: FlowAtLocation<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n     pub move_outs: FlowAtLocation<MovingOutStatements<'b, 'gcx, 'tcx>>,\n@@ -32,7 +32,7 @@ pub struct Flows<'b, 'gcx: 'tcx, 'tcx: 'b> {\n \n impl<'b, 'gcx, 'tcx> Flows<'b, 'gcx, 'tcx> {\n     pub fn new(\n-        borrows: FlowAtLocation<Borrows<'b, 'gcx, 'tcx>>,\n+        borrows: FlowAtLocation<ActiveBorrows<'b, 'gcx, 'tcx>>,\n         inits: FlowAtLocation<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n         uninits: FlowAtLocation<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n         move_outs: FlowAtLocation<MovingOutStatements<'b, 'gcx, 'tcx>>,\n@@ -87,7 +87,7 @@ impl<'b, 'gcx, 'tcx> fmt::Display for Flows<'b, 'gcx, 'tcx> {\n                 s.push_str(\", \");\n             };\n             saw_one = true;\n-            let borrow_data = &self.borrows.operator().borrows()[borrow];\n+            let borrow_data = &self.borrows.operator().borrows()[borrow.borrow_index()];\n             s.push_str(&format!(\"{}\", borrow_data));\n         });\n         s.push_str(\"] \");\n@@ -99,7 +99,7 @@ impl<'b, 'gcx, 'tcx> fmt::Display for Flows<'b, 'gcx, 'tcx> {\n                 s.push_str(\", \");\n             };\n             saw_one = true;\n-            let borrow_data = &self.borrows.operator().borrows()[borrow];\n+            let borrow_data = &self.borrows.operator().borrows()[borrow.borrow_index()];\n             s.push_str(&format!(\"{}\", borrow_data));\n         });\n         s.push_str(\"] \");"}, {"sha": "0be250eb96ce8d8c3680fa48e225e55ee5662e63", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 52, "deletions": 24, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ced5a701ffd1ba3ff153c811ff81577f28d67785/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced5a701ffd1ba3ff153c811ff81577f28d67785/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=ced5a701ffd1ba3ff153c811ff81577f28d67785", "patch": "@@ -30,11 +30,12 @@ use syntax_pos::Span;\n \n use dataflow::{do_dataflow, DebugFormatted};\n use dataflow::MoveDataParamEnv;\n-use dataflow::DataflowResultsConsumer;\n+use dataflow::{DataflowAnalysis, DataflowResultsConsumer};\n use dataflow::{FlowAtLocation, FlowsAtLocation};\n use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use dataflow::{EverInitializedLvals, MovingOutStatements};\n-use dataflow::{BorrowData, BorrowIndex, Borrows};\n+use dataflow::{Borrows, BorrowData, ReserveOrActivateIndex};\n+use dataflow::{ActiveBorrows, Reservations};\n use dataflow::move_paths::{IllegalMoveOriginKind, MoveError};\n use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MovePathIndex};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n@@ -48,6 +49,9 @@ use self::MutateMode::{JustWrite, WriteAndRead};\n mod error_reporting;\n mod flows;\n mod prefixes;\n+\n+use std::borrow::Cow;\n+\n pub(crate) mod nll;\n \n pub fn provide(providers: &mut Providers) {\n@@ -205,23 +209,6 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     };\n     let flow_inits = flow_inits; // remove mut\n \n-    let flow_borrows = FlowAtLocation::new(do_dataflow(\n-        tcx,\n-        mir,\n-        id,\n-        &attributes,\n-        &dead_unwinds,\n-        Borrows::new(tcx, mir, opt_regioncx, def_id, body_id),\n-        |bd, i| DebugFormatted::new(bd.location(i)),\n-    ));\n-\n-    let mut state = Flows::new(\n-        flow_borrows,\n-        flow_inits,\n-        flow_uninits,\n-        flow_move_outs,\n-        flow_ever_inits,\n-    );\n     let mut mbcx = MirBorrowckCtxt {\n         tcx: tcx,\n         mir: mir,\n@@ -237,6 +224,44 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         storage_dead_or_drop_error_reported_s: FxHashSet(),\n     };\n \n+    let borrows = Borrows::new(tcx, mir, opt_regioncx, def_id, body_id);\n+    let flow_reservations = do_dataflow(\n+        tcx,\n+        mir,\n+        id,\n+        &attributes,\n+        &dead_unwinds,\n+        Reservations::new(borrows),\n+        |rs, i| {\n+            // In principle we could make the dataflow ensure that\n+            // only reservation bits show up, and assert so here.\n+            //\n+            // In practice it is easier to be looser; in particular,\n+            // it is okay for the kill-sets to hold activation bits.\n+            DebugFormatted::new(&(i.kind(), rs.location(i)))\n+        });\n+    let flow_active_borrows = {\n+        let reservations_on_entry = flow_reservations.0.sets.entry_set_state();\n+        let reservations = flow_reservations.0.operator;\n+        let a = DataflowAnalysis::new_with_entry_sets(mir,\n+                                                      &dead_unwinds,\n+                                                      Cow::Borrowed(reservations_on_entry),\n+                                                      ActiveBorrows::new(reservations));\n+        let results = a.run(tcx,\n+                            id,\n+                            &attributes,\n+                            |ab, i| DebugFormatted::new(&(i.kind(), ab.location(i))));\n+        FlowAtLocation::new(results)\n+    };\n+\n+    let mut state = Flows::new(\n+        flow_active_borrows,\n+        flow_inits,\n+        flow_uninits,\n+        flow_move_outs,\n+        flow_ever_inits,\n+    );\n+\n     mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n \n     opt_closure_req\n@@ -504,9 +529,8 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 let data = domain.borrows();\n                 flow_state.borrows.with_elems_outgoing(|borrows| {\n                     for i in borrows {\n-                        let borrow = &data[i];\n+                        let borrow = &data[i.borrow_index()];\n                         let context = ContextKind::StorageDead.new(loc);\n-\n                         self.check_for_invalidation_at_exit(context, borrow, span, flow_state);\n                     }\n                 });\n@@ -721,7 +745,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         WriteKind::StorageDeadOrDrop => {\n                             error_reported = true;\n                             this.report_borrowed_value_does_not_live_long_enough(\n-                                context, borrow, place_span.1, flow_state.borrows.operator());\n+                                context, borrow, place_span.1,\n+                                flow_state.borrows.operator());\n                         }\n                         WriteKind::Mutate => {\n                             error_reported = true;\n@@ -1778,7 +1803,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n         mut op: F,\n     ) where\n-        F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>) -> Control,\n+        F: FnMut(&mut Self, ReserveOrActivateIndex, &BorrowData<'tcx>) -> Control,\n     {\n         let (access, place) = access_place;\n \n@@ -1790,7 +1815,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // check for loan restricting path P being used. Accounts for\n         // borrows of P, P.a.b, etc.\n         for i in flow_state.borrows.elems_incoming() {\n-            let borrowed = &data[i];\n+            // FIXME for now, just skip the activation state.\n+            if i.is_activation() { continue }\n+\n+            let borrowed = &data[i.borrow_index()];\n \n             if self.places_conflict(&borrowed.borrowed_place, place, access) {\n                 let ctrl = op(self, i, borrowed);"}, {"sha": "fefb378fc753e876e5b73f3906b17c196cb69a8a", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ced5a701ffd1ba3ff153c811ff81577f28d67785/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced5a701ffd1ba3ff153c811ff81577f28d67785/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=ced5a701ffd1ba3ff153c811ff81577f28d67785", "patch": "@@ -121,9 +121,8 @@ impl<BD> FlowsAtLocation for FlowAtLocation<BD>\n     fn reconstruct_statement_effect(&mut self, loc: Location) {\n         self.stmt_gen.reset_to_empty();\n         self.stmt_kill.reset_to_empty();\n-        let mut ignored = IdxSetBuf::new_empty(0);\n         let mut sets = BlockSets {\n-            on_entry: &mut ignored,\n+            on_entry: &mut self.curr_state,\n             gen_set: &mut self.stmt_gen,\n             kill_set: &mut self.stmt_kill,\n         };\n@@ -135,9 +134,8 @@ impl<BD> FlowsAtLocation for FlowAtLocation<BD>\n     fn reconstruct_terminator_effect(&mut self, loc: Location) {\n         self.stmt_gen.reset_to_empty();\n         self.stmt_kill.reset_to_empty();\n-        let mut ignored = IdxSetBuf::new_empty(0);\n         let mut sets = BlockSets {\n-            on_entry: &mut ignored,\n+            on_entry: &mut self.curr_state,\n             gen_set: &mut self.stmt_gen,\n             kill_set: &mut self.stmt_kill,\n         };"}, {"sha": "abfc3159cff84adeead06c1a290e11eaf475e134", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 394, "deletions": 64, "changes": 458, "blob_url": "https://github.com/rust-lang/rust/blob/ced5a701ffd1ba3ff153c811ff81577f28d67785/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced5a701ffd1ba3ff153c811ff81577f28d67785/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=ced5a701ffd1ba3ff153c811ff81577f28d67785", "patch": "@@ -11,25 +11,26 @@\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::middle::region;\n-use rustc::mir::{self, Location, Mir};\n-use rustc::mir::visit::Visitor;\n+use rustc::mir::{self, Location, Place, Mir};\n+use rustc::mir::visit::{PlaceContext, Visitor};\n use rustc::ty::{self, Region, TyCtxt};\n use rustc::ty::RegionKind;\n use rustc::ty::RegionKind::ReScope;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n use rustc_data_structures::bitslice::{BitwiseOperator};\n use rustc_data_structures::indexed_set::{IdxSet};\n-use rustc_data_structures::indexed_vec::{IndexVec};\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n use dataflow::{BitDenotation, BlockSets, InitialFlow};\n-pub use dataflow::indexes::BorrowIndex;\n+pub use dataflow::indexes::{BorrowIndex, ReserveOrActivateIndex};\n use borrow_check::nll::region_infer::RegionInferenceContext;\n use borrow_check::nll::ToRegionVid;\n \n use syntax_pos::Span;\n \n use std::fmt;\n+use std::hash::Hash;\n use std::rc::Rc;\n \n // `Borrows` maps each dataflow bit to an `Rvalue::Ref`, which can be\n@@ -42,12 +43,47 @@ pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     root_scope: Option<region::Scope>,\n     borrows: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n     location_map: FxHashMap<Location, BorrowIndex>,\n+    assigned_map: FxHashMap<Place<'tcx>, FxHashSet<BorrowIndex>>,\n     region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n     local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n     region_span_map: FxHashMap<RegionKind, Span>,\n     nonlexical_regioncx: Option<RegionInferenceContext<'tcx>>,\n }\n \n+// Two-phase borrows actually requires two flow analyses; they need\n+// to be separate because the final results of the first are used to\n+// construct the gen+kill sets for the second. (The dataflow system\n+// is not designed to allow the gen/kill sets to change during the\n+// fixed-point iteration.)\n+\n+/// The `Reservations` analysis is the first of the two flow analyses\n+/// tracking (phased) borrows. It computes where a borrow is reserved;\n+/// i.e. where it can reach in the control flow starting from its\n+/// initial `assigned = &'rgn borrowed` statement, and ending\n+/// whereever `'rgn` itself ends.\n+pub(crate) struct Reservations<'a, 'gcx: 'tcx, 'tcx: 'a>(pub(crate) Borrows<'a, 'gcx, 'tcx>);\n+\n+/// The `ActiveBorrows` analysis is the second of the two flow\n+/// analyses tracking (phased) borrows. It computes where any given\n+/// borrow `&assigned = &'rgn borrowed` is *active*, which starts at\n+/// the first use of `assigned` after the reservation has started, and\n+/// ends whereever `'rgn` itself ends.\n+pub(crate) struct ActiveBorrows<'a, 'gcx: 'tcx, 'tcx: 'a>(pub(crate) Borrows<'a, 'gcx, 'tcx>);\n+\n+impl<'a, 'gcx, 'tcx> Reservations<'a, 'gcx, 'tcx> {\n+    pub(crate) fn new(b: Borrows<'a, 'gcx, 'tcx>) -> Self { Reservations(b) }\n+    pub(crate) fn location(&self, idx: ReserveOrActivateIndex) -> &Location {\n+        self.0.location(idx.borrow_index())\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> ActiveBorrows<'a, 'gcx, 'tcx> {\n+    pub(crate) fn new(r: Reservations<'a, 'gcx, 'tcx>) -> Self { ActiveBorrows(r.0) }\n+    pub(crate) fn location(&self, idx: ReserveOrActivateIndex) -> &Location {\n+        self.0.location(idx.borrow_index())\n+    }\n+}\n+\n // temporarily allow some dead fields: `kind` and `region` will be\n // needed by borrowck; `borrowed_place` will probably be a MovePathIndex when\n // that is extended to include borrowed data paths.\n@@ -58,6 +94,7 @@ pub struct BorrowData<'tcx> {\n     pub(crate) kind: mir::BorrowKind,\n     pub(crate) region: Region<'tcx>,\n     pub(crate) borrowed_place: mir::Place<'tcx>,\n+    pub(crate) assigned_place: mir::Place<'tcx>,\n }\n \n impl<'tcx> fmt::Display for BorrowData<'tcx> {\n@@ -73,6 +110,21 @@ impl<'tcx> fmt::Display for BorrowData<'tcx> {\n     }\n }\n \n+impl ReserveOrActivateIndex {\n+    fn reserved(i: BorrowIndex) -> Self { ReserveOrActivateIndex::new((i.index() * 2)) }\n+    fn active(i: BorrowIndex) -> Self { ReserveOrActivateIndex::new((i.index() * 2) + 1) }\n+\n+    pub(crate) fn is_reservation(self) -> bool { self.index() % 2 == 0 }\n+    pub(crate) fn is_activation(self) -> bool { self.index() % 2 == 1}\n+\n+    pub(crate) fn kind(self) -> &'static str {\n+        if self.is_reservation() { \"reserved\" } else { \"active\" }\n+    }\n+    pub(crate) fn borrow_index(self) -> BorrowIndex {\n+        BorrowIndex::new(self.index() / 2)\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n@@ -89,6 +141,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             mir,\n             idx_vec: IndexVec::new(),\n             location_map: FxHashMap(),\n+            assigned_map: FxHashMap(),\n             region_map: FxHashMap(),\n             local_map: FxHashMap(),\n             region_span_map: FxHashMap()\n@@ -100,6 +153,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                          scope_tree,\n                          root_scope,\n                          location_map: visitor.location_map,\n+                         assigned_map: visitor.assigned_map,\n                          region_map: visitor.region_map,\n                          local_map: visitor.local_map,\n                          region_span_map: visitor.region_span_map,\n@@ -110,13 +164,16 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             mir: &'a Mir<'tcx>,\n             idx_vec: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n             location_map: FxHashMap<Location, BorrowIndex>,\n+            assigned_map: FxHashMap<Place<'tcx>, FxHashSet<BorrowIndex>>,\n             region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n             local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n             region_span_map: FxHashMap<RegionKind, Span>,\n         }\n \n         impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n-            fn visit_rvalue(&mut self,\n+            fn visit_assign(&mut self,\n+                            block: mir::BasicBlock,\n+                            assigned_place: &mir::Place<'tcx>,\n                             rvalue: &mir::Rvalue<'tcx>,\n                             location: mir::Location) {\n                 fn root_local(mut p: &mir::Place<'_>) -> Option<mir::Local> {\n@@ -127,23 +184,59 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                     }}\n                 }\n \n-                if let mir::Rvalue::Ref(region, kind, ref place) = *rvalue {\n-                    if is_unsafe_place(self.tcx, self.mir, place) { return; }\n+                if let mir::Rvalue::Ref(region, kind, ref borrowed_place) = *rvalue {\n+                    if is_unsafe_place(self.tcx, self.mir, borrowed_place) { return; }\n \n                     let borrow = BorrowData {\n-                        location, kind, region, borrowed_place: place.clone(),\n+                        location, kind, region,\n+                        borrowed_place: borrowed_place.clone(),\n+                        assigned_place: assigned_place.clone(),\n                     };\n                     let idx = self.idx_vec.push(borrow);\n                     self.location_map.insert(location, idx);\n \n-                    let borrows = self.region_map.entry(region).or_insert(FxHashSet());\n-                    borrows.insert(idx);\n+                    insert(&mut self.assigned_map, assigned_place, idx);\n+                    insert(&mut self.region_map, &region, idx);\n+                    if let Some(local) = root_local(borrowed_place) {\n+                        insert(&mut self.local_map, &local, idx);\n+                    }\n+                }\n+\n+                return self.super_assign(block, assigned_place, rvalue, location);\n \n-                    if let Some(local) = root_local(place) {\n-                        let borrows = self.local_map.entry(local).or_insert(FxHashSet());\n-                        borrows.insert(idx);\n+                fn insert<'a, K, V>(map: &'a mut FxHashMap<K, FxHashSet<V>>,\n+                                    k: &K,\n+                                    v: V)\n+                    where K: Clone+Eq+Hash, V: Eq+Hash\n+                {\n+                    map.entry(k.clone())\n+                        .or_insert(FxHashSet())\n+                        .insert(v);\n+                }\n+            }\n+\n+            fn visit_rvalue(&mut self,\n+                            rvalue: &mir::Rvalue<'tcx>,\n+                            location: mir::Location) {\n+                if let mir::Rvalue::Ref(region, kind, ref place) = *rvalue {\n+                    // double-check that we already registered a BorrowData for this\n+\n+                    let mut found_it = false;\n+                    for idx in &self.region_map[region] {\n+                        let bd = &self.idx_vec[*idx];\n+                        if bd.location == location &&\n+                            bd.kind == kind &&\n+                            bd.region == region &&\n+                            bd.borrowed_place == *place\n+                        {\n+                            found_it = true;\n+                            break;\n+                        }\n                     }\n+                    assert!(found_it, \"Ref {:?} at {:?} missing BorrowData\", rvalue, location);\n                 }\n+\n+                return self.super_rvalue(rvalue, location);\n             }\n \n             fn visit_statement(&mut self,\n@@ -153,7 +246,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                 if let mir::StatementKind::EndRegion(region_scope) = statement.kind {\n                     self.region_span_map.insert(ReScope(region_scope), statement.source_info.span);\n                 }\n-                self.super_statement(block, statement, location);\n+                return self.super_statement(block, statement, location);\n             }\n         }\n     }\n@@ -166,26 +259,19 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n         &self.borrows[idx].location\n     }\n \n-    /// Returns the span for the \"end point\" given region. This will\n-    /// return `None` if NLL is enabled, since that concept has no\n-    /// meaning there.  Otherwise, return region span if it exists and\n-    /// span for end of the function if it doesn't exist.\n-    pub fn opt_region_end_span(&self, region: &Region) -> Option<Span> {\n-        match self.nonlexical_regioncx {\n-            Some(_) => None,\n-            None => {\n-                match self.region_span_map.get(region) {\n-                    Some(span) => Some(span.end_point()),\n-                    None => Some(self.mir.span.end_point())\n-                }\n-            }\n-        }\n-    }\n-\n     /// Add all borrows to the kill set, if those borrows are out of scope at `location`.\n+    ///\n+    /// `is_activations` tracks whether we are in the Reservations or\n+    /// the ActiveBorrows flow analysis, and does not set the\n+    /// activation kill bits in the former case. (Technically, we\n+    /// could set those kill bits without such a guard, since they are\n+    /// never gen'ed by Reservations in the first place.  But it makes\n+    /// the instrumentation and graph renderings nicer to leave\n+    /// activations out when of the Reservations kill sets.)\n     fn kill_loans_out_of_scope_at_location(&self,\n-                                           sets: &mut BlockSets<BorrowIndex>,\n-                                           location: Location) {\n+                                           sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                                           location: Location,\n+                                           is_activations: bool) {\n         if let Some(ref regioncx) = self.nonlexical_regioncx {\n             for (borrow_index, borrow_data) in self.borrows.iter_enumerated() {\n                 let borrow_region = borrow_data.region.to_region_vid();\n@@ -201,45 +287,74 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                     // mismatch here by not generating a kill for the\n                     // location on the borrow itself.\n                     if location != borrow_data.location {\n-                        sets.kill(&borrow_index);\n+                        sets.kill(&ReserveOrActivateIndex::reserved(borrow_index));\n+                    }\n+\n+                    // FIXME: the logic used to justify the above\n+                    // \"accounting for mismatch\" does not generalize\n+                    // to activations, so we set the kill-bits without\n+                    // that same location check here.\n+                    //\n+                    // But... can we get into a situation where the\n+                    // gen/kill bits are both sets in this case, in\n+                    // which case we *do* need an analogous guard of\n+                    // some kind?\n+                    if is_activations {\n+                        sets.kill(&ReserveOrActivateIndex::active(borrow_index));\n                     }\n                 }\n             }\n         }\n     }\n-}\n \n-impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n-    type Idx = BorrowIndex;\n-    fn name() -> &'static str { \"borrows\" }\n-    fn bits_per_block(&self) -> usize {\n-        self.borrows.len()\n-    }\n-    fn start_block_effect(&self, _sets: &mut IdxSet<BorrowIndex>)  {\n-        // no borrows of code region_scopes have been taken prior to\n-        // function execution, so this method has no effect on\n-        // `_sets`.\n-    }\n-    fn statement_effect(&self,\n-                        sets: &mut BlockSets<BorrowIndex>,\n-                        location: Location) {\n+    /// Models statement effect in Reservations and ActiveBorrows flow\n+    /// analyses; `is activations` tells us if we are in the latter\n+    /// case.\n+    fn statement_effect_on_borrows(&self,\n+                                   sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                                   location: Location,\n+                                   is_activations: bool) {\n         let block = &self.mir.basic_blocks().get(location.block).unwrap_or_else(|| {\n             panic!(\"could not find block at location {:?}\", location);\n         });\n         let stmt = block.statements.get(location.statement_index).unwrap_or_else(|| {\n             panic!(\"could not find statement at location {:?}\");\n         });\n+\n+        if is_activations {\n+            // INVARIANT: At this point, `sets.on_entry` should\n+            // correctly reflect the reservations as we enter the\n+            // statement (because accumulates_intrablock_state is\n+            // overridden)\n+            //\n+            // Now compute effect of the statement on the activations\n+            // themselves in the ActiveBorrows state.\n+            let mut find = FindPlaceUses { sets, assigned_map: &self.assigned_map };\n+            find.visit_statement(location.block, stmt, location);\n+        }\n+\n         match stmt.kind {\n+            // EndRegion kills any borrows (reservations and active borrows both)\n             mir::StatementKind::EndRegion(region_scope) => {\n                 if let Some(borrow_indexes) = self.region_map.get(&ReScope(region_scope)) {\n                     assert!(self.nonlexical_regioncx.is_none());\n-                    sets.kill_all(borrow_indexes);\n+                    for idx in borrow_indexes {\n+                        sets.kill(&ReserveOrActivateIndex::reserved(*idx));\n+                        if is_activations {\n+                            sets.kill(&ReserveOrActivateIndex::active(*idx));\n+                        }\n+                    }\n                 } else {\n                     // (if there is no entry, then there are no borrows to be tracked)\n                 }\n             }\n \n             mir::StatementKind::Assign(_, ref rhs) => {\n+                // NOTE: if/when the Assign case is revised to inspect\n+                // the assigned_place here, make sure to also\n+                // re-consider the current implementations of the\n+                // propagate_call_return method.\n+\n                 if let mir::Rvalue::Ref(region, _, ref place) = *rhs {\n                     if is_unsafe_place(self.tcx, self.mir, place) { return; }\n                     if let RegionKind::ReEmpty = region {\n@@ -254,7 +369,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                     assert!(self.region_map.get(region).unwrap_or_else(|| {\n                         panic!(\"could not find BorrowIndexs for region {:?}\", region);\n                     }).contains(&index));\n-                    sets.gen(&index);\n+                    sets.gen(&ReserveOrActivateIndex::reserved(*index));\n                 }\n             }\n \n@@ -264,7 +379,12 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                 //\n                 // FIXME: expand this to variables that are assigned over.\n                 if let Some(borrow_indexes) = self.local_map.get(&local) {\n-                    sets.kill_all(borrow_indexes);\n+                    sets.kill_all(borrow_indexes.iter()\n+                                  .map(|b| ReserveOrActivateIndex::reserved(*b)));\n+                    if is_activations {\n+                        sets.kill_all(borrow_indexes.iter()\n+                                      .map(|b| ReserveOrActivateIndex::active(*b)));\n+                    }\n                 }\n             }\n \n@@ -276,16 +396,28 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n \n         }\n \n-        self.kill_loans_out_of_scope_at_location(sets, location);\n+        self.kill_loans_out_of_scope_at_location(sets, location, is_activations);\n     }\n \n-    fn terminator_effect(&self,\n-                         sets: &mut BlockSets<BorrowIndex>,\n-                         location: Location) {\n+    /// Models terminator effect in Reservations and ActiveBorrows\n+    /// flow analyses; `is activations` tells us if we are in the\n+    /// latter case.\n+    fn terminator_effect_on_borrows(&self,\n+                                    sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                                    location: Location,\n+                                    is_activations: bool) {\n         let block = &self.mir.basic_blocks().get(location.block).unwrap_or_else(|| {\n             panic!(\"could not find block at location {:?}\", location);\n         });\n-        match block.terminator().kind {\n+\n+        let term = block.terminator();\n+        if is_activations {\n+            // Any uses of reserved Places in the statement are now activated.\n+            let mut find = FindPlaceUses { sets, assigned_map: &self.assigned_map };\n+            find.visit_terminator(location.block, term, location);\n+        }\n+\n+        match term.kind {\n             mir::TerminatorKind::Resume |\n             mir::TerminatorKind::Return |\n             mir::TerminatorKind::GeneratorDrop => {\n@@ -304,7 +436,10 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                             if *scope != root_scope &&\n                                 self.scope_tree.is_subscope_of(*scope, root_scope)\n                             {\n-                                sets.kill(&borrow_index);\n+                                sets.kill(&ReserveOrActivateIndex::reserved(borrow_index));\n+                                if is_activations {\n+                                    sets.kill(&ReserveOrActivateIndex::active(borrow_index));\n+                                }\n                             }\n                         }\n                     }\n@@ -320,29 +455,224 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n             mir::TerminatorKind::FalseEdges {..} |\n             mir::TerminatorKind::Unreachable => {}\n         }\n-        self.kill_loans_out_of_scope_at_location(sets, location);\n+        self.kill_loans_out_of_scope_at_location(sets, location, is_activations);\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> ActiveBorrows<'a, 'gcx, 'tcx> {\n+    pub(crate) fn borrows(&self) -> &IndexVec<BorrowIndex, BorrowData<'tcx>> {\n+        self.0.borrows()\n+    }\n+\n+    /// Returns the span for the \"end point\" given region. This will\n+    /// return `None` if NLL is enabled, since that concept has no\n+    /// meaning there.  Otherwise, return region span if it exists and\n+    /// span for end of the function if it doesn't exist.\n+    pub(crate) fn opt_region_end_span(&self, region: &Region) -> Option<Span> {\n+        match self.0.nonlexical_regioncx {\n+            Some(_) => None,\n+            None => {\n+                match self.0.region_span_map.get(region) {\n+                    Some(span) => Some(span.end_point()),\n+                    None => Some(self.0.mir.span.end_point())\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// `FindPlaceUses` is a MIR visitor that updates `self.sets` for all\n+/// of the borrows activated by a given statement or terminator.\n+///\n+/// ----\n+///\n+/// The `ActiveBorrows` flow analysis, when inspecting any given\n+/// statement or terminator, needs to \"generate\" (i.e. set to 1) all\n+/// of the bits for the borrows that are activated by that\n+/// statement/terminator.\n+///\n+/// This struct will seek out all places that are assignment-targets\n+/// for borrows (gathered in `self.assigned_map`; see also the\n+/// `assigned_map` in `struct Borrows`), and set the corresponding\n+/// gen-bits for activations of those borrows in `self.sets`\n+struct FindPlaceUses<'a, 'b: 'a, 'tcx: 'a> {\n+    assigned_map: &'a FxHashMap<Place<'tcx>, FxHashSet<BorrowIndex>>,\n+    sets: &'a mut BlockSets<'b, ReserveOrActivateIndex>,\n+}\n+\n+impl<'a, 'b, 'tcx> FindPlaceUses<'a, 'b, 'tcx> {\n+    fn has_been_reserved(&self, b: &BorrowIndex) -> bool {\n+        self.sets.on_entry.contains(&ReserveOrActivateIndex::reserved(*b))\n+    }\n+\n+    /// return whether `context` should be considered a \"use\" of a\n+    /// place found in that context. \"Uses\" activate associated\n+    /// borrows (at least when such uses occur while the borrow also\n+    /// has a reservation at the time).\n+    fn is_potential_use(context: PlaceContext) -> bool {\n+        match context {\n+            // storage effects on an place do not activate it\n+            PlaceContext::StorageLive | PlaceContext::StorageDead => false,\n+\n+            // validation effects do not activate an place\n+            //\n+            // FIXME: Should they? Is it just another read? Or can we\n+            // guarantee it won't dereference the stored address? How\n+            // \"deep\" does validation go?\n+            PlaceContext::Validate => false,\n+\n+            // pure overwrites of an place do not activate it. (note\n+            // PlaceContext::Call is solely about dest place)\n+            PlaceContext::Store | PlaceContext::Call => false,\n+\n+            // reads of an place *do* activate it\n+            PlaceContext::Move |\n+            PlaceContext::Copy |\n+            PlaceContext::Drop |\n+            PlaceContext::Inspect |\n+            PlaceContext::Borrow { .. } |\n+            PlaceContext::Projection(..) => true,\n+        }\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx> Visitor<'tcx> for FindPlaceUses<'a, 'b, 'tcx> {\n+    fn visit_place(&mut self,\n+                    place: &mir::Place<'tcx>,\n+                    context: PlaceContext<'tcx>,\n+                    location: Location) {\n+        debug!(\"FindPlaceUses place: {:?} assigned from borrows: {:?} \\\n+                used in context: {:?} at location: {:?}\",\n+               place, self.assigned_map.get(place), context, location);\n+        if Self::is_potential_use(context) {\n+            if let Some(borrows) = self.assigned_map.get(place) {\n+                for borrow_idx in borrows {\n+                    debug!(\"checking if index {:?} for {:?} is reserved ({}) \\\n+                            and thus needs active gen-bit set in sets {:?}\",\n+                           borrow_idx, place, self.has_been_reserved(&borrow_idx), self.sets);\n+                    if self.has_been_reserved(&borrow_idx) {\n+                        self.sets.gen(&ReserveOrActivateIndex::active(*borrow_idx));\n+                    } else {\n+                        // (This can certainly happen in valid code. I\n+                        // just want to know about it in the short\n+                        // term.)\n+                        debug!(\"encountered use of Place {:?} of borrow_idx {:?} \\\n+                                at location {:?} outside of reservation\",\n+                               place, borrow_idx, location);\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.super_place(place, context, location);\n+    }\n+}\n+\n+\n+impl<'a, 'gcx, 'tcx> BitDenotation for Reservations<'a, 'gcx, 'tcx> {\n+    type Idx = ReserveOrActivateIndex;\n+    fn name() -> &'static str { \"reservations\" }\n+    fn bits_per_block(&self) -> usize {\n+        self.0.borrows.len() * 2\n+    }\n+    fn start_block_effect(&self, _entry_set: &mut IdxSet<ReserveOrActivateIndex>)  {\n+        // no borrows of code region_scopes have been taken prior to\n+        // function execution, so this method has no effect on\n+        // `_sets`.\n+    }\n+\n+    fn statement_effect(&self,\n+                        sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                        location: Location) {\n+        debug!(\"Reservations::statement_effect sets: {:?} location: {:?}\", sets, location);\n+        self.0.statement_effect_on_borrows(sets, location, false);\n+    }\n+\n+    fn terminator_effect(&self,\n+                         sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                         location: Location) {\n+        debug!(\"Reservations::terminator_effect sets: {:?} location: {:?}\", sets, location);\n+        self.0.terminator_effect_on_borrows(sets, location, false);\n     }\n \n     fn propagate_call_return(&self,\n-                             _in_out: &mut IdxSet<BorrowIndex>,\n+                             _in_out: &mut IdxSet<ReserveOrActivateIndex>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n                              _dest_place: &mir::Place) {\n-        // there are no effects on the region scopes from method calls.\n+        // there are no effects on borrows from method call return...\n+        //\n+        // ... but if overwriting a place can affect flow state, then\n+        // latter is not true; see NOTE on Assign case in\n+        // statement_effect_on_borrows.\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> BitDenotation for ActiveBorrows<'a, 'gcx, 'tcx> {\n+    type Idx = ReserveOrActivateIndex;\n+    fn name() -> &'static str { \"active_borrows\" }\n+\n+    /// Overriding this method; `ActiveBorrows` uses the intrablock\n+    /// state in `on_entry` to track the current reservations (which\n+    /// then affect the construction of the gen/kill sets for\n+    /// activations).\n+    fn accumulates_intrablock_state() -> bool { true }\n+\n+    fn bits_per_block(&self) -> usize {\n+        self.0.borrows.len() * 2\n+    }\n+\n+    fn start_block_effect(&self, _entry_sets: &mut IdxSet<ReserveOrActivateIndex>)  {\n+        // no borrows of code region_scopes have been taken prior to\n+        // function execution, so this method has no effect on\n+        // `_sets`.\n+    }\n+\n+    fn statement_effect(&self,\n+                        sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                        location: Location) {\n+        debug!(\"ActiveBorrows::statement_effect sets: {:?} location: {:?}\", sets, location);\n+        self.0.statement_effect_on_borrows(sets, location, true);\n+    }\n+\n+    fn terminator_effect(&self,\n+                         sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                         location: Location) {\n+        debug!(\"ActiveBorrows::terminator_effect sets: {:?} location: {:?}\", sets, location);\n+        self.0.terminator_effect_on_borrows(sets, location, true);\n+    }\n+\n+    fn propagate_call_return(&self,\n+                             _in_out: &mut IdxSet<ReserveOrActivateIndex>,\n+                             _call_bb: mir::BasicBlock,\n+                             _dest_bb: mir::BasicBlock,\n+                             _dest_place: &mir::Place) {\n+        // there are no effects on borrows from method call return...\n+        //\n+        // ... but If overwriting a place can affect flow state, then\n+        // latter is not true; see NOTE on Assign case in\n+        // statement_effect_on_borrows.\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> BitwiseOperator for Reservations<'a, 'gcx, 'tcx> {\n+    #[inline]\n+    fn join(&self, pred1: usize, pred2: usize) -> usize {\n+        pred1 | pred2 // union effects of preds when computing reservations\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitwiseOperator for Borrows<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitwiseOperator for ActiveBorrows<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n-        pred1 | pred2 // union effects of preds when computing borrows\n+        pred1 | pred2 // union effects of preds when computing activations\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> InitialFlow for Borrows<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InitialFlow for Reservations<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n-        false // bottom = no Rvalue::Refs are active by default\n+        false // bottom = no Rvalue::Refs are reserved by default\n     }\n }\n "}, {"sha": "83c46e0199eebd290a121b672ca75cd6cb693862", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 92, "deletions": 50, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/ced5a701ffd1ba3ff153c811ff81577f28d67785/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced5a701ffd1ba3ff153c811ff81577f28d67785/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=ced5a701ffd1ba3ff153c811ff81577f28d67785", "patch": "@@ -18,7 +18,7 @@ use rustc::ty::{self, TyCtxt};\n use rustc::mir::{self, Mir, BasicBlock, BasicBlockData, Location, Statement, Terminator};\n use rustc::session::Session;\n \n-use std::borrow::Borrow;\n+use std::borrow::{Borrow, Cow};\n use std::fmt;\n use std::io;\n use std::mem;\n@@ -29,7 +29,8 @@ pub use self::impls::{MaybeStorageLive};\n pub use self::impls::{MaybeInitializedLvals, MaybeUninitializedLvals};\n pub use self::impls::{DefinitelyInitializedLvals, MovingOutStatements};\n pub use self::impls::EverInitializedLvals;\n-pub use self::impls::borrows::{Borrows, BorrowData, BorrowIndex};\n+pub use self::impls::borrows::{Borrows, BorrowData};\n+pub(crate) use self::impls::borrows::{ActiveBorrows, Reservations, ReserveOrActivateIndex};\n pub use self::at_location::{FlowAtLocation, FlowsAtLocation};\n pub(crate) use self::drop_flag_effects::*;\n \n@@ -120,7 +121,7 @@ pub struct MoveDataParamEnv<'gcx, 'tcx> {\n }\n \n pub(crate) fn do_dataflow<'a, 'gcx, 'tcx, BD, P>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                 mir: &Mir<'tcx>,\n+                                                 mir: &'a Mir<'tcx>,\n                                                  node_id: ast::NodeId,\n                                                  attributes: &[ast::Attribute],\n                                                  dead_unwinds: &IdxSet<BasicBlock>,\n@@ -130,34 +131,46 @@ pub(crate) fn do_dataflow<'a, 'gcx, 'tcx, BD, P>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     where BD: BitDenotation + InitialFlow,\n           P: Fn(&BD, BD::Idx) -> DebugFormatted\n {\n-    let name_found = |sess: &Session, attrs: &[ast::Attribute], name| -> Option<String> {\n-        if let Some(item) = has_rustc_mir_with(attrs, name) {\n-            if let Some(s) = item.value_str() {\n-                return Some(s.to_string())\n-            } else {\n-                sess.span_err(\n-                    item.span,\n-                    &format!(\"{} attribute requires a path\", item.name()));\n-                return None;\n+    let flow_state = DataflowAnalysis::new(mir, dead_unwinds, bd);\n+    flow_state.run(tcx, node_id, attributes, p)\n+}\n+\n+impl<'a, 'gcx: 'tcx, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation\n+{\n+    pub(crate) fn run<P>(self,\n+                         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                         node_id: ast::NodeId,\n+                         attributes: &[ast::Attribute],\n+                         p: P) -> DataflowResults<BD>\n+        where P: Fn(&BD, BD::Idx) -> DebugFormatted\n+    {\n+        let name_found = |sess: &Session, attrs: &[ast::Attribute], name| -> Option<String> {\n+            if let Some(item) = has_rustc_mir_with(attrs, name) {\n+                if let Some(s) = item.value_str() {\n+                    return Some(s.to_string())\n+                } else {\n+                    sess.span_err(\n+                        item.span,\n+                        &format!(\"{} attribute requires a path\", item.name()));\n+                    return None;\n+                }\n             }\n-        }\n-        return None;\n-    };\n+            return None;\n+        };\n \n-    let print_preflow_to =\n-        name_found(tcx.sess, attributes, \"borrowck_graphviz_preflow\");\n-    let print_postflow_to =\n-        name_found(tcx.sess, attributes, \"borrowck_graphviz_postflow\");\n+        let print_preflow_to =\n+            name_found(tcx.sess, attributes, \"borrowck_graphviz_preflow\");\n+        let print_postflow_to =\n+            name_found(tcx.sess, attributes, \"borrowck_graphviz_postflow\");\n \n-    let mut mbcx = DataflowBuilder {\n-        node_id,\n-        print_preflow_to,\n-        print_postflow_to,\n-        flow_state: DataflowAnalysis::new(tcx, mir, dead_unwinds, bd),\n-    };\n+        let mut mbcx = DataflowBuilder {\n+            node_id,\n+            print_preflow_to, print_postflow_to, flow_state: self,\n+        };\n \n-    mbcx.dataflow(p);\n-    mbcx.flow_state.results()\n+        mbcx.dataflow(p);\n+        mbcx.flow_state.results()\n+    }\n }\n \n struct PropagationContext<'b, 'a: 'b, 'tcx: 'a, O> where O: 'b + BitDenotation\n@@ -181,11 +194,7 @@ impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation\n     }\n \n     fn build_sets(&mut self) {\n-        // First we need to build the entry-, gen- and kill-sets. The\n-        // gather_moves information provides a high-level mapping from\n-        // mir-locations to the MoveOuts (and those correspond\n-        // directly to gen-sets here). But we still need to figure out\n-        // the kill-sets.\n+        // First we need to build the entry-, gen- and kill-sets.\n \n         {\n             let sets = &mut self.flow_state.sets.for_block(mir::START_BLOCK.index());\n@@ -197,18 +206,26 @@ impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation\n \n             let mut interim_state;\n             let sets = &mut self.flow_state.sets.for_block(bb.index());\n-            if BD::accumulates_intrablock_state() {\n+            let track_intrablock = BD::accumulates_intrablock_state();\n+            if track_intrablock {\n+                debug!(\"swapping in mutable on_entry, initially {:?}\", sets.on_entry);\n                 interim_state = sets.on_entry.to_owned();\n                 sets.on_entry = &mut interim_state;\n             }\n             for j_stmt in 0..statements.len() {\n                 let location = Location { block: bb, statement_index: j_stmt };\n                 self.flow_state.operator.statement_effect(sets, location);\n+                if track_intrablock {\n+                    sets.apply_local_effect();\n+                }\n             }\n \n             if terminator.is_some() {\n                 let location = Location { block: bb, statement_index: statements.len() };\n                 self.flow_state.operator.terminator_effect(sets, location);\n+                if track_intrablock {\n+                    sets.apply_local_effect();\n+                }\n             }\n         }\n     }\n@@ -271,7 +288,7 @@ impl<'a, 'tcx: 'a, BD> DataflowBuilder<'a, 'tcx, BD> where BD: BitDenotation\n \n /// Maps each block to a set of bits\n #[derive(Debug)]\n-struct Bits<E:Idx> {\n+pub(crate) struct Bits<E:Idx> {\n     bits: IdxSetBuf<E>,\n }\n \n@@ -292,7 +309,7 @@ impl<E:Idx> Bits<E> {\n /// underlying flow analysis results, because it needs to handle cases\n /// where we are combining the results of *multiple* flow analyses\n /// (e.g. borrows + inits + uninits).\n-pub trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n+pub(crate) trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n     type FlowState: FlowsAtLocation;\n \n     // Observation Hooks: override (at least one of) these to get analysis feedback.\n@@ -471,6 +488,7 @@ pub struct AllSets<E: Idx> {\n /// killed during the iteration. (This is such a good idea that the\n /// `fn gen` and `fn kill` methods that set their state enforce this\n /// for you.)\n+#[derive(Debug)]\n pub struct BlockSets<'a, E: Idx> {\n     /// Dataflow state immediately before control flow enters the given block.\n     pub(crate) on_entry: &'a mut IdxSet<E>,\n@@ -512,6 +530,7 @@ impl<'a, E:Idx> BlockSets<'a, E> {\n         self.gen_set.remove(e);\n         self.kill_set.add(e);\n     }\n+\n     fn kill_all<I>(&mut self, i: I)\n         where I: IntoIterator,\n               I::Item: Borrow<E>\n@@ -520,6 +539,11 @@ impl<'a, E:Idx> BlockSets<'a, E> {\n             self.kill(j.borrow());\n         }\n     }\n+\n+    fn apply_local_effect(&mut self) {\n+        self.on_entry.union(&self.gen_set);\n+        self.on_entry.subtract(&self.kill_set);\n+    }\n }\n \n impl<E:Idx> AllSets<E> {\n@@ -548,6 +572,9 @@ impl<E:Idx> AllSets<E> {\n     pub fn on_entry_set_for(&self, block_idx: usize) -> &IdxSet<E> {\n         self.lookup_set_for(&self.on_entry_sets, block_idx)\n     }\n+    pub(crate) fn entry_set_state(&self) -> &Bits<E> {\n+        &self.on_entry_sets\n+    }\n }\n \n /// Parameterization for the precise form of data flow that is used.\n@@ -664,29 +691,33 @@ pub trait BitDenotation: BitwiseOperator {\n                              dest_place: &mir::Place);\n }\n \n-impl<'a, 'gcx, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n+impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n {\n-    pub fn new(_tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-               mir: &'a Mir<'tcx>,\n+    pub fn new(mir: &'a Mir<'tcx>,\n                dead_unwinds: &'a IdxSet<mir::BasicBlock>,\n                denotation: D) -> Self where D: InitialFlow {\n         let bits_per_block = denotation.bits_per_block();\n-        let usize_bits = mem::size_of::<usize>() * 8;\n-        let words_per_block = (bits_per_block + usize_bits - 1) / usize_bits;\n-\n-        // (now rounded up to multiple of word size)\n-        let bits_per_block = words_per_block * usize_bits;\n-\n-        let num_blocks = mir.basic_blocks().len();\n-        let num_overall = num_blocks * bits_per_block;\n-\n-        let zeroes = Bits::new(IdxSetBuf::new_empty(num_overall));\n+        let num_overall = Self::num_bits_overall(mir, bits_per_block);\n         let on_entry = Bits::new(if D::bottom_value() {\n             IdxSetBuf::new_filled(num_overall)\n         } else {\n             IdxSetBuf::new_empty(num_overall)\n         });\n \n+        Self::new_with_entry_sets(mir, dead_unwinds, Cow::Owned(on_entry), denotation)\n+    }\n+\n+    pub(crate) fn new_with_entry_sets(mir: &'a Mir<'tcx>,\n+                                      dead_unwinds: &'a IdxSet<mir::BasicBlock>,\n+                                      on_entry: Cow<Bits<D::Idx>>,\n+                                      denotation: D)\n+                                      -> Self {\n+        let bits_per_block = denotation.bits_per_block();\n+        let usize_bits = mem::size_of::<usize>() * 8;\n+        let words_per_block = (bits_per_block + usize_bits - 1) / usize_bits;\n+        let num_overall = Self::num_bits_overall(mir, bits_per_block);\n+        assert_eq!(num_overall, on_entry.bits.words().len() * usize_bits);\n+        let zeroes = Bits::new(IdxSetBuf::new_empty(num_overall));\n         DataflowAnalysis {\n             mir,\n             dead_unwinds,\n@@ -696,12 +727,23 @@ impl<'a, 'gcx, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n                     words_per_block,\n                     gen_sets: zeroes.clone(),\n                     kill_sets: zeroes,\n-                    on_entry_sets: on_entry,\n+                    on_entry_sets: on_entry.into_owned(),\n                 },\n                 operator: denotation,\n-            },\n+            }\n         }\n+    }\n+\n+    fn num_bits_overall(mir: &Mir, bits_per_block: usize) -> usize {\n+        let usize_bits = mem::size_of::<usize>() * 8;\n+        let words_per_block = (bits_per_block + usize_bits - 1) / usize_bits;\n \n+        // (now rounded up to multiple of word size)\n+        let bits_per_block = words_per_block * usize_bits;\n+\n+        let num_blocks = mir.basic_blocks().len();\n+        let num_overall = num_blocks * bits_per_block;\n+        num_overall\n     }\n }\n "}, {"sha": "bcf4662211e8b3f38a15440b959a3c0c7595face", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ced5a701ffd1ba3ff153c811ff81577f28d67785/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced5a701ffd1ba3ff153c811ff81577f28d67785/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=ced5a701ffd1ba3ff153c811ff81577f28d67785", "patch": "@@ -65,6 +65,9 @@ pub(crate) mod indexes {\n \n     /// Index into Borrows.locations\n     new_index!(BorrowIndex, \"bw\");\n+\n+    /// Index into Reservations/Activations bitvector\n+    new_index!(ReserveOrActivateIndex, \"ra\");\n }\n \n pub use self::indexes::MovePathIndex;"}]}