{"sha": "da61325bfab3f4292843791b10eeaabf2f835741", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNjEzMjViZmFiM2Y0MjkyODQzNzkxYjEwZWVhYWJmMmY4MzU3NDE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-07T06:06:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-07T06:06:07Z"}, "message": "Rollup merge of #64149 - eddyb:llvm-var-names, r=rkruppe\n\nrustc_codegen_llvm: give names to non-alloca variable values.\n\nThese names only matter when looking at LLVM IR, but they can help.\n\nWhen one value is used for multiple variables, I decided to combine the names.\nI chose `,` as a separator but maybe `=` or ` ` (space) are more appropriate.\n(LLVM names can contain any characters - if necessary they end up having quotes)\n\nAs an example, this function:\n```rust\n#[no_mangle]\npub fn test(a: u32, b: u32) -> u32 {\n    let c = a + b;\n    let d = c;\n    let e = d * a;\n    e\n}\n```\nUsed to produce this LLVM IR:\n```llvm\ndefine i32 @test(i32 %a, i32 %b) unnamed_addr #0 {\nstart:\n  %0 = add i32 %a, %b\n  %1 = mul i32 %0, %a\n  ret i32 %1\n}\n```\nBut after this PR you get this:\n```llvm\ndefine i32 @test(i32 %a, i32 %b) unnamed_addr #0 {\nstart:\n  %\"c,d\" = add i32 %a, %b\n  %e = mul i32 %\"c,d\", %a\n  ret i32 %e\n}\n```\n\ncc @nagisa @rkruppe", "tree": {"sha": "da3db2e395551cbbe222d341b9d76e678de05ef4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da3db2e395551cbbe222d341b9d76e678de05ef4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da61325bfab3f4292843791b10eeaabf2f835741", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdc0jPCRBK7hj4Ov3rIwAAdHIIABxbKZ5C7bSS1wg+6RGQ4CFx\n4xTcx7QuoJ+3Nstkqt0imQDJNVfCzc9IZCEo82BjHia7cJcuTC0zRCE0qofwdUDY\nf3+ohbgNFS84gZfEply1/ShtwjFdQFPhRvV9FYt5RknPzgmI9elKpc5YUBTvHQS8\nj3vHsNuxUVf90wOHCrf/MmgizUiiS1xY7oRl3siFQYJE2QvwfPnvDuGrLs+9UlmS\nPT88O40zmovPt104p5kivKBD+tiOPBoiluArxVvgwVCSTUJi4gFXUt8T1wh21zdC\n2ajedGdXRz2X/RV6r6YlXPFs70xev/EifoCPSE5zTkXii7ADTb1RnWM/IR3qGiI=\n=I7zP\n-----END PGP SIGNATURE-----\n", "payload": "tree da3db2e395551cbbe222d341b9d76e678de05ef4\nparent 7dcac19446ca8fca2c74e3da0461d010043224a7\nparent eedf555d0c041caa0a9e7c8cd4394716e637feaf\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1567836367 +0200\ncommitter GitHub <noreply@github.com> 1567836367 +0200\n\nRollup merge of #64149 - eddyb:llvm-var-names, r=rkruppe\n\nrustc_codegen_llvm: give names to non-alloca variable values.\n\nThese names only matter when looking at LLVM IR, but they can help.\n\nWhen one value is used for multiple variables, I decided to combine the names.\nI chose `,` as a separator but maybe `=` or ` ` (space) are more appropriate.\n(LLVM names can contain any characters - if necessary they end up having quotes)\n\nAs an example, this function:\n```rust\n#[no_mangle]\npub fn test(a: u32, b: u32) -> u32 {\n    let c = a + b;\n    let d = c;\n    let e = d * a;\n    e\n}\n```\nUsed to produce this LLVM IR:\n```llvm\ndefine i32 @test(i32 %a, i32 %b) unnamed_addr #0 {\nstart:\n  %0 = add i32 %a, %b\n  %1 = mul i32 %0, %a\n  ret i32 %1\n}\n```\nBut after this PR you get this:\n```llvm\ndefine i32 @test(i32 %a, i32 %b) unnamed_addr #0 {\nstart:\n  %\"c,d\" = add i32 %a, %b\n  %e = mul i32 %\"c,d\", %a\n  ret i32 %e\n}\n```\n\ncc @nagisa @rkruppe\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da61325bfab3f4292843791b10eeaabf2f835741", "html_url": "https://github.com/rust-lang/rust/commit/da61325bfab3f4292843791b10eeaabf2f835741", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da61325bfab3f4292843791b10eeaabf2f835741/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7dcac19446ca8fca2c74e3da0461d010043224a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/7dcac19446ca8fca2c74e3da0461d010043224a7", "html_url": "https://github.com/rust-lang/rust/commit/7dcac19446ca8fca2c74e3da0461d010043224a7"}, {"sha": "eedf555d0c041caa0a9e7c8cd4394716e637feaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/eedf555d0c041caa0a9e7c8cd4394716e637feaf", "html_url": "https://github.com/rust-lang/rust/commit/eedf555d0c041caa0a9e7c8cd4394716e637feaf"}], "stats": {"total": 86, "additions": 73, "deletions": 13}, "files": [{"sha": "6dedf10f0ab837e41fb5f3094e02c757df62868a", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/da61325bfab3f4292843791b10eeaabf2f835741/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da61325bfab3f4292843791b10eeaabf2f835741/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=da61325bfab3f4292843791b10eeaabf2f835741", "patch": "@@ -32,7 +32,7 @@ use rustc_codegen_ssa::debuginfo::{FunctionDebugContext, MirDebugScope, Variable\n \n use libc::c_uint;\n use std::cell::RefCell;\n-use std::ffi::CString;\n+use std::ffi::{CStr, CString};\n \n use syntax_pos::{self, Span, Pos};\n use syntax::ast;\n@@ -224,8 +224,37 @@ impl DebugInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         gdb::insert_reference_to_gdb_debug_scripts_section_global(self)\n     }\n \n-    fn set_value_name(&mut self, value: &'ll Value, name: &str) {\n-        let cname = SmallCStr::new(name);\n+    fn set_var_name(&mut self, value: &'ll Value, name: impl ToString) {\n+        // Avoid wasting time if LLVM value names aren't even enabled.\n+        if self.sess().fewer_names() {\n+            return;\n+        }\n+\n+        // Only function parameters and instructions are local to a function,\n+        // don't change the name of anything else (e.g. globals).\n+        let param_or_inst = unsafe {\n+            llvm::LLVMIsAArgument(value).is_some() ||\n+            llvm::LLVMIsAInstruction(value).is_some()\n+        };\n+        if !param_or_inst {\n+            return;\n+        }\n+\n+        let old_name = unsafe {\n+            CStr::from_ptr(llvm::LLVMGetValueName(value))\n+        };\n+        match old_name.to_str() {\n+            Ok(\"\") => {}\n+            Ok(_) => {\n+                // Avoid replacing the name if it already exists.\n+                // While we could combine the names somehow, it'd\n+                // get noisy quick, and the usefulness is dubious.\n+                return;\n+            }\n+            Err(_) => return,\n+        }\n+\n+        let cname = CString::new(name.to_string()).unwrap();\n         unsafe {\n             llvm::LLVMSetValueName(value, cname.as_ptr());\n         }"}, {"sha": "b07214fdc03f3c22b4f93d2e462369ca87cd1bff", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da61325bfab3f4292843791b10eeaabf2f835741/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da61325bfab3f4292843791b10eeaabf2f835741/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=da61325bfab3f4292843791b10eeaabf2f835741", "patch": "@@ -806,6 +806,7 @@ extern \"C\" {\n     pub fn LLVMRustRemoveFunctionAttributes(Fn: &Value, index: c_uint, attr: Attribute);\n \n     // Operations on parameters\n+    pub fn LLVMIsAArgument(Val: &Value) -> Option<&Value>;\n     pub fn LLVMCountParams(Fn: &Value) -> c_uint;\n     pub fn LLVMGetParam(Fn: &Value, Index: c_uint) -> &Value;\n \n@@ -818,6 +819,7 @@ extern \"C\" {\n     pub fn LLVMDeleteBasicBlock(BB: &BasicBlock);\n \n     // Operations on instructions\n+    pub fn LLVMIsAInstruction(Val: &Value) -> Option<&Value>;\n     pub fn LLVMGetFirstBasicBlock(Fn: &Value) -> &BasicBlock;\n \n     // Operations on call sites"}, {"sha": "00e9ca01f4dd257c6a78d5eb6229da08e3bd8f2a", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da61325bfab3f4292843791b10eeaabf2f835741/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da61325bfab3f4292843791b10eeaabf2f835741/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=da61325bfab3f4292843791b10eeaabf2f835741", "patch": "@@ -518,19 +518,19 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 PassMode::Ignore(IgnoreMode::CVarArgs) => {}\n                 PassMode::Direct(_) => {\n                     let llarg = bx.get_param(llarg_idx);\n-                    bx.set_value_name(llarg, &name);\n+                    bx.set_var_name(llarg, &name);\n                     llarg_idx += 1;\n                     return local(\n                         OperandRef::from_immediate_or_packed_pair(bx, llarg, arg.layout));\n                 }\n                 PassMode::Pair(..) => {\n-                    let a = bx.get_param(llarg_idx);\n-                    bx.set_value_name(a, &(name.clone() + \".0\"));\n-                    llarg_idx += 1;\n+                    let (a, b) = (bx.get_param(llarg_idx), bx.get_param(llarg_idx + 1));\n+                    llarg_idx += 2;\n \n-                    let b = bx.get_param(llarg_idx);\n-                    bx.set_value_name(b, &(name + \".1\"));\n-                    llarg_idx += 1;\n+                    // FIXME(eddyb) these are scalar components,\n+                    // maybe extract the high-level fields?\n+                    bx.set_var_name(a, format_args!(\"{}.0\", name));\n+                    bx.set_var_name(b, format_args!(\"{}.1\", name));\n \n                     return local(OperandRef {\n                         val: OperandValue::Pair(a, b),\n@@ -546,7 +546,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             // already put it in a temporary alloca and gave it up.\n             // FIXME: lifetimes\n             let llarg = bx.get_param(llarg_idx);\n-            bx.set_value_name(llarg, &name);\n+            bx.set_var_name(llarg, &name);\n             llarg_idx += 1;\n             PlaceRef::new_sized(llarg, arg.layout)\n         } else if arg.is_unsized_indirect() {"}, {"sha": "594f45c833758874caf2d4220bdc9cfe1784f35a", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da61325bfab3f4292843791b10eeaabf2f835741/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da61325bfab3f4292843791b10eeaabf2f835741/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=da61325bfab3f4292843791b10eeaabf2f835741", "patch": "@@ -29,7 +29,21 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             self.codegen_rvalue_unsized(bx, cg_indirect_dest, rvalue)\n                         }\n                         LocalRef::Operand(None) => {\n-                            let (bx, operand) = self.codegen_rvalue_operand(bx, rvalue);\n+                            let (mut bx, operand) = self.codegen_rvalue_operand(bx, rvalue);\n+                            if let Some(name) = self.mir.local_decls[index].name {\n+                                match operand.val {\n+                                    OperandValue::Ref(x, ..) |\n+                                    OperandValue::Immediate(x) => {\n+                                        bx.set_var_name(x, name);\n+                                    }\n+                                    OperandValue::Pair(a, b) => {\n+                                        // FIXME(eddyb) these are scalar components,\n+                                        // maybe extract the high-level fields?\n+                                        bx.set_var_name(a, format_args!(\"{}.0\", name));\n+                                        bx.set_var_name(b, format_args!(\"{}.1\", name));\n+                                    }\n+                                }\n+                            }\n                             self.locals[index] = LocalRef::Operand(Some(operand));\n                             bx\n                         }"}, {"sha": "9c16b864ef21dce3b48d1c017b16cb8b885848ac", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da61325bfab3f4292843791b10eeaabf2f835741/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da61325bfab3f4292843791b10eeaabf2f835741/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=da61325bfab3f4292843791b10eeaabf2f835741", "patch": "@@ -57,5 +57,5 @@ pub trait DebugInfoBuilderMethods<'tcx>: BackendTypes {\n         span: Span,\n     );\n     fn insert_reference_to_gdb_debug_scripts_section_global(&mut self);\n-    fn set_value_name(&mut self, value: Self::Value, name: &str);\n+    fn set_var_name(&mut self, value: Self::Value, name: impl ToString);\n }"}, {"sha": "3140a7c6b6cc2fef663d5ed682c37f43b6c498d2", "filename": "src/test/codegen/var-names.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/da61325bfab3f4292843791b10eeaabf2f835741/src%2Ftest%2Fcodegen%2Fvar-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da61325bfab3f4292843791b10eeaabf2f835741/src%2Ftest%2Fcodegen%2Fvar-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fvar-names.rs?ref=da61325bfab3f4292843791b10eeaabf2f835741", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags: -O -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+// CHECK-LABEL: define i32 @test(i32 %a, i32 %b)\n+#[no_mangle]\n+pub fn test(a: u32, b: u32) -> u32 {\n+    let c = a + b;\n+    // CHECK: %c = add i32 %a, %b\n+    let d = c;\n+    let e = d * a;\n+    // CHECK-NEXT: %e = mul i32 %c, %a\n+    e\n+    // CHECK-NEXT: ret i32 %e\n+}"}]}