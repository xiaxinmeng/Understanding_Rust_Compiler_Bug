{"sha": "082996032054031bd1b68ee45ab04293f4877e91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4Mjk5NjAzMjA1NDAzMWJkMWI2OGVlNDVhYjA0MjkzZjQ4NzdlOTE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-04T11:30:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-04T11:30:07Z"}, "message": "Merge #8327\n\n8327: Move `Ty` creation methods out of `Ty` (Chalk move preparation) r=flodiebold a=flodiebold\n\nWhen we'll move to using `chalk_ir::Ty` (#8313), we won't be able to have our own inherent methods on `Ty` anymore, so we need to move the helpers elsewhere.\r\nThis adds a `TyBuilder` that allows easily constructing `Ty` and related types (`TraitRef`, `ProjectionTy`, `Substitution`). It also replaces `SubstsBuilder`. `TyBuilder` can construct different things based on its type parameter; e.g. if it has an `AdtId`, we're constructing an ADT type, but if it has a `TraitId`, we're constructing a `TraitRef`. The common thing for all of them is that we need to build a `Substitution`, so the API stays the same for all of them except at the beginning and end.\r\n\r\nWe also use `TyBuilder` to house various one-shot methods for constructing types, e.g. `TyBuilder::unit()`.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "ccf4586bbb70ef9ebf429a2c79a5f409549ebf73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccf4586bbb70ef9ebf429a2c79a5f409549ebf73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/082996032054031bd1b68ee45ab04293f4877e91", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgaaM/CRBK7hj4Ov3rIwAAdHIIADwH3BXeKpDf4Za69FoyHTne\n1DVQvuBir5Lddq61/TKdga950kURXzU/EQNnZTteDGz4hIhC3BczIjqa9TnpDe/j\nrWIvtqW1J/cHdrh+2wGNOtu/fVpvbl08Edeww5nEv19FdZYJtlQuZO+/ohnhgF56\nnNOSGs9iPfz2mLLbpMh8xTJGbs59lE/hAVs+OdQlDpPoWxOzU50Ec6+SrzA+8c16\noVEO/oV6BtRdwZ/2BVNCe03NUNdsL2UekpGr3iH+bT9ggmLLLtFZwxfjgE8A8ssD\nOtYgEiWZnLb1VyxAJLo0x6MX5bbO2dqbuOEY0UoVw6Kk+qhA1RXhl0fD+djwke0=\n=cu9u\n-----END PGP SIGNATURE-----\n", "payload": "tree ccf4586bbb70ef9ebf429a2c79a5f409549ebf73\nparent c9bcbf9a43eb0bf1a5255f704080305e568f0a36\nparent cde3857897955558ed0e60cf8158e18d5c75d188\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1617535807 +0000\ncommitter GitHub <noreply@github.com> 1617535807 +0000\n\nMerge #8327\n\n8327: Move `Ty` creation methods out of `Ty` (Chalk move preparation) r=flodiebold a=flodiebold\n\nWhen we'll move to using `chalk_ir::Ty` (#8313), we won't be able to have our own inherent methods on `Ty` anymore, so we need to move the helpers elsewhere.\r\nThis adds a `TyBuilder` that allows easily constructing `Ty` and related types (`TraitRef`, `ProjectionTy`, `Substitution`). It also replaces `SubstsBuilder`. `TyBuilder` can construct different things based on its type parameter; e.g. if it has an `AdtId`, we're constructing an ADT type, but if it has a `TraitId`, we're constructing a `TraitRef`. The common thing for all of them is that we need to build a `Substitution`, so the API stays the same for all of them except at the beginning and end.\r\n\r\nWe also use `TyBuilder` to house various one-shot methods for constructing types, e.g. `TyBuilder::unit()`.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/082996032054031bd1b68ee45ab04293f4877e91", "html_url": "https://github.com/rust-lang/rust/commit/082996032054031bd1b68ee45ab04293f4877e91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/082996032054031bd1b68ee45ab04293f4877e91/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9bcbf9a43eb0bf1a5255f704080305e568f0a36", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9bcbf9a43eb0bf1a5255f704080305e568f0a36", "html_url": "https://github.com/rust-lang/rust/commit/c9bcbf9a43eb0bf1a5255f704080305e568f0a36"}, {"sha": "cde3857897955558ed0e60cf8158e18d5c75d188", "url": "https://api.github.com/repos/rust-lang/rust/commits/cde3857897955558ed0e60cf8158e18d5c75d188", "html_url": "https://github.com/rust-lang/rust/commit/cde3857897955558ed0e60cf8158e18d5c75d188"}], "stats": {"total": 796, "additions": 423, "deletions": 373}, "files": [{"sha": "993772aac50387a4e50b211f46e95ac054c5d98a", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=082996032054031bd1b68ee45ab04293f4877e91", "patch": "@@ -13,7 +13,7 @@ use syntax::ast::{self, NameOwner};\n \n use crate::{\n     Adt, Const, ConstParam, Enum, Field, Function, GenericParam, HasVisibility, LifetimeParam,\n-    Module, Static, Struct, Substitution, Trait, Type, TypeAlias, TypeParam, Union, Variant,\n+    Module, Static, Struct, Trait, TyBuilder, Type, TypeAlias, TypeParam, Union, Variant,\n };\n \n impl HirDisplay for Function {\n@@ -234,7 +234,7 @@ impl HirDisplay for TypeParam {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         write!(f, \"{}\", self.name(f.db))?;\n         let bounds = f.db.generic_predicates_for_param(self.id);\n-        let substs = Substitution::type_params(f.db, self.id.parent);\n+        let substs = TyBuilder::type_params_subst(f.db, self.id.parent);\n         let predicates = bounds.iter().cloned().map(|b| b.subst(&substs)).collect::<Vec<_>>();\n         if !(predicates.is_empty() || f.omit_verbose_types()) {\n             write_bounds_like_dyn_trait_with_prefix(\":\", &predicates, f)?;"}, {"sha": "19901ed3346da211dbeb4b103a19c52bfe159d45", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=082996032054031bd1b68ee45ab04293f4877e91", "patch": "@@ -55,11 +55,10 @@ use hir_ty::{\n     autoderef, could_unify,\n     method_resolution::{self, TyFingerprint},\n     primitive::UintTy,\n-    to_assoc_type_id,\n     traits::{FnTrait, Solution, SolutionVariables},\n     AliasEq, AliasTy, BoundVar, CallableDefId, CallableSig, Canonical, CanonicalVarKinds, Cast,\n-    DebruijnIndex, InEnvironment, Interner, ProjectionTy, QuantifiedWhereClause, Scalar,\n-    Substitution, TraitEnvironment, Ty, TyDefId, TyKind, TyVariableKind, WhereClause,\n+    DebruijnIndex, InEnvironment, Interner, QuantifiedWhereClause, Scalar, Substitution,\n+    TraitEnvironment, Ty, TyBuilder, TyDefId, TyKind, TyVariableKind, WhereClause,\n };\n use itertools::Itertools;\n use rustc_hash::FxHashSet;\n@@ -515,7 +514,7 @@ impl Field {\n             VariantDef::Union(it) => it.id.into(),\n             VariantDef::Variant(it) => it.parent.id.into(),\n         };\n-        let substs = Substitution::type_params(db, generic_def_id);\n+        let substs = TyBuilder::type_params_subst(db, generic_def_id);\n         let ty = db.field_types(var_id)[self.id].clone().subst(&substs);\n         Type::new(db, self.parent.module(db).id.krate(), var_id, ty)\n     }\n@@ -1129,7 +1128,7 @@ pub struct BuiltinType {\n impl BuiltinType {\n     pub fn ty(self, db: &dyn HirDatabase, module: Module) -> Type {\n         let resolver = module.id.resolver(db.upcast());\n-        Type::new_with_resolver(db, &resolver, Ty::builtin(self.inner))\n+        Type::new_with_resolver(db, &resolver, TyBuilder::builtin(self.inner))\n             .expect(\"crate not present in resolver\")\n     }\n \n@@ -1502,7 +1501,7 @@ impl TypeParam {\n         let resolver = self.id.parent.resolver(db.upcast());\n         let krate = self.id.parent.module(db.upcast()).krate();\n         let ty = params.get(local_idx)?.clone();\n-        let subst = Substitution::type_params(db, self.id.parent);\n+        let subst = TyBuilder::type_params_subst(db, self.id.parent);\n         let ty = ty.subst(&subst.prefix(local_idx));\n         Some(Type::new_with_resolver_inner(db, krate, &resolver, ty))\n     }\n@@ -1703,10 +1702,9 @@ impl Type {\n     fn from_def(\n         db: &dyn HirDatabase,\n         krate: CrateId,\n-        def: impl HasResolver + Into<TyDefId> + Into<GenericDefId>,\n+        def: impl HasResolver + Into<TyDefId>,\n     ) -> Type {\n-        let substs = Substitution::build_for_def(db, def).fill_with_unknown().build();\n-        let ty = db.ty(def.into()).subst(&substs);\n+        let ty = TyBuilder::def_ty(db, def.into()).fill_with_unknown().build();\n         Type::new(db, krate, def, ty)\n     }\n \n@@ -1785,13 +1783,10 @@ impl Type {\n     }\n \n     pub fn impls_trait(&self, db: &dyn HirDatabase, trait_: Trait, args: &[Type]) -> bool {\n-        let trait_ref = hir_ty::TraitRef {\n-            trait_id: hir_ty::to_chalk_trait_id(trait_.id),\n-            substitution: Substitution::build_for_def(db, trait_.id)\n-                .push(self.ty.clone())\n-                .fill(args.iter().map(|t| t.ty.clone()))\n-                .build(),\n-        };\n+        let trait_ref = TyBuilder::trait_ref(db, trait_.id)\n+            .push(self.ty.clone())\n+            .fill(args.iter().map(|t| t.ty.clone()))\n+            .build();\n \n         let goal = Canonical {\n             value: hir_ty::InEnvironment::new(self.env.env.clone(), trait_ref.cast(&Interner)),\n@@ -1804,22 +1799,18 @@ impl Type {\n     pub fn normalize_trait_assoc_type(\n         &self,\n         db: &dyn HirDatabase,\n-        trait_: Trait,\n         args: &[Type],\n         alias: TypeAlias,\n     ) -> Option<Type> {\n-        let subst = Substitution::build_for_def(db, trait_.id)\n+        let projection = TyBuilder::assoc_type_projection(db, alias.id)\n             .push(self.ty.clone())\n             .fill(args.iter().map(|t| t.ty.clone()))\n             .build();\n         let goal = Canonical::new(\n             InEnvironment::new(\n                 self.env.env.clone(),\n                 AliasEq {\n-                    alias: AliasTy::Projection(ProjectionTy {\n-                        associated_ty_id: to_assoc_type_id(alias.id),\n-                        substitution: subst,\n-                    }),\n+                    alias: AliasTy::Projection(projection),\n                     ty: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0))\n                         .intern(&Interner),\n                 }"}, {"sha": "70c56cc459f4a3c091b26dc475ec02d1d58e0d56", "filename": "crates/hir_ty/src/autoderef.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs?ref=082996032054031bd1b68ee45ab04293f4877e91", "patch": "@@ -13,11 +13,9 @@ use log::{info, warn};\n \n use crate::{\n     db::HirDatabase,\n-    to_assoc_type_id, to_chalk_trait_id,\n     traits::{InEnvironment, Solution},\n-    utils::generics,\n-    AliasEq, AliasTy, BoundVar, Canonical, CanonicalVarKinds, DebruijnIndex, Interner,\n-    ProjectionTy, Substitution, TraitRef, Ty, TyKind,\n+    AliasEq, AliasTy, BoundVar, Canonical, CanonicalVarKinds, DebruijnIndex, Interner, Ty,\n+    TyBuilder, TyKind,\n };\n \n const AUTODEREF_RECURSION_LIMIT: usize = 10;\n@@ -57,21 +55,20 @@ fn deref_by_trait(\n     };\n     let target = db.trait_data(deref_trait).associated_type_by_name(&name![Target])?;\n \n-    let generic_params = generics(db.upcast(), target.into());\n-    if generic_params.len() != 1 {\n-        // the Target type + Deref trait should only have one generic parameter,\n-        // namely Deref's Self type\n-        return None;\n-    }\n+    let projection = {\n+        let b = TyBuilder::assoc_type_projection(db, target);\n+        if b.remaining() != 1 {\n+            // the Target type + Deref trait should only have one generic parameter,\n+            // namely Deref's Self type\n+            return None;\n+        }\n+        b.push(ty.goal.value.clone()).build()\n+    };\n \n     // FIXME make the Canonical / bound var handling nicer\n \n-    let parameters =\n-        Substitution::build_for_generics(&generic_params).push(ty.goal.value.clone()).build();\n-\n     // Check that the type implements Deref at all\n-    let trait_ref =\n-        TraitRef { trait_id: to_chalk_trait_id(deref_trait), substitution: parameters.clone() };\n+    let trait_ref = projection.trait_ref(db);\n     let implements_goal = Canonical {\n         binders: ty.goal.binders.clone(),\n         value: InEnvironment {\n@@ -84,21 +81,16 @@ fn deref_by_trait(\n     }\n \n     // Now do the assoc type projection\n-    let projection = AliasEq {\n-        alias: AliasTy::Projection(ProjectionTy {\n-            associated_ty_id: to_assoc_type_id(target),\n-            substitution: parameters,\n-        }),\n+    let alias_eq = AliasEq {\n+        alias: AliasTy::Projection(projection),\n         ty: TyKind::BoundVar(BoundVar::new(\n             DebruijnIndex::INNERMOST,\n             ty.goal.binders.len(&Interner),\n         ))\n         .intern(&Interner),\n     };\n \n-    let obligation = projection.cast(&Interner);\n-\n-    let in_env = InEnvironment { goal: obligation, environment: ty.environment };\n+    let in_env = InEnvironment { goal: alias_eq.cast(&Interner), environment: ty.environment };\n \n     let canonical = Canonical {\n         value: in_env,"}, {"sha": "4a9a8058fcc14564bdd3f12ef3e4c1ea8e8a79e9", "filename": "crates/hir_ty/src/builder.rs", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs?ref=082996032054031bd1b68ee45ab04293f4877e91", "patch": "@@ -0,0 +1,219 @@\n+//! `TyBuilder`, a helper for building instances of `Ty` and related types.\n+\n+use std::iter;\n+\n+use chalk_ir::{\n+    cast::{Cast, CastTo, Caster},\n+    interner::HasInterner,\n+    AdtId, BoundVar, DebruijnIndex, Safety, Scalar,\n+};\n+use hir_def::{builtin_type::BuiltinType, GenericDefId, TraitId, TypeAliasId};\n+use smallvec::SmallVec;\n+\n+use crate::{\n+    db::HirDatabase, primitive, to_assoc_type_id, to_chalk_trait_id, utils::generics, Binders,\n+    CallableSig, FnPointer, FnSig, GenericArg, Interner, ProjectionTy, Substitution, TraitRef, Ty,\n+    TyDefId, TyKind, TypeWalk, ValueTyDefId,\n+};\n+\n+/// This is a builder for `Ty` or anything that needs a `Substitution`.\n+pub struct TyBuilder<D> {\n+    /// The `data` field is used to keep track of what we're building (e.g. an\n+    /// ADT, a `TraitRef`, ...).\n+    data: D,\n+    vec: SmallVec<[GenericArg; 2]>,\n+    param_count: usize,\n+}\n+\n+impl<D> TyBuilder<D> {\n+    fn new(data: D, param_count: usize) -> TyBuilder<D> {\n+        TyBuilder { data, param_count, vec: SmallVec::with_capacity(param_count) }\n+    }\n+\n+    fn build_internal(self) -> (D, Substitution) {\n+        assert_eq!(self.vec.len(), self.param_count);\n+        // FIXME: would be good to have a way to construct a chalk_ir::Substitution from the interned form\n+        let subst = Substitution(self.vec);\n+        (self.data, subst)\n+    }\n+\n+    pub fn push(mut self, arg: impl CastTo<GenericArg>) -> Self {\n+        self.vec.push(arg.cast(&Interner));\n+        self\n+    }\n+\n+    pub fn remaining(&self) -> usize {\n+        self.param_count - self.vec.len()\n+    }\n+\n+    pub fn fill_with_bound_vars(self, debruijn: DebruijnIndex, starting_from: usize) -> Self {\n+        self.fill(\n+            (starting_from..)\n+                .map(|idx| TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(&Interner)),\n+        )\n+    }\n+\n+    pub fn fill_with_unknown(self) -> Self {\n+        self.fill(iter::repeat(TyKind::Unknown.intern(&Interner)))\n+    }\n+\n+    pub fn fill(mut self, filler: impl Iterator<Item = impl CastTo<GenericArg>>) -> Self {\n+        self.vec.extend(filler.take(self.remaining()).casted(&Interner));\n+        assert_eq!(self.remaining(), 0);\n+        self\n+    }\n+\n+    pub fn use_parent_substs(mut self, parent_substs: &Substitution) -> Self {\n+        assert!(self.vec.is_empty());\n+        assert!(parent_substs.len(&Interner) <= self.param_count);\n+        self.vec.extend(parent_substs.iter(&Interner).cloned());\n+        self\n+    }\n+}\n+\n+impl TyBuilder<()> {\n+    pub fn unit() -> Ty {\n+        TyKind::Tuple(0, Substitution::empty(&Interner)).intern(&Interner)\n+    }\n+\n+    pub fn fn_ptr(sig: CallableSig) -> Ty {\n+        TyKind::Function(FnPointer {\n+            num_args: sig.params().len(),\n+            sig: FnSig { abi: (), safety: Safety::Safe, variadic: sig.is_varargs },\n+            substs: Substitution::from_iter(&Interner, sig.params_and_return.iter().cloned()),\n+        })\n+        .intern(&Interner)\n+    }\n+\n+    pub fn builtin(builtin: BuiltinType) -> Ty {\n+        match builtin {\n+            BuiltinType::Char => TyKind::Scalar(Scalar::Char).intern(&Interner),\n+            BuiltinType::Bool => TyKind::Scalar(Scalar::Bool).intern(&Interner),\n+            BuiltinType::Str => TyKind::Str.intern(&Interner),\n+            BuiltinType::Int(t) => {\n+                TyKind::Scalar(Scalar::Int(primitive::int_ty_from_builtin(t))).intern(&Interner)\n+            }\n+            BuiltinType::Uint(t) => {\n+                TyKind::Scalar(Scalar::Uint(primitive::uint_ty_from_builtin(t))).intern(&Interner)\n+            }\n+            BuiltinType::Float(t) => {\n+                TyKind::Scalar(Scalar::Float(primitive::float_ty_from_builtin(t))).intern(&Interner)\n+            }\n+        }\n+    }\n+\n+    pub fn type_params_subst(db: &dyn HirDatabase, def: impl Into<GenericDefId>) -> Substitution {\n+        let params = generics(db.upcast(), def.into());\n+        params.type_params_subst(db)\n+    }\n+\n+    pub fn subst_for_def(db: &dyn HirDatabase, def: impl Into<GenericDefId>) -> TyBuilder<()> {\n+        let def = def.into();\n+        let params = generics(db.upcast(), def);\n+        let param_count = params.len();\n+        TyBuilder::new((), param_count)\n+    }\n+\n+    pub fn build(self) -> Substitution {\n+        let ((), subst) = self.build_internal();\n+        subst\n+    }\n+}\n+\n+impl TyBuilder<hir_def::AdtId> {\n+    pub fn adt(db: &dyn HirDatabase, adt: hir_def::AdtId) -> TyBuilder<hir_def::AdtId> {\n+        let generics = generics(db.upcast(), adt.into());\n+        let param_count = generics.len();\n+        TyBuilder::new(adt, param_count)\n+    }\n+\n+    pub fn fill_with_defaults(\n+        mut self,\n+        db: &dyn HirDatabase,\n+        mut fallback: impl FnMut() -> Ty,\n+    ) -> Self {\n+        let defaults = db.generic_defaults(self.data.into());\n+        for default_ty in defaults.iter().skip(self.vec.len()) {\n+            if default_ty.skip_binders().is_unknown() {\n+                self.vec.push(fallback().cast(&Interner));\n+            } else {\n+                // each default can depend on the previous parameters\n+                let subst_so_far = Substitution(self.vec.clone());\n+                self.vec.push(default_ty.clone().subst(&subst_so_far).cast(&Interner));\n+            }\n+        }\n+        self\n+    }\n+\n+    pub fn build(self) -> Ty {\n+        let (adt, subst) = self.build_internal();\n+        TyKind::Adt(AdtId(adt), subst).intern(&Interner)\n+    }\n+}\n+\n+pub struct Tuple(usize);\n+impl TyBuilder<Tuple> {\n+    pub fn tuple(size: usize) -> TyBuilder<Tuple> {\n+        TyBuilder::new(Tuple(size), size)\n+    }\n+\n+    pub fn build(self) -> Ty {\n+        let (Tuple(size), subst) = self.build_internal();\n+        TyKind::Tuple(size, subst).intern(&Interner)\n+    }\n+}\n+\n+impl TyBuilder<TraitId> {\n+    pub fn trait_ref(db: &dyn HirDatabase, trait_id: TraitId) -> TyBuilder<TraitId> {\n+        let generics = generics(db.upcast(), trait_id.into());\n+        let param_count = generics.len();\n+        TyBuilder::new(trait_id, param_count)\n+    }\n+\n+    pub fn build(self) -> TraitRef {\n+        let (trait_id, substitution) = self.build_internal();\n+        TraitRef { trait_id: to_chalk_trait_id(trait_id), substitution }\n+    }\n+}\n+\n+impl TyBuilder<TypeAliasId> {\n+    pub fn assoc_type_projection(\n+        db: &dyn HirDatabase,\n+        type_alias: TypeAliasId,\n+    ) -> TyBuilder<TypeAliasId> {\n+        let generics = generics(db.upcast(), type_alias.into());\n+        let param_count = generics.len();\n+        TyBuilder::new(type_alias, param_count)\n+    }\n+\n+    pub fn build(self) -> ProjectionTy {\n+        let (type_alias, substitution) = self.build_internal();\n+        ProjectionTy { associated_ty_id: to_assoc_type_id(type_alias), substitution }\n+    }\n+}\n+\n+impl<T: TypeWalk + HasInterner<Interner = Interner>> TyBuilder<Binders<T>> {\n+    fn subst_binders(b: Binders<T>) -> Self {\n+        let param_count = b.num_binders;\n+        TyBuilder::new(b, param_count)\n+    }\n+\n+    pub fn build(self) -> T {\n+        let (b, subst) = self.build_internal();\n+        b.subst(&subst)\n+    }\n+}\n+\n+impl TyBuilder<Binders<Ty>> {\n+    pub fn def_ty(db: &dyn HirDatabase, def: TyDefId) -> TyBuilder<Binders<Ty>> {\n+        TyBuilder::subst_binders(db.ty(def.into()))\n+    }\n+\n+    pub fn impl_self_ty(db: &dyn HirDatabase, def: hir_def::ImplId) -> TyBuilder<Binders<Ty>> {\n+        TyBuilder::subst_binders(db.impl_self_ty(def))\n+    }\n+\n+    pub fn value_ty(db: &dyn HirDatabase, def: ValueTyDefId) -> TyBuilder<Binders<Ty>> {\n+        TyBuilder::subst_binders(db.value_ty(def))\n+    }\n+}"}, {"sha": "b7463366b8997e61159c59b25bde212f41ef3f85", "filename": "crates/hir_ty/src/chalk_ext.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs?ref=082996032054031bd1b68ee45ab04293f4877e91", "patch": "@@ -0,0 +1,13 @@\n+//! Various extensions traits for Chalk types.\n+\n+use crate::{Interner, Ty, TyKind};\n+\n+pub trait TyExt {\n+    fn is_unit(&self) -> bool;\n+}\n+\n+impl TyExt for Ty {\n+    fn is_unit(&self) -> bool {\n+        matches!(self.kind(&Interner), TyKind::Tuple(0, _))\n+    }\n+}"}, {"sha": "8169b759f5189ba2773bf597a19efe5bdb45433a", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=082996032054031bd1b68ee45ab04293f4877e91", "patch": "@@ -15,7 +15,7 @@ use crate::{\n         MissingPatFields, RemoveThisSemicolon,\n     },\n     utils::variant_data,\n-    AdtId, InferenceResult, Interner, Ty, TyKind,\n+    AdtId, InferenceResult, Interner, TyExt, TyKind,\n };\n \n pub(crate) use hir_def::{\n@@ -423,7 +423,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             None => return,\n         };\n \n-        if mismatch.actual != Ty::unit() || mismatch.expected != *possible_tail_ty {\n+        if !mismatch.actual.is_unit() || mismatch.expected != *possible_tail_ty {\n             return;\n         }\n "}, {"sha": "385bd94059d70c8e8429f2f576079d3dbac43ce1", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=082996032054031bd1b68ee45ab04293f4877e91", "patch": "@@ -19,7 +19,7 @@ use crate::{\n     db::HirDatabase, from_assoc_type_id, from_foreign_def_id, from_placeholder_idx, primitive,\n     to_assoc_type_id, traits::chalk::from_chalk, utils::generics, AdtId, AliasEq, AliasTy,\n     CallableDefId, CallableSig, DomainGoal, GenericArg, ImplTraitId, Interner, Lifetime, OpaqueTy,\n-    ProjectionTy, QuantifiedWhereClause, Scalar, Substitution, TraitRef, Ty, TyKind, WhereClause,\n+    ProjectionTy, QuantifiedWhereClause, Scalar, TraitRef, Ty, TyExt, TyKind, WhereClause,\n };\n \n pub struct HirFormatter<'a> {\n@@ -423,7 +423,7 @@ impl HirDisplay for Ty {\n                 f.write_joined(sig.params(), \", \")?;\n                 write!(f, \")\")?;\n                 let ret = sig.ret();\n-                if *ret != Ty::unit() {\n+                if !ret.is_unit() {\n                     let ret_display = ret.into_displayable(\n                         f.db,\n                         f.max_size,\n@@ -591,7 +591,7 @@ impl HirDisplay for Ty {\n                         write!(f, \"{}\", param_data.name.clone().unwrap_or_else(Name::missing))?\n                     }\n                     TypeParamProvenance::ArgumentImplTrait => {\n-                        let substs = Substitution::type_params_for_generics(f.db, &generics);\n+                        let substs = generics.type_params_subst(f.db);\n                         let bounds = f\n                             .db\n                             .generic_predicates(id.parent)\n@@ -663,7 +663,7 @@ impl HirDisplay for CallableSig {\n         }\n         write!(f, \")\")?;\n         let ret = self.ret();\n-        if *ret != Ty::unit() {\n+        if !ret.is_unit() {\n             let ret_display =\n                 ret.into_displayable(f.db, f.max_size, f.omit_verbose_types, f.display_target);\n             write!(f, \" -> {}\", ret_display)?;"}, {"sha": "1b1d4458c0c9b4fcfbbb23e44904ea3041bd13b5", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=082996032054031bd1b68ee45ab04293f4877e91", "patch": "@@ -38,11 +38,11 @@ use syntax::SmolStr;\n \n use super::{\n     traits::{DomainGoal, Guidance, Solution},\n-    InEnvironment, ProjectionTy, Substitution, TraitEnvironment, TraitRef, Ty, TypeWalk,\n+    InEnvironment, ProjectionTy, TraitEnvironment, TraitRef, Ty, TypeWalk,\n };\n use crate::{\n     db::HirDatabase, infer::diagnostics::InferenceDiagnostic, lower::ImplTraitLoweringMode,\n-    to_assoc_type_id, to_chalk_trait_id, AliasEq, AliasTy, Interner, TyKind,\n+    to_assoc_type_id, AliasEq, AliasTy, Interner, TyBuilder, TyKind,\n };\n \n // This lint has a false positive here. See the link below for details.\n@@ -409,16 +409,14 @@ impl<'a> InferenceContext<'a> {\n                     _ => panic!(\"resolve_associated_type called with non-associated type\"),\n                 };\n                 let ty = self.table.new_type_var();\n-                let substs = Substitution::build_for_def(self.db, res_assoc_ty)\n+                let trait_ref = TyBuilder::trait_ref(self.db, trait_)\n                     .push(inner_ty)\n                     .fill(params.iter().cloned())\n                     .build();\n-                let trait_ref =\n-                    TraitRef { trait_id: to_chalk_trait_id(trait_), substitution: substs.clone() };\n                 let alias_eq = AliasEq {\n                     alias: AliasTy::Projection(ProjectionTy {\n                         associated_ty_id: to_assoc_type_id(res_assoc_ty),\n-                        substitution: substs,\n+                        substitution: trait_ref.substitution.clone(),\n                     }),\n                     ty: ty.clone(),\n                 };\n@@ -489,7 +487,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             TypeNs::SelfType(impl_id) => {\n                 let generics = crate::utils::generics(self.db.upcast(), impl_id.into());\n-                let substs = Substitution::type_params_for_generics(self.db, &generics);\n+                let substs = generics.type_params_subst(self.db);\n                 let ty = self.db.impl_self_ty(impl_id).subst(&substs);\n                 match unresolved {\n                     None => {\n@@ -516,10 +514,9 @@ impl<'a> InferenceContext<'a> {\n                 }\n             }\n             TypeNs::TypeAliasId(it) => {\n-                let substs = Substitution::build_for_def(self.db, it)\n+                let ty = TyBuilder::def_ty(self.db, it.into())\n                     .fill(std::iter::repeat_with(|| self.table.new_type_var()))\n                     .build();\n-                let ty = self.db.ty(it.into()).subst(&substs);\n                 let variant = ty_variant(&ty);\n                 forbid_unresolved_segments((ty, variant), unresolved)\n             }"}, {"sha": "028a4d568d70b8417fb120b79dfa5ae81ce42222", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=082996032054031bd1b68ee45ab04293f4877e91", "patch": "@@ -7,9 +7,7 @@\n use chalk_ir::{cast::Cast, Mutability, TyVariableKind};\n use hir_def::lang_item::LangItemTarget;\n \n-use crate::{\n-    autoderef, to_chalk_trait_id, traits::Solution, Interner, Substitution, TraitRef, Ty, TyKind,\n-};\n+use crate::{autoderef, traits::Solution, Interner, Ty, TyBuilder, TyKind};\n \n use super::{InEnvironment, InferenceContext};\n \n@@ -44,8 +42,8 @@ impl<'a> InferenceContext<'a> {\n                 // https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src/librustc_typeck/check/coercion.rs#L877-L916\n                 let sig1 = ty1.callable_sig(self.db).expect(\"FnDef without callable sig\");\n                 let sig2 = ty2.callable_sig(self.db).expect(\"FnDef without callable sig\");\n-                let ptr_ty1 = Ty::fn_ptr(sig1);\n-                let ptr_ty2 = Ty::fn_ptr(sig2);\n+                let ptr_ty1 = TyBuilder::fn_ptr(sig1);\n+                let ptr_ty2 = TyBuilder::fn_ptr(sig2);\n                 self.coerce_merge_branch(&ptr_ty1, &ptr_ty2)\n             } else {\n                 cov_mark::hit!(coerce_merge_fail_fallback);\n@@ -95,7 +93,7 @@ impl<'a> InferenceContext<'a> {\n             (TyKind::FnDef(..), TyKind::Function { .. }) => match from_ty.callable_sig(self.db) {\n                 None => return false,\n                 Some(sig) => {\n-                    from_ty = Ty::fn_ptr(sig);\n+                    from_ty = TyBuilder::fn_ptr(sig);\n                 }\n             },\n \n@@ -130,18 +128,15 @@ impl<'a> InferenceContext<'a> {\n             _ => return None,\n         };\n \n-        let generic_params = crate::utils::generics(self.db.upcast(), coerce_unsized_trait.into());\n-        if generic_params.len() != 2 {\n-            // The CoerceUnsized trait should have two generic params: Self and T.\n-            return None;\n-        }\n+        let trait_ref = {\n+            let b = TyBuilder::trait_ref(self.db, coerce_unsized_trait);\n+            if b.remaining() != 2 {\n+                // The CoerceUnsized trait should have two generic params: Self and T.\n+                return None;\n+            }\n+            b.push(from_ty.clone()).push(to_ty.clone()).build()\n+        };\n \n-        let substs = Substitution::build_for_generics(&generic_params)\n-            .push(from_ty.clone())\n-            .push(to_ty.clone())\n-            .build();\n-        let trait_ref =\n-            TraitRef { trait_id: to_chalk_trait_id(coerce_unsized_trait), substitution: substs };\n         let goal = InEnvironment::new(self.trait_env.env.clone(), trait_ref.cast(&Interner));\n \n         let canonicalizer = self.canonicalizer();"}, {"sha": "c584a2c0850064bd6059644bc2d6fcdd3fd8db30", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 45, "deletions": 57, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=082996032054031bd1b68ee45ab04293f4877e91", "patch": "@@ -19,11 +19,11 @@ use crate::{\n     lower::lower_to_chalk_mutability,\n     method_resolution, op,\n     primitive::{self, UintTy},\n-    to_assoc_type_id, to_chalk_trait_id,\n+    to_chalk_trait_id,\n     traits::{chalk::from_chalk, FnTrait, InEnvironment},\n     utils::{generics, variant_data, Generics},\n-    AdtId, Binders, CallableDefId, DomainGoal, FnPointer, FnSig, Interner, Rawness, Scalar,\n-    Substitution, TraitRef, Ty, TyKind,\n+    AdtId, Binders, CallableDefId, FnPointer, FnSig, Interner, Rawness, Scalar, Substitution,\n+    TraitRef, Ty, TyBuilder, TyKind,\n };\n \n use super::{\n@@ -73,38 +73,33 @@ impl<'a> InferenceContext<'a> {\n         let fn_once_trait = FnTrait::FnOnce.get_id(self.db, krate)?;\n         let output_assoc_type =\n             self.db.trait_data(fn_once_trait).associated_type_by_name(&name![Output])?;\n-        let generic_params = generics(self.db.upcast(), fn_once_trait.into());\n-        if generic_params.len() != 2 {\n-            return None;\n-        }\n \n-        let mut param_builder = Substitution::builder(num_args);\n         let mut arg_tys = vec![];\n-        for _ in 0..num_args {\n-            let arg = self.table.new_type_var();\n-            param_builder = param_builder.push(arg.clone());\n-            arg_tys.push(arg);\n-        }\n-        let parameters = param_builder.build();\n-        let arg_ty = TyKind::Tuple(num_args, parameters).intern(&Interner);\n-        let substs =\n-            Substitution::build_for_generics(&generic_params).push(ty.clone()).push(arg_ty).build();\n+        let arg_ty = TyBuilder::tuple(num_args)\n+            .fill(repeat_with(|| {\n+                let arg = self.table.new_type_var();\n+                arg_tys.push(arg.clone());\n+                arg\n+            }))\n+            .build();\n+\n+        let projection = {\n+            let b = TyBuilder::assoc_type_projection(self.db, output_assoc_type);\n+            if b.remaining() != 2 {\n+                return None;\n+            }\n+            b.push(ty.clone()).push(arg_ty).build()\n+        };\n \n         let trait_env = self.trait_env.env.clone();\n-        let implements_fn_trait: DomainGoal =\n-            TraitRef { trait_id: to_chalk_trait_id(fn_once_trait), substitution: substs.clone() }\n-                .cast(&Interner);\n-        let goal = self.canonicalizer().canonicalize_obligation(InEnvironment {\n-            goal: implements_fn_trait.clone(),\n+        let obligation = InEnvironment {\n+            goal: projection.trait_ref(self.db).cast(&Interner),\n             environment: trait_env,\n-        });\n-        if self.db.trait_solve(krate, goal.value).is_some() {\n-            self.push_obligation(implements_fn_trait);\n-            let output_proj_ty = crate::ProjectionTy {\n-                associated_ty_id: to_assoc_type_id(output_assoc_type),\n-                substitution: substs,\n-            };\n-            let return_ty = self.normalize_projection_ty(output_proj_ty);\n+        };\n+        let canonical = self.canonicalizer().canonicalize_obligation(obligation.clone());\n+        if self.db.trait_solve(krate, canonical.value).is_some() {\n+            self.push_obligation(obligation.goal);\n+            let return_ty = self.normalize_projection_ty(projection);\n             Some((arg_tys, return_ty))\n         } else {\n             None\n@@ -138,7 +133,7 @@ impl<'a> InferenceContext<'a> {\n                 both_arms_diverge &= mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let else_ty = match else_branch {\n                     Some(else_branch) => self.infer_expr_inner(*else_branch, &expected),\n-                    None => Ty::unit(),\n+                    None => TyBuilder::unit(),\n                 };\n                 both_arms_diverge &= self.diverges;\n \n@@ -193,7 +188,7 @@ impl<'a> InferenceContext<'a> {\n                     break_ty: self.table.new_type_var(),\n                     label: label.map(|label| self.body[label].name.clone()),\n                 });\n-                self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n+                self.infer_expr(*body, &Expectation::has_type(TyBuilder::unit()));\n \n                 let ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n                 if ctxt.may_break {\n@@ -217,11 +212,11 @@ impl<'a> InferenceContext<'a> {\n                     *condition,\n                     &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(&Interner)),\n                 );\n-                self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n+                self.infer_expr(*body, &Expectation::has_type(TyBuilder::unit()));\n                 let _ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n                 // the body may not run, so it diverging doesn't mean we diverge\n                 self.diverges = Diverges::Maybe;\n-                Ty::unit()\n+                TyBuilder::unit()\n             }\n             Expr::For { iterable, body, pat, label } => {\n                 let iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n@@ -236,11 +231,11 @@ impl<'a> InferenceContext<'a> {\n \n                 self.infer_pat(*pat, &pat_ty, BindingMode::default());\n \n-                self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n+                self.infer_expr(*body, &Expectation::has_type(TyBuilder::unit()));\n                 let _ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n                 // the body may not run, so it diverging doesn't mean we diverge\n                 self.diverges = Diverges::Maybe;\n-                Ty::unit()\n+                TyBuilder::unit()\n             }\n             Expr::Lambda { body, args, ret_type, arg_types } => {\n                 assert_eq!(args.len(), arg_types.len());\n@@ -360,7 +355,7 @@ impl<'a> InferenceContext<'a> {\n                 let val_ty = if let Some(expr) = expr {\n                     self.infer_expr(*expr, &Expectation::none())\n                 } else {\n-                    Ty::unit()\n+                    TyBuilder::unit()\n                 };\n \n                 let last_ty =\n@@ -386,7 +381,7 @@ impl<'a> InferenceContext<'a> {\n                 if let Some(expr) = expr {\n                     self.infer_expr_coerce(*expr, &Expectation::has_type(self.return_ty.clone()));\n                 } else {\n-                    let unit = Ty::unit();\n+                    let unit = TyBuilder::unit();\n                     self.coerce(&unit, &self.return_ty.clone());\n                 }\n                 TyKind::Never.intern(&Interner)\n@@ -539,17 +534,10 @@ impl<'a> InferenceContext<'a> {\n             Expr::Box { expr } => {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 if let Some(box_) = self.resolve_boxed_box() {\n-                    let mut sb =\n-                        Substitution::build_for_generics(&generics(self.db.upcast(), box_.into()));\n-                    sb = sb.push(inner_ty);\n-                    match self.db.generic_defaults(box_.into()).get(1) {\n-                        Some(alloc_ty) if !alloc_ty.value.is_unknown() && sb.remaining() > 0 => {\n-                            sb = sb.push(alloc_ty.value.clone());\n-                        }\n-                        _ => (),\n-                    }\n-                    sb = sb.fill(repeat_with(|| self.table.new_type_var()));\n-                    Ty::adt_ty(box_, sb.build())\n+                    TyBuilder::adt(self.db, box_)\n+                        .push(inner_ty)\n+                        .fill_with_defaults(self.db, || self.table.new_type_var())\n+                        .build()\n                 } else {\n                     self.err_ty()\n                 }\n@@ -639,31 +627,31 @@ impl<'a> InferenceContext<'a> {\n                 let rhs_ty = rhs.map(|e| self.infer_expr(e, &rhs_expect));\n                 match (range_type, lhs_ty, rhs_ty) {\n                     (RangeOp::Exclusive, None, None) => match self.resolve_range_full() {\n-                        Some(adt) => Ty::adt_ty(adt, Substitution::empty(&Interner)),\n+                        Some(adt) => TyBuilder::adt(self.db, adt).build(),\n                         None => self.err_ty(),\n                     },\n                     (RangeOp::Exclusive, None, Some(ty)) => match self.resolve_range_to() {\n-                        Some(adt) => Ty::adt_ty(adt, Substitution::single(ty)),\n+                        Some(adt) => TyBuilder::adt(self.db, adt).push(ty).build(),\n                         None => self.err_ty(),\n                     },\n                     (RangeOp::Inclusive, None, Some(ty)) => {\n                         match self.resolve_range_to_inclusive() {\n-                            Some(adt) => Ty::adt_ty(adt, Substitution::single(ty)),\n+                            Some(adt) => TyBuilder::adt(self.db, adt).push(ty).build(),\n                             None => self.err_ty(),\n                         }\n                     }\n                     (RangeOp::Exclusive, Some(_), Some(ty)) => match self.resolve_range() {\n-                        Some(adt) => Ty::adt_ty(adt, Substitution::single(ty)),\n+                        Some(adt) => TyBuilder::adt(self.db, adt).push(ty).build(),\n                         None => self.err_ty(),\n                     },\n                     (RangeOp::Inclusive, Some(_), Some(ty)) => {\n                         match self.resolve_range_inclusive() {\n-                            Some(adt) => Ty::adt_ty(adt, Substitution::single(ty)),\n+                            Some(adt) => TyBuilder::adt(self.db, adt).push(ty).build(),\n                             None => self.err_ty(),\n                         }\n                     }\n                     (RangeOp::Exclusive, Some(ty), None) => match self.resolve_range_from() {\n-                        Some(adt) => Ty::adt_ty(adt, Substitution::single(ty)),\n+                        Some(adt) => TyBuilder::adt(self.db, adt).push(ty).build(),\n                         None => self.err_ty(),\n                     },\n                     (RangeOp::Inclusive, _, None) => self.err_ty(),\n@@ -828,8 +816,8 @@ impl<'a> InferenceContext<'a> {\n                 // we don't even make an attempt at coercion\n                 self.table.new_maybe_never_var()\n             } else {\n-                self.coerce(&Ty::unit(), &expected.coercion_target());\n-                Ty::unit()\n+                self.coerce(&TyBuilder::unit(), &expected.coercion_target());\n+                TyBuilder::unit()\n             }\n         };\n         ty"}, {"sha": "5b70d5e5a2bc634808fa1b953b6d22f7808f7281", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=082996032054031bd1b68ee45ab04293f4877e91", "patch": "@@ -13,9 +13,8 @@ use hir_expand::name::Name;\n \n use super::{BindingMode, Expectation, InferenceContext};\n use crate::{\n-    lower::lower_to_chalk_mutability,\n-    utils::{generics, variant_data},\n-    Interner, Substitution, Ty, TyKind,\n+    lower::lower_to_chalk_mutability, utils::variant_data, Interner, Substitution, Ty, TyBuilder,\n+    TyKind,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -246,23 +245,12 @@ impl<'a> InferenceContext<'a> {\n                     };\n \n                     let inner_ty = self.infer_pat(*inner, &inner_ty, default_bm);\n-                    let mut sb = Substitution::build_for_generics(&generics(\n-                        self.db.upcast(),\n-                        box_adt.into(),\n-                    ));\n-                    sb = sb.push(inner_ty);\n-                    if sb.remaining() == 1 {\n-                        sb = sb.push(match alloc_ty {\n-                            Some(alloc_ty) if !alloc_ty.is_unknown() => alloc_ty,\n-                            _ => match self.db.generic_defaults(box_adt.into()).get(1) {\n-                                Some(alloc_ty) if !alloc_ty.value.is_unknown() => {\n-                                    alloc_ty.value.clone()\n-                                }\n-                                _ => self.table.new_type_var(),\n-                            },\n-                        });\n+                    let mut b = TyBuilder::adt(self.db, box_adt).push(inner_ty);\n+\n+                    if let Some(alloc_ty) = alloc_ty {\n+                        b = b.push(alloc_ty);\n                     }\n-                    Ty::adt_ty(box_adt, sb.build())\n+                    b.fill_with_defaults(self.db, || self.table.new_type_var()).build()\n                 }\n                 None => self.err_ty(),\n             },"}, {"sha": "671ea355f44befff7cb00609e75c7804a6238cd3", "filename": "crates/hir_ty/src/infer/path.rs", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=082996032054031bd1b68ee45ab04293f4877e91", "patch": "@@ -10,9 +10,7 @@ use hir_def::{\n };\n use hir_expand::name::Name;\n \n-use crate::{\n-    method_resolution, to_chalk_trait_id, Interner, Substitution, Ty, TyKind, ValueTyDefId,\n-};\n+use crate::{method_resolution, Interner, Substitution, Ty, TyBuilder, TyKind, ValueTyDefId};\n \n use super::{ExprOrPatId, InferenceContext, TraitRef};\n \n@@ -82,7 +80,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             ValueNs::ImplSelf(impl_id) => {\n                 let generics = crate::utils::generics(self.db.upcast(), impl_id.into());\n-                let substs = Substitution::type_params_for_generics(self.db, &generics);\n+                let substs = generics.type_params_subst(self.db);\n                 let ty = self.db.impl_self_ty(impl_id).subst(&substs);\n                 if let Some((AdtId::StructId(struct_id), substs)) = ty.as_adt() {\n                     let ty = self.db.value_ty(struct_id.into()).subst(&substs);\n@@ -95,16 +93,13 @@ impl<'a> InferenceContext<'a> {\n             ValueNs::GenericParam(it) => return Some(self.db.const_param_ty(it)),\n         };\n \n-        let ty = self.db.value_ty(typable);\n-        // self_subst is just for the parent\n         let parent_substs = self_subst.unwrap_or_else(|| Substitution::empty(&Interner));\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n         let substs = ctx.substs_from_path(path, typable, true);\n-        let full_substs = Substitution::builder(substs.len(&Interner))\n+        let ty = TyBuilder::value_ty(self.db, typable)\n             .use_parent_substs(&parent_substs)\n             .fill(substs.interned(&Interner)[parent_substs.len(&Interner)..].iter().cloned())\n             .build();\n-        let ty = ty.subst(&full_substs);\n         Some(ty)\n     }\n \n@@ -245,7 +240,7 @@ impl<'a> InferenceContext<'a> {\n                 };\n                 let substs = match container {\n                     AssocContainerId::ImplId(impl_id) => {\n-                        let impl_substs = Substitution::build_for_def(self.db, impl_id)\n+                        let impl_substs = TyBuilder::subst_for_def(self.db, impl_id)\n                             .fill(iter::repeat_with(|| self.table.new_type_var()))\n                             .build();\n                         let impl_self_ty = self.db.impl_self_ty(impl_id).subst(&impl_substs);\n@@ -254,18 +249,12 @@ impl<'a> InferenceContext<'a> {\n                     }\n                     AssocContainerId::TraitId(trait_) => {\n                         // we're picking this method\n-                        let trait_substs = Substitution::build_for_def(self.db, trait_)\n+                        let trait_ref = TyBuilder::trait_ref(self.db, trait_)\n                             .push(ty.clone())\n                             .fill(std::iter::repeat_with(|| self.table.new_type_var()))\n                             .build();\n-                        self.push_obligation(\n-                            TraitRef {\n-                                trait_id: to_chalk_trait_id(trait_),\n-                                substitution: trait_substs.clone(),\n-                            }\n-                            .cast(&Interner),\n-                        );\n-                        Some(trait_substs)\n+                        self.push_obligation(trait_ref.clone().cast(&Interner));\n+                        Some(trait_ref.substitution)\n                     }\n                     AssocContainerId::ModuleId(_) => None,\n                 };"}, {"sha": "a04b935ef9f1e5cb43eb3baaa7f7b1833581988a", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=082996032054031bd1b68ee45ab04293f4877e91", "patch": "@@ -186,14 +186,11 @@ pub(crate) fn unify(tys: &Canonical<(Ty, Ty)>) -> Option<Substitution> {\n             );\n         }\n     }\n-    Some(\n-        Substitution::builder(tys.binders.len(&Interner))\n-            .fill(\n-                vars.iter(&Interner)\n-                    .map(|v| table.resolve_ty_completely(v.assert_ty_ref(&Interner).clone())),\n-            )\n-            .build(),\n-    )\n+    Some(Substitution::from_iter(\n+        &Interner,\n+        vars.iter(&Interner)\n+            .map(|v| table.resolve_ty_completely(v.assert_ty_ref(&Interner).clone())),\n+    ))\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "a8c87eadf3ae64fefe442dfca564c8025a744209", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 14, "deletions": 144, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=082996032054031bd1b68ee45ab04293f4877e91", "patch": "@@ -14,6 +14,8 @@ mod lower;\n pub(crate) mod infer;\n pub(crate) mod utils;\n mod chalk_cast;\n+mod chalk_ext;\n+mod builder;\n \n pub mod display;\n pub mod db;\n@@ -24,24 +26,27 @@ mod tests;\n #[cfg(test)]\n mod test_db;\n \n-use std::{iter, mem, sync::Arc};\n+use std::{mem, sync::Arc};\n \n-use base_db::salsa;\n use chalk_ir::cast::{CastTo, Caster};\n-use hir_def::{\n-    builtin_type::BuiltinType, expr::ExprId, type_ref::Rawness, AssocContainerId, FunctionId,\n-    GenericDefId, HasModule, LifetimeParamId, Lookup, TraitId, TypeAliasId, TypeParamId,\n-};\n use itertools::Itertools;\n use smallvec::SmallVec;\n \n+use base_db::salsa;\n+use hir_def::{\n+    expr::ExprId, type_ref::Rawness, AssocContainerId, FunctionId, GenericDefId, HasModule,\n+    LifetimeParamId, Lookup, TraitId, TypeAliasId, TypeParamId,\n+};\n+\n use crate::{\n     db::HirDatabase,\n     display::HirDisplay,\n-    utils::{generics, make_mut_slice, Generics},\n+    utils::{generics, make_mut_slice},\n };\n \n pub use autoderef::autoderef;\n+pub use builder::TyBuilder;\n+pub use chalk_ext::TyExt;\n pub use infer::{could_unify, InferenceResult, InferenceVar};\n pub use lower::{\n     associated_type_shorthand_candidates, callable_item_sig, CallableDefId, ImplTraitLoweringMode,\n@@ -457,104 +462,13 @@ impl Substitution {\n     ) -> Self {\n         Substitution(elements.into_iter().casted(interner).collect())\n     }\n-\n-    /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n-    pub(crate) fn type_params_for_generics(\n-        db: &dyn HirDatabase,\n-        generic_params: &Generics,\n-    ) -> Substitution {\n-        Substitution::from_iter(\n-            &Interner,\n-            generic_params\n-                .iter()\n-                .map(|(id, _)| TyKind::Placeholder(to_placeholder_idx(db, id)).intern(&Interner)),\n-        )\n-    }\n-\n-    /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n-    pub fn type_params(db: &dyn HirDatabase, def: impl Into<GenericDefId>) -> Substitution {\n-        let params = generics(db.upcast(), def.into());\n-        Substitution::type_params_for_generics(db, &params)\n-    }\n-\n-    /// Return Substs that replace each parameter by a bound variable.\n-    pub(crate) fn bound_vars(generic_params: &Generics, debruijn: DebruijnIndex) -> Substitution {\n-        Substitution::from_iter(\n-            &Interner,\n-            generic_params\n-                .iter()\n-                .enumerate()\n-                .map(|(idx, _)| TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(&Interner)),\n-        )\n-    }\n-\n-    pub fn build_for_def(db: &dyn HirDatabase, def: impl Into<GenericDefId>) -> SubstsBuilder {\n-        let def = def.into();\n-        let params = generics(db.upcast(), def);\n-        let param_count = params.len();\n-        Substitution::builder(param_count)\n-    }\n-\n-    pub(crate) fn build_for_generics(generic_params: &Generics) -> SubstsBuilder {\n-        Substitution::builder(generic_params.len())\n-    }\n-\n-    fn builder(param_count: usize) -> SubstsBuilder {\n-        SubstsBuilder { vec: Vec::with_capacity(param_count), param_count }\n-    }\n }\n \n /// Return an index of a parameter in the generic type parameter list by it's id.\n pub fn param_idx(db: &dyn HirDatabase, id: TypeParamId) -> Option<usize> {\n     generics(db.upcast(), id.parent).param_idx(id)\n }\n \n-#[derive(Debug, Clone)]\n-pub struct SubstsBuilder {\n-    vec: Vec<GenericArg>,\n-    param_count: usize,\n-}\n-\n-impl SubstsBuilder {\n-    pub fn build(self) -> Substitution {\n-        assert_eq!(self.vec.len(), self.param_count);\n-        Substitution::from_iter(&Interner, self.vec)\n-    }\n-\n-    pub fn push(mut self, ty: impl CastTo<GenericArg>) -> Self {\n-        self.vec.push(ty.cast(&Interner));\n-        self\n-    }\n-\n-    fn remaining(&self) -> usize {\n-        self.param_count - self.vec.len()\n-    }\n-\n-    pub fn fill_with_bound_vars(self, debruijn: DebruijnIndex, starting_from: usize) -> Self {\n-        self.fill(\n-            (starting_from..)\n-                .map(|idx| TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(&Interner)),\n-        )\n-    }\n-\n-    pub fn fill_with_unknown(self) -> Self {\n-        self.fill(iter::repeat(TyKind::Unknown.intern(&Interner)))\n-    }\n-\n-    pub fn fill(mut self, filler: impl Iterator<Item = impl CastTo<GenericArg>>) -> Self {\n-        self.vec.extend(filler.take(self.remaining()).casted(&Interner));\n-        assert_eq!(self.remaining(), 0);\n-        self\n-    }\n-\n-    pub fn use_parent_substs(mut self, parent_substs: &Substitution) -> Self {\n-        assert!(self.vec.is_empty());\n-        assert!(parent_substs.len(&Interner) <= self.param_count);\n-        self.vec.extend(parent_substs.iter(&Interner).cloned());\n-        self\n-    }\n-}\n-\n #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n pub struct Binders<T> {\n     pub num_binders: usize,\n@@ -760,7 +674,7 @@ impl CallableSig {\n \n     pub fn from_fn_ptr(fn_ptr: &FnPointer) -> CallableSig {\n         CallableSig {\n-            // FIXME: what to do about lifetime params?\n+            // FIXME: what to do about lifetime params? -> return PolyFnSig\n             params_and_return: fn_ptr\n                 .substs\n                 .clone()\n@@ -773,16 +687,6 @@ impl CallableSig {\n         }\n     }\n \n-    pub fn from_substs(substs: &Substitution) -> CallableSig {\n-        CallableSig {\n-            params_and_return: substs\n-                .iter(&Interner)\n-                .map(|arg| arg.assert_ty_ref(&Interner).clone())\n-                .collect(),\n-            is_varargs: false,\n-        }\n-    }\n-\n     pub fn params(&self) -> &[Ty] {\n         &self.params_and_return[0..self.params_and_return.len() - 1]\n     }\n@@ -811,40 +715,6 @@ impl TypeWalk for CallableSig {\n }\n \n impl Ty {\n-    pub fn unit() -> Self {\n-        TyKind::Tuple(0, Substitution::empty(&Interner)).intern(&Interner)\n-    }\n-\n-    pub fn adt_ty(adt: hir_def::AdtId, substs: Substitution) -> Ty {\n-        TyKind::Adt(AdtId(adt), substs).intern(&Interner)\n-    }\n-\n-    pub fn fn_ptr(sig: CallableSig) -> Self {\n-        TyKind::Function(FnPointer {\n-            num_args: sig.params().len(),\n-            sig: FnSig { abi: (), safety: Safety::Safe, variadic: sig.is_varargs },\n-            substs: Substitution::from_iter(&Interner, sig.params_and_return.iter().cloned()),\n-        })\n-        .intern(&Interner)\n-    }\n-\n-    pub fn builtin(builtin: BuiltinType) -> Self {\n-        match builtin {\n-            BuiltinType::Char => TyKind::Scalar(Scalar::Char).intern(&Interner),\n-            BuiltinType::Bool => TyKind::Scalar(Scalar::Bool).intern(&Interner),\n-            BuiltinType::Str => TyKind::Str.intern(&Interner),\n-            BuiltinType::Int(t) => {\n-                TyKind::Scalar(Scalar::Int(primitive::int_ty_from_builtin(t))).intern(&Interner)\n-            }\n-            BuiltinType::Uint(t) => {\n-                TyKind::Scalar(Scalar::Uint(primitive::uint_ty_from_builtin(t))).intern(&Interner)\n-            }\n-            BuiltinType::Float(t) => {\n-                TyKind::Scalar(Scalar::Float(primitive::float_ty_from_builtin(t))).intern(&Interner)\n-            }\n-        }\n-    }\n-\n     pub fn as_reference(&self) -> Option<(&Ty, Mutability)> {\n         match self.kind(&Interner) {\n             TyKind::Ref(mutability, ty) => Some((ty, *mutability)),\n@@ -1068,7 +938,7 @@ impl Ty {\n                 let param_data = &generic_params.types[id.local_id];\n                 match param_data.provenance {\n                     hir_def::generics::TypeParamProvenance::ArgumentImplTrait => {\n-                        let substs = Substitution::type_params(db, id.parent);\n+                        let substs = TyBuilder::type_params_subst(db, id.parent);\n                         let predicates = db\n                             .generic_predicates(id.parent)\n                             .into_iter()"}, {"sha": "214655807675c1e951aadd5370960503807d3965", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 21, "deletions": 28, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=082996032054031bd1b68ee45ab04293f4877e91", "patch": "@@ -36,7 +36,7 @@ use crate::{\n     AliasEq, AliasTy, Binders, BoundVar, CallableSig, DebruijnIndex, DynTy, FnPointer, FnSig,\n     ImplTraitId, OpaqueTy, PolyFnSig, ProjectionTy, QuantifiedWhereClause, QuantifiedWhereClauses,\n     ReturnTypeImplTrait, ReturnTypeImplTraits, Substitution, TraitEnvironment, TraitRef, Ty,\n-    TyKind, TypeWalk, WhereClause,\n+    TyBuilder, TyKind, TypeWalk, WhereClause,\n };\n \n #[derive(Debug)]\n@@ -234,7 +234,7 @@ impl<'a> TyLoweringContext<'a> {\n                         let impl_trait_id = ImplTraitId::ReturnTypeImplTrait(func, idx);\n                         let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n                         let generics = generics(self.db.upcast(), func.into());\n-                        let parameters = Substitution::bound_vars(&generics, self.in_binders);\n+                        let parameters = generics.bound_vars_subst(self.in_binders);\n                         TyKind::Alias(AliasTy::Opaque(OpaqueTy {\n                             opaque_ty_id,\n                             substitution: parameters,\n@@ -411,24 +411,16 @@ impl<'a> TyLoweringContext<'a> {\n             TypeNs::SelfType(impl_id) => {\n                 let generics = generics(self.db.upcast(), impl_id.into());\n                 let substs = match self.type_param_mode {\n-                    TypeParamLoweringMode::Placeholder => {\n-                        Substitution::type_params_for_generics(self.db, &generics)\n-                    }\n-                    TypeParamLoweringMode::Variable => {\n-                        Substitution::bound_vars(&generics, self.in_binders)\n-                    }\n+                    TypeParamLoweringMode::Placeholder => generics.type_params_subst(self.db),\n+                    TypeParamLoweringMode::Variable => generics.bound_vars_subst(self.in_binders),\n                 };\n                 self.db.impl_self_ty(impl_id).subst(&substs)\n             }\n             TypeNs::AdtSelfType(adt) => {\n                 let generics = generics(self.db.upcast(), adt.into());\n                 let substs = match self.type_param_mode {\n-                    TypeParamLoweringMode::Placeholder => {\n-                        Substitution::type_params_for_generics(self.db, &generics)\n-                    }\n-                    TypeParamLoweringMode::Variable => {\n-                        Substitution::bound_vars(&generics, self.in_binders)\n-                    }\n+                    TypeParamLoweringMode::Placeholder => generics.type_params_subst(self.db),\n+                    TypeParamLoweringMode::Variable => generics.bound_vars_subst(self.in_binders),\n                 };\n                 self.db.ty(adt.into()).subst(&substs)\n             }\n@@ -478,12 +470,13 @@ impl<'a> TyLoweringContext<'a> {\n                             TypeParamLoweringMode::Placeholder => {\n                                 // if we're lowering to placeholders, we have to put\n                                 // them in now\n-                                let s = Substitution::type_params(\n-                                    self.db,\n+                                let generics = generics(\n+                                    self.db.upcast(),\n                                     self.resolver.generic_def().expect(\n                                         \"there should be generics if there's a generic param\",\n                                     ),\n                                 );\n+                                let s = generics.type_params_subst(self.db);\n                                 t.substitution.clone().subst_bound_vars(&s)\n                             }\n                             TypeParamLoweringMode::Variable => t.substitution.clone(),\n@@ -860,10 +853,9 @@ pub fn associated_type_shorthand_candidates<R>(\n                 if generics.params.types[param_id.local_id].provenance\n                     == TypeParamProvenance::TraitSelf\n                 {\n-                    let trait_ref = TraitRef {\n-                        trait_id: to_chalk_trait_id(trait_id),\n-                        substitution: Substitution::bound_vars(&generics, DebruijnIndex::INNERMOST),\n-                    };\n+                    let trait_ref = TyBuilder::trait_ref(db, trait_id)\n+                        .fill_with_bound_vars(DebruijnIndex::INNERMOST, 0)\n+                        .build();\n                     return search(trait_ref);\n                 }\n             }\n@@ -972,7 +964,7 @@ pub(crate) fn trait_environment_query(\n         // function default implementations (and hypothetical code\n         // inside consts or type aliases)\n         cov_mark::hit!(trait_self_implements_self);\n-        let substs = Substitution::type_params(db, trait_id);\n+        let substs = TyBuilder::type_params_subst(db, trait_id);\n         let trait_ref = TraitRef { trait_id: to_chalk_trait_id(trait_id), substitution: substs };\n         let pred = WhereClause::Implemented(trait_ref);\n         let program_clause: chalk_ir::ProgramClause<Interner> = pred.to_chalk(db).cast(&Interner);\n@@ -1061,7 +1053,7 @@ fn fn_sig_for_fn(db: &dyn HirDatabase, def: FunctionId) -> PolyFnSig {\n /// function body.\n fn type_for_fn(db: &dyn HirDatabase, def: FunctionId) -> Binders<Ty> {\n     let generics = generics(db.upcast(), def.into());\n-    let substs = Substitution::bound_vars(&generics, DebruijnIndex::INNERMOST);\n+    let substs = generics.bound_vars_subst(DebruijnIndex::INNERMOST);\n     Binders::new(\n         substs.len(&Interner),\n         TyKind::FnDef(CallableDefId::FunctionId(def).to_chalk(db), substs).intern(&Interner),\n@@ -1106,7 +1098,7 @@ fn type_for_struct_constructor(db: &dyn HirDatabase, def: StructId) -> Binders<T\n         return type_for_adt(db, def.into());\n     }\n     let generics = generics(db.upcast(), def.into());\n-    let substs = Substitution::bound_vars(&generics, DebruijnIndex::INNERMOST);\n+    let substs = generics.bound_vars_subst(DebruijnIndex::INNERMOST);\n     Binders::new(\n         substs.len(&Interner),\n         TyKind::FnDef(CallableDefId::StructId(def).to_chalk(db), substs).intern(&Interner),\n@@ -1133,17 +1125,18 @@ fn type_for_enum_variant_constructor(db: &dyn HirDatabase, def: EnumVariantId) -\n         return type_for_adt(db, def.parent.into());\n     }\n     let generics = generics(db.upcast(), def.parent.into());\n-    let substs = Substitution::bound_vars(&generics, DebruijnIndex::INNERMOST);\n+    let substs = generics.bound_vars_subst(DebruijnIndex::INNERMOST);\n     Binders::new(\n         substs.len(&Interner),\n         TyKind::FnDef(CallableDefId::EnumVariantId(def).to_chalk(db), substs).intern(&Interner),\n     )\n }\n \n fn type_for_adt(db: &dyn HirDatabase, adt: AdtId) -> Binders<Ty> {\n-    let generics = generics(db.upcast(), adt.into());\n-    let substs = Substitution::bound_vars(&generics, DebruijnIndex::INNERMOST);\n-    Binders::new(substs.len(&Interner), Ty::adt_ty(adt, substs))\n+    let b = TyBuilder::adt(db, adt);\n+    let num_binders = b.remaining();\n+    let ty = b.fill_with_bound_vars(DebruijnIndex::INNERMOST, 0).build();\n+    Binders::new(num_binders, ty)\n }\n \n fn type_for_type_alias(db: &dyn HirDatabase, t: TypeAliasId) -> Binders<Ty> {\n@@ -1215,7 +1208,7 @@ impl_from!(FunctionId, StructId, UnionId, EnumVariantId, ConstId, StaticId for V\n /// namespace.\n pub(crate) fn ty_query(db: &dyn HirDatabase, def: TyDefId) -> Binders<Ty> {\n     match def {\n-        TyDefId::BuiltinType(it) => Binders::new(0, Ty::builtin(it)),\n+        TyDefId::BuiltinType(it) => Binders::new(0, TyBuilder::builtin(it)),\n         TyDefId::AdtId(it) => type_for_adt(db, it),\n         TyDefId::TypeAliasId(it) => type_for_type_alias(db, it),\n     }"}, {"sha": "a76586f0cc04f7e7864dea57b33d27e1010187d8", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=082996032054031bd1b68ee45ab04293f4877e91", "patch": "@@ -19,10 +19,9 @@ use crate::{\n     db::HirDatabase,\n     from_foreign_def_id,\n     primitive::{self, FloatTy, IntTy, UintTy},\n-    to_chalk_trait_id,\n     utils::all_super_traits,\n     AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, FnPointer, FnSig, ForeignDefId,\n-    InEnvironment, Interner, Scalar, Substitution, TraitEnvironment, TraitRef, Ty, TyKind,\n+    InEnvironment, Interner, Scalar, Substitution, TraitEnvironment, Ty, TyBuilder, TyKind,\n     TypeWalk,\n };\n \n@@ -710,7 +709,7 @@ pub(crate) fn inherent_impl_substs(\n ) -> Option<Substitution> {\n     // we create a var for each type parameter of the impl; we need to keep in\n     // mind here that `self_ty` might have vars of its own\n-    let vars = Substitution::build_for_def(db, impl_id)\n+    let vars = TyBuilder::subst_for_def(db, impl_id)\n         .fill_with_bound_vars(DebruijnIndex::INNERMOST, self_ty.binders.len(&Interner))\n         .build();\n     let self_ty_with_vars = db.impl_self_ty(impl_id).subst(&vars);\n@@ -761,13 +760,13 @@ fn transform_receiver_ty(\n     self_ty: &Canonical<Ty>,\n ) -> Option<Ty> {\n     let substs = match function_id.lookup(db.upcast()).container {\n-        AssocContainerId::TraitId(_) => Substitution::build_for_def(db, function_id)\n+        AssocContainerId::TraitId(_) => TyBuilder::subst_for_def(db, function_id)\n             .push(self_ty.value.clone())\n             .fill_with_unknown()\n             .build(),\n         AssocContainerId::ImplId(impl_id) => {\n             let impl_substs = inherent_impl_substs(db, impl_id, &self_ty)?;\n-            Substitution::build_for_def(db, function_id)\n+            TyBuilder::subst_for_def(db, function_id)\n                 .use_parent_substs(&impl_substs)\n                 .fill_with_unknown()\n                 .build()\n@@ -813,7 +812,7 @@ fn generic_implements_goal(\n     self_ty: Canonical<Ty>,\n ) -> Canonical<InEnvironment<super::DomainGoal>> {\n     let mut kinds = self_ty.binders.interned().to_vec();\n-    let substs = super::Substitution::build_for_def(db, trait_)\n+    let trait_ref = TyBuilder::trait_ref(db, trait_)\n         .push(self_ty.value)\n         .fill_with_bound_vars(DebruijnIndex::INNERMOST, kinds.len())\n         .build();\n@@ -822,9 +821,8 @@ fn generic_implements_goal(\n             chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n             UniverseIndex::ROOT,\n         ))\n-        .take(substs.len(&Interner) - 1),\n+        .take(trait_ref.substitution.len(&Interner) - 1),\n     );\n-    let trait_ref = TraitRef { trait_id: to_chalk_trait_id(trait_), substitution: substs };\n     let obligation = trait_ref.cast(&Interner);\n     Canonical {\n         binders: CanonicalVarKinds::from_iter(&Interner, kinds),"}, {"sha": "90dd31a356c9776d7ff4afa2cf61d82189e2a894", "filename": "crates/hir_ty/src/op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fop.rs?ref=082996032054031bd1b68ee45ab04293f4877e91", "patch": "@@ -2,12 +2,12 @@\n use chalk_ir::TyVariableKind;\n use hir_def::expr::{ArithOp, BinaryOp, CmpOp};\n \n-use crate::{Interner, Scalar, Ty, TyKind};\n+use crate::{Interner, Scalar, Ty, TyBuilder, TyKind};\n \n pub(super) fn binary_op_return_ty(op: BinaryOp, lhs_ty: Ty, rhs_ty: Ty) -> Ty {\n     match op {\n         BinaryOp::LogicOp(_) | BinaryOp::CmpOp(_) => TyKind::Scalar(Scalar::Bool).intern(&Interner),\n-        BinaryOp::Assignment { .. } => Ty::unit(),\n+        BinaryOp::Assignment { .. } => TyBuilder::unit(),\n         BinaryOp::ArithOp(ArithOp::Shl) | BinaryOp::ArithOp(ArithOp::Shr) => {\n             match lhs_ty.kind(&Interner) {\n                 TyKind::Scalar(Scalar::Int(_))"}, {"sha": "541e6082f2ff7a88a5511541dd5d2b2ad3badda5", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=082996032054031bd1b68ee45ab04293f4877e91", "patch": "@@ -22,7 +22,7 @@ use crate::{\n     to_assoc_type_id, to_chalk_trait_id,\n     utils::generics,\n     AliasEq, AliasTy, BoundVar, CallableDefId, DebruijnIndex, FnDefId, ProjectionTy, Substitution,\n-    TraitRef, Ty, TyKind, WhereClause,\n+    TraitRef, Ty, TyBuilder, TyKind, WhereClause,\n };\n use mapping::{\n     convert_where_clauses, generic_predicate_to_inline_bound, make_binders, TypeAliasAsValue,\n@@ -300,7 +300,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         _closure_id: chalk_ir::ClosureId<Interner>,\n         _substs: &chalk_ir::Substitution<Interner>,\n     ) -> chalk_ir::Binders<chalk_ir::Ty<Interner>> {\n-        let ty = Ty::unit().to_chalk(self.db);\n+        let ty = TyBuilder::unit().to_chalk(self.db);\n         make_binders(ty, 0)\n     }\n     fn closure_fn_substitution(\n@@ -387,7 +387,7 @@ pub(crate) fn associated_ty_data_query(\n     // Lower bounds -- we could/should maybe move this to a separate query in `lower`\n     let type_alias_data = db.type_alias_data(type_alias);\n     let generic_params = generics(db.upcast(), type_alias.into());\n-    let bound_vars = Substitution::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n+    let bound_vars = generic_params.bound_vars_subst(DebruijnIndex::INNERMOST);\n     let resolver = hir_def::resolver::HasResolver::resolver(type_alias, db.upcast());\n     let ctx = crate::TyLoweringContext::new(db, &resolver)\n         .with_type_param_mode(crate::lower::TypeParamLoweringMode::Variable);\n@@ -421,7 +421,7 @@ pub(crate) fn trait_datum_query(\n     let trait_data = db.trait_data(trait_);\n     debug!(\"trait {:?} = {:?}\", trait_id, trait_data.name);\n     let generic_params = generics(db.upcast(), trait_.into());\n-    let bound_vars = Substitution::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n+    let bound_vars = generic_params.bound_vars_subst(DebruijnIndex::INNERMOST);\n     let flags = rust_ir::TraitFlags {\n         auto: trait_data.is_auto,\n         upstream: trait_.lookup(db.upcast()).container.krate() != krate,\n@@ -490,7 +490,7 @@ pub(crate) fn struct_datum_query(\n     let upstream = adt_id.module(db.upcast()).krate() != krate;\n     let where_clauses = {\n         let generic_params = generics(db.upcast(), adt_id.into());\n-        let bound_vars = Substitution::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n+        let bound_vars = generic_params.bound_vars_subst(DebruijnIndex::INNERMOST);\n         convert_where_clauses(db, adt_id.into(), &bound_vars)\n     };\n     let flags = rust_ir::AdtFlags {\n@@ -539,7 +539,7 @@ fn impl_def_datum(\n     let impl_data = db.impl_data(impl_id);\n \n     let generic_params = generics(db.upcast(), impl_id.into());\n-    let bound_vars = Substitution::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n+    let bound_vars = generic_params.bound_vars_subst(DebruijnIndex::INNERMOST);\n     let trait_ = trait_ref.hir_trait_id();\n     let impl_type = if impl_id.lookup(db.upcast()).container.krate() == krate {\n         rust_ir::ImplType::Local\n@@ -629,7 +629,7 @@ pub(crate) fn fn_def_datum_query(\n     let callable_def: CallableDefId = from_chalk(db, fn_def_id);\n     let generic_params = generics(db.upcast(), callable_def.into());\n     let sig = db.callable_item_signature(callable_def);\n-    let bound_vars = Substitution::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n+    let bound_vars = generic_params.bound_vars_subst(DebruijnIndex::INNERMOST);\n     let where_clauses = convert_where_clauses(db, callable_def.into(), &bound_vars);\n     let bound = rust_ir::FnDefDatumBound {\n         // Note: Chalk doesn't actually use this information yet as far as I am aware, but we provide it anyway"}, {"sha": "b23e91b1b96cc22b55312acd479660469df83df9", "filename": "crates/hir_ty/src/utils.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fhir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Futils.rs?ref=082996032054031bd1b68ee45ab04293f4877e91", "patch": "@@ -2,7 +2,7 @@\n //! query, but can't be computed directly from `*Data` (ie, which need a `db`).\n use std::sync::Arc;\n \n-use chalk_ir::DebruijnIndex;\n+use chalk_ir::{BoundVar, DebruijnIndex};\n use hir_def::{\n     adt::VariantData,\n     db::DefDatabase,\n@@ -16,7 +16,7 @@ use hir_def::{\n };\n use hir_expand::name::{name, Name};\n \n-use crate::{db::HirDatabase, TraitRef, TypeWalk, WhereClause};\n+use crate::{db::HirDatabase, Interner, Substitution, TraitRef, TyKind, TypeWalk, WhereClause};\n \n fn direct_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n     let resolver = trait_.resolver(db);\n@@ -249,6 +249,26 @@ impl Generics {\n             self.parent_generics.as_ref().and_then(|g| g.find_param(param))\n         }\n     }\n+\n+    /// Returns a Substitution that replaces each parameter by a bound variable.\n+    pub(crate) fn bound_vars_subst(&self, debruijn: DebruijnIndex) -> Substitution {\n+        Substitution::from_iter(\n+            &Interner,\n+            self.iter()\n+                .enumerate()\n+                .map(|(idx, _)| TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(&Interner)),\n+        )\n+    }\n+\n+    /// Returns a Substitution that replaces each parameter by itself (i.e. `Ty::Param`).\n+    pub(crate) fn type_params_subst(&self, db: &dyn HirDatabase) -> Substitution {\n+        Substitution::from_iter(\n+            &Interner,\n+            self.iter().map(|(id, _)| {\n+                TyKind::Placeholder(crate::to_placeholder_idx(db, id)).intern(&Interner)\n+            }),\n+        )\n+    }\n }\n \n fn parent_generic_def(db: &dyn DefDatabase, def: GenericDefId) -> Option<GenericDefId> {"}, {"sha": "d5ef054d807a786292765b1fcd73f97e9f8bf14f", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082996032054031bd1b68ee45ab04293f4877e91/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=082996032054031bd1b68ee45ab04293f4877e91", "patch": "@@ -234,7 +234,7 @@ fn hint_iterator(\n             hir::AssocItem::TypeAlias(alias) if alias.name(db) == known::Item => Some(alias),\n             _ => None,\n         })?;\n-        if let Some(ty) = ty.normalize_trait_assoc_type(db, iter_trait, &[], assoc_type_item) {\n+        if let Some(ty) = ty.normalize_trait_assoc_type(db, &[], assoc_type_item) {\n             const LABEL_START: &str = \"impl Iterator<Item = \";\n             const LABEL_END: &str = \">\";\n "}]}