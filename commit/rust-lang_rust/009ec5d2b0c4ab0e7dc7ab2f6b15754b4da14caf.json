{"sha": "009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwOWVjNWQyYjBjNGFiMGU3ZGM3YWIyZjZiMTU3NTRiNGRhMTRjYWY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-02T17:19:00Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-02T17:19:00Z"}, "message": "rollup merge of #20315: alexcrichton/std-sync\n\nConflicts:\n\tsrc/libstd/rt/exclusive.rs\n\tsrc/libstd/sync/barrier.rs\n\tsrc/libstd/sys/unix/pipe.rs\n\tsrc/test/bench/shootout-binarytrees.rs\n\tsrc/test/bench/shootout-fannkuch-redux.rs", "tree": {"sha": "8b441fd58860857f2e7bf5eabbf2226b92bf13c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b441fd58860857f2e7bf5eabbf2226b92bf13c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "html_url": "https://github.com/rust-lang/rust/commit/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0101bbe7acb38e8113c0cafeb7d5ae0be6448e5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0101bbe7acb38e8113c0cafeb7d5ae0be6448e5b", "html_url": "https://github.com/rust-lang/rust/commit/0101bbe7acb38e8113c0cafeb7d5ae0be6448e5b"}, {"sha": "f3a7ec7028c76b3a1c6051131328f372b068e33a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3a7ec7028c76b3a1c6051131328f372b068e33a", "html_url": "https://github.com/rust-lang/rust/commit/f3a7ec7028c76b3a1c6051131328f372b068e33a"}], "stats": {"total": 959, "additions": 167, "deletions": 792}, "files": [{"sha": "8eb13187e5841b8d1595ca846b0d9606be8c2ef8", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -206,6 +206,7 @@ getting the result later.\n The basic example below illustrates this.\n \n ```{rust,ignore}\n+# #![allow(deprecated)]\n use std::sync::Future;\n \n # fn main() {\n@@ -233,6 +234,7 @@ Here is another example showing how futures allow you to background\n computations. The workload will be distributed on the available cores.\n \n ```{rust,ignore}\n+# #![allow(deprecated)]\n # use std::num::Float;\n # use std::sync::Future;\n fn partial_sum(start: uint) -> f64 {"}, {"sha": "dba05e60ed1c585aaa1fc3b6fea6b97a47c56d15", "filename": "src/doc/guide.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -5339,6 +5339,7 @@ example, if you wish to compute some value in the background, `Future` is\n a useful thing to use:\n \n ```{rust}\n+# #![allow(deprecated)]\n use std::sync::Future;\n \n let mut delayed_value = Future::spawn(move || {"}, {"sha": "38ca90aeeccec23fd3b0a7093dd9c6cdd6c2e874", "filename": "src/doc/reference.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -1480,9 +1480,9 @@ data are being stored, or single-address and mutability properties are required.\n ```\n use std::sync::atomic;\n \n-// Note that INIT_ATOMIC_UINT is a *const*, but it may be used to initialize a\n+// Note that ATOMIC_UINT_INIT is a *const*, but it may be used to initialize a\n // static. This static can be modified, so it is not placed in read-only memory.\n-static COUNTER: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+static COUNTER: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n \n // This table is a candidate to be placed in read-only memory.\n static TABLE: &'static [uint] = &[1, 2, 3, /* ... */];"}, {"sha": "351151c0f07893da4fc5bf31c4c9ff08ef920adc", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -2265,7 +2265,7 @@ mod tests {\n             }\n         }\n         const NUM_ELEMENTS: uint = 2;\n-        static DROP_COUNTER: AtomicUint = atomic::INIT_ATOMIC_UINT;\n+        static DROP_COUNTER: AtomicUint = atomic::ATOMIC_UINT_INIT;\n \n         let v = Vec::from_elem(NUM_ELEMENTS, Nothing);\n "}, {"sha": "f653998c9bf5d471db0b65a7856614ee9634da7a", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -89,17 +89,27 @@ pub enum Ordering {\n \n /// An `AtomicBool` initialized to `false`.\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n-pub const INIT_ATOMIC_BOOL: AtomicBool =\n+pub const ATOMIC_BOOL_INIT: AtomicBool =\n         AtomicBool { v: UnsafeCell { value: 0 } };\n /// An `AtomicInt` initialized to `0`.\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n-pub const INIT_ATOMIC_INT: AtomicInt =\n+pub const ATOMIC_INT_INIT: AtomicInt =\n         AtomicInt { v: UnsafeCell { value: 0 } };\n /// An `AtomicUint` initialized to `0`.\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n-pub const INIT_ATOMIC_UINT: AtomicUint =\n+pub const ATOMIC_UINT_INIT: AtomicUint =\n         AtomicUint { v: UnsafeCell { value: 0, } };\n \n+/// Deprecated\n+#[deprecated = \"renamed to ATOMIC_BOOL_INIT\"]\n+pub const INIT_ATOMIC_BOOL: AtomicBool = ATOMIC_BOOL_INIT;\n+/// Deprecated\n+#[deprecated = \"renamed to ATOMIC_INT_INIT\"]\n+pub const INIT_ATOMIC_INT: AtomicInt = ATOMIC_INT_INIT;\n+/// Deprecated\n+#[deprecated = \"renamed to ATOMIC_UINT_INIT\"]\n+pub const INIT_ATOMIC_UINT: AtomicUint = ATOMIC_UINT_INIT;\n+\n // NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n const UINT_TRUE: uint = -1;\n "}, {"sha": "94e9441abc8b658ba33a76c38699a1fb1e944c7e", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -155,6 +155,8 @@\n // FIXME: Can't be shared between threads. Dynamic borrows\n // FIXME: Relationship to Atomic types and RWLock\n \n+#![stable]\n+\n use clone::Clone;\n use cmp::PartialEq;\n use default::Default;"}, {"sha": "f8e943ec9f651a9bef01e5e5c2388dc6b24beabb", "filename": "src/libcoretest/atomic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibcoretest%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibcoretest%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fatomic.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -70,9 +70,9 @@ fn int_xor() {\n     assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n }\n \n-static S_BOOL : AtomicBool = INIT_ATOMIC_BOOL;\n-static S_INT  : AtomicInt  = INIT_ATOMIC_INT;\n-static S_UINT : AtomicUint = INIT_ATOMIC_UINT;\n+static S_BOOL : AtomicBool = ATOMIC_BOOL_INIT;\n+static S_INT  : AtomicInt  = ATOMIC_INT_INIT;\n+static S_UINT : AtomicUint = ATOMIC_UINT_INIT;\n \n #[test]\n fn static_init() {"}, {"sha": "4ee5b2d5e834991db0dcde74e74ceef76a1d92f2", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -352,7 +352,7 @@ pub struct LogLocation {\n #[doc(hidden)]\n pub fn mod_enabled(level: u32, module: &str) -> bool {\n     static INIT: Once = ONCE_INIT;\n-    INIT.doit(init);\n+    INIT.call_once(init);\n \n     // It's possible for many threads are in this function, only one of them\n     // will perform the global initialization, but all of them will need to check"}, {"sha": "b6020fe5ce38bf3d142ff2b826ac408914e6235c", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -73,7 +73,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n     let output_path = {\n         let output_template = match requested_output {\n             Some(ref s) if s.as_slice() == \"help\" => {\n-                static PRINTED_YET : atomic::AtomicBool = atomic::INIT_ATOMIC_BOOL;\n+                static PRINTED_YET : atomic::AtomicBool = atomic::ATOMIC_BOOL_INIT;\n                 if !PRINTED_YET.load(atomic::SeqCst) {\n                     print_help_message();\n                     PRINTED_YET.store(true, atomic::SeqCst);"}, {"sha": "cb1954f3ff7638a6ecf97c8555d6ce68b8cff0e0", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -1011,7 +1011,7 @@ unsafe fn configure_llvm(sess: &Session) {\n         }\n     }\n \n-    INIT.doit(|| {\n+    INIT.call_once(|| {\n         llvm::LLVMInitializePasses();\n \n         // Only initialize the platforms supported by Rust here, because"}, {"sha": "bf53885e9e50d83ae7590d97b669997831b9fca0", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -3097,7 +3097,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n         use std::sync::{Once, ONCE_INIT};\n         static INIT: Once = ONCE_INIT;\n         static mut POISONED: bool = false;\n-        INIT.doit(|| {\n+        INIT.call_once(|| {\n             if llvm::LLVMStartMultithreaded() != 1 {\n                 // use an extra bool to make sure that all future usage of LLVM\n                 // cannot proceed despite the Once not running more than once."}, {"sha": "852cab500f6731e714534f0e1efb369f05bf0d8a", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -22,7 +22,6 @@ use result::Result::{Ok, Err};\n use slice::{SliceExt};\n use slice;\n use vec::Vec;\n-use kinds::{Send,Sync};\n \n /// Wraps a Reader and buffers input from it\n ///\n@@ -52,11 +51,6 @@ pub struct BufferedReader<R> {\n     cap: uint,\n }\n \n-\n-unsafe impl<R: Send> Send for BufferedReader<R> {}\n-unsafe impl<R: Send+Sync> Sync for BufferedReader<R> {}\n-\n-\n impl<R: Reader> BufferedReader<R> {\n     /// Creates a new `BufferedReader` with the specified buffer capacity\n     pub fn with_capacity(cap: uint, inner: R) -> BufferedReader<R> {"}, {"sha": "ba709b2dc74fe7a9f3a6375ac7586997c7964901", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -218,7 +218,7 @@ pub fn stdin() -> StdinReader {\n     static ONCE: Once = ONCE_INIT;\n \n     unsafe {\n-        ONCE.doit(|| {\n+        ONCE.call_once(|| {\n             // The default buffer capacity is 64k, but apparently windows doesn't like\n             // 64k reads on stdin. See #13304 for details, but the idea is that on\n             // windows we use a slightly smaller buffer that's been seen to be"}, {"sha": "5cf8667665162ebf34b84e81cd75eaba3b919bab", "filename": "src/libstd/io/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fio%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fio%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftempfile.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -90,7 +90,7 @@ impl TempDir {\n             return TempDir::new_in(&abs_tmpdir, suffix);\n         }\n \n-        static CNT: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+        static CNT: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n \n         let mut attempts = 0u;\n         loop {"}, {"sha": "2f87abd0ee2fc6731a7d38887af16ca08f821206", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -17,17 +17,17 @@ use prelude::v1::*;\n use libc;\n use os;\n use std::io::net::ip::*;\n-use sync::atomic::{AtomicUint, INIT_ATOMIC_UINT, Relaxed};\n+use sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Relaxed};\n \n /// Get a port number, starting at 9600, for use in tests\n pub fn next_test_port() -> u16 {\n-    static NEXT_OFFSET: AtomicUint = INIT_ATOMIC_UINT;\n+    static NEXT_OFFSET: AtomicUint = ATOMIC_UINT_INIT;\n     base_port() + NEXT_OFFSET.fetch_add(1, Relaxed) as u16\n }\n \n /// Get a temporary path which could be the location of a unix socket\n pub fn next_test_unix() -> Path {\n-    static COUNT: AtomicUint = INIT_ATOMIC_UINT;\n+    static COUNT: AtomicUint = ATOMIC_UINT_INIT;\n     // base port and pid are an attempt to be unique between multiple\n     // test-runners of different configurations running on one\n     // buildbot, the count is to be unique within this executable."}, {"sha": "02e520daaf277d36e652debdcbcdda861912ddc9", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -55,7 +55,7 @@ use slice::{AsSlice, SliceExt};\n use slice::CloneSliceExt;\n use str::{Str, StrExt};\n use string::{String, ToString};\n-use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n+use sync::atomic::{AtomicInt, ATOMIC_INT_INIT, SeqCst};\n use vec::Vec;\n \n #[cfg(unix)] use c_str::ToCStr;\n@@ -596,7 +596,7 @@ pub fn last_os_error() -> String {\n     error_string(errno() as uint)\n }\n \n-static EXIT_STATUS: AtomicInt = INIT_ATOMIC_INT;\n+static EXIT_STATUS: AtomicInt = ATOMIC_INT_INIT;\n \n /// Sets the process exit code\n ///"}, {"sha": "9f3ac84afff514b33e622dc69f31c47e0d6d634b", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -84,10 +84,10 @@ mod imp {\n     #[cfg(all(target_os = \"linux\",\n               any(target_arch = \"x86_64\", target_arch = \"x86\", target_arch = \"arm\")))]\n     fn is_getrandom_available() -> bool {\n-        use sync::atomic::{AtomicBool, INIT_ATOMIC_BOOL, Relaxed};\n+        use sync::atomic::{AtomicBool, ATOMIC_BOOL_INIT, Relaxed};\n \n-        static GETRANDOM_CHECKED: AtomicBool = INIT_ATOMIC_BOOL;\n-        static GETRANDOM_AVAILABLE: AtomicBool = INIT_ATOMIC_BOOL;\n+        static GETRANDOM_CHECKED: AtomicBool = ATOMIC_BOOL_INIT;\n+        static GETRANDOM_AVAILABLE: AtomicBool = ATOMIC_BOOL_INIT;\n \n         if !GETRANDOM_CHECKED.load(Relaxed) {\n             let mut buf: [u8; 0] = [];"}, {"sha": "ae405e9400b374a1ced5166dc320186008bf1b04", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -22,7 +22,7 @@ pub use sys::backtrace::write;\n // For now logging is turned off by default, and this function checks to see\n // whether the magical environment variable is present to see if it's turned on.\n pub fn log_enabled() -> bool {\n-    static ENABLED: atomic::AtomicInt = atomic::INIT_ATOMIC_INT;\n+    static ENABLED: atomic::AtomicInt = atomic::ATOMIC_INT_INIT;\n     match ENABLED.load(atomic::SeqCst) {\n         1 => return false,\n         2 => return true,"}, {"sha": "eb6b36554445767def015a22d71dfaf61abdfece", "filename": "src/libstd/rt/exclusive.rs", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/0101bbe7acb38e8113c0cafeb7d5ae0be6448e5b/src%2Flibstd%2Frt%2Fexclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0101bbe7acb38e8113c0cafeb7d5ae0be6448e5b/src%2Flibstd%2Frt%2Fexclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fexclusive.rs?ref=0101bbe7acb38e8113c0cafeb7d5ae0be6448e5b", "patch": "@@ -1,119 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use core::prelude::*;\n-\n-use cell::UnsafeCell;\n-use rt::mutex;\n-\n-/// An OS mutex over some data.\n-///\n-/// This is not a safe primitive to use, it is unaware of the libgreen\n-/// scheduler, as well as being easily susceptible to misuse due to the usage of\n-/// the inner NativeMutex.\n-///\n-/// > **Note**: This type is not recommended for general use. The mutex provided\n-/// >           as part of `libsync` should almost always be favored.\n-pub struct Exclusive<T> {\n-    lock: mutex::NativeMutex,\n-    data: UnsafeCell<T>,\n-}\n-\n-unsafe impl<T:Send> Send for Exclusive<T> { }\n-\n-unsafe impl<T:Send> Sync for Exclusive<T> { }\n-\n-/// An RAII guard returned via `lock`\n-pub struct ExclusiveGuard<'a, T:'a> {\n-    // FIXME #12808: strange name to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _data: &'a mut T,\n-    _guard: mutex::LockGuard<'a>,\n-}\n-\n-impl<T: Send> Exclusive<T> {\n-    /// Creates a new `Exclusive` which will protect the data provided.\n-    pub fn new(user_data: T) -> Exclusive<T> {\n-        Exclusive {\n-            lock: unsafe { mutex::NativeMutex::new() },\n-            data: UnsafeCell::new(user_data),\n-        }\n-    }\n-\n-    /// Acquires this lock, returning a guard which the data is accessed through\n-    /// and from which that lock will be unlocked.\n-    ///\n-    /// This method is unsafe due to many of the same reasons that the\n-    /// NativeMutex itself is unsafe.\n-    pub unsafe fn lock<'a>(&'a self) -> ExclusiveGuard<'a, T> {\n-        let guard = self.lock.lock();\n-        let data = &mut *self.data.get();\n-\n-        ExclusiveGuard {\n-            _data: data,\n-            _guard: guard,\n-        }\n-    }\n-}\n-\n-impl<'a, T: Send> ExclusiveGuard<'a, T> {\n-    // The unsafety here should be ok because our loan guarantees that the lock\n-    // itself is not moving\n-    pub fn signal(&self) {\n-        unsafe { self._guard.signal() }\n-    }\n-    pub fn wait(&self) {\n-        unsafe { self._guard.wait() }\n-    }\n-}\n-\n-impl<'a, T: Send> Deref<T> for ExclusiveGuard<'a, T> {\n-    fn deref(&self) -> &T { &*self._data }\n-}\n-impl<'a, T: Send> DerefMut<T> for ExclusiveGuard<'a, T> {\n-    fn deref_mut(&mut self) -> &mut T { &mut *self._data }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::v1::*;\n-    use sync::Arc;\n-    use super::Exclusive;\n-    use task;\n-\n-    #[test]\n-    fn exclusive_new_arc() {\n-        unsafe {\n-            let mut futures = Vec::new();\n-\n-            let num_tasks = 10;\n-            let count = 10;\n-\n-            let total = Arc::new(Exclusive::new(box 0));\n-\n-            for _ in range(0u, num_tasks) {\n-                let total = total.clone();\n-                let (tx, rx) = channel();\n-                futures.push(rx);\n-\n-                task::spawn(move || {\n-                    for _ in range(0u, count) {\n-                        **total.lock() += 1;\n-                    }\n-                    tx.send(());\n-                });\n-            };\n-\n-            for f in futures.iter_mut() { f.recv() }\n-\n-            assert_eq!(**total.lock(), num_tasks * count);\n-        }\n-    }\n-}"}, {"sha": "48cdfc20a351a8eacf10e57a7825172e072315dc", "filename": "src/libstd/rt/task.rs", "status": "removed", "additions": 0, "deletions": 554, "changes": 554, "blob_url": "https://github.com/rust-lang/rust/blob/0101bbe7acb38e8113c0cafeb7d5ae0be6448e5b/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0101bbe7acb38e8113c0cafeb7d5ae0be6448e5b/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=0101bbe7acb38e8113c0cafeb7d5ae0be6448e5b", "patch": "@@ -1,554 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Language-level runtime services that should reasonably expected\n-//! to be available 'everywhere'. Unwinding, local storage, and logging.\n-//! Even a 'freestanding' Rust would likely want to implement this.\n-\n-pub use self::BlockedTask::*;\n-use self::TaskState::*;\n-\n-use any::Any;\n-use boxed::Box;\n-use sync::Arc;\n-use sync::atomic::{AtomicUint, SeqCst};\n-use iter::{IteratorExt, Take};\n-use kinds::marker;\n-use mem;\n-use ops::FnMut;\n-use core::prelude::{Clone, Drop, Err, Iterator, None, Ok, Option, Send, Some};\n-use core::prelude::{drop};\n-use str::SendStr;\n-use thunk::Thunk;\n-\n-use rt;\n-use rt::mutex::NativeMutex;\n-use rt::local::Local;\n-use rt::thread::{mod, Thread};\n-use sys_common::stack;\n-use rt::unwind;\n-use rt::unwind::Unwinder;\n-\n-/// State associated with Rust threads\n-///\n-/// This structure is currently undergoing major changes, and is\n-/// likely to be move/be merged with a `Thread` structure.\n-pub struct Task {\n-    pub unwinder: Unwinder,\n-    pub death: Death,\n-    pub name: Option<SendStr>,\n-\n-    state: TaskState,\n-    lock: NativeMutex,       // native synchronization\n-    awoken: bool,            // used to prevent spurious wakeups\n-\n-    // This field holds the known bounds of the stack in (lo, hi) form. Not all\n-    // native threads necessarily know their precise bounds, hence this is\n-    // optional.\n-    stack_bounds: (uint, uint),\n-\n-    stack_guard: uint\n-}\n-\n-// Once a thread has entered the `Armed` state it must be destroyed via `drop`,\n-// and no other method. This state is used to track this transition.\n-#[deriving(PartialEq)]\n-enum TaskState {\n-    New,\n-    Armed,\n-    Destroyed,\n-}\n-\n-pub struct TaskOpts {\n-    /// Invoke this procedure with the result of the thread when it finishes.\n-    pub on_exit: Option<Thunk<Result>>,\n-    /// A name for the thread-to-be, for identification in panic messages\n-    pub name: Option<SendStr>,\n-    /// The size of the stack for the spawned thread\n-    pub stack_size: Option<uint>,\n-}\n-\n-/// Indicates the manner in which a thread exited.\n-///\n-/// A thread that completes without panicking is considered to exit successfully.\n-///\n-/// If you wish for this result's delivery to block until all\n-/// children threads complete, recommend using a result future.\n-pub type Result = ::core::result::Result<(), Box<Any + Send>>;\n-\n-/// A handle to a blocked thread. Usually this means having the Box<Task>\n-/// pointer by ownership, but if the thread is killable, a killer can steal it\n-/// at any time.\n-pub enum BlockedTask {\n-    Owned(Box<Task>),\n-    Shared(Arc<AtomicUint>),\n-}\n-\n-/// Per-thread state related to thread death, killing, panic, etc.\n-pub struct Death {\n-    pub on_exit: Option<Thunk<Result>>,\n-}\n-\n-pub struct BlockedTasks {\n-    inner: Arc<AtomicUint>,\n-}\n-\n-impl Task {\n-    /// Creates a new uninitialized thread.\n-    pub fn new(stack_bounds: Option<(uint, uint)>, stack_guard: Option<uint>) -> Task {\n-        Task {\n-            unwinder: Unwinder::new(),\n-            death: Death::new(),\n-            state: New,\n-            name: None,\n-            lock: unsafe { NativeMutex::new() },\n-            awoken: false,\n-            // these *should* get overwritten\n-            stack_bounds: stack_bounds.unwrap_or((0, 0)),\n-            stack_guard: stack_guard.unwrap_or(0)\n-        }\n-    }\n-\n-    pub fn spawn<F>(opts: TaskOpts, f: F)\n-        where F : FnOnce(), F : Send\n-    {\n-        Task::spawn_thunk(opts, Thunk::new(f))\n-    }\n-\n-    fn spawn_thunk(opts: TaskOpts, f: Thunk) {\n-        let TaskOpts { name, stack_size, on_exit } = opts;\n-\n-        let mut task = box Task::new(None, None);\n-        task.name = name;\n-        task.death.on_exit = on_exit;\n-\n-        let stack = stack_size.unwrap_or(rt::min_stack());\n-\n-        // Spawning a new OS thread guarantees that __morestack will never get\n-        // triggered, but we must manually set up the actual stack bounds once\n-        // this function starts executing. This raises the lower limit by a bit\n-        // because by the time that this function is executing we've already\n-        // consumed at least a little bit of stack (we don't know the exact byte\n-        // address at which our stack started).\n-        Thread::spawn_stack(stack, move|| {\n-            let something_around_the_top_of_the_stack = 1;\n-            let addr = &something_around_the_top_of_the_stack as *const int;\n-            let my_stack = addr as uint;\n-            unsafe {\n-                stack::record_os_managed_stack_bounds(my_stack - stack + 1024,\n-                                                      my_stack);\n-            }\n-            task.stack_guard = thread::current_guard_page();\n-            task.stack_bounds = (my_stack - stack + 1024, my_stack);\n-\n-            let mut f = Some(f);\n-            drop(task.run(|| { f.take().unwrap().invoke(()) }).destroy());\n-        })\n-    }\n-\n-    /// Consumes ownership of a thread, runs some code, and returns the thread back.\n-    ///\n-    /// This function can be used as an emulated \"try/catch\" to interoperate\n-    /// with the rust runtime at the outermost boundary. It is not possible to\n-    /// use this function in a nested fashion (a try/catch inside of another\n-    /// try/catch). Invoking this function is quite cheap.\n-    ///\n-    /// If the closure `f` succeeds, then the returned thread can be used again\n-    /// for another invocation of `run`. If the closure `f` panics then `self`\n-    /// will be internally destroyed along with all of the other associated\n-    /// resources of this thread. The `on_exit` callback is invoked with the\n-    /// cause of panic (not returned here). This can be discovered by querying\n-    /// `is_destroyed()`.\n-    ///\n-    /// Note that it is possible to view partial execution of the closure `f`\n-    /// because it is not guaranteed to run to completion, but this function is\n-    /// guaranteed to return if it panicks. Care should be taken to ensure that\n-    /// stack references made by `f` are handled appropriately.\n-    ///\n-    /// It is invalid to call this function with a thread that has been previously\n-    /// destroyed via a failed call to `run`.\n-    pub fn run<F>(mut self: Box<Task>, f: F) -> Box<Task> where F: FnOnce() {\n-        assert!(!self.is_destroyed(), \"cannot re-use a destroyed thread\");\n-\n-        // First, make sure that no one else is in TLS. This does not allow\n-        // recursive invocations of run(). If there's no one else, then\n-        // relinquish ownership of ourselves back into TLS.\n-        if Local::exists(None::<Task>) {\n-            panic!(\"cannot run a thread recursively inside another\");\n-        }\n-        self.state = Armed;\n-        Local::put(self);\n-\n-        // There are two primary reasons that general try/catch is unsafe. The\n-        // first is that we do not support nested try/catch. The above check for\n-        // an existing thread in TLS is sufficient for this invariant to be\n-        // upheld. The second is that unwinding while unwinding is not defined.\n-        // We take care of that by having an 'unwinding' flag in the thread\n-        // itself. For these reasons, this unsafety should be ok.\n-        let result = unsafe { unwind::try(f) };\n-\n-        // After running the closure given return the thread back out if it ran\n-        // successfully, or clean up the thread if it panicked.\n-        let task: Box<Task> = Local::take();\n-        match result {\n-            Ok(()) => task,\n-            Err(cause) => { task.cleanup(Err(cause)) }\n-        }\n-    }\n-\n-    /// Destroy all associated resources of this thread.\n-    ///\n-    /// This function will perform any necessary clean up to prepare the thread\n-    /// for destruction. It is required that this is called before a `Task`\n-    /// falls out of scope.\n-    ///\n-    /// The returned thread cannot be used for running any more code, but it may\n-    /// be used to extract the runtime as necessary.\n-    pub fn destroy(self: Box<Task>) -> Box<Task> {\n-        if self.is_destroyed() {\n-            self\n-        } else {\n-            self.cleanup(Ok(()))\n-        }\n-    }\n-\n-    /// Cleans up a thread, processing the result of the thread as appropriate.\n-    ///\n-    /// This function consumes ownership of the thread, deallocating it once it's\n-    /// done being processed. It is assumed that TLD and the local heap have\n-    /// already been destroyed and/or annihilated.\n-    fn cleanup(mut self: Box<Task>, result: Result) -> Box<Task> {\n-        // After taking care of the data above, we need to transmit the result\n-        // of this thread.\n-        let what_to_do = self.death.on_exit.take();\n-        Local::put(self);\n-\n-        // FIXME: this is running in a seriously constrained context. If this\n-        //        allocates TLD then it will likely abort the runtime. Similarly,\n-        //        if this panics, this will also likely abort the runtime.\n-        //\n-        //        This closure is currently limited to a channel send via the\n-        //        standard library's thread interface, but this needs\n-        //        reconsideration to whether it's a reasonable thing to let a\n-        //        thread to do or not.\n-        match what_to_do {\n-            Some(f) => { f.invoke(result) }\n-            None => { drop(result) }\n-        }\n-\n-        // Now that we're done, we remove the thread from TLS and flag it for\n-        // destruction.\n-        let mut task: Box<Task> = Local::take();\n-        task.state = Destroyed;\n-        return task;\n-    }\n-\n-    /// Queries whether this can be destroyed or not.\n-    pub fn is_destroyed(&self) -> bool { self.state == Destroyed }\n-\n-    /// Deschedules the current thread, invoking `f` `amt` times. It is not\n-    /// recommended to use this function directly, but rather communication\n-    /// primitives in `std::comm` should be used.\n-    //\n-    // This function gets a little interesting. There are a few safety and\n-    // ownership violations going on here, but this is all done in the name of\n-    // shared state. Additionally, all of the violations are protected with a\n-    // mutex, so in theory there are no races.\n-    //\n-    // The first thing we need to do is to get a pointer to the thread's internal\n-    // mutex. This address will not be changing (because the thread is allocated\n-    // on the heap). We must have this handle separately because the thread will\n-    // have its ownership transferred to the given closure. We're guaranteed,\n-    // however, that this memory will remain valid because *this* is the current\n-    // thread's execution thread.\n-    //\n-    // The next weird part is where ownership of the thread actually goes. We\n-    // relinquish it to the `f` blocking function, but upon returning this\n-    // function needs to replace the thread back in TLS. There is no communication\n-    // from the wakeup thread back to this thread about the thread pointer, and\n-    // there's really no need to. In order to get around this, we cast the thread\n-    // to a `uint` which is then used at the end of this function to cast back\n-    // to a `Box<Task>` object. Naturally, this looks like it violates\n-    // ownership semantics in that there may be two `Box<Task>` objects.\n-    //\n-    // The fun part is that the wakeup half of this implementation knows to\n-    // \"forget\" the thread on the other end. This means that the awakening half of\n-    // things silently relinquishes ownership back to this thread, but not in a\n-    // way that the compiler can understand. The thread's memory is always valid\n-    // for both threads because these operations are all done inside of a mutex.\n-    //\n-    // You'll also find that if blocking fails (the `f` function hands the\n-    // BlockedTask back to us), we will `mem::forget` the handles. The\n-    // reasoning for this is the same logic as above in that the thread silently\n-    // transfers ownership via the `uint`, not through normal compiler\n-    // semantics.\n-    //\n-    // On a mildly unrelated note, it should also be pointed out that OS\n-    // condition variables are susceptible to spurious wakeups, which we need to\n-    // be ready for. In order to accommodate for this fact, we have an extra\n-    // `awoken` field which indicates whether we were actually woken up via some\n-    // invocation of `reawaken`. This flag is only ever accessed inside the\n-    // lock, so there's no need to make it atomic.\n-    pub fn deschedule<F>(mut self: Box<Task>, times: uint, mut f: F) where\n-        F: FnMut(BlockedTask) -> ::core::result::Result<(), BlockedTask>,\n-    {\n-        unsafe {\n-            let me = &mut *self as *mut Task;\n-            let task = BlockedTask::block(self);\n-\n-            if times == 1 {\n-                let guard = (*me).lock.lock();\n-                (*me).awoken = false;\n-                match f(task) {\n-                    Ok(()) => {\n-                        while !(*me).awoken {\n-                            guard.wait();\n-                        }\n-                    }\n-                    Err(task) => { mem::forget(task.wake()); }\n-                }\n-            } else {\n-                let iter = task.make_selectable(times);\n-                let guard = (*me).lock.lock();\n-                (*me).awoken = false;\n-\n-                // Apply the given closure to all of the \"selectable threads\",\n-                // bailing on the first one that produces an error. Note that\n-                // care must be taken such that when an error is occurred, we\n-                // may not own the thread, so we may still have to wait for the\n-                // thread to become available. In other words, if thread.wake()\n-                // returns `None`, then someone else has ownership and we must\n-                // wait for their signal.\n-                match iter.map(f).filter_map(|a| a.err()).next() {\n-                    None => {}\n-                    Some(task) => {\n-                        match task.wake() {\n-                            Some(task) => {\n-                                mem::forget(task);\n-                                (*me).awoken = true;\n-                            }\n-                            None => {}\n-                        }\n-                    }\n-                }\n-                while !(*me).awoken {\n-                    guard.wait();\n-                }\n-            }\n-            // put the thread back in TLS, and everything is as it once was.\n-            Local::put(mem::transmute(me));\n-        }\n-    }\n-\n-    /// Wakes up a previously blocked thread. This function can only be\n-    /// called on threads that were previously blocked in `deschedule`.\n-    //\n-    // See the comments on `deschedule` for why the thread is forgotten here, and\n-    // why it's valid to do so.\n-    pub fn reawaken(mut self: Box<Task>) {\n-        unsafe {\n-            let me = &mut *self as *mut Task;\n-            mem::forget(self);\n-            let guard = (*me).lock.lock();\n-            (*me).awoken = true;\n-            guard.signal();\n-        }\n-    }\n-\n-    /// Yields control of this thread to another thread. This function will\n-    /// eventually return, but possibly not immediately. This is used as an\n-    /// opportunity to allow other threads a chance to run.\n-    pub fn yield_now() {\n-        Thread::yield_now();\n-    }\n-\n-    /// Returns the stack bounds for this thread in (lo, hi) format. The stack\n-    /// bounds may not be known for all threads, so the return value may be\n-    /// `None`.\n-    pub fn stack_bounds(&self) -> (uint, uint) {\n-        self.stack_bounds\n-    }\n-\n-    /// Returns the stack guard for this thread, if known.\n-    pub fn stack_guard(&self) -> Option<uint> {\n-        if self.stack_guard != 0 {\n-            Some(self.stack_guard)\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Consume this thread, flagging it as a candidate for destruction.\n-    ///\n-    /// This function is required to be invoked to destroy a thread. A thread\n-    /// destroyed through a normal drop will abort.\n-    pub fn drop(mut self) {\n-        self.state = Destroyed;\n-    }\n-}\n-\n-impl Drop for Task {\n-    fn drop(&mut self) {\n-        rtdebug!(\"called drop for a thread: {}\", self as *mut Task as uint);\n-        rtassert!(self.state != Armed);\n-    }\n-}\n-\n-impl TaskOpts {\n-    pub fn new() -> TaskOpts {\n-        TaskOpts { on_exit: None, name: None, stack_size: None }\n-    }\n-}\n-\n-impl Iterator<BlockedTask> for BlockedTasks {\n-    fn next(&mut self) -> Option<BlockedTask> {\n-        Some(Shared(self.inner.clone()))\n-    }\n-}\n-\n-impl BlockedTask {\n-    /// Returns Some if the thread was successfully woken; None if already killed.\n-    pub fn wake(self) -> Option<Box<Task>> {\n-        match self {\n-            Owned(task) => Some(task),\n-            Shared(arc) => {\n-                match arc.swap(0, SeqCst) {\n-                    0 => None,\n-                    n => Some(unsafe { mem::transmute(n) }),\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Reawakens this thread if ownership is acquired. If finer-grained control\n-    /// is desired, use `wake` instead.\n-    pub fn reawaken(self) {\n-        self.wake().map(|t| t.reawaken());\n-    }\n-\n-    // This assertion has two flavours because the wake involves an atomic op.\n-    // In the faster version, destructors will panic dramatically instead.\n-    #[cfg(not(test))] pub fn trash(self) { }\n-    #[cfg(test)]      pub fn trash(self) { assert!(self.wake().is_none()); }\n-\n-    /// Create a blocked thread, unless the thread was already killed.\n-    pub fn block(task: Box<Task>) -> BlockedTask {\n-        Owned(task)\n-    }\n-\n-    /// Converts one blocked thread handle to a list of many handles to the same.\n-    pub fn make_selectable(self, num_handles: uint) -> Take<BlockedTasks> {\n-        let arc = match self {\n-            Owned(task) => {\n-                let flag = unsafe { AtomicUint::new(mem::transmute(task)) };\n-                Arc::new(flag)\n-            }\n-            Shared(arc) => arc.clone(),\n-        };\n-        BlockedTasks{ inner: arc }.take(num_handles)\n-    }\n-\n-    /// Convert to an unsafe uint value. Useful for storing in a pipe's state\n-    /// flag.\n-    #[inline]\n-    pub unsafe fn cast_to_uint(self) -> uint {\n-        match self {\n-            Owned(task) => {\n-                let blocked_task_ptr: uint = mem::transmute(task);\n-                rtassert!(blocked_task_ptr & 0x1 == 0);\n-                blocked_task_ptr\n-            }\n-            Shared(arc) => {\n-                let blocked_task_ptr: uint = mem::transmute(box arc);\n-                rtassert!(blocked_task_ptr & 0x1 == 0);\n-                blocked_task_ptr | 0x1\n-            }\n-        }\n-    }\n-\n-    /// Convert from an unsafe uint value. Useful for retrieving a pipe's state\n-    /// flag.\n-    #[inline]\n-    pub unsafe fn cast_from_uint(blocked_task_ptr: uint) -> BlockedTask {\n-        if blocked_task_ptr & 0x1 == 0 {\n-            Owned(mem::transmute(blocked_task_ptr))\n-        } else {\n-            let ptr: Box<Arc<AtomicUint>> =\n-                mem::transmute(blocked_task_ptr & !1);\n-            Shared(*ptr)\n-        }\n-    }\n-}\n-\n-impl Death {\n-    pub fn new() -> Death {\n-        Death { on_exit: None }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    use prelude::v1::*;\n-    use task;\n-    use rt::unwind;\n-\n-    #[test]\n-    fn unwind() {\n-        let result = task::try(move|| ());\n-        rtdebug!(\"trying first assert\");\n-        assert!(result.is_ok());\n-        let result = task::try(move|| -> () panic!());\n-        rtdebug!(\"trying second assert\");\n-        assert!(result.is_err());\n-    }\n-\n-    #[test]\n-    fn rng() {\n-        use rand::{StdRng, Rng};\n-        let mut r = StdRng::new().ok().unwrap();\n-        let _ = r.next_u32();\n-    }\n-\n-    #[test]\n-    fn comm_stream() {\n-        let (tx, rx) = channel();\n-        tx.send(10i);\n-        assert!(rx.recv() == 10);\n-    }\n-\n-    #[test]\n-    fn comm_shared_chan() {\n-        let (tx, rx) = channel();\n-        tx.send(10i);\n-        assert!(rx.recv() == 10);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_begin_unwind() {\n-        use rt::unwind::begin_unwind;\n-        begin_unwind(\"cause\", &(file!(), line!()))\n-    }\n-\n-    #[test]\n-    fn drop_new_task_ok() {\n-        drop(Task::new(None, None));\n-    }\n-\n-    // Thread blocking tests\n-\n-    #[test]\n-    fn block_and_wake() {\n-        let task = box Task::new(None, None);\n-        let task = BlockedTask::block(task).wake().unwrap();\n-        task.drop();\n-    }\n-}"}, {"sha": "6f6be2e111df478b7337bf0a4b4e2e1ed047fb39", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -84,15 +84,15 @@ pub type Callback = fn(msg: &(Any + Send), file: &'static str, line: uint);\n // For more information, see below.\n const MAX_CALLBACKS: uint = 16;\n static CALLBACKS: [atomic::AtomicUint; MAX_CALLBACKS] =\n-        [atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n-         atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n-         atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n-         atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n-         atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n-         atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n-         atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n-         atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT];\n-static CALLBACK_CNT: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+        [atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n+         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n+         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n+         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n+         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n+         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n+         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n+         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT];\n+static CALLBACK_CNT: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n \n thread_local! { static PANICKING: Cell<bool> = Cell::new(false) }\n \n@@ -533,7 +533,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n     // Make sure the default failure handler is registered before we look at the\n     // callbacks.\n     static INIT: Once = ONCE_INIT;\n-    INIT.doit(|| unsafe { register(failure::on_fail); });\n+    INIT.call_once(|| unsafe { register(failure::on_fail); });\n \n     // First, invoke call the user-defined callbacks triggered on thread panic.\n     //"}, {"sha": "09859cab536202d5a5b703f77925e4ca290802af", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -46,7 +46,7 @@ pub fn limit_thread_creation_due_to_osx_and_valgrind() -> bool {\n }\n \n pub fn min_stack() -> uint {\n-    static MIN: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+    static MIN: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n     match MIN.load(atomic::SeqCst) {\n         0 => {}\n         n => return n - 1,"}, {"sha": "d4d7607bde34c50c65df27e45904ea4dd4cf2d85", "filename": "src/libstd/sync/atomic.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomic.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -86,22 +86,23 @@\n //! Keep a global count of live tasks:\n //!\n //! ```\n-//! use std::sync::atomic::{AtomicUint, SeqCst, INIT_ATOMIC_UINT};\n+//! use std::sync::atomic::{AtomicUint, SeqCst, ATOMIC_UINT_INIT};\n //!\n-//! static GLOBAL_TASK_COUNT: AtomicUint = INIT_ATOMIC_UINT;\n+//! static GLOBAL_TASK_COUNT: AtomicUint = ATOMIC_UINT_INIT;\n //!\n //! let old_task_count = GLOBAL_TASK_COUNT.fetch_add(1, SeqCst);\n //! println!(\"live tasks: {}\", old_task_count + 1);\n //! ```\n \n-#![allow(deprecated)]\n+#![stable]\n \n use alloc::boxed::Box;\n use core::mem;\n use core::prelude::{Send, Drop, None, Option, Some};\n \n pub use core::atomic::{AtomicBool, AtomicInt, AtomicUint, AtomicPtr};\n pub use core::atomic::{INIT_ATOMIC_BOOL, INIT_ATOMIC_INT, INIT_ATOMIC_UINT};\n+pub use core::atomic::{ATOMIC_BOOL_INIT, ATOMIC_INT_INIT, ATOMIC_UINT_INIT};\n pub use core::atomic::fence;\n pub use core::atomic::Ordering::{mod, Relaxed, Release, Acquire, AcqRel, SeqCst};\n \n@@ -116,6 +117,7 @@ pub struct AtomicOption<T> {\n     p: AtomicUint,\n }\n \n+#[allow(deprecated)]\n impl<T: Send> AtomicOption<T> {\n     /// Create a new `AtomicOption`\n     pub fn new(p: Box<T>) -> AtomicOption<T> {"}, {"sha": "bf5da3e7cbae018b18381d6899fd894fcee6a379", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use kinds::{Send, Sync};\n use sync::{Mutex, Condvar};\n \n /// A barrier enables multiple tasks to synchronize the beginning\n@@ -30,29 +29,32 @@ use sync::{Mutex, Condvar};\n ///     }).detach();\n /// }\n /// ```\n+#[stable]\n pub struct Barrier {\n     lock: Mutex<BarrierState>,\n     cvar: Condvar,\n     num_threads: uint,\n }\n \n-unsafe impl Send for Barrier {}\n-unsafe impl Sync for Barrier {}\n-\n // The inner state of a double barrier\n struct BarrierState {\n     count: uint,\n     generation_id: uint,\n }\n \n-unsafe impl Send for BarrierState {}\n-unsafe impl Sync for BarrierState {}\n+/// A result returned from wait.\n+///\n+/// Currently this opaque structure only has one method, `.is_leader()`. Only\n+/// one thread will receive a result that will return `true` from this function.\n+#[allow(missing_copy_implementations)]\n+pub struct BarrierWaitResult(bool);\n \n impl Barrier {\n     /// Create a new barrier that can block a given number of threads.\n     ///\n     /// A barrier will block `n`-1 threads which call `wait` and then wake up\n     /// all threads at once when the `n`th thread calls `wait`.\n+    #[stable]\n     pub fn new(n: uint) -> Barrier {\n         Barrier {\n             lock: Mutex::new(BarrierState {\n@@ -68,7 +70,13 @@ impl Barrier {\n     ///\n     /// Barriers are re-usable after all threads have rendezvoused once, and can\n     /// be used continuously.\n-    pub fn wait(&self) {\n+    ///\n+    /// A single (arbitrary) thread will receive a `BarrierWaitResult` that\n+    /// returns `true` from `is_leader` when returning from this function, and\n+    /// all other threads will receive a result that will return `false` from\n+    /// `is_leader`\n+    #[stable]\n+    pub fn wait(&self) -> BarrierWaitResult {\n         let mut lock = self.lock.lock().unwrap();\n         let local_gen = lock.generation_id;\n         lock.count += 1;\n@@ -79,14 +87,25 @@ impl Barrier {\n                   lock.count < self.num_threads {\n                 lock = self.cvar.wait(lock).unwrap();\n             }\n+            BarrierWaitResult(false)\n         } else {\n             lock.count = 0;\n             lock.generation_id += 1;\n             self.cvar.notify_all();\n+            BarrierWaitResult(true)\n         }\n     }\n }\n \n+impl BarrierWaitResult {\n+    /// Return whether this thread from `wait` is the \"leader thread\".\n+    ///\n+    /// Only one thread will have `true` returned from their result, all other\n+    /// threads will have `false` returned.\n+    #[stable]\n+    pub fn is_leader(&self) -> bool { self.0 }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use prelude::v1::*;\n@@ -97,15 +116,16 @@ mod tests {\n \n     #[test]\n     fn test_barrier() {\n-        let barrier = Arc::new(Barrier::new(10));\n+        const N: uint = 10;\n+\n+        let barrier = Arc::new(Barrier::new(N));\n         let (tx, rx) = channel();\n \n-        for _ in range(0u, 9) {\n+        for _ in range(0u, N - 1) {\n             let c = barrier.clone();\n             let tx = tx.clone();\n             Thread::spawn(move|| {\n-                c.wait();\n-                tx.send(true).unwrap();\n+                tx.send(c.wait().is_leader()).unwrap();\n             }).detach();\n         }\n \n@@ -116,10 +136,15 @@ mod tests {\n             _ => false,\n         });\n \n-        barrier.wait();\n+        let mut leader_found = barrier.wait().is_leader();\n+\n         // Now, the barrier is cleared and we should get data.\n-        for _ in range(0u, 9) {\n-            rx.recv().unwrap();\n+        for _ in range(0u, N - 1) {\n+            if rx.recv().unwrap() {\n+                assert!(!leader_found);\n+                leader_found = true;\n+            }\n         }\n+        assert!(leader_found);\n     }\n }"}, {"sha": "8d40a854aaf385c5a5a7200aaabe9f6df5988367", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -88,7 +88,7 @@ unsafe impl Sync for StaticCondvar {}\n #[unstable = \"may be merged with Condvar in the future\"]\n pub const CONDVAR_INIT: StaticCondvar = StaticCondvar {\n     inner: sys::CONDVAR_INIT,\n-    mutex: atomic::INIT_ATOMIC_UINT,\n+    mutex: atomic::ATOMIC_UINT_INIT,\n };\n \n impl Condvar {"}, {"sha": "e5245251ea817482d4ee1862fc35bb12561ce0ec", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A type representing values that may be computed concurrently and operations for working with\n-//! them.\n+//! A type representing values that may be computed concurrently and operations\n+//! for working with them.\n //!\n //! # Example\n //!\n@@ -23,6 +23,9 @@\n //! ```\n \n #![allow(missing_docs)]\n+#![unstable = \"futures as-is have yet to be deeply reevaluated with recent \\\n+               core changes to Rust's synchronization story, and will likely \\\n+               become stable in the future but are unstable until that time\"]\n \n use core::prelude::*;\n use core::mem::replace;"}, {"sha": "c09c3b45d3e26478df726c7bfe7ec30940073df6", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -26,7 +26,7 @@ pub use self::rwlock::{RWLockReadGuard, RWLockWriteGuard};\n pub use self::condvar::{Condvar, StaticCondvar, CONDVAR_INIT};\n pub use self::once::{Once, ONCE_INIT};\n pub use self::semaphore::{Semaphore, SemaphoreGuard};\n-pub use self::barrier::Barrier;\n+pub use self::barrier::{Barrier, BarrierWaitResult};\n pub use self::poison::{PoisonError, TryLockError, TryLockResult, LockResult};\n \n pub use self::future::Future;"}, {"sha": "a529901272358604752c43e9d73e86fe907d5142", "filename": "src/libstd/sync/mpsc/blocking.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -11,7 +11,7 @@\n //! Generic support for building blocking abstractions.\n \n use thread::Thread;\n-use sync::atomic::{AtomicBool, INIT_ATOMIC_BOOL, Ordering};\n+use sync::atomic::{AtomicBool, ATOMIC_BOOL_INIT, Ordering};\n use sync::Arc;\n use kinds::{Sync, Send};\n use kinds::marker::{NoSend, NoSync};\n@@ -40,7 +40,7 @@ pub struct WaitToken {\n pub fn tokens() -> (WaitToken, SignalToken) {\n     let inner = Arc::new(Inner {\n         thread: Thread::current(),\n-        woken: INIT_ATOMIC_BOOL,\n+        woken: ATOMIC_BOOL_INIT,\n     });\n     let wait_token = WaitToken {\n         inner: inner.clone(),"}, {"sha": "9e9a17e482fbf2c72e24fbf07d90a0f210538a35", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -32,10 +32,11 @@ use sync::{StaticMutex, MUTEX_INIT};\n ///\n /// static START: Once = ONCE_INIT;\n ///\n-/// START.doit(|| {\n+/// START.call_once(|| {\n ///     // run initialization here\n /// });\n /// ```\n+#[stable]\n pub struct Once {\n     mutex: StaticMutex,\n     cnt: atomic::AtomicInt,\n@@ -45,23 +46,25 @@ pub struct Once {\n unsafe impl Sync for Once {}\n \n /// Initialization value for static `Once` values.\n+#[stable]\n pub const ONCE_INIT: Once = Once {\n     mutex: MUTEX_INIT,\n-    cnt: atomic::INIT_ATOMIC_INT,\n-    lock_cnt: atomic::INIT_ATOMIC_INT,\n+    cnt: atomic::ATOMIC_INT_INIT,\n+    lock_cnt: atomic::ATOMIC_INT_INIT,\n };\n \n impl Once {\n     /// Perform an initialization routine once and only once. The given closure\n-    /// will be executed if this is the first time `doit` has been called, and\n-    /// otherwise the routine will *not* be invoked.\n+    /// will be executed if this is the first time `call_once` has been called,\n+    /// and otherwise the routine will *not* be invoked.\n     ///\n     /// This method will block the calling task if another initialization\n     /// routine is currently running.\n     ///\n     /// When this function returns, it is guaranteed that some initialization\n     /// has run and completed (it may not be the closure specified).\n-    pub fn doit<F>(&'static self, f: F) where F: FnOnce() {\n+    #[stable]\n+    pub fn call_once<F>(&'static self, f: F) where F: FnOnce() {\n         // Optimize common path: load is much cheaper than fetch_add.\n         if self.cnt.load(atomic::SeqCst) < 0 {\n             return\n@@ -91,13 +94,13 @@ impl Once {\n         //\n         // It is crucial that the negative value is swapped in *after* the\n         // initialization routine has completed because otherwise new threads\n-        // calling `doit` will return immediately before the initialization has\n-        // completed.\n+        // calling `call_once` will return immediately before the initialization\n+        // has completed.\n \n         let prev = self.cnt.fetch_add(1, atomic::SeqCst);\n         if prev < 0 {\n             // Make sure we never overflow, we'll never have int::MIN\n-            // simultaneous calls to `doit` to make this value go back to 0\n+            // simultaneous calls to `call_once` to make this value go back to 0\n             self.cnt.store(int::MIN, atomic::SeqCst);\n             return\n         }\n@@ -118,6 +121,10 @@ impl Once {\n             unsafe { self.mutex.destroy() }\n         }\n     }\n+\n+    /// Deprecated\n+    #[deprecated = \"renamed to `call_once`\"]\n+    pub fn doit<F>(&'static self, f: F) where F: FnOnce() { self.call_once(f) }\n }\n \n #[cfg(test)]\n@@ -132,9 +139,9 @@ mod test {\n     fn smoke_once() {\n         static O: Once = ONCE_INIT;\n         let mut a = 0i;\n-        O.doit(|| a += 1);\n+        O.call_once(|| a += 1);\n         assert_eq!(a, 1);\n-        O.doit(|| a += 1);\n+        O.call_once(|| a += 1);\n         assert_eq!(a, 1);\n     }\n \n@@ -149,7 +156,7 @@ mod test {\n             Thread::spawn(move|| {\n                 for _ in range(0u, 4) { Thread::yield_now() }\n                 unsafe {\n-                    O.doit(|| {\n+                    O.call_once(|| {\n                         assert!(!run);\n                         run = true;\n                     });\n@@ -160,7 +167,7 @@ mod test {\n         }\n \n         unsafe {\n-            O.doit(|| {\n+            O.call_once(|| {\n                 assert!(!run);\n                 run = true;\n             });"}, {"sha": "c0ff674ba0f7dad5870d64df1f644bac1ceb3a53", "filename": "src/libstd/sync/semaphore.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![unstable = \"the interaction between semaphores and the acquisition/release \\\n+               of resources is currently unclear\"]\n+\n use ops::Drop;\n use sync::{Mutex, Condvar};\n "}, {"sha": "088827dc0842d9041d70db2f98f60dbed7904e13", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -10,6 +10,11 @@\n \n //! Abstraction of a thread pool for basic parallelism.\n \n+#![unstable = \"the semantics of a failing task and whether a thread is \\\n+               re-attached to a thread pool are somewhat unclear, and the \\\n+               utility of this type in `std::sync` is questionable with \\\n+               respect to the jobs of other primitives\"]\n+\n use core::prelude::*;\n \n use sync::{Arc, Mutex};"}, {"sha": "9d7188a37bcdfd7c0848f7dcb26849cedb31f036", "filename": "src/libstd/sys/common/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -137,7 +137,7 @@ pub const INIT: StaticKey = StaticKey {\n ///\n /// This value allows specific configuration of the destructor for a TLS key.\n pub const INIT_INNER: StaticKeyInner = StaticKeyInner {\n-    key: atomic::INIT_ATOMIC_UINT,\n+    key: atomic::ATOMIC_UINT_INIT,\n };\n \n static INIT_KEYS: Once = ONCE_INIT;"}, {"sha": "6a8f55e79c8728feecd0b857d7ba66b44ef25ca9", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -20,7 +20,7 @@ use libc::{mod, c_int, c_char, c_void};\n use os;\n use path::{BytesContainer};\n use ptr;\n-use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n+use sync::atomic::{AtomicInt, SeqCst};\n use sys::fs::FileDesc;\n \n use os::TMPBUF_SZ;"}, {"sha": "0ab213cd0af0974fc68c3f8a532ddb249b210426", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -10,6 +10,8 @@\n \n use prelude::v1::*;\n \n+use prelude::*;\n+\n use libc;\n use c_str::CString;\n use mem;\n@@ -117,9 +119,6 @@ pub struct UnixStream {\n     write_deadline: u64,\n }\n \n-unsafe impl Send for UnixStream {}\n-unsafe impl Sync for UnixStream {}\n-\n impl UnixStream {\n     pub fn connect(addr: &CString,\n                    timeout: Option<u64>) -> IoResult<UnixStream> {\n@@ -218,6 +217,7 @@ pub struct UnixListener {\n     path: CString,\n }\n \n+// we currently own the CString, so these impls should be safe\n unsafe impl Send for UnixListener {}\n unsafe impl Sync for UnixListener {}\n \n@@ -265,9 +265,6 @@ struct AcceptorInner {\n     closed: atomic::AtomicBool,\n }\n \n-unsafe impl Send for AcceptorInner {}\n-unsafe impl Sync for AcceptorInner {}\n-\n impl UnixAcceptor {\n     pub fn fd(&self) -> fd_t { self.inner.listener.fd() }\n "}, {"sha": "80f93dd2f618cb7611b5be23b9537da6b48cf54b", "filename": "src/libstd/sys/unix/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -211,7 +211,7 @@ impl Timer {\n         // instead of ()\n         HELPER.boot(|| {}, helper);\n \n-        static ID: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+        static ID: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n         let id = ID.fetch_add(1, atomic::Relaxed);\n         Ok(Timer {\n             id: id,"}, {"sha": "d625e63952a2722361abb04b5fa7700d6da7de22", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -173,7 +173,7 @@ pub fn init_net() {\n     unsafe {\n         static START: Once = ONCE_INIT;\n \n-        START.doit(|| {\n+        START.call_once(|| {\n             let mut data: c::WSADATA = mem::zeroed();\n             let ret = c::WSAStartup(0x202, // version 2.2\n                                     &mut data);"}, {"sha": "e0fa02b559958cb5858922ff74516781c72fbff8", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -20,7 +20,7 @@ const SPIN_COUNT: DWORD = 4000;\n \n pub struct Mutex { inner: atomic::AtomicUint }\n \n-pub const MUTEX_INIT: Mutex = Mutex { inner: atomic::INIT_ATOMIC_UINT };\n+pub const MUTEX_INIT: Mutex = Mutex { inner: atomic::ATOMIC_UINT_INIT };\n \n unsafe impl Sync for Mutex {}\n "}, {"sha": "d6c94f27a8baf9462dea4a451861ad329956d37b", "filename": "src/libstd/time/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Ftime%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibstd%2Ftime%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fmod.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -45,7 +45,7 @@ fn precise_time_ns() -> u64 {\n                                                                                    denom: 0 };\n         static ONCE: sync::Once = sync::ONCE_INIT;\n         unsafe {\n-            ONCE.doit(|| {\n+            ONCE.call_once(|| {\n                 imp::mach_timebase_info(&mut TIMEBASE);\n             });\n             let time = imp::mach_absolute_time();"}, {"sha": "d9db2d80adaff4714207720b566b5bb477d0c232", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -197,7 +197,7 @@ pub fn precise_time_ns() -> u64 {\n                                                                                    denom: 0 };\n         static ONCE: std::sync::Once = std::sync::ONCE_INIT;\n         unsafe {\n-            ONCE.doit(|| {\n+            ONCE.call_once(|| {\n                 imp::mach_timebase_info(&mut TIMEBASE);\n             });\n             let time = imp::mach_absolute_time();"}, {"sha": "689610d799ec065d979858c998df04ce60a473d5", "filename": "src/test/auxiliary/issue-17718.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Ftest%2Fauxiliary%2Fissue-17718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Ftest%2Fauxiliary%2Fissue-17718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-17718.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -11,12 +11,12 @@\n use std::sync::atomic;\n \n pub const C1: uint = 1;\n-pub const C2: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+pub const C2: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n pub const C3: fn() = foo;\n pub const C4: uint = C1 * C1 + C1 / C1;\n pub const C5: &'static uint = &C4;\n \n pub static S1: uint = 3;\n-pub static S2: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+pub static S2: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n \n fn foo() {}"}, {"sha": "236e1cbb217352385246cecd807bdc73b65368b5", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -41,9 +41,7 @@\n extern crate arena;\n \n use std::iter::range_step;\n-use std::str::from_str;\n-use std::sync::Future;\n-\n+use std::thread::Thread;\n use arena::TypedArena;\n \n enum Tree<'a> {\n@@ -97,7 +95,7 @@ fn main() {\n     let mut messages = range_step(min_depth, max_depth + 1, 2).map(|depth| {\n             use std::num::Int;\n             let iterations = 2i.pow((max_depth - depth + min_depth) as uint);\n-            Future::spawn(move|| {\n+            Thread::spawn(move|| {\n                 let mut chk = 0;\n                 for i in range(1, iterations + 1) {\n                     let arena = TypedArena::new();\n@@ -108,10 +106,10 @@ fn main() {\n                 format!(\"{}\\t trees of depth {}\\t check: {}\",\n                         iterations * 2, depth, chk)\n             })\n-        }).collect::<Vec<Future<String>>>();\n+        }).collect::<Vec<_>>();\n \n-    for message in messages.iter_mut() {\n-        println!(\"{}\", *message.get_ref());\n+    for message in messages.into_iter() {\n+        println!(\"{}\", message.join().ok().unwrap());\n     }\n \n     println!(\"long lived tree of depth {}\\t check: {}\","}, {"sha": "8e594b861803f57be4811fd10c9353577598231e", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -40,9 +40,8 @@\n \n #![feature(slicing_syntax)]\n \n-use std::str::from_str;\n-use std::sync::Future;\n use std::{cmp, iter, mem};\n+use std::thread::Thread;\n \n fn rotate(x: &mut [i32]) {\n     let mut prev = x[0];\n@@ -169,15 +168,15 @@ fn fannkuch(n: i32) -> (i32, i32) {\n     for (i, j) in range(0, N).zip(iter::count(0, k)) {\n         let max = cmp::min(j+k, perm.max());\n \n-        futures.push(Future::spawn(move|| {\n+        futures.push(Thread::spawn(move|| {\n             work(perm, j as uint, max as uint)\n         }))\n     }\n \n     let mut checksum = 0;\n     let mut maxflips = 0;\n-    for fut in futures.iter_mut() {\n-        let (cs, mf) = fut.get();\n+    for fut in futures.into_iter() {\n+        let (cs, mf) = fut.join().ok().unwrap();\n         checksum += cs;\n         maxflips = cmp::max(maxflips, mf);\n     }"}, {"sha": "501187ca9e5435257bb62a0ee9ba426146d68b9f", "filename": "src/test/compile-fail/std-uncopyable-atomics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -16,11 +16,11 @@ use std::sync::atomic::*;\n use std::ptr;\n \n fn main() {\n-    let x = INIT_ATOMIC_BOOL;\n+    let x = ATOMIC_BOOL_INIT;\n     let x = *&x; //~ ERROR: cannot move out of dereference\n-    let x = INIT_ATOMIC_INT;\n+    let x = ATOMIC_INT_INIT;\n     let x = *&x; //~ ERROR: cannot move out of dereference\n-    let x = INIT_ATOMIC_UINT;\n+    let x = ATOMIC_UINT_INIT;\n     let x = *&x; //~ ERROR: cannot move out of dereference\n     let x: AtomicPtr<uint> = AtomicPtr::new(ptr::null_mut());\n     let x = *&x; //~ ERROR: cannot move out of dereference"}, {"sha": "10ad0f620e9f3076442ba870abae2fb60a0ac573", "filename": "src/test/run-pass/issue-17718.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Ftest%2Frun-pass%2Fissue-17718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Ftest%2Frun-pass%2Fissue-17718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17718.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -15,7 +15,7 @@ extern crate \"issue-17718\" as other;\n use std::sync::atomic;\n \n const C1: uint = 1;\n-const C2: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+const C2: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n const C3: fn() = foo;\n const C4: uint = C1 * C1 + C1 / C1;\n const C5: &'static uint = &C4;\n@@ -25,7 +25,7 @@ const C6: uint = {\n };\n \n static S1: uint = 3;\n-static S2: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+static S2: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n \n mod test {\n     static A: uint = 4;"}, {"sha": "c5f5cd2c3aab58dde727d58fc8157b5642235e53", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "patch": "@@ -9,26 +9,26 @@\n // except according to those terms.\n \n use std::task;\n-use std::sync::atomic::{AtomicUint, INIT_ATOMIC_UINT, Relaxed};\n+use std::sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Relaxed};\n use std::rand::{thread_rng, Rng, Rand};\n \n const REPEATS: uint = 5;\n const MAX_LEN: uint = 32;\n static drop_counts: [AtomicUint;  MAX_LEN] =\n     // FIXME #5244: AtomicUint is not Copy.\n     [\n-        INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT,\n-        INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT,\n-        INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT,\n-        INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT,\n+        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n+        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n+        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n+        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n \n-        INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT,\n-        INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT,\n-        INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT,\n-        INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT,\n+        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n+        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n+        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n+        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n      ];\n \n-static creation_count: AtomicUint = INIT_ATOMIC_UINT;\n+static creation_count: AtomicUint = ATOMIC_UINT_INIT;\n \n #[deriving(Clone, PartialEq, PartialOrd, Eq, Ord)]\n struct DropCounter { x: uint, creation_id: uint }"}]}