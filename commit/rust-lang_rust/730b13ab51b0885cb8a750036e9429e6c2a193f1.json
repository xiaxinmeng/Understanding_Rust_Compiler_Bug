{"sha": "730b13ab51b0885cb8a750036e9429e6c2a193f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczMGIxM2FiNTFiMDg4NWNiOGE3NTAwMzZlOTQyOWU2YzJhMTkzZjE=", "commit": {"author": {"name": "Denis Merigoux", "email": "denis.merigoux@gmail.com", "date": "2018-09-05T21:14:03Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T12:11:59Z"}, "message": "Traitification of type_ methods\nThe methods are now attached to CodegenCx instead of Type", "tree": {"sha": "a80c3c3a5e8c51ef6c6d5c7fa9d750b17221339c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a80c3c3a5e8c51ef6c6d5c7fa9d750b17221339c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/730b13ab51b0885cb8a750036e9429e6c2a193f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/730b13ab51b0885cb8a750036e9429e6c2a193f1", "html_url": "https://github.com/rust-lang/rust/commit/730b13ab51b0885cb8a750036e9429e6c2a193f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/730b13ab51b0885cb8a750036e9429e6c2a193f1/comments", "author": {"login": "denismerigoux", "id": 1766128, "node_id": "MDQ6VXNlcjE3NjYxMjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1766128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denismerigoux", "html_url": "https://github.com/denismerigoux", "followers_url": "https://api.github.com/users/denismerigoux/followers", "following_url": "https://api.github.com/users/denismerigoux/following{/other_user}", "gists_url": "https://api.github.com/users/denismerigoux/gists{/gist_id}", "starred_url": "https://api.github.com/users/denismerigoux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denismerigoux/subscriptions", "organizations_url": "https://api.github.com/users/denismerigoux/orgs", "repos_url": "https://api.github.com/users/denismerigoux/repos", "events_url": "https://api.github.com/users/denismerigoux/events{/privacy}", "received_events_url": "https://api.github.com/users/denismerigoux/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f28e0a0b627c2e20689906db8475e2e7d133672", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f28e0a0b627c2e20689906db8475e2e7d133672", "html_url": "https://github.com/rust-lang/rust/commit/5f28e0a0b627c2e20689906db8475e2e7d133672"}], "stats": {"total": 809, "additions": 402, "deletions": 407}, "files": [{"sha": "f07ec35049bb5a5ec9f64f995905724ce04699c9", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=730b13ab51b0885cb8a750036e9429e6c2a193f1", "patch": "@@ -18,7 +18,7 @@ use type_::Type;\n use type_of::{LayoutLlvmExt, PointerKind};\n use value::Value;\n \n-use interfaces::{BuilderMethods, CommonMethods};\n+use interfaces::{BuilderMethods, CommonMethods, TypeMethods};\n \n use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TyLayout, Abi as LayoutAbi};\n use rustc::ty::{self, Ty};\n@@ -111,16 +111,16 @@ pub trait LlvmType {\n impl LlvmType for Reg {\n     fn llvm_type(&self, cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n         match self.kind {\n-            RegKind::Integer => Type::ix(cx, self.size.bits()),\n+            RegKind::Integer => cx.ix(self.size.bits()),\n             RegKind::Float => {\n                 match self.size.bits() {\n-                    32 => Type::f32(cx),\n-                    64 => Type::f64(cx),\n+                    32 => cx.f32(),\n+                    64 => cx.f64(),\n                     _ => bug!(\"unsupported float: {:?}\", self)\n                 }\n             }\n             RegKind::Vector => {\n-                Type::vector(Type::i8(cx), self.size.bytes())\n+                cx.vector(cx.i8(), self.size.bytes())\n             }\n         }\n     }\n@@ -144,7 +144,7 @@ impl LlvmType for CastTarget {\n \n             // Simplify to array when all chunks are the same size and type\n             if rem_bytes == 0 {\n-                return Type::array(rest_ll_unit, rest_count);\n+                return cx.array(rest_ll_unit, rest_count);\n             }\n         }\n \n@@ -159,10 +159,10 @@ impl LlvmType for CastTarget {\n         if rem_bytes != 0 {\n             // Only integers can be really split further.\n             assert_eq!(self.rest.unit.kind, RegKind::Integer);\n-            args.push(Type::ix(cx, rem_bytes * 8));\n+            args.push(cx.ix(rem_bytes * 8));\n         }\n \n-        Type::struct_(cx, &args, false)\n+        cx.struct_(&args, false)\n     }\n }\n \n@@ -212,7 +212,7 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n             let can_store_through_cast_ptr = false;\n             if can_store_through_cast_ptr {\n-                let cast_dst = bx.pointercast(dst.llval, cast.llvm_type(cx).ptr_to());\n+                let cast_dst = bx.pointercast(dst.llval, cx.ptr_to(cast.llvm_type(cx)));\n                 bx.store(val, cast_dst, self.layout.align);\n             } else {\n                 // The actual return type is a struct, but the ABI\n@@ -240,9 +240,9 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n \n                 // ...and then memcpy it to the intended destination.\n                 base::call_memcpy(bx,\n-                                  bx.pointercast(dst.llval, Type::i8p(cx)),\n+                                  bx.pointercast(dst.llval, cx.i8p()),\n                                   self.layout.align,\n-                                  bx.pointercast(llscratch, Type::i8p(cx)),\n+                                  bx.pointercast(llscratch, cx.i8p()),\n                                   scratch_align,\n                                   cx.c_usize(self.layout.size.bytes()),\n                                   MemFlags::empty());\n@@ -635,14 +635,14 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n         );\n \n         let llreturn_ty = match self.ret.mode {\n-            PassMode::Ignore => Type::void(cx),\n+            PassMode::Ignore => cx.void(),\n             PassMode::Direct(_) | PassMode::Pair(..) => {\n                 self.ret.layout.immediate_llvm_type(cx)\n             }\n             PassMode::Cast(cast) => cast.llvm_type(cx),\n             PassMode::Indirect(..) => {\n-                llargument_tys.push(self.ret.memory_ty(cx).ptr_to());\n-                Type::void(cx)\n+                llargument_tys.push(cx.ptr_to(self.ret.memory_ty(cx)));\n+                cx.void()\n             }\n         };\n \n@@ -668,15 +668,15 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                     continue;\n                 }\n                 PassMode::Cast(cast) => cast.llvm_type(cx),\n-                PassMode::Indirect(_, None) => arg.memory_ty(cx).ptr_to(),\n+                PassMode::Indirect(_, None) => cx.ptr_to(arg.memory_ty(cx)),\n             };\n             llargument_tys.push(llarg_ty);\n         }\n \n         if self.variadic {\n-            Type::variadic_func(&llargument_tys, llreturn_ty)\n+            cx.variadic_func(&llargument_tys, llreturn_ty)\n         } else {\n-            Type::func(&llargument_tys, llreturn_ty)\n+            cx.func(&llargument_tys, llreturn_ty)\n         }\n     }\n "}, {"sha": "15eceaf405f7f01ad585597ba3b5ea658598b2cb", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=730b13ab51b0885cb8a750036e9429e6c2a193f1", "patch": "@@ -10,13 +10,12 @@\n \n use llvm;\n use context::CodegenCx;\n-use type_::Type;\n use type_of::LayoutLlvmExt;\n use builder::Builder;\n use value::Value;\n \n use rustc::hir;\n-use interfaces::{BuilderMethods, CommonMethods};\n+use interfaces::{BuilderMethods, CommonMethods, TypeMethods};\n \n use mir::place::PlaceRef;\n use mir::operand::OperandValue;\n@@ -76,9 +75,9 @@ pub fn codegen_inline_asm(\n     // Depending on how many outputs we have, the return type is different\n     let num_outputs = output_types.len();\n     let output_type = match num_outputs {\n-        0 => Type::void(bx.cx()),\n+        0 => bx.cx().void(),\n         1 => output_types[0],\n-        _ => Type::struct_(bx.cx(), &output_types, false)\n+        _ => bx.cx().struct_(&output_types, false)\n     };\n \n     let asm = CString::new(ia.asm.as_str().as_bytes()).unwrap();"}, {"sha": "7f1dafbe1611f36fe0a53ab0652bd2e0e3977502", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=730b13ab51b0885cb8a750036e9429e6c2a193f1", "patch": "@@ -456,6 +456,14 @@ impl CommonWriteMethods for CodegenContext<'ll> {\n     }\n }\n \n+impl CodegenContext<'ll> {\n+    pub fn ptr_to(&self, ty: &'ll Type) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMPointerType(ty, 0)\n+        }\n+    }\n+}\n+\n \n pub struct DiagnosticHandlers<'a> {\n     data: *mut (&'a CodegenContext<'a>, &'a Handler),\n@@ -2609,7 +2617,7 @@ fn create_msvc_imps(cgcx: &CodegenContext, llcx: &llvm::Context, llmod: &llvm::M\n         \"\\x01__imp_\"\n     };\n     unsafe {\n-        let i8p_ty = Type::i8p_llcx(llcx);\n+        let i8p_ty = Type::i8p_llcx(cgcx, llcx);\n         let globals = base::iter_globals(llmod)\n             .filter(|&val| {\n                 llvm::LLVMRustGetLinkage(val) == llvm::Linkage::ExternalLinkage &&"}, {"sha": "df0e47621a0532b017c692472f970414636ad79e", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=730b13ab51b0885cb8a750036e9429e6c2a193f1", "patch": "@@ -74,7 +74,7 @@ use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::indexed_vec::Idx;\n \n-use interfaces::{BuilderMethods, CommonMethods, CommonWriteMethods};\n+use interfaces::{BuilderMethods, CommonMethods, CommonWriteMethods, TypeMethods};\n \n use std::any::Any;\n use std::cmp;\n@@ -234,13 +234,13 @@ pub fn unsize_thin_ptr(\n         (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }),\n          &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n             assert!(bx.cx().type_is_sized(a));\n-            let ptr_ty = bx.cx().layout_of(b).llvm_type(bx.cx()).ptr_to();\n+            let ptr_ty = bx.cx().ptr_to(bx.cx().layout_of(b).llvm_type(bx.cx()));\n             (bx.pointercast(src, ptr_ty), unsized_info(bx.cx(), a, b, None))\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             let (a, b) = (src_ty.boxed_ty(), dst_ty.boxed_ty());\n             assert!(bx.cx().type_is_sized(a));\n-            let ptr_ty = bx.cx().layout_of(b).llvm_type(bx.cx()).ptr_to();\n+            let ptr_ty = bx.cx().ptr_to(bx.cx().layout_of(b).llvm_type(bx.cx()));\n             (bx.pointercast(src, ptr_ty), unsized_info(bx.cx(), a, b, None))\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n@@ -353,14 +353,14 @@ fn cast_shift_rhs<'ll, F, G>(bx: &Builder<'_, 'll, '_>,\n     if op.is_shift() {\n         let mut rhs_llty = bx.cx().val_ty(rhs);\n         let mut lhs_llty = bx.cx().val_ty(lhs);\n-        if rhs_llty.kind() == TypeKind::Vector {\n-            rhs_llty = rhs_llty.element_type()\n+        if bx.cx().kind(rhs_llty) == TypeKind::Vector {\n+            rhs_llty = bx.cx().element_type(rhs_llty)\n         }\n-        if lhs_llty.kind() == TypeKind::Vector {\n-            lhs_llty = lhs_llty.element_type()\n+        if bx.cx().kind(lhs_llty) == TypeKind::Vector {\n+            lhs_llty = bx.cx().element_type(lhs_llty)\n         }\n-        let rhs_sz = rhs_llty.int_width();\n-        let lhs_sz = lhs_llty.int_width();\n+        let rhs_sz = bx.cx().int_width(rhs_llty);\n+        let lhs_sz = bx.cx().int_width(lhs_llty);\n         if lhs_sz < rhs_sz {\n             trunc(rhs, lhs_llty)\n         } else if lhs_sz > rhs_sz {\n@@ -393,8 +393,8 @@ pub fn from_immediate<'a, 'll: 'a, 'tcx: 'll>(\n     bx: &Builder<'_ ,'ll, '_, &'ll Value>,\n     val: &'ll Value\n ) -> &'ll Value {\n-    if bx.cx().val_ty(val) == Type::i1(bx.cx()) {\n-        bx.zext(val, Type::i8(bx.cx()))\n+    if bx.cx().val_ty(val) == bx.cx().i1() {\n+        bx.zext(val, bx.cx().i8())\n     } else {\n         val\n     }\n@@ -417,7 +417,7 @@ pub fn to_immediate_scalar(\n     scalar: &layout::Scalar,\n ) -> &'ll Value {\n     if scalar.is_bool() {\n-        return bx.trunc(val, Type::i1(bx.cx()));\n+        return bx.trunc(val, bx.cx().i1());\n     }\n     val\n }\n@@ -434,13 +434,13 @@ pub fn call_memcpy<'a, 'll: 'a, 'tcx: 'll>(\n     if flags.contains(MemFlags::NONTEMPORAL) {\n         // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n         let val = bx.load(src, src_align);\n-        let ptr = bx.pointercast(dst, bx.cx().val_ty(val).ptr_to());\n+        let ptr = bx.pointercast(dst, bx.cx().ptr_to(bx.cx().val_ty(val)));\n         bx.store_with_flags(val, ptr, dst_align, flags);\n         return;\n     }\n     let cx = bx.cx();\n-    let src_ptr = bx.pointercast(src, Type::i8p(cx));\n-    let dst_ptr = bx.pointercast(dst, Type::i8p(cx));\n+    let src_ptr = bx.pointercast(src, cx.i8p());\n+    let dst_ptr = bx.pointercast(dst, cx.i8p());\n     let size = bx.intcast(n_bytes, cx.isize_ty, false);\n     let volatile = flags.contains(MemFlags::VOLATILE);\n     bx.memcpy(dst_ptr, dst_align.abi(), src_ptr, src_align.abi(), size, volatile);\n@@ -551,7 +551,7 @@ fn maybe_create_entry_wrapper(cx: &CodegenCx) {\n         use_start_lang_item: bool,\n     ) {\n         let llfty =\n-            Type::func(&[Type::c_int(cx), Type::i8p(cx).ptr_to()], Type::c_int(cx));\n+            cx.func(&[cx.t_int(), cx.ptr_to(cx.i8p())], cx.t_int());\n \n         let main_ret_ty = cx.tcx.fn_sig(rust_main_def_id).output();\n         // Given that `main()` has no arguments,\n@@ -594,15 +594,15 @@ fn maybe_create_entry_wrapper(cx: &CodegenCx) {\n                 start_def_id,\n                 cx.tcx.intern_substs(&[main_ret_ty.into()]),\n             );\n-            (start_fn, vec![bx.pointercast(rust_main, Type::i8p(cx).ptr_to()),\n+            (start_fn, vec![bx.pointercast(rust_main, cx.ptr_to(cx.i8p())),\n                             arg_argc, arg_argv])\n         } else {\n             debug!(\"using user-defined start fn\");\n             (rust_main, vec![arg_argc, arg_argv])\n         };\n \n         let result = bx.call(start_fn, &args, None);\n-        bx.ret(bx.intcast(result, Type::c_int(cx), true));\n+        bx.ret(bx.intcast(result, cx.t_int(), true));\n     }\n }\n \n@@ -1151,7 +1151,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             if !cx.used_statics.borrow().is_empty() {\n                 let name = const_cstr!(\"llvm.used\");\n                 let section = const_cstr!(\"llvm.metadata\");\n-                let array = cx.c_array(Type::i8(&cx).ptr_to(), &*cx.used_statics.borrow());\n+                let array = cx.c_array(&cx.ptr_to(cx.i8()), &*cx.used_statics.borrow());\n \n                 unsafe {\n                     let g = llvm::LLVMAddGlobal(cx.llmod,"}, {"sha": "1d3ef94f1552c156bd4ea1eaa174a90a08df5acb", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=730b13ab51b0885cb8a750036e9429e6c2a193f1", "patch": "@@ -19,7 +19,7 @@ use rustc::ty::TyCtxt;\n use rustc::ty::layout::{Align, Size};\n use rustc::session::{config, Session};\n use rustc_data_structures::small_c_str::SmallCStr;\n-use interfaces::{BuilderMethods, Backend, CommonMethods, CommonWriteMethods};\n+use interfaces::{BuilderMethods, Backend, CommonMethods, CommonWriteMethods, TypeMethods};\n use syntax;\n \n use std::borrow::Cow;\n@@ -765,7 +765,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }).collect::<Vec<_>>();\n \n         debug!(\"Asm Output Type: {:?}\", output);\n-        let fty = type_::Type::func(&argtys[..], output);\n+        let fty = &self.cx().func(&argtys[..], output);\n         unsafe {\n             // Ask LLVM to verify that the constraints are well-formed.\n             let constraints_ok = llvm::LLVMRustInlineAsmVerify(fty, cons);\n@@ -861,10 +861,10 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn vector_splat(&self, num_elts: usize, elt: &'ll Value) -> &'ll Value {\n         unsafe {\n             let elt_ty = self.cx.val_ty(elt);\n-            let undef = llvm::LLVMGetUndef(type_::Type::vector(elt_ty, num_elts as u64));\n+            let undef = llvm::LLVMGetUndef(&self.cx().vector(elt_ty, num_elts as u64));\n             let vec = self.insert_element(undef, elt, self.cx.c_i32(0));\n-            let vec_i32_ty = type_::Type::vector(type_::Type::i32(self.cx), num_elts as u64);\n-            self.shuffle_vector(vec, undef, self.cx.c_null(vec_i32_ty))\n+            let vec_i32_ty = &self.cx().vector(&self.cx().i32(), num_elts as u64);\n+            self.shuffle_vector(vec, undef, self.cx().c_null(vec_i32_ty))\n         }\n     }\n \n@@ -1142,9 +1142,9 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n                        ptr: &'ll Value) -> &'ll Value {\n         let dest_ptr_ty = self.cx.val_ty(ptr);\n         let stored_ty = self.cx.val_ty(val);\n-        let stored_ptr_ty = stored_ty.ptr_to();\n+        let stored_ptr_ty = self.cx.ptr_to(stored_ty);\n \n-        assert_eq!(dest_ptr_ty.kind(), llvm::TypeKind::Pointer);\n+        assert_eq!(self.cx.kind(dest_ptr_ty), llvm::TypeKind::Pointer);\n \n         if dest_ptr_ty == stored_ptr_ty {\n             ptr\n@@ -1163,14 +1163,14 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n                       args: &'b [&'ll Value]) -> Cow<'b, [&'ll Value]> {\n         let mut fn_ty = self.cx.val_ty(llfn);\n         // Strip off pointers\n-        while fn_ty.kind() == llvm::TypeKind::Pointer {\n-            fn_ty = fn_ty.element_type();\n+        while self.cx.kind(fn_ty) == llvm::TypeKind::Pointer {\n+            fn_ty = self.cx.element_type(fn_ty);\n         }\n \n-        assert!(fn_ty.kind() == llvm::TypeKind::Function,\n+        assert!(self.cx.kind(fn_ty) == llvm::TypeKind::Function,\n                 \"builder::{} not passed a function, but {:?}\", typ, fn_ty);\n \n-        let param_tys = fn_ty.func_params();\n+        let param_tys = self.cx.func_params(fn_ty);\n \n         let all_args_match = param_tys.iter()\n             .zip(args.iter().map(|&v| self.cx().val_ty(v)))\n@@ -1227,7 +1227,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n         let lifetime_intrinsic = self.cx.get_intrinsic(intrinsic);\n \n-        let ptr = self.pointercast(ptr, type_::Type::i8p(self.cx));\n+        let ptr = self.pointercast(ptr, self.cx.i8p());\n         self.call(lifetime_intrinsic, &[self.cx.c_u64(size), ptr], None);\n     }\n "}, {"sha": "e31c5f1cae43f81e71e1ca2ae487b0da672dc71f", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=730b13ab51b0885cb8a750036e9429e6c2a193f1", "patch": "@@ -24,7 +24,7 @@ use declare;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n use value::Value;\n-use interfaces::{Backend, CommonMethods, CommonWriteMethods};\n+use interfaces::{Backend, CommonMethods, CommonWriteMethods, TypeMethods};\n \n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{HasDataLayout, LayoutOf};\n@@ -236,19 +236,19 @@ impl<'ll, 'tcx: 'll> CommonMethods for CodegenCx<'ll, 'tcx> {\n     }\n \n     fn c_bool(&self, val: bool) -> &'ll Value {\n-        &self.c_uint(Type::i1(&self), val as u64)\n+        &self.c_uint(&self.i1(), val as u64)\n     }\n \n     fn c_i32(&self, i: i32) -> &'ll Value {\n-        &self.c_int(Type::i32(&self), i as i64)\n+        &self.c_int(&self.i32(), i as i64)\n     }\n \n     fn c_u32(&self, i: u32) -> &'ll Value {\n-        &self.c_uint(Type::i32(&self), i as u64)\n+        &self.c_uint(&self.i32(), i as u64)\n     }\n \n     fn c_u64(&self, i: u64) -> &'ll Value {\n-        &self.c_uint(Type::i64(&self), i)\n+        &self.c_uint(&self.i64(), i)\n     }\n \n     fn c_usize(&self, i: u64) -> &'ll Value {\n@@ -262,7 +262,7 @@ impl<'ll, 'tcx: 'll> CommonMethods for CodegenCx<'ll, 'tcx> {\n     }\n \n     fn c_u8(&self, i: u8) -> &'ll Value {\n-        &self.c_uint(Type::i8(&self), i as u64)\n+        &self.c_uint(&self.i8(), i as u64)\n     }\n \n \n@@ -300,7 +300,7 @@ impl<'ll, 'tcx: 'll> CommonMethods for CodegenCx<'ll, 'tcx> {\n     fn c_str_slice(&self, s: LocalInternedString) -> &'ll Value {\n         let len = s.len();\n         let cs = consts::ptrcast(&self.c_cstr(s, false),\n-            &self.layout_of(&self.tcx.mk_str()).llvm_type(&self).ptr_to());\n+            &self.ptr_to(&self.layout_of(&self.tcx.mk_str()).llvm_type(&self)));\n         &self.c_fat_ptr(cs, &self.c_usize(len as u64))\n     }\n \n@@ -505,20 +505,25 @@ pub fn shift_mask_val(\n     mask_llty: &'ll Type,\n     invert: bool\n ) -> &'ll Value {\n-    let kind = llty.kind();\n+    let kind = bx.cx().kind(llty);\n     match kind {\n         TypeKind::Integer => {\n             // i8/u8 can shift by at most 7, i16/u16 by at most 15, etc.\n-            let val = llty.int_width() - 1;\n+            let val = bx.cx().int_width(llty) - 1;\n             if invert {\n                 bx.cx.c_int(mask_llty, !val as i64)\n             } else {\n                 bx.cx.c_uint(mask_llty, val)\n             }\n         },\n         TypeKind::Vector => {\n-            let mask = shift_mask_val(bx, llty.element_type(), mask_llty.element_type(), invert);\n-            bx.vector_splat(mask_llty.vector_length(), mask)\n+            let mask = shift_mask_val(\n+                bx,\n+                bx.cx().element_type(llty),\n+                bx.cx().element_type(mask_llty),\n+                invert\n+            );\n+            bx.vector_splat(bx.cx().vector_length(mask_llty), mask)\n         },\n         _ => bug!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n     }"}, {"sha": "49f30d6757494677c6f3a44d01c2fbc47352bbfa", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=730b13ab51b0885cb8a750036e9429e6c2a193f1", "patch": "@@ -24,7 +24,7 @@ use type_::Type;\n use type_of::LayoutLlvmExt;\n use value::Value;\n use rustc::ty::{self, Ty};\n-use interfaces::CommonWriteMethods;\n+use interfaces::{CommonWriteMethods, TypeMethods};\n \n use rustc::ty::layout::{Align, LayoutOf};\n \n@@ -313,8 +313,8 @@ pub fn codegen_static<'a, 'tcx>(\n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected\n         let mut val_llty = cx.val_ty(v);\n-        let v = if val_llty == Type::i1(cx) {\n-            val_llty = Type::i8(cx);\n+        let v = if val_llty == cx.i1() {\n+            val_llty = cx.i8();\n             llvm::LLVMConstZExt(v, val_llty)\n         } else {\n             v\n@@ -432,7 +432,7 @@ pub fn codegen_static<'a, 'tcx>(\n \n         if attrs.flags.contains(CodegenFnAttrFlags::USED) {\n             // This static will be stored in the llvm.used variable which is an array of i8*\n-            let cast = llvm::LLVMConstPointerCast(g, Type::i8p(cx));\n+            let cast = llvm::LLVMConstPointerCast(g, cx.i8p());\n             cx.used_statics.borrow_mut().push(cast);\n         }\n     }"}, {"sha": "e19143efa984fca7e5372057de83637da58dd4aa", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=730b13ab51b0885cb8a750036e9429e6c2a193f1", "patch": "@@ -23,6 +23,7 @@ use value::Value;\n use monomorphize::partitioning::CodegenUnit;\n use type_::Type;\n use type_of::PointeeInfo;\n+use interfaces::TypeMethods;\n \n use rustc_data_structures::base_n;\n use rustc_data_structures::small_c_str::SmallCStr;\n@@ -379,7 +380,7 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n                 } else {\n                     \"rust_eh_personality\"\n                 };\n-                let fty = Type::variadic_func(&[], Type::i32(self));\n+                let fty = &self.variadic_func(&[], &self.i32());\n                 declare::declare_cfn(self, name, fty)\n             }\n         };\n@@ -487,52 +488,52 @@ fn declare_intrinsic(\n     macro_rules! ifn {\n         ($name:expr, fn() -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(cx, $name, Type::func(&[], $ret));\n+                let f = declare::declare_cfn(cx, $name, cx.func(&[], $ret));\n                 llvm::SetUnnamedAddr(f, false);\n                 cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn(...) -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(cx, $name, Type::variadic_func(&[], $ret));\n+                let f = declare::declare_cfn(cx, $name, cx.variadic_func(&[], $ret));\n                 llvm::SetUnnamedAddr(f, false);\n                 cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(cx, $name, Type::func(&[$($arg),*], $ret));\n+                let f = declare::declare_cfn(cx, $name, cx.func(&[$($arg),*], $ret));\n                 llvm::SetUnnamedAddr(f, false);\n                 cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n     }\n     macro_rules! mk_struct {\n-        ($($field_ty:expr),*) => (Type::struct_(cx, &[$($field_ty),*], false))\n+        ($($field_ty:expr),*) => (cx.struct_( &[$($field_ty),*], false))\n     }\n \n-    let i8p = Type::i8p(cx);\n-    let void = Type::void(cx);\n-    let i1 = Type::i1(cx);\n-    let t_i8 = Type::i8(cx);\n-    let t_i16 = Type::i16(cx);\n-    let t_i32 = Type::i32(cx);\n-    let t_i64 = Type::i64(cx);\n-    let t_i128 = Type::i128(cx);\n-    let t_f32 = Type::f32(cx);\n-    let t_f64 = Type::f64(cx);\n-\n-    let t_v2f32 = Type::vector(t_f32, 2);\n-    let t_v4f32 = Type::vector(t_f32, 4);\n-    let t_v8f32 = Type::vector(t_f32, 8);\n-    let t_v16f32 = Type::vector(t_f32, 16);\n-\n-    let t_v2f64 = Type::vector(t_f64, 2);\n-    let t_v4f64 = Type::vector(t_f64, 4);\n-    let t_v8f64 = Type::vector(t_f64, 8);\n+    let i8p = cx.i8p();\n+    let void = cx.void();\n+    let i1 = cx.i1();\n+    let t_i8 = cx.i8();\n+    let t_i16 = cx.i16();\n+    let t_i32 = cx.i32();\n+    let t_i64 = cx.i64();\n+    let t_i128 = cx.i128();\n+    let t_f32 = cx.f32();\n+    let t_f64 = cx.f64();\n+\n+    let t_v2f32 = cx.vector(t_f32, 2);\n+    let t_v4f32 = cx.vector(t_f32, 4);\n+    let t_v8f32 = cx.vector(t_f32, 8);\n+    let t_v16f32 = cx.vector(t_f32, 16);\n+\n+    let t_v2f64 = cx.vector(t_f64, 2);\n+    let t_v4f64 = cx.vector(t_f64, 4);\n+    let t_v8f64 = cx.vector(t_f64, 8);\n \n     ifn!(\"llvm.memset.p0i8.i16\", fn(i8p, t_i8, t_i16, t_i32, i1) -> void);\n     ifn!(\"llvm.memset.p0i8.i32\", fn(i8p, t_i8, t_i32, t_i32, i1) -> void);\n@@ -785,8 +786,8 @@ fn declare_intrinsic(\n     ifn!(\"llvm.prefetch\", fn(i8p, t_i32, t_i32, t_i32) -> void);\n \n     if cx.sess().opts.debuginfo != DebugInfo::None {\n-        ifn!(\"llvm.dbg.declare\", fn(Type::metadata(cx), Type::metadata(cx)) -> void);\n-        ifn!(\"llvm.dbg.value\", fn(Type::metadata(cx), t_i64, Type::metadata(cx)) -> void);\n+        ifn!(\"llvm.dbg.declare\", fn(cx.metadata(), cx.metadata()) -> void);\n+        ifn!(\"llvm.dbg.value\", fn(cx.metadata(), t_i64, cx.metadata()) -> void);\n     }\n \n     None"}, {"sha": "35b17a265a45494448c2e16d9e11f3495cf16cff", "filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs?ref=730b13ab51b0885cb8a750036e9429e6c2a193f1", "patch": "@@ -16,9 +16,8 @@ use common::CodegenCx;\n use builder::Builder;\n use declare;\n use rustc::session::config::DebugInfo;\n-use type_::Type;\n use value::Value;\n-use interfaces::{BuilderMethods, CommonMethods};\n+use interfaces::{BuilderMethods, CommonMethods, TypeMethods};\n \n use syntax::attr;\n \n@@ -56,7 +55,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx<'ll, '_>)\n         let section_contents = b\"\\x01gdb_load_rust_pretty_printers.py\\0\";\n \n         unsafe {\n-            let llvm_type = Type::array(Type::i8(cx),\n+            let llvm_type = cx.array(cx.i8(),\n                                         section_contents.len() as u64);\n \n             let section_var = declare::define_global(cx, section_var_name,"}, {"sha": "7a2080e1a2671c5a174a601c559f544e1ccbe9be", "filename": "src/librustc_codegen_llvm/interfaces/type_.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Finterfaces%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Finterfaces%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Ftype_.rs?ref=730b13ab51b0885cb8a750036e9429e6c2a193f1", "patch": "@@ -22,22 +22,20 @@ pub trait TypeMethods : Backend {\n     fn ix(&self, num_bites: u64) -> Self::Type;\n     fn f32(&self) -> Self::Type;\n     fn f64(&self) -> Self::Type;\n-    fn bool(&self) -> Self::Type;\n-    fn char(&self) -> Self::Type;\n-    fn i8p(&self) -> Self::Type;\n+    fn x86_mmx(&self) -> Self::Type;\n \n     fn func(&self, args: &[Self::Type], ret: Self::Type) -> Self::Type;\n-    fn variadic_func(&self, args: &[Self::Type]) -> Self::Type;\n+    fn variadic_func(&self, args: &[Self::Type], ret: Self::Type) -> Self::Type;\n     fn struct_(&self, els: &[Self::Type], packed: bool) -> Self::Type;\n     fn named_struct(&self, name: &str) -> Self::Type;\n     fn array(&self, ty: Self::Type, len: u64) -> Self::Type;\n     fn vector(&self, ty: Self::Type, len: u64) -> Self::Type;\n     fn kind(&self, ty: Self::Type) -> Self::TypeKind;\n-    fn set_struct_body(&self, els: &[Self::Type], packed: bool);\n+    fn set_struct_body(&self, ty: Self::Type, els: &[Self::Type], packed: bool);\n     fn ptr_to(&self, ty: Self::Type) -> Self::Type;\n     fn element_type(&self, ty: Self::Type) -> Self::Type;\n     fn vector_length(&self, ty: Self::Type) -> usize;\n     fn func_params(&self, ty: Self::Type) -> Vec<Self::Type>;\n     fn float_width(&self, ty: Self::Type) -> usize;\n-    fn int_width(&self, ty: Self::Type) -> usize;\n+    fn int_width(&self, ty: Self::Type) -> u64;\n }"}, {"sha": "6cc6692c3d16b07e578356de7d598125d8424df3", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=730b13ab51b0885cb8a750036e9429e6c2a193f1", "patch": "@@ -32,7 +32,7 @@ use syntax::symbol::Symbol;\n use builder::Builder;\n use value::Value;\n \n-use interfaces::{BuilderMethods, CommonMethods};\n+use interfaces::{BuilderMethods, CommonMethods, TypeMethods};\n \n use rustc::session::Session;\n use syntax_pos::Span;\n@@ -252,7 +252,7 @@ pub fn codegen_intrinsic_call(\n             let tp_ty = substs.type_at(0);\n             let mut ptr = args[0].immediate();\n             if let PassMode::Cast(ty) = fn_ty.ret.mode {\n-                ptr = bx.pointercast(ptr, ty.llvm_type(cx).ptr_to());\n+                ptr = bx.pointercast(ptr, bx.cx().ptr_to(ty.llvm_type(cx)));\n             }\n             let load = bx.volatile_load(ptr);\n             let align = if name == \"unaligned_volatile_load\" {\n@@ -338,7 +338,7 @@ pub fn codegen_intrinsic_call(\n                                 args[1].immediate()\n                             ], None);\n                             let val = bx.extract_value(pair, 0);\n-                            let overflow = bx.zext(bx.extract_value(pair, 1), Type::bool(cx));\n+                            let overflow = bx.zext(bx.extract_value(pair, 1), cx.bool());\n \n                             let dest = result.project_field(bx, 0);\n                             bx.store(val, dest.llval, dest.align);\n@@ -388,7 +388,7 @@ pub fn codegen_intrinsic_call(\n                             } else {\n                                 // rotate_left: (X << (S % BW)) | (X >> ((BW - S) % BW))\n                                 // rotate_right: (X << ((BW - S) % BW)) | (X >> (S % BW))\n-                                let width = cx.c_uint(Type::ix(cx, width), width);\n+                                let width = cx.c_uint(cx.ix(width), width);\n                                 let shift = bx.urem(raw_shift, width);\n                                 let inv_shift = bx.urem(bx.sub(width, raw_shift), width);\n                                 let shift1 = bx.shl(val, if is_left { shift } else { inv_shift });\n@@ -495,7 +495,7 @@ pub fn codegen_intrinsic_call(\n                             failorder,\n                             weak);\n                         let val = bx.extract_value(pair, 0);\n-                        let success = bx.zext(bx.extract_value(pair, 1), Type::bool(bx.cx()));\n+                        let success = bx.zext(bx.extract_value(pair, 1), bx.cx().bool());\n \n                         let dest = result.project_field(bx, 0);\n                         bx.store(val, dest.llval, dest.align);\n@@ -582,32 +582,32 @@ pub fn codegen_intrinsic_call(\n             fn ty_to_type(cx: &CodegenCx<'ll, '_>, t: &intrinsics::Type) -> Vec<&'ll Type> {\n                 use intrinsics::Type::*;\n                 match *t {\n-                    Void => vec![Type::void(cx)],\n+                    Void => vec![cx.void()],\n                     Integer(_signed, _width, llvm_width) => {\n-                        vec![Type::ix(cx, llvm_width as u64)]\n+                        vec![cx.ix( llvm_width as u64)]\n                     }\n                     Float(x) => {\n                         match x {\n-                            32 => vec![Type::f32(cx)],\n-                            64 => vec![Type::f64(cx)],\n+                            32 => vec![cx.f32()],\n+                            64 => vec![cx.f64()],\n                             _ => bug!()\n                         }\n                     }\n                     Pointer(ref t, ref llvm_elem, _const) => {\n                         let t = llvm_elem.as_ref().unwrap_or(t);\n                         let elem = one(ty_to_type(cx, t));\n-                        vec![elem.ptr_to()]\n+                        vec![cx.ptr_to(elem)]\n                     }\n                     Vector(ref t, ref llvm_elem, length) => {\n                         let t = llvm_elem.as_ref().unwrap_or(t);\n                         let elem = one(ty_to_type(cx, t));\n-                        vec![Type::vector(elem, length as u64)]\n+                        vec![cx.vector(elem, length as u64)]\n                     }\n                     Aggregate(false, ref contents) => {\n                         let elems = contents.iter()\n                                             .map(|t| one(ty_to_type(cx, t)))\n                                             .collect::<Vec<_>>();\n-                        vec![Type::struct_(cx, &elems, false)]\n+                        vec![cx.struct_( &elems, false)]\n                     }\n                     Aggregate(true, ref contents) => {\n                         contents.iter()\n@@ -646,20 +646,20 @@ pub fn codegen_intrinsic_call(\n                     }\n                     intrinsics::Type::Pointer(_, Some(ref llvm_elem), _) => {\n                         let llvm_elem = one(ty_to_type(bx.cx(), llvm_elem));\n-                        vec![bx.pointercast(arg.immediate(), llvm_elem.ptr_to())]\n+                        vec![bx.pointercast(arg.immediate(), bx.cx().ptr_to(llvm_elem))]\n                     }\n                     intrinsics::Type::Vector(_, Some(ref llvm_elem), length) => {\n                         let llvm_elem = one(ty_to_type(bx.cx(), llvm_elem));\n                         vec![\n                             bx.bitcast(arg.immediate(),\n-                            Type::vector(llvm_elem, length as u64))\n+                            bx.cx().vector(llvm_elem, length as u64))\n                         ]\n                     }\n                     intrinsics::Type::Integer(_, width, llvm_width) if width != llvm_width => {\n                         // the LLVM intrinsic uses a smaller integer\n                         // size than the C intrinsic's signature, so\n                         // we have to trim it down here.\n-                        vec![bx.trunc(arg.immediate(), Type::ix(bx.cx(), llvm_width as u64))]\n+                        vec![bx.trunc(arg.immediate(), bx.cx().ix(llvm_width as u64))]\n                     }\n                     _ => vec![arg.immediate()],\n                 }\n@@ -681,7 +681,7 @@ pub fn codegen_intrinsic_call(\n                 intrinsics::IntrinsicDef::Named(name) => {\n                     let f = declare::declare_cfn(cx,\n                                                  name,\n-                                                 Type::func(&inputs, outputs));\n+                                                 cx.func(&inputs, outputs));\n                     bx.call(f, &llargs, None)\n                 }\n             };\n@@ -705,7 +705,7 @@ pub fn codegen_intrinsic_call(\n \n     if !fn_ty.ret.is_ignore() {\n         if let PassMode::Cast(ty) = fn_ty.ret.mode {\n-            let ptr = bx.pointercast(result.llval, ty.llvm_type(cx).ptr_to());\n+            let ptr = bx.pointercast(result.llval, cx.ptr_to(ty.llvm_type(cx)));\n             bx.store(llval, ptr, result.align);\n         } else {\n             OperandRef::from_immediate_or_packed_pair(bx, llval, result.layout)\n@@ -727,8 +727,8 @@ fn copy_intrinsic(\n     let (size, align) = cx.size_and_align_of(ty);\n     let size = cx.c_usize(size.bytes());\n     let align = align.abi();\n-    let dst_ptr = bx.pointercast(dst, Type::i8p(cx));\n-    let src_ptr = bx.pointercast(src, Type::i8p(cx));\n+    let dst_ptr = bx.pointercast(dst, cx.i8p());\n+    let src_ptr = bx.pointercast(src, cx.i8p());\n     if allow_overlap {\n         bx.memmove(dst_ptr, align, src_ptr, align, bx.mul(size, count), volatile)\n     } else {\n@@ -748,7 +748,7 @@ fn memset_intrinsic(\n     let (size, align) = cx.size_and_align_of(ty);\n     let size = cx.c_usize(size.bytes());\n     let align = cx.c_i32(align.abi() as i32);\n-    let dst = bx.pointercast(dst, Type::i8p(cx));\n+    let dst = bx.pointercast(dst, cx.i8p());\n     call_memset(bx, dst, val, bx.mul(size, count), align, volatile)\n }\n \n@@ -763,7 +763,7 @@ fn try_intrinsic(\n     if bx.sess().no_landing_pads() {\n         bx.call(func, &[data], None);\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n-        bx.store(bx.cx().c_null(Type::i8p(&bx.cx())), dest, ptr_align);\n+        bx.store(cx.c_null(cx.i8p()), dest, ptr_align);\n     } else if wants_msvc_seh(bx.sess()) {\n         codegen_msvc_try(bx, cx, func, data, local_ptr, dest);\n     } else {\n@@ -839,7 +839,7 @@ fn codegen_msvc_try(\n         //      }\n         //\n         // More information can be found in libstd's seh.rs implementation.\n-        let i64p = Type::i64(cx).ptr_to();\n+        let i64p = cx.ptr_to(cx.i64());\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n         let slot = bx.alloca(i64p, \"slot\", ptr_align);\n         bx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(), None);\n@@ -930,12 +930,12 @@ fn codegen_gnu_try(\n         // being thrown.  The second value is a \"selector\" indicating which of\n         // the landing pad clauses the exception's type had been matched to.\n         // rust_try ignores the selector.\n-        let lpad_ty = Type::struct_(cx, &[Type::i8p(cx), Type::i32(cx)], false);\n+        let lpad_ty = cx.struct_(&[cx.i8p(), cx.i32()], false);\n         let vals = catch.landing_pad(lpad_ty, bx.cx().eh_personality(), 1);\n-        catch.add_clause(vals, bx.cx().c_null(Type::i8p(cx)));\n+        catch.add_clause(vals, bx.cx().c_null(cx.i8p()));\n         let ptr = catch.extract_value(vals, 0);\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n-        catch.store(ptr, catch.bitcast(local_ptr, Type::i8p(cx).ptr_to()), ptr_align);\n+        catch.store(ptr, catch.bitcast(local_ptr, cx.ptr_to(cx.i8p())), ptr_align);\n         catch.ret(cx.c_i32(1));\n     });\n \n@@ -1078,7 +1078,7 @@ fn generic_simd_intrinsic(\n                   found `{}` with length {}\",\n                  in_len, in_ty,\n                  ret_ty, out_len);\n-        require!(llret_ty.element_type().kind() == TypeKind::Integer,\n+        require!(bx.cx().kind(bx.cx().element_type(llret_ty)) == TypeKind::Integer,\n                  \"expected return type with integer elements, found `{}` with non-integer `{}`\",\n                  ret_ty,\n                  ret_ty.simd_type(tcx));\n@@ -1167,8 +1167,8 @@ fn generic_simd_intrinsic(\n             _ => return_error!(\"mask element type is `{}`, expected `i_`\", m_elem_ty)\n         }\n         // truncate the mask to a vector of i1s\n-        let i1 = Type::i1(bx.cx());\n-        let i1xn = Type::vector(i1, m_len as u64);\n+        let i1 = bx.cx().i1();\n+        let i1xn = bx.cx().vector(i1, m_len as u64);\n         let m_i1s = bx.trunc(args[0].immediate(), i1xn);\n         return Ok(bx.select(m_i1s, args[1].immediate(), args[2].immediate()));\n     }\n@@ -1300,16 +1300,16 @@ fn generic_simd_intrinsic(\n                       mut no_pointers: usize) -> &'ll Type {\n         // FIXME: use cx.layout_of(ty).llvm_type() ?\n         let mut elem_ty = match elem_ty.sty {\n-            ty::Int(v) => Type::int_from_ty(cx, v),\n-            ty::Uint(v) => Type::uint_from_ty(cx, v),\n-            ty::Float(v) => Type::float_from_ty(cx, v),\n+            ty::Int(v) => cx.int_from_ty( v),\n+            ty::Uint(v) => cx.uint_from_ty( v),\n+            ty::Float(v) => cx.float_from_ty( v),\n             _ => unreachable!(),\n         };\n         while no_pointers > 0 {\n-            elem_ty = elem_ty.ptr_to();\n+            elem_ty = cx.ptr_to(elem_ty);\n             no_pointers -= 1;\n         }\n-        Type::vector(elem_ty, vec_len as u64)\n+        cx.vector(elem_ty, vec_len as u64)\n     }\n \n \n@@ -1386,13 +1386,13 @@ fn generic_simd_intrinsic(\n         }\n \n         // Alignment of T, must be a constant integer value:\n-        let alignment_ty = Type::i32(bx.cx());\n+        let alignment_ty = bx.cx().i32();\n         let alignment = bx.cx().c_i32(bx.cx().align_of(in_elem).abi() as i32);\n \n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n-            let i1 = Type::i1(bx.cx());\n-            let i1xn = Type::vector(i1, in_len as u64);\n+            let i1 = bx.cx().i1();\n+            let i1xn = bx.cx().vector(i1, in_len as u64);\n             (bx.trunc(args[2].immediate(), i1xn), i1xn)\n         };\n \n@@ -1407,7 +1407,7 @@ fn generic_simd_intrinsic(\n         let llvm_intrinsic = format!(\"llvm.masked.gather.{}.{}\",\n                                      llvm_elem_vec_str, llvm_pointer_vec_str);\n         let f = declare::declare_cfn(bx.cx(), &llvm_intrinsic,\n-                                     Type::func(&[\n+                                     bx.cx().func(&[\n                                          llvm_pointer_vec_ty,\n                                          alignment_ty,\n                                          mask_ty,\n@@ -1486,17 +1486,17 @@ fn generic_simd_intrinsic(\n         }\n \n         // Alignment of T, must be a constant integer value:\n-        let alignment_ty = Type::i32(bx.cx());\n+        let alignment_ty = bx.cx().i32();\n         let alignment = bx.cx().c_i32(bx.cx().align_of(in_elem).abi() as i32);\n \n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n-            let i1 = Type::i1(bx.cx());\n-            let i1xn = Type::vector(i1, in_len as u64);\n+            let i1 = bx.cx().i1();\n+            let i1xn = bx.cx().vector(i1, in_len as u64);\n             (bx.trunc(args[2].immediate(), i1xn), i1xn)\n         };\n \n-        let ret_t = Type::void(bx.cx());\n+        let ret_t = bx.cx().void();\n \n         // Type of the vector of pointers:\n         let llvm_pointer_vec_ty = llvm_vector_ty(bx.cx(), underlying_ty, in_len, pointer_count);\n@@ -1509,7 +1509,7 @@ fn generic_simd_intrinsic(\n         let llvm_intrinsic = format!(\"llvm.masked.scatter.{}.{}\",\n                                      llvm_elem_vec_str, llvm_pointer_vec_str);\n         let f = declare::declare_cfn(bx.cx(), &llvm_intrinsic,\n-                                     Type::func(&[llvm_elem_vec_ty,\n+                                     bx.cx().func(&[llvm_elem_vec_ty,\n                                                   llvm_pointer_vec_ty,\n                                                   alignment_ty,\n                                                   mask_ty], ret_t));\n@@ -1565,8 +1565,8 @@ fn generic_simd_intrinsic(\n                         } else {\n                             // unordered arithmetic reductions do not:\n                             match f.bit_width() {\n-                                32 => bx.cx().c_undef(Type::f32(bx.cx())),\n-                                64 => bx.cx().c_undef(Type::f64(bx.cx())),\n+                                32 => bx.cx().c_undef(bx.cx().f32()),\n+                                64 => bx.cx().c_undef(bx.cx().f64()),\n                                 v => {\n                                     return_error!(r#\"\n unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n@@ -1643,8 +1643,8 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     }\n \n                     // boolean reductions operate on vectors of i1s:\n-                    let i1 = Type::i1(bx.cx());\n-                    let i1xn = Type::vector(i1, in_len as u64);\n+                    let i1 = bx.cx().i1();\n+                    let i1xn = bx.cx().vector(i1, in_len as u64);\n                     bx.trunc(args[0].immediate(), i1xn)\n                 };\n                 return match in_elem.sty {\n@@ -1654,7 +1654,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                             if !$boolean {\n                                 r\n                             } else {\n-                                bx.zext(r, Type::bool(bx.cx()))\n+                                bx.zext(r, bx.cx().bool())\n                             }\n                         )\n                     },"}, {"sha": "a8312b2a469d31b1aad0dc6ffaa73cd702189eb5", "filename": "src/librustc_codegen_llvm/meth.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmeth.rs?ref=730b13ab51b0885cb8a750036e9429e6c2a193f1", "patch": "@@ -14,10 +14,9 @@ use context::CodegenCx;\n use builder::Builder;\n use consts;\n use monomorphize;\n-use type_::Type;\n use value::Value;\n \n-use interfaces::{BuilderMethods, CommonMethods};\n+use interfaces::{BuilderMethods, CommonMethods, TypeMethods};\n \n use rustc::ty::{self, Ty};\n use rustc::ty::layout::HasDataLayout;\n@@ -41,7 +40,10 @@ impl<'a, 'tcx> VirtualIndex {\n         // Load the data pointer from the object.\n         debug!(\"get_fn({:?}, {:?})\", llvtable, self);\n \n-        let llvtable = bx.pointercast(llvtable, fn_ty.ptr_to_llvm_type(bx.cx()).ptr_to());\n+        let llvtable = bx.pointercast(\n+            llvtable,\n+            bx.cx().ptr_to(fn_ty.ptr_to_llvm_type(bx.cx()))\n+        );\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n         let ptr = bx.load(\n             bx.inbounds_gep(llvtable, &[bx.cx().c_usize(self.0)]),\n@@ -61,7 +63,7 @@ impl<'a, 'tcx> VirtualIndex {\n         // Load the data pointer from the object.\n         debug!(\"get_int({:?}, {:?})\", llvtable, self);\n \n-        let llvtable = bx.pointercast(llvtable, Type::isize(bx.cx()).ptr_to());\n+        let llvtable = bx.pointercast(llvtable, bx.cx().ptr_to(bx.cx().isize()));\n         let usize_align = bx.tcx().data_layout.pointer_align;\n         let ptr = bx.load(\n             bx.inbounds_gep(llvtable, &[bx.cx().c_usize(self.0)]),\n@@ -96,7 +98,7 @@ pub fn get_vtable(\n     }\n \n     // Not in the cache. Build it.\n-    let nullptr = cx.c_null(Type::i8p(cx));\n+    let nullptr = cx.c_null(cx.i8p());\n \n     let methods = tcx.vtable_methods(trait_ref.with_self_ty(tcx, ty));\n     let methods = methods.iter().cloned().map(|opt_mth| {"}, {"sha": "810baab48d6637994aaf4df51593139d0d6b6e55", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=730b13ab51b0885cb8a750036e9429e6c2a193f1", "patch": "@@ -26,7 +26,7 @@ use type_of::LayoutLlvmExt;\n use type_::Type;\n use value::Value;\n \n-use interfaces::{BuilderMethods, CommonMethods};\n+use interfaces::{BuilderMethods, CommonMethods, TypeMethods};\n \n use syntax::symbol::Symbol;\n use syntax_pos::Pos;\n@@ -268,7 +268,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                             }\n                         };\n                         bx.load(\n-                            bx.pointercast(llslot, cast_ty.llvm_type(bx.cx()).ptr_to()),\n+                            bx.pointercast(llslot, bx.cx().ptr_to(cast_ty.llvm_type(bx.cx()))),\n                             self.fn_ty.ret.layout.align)\n                     }\n                 };\n@@ -560,7 +560,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     let dest = match ret_dest {\n                         _ if fn_ty.ret.is_indirect() => llargs[0],\n                         ReturnDest::Nothing => {\n-                            bx.cx().c_undef(fn_ty.ret.memory_ty(bx.cx()).ptr_to())\n+                            bx.cx().c_undef(bx.cx().ptr_to(fn_ty.ret.memory_ty(bx.cx())))\n                         }\n                         ReturnDest::IndirectOperand(dst, _) |\n                         ReturnDest::Store(dst) => dst.llval,\n@@ -801,7 +801,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         if by_ref && !arg.is_indirect() {\n             // Have to load the argument, maybe while casting it.\n             if let PassMode::Cast(ty) = arg.mode {\n-                llval = bx.load(bx.pointercast(llval, ty.llvm_type(bx.cx()).ptr_to()),\n+                llval = bx.load(bx.pointercast(llval, bx.cx().ptr_to(ty.llvm_type(bx.cx()))),\n                                 align.min(arg.layout.align));\n             } else {\n                 // We can't use `PlaceRef::load` here because the argument\n@@ -902,7 +902,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n     fn landing_pad_type(&self) -> &'ll Type {\n         let cx = self.cx;\n-        Type::struct_(cx, &[Type::i8p(cx), Type::i32(cx)], false)\n+        cx.struct_( &[cx.i8p(), cx.i32()], false)\n     }\n \n     fn unreachable_block(&mut self) -> &'ll BasicBlock {\n@@ -1014,7 +1014,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                               dst: PlaceRef<'tcx, &'ll Value>) {\n         let src = self.codegen_operand(bx, src);\n         let llty = src.layout.llvm_type(bx.cx());\n-        let cast_ptr = bx.pointercast(dst.llval, llty.ptr_to());\n+        let cast_ptr = bx.pointercast(dst.llval, bx.cx().ptr_to(llty));\n         let align = src.layout.align.min(dst.layout.align);\n         src.val.store(bx, PlaceRef::new_sized(cast_ptr, src.layout, align));\n     }"}, {"sha": "4c401a3fdb84a4af8c4d300ae94baad8bb7b75b3", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=730b13ab51b0885cb8a750036e9429e6c2a193f1", "patch": "@@ -25,7 +25,7 @@ use type_::Type;\n use syntax::ast::Mutability;\n use syntax::source_map::Span;\n use value::Value;\n-use interfaces::{BuilderMethods, CommonMethods};\n+use interfaces::{BuilderMethods, CommonMethods, TypeMethods};\n \n use super::super::callee;\n use super::FunctionCx;\n@@ -40,11 +40,11 @@ pub fn scalar_to_llvm(\n     match cv {\n         Scalar::Bits { size: 0, .. } => {\n             assert_eq!(0, layout.value.size(cx).bytes());\n-            cx.c_undef(Type::ix(cx, 0))\n+            cx.c_undef(cx.ix(0))\n         },\n         Scalar::Bits { bits, size } => {\n             assert_eq!(size as u64, layout.value.size(cx).bytes());\n-            let llval = cx.c_uint_big(Type::ix(cx, bitsize), bits);\n+            let llval = cx.c_uint_big(cx.ix(bitsize), bits);\n             if layout.value == layout::Pointer {\n                 unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n             } else {\n@@ -72,7 +72,7 @@ pub fn scalar_to_llvm(\n                 None => bug!(\"missing allocation {:?}\", ptr.alloc_id),\n             };\n             let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n-                consts::bitcast(base_addr, Type::i8p(cx)),\n+                consts::bitcast(base_addr, cx.i8p()),\n                 &cx.c_usize(ptr.offset.bytes()),\n                 1,\n             ) };\n@@ -109,7 +109,7 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n                 value: layout::Primitive::Pointer,\n                 valid_range: 0..=!0\n             },\n-            Type::i8p(cx)\n+            cx.i8p()\n         ));\n         next_offset = offset + pointer_size;\n     }"}, {"sha": "10282c1053f4644c01661c71c7e49761f20783ee", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=730b13ab51b0885cb8a750036e9429e6c2a193f1", "patch": "@@ -23,7 +23,6 @@ use common::{CodegenCx, Funclet};\n use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n use monomorphize::Instance;\n use abi::{ArgTypeExt, FnType, FnTypeExt, PassMode};\n-use type_::Type;\n use value::Value;\n use interfaces::{BuilderMethods, CommonMethods};\n \n@@ -420,7 +419,7 @@ fn create_funclets(\n                 // C++ personality function, but `catch (...)` has no type so\n                 // it's null. The 64 here is actually a bitfield which\n                 // represents that this is a catch-all block.\n-                let null = bx.cx().c_null(Type::i8p(bx.cx()));\n+                let null = bx.cx().c_null(bx.cx().i8p());\n                 let sixty_four = bx.cx().c_i32(64);\n                 cleanup = cp_bx.catch_pad(cs, &[null, sixty_four, null]);\n                 cp_bx.br(llbb);"}, {"sha": "887b8fb0d0fe4b45951a2f9da5bcdda81d9c3184", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=730b13ab51b0885cb8a750036e9429e6c2a193f1", "patch": "@@ -18,10 +18,9 @@ use common::CodegenCx;\n use builder::{Builder, MemFlags};\n use value::Value;\n use type_of::LayoutLlvmExt;\n-use type_::Type;\n use glue;\n \n-use interfaces::{BuilderMethods, CommonMethods};\n+use interfaces::{BuilderMethods, CommonMethods, TypeMethods};\n \n use std::fmt;\n \n@@ -349,7 +348,7 @@ impl OperandValue<&'ll Value> {\n \n         // Allocate an appropriate region on the stack, and copy the value into it\n         let (llsize, _) = glue::size_and_align_of_dst(bx, unsized_ty, Some(llextra));\n-        let lldst = bx.array_alloca(Type::i8(bx.cx()), llsize, \"unsized_tmp\", max_align);\n+        let lldst = bx.array_alloca(bx.cx().i8(), llsize, \"unsized_tmp\", max_align);\n         base::call_memcpy(bx, lldst, max_align, llptr, min_align, llsize, flags);\n \n         // Store the allocated region and the extra to the indirect place.\n@@ -463,7 +462,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         // We've errored, so we don't have to produce working code.\n                         let layout = bx.cx().layout_of(ty);\n                         PlaceRef::new_sized(\n-                            bx.cx().c_undef(layout.llvm_type(bx.cx()).ptr_to()),\n+                            bx.cx().c_undef(bx.cx().ptr_to(layout.llvm_type(bx.cx()))),\n                             layout,\n                             layout.align,\n                         ).load(bx)"}, {"sha": "b34eea0ce1c1da50704787b30a6eaf4274bf8c16", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=730b13ab51b0885cb8a750036e9429e6c2a193f1", "patch": "@@ -18,12 +18,11 @@ use builder::Builder;\n use common::{CodegenCx, IntPredicate};\n use consts;\n use type_of::LayoutLlvmExt;\n-use type_::Type;\n use value::Value;\n use glue;\n use mir::constant::const_alloc_to_llvm;\n \n-use interfaces::{BuilderMethods, CommonMethods};\n+use interfaces::{BuilderMethods, CommonMethods, TypeMethods};\n \n use super::{FunctionCx, LocalRef};\n use super::operand::{OperandRef, OperandValue};\n@@ -68,11 +67,11 @@ impl PlaceRef<'tcx, &'ll Value> {\n         let base_addr = consts::addr_of(bx.cx(), init, layout.align, None);\n \n         let llval = unsafe { LLVMConstInBoundsGEP(\n-            consts::bitcast(base_addr, Type::i8p(bx.cx())),\n+            consts::bitcast(base_addr, bx.cx().i8p()),\n             &bx.cx().c_usize(offset.bytes()),\n             1,\n         )};\n-        let llval = consts::bitcast(llval, layout.llvm_type(bx.cx()).ptr_to());\n+        let llval = consts::bitcast(llval, bx.cx().ptr_to(layout.llvm_type(bx.cx())));\n         PlaceRef::new_sized(llval, layout, alloc.align)\n     }\n \n@@ -160,7 +159,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n                 let load = bx.load(llptr, self.align);\n                 scalar_load_metadata(load, scalar);\n                 if scalar.is_bool() {\n-                    bx.trunc(load, Type::i1(bx.cx()))\n+                    bx.trunc(load, bx.cx().i1())\n                 } else {\n                     load\n                 }\n@@ -197,7 +196,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n             };\n             PlaceRef {\n                 // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n-                llval: bx.pointercast(llval, field.llvm_type(cx).ptr_to()),\n+                llval: bx.pointercast(llval, cx.ptr_to(field.llvm_type(cx))),\n                 llextra: if cx.type_has_metadata(field.ty) {\n                     self.llextra\n                 } else {\n@@ -266,15 +265,15 @@ impl PlaceRef<'tcx, &'ll Value> {\n         debug!(\"struct_field_ptr: DST field offset: {:?}\", offset);\n \n         // Cast and adjust pointer\n-        let byte_ptr = bx.pointercast(self.llval, Type::i8p(cx));\n+        let byte_ptr = bx.pointercast(self.llval, cx.i8p());\n         let byte_ptr = bx.gep(byte_ptr, &[offset]);\n \n         // Finally, cast back to the type expected\n         let ll_fty = field.llvm_type(cx);\n         debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n \n         PlaceRef {\n-            llval: bx.pointercast(byte_ptr, ll_fty.ptr_to()),\n+            llval: bx.pointercast(byte_ptr, bx.cx().ptr_to(ll_fty)),\n             llextra: self.llextra,\n             layout: field,\n             align: effective_field_align,\n@@ -380,7 +379,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n                        bx.sess().target.target.arch == \"aarch64\" {\n                         // Issue #34427: As workaround for LLVM bug on ARM,\n                         // use memset of 0 before assigning niche value.\n-                        let llptr = bx.pointercast(self.llval, Type::i8(bx.cx()).ptr_to());\n+                        let llptr = bx.pointercast(self.llval, bx.cx().ptr_to(bx.cx().i8()));\n                         let fill_byte = bx.cx().c_u8(0);\n                         let (size, align) = self.layout.size_and_align();\n                         let size = bx.cx().c_usize(size.bytes());\n@@ -423,7 +422,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n \n         // Cast to the appropriate variant struct type.\n         let variant_ty = downcast.layout.llvm_type(bx.cx());\n-        downcast.llval = bx.pointercast(downcast.llval, variant_ty.ptr_to());\n+        downcast.llval = bx.pointercast(downcast.llval, bx.cx().ptr_to(variant_ty));\n \n         downcast\n     }\n@@ -484,7 +483,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         // so we generate an abort\n                         let fnname = bx.cx().get_intrinsic(&(\"llvm.trap\"));\n                         bx.call(fnname, &[], None);\n-                        let llval = bx.cx().c_undef(layout.llvm_type(bx.cx()).ptr_to());\n+                        let llval = bx.cx().c_undef(bx.cx().ptr_to(layout.llvm_type(bx.cx())));\n                         PlaceRef::new_sized(llval, layout, layout.align)\n                     }\n                 }\n@@ -544,7 +543,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         // Cast the place pointer type to the new\n                         // array or slice type (*[%_; new_len]).\n                         subslice.llval = bx.pointercast(subslice.llval,\n-                            subslice.layout.llvm_type(bx.cx()).ptr_to());\n+                            bx.cx().ptr_to(subslice.layout.llvm_type(bx.cx())));\n \n                         subslice\n                     }"}, {"sha": "3066e38753aac79f1eaceb83080f0d1cfc7526eb", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 33, "deletions": 22, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=730b13ab51b0885cb8a750036e9429e6c2a193f1", "patch": "@@ -26,7 +26,7 @@ use type_::Type;\n use type_of::LayoutLlvmExt;\n use value::Value;\n \n-use interfaces::{BuilderMethods, CommonMethods, CommonWriteMethods};\n+use interfaces::{BuilderMethods, CommonMethods, CommonWriteMethods, TypeMethods};\n \n use super::{FunctionCx, LocalRef};\n use super::operand::{OperandRef, OperandValue};\n@@ -117,7 +117,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n                     // Use llvm.memset.p0i8.* to initialize byte arrays\n                     let v = base::from_immediate(&bx, v);\n-                    if bx.cx().val_ty(v) == Type::i8(bx.cx()) {\n+                    if bx.cx().val_ty(v) == bx.cx().i8() {\n                         base::call_memset(&bx, start, v, size, align, false);\n                         return bx;\n                     }\n@@ -349,8 +349,8 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                                 bx.intcast(llval, ll_t_out, signed)\n                             }\n                             (CastTy::Float, CastTy::Float) => {\n-                                let srcsz = ll_t_in.float_width();\n-                                let dstsz = ll_t_out.float_width();\n+                                let srcsz = bx.cx().float_width(ll_t_in);\n+                                let dstsz = bx.cx().float_width(ll_t_out);\n                                 if dstsz > srcsz {\n                                     bx.fpext(llval, ll_t_out)\n                                 } else if srcsz > dstsz {\n@@ -828,7 +828,9 @@ fn cast_int_to_float(bx: &Builder<'_, 'll, '_>,\n     // Most integer types, even i128, fit into [-f32::MAX, f32::MAX] after rounding.\n     // It's only u128 -> f32 that can cause overflows (i.e., should yield infinity).\n     // LLVM's uitofp produces undef in those cases, so we manually check for that case.\n-    let is_u128_to_f32 = !signed && int_ty.int_width() == 128 && float_ty.float_width() == 32;\n+    let is_u128_to_f32 = !signed &&\n+        bx.cx().int_width(int_ty) == 128 &&\n+        bx.cx().float_width(float_ty) == 32;\n     if is_u128_to_f32 {\n         // All inputs greater or equal to (f32::MAX + 0.5 ULP) are rounded to infinity,\n         // and for everything else LLVM's uitofp works just fine.\n@@ -883,39 +885,48 @@ fn cast_float_to_int(bx: &Builder<'_, 'll, '_>,\n     // On the other hand, f_max works even if int_ty::MAX is greater than float_ty::MAX. Because\n     // we're rounding towards zero, we just get float_ty::MAX (which is always an integer).\n     // This already happens today with u128::MAX = 2^128 - 1 > f32::MAX.\n-    fn compute_clamp_bounds<F: Float>(signed: bool, int_ty: &Type) -> (u128, u128) {\n-        let rounded_min = F::from_i128_r(int_min(signed, int_ty), Round::TowardZero);\n-        assert_eq!(rounded_min.status, Status::OK);\n-        let rounded_max = F::from_u128_r(int_max(signed, int_ty), Round::TowardZero);\n-        assert!(rounded_max.value.is_finite());\n-        (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n-    }\n-    fn int_max(signed: bool, int_ty: &Type) -> u128 {\n-        let shift_amount = 128 - int_ty.int_width();\n+    let int_max = |signed: bool, int_ty: &'ll Type| -> u128 {\n+        let shift_amount = 128 - bx.cx().int_width(int_ty);\n         if signed {\n             i128::MAX as u128 >> shift_amount\n         } else {\n             u128::MAX >> shift_amount\n         }\n-    }\n-    fn int_min(signed: bool, int_ty: &Type) -> i128 {\n+    };\n+    let int_min = |signed: bool, int_ty: &'ll Type| -> i128 {\n         if signed {\n-            i128::MIN >> (128 - int_ty.int_width())\n+            i128::MIN >> (128 - bx.cx().int_width(int_ty))\n         } else {\n             0\n         }\n-    }\n+    };\n+\n+    let compute_clamp_bounds_single = |signed: bool, int_ty: &'ll Type| -> (u128, u128) {\n+        let rounded_min = ieee::Single::from_i128_r(int_min(signed, int_ty), Round::TowardZero);\n+        assert_eq!(rounded_min.status, Status::OK);\n+        let rounded_max = ieee::Single::from_u128_r(int_max(signed, int_ty), Round::TowardZero);\n+        assert!(rounded_max.value.is_finite());\n+        (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n+    };\n+    let compute_clamp_bounds_double = |signed: bool, int_ty: &'ll Type| -> (u128, u128) {\n+        let rounded_min = ieee::Double::from_i128_r(int_min(signed, int_ty), Round::TowardZero);\n+        assert_eq!(rounded_min.status, Status::OK);\n+        let rounded_max = ieee::Double::from_u128_r(int_max(signed, int_ty), Round::TowardZero);\n+        assert!(rounded_max.value.is_finite());\n+        (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n+    };\n+\n     let float_bits_to_llval = |bits| {\n-        let bits_llval = match float_ty.float_width() {\n+        let bits_llval = match bx.cx().float_width(float_ty) {\n             32 => bx.cx().c_u32(bits as u32),\n             64 => bx.cx().c_u64(bits as u64),\n             n => bug!(\"unsupported float width {}\", n),\n         };\n         consts::bitcast(bits_llval, float_ty)\n     };\n-    let (f_min, f_max) = match float_ty.float_width() {\n-        32 => compute_clamp_bounds::<ieee::Single>(signed, int_ty),\n-        64 => compute_clamp_bounds::<ieee::Double>(signed, int_ty),\n+    let (f_min, f_max) = match bx.cx().float_width(float_ty) {\n+        32 => compute_clamp_bounds_single(signed, int_ty),\n+        64 => compute_clamp_bounds_double(signed, int_ty),\n         n => bug!(\"unsupported float width {}\", n),\n     };\n     let f_min = float_bits_to_llval(f_min);"}, {"sha": "d4b137926d516a1f0dc39bcc4d7c708d11a4cd15", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 152, "deletions": 178, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=730b13ab51b0885cb8a750036e9429e6c2a193f1", "patch": "@@ -16,10 +16,12 @@ use llvm;\n use llvm::{Bool, False, True, TypeKind};\n \n use context::CodegenCx;\n+use interfaces::TypeMethods;\n \n use syntax::ast;\n use rustc::ty::layout::{self, Align, Size};\n use rustc_data_structures::small_c_str::SmallCStr;\n+use back::write;\n \n use std::fmt;\n \n@@ -39,191 +41,85 @@ impl fmt::Debug for Type {\n     }\n }\n \n-impl Type {\n-    pub fn void(\n-        cx: &CodegenCx<'ll, '_>\n-    ) -> &'ll Type {\n-        unsafe {\n-            llvm::LLVMVoidTypeInContext(cx.llcx)\n-        }\n-    }\n+impl TypeMethods for CodegenCx<'ll, 'tcx> {\n \n-    pub fn metadata(\n-        cx: &CodegenCx<'ll, '_>\n-    ) -> &'ll Type {\n+    fn void(&self) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMRustMetadataTypeInContext(cx.llcx)\n+            llvm::LLVMVoidTypeInContext(self.llcx)\n         }\n     }\n \n-    pub fn i1(\n-        cx: &CodegenCx<'ll, '_>\n-    ) -> &'ll Type {\n+    fn metadata(&self) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMInt1TypeInContext(cx.llcx)\n+            llvm::LLVMRustMetadataTypeInContext(self.llcx)\n         }\n     }\n \n-    pub fn i8(\n-        cx: &CodegenCx<'ll, '_>\n-    ) -> &'ll Type {\n+    fn i1(&self) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMInt8TypeInContext(cx.llcx)\n+            llvm::LLVMInt1TypeInContext(self.llcx)\n         }\n     }\n \n-    pub fn i8_llcx(llcx: &llvm::Context) -> &Type {\n+    fn i8(&self) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMInt8TypeInContext(llcx)\n+            llvm::LLVMInt8TypeInContext(self.llcx)\n         }\n     }\n \n-    pub fn i16(\n-        cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+\n+    fn i16(&self) -> &'ll Type {\n         unsafe {\n \n-            llvm::LLVMInt16TypeInContext(cx.llcx)\n+            llvm::LLVMInt16TypeInContext(self.llcx)\n         }\n     }\n \n-    pub fn i32(\n-        cx: &CodegenCx<'ll, '_>\n-    ) -> &'ll Type {\n+    fn i32(&self) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMInt32TypeInContext(cx.llcx)\n+            llvm::LLVMInt32TypeInContext(self.llcx)\n         }\n     }\n \n-    pub fn i64(\n-        cx: &CodegenCx<'ll, '_>\n-    ) -> &'ll Type {\n+    fn i64(&self) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMInt64TypeInContext(cx.llcx)\n+            llvm::LLVMInt64TypeInContext(self.llcx)\n         }\n     }\n \n-    pub fn i128(\n-        cx: &CodegenCx<'ll, '_>\n-    ) -> &'ll Type {\n+    fn i128(&self) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMIntTypeInContext(cx.llcx, 128)\n+            llvm::LLVMIntTypeInContext(self.llcx, 128)\n         }\n     }\n \n     // Creates an integer type with the given number of bits, e.g. i24\n-    pub fn ix(\n-        cx: &CodegenCx<'ll, '_>,\n-        num_bits: u64\n-    ) -> &'ll Type {\n+    fn ix(&self, num_bits: u64) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMIntTypeInContext(cx.llcx, num_bits as c_uint)\n+            llvm::LLVMIntTypeInContext(self.llcx, num_bits as c_uint)\n         }\n     }\n \n-    // Creates an integer type with the given number of bits, e.g. i24\n-    pub fn ix_llcx(\n-        llcx: &llvm::Context,\n-        num_bits: u64\n-    ) -> &Type {\n+    fn f32(&self) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMIntTypeInContext(llcx, num_bits as c_uint)\n+            llvm::LLVMFloatTypeInContext(self.llcx)\n         }\n     }\n \n-    pub fn f32(\n-        cx: &CodegenCx<'ll, '_>\n-    ) -> &'ll Type {\n+    fn f64(&self) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMFloatTypeInContext(cx.llcx)\n+            llvm::LLVMDoubleTypeInContext(self.llcx)\n         }\n     }\n \n-    pub fn f64(\n-        cx: &CodegenCx<'ll, '_>\n-    ) -> &'ll Type {\n+    fn x86_mmx(&self) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMDoubleTypeInContext(cx.llcx)\n-        }\n-    }\n-\n-    pub fn bool(\n-        cx: &CodegenCx<'ll, '_>\n-    ) -> &'ll Type {\n-        Type::i8(cx)\n-    }\n-\n-    pub fn char(\n-        cx: &CodegenCx<'ll, '_>\n-    ) -> &'ll Type {\n-        Type::i32(cx)\n-    }\n-\n-    pub fn i8p(\n-        cx: &CodegenCx<'ll, '_>\n-    ) -> &'ll Type {\n-        Type::i8(cx).ptr_to()\n-    }\n-\n-    pub fn i8p_llcx(llcx: &llvm::Context) -> &Type {\n-        Type::i8_llcx(llcx).ptr_to()\n-    }\n-\n-    pub fn isize(\n-        cx: &CodegenCx<'ll, '_>\n-    ) -> &'ll Type {\n-        cx.isize_ty\n-    }\n-\n-    pub fn c_int(\n-        cx: &CodegenCx<'ll, '_>\n-    ) -> &'ll Type {\n-        match &cx.tcx.sess.target.target.target_c_int_width[..] {\n-            \"16\" => Type::i16(cx),\n-            \"32\" => Type::i32(cx),\n-            \"64\" => Type::i64(cx),\n-            width => bug!(\"Unsupported target_c_int_width: {}\", width),\n-        }\n-    }\n-\n-    pub fn int_from_ty(\n-        cx: &CodegenCx<'ll, '_>,\n-        t: ast::IntTy\n-    ) -> &'ll Type {\n-        match t {\n-            ast::IntTy::Isize => cx.isize_ty,\n-            ast::IntTy::I8 => Type::i8(cx),\n-            ast::IntTy::I16 => Type::i16(cx),\n-            ast::IntTy::I32 => Type::i32(cx),\n-            ast::IntTy::I64 => Type::i64(cx),\n-            ast::IntTy::I128 => Type::i128(cx),\n-        }\n-    }\n-\n-    pub fn uint_from_ty(\n-        cx: &CodegenCx<'ll, '_>,\n-        t: ast::UintTy\n-    ) -> &'ll Type {\n-        match t {\n-            ast::UintTy::Usize => cx.isize_ty,\n-            ast::UintTy::U8 => Type::i8(cx),\n-            ast::UintTy::U16 => Type::i16(cx),\n-            ast::UintTy::U32 => Type::i32(cx),\n-            ast::UintTy::U64 => Type::i64(cx),\n-            ast::UintTy::U128 => Type::i128(cx),\n-        }\n-    }\n-\n-    pub fn float_from_ty(\n-        cx: &CodegenCx<'ll, '_>,\n-        t: ast::FloatTy\n-    ) -> &'ll Type {\n-        match t {\n-            ast::FloatTy::F32 => Type::f32(cx),\n-            ast::FloatTy::F64 => Type::f64(cx),\n+            llvm::LLVMX86MMXTypeInContext(self.llcx)\n         }\n     }\n \n-    pub fn func(\n+    fn func(\n+        &self,\n         args: &[&'ll Type],\n         ret: &'ll Type\n     ) -> &'ll Type {\n@@ -233,7 +129,8 @@ impl Type {\n         }\n     }\n \n-    pub fn variadic_func(\n+    fn variadic_func(\n+        &self,\n         args: &[&'ll Type],\n         ret: &'ll Type\n     ) -> &'ll Type {\n@@ -243,84 +140,84 @@ impl Type {\n         }\n     }\n \n-    pub fn struct_(\n-        cx: &CodegenCx<'ll, '_>,\n+    fn struct_(\n+        &self,\n         els: &[&'ll Type],\n         packed: bool\n     ) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMStructTypeInContext(cx.llcx, els.as_ptr(),\n+            llvm::LLVMStructTypeInContext(self.llcx, els.as_ptr(),\n                                           els.len() as c_uint,\n                                           packed as Bool)\n         }\n     }\n \n-    pub fn named_struct(cx: &CodegenCx<'ll, '_>, name: &str) -> &'ll Type {\n+    fn named_struct(&self, name: &str) -> &'ll Type {\n         let name = SmallCStr::new(name);\n         unsafe {\n-            llvm::LLVMStructCreateNamed(cx.llcx, name.as_ptr())\n+            llvm::LLVMStructCreateNamed(self.llcx, name.as_ptr())\n         }\n     }\n \n \n-    pub fn array(ty: &Type, len: u64) -> &Type {\n+    fn array(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n         unsafe {\n             llvm::LLVMRustArrayType(ty, len)\n         }\n     }\n \n-    pub fn vector(ty: &Type, len: u64) -> &Type {\n+    fn vector(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n         unsafe {\n             llvm::LLVMVectorType(ty, len as c_uint)\n         }\n     }\n \n-    pub fn kind(&self) -> TypeKind {\n+    fn kind(&self, ty: &'ll Type) -> TypeKind {\n         unsafe {\n-            llvm::LLVMRustGetTypeKind(self)\n+            llvm::LLVMRustGetTypeKind(ty)\n         }\n     }\n \n-    pub fn set_struct_body(&'ll self, els: &[&'ll Type], packed: bool) {\n+    fn set_struct_body(&self, ty: &'ll Type, els: &[&'ll Type], packed: bool) {\n         unsafe {\n-            llvm::LLVMStructSetBody(self, els.as_ptr(),\n+            llvm::LLVMStructSetBody(ty, els.as_ptr(),\n                                     els.len() as c_uint, packed as Bool)\n         }\n     }\n \n-    pub fn ptr_to(&self) -> &Type {\n-        assert_ne!(self.kind(), TypeKind::Function,\n+    fn ptr_to(&self, ty: &'ll Type) -> &'ll Type {\n+        assert_ne!(self.kind(ty), TypeKind::Function,\n                    \"don't call ptr_to on function types, use ptr_to_llvm_type on FnType instead\");\n         unsafe {\n-            llvm::LLVMPointerType(self, 0)\n+            llvm::LLVMPointerType(ty, 0)\n         }\n     }\n \n-    pub fn element_type(&self) -> &Type {\n+    fn element_type(&self, ty: &'ll Type) -> &'ll Type {\n         unsafe {\n-            llvm::LLVMGetElementType(self)\n+            llvm::LLVMGetElementType(ty)\n         }\n     }\n \n     /// Return the number of elements in `self` if it is a LLVM vector type.\n-    pub fn vector_length(&self) -> usize {\n+    fn vector_length(&self, ty: &'ll Type) -> usize {\n         unsafe {\n-            llvm::LLVMGetVectorSize(self) as usize\n+            llvm::LLVMGetVectorSize(ty) as usize\n         }\n     }\n \n-    pub fn func_params(&self) -> Vec<&Type> {\n+    fn func_params(&self, ty: &'ll Type) -> Vec<&'ll Type> {\n         unsafe {\n-            let n_args = llvm::LLVMCountParamTypes(self) as usize;\n+            let n_args = llvm::LLVMCountParamTypes(ty) as usize;\n             let mut args = Vec::with_capacity(n_args);\n-            llvm::LLVMGetParamTypes(self, args.as_mut_ptr());\n+            llvm::LLVMGetParamTypes(ty, args.as_mut_ptr());\n             args.set_len(n_args);\n             args\n         }\n     }\n \n-    pub fn float_width(&self) -> usize {\n-        match self.kind() {\n+    fn float_width(&self, ty : &'ll Type) -> usize {\n+        match self.kind(ty) {\n             TypeKind::Float => 32,\n             TypeKind::Double => 64,\n             TypeKind::X86_FP80 => 80,\n@@ -330,44 +227,121 @@ impl Type {\n     }\n \n     /// Retrieve the bit width of the integer type `self`.\n-    pub fn int_width(&self) -> u64 {\n+    fn int_width(&self, ty: &'ll Type) -> u64 {\n+        unsafe {\n+            llvm::LLVMGetIntTypeWidth(ty) as u64\n+        }\n+    }\n+}\n+\n+impl Type {\n+    pub fn i8_llcx(llcx: &llvm::Context) -> &Type {\n+        unsafe {\n+            llvm::LLVMInt8TypeInContext(llcx)\n+        }\n+    }\n+\n+    // Creates an integer type with the given number of bits, e.g. i24\n+    pub fn ix_llcx(\n+        llcx: &llvm::Context,\n+        num_bits: u64\n+    ) -> &Type {\n         unsafe {\n-            llvm::LLVMGetIntTypeWidth(self) as u64\n+            llvm::LLVMIntTypeInContext(llcx, num_bits as c_uint)\n+        }\n+    }\n+\n+    pub fn i8p_llcx(cx : &write::CodegenContext<'ll>, llcx: &'ll llvm::Context) -> &'ll Type {\n+        cx.ptr_to(Type::i8_llcx(llcx))\n+    }\n+}\n+\n+impl CodegenCx<'ll, 'tcx> {\n+    pub fn bool(&self) -> &'ll Type {\n+        self.i8()\n+    }\n+\n+    pub fn i8p(&self) -> &'ll Type {\n+        self.ptr_to(self.i8())\n+    }\n+\n+    pub fn isize(&self) -> &'ll Type {\n+        self.isize_ty\n+    }\n+\n+    pub fn t_int(&self) -> &'ll Type {\n+        match &self.sess().target.target.target_c_int_width[..] {\n+            \"16\" => self.i16(),\n+            \"32\" => self.i32(),\n+            \"64\" => self.i64(),\n+            width => bug!(\"Unsupported target_c_int_width: {}\", width),\n+        }\n+    }\n+\n+    pub fn int_from_ty(\n+        &self,\n+        t: ast::IntTy\n+    ) -> &'ll Type {\n+        match t {\n+            ast::IntTy::Isize => self.isize_ty,\n+            ast::IntTy::I8 => self.i8(),\n+            ast::IntTy::I16 => self.i16(),\n+            ast::IntTy::I32 => self.i32(),\n+            ast::IntTy::I64 => self.i64(),\n+            ast::IntTy::I128 => self.i128(),\n+        }\n+    }\n+\n+    pub fn uint_from_ty(\n+        &self,\n+        t: ast::UintTy\n+    ) -> &'ll Type {\n+        match t {\n+            ast::UintTy::Usize => self.isize_ty,\n+            ast::UintTy::U8 => self.i8(),\n+            ast::UintTy::U16 => self.i16(),\n+            ast::UintTy::U32 => self.i32(),\n+            ast::UintTy::U64 => self.i64(),\n+            ast::UintTy::U128 => self.i128(),\n         }\n     }\n \n-    pub fn from_integer(cx: &CodegenCx<'ll, '_>, i: layout::Integer) -> &'ll Type {\n+    pub fn float_from_ty(\n+        &self,\n+        t: ast::FloatTy\n+    ) -> &'ll Type {\n+        match t {\n+            ast::FloatTy::F32 => self.f32(),\n+            ast::FloatTy::F64 => self.f64(),\n+        }\n+    }\n+\n+    pub fn from_integer(&self, i: layout::Integer) -> &'ll Type {\n         use rustc::ty::layout::Integer::*;\n         match i {\n-            I8 => Type::i8(cx),\n-            I16 => Type::i16(cx),\n-            I32 => Type::i32(cx),\n-            I64 => Type::i64(cx),\n-            I128 => Type::i128(cx),\n+            I8 => self.i8(),\n+            I16 => self.i16(),\n+            I32 => self.i32(),\n+            I64 => self.i64(),\n+            I128 => self.i128(),\n         }\n     }\n \n     /// Return a LLVM type that has at most the required alignment,\n     /// as a conservative approximation for unknown pointee types.\n-    pub fn pointee_for_abi_align(cx: &CodegenCx<'ll, '_>, align: Align) -> &'ll Type {\n+    pub fn pointee_for_abi_align(&self, align: Align) -> &'ll Type {\n         // FIXME(eddyb) We could find a better approximation if ity.align < align.\n-        let ity = layout::Integer::approximate_abi_align(cx, align);\n-        Type::from_integer(cx, ity)\n+        let ity = layout::Integer::approximate_abi_align(self, align);\n+        self.from_integer(ity)\n     }\n \n     /// Return a LLVM type that has at most the required alignment,\n     /// and exactly the required size, as a best-effort padding array.\n-    pub fn padding_filler(cx: &CodegenCx<'ll, '_>, size: Size, align: Align) -> &'ll Type {\n-        let unit = layout::Integer::approximate_abi_align(cx, align);\n+    pub fn padding_filler(&self, size: Size, align: Align) -> &'ll Type {\n+        let unit = layout::Integer::approximate_abi_align(self, align);\n         let size = size.bytes();\n         let unit_size = unit.size().bytes();\n         assert_eq!(size % unit_size, 0);\n-        Type::array(Type::from_integer(cx, unit), size / unit_size)\n-    }\n-\n-    pub fn x86_mmx(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n-        unsafe {\n-            llvm::LLVMX86MMXTypeInContext(cx.llcx)\n-        }\n+        self.array(self.from_integer(unit), size / unit_size)\n     }\n }"}, {"sha": "4cc3d216abac0b2c1cdad1fef775fe72b6522ada", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730b13ab51b0885cb8a750036e9429e6c2a193f1/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=730b13ab51b0885cb8a750036e9429e6c2a193f1", "patch": "@@ -16,6 +16,7 @@ use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n use rustc_target::abi::FloatTy;\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n use type_::Type;\n+use interfaces::TypeMethods;\n \n use std::fmt::Write;\n \n@@ -37,14 +38,14 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 (cx.sess().target.target.arch == \"x86\" ||\n                  cx.sess().target.target.arch == \"x86_64\");\n             if use_x86_mmx {\n-                return Type::x86_mmx(cx)\n+                return cx.x86_mmx()\n             } else {\n                 let element = layout.scalar_llvm_type_at(cx, element, Size::ZERO);\n-                return Type::vector(element, count);\n+                return cx.vector(element, count);\n             }\n         }\n         layout::Abi::ScalarPair(..) => {\n-            return Type::struct_(cx, &[\n+            return cx.struct_( &[\n                 layout.scalar_pair_element_llvm_type(cx, 0, false),\n                 layout.scalar_pair_element_llvm_type(cx, 1, false),\n             ], false);\n@@ -79,30 +80,30 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n     match layout.fields {\n         layout::FieldPlacement::Union(_) => {\n-            let fill = Type::padding_filler(cx, layout.size, layout.align);\n+            let fill = cx.padding_filler( layout.size, layout.align);\n             let packed = false;\n             match name {\n                 None => {\n-                    Type::struct_(cx, &[fill], packed)\n+                    cx.struct_( &[fill], packed)\n                 }\n                 Some(ref name) => {\n-                    let llty = Type::named_struct(cx, name);\n-                    llty.set_struct_body(&[fill], packed);\n+                    let llty = cx.named_struct( name);\n+                    cx.set_struct_body(llty, &[fill], packed);\n                     llty\n                 }\n             }\n         }\n         layout::FieldPlacement::Array { count, .. } => {\n-            Type::array(layout.field(cx, 0).llvm_type(cx), count)\n+            cx.array(layout.field(cx, 0).llvm_type(cx), count)\n         }\n         layout::FieldPlacement::Arbitrary { .. } => {\n             match name {\n                 None => {\n                     let (llfields, packed) = struct_llfields(cx, layout);\n-                    Type::struct_(cx, &llfields, packed)\n+                    cx.struct_( &llfields, packed)\n                 }\n                 Some(ref name) => {\n-                    let llty = Type::named_struct(cx, name);\n+                    let llty = cx.named_struct( name);\n                     *defer = Some((llty, layout));\n                     llty\n                 }\n@@ -136,7 +137,7 @@ fn struct_llfields<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         let padding = target_offset - offset;\n         let padding_align = prev_effective_align.min(effective_field_align);\n         assert_eq!(offset.abi_align(padding_align) + padding, target_offset);\n-        result.push(Type::padding_filler(cx, padding, padding_align));\n+        result.push(cx.padding_filler( padding, padding_align));\n         debug!(\"    padding before: {:?}\", padding);\n \n         result.push(field.llvm_type(cx));\n@@ -153,7 +154,7 @@ fn struct_llfields<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         assert_eq!(offset.abi_align(padding_align) + padding, layout.size);\n         debug!(\"struct_llfields: pad_bytes: {:?} offset: {:?} stride: {:?}\",\n                padding, offset, layout.size);\n-        result.push(Type::padding_filler(cx, padding, padding_align));\n+        result.push(cx.padding_filler(padding, padding_align));\n         assert_eq!(result.len(), 1 + field_count * 2);\n     } else {\n         debug!(\"struct_llfields: offset: {:?} stride: {:?}\",\n@@ -255,10 +256,10 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n             let llty = match self.ty.sty {\n                 ty::Ref(_, ty, _) |\n                 ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n-                    cx.layout_of(ty).llvm_type(cx).ptr_to()\n+                    cx.ptr_to(cx.layout_of(ty).llvm_type(cx))\n                 }\n                 ty::Adt(def, _) if def.is_box() => {\n-                    cx.layout_of(self.ty.boxed_ty()).llvm_type(cx).ptr_to()\n+                    cx.ptr_to(cx.layout_of(self.ty.boxed_ty()).llvm_type(cx))\n                 }\n                 ty::FnPtr(sig) => {\n                     let sig = cx.tcx.normalize_erasing_late_bound_regions(\n@@ -307,7 +308,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n \n         if let Some((llty, layout)) = defer {\n             let (llfields, packed) = struct_llfields(cx, layout);\n-            llty.set_struct_body(&llfields, packed)\n+            cx.set_struct_body(llty, &llfields, packed)\n         }\n \n         llty\n@@ -316,7 +317,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     fn immediate_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type {\n         if let layout::Abi::Scalar(ref scalar) = self.abi {\n             if scalar.is_bool() {\n-                return Type::i1(cx);\n+                return cx.i1();\n             }\n         }\n         self.llvm_type(cx)\n@@ -325,17 +326,17 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     fn scalar_llvm_type_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>,\n                                scalar: &layout::Scalar, offset: Size) -> &'a Type {\n         match scalar.value {\n-            layout::Int(i, _) => Type::from_integer(cx, i),\n-            layout::Float(FloatTy::F32) => Type::f32(cx),\n-            layout::Float(FloatTy::F64) => Type::f64(cx),\n+            layout::Int(i, _) => cx.from_integer( i),\n+            layout::Float(FloatTy::F32) => cx.f32(),\n+            layout::Float(FloatTy::F64) => cx.f64(),\n             layout::Pointer => {\n                 // If we know the alignment, pick something better than i8.\n                 let pointee = if let Some(pointee) = self.pointee_info_at(cx, offset) {\n-                    Type::pointee_for_abi_align(cx, pointee.align)\n+                    cx.pointee_for_abi_align( pointee.align)\n                 } else {\n-                    Type::i8(cx)\n+                    cx.i8()\n                 };\n-                pointee.ptr_to()\n+                cx.ptr_to(pointee)\n             }\n         }\n     }\n@@ -369,7 +370,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         // when immediate.  We need to load/store `bool` as `i8` to avoid\n         // crippling LLVM optimizations or triggering other LLVM bugs with `i1`.\n         if immediate && scalar.is_bool() {\n-            return Type::i1(cx);\n+            return cx.i1();\n         }\n \n         let offset = if index == 0 {"}]}