{"sha": "54615ec9894f4f101bb15d70b6dc9b0c61f1249c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0NjE1ZWM5ODk0ZjRmMTAxYmIxNWQ3MGI2ZGM5YjBjNjFmMTI0OWM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2018-01-28T13:41:17Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-03-08T07:34:12Z"}, "message": "Split const prop into its own pass", "tree": {"sha": "b19bb0520b06d40be144535e6e4221bec8ae8b45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b19bb0520b06d40be144535e6e4221bec8ae8b45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54615ec9894f4f101bb15d70b6dc9b0c61f1249c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlqg53QACgkQpp+NIls6\n19lzEA/8DXfoWE6HDduFywBDI/BXMd+pLKFifZ7gcbA/efx19Tx0bdNGeHr5vODs\nzGHUOsVdC5GCh0pblFmvsn61QGjkhLa681f1Ul2lgkX3cROXO5LWFjADVhxuKocT\nDM5U1og3knGJov0ryNrOPHvUzOP4AE0omOdrxWi56nDmHyvUQOKMtM4ReJKrWDcB\nDaGWRhGFZJeX64fEfH9RNYxY5WaT9J+x/xREkpgygqFYB0+9Eta1wH7VQrecKCwU\n9RIP2cMFouqgaEqSIOT/NtqiMwCbYF4e/3ThBJngDKqxByOSbdD7QTmuU02/k/3t\nWZZgnccGOzugckI4ftE5LmB6hokOo+tqxRuip7vr8EN4qvE21WGdWmN3B4CCbLSC\nYc6kvO4FSxn+f8eJtJjseAsgCuh9LATF2H+orGDa9JAr7pqrq4l5g3zmND2lM8P+\nk6sM3K747Nw1MLLrY/LWDWYih1SBfCd754imO5W++C+dcmAew/ParuUxBKTL6b0+\nFaV3FBbqhf06IUNtN4t4lcVVe7LG1Z8q7rB1hk+kq9q4cSqJwBJv9tQ8L6cMvb6k\nInXezYSJmcWeA1ShIIXRwJuDrw9RPG0XoiB9d2Eqf+IsBCIkn8x0LVtdzqJFaHUx\n9vGhTJ0Led/BhJBCIykUOUwL2/Voi7hHLA73P46fJr4WGcATjII=\n=A/L0\n-----END PGP SIGNATURE-----", "payload": "tree b19bb0520b06d40be144535e6e4221bec8ae8b45\nparent edb2af58e4171a5a34fef0cc1b542039e5fc4701\nauthor Oliver Schneider <git-no-reply-9879165716479413131@oli-obk.de> 1517146877 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1520494452 +0100\n\nSplit const prop into its own pass\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54615ec9894f4f101bb15d70b6dc9b0c61f1249c", "html_url": "https://github.com/rust-lang/rust/commit/54615ec9894f4f101bb15d70b6dc9b0c61f1249c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54615ec9894f4f101bb15d70b6dc9b0c61f1249c/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edb2af58e4171a5a34fef0cc1b542039e5fc4701", "url": "https://api.github.com/repos/rust-lang/rust/commits/edb2af58e4171a5a34fef0cc1b542039e5fc4701", "html_url": "https://github.com/rust-lang/rust/commit/edb2af58e4171a5a34fef0cc1b542039e5fc4701"}], "stats": {"total": 959, "additions": 520, "deletions": 439}, "files": [{"sha": "652b921e80a74624861638786ad0c133da8d7001", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "added", "additions": 513, "deletions": 0, "changes": 513, "blob_url": "https://github.com/rust-lang/rust/blob/54615ec9894f4f101bb15d70b6dc9b0c61f1249c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54615ec9894f4f101bb15d70b6dc9b0c61f1249c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=54615ec9894f4f101bb15d70b6dc9b0c61f1249c", "patch": "@@ -0,0 +1,513 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Propagates constants for early reporting of statically known\n+//! assertion failures\n+\n+\n+\n+use rustc::mir::{Constant, Literal, Location, Place, Mir, Operand, Rvalue, Local};\n+use rustc::mir::{NullOp, StatementKind, Statement, BasicBlock, LocalKind};\n+use rustc::mir::TerminatorKind;\n+use rustc::mir::visit::{MutVisitor, Visitor};\n+use rustc::middle::const_val::ConstVal;\n+use rustc::ty::{TyCtxt, self, Instance};\n+use rustc::mir::interpret::{Value, PrimVal, GlobalId};\n+use interpret::{eval_body_with_mir, eval_body, mk_borrowck_eval_cx, unary_op, ValTy};\n+use rustc::util::nodemap::FxHashMap;\n+use transform::{MirPass, MirSource};\n+use syntax::codemap::Span;\n+use rustc::ty::subst::Substs;\n+\n+pub struct ConstProp;\n+\n+impl MirPass for ConstProp {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          source: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n+        trace!(\"ConstProp starting for {:?}\", source.def_id);\n+\n+        // First, find optimization opportunities. This is done in a pre-pass to keep the MIR\n+        // read-only so that we can do global analyses on the MIR in the process (e.g.\n+        // `Place::ty()`).\n+        let optimizations = {\n+            let mut optimization_finder = OptimizationFinder::new(mir, tcx, source);\n+            optimization_finder.visit_mir(mir);\n+            optimization_finder.optimizations\n+        };\n+\n+        // Then carry out those optimizations.\n+        MutVisitor::visit_mir(&mut ConstPropVisitor { optimizations, tcx }, mir);\n+        trace!(\"ConstProp done for {:?}\", source.def_id);\n+    }\n+}\n+\n+type Const<'tcx> = (Value, ty::Ty<'tcx>, Span);\n+\n+pub struct ConstPropVisitor<'a, 'tcx: 'a> {\n+    optimizations: OptimizationList<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+}\n+\n+impl<'a, 'tcx> MutVisitor<'tcx> for ConstPropVisitor<'a, 'tcx> {\n+    fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n+        if let Some((value, ty, span)) = self.optimizations.const_prop.remove(&location) {\n+            let value = self.tcx.mk_const(ty::Const {\n+                val: ConstVal::Value(value),\n+                ty,\n+            });\n+            debug!(\"Replacing `{:?}` with {:?}\", rvalue, value);\n+            let constant = Constant {\n+                ty,\n+                literal: Literal::Value { value },\n+                span,\n+            };\n+            *rvalue = Rvalue::Use(Operand::Constant(box constant));\n+        }\n+\n+        self.super_rvalue(rvalue, location)\n+    }\n+\n+    fn visit_constant(\n+        &mut self,\n+        constant: &mut Constant<'tcx>,\n+        location: Location,\n+    ) {\n+        self.super_constant(constant, location);\n+        if let Some(&(val, ty, _)) = self.optimizations.constants.get(constant) {\n+            debug!(\"Replacing `{:?}` with {:?}:{:?}\", constant.literal, val, ty);\n+            constant.literal = Literal::Value {\n+                value: self.tcx.mk_const(ty::Const {\n+                    val: ConstVal::Value(val),\n+                    ty,\n+                }),\n+            };\n+        }\n+    }\n+\n+    fn visit_operand(\n+        &mut self,\n+        operand: &mut Operand<'tcx>,\n+        location: Location,\n+    ) {\n+        self.super_operand(operand, location);\n+        let new = match operand {\n+            Operand::Move(Place::Local(local)) |\n+            Operand::Copy(Place::Local(local)) => {\n+                trace!(\"trying to read {:?}\", local);\n+                self.optimizations.places.get(&local).cloned()\n+            },\n+            _ => return,\n+        };\n+        if let Some((value, ty, span)) = new {\n+            let value = self.tcx.mk_const(ty::Const {\n+                val: ConstVal::Value(value),\n+                ty,\n+            });\n+            debug!(\"Replacing `{:?}` with {:?}\", operand, value);\n+            let constant = Constant {\n+                ty,\n+                literal: Literal::Value { value },\n+                span,\n+            };\n+            *operand = Operand::Constant(box constant);\n+        }\n+    }\n+\n+    fn visit_terminator_kind(\n+        &mut self,\n+        block: BasicBlock,\n+        kind: &mut TerminatorKind<'tcx>,\n+        location: Location,\n+    ) {\n+        match kind {\n+            TerminatorKind::SwitchInt { discr: value, .. } |\n+            TerminatorKind::Yield { value, .. } |\n+            TerminatorKind::Assert { cond: value, .. } => {\n+                if let Some((new, ty, span)) = self.optimizations.terminators.remove(&block) {\n+                    let new = self.tcx.mk_const(ty::Const {\n+                        val: ConstVal::Value(new),\n+                        ty,\n+                    });\n+                    debug!(\"Replacing `{:?}` with {:?}\", value, new);\n+                    let constant = Constant {\n+                        ty,\n+                        literal: Literal::Value { value: new },\n+                        span,\n+                    };\n+                    *value = Operand::Constant(box constant);\n+                }\n+            }\n+            // FIXME: do this optimization for function calls\n+            _ => {},\n+        }\n+        self.super_terminator_kind(block, kind, location)\n+    }\n+}\n+\n+/// Finds optimization opportunities on the MIR.\n+struct OptimizationFinder<'b, 'a, 'tcx:'a+'b> {\n+    mir: &'b Mir<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    source: MirSource,\n+    optimizations: OptimizationList<'tcx>,\n+}\n+\n+impl<'b, 'a, 'tcx:'b> OptimizationFinder<'b, 'a, 'tcx> {\n+    fn new(\n+        mir: &'b Mir<'tcx>,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        source: MirSource,\n+    ) -> OptimizationFinder<'b, 'a, 'tcx> {\n+        OptimizationFinder {\n+            mir,\n+            tcx,\n+            source,\n+            optimizations: OptimizationList::default(),\n+        }\n+    }\n+\n+    fn eval_constant(&mut self, c: &Constant<'tcx>) -> Option<Const<'tcx>> {\n+        if let Some(&val) = self.optimizations.constants.get(c) {\n+            return Some(val);\n+        }\n+        match c.literal {\n+            Literal::Value { value } => match value.val {\n+                ConstVal::Value(v) => Some((v, value.ty, c.span)),\n+                ConstVal::Unevaluated(did, substs) => {\n+                    let param_env = self.tcx.param_env(self.source.def_id);\n+                    let instance = Instance::resolve(\n+                        self.tcx,\n+                        param_env,\n+                        did,\n+                        substs,\n+                    )?;\n+                    let cid = GlobalId {\n+                        instance,\n+                        promoted: None,\n+                    };\n+                    let (value, _, ty) = eval_body(self.tcx, cid, param_env)?;\n+                    let val = (value, ty, c.span);\n+                    trace!(\"evaluated {:?} to {:?}\", c, val);\n+                    self.optimizations.constants.insert(c.clone(), val);\n+                    Some(val)\n+                },\n+            },\n+            // evaluate the promoted and replace the constant with the evaluated result\n+            Literal::Promoted { index } => {\n+                let generics = self.tcx.generics_of(self.source.def_id);\n+                if generics.parent_types as usize + generics.types.len() > 0 {\n+                    // FIXME: can't handle code with generics\n+                    return None;\n+                }\n+                let substs = Substs::identity_for_item(self.tcx, self.source.def_id);\n+                let instance = Instance::new(self.source.def_id, substs);\n+                let cid = GlobalId {\n+                    instance,\n+                    promoted: Some(index),\n+                };\n+                let param_env = self.tcx.param_env(self.source.def_id);\n+                let (value, _, ty) = eval_body_with_mir(self.tcx, cid, self.mir, param_env)?;\n+                let val = (value, ty, c.span);\n+                trace!(\"evaluated {:?} to {:?}\", c, val);\n+                self.optimizations.constants.insert(c.clone(), val);\n+                Some(val)\n+            }\n+        }\n+    }\n+\n+    fn eval_operand(&mut self, op: &Operand<'tcx>) -> Option<Const<'tcx>> {\n+        match *op {\n+            Operand::Constant(ref c) => self.eval_constant(c),\n+            Operand::Move(ref place) | Operand::Copy(ref place) => match *place {\n+                Place::Local(loc) => self.optimizations.places.get(&loc).cloned(),\n+                // FIXME(oli-obk): field and index projections\n+                Place::Projection(_) => None,\n+                _ => None,\n+            },\n+        }\n+    }\n+\n+    fn simplify_operand(&mut self, op: &Operand<'tcx>) -> Option<Const<'tcx>> {\n+        match *op {\n+            Operand::Constant(ref c) => match c.literal {\n+                Literal::Value { .. } => None,\n+                _ => self.eval_operand(op),\n+            },\n+            _ => self.eval_operand(op),\n+        }\n+    }\n+\n+    fn const_prop(\n+        &mut self,\n+        rvalue: &Rvalue<'tcx>,\n+        place_ty: ty::Ty<'tcx>,\n+        span: Span,\n+    ) -> Option<Const<'tcx>> {\n+        match *rvalue {\n+            // No need to overwrite an already evaluated constant\n+            Rvalue::Use(Operand::Constant(box Constant {\n+                literal: Literal::Value {\n+                    value: &ty::Const {\n+                        val: ConstVal::Value(_),\n+                        ..\n+                    },\n+                },\n+                ..\n+            })) => None,\n+            // This branch exists for the sanity type check\n+            Rvalue::Use(Operand::Constant(ref c)) => {\n+                assert_eq!(c.ty, place_ty);\n+                self.eval_constant(c)\n+            },\n+            Rvalue::Use(ref op) => {\n+                self.eval_operand(op)\n+            },\n+            Rvalue::Repeat(..) |\n+            Rvalue::Ref(..) |\n+            Rvalue::Cast(..) |\n+            Rvalue::Aggregate(..) |\n+            Rvalue::NullaryOp(NullOp::Box, _) |\n+            Rvalue::Discriminant(..) => None,\n+            // FIXME(oli-obk): evaluate static/constant slice lengths\n+            Rvalue::Len(_) => None,\n+            Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n+                let param_env = self.tcx.param_env(self.source.def_id);\n+                type_size_of(self.tcx, param_env, ty).map(|n| (\n+                    Value::ByVal(PrimVal::Bytes(n as u128)),\n+                    self.tcx.types.usize,\n+                    span,\n+                ))\n+            }\n+            Rvalue::UnaryOp(op, ref arg) => {\n+                let def_id = if self.tcx.is_closure(self.source.def_id) {\n+                    self.tcx.closure_base_def_id(self.source.def_id)\n+                } else {\n+                    self.source.def_id\n+                };\n+                let generics = self.tcx.generics_of(def_id);\n+                if generics.parent_types as usize + generics.types.len() > 0 {\n+                    // FIXME: can't handle code with generics\n+                    return None;\n+                }\n+                let substs = Substs::identity_for_item(self.tcx, self.source.def_id);\n+                let instance = Instance::new(self.source.def_id, substs);\n+                let ecx = mk_borrowck_eval_cx(self.tcx, instance, self.mir, span).unwrap();\n+\n+                let val = self.eval_operand(arg)?;\n+                let prim = ecx.value_to_primval(ValTy { value: val.0, ty: val.1 }).ok()?;\n+                let kind = ecx.ty_to_primval_kind(val.1).ok()?;\n+                match unary_op(op, prim, kind) {\n+                    Ok(val) => Some((Value::ByVal(val), place_ty, span)),\n+                    Err(mut err) => {\n+                        ecx.report(&mut err, false, Some(span));\n+                        None\n+                    },\n+                }\n+            }\n+            Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n+            Rvalue::BinaryOp(op, ref left, ref right) => {\n+                trace!(\"rvalue binop {:?} for {:?} and {:?}\", op, left, right);\n+                let left = self.eval_operand(left)?;\n+                let right = self.eval_operand(right)?;\n+                let def_id = if self.tcx.is_closure(self.source.def_id) {\n+                    self.tcx.closure_base_def_id(self.source.def_id)\n+                } else {\n+                    self.source.def_id\n+                };\n+                let generics = self.tcx.generics_of(def_id);\n+                let has_generics = generics.parent_types as usize + generics.types.len() > 0;\n+                if has_generics {\n+                    // FIXME: can't handle code with generics\n+                    return None;\n+                }\n+                let substs = Substs::identity_for_item(self.tcx, self.source.def_id);\n+                let instance = Instance::new(self.source.def_id, substs);\n+                let ecx = mk_borrowck_eval_cx(self.tcx, instance, self.mir, span).unwrap();\n+\n+                let l = ecx.value_to_primval(ValTy { value: left.0, ty: left.1 }).ok()?;\n+                let r = ecx.value_to_primval(ValTy { value: right.0, ty: right.1 }).ok()?;\n+                trace!(\"const evaluating {:?} for {:?} and {:?}\", op, left, right);\n+                match ecx.binary_op(op, l, left.1, r, right.1) {\n+                    Ok((val, overflow)) => {\n+                        let val = if let Rvalue::CheckedBinaryOp(..) = *rvalue {\n+                            Value::ByValPair(\n+                                val,\n+                                PrimVal::from_bool(overflow),\n+                            )\n+                        } else {\n+                            if overflow {\n+                                use rustc::mir::interpret::EvalErrorKind;\n+                                let mut err = EvalErrorKind::OverflowingMath.into();\n+                                ecx.report(&mut err, false, Some(span));\n+                                return None;\n+                            }\n+                            Value::ByVal(val)\n+                        };\n+                        Some((val, place_ty, span))\n+                    },\n+                    Err(mut err) => {\n+                        ecx.report(&mut err, false, Some(span));\n+                        None\n+                    },\n+                }\n+            },\n+        }\n+    }\n+}\n+\n+fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          param_env: ty::ParamEnv<'tcx>,\n+                          ty: ty::Ty<'tcx>) -> Option<u64> {\n+    use rustc::ty::layout::LayoutOf;\n+    (tcx, param_env).layout_of(ty).ok().map(|layout| layout.size.bytes())\n+}\n+\n+struct CanConstProp {\n+    local: Local,\n+    can_const_prop: bool,\n+    // false at the beginning, once set, there are not allowed to be any more assignments\n+    found_assignment: bool,\n+}\n+\n+impl CanConstProp {\n+    /// returns true if `local` can be propagated\n+    fn check<'tcx>(local: Local, mir: &Mir<'tcx>) -> bool {\n+        let mut cpv = CanConstProp {\n+            local,\n+            can_const_prop: true,\n+            found_assignment: false,\n+        };\n+        cpv.visit_mir(mir);\n+        cpv.can_const_prop\n+    }\n+\n+    fn is_our_local(&mut self, mut place: &Place) -> bool {\n+        while let Place::Projection(ref proj) = place {\n+            place = &proj.base;\n+        }\n+        if let Place::Local(local) = *place {\n+            local == self.local\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for CanConstProp {\n+    fn visit_statement(\n+        &mut self,\n+        block: BasicBlock,\n+        statement: &Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        self.super_statement(block, statement, location);\n+        match statement.kind {\n+            StatementKind::SetDiscriminant { ref place, .. } |\n+            StatementKind::Assign(ref place, _) => {\n+                if self.is_our_local(place) {\n+                    if self.found_assignment {\n+                        self.can_const_prop = false;\n+                    } else {\n+                        self.found_assignment = true\n+                    }\n+                }\n+            },\n+            StatementKind::InlineAsm { ref outputs, .. } => {\n+                for place in outputs {\n+                    if self.is_our_local(place) {\n+                        if self.found_assignment {\n+                            self.can_const_prop = false;\n+                        } else {\n+                            self.found_assignment = true\n+                        }\n+                        return;\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n+        self.super_rvalue(rvalue, location);\n+        if let Rvalue::Ref(_, _, ref place) = *rvalue {\n+            if self.is_our_local(place) {\n+                self.can_const_prop = false;\n+            }\n+        }\n+    }\n+}\n+\n+impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n+    fn visit_constant(\n+        &mut self,\n+        constant: &Constant<'tcx>,\n+        location: Location,\n+    ) {\n+        trace!(\"visit_constant: {:?}\", constant);\n+        self.super_constant(constant, location);\n+        self.eval_constant(constant);\n+    }\n+\n+    fn visit_statement(\n+        &mut self,\n+        block: BasicBlock,\n+        statement: &Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        trace!(\"visit_statement: {:?}\", statement);\n+        if let StatementKind::Assign(ref place, ref rval) = statement.kind {\n+            let place_ty = place\n+                .ty(&self.mir.local_decls, self.tcx)\n+                .to_ty(self.tcx);\n+            let span = statement.source_info.span;\n+            if let Some(value) = self.const_prop(rval, place_ty, span) {\n+                self.optimizations.const_prop.insert(location, value);\n+                if let Place::Local(local) = *place {\n+                    if self.mir.local_kind(local) == LocalKind::Temp\n+                        && CanConstProp::check(local, self.mir) {\n+                        trace!(\"storing {:?} to {:?}\", value, local);\n+                        assert!(self.optimizations.places.insert(local, value).is_none());\n+                    }\n+                }\n+            }\n+        }\n+        self.super_statement(block, statement, location);\n+    }\n+\n+    fn visit_terminator_kind(\n+        &mut self,\n+        block: BasicBlock,\n+        kind: &TerminatorKind<'tcx>,\n+        _location: Location,\n+    ) {\n+        match kind {\n+            TerminatorKind::SwitchInt { discr: value, .. } |\n+            TerminatorKind::Yield { value, .. } |\n+            TerminatorKind::Assert { cond: value, .. } => {\n+                if let Some(value) = self.simplify_operand(value) {\n+                    self.optimizations.terminators.insert(block, value);\n+                }\n+            }\n+            // FIXME: do this optimization for function calls\n+            _ => {},\n+        }\n+    }\n+}\n+\n+#[derive(Default)]\n+struct OptimizationList<'tcx> {\n+    const_prop: FxHashMap<Location, Const<'tcx>>,\n+    /// Terminators that get their Operand(s) turned into constants.\n+    terminators: FxHashMap<BasicBlock, Const<'tcx>>,\n+    places: FxHashMap<Local, Const<'tcx>>,\n+    constants: FxHashMap<Constant<'tcx>, Const<'tcx>>,\n+}"}, {"sha": "d1c2c7a61d4951574be52b013142dcef0e8a6a0c", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 5, "deletions": 439, "changes": 444, "blob_url": "https://github.com/rust-lang/rust/blob/54615ec9894f4f101bb15d70b6dc9b0c61f1249c/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54615ec9894f4f101bb15d70b6dc9b0c61f1249c/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=54615ec9894f4f101bb15d70b6dc9b0c61f1249c", "patch": "@@ -11,19 +11,12 @@\n //! Performs various peephole optimizations.\n \n use rustc::mir::{Constant, Literal, Location, Place, Mir, Operand, ProjectionElem, Rvalue, Local};\n-use rustc::mir::{NullOp, StatementKind, Statement, BasicBlock, LocalKind};\n-use rustc::mir::TerminatorKind;\n use rustc::mir::visit::{MutVisitor, Visitor};\n-use rustc::middle::const_val::ConstVal;\n-use rustc::ty::{TyCtxt, TypeVariants, self, Instance};\n-use rustc::mir::interpret::{Value, PrimVal, GlobalId};\n-use interpret::{eval_body_with_mir, eval_body, mk_borrowck_eval_cx, unary_op, ValTy};\n+use rustc::ty::{TyCtxt, TypeVariants};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::Idx;\n use std::mem;\n use transform::{MirPass, MirSource};\n-use syntax::codemap::Span;\n-use rustc::ty::subst::Substs;\n \n pub struct InstCombine;\n \n@@ -38,25 +31,22 @@ impl MirPass for InstCombine {\n         // read-only so that we can do global analyses on the MIR in the process (e.g.\n         // `Place::ty()`).\n         let optimizations = {\n-            let mut optimization_finder = OptimizationFinder::new(mir, tcx, source);\n+            let mut optimization_finder = OptimizationFinder::new(mir, tcx);\n             optimization_finder.visit_mir(mir);\n             optimization_finder.optimizations\n         };\n \n         // Then carry out those optimizations.\n-        MutVisitor::visit_mir(&mut InstCombineVisitor { optimizations, tcx }, mir);\n+        MutVisitor::visit_mir(&mut InstCombineVisitor { optimizations }, mir);\n         trace!(\"InstCombine done for {:?}\", source.def_id);\n     }\n }\n \n-type Const<'tcx> = (Value, ty::Ty<'tcx>, Span);\n-\n-pub struct InstCombineVisitor<'a, 'tcx: 'a> {\n+pub struct InstCombineVisitor<'tcx> {\n     optimizations: OptimizationList<'tcx>,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> MutVisitor<'tcx> for InstCombineVisitor<'a, 'tcx> {\n+impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n         if self.optimizations.and_stars.remove(&location) {\n             debug!(\"Replacing `&*`: {:?}\", rvalue);\n@@ -75,431 +65,31 @@ impl<'a, 'tcx> MutVisitor<'tcx> for InstCombineVisitor<'a, 'tcx> {\n             *rvalue = Rvalue::Use(Operand::Constant(box constant));\n         }\n \n-        if let Some((value, ty, span)) = self.optimizations.const_prop.remove(&location) {\n-            let value = self.tcx.mk_const(ty::Const {\n-                val: ConstVal::Value(value),\n-                ty,\n-            });\n-            debug!(\"Replacing `{:?}` with {:?}\", rvalue, value);\n-            let constant = Constant {\n-                ty,\n-                literal: Literal::Value { value },\n-                span,\n-            };\n-            *rvalue = Rvalue::Use(Operand::Constant(box constant));\n-        }\n-\n         self.super_rvalue(rvalue, location)\n     }\n-\n-    fn visit_constant(\n-        &mut self,\n-        constant: &mut Constant<'tcx>,\n-        location: Location,\n-    ) {\n-        self.super_constant(constant, location);\n-        if let Some(&(val, ty, _)) = self.optimizations.constants.get(constant) {\n-            debug!(\"Replacing `{:?}` with {:?}:{:?}\", constant.literal, val, ty);\n-            constant.literal = Literal::Value {\n-                value: self.tcx.mk_const(ty::Const {\n-                    val: ConstVal::Value(val),\n-                    ty,\n-                }),\n-            };\n-        }\n-    }\n-\n-    fn visit_operand(\n-        &mut self,\n-        operand: &mut Operand<'tcx>,\n-        location: Location,\n-    ) {\n-        self.super_operand(operand, location);\n-        let new = match operand {\n-            Operand::Move(Place::Local(local)) |\n-            Operand::Copy(Place::Local(local)) => {\n-                trace!(\"trying to read {:?}\", local);\n-                self.optimizations.places.get(&local).cloned()\n-            },\n-            _ => return,\n-        };\n-        if let Some((value, ty, span)) = new {\n-            let value = self.tcx.mk_const(ty::Const {\n-                val: ConstVal::Value(value),\n-                ty,\n-            });\n-            debug!(\"Replacing `{:?}` with {:?}\", operand, value);\n-            let constant = Constant {\n-                ty,\n-                literal: Literal::Value { value },\n-                span,\n-            };\n-            *operand = Operand::Constant(box constant);\n-        }\n-    }\n-\n-    fn visit_terminator_kind(\n-        &mut self,\n-        block: BasicBlock,\n-        kind: &mut TerminatorKind<'tcx>,\n-        location: Location,\n-    ) {\n-        match kind {\n-            TerminatorKind::SwitchInt { discr: value, .. } |\n-            TerminatorKind::Yield { value, .. } |\n-            TerminatorKind::Assert { cond: value, .. } => {\n-                if let Some((new, ty, span)) = self.optimizations.terminators.remove(&block) {\n-                    let new = self.tcx.mk_const(ty::Const {\n-                        val: ConstVal::Value(new),\n-                        ty,\n-                    });\n-                    debug!(\"Replacing `{:?}` with {:?}\", value, new);\n-                    let constant = Constant {\n-                        ty,\n-                        literal: Literal::Value { value: new },\n-                        span,\n-                    };\n-                    *value = Operand::Constant(box constant);\n-                }\n-            }\n-            // FIXME: do this optimization for function calls\n-            _ => {},\n-        }\n-        self.super_terminator_kind(block, kind, location)\n-    }\n }\n \n /// Finds optimization opportunities on the MIR.\n struct OptimizationFinder<'b, 'a, 'tcx:'a+'b> {\n     mir: &'b Mir<'tcx>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    source: MirSource,\n     optimizations: OptimizationList<'tcx>,\n }\n \n impl<'b, 'a, 'tcx:'b> OptimizationFinder<'b, 'a, 'tcx> {\n     fn new(\n         mir: &'b Mir<'tcx>,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        source: MirSource,\n     ) -> OptimizationFinder<'b, 'a, 'tcx> {\n         OptimizationFinder {\n             mir,\n             tcx,\n-            source,\n             optimizations: OptimizationList::default(),\n         }\n     }\n-\n-    fn eval_constant(&mut self, c: &Constant<'tcx>) -> Option<Const<'tcx>> {\n-        if let Some(&val) = self.optimizations.constants.get(c) {\n-            return Some(val);\n-        }\n-        match c.literal {\n-            Literal::Value { value } => match value.val {\n-                ConstVal::Value(v) => Some((v, value.ty, c.span)),\n-                ConstVal::Unevaluated(did, substs) => {\n-                    let param_env = self.tcx.param_env(self.source.def_id);\n-                    let instance = Instance::resolve(\n-                        self.tcx,\n-                        param_env,\n-                        did,\n-                        substs,\n-                    )?;\n-                    let cid = GlobalId {\n-                        instance,\n-                        promoted: None,\n-                    };\n-                    let (value, _, ty) = eval_body(self.tcx, cid, param_env)?;\n-                    let val = (value, ty, c.span);\n-                    trace!(\"evaluated {:?} to {:?}\", c, val);\n-                    self.optimizations.constants.insert(c.clone(), val);\n-                    Some(val)\n-                },\n-            },\n-            // evaluate the promoted and replace the constant with the evaluated result\n-            Literal::Promoted { index } => {\n-                let generics = self.tcx.generics_of(self.source.def_id);\n-                if generics.parent_types as usize + generics.types.len() > 0 {\n-                    // FIXME: can't handle code with generics\n-                    return None;\n-                }\n-                let substs = Substs::identity_for_item(self.tcx, self.source.def_id);\n-                let instance = Instance::new(self.source.def_id, substs);\n-                let cid = GlobalId {\n-                    instance,\n-                    promoted: Some(index),\n-                };\n-                let param_env = self.tcx.param_env(self.source.def_id);\n-                let (value, _, ty) = eval_body_with_mir(self.tcx, cid, self.mir, param_env)?;\n-                let val = (value, ty, c.span);\n-                trace!(\"evaluated {:?} to {:?}\", c, val);\n-                self.optimizations.constants.insert(c.clone(), val);\n-                Some(val)\n-            }\n-        }\n-    }\n-\n-    fn eval_operand(&mut self, op: &Operand<'tcx>) -> Option<Const<'tcx>> {\n-        match *op {\n-            Operand::Constant(ref c) => self.eval_constant(c),\n-            Operand::Move(ref place) | Operand::Copy(ref place) => match *place {\n-                Place::Local(loc) => self.optimizations.places.get(&loc).cloned(),\n-                // FIXME(oli-obk): field and index projections\n-                Place::Projection(_) => None,\n-                _ => None,\n-            },\n-        }\n-    }\n-\n-    fn simplify_operand(&mut self, op: &Operand<'tcx>) -> Option<Const<'tcx>> {\n-        match *op {\n-            Operand::Constant(ref c) => match c.literal {\n-                Literal::Value { .. } => None,\n-                _ => self.eval_operand(op),\n-            },\n-            _ => self.eval_operand(op),\n-        }\n-    }\n-\n-    fn const_prop(\n-        &mut self,\n-        rvalue: &Rvalue<'tcx>,\n-        place_ty: ty::Ty<'tcx>,\n-        span: Span,\n-    ) -> Option<Const<'tcx>> {\n-        match *rvalue {\n-            // No need to overwrite an already evaluated constant\n-            Rvalue::Use(Operand::Constant(box Constant {\n-                literal: Literal::Value {\n-                    value: &ty::Const {\n-                        val: ConstVal::Value(_),\n-                        ..\n-                    },\n-                },\n-                ..\n-            })) => None,\n-            // This branch exists for the sanity type check\n-            Rvalue::Use(Operand::Constant(ref c)) => {\n-                assert_eq!(c.ty, place_ty);\n-                self.eval_constant(c)\n-            },\n-            Rvalue::Use(ref op) => {\n-                self.eval_operand(op)\n-            },\n-            Rvalue::Repeat(..) |\n-            Rvalue::Ref(..) |\n-            Rvalue::Cast(..) |\n-            Rvalue::Aggregate(..) |\n-            Rvalue::NullaryOp(NullOp::Box, _) |\n-            Rvalue::Discriminant(..) => None,\n-            // FIXME(oli-obk): evaluate static/constant slice lengths\n-            Rvalue::Len(_) => None,\n-            Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n-                let param_env = self.tcx.param_env(self.source.def_id);\n-                type_size_of(self.tcx, param_env, ty).map(|n| (\n-                    Value::ByVal(PrimVal::Bytes(n as u128)),\n-                    self.tcx.types.usize,\n-                    span,\n-                ))\n-            }\n-            Rvalue::UnaryOp(op, ref arg) => {\n-                let def_id = if self.tcx.is_closure(self.source.def_id) {\n-                    self.tcx.closure_base_def_id(self.source.def_id)\n-                } else {\n-                    self.source.def_id\n-                };\n-                let generics = self.tcx.generics_of(def_id);\n-                if generics.parent_types as usize + generics.types.len() > 0 {\n-                    // FIXME: can't handle code with generics\n-                    return None;\n-                }\n-                let substs = Substs::identity_for_item(self.tcx, self.source.def_id);\n-                let instance = Instance::new(self.source.def_id, substs);\n-                let ecx = mk_borrowck_eval_cx(self.tcx, instance, self.mir, span).unwrap();\n-\n-                let val = self.eval_operand(arg)?;\n-                let prim = ecx.value_to_primval(ValTy { value: val.0, ty: val.1 }).ok()?;\n-                let kind = ecx.ty_to_primval_kind(val.1).ok()?;\n-                match unary_op(op, prim, kind) {\n-                    Ok(val) => Some((Value::ByVal(val), place_ty, span)),\n-                    Err(mut err) => {\n-                        ecx.report(&mut err, false, Some(span));\n-                        None\n-                    },\n-                }\n-            }\n-            Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n-            Rvalue::BinaryOp(op, ref left, ref right) => {\n-                trace!(\"rvalue binop {:?} for {:?} and {:?}\", op, left, right);\n-                let left = self.eval_operand(left)?;\n-                let right = self.eval_operand(right)?;\n-                let def_id = if self.tcx.is_closure(self.source.def_id) {\n-                    self.tcx.closure_base_def_id(self.source.def_id)\n-                } else {\n-                    self.source.def_id\n-                };\n-                let generics = self.tcx.generics_of(def_id);\n-                let has_generics = generics.parent_types as usize + generics.types.len() > 0;\n-                if has_generics {\n-                    // FIXME: can't handle code with generics\n-                    return None;\n-                }\n-                let substs = Substs::identity_for_item(self.tcx, self.source.def_id);\n-                let instance = Instance::new(self.source.def_id, substs);\n-                let ecx = mk_borrowck_eval_cx(self.tcx, instance, self.mir, span).unwrap();\n-\n-                let l = ecx.value_to_primval(ValTy { value: left.0, ty: left.1 }).ok()?;\n-                let r = ecx.value_to_primval(ValTy { value: right.0, ty: right.1 }).ok()?;\n-                trace!(\"const evaluating {:?} for {:?} and {:?}\", op, left, right);\n-                match ecx.binary_op(op, l, left.1, r, right.1) {\n-                    Ok((val, overflow)) => {\n-                        let val = if let Rvalue::CheckedBinaryOp(..) = *rvalue {\n-                            Value::ByValPair(\n-                                val,\n-                                PrimVal::from_bool(overflow),\n-                            )\n-                        } else {\n-                            if overflow {\n-                                use rustc::mir::interpret::EvalErrorKind;\n-                                let mut err = EvalErrorKind::OverflowingMath.into();\n-                                ecx.report(&mut err, false, Some(span));\n-                                return None;\n-                            }\n-                            Value::ByVal(val)\n-                        };\n-                        Some((val, place_ty, span))\n-                    },\n-                    Err(mut err) => {\n-                        ecx.report(&mut err, false, Some(span));\n-                        None\n-                    },\n-                }\n-            },\n-        }\n-    }\n-}\n-\n-fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          param_env: ty::ParamEnv<'tcx>,\n-                          ty: ty::Ty<'tcx>) -> Option<u64> {\n-    use rustc::ty::layout::LayoutOf;\n-    (tcx, param_env).layout_of(ty).ok().map(|layout| layout.size.bytes())\n-}\n-\n-struct ConstPropVisitor {\n-    local: Local,\n-    can_const_prop: bool,\n-    // false at the beginning, once set, there are not allowed to be any more assignments\n-    found_assignment: bool,\n-}\n-\n-impl ConstPropVisitor {\n-    /// returns true if `local` can be propagated\n-    fn check<'tcx>(local: Local, mir: &Mir<'tcx>) -> bool {\n-        let mut cpv = ConstPropVisitor {\n-            local,\n-            can_const_prop: true,\n-            found_assignment: false,\n-        };\n-        cpv.visit_mir(mir);\n-        cpv.can_const_prop\n-    }\n-\n-    fn is_our_local(&mut self, mut place: &Place) -> bool {\n-        while let Place::Projection(ref proj) = place {\n-            place = &proj.base;\n-        }\n-        if let Place::Local(local) = *place {\n-            local == self.local\n-        } else {\n-            false\n-        }\n-    }\n-}\n-\n-impl<'tcx> Visitor<'tcx> for ConstPropVisitor {\n-    fn visit_statement(\n-        &mut self,\n-        block: BasicBlock,\n-        statement: &Statement<'tcx>,\n-        location: Location,\n-    ) {\n-        self.super_statement(block, statement, location);\n-        match statement.kind {\n-            StatementKind::SetDiscriminant { ref place, .. } |\n-            StatementKind::Assign(ref place, _) => {\n-                if self.is_our_local(place) {\n-                    if self.found_assignment {\n-                        self.can_const_prop = false;\n-                    } else {\n-                        self.found_assignment = true\n-                    }\n-                }\n-            },\n-            StatementKind::InlineAsm { ref outputs, .. } => {\n-                for place in outputs {\n-                    if self.is_our_local(place) {\n-                        if self.found_assignment {\n-                            self.can_const_prop = false;\n-                        } else {\n-                            self.found_assignment = true\n-                        }\n-                        return;\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n-        self.super_rvalue(rvalue, location);\n-        if let Rvalue::Ref(_, _, ref place) = *rvalue {\n-            if self.is_our_local(place) {\n-                self.can_const_prop = false;\n-            }\n-        }\n-    }\n }\n \n impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n-    fn visit_constant(\n-        &mut self,\n-        constant: &Constant<'tcx>,\n-        location: Location,\n-    ) {\n-        trace!(\"visit_constant: {:?}\", constant);\n-        self.super_constant(constant, location);\n-        self.eval_constant(constant);\n-    }\n-\n-    fn visit_statement(\n-        &mut self,\n-        block: BasicBlock,\n-        statement: &Statement<'tcx>,\n-        location: Location,\n-    ) {\n-        trace!(\"visit_statement: {:?}\", statement);\n-        if let StatementKind::Assign(ref place, ref rval) = statement.kind {\n-            let place_ty = place\n-                .ty(&self.mir.local_decls, self.tcx)\n-                .to_ty(self.tcx);\n-            let span = statement.source_info.span;\n-            if let Some(value) = self.const_prop(rval, place_ty, span) {\n-                self.optimizations.const_prop.insert(location, value);\n-                if let Place::Local(local) = *place {\n-                    if self.mir.local_kind(local) == LocalKind::Temp\n-                        && ConstPropVisitor::check(local, self.mir) {\n-                        trace!(\"storing {:?} to {:?}\", value, local);\n-                        assert!(self.optimizations.places.insert(local, value).is_none());\n-                    }\n-                }\n-                return;\n-            }\n-        }\n-        self.super_statement(block, statement, location);\n-    }\n-\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         if let Rvalue::Ref(_, _, Place::Projection(ref projection)) = *rvalue {\n             if let ProjectionElem::Deref = projection.elem {\n@@ -522,34 +112,10 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n \n         self.super_rvalue(rvalue, location)\n     }\n-\n-    fn visit_terminator_kind(\n-        &mut self,\n-        block: BasicBlock,\n-        kind: &TerminatorKind<'tcx>,\n-        _location: Location,\n-    ) {\n-        match kind {\n-            TerminatorKind::SwitchInt { discr: value, .. } |\n-            TerminatorKind::Yield { value, .. } |\n-            TerminatorKind::Assert { cond: value, .. } => {\n-                if let Some(value) = self.simplify_operand(value) {\n-                    self.optimizations.terminators.insert(block, value);\n-                }\n-            }\n-            // FIXME: do this optimization for function calls\n-            _ => {},\n-        }\n-    }\n }\n \n #[derive(Default)]\n struct OptimizationList<'tcx> {\n     and_stars: FxHashSet<Location>,\n     arrays_lengths: FxHashMap<Location, Constant<'tcx>>,\n-    const_prop: FxHashMap<Location, Const<'tcx>>,\n-    /// Terminators that get their Operand(s) turned into constants.\n-    terminators: FxHashMap<BasicBlock, Const<'tcx>>,\n-    places: FxHashMap<Local, Const<'tcx>>,\n-    constants: FxHashMap<Constant<'tcx>, Const<'tcx>>,\n }"}, {"sha": "81b740c917b5e492e4045b7ca2fccf830879d50d", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54615ec9894f4f101bb15d70b6dc9b0c61f1249c/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54615ec9894f4f101bb15d70b6dc9b0c61f1249c/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=54615ec9894f4f101bb15d70b6dc9b0c61f1249c", "patch": "@@ -41,6 +41,7 @@ pub mod dump_mir;\n pub mod deaggregator;\n pub mod instcombine;\n pub mod copy_prop;\n+pub mod const_prop;\n pub mod generator;\n pub mod inline;\n pub mod lower_128bit;\n@@ -265,6 +266,7 @@ fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n         generator::StateTransform,\n \n         instcombine::InstCombine,\n+        const_prop::ConstProp,\n         simplify_branches::SimplifyBranches::new(\"after-const-prop\"),\n         deaggregator::Deaggregator,\n         copy_prop::CopyPropagation,"}]}