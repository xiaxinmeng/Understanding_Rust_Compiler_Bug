{"sha": "a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MjUwYTk2ZmRmNjExNDJhOWM4ZGJiNmQzN2FlODQzNWM5OWUzOTY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-02-05T22:30:53Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-02-05T22:30:53Z"}, "message": "Revert \"oldmap: use &K instead of K in find and get\"\n\nThis reverts commit 8e643525d4e5bca993dada43615916c382a0645b.", "tree": {"sha": "0d31d5d32334825c1b174c1febf2160689626801", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d31d5d32334825c1b174c1febf2160689626801"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "html_url": "https://github.com/rust-lang/rust/commit/a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0110dfb27cc72b7cb269630061e87e858eda0610", "url": "https://api.github.com/repos/rust-lang/rust/commits/0110dfb27cc72b7cb269630061e87e858eda0610", "html_url": "https://github.com/rust-lang/rust/commit/0110dfb27cc72b7cb269630061e87e858eda0610"}], "stats": {"total": 961, "additions": 479, "deletions": 482}, "files": [{"sha": "960bcf88eb7ef7fc3b2ff972f01ffbfa841a1472", "filename": "src/libcargo/cargo.rc", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rc?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -731,7 +731,7 @@ pub fn configure(opts: Options) -> Cargo {\n     need_dir(&c.bindir);\n \n     for sources.each_key_ref |&k| {\n-        let mut s = sources.get(&k);\n+        let mut s = sources.get(k);\n         load_source_packages(&c, s);\n         sources.insert(k, s);\n     }\n@@ -981,7 +981,7 @@ pub fn install_named(c: &mut Cargo, wd: &Path, name: ~str) {\n \n pub fn install_uuid_specific(c: &mut Cargo, wd: &Path, src: ~str,\n                              uuid: ~str) {\n-    match c.sources.find(&src) {\n+    match c.sources.find(src) {\n         Some(s) => {\n             for s.packages.each |p| {\n                 if p.uuid == uuid {\n@@ -997,7 +997,7 @@ pub fn install_uuid_specific(c: &mut Cargo, wd: &Path, src: ~str,\n \n pub fn install_named_specific(c: &mut Cargo, wd: &Path, src: ~str,\n                               name: ~str) {\n-    match c.sources.find(&src) {\n+    match c.sources.find(src) {\n         Some(s) => {\n             for s.packages.each |p| {\n                 if p.name == name {\n@@ -1064,7 +1064,7 @@ pub fn cmd_uninstall(c: &Cargo) {\n }\n \n pub fn install_query(c: &mut Cargo, wd: &Path, target: ~str) {\n-    match c.dep_cache.find(&target) {\n+    match c.dep_cache.find(target) {\n         Some(inst) => {\n             if inst {\n                 return;\n@@ -1156,7 +1156,7 @@ pub fn cmd_install(c: &mut Cargo) {\n \n pub fn sync(c: &Cargo) {\n     for c.sources.each_key_ref |&k| {\n-        let mut s = c.sources.get(&k);\n+        let mut s = c.sources.get(k);\n         sync_one(c, s);\n         c.sources.insert(k, s);\n     }\n@@ -1558,7 +1558,7 @@ pub fn cmd_list(c: &Cargo) {\n             if !valid_pkg_name(*name) {\n                 error(fmt!(\"'%s' is an invalid source name\", *name));\n             } else {\n-                match c.sources.find(name) {\n+                match c.sources.find(*name) {\n                     Some(source) => {\n                         print_source(source);\n                     }\n@@ -1754,7 +1754,7 @@ pub fn cmd_sources(c: &Cargo) {\n                 return;\n             }\n \n-            match c.sources.find(&name) {\n+            match c.sources.find(name) {\n                 Some(source) => {\n                     let old = copy source.url;\n                     let method = assume_source_method(url);\n@@ -1785,7 +1785,7 @@ pub fn cmd_sources(c: &Cargo) {\n                 return;\n             }\n \n-            match c.sources.find(&name) {\n+            match c.sources.find(name) {\n                 Some(source) => {\n                     let old = copy source.method;\n \n@@ -1823,7 +1823,7 @@ pub fn cmd_sources(c: &Cargo) {\n                 return;\n             }\n \n-            match c.sources.find(&name) {\n+            match c.sources.find(name) {\n                 Some(source) => {\n                     c.sources.remove(&name);\n                     c.sources.insert(newn, source);"}, {"sha": "22923cb7290423c715596abccb0946a1834b7ea0", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -596,7 +596,7 @@ pub fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &hash::State, t: ty::t,\n }\n \n pub fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> @str {\n-    match ccx.type_hashcodes.find(&t) {\n+    match ccx.type_hashcodes.find(t) {\n       Some(h) => h,\n       None => {\n         let hash = symbol_hash(ccx.tcx, ccx.symbol_hasher, t, ccx.link_meta);"}, {"sha": "1464fa29afc1298e646ad024ca26ca461ff7c94c", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -538,7 +538,7 @@ pub fn build_session_options(+binary: ~str,\n                                 getopts::opt_strs(matches, level_name));\n         for flags.each |lint_name| {\n             let lint_name = str::replace(*lint_name, ~\"-\", ~\"_\");\n-            match lint_dict.find(&lint_name) {\n+            match lint_dict.find(/*bad*/ copy lint_name) {\n               None => {\n                 early_error(demitter, fmt!(\"unknown %s flag: %s\",\n                                            level_name, lint_name));"}, {"sha": "e114a18f4fd382b42675b5ea66ec335d76ad3dc1", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -1331,11 +1331,11 @@ pub fn associate_type(tn: type_names, s: @str, t: TypeRef) {\n }\n \n pub fn type_has_name(tn: type_names, t: TypeRef) -> Option<@str> {\n-    return tn.type_names.find(&t);\n+    return tn.type_names.find(t);\n }\n \n pub fn name_has_type(tn: type_names, s: @str) -> Option<TypeRef> {\n-    return tn.named_types.find(&s);\n+    return tn.named_types.find(s);\n }\n \n pub fn mk_type_names() -> type_names {"}, {"sha": "c8a1a619436b374178cf0b2ffcfcccbade0fac34", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -74,7 +74,7 @@ pub fn mk_cstore(intr: @ident_interner) -> CStore {\n \n pub fn get_crate_data(cstore: CStore, cnum: ast::crate_num)\n                    -> crate_metadata {\n-    return p(cstore).metas.get(&cnum);\n+    return p(cstore).metas.get(cnum);\n }\n \n pub fn get_crate_hash(cstore: CStore, cnum: ast::crate_num) -> ~str {\n@@ -139,7 +139,7 @@ pub fn add_use_stmt_cnum(cstore: CStore, use_id: ast::node_id,\n \n pub fn find_use_stmt_cnum(cstore: CStore,\n                           use_id: ast::node_id) -> Option<ast::crate_num> {\n-    p(cstore).use_crate_map.find(&use_id)\n+    p(cstore).use_crate_map.find(use_id)\n }\n \n // returns hashes of crates directly used by this crate. Hashes are"}, {"sha": "c3c7c969cd87a05af5abba7b622fc26aa56e195b", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -1099,7 +1099,7 @@ pub fn translate_def_id(cdata: cmd, did: ast::def_id) -> ast::def_id {\n         return ast::def_id { crate: cdata.cnum, node: did.node };\n     }\n \n-    match cdata.cnum_map.find(&did.crate) {\n+    match cdata.cnum_map.find(did.crate) {\n       option::Some(n) => ast::def_id { crate: n, node: did.node },\n       option::None => die!(~\"didn't find a crate in the cnum_map\")\n     }"}, {"sha": "438084a3bd7a5d60d3de0288199909ef46f66f59", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -118,7 +118,7 @@ pub fn encode_def_id(ebml_w: writer::Encoder, id: def_id) {\n \n fn encode_region_param(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                        it: @ast::item) {\n-    let opt_rp = ecx.tcx.region_paramd_items.find(&it.id);\n+    let opt_rp = ecx.tcx.region_paramd_items.find(it.id);\n     for opt_rp.each |rp| {\n         do ebml_w.wr_tag(tag_region_param) {\n             (*rp).encode(&ebml_w);\n@@ -184,7 +184,7 @@ fn encode_ty_type_param_bounds(ebml_w: writer::Encoder, ecx: @encode_ctxt,\n fn encode_type_param_bounds(ebml_w: writer::Encoder, ecx: @encode_ctxt,\n                             params: &[ty_param]) {\n     let ty_param_bounds =\n-        @params.map(|param| ecx.tcx.ty_param_bounds.get(&param.id));\n+        @params.map(|param| ecx.tcx.ty_param_bounds.get(param.id));\n     encode_ty_type_param_bounds(ebml_w, ecx, ty_param_bounds);\n }\n \n@@ -224,7 +224,7 @@ fn encode_type(ecx: @encode_ctxt, ebml_w: writer::Encoder, typ: ty::t) {\n \n fn encode_symbol(ecx: @encode_ctxt, ebml_w: writer::Encoder, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n-    let sym = match ecx.item_symbols.find(&id) {\n+    let sym = match ecx.item_symbols.find(id) {\n       Some(ref x) => (/*bad*/copy *x),\n       None => {\n         ecx.diag.handler().bug(\n@@ -238,7 +238,7 @@ fn encode_symbol(ecx: @encode_ctxt, ebml_w: writer::Encoder, id: node_id) {\n fn encode_discriminant(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                        id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n-    ebml_w.writer.write(str::to_bytes(ecx.discrim_symbols.get(&id)));\n+    ebml_w.writer.write(str::to_bytes(ecx.discrim_symbols.get(id)));\n     ebml_w.end_tag();\n }\n \n@@ -349,7 +349,7 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n \n     // Encode the reexports of this module.\n     debug!(\"(encoding info for module) encoding reexports for %d\", id);\n-    match ecx.reexports2.find(&id) {\n+    match ecx.reexports2.find(id) {\n         Some(ref exports) => {\n             debug!(\"(encoding info for module) found reexports for %d\", id);\n             for (*exports).each |exp| {\n@@ -813,7 +813,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n             encode_name(ecx, ebml_w, ty_m.ident);\n             encode_family(ebml_w,\n                           purity_static_method_family(ty_m.purity));\n-            let polyty = ecx.tcx.tcache.get(&local_def(ty_m.id));\n+            let polyty = ecx.tcx.tcache.get(local_def(ty_m.id));\n             encode_ty_type_param_bounds(ebml_w, ecx, polyty.bounds);\n             encode_type(ecx, ebml_w, polyty.ty);\n             let mut m_path = vec::append(~[], path); // :-(\n@@ -881,7 +881,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n             let ebml_w = copy ebml_w;\n             |i, cx, v| {\n                 visit::visit_item(i, cx, v);\n-                match ecx.tcx.items.get(&i.id) {\n+                match ecx.tcx.items.get(i.id) {\n                     ast_map::node_item(_, pt) => {\n                         encode_info_for_item(ecx, ebml_w, i,\n                                              index, *pt);\n@@ -894,7 +894,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n             let ebml_w = copy ebml_w;\n             |ni, cx, v| {\n                 visit::visit_foreign_item(ni, cx, v);\n-                match ecx.tcx.items.get(&ni.id) {\n+                match ecx.tcx.items.get(ni.id) {\n                     ast_map::node_foreign_item(_, abi, pt) => {\n                         encode_info_for_foreign_item(ecx, ebml_w, ni,\n                                                      index, /*bad*/copy *pt,"}, {"sha": "5dd499dfd63d7a125c434ccb2794e2d50192c081", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -329,7 +329,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         let len = parse_hex(st);\n         assert (next(st) == '#');\n         let key = creader_cache_key { cnum: st.crate, pos: pos, len: len };\n-        match st.tcx.rcache.find(&key) {\n+        match st.tcx.rcache.find(key) {\n           Some(tt) => return tt,\n           None => {\n             let ps = @{pos: pos ,.. copy *st};"}, {"sha": "a0e2065b20b8c36434243bdea3ba246d3186dac3", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -56,7 +56,7 @@ fn cx_uses_abbrevs(cx: @ctxt) -> bool {\n pub fn enc_ty(w: io::Writer, cx: @ctxt, t: ty::t) {\n     match cx.abbrevs {\n       ac_no_abbrevs => {\n-        let result_str = match cx.tcx.short_names_cache.find(&t) {\n+        let result_str = match cx.tcx.short_names_cache.find(t) {\n             Some(s) => /*bad*/copy *s,\n             None => {\n                 let s = do io::with_str_writer |wr| {\n@@ -69,7 +69,7 @@ pub fn enc_ty(w: io::Writer, cx: @ctxt, t: ty::t) {\n         w.write_str(result_str);\n       }\n       ac_use_abbrevs(abbrevs) => {\n-        match abbrevs.find(&t) {\n+        match abbrevs.find(t) {\n           Some(a) => { w.write_str(*a.s); return; }\n           None => {\n             let pos = w.tell();"}, {"sha": "2fc592e131e61a282a057fcb16904547087cc27e", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -838,7 +838,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n \n     debug!(\"Encoding side tables for id %d\", id);\n \n-    do option::iter(&tcx.def_map.find(&id)) |def| {\n+    do option::iter(&tcx.def_map.find(id)) |def| {\n         do ebml_w.tag(c::tag_table_def) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -855,7 +855,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    do option::iter(&tcx.node_type_substs.find(&id)) |tys| {\n+    do option::iter(&tcx.node_type_substs.find(id)) |tys| {\n         do ebml_w.tag(c::tag_table_node_type_subst) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -864,7 +864,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    do option::iter(&tcx.freevars.find(&id)) |fv| {\n+    do option::iter(&tcx.freevars.find(id)) |fv| {\n         do ebml_w.tag(c::tag_table_freevars) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -876,7 +876,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n     }\n \n     let lid = ast::def_id { crate: ast::local_crate, node: id };\n-    do option::iter(&tcx.tcache.find(&lid)) |tpbt| {\n+    do option::iter(&tcx.tcache.find(lid)) |tpbt| {\n         do ebml_w.tag(c::tag_table_tcache) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -885,7 +885,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    do option::iter(&tcx.ty_param_bounds.find(&id)) |pbs| {\n+    do option::iter(&tcx.ty_param_bounds.find(id)) |pbs| {\n         do ebml_w.tag(c::tag_table_param_bounds) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -899,7 +899,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n     // is what we actually use in trans, all modes will have been\n     // resolved.\n     //\n-    //option::iter(tcx.inferred_modes.find(&id)) {|m|\n+    //option::iter(tcx.inferred_modes.find(id)) {|m|\n     //    ebml_w.tag(c::tag_table_inferred_modes) {||\n     //        ebml_w.id(id);\n     //        ebml_w.tag(c::tag_table_val) {||\n@@ -908,13 +908,13 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n     //    }\n     //}\n \n-    do option::iter(&maps.mutbl_map.find(&id)) |_m| {\n+    do option::iter(&maps.mutbl_map.find(id)) |_m| {\n         do ebml_w.tag(c::tag_table_mutbl) {\n             ebml_w.id(id);\n         }\n     }\n \n-    do option::iter(&maps.last_use_map.find(&id)) |m| {\n+    do option::iter(&maps.last_use_map.find(id)) |m| {\n         do ebml_w.tag(c::tag_table_last_use) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -925,7 +925,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    do option::iter(&maps.method_map.find(&id)) |mme| {\n+    do option::iter(&maps.method_map.find(id)) |mme| {\n         do ebml_w.tag(c::tag_table_method_map) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -934,7 +934,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    do option::iter(&maps.vtable_map.find(&id)) |dr| {\n+    do option::iter(&maps.vtable_map.find(id)) |dr| {\n         do ebml_w.tag(c::tag_table_vtable_map) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -943,7 +943,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    do option::iter(&tcx.adjustments.find(&id)) |adj| {\n+    do option::iter(&tcx.adjustments.find(id)) |adj| {\n         do ebml_w.tag(c::tag_table_adjustments) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -952,19 +952,19 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    do option::iter(&tcx.legacy_boxed_traits.find(&id)) |_x| {\n+    do option::iter(&tcx.legacy_boxed_traits.find(id)) |_x| {\n         do ebml_w.tag(c::tag_table_legacy_boxed_trait) {\n             ebml_w.id(id);\n         }\n     }\n \n-    for maps.moves_map.find(&id).each |_| {\n+    for maps.moves_map.find(id).each |_| {\n         do ebml_w.tag(c::tag_table_moves_map) {\n             ebml_w.id(id);\n         }\n     }\n \n-    for maps.capture_map.find(&id).each |cap_vars| {\n+    for maps.capture_map.find(id).each |cap_vars| {\n         do ebml_w.tag(c::tag_table_capture_map) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {"}, {"sha": "19740b6a929b28091ee465a6cc133e3c1604cb6b", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -126,12 +126,12 @@ impl check_loan_ctxt {\n         let region_map = self.tcx().region_map;\n         let pure_map = self.req_maps.pure_map;\n         loop {\n-            match pure_map.find(&scope_id) {\n+            match pure_map.find(scope_id) {\n               None => (),\n               Some(ref e) => return Some(pc_cmt((*e)))\n             }\n \n-            match region_map.find(&scope_id) {\n+            match region_map.find(scope_id) {\n               None => return default_purity,\n               Some(next_scope_id) => scope_id = next_scope_id\n             }\n@@ -144,13 +144,13 @@ impl check_loan_ctxt {\n         let req_loan_map = self.req_maps.req_loan_map;\n \n         loop {\n-            for req_loan_map.find(&scope_id).each |loans| {\n+            for req_loan_map.find(scope_id).each |loans| {\n                 for loans.each |loan| {\n                     if !f(loan) { return; }\n                 }\n             }\n \n-            match region_map.find(&scope_id) {\n+            match region_map.find(scope_id) {\n               None => return,\n               Some(next_scope_id) => scope_id = next_scope_id,\n             }\n@@ -199,7 +199,7 @@ impl check_loan_ctxt {\n           Some(expr) => {\n             match expr.node {\n               ast::expr_path(_) if pc == pc_pure_fn => {\n-                let def = self.tcx().def_map.get(&expr.id);\n+                let def = self.tcx().def_map.get(expr.id);\n                 let did = ast_util::def_id_of_def(def);\n                 let is_fn_arg =\n                     did.crate == ast::local_crate &&\n@@ -247,7 +247,7 @@ impl check_loan_ctxt {\n     fn is_allowed_pure_arg(expr: @ast::expr) -> bool {\n         return match expr.node {\n           ast::expr_path(_) => {\n-            let def = self.tcx().def_map.get(&expr.id);\n+            let def = self.tcx().def_map.get(expr.id);\n             let did = ast_util::def_id_of_def(def);\n             did.crate == ast::local_crate &&\n                 (*self.fn_args).contains(&(did.node))\n@@ -262,14 +262,14 @@ impl check_loan_ctxt {\n     fn check_for_conflicting_loans(scope_id: ast::node_id) {\n         debug!(\"check_for_conflicting_loans(scope_id=%?)\", scope_id);\n \n-        let new_loans = match self.req_maps.req_loan_map.find(&scope_id) {\n+        let new_loans = match self.req_maps.req_loan_map.find(scope_id) {\n             None => return,\n             Some(loans) => loans\n         };\n \n         debug!(\"new_loans has length %?\", new_loans.len());\n \n-        let par_scope_id = self.tcx().region_map.get(&scope_id);\n+        let par_scope_id = self.tcx().region_map.get(scope_id);\n         for self.walk_loans(par_scope_id) |old_loan| {\n             debug!(\"old_loan=%?\", self.bccx.loan_to_repr(old_loan));\n \n@@ -325,7 +325,7 @@ impl check_loan_ctxt {\n     fn check_assignment(at: assignment_type, ex: @ast::expr) {\n         // We don't use cat_expr() here because we don't want to treat\n         // auto-ref'd parameters in overloaded operators as rvalues.\n-        let cmt = match self.bccx.tcx.adjustments.find(&ex.id) {\n+        let cmt = match self.bccx.tcx.adjustments.find(ex.id) {\n             None => self.bccx.cat_expr_unadjusted(ex),\n             Some(adj) => self.bccx.cat_expr_autoderefd(ex, adj)\n         };\n@@ -612,7 +612,7 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n     {\n         match fty_proto {\n             ast::ProtoBox | ast::ProtoUniq => {\n-                let cap_vars = self.bccx.capture_map.get(&id);\n+                let cap_vars = self.bccx.capture_map.get(id);\n                 for cap_vars.each |cap_var| {\n                     match cap_var.mode {\n                         moves::CapRef | moves::CapCopy => { loop; }"}, {"sha": "b7b9942492411618dac7b89656ce280c74c90b49", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -126,7 +126,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n \n     // If this expression is borrowed, have to ensure it remains valid:\n     if !self.ignore_adjustments.contains(&ex.id) {\n-        for tcx.adjustments.find(&ex.id).each |adjustments| {\n+        for tcx.adjustments.find(ex.id).each |adjustments| {\n             self.guarantee_adjustments(ex, *adjustments);\n         }\n     }\n@@ -172,7 +172,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n             }\n         }\n \n-        match self.bccx.method_map.find(&ex.id) {\n+        match self.bccx.method_map.find(ex.id) {\n             Some(ref method_map_entry) => {\n                 match (*method_map_entry).explicit_self {\n                     ast::sty_by_ref => {\n@@ -250,7 +250,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n         // (if used like `a.b(...)`), the call where it's an argument\n         // (if used like `x(a.b)`), or the block (if used like `let x\n         // = a.b`).\n-        let scope_r = ty::re_scope(self.tcx().region_map.get(&ex.id));\n+        let scope_r = ty::re_scope(self.tcx().region_map.get(ex.id));\n         let rcvr_cmt = self.bccx.cat_expr(rcvr);\n         self.guarantee_valid(rcvr_cmt, m_imm, scope_r);\n         visit::visit_expr(ex, self, vt);\n@@ -536,7 +536,7 @@ impl gather_loan_ctxt {\n \n     fn add_loans_to_scope_id(&self, scope_id: ast::node_id, +loans: ~[Loan]) {\n         debug!(\"adding %u loans to scope_id %?\", loans.len(), scope_id);\n-        match self.req_maps.req_loan_map.find(&scope_id) {\n+        match self.req_maps.req_loan_map.find(scope_id) {\n             Some(req_loans) => {\n                 req_loans.push_all(loans);\n             }"}, {"sha": "0b06fbd2a3a4d4eba75c263d29d16bcbbd2e6378", "filename": "src/librustc/middle/borrowck/loan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -129,7 +129,7 @@ impl LoanContext {\n                 ~\"rvalue with a non-none lp\");\n           }\n           cat_local(local_id) | cat_arg(local_id) | cat_self(local_id) => {\n-            let local_scope_id = self.tcx().region_map.get(&local_id);\n+            let local_scope_id = self.tcx().region_map.get(local_id);\n             self.issue_loan(cmt, ty::re_scope(local_scope_id), req_mutbl,\n                             owns_lent_data)\n           }"}, {"sha": "3bc34d2ef292cb9cd381cd55ff998817be3ed684", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -109,7 +109,7 @@ impl PreserveCtxt {\n                 // Maybe if we pass in the parent instead here,\n                 // we can prevent the \"scope not found\" error\n                 debug!(\"scope_region thing: %? \", cmt.id);\n-                ty::re_scope(self.tcx().region_map.get(&cmt.id))\n+                ty::re_scope(self.tcx().region_map.get(cmt.id))\n             };\n \n             self.compare_scope(cmt, scope_region)\n@@ -129,26 +129,26 @@ impl PreserveCtxt {\n                     cmt.span,\n                     ~\"preserve() called with local and !root_managed_data\");\n             }\n-            let local_scope_id = self.tcx().region_map.get(&local_id);\n+            let local_scope_id = self.tcx().region_map.get(local_id);\n             self.compare_scope(cmt, ty::re_scope(local_scope_id))\n           }\n           cat_binding(local_id) => {\n             // Bindings are these kind of weird implicit pointers (cc\n             // #2329).  We require (in gather_loans) that they be\n             // rooted in an immutable location.\n-            let local_scope_id = self.tcx().region_map.get(&local_id);\n+            let local_scope_id = self.tcx().region_map.get(local_id);\n             self.compare_scope(cmt, ty::re_scope(local_scope_id))\n           }\n           cat_arg(local_id) => {\n             // This can happen as not all args are lendable (e.g., &&\n             // modes).  In that case, the caller guarantees stability\n             // for at least the scope of the fn.  This is basically a\n             // deref of a region ptr.\n-            let local_scope_id = self.tcx().region_map.get(&local_id);\n+            let local_scope_id = self.tcx().region_map.get(local_id);\n             self.compare_scope(cmt, ty::re_scope(local_scope_id))\n           }\n           cat_self(local_id) => {\n-            let local_scope_id = self.tcx().region_map.get(&local_id);\n+            let local_scope_id = self.tcx().region_map.get(local_id);\n             self.compare_scope(cmt, ty::re_scope(local_scope_id))\n           }\n           cat_comp(cmt_base, comp_field(*)) |"}, {"sha": "98c3fdaa8c35d84065164da1f45010442e20712c", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -126,7 +126,7 @@ pub fn check_expr(sess: Session,\n                     e.span, ~\"paths in constants may only refer to \\\n                               items without type parameters\");\n             }\n-            match def_map.find(&e.id) {\n+            match def_map.find(e.id) {\n               Some(def_const(def_id)) |\n                 Some(def_fn(def_id, _)) |\n                 Some(def_variant(_, def_id)) |\n@@ -151,7 +151,7 @@ pub fn check_expr(sess: Session,\n             }\n           }\n           expr_call(callee, _, false) => {\n-            match def_map.find(&callee.id) {\n+            match def_map.find(callee.id) {\n                 Some(def_struct(*)) => {}    // OK.\n                 Some(def_variant(*)) => {}    // OK.\n                 _ => {\n@@ -247,9 +247,9 @@ pub fn check_item_recursion(sess: Session,\n     fn visit_expr(e: @expr, &&env: env, v: visit::vt<env>) {\n         match e.node {\n           expr_path(*) => {\n-            match env.def_map.find(&e.id) {\n+            match env.def_map.find(e.id) {\n               Some(def_const(def_id)) => {\n-                match env.ast_map.get(&def_id.node) {\n+                match env.ast_map.get(def_id.node) {\n                   ast_map::node_item(it, _) => {\n                     (v.visit_item)(it, env, v);\n                   }"}, {"sha": "e25ceee5d30164a005ebed785c71e0e309d18901", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -292,7 +292,7 @@ pub fn pat_ctor_id(cx: @MatchCheckCtxt, p: @pat) -> Option<ctor> {\n     match /*bad*/copy pat.node {\n       pat_wild => { None }\n       pat_ident(_, _, _) | pat_enum(_, _) => {\n-        match cx.tcx.def_map.find(&pat.id) {\n+        match cx.tcx.def_map.find(pat.id) {\n           Some(def_variant(_, id)) => Some(variant(id)),\n           Some(def_const(did)) => {\n             let const_expr = lookup_const_by_id(cx.tcx, did).get();\n@@ -306,7 +306,7 @@ pub fn pat_ctor_id(cx: @MatchCheckCtxt, p: @pat) -> Option<ctor> {\n         Some(range(eval_const_expr(cx.tcx, lo), eval_const_expr(cx.tcx, hi)))\n       }\n       pat_struct(*) => {\n-        match cx.tcx.def_map.find(&pat.id) {\n+        match cx.tcx.def_map.find(pat.id) {\n           Some(def_variant(_, id)) => Some(variant(id)),\n           _ => Some(single)\n         }\n@@ -329,7 +329,7 @@ pub fn is_wild(cx: @MatchCheckCtxt, p: @pat) -> bool {\n     match pat.node {\n       pat_wild => { true }\n       pat_ident(_, _, _) => {\n-        match cx.tcx.def_map.find(&pat.id) {\n+        match cx.tcx.def_map.find(pat.id) {\n           Some(def_variant(_, _)) | Some(def_const(*)) => { false }\n           _ => { true }\n         }\n@@ -480,7 +480,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n             pat_wild => Some(vec::append(vec::from_elem(arity, wild()),\n                                          vec::tail(r))),\n             pat_ident(_, _, _) => {\n-                match cx.tcx.def_map.find(&pat_id) {\n+                match cx.tcx.def_map.find(pat_id) {\n                     Some(def_variant(_, id)) => {\n                         if variant(id) == ctor_id { Some(vec::tail(r)) }\n                         else { None }\n@@ -505,7 +505,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                 }\n             }\n             pat_enum(_, args) => {\n-                match cx.tcx.def_map.get(&pat_id) {\n+                match cx.tcx.def_map.get(pat_id) {\n                     def_variant(_, id) if variant(id) == ctor_id => {\n                         let args = match args {\n                             Some(args) => args,\n@@ -541,7 +541,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n             }\n             pat_struct(_, ref flds, _) => {\n                 // Is this a struct or an enum variant?\n-                match cx.tcx.def_map.get(&pat_id) {\n+                match cx.tcx.def_map.get(pat_id) {\n                     def_variant(_, variant_id) => {\n                         if variant(variant_id) == ctor_id {\n                             // FIXME #4731: Is this right? --pcw\n@@ -678,7 +678,7 @@ pub fn check_fn(cx: @MatchCheckCtxt,\n }\n \n pub fn is_refutable(cx: @MatchCheckCtxt, pat: &pat) -> bool {\n-    match cx.tcx.def_map.find(&pat.id) {\n+    match cx.tcx.def_map.find(pat.id) {\n       Some(def_variant(enum_id, _)) => {\n         if vec::len(*ty::enum_variants(cx.tcx, enum_id)) != 1u {\n             return true;"}, {"sha": "f917964d2345f86a46ee9e6706c49b23cd10f3b4", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -78,7 +78,7 @@ pub fn classify(e: @expr,\n                 tcx: ty::ctxt)\n              -> constness {\n     let did = ast_util::local_def(e.id);\n-    match tcx.ccache.find(&did) {\n+    match tcx.ccache.find(did) {\n       Some(x) => x,\n       None => {\n         let cn =\n@@ -170,7 +170,7 @@ pub fn classify(e: @expr,\n }\n \n pub fn lookup_const(tcx: ty::ctxt, e: @expr) -> Option<@expr> {\n-    match tcx.def_map.find(&e.id) {\n+    match tcx.def_map.find(e.id) {\n         Some(ast::def_const(def_id)) => lookup_const_by_id(tcx, def_id),\n         _ => None\n     }\n@@ -180,7 +180,7 @@ pub fn lookup_const_by_id(tcx: ty::ctxt,\n                           def_id: ast::def_id)\n                        -> Option<@expr> {\n     if ast_util::is_local(def_id) {\n-        match tcx.items.find(&def_id.node) {\n+        match tcx.items.find(def_id.node) {\n             None => None,\n             Some(ast_map::node_item(it, _)) => match it.node {\n                 item_const(_, const_expr) => Some(const_expr),"}, {"sha": "1e9d8c9c08e28b595c8a5db07454f2afd8470535", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -58,7 +58,7 @@ fn collect_freevars(def_map: resolve::DefMap, blk: ast::blk)\n               }\n               ast::expr_path(*) => {\n                   let mut i = 0;\n-                  match def_map.find(&expr.id) {\n+                  match def_map.find(expr.id) {\n                     None => die!(~\"path not found\"),\n                     Some(df) => {\n                       let mut def = df;\n@@ -118,7 +118,7 @@ pub fn annotate_freevars(def_map: resolve::DefMap, crate: @ast::crate) ->\n }\n \n pub fn get_freevars(tcx: ty::ctxt, fid: ast::node_id) -> freevar_info {\n-    match tcx.freevars.find(&fid) {\n+    match tcx.freevars.find(fid) {\n       None => die!(~\"get_freevars: \" + int::str(fid) + ~\" has no freevars\"),\n       Some(d) => return d\n     }"}, {"sha": "09232a2a0c52f5d9a08701422c662c6788f2f6ec", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -195,10 +195,10 @@ pub fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         expr_unary(*)|expr_binary(*)|expr_method_call(*) => e.callee_id,\n         _ => e.id\n     };\n-    do option::iter(&cx.tcx.node_type_substs.find(&type_parameter_id)) |ts| {\n+    do option::iter(&cx.tcx.node_type_substs.find(type_parameter_id)) |ts| {\n         let bounds = match e.node {\n           expr_path(_) => {\n-            let did = ast_util::def_id_of_def(cx.tcx.def_map.get(&e.id));\n+            let did = ast_util::def_id_of_def(cx.tcx.def_map.get(e.id));\n             ty::lookup_item_type(cx.tcx, did).bounds\n           }\n           _ => {\n@@ -292,8 +292,8 @@ pub fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n fn check_ty(aty: @Ty, cx: ctx, v: visit::vt<ctx>) {\n     match aty.node {\n       ty_path(_, id) => {\n-        do option::iter(&cx.tcx.node_type_substs.find(&id)) |ts| {\n-            let did = ast_util::def_id_of_def(cx.tcx.def_map.get(&id));\n+        do option::iter(&cx.tcx.node_type_substs.find(id)) |ts| {\n+            let did = ast_util::def_id_of_def(cx.tcx.def_map.get(id));\n             let bounds = ty::lookup_item_type(cx.tcx, did).bounds;\n             for vec::each2(*ts, *bounds) |ty, bound| {\n                 check_bounds(cx, aty.id, aty.span, *ty, *bound)\n@@ -334,7 +334,7 @@ pub fn check_bounds(cx: ctx, id: node_id, sp: span,\n fn is_nullary_variant(cx: ctx, ex: @expr) -> bool {\n     match ex.node {\n       expr_path(_) => {\n-        match cx.tcx.def_map.get(&ex.id) {\n+        match cx.tcx.def_map.get(ex.id) {\n           def_variant(edid, vdid) => {\n             vec::len(ty::enum_variant_with_id(cx.tcx, edid, vdid).args) == 0u\n           }"}, {"sha": "3eb65505e6462a8aceceda6ff606ea72b61ce531", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -352,7 +352,7 @@ impl LanguageItemCollector {\n             return;    // Didn't match.\n         }\n \n-        match self.item_refs.find(&value) {\n+        match self.item_refs.find(/*bad*/copy value) {\n             None => {\n                 // Didn't match.\n             }"}, {"sha": "0dc7a746e9e8389ca90ef50faa5aa034ad0a720c", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -265,7 +265,7 @@ pub fn get_lint_settings_level(settings: lint_settings,\n                                _expr_id: ast::node_id,\n                                item_id: ast::node_id)\n                             -> level {\n-    match settings.settings_map.find(&item_id) {\n+    match settings.settings_map.find(item_id) {\n       Some(modes) => get_lint_level(modes, lint_mode),\n       None => get_lint_level(settings.default_settings, lint_mode)\n     }\n@@ -346,7 +346,7 @@ impl ctxt {\n \n         for triples.each |pair| {\n             let (meta, level, lintname) = /*bad*/copy *pair;\n-            match self.dict.find(&lintname) {\n+            match self.dict.find(/*bad*/ copy lintname) {\n               None => {\n                 self.span_lint(\n                     new_ctxt.get_level(unrecognized_lint),\n@@ -684,7 +684,7 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n         for vec::each(vec::append_one(tys, decl.output)) |ty| {\n             match ty.node {\n               ast::ty_path(_, id) => {\n-                match cx.def_map.get(&id) {\n+                match cx.def_map.get(id) {\n                   ast::def_prim_ty(ast::ty_int(ast::ty_i)) => {\n                     cx.sess.span_lint(\n                         ctypes, id, fn_id,"}, {"sha": "c13af3a32f200636832257d6ed5ce141f310feba", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -368,7 +368,7 @@ impl IrMaps {\n     }\n \n     fn variable(node_id: node_id, span: span) -> Variable {\n-        match self.variable_map.find(&node_id) {\n+        match self.variable_map.find(node_id) {\n           Some(var) => var,\n           None => {\n             self.tcx.sess.span_bug(\n@@ -390,7 +390,7 @@ impl IrMaps {\n     }\n \n     fn captures(expr: @expr) -> @~[CaptureInfo] {\n-        match self.capture_info_map.find(&expr.id) {\n+        match self.capture_info_map.find(expr.id) {\n           Some(caps) => caps,\n           None => {\n             self.tcx.sess.span_bug(expr.span, ~\"no registered caps\");\n@@ -410,7 +410,7 @@ impl IrMaps {\n           Local(LocalInfo {id: id, kind: FromLetNoInitializer, _}) |\n           Local(LocalInfo {id: id, kind: FromLetWithInitializer, _}) |\n           Local(LocalInfo {id: id, kind: FromMatch(_), _}) => {\n-            let v = match self.last_use_map.find(&expr_id) {\n+            let v = match self.last_use_map.find(expr_id) {\n               Some(v) => v,\n               None => {\n                 let v = @DVec();\n@@ -552,7 +552,7 @@ fn visit_expr(expr: @expr, &&self: @IrMaps, vt: vt<@IrMaps>) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       expr_path(_) => {\n-        let def = self.tcx.def_map.get(&expr.id);\n+        let def = self.tcx.def_map.get(expr.id);\n         debug!(\"expr %d: path that leads to %?\", expr.id, def);\n         if relevant_def(def).is_some() {\n             self.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -569,7 +569,7 @@ fn visit_expr(expr: @expr, &&self: @IrMaps, vt: vt<@IrMaps>) {\n         // being the location that the variable is used.  This results\n         // in better error messages than just pointing at the closure\n         // construction site.\n-        let cvs = self.capture_map.get(&expr.id);\n+        let cvs = self.capture_map.get(expr.id);\n         let mut call_caps = ~[];\n         for cvs.each |cv| {\n             match relevant_def(cv.def) {\n@@ -685,7 +685,7 @@ fn Liveness(ir: @IrMaps, specials: Specials) -> Liveness {\n \n impl Liveness {\n     fn live_node(node_id: node_id, span: span) -> LiveNode {\n-        match self.ir.live_node_map.find(&node_id) {\n+        match self.ir.live_node_map.find(node_id) {\n           Some(ln) => ln,\n           None => {\n             // This must be a mismatch between the ir_map construction\n@@ -702,7 +702,7 @@ impl Liveness {\n     fn variable_from_path(expr: @expr) -> Option<Variable> {\n         match expr.node {\n           expr_path(_) => {\n-            let def = self.tcx.def_map.get(&expr.id);\n+            let def = self.tcx.def_map.get(expr.id);\n             relevant_def(def).map(\n                 |rdef| self.variable(*rdef, expr.span)\n             )\n@@ -717,7 +717,7 @@ impl Liveness {\n \n     fn variable_from_def_map(node_id: node_id,\n                              span: span) -> Option<Variable> {\n-        match self.tcx.def_map.find(&node_id) {\n+        match self.tcx.def_map.find(node_id) {\n           Some(def) => {\n             relevant_def(def).map(\n                 |rdef| self.variable(*rdef, span)\n@@ -837,7 +837,7 @@ impl Liveness {\n         match opt_label {\n             Some(_) => // Refers to a labeled loop. Use the results of resolve\n                       // to find with one\n-                match self.tcx.def_map.find(&id) {\n+                match self.tcx.def_map.find(id) {\n                     Some(def_label(loop_id)) => loop_id,\n                     _ => self.tcx.sess.span_bug(sp, ~\"Label on break/loop \\\n                                                     doesn't refer to a loop\")\n@@ -1203,7 +1203,7 @@ impl Liveness {\n               // Now that we know the label we're going to,\n               // look it up in the break loop nodes table\n \n-              match self.break_ln.find(&sc) {\n+              match self.break_ln.find(sc) {\n                   Some(b) => b,\n                   None => self.tcx.sess.span_bug(expr.span,\n                                 ~\"Break to unknown label\")\n@@ -1217,7 +1217,7 @@ impl Liveness {\n               // Now that we know the label we're going to,\n               // look it up in the continue loop nodes table\n \n-              match self.cont_ln.find(&sc) {\n+              match self.cont_ln.find(sc) {\n                   Some(b) => b,\n                   None => self.tcx.sess.span_bug(expr.span,\n                                 ~\"Loop to unknown label\")\n@@ -1424,7 +1424,7 @@ impl Liveness {\n     }\n \n     fn access_path(expr: @expr, succ: LiveNode, acc: uint) -> LiveNode {\n-        let def = self.tcx.def_map.get(&expr.id);\n+        let def = self.tcx.def_map.get(expr.id);\n         match relevant_def(def) {\n           Some(nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n@@ -1560,7 +1560,7 @@ fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n             let ln = self.live_node(expr.id, expr.span);\n             self.consider_last_use(expr, ln, *var);\n \n-            match self.ir.variable_moves_map.find(&expr.id) {\n+            match self.ir.variable_moves_map.find(expr.id) {\n                 None => {}\n                 Some(entire_expr) => {\n                     debug!(\"(checking expr) is a move: `%s`\",\n@@ -1689,7 +1689,7 @@ impl @Liveness {\n     fn check_lvalue(expr: @expr, vt: vt<@Liveness>) {\n         match expr.node {\n           expr_path(_) => {\n-            match self.tcx.def_map.get(&expr.id) {\n+            match self.tcx.def_map.get(expr.id) {\n               def_local(nid, false) => {\n                 // Assignment to an immutable variable or argument:\n                 // only legal if there is no later assignment."}, {"sha": "94fc63b75ddaae2948bf82964ce8233b1f69b033", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -308,7 +308,7 @@ pub struct mem_categorization_ctxt {\n \n pub impl &mem_categorization_ctxt {\n     fn cat_expr(expr: @ast::expr) -> cmt {\n-        match self.tcx.adjustments.find(&expr.id) {\n+        match self.tcx.adjustments.find(expr.id) {\n             None => {\n                 // No adjustments.\n                 self.cat_expr_unadjusted(expr)\n@@ -375,7 +375,7 @@ pub impl &mem_categorization_ctxt {\n           }\n \n           ast::expr_path(_) => {\n-            let def = self.tcx.def_map.get(&expr.id);\n+            let def = self.tcx.def_map.get(expr.id);\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n@@ -840,7 +840,7 @@ pub impl &mem_categorization_ctxt {\n             // variant(*)\n           }\n           ast::pat_enum(_, Some(ref subpats)) => {\n-            match self.tcx.def_map.find(&pat.id) {\n+            match self.tcx.def_map.find(pat.id) {\n                 Some(ast::def_variant(enum_did, _)) => {\n                     // variant(x, y, z)\n                     for subpats.each |subpat| {\n@@ -1063,7 +1063,7 @@ pub fn field_mutbl(tcx: ty::ctxt,\n         }\n       }\n       ty::ty_enum(*) => {\n-        match tcx.def_map.get(&node_id) {\n+        match tcx.def_map.get(node_id) {\n           ast::def_variant(_, variant_id) => {\n             for ty::lookup_struct_fields(tcx, variant_id).each |fld| {\n                 if fld.ident == f_name {"}, {"sha": "8adebdb45820d88c2c7b7e61558249c8c43f20de", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -409,7 +409,7 @@ impl VisitContext {\n         // `expr_mode` refers to the post-adjustment value.  If one of\n         // those adjustments is to take a reference, then it's only\n         // reading the underlying expression, not moving it.\n-        let comp_mode = match self.tcx.adjustments.find(&expr.id) {\n+        let comp_mode = match self.tcx.adjustments.find(expr.id) {\n             Some(adj) if adj.autoref.is_some() => Read,\n             _ => expr_mode.component_mode(expr)\n         };\n@@ -713,7 +713,7 @@ impl VisitContext {\n                     receiver_expr: @expr,\n                     visitor: vt<VisitContext>)\n     {\n-        let callee_mode = match self.method_map.find(&expr_id) {\n+        let callee_mode = match self.method_map.find(expr_id) {\n             Some(ref method_map_entry) => {\n                 match method_map_entry.explicit_self {\n                     sty_by_ref => by_ref,"}, {"sha": "c39d750a5814a4508acb678926e2bb42dfb62a3d", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -35,7 +35,7 @@ pub fn pat_id_map(dm: resolve::DefMap, pat: @pat) -> PatIdMap {\n pub fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: @pat) -> bool {\n     match pat.node {\n         pat_enum(_, _) | pat_ident(_, _, None) | pat_struct(*) => {\n-            match dm.find(&pat.id) {\n+            match dm.find(pat.id) {\n                 Some(def_variant(*)) | Some(def_struct(*)) => true,\n                 _ => false\n             }\n@@ -47,7 +47,7 @@ pub fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: @pat) -> bool {\n pub fn pat_is_const(dm: resolve::DefMap, pat: &pat) -> bool {\n     match pat.node {\n         pat_ident(_, _, None) => {\n-            match dm.find(&pat.id) {\n+            match dm.find(pat.id) {\n                 Some(def_const(*)) => true,\n                 _ => false\n             }"}, {"sha": "482f01f72016ffaee9adfcdebf51e4daacfe0fe0", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -105,7 +105,7 @@ pub fn check_crate(tcx: ty::ctxt,\n         match *origin {\n             method_static(method_id) => {\n                 if method_id.crate == local_crate {\n-                    match tcx.items.find(&method_id.node) {\n+                    match tcx.items.find(method_id.node) {\n                         Some(node_method(method, impl_id, _)) => {\n                             if method.vis == private &&\n                                     (impl_id.crate != local_crate ||\n@@ -143,7 +143,7 @@ pub fn check_crate(tcx: ty::ctxt,\n             method_self(trait_id, method_num) |\n             method_super(trait_id, method_num) => {\n                 if trait_id.crate == local_crate {\n-                    match tcx.items.find(&trait_id.node) {\n+                    match tcx.items.find(trait_id.node) {\n                         Some(node_item(item, _)) => {\n                             match item.node {\n                                 item_trait(_, _, ref methods) => {\n@@ -221,7 +221,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                         ty_struct(id, _)\n                         if id.crate != local_crate ||\n                            !privileged_items.contains(&(id.node)) => {\n-                            match method_map.find(&expr.id) {\n+                            match method_map.find(expr.id) {\n                                 None => {\n                                     debug!(\"(privacy checking) checking \\\n                                             field access\");\n@@ -244,7 +244,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                         ty_struct(id, _)\n                         if id.crate != local_crate ||\n                            !privileged_items.contains(&(id.node)) => {\n-                            match method_map.find(&expr.id) {\n+                            match method_map.find(expr.id) {\n                                 None => {\n                                     tcx.sess.span_bug(expr.span,\n                                                       ~\"method call not in \\\n@@ -276,7 +276,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                         ty_enum(id, _) => {\n                             if id.crate != local_crate ||\n                                     !privileged_items.contains(&(id.node)) {\n-                                match tcx.def_map.get(&expr.id) {\n+                                match tcx.def_map.get(expr.id) {\n                                     def_variant(_, variant_id) => {\n                                         for (*fields).each |field| {\n                                                 debug!(\"(privacy checking) \\\n@@ -343,7 +343,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                             if enum_id.crate != local_crate ||\n                                     !privileged_items.contains(\n                                         &enum_id.node) {\n-                                match tcx.def_map.find(&pattern.id) {\n+                                match tcx.def_map.find(pattern.id) {\n                                     Some(def_variant(_, variant_id)) => {\n                                         for fields.each |field| {\n                                             debug!(\"(privacy checking) \\"}, {"sha": "4602d2aff4ee95b43b24d2c6576ce47f6aabbd7b", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -115,7 +115,7 @@ pub fn scope_contains(region_map: region_map, superscope: ast::node_id,\n                       subscope: ast::node_id) -> bool {\n     let mut subscope = subscope;\n     while superscope != subscope {\n-        match region_map.find(&subscope) {\n+        match region_map.find(subscope) {\n             None => return false,\n             Some(scope) => subscope = scope\n         }\n@@ -159,7 +159,7 @@ pub fn nearest_common_ancestor(region_map: region_map,\n         let mut result = ~[scope];\n         let mut scope = scope;\n         loop {\n-            match region_map.find(&scope) {\n+            match region_map.find(scope) {\n                 None => return result,\n                 Some(superscope) => {\n                     result.push(superscope);\n@@ -237,7 +237,7 @@ pub fn resolve_arm(arm: ast::arm, cx: ctxt, visitor: visit::vt<ctxt>) {\n pub fn resolve_pat(pat: @ast::pat, cx: ctxt, visitor: visit::vt<ctxt>) {\n     match pat.node {\n       ast::pat_ident(*) => {\n-        let defn_opt = cx.def_map.find(&pat.id);\n+        let defn_opt = cx.def_map.find(pat.id);\n         match defn_opt {\n           Some(ast::def_variant(_,_)) => {\n             /* Nothing to do; this names a variant. */\n@@ -475,7 +475,7 @@ pub impl determine_rp_ctxt {\n     /// the new variance is joined with the old variance.\n     fn add_rp(id: ast::node_id, variance: region_variance) {\n         assert id != 0;\n-        let old_variance = self.region_paramd_items.find(&id);\n+        let old_variance = self.region_paramd_items.find(id);\n         let joined_variance = match old_variance {\n           None => variance,\n           Some(v) => join_variance(v, variance)\n@@ -505,7 +505,7 @@ pub impl determine_rp_ctxt {\n                ast_map::node_id_to_str(self.ast_map, self.item_id,\n                                        self.sess.parse_sess.interner),\n                copy self.ambient_variance);\n-        let vec = match self.dep_map.find(&from) {\n+        let vec = match self.dep_map.find(from) {\n             Some(vec) => vec,\n             None => {\n                 let vec = @DVec();\n@@ -685,7 +685,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n     // that as a direct dependency.\n     match ty.node {\n       ast::ty_path(path, id) => {\n-        match cx.def_map.find(&id) {\n+        match cx.def_map.find(id) {\n           Some(ast::def_ty(did)) | Some(ast::def_struct(did)) => {\n             if did.crate == ast::local_crate {\n                 if cx.opt_region_is_relevant(path.rp) {\n@@ -818,9 +818,9 @@ pub fn determine_rp_in_crate(sess: Session,\n     // update the region-parameterization of D to reflect the result.\n     while cx.worklist.len() != 0 {\n         let c_id = cx.worklist.pop();\n-        let c_variance = cx.region_paramd_items.get(&c_id);\n+        let c_variance = cx.region_paramd_items.get(c_id);\n         debug!(\"popped %d from worklist\", c_id);\n-        match cx.dep_map.find(&c_id) {\n+        match cx.dep_map.find(c_id) {\n           None => {}\n           Some(deps) => {\n             for deps.each |dep| {"}, {"sha": "c40b6df692689de79e1ed0b9f2a63cfe9ab974f2", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -947,7 +947,7 @@ pub impl Resolver {\n \n         // Add or reuse the child.\n         let new_parent = ModuleReducedGraphParent(module_);\n-        match module_.children.find(&name) {\n+        match module_.children.find(name) {\n             None => {\n                 let child = @NameBindings();\n                 module_.children.insert(name, child);\n@@ -1558,7 +1558,7 @@ pub impl Resolver {\n                         %s\", final_ident);\n                 let parent_link = self.get_parent_link(new_parent, ident);\n \n-                match modules.find(&def_id) {\n+                match modules.find(def_id) {\n                   None => {\n                     child_name_bindings.define_module(Public,\n                                                       parent_link,\n@@ -1582,8 +1582,7 @@ pub impl Resolver {\n                         die!(~\"can't happen\");\n                       }\n                       ModuleParentLink(parent_module, ident) => {\n-                        let name_bindings = parent_module.children.get(\n-                            &ident);\n+                        let name_bindings = parent_module.children.get(ident);\n                         resolution.type_target =\n                             Some(Target(parent_module, name_bindings));\n                       }\n@@ -1842,7 +1841,7 @@ pub impl Resolver {\n                        self.idents_to_str(module_path.get()),\n                        self.session.str_of(target));\n \n-                match module_.import_resolutions.find(&target) {\n+                match module_.import_resolutions.find(target) {\n                     Some(resolution) => {\n                         debug!(\"(building import directive) bumping \\\n                                 reference\");\n@@ -2113,7 +2112,7 @@ pub impl Resolver {\n         let mut type_result = UnknownResult;\n \n         // Search for direct children of the containing module.\n-        match containing_module.children.find(&source) {\n+        match containing_module.children.find(source) {\n             None => {\n                 // Continue.\n             }\n@@ -2149,7 +2148,7 @@ pub impl Resolver {\n                 // Now search the exported imports within the containing\n                 // module.\n \n-                match containing_module.import_resolutions.find(&source) {\n+                match containing_module.import_resolutions.find(source) {\n                     None => {\n                         // The containing module definitely doesn't have an\n                         // exported import with the name in question. We can\n@@ -2213,7 +2212,7 @@ pub impl Resolver {\n \n         // We've successfully resolved the import. Write the results in.\n         assert module_.import_resolutions.contains_key_ref(&target);\n-        let import_resolution = module_.import_resolutions.get(&target);\n+        let import_resolution = module_.import_resolutions.get(target);\n \n         match value_result {\n             BoundResult(target_module, name_bindings) => {\n@@ -2298,7 +2297,7 @@ pub impl Resolver {\n         let mut module_result = UnknownResult;\n \n         // Search for direct children of the containing module.\n-        match containing_module.children.find(&source) {\n+        match containing_module.children.find(source) {\n             None => {\n                 // Continue.\n             }\n@@ -2328,7 +2327,7 @@ pub impl Resolver {\n \n                 // Now search the exported imports within the containing\n                 // module.\n-                match containing_module.import_resolutions.find(&source) {\n+                match containing_module.import_resolutions.find(source) {\n                     None => {\n                         // The containing module definitely doesn't have an\n                         // exported import with the name in question. We can\n@@ -2372,7 +2371,7 @@ pub impl Resolver {\n \n         // We've successfully resolved the import. Write the results in.\n         assert module_.import_resolutions.contains_key_ref(&target);\n-        let import_resolution = module_.import_resolutions.get(&target);\n+        let import_resolution = module_.import_resolutions.get(target);\n \n         match module_result {\n             BoundResult(target_module, name_bindings) => {\n@@ -2440,7 +2439,7 @@ pub impl Resolver {\n                    self.module_to_str(module_));\n \n             // Here we merge two import resolutions.\n-            match module_.import_resolutions.find(&ident) {\n+            match module_.import_resolutions.find(ident) {\n                 None => {\n                     // Simple: just copy the old import resolution.\n                     let new_import_resolution =\n@@ -2483,7 +2482,7 @@ pub impl Resolver {\n         // Add all children from the containing module.\n         for containing_module.children.each_ref |&ident, &name_bindings| {\n             let mut dest_import_resolution;\n-            match module_.import_resolutions.find(&ident) {\n+            match module_.import_resolutions.find(ident) {\n                 None => {\n                     // Create a new import resolution from this child.\n                     dest_import_resolution = @ImportResolution(privacy, span);\n@@ -2687,7 +2686,7 @@ pub impl Resolver {\n         // The current module node is handled specially. First, check for\n         // its immediate children.\n \n-        match module_.children.find(&name) {\n+        match module_.children.find(name) {\n             Some(name_bindings)\n                     if (*name_bindings).defined_in_namespace(namespace) => {\n                 return Success(Target(module_, name_bindings));\n@@ -2700,7 +2699,7 @@ pub impl Resolver {\n         // adjacent import statements are processed as though they mutated the\n         // current scope.\n \n-        match module_.import_resolutions.find(&name) {\n+        match module_.import_resolutions.find(name) {\n             None => {\n                 // Not found; continue.\n             }\n@@ -2924,7 +2923,7 @@ pub impl Resolver {\n                self.module_to_str(module_));\n \n         // First, check the direct children of the module.\n-        match module_.children.find(&name) {\n+        match module_.children.find(name) {\n             Some(name_bindings)\n                     if (*name_bindings).defined_in_namespace(namespace) => {\n \n@@ -2945,7 +2944,7 @@ pub impl Resolver {\n         }\n \n         // Otherwise, we check the list of resolved imports.\n-        match module_.import_resolutions.find(&name) {\n+        match module_.import_resolutions.find(name) {\n             Some(import_resolution) => {\n                 if import_resolution.outstanding_references != 0 {\n                     debug!(\"(resolving name in module) import unresolved; \\\n@@ -3115,7 +3114,7 @@ pub impl Resolver {\n         }\n \n         // Otherwise, proceed and write in the bindings.\n-        match module_.import_resolutions.find(&target_name) {\n+        match module_.import_resolutions.find(target_name) {\n             None => {\n                 die!(~\"(resolving one-level renaming import) reduced graph \\\n                       construction or glob importing should have created the \\\n@@ -3329,7 +3328,7 @@ pub impl Resolver {\n                 // Nothing to do.\n             }\n             Some(name) => {\n-                match orig_module.children.find(&name) {\n+                match orig_module.children.find(name) {\n                     None => {\n                         debug!(\"!!! (with scope) didn't find `%s` in `%s`\",\n                                self.session.str_of(name),\n@@ -3406,7 +3405,7 @@ pub impl Resolver {\n                   // If the def is a ty param, and came from the parent\n                   // item, it's ok\n                   match def {\n-                    def_ty_param(did, _) if self.def_map.find(&did.node)\n+                    def_ty_param(did, _) if self.def_map.find(copy(did.node))\n                       == Some(def_typaram_binder(item_id)) => {\n                       // ok\n                     }\n@@ -3478,7 +3477,7 @@ pub impl Resolver {\n         while i != 0 {\n             i -= 1;\n             let rib = (*ribs).get_elt(i);\n-            match rib.bindings.find(&name) {\n+            match rib.bindings.find(name) {\n                 Some(def_like) => {\n                     return self.upvarify(ribs, i, def_like, span,\n                                       allow_capturing_self);\n@@ -4070,7 +4069,7 @@ pub impl Resolver {\n             let map_i = self.binding_mode_map(*p);\n \n             for map_0.each_ref |&key, &binding_0| {\n-                match map_i.find(&key) {\n+                match map_i.find(key) {\n                   None => {\n                     self.session.span_err(\n                         p.span,\n@@ -4127,7 +4126,7 @@ pub impl Resolver {\n \n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.current_module;\n-        match self.current_module.anonymous_children.find(&block.node.id) {\n+        match self.current_module.anonymous_children.find(block.node.id) {\n             None => { /* Nothing to do. */ }\n             Some(anonymous_module) => {\n                 debug!(\"(resolving block) found anonymous module, moving \\\n@@ -4162,7 +4161,7 @@ pub impl Resolver {\n \n                     match self.primitive_type_table\n                             .primitive_types\n-                            .find(&name) {\n+                            .find(name) {\n \n                         Some(primitive_type) => {\n                             result_def =\n@@ -4328,7 +4327,7 @@ pub impl Resolver {\n                                     bindings_list.insert(ident, pat_id);\n                                 }\n                                 Some(b) => {\n-                                  if b.find(&ident) == Some(pat_id) {\n+                                  if b.find(ident) == Some(pat_id) {\n                                       // Then this is a duplicate variable\n                                       // in the same disjunct, which is an\n                                       // error\n@@ -4527,7 +4526,7 @@ pub impl Resolver {\n                                          -> NameDefinition {\n \n         // First, search children.\n-        match containing_module.children.find(&name) {\n+        match containing_module.children.find(name) {\n             Some(child_name_bindings) => {\n                 match (child_name_bindings.def_for_namespace(namespace),\n                        child_name_bindings.privacy_for_namespace(namespace)) {\n@@ -4550,7 +4549,7 @@ pub impl Resolver {\n         }\n \n         // Next, search import resolutions.\n-        match containing_module.import_resolutions.find(&name) {\n+        match containing_module.import_resolutions.find(name) {\n             Some(import_resolution) if import_resolution.privacy == Public ||\n                                        xray == Xray => {\n                 match (*import_resolution).target_for_namespace(namespace) {\n@@ -5077,7 +5076,7 @@ pub impl Resolver {\n                trait_def_id.node,\n                self.session.str_of(name));\n \n-        match self.trait_info.find(&trait_def_id) {\n+        match self.trait_info.find(trait_def_id) {\n             Some(trait_info) if trait_info.contains_key_ref(&name) => {\n                 debug!(\"(adding trait info if containing method) found trait \\\n                         %d:%d for method '%s'\","}, {"sha": "6913cf8e2f5187e83d14b5f94c92f0842f5e46ef", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -282,7 +282,7 @@ pub fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n }\n \n pub fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> Opt {\n-    match tcx.def_map.get(&pat_id) {\n+    match tcx.def_map.get(pat_id) {\n         ast::def_variant(enum_id, var_id) => {\n             let variants = ty::enum_variants(tcx, enum_id);\n             for vec::each(*variants) |v| {\n@@ -377,7 +377,7 @@ pub fn expand_nested_bindings(bcx: block, m: &[@Match/&r],\n                                 vec::view(br.pats, col + 1u, br.pats.len())));\n \n                 let binding_info =\n-                    br.data.bindings_map.get(&path_to_ident(path));\n+                    br.data.bindings_map.get(path_to_ident(path));\n \n                 Store(bcx, val, binding_info.llmatch);\n                 @Match {pats: pats, data: br.data}\n@@ -424,8 +424,7 @@ pub fn enter_match(bcx: block, dm: DefMap, m: &[@Match/&r],\n                     ast::pat_ident(_, path, None) => {\n                         if pat_is_binding(dm, self) {\n                             let binding_info =\n-                                br.data.bindings_map.get(\n-                                    &path_to_ident(path));\n+                                br.data.bindings_map.get(path_to_ident(path));\n                             Store(bcx, val, binding_info.llmatch);\n                         }\n                     }\n@@ -519,7 +518,7 @@ pub fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n                 }\n             }\n             ast::pat_ident(_, _, None) if pat_is_const(tcx.def_map, p) => {\n-                let const_def = tcx.def_map.get(&p.id);\n+                let const_def = tcx.def_map.get(p.id);\n                 let const_def_id = ast_util::def_id_of_def(const_def);\n                 if opt_eq(tcx, &lit(ConstLit(const_def_id)), opt) {\n                     Some(~[])\n@@ -537,7 +536,7 @@ pub fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n                 if opt_eq(tcx, &variant_opt(tcx, p.id), opt) {\n                     // Look up the struct variant ID.\n                     let struct_id;\n-                    match tcx.def_map.get(&p.id) {\n+                    match tcx.def_map.get(p.id) {\n                         ast::def_variant(_, found_struct_id) => {\n                             struct_id = found_struct_id;\n                         }\n@@ -775,7 +774,7 @@ pub fn get_options(ccx: @crate_ctxt, m: &[@Match], col: uint) -> ~[Opt] {\n             ast::pat_ident(*) => {\n                 // This is one of: an enum variant, a unit-like struct, or a\n                 // variable binding.\n-                match ccx.tcx.def_map.find(&cur.id) {\n+                match ccx.tcx.def_map.find(cur.id) {\n                     Some(ast::def_variant(*)) => {\n                         add_to_set(ccx.tcx, &found,\n                                    variant_opt(ccx.tcx, cur.id));\n@@ -794,7 +793,7 @@ pub fn get_options(ccx: @crate_ctxt, m: &[@Match], col: uint) -> ~[Opt] {\n             ast::pat_enum(*) | ast::pat_struct(*) => {\n                 // This could be one of: a tuple-like enum variant, a\n                 // struct-like enum variant, or a struct.\n-                match ccx.tcx.def_map.find(&cur.id) {\n+                match ccx.tcx.def_map.find(cur.id) {\n                     Some(ast::def_variant(*)) => {\n                         add_to_set(ccx.tcx, &found,\n                                    variant_opt(ccx.tcx, cur.id));\n@@ -927,7 +926,7 @@ pub fn root_pats_as_necessary(bcx: block,\n         let pat_id = br.pats[col].id;\n \n         let key = root_map_key {id: pat_id, derefs: 0u };\n-        match bcx.ccx().maps.root_map.find(&key) {\n+        match bcx.ccx().maps.root_map.find(key) {\n             None => (),\n             Some(root_info) => {\n                 // Note: the scope_id will always be the id of the match.  See\n@@ -982,7 +981,7 @@ pub fn any_tuple_struct_pat(bcx: block, m: &[@Match], col: uint) -> bool {\n         let pat = br.pats[col];\n         match pat.node {\n             ast::pat_enum(_, Some(_)) => {\n-                match bcx.tcx().def_map.find(&pat.id) {\n+                match bcx.tcx().def_map.find(pat.id) {\n                     Some(ast::def_struct(*)) => true,\n                     _ => false\n                 }\n@@ -1718,9 +1717,9 @@ pub fn bind_irrefutable_pat(bcx: block,\n             }\n         }\n         ast::pat_enum(_, sub_pats) => {\n-            match bcx.tcx().def_map.find(&pat.id) {\n+            match bcx.tcx().def_map.find(pat.id) {\n                 Some(ast::def_variant(*)) => {\n-                    let pat_def = ccx.tcx.def_map.get(&pat.id);\n+                    let pat_def = ccx.tcx.def_map.get(pat.id);\n                     let vdefs = ast_util::variant_def_ids(pat_def);\n                     let args = extract_variant_args(bcx, pat.id, vdefs, val);\n                     for sub_pats.each |sub_pat| {"}, {"sha": "a858ecb520a504bb9e0f132ecc4491a7b418a2c7", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -169,7 +169,7 @@ pub fn get_extern_fn(externs: HashMap<~str, ValueRef>,\n                      +name: ~str,\n                      cc: lib::llvm::CallConv,\n                      ty: TypeRef) -> ValueRef {\n-    if externs.contains_key_ref(&name) { return externs.get(&name); }\n+    if externs.contains_key_ref(&name) { return externs.get(name); }\n     // XXX: Bad copy.\n     let f = decl_fn(llmod, copy name, cc, ty);\n     externs.insert(name, f);\n@@ -179,7 +179,7 @@ pub fn get_extern_fn(externs: HashMap<~str, ValueRef>,\n pub fn get_extern_const(externs: HashMap<~str, ValueRef>, llmod: ModuleRef,\n                         +name: ~str, ty: TypeRef) -> ValueRef {\n     unsafe {\n-        if externs.contains_key_ref(&name) { return externs.get(&name); }\n+        if externs.contains_key_ref(&name) { return externs.get(name); }\n         let c = str::as_c_str(name, |buf| {\n             llvm::LLVMAddGlobal(llmod, ty, buf)\n         });\n@@ -372,7 +372,7 @@ pub fn get_tydesc_simple(ccx: @crate_ctxt, t: ty::t) -> ValueRef {\n }\n \n pub fn get_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n-    match ccx.tydescs.find(&t) {\n+    match ccx.tydescs.find(t) {\n       Some(inf) => inf,\n       _ => {\n         ccx.stats.n_static_tydescs += 1u;\n@@ -807,7 +807,7 @@ pub fn get_discrim_val(cx: @crate_ctxt, span: span, enum_did: ast::def_id,\n pub fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n     unsafe {\n         let _icx = ccx.insn_ctxt(\"lookup_discriminant\");\n-        match ccx.discrims.find(&vid) {\n+        match ccx.discrims.find(vid) {\n             None => {\n                 // It's an external discriminant that we haven't seen yet.\n                 assert (vid.crate != ast::local_crate);\n@@ -1095,7 +1095,7 @@ pub fn init_local(bcx: block, local: @ast::local) -> block {\n         }\n     }\n \n-    let llptr = match bcx.fcx.lllocals.find(&local.node.id) {\n+    let llptr = match bcx.fcx.lllocals.find(local.node.id) {\n       Some(local_mem(v)) => v,\n       _ => { bcx.tcx().sess.span_bug(local.span,\n                         ~\"init_local: Someone forgot to document why it's\\\n@@ -1437,7 +1437,7 @@ pub fn call_memcpy(cx: block, dst: ValueRef, src: ValueRef,\n       session::arch_x86 | session::arch_arm => ~\"llvm.memcpy.p0i8.p0i8.i32\",\n       session::arch_x86_64 => ~\"llvm.memcpy.p0i8.p0i8.i64\"\n     };\n-    let memcpy = ccx.intrinsics.get(&key);\n+    let memcpy = ccx.intrinsics.get(key);\n     let src_ptr = PointerCast(cx, src, T_ptr(T_i8()));\n     let dst_ptr = PointerCast(cx, dst, T_ptr(T_i8()));\n     let size = IntCast(cx, n_bytes, ccx.int_type);\n@@ -1484,7 +1484,7 @@ pub fn memzero(cx: block, llptr: ValueRef, llty: TypeRef) {\n         }\n     }\n \n-    let llintrinsicfn = ccx.intrinsics.get(&intrinsic_key);\n+    let llintrinsicfn = ccx.intrinsics.get(intrinsic_key);\n     let llptr = PointerCast(cx, llptr, T_ptr(T_i8()));\n     let llzeroval = C_u8(0);\n     let size = IntCast(cx, machine::llsize_of(ccx, llty), ccx.int_type);\n@@ -1884,7 +1884,7 @@ pub fn trans_enum_variant(ccx: @crate_ctxt,\n         // If this argument to this function is a enum, it'll have come in to\n         // this function as an opaque blob due to the way that type_of()\n         // works. So we have to cast to the destination's view of the type.\n-        let llarg = match fcx.llargs.find(&va.id) {\n+        let llarg = match fcx.llargs.find(va.id) {\n             Some(local_mem(x)) => x,\n             _ => die!(~\"trans_enum_variant: how do we know this works?\"),\n         };\n@@ -1930,7 +1930,7 @@ pub fn trans_tuple_struct(ccx: @crate_ctxt,\n \n     for fields.eachi |i, field| {\n         let lldestptr = GEPi(bcx, fcx.llretptr, [0, 0, i]);\n-        let llarg = match fcx.llargs.get(&field.node.id) {\n+        let llarg = match fcx.llargs.get(field.node.id) {\n             local_mem(x) => x,\n             _ => {\n                 ccx.tcx.sess.bug(~\"trans_tuple_struct: llarg wasn't \\\n@@ -2019,7 +2019,7 @@ pub fn trans_enum_def(ccx: @crate_ctxt, enum_definition: ast::enum_def,\n \n pub fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n     let _icx = ccx.insn_ctxt(\"trans_item\");\n-    let path = match ccx.tcx.items.get(&item.id) {\n+    let path = match ccx.tcx.items.get(item.id) {\n         ast_map::node_item(_, p) => p,\n         // tjc: ?\n         _ => die!(~\"trans_item\"),\n@@ -2275,7 +2275,7 @@ pub fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n \n pub fn item_path(ccx: @crate_ctxt, i: @ast::item) -> path {\n     vec::append(\n-        /*bad*/copy *match ccx.tcx.items.get(&i.id) {\n+        /*bad*/copy *match ccx.tcx.items.get(i.id) {\n             ast_map::node_item(_, p) => p,\n                 // separate map for paths?\n             _ => die!(~\"item_path\")\n@@ -2291,7 +2291,7 @@ pub fn get_dtor_symbol(ccx: @crate_ctxt,\n                        +substs: Option<param_substs>)\n                     -> ~str {\n   let t = ty::node_id_to_type(ccx.tcx, id);\n-  match ccx.item_symbols.find(&id) {\n+  match ccx.item_symbols.find(id) {\n      Some(ref s) => (/*bad*/copy *s),\n      None if substs.is_none() => {\n        let s = mangle_exported_name(\n@@ -2326,12 +2326,12 @@ pub fn get_dtor_symbol(ccx: @crate_ctxt,\n pub fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n     debug!(\"get_item_val(id=`%?`)\", id);\n     let tcx = ccx.tcx;\n-    match ccx.item_vals.find(&id) {\n+    match ccx.item_vals.find(id) {\n       Some(v) => v,\n       None => {\n \n         let mut exprt = false;\n-        let val = match ccx.tcx.items.get(&id) {\n+        let val = match ccx.tcx.items.get(id) {\n           ast_map::node_item(i, pth) => {\n             let my_path = vec::append(/*bad*/copy *pth,\n                                       ~[path_name(i.ident)]);\n@@ -2770,7 +2770,7 @@ pub fn declare_dbg_intrinsics(llmod: ModuleRef,\n \n pub fn trap(bcx: block) {\n     let v: ~[ValueRef] = ~[];\n-    match bcx.ccx().intrinsics.find(&~\"llvm.trap\") {\n+    match bcx.ccx().intrinsics.find(~\"llvm.trap\") {\n       Some(x) => { Call(bcx, x, v); },\n       _ => bcx.sess().bug(~\"unbound llvm.trap in trap\")\n     }"}, {"sha": "7923643358026ada337091c835c1eb9ae5eb28f2", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -70,7 +70,7 @@ pub fn count_insn(cx: block, category: &str) {\n         i = 0u;\n         while i < len {\n             let e = /*bad*/copy v[i];\n-            i = mm.get(&e);\n+            i = mm.get(/*bad*/ copy e);\n             s += ~\"/\";\n             s += e;\n             i += 1u;\n@@ -79,7 +79,7 @@ pub fn count_insn(cx: block, category: &str) {\n         s += ~\"/\";\n         s += category;\n \n-        let n = match h.find(&s) {\n+        let n = match h.find(/*bad*/ copy s) {\n           Some(n) => n,\n           _ => 0u\n         };"}, {"sha": "833cff80d2ddb9d69f55a381e14962637168e064", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -70,7 +70,7 @@ pub fn trans(bcx: block, expr: @ast::expr) -> Callee {\n             return trans_def(bcx, bcx.def(expr.id), expr);\n         }\n         ast::expr_field(base, _, _) => {\n-            match bcx.ccx().maps.method_map.find(&expr.id) {\n+            match bcx.ccx().maps.method_map.find(expr.id) {\n                 Some(ref origin) => { // An impl method\n                     return meth::trans_method_callee(bcx, expr.id,\n                                                      base, (*origin));\n@@ -208,7 +208,7 @@ pub fn trans_fn_ref_with_vtables(\n     // Modify the def_id if this is a default method; we want to be\n     // monomorphizing the trait's code.\n     let (def_id, opt_impl_did) =\n-            match tcx.provided_method_sources.find(&def_id) {\n+            match tcx.provided_method_sources.find(def_id) {\n         None => (def_id, None),\n         Some(source) => (source.method_id, Some(source.impl_id))\n     };\n@@ -234,7 +234,7 @@ pub fn trans_fn_ref_with_vtables(\n     } else if def_id.crate == ast::local_crate {\n         let map_node = session::expect(\n             ccx.sess,\n-            ccx.tcx.items.find(&def_id.node),\n+            ccx.tcx.items.find(def_id.node),\n             || fmt!(\"local item should be in ast map\"));\n \n         match map_node {\n@@ -313,7 +313,7 @@ pub fn trans_method_call(in_cx: block,\n         node_id_type(in_cx, call_ex.callee_id),\n         expr_ty(in_cx, call_ex),\n         |cx| {\n-            match cx.ccx().maps.method_map.find(&call_ex.id) {\n+            match cx.ccx().maps.method_map.find(call_ex.id) {\n                 Some(ref origin) => {\n                     meth::trans_method_callee(cx,\n                                               call_ex.callee_id,"}, {"sha": "4cbf6a4f4b74a6abe875d934307a642b35a7f594", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -419,7 +419,7 @@ pub fn trans_expr_fn(bcx: block,\n \n     let Result {bcx: bcx, val: closure} = match proto {\n         ast::ProtoBorrowed | ast::ProtoBox | ast::ProtoUniq => {\n-            let cap_vars = ccx.maps.capture_map.get(&user_id);\n+            let cap_vars = ccx.maps.capture_map.get(user_id);\n             let ret_handle = match is_loop_body {Some(x) => x,\n                                                  None => None};\n             let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, proto,"}, {"sha": "571f16e4b34ee6369bdf5e34c233b802893bc0dc", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -700,7 +700,7 @@ pub impl block {\n     }\n \n     fn def(nid: ast::node_id) -> ast::def {\n-        match self.tcx().def_map.find(&nid) {\n+        match self.tcx().def_map.find(nid) {\n             Some(v) => v,\n             None => {\n                 self.tcx().sess.bug(fmt!(\n@@ -1134,7 +1134,7 @@ pub fn C_u8(i: uint) -> ValueRef {\n // our boxed-and-length-annotated strings.\n pub fn C_cstr(cx: @crate_ctxt, +s: ~str) -> ValueRef {\n     unsafe {\n-        match cx.const_cstr_cache.find(&s) {\n+        match cx.const_cstr_cache.find(/*bad*/copy s) {\n           Some(llval) => return llval,\n           None => ()\n         }\n@@ -1356,7 +1356,7 @@ pub fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n \n pub fn node_vtables(bcx: block, id: ast::node_id)\n                  -> Option<typeck::vtable_res> {\n-    let raw_vtables = bcx.ccx().maps.vtable_map.find(&id);\n+    let raw_vtables = bcx.ccx().maps.vtable_map.find(id);\n     raw_vtables.map(\n         |vts| resolve_vtables_in_fn_ctxt(bcx.fcx, *vts))\n }"}, {"sha": "b5652fed10e6dbbdadc1bb9070b4c4dfb4323275", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -82,7 +82,7 @@ pub fn const_vec(cx: @crate_ctxt, e: @ast::expr, es: &[@ast::expr])\n \n pub fn const_deref(cx: @crate_ctxt, v: ValueRef) -> ValueRef {\n     unsafe {\n-        let v = match cx.const_globals.find(&(v as int)) {\n+        let v = match cx.const_globals.find(v as int) {\n             Some(v) => v,\n             None => v\n         };\n@@ -127,7 +127,7 @@ pub fn get_const_val(cx: @crate_ctxt, def_id: ast::def_id) -> ValueRef {\n         cx.tcx.sess.bug(~\"cross-crate constants\");\n     }\n     if !cx.const_values.contains_key_ref(&def_id.node) {\n-        match cx.tcx.items.get(&def_id.node) {\n+        match cx.tcx.items.get(def_id.node) {\n             ast_map::node_item(@ast::item {\n                 node: ast::item_const(_, subexpr), _\n             }, _) => {\n@@ -136,7 +136,7 @@ pub fn get_const_val(cx: @crate_ctxt, def_id: ast::def_id) -> ValueRef {\n             _ => cx.tcx.sess.bug(~\"expected a const to be an item\")\n         }\n     }\n-    cx.const_values.get(&def_id.node)\n+    cx.const_values.get(def_id.node)\n }\n \n pub fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n@@ -402,7 +402,7 @@ pub fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n           }\n           ast::expr_path(pth) => {\n             assert pth.types.len() == 0;\n-            match cx.tcx.def_map.find(&e.id) {\n+            match cx.tcx.def_map.find(e.id) {\n                 Some(ast::def_fn(def_id, purity)) => {\n                     assert ast_util::is_local(def_id);\n                     let f = base::get_item_val(cx, def_id.node);\n@@ -437,7 +437,7 @@ pub fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n             }\n           }\n           ast::expr_call(callee, args, _) => {\n-            match cx.tcx.def_map.find(&callee.id) {\n+            match cx.tcx.def_map.find(callee.id) {\n                 Some(ast::def_struct(def_id)) => {\n                     let ety = ty::expr_ty(cx.tcx, e);\n                     let llty = type_of::type_of(cx, ety);\n@@ -482,7 +482,7 @@ pub fn trans_const(ccx: @crate_ctxt, _e: @ast::expr, id: ast::node_id) {\n         let g = base::get_item_val(ccx, id);\n         // At this point, get_item_val has already translated the\n         // constant's initializer to determine its LLVM type.\n-        let v = ccx.const_values.get(&id);\n+        let v = ccx.const_values.get(id);\n         llvm::LLVMSetInitializer(g, v);\n         llvm::LLVMSetGlobalConstant(g, True);\n     }"}, {"sha": "240c323965faa4f8fd68521bac8dffbfb42f9f6b", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -184,7 +184,7 @@ pub fn trans_log(log_ex: @ast::expr,\n     let modname = path_str(ccx.sess, copy modpath);\n \n     let global = if ccx.module_data.contains_key_ref(&modname) {\n-        ccx.module_data.get(&modname)\n+        ccx.module_data.get(modname)\n     } else {\n         let s = link::mangle_internal_name_by_path_and_seq(\n             ccx, modpath, ~\"loglevel\");"}, {"sha": "554cebbbcb781fa1756430caaa212b6d1783d215", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -627,15 +627,15 @@ pub impl Datum {\n         //\n         // (Note: root'd values are always boxes)\n         let key = root_map_key { id: expr_id, derefs: derefs };\n-        let bcx = match ccx.maps.root_map.find(&key) {\n+        let bcx = match ccx.maps.root_map.find(key) {\n             None => bcx,\n             Some(root_info) => self.root(bcx, root_info)\n         };\n \n         // Perform the write guard, if necessary.\n         //\n         // (Note: write-guarded values are always boxes)\n-        let bcx = match ccx.maps.write_guard_map.find(&key) {\n+        let bcx = match ccx.maps.write_guard_map.find(key) {\n             None => bcx,\n             Some(_) => self.perform_write_guard(bcx)\n         };"}, {"sha": "35abddfb85a515c5b47cd6787cd1d6cf552641be", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -118,7 +118,7 @@ pub fn mk_ctxt(+crate: ~str, intr: @ident_interner) -> debug_ctxt {\n \n fn update_cache(cache: metadata_cache, mdtag: int, val: debug_metadata) {\n     let existing = if cache.contains_key_ref(&mdtag) {\n-        cache.get(&mdtag)\n+        cache.get(mdtag)\n     } else {\n         ~[]\n     };\n@@ -177,7 +177,7 @@ fn cached_metadata<T: Copy>(cache: metadata_cache,\n                          -> Option<T> {\n     unsafe {\n         if cache.contains_key_ref(&mdtag) {\n-            let items = cache.get(&mdtag);\n+            let items = cache.get(mdtag);\n             for items.each |item| {\n                 let md: T = md_from_metadata::<T>(*item);\n                 if eq_fn(md) {\n@@ -289,7 +289,7 @@ fn create_block(cx: block) -> @metadata<block_md> {\n         Some(bcx) => create_block(bcx).node\n     };\n     let file_node = create_file(cx.ccx(), fname);\n-    let unique_id = match cache.find(&LexicalBlockTag) {\n+    let unique_id = match cache.find(LexicalBlockTag) {\n       option::Some(v) => vec::len(v) as int,\n       option::None => 0\n     };\n@@ -679,22 +679,22 @@ pub fn create_local_var(bcx: block, local: @ast::local)\n         let mdval = @{node: mdnode, data: {id: local.node.id}};\n         update_cache(cache, AutoVariableTag, local_var_metadata(mdval));\n \n-        let llptr = match bcx.fcx.lllocals.find(&local.node.id) {\n+        let llptr = match bcx.fcx.lllocals.find(local.node.id) {\n           option::Some(local_mem(v)) => v,\n           option::Some(_) => {\n             bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n                     something weird\");\n           }\n           option::None => {\n-            match bcx.fcx.lllocals.get(&local.node.pat.id) {\n+            match bcx.fcx.lllocals.get(local.node.pat.id) {\n               local_imm(v) => v,\n               _ => bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n                                                          something weird\")\n             }\n           }\n         };\n         let declargs = ~[llmdnode(~[llptr]), mdnode];\n-        trans::build::Call(bcx, cx.intrinsics.get(&~\"llvm.dbg.declare\"),\n+        trans::build::Call(bcx, cx.intrinsics.get(~\"llvm.dbg.declare\"),\n                            declargs);\n         return mdval;\n     }\n@@ -731,12 +731,12 @@ pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n                 let mdval = @{node: mdnode, data: {id: arg.id}};\n                 update_cache(cache, tg, argument_metadata(mdval));\n \n-                let llptr = match fcx.llargs.get(&arg.id) {\n+                let llptr = match fcx.llargs.get(arg.id) {\n                   local_mem(v) | local_imm(v) => v,\n                 };\n                 let declargs = ~[llmdnode(~[llptr]), mdnode];\n                 trans::build::Call(bcx,\n-                                   cx.intrinsics.get(&~\"llvm.dbg.declare\"),\n+                                   cx.intrinsics.get(~\"llvm.dbg.declare\"),\n                                    declargs);\n                 return Some(mdval);\n             }\n@@ -774,7 +774,7 @@ pub fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     let sp = fcx.span.get();\n     log(debug, cx.sess.codemap.span_to_str(sp));\n \n-    let (ident, ret_ty, id) = match cx.tcx.items.get(&fcx.id) {\n+    let (ident, ret_ty, id) = match cx.tcx.items.get(fcx.id) {\n       ast_map::node_item(item, _) => {\n         match /*bad*/copy item.node {\n           ast::item_fn(decl, _, _, _) => {"}, {"sha": "4cf449cd972104e7a0413c9d6b321e7f3e98f2e1", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -185,7 +185,7 @@ fn drop_and_cancel_clean(bcx: block, dat: Datum) -> block {\n \n pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n     debug!(\"trans_to_datum(expr=%s)\", bcx.expr_to_str(expr));\n-    return match bcx.tcx().adjustments.find(&expr.id) {\n+    return match bcx.tcx().adjustments.find(expr.id) {\n         None => {\n             trans_to_datum_unadjusted(bcx, expr)\n         }\n@@ -329,7 +329,7 @@ fn trans_lvalue(bcx: block, expr: @ast::expr) -> DatumBlock {\n      * instead, but sometimes we call trans_lvalue() directly as a\n      * means of asserting that a particular expression is an lvalue. */\n \n-    return match bcx.tcx().adjustments.find(&expr.id) {\n+    return match bcx.tcx().adjustments.find(expr.id) {\n         None => trans_lvalue_unadjusted(bcx, expr),\n         Some(_) => {\n             bcx.sess().span_bug(\n@@ -742,7 +742,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     // the lvalue in there, and then arrange for it to be cleaned up\n     // at the end of the scope with id `scope_id`:\n     let root_key = root_map_key { id: expr.id, derefs: 0u };\n-    for bcx.ccx().maps.root_map.find(&root_key).each |&root_info| {\n+    for bcx.ccx().maps.root_map.find(root_key).each |&root_info| {\n         bcx = unrooted_datum.root(bcx, root_info);\n     }\n \n@@ -934,7 +934,7 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n         ast::def_upvar(nid, _, _, _) => {\n             // Can't move upvars, so this is never a ZeroMemLastUse.\n             let local_ty = node_id_type(bcx, nid);\n-            match bcx.fcx.llupvars.find(&nid) {\n+            match bcx.fcx.llupvars.find(nid) {\n                 Some(val) => {\n                     Datum {\n                         val: val,\n@@ -987,7 +987,7 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n     fn take_local(bcx: block,\n                   table: HashMap<ast::node_id, local_val>,\n                   nid: ast::node_id) -> Datum {\n-        let (v, mode) = match table.find(&nid) {\n+        let (v, mode) = match table.find(nid) {\n             Some(local_mem(v)) => (v, ByRef),\n             Some(local_imm(v)) => (v, ByValue),\n             None => {\n@@ -1066,7 +1066,7 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n                         ty_to_str(tcx, ty)));\n                 }\n                 Some(node_id) => {\n-                    match tcx.def_map.get(&node_id) {\n+                    match tcx.def_map.get(node_id) {\n                         ast::def_variant(_, variant_id) => {\n                             op(false, struct_mutable_fields(\n                                 tcx, variant_id, substs))\n@@ -1120,7 +1120,7 @@ fn trans_rec_or_struct(bcx: block,\n     let tcx = bcx.tcx();\n     let addr = match ty::get(ty).sty {\n         ty::ty_enum(_, ref substs) => {\n-            match tcx.def_map.get(&id) {\n+            match tcx.def_map.get(id) {\n                 ast::def_variant(enum_id, variant_id) => {\n                     let variant_info = ty::enum_variant_with_id(\n                         tcx, enum_id, variant_id);\n@@ -1479,7 +1479,7 @@ fn trans_overloaded_op(bcx: block,\n                        dest: Dest,\n                        +autoref_arg: AutorefArg) -> block\n {\n-    let origin = bcx.ccx().maps.method_map.get(&expr.id);\n+    let origin = bcx.ccx().maps.method_map.get(expr.id);\n     let fty = node_id_type(bcx, expr.callee_id);\n     return callee::trans_call_inner(\n         bcx, expr.info(), fty,\n@@ -1636,7 +1636,7 @@ fn trans_assign_op(bcx: block,\n     let dst_datum = unpack_datum!(bcx, trans_lvalue_unadjusted(bcx, dst));\n \n     // A user-defined operator method\n-    if bcx.ccx().maps.method_map.find(&expr.id).is_some() {\n+    if bcx.ccx().maps.method_map.find(expr.id).is_some() {\n         // FIXME(#2528) evaluates the receiver twice!!\n         let scratch = scratch_datum(bcx, dst_datum.ty, false);\n         let bcx = trans_overloaded_op(bcx, expr, dst, ~[src],"}, {"sha": "9c2245411c62863ddf651b804976a58b64735da2", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -498,7 +498,7 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n             let tp_sz = machine::llbitsize_of_real(ccx, lltp_ty),\n             out_sz = machine::llbitsize_of_real(ccx, llout_ty);\n           if tp_sz != out_sz {\n-              let sp = match ccx.tcx.items.get(&ref_id.get()) {\n+              let sp = match ccx.tcx.items.get(ref_id.get()) {\n                   ast_map::node_expr(e) => e.span,\n                   _ => die!(~\"reinterpret_cast or forget has non-expr arg\")\n               };\n@@ -535,7 +535,7 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n                                         abi::tydesc_field_visit_glue, None);\n         }\n         ~\"frame_address\" => {\n-            let frameaddress = ccx.intrinsics.get(&~\"llvm.frameaddress\");\n+            let frameaddress = ccx.intrinsics.get(~\"llvm.frameaddress\");\n             let frameaddress_val = Call(bcx, frameaddress, ~[C_i32(0i32)]);\n             let star_u8 = ty::mk_imm_ptr(\n                 bcx.tcx(),\n@@ -576,7 +576,7 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n             let align = C_i32(1);\n             let volatile = C_bool(false);\n             let llfn = bcx.ccx().intrinsics.get(\n-                &~\"llvm.memmove.p0i8.p0i8.i32\");\n+                ~\"llvm.memmove.p0i8.p0i8.i32\");\n             Call(bcx, llfn, ~[dst_ptr, src_ptr, size, align, volatile]);\n         }\n         ~\"memmove64\" => {\n@@ -586,248 +586,248 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n             let align = C_i32(1);\n             let volatile = C_bool(false);\n             let llfn = bcx.ccx().intrinsics.get(\n-                &~\"llvm.memmove.p0i8.p0i8.i64\");\n+                ~\"llvm.memmove.p0i8.p0i8.i64\");\n             Call(bcx, llfn, ~[dst_ptr, src_ptr, size, align, volatile]);\n         }\n         ~\"sqrtf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let sqrtf = ccx.intrinsics.get(&~\"llvm.sqrt.f32\");\n+            let sqrtf = ccx.intrinsics.get(~\"llvm.sqrt.f32\");\n             Store(bcx, Call(bcx, sqrtf, ~[x]), fcx.llretptr);\n         }\n         ~\"sqrtf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let sqrtf = ccx.intrinsics.get(&~\"llvm.sqrt.f64\");\n+            let sqrtf = ccx.intrinsics.get(~\"llvm.sqrt.f64\");\n             Store(bcx, Call(bcx, sqrtf, ~[x]), fcx.llretptr);\n         }\n         ~\"powif32\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n-            let powif = ccx.intrinsics.get(&~\"llvm.powi.f32\");\n+            let powif = ccx.intrinsics.get(~\"llvm.powi.f32\");\n             Store(bcx, Call(bcx, powif, ~[a, x]), fcx.llretptr);\n         }\n         ~\"powif64\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n-            let powif = ccx.intrinsics.get(&~\"llvm.powi.f64\");\n+            let powif = ccx.intrinsics.get(~\"llvm.powi.f64\");\n             Store(bcx, Call(bcx, powif, ~[a, x]), fcx.llretptr);\n         }\n         ~\"sinf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let sinf = ccx.intrinsics.get(&~\"llvm.sin.f32\");\n+            let sinf = ccx.intrinsics.get(~\"llvm.sin.f32\");\n             Store(bcx, Call(bcx, sinf, ~[x]), fcx.llretptr);\n         }\n         ~\"sinf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let sinf = ccx.intrinsics.get(&~\"llvm.sin.f64\");\n+            let sinf = ccx.intrinsics.get(~\"llvm.sin.f64\");\n             Store(bcx, Call(bcx, sinf, ~[x]), fcx.llretptr);\n         }\n         ~\"cosf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cosf = ccx.intrinsics.get(&~\"llvm.cos.f32\");\n+            let cosf = ccx.intrinsics.get(~\"llvm.cos.f32\");\n             Store(bcx, Call(bcx, cosf, ~[x]), fcx.llretptr);\n         }\n         ~\"cosf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cosf = ccx.intrinsics.get(&~\"llvm.cos.f64\");\n+            let cosf = ccx.intrinsics.get(~\"llvm.cos.f64\");\n             Store(bcx, Call(bcx, cosf, ~[x]), fcx.llretptr);\n         }\n         ~\"powf32\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n-            let powf = ccx.intrinsics.get(&~\"llvm.pow.f32\");\n+            let powf = ccx.intrinsics.get(~\"llvm.pow.f32\");\n             Store(bcx, Call(bcx, powf, ~[a, x]), fcx.llretptr);\n         }\n         ~\"powf64\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n-            let powf = ccx.intrinsics.get(&~\"llvm.pow.f64\");\n+            let powf = ccx.intrinsics.get(~\"llvm.pow.f64\");\n             Store(bcx, Call(bcx, powf, ~[a, x]), fcx.llretptr);\n         }\n         ~\"expf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let expf = ccx.intrinsics.get(&~\"llvm.exp.f32\");\n+            let expf = ccx.intrinsics.get(~\"llvm.exp.f32\");\n             Store(bcx, Call(bcx, expf, ~[x]), fcx.llretptr);\n         }\n         ~\"expf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let expf = ccx.intrinsics.get(&~\"llvm.exp.f64\");\n+            let expf = ccx.intrinsics.get(~\"llvm.exp.f64\");\n             Store(bcx, Call(bcx, expf, ~[x]), fcx.llretptr);\n         }\n         ~\"exp2f32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let exp2f = ccx.intrinsics.get(&~\"llvm.exp2.f32\");\n+            let exp2f = ccx.intrinsics.get(~\"llvm.exp2.f32\");\n             Store(bcx, Call(bcx, exp2f, ~[x]), fcx.llretptr);\n         }\n         ~\"exp2f64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let exp2f = ccx.intrinsics.get(&~\"llvm.exp2.f64\");\n+            let exp2f = ccx.intrinsics.get(~\"llvm.exp2.f64\");\n             Store(bcx, Call(bcx, exp2f, ~[x]), fcx.llretptr);\n         }\n         ~\"logf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let logf = ccx.intrinsics.get(&~\"llvm.log.f32\");\n+            let logf = ccx.intrinsics.get(~\"llvm.log.f32\");\n             Store(bcx, Call(bcx, logf, ~[x]), fcx.llretptr);\n         }\n         ~\"logf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let logf = ccx.intrinsics.get(&~\"llvm.log.f64\");\n+            let logf = ccx.intrinsics.get(~\"llvm.log.f64\");\n             Store(bcx, Call(bcx, logf, ~[x]), fcx.llretptr);\n         }\n         ~\"log10f32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let log10f = ccx.intrinsics.get(&~\"llvm.log10.f32\");\n+            let log10f = ccx.intrinsics.get(~\"llvm.log10.f32\");\n             Store(bcx, Call(bcx, log10f, ~[x]), fcx.llretptr);\n         }\n         ~\"log10f64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let log10f = ccx.intrinsics.get(&~\"llvm.log10.f64\");\n+            let log10f = ccx.intrinsics.get(~\"llvm.log10.f64\");\n             Store(bcx, Call(bcx, log10f, ~[x]), fcx.llretptr);\n         }\n         ~\"log2f32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let log2f = ccx.intrinsics.get(&~\"llvm.log2.f32\");\n+            let log2f = ccx.intrinsics.get(~\"llvm.log2.f32\");\n             Store(bcx, Call(bcx, log2f, ~[x]), fcx.llretptr);\n         }\n         ~\"log2f64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let log2f = ccx.intrinsics.get(&~\"llvm.log2.f64\");\n+            let log2f = ccx.intrinsics.get(~\"llvm.log2.f64\");\n             Store(bcx, Call(bcx, log2f, ~[x]), fcx.llretptr);\n         }\n         ~\"fmaf32\" => {\n             let a = get_param(decl, first_real_arg);\n             let b = get_param(decl, first_real_arg + 1u);\n             let c = get_param(decl, first_real_arg + 2u);\n-            let fmaf = ccx.intrinsics.get(&~\"llvm.fma.f32\");\n+            let fmaf = ccx.intrinsics.get(~\"llvm.fma.f32\");\n             Store(bcx, Call(bcx, fmaf, ~[a, b, c]), fcx.llretptr);\n         }\n         ~\"fmaf64\" => {\n             let a = get_param(decl, first_real_arg);\n             let b = get_param(decl, first_real_arg + 1u);\n             let c = get_param(decl, first_real_arg + 2u);\n-            let fmaf = ccx.intrinsics.get(&~\"llvm.fma.f64\");\n+            let fmaf = ccx.intrinsics.get(~\"llvm.fma.f64\");\n             Store(bcx, Call(bcx, fmaf, ~[a, b, c]), fcx.llretptr);\n         }\n         ~\"fabsf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let fabsf = ccx.intrinsics.get(&~\"llvm.fabs.f32\");\n+            let fabsf = ccx.intrinsics.get(~\"llvm.fabs.f32\");\n             Store(bcx, Call(bcx, fabsf, ~[x]), fcx.llretptr);\n         }\n         ~\"fabsf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let fabsf = ccx.intrinsics.get(&~\"llvm.fabs.f64\");\n+            let fabsf = ccx.intrinsics.get(~\"llvm.fabs.f64\");\n             Store(bcx, Call(bcx, fabsf, ~[x]), fcx.llretptr);\n         }\n         ~\"floorf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let floorf = ccx.intrinsics.get(&~\"llvm.floor.f32\");\n+            let floorf = ccx.intrinsics.get(~\"llvm.floor.f32\");\n             Store(bcx, Call(bcx, floorf, ~[x]), fcx.llretptr);\n         }\n         ~\"floorf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let floorf = ccx.intrinsics.get(&~\"llvm.floor.f64\");\n+            let floorf = ccx.intrinsics.get(~\"llvm.floor.f64\");\n             Store(bcx, Call(bcx, floorf, ~[x]), fcx.llretptr);\n         }\n         ~\"ceilf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ceilf = ccx.intrinsics.get(&~\"llvm.ceil.f32\");\n+            let ceilf = ccx.intrinsics.get(~\"llvm.ceil.f32\");\n             Store(bcx, Call(bcx, ceilf, ~[x]), fcx.llretptr);\n         }\n         ~\"ceilf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ceilf = ccx.intrinsics.get(&~\"llvm.ceil.f64\");\n+            let ceilf = ccx.intrinsics.get(~\"llvm.ceil.f64\");\n             Store(bcx, Call(bcx, ceilf, ~[x]), fcx.llretptr);\n         }\n         ~\"truncf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let truncf = ccx.intrinsics.get(&~\"llvm.trunc.f32\");\n+            let truncf = ccx.intrinsics.get(~\"llvm.trunc.f32\");\n             Store(bcx, Call(bcx, truncf, ~[x]), fcx.llretptr);\n         }\n         ~\"truncf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let truncf = ccx.intrinsics.get(&~\"llvm.trunc.f64\");\n+            let truncf = ccx.intrinsics.get(~\"llvm.trunc.f64\");\n             Store(bcx, Call(bcx, truncf, ~[x]), fcx.llretptr);\n         }\n         ~\"ctpop8\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ctpop = ccx.intrinsics.get(&~\"llvm.ctpop.i8\");\n+            let ctpop = ccx.intrinsics.get(~\"llvm.ctpop.i8\");\n             Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr)\n         }\n         ~\"ctpop16\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ctpop = ccx.intrinsics.get(&~\"llvm.ctpop.i16\");\n+            let ctpop = ccx.intrinsics.get(~\"llvm.ctpop.i16\");\n             Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr)\n         }\n         ~\"ctpop32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ctpop = ccx.intrinsics.get(&~\"llvm.ctpop.i32\");\n+            let ctpop = ccx.intrinsics.get(~\"llvm.ctpop.i32\");\n             Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr)\n         }\n         ~\"ctpop64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ctpop = ccx.intrinsics.get(&~\"llvm.ctpop.i64\");\n+            let ctpop = ccx.intrinsics.get(~\"llvm.ctpop.i64\");\n             Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr)\n         }\n         ~\"ctlz8\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_bool(false);\n-            let ctlz = ccx.intrinsics.get(&~\"llvm.ctlz.i8\");\n+            let ctlz = ccx.intrinsics.get(~\"llvm.ctlz.i8\");\n             Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"ctlz16\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_bool(false);\n-            let ctlz = ccx.intrinsics.get(&~\"llvm.ctlz.i16\");\n+            let ctlz = ccx.intrinsics.get(~\"llvm.ctlz.i16\");\n             Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"ctlz32\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_bool(false);\n-            let ctlz = ccx.intrinsics.get(&~\"llvm.ctlz.i32\");\n+            let ctlz = ccx.intrinsics.get(~\"llvm.ctlz.i32\");\n             Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"ctlz64\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_bool(false);\n-            let ctlz = ccx.intrinsics.get(&~\"llvm.ctlz.i64\");\n+            let ctlz = ccx.intrinsics.get(~\"llvm.ctlz.i64\");\n             Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"cttz8\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_bool(false);\n-            let cttz = ccx.intrinsics.get(&~\"llvm.cttz.i8\");\n+            let cttz = ccx.intrinsics.get(~\"llvm.cttz.i8\");\n             Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"cttz16\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_bool(false);\n-            let cttz = ccx.intrinsics.get(&~\"llvm.cttz.i16\");\n+            let cttz = ccx.intrinsics.get(~\"llvm.cttz.i16\");\n             Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"cttz32\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_bool(false);\n-            let cttz = ccx.intrinsics.get(&~\"llvm.cttz.i32\");\n+            let cttz = ccx.intrinsics.get(~\"llvm.cttz.i32\");\n             Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"cttz64\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_bool(false);\n-            let cttz = ccx.intrinsics.get(&~\"llvm.cttz.i64\");\n+            let cttz = ccx.intrinsics.get(~\"llvm.cttz.i64\");\n             Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"bswap16\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cttz = ccx.intrinsics.get(&~\"llvm.bswap.i16\");\n+            let cttz = ccx.intrinsics.get(~\"llvm.bswap.i16\");\n             Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr)\n         }\n         ~\"bswap32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cttz = ccx.intrinsics.get(&~\"llvm.bswap.i32\");\n+            let cttz = ccx.intrinsics.get(~\"llvm.bswap.i32\");\n             Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr)\n         }\n         ~\"bswap64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cttz = ccx.intrinsics.get(&~\"llvm.bswap.i64\");\n+            let cttz = ccx.intrinsics.get(~\"llvm.bswap.i64\");\n             Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr)\n         }\n         _ => {\n@@ -955,7 +955,7 @@ pub fn register_foreign_fn(ccx: @crate_ctxt,\n fn abi_of_foreign_fn(ccx: @crate_ctxt, i: @ast::foreign_item)\n     -> ast::foreign_abi {\n     match attr::first_attr_value_str_by_name(i.attrs, ~\"abi\") {\n-      None => match ccx.tcx.items.get(&i.id) {\n+      None => match ccx.tcx.items.get(i.id) {\n         ast_map::node_foreign_item(_, abi, _) => abi,\n         // ??\n         _ => die!(~\"abi_of_foreign_fn: not foreign\")"}, {"sha": "849a718a52e9c6268bb887eccbd20eb976403a14", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -381,7 +381,7 @@ pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let mut bcx = bcx;\n     let ty_visitor_name = special_idents::ty_visitor;\n     assert bcx.ccx().tcx.intrinsic_defs.contains_key_ref(&ty_visitor_name);\n-    let (trait_id, ty) = bcx.ccx().tcx.intrinsic_defs.get(&ty_visitor_name);\n+    let (trait_id, ty) = bcx.ccx().tcx.intrinsic_defs.get(ty_visitor_name);\n     let v = PointerCast(bcx, v, T_ptr(type_of::type_of(bcx.ccx(), ty)));\n     bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, trait_id);\n     build_return(bcx);"}, {"sha": "f5d232363347c32fe28661ee9057b82615db5a8e", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -31,7 +31,7 @@ pub fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id,\n                                 translate: bool)\n     -> ast::def_id {\n     let _icx = ccx.insn_ctxt(\"maybe_instantiate_inline\");\n-    match ccx.external.find(&fn_id) {\n+    match ccx.external.find(fn_id) {\n       Some(Some(node_id)) => {\n         // Already inline\n         debug!(\"maybe_instantiate_inline(%s): already inline as node id %d\","}, {"sha": "1b3e13cddabffe17c4cc8c831e7930283e664606", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -178,7 +178,7 @@ pub fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n \n // Computes the size of the data part of an enum.\n pub fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n-    if cx.enum_sizes.contains_key_ref(&t) { return cx.enum_sizes.get(&t); }\n+    if cx.enum_sizes.contains_key_ref(&t) { return cx.enum_sizes.get(t); }\n     match ty::get(t).sty {\n       ty::ty_enum(tid, ref substs) => {\n         // Compute max(variant sizes)."}, {"sha": "f488c32437c73d0f8618a6f20198961feec4535d", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -308,7 +308,7 @@ pub fn trans_static_method_callee(bcx: block,\n     };\n \n     let mname = if method_id.crate == ast::local_crate {\n-        match bcx.tcx().items.get(&method_id.node) {\n+        match bcx.tcx().items.get(method_id.node) {\n             ast_map::node_trait_method(trait_method, _, _) => {\n                 ast_util::trait_method_to_ty_method(*trait_method).ident\n             }\n@@ -325,7 +325,7 @@ pub fn trans_static_method_callee(bcx: block,\n             name=%s\", method_id, callee_id, ccx.sess.str_of(mname));\n \n     let vtbls = resolve_vtables_in_fn_ctxt(\n-        bcx.fcx, ccx.maps.vtable_map.get(&callee_id));\n+        bcx.fcx, ccx.maps.vtable_map.get(callee_id));\n \n     match /*bad*/copy vtbls[bound_index] {\n         typeck::vtable_static(impl_did, rcvr_substs, rcvr_origins) => {\n@@ -362,7 +362,7 @@ pub fn method_from_methods(ms: ~[@ast::method], name: ast::ident)\n pub fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n                         name: ast::ident) -> ast::def_id {\n     if impl_id.crate == ast::local_crate {\n-        match ccx.tcx.items.get(&impl_id.node) {\n+        match ccx.tcx.items.get(impl_id.node) {\n           ast_map::node_item(@ast::item {\n                 node: ast::item_impl(_, _, _, ref ms),\n                 _\n@@ -379,7 +379,7 @@ pub fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n pub fn method_with_name_or_default(ccx: @crate_ctxt, impl_id: ast::def_id,\n                                    name: ast::ident) -> ast::def_id {\n     if impl_id.crate == ast::local_crate {\n-        match ccx.tcx.items.get(&impl_id.node) {\n+        match ccx.tcx.items.get(impl_id.node) {\n           ast_map::node_item(@ast::item {\n                 node: ast::item_impl(_, _, _, ref ms), _\n           }, _) => {\n@@ -389,7 +389,7 @@ pub fn method_with_name_or_default(ccx: @crate_ctxt, impl_id: ast::def_id,\n               } else {\n                   // Look for a default method\n                   let pmm = ccx.tcx.provided_methods;\n-                  match pmm.find(&impl_id) {\n+                  match pmm.find(impl_id) {\n                       Some(pmis) => {\n                           for pmis.each |pmi| {\n                               if pmi.method_info.ident == name {\n@@ -414,10 +414,10 @@ pub fn method_ty_param_count(ccx: @crate_ctxt, m_id: ast::def_id,\n                              i_id: ast::def_id) -> uint {\n     debug!(\"method_ty_param_count: m_id: %?, i_id: %?\", m_id, i_id);\n     if m_id.crate == ast::local_crate {\n-        match ccx.tcx.items.find(&m_id.node) {\n+        match ccx.tcx.items.find(m_id.node) {\n             Some(ast_map::node_method(m, _, _)) => m.tps.len(),\n             None => {\n-                match ccx.tcx.provided_method_sources.find(&m_id) {\n+                match ccx.tcx.provided_method_sources.find(m_id) {\n                     Some(source) => {\n                         method_ty_param_count(\n                             ccx, source.method_id, source.impl_id)\n@@ -779,7 +779,7 @@ pub fn get_vtable(ccx: @crate_ctxt,\n                -> ValueRef {\n     // XXX: Bad copy.\n     let hash_id = vtable_id(ccx, copy origin);\n-    match ccx.vtables.find(&hash_id) {\n+    match ccx.vtables.find(hash_id) {\n       Some(val) => val,\n       None => match origin {\n         typeck::vtable_static(id, substs, sub_vtables) => {\n@@ -916,7 +916,7 @@ pub fn trans_trait_cast(bcx: block,\n     }\n \n     // Store the vtable into the pair or triple.\n-    let orig = /*bad*/copy ccx.maps.vtable_map.get(&id)[0];\n+    let orig = /*bad*/copy ccx.maps.vtable_map.get(id)[0];\n     let orig = resolve_vtable_in_fn_ctxt(bcx.fcx, orig);\n     let vtable = get_vtable(bcx.ccx(), orig);\n     Store(bcx, vtable, PointerCast(bcx,"}, {"sha": "60b4057d4487a8b7c70d5c0ac9b6f6111cd054ba", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -69,7 +69,7 @@ pub fn monomorphic_fn(ccx: @crate_ctxt,\n            real_substs.map(|s| ty_to_str(ccx.tcx, *s)),\n            substs.map(|s| ty_to_str(ccx.tcx, *s)), hash_id);\n \n-    match ccx.monomorphized.find(&hash_id) {\n+    match ccx.monomorphized.find(hash_id) {\n       Some(val) => {\n         debug!(\"leaving monomorphic fn %s\",\n                ty::item_path_str(ccx.tcx, fn_id));\n@@ -81,7 +81,7 @@ pub fn monomorphic_fn(ccx: @crate_ctxt,\n     let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n     let mut llitem_ty = tpt.ty;\n \n-    let map_node = session::expect(ccx.sess, ccx.tcx.items.find(&fn_id.node),\n+    let map_node = session::expect(ccx.sess, ccx.tcx.items.find(fn_id.node),\n      || fmt!(\"While monomorphizing %?, couldn't find it in the item map \\\n         (may have attempted to monomorphize an item defined in a different \\\n         crate?)\", fn_id));\n@@ -136,7 +136,7 @@ pub fn monomorphic_fn(ccx: @crate_ctxt,\n \n     ccx.stats.n_monos += 1;\n \n-    let depth = option::get_or_default(ccx.monomorphizing.find(&fn_id), 0u);\n+    let depth = option::get_or_default(ccx.monomorphizing.find(fn_id), 0u);\n     // Random cut-off -- code that needs to instantiate the same function\n     // recursively more than ten times can probably safely be assumed to be\n     // causing an infinite expansion."}, {"sha": "02e07e8484abd79f5fa59ceeb08438935569098f", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -54,7 +54,7 @@ pub fn find_reachable(crate_mod: _mod, exp_map2: resolve::ExportMap2,\n \n fn traverse_exports(cx: ctx, mod_id: node_id) -> bool {\n     let mut found_export = false;\n-    match cx.exp_map2.find(&mod_id) {\n+    match cx.exp_map2.find(mod_id) {\n       Some(ref exp2s) => {\n         for (*exp2s).each |e2| {\n             found_export = true;\n@@ -68,7 +68,7 @@ fn traverse_exports(cx: ctx, mod_id: node_id) -> bool {\n \n fn traverse_def_id(cx: ctx, did: def_id) {\n     if did.crate != local_crate { return; }\n-    let n = match cx.tcx.items.find(&did.node) {\n+    let n = match cx.tcx.items.find(did.node) {\n         None => return, // This can happen for self, for example\n         Some(ref n) => (/*bad*/copy *n)\n     };\n@@ -150,7 +150,7 @@ fn traverse_ty(ty: @Ty, cx: ctx, v: visit::vt<ctx>) {\n \n     match ty.node {\n       ty_path(p, p_id) => {\n-        match cx.tcx.def_map.find(&p_id) {\n+        match cx.tcx.def_map.find(p_id) {\n           // Kind of a hack to check this here, but I'm not sure what else\n           // to do\n           Some(def_prim_ty(_)) => { /* do nothing */ }\n@@ -169,7 +169,7 @@ fn traverse_inline_body(cx: ctx, body: blk) {\n     fn traverse_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         match e.node {\n           expr_path(_) => {\n-            match cx.tcx.def_map.find(&e.id) {\n+            match cx.tcx.def_map.find(e.id) {\n                 Some(d) => {\n                   traverse_def_id(cx, def_id_of_def(d));\n                 }\n@@ -179,7 +179,7 @@ fn traverse_inline_body(cx: ctx, body: blk) {\n             }\n           }\n           expr_field(_, _, _) => {\n-            match cx.method_map.find(&e.id) {\n+            match cx.method_map.find(e.id) {\n               Some(typeck::method_map_entry {\n                   origin: typeck::method_static(did),\n                   _\n@@ -190,7 +190,7 @@ fn traverse_inline_body(cx: ctx, body: blk) {\n             }\n           }\n           expr_method_call(*) => {\n-            match cx.method_map.find(&e.id) {\n+            match cx.method_map.find(e.id) {\n               Some(typeck::method_map_entry {\n                   origin: typeck::method_static(did),\n                   _"}, {"sha": "b9a055ad8ab23e02ed57702c110bedb47743b449", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -317,7 +317,7 @@ pub fn emit_calls_to_trait_visit_ty(bcx: block,\n     use syntax::parse::token::special_idents::tydesc;\n     let final = sub_block(bcx, ~\"final\");\n     assert bcx.ccx().tcx.intrinsic_defs.contains_key_ref(&tydesc);\n-    let (_, tydesc_ty) = bcx.ccx().tcx.intrinsic_defs.get(&tydesc);\n+    let (_, tydesc_ty) = bcx.ccx().tcx.intrinsic_defs.get(tydesc);\n     let tydesc_ty = type_of::type_of(bcx.ccx(), tydesc_ty);\n     let r = reflector({\n         visitor_val: visitor_val,"}, {"sha": "72efab0c371c4eecfdbecbbfb0d4d5c3b0558f23", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -87,7 +87,7 @@ pub fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     debug!(\"type_of %?: %?\", t, ty::get(t));\n \n     // Check the cache.\n-    if cx.lltypes.contains_key_ref(&t) { return cx.lltypes.get(&t); }\n+    if cx.lltypes.contains_key_ref(&t) { return cx.lltypes.get(t); }\n \n     // Replace any typedef'd types with their equivalent non-typedef\n     // type. This ensures that all LLVM nominal types that contain"}, {"sha": "350b1393c33336b90291ab222dfbfff38cb7de12", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -53,7 +53,7 @@ pub type ctx = {ccx: @crate_ctxt, uses: ~[mut type_uses]};\n \n pub fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n     -> ~[type_uses] {\n-    match ccx.type_use_cache.find(&fn_id) {\n+    match ccx.type_use_cache.find(fn_id) {\n       Some(uses) => return uses,\n       None => ()\n     }\n@@ -87,7 +87,7 @@ pub fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n         ccx.type_use_cache.insert(fn_id, copy uses);\n         return uses;\n     }\n-    let map_node = match ccx.tcx.items.find(&fn_id_loc.node) {\n+    let map_node = match ccx.tcx.items.find(fn_id_loc.node) {\n         Some(ref x) => (/*bad*/copy *x),\n         None    => ccx.sess.bug(fmt!(\"type_uses_for: unbound item ID %?\",\n                                      fn_id_loc))\n@@ -226,10 +226,10 @@ pub fn node_type_needs(cx: ctx, use_: uint, id: node_id) {\n }\n \n pub fn mark_for_method_call(cx: ctx, e_id: node_id, callee_id: node_id) {\n-    do option::iter(&cx.ccx.maps.method_map.find(&e_id)) |mth| {\n+    do option::iter(&cx.ccx.maps.method_map.find(e_id)) |mth| {\n         match mth.origin {\n           typeck::method_static(did) => {\n-            do cx.ccx.tcx.node_type_substs.find(&callee_id).iter |ts| {\n+            do cx.ccx.tcx.node_type_substs.find(callee_id).iter |ts| {\n                 let type_uses = type_uses_for(cx.ccx, did, ts.len());\n                 for vec::each2(type_uses, *ts) |uses, subst| {\n                     type_needs(cx, *uses, *subst)\n@@ -278,8 +278,8 @@ pub fn mark_for_expr(cx: ctx, e: @expr) {\n         }\n       }\n       expr_path(_) => {\n-        do cx.ccx.tcx.node_type_substs.find(&e.id).iter |ts| {\n-            let id = ast_util::def_id_of_def(cx.ccx.tcx.def_map.get(&e.id));\n+        do cx.ccx.tcx.node_type_substs.find(e.id).iter |ts| {\n+            let id = ast_util::def_id_of_def(cx.ccx.tcx.def_map.get(e.id));\n             let uses_for_ts = type_uses_for(cx.ccx, id, ts.len());\n             for vec::each2(uses_for_ts, *ts) |uses, subst| {\n                 type_needs(cx, *uses, *subst)"}, {"sha": "2bfcecfd2f74e0241f98dc3f9728ebc357d7b851", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -876,7 +876,7 @@ fn mk_t(cx: ctxt, +st: sty) -> t { mk_t_with_id(cx, st, None) }\n // and returns the box as cast to an unsafe ptr (see comments for t above).\n fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n     let key = intern_key { sty: to_unsafe_ptr(&st), o_def_id: o_def_id };\n-    match cx.interner.find(&key) {\n+    match cx.interner.find(key) {\n       Some(t) => unsafe { return cast::reinterpret_cast(&t); },\n       _ => ()\n     }\n@@ -1142,7 +1142,7 @@ pub fn default_arg_mode_for_ty(tcx: ctxt, ty: ty::t) -> ast::rmode {\n // Returns the narrowest lifetime enclosing the evaluation of the expression\n // with id `id`.\n pub fn encl_region(cx: ctxt, id: ast::node_id) -> ty::Region {\n-    match cx.region_map.find(&id) {\n+    match cx.region_map.find(id) {\n       Some(encl_scope) => ty::re_scope(encl_scope),\n       None => ty::re_static\n     }\n@@ -1653,7 +1653,7 @@ pub fn type_is_immediate(ty: t) -> bool {\n }\n \n pub fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n-    match cx.needs_drop_cache.find(&ty) {\n+    match cx.needs_drop_cache.find(ty) {\n       Some(result) => return result,\n       None => {/* fall through */ }\n     }\n@@ -1732,7 +1732,7 @@ pub fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n // that only contain scalars and shared boxes can avoid unwind\n // cleanups.\n pub fn type_needs_unwind_cleanup(cx: ctxt, ty: t) -> bool {\n-    match cx.needs_unwind_cleanup_cache.find(&ty) {\n+    match cx.needs_unwind_cleanup_cache.find(ty) {\n       Some(result) => return result,\n       None => ()\n     }\n@@ -1749,7 +1749,7 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n                               encountered_box: bool) -> bool {\n \n     // Prevent infinite recursion\n-    match tycache.find(&ty) {\n+    match tycache.find(ty) {\n       Some(_) => return false,\n       None => { tycache.insert(ty, ()); }\n     }\n@@ -2011,7 +2011,7 @@ pub fn type_kind(cx: ctxt, ty: t) -> Kind {\n // If `allow_ty_var` is true, then this is a conservative assumption; we\n // assume that type variables *do* have all kinds.\n pub fn type_kind_ext(cx: ctxt, ty: t, allow_ty_var: bool) -> Kind {\n-    match cx.kind_cache.find(&ty) {\n+    match cx.kind_cache.find(ty) {\n       Some(result) => return result,\n       None => {/* fall through */ }\n     }\n@@ -2165,7 +2165,7 @@ pub fn type_kind_ext(cx: ctxt, ty: t, allow_ty_var: bool) -> Kind {\n           // cross-crate inlining code to translate a def-id.\n           assert p.def_id.crate == ast::local_crate;\n \n-          param_bounds_to_kind(cx.ty_param_bounds.get(&p.def_id.node))\n+          param_bounds_to_kind(cx.ty_param_bounds.get(p.def_id.node))\n       }\n \n       // self is a special type parameter that can only appear in traits; it\n@@ -2810,7 +2810,7 @@ pub fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n }\n \n pub fn node_id_to_type_params(cx: ctxt, id: ast::node_id) -> ~[t] {\n-    match cx.node_type_substs.find(&id) {\n+    match cx.node_type_substs.find(id) {\n       None => return ~[],\n       Some(ts) => return ts\n     }\n@@ -2950,7 +2950,7 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: @ast::expr) -> t {\n \n     let unadjusted_ty = expr_ty(cx, expr);\n \n-    return match cx.adjustments.find(&expr.id) {\n+    return match cx.adjustments.find(expr.id) {\n         None => unadjusted_ty,\n \n         Some(adj) => {\n@@ -3054,7 +3054,7 @@ pub fn expr_has_ty_params(cx: ctxt, expr: @ast::expr) -> bool {\n pub fn method_call_bounds(tcx: ctxt, method_map: typeck::method_map,\n                           id: ast::node_id)\n     -> Option<@~[param_bounds]> {\n-    do method_map.find(&id).map |method| {\n+    do method_map.find(id).map |method| {\n         match method.origin {\n           typeck::method_static(did) => {\n             // n.b.: When we encode impl methods, the bounds\n@@ -3081,7 +3081,7 @@ pub fn method_call_bounds(tcx: ctxt, method_map: typeck::method_map,\n }\n \n fn resolve_expr(tcx: ctxt, expr: @ast::expr) -> ast::def {\n-    match tcx.def_map.find(&expr.id) {\n+    match tcx.def_map.find(expr.id) {\n         Some(def) => def,\n         None => {\n             tcx.sess.span_bug(expr.span, fmt!(\n@@ -3335,7 +3335,7 @@ pub fn occurs_check(tcx: ctxt, sp: span, vid: TyVid, rt: t) {\n fn canon<T:Copy cmp::Eq>(tbl: HashMap<ast::node_id, ast::inferable<T>>,\n                          +m0: ast::inferable<T>) -> ast::inferable<T> {\n     match m0 {\n-      ast::infer(id) => match tbl.find(&id) {\n+      ast::infer(id) => match tbl.find(id) {\n         None => m0,\n         Some(ref m1) => {\n             let cm1 = canon(tbl, (*m1));\n@@ -3597,7 +3597,7 @@ pub fn store_trait_methods(cx: ctxt, id: ast::node_id, ms: @~[method]) {\n \n pub fn provided_trait_methods(cx: ctxt, id: ast::def_id) -> ~[ast::ident] {\n     if is_local(id) {\n-        match cx.items.find(&id.node) {\n+        match cx.items.find(id.node) {\n             Some(ast_map::node_item(@ast::item {\n                         node: item_trait(_, _, ref ms),\n                         _\n@@ -3617,7 +3617,7 @@ pub fn trait_supertraits(cx: ctxt,\n                          id: ast::def_id)\n                       -> @~[InstantiatedTraitRef] {\n     // Check the cache.\n-    match cx.supertraits.find(&id) {\n+    match cx.supertraits.find(id) {\n         Some(instantiated_trait_info) => { return instantiated_trait_info; }\n         None => {}  // Continue.\n     }\n@@ -3646,7 +3646,7 @@ pub fn trait_supertraits(cx: ctxt,\n }\n \n pub fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n-    match cx.trait_method_cache.find(&id) {\n+    match cx.trait_method_cache.find(id) {\n       // Local traits are supposed to have been added explicitly.\n       Some(ms) => ms,\n       _ => {\n@@ -3680,7 +3680,7 @@ pub fn impl_traits(cx: ctxt, id: ast::def_id, vstore: vstore) -> ~[t] {\n \n     if id.crate == ast::local_crate {\n         debug!(\"(impl_traits) searching for trait impl %?\", id);\n-        match cx.items.find(&id.node) {\n+        match cx.items.find(id.node) {\n            Some(ast_map::node_item(@ast::item {\n                         node: ast::item_impl(_, opt_trait, _, _),\n                         _},\n@@ -3716,7 +3716,7 @@ fn struct_ctor_id(cx: ctxt, struct_did: ast::def_id) -> Option<ast::def_id> {\n         cx.sess.unimpl(~\"constructor ID of cross-crate tuple structs\");\n     }\n \n-    match cx.items.find(&struct_did.node) {\n+    match cx.items.find(struct_did.node) {\n         Some(ast_map::node_item(item, _)) => {\n             match item.node {\n                 ast::item_struct(struct_def, _) => {\n@@ -3782,13 +3782,13 @@ impl DtorKind {\n /* If struct_id names a struct with a dtor, return Some(the dtor's id).\n    Otherwise return none. */\n pub fn ty_dtor(cx: ctxt, struct_id: def_id) -> DtorKind {\n-    match cx.destructor_for_type.find(&struct_id) {\n+    match cx.destructor_for_type.find(struct_id) {\n         Some(method_def_id) => return TraitDtor(method_def_id),\n         None => {}  // Continue.\n     }\n \n     if is_local(struct_id) {\n-       match cx.items.find(&struct_id.node) {\n+       match cx.items.find(struct_id.node) {\n            Some(ast_map::node_item(@ast::item {\n                node: ast::item_struct(@ast::struct_def { dtor: Some(ref dtor),\n                                                          _ },\n@@ -3816,7 +3816,7 @@ pub fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n     if id.crate != ast::local_crate {\n         csearch::get_item_path(cx, id)\n     } else {\n-        let node = cx.items.get(&id.node);\n+        let node = cx.items.get(id.node);\n         match node {\n           ast_map::node_item(item, path) => {\n             let item_elt = match item.node {\n@@ -3880,7 +3880,7 @@ pub fn type_is_empty(cx: ctxt, t: t) -> bool {\n }\n \n pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n-    match cx.enum_var_cache.find(&id) {\n+    match cx.enum_var_cache.find(id) {\n       Some(variants) => return variants,\n       _ => { /* fallthrough */ }\n     }\n@@ -3893,7 +3893,7 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n           call eval_const_expr, it should never get called twice for the same\n           expr, since check_enum_variants also updates the enum_var_cache\n          */\n-        match cx.items.get(&id.node) {\n+        match cx.items.get(id.node) {\n           ast_map::node_item(@ast::item {\n                     node: ast::item_enum(ref enum_definition, _),\n                     _\n@@ -3967,7 +3967,7 @@ pub fn enum_variant_with_id(cx: ctxt,\n pub fn lookup_item_type(cx: ctxt,\n                         did: ast::def_id)\n                      -> ty_param_bounds_and_ty {\n-    match cx.tcache.find(&did) {\n+    match cx.tcache.find(did) {\n       Some(tpt) => {\n         // The item is in this crate. The caller should have added it to the\n         // type cache already\n@@ -3993,7 +3993,7 @@ pub fn lookup_field_type(tcx: ctxt,\n         node_id_to_type(tcx, id.node)\n     }\n     else {\n-        match tcx.tcache.find(&id) {\n+        match tcx.tcache.find(id) {\n            Some(tpt) => tpt.ty,\n            None => {\n                let tpt = csearch::get_field_type(tcx, struct_id, id);\n@@ -4009,7 +4009,7 @@ pub fn lookup_field_type(tcx: ctxt,\n // Fails if the id is not bound to a struct.\n pub fn lookup_struct_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n   if did.crate == ast::local_crate {\n-    match cx.items.find(&did.node) {\n+    match cx.items.find(did.node) {\n        Some(ast_map::node_item(i,_)) => {\n          match i.node {\n             ast::item_struct(struct_def, _) => {\n@@ -4214,7 +4214,7 @@ pub fn normalize_ty(cx: ctxt, t: t) -> t {\n         }\n     }\n \n-    match cx.normalized_cache.find(&t) {\n+    match cx.normalized_cache.find(t) {\n       Some(t) => return t,\n       None => ()\n     }\n@@ -4397,8 +4397,8 @@ pub fn count_traits_and_supertraits(tcx: ctxt,\n \n // Given a trait and a type, returns the impl of that type\n pub fn get_impl_id(tcx: ctxt, trait_id: def_id, self_ty: t) -> def_id {\n-    match tcx.trait_impls.find(&trait_id) {\n-        Some(ty_to_impl) => match ty_to_impl.find(&self_ty) {\n+    match tcx.trait_impls.find(trait_id) {\n+        Some(ty_to_impl) => match ty_to_impl.find(self_ty) {\n             Some(the_impl) => the_impl.did,\n             None => // try autoderef!\n                 match deref(tcx, self_ty, false) {"}, {"sha": "4e4fc564c2384666ea73d9e9dabb6494aec04f50", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -211,7 +211,7 @@ pub fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n                 return ty::mk_evec(tcx, mt, vst);\n             }\n             ast::ty_path(path, id) if a_seq_ty.mutbl == ast::m_imm => {\n-                match tcx.def_map.find(&id) {\n+                match tcx.def_map.find(id) {\n                     Some(ast::def_prim_ty(ast::ty_str)) => {\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                         return ty::mk_estr(tcx, vst);\n@@ -273,7 +273,7 @@ pub fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n \n     let tcx = self.tcx();\n \n-    match tcx.ast_ty_to_ty_cache.find(&ast_ty) {\n+    match tcx.ast_ty_to_ty_cache.find(ast_ty) {\n       Some(ty::atttce_resolved(ty)) => return ty,\n       Some(ty::atttce_unresolved) => {\n         tcx.sess.span_fatal(ast_ty.span, ~\"illegal recursive type; \\\n@@ -330,7 +330,7 @@ pub fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n         ty::mk_fn(tcx, fn_decl)\n       }\n       ast::ty_path(path, id) => {\n-        let a_def = match tcx.def_map.find(&id) {\n+        let a_def = match tcx.def_map.find(id) {\n           None => tcx.sess.span_fatal(\n               ast_ty.span, fmt!(\"unbound path %s\",\n                                 path_to_str(path, tcx.sess.intr()))),"}, {"sha": "3e898ce3aa676742c8887104e13c6e0987733304", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -216,7 +216,7 @@ pub fn check_struct_pat_fields(pcx: pat_ctxt,\n     // Typecheck each field.\n     let found_fields = HashMap();\n     for fields.each |field| {\n-        match field_map.find(&field.ident) {\n+        match field_map.find(field.ident) {\n             Some(index) => {\n                 let class_field = class_fields[index];\n                 let field_type = ty::lookup_field_type(tcx,\n@@ -259,7 +259,7 @@ pub fn check_struct_pat(pcx: pat_ctxt, pat_id: ast::node_id, span: span,\n     let class_fields = ty::lookup_struct_fields(tcx, class_id);\n \n     // Check to ensure that the struct is the one specified.\n-    match tcx.def_map.find(&pat_id) {\n+    match tcx.def_map.find(pat_id) {\n         Some(ast::def_struct(supplied_def_id))\n                 if supplied_def_id == class_id => {\n             // OK.\n@@ -300,7 +300,7 @@ pub fn check_struct_like_enum_variant_pat(pcx: pat_ctxt,\n     let tcx = pcx.fcx.ccx.tcx;\n \n     // Find the variant that was specified.\n-    match tcx.def_map.find(&pat_id) {\n+    match tcx.def_map.find(pat_id) {\n         Some(ast::def_variant(found_enum_id, variant_id))\n                 if found_enum_id == enum_id => {\n             // Get the struct fields from this struct-like enum variant.\n@@ -360,7 +360,7 @@ pub fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         fcx.write_ty(pat.id, b_ty);\n       }\n       ast::pat_ident(*) if pat_is_const(tcx.def_map, pat) => {\n-        let const_did = ast_util::def_id_of_def(tcx.def_map.get(&pat.id));\n+        let const_did = ast_util::def_id_of_def(tcx.def_map.get(pat.id));\n         let const_tpt = ty::lookup_item_type(tcx, const_did);\n         fcx.write_ty(pat.id, const_tpt.ty);\n       }\n@@ -386,7 +386,7 @@ pub fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n           }\n         }\n \n-        let canon_id = pcx.map.get(&ast_util::path_to_ident(name));\n+        let canon_id = pcx.map.get(ast_util::path_to_ident(name));\n         if canon_id != pat.id {\n             let ct = fcx.local_ty(pat.span, canon_id);\n             demand::eqtype(fcx, pat.span, ct, typ);"}, {"sha": "5a12f9fc3a1968e567b03928cba730c3dc4fc418", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -323,15 +323,14 @@ pub impl LookupContext {\n         // If the method being called is associated with a trait, then\n         // find all the impls of that trait.  Each of those are\n         // candidates.\n-        let opt_applicable_traits = self.fcx.ccx.trait_map.find(\n-            &self.expr.id);\n+        let opt_applicable_traits = self.fcx.ccx.trait_map.find(self.expr.id);\n         for opt_applicable_traits.each |applicable_traits| {\n             for applicable_traits.each |trait_did| {\n                 let coherence_info = self.fcx.ccx.coherence_info;\n \n                 // Look for explicit implementations.\n                 let opt_impl_infos =\n-                    coherence_info.extension_methods.find(trait_did);\n+                    coherence_info.extension_methods.find(*trait_did);\n                 for opt_impl_infos.each |impl_infos| {\n                     for impl_infos.each |impl_info| {\n                         self.push_candidates_from_impl(\n@@ -340,7 +339,7 @@ pub impl LookupContext {\n                 }\n \n                 // Look for default methods.\n-                match self.tcx().provided_methods.find(trait_did) {\n+                match self.tcx().provided_methods.find(*trait_did) {\n                     Some(methods) => {\n                         self.push_candidates_from_provided_methods(\n                             &self.extension_candidates, self_ty, *trait_did,\n@@ -361,7 +360,7 @@ pub impl LookupContext {\n \n         let tcx = self.tcx();\n         let mut next_bound_idx = 0; // count only trait bounds\n-        let bounds = tcx.ty_param_bounds.get(&param_ty.def_id.node);\n+        let bounds = tcx.ty_param_bounds.get(param_ty.def_id.node);\n \n         for vec::each(*bounds) |bound| {\n             let bound_trait_ty = match *bound {\n@@ -608,7 +607,7 @@ pub impl LookupContext {\n \n     fn push_inherent_impl_candidates_for_type(did: def_id) {\n         let opt_impl_infos =\n-            self.fcx.ccx.coherence_info.inherent_methods.find(&did);\n+            self.fcx.ccx.coherence_info.inherent_methods.find(did);\n         for opt_impl_infos.each |impl_infos| {\n             for impl_infos.each |impl_info| {\n                 self.push_candidates_from_impl(\n@@ -1233,7 +1232,7 @@ pub impl LookupContext {\n \n     fn report_static_candidate(&self, idx: uint, did: def_id) {\n         let span = if did.crate == ast::local_crate {\n-            match self.tcx().items.find(&did.node) {\n+            match self.tcx().items.find(did.node) {\n               Some(ast_map::node_method(m, _, _)) => m.span,\n               _ => die!(fmt!(\"report_static_candidate: bad item %?\", did))\n             }"}, {"sha": "f3abfe3282a3131a53bab4ea1e554b6e2c667895", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -405,7 +405,7 @@ pub fn check_fn(ccx: @crate_ctxt,\n             assign(self_info.self_id, Some(self_info.self_ty));\n             debug!(\"self is assigned to %s\",\n                    fcx.infcx().ty_to_str(\n-                       fcx.inh.locals.get(&self_info.self_id)));\n+                       fcx.inh.locals.get(self_info.self_id)));\n         }\n \n         // Add formal parameters.\n@@ -438,7 +438,7 @@ pub fn check_fn(ccx: @crate_ctxt,\n             debug!(\"Local variable %s is assigned type %s\",\n                    fcx.pat_to_str(local.node.pat),\n                    fcx.infcx().ty_to_str(\n-                       fcx.inh.locals.get(&local.node.id)));\n+                       fcx.inh.locals.get(local.node.id)));\n             visit::visit_local(local, e, v);\n         };\n \n@@ -451,7 +451,7 @@ pub fn check_fn(ccx: @crate_ctxt,\n                 debug!(\"Pattern binding %s is assigned to %s\",\n                        tcx.sess.str_of(path.idents[0]),\n                        fcx.infcx().ty_to_str(\n-                           fcx.inh.locals.get(&p.id)));\n+                           fcx.inh.locals.get(p.id)));\n               }\n               _ => {}\n             }\n@@ -501,7 +501,7 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n \n     for fields.each |p| {\n         let (id, sp) = *p;\n-        match field_names.find(&id) {\n+        match field_names.find(id) {\n           Some(orig_sp) => {\n             tcx.sess.span_err(sp, fmt!(\"Duplicate field \\\n                                    name %s in record type declaration\",\n@@ -558,7 +558,7 @@ pub fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         check_bare_fn(ccx, decl, (*body), it.id, None);\n       }\n       ast::item_impl(_, _, ty, ms) => {\n-        let rp = ccx.tcx.region_paramd_items.find(&it.id);\n+        let rp = ccx.tcx.region_paramd_items.find(it.id);\n         debug!(\"item_impl %s with id %d rp %?\",\n                ccx.tcx.sess.str_of(it.ident), it.id, rp);\n         let self_ty = ccx.to_ty(rscope::type_rscope(rp), ty);\n@@ -664,7 +664,7 @@ pub impl @fn_ctxt {\n     fn tag() -> ~str { fmt!(\"%x\", ptr::addr_of(&(*self)) as uint) }\n \n     fn local_ty(span: span, nid: ast::node_id) -> ty::t {\n-        match self.inh.locals.find(&nid) {\n+        match self.inh.locals.find(nid) {\n             Some(t) => t,\n             None => {\n                 self.tcx().sess.span_bug(\n@@ -740,7 +740,7 @@ pub impl @fn_ctxt {\n     }\n \n     fn expr_ty(ex: @ast::expr) -> ty::t {\n-        match self.inh.node_types.find(&ex.id) {\n+        match self.inh.node_types.find(ex.id) {\n             Some(t) => t,\n             None => {\n                 self.tcx().sess.bug(\n@@ -750,7 +750,7 @@ pub impl @fn_ctxt {\n         }\n     }\n     fn node_ty(id: ast::node_id) -> ty::t {\n-        match self.inh.node_types.find(&id) {\n+        match self.inh.node_types.find(id) {\n             Some(t) => t,\n             None => {\n                 self.tcx().sess.bug(\n@@ -763,7 +763,7 @@ pub impl @fn_ctxt {\n         }\n     }\n     fn node_ty_substs(id: ast::node_id) -> ty::substs {\n-        match self.inh.node_type_substs.find(&id) {\n+        match self.inh.node_type_substs.find(id) {\n             Some(ref ts) => (/*bad*/copy *ts),\n             None => {\n                 self.tcx().sess.bug(\n@@ -776,7 +776,7 @@ pub impl @fn_ctxt {\n         }\n     }\n     fn opt_node_ty_substs(id: ast::node_id) -> Option<ty::substs> {\n-        self.inh.node_type_substs.find(&id)\n+        self.inh.node_type_substs.find(id)\n     }\n \n \n@@ -1001,8 +1001,8 @@ pub fn impl_self_ty(vcx: &VtableContext,\n     let tcx = vcx.tcx();\n \n     let {n_tps, region_param, raw_ty} = if did.crate == ast::local_crate {\n-        let region_param = tcx.region_paramd_items.find(&did.node);\n-        match tcx.items.find(&did.node) {\n+        let region_param = tcx.region_paramd_items.find(did.node);\n+        match tcx.items.find(did.node) {\n           Some(ast_map::node_item(@ast::item {\n                   node: ast::item_impl(ref ts, _, st, _),\n                   _\n@@ -1698,7 +1698,7 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         // Typecheck each field.\n         for ast_fields.each |field| {\n-            match class_field_map.find(&field.node.ident) {\n+            match class_field_map.find(field.node.ident) {\n                 None => {\n                     tcx.sess.span_err(\n                         field.span,\n@@ -1734,7 +1734,7 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 let mut missing_fields = ~[];\n                 for field_types.each |class_field| {\n                     let name = class_field.ident;\n-                    let (_, seen) = class_field_map.get(&name);\n+                    let (_, seen) = class_field_map.get(name);\n                     if !seen {\n                         missing_fields.push(\n                             ~\"`\" + tcx.sess.str_of(name) + ~\"`\");\n@@ -1769,8 +1769,8 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let type_parameter_count, region_parameterized, raw_type;\n         if class_id.crate == ast::local_crate {\n             region_parameterized =\n-                tcx.region_paramd_items.find(&class_id.node);\n-            match tcx.items.find(&class_id.node) {\n+                tcx.region_paramd_items.find(class_id.node);\n+            match tcx.items.find(class_id.node) {\n                 Some(ast_map::node_item(@ast::item {\n                         node: ast::item_struct(_, ref type_parameters),\n                         _\n@@ -1852,8 +1852,8 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let type_parameter_count, region_parameterized, raw_type;\n         if enum_id.crate == ast::local_crate {\n             region_parameterized =\n-                tcx.region_paramd_items.find(&enum_id.node);\n-            match tcx.items.find(&enum_id.node) {\n+                tcx.region_paramd_items.find(enum_id.node);\n+            match tcx.items.find(enum_id.node) {\n                 Some(ast_map::node_item(@ast::item {\n                         node: ast::item_enum(_, ref type_parameters),\n                         _\n@@ -2435,7 +2435,7 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n       }\n       ast::expr_struct(path, ref fields, base_expr) => {\n         // Resolve the path.\n-        match tcx.def_map.find(&id) {\n+        match tcx.def_map.find(id) {\n             Some(ast::def_struct(type_def_id)) => {\n                 check_struct_constructor(fcx, id, expr.span, type_def_id,\n                                          (/*bad*/copy *fields), base_expr);\n@@ -2532,7 +2532,7 @@ pub fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n     }\n \n     let region =\n-        ty::re_scope(tcx.region_map.get(&local.node.id));\n+        ty::re_scope(tcx.region_map.get(local.node.id));\n     let pcx = pat_ctxt {\n         fcx: fcx,\n         map: pat_id_map(tcx.def_map, local.node.pat),\n@@ -2633,7 +2633,7 @@ pub fn check_const(ccx: @crate_ctxt,\n                    id: ast::node_id) {\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n     let fcx = blank_fn_ctxt(ccx, rty, e.id);\n-    let declty = fcx.ccx.tcx.tcache.get(&local_def(id)).ty;\n+    let declty = fcx.ccx.tcx.tcache.get(local_def(id)).ty;\n     check_const_with_ty(fcx, _sp, e, declty);\n }\n \n@@ -2984,7 +2984,7 @@ pub fn may_break(cx: ty::ctxt, id: ast::node_id, b: ast::blk) -> bool {\n     (block_query(b, |e| {\n         match e.node {\n             ast::expr_break(Some(_)) =>\n-                match cx.def_map.find(&e.id) {\n+                match cx.def_map.find(e.id) {\n                     Some(ast::def_label(loop_id)) if id == loop_id => true,\n                     _ => false,\n                 },\n@@ -3080,8 +3080,8 @@ pub fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n           let ty_visitor_name = tcx.sess.ident_of(~\"TyVisitor\");\n           assert tcx.intrinsic_defs.contains_key_ref(&tydesc_name);\n           assert ccx.tcx.intrinsic_defs.contains_key_ref(&ty_visitor_name);\n-          let (_, tydesc_ty) = tcx.intrinsic_defs.get(&tydesc_name);\n-          let (_, visitor_trait) = tcx.intrinsic_defs.get(&ty_visitor_name);\n+          let (_, tydesc_ty) = tcx.intrinsic_defs.get(tydesc_name);\n+          let (_, visitor_trait) = tcx.intrinsic_defs.get(ty_visitor_name);\n           let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {ty: tydesc_ty,\n                                                    mutbl: ast::m_imm});\n           (0u, ~[arg(ast::by_val, td_ptr),"}, {"sha": "9ae55d4556b15bc1b99d691de168a25e2efb160e", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -181,7 +181,7 @@ pub fn visit_block(b: ast::blk, &&rcx: @rcx, v: rvt) {\n pub fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n     debug!(\"visit_expr(e=%s)\", rcx.fcx.expr_to_str(expr));\n \n-    for rcx.fcx.inh.adjustments.find(&expr.id).each |adjustment| {\n+    for rcx.fcx.inh.adjustments.find(expr.id).each |adjustment| {\n         for adjustment.autoref.each |autoref| {\n             guarantor::for_autoref(rcx, expr, *adjustment, autoref);\n         }\n@@ -327,7 +327,7 @@ pub fn constrain_auto_ref(rcx: @rcx, expr: @ast::expr) {\n \n     debug!(\"constrain_auto_ref(expr=%s)\", rcx.fcx.expr_to_str(expr));\n \n-    let adjustment = rcx.fcx.inh.adjustments.find(&expr.id);\n+    let adjustment = rcx.fcx.inh.adjustments.find(expr.id);\n     let region = match adjustment {\n         Some(@ty::AutoAdjustment { autoref: Some(ref auto_ref), _ }) => {\n             auto_ref.region\n@@ -725,7 +725,7 @@ pub mod guarantor {\n         let mut expr_ct = categorize_unadjusted(rcx, expr);\n         debug!(\"before adjustments, cat=%?\", expr_ct.cat);\n \n-        for rcx.fcx.inh.adjustments.find(&expr.id).each |adjustment| {\n+        for rcx.fcx.inh.adjustments.find(expr.id).each |adjustment| {\n             debug!(\"adjustment=%?\", adjustment);\n \n             expr_ct = apply_autoderefs("}, {"sha": "18a4f20d031b5be7bbe5ccd6360394287f8d4166", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -194,7 +194,7 @@ pub fn lookup_vtable(vcx: &VtableContext,\n     match ty::get(ty).sty {\n         ty::ty_param(param_ty {idx: n, def_id: did}) => {\n             let mut n_bound = 0;\n-            let bounds = tcx.ty_param_bounds.get(&did.node);\n+            let bounds = tcx.ty_param_bounds.get(did.node);\n             for ty::iter_bound_traits_and_supertraits(\n                 tcx, bounds) |ity| {\n                 debug!(\"checking bounds trait %?\",\n@@ -255,7 +255,7 @@ pub fn lookup_vtable(vcx: &VtableContext,\n \n             let mut impls_seen = HashMap();\n \n-            match vcx.ccx.coherence_info.extension_methods.find(&trait_id) {\n+            match vcx.ccx.coherence_info.extension_methods.find(trait_id) {\n                 None => {\n                     // Nothing found. Continue.\n                 }\n@@ -525,7 +525,7 @@ pub fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n       ast::expr_path(*) => {\n         match fcx.opt_node_ty_substs(ex.id) {\n           Some(ref substs) => {\n-              let def = cx.tcx.def_map.get(&ex.id);\n+              let def = cx.tcx.def_map.get(ex.id);\n             let did = ast_util::def_id_of_def(def);\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n             debug!(\"early resolve expr: def %? %?, %?, %?\", ex.id, did, def,"}, {"sha": "64ea45c8704001cf44747ddf56a35dc698c007e4", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -55,7 +55,7 @@ fn resolve_type_vars_in_type(fcx: @fn_ctxt, sp: span, typ: ty::t)\n fn resolve_method_map_entry(fcx: @fn_ctxt, sp: span, id: ast::node_id)\n {\n     // Resolve any method map entry\n-    match fcx.ccx.method_map.find(&id) {\n+    match fcx.ccx.method_map.find(id) {\n         None => {}\n         Some(ref mme) => {\n             for resolve_type_vars_in_type(fcx, sp, mme.self_arg.ty).each |t| {\n@@ -77,7 +77,7 @@ fn resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span, id: ast::node_id)\n     let fcx = wbcx.fcx, tcx = fcx.ccx.tcx;\n \n     // Resolve any borrowings for the node with id `id`\n-    match fcx.inh.adjustments.find(&id) {\n+    match fcx.inh.adjustments.find(id) {\n         None => (),\n         Some(adj) => {\n             let resolved_autoref = match adj.autoref {"}, {"sha": "5ad8fd4c8208ce311fcb37619759f493743ef2e8", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -236,8 +236,7 @@ pub impl CoherenceChecker {\n     }\n \n     fn check_implementation(item: @item, associated_traits: ~[@trait_ref]) {\n-        let self_type = self.crate_context.tcx.tcache.get(\n-            &local_def(item.id));\n+        let self_type = self.crate_context.tcx.tcache.get(local_def(item.id));\n \n         // If there are no traits, then this implementation must have a\n         // base type.\n@@ -355,7 +354,7 @@ pub impl CoherenceChecker {\n                 };\n \n             let pmm = self.crate_context.tcx.provided_methods;\n-            match pmm.find(&local_def(impl_id)) {\n+            match pmm.find(local_def(impl_id)) {\n                 Some(mis) => {\n                     // If the trait already has an entry in the\n                     // provided_methods_map, we just need to add this\n@@ -383,7 +382,7 @@ pub impl CoherenceChecker {\n     fn add_inherent_method(base_def_id: def_id, implementation: @Impl) {\n         let implementation_list;\n         match self.crate_context.coherence_info.inherent_methods\n-                  .find(&base_def_id) {\n+                  .find(base_def_id) {\n             None => {\n                 implementation_list = @DVec();\n                 self.crate_context.coherence_info.inherent_methods\n@@ -400,7 +399,7 @@ pub impl CoherenceChecker {\n     fn add_trait_method(trait_id: def_id, implementation: @Impl) {\n         let implementation_list;\n         match self.crate_context.coherence_info.extension_methods\n-                  .find(&trait_id) {\n+                  .find(trait_id) {\n             None => {\n                 implementation_list = @DVec();\n                 self.crate_context.coherence_info.extension_methods\n@@ -463,7 +462,7 @@ pub impl CoherenceChecker {\n         debug!(\"Adding impl %? of %? for %s\",\n                the_impl.did, trait_t,\n                ty_to_str(self.crate_context.tcx, self_t));\n-        match self.crate_context.tcx.trait_impls.find(&trait_t) {\n+        match self.crate_context.tcx.trait_impls.find(trait_t) {\n             None => {\n                 let m = HashMap();\n                 m.insert(self_t, the_impl);\n@@ -481,7 +480,7 @@ pub impl CoherenceChecker {\n         let coherence_info = &self.crate_context.coherence_info;\n         let extension_methods = &coherence_info.extension_methods;\n \n-        match extension_methods.find(&trait_def_id) {\n+        match extension_methods.find(trait_def_id) {\n             Some(impls) => {\n                 for uint::range(0, impls.len()) |i| {\n                     f(impls[i]);\n@@ -613,7 +612,7 @@ pub impl CoherenceChecker {\n \n     fn get_self_type_for_implementation(implementation: @Impl)\n                                      -> ty_param_bounds_and_ty {\n-        return self.crate_context.tcx.tcache.get(&implementation.did);\n+        return self.crate_context.tcx.tcache.get(implementation.did);\n     }\n \n     // Privileged scope checking\n@@ -628,7 +627,7 @@ pub impl CoherenceChecker {\n                     item_impl(_, opt_trait, _, _) => {\n                         let mut ok = false;\n                         match self.base_type_def_ids.find(\n-                            &local_def(item.id)) {\n+                            local_def(item.id)) {\n \n                             None => {\n                                 // Nothing to do.\n@@ -702,7 +701,7 @@ pub impl CoherenceChecker {\n \n     fn trait_ref_to_trait_def_id(trait_ref: @trait_ref) -> def_id {\n         let def_map = self.crate_context.tcx.def_map;\n-        let trait_def = def_map.get(&trait_ref.ref_id);\n+        let trait_def = def_map.get(trait_ref.ref_id);\n         let trait_id = def_id_of_def(trait_def);\n         return trait_id;\n     }\n@@ -775,7 +774,7 @@ pub impl CoherenceChecker {\n \n                     match self.crate_context.tcx\n                               .provided_methods\n-                              .find(&local_def(item.id)) {\n+                              .find(local_def(item.id)) {\n                         None => {\n                             debug!(\"(creating impl) trait with node_id `%d` \\\n                                     has no provided methods\", trait_did.node);\n@@ -809,7 +808,7 @@ pub impl CoherenceChecker {\n \n     fn span_of_impl(implementation: @Impl) -> span {\n         assert implementation.did.crate == local_crate;\n-        match self.crate_context.tcx.items.find(&implementation.did.node) {\n+        match self.crate_context.tcx.items.find(implementation.did.node) {\n             Some(node_item(item, _)) => {\n                 return item.span;\n             }\n@@ -837,7 +836,7 @@ pub impl CoherenceChecker {\n \n             // Make sure we don't visit the same implementation\n             // multiple times.\n-            match impls_seen.find(&implementation.did) {\n+            match impls_seen.find(implementation.did) {\n                 None => {\n                     // Good. Continue.\n                     impls_seen.insert(implementation.did, ());\n@@ -989,7 +988,7 @@ pub impl CoherenceChecker {\n         let coherence_info = &self.crate_context.coherence_info;\n         let tcx = self.crate_context.tcx;\n         let drop_trait = tcx.lang_items.drop_trait();\n-        let impls_opt = coherence_info.extension_methods.find(&drop_trait);\n+        let impls_opt = coherence_info.extension_methods.find(drop_trait);\n \n         let impls;\n         match impls_opt {\n@@ -1014,7 +1013,7 @@ pub impl CoherenceChecker {\n                 _ => {\n                     // Destructors only work on nominal types.\n                     if impl_info.did.crate == ast::local_crate {\n-                        match tcx.items.find(&impl_info.did.node) {\n+                        match tcx.items.find(impl_info.did.node) {\n                             Some(ast_map::node_item(@ref item, _)) => {\n                                 tcx.sess.span_err((*item).span,\n                                                   ~\"the Drop trait may only \\"}, {"sha": "32d924891886aac8fe29d8304b0766a755883a87", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -130,7 +130,7 @@ pub impl @crate_ctxt: ast_conv {\n         if id.crate != ast::local_crate {\n             csearch::get_type(self.tcx, id)\n         } else {\n-            match self.tcx.items.find(&id.node) {\n+            match self.tcx.items.find(id.node) {\n               Some(ast_map::node_item(item, _)) => {\n                 ty_of_item(self, item)\n               }\n@@ -290,8 +290,8 @@ pub fn ensure_trait_methods(ccx: @crate_ctxt,\n \n \n     let tcx = ccx.tcx;\n-    let region_paramd = tcx.region_paramd_items.find(&id);\n-    match tcx.items.get(&id) {\n+    let region_paramd = tcx.region_paramd_items.find(id);\n+    match tcx.items.get(id) {\n       ast_map::node_item(@ast::item {\n                 node: ast::item_trait(ref params, _, ref ms),\n                 _\n@@ -521,7 +521,7 @@ pub fn check_methods_against_trait(ccx: @crate_ctxt,\n         // trait ref. Otherwise, we will potentially overwrite the types of\n         // the methods within the trait with bogus results. (See issue #3903.)\n \n-        match tcx.items.find(&did.node) {\n+        match tcx.items.find(did.node) {\n             Some(ast_map::node_item(item, _)) => {\n                 let tpt = ty_of_item(ccx, item);\n                 ensure_trait_methods(ccx, did.node, tpt.ty);\n@@ -616,7 +616,7 @@ pub fn ensure_no_ty_param_bounds(ccx: @crate_ctxt,\n \n pub fn convert(ccx: @crate_ctxt, it: @ast::item) {\n     let tcx = ccx.tcx;\n-    let rp = tcx.region_paramd_items.find(&it.id);\n+    let rp = tcx.region_paramd_items.find(it.id);\n     debug!(\"convert: item %s with id %d rp %?\",\n            tcx.sess.str_of(it.ident), it.id, rp);\n     match /*bad*/copy it.node {\n@@ -740,7 +740,7 @@ pub fn convert_struct(ccx: @crate_ctxt,\n                             arg {\n                                 mode: ast::expl(ast::by_copy),\n                                 ty: ccx.tcx.tcache.get\n-                                        (&local_def(field.node.id)).ty\n+                                        (local_def(field.node.id)).ty\n                             }\n                         },\n                         output: selfty\n@@ -830,11 +830,11 @@ pub fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n \n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n-    match tcx.tcache.find(&def_id) {\n+    match tcx.tcache.find(def_id) {\n       Some(tpt) => return tpt,\n       _ => {}\n     }\n-    let rp = tcx.region_paramd_items.find(&it.id);\n+    let rp = tcx.region_paramd_items.find(it.id);\n     match /*bad*/copy it.node {\n       ast::item_const(t, _) => {\n         let typ = ccx.to_ty(empty_rscope, t);\n@@ -859,12 +859,12 @@ pub fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n         return tpt;\n       }\n       ast::item_ty(t, tps) => {\n-        match tcx.tcache.find(&local_def(it.id)) {\n+        match tcx.tcache.find(local_def(it.id)) {\n           Some(tpt) => return tpt,\n           None => { }\n         }\n \n-        let rp = tcx.region_paramd_items.find(&it.id);\n+        let rp = tcx.region_paramd_items.find(it.id);\n         let tpt = {\n             let ty = {\n                 let t0 = ccx.to_ty(type_rscope(rp), t);\n@@ -978,7 +978,7 @@ pub fn compute_bounds(ccx: @crate_ctxt,\n pub fn ty_param_bounds(ccx: @crate_ctxt,\n                        params: ~[ast::ty_param]) -> @~[ty::param_bounds] {\n     @do params.map |param| {\n-        match ccx.tcx.ty_param_bounds.find(&param.id) {\n+        match ccx.tcx.ty_param_bounds.find(param.id) {\n           Some(bs) => bs,\n           None => {\n             let bounds = compute_bounds(ccx, param.bounds);"}, {"sha": "1a8e25239b34a28f40b4ccdb6ecf917ed7688e72", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -912,7 +912,7 @@ pub impl RegionVarBindings {\n         -> cres<Region> {\n \n         let vars = TwoRegions { a: a, b: b };\n-        match combines.find(&vars) {\n+        match combines.find(vars) {\n           Some(c) => Ok(re_infer(ReVar(c))),\n           None => {\n             let c = self.new_region_var(span);"}, {"sha": "d292f04caa4066d23eb68f25b8758c85045d9415", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -225,7 +225,7 @@ pub fn write_substs_to_tcx(tcx: ty::ctxt,\n }\n \n pub fn lookup_def_tcx(tcx: ty::ctxt, sp: span, id: ast::node_id) -> ast::def {\n-    match tcx.def_map.find(&id) {\n+    match tcx.def_map.find(id) {\n       Some(x) => x,\n       _ => {\n         tcx.sess.span_fatal(sp, ~\"internal error looking up a definition\")\n@@ -325,7 +325,7 @@ fn check_main_fn_ty(ccx: @crate_ctxt,\n     let main_t = ty::node_id_to_type(tcx, main_id);\n     match ty::get(main_t).sty {\n         ty::ty_fn(ref fn_ty) => {\n-            match tcx.items.find(&main_id) {\n+            match tcx.items.find(main_id) {\n                 Some(ast_map::node_item(it,_)) => {\n                     match it.node {\n                         ast::item_fn(_, _, ref ps, _)"}, {"sha": "2ed2d3ea5d7fe255bfe49d4a4cc448a8bf6656b0", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -67,7 +67,7 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n                             -> (~str, Option<span>) {\n     return match region {\n       re_scope(node_id) => {\n-        match cx.items.find(&node_id) {\n+        match cx.items.find(node_id) {\n           Some(ast_map::node_block(ref blk)) => {\n             explain_span(cx, \"block\", (*blk).span)\n           }\n@@ -105,7 +105,7 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n                     bound_region_to_str(cx, br))\n         };\n \n-        match cx.items.find(&id) {\n+        match cx.items.find(id) {\n           Some(ast_map::node_block(ref blk)) => {\n             let (msg, opt_span) = explain_span(cx, \"block\", (*blk).span);\n             (fmt!(\"%s %s\", prefix, msg), opt_span)\n@@ -154,7 +154,7 @@ pub fn bound_region_to_str_adorned(cx: ctxt, prefix: &str,\n }\n \n pub fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n-    match cx.items.find(&node_id) {\n+    match cx.items.find(node_id) {\n       Some(ast_map::node_block(ref blk)) => {\n         fmt!(\"<block at %s>\",\n              cx.sess.codemap.span_to_str((*blk).span))"}, {"sha": "0e70900520d2ceeac3083de98c4ed70513467c05", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -116,7 +116,7 @@ fn parse_item_attrs<T:Owned>(\n     id: doc::AstId,\n     parse_attrs: fn~(a: ~[ast::attribute]) -> T) -> T {\n     do astsrv::exec(srv) |move parse_attrs, ctxt| {\n-        let attrs = match ctxt.ast_map.get(&id) {\n+        let attrs = match ctxt.ast_map.get(id) {\n           ast_map::node_item(item, _) => copy item.attrs,\n           ast_map::node_foreign_item(item, _, _) => copy item.attrs,\n           _ => die!(~\"parse_item_attrs: not an item\")\n@@ -170,7 +170,7 @@ fn fold_enum(\n             let desc = {\n                 let variant = copy variant;\n                 do astsrv::exec(srv.clone()) |ctxt| {\n-                    match ctxt.ast_map.get(&doc_id) {\n+                    match ctxt.ast_map.get(doc_id) {\n                         ast_map::node_item(@ast::item {\n                             node: ast::item_enum(ref enum_definition, _), _\n                         }, _) => {\n@@ -234,7 +234,7 @@ fn merge_method_attrs(\n \n     // Create an assoc list from method name to attributes\n     let attrs: ~[(~str, Option<~str>)] = do astsrv::exec(srv) |ctxt| {\n-        match ctxt.ast_map.get(&item_id) {\n+        match ctxt.ast_map.get(item_id) {\n           ast_map::node_item(@ast::item {\n             node: ast::item_trait(_, _, ref methods), _\n           }, _) => {"}, {"sha": "f039bb74583e56a8e1cbcb6d828d4bd779b66bdd", "filename": "src/librustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_hidden_pass.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -56,7 +56,7 @@ fn is_hidden(srv: astsrv::Srv, doc: doc::ItemDoc) -> bool {\n \n     let id = doc.id;\n     do astsrv::exec(srv) |ctxt| {\n-        let attrs = match ctxt.ast_map.get(&id) {\n+        let attrs = match ctxt.ast_map.get(id) {\n           ast_map::node_item(item, _) => copy item.attrs,\n           _ => ~[]\n         };"}, {"sha": "4b47b71449af2e06cfea267fbd2f90ccb7cdc5a5", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -59,7 +59,7 @@ fn is_visible(srv: astsrv::Srv, doc: doc::ItemDoc) -> bool {\n     let id = doc.id;\n \n     do astsrv::exec(srv) |ctxt| {\n-        match ctxt.ast_map.get(&id) {\n+        match ctxt.ast_map.get(id) {\n             ast_map::node_item(item, _) => {\n                 item.vis == ast::public\n             }"}, {"sha": "4ab40530cfb875ff5f8ef5c84f30b788d90597b4", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -68,7 +68,7 @@ fn fold_fn(\n \n fn get_fn_sig(srv: astsrv::Srv, fn_id: doc::AstId) -> Option<~str> {\n     do astsrv::exec(srv) |ctxt| {\n-        match ctxt.ast_map.get(&fn_id) {\n+        match ctxt.ast_map.get(fn_id) {\n           ast_map::node_item(@ast::item {\n             ident: ident,\n             node: ast::item_fn(ref decl, _, ref tys, _), _\n@@ -107,7 +107,7 @@ fn fold_const(\n         sig: Some({\n             let doc = copy doc;\n             do astsrv::exec(srv) |ctxt| {\n-                match ctxt.ast_map.get(&doc.id()) {\n+                match ctxt.ast_map.get(doc.id()) {\n                     ast_map::node_item(@ast::item {\n                         node: ast::item_const(ty, _), _\n                     }, _) => {\n@@ -138,7 +138,7 @@ fn fold_enum(\n             let sig = {\n                 let variant = copy *variant;\n                 do astsrv::exec(srv.clone()) |copy variant, ctxt| {\n-                    match ctxt.ast_map.get(&doc_id) {\n+                    match ctxt.ast_map.get(doc_id) {\n                         ast_map::node_item(@ast::item {\n                             node: ast::item_enum(ref enum_definition, _), _\n                         }, _) => {\n@@ -199,7 +199,7 @@ fn get_method_sig(\n     method_name: ~str\n ) -> Option<~str> {\n     do astsrv::exec(srv) |copy method_name, ctxt| {\n-        match ctxt.ast_map.get(&item_id) {\n+        match ctxt.ast_map.get(item_id) {\n           ast_map::node_item(@ast::item {\n             node: ast::item_trait(_, _, ref methods), _\n           }, _) => {\n@@ -271,7 +271,7 @@ fn fold_impl(\n     let (trait_types, self_ty) = {\n         let doc = copy doc;\n         do astsrv::exec(srv) |ctxt| {\n-            match ctxt.ast_map.get(&doc.id()) {\n+            match ctxt.ast_map.get(doc.id()) {\n                 ast_map::node_item(@ast::item {\n                     node: ast::item_impl(_, opt_trait_type, self_ty, _), _\n                 }, _) => {\n@@ -331,7 +331,7 @@ fn fold_type(\n         sig: {\n             let doc = copy doc;\n             do astsrv::exec(srv) |ctxt| {\n-                match ctxt.ast_map.get(&doc.id()) {\n+                match ctxt.ast_map.get(doc.id()) {\n                     ast_map::node_item(@ast::item {\n                         ident: ident,\n                         node: ast::item_ty(ty, ref params), _\n@@ -369,7 +369,7 @@ fn fold_struct(\n         sig: {\n             let doc = copy doc;\n             do astsrv::exec(srv) |ctxt| {\n-                match ctxt.ast_map.get(&doc.id()) {\n+                match ctxt.ast_map.get(doc.id()) {\n                     ast_map::node_item(item, _) => {\n                         let item = strip_struct_extra_stuff(item);\n                         Some(pprust::item_to_str(item,"}, {"sha": "a4d4a4e806b0dd566b0dd64e486fa5ab0d625e5c", "filename": "src/libstd/oldmap.rs", "status": "modified", "additions": 53, "deletions": 52, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibstd%2Foldmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibstd%2Foldmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldmap.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -226,9 +226,9 @@ pub mod chained {\n             }\n         }\n \n-        pure fn find(&self, k: &K) -> Option<V> {\n+        pure fn find(&self, k: K) -> Option<V> {\n             unsafe {\n-                match self.search_tbl(k, k.hash_keyed(0,0) as uint) {\n+                match self.search_tbl(&k, k.hash_keyed(0,0) as uint) {\n                   NotFound => None,\n                   FoundFirst(_, entry) => Some(entry.value),\n                   FoundAfter(_, entry) => Some(entry.value)\n@@ -291,7 +291,7 @@ pub mod chained {\n             return self.update_with_key(key, newval, |_k, v, v1| ff(v,v1));\n         }\n \n-        pure fn get(&self, k: &K) -> V {\n+        pure fn get(&self, k: K) -> V {\n             let opt_v = self.find(k);\n             if opt_v.is_none() {\n                 die!(fmt!(\"Key not found in table: %?\", k));\n@@ -364,7 +364,7 @@ pub mod chained {\n     impl<K:Eq IterBytes Hash Copy, V: Copy> T<K, V>: ops::Index<K, V> {\n         pure fn index(&self, k: K) -> V {\n             unsafe {\n-                self.get(&k)\n+                self.get(k)\n             }\n         }\n     }\n@@ -421,6 +421,7 @@ pub fn hash_from_vec<K: Eq IterBytes Hash Const Copy, V: Copy>(\n #[cfg(test)]\n mod tests {\n     use core::option::None;\n+    use core::option;\n     use core::uint;\n \n     use super::*;\n@@ -436,13 +437,13 @@ mod tests {\n         assert (hm_uu.insert(10u, 12u));\n         assert (hm_uu.insert(11u, 13u));\n         assert (hm_uu.insert(12u, 14u));\n-        assert (hm_uu.get(&11) == 13u);\n-        assert (hm_uu.get(&12) == 14u);\n-        assert (hm_uu.get(&10) == 12u);\n+        assert (hm_uu.get(11u) == 13u);\n+        assert (hm_uu.get(12u) == 14u);\n+        assert (hm_uu.get(10u) == 12u);\n         assert (!hm_uu.insert(12u, 14u));\n-        assert (hm_uu.get(&12) == 14u);\n+        assert (hm_uu.get(12u) == 14u);\n         assert (!hm_uu.insert(12u, 12u));\n-        assert (hm_uu.get(&12) == 12u);\n+        assert (hm_uu.get(12u) == 12u);\n         let ten: ~str = ~\"ten\";\n         let eleven: ~str = ~\"eleven\";\n         let twelve: ~str = ~\"twelve\";\n@@ -452,40 +453,40 @@ mod tests {\n         assert (hm_su.insert(~\"ten\", 12u));\n         assert (hm_su.insert(eleven, 13u));\n         assert (hm_su.insert(~\"twelve\", 14u));\n-        assert (hm_su.get(&eleven) == 13u);\n-        assert (hm_su.get(&~\"eleven\") == 13u);\n-        assert (hm_su.get(&~\"twelve\") == 14u);\n-        assert (hm_su.get(&~\"ten\") == 12u);\n+        assert (hm_su.get(eleven) == 13u);\n+        assert (hm_su.get(~\"eleven\") == 13u);\n+        assert (hm_su.get(~\"twelve\") == 14u);\n+        assert (hm_su.get(~\"ten\") == 12u);\n         assert (!hm_su.insert(~\"twelve\", 14u));\n-        assert (hm_su.get(&~\"twelve\") == 14u);\n+        assert (hm_su.get(~\"twelve\") == 14u);\n         assert (!hm_su.insert(~\"twelve\", 12u));\n-        assert (hm_su.get(&~\"twelve\") == 12u);\n+        assert (hm_su.get(~\"twelve\") == 12u);\n         debug!(\"uint -> str\");\n         let hm_us: HashMap<uint, ~str> =\n             HashMap::<uint, ~str>();\n         assert (hm_us.insert(10u, ~\"twelve\"));\n         assert (hm_us.insert(11u, ~\"thirteen\"));\n         assert (hm_us.insert(12u, ~\"fourteen\"));\n-        assert hm_us.get(&11) == ~\"thirteen\";\n-        assert hm_us.get(&12) == ~\"fourteen\";\n-        assert hm_us.get(&10) == ~\"twelve\";\n+        assert hm_us.get(11u) == ~\"thirteen\";\n+        assert hm_us.get(12u) == ~\"fourteen\";\n+        assert hm_us.get(10u) == ~\"twelve\";\n         assert (!hm_us.insert(12u, ~\"fourteen\"));\n-        assert hm_us.get(&12) == ~\"fourteen\";\n+        assert hm_us.get(12u) == ~\"fourteen\";\n         assert (!hm_us.insert(12u, ~\"twelve\"));\n-        assert hm_us.get(&12) == ~\"twelve\";\n+        assert hm_us.get(12u) == ~\"twelve\";\n         debug!(\"str -> str\");\n         let hm_ss: HashMap<~str, ~str> =\n             HashMap::<~str, ~str>();\n         assert (hm_ss.insert(ten, ~\"twelve\"));\n         assert (hm_ss.insert(eleven, ~\"thirteen\"));\n         assert (hm_ss.insert(twelve, ~\"fourteen\"));\n-        assert hm_ss.get(&~\"eleven\") == ~\"thirteen\";\n-        assert hm_ss.get(&~\"twelve\") == ~\"fourteen\";\n-        assert hm_ss.get(&~\"ten\") == ~\"twelve\";\n+        assert hm_ss.get(~\"eleven\") == ~\"thirteen\";\n+        assert hm_ss.get(~\"twelve\") == ~\"fourteen\";\n+        assert hm_ss.get(~\"ten\") == ~\"twelve\";\n         assert (!hm_ss.insert(~\"twelve\", ~\"fourteen\"));\n-        assert hm_ss.get(&~\"twelve\") == ~\"fourteen\";\n+        assert hm_ss.get(~\"twelve\") == ~\"fourteen\";\n         assert (!hm_ss.insert(~\"twelve\", ~\"twelve\"));\n-        assert hm_ss.get(&~\"twelve\") == ~\"twelve\";\n+        assert hm_ss.get(~\"twelve\") == ~\"twelve\";\n         debug!(\"*** finished test_simple\");\n     }\n \n@@ -511,17 +512,17 @@ mod tests {\n         debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n-            debug!(\"get(%u) = %u\", i, hm_uu.get(&i));\n-            assert (hm_uu.get(&i) == i * i);\n+            debug!(\"get(%u) = %u\", i, hm_uu.get(i));\n+            assert (hm_uu.get(i) == i * i);\n             i += 1u;\n         }\n         assert (hm_uu.insert(num_to_insert, 17u));\n-        assert (hm_uu.get(&num_to_insert) == 17u);\n+        assert (hm_uu.get(num_to_insert) == 17u);\n         debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n-            debug!(\"get(%u) = %u\", i, hm_uu.get(&i));\n-            assert (hm_uu.get(&i) == i * i);\n+            debug!(\"get(%u) = %u\", i, hm_uu.get(i));\n+            assert (hm_uu.get(i) == i * i);\n             i += 1u;\n         }\n         debug!(\"str -> str\");\n@@ -541,22 +542,22 @@ mod tests {\n         while i < num_to_insert {\n             debug!(\"get(\\\"%s\\\") = \\\"%s\\\"\",\n                    uint::to_str_radix(i, 2u),\n-                   hm_ss.get(&uint::to_str_radix(i, 2u)));\n-            assert hm_ss.get(&uint::to_str_radix(i, 2u)) ==\n+                   hm_ss.get(uint::to_str_radix(i, 2u)));\n+            assert hm_ss.get(uint::to_str_radix(i, 2u)) ==\n                              uint::to_str_radix(i * i, 2u);\n             i += 1u;\n         }\n         assert (hm_ss.insert(uint::to_str_radix(num_to_insert, 2u),\n                              uint::to_str_radix(17u, 2u)));\n-        assert hm_ss.get(&uint::to_str_radix(num_to_insert, 2u)) ==\n+        assert hm_ss.get(uint::to_str_radix(num_to_insert, 2u)) ==\n             uint::to_str_radix(17u, 2u);\n         debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n             debug!(\"get(\\\"%s\\\") = \\\"%s\\\"\",\n                    uint::to_str_radix(i, 2u),\n-                   hm_ss.get(&uint::to_str_radix(i, 2u)));\n-            assert hm_ss.get(&uint::to_str_radix(i, 2u)) ==\n+                   hm_ss.get(uint::to_str_radix(i, 2u)));\n+            assert hm_ss.get(uint::to_str_radix(i, 2u)) ==\n                              uint::to_str_radix(i * i, 2u);\n             i += 1u;\n         }\n@@ -588,15 +589,15 @@ mod tests {\n         debug!(\"-----\");\n         i = 1u;\n         while i < num_to_insert {\n-            debug!(\"get(%u) = %u\", i, hm.get(&i));\n-            assert (hm.get(&i) == i * i);\n+            debug!(\"get(%u) = %u\", i, hm.get(i));\n+            assert (hm.get(i) == i * i);\n             i += 2u;\n         }\n         debug!(\"-----\");\n         i = 1u;\n         while i < num_to_insert {\n-            debug!(\"get(%u) = %u\", i, hm.get(&i));\n-            assert (hm.get(&i) == i * i);\n+            debug!(\"get(%u) = %u\", i, hm.get(i));\n+            assert (hm.get(i) == i * i);\n             i += 2u;\n         }\n         debug!(\"-----\");\n@@ -610,16 +611,16 @@ mod tests {\n         debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n-            debug!(\"get(%u) = %u\", i, hm.get(&i));\n-            assert (hm.get(&i) == i * i);\n+            debug!(\"get(%u) = %u\", i, hm.get(i));\n+            assert (hm.get(i) == i * i);\n             i += 1u;\n         }\n         debug!(\"-----\");\n         assert (hm.len() == num_to_insert);\n         i = 0u;\n         while i < num_to_insert {\n-            debug!(\"get(%u) = %u\", i, hm.get(&i));\n-            assert (hm.get(&i) == i * i);\n+            debug!(\"get(%u) = %u\", i, hm.get(i));\n+            assert (hm.get(i) == i * i);\n             i += 1u;\n         }\n         debug!(\"*** finished test_removal\");\n@@ -638,9 +639,9 @@ mod tests {\n     fn test_find() {\n         let key = ~\"k\";\n         let map = HashMap::<~str, ~str>();\n-        assert map.find(&key).is_none();\n+        assert (option::is_none(&map.find(key)));\n         map.insert(key, ~\"val\");\n-        assert map.find(&key).get() == ~\"val\";\n+        assert (option::get(map.find(key)) == ~\"val\");\n     }\n \n     #[test]\n@@ -663,9 +664,9 @@ mod tests {\n             (~\"c\", 3)\n         ]);\n         assert map.len() == 3u;\n-        assert map.get(&~\"a\") == 1;\n-        assert map.get(&~\"b\") == 2;\n-        assert map.get(&~\"c\") == 3;\n+        assert map.get(~\"a\") == 1;\n+        assert map.get(~\"b\") == 2;\n+        assert map.get(~\"c\") == 3;\n     }\n \n     #[test]\n@@ -691,11 +692,11 @@ mod tests {\n         map.update_with_key(~\"cat\",      2, addMoreToCount);\n \n         // check the total counts\n-        assert map.find(&~\"cat\").get() == 10;\n-        assert map.find(&~\"ferret\").get() == 3;\n-        assert map.find(&~\"mongoose\").get() == 1;\n+        assert 10 == option::get(map.find(~\"cat\"));\n+        assert  3 == option::get(map.find(~\"ferret\"));\n+        assert  1 == option::get(map.find(~\"mongoose\"));\n \n         // sadly, no mythical animals were counted!\n-        assert map.find(&~\"unicorn\").is_none();\n+        assert None == map.find(~\"unicorn\");\n     }\n }"}, {"sha": "e6a4639ad80684f732b775a4044686e4b2496d9d", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -333,7 +333,7 @@ pub fn map_stmt(stmt: @stmt, cx: ctx, v: vt) {\n }\n \n pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n-    match map.find(&id) {\n+    match map.find(id) {\n       None => {\n         fmt!(\"unknown node (id=%d)\", id)\n       }\n@@ -398,7 +398,7 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n pub fn node_item_query<Result>(items: map, id: node_id,\n                            query: fn(@item) -> Result,\n                            error_msg: ~str) -> Result {\n-    match items.find(&id) {\n+    match items.find(id) {\n         Some(node_item(it, _)) => query(it),\n         _ => die!(error_msg)\n     }"}, {"sha": "227a86e0766fd3ccb19af9cc9f9a8411e9106e9f", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -40,7 +40,7 @@ pub fn expand_expr(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n                 /* using idents and token::special_idents would make the\n                 the macro names be hygienic */\n                 let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-                match exts.find(extname) {\n+                match exts.find(*extname) {\n                   None => {\n                     cx.span_fatal(pth.span,\n                                   fmt!(\"macro undefined: '%s'\", *extname))\n@@ -104,7 +104,7 @@ pub fn expand_mod_items(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n               ast::meta_name_value(ref n, _) => (*n),\n               ast::meta_list(ref n, _) => (*n)\n             };\n-            match exts.find(&mname) {\n+            match exts.find(mname) {\n               None | Some(NormalTT(_)) | Some(ItemTT(*)) => items,\n               Some(ItemDecorator(dec_fn)) => {\n                   cx.bt_push(ExpandedFrom({call_site: attr.span,\n@@ -161,7 +161,7 @@ pub fn expand_item_mac(exts: HashMap<~str, SyntaxExtension>,\n     };\n \n     let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-    let expanded = match exts.find(extname) {\n+    let expanded = match exts.find(*extname) {\n         None => cx.span_fatal(pth.span,\n                               fmt!(\"macro undefined: '%s!'\", *extname)),\n \n@@ -224,7 +224,7 @@ pub fn expand_stmt(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n \n     assert(vec::len(pth.idents) == 1u);\n     let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-    let (fully_expanded, sp) = match exts.find(extname) {\n+    let (fully_expanded, sp) = match exts.find(*extname) {\n         None =>\n             cx.span_fatal(pth.span, fmt!(\"macro undefined: '%s'\", *extname)),\n "}, {"sha": "31172cbfa85275016c4baf4eb01b8ac34f439133", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -59,11 +59,11 @@ pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                                      arg_reader as reader, argument_gram);\n \n     // Extract the arguments:\n-    let lhses:~[@named_match] = match argument_map.get(&lhs_nm) {\n+    let lhses:~[@named_match] = match argument_map.get(lhs_nm) {\n       @matched_seq(s, _) => s,\n       _ => cx.span_bug(sp, ~\"wrong-structured lhs\")\n     };\n-    let rhses:~[@named_match] = match argument_map.get(&rhs_nm) {\n+    let rhses:~[@named_match] = match argument_map.get(rhs_nm) {\n       @matched_seq(s, _) => s,\n       _ => cx.span_bug(sp, ~\"wrong-structured rhs\")\n     };"}, {"sha": "6bf90617a6e96e0fa943135bb4baec9ca7972fb3", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -111,7 +111,7 @@ pure fn lookup_cur_matched_by_matched(r: tt_reader,\n }\n \n fn lookup_cur_matched(r: tt_reader, name: ident) -> @named_match {\n-    lookup_cur_matched_by_matched(r, r.interpolations.get(&name))\n+    lookup_cur_matched_by_matched(r, r.interpolations.get(name))\n }\n enum lis {\n     lis_unconstrained, lis_constraint(uint, ident), lis_contradiction(~str)"}, {"sha": "19b938ccd687a47e097e9992353f2144b299bb79", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -44,7 +44,7 @@ pub trait Interner<T:Eq IterBytes Hash Const Copy> {\n \n pub impl <T:Eq IterBytes Hash Const Copy> hash_interner<T>: Interner<T> {\n     fn intern(val: T) -> uint {\n-        match self.map.find(&val) {\n+        match self.map.find(val) {\n           Some(idx) => return idx,\n           None => {\n             let new_idx = self.vect.len();"}, {"sha": "748c209229c29b965a9813775089d65acf8c6136", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -20,5 +20,5 @@ pub type header_map = HashMap<~str, @DVec<@~str>>;\n \n // the unused ty param is necessary so this gets monomorphized\n pub fn request<T: Copy>(req: header_map) {\n-  let _x = copy *(copy *req.get(&~\"METHOD\"))[0u];\n+  let _x = copy *(copy *req.get(~\"METHOD\"))[0u];\n }"}, {"sha": "67c071da26dae6397f81f557097553090ea1a47b", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -42,7 +42,7 @@ fn old_int_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n             }\n \n             for uint::range(0, num_keys) |i| {\n-                assert map.get(&i) == i+1;\n+                assert map.get(i) == i+1;\n             }\n         }\n     }\n@@ -81,7 +81,7 @@ fn old_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n \n             for uint::range(0, num_keys) |i| {\n                 let s = uint::to_str(i);\n-                assert map.get(&s) == i;\n+                assert map.get(s) == i;\n             }\n         }\n     }"}, {"sha": "32b6c49189882cb29a10cb84f57d96ecad9bbfa1", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -83,7 +83,7 @@ fn str_set() {\n \n     let mut found = 0;\n     for int::range(0, 1000) |_i| {\n-        match s.find(&r.gen_str(10)) {\n+        match s.find(r.gen_str(10)) {\n           Some(_) => { found += 1; }\n           None => { }\n         }"}, {"sha": "0f4f22196ce67554a8e74a9da190b03de8f7f91c", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -69,7 +69,7 @@ fn sort_and_fmt(mm: HashMap<~[u8], uint>, total: uint) -> ~str {\n \n // given a map, search for the frequency of a pattern\n fn find(mm: HashMap<~[u8], uint>, key: ~str) -> uint {\n-   match mm.find(&str::to_bytes(str::to_lower(key))) {\n+   match mm.find(str::to_bytes(str::to_lower(key))) {\n       option::None      => { return 0u; }\n       option::Some(num) => { return num; }\n    }"}, {"sha": "8cf57b19825935786e3adcdbe70d617eab544879", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -136,7 +136,7 @@ fn writer(path: ~str, pport: pipes::Port<Line>, size: uint)\n             while prev <= i {\n                 if lines.contains_key_ref(&prev) {\n                     debug!(\"WS %u\", prev);\n-                    cout.write(lines.get(&prev));\n+                    cout.write(lines.get(prev));\n                     done += 1_u;\n                     lines.remove(&prev);\n                     prev += 1_u;"}, {"sha": "43e2bee644a75c3a9a1e2470db6478efdef5ab1c", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4250a96fdf61142a9c8dbb6d37ae8435c99e396/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=a4250a96fdf61142a9c8dbb6d37ae8435c99e396", "patch": "@@ -49,7 +49,7 @@ mod map_reduce {\n         fn emit(im: oldmap::HashMap<~str, int>, ctrl: SharedChan<ctrl_proto>, key: ~str,\n                 val: ~str) {\n             let mut c;\n-            match im.find(&key) {\n+            match im.find(copy key) {\n               Some(_c) => { c = _c }\n               None => {\n                   let (pp, cc) = stream();\n@@ -88,7 +88,7 @@ mod map_reduce {\n               mapper_done => { num_mappers -= 1; }\n               find_reducer(k, cc) => {\n                 let mut c;\n-                match reducers.find(&str::from_bytes(k)) {\n+                match reducers.find(str::from_bytes(k)) {\n                   Some(_c) => { c = _c; }\n                   None => { c = 0; }\n                 }"}]}