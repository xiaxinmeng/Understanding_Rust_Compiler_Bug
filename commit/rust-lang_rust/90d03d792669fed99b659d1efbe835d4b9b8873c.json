{"sha": "90d03d792669fed99b659d1efbe835d4b9b8873c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwZDAzZDc5MjY2OWZlZDk5YjY1OWQxZWZiZTgzNWQ0YjliODg3M2M=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-06T15:17:01Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-09T16:44:50Z"}, "message": "rustc: Add `const` globals to the language\n\nThis change is an implementation of [RFC 69][rfc] which adds a third kind of\nglobal to the language, `const`. This global is most similar to what the old\n`static` was, and if you're unsure about what to use then you should use a\n`const`.\n\nThe semantics of these three kinds of globals are:\n\n* A `const` does not represent a memory location, but only a value. Constants\n  are translated as rvalues, which means that their values are directly inlined\n  at usage location (similar to a #define in C/C++). Constant values are, well,\n  constant, and can not be modified. Any \"modification\" is actually a\n  modification to a local value on the stack rather than the actual constant\n  itself.\n\n  Almost all values are allowed inside constants, whether they have interior\n  mutability or not. There are a few minor restrictions listed in the RFC, but\n  they should in general not come up too often.\n\n* A `static` now always represents a memory location (unconditionally). Any\n  references to the same `static` are actually a reference to the same memory\n  location. Only values whose types ascribe to `Sync` are allowed in a `static`.\n  This restriction is in place because many threads may access a `static`\n  concurrently. Lifting this restriction (and allowing unsafe access) is a\n  future extension not implemented at this time.\n\n* A `static mut` continues to always represent a memory location. All references\n  to a `static mut` continue to be `unsafe`.\n\nThis is a large breaking change, and many programs will need to be updated\naccordingly. A summary of the breaking changes is:\n\n* Statics may no longer be used in patterns. Statics now always represent a\n  memory location, which can sometimes be modified. To fix code, repurpose the\n  matched-on-`static` to a `const`.\n\n      static FOO: uint = 4;\n      match n {\n          FOO => { /* ... */ }\n          _ => { /* ... */ }\n      }\n\n  change this code to:\n\n      const FOO: uint = 4;\n      match n {\n          FOO => { /* ... */ }\n          _ => { /* ... */ }\n      }\n\n* Statics may no longer refer to other statics by value. Due to statics being\n  able to change at runtime, allowing them to reference one another could\n  possibly lead to confusing semantics. If you are in this situation, use a\n  constant initializer instead. Note, however, that statics may reference other\n  statics by address, however.\n\n* Statics may no longer be used in constant expressions, such as array lengths.\n  This is due to the same restrictions as listed above. Use a `const` instead.\n\n[breaking-change]\n\n[rfc]: https://github.com/rust-lang/rfcs/pull/246", "tree": {"sha": "515a528e1fadef2239236c08d2c11018ea6ebd11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/515a528e1fadef2239236c08d2c11018ea6ebd11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90d03d792669fed99b659d1efbe835d4b9b8873c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90d03d792669fed99b659d1efbe835d4b9b8873c", "html_url": "https://github.com/rust-lang/rust/commit/90d03d792669fed99b659d1efbe835d4b9b8873c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90d03d792669fed99b659d1efbe835d4b9b8873c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a89ad587101b4603c8334f344d303ae6eaa99827", "url": "https://api.github.com/repos/rust-lang/rust/commits/a89ad587101b4603c8334f344d303ae6eaa99827", "html_url": "https://github.com/rust-lang/rust/commit/a89ad587101b4603c8334f344d303ae6eaa99827"}], "stats": {"total": 1166, "additions": 721, "deletions": 445}, "files": [{"sha": "451d39fbc3defe19b8f54865eb83c48138bb90fb", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -978,7 +978,8 @@ impl LintPass for NonUppercaseStatics {\n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n         match it.node {\n             // only check static constants\n-            ast::ItemStatic(_, ast::MutImmutable, _) => {\n+            ast::ItemStatic(_, ast::MutImmutable, _) |\n+            ast::ItemConst(..) => {\n                 let s = token::get_ident(it.ident);\n                 // check for lowercase letters rather than non-uppercase\n                 // ones (some scripts don't have a concept of\n@@ -998,7 +999,7 @@ impl LintPass for NonUppercaseStatics {\n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n         match (&p.node, cx.tcx.def_map.borrow().find(&p.id)) {\n-            (&ast::PatIdent(_, ref path1, _), Some(&def::DefStatic(_, false))) => {\n+            (&ast::PatIdent(_, ref path1, _), Some(&def::DefConst(..))) => {\n                 let s = token::get_ident(path1.node);\n                 if s.get().chars().any(|c| c.is_lowercase()) {\n                     cx.span_lint(NON_UPPERCASE_STATICS, path1.span,"}, {"sha": "dcf394aa3f406663938b54f1774699073526b007", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -126,12 +126,14 @@ enum Family {\n     Trait,                 // I\n     Struct,                // S\n     PublicField,           // g\n-    InheritedField         // N\n+    InheritedField,        // N\n+    Constant,              // C\n }\n \n fn item_family(item: rbml::Doc) -> Family {\n     let fam = reader::get_doc(item, tag_items_data_item_family);\n     match reader::doc_as_u8(fam) as char {\n+      'C' => Constant,\n       'c' => ImmStatic,\n       'b' => MutStatic,\n       'f' => Fn,\n@@ -303,6 +305,7 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n     -> DefLike {\n     let fam = item_family(item);\n     match fam {\n+        Constant  => DlDef(def::DefConst(did)),\n         ImmStatic => DlDef(def::DefStatic(did, false)),\n         MutStatic => DlDef(def::DefStatic(did, true)),\n         Struct    => DlDef(def::DefStruct(did)),"}, {"sha": "94d86956f70058142542acb92012d90fe71aeaa8", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -69,7 +69,6 @@ pub struct EncodeParams<'a, 'tcx: 'a> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n     pub reexports2: &'a middle::resolve::ExportMap2,\n     pub item_symbols: &'a RefCell<NodeMap<String>>,\n-    pub non_inlineable_statics: &'a RefCell<NodeSet>,\n     pub link_meta: &'a LinkMeta,\n     pub cstore: &'a cstore::CStore,\n     pub encode_inlined_item: EncodeInlinedItem<'a>,\n@@ -81,7 +80,6 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n     pub reexports2: &'a middle::resolve::ExportMap2,\n     pub item_symbols: &'a RefCell<NodeMap<String>>,\n-    pub non_inlineable_statics: &'a RefCell<NodeSet>,\n     pub link_meta: &'a LinkMeta,\n     pub cstore: &'a cstore::CStore,\n     pub encode_inlined_item: RefCell<EncodeInlinedItem<'a>>,\n@@ -1069,12 +1067,20 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_symbol(ecx, rbml_w, item.id);\n         encode_name(rbml_w, item.ident.name);\n         encode_path(rbml_w, path);\n-\n-        let inlineable = !ecx.non_inlineable_statics.borrow().contains(&item.id);\n-\n-        if inlineable {\n-            encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n-        }\n+        encode_visibility(rbml_w, vis);\n+        encode_stability(rbml_w, stab);\n+        encode_attributes(rbml_w, item.attrs.as_slice());\n+        rbml_w.end_tag();\n+      }\n+      ItemConst(_, _) => {\n+        add_to_index(item, rbml_w, index);\n+        rbml_w.start_tag(tag_items_data_item);\n+        encode_def_id(rbml_w, def_id);\n+        encode_family(rbml_w, 'C');\n+        encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n+        encode_name(rbml_w, item.ident.name);\n+        encode_path(rbml_w, path);\n+        encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n         rbml_w.end_tag();\n@@ -2076,7 +2082,6 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter, parms: EncodeParams, krate:\n         cstore,\n         encode_inlined_item,\n         link_meta,\n-        non_inlineable_statics,\n         reachable,\n         ..\n     } = parms;\n@@ -2085,7 +2090,6 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter, parms: EncodeParams, krate:\n         tcx: tcx,\n         reexports2: reexports2,\n         item_symbols: item_symbols,\n-        non_inlineable_statics: non_inlineable_statics,\n         link_meta: link_meta,\n         cstore: cstore,\n         encode_inlined_item: RefCell::new(encode_inlined_item),"}, {"sha": "955228c99deedea6a0abc9e05dbb583ef1d18b10", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -460,6 +460,7 @@ impl tr for def::Def {\n           def::DefMod(did) => { def::DefMod(did.tr(dcx)) }\n           def::DefForeignMod(did) => { def::DefForeignMod(did.tr(dcx)) }\n           def::DefStatic(did, m) => { def::DefStatic(did.tr(dcx), m) }\n+          def::DefConst(did) => { def::DefConst(did.tr(dcx)) }\n           def::DefLocal(nid) => { def::DefLocal(dcx.tr_id(nid)) }\n           def::DefVariant(e_did, v_did, is_s) => {\n             def::DefVariant(e_did.tr(dcx), v_did.tr(dcx), is_s)"}, {"sha": "f2ff104ba1d104bb623c4af915fb1faf0b3c2556", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -169,15 +169,11 @@ fn check_aliasability(bccx: &BorrowckCtxt,\n             // Borrow of an immutable static item:\n             match safety {\n                 mc::InteriorUnsafe => {\n-                    // If the static item contains an Unsafe<T>, it has interior mutability.\n-                    // In such cases, we cannot permit it to be borrowed, because the\n-                    // static item resides in immutable memory and mutating it would\n-                    // cause segfaults.\n-                    bccx.tcx.sess.span_err(borrow_span,\n-                                           \"borrow of immutable static items \\\n-                                            with unsafe interior is not \\\n-                                            allowed\");\n-                    Err(())\n+                    // If the static item contains an Unsafe<T>, it has interior\n+                    // mutability.  In such cases, another phase of the compiler\n+                    // will ensure that the type is `Sync` and then trans will\n+                    // not put it in rodata, so this is ok to allow.\n+                    Ok(())\n                 }\n                 mc::InteriorSafe => {\n                     // Immutable static can be borrowed, no problem."}, {"sha": "7d0d99443b0d85d5a12801f0705fe637d8bb0ade", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -106,7 +106,8 @@ fn borrowck_item(this: &mut BorrowckCtxt, item: &ast::Item) {\n     // loan step is intended for things that have a data\n     // flow dependent conditions.\n     match item.node {\n-        ast::ItemStatic(_, _, ref ex) => {\n+        ast::ItemStatic(_, _, ref ex) |\n+        ast::ItemConst(_, ref ex) => {\n             gather_loans::gather_loans_in_static_initializer(this, &**ex);\n         }\n         _ => {"}, {"sha": "f0455db6e3bb693cdade8cf92ff6a549582291ad", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -48,7 +48,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n     }\n     fn visit_expr(&mut self, ex: &Expr) {\n         if check_expr(self, ex) {\n-            visit::walk_expr(v, e);\n+            visit::walk_expr(self, ex);\n         }\n     }\n }\n@@ -61,7 +61,8 @@ pub fn check_crate(tcx: &ty::ctxt) {\n \n fn check_item(v: &mut CheckCrateVisitor, it: &Item) {\n     match it.node {\n-        ItemStatic(_, _, ref ex) => {\n+        ItemStatic(_, _, ref ex) |\n+        ItemConst(_, ref ex) => {\n             v.inside_const(|v| v.visit_expr(&**ex));\n         }\n         ItemEnum(ref enum_definition, _) => {\n@@ -138,6 +139,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) -> bool {\n             }\n             match v.tcx.def_map.borrow().find(&e.id) {\n                 Some(&DefStatic(..)) |\n+                Some(&DefConst(..)) |\n                 Some(&DefFn(..)) |\n                 Some(&DefVariant(_, _, _)) |\n                 Some(&DefStruct(_)) => { }\n@@ -190,7 +192,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) -> bool {\n                 }\n             }\n             match block.expr {\n-                Some(ref expr) => check_expr(v, &**expr),\n+                Some(ref expr) => { check_expr(v, &**expr); }\n                 None => {}\n             }\n         }"}, {"sha": "297640707687c766bebb603a71325d286a7b877b", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 37, "deletions": 27, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -32,7 +32,7 @@ use syntax::ptr::P;\n use syntax::visit::{mod, Visitor, FnKind};\n use util::ppaux::ty_to_string;\n \n-static DUMMY_WILD_PAT: Pat = Pat {\n+pub const DUMMY_WILD_PAT: Pat = Pat {\n     id: DUMMY_NODE_ID,\n     node: PatWild(PatWildSingle),\n     span: DUMMY_SP\n@@ -299,9 +299,10 @@ fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix) {\n     match is_useful(cx, matrix, &[&DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n+            let dummy = DUMMY_WILD_PAT.clone();\n             let witness = match pats.as_slice() {\n                 [ref witness] => &**witness,\n-                [] => &DUMMY_WILD_PAT,\n+                [] => &dummy,\n                 _ => unreachable!()\n             };\n             span_err!(cx.tcx.sess, sp, E0004,\n@@ -349,7 +350,7 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n             PatIdent(..) | PatEnum(..) => {\n                 let def = self.tcx.def_map.borrow().find_copy(&pat.id);\n                 match def {\n-                    Some(DefStatic(did, _)) => match lookup_const_by_id(self.tcx, did) {\n+                    Some(DefConst(did)) => match lookup_const_by_id(self.tcx, did) {\n                         Some(const_expr) => {\n                             const_expr_to_pat(self.tcx, const_expr).map(|mut new_pat| {\n                                 new_pat.span = pat.span;\n@@ -359,7 +360,7 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n                         None => {\n                             self.failed = true;\n                             span_err!(self.tcx.sess, pat.span, E0158,\n-                                \"extern statics cannot be referenced in patterns\");\n+                                \"statics cannot be referenced in patterns\");\n                             pat\n                         }\n                     },\n@@ -555,8 +556,9 @@ fn is_useful(cx: &MatchCheckCtxt,\n                             let arity = constructor_arity(cx, &c, left_ty);\n                             let mut result = {\n                                 let pat_slice = pats.as_slice();\n+                                let dummy = DUMMY_WILD_PAT.clone();\n                                 let subpats = Vec::from_fn(arity, |i| {\n-                                    pat_slice.get(i).map_or(&DUMMY_WILD_PAT, |p| &**p)\n+                                    pat_slice.get(i).map_or(&dummy, |p| &**p)\n                                 });\n                                 vec![construct_witness(cx, &c, subpats, left_ty)]\n                             };\n@@ -578,8 +580,9 @@ fn is_useful(cx: &MatchCheckCtxt,\n                 }).collect();\n                 match is_useful(cx, &matrix, v.tail(), witness) {\n                     UsefulWithWitness(pats) => {\n+                        let dummy = DUMMY_WILD_PAT.clone();\n                         let arity = constructor_arity(cx, &constructor, left_ty);\n-                        let wild_pats = Vec::from_elem(arity, &DUMMY_WILD_PAT);\n+                        let wild_pats = Vec::from_elem(arity, &dummy);\n                         let enum_pat = construct_witness(cx, &constructor, wild_pats, left_ty);\n                         let mut new_pats = vec![enum_pat];\n                         new_pats.extend(pats.into_iter());\n@@ -600,10 +603,11 @@ fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix,\n                          v: &[&Pat], ctor: Constructor, lty: ty::t,\n                          witness: WitnessPreference) -> Usefulness {\n     let arity = constructor_arity(cx, &ctor, lty);\n+    let dummy = DUMMY_WILD_PAT.clone();\n     let matrix = Matrix(m.iter().filter_map(|r| {\n-        specialize(cx, r.as_slice(), &ctor, 0u, arity)\n+        specialize(cx, r.as_slice(), &dummy, &ctor, 0u, arity)\n     }).collect());\n-    match specialize(cx, v, &ctor, 0u, arity) {\n+    match specialize(cx, v, &dummy, &ctor, 0u, arity) {\n         Some(v) => is_useful(cx, &matrix, v.as_slice(), witness),\n         None => NotUseful\n     }\n@@ -624,23 +628,26 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n     match pat.node {\n         PatIdent(..) =>\n             match cx.tcx.def_map.borrow().find(&pat.id) {\n-                Some(&DefStatic(..)) =>\n-                    cx.tcx.sess.span_bug(pat.span, \"static pattern should've been rewritten\"),\n+                Some(&DefConst(..)) =>\n+                    cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n+                                                    been rewritten\"),\n                 Some(&DefStruct(_)) => vec!(Single),\n                 Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!()\n             },\n         PatEnum(..) =>\n             match cx.tcx.def_map.borrow().find(&pat.id) {\n-                Some(&DefStatic(..)) =>\n-                    cx.tcx.sess.span_bug(pat.span, \"static pattern should've been rewritten\"),\n+                Some(&DefConst(..)) =>\n+                    cx.tcx.sess.span_bug(pat.span, \"static pattern should've \\\n+                                                    been rewritten\"),\n                 Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n         PatStruct(..) =>\n             match cx.tcx.def_map.borrow().find(&pat.id) {\n-                Some(&DefStatic(..)) =>\n-                    cx.tcx.sess.span_bug(pat.span, \"static pattern should've been rewritten\"),\n+                Some(&DefConst(..)) =>\n+                    cx.tcx.sess.span_bug(pat.span, \"static pattern should've \\\n+                                                    been rewritten\"),\n                 Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n@@ -722,40 +729,42 @@ fn range_covered_by_constructor(ctor: &Constructor,\n /// different patterns.\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n-pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n+pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat], dummy: &'a Pat,\n                       constructor: &Constructor, col: uint, arity: uint) -> Option<Vec<&'a Pat>> {\n     let &Pat {\n         id: pat_id, node: ref node, span: pat_span\n     } = raw_pat(r[col]);\n     let head: Option<Vec<&Pat>> = match node {\n \n         &PatWild(_) =>\n-            Some(Vec::from_elem(arity, &DUMMY_WILD_PAT)),\n+            Some(Vec::from_elem(arity, dummy)),\n \n         &PatIdent(_, _, _) => {\n             let opt_def = cx.tcx.def_map.borrow().find_copy(&pat_id);\n             match opt_def {\n-                Some(DefStatic(..)) =>\n-                    cx.tcx.sess.span_bug(pat_span, \"static pattern should've been rewritten\"),\n+                Some(DefConst(..)) =>\n+                    cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n+                                                    been rewritten\"),\n                 Some(DefVariant(_, id, _)) => if *constructor == Variant(id) {\n                     Some(vec!())\n                 } else {\n                     None\n                 },\n-                _ => Some(Vec::from_elem(arity, &DUMMY_WILD_PAT))\n+                _ => Some(Vec::from_elem(arity, dummy))\n             }\n         }\n \n         &PatEnum(_, ref args) => {\n             let def = cx.tcx.def_map.borrow().get_copy(&pat_id);\n             match def {\n-                DefStatic(..) =>\n-                    cx.tcx.sess.span_bug(pat_span, \"static pattern should've been rewritten\"),\n+                DefConst(..) =>\n+                    cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n+                                                    been rewritten\"),\n                 DefVariant(_, id, _) if *constructor != Variant(id) => None,\n                 DefVariant(..) | DefStruct(..) => {\n                     Some(match args {\n                         &Some(ref args) => args.iter().map(|p| &**p).collect(),\n-                        &None => Vec::from_elem(arity, &DUMMY_WILD_PAT)\n+                        &None => Vec::from_elem(arity, dummy)\n                     })\n                 }\n                 _ => None\n@@ -766,8 +775,9 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             // Is this a struct or an enum variant?\n             let def = cx.tcx.def_map.borrow().get_copy(&pat_id);\n             let class_id = match def {\n-                DefStatic(..) =>\n-                    cx.tcx.sess.span_bug(pat_span, \"static pattern should've been rewritten\"),\n+                DefConst(..) =>\n+                    cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n+                                                    been rewritten\"),\n                 DefVariant(_, variant_id, _) => if *constructor == Variant(variant_id) {\n                     Some(variant_id)\n                 } else {\n@@ -790,7 +800,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 let args = struct_fields.iter().map(|sf| {\n                     match pattern_fields.iter().find(|f| f.ident.name == sf.name) {\n                         Some(ref f) => &*f.pat,\n-                        _ => &DUMMY_WILD_PAT\n+                        _ => dummy\n                     }\n                 }).collect();\n                 args\n@@ -833,13 +843,13 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 // Fixed-length vectors.\n                 Single => {\n                     let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n-                    pats.grow_fn(arity - before.len() - after.len(), |_| &DUMMY_WILD_PAT);\n+                    pats.grow_fn(arity - before.len() - after.len(), |_| dummy);\n                     pats.extend(after.iter().map(|p| &**p));\n                     Some(pats)\n                 },\n                 Slice(length) if before.len() + after.len() <= length && slice.is_some() => {\n                     let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n-                    pats.grow_fn(arity - before.len() - after.len(), |_| &DUMMY_WILD_PAT);\n+                    pats.grow_fn(arity - before.len() - after.len(), |_| dummy);\n                     pats.extend(after.iter().map(|p| &**p));\n                     Some(pats)\n                 },"}, {"sha": "9cc1f92dc9304ed8b2f3aed79131f65346b3e82a", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 244, "deletions": 63, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -25,71 +25,124 @@\n // by borrowck::gather_loans\n \n use middle::ty;\n+use middle::def;\n+use middle::typeck;\n+use middle::traits;\n+use middle::mem_categorization as mc;\n+use middle::expr_use_visitor as euv;\n+use util::nodemap::NodeSet;\n \n use syntax::ast;\n+use syntax::print::pprust;\n use syntax::visit::Visitor;\n+use syntax::codemap::{DUMMY_SP, Span};\n use syntax::visit;\n-use syntax::print::pprust;\n-\n-\n-fn safe_type_for_static_mut(cx: &ty::ctxt, e: &ast::Expr) -> Option<String> {\n-    let node_ty = ty::node_id_to_type(cx, e.id);\n-    let tcontents = ty::type_contents(cx, node_ty);\n-    debug!(\"safe_type_for_static_mut(dtor={}, managed={}, owned={})\",\n-           tcontents.has_dtor(), tcontents.owns_managed(), tcontents.owns_owned())\n-\n-    let suffix = if tcontents.has_dtor() {\n-        \"destructors\"\n-    } else if tcontents.owns_managed() {\n-        \"managed pointers\"\n-    } else if tcontents.owns_owned() {\n-        \"owned pointers\"\n-    } else {\n-        return None;\n-    };\n \n-    Some(format!(\"mutable static items are not allowed to have {}\", suffix))\n+#[deriving(Eq, PartialEq)]\n+enum Mode {\n+    InConstant,\n+    InStatic,\n+    InStaticMut,\n+    InNothing,\n }\n \n struct CheckStaticVisitor<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    in_const: bool\n+    mode: Mode,\n+    checker: &'a mut GlobalChecker,\n+}\n+\n+struct GlobalVisitor<'a, 'b, 't: 'b>(euv::ExprUseVisitor<'a, 'b, ty::ctxt<'t>>);\n+struct GlobalChecker {\n+    static_consumptions: NodeSet,\n+    const_borrows: NodeSet,\n+    static_interior_borrows: NodeSet,\n }\n \n pub fn check_crate(tcx: &ty::ctxt) {\n-    visit::walk_crate(&mut CheckStaticVisitor { tcx: tcx, in_const: false },\n-                      tcx.map.krate())\n+    let mut checker = GlobalChecker {\n+        static_consumptions: NodeSet::new(),\n+        const_borrows: NodeSet::new(),\n+        static_interior_borrows: NodeSet::new(),\n+    };\n+    {\n+        let visitor = euv::ExprUseVisitor::new(&mut checker, tcx);\n+        visit::walk_crate(&mut GlobalVisitor(visitor), tcx.map.krate());\n+    }\n+    visit::walk_crate(&mut CheckStaticVisitor {\n+        tcx: tcx,\n+        mode: InNothing,\n+        checker: &mut checker,\n+    }, tcx.map.krate());\n }\n \n impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n-    fn with_const(&mut self, in_const: bool, f: |&mut CheckStaticVisitor<'a, 'tcx>|) {\n-        let was_const = self.in_const;\n-        self.in_const = in_const;\n+    fn with_mode(&mut self, mode: Mode, f: |&mut CheckStaticVisitor<'a, 'tcx>|) {\n+        let old = self.mode;\n+        self.mode = mode;\n         f(self);\n-        self.in_const = was_const;\n+        self.mode = old;\n+    }\n+\n+    fn msg(&self) -> &'static str {\n+        match self.mode {\n+            InConstant => \"constants\",\n+            InStaticMut | InStatic => \"statics\",\n+            InNothing => unreachable!(),\n+        }\n+    }\n+\n+    fn check_static_mut_type(&self, e: &ast::Expr) {\n+        let node_ty = ty::node_id_to_type(self.tcx, e.id);\n+        let tcontents = ty::type_contents(self.tcx, node_ty);\n+\n+        let suffix = if tcontents.has_dtor() {\n+            \"destructors\"\n+        } else if tcontents.owns_owned() {\n+            \"owned pointers\"\n+        } else {\n+            return\n+        };\n+\n+        self.tcx.sess.span_err(e.span, format!(\"mutable statics are not allowed \\\n+                                                to have {}\", suffix).as_slice());\n+    }\n+\n+    fn check_static_type(&self, e: &ast::Expr) {\n+        let ty = ty::node_id_to_type(self.tcx, e.id);\n+        let infcx = typeck::infer::new_infer_ctxt(self.tcx);\n+        let mut fulfill_cx = traits::FulfillmentContext::new();\n+        let cause = traits::ObligationCause::misc(DUMMY_SP);\n+        let obligation = traits::obligation_for_builtin_bound(self.tcx, cause, ty,\n+                                                              ty::BoundSync);\n+        fulfill_cx.register_obligation(self.tcx, obligation.unwrap());\n+        let env = ty::empty_parameter_environment();\n+        let result = fulfill_cx.select_all_or_error(&infcx, &env, self.tcx).is_ok();\n+        if !result {\n+            self.tcx.sess.span_err(e.span, \"shared static items must have a \\\n+                                            type which implements Sync\");\n+        }\n     }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for CheckStaticVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item) {\n         debug!(\"visit_item(item={})\", pprust::item_to_string(i));\n         match i.node {\n-            ast::ItemStatic(_, mutability, ref expr) => {\n-                match mutability {\n-                    ast::MutImmutable => {\n-                        self.with_const(true, |v| v.visit_expr(&**expr));\n-                    }\n-                    ast::MutMutable => {\n-                        match safe_type_for_static_mut(self.tcx, &**expr) {\n-                            Some(msg) => {\n-                                self.tcx.sess.span_err(expr.span, msg.as_slice());\n-                            }\n-                            None => {}\n-                        }\n-                    }\n-                }\n+            ast::ItemStatic(_, ast::MutImmutable, ref expr) => {\n+                self.check_static_type(&**expr);\n+                self.with_mode(InStatic, |v| v.visit_expr(&**expr));\n+            }\n+            ast::ItemStatic(_, ast::MutMutable, ref expr) => {\n+                self.check_static_mut_type(&**expr);\n+                self.with_mode(InStaticMut, |v| v.visit_expr(&**expr));\n+            }\n+            ast::ItemConst(_, ref expr) => {\n+                self.with_mode(InConstant, |v| v.visit_expr(&**expr));\n+            }\n+            _ => {\n+                self.with_mode(InNothing, |v| visit::walk_item(v, i));\n             }\n-            _ => self.with_const(false, |v| visit::walk_item(v, i))\n         }\n     }\n \n@@ -100,42 +153,170 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckStaticVisitor<'a, 'tcx> {\n     /// of a static item, this method does nothing but walking\n     /// down through it.\n     fn visit_expr(&mut self, e: &ast::Expr) {\n-        debug!(\"visit_expr(expr={})\", pprust::expr_to_string(e));\n-\n-        if !self.in_const {\n+        if self.mode == InNothing {\n             return visit::walk_expr(self, e);\n         }\n \n-        match e.node {\n-            ast::ExprField(..) | ast::ExprTupField(..) | ast::ExprVec(..) |\n-            ast::ExprBlock(..) | ast::ExprTup(..)  => {\n-                visit::walk_expr(self, e);\n+        let node_ty = ty::node_id_to_type(self.tcx, e.id);\n+\n+        match ty::get(node_ty).sty {\n+            ty::ty_struct(did, _) |\n+            ty::ty_enum(did, _) if ty::has_dtor(self.tcx, did) => {\n+                self.tcx.sess.span_err(e.span,\n+                                       format!(\"{} are not allowed to have \\\n+                                                destructors\", self.msg()).as_slice())\n             }\n+            _ => {}\n+        }\n+\n+        // statics cannot be consumed by value at any time, that would imply\n+        // that they're an initializer (what a const is for) or kept in sync\n+        // over time (not feasible), so deny it outright.\n+        if self.checker.static_consumptions.remove(&e.id) {\n+            self.tcx.sess.span_err(e.span, \"cannot refer to other statics by \\\n+                                            value, use the address-of operator \\\n+                                            or a constant instead\");\n+        }\n+\n+        // Borrowed statics can specifically *only* have their address taken,\n+        // not any number of other borrows such as borrowing fields, reading\n+        // elements of an array, etc.\n+        if self.checker.static_interior_borrows.remove(&e.id) {\n+            self.tcx.sess.span_err(e.span, \"cannot refer to the interior of \\\n+                                            another static, use a constant \\\n+                                            instead\");\n+        }\n+\n+        // constants cannot be borrowed if they contain interior mutability as\n+        // it means that our \"silent insertion of statics\" could change\n+        // initializer values (very bad).\n+        if self.checker.const_borrows.remove(&e.id) {\n+            let node_ty = ty::node_id_to_type(self.tcx, e.id);\n+            let tcontents = ty::type_contents(self.tcx, node_ty);\n+            if tcontents.interior_unsafe() {\n+                self.tcx.sess.span_err(e.span, \"cannot borrow a constant which \\\n+                                                contains interior mutability, \\\n+                                                create a static instead\");\n+            }\n+        }\n+\n+        match e.node {\n             ast::ExprAddrOf(ast::MutMutable, _) => {\n-                span_err!(self.tcx.sess, e.span, E0020,\n-                    \"static items are not allowed to have mutable slices\");\n+                if self.mode != InStaticMut {\n+                    span_err!(self.tcx.sess, e.span, E0020,\n+                              \"{} are not allowed to have mutable references\",\n+                              self.msg());\n+                }\n             },\n             ast::ExprBox(..) |\n             ast::ExprUnary(ast::UnUniq, _) => {\n                 span_err!(self.tcx.sess, e.span, E0022,\n-                    \"static items are not allowed to have custom pointers\");\n+                          \"{} are not allowed to have custom pointers\",\n+                          self.msg());\n             }\n-            _ => {\n-                let node_ty = ty::node_id_to_type(self.tcx, e.id);\n-\n-                match ty::get(node_ty).sty {\n-                    ty::ty_struct(did, _) |\n-                    ty::ty_enum(did, _) => {\n-                        if ty::has_dtor(self.tcx, did) {\n-                            self.tcx.sess.span_err(e.span,\n-                                \"static items are not allowed to have destructors\");\n-                            return;\n-                        }\n+            ast::ExprPath(..) => {\n+                match ty::resolve_expr(self.tcx, e) {\n+                    def::DefStatic(..) if self.mode == InConstant => {\n+                        let msg = \"constants cannot refer to other statics, \\\n+                                   insert an intermediate constant \\\n+                                   instead\";\n+                        self.tcx.sess.span_err(e.span, msg.as_slice());\n                     }\n                     _ => {}\n                 }\n-                visit::walk_expr(self, e);\n             }\n+            _ => {}\n+        }\n+        visit::walk_expr(self, e);\n+    }\n+}\n+\n+impl<'a, 'b, 't, 'v> Visitor<'v> for GlobalVisitor<'a, 'b, 't> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        match item.node {\n+            ast::ItemConst(_, ref e) |\n+            ast::ItemStatic(_, _, ref e) => {\n+                let GlobalVisitor(ref mut v) = *self;\n+                v.consume_expr(&**e);\n+            }\n+            _ => {}\n         }\n+        visit::walk_item(self, item);\n     }\n }\n+\n+impl euv::Delegate for GlobalChecker {\n+    fn consume(&mut self,\n+               consume_id: ast::NodeId,\n+               _consume_span: Span,\n+               cmt: mc::cmt,\n+               _mode: euv::ConsumeMode) {\n+        let mut cur = &cmt;\n+        loop {\n+            match cur.cat {\n+                mc::cat_static_item => {\n+                    self.static_consumptions.insert(consume_id);\n+                    break\n+                }\n+                mc::cat_deref(ref cmt, _, _) |\n+                mc::cat_discr(ref cmt, _) |\n+                mc::cat_downcast(ref cmt) |\n+                mc::cat_interior(ref cmt, _) => cur = cmt,\n+\n+                mc::cat_rvalue(..) |\n+                mc::cat_copied_upvar(..) |\n+                mc::cat_upvar(..) |\n+                mc::cat_local(..) => break,\n+            }\n+        }\n+    }\n+    fn borrow(&mut self,\n+              borrow_id: ast::NodeId,\n+              _borrow_span: Span,\n+              cmt: mc::cmt,\n+              _loan_region: ty::Region,\n+              _bk: ty::BorrowKind,\n+              _loan_cause: euv::LoanCause) {\n+        let mut cur = &cmt;\n+        let mut is_interior = false;\n+        loop {\n+            match cur.cat {\n+                mc::cat_rvalue(..) => {\n+                    self.const_borrows.insert(borrow_id);\n+                    break\n+                }\n+                mc::cat_static_item => {\n+                    if is_interior {\n+                        self.static_interior_borrows.insert(borrow_id);\n+                    }\n+                    break\n+                }\n+                mc::cat_deref(ref cmt, _, _) |\n+                mc::cat_interior(ref cmt, _) => {\n+                    is_interior = true;\n+                    cur = cmt;\n+                }\n+\n+                mc::cat_downcast(..) |\n+                mc::cat_discr(..) |\n+                mc::cat_copied_upvar(..) |\n+                mc::cat_upvar(..) |\n+                mc::cat_local(..) => unreachable!(),\n+            }\n+        }\n+    }\n+\n+    fn decl_without_init(&mut self,\n+                         _id: ast::NodeId,\n+                         _span: Span) {}\n+    fn mutate(&mut self,\n+              _assignment_id: ast::NodeId,\n+              _assignment_span: Span,\n+              _assignee_cmt: mc::cmt,\n+              _mode: euv::MutateMode) {}\n+    fn consume_pat(&mut self,\n+                   _consume_pat: &ast::Pat,\n+                   _cmt: mc::cmt,\n+                   _mode: euv::ConsumeMode) {}\n+}\n+"}, {"sha": "1f76d9dba263553e6d56a89caba63c793cece5fd", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -13,9 +13,9 @@\n \n use driver::session::Session;\n use middle::resolve;\n-use middle::def::DefStatic;\n+use middle::def::{DefStatic, DefConst};\n \n-use syntax::ast::{Crate, Expr, ExprPath, Item, ItemStatic, NodeId};\n+use syntax::ast;\n use syntax::{ast_util, ast_map};\n use syntax::visit::Visitor;\n use syntax::visit;\n@@ -27,13 +27,13 @@ struct CheckCrateVisitor<'a, 'ast: 'a> {\n }\n \n impl<'v, 'a, 'ast> Visitor<'v> for CheckCrateVisitor<'a, 'ast> {\n-    fn visit_item(&mut self, i: &Item) {\n+    fn visit_item(&mut self, i: &ast::Item) {\n         check_item(self, i);\n     }\n }\n \n pub fn check_crate<'ast>(sess: &Session,\n-                         krate: &Crate,\n+                         krate: &ast::Crate,\n                          def_map: &resolve::DefMap,\n                          ast_map: &ast_map::Map<'ast>) {\n     let mut visitor = CheckCrateVisitor {\n@@ -45,9 +45,10 @@ pub fn check_crate<'ast>(sess: &Session,\n     sess.abort_if_errors();\n }\n \n-fn check_item(v: &mut CheckCrateVisitor, it: &Item) {\n+fn check_item(v: &mut CheckCrateVisitor, it: &ast::Item) {\n     match it.node {\n-        ItemStatic(_, _, ref ex) => {\n+        ast::ItemStatic(_, _, ref ex) |\n+        ast::ItemConst(_, ref ex) => {\n             check_item_recursion(v.sess, v.ast_map, v.def_map, it);\n             visit::walk_expr(v, &**ex)\n         },\n@@ -56,19 +57,19 @@ fn check_item(v: &mut CheckCrateVisitor, it: &Item) {\n }\n \n struct CheckItemRecursionVisitor<'a, 'ast: 'a> {\n-    root_it: &'a Item,\n+    root_it: &'a ast::Item,\n     sess: &'a Session,\n     ast_map: &'a ast_map::Map<'ast>,\n     def_map: &'a resolve::DefMap,\n-    idstack: Vec<NodeId>\n+    idstack: Vec<ast::NodeId>\n }\n \n // Make sure a const item doesn't recursively refer to itself\n // FIXME: Should use the dependency graph when it's available (#1356)\n pub fn check_item_recursion<'a>(sess: &'a Session,\n                                 ast_map: &'a ast_map::Map,\n                                 def_map: &'a resolve::DefMap,\n-                                it: &'a Item) {\n+                                it: &'a ast::Item) {\n \n     let mut visitor = CheckItemRecursionVisitor {\n         root_it: it,\n@@ -81,7 +82,7 @@ pub fn check_item_recursion<'a>(sess: &'a Session,\n }\n \n impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n-    fn visit_item(&mut self, it: &Item) {\n+    fn visit_item(&mut self, it: &ast::Item) {\n         if self.idstack.iter().any(|x| x == &(it.id)) {\n             self.sess.span_err(self.root_it.span, \"recursive constant\");\n             return;\n@@ -91,11 +92,12 @@ impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n         self.idstack.pop();\n     }\n \n-    fn visit_expr(&mut self, e: &Expr) {\n+    fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n-            ExprPath(..) => {\n+            ast::ExprPath(..) => {\n                 match self.def_map.borrow().find(&e.id) {\n-                    Some(&DefStatic(def_id, _)) if\n+                    Some(&DefStatic(def_id, _)) |\n+                    Some(&DefConst(def_id)) if\n                             ast_util::is_local(def_id) => {\n                         self.visit_item(&*self.ast_map.expect_item(def_id.node));\n                     }"}, {"sha": "abcdc45bdcfdec795bc7f5baf82eb52e473add75", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -87,7 +87,7 @@ pub fn join_all<It: Iterator<constness>>(mut cs: It) -> constness {\n fn lookup_const<'a>(tcx: &'a ty::ctxt, e: &Expr) -> Option<&'a Expr> {\n     let opt_def = tcx.def_map.borrow().find_copy(&e.id);\n     match opt_def {\n-        Some(def::DefStatic(def_id, false)) => {\n+        Some(def::DefConst(def_id)) => {\n             lookup_const_by_id(tcx, def_id)\n         }\n         Some(def::DefVariant(enum_def, variant_def, _)) => {\n@@ -155,7 +155,7 @@ pub fn lookup_const_by_id<'a>(tcx: &'a ty::ctxt, def_id: ast::DefId)\n         match tcx.map.find(def_id.node) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n-                ItemStatic(_, ast::MutImmutable, ref const_expr) => {\n+                ItemConst(_, ref const_expr) => {\n                     Some(&**const_expr)\n                 }\n                 _ => None\n@@ -173,7 +173,7 @@ pub fn lookup_const_by_id<'a>(tcx: &'a ty::ctxt, def_id: ast::DefId)\n         let expr_id = match csearch::maybe_get_item_ast(tcx, def_id,\n             |a, b, c, d| astencode::decode_inlined_item(a, b, c, d)) {\n             csearch::found(&ast::IIItem(ref item)) => match item.node {\n-                ItemStatic(_, ast::MutImmutable, ref const_expr) => Some(const_expr.id),\n+                ItemConst(_, ref const_expr) => Some(const_expr.id),\n                 _ => None\n             },\n             _ => None"}, {"sha": "ff3720381009c187164ba5a78823c27cc3ee2c5c", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -215,7 +215,8 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                     ast::ItemFn(..)\n                     | ast::ItemEnum(..)\n                     | ast::ItemTy(..)\n-                    | ast::ItemStatic(..) => {\n+                    | ast::ItemStatic(..)\n+                    | ast::ItemConst(..) => {\n                         visit::walk_item(self, &*item);\n                     }\n                     _ => ()"}, {"sha": "3b7af9788ac57500bbe9ce5dee4a9d4876a709f0", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -20,6 +20,7 @@ pub enum Def {\n     DefMod(ast::DefId),\n     DefForeignMod(ast::DefId),\n     DefStatic(ast::DefId, bool /* is_mutbl */),\n+    DefConst(ast::DefId),\n     DefLocal(ast::NodeId),\n     DefVariant(ast::DefId /* enum */, ast::DefId /* variant */, bool /* is_structure */),\n     DefTy(ast::DefId, bool /* is_enum */),\n@@ -61,7 +62,7 @@ impl Def {\n             DefForeignMod(id) | DefStatic(id, _) |\n             DefVariant(_, id, _) | DefTy(id, _) | DefAssociatedTy(id) |\n             DefTyParam(_, id, _) | DefUse(id) | DefStruct(id) | DefTrait(id) |\n-            DefMethod(id, _) => {\n+            DefMethod(id, _) | DefConst(id) => {\n                 id\n             }\n             DefLocal(id) |"}, {"sha": "6cfdac93efc8ad93a3d89da8c3da053e7ea9e1fe", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -267,7 +267,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n         }\n     }\n \n-    fn consume_expr(&mut self, expr: &ast::Expr) {\n+    pub fn consume_expr(&mut self, expr: &ast::Expr) {\n         debug!(\"consume_expr(expr={})\", expr.repr(self.tcx()));\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));"}, {"sha": "fa494b357c19d5f8d100d4ffd819314be38ae182", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -544,7 +544,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         match def {\n           def::DefStruct(..) | def::DefVariant(..) | def::DefFn(..) |\n-          def::DefStaticMethod(..) => {\n+          def::DefStaticMethod(..) | def::DefConst(..) => {\n                 Ok(self.cat_rvalue_node(id, span, expr_ty))\n           }\n           def::DefMod(_) | def::DefForeignMod(_) | def::DefUse(_) |\n@@ -1104,7 +1104,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                                 |x,y,z| op(x,y,z)));\n                     }\n                 }\n-                Some(&def::DefStatic(..)) => {\n+                Some(&def::DefConst(..)) => {\n                     for subpat in subpats.iter() {\n                         if_ok!(self.cat_pattern(cmt.clone(), &**subpat, |x,y,z| op(x,y,z)));\n                     }"}, {"sha": "4d61baca70874860500cb5a560451b5f83690772", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -46,7 +46,7 @@ pub fn pat_is_const(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n         PatIdent(_, _, None) | PatEnum(..) => {\n             match dm.borrow().find(&pat.id) {\n-                Some(&DefStatic(_, false)) => true,\n+                Some(&DefConst(..)) => true,\n                 _ => false\n             }\n         }"}, {"sha": "e434d859993c0e46ccf0b67f012293e20d764a84", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -805,6 +805,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             def::DefStaticMethod(..) => ck(\"static method\"),\n             def::DefFn(..) => ck(\"function\"),\n             def::DefStatic(..) => ck(\"static\"),\n+            def::DefConst(..) => ck(\"const\"),\n             def::DefVariant(..) => ck(\"variant\"),\n             def::DefTy(_, false) => ck(\"type\"),\n             def::DefTy(_, true) => ck(\"enum\"),\n@@ -1181,7 +1182,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n \n-            ast::ItemStatic(..) | ast::ItemStruct(..) |\n+            ast::ItemConst(..) | ast::ItemStatic(..) | ast::ItemStruct(..) |\n             ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n             ast::ItemMac(..) => {}\n         }\n@@ -1245,7 +1246,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n \n-            ast::ItemStatic(..) |\n+            ast::ItemStatic(..) | ast::ItemConst(..) |\n             ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n             ast::ItemMac(..) => {}\n         }"}, {"sha": "5d6f7048b82e14523d2a1a406c3067959fe7ce56", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -27,7 +27,6 @@ use syntax::abi;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::{is_local, PostExpansionMethod};\n-use syntax::ast_util;\n use syntax::attr::{InlineAlways, InlineHint, InlineNever, InlineNone};\n use syntax::attr;\n use syntax::visit::Visitor;\n@@ -121,15 +120,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n                         self.worklist.push(def_id.node)\n                     } else {\n                         match def {\n-                            // If this path leads to a static, then we may have\n-                            // to do some work to figure out whether the static\n-                            // is indeed reachable. (Inlineable statics are\n-                            // never reachable.)\n-                            def::DefStatic(..) => {\n+                            // If this path leads to a constant, then we need to\n+                            // recurse into the constant to continue finding\n+                            // items that are reachable.\n+                            def::DefConst(..) => {\n                                 self.worklist.push(def_id.node);\n                             }\n \n-                            // If this wasn't a static, then this destination is\n+                            // If this wasn't a static, then the destination is\n                             // surely reachable.\n                             _ => {\n                                 self.reachable_symbols.insert(def_id.node);\n@@ -238,15 +236,14 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     fn propagate(&mut self) {\n         let mut scanned = HashSet::new();\n         loop {\n-            if self.worklist.len() == 0 {\n-                break\n-            }\n-            let search_item = self.worklist.pop().unwrap();\n-            if scanned.contains(&search_item) {\n+            let search_item = match self.worklist.pop() {\n+                Some(item) => item,\n+                None => break,\n+            };\n+            if !scanned.insert(search_item) {\n                 continue\n             }\n \n-            scanned.insert(search_item);\n             match self.tcx.map.find(search_item) {\n                 Some(ref item) => self.propagate_node(item, search_item),\n                 None if search_item == ast::CRATE_NODE_ID => {}\n@@ -297,21 +294,17 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         }\n                     }\n \n-                    // Statics with insignificant addresses are not reachable\n-                    // because they're inlined specially into all other crates.\n-                    ast::ItemStatic(_, mutbl, ref init) => {\n-                        if !ast_util::static_has_significant_address(\n-                                mutbl,\n-                                item.attrs.as_slice()) {\n-                            self.reachable_symbols.remove(&search_item);\n-                        }\n-                        visit::walk_expr(self, &**init);\n+                    // Reachable constants will be inlined into other crates\n+                    // unconditionally, so we need to make sure that their\n+                    // contents are also reachable.\n+                    ast::ItemConst(_, ref init) => {\n+                        self.visit_expr(&**init);\n                     }\n \n                     // These are normal, nothing reachable about these\n                     // inherently and their children are already in the\n                     // worklist, as determined by the privacy pass\n-                    ast::ItemTy(..) |\n+                    ast::ItemTy(..) | ast::ItemStatic(_, _, _) |\n                     ast::ItemMod(..) | ast::ItemForeignMod(..) |\n                     ast::ItemImpl(..) | ast::ItemTrait(..) |\n                     ast::ItemStruct(..) | ast::ItemEnum(..) => {}"}, {"sha": "318bc05d05f88b30452beb8180abca7e8b888d2d", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -29,7 +29,7 @@ use syntax::ast::{ExprPath, ExprProc, ExprStruct, ExprUnboxedFn, FnDecl};\n use syntax::ast::{ForeignItem, ForeignItemFn, ForeignItemStatic, Generics};\n use syntax::ast::{Ident, ImplItem, Item, ItemEnum, ItemFn, ItemForeignMod};\n use syntax::ast::{ItemImpl, ItemMac, ItemMod, ItemStatic, ItemStruct};\n-use syntax::ast::{ItemTrait, ItemTy, LOCAL_CRATE, Local};\n+use syntax::ast::{ItemTrait, ItemTy, LOCAL_CRATE, Local, ItemConst};\n use syntax::ast::{MethodImplItem, Mod, Name, NamedField, NodeId};\n use syntax::ast::{Pat, PatEnum, PatIdent, PatLit};\n use syntax::ast::{PatRange, PatStruct, Path, PathListIdent, PathListMod};\n@@ -1243,6 +1243,12 @@ impl<'a> Resolver<'a> {\n                     (DefStatic(local_def(item.id), mutbl), sp, is_public);\n                 parent\n             }\n+            ItemConst(_, _) => {\n+                self.add_child(ident, parent.clone(), ForbidDuplicateValues, sp)\n+                    .define_value(DefConst(local_def(item.id)),\n+                                  sp, is_public);\n+                parent\n+            }\n             ItemFn(_, fn_style, _, _, _) => {\n                 let name_bindings =\n                     self.add_child(ident, parent.clone(), ForbidDuplicateValues, sp);\n@@ -1829,7 +1835,7 @@ impl<'a> Resolver<'a> {\n                 csearch::get_tuple_struct_definition_if_ctor(&self.session.cstore, ctor_id)\n                     .map_or(def, |_| DefStruct(ctor_id)), DUMMY_SP, is_public);\n           }\n-          DefFn(..) | DefStaticMethod(..) | DefStatic(..) => {\n+          DefFn(..) | DefStaticMethod(..) | DefStatic(..) | DefConst(..) => {\n             debug!(\"(building reduced graph for external \\\n                     crate) building value (fn/static) {}\", final_ident);\n             child_name_bindings.define_value(def, DUMMY_SP, is_public);\n@@ -4216,7 +4222,7 @@ impl<'a> Resolver<'a> {\n                                       &**block);\n             }\n \n-            ItemStatic(..) => {\n+            ItemConst(..) | ItemStatic(..) => {\n                 self.with_constant_rib(|this| {\n                     visit::walk_item(this, item);\n                 });\n@@ -5084,6 +5090,7 @@ impl<'a> Resolver<'a> {\n                         Some(def @ (DefFn(..), _))      |\n                         Some(def @ (DefVariant(..), _)) |\n                         Some(def @ (DefStruct(..), _))  |\n+                        Some(def @ (DefConst(..), _))  |\n                         Some(def @ (DefStatic(..), _)) => {\n                             self.record_def(pattern.id, def);\n                         }\n@@ -5171,12 +5178,14 @@ impl<'a> Resolver<'a> {\n                             def @ DefVariant(..) | def @ DefStruct(..) => {\n                                 return FoundStructOrEnumVariant(def, LastMod(AllPublic));\n                             }\n-                            def @ DefStatic(_, false) => {\n+                            def @ DefConst(..) => {\n                                 return FoundConst(def, LastMod(AllPublic));\n                             }\n-                            DefStatic(_, true) => {\n+                            DefStatic(..) => {\n                                 self.resolve_error(span,\n-                                    \"mutable static variables cannot be referenced in a pattern\");\n+                                                   \"static variables cannot be \\\n+                                                    referenced in a pattern, \\\n+                                                    use a `const` instead\");\n                                 return BareIdentifierPatternUnresolved;\n                             }\n                             _ => {"}, {"sha": "6d84b8cb49dd2319809190e8886a13f09779fce1", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n             ast::ItemMod(..) |\n             ast::ItemMac(..) |\n             ast::ItemForeignMod(..) |\n-            ast::ItemStatic(..) => {\n+            ast::ItemStatic(..) | ast::ItemConst(..) => {\n                 self.with(|_, f| f(RootScope), |v| visit::walk_item(v, item));\n                 return;\n             }"}, {"sha": "4aba29d7bae1639d4888a625b6d0fb5275265455", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -230,6 +230,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefAssociatedTy(..) |\n             def::DefTrait(_) => Some(recorder::TypeRef),\n             def::DefStatic(_, _) |\n+            def::DefConst(_) |\n             def::DefLocal(_) |\n             def::DefVariant(_, _, _) |\n             def::DefUpvar(..) => Some(recorder::VarRef),\n@@ -521,6 +522,29 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.visit_expr(expr);\n     }\n \n+    fn process_const(&mut self,\n+                      item: &ast::Item,\n+                      typ: &ast::Ty,\n+                      expr: &ast::Expr)\n+    {\n+        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+\n+        let sub_span = self.span.sub_span_after_keyword(item.span,\n+                                                        keywords::Const);\n+        self.fmt.static_str(item.span,\n+                            sub_span,\n+                            item.id,\n+                            get_ident(item.ident).get(),\n+                            qualname.as_slice(),\n+                            \"\",\n+                            ty_to_string(&*typ).as_slice(),\n+                            self.cur_scope);\n+\n+        // walk type and init value\n+        self.visit_ty(&*typ);\n+        self.visit_expr(expr);\n+    }\n+\n     fn process_struct(&mut self,\n                       item: &ast::Item,\n                       def: &ast::StructDef,\n@@ -740,6 +764,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefUpvar(..) |\n             def::DefLocal(..) |\n             def::DefStatic(..) |\n+            def::DefConst(..) |\n             def::DefVariant(..) => self.fmt.ref_str(recorder::VarRef,\n                                                     ex.span,\n                                                     sub_span,\n@@ -807,6 +832,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             },\n             def::DefLocal(_) |\n             def::DefStatic(_,_) |\n+            def::DefConst(..) |\n             def::DefStruct(_) |\n             def::DefFn(..) => self.write_sub_paths_truncated(path),\n             _ => {},\n@@ -1008,6 +1034,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 self.process_fn(item, &**decl, ty_params, &**body),\n             ast::ItemStatic(ref typ, mt, ref expr) =>\n                 self.process_static(item, &**typ, mt, &**expr),\n+            ast::ItemConst(ref typ, ref expr) =>\n+                self.process_const(item, &**typ, &**expr),\n             ast::ItemStruct(ref def, ref ty_params) => self.process_struct(item, &**def, ty_params),\n             ast::ItemEnum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n             ast::ItemImpl(ref ty_params,\n@@ -1386,6 +1414,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                                             self.cur_scope),\n                 // FIXME(nrc) what is this doing here?\n                 def::DefStatic(_, _) => {}\n+                def::DefConst(..) => {}\n                 _ => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n                             *def)\n             }"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/librustc/middle/traexpr", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftraexpr", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftraexpr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraexpr?ref=90d03d792669fed99b659d1efbe835d4b9b8873c"}, {"sha": "9eb02717f04a11e2b81ad6bf572fa06e6fb8e180", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -271,14 +271,14 @@ impl<'a> Opt<'a> {\n         match *self {\n             ConstantValue(ConstantExpr(lit_expr)) => {\n                 let lit_ty = ty::node_id_to_type(bcx.tcx(), lit_expr.id);\n-                let (llval, _, _) = consts::const_expr(ccx, &*lit_expr, true);\n+                let (llval, _) = consts::const_expr(ccx, &*lit_expr);\n                 let lit_datum = immediate_rvalue(llval, lit_ty);\n                 let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n                 SingleResult(Result::new(bcx, lit_datum.val))\n             }\n             ConstantRange(ConstantExpr(ref l1), ConstantExpr(ref l2)) => {\n-                let (l1, _, _) = consts::const_expr(ccx, &**l1, true);\n-                let (l2, _, _) = consts::const_expr(ccx, &**l2, true);\n+                let (l1, _) = consts::const_expr(ccx, &**l1);\n+                let (l2, _) = consts::const_expr(ccx, &**l2);\n                 RangeResult(Result::new(bcx, l1), Result::new(bcx, l2))\n             }\n             Variant(disr_val, ref repr, _) => {\n@@ -350,7 +350,20 @@ struct ArmData<'p, 'blk, 'tcx: 'blk> {\n struct Match<'a, 'p: 'a, 'blk: 'a, 'tcx: 'blk> {\n     pats: Vec<&'p ast::Pat>,\n     data: &'a ArmData<'p, 'blk, 'tcx>,\n-    bound_ptrs: Vec<(Ident, ValueRef)>\n+    bound_ptrs: Vec<(Ident, ValueRef)>,\n+\n+    // This is a pointer to an instance of check_match::DUMMY_WILD_PAT. The\n+    // check_match code requires that we pass this in (with the same lifetime as\n+    // the patterns passed in). Unfortunately this is required to be propagated\n+    // into this structure in order to get the lifetimes to work.\n+    //\n+    // Lots of the `check_match` code will deal with &DUMMY_WILD_PAT when\n+    // returning references, which used to have the `'static` lifetime before\n+    // const was added to the language. The DUMMY_WILD_PAT does not implement\n+    // Sync, however, so it must be a const, which longer has a static lifetime,\n+    // hence we're passing it in here. This certainly isn't crucial, and if it\n+    // can be removed, please do!\n+    dummy: &'p ast::Pat,\n }\n \n impl<'a, 'p, 'blk, 'tcx> Repr for Match<'a, 'p, 'blk, 'tcx> {\n@@ -403,21 +416,22 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         *pats.get_mut(col) = pat;\n         Match {\n             pats: pats,\n+            dummy: br.dummy,\n             data: &*br.data,\n             bound_ptrs: bound_ptrs\n         }\n     }).collect()\n }\n \n-type EnterPatterns<'a> = <'p> |&[&'p ast::Pat]|: 'a -> Option<Vec<&'p ast::Pat>>;\n+type EnterPatterns<'a, 'p> = |&[&'p ast::Pat]|: 'a -> Option<Vec<&'p ast::Pat>>;\n \n-fn enter_match<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   dm: &DefMap,\n-                                   m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                   col: uint,\n-                                   val: ValueRef,\n-                                   e: EnterPatterns)\n-                                   -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n+fn enter_match<'a, 'b, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                       dm: &DefMap,\n+                                       m: &[Match<'a, 'p, 'blk, 'tcx>],\n+                                       col: uint,\n+                                       val: ValueRef,\n+                                       e: EnterPatterns<'b, 'p>)\n+                                       -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"enter_match(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -450,6 +464,7 @@ fn enter_match<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n             Match {\n                 pats: pats,\n+                dummy: br.dummy,\n                 data: br.data,\n                 bound_ptrs: bound_ptrs\n             }\n@@ -544,7 +559,8 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n \n     let mcx = check_match::MatchCheckCtxt { tcx: bcx.tcx() };\n     enter_match(bcx, dm, m, col, val, |pats|\n-        check_match::specialize(&mcx, pats.as_slice(), &ctor, col, variant_size)\n+        check_match::specialize(&mcx, pats.as_slice(), m[0].dummy, &ctor, col,\n+                                variant_size)\n     )\n }\n \n@@ -1025,7 +1041,9 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     match adt_vals {\n         Some(field_vals) => {\n             let pats = enter_match(bcx, dm, m, col, val, |pats|\n-                check_match::specialize(&mcx, pats, &check_match::Single, col, field_vals.len())\n+                check_match::specialize(&mcx, pats, m[0].dummy,\n+                                        &check_match::Single, col,\n+                                        field_vals.len())\n             );\n             let vals = field_vals.append(vals_left.as_slice());\n             compile_submatch(bcx, pats.as_slice(), vals.as_slice(), chk, has_genuine_default);\n@@ -1347,6 +1365,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         bindings_map: create_bindings_map(bcx, &**arm.pats.get(0), discr_expr, &*arm.body)\n     }).collect();\n \n+    let dummy = check_match::DUMMY_WILD_PAT.clone();\n     let mut static_inliner = StaticInliner::new(scope_cx.tcx());\n     let arm_pats: Vec<Vec<P<ast::Pat>>> = arm_datas.iter().map(|arm_data| {\n         arm_data.arm.pats.iter().map(|p| static_inliner.fold_pat((*p).clone())).collect()\n@@ -1355,6 +1374,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n     for (arm_data, pats) in arm_datas.iter().zip(arm_pats.iter()) {\n         matches.extend(pats.iter().map(|p| Match {\n             pats: vec![&**p],\n+            dummy: &dummy,\n             data: arm_data,\n             bound_ptrs: Vec::new(),\n         }));"}, {"sha": "8df5b375a81678f1b15bca07db999d7fa87c88a1", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 45, "deletions": 65, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -32,7 +32,7 @@ use driver::config::{NoDebugInfo, FullDebugInfo};\n use driver::driver::{CrateAnalysis, CrateTranslation, ModuleTranslation};\n use driver::session::Session;\n use lint;\n-use llvm::{BasicBlockRef, ModuleRef, ValueRef, Vector, get_param};\n+use llvm::{BasicBlockRef, ValueRef, Vector, get_param};\n use llvm;\n use metadata::{csearch, encoder, loader};\n use middle::astencode;\n@@ -89,7 +89,7 @@ use std::rc::Rc;\n use std::{i8, i16, i32, i64};\n use syntax::abi::{X86, X86_64, Arm, Mips, Mipsel, Rust, RustCall};\n use syntax::abi::{RustIntrinsic, Abi, OsWindows};\n-use syntax::ast_util::{local_def, is_local};\n+use syntax::ast_util::local_def;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n use syntax::codemap::Span;\n@@ -317,17 +317,31 @@ pub fn decl_internal_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> Va\n     llfn\n }\n \n-pub fn get_extern_const(externs: &mut ExternMap, llmod: ModuleRef,\n-                        name: &str, ty: Type) -> ValueRef {\n-    match externs.find_equiv(&name) {\n+pub fn get_extern_const(ccx: &CrateContext, did: ast::DefId,\n+                        t: ty::t) -> ValueRef {\n+    let name = csearch::get_symbol(&ccx.sess().cstore, did);\n+    let ty = type_of(ccx, t);\n+    match ccx.externs().borrow_mut().find(&name) {\n         Some(n) => return *n,\n         None => ()\n     }\n     unsafe {\n         let c = name.with_c_str(|buf| {\n-            llvm::LLVMAddGlobal(llmod, ty.to_ref(), buf)\n+            llvm::LLVMAddGlobal(ccx.llmod(), ty.to_ref(), buf)\n         });\n-        externs.insert(name.to_string(), c);\n+        // Thread-local statics in some other crate need to *always* be linked\n+        // against in a thread-local fashion, so we need to be sure to apply the\n+        // thread-local attribute locally if it was present remotely. If we\n+        // don't do this then linker errors can be generated where the linker\n+        // complains that one object files has a thread local version of the\n+        // symbol and another one doesn't.\n+        ty::each_attr(ccx.tcx(), did, |attr| {\n+            if attr.check_name(\"thread_local\") {\n+                llvm::set_thread_local(c, true);\n+            }\n+            true\n+        });\n+        ccx.externs().borrow_mut().insert(name.to_string(), c);\n         return c;\n     }\n }\n@@ -935,11 +949,7 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n             get_extern_rust_fn(ccx, t, name.as_slice(), did)\n         }\n         _ => {\n-            let llty = type_of(ccx, t);\n-            get_extern_const(&mut *ccx.externs().borrow_mut(),\n-                             ccx.llmod(),\n-                             name.as_slice(),\n-                             llty)\n+            get_extern_const(ccx, did, t)\n         }\n     }\n }\n@@ -2228,21 +2238,19 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n       ast::ItemEnum(ref enum_definition, _) => {\n         enum_variant_size_lint(ccx, enum_definition, item.span, item.id);\n       }\n+      ast::ItemConst(_, ref expr) => {\n+          // Recurse on the expression to catch items in blocks\n+          let mut v = TransItemVisitor{ ccx: ccx };\n+          v.visit_expr(&**expr);\n+      }\n       ast::ItemStatic(_, m, ref expr) => {\n           // Recurse on the expression to catch items in blocks\n           let mut v = TransItemVisitor{ ccx: ccx };\n           v.visit_expr(&**expr);\n \n-          let trans_everywhere = attr::requests_inline(item.attrs.as_slice());\n-          for (ref ccx, is_origin) in ccx.maybe_iter(!from_external && trans_everywhere) {\n-              consts::trans_const(ccx, m, item.id);\n-\n-              let g = get_item_val(ccx, item.id);\n-              update_linkage(ccx,\n-                             g,\n-                             Some(item.id),\n-                             if is_origin { OriginalTranslation } else { InlinedCopy });\n-          }\n+          consts::trans_static(ccx, m, item.id);\n+          let g = get_item_val(ccx, item.id);\n+          update_linkage(ccx, g, Some(item.id), OriginalTranslation);\n \n           // Do static_assert checking. It can't really be done much earlier\n           // because we need to get the value of the bool out of LLVM\n@@ -2253,7 +2261,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                                          static\");\n               }\n \n-              let v = ccx.const_values().borrow().get_copy(&item.id);\n+              let v = ccx.static_values().borrow().get_copy(&item.id);\n               unsafe {\n                   if !(llvm::LLVMConstIntGetZExtValue(v) != 0) {\n                       ccx.sess().span_fatal(expr.span, \"static assertion failed\");\n@@ -2667,23 +2675,21 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     let val = match item {\n         ast_map::NodeItem(i) => {\n             let ty = ty::node_id_to_type(ccx.tcx(), i.id);\n-            let sym = exported_name(ccx, id, ty, i.attrs.as_slice());\n+            let sym = || exported_name(ccx, id, ty, i.attrs.as_slice());\n \n             let v = match i.node {\n-                ast::ItemStatic(_, mutbl, ref expr) => {\n+                ast::ItemStatic(_, _, ref expr) => {\n                     // If this static came from an external crate, then\n                     // we need to get the symbol from csearch instead of\n                     // using the current crate's name/version\n                     // information in the hash of the symbol\n+                    let sym = sym();\n                     debug!(\"making {}\", sym);\n-                    let is_local = !ccx.external_srcs().borrow().contains_key(&id);\n \n                     // We need the translated value here, because for enums the\n                     // LLVM type is not fully determined by the Rust type.\n-                    let (v, inlineable, ty) = consts::const_expr(ccx, &**expr, is_local);\n-                    ccx.const_values().borrow_mut().insert(id, v);\n-                    let mut inlineable = inlineable;\n-\n+                    let (v, ty) = consts::const_expr(ccx, &**expr);\n+                    ccx.static_values().borrow_mut().insert(id, v);\n                     unsafe {\n                         // boolean SSA values are i1, but they have to be stored in i8 slots,\n                         // otherwise some LLVM optimization passes don't work as expected\n@@ -2694,55 +2700,30 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                         };\n                         if contains_null(sym.as_slice()) {\n                             ccx.sess().fatal(\n-                                format!(\"Illegal null byte in export_name value: `{}`\",\n-                                        sym).as_slice());\n+                                format!(\"Illegal null byte in export_name \\\n+                                         value: `{}`\", sym).as_slice());\n                         }\n                         let g = sym.as_slice().with_c_str(|buf| {\n                             llvm::LLVMAddGlobal(ccx.llmod(), llty, buf)\n                         });\n \n-                        // Apply the `unnamed_addr` attribute if\n-                        // requested\n-                        if !ast_util::static_has_significant_address(\n-                                mutbl,\n-                                i.attrs.as_slice()) {\n-                            llvm::SetUnnamedAddr(g, true);\n-\n-                            // This is a curious case where we must make\n-                            // all of these statics inlineable. If a\n-                            // global is not tagged as `#[inline(never)]`,\n-                            // then LLVM won't coalesce globals unless they\n-                            // have an internal linkage type. This means that\n-                            // external crates cannot use this global.\n-                            // This is a problem for things like inner\n-                            // statics in generic functions, because the\n-                            // function will be inlined into another\n-                            // crate and then attempt to link to the\n-                            // static in the original crate, only to\n-                            // find that it's not there. On the other\n-                            // side of inlining, the crates knows to\n-                            // not declare this static as\n-                            // available_externally (because it isn't)\n-                            inlineable = true;\n-                        }\n-\n                         if attr::contains_name(i.attrs.as_slice(),\n                                                \"thread_local\") {\n                             llvm::set_thread_local(g, true);\n                         }\n-\n-                        if !inlineable {\n-                            debug!(\"{} not inlined\", sym);\n-                            ccx.non_inlineable_statics().borrow_mut()\n-                                                      .insert(id);\n-                        }\n-\n                         ccx.item_symbols().borrow_mut().insert(i.id, sym);\n                         g\n                     }\n                 }\n \n+                ast::ItemConst(_, ref expr) => {\n+                    let (v, _) = consts::const_expr(ccx, &**expr);\n+                    ccx.const_values().borrow_mut().insert(id, v);\n+                    v\n+                }\n+\n                 ast::ItemFn(_, _, abi, _, _) => {\n+                    let sym = sym();\n                     let llfn = if abi == Rust {\n                         register_fn(ccx, i.span, sym, i.id, ty)\n                     } else {\n@@ -2911,7 +2892,6 @@ pub fn crate_ctxt_to_encode_parms<'a, 'tcx>(cx: &'a SharedCrateContext<'tcx>,\n         tcx: cx.tcx(),\n         reexports2: cx.exp_map2(),\n         item_symbols: cx.item_symbols(),\n-        non_inlineable_statics: cx.non_inlineable_statics(),\n         link_meta: cx.link_meta(),\n         cstore: &cx.sess().cstore,\n         encode_inlined_item: ie,"}, {"sha": "bc562b39c98f75af9cc4212c5cb3af3aece8ba78", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -196,6 +196,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 }\n             }\n             def::DefStatic(..) |\n+            def::DefConst(..) |\n             def::DefLocal(..) |\n             def::DefUpvar(..) => {\n                 datum_callee(bcx, ref_expr)"}, {"sha": "ec357f7bfd7c68573758e677e2c2722173e45b55", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 106, "deletions": 100, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -33,7 +33,6 @@ use middle::ty;\n use util::ppaux::{Repr, ty_to_string};\n \n use std::c_str::ToCStr;\n-use std::vec;\n use libc::c_uint;\n use syntax::{ast, ast_util};\n use syntax::ptr::P;\n@@ -96,24 +95,20 @@ pub fn const_ptrcast(cx: &CrateContext, a: ValueRef, t: Type) -> ValueRef {\n     }\n }\n \n-// Helper function because we don't have tuple-swizzling.\n-fn first_two<R, S, T>((a, b, _): (R, S, T)) -> (R, S) {\n-    (a, b)\n-}\n-\n fn const_vec(cx: &CrateContext, e: &ast::Expr,\n-             es: &[P<ast::Expr>], is_local: bool) -> (ValueRef, Type, bool) {\n+             es: &[P<ast::Expr>]) -> (ValueRef, Type) {\n     let vec_ty = ty::expr_ty(cx.tcx(), e);\n     let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n     let llunitty = type_of::type_of(cx, unit_ty);\n-    let (vs, inlineable) = vec::unzip(es.iter().map(|e| first_two(const_expr(cx, &**e, is_local))));\n+    let vs = es.iter().map(|e| const_expr(cx, &**e).val0())\n+                      .collect::<Vec<_>>();\n     // If the vector contains enums, an LLVM array won't work.\n     let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n         C_struct(cx, vs.as_slice(), false)\n     } else {\n         C_array(llunitty, vs.as_slice())\n     };\n-    (v, llunitty, inlineable.iter().fold(true, |a, &b| a && b))\n+    (v, llunitty)\n }\n \n pub fn const_addr_of(cx: &CrateContext, cv: ValueRef, mutbl: ast::Mutability) -> ValueRef {\n@@ -177,29 +172,25 @@ fn const_deref(cx: &CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n }\n \n pub fn get_const_val(cx: &CrateContext,\n-                     mut def_id: ast::DefId) -> (ValueRef, bool) {\n+                     mut def_id: ast::DefId) -> ValueRef {\n     let contains_key = cx.const_values().borrow().contains_key(&def_id.node);\n     if !ast_util::is_local(def_id) || !contains_key {\n         if !ast_util::is_local(def_id) {\n             def_id = inline::maybe_instantiate_inline(cx, def_id);\n         }\n \n         match cx.tcx().map.expect_item(def_id.node).node {\n-            ast::ItemStatic(_, ast::MutImmutable, _) => {\n-                trans_const(cx, ast::MutImmutable, def_id.node);\n-            }\n+            ast::ItemConst(..) => { base::get_item_val(cx, def_id.node); }\n             _ => {}\n         }\n     }\n \n-    (cx.const_values().borrow().get_copy(&def_id.node),\n-     !cx.non_inlineable_statics().borrow().contains(&def_id.node))\n+    cx.const_values().borrow().get_copy(&def_id.node)\n }\n \n-pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef, bool, ty::t) {\n-    let (llconst, inlineable) = const_expr_unadjusted(cx, e, is_local);\n+pub fn const_expr(cx: &CrateContext, e: &ast::Expr) -> (ValueRef, ty::t) {\n+    let llconst = const_expr_unadjusted(cx, e);\n     let mut llconst = llconst;\n-    let mut inlineable = inlineable;\n     let ety = ty::expr_ty(cx.tcx(), e);\n     let mut ety_adjusted = ty::expr_ty_adjusted(cx.tcx(), e);\n     let opt_adj = cx.tcx().adjustments.borrow().find_copy(&e.id);\n@@ -213,7 +204,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                                                                    ety_adjusted,\n                                                                    def,\n                                                                    llconst,\n-                                                                   is_local);\n+                                                                   true);\n                     llconst = C_struct(cx, [wrapper, C_null(Type::i8p(cx))], false)\n                 }\n                 ty::AdjustAddEnv(store) => {\n@@ -250,7 +241,6 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                                     // Don't copy data to do a deref+ref\n                                     // (i.e., skip the last auto-deref).\n                                     if adj.autoderefs == 0 {\n-                                        inlineable = false;\n                                         llconst = const_addr_of(cx, llconst, ast::MutImmutable);\n                                     }\n                                 }\n@@ -271,7 +261,6 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n \n                                     match ty::get(ty).sty {\n                                         ty::ty_vec(unit_ty, Some(len)) => {\n-                                            inlineable = false;\n                                             let llunitty = type_of::type_of(cx, unit_ty);\n                                             let llptr = const_ptrcast(cx, llconst, llunitty);\n                                             assert_eq!(abi::slice_elt_base, 0);\n@@ -314,29 +303,25 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                          e.repr(cx.tcx()), ty_to_string(cx.tcx(), ety),\n                          csize, tsize).as_slice());\n     }\n-    (llconst, inlineable, ety_adjusted)\n+    (llconst, ety_adjusted)\n }\n \n // the bool returned is whether this expression can be inlined into other crates\n // if it's assigned to a static.\n-fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n-                         is_local: bool) -> (ValueRef, bool) {\n+fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n     let map_list = |exprs: &[P<ast::Expr>]| {\n-        exprs.iter().map(|e| first_two(const_expr(cx, &**e, is_local)))\n-             .fold((Vec::new(), true),\n-                   |(l, all_inlineable), (val, inlineable)| {\n-                (l.append_one(val), all_inlineable && inlineable)\n-             })\n+        exprs.iter().map(|e| const_expr(cx, &**e).val0())\n+             .fold(Vec::new(), |l, val| l.append_one(val))\n     };\n     unsafe {\n         let _icx = push_ctxt(\"const_expr\");\n         return match e.node {\n           ast::ExprLit(ref lit) => {\n-              (consts::const_lit(cx, e, &**lit), true)\n+              consts::const_lit(cx, e, &**lit)\n           }\n           ast::ExprBinary(b, ref e1, ref e2) => {\n-            let (te1, _, _) = const_expr(cx, &**e1, is_local);\n-            let (te2, _, _) = const_expr(cx, &**e2, is_local);\n+            let (te1, _) = const_expr(cx, &**e1);\n+            let (te2, _) = const_expr(cx, &**e2);\n \n             let te2 = base::cast_shift_const_rhs(b, te1, te2);\n \n@@ -345,7 +330,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n             let ty = ty::expr_ty(cx.tcx(), &**e1);\n             let is_float = ty::type_is_fp(ty);\n             let signed = ty::type_is_signed(ty);\n-            return (match b {\n+            return match b {\n               ast::BiAdd   => {\n                 if is_float { llvm::LLVMConstFAdd(te1, te2) }\n                 else        { llvm::LLVMConstAdd(te1, te2) }\n@@ -414,13 +399,13 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                       else      { ConstICmp(IntUGT, te1, te2) }\n                   }\n               },\n-            }, true)\n+            }\n           },\n           ast::ExprUnary(u, ref e) => {\n-            let (te, _, _) = const_expr(cx, &**e, is_local);\n+            let (te, _) = const_expr(cx, &**e);\n             let ty = ty::expr_ty(cx.tcx(), &**e);\n             let is_float = ty::type_is_fp(ty);\n-            return (match u {\n+            return match u {\n               ast::UnUniq | ast::UnDeref => {\n                 let (dv, _dt) = const_deref(cx, te, ty, true);\n                 dv\n@@ -430,26 +415,26 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                 if is_float { llvm::LLVMConstFNeg(te) }\n                 else        { llvm::LLVMConstNeg(te) }\n               }\n-            }, true)\n+            }\n           }\n           ast::ExprField(ref base, field, _) => {\n-              let (bv, inlineable, bt) = const_expr(cx, &**base, is_local);\n+              let (bv, bt) = const_expr(cx, &**base);\n               let brepr = adt::represent_type(cx, bt);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, field_tys| {\n                   let ix = ty::field_idx_strict(cx.tcx(), field.node.name, field_tys);\n-                  (adt::const_get_field(cx, &*brepr, bv, discr, ix), inlineable)\n+                  adt::const_get_field(cx, &*brepr, bv, discr, ix)\n               })\n           }\n           ast::ExprTupField(ref base, idx, _) => {\n-              let (bv, inlineable, bt) = const_expr(cx, &**base, is_local);\n+              let (bv, bt) = const_expr(cx, &**base);\n               let brepr = adt::represent_type(cx, bt);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, _| {\n-                  (adt::const_get_field(cx, &*brepr, bv, discr, idx.node), inlineable)\n+                  adt::const_get_field(cx, &*brepr, bv, discr, idx.node)\n               })\n           }\n \n           ast::ExprIndex(ref base, ref index) => {\n-              let (bv, inlineable, bt) = const_expr(cx, &**base, is_local);\n+              let (bv, bt) = const_expr(cx, &**base);\n               let iv = match const_eval::eval_const_expr(cx.tcx(), &**index) {\n                   const_eval::const_int(i) => i as u64,\n                   const_eval::const_uint(u) => u,\n@@ -500,13 +485,13 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                   cx.sess().span_err(e.span,\n                                      \"const index-expr is out of bounds\");\n               }\n-              (const_get_elt(cx, arr, [iv as c_uint]), inlineable)\n+              const_get_elt(cx, arr, [iv as c_uint])\n           }\n           ast::ExprCast(ref base, _) => {\n             let ety = ty::expr_ty(cx.tcx(), e);\n             let llty = type_of::type_of(cx, ety);\n-            let (v, inlineable, basety) = const_expr(cx, &**base, is_local);\n-            return (match (expr::cast_type_kind(cx.tcx(), basety),\n+            let (v, basety) = const_expr(cx, &**base);\n+            return match (expr::cast_type_kind(cx.tcx(), basety),\n                            expr::cast_type_kind(cx.tcx(), ety)) {\n \n               (expr::cast_integral, expr::cast_integral) => {\n@@ -554,54 +539,73 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                 cx.sess().impossible_case(e.span,\n                                           \"bad combination of types for cast\")\n               }\n-            }, inlineable)\n+            }\n           }\n           ast::ExprAddrOf(mutbl, ref sub) => {\n-              let (e, _, _) = const_expr(cx, &**sub, is_local);\n-              (const_addr_of(cx, e, mutbl), false)\n+              // If this is the address of some static, then we need to return\n+              // the actual address of the static itself (short circuit the rest\n+              // of const eval).\n+              let mut cur = sub;\n+              loop {\n+                  match cur.node {\n+                      ast::ExprParen(ref sub) => cur = sub,\n+                      _ => break,\n+                  }\n+              }\n+              let opt_def = cx.tcx().def_map.borrow().find_copy(&cur.id);\n+              match opt_def {\n+                  Some(def::DefStatic(def_id, _)) => {\n+                      let ty = ty::expr_ty(cx.tcx(), e);\n+                      return get_static_val(cx, def_id, ty);\n+                  }\n+                  _ => {}\n+              }\n+\n+              // If this isn't the address of a static, then keep going through\n+              // normal constant evaluation.\n+              let (e, _) = const_expr(cx, &**sub);\n+              const_addr_of(cx, e, mutbl)\n           }\n           ast::ExprTup(ref es) => {\n               let ety = ty::expr_ty(cx.tcx(), e);\n               let repr = adt::represent_type(cx, ety);\n-              let (vals, inlineable) = map_list(es.as_slice());\n-              (adt::trans_const(cx, &*repr, 0, vals.as_slice()), inlineable)\n+              let vals = map_list(es.as_slice());\n+              adt::trans_const(cx, &*repr, 0, vals.as_slice())\n           }\n           ast::ExprStruct(_, ref fs, ref base_opt) => {\n               let ety = ty::expr_ty(cx.tcx(), e);\n               let repr = adt::represent_type(cx, ety);\n               let tcx = cx.tcx();\n \n               let base_val = match *base_opt {\n-                Some(ref base) => Some(const_expr(cx, &**base, is_local)),\n+                Some(ref base) => Some(const_expr(cx, &**base)),\n                 None => None\n               };\n \n               expr::with_field_tys(tcx, ety, Some(e.id), |discr, field_tys| {\n-                  let (cs, inlineable) = vec::unzip(field_tys.iter().enumerate()\n-                      .map(|(ix, &field_ty)| {\n+                  let cs = field_tys.iter().enumerate()\n+                                    .map(|(ix, &field_ty)| {\n                       match fs.iter().find(|f| field_ty.ident.name == f.ident.node.name) {\n-                          Some(ref f) => first_two(const_expr(cx, &*f.expr, is_local)),\n+                          Some(ref f) => const_expr(cx, &*f.expr).val0(),\n                           None => {\n                               match base_val {\n-                                Some((bv, inlineable, _)) => {\n-                                    (adt::const_get_field(cx, &*repr, bv, discr, ix),\n-                                     inlineable)\n-                                }\n-                                None => cx.sess().span_bug(e.span, \"missing struct field\")\n+                                  Some((bv, _)) => {\n+                                      adt::const_get_field(cx, &*repr, bv,\n+                                                           discr, ix)\n+                                  }\n+                                  None => {\n+                                      cx.sess().span_bug(e.span,\n+                                                         \"missing struct field\")\n+                                  }\n                               }\n                           }\n                       }\n-                  }));\n-                  (adt::trans_const(cx, &*repr, discr, cs.as_slice()),\n-                   inlineable.iter().fold(true, |a, &b| a && b))\n+                  }).collect::<Vec<_>>();\n+                  adt::trans_const(cx, &*repr, discr, cs.as_slice())\n               })\n           }\n           ast::ExprVec(ref es) => {\n-            let (v, _, inlineable) = const_vec(cx,\n-                                               e,\n-                                               es.as_slice(),\n-                                               is_local);\n-            (v, inlineable)\n+            const_vec(cx, e, es.as_slice()).val0()\n           }\n           ast::ExprRepeat(ref elem, ref count) => {\n             let vec_ty = ty::expr_ty(cx.tcx(), e);\n@@ -612,13 +616,12 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                 const_eval::const_uint(i) => i as uint,\n                 _ => cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n             };\n-            let vs = Vec::from_elem(n, const_expr(cx, &**elem, is_local).val0());\n-            let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n+            let vs = Vec::from_elem(n, const_expr(cx, &**elem).val0());\n+            if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n                 C_struct(cx, vs.as_slice(), false)\n             } else {\n                 C_array(llunitty, vs.as_slice())\n-            };\n-            (v, true)\n+            }\n           }\n           ast::ExprPath(ref pth) => {\n             // Assert that there are no type parameters in this path.\n@@ -629,13 +632,13 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                 Some(def::DefFn(def_id, _fn_style, _)) => {\n                     if !ast_util::is_local(def_id) {\n                         let ty = csearch::get_type(cx.tcx(), def_id).ty;\n-                        (base::trans_external_path(cx, def_id, ty), true)\n+                        base::trans_external_path(cx, def_id, ty)\n                     } else {\n                         assert!(ast_util::is_local(def_id));\n-                        (base::get_item_val(cx, def_id.node), true)\n+                        base::get_item_val(cx, def_id.node)\n                     }\n                 }\n-                Some(def::DefStatic(def_id, false)) => {\n+                Some(def::DefConst(def_id)) => {\n                     get_const_val(cx, def_id)\n                 }\n                 Some(def::DefVariant(enum_did, variant_did, _)) => {\n@@ -644,15 +647,16 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                     let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                          enum_did,\n                                                          variant_did);\n-                    (adt::trans_const(cx, &*repr, vinfo.disr_val, []), true)\n+                    adt::trans_const(cx, &*repr, vinfo.disr_val, [])\n                 }\n                 Some(def::DefStruct(_)) => {\n                     let ety = ty::expr_ty(cx.tcx(), e);\n                     let llty = type_of::type_of(cx, ety);\n-                    (C_null(llty), true)\n+                    C_null(llty)\n                 }\n                 _ => {\n-                    cx.sess().span_bug(e.span, \"expected a const, fn, struct, or variant def\")\n+                    cx.sess().span_bug(e.span, \"expected a const, fn, struct, \\\n+                                                or variant def\")\n                 }\n             }\n           }\n@@ -662,30 +666,29 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                   Some(def::DefStruct(_)) => {\n                       let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n-                      let (arg_vals, inlineable) = map_list(args.as_slice());\n-                      (adt::trans_const(cx, &*repr, 0, arg_vals.as_slice()),\n-                       inlineable)\n+                      let arg_vals = map_list(args.as_slice());\n+                      adt::trans_const(cx, &*repr, 0, arg_vals.as_slice())\n                   }\n                   Some(def::DefVariant(enum_did, variant_did, _)) => {\n                       let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n                       let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                            enum_did,\n                                                            variant_did);\n-                      let (arg_vals, inlineable) = map_list(args.as_slice());\n-                      (adt::trans_const(cx,\n-                                        &*repr,\n-                                        vinfo.disr_val,\n-                                        arg_vals.as_slice()), inlineable)\n+                      let arg_vals = map_list(args.as_slice());\n+                      adt::trans_const(cx,\n+                                       &*repr,\n+                                       vinfo.disr_val,\n+                                       arg_vals.as_slice())\n                   }\n                   _ => cx.sess().span_bug(e.span, \"expected a struct or variant def\")\n               }\n           }\n-          ast::ExprParen(ref e) => first_two(const_expr(cx, &**e, is_local)),\n+          ast::ExprParen(ref e) => const_expr(cx, &**e).val0(),\n           ast::ExprBlock(ref block) => {\n             match block.expr {\n-                Some(ref expr) => first_two(const_expr(cx, &**expr, is_local)),\n-                None => (C_nil(cx), true)\n+                Some(ref expr) => const_expr(cx, &**expr).val0(),\n+                None => C_nil(cx)\n             }\n           }\n           _ => cx.sess().span_bug(e.span,\n@@ -694,13 +697,13 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n     }\n }\n \n-pub fn trans_const(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) {\n+pub fn trans_static(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) {\n     unsafe {\n-        let _icx = push_ctxt(\"trans_const\");\n+        let _icx = push_ctxt(\"trans_static\");\n         let g = base::get_item_val(ccx, id);\n         // At this point, get_item_val has already translated the\n         // constant's initializer to determine its LLVM type.\n-        let v = ccx.const_values().borrow().get_copy(&id);\n+        let v = ccx.static_values().borrow().get_copy(&id);\n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected\n         let v = if llvm::LLVMTypeOf(v) == Type::i1(ccx).to_ref() {\n@@ -710,17 +713,20 @@ pub fn trans_const(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) {\n         };\n         llvm::LLVMSetInitializer(g, v);\n \n-        // `get_item_val` left `g` with external linkage, but we just set an\n-        // initializer for it.  But we don't know yet if `g` should really be\n-        // defined in this compilation unit, so we set its linkage to\n-        // `AvailableExternallyLinkage`.  (It's still a definition, but acts\n-        // like a declaration for most purposes.)  If `g` really should be\n-        // declared here, then `trans_item` will fix up the linkage later on.\n-        llvm::SetLinkage(g, llvm::AvailableExternallyLinkage);\n-\n+        // As an optimization, all shared statics which do not have interior\n+        // mutability are placed into read-only memory.\n         if m != ast::MutMutable {\n-            llvm::LLVMSetGlobalConstant(g, True);\n+            let node_ty = ty::node_id_to_type(ccx.tcx(), id);\n+            let tcontents = ty::type_contents(ccx.tcx(), node_ty);\n+            if !tcontents.interior_unsafe() {\n+                llvm::LLVMSetGlobalConstant(g, True);\n+            }\n         }\n         debuginfo::create_global_var_metadata(ccx, id, g);\n     }\n }\n+\n+fn get_static_val(ccx: &CrateContext, did: ast::DefId, ty: ty::t) -> ValueRef {\n+    if ast_util::is_local(did) { return base::get_item_val(ccx, did.node) }\n+    base::trans_external_path(ccx, did, ty)\n+}"}, {"sha": "ee5ba61a295cfb080a793fe881ef139ff9c91532", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -66,10 +66,6 @@ pub struct SharedCrateContext<'tcx> {\n     reachable: NodeSet,\n     item_symbols: RefCell<NodeMap<String>>,\n     link_meta: LinkMeta,\n-    /// A set of static items which cannot be inlined into other crates. This\n-    /// will prevent in IIItem() structures from being encoded into the metadata\n-    /// that is generated\n-    non_inlineable_statics: RefCell<NodeSet>,\n     symbol_hasher: RefCell<Sha256>,\n     tcx: ty::ctxt<'tcx>,\n     stats: Stats,\n@@ -121,6 +117,9 @@ pub struct LocalCrateContext {\n     /// Cache of emitted const values\n     const_values: RefCell<NodeMap<ValueRef>>,\n \n+    /// Cache of emitted static values\n+    static_values: RefCell<NodeMap<ValueRef>>,\n+\n     /// Cache of external const values\n     extern_const_values: RefCell<DefIdMap<ValueRef>>,\n \n@@ -259,7 +258,6 @@ impl<'tcx> SharedCrateContext<'tcx> {\n             reachable: reachable,\n             item_symbols: RefCell::new(NodeMap::new()),\n             link_meta: link_meta,\n-            non_inlineable_statics: RefCell::new(NodeSet::new()),\n             symbol_hasher: RefCell::new(symbol_hasher),\n             tcx: tcx,\n             stats: Stats {\n@@ -351,10 +349,6 @@ impl<'tcx> SharedCrateContext<'tcx> {\n         &self.link_meta\n     }\n \n-    pub fn non_inlineable_statics<'a>(&'a self) -> &'a RefCell<NodeSet> {\n-        &self.non_inlineable_statics\n-    }\n-\n     pub fn symbol_hasher<'a>(&'a self) -> &'a RefCell<Sha256> {\n         &self.symbol_hasher\n     }\n@@ -414,6 +408,7 @@ impl LocalCrateContext {\n                 const_cstr_cache: RefCell::new(HashMap::new()),\n                 const_globals: RefCell::new(HashMap::new()),\n                 const_values: RefCell::new(NodeMap::new()),\n+                static_values: RefCell::new(NodeMap::new()),\n                 extern_const_values: RefCell::new(DefIdMap::new()),\n                 impl_method_cache: RefCell::new(HashMap::new()),\n                 closure_bare_wrapper_cache: RefCell::new(HashMap::new()),\n@@ -610,10 +605,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.external_srcs\n     }\n \n-    pub fn non_inlineable_statics<'a>(&'a self) -> &'a RefCell<NodeSet> {\n-        &self.shared.non_inlineable_statics\n-    }\n-\n     pub fn monomorphized<'a>(&'a self) -> &'a RefCell<HashMap<MonoId, ValueRef>> {\n         &self.local.monomorphized\n     }\n@@ -638,6 +629,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.const_values\n     }\n \n+    pub fn static_values<'a>(&'a self) -> &'a RefCell<NodeMap<ValueRef>> {\n+        &self.local.static_values\n+    }\n+\n     pub fn extern_const_values<'a>(&'a self) -> &'a RefCell<DefIdMap<ValueRef>> {\n         &self.local.extern_const_values\n     }"}, {"sha": "ec92f935c49be3ab2be09683e5b96187f4b70fa6", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -776,6 +776,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n         ast_map::NodeItem(item) => {\n             match item.node {\n                 ast::ItemStatic(..) => (item.ident, item.span),\n+                ast::ItemConst(..) => (item.ident, item.span),\n                 _ => {\n                     cx.sess()\n                       .span_bug(item.span,"}, {"sha": "19c9c5e0119d2aafa255870b74be6a9fe2d0a999", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -36,7 +36,6 @@\n use back::abi;\n use llvm;\n use llvm::{ValueRef};\n-use metadata::csearch;\n use middle::def;\n use middle::mem_categorization::Typer;\n use middle::subst;\n@@ -839,25 +838,20 @@ fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans_def_fn_unadjusted(bcx, ref_expr, def)\n         }\n         def::DefStatic(did, _) => {\n-            // There are three things that may happen here:\n+            // There are two things that may happen here:\n             //  1) If the static item is defined in this crate, it will be\n             //     translated using `get_item_val`, and we return a pointer to\n             //     the result.\n-            //  2) If the static item is defined in another crate, but is\n-            //     marked inlineable, then it will be inlined into this crate\n-            //     and then translated with `get_item_val`.  Again, we return a\n-            //     pointer to the result.\n-            //  3) If the static item is defined in another crate and is not\n-            //     marked inlineable, then we add (or reuse) a declaration of\n-            //     an external global, and return a pointer to that.\n+            //  2) If the static item is defined in another crate then we add\n+            //     (or reuse) a declaration of an external global, and return a\n+            //     pointer to that.\n             let const_ty = expr_ty(bcx, ref_expr);\n \n-            fn get_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, did: ast::DefId, const_ty: ty::t)\n-                                   -> ValueRef {\n+            fn get_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, did: ast::DefId,\n+                                   const_ty: ty::t) -> ValueRef {\n                 // For external constants, we don't inline.\n                 if did.krate == ast::LOCAL_CRATE {\n-                    // Case 1 or 2.  (The inlining in case 2 produces a new\n-                    // DefId in LOCAL_CRATE.)\n+                    // Case 1.\n \n                     // The LLVM global has the type of its initializer,\n                     // which may not be equal to the enum's type for\n@@ -866,36 +860,41 @@ fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     let pty = type_of::type_of(bcx.ccx(), const_ty).ptr_to();\n                     PointerCast(bcx, val, pty)\n                 } else {\n-                    // Case 3.\n-                    match bcx.ccx().extern_const_values().borrow().find(&did) {\n-                        None => {}  // Continue.\n-                        Some(llval) => {\n-                            return *llval;\n-                        }\n-                    }\n-\n-                    unsafe {\n-                        let llty = type_of::type_of(bcx.ccx(), const_ty);\n-                        let symbol = csearch::get_symbol(\n-                            &bcx.ccx().sess().cstore,\n-                            did);\n-                        let llval = symbol.as_slice().with_c_str(|buf| {\n-                                llvm::LLVMAddGlobal(bcx.ccx().llmod(),\n-                                                    llty.to_ref(),\n-                                                    buf)\n-                            });\n-                        bcx.ccx().extern_const_values().borrow_mut()\n-                           .insert(did, llval);\n-                        llval\n-                    }\n+                    // Case 2.\n+                    base::get_extern_const(bcx.ccx(), did, const_ty)\n                 }\n             }\n-            // The DefId produced by `maybe_instantiate_inline`\n-            // may be in the LOCAL_CRATE or not.\n-            let did = inline::maybe_instantiate_inline(bcx.ccx(), did);\n             let val = get_val(bcx, did, const_ty);\n             DatumBlock::new(bcx, Datum::new(val, const_ty, LvalueExpr))\n         }\n+        def::DefConst(did) => {\n+            // First, inline any external constants into the local crate so we\n+            // can be sure to get the LLVM value corresponding to it.\n+            let did = inline::maybe_instantiate_inline(bcx.ccx(), did);\n+            if did.krate != ast::LOCAL_CRATE {\n+                bcx.tcx().sess.span_bug(ref_expr.span,\n+                                        \"cross crate constant could not \\\n+                                         be inlined\");\n+            }\n+            let val = base::get_item_val(bcx.ccx(), did.node);\n+\n+            // Next, we need to crate a ByRef rvalue datum to return. We can't\n+            // use the normal .to_ref_datum() function because the type of\n+            // `val` is not actually the same as `const_ty`.\n+            //\n+            // To get around this, we make a custom alloca slot with the\n+            // appropriate type (const_ty), and then we cast it to a pointer of\n+            // typeof(val), store the value, and then hand this slot over to\n+            // the datum infrastructure.\n+            let const_ty = expr_ty(bcx, ref_expr);\n+            let llty = type_of::type_of(bcx.ccx(), const_ty);\n+            let slot = alloca(bcx, llty, \"const\");\n+            let pty = Type::from_ref(unsafe { llvm::LLVMTypeOf(val) }).ptr_to();\n+            Store(bcx, val, PointerCast(bcx, slot, pty));\n+\n+            let datum = Datum::new(slot, const_ty, Rvalue::new(ByRef));\n+            DatumBlock::new(bcx, datum.to_expr_datum())\n+        }\n         _ => {\n             DatumBlock::new(bcx, trans_local_var(bcx, def).to_expr_datum())\n         }"}, {"sha": "048402782a6d96b5a41d07ae4bd7efb533f0ff73", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -17,7 +17,6 @@ use middle::ty;\n \n use syntax::ast;\n use syntax::ast_util::{local_def, PostExpansionMethod};\n-use syntax::ast_util;\n \n fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n     -> Option<ast::DefId> {\n@@ -76,21 +75,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n                         }\n                     }\n                 }\n-                ast::ItemStatic(_, mutbl, _) => {\n-                    if !ast_util::static_has_significant_address(mutbl, item.attrs.as_slice()) {\n-                        // Inlined static items use internal linkage when\n-                        // possible, so that LLVM will coalesce globals with\n-                        // identical initializers.  (It only does this for\n-                        // globals with unnamed_addr and either internal or\n-                        // private linkage.)\n-                        Some(InternalLinkage)\n-                    } else {\n-                        // The address is significant, so we can't create an\n-                        // internal copy of the static.  (The copy would have a\n-                        // different address from the original.)\n-                        Some(AvailableExternallyLinkage)\n-                    }\n-                }\n+                ast::ItemConst(..) => None,\n                 _ => unreachable!(),\n             };\n "}, {"sha": "e1491c1f49be24fc20680fb9c90a8f641ab6064b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -1374,6 +1374,7 @@ impl ParameterEnvironment {\n                     ast::ItemEnum(..) |\n                     ast::ItemStruct(..) |\n                     ast::ItemImpl(..) |\n+                    ast::ItemConst(..) |\n                     ast::ItemStatic(..) => {\n                         let def_id = ast_util::local_def(id);\n                         let pty = ty::lookup_item_type(cx, def_id);\n@@ -3576,6 +3577,8 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                 def::DefUpvar(..) |\n                 def::DefLocal(..) => LvalueExpr,\n \n+                def::DefConst(..) => RvalueDatumExpr,\n+\n                 def => {\n                     tcx.sess.span_bug(\n                         expr.span,"}, {"sha": "68bb3fcf945446534dd93c0d5a1832f44e1ac317", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -677,7 +677,8 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n     let _indenter = indenter();\n \n     match it.node {\n-      ast::ItemStatic(_, _, ref e) => check_const(ccx, it.span, &**e, it.id),\n+      ast::ItemStatic(_, _, ref e) |\n+      ast::ItemConst(_, ref e) => check_const(ccx, it.span, &**e, it.id),\n       ast::ItemEnum(ref enum_definition, _) => {\n         check_enum_variants(ccx,\n                             it.span,\n@@ -5083,7 +5084,7 @@ pub fn polytype_for_def(fcx: &FnCtxt,\n       }\n       def::DefFn(id, _, _) | def::DefStaticMethod(id, _, _) |\n       def::DefStatic(id, _) | def::DefVariant(_, id, _) |\n-      def::DefStruct(id) => {\n+      def::DefStruct(id) | def::DefConst(id) => {\n         return ty::lookup_item_type(fcx.ccx.tcx, id);\n       }\n       def::DefTrait(_) |\n@@ -5211,6 +5212,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n \n         // Case 2. Reference to a top-level value.\n         def::DefFn(..) |\n+        def::DefConst(..) |\n         def::DefStatic(..) => {\n             segment_spaces = Vec::from_elem(path.segments.len() - 1, None);\n             segment_spaces.push(Some(subst::FnSpace));"}, {"sha": "4c3cec1aff42f2005c760fb9de67ca9f87fbc73e", "filename": "src/librustc/middle/typeck/check/wf.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -69,6 +69,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             ast::ItemStatic(..) => {\n                 self.check_item_type(item);\n             }\n+            ast::ItemConst(..) => {\n+                self.check_item_type(item);\n+            }\n             ast::ItemStruct(ref struct_def, _) => {\n                 self.check_type_defn(item, |fcx| {\n                     vec![struct_variant(fcx, &**struct_def)]"}, {"sha": "0b5c86fea7123435c926985f564e4ecdfdd6633a", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -1550,7 +1550,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n         _ => {}\n     }\n     match it.node {\n-        ast::ItemStatic(ref t, _, _) => {\n+        ast::ItemStatic(ref t, _, _) | ast::ItemConst(ref t, _) => {\n             let typ = ccx.to_ty(&ExplicitRscope, &**t);\n             let pty = no_params(typ);\n "}, {"sha": "6ef2143b624f821543f4759fa52720f9d2c5df3d", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -197,7 +197,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n             }\n \n             return match it.node {\n-                ast::ItemStatic(..) | ast::ItemFn(..) |\n+                ast::ItemConst(..) | ast::ItemStatic(..) | ast::ItemFn(..) |\n                 ast::ItemForeignMod(..) | ast::ItemTy(..) => {\n                     None\n                 }"}, {"sha": "60a7aa77904420b151b397fa31f1d3823472ce03", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -384,6 +384,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n \n             ast::ItemImpl(..) |\n             ast::ItemStatic(..) |\n+            ast::ItemConst(..) |\n             ast::ItemFn(..) |\n             ast::ItemMod(..) |\n             ast::ItemForeignMod(..) |\n@@ -528,6 +529,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n             }\n \n             ast::ItemStatic(..) |\n+            ast::ItemConst(..) |\n             ast::ItemFn(..) |\n             ast::ItemMod(..) |\n             ast::ItemForeignMod(..) |"}, {"sha": "c47d6b0fc9dc8ee3370c73da2b53a35a5cbbf508", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -1309,6 +1309,7 @@ pub struct Item {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Item_ {\n     ItemStatic(P<Ty>, Mutability, P<Expr>),\n+    ItemConst(P<Ty>, P<Expr>),\n     ItemFn(P<FnDecl>, FnStyle, Abi, Generics, P<Block>),\n     ItemMod(Mod),\n     ItemForeignMod(ForeignMod),"}, {"sha": "2d0cea2fefc9d0576707f5ac0d0f98d1b0e61c46", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -1018,6 +1018,7 @@ fn node_id_to_string(map: &Map, id: NodeId) -> String {\n             let path_str = map.path_to_str_with_ident(id, item.ident);\n             let item_str = match item.node {\n                 ItemStatic(..) => \"static\",\n+                ItemConst(..) => \"const\",\n                 ItemFn(..) => \"fn\",\n                 ItemMod(..) => \"mod\",\n                 ItemForeignMod(..) => \"foreign mod\","}, {"sha": "f51c2985f0bf413701222b08b8ef7170b5d3b176", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -12,8 +12,6 @@ use abi::Abi;\n use ast::*;\n use ast;\n use ast_util;\n-use attr::{InlineNever, InlineNone};\n-use attr;\n use codemap;\n use codemap::Span;\n use owned_slice::OwnedSlice;\n@@ -706,18 +704,6 @@ pub fn lit_is_str(lit: &Lit) -> bool {\n     }\n }\n \n-/// Returns true if the static with the given mutability and attributes\n-/// has a significant address and false otherwise.\n-pub fn static_has_significant_address(mutbl: ast::Mutability,\n-                                              attrs: &[ast::Attribute])\n-                                              -> bool {\n-    if mutbl == ast::MutMutable {\n-        return true\n-    }\n-    let inline = attr::find_inline_attr(attrs);\n-    inline == InlineNever || inline == InlineNone\n-}\n-\n /// Macro invocations are guaranteed not to occur after expansion is complete.\n /// Extracting fields of a method requires a dynamic check to make sure that it's\n /// not a macro invocation. This check is guaranteed to succeed, assuming"}, {"sha": "87983e1aea3a920df1412c5742ecae3fce3fae72", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -250,6 +250,13 @@ pub trait AstBuilder {\n                    expr: P<ast::Expr>)\n                    -> P<ast::Item>;\n \n+    fn item_const(&self,\n+                   span: Span,\n+                   name: Ident,\n+                   ty: P<ast::Ty>,\n+                   expr: P<ast::Expr>)\n+                   -> P<ast::Item>;\n+\n     fn item_ty_poly(&self,\n                     span: Span,\n                     name: Ident,\n@@ -1033,6 +1040,15 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.item(span, name, Vec::new(), ast::ItemStatic(ty, mutbl, expr))\n     }\n \n+    fn item_const(&self,\n+                  span: Span,\n+                  name: Ident,\n+                  ty: P<ast::Ty>,\n+                  expr: P<ast::Expr>)\n+                  -> P<ast::Item> {\n+        self.item(span, name, Vec::new(), ast::ItemConst(ty, expr))\n+    }\n+\n     fn item_ty_poly(&self, span: Span, name: Ident, ty: P<ast::Ty>,\n                     generics: Generics) -> P<ast::Item> {\n         self.item(span, name, Vec::new(), ast::ItemTy(ty, generics))"}, {"sha": "32e226361e9d45d980c02afd65936e2541e9b455", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -903,6 +903,9 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n         ItemStatic(t, m, e) => {\n             ItemStatic(folder.fold_ty(t), m, folder.fold_expr(e))\n         }\n+        ItemConst(t, e) => {\n+            ItemConst(folder.fold_ty(t), folder.fold_expr(e))\n+        }\n         ItemFn(decl, fn_style, abi, generics, body) => {\n             ItemFn(\n                 folder.fold_fn_decl(decl),"}, {"sha": "e73ffd7e58123594a29802c0b32dafbfd83d3a7f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -32,7 +32,7 @@ use ast::{FnUnboxedClosureKind, FnMutUnboxedClosureKind};\n use ast::{FnOnceUnboxedClosureKind};\n use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod};\n use ast::{Ident, NormalFn, Inherited, ImplItem, Item, Item_, ItemStatic};\n-use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl};\n+use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl, ItemConst};\n use ast::{ItemMac, ItemMod, ItemStruct, ItemTrait, ItemTy};\n use ast::{LifetimeDef, Lit, Lit_};\n use ast::{LitBool, LitChar, LitByte, LitBinary};\n@@ -4739,14 +4739,18 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_item_const(&mut self, m: Mutability) -> ItemInfo {\n+    fn parse_item_const(&mut self, m: Option<Mutability>) -> ItemInfo {\n         let id = self.parse_ident();\n         self.expect(&token::COLON);\n         let ty = self.parse_ty(true);\n         self.expect(&token::EQ);\n         let e = self.parse_expr();\n         self.commit_expr_expecting(&*e, token::SEMI);\n-        (id, ItemStatic(ty, m, e), None)\n+        let item = match m {\n+            Some(m) => ItemStatic(ty, m, e),\n+            None => ItemConst(ty, e),\n+        };\n+        (id, item, None)\n     }\n \n     /// Parse a `mod <foo> { ... }` or `mod <foo>;` item\n@@ -5296,7 +5300,7 @@ impl<'a> Parser<'a> {\n             // STATIC ITEM\n             self.bump();\n             let m = if self.eat_keyword(keywords::Mut) {MutMutable} else {MutImmutable};\n-            let (ident, item_, extra_attrs) = self.parse_item_const(m);\n+            let (ident, item_, extra_attrs) = self.parse_item_const(Some(m));\n             let last_span = self.last_span;\n             let item = self.mk_item(lo,\n                                     last_span.hi,\n@@ -5314,7 +5318,7 @@ impl<'a> Parser<'a> {\n                 self.span_err(last_span, \"const globals cannot be mutable, \\\n                                           did you mean to declare a static?\");\n             }\n-            let (ident, item_, extra_attrs) = self.parse_item_const(MutImmutable);\n+            let (ident, item_, extra_attrs) = self.parse_item_const(None);\n             let last_span = self.last_span;\n             let item = self.mk_item(lo,\n                                     last_span.hi,"}, {"sha": "321b00db47eaf28c2bf454129de039b575a0bf2e", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -757,6 +757,20 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer cbox\n             }\n+            ast::ItemConst(ref ty, ref expr) => {\n+                try!(self.head(visibility_qualified(item.vis,\n+                                                    \"const\").as_slice()));\n+                try!(self.print_ident(item.ident));\n+                try!(self.word_space(\":\"));\n+                try!(self.print_type(&**ty));\n+                try!(space(&mut self.s));\n+                try!(self.end()); // end the head-ibox\n+\n+                try!(self.word_space(\"=\"));\n+                try!(self.print_expr(&**expr));\n+                try!(word(&mut self.s, \";\"));\n+                try!(self.end()); // end the outer cbox\n+            }\n             ast::ItemFn(ref decl, fn_style, abi, ref typarams, ref body) => {\n                 try!(self.print_fn(\n                     &**decl,"}, {"sha": "9fb5742bb9b15fbc0fc19257b6d0511bbdaaf557", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -493,11 +493,10 @@ fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n                                   Some(static_lt),\n                                   ast::MutImmutable);\n     // static TESTS: $static_type = &[...];\n-    ecx.item_static(sp,\n-                    ecx.ident_of(\"TESTS\"),\n-                    static_type,\n-                    ast::MutImmutable,\n-                    test_descs)\n+    ecx.item_const(sp,\n+                   ecx.ident_of(\"TESTS\"),\n+                   static_type,\n+                   test_descs)\n }\n \n fn is_test_crate(krate: &ast::Crate) -> bool {"}, {"sha": "5c7b144f4ab6efde7d1167375e8addb6cbda93c4", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -211,7 +211,8 @@ pub fn walk_trait_ref_helper<'v,V>(visitor: &mut V, trait_ref: &'v TraitRef)\n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     visitor.visit_ident(item.span, item.ident);\n     match item.node {\n-        ItemStatic(ref typ, _, ref expr) => {\n+        ItemStatic(ref typ, _, ref expr) |\n+        ItemConst(ref typ, ref expr) => {\n             visitor.visit_ty(&**typ);\n             visitor.visit_expr(&**expr);\n         }"}, {"sha": "dffbfe155646a020e6cb6d14ca38ddd64bd05481", "filename": "src/test/compile-fail/issue-17718-const-destructors.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-destructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d03d792669fed99b659d1efbe835d4b9b8873c/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-destructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-destructors.rs?ref=90d03d792669fed99b659d1efbe835d4b9b8873c", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct A;\n+impl Drop for A {\n+    fn drop(&mut self) {}\n+}\n+\n+const FOO: A = A;\n+//~ ERROR: constants are not allowed to have destructors\n+\n+fn main() {}"}]}