{"sha": "cd7b26c6eb9b873ebe2a43ad7a51fb7554640e6a", "node_id": "C_kwDOAAsO6NoAKGNkN2IyNmM2ZWI5Yjg3M2ViZTJhNDNhZDdhNTFmYjc1NTQ2NDBlNmE", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-26T14:02:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-26T14:02:25Z"}, "message": "Merge #10352\n\n10352: feat: Implement inline callers assist r=Veykril a=Veykril\n\nFixes #7242\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "8df667a68ffb5db0d2a2d4d691e64afdc3d33bf9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8df667a68ffb5db0d2a2d4d691e64afdc3d33bf9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd7b26c6eb9b873ebe2a43ad7a51fb7554640e6a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhUH1xCRBK7hj4Ov3rIwAAz5QIABQtr01r1+fR1mZJv8nKCGit\nS+21arfjD77tIOmhMv6KEXMLx8NBkna5iBDhNZu9yMGurSyXPEkxCJqFT7Zb3FCY\nbOJNwyLDXOCg9LHtIE3t/uQNBDBtBAUj2iRGzCgEdCF+kI83QE4Xkq5cIzSeevMv\nBQzR0aFz1a5j0nzzGONdrpQr9mLAo33tI+D0h9tuB+oYkhL9x0Ga1UEn8uSu9nrA\nmhoPfl51SwJtmRVn7pvq2RTBIHbqRCLJL7WT87mLR5qX1MgB9DU3yII0oU6G1odn\n0R8Fyw/Fw8MYAE6+rOljX3Y3bkRXSpCm3vdlDpt5XZw9+cMwpoectN268pCOEM8=\n=sKU9\n-----END PGP SIGNATURE-----\n", "payload": "tree 8df667a68ffb5db0d2a2d4d691e64afdc3d33bf9\nparent 0e3e3e2a519bae999a6ba6e621300ac85e8bf1b0\nparent 215a077ee42f60c7fad26ac662726295a6c41d2d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1632664945 +0000\ncommitter GitHub <noreply@github.com> 1632664945 +0000\n\nMerge #10352\n\n10352: feat: Implement inline callers assist r=Veykril a=Veykril\n\nFixes #7242\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd7b26c6eb9b873ebe2a43ad7a51fb7554640e6a", "html_url": "https://github.com/rust-lang/rust/commit/cd7b26c6eb9b873ebe2a43ad7a51fb7554640e6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd7b26c6eb9b873ebe2a43ad7a51fb7554640e6a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e3e3e2a519bae999a6ba6e621300ac85e8bf1b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e3e3e2a519bae999a6ba6e621300ac85e8bf1b0", "html_url": "https://github.com/rust-lang/rust/commit/0e3e3e2a519bae999a6ba6e621300ac85e8bf1b0"}, {"sha": "215a077ee42f60c7fad26ac662726295a6c41d2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/215a077ee42f60c7fad26ac662726295a6c41d2d", "html_url": "https://github.com/rust-lang/rust/commit/215a077ee42f60c7fad26ac662726295a6c41d2d"}], "stats": {"total": 708, "additions": 546, "deletions": 162}, "files": [{"sha": "cc1de54dfb34b62810cd861f627f6e715dda793e", "filename": "crates/base_db/src/fixture.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd7b26c6eb9b873ebe2a43ad7a51fb7554640e6a/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd7b26c6eb9b873ebe2a43ad7a51fb7554640e6a/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Ffixture.rs?ref=cd7b26c6eb9b873ebe2a43ad7a51fb7554640e6a", "patch": "@@ -161,7 +161,8 @@ impl ChangeFixture {\n         }\n \n         if crates.is_empty() {\n-            let crate_root = default_crate_root.unwrap();\n+            let crate_root = default_crate_root\n+                .expect(\"missing default crate root, specify a main.rs or lib.rs\");\n             crate_graph.add_crate_root(\n                 crate_root,\n                 Edition::CURRENT,"}, {"sha": "9927ceb74ec6beba6329e6d8421a2c526762b1db", "filename": "crates/ide_assists/src/handlers/inline_call.rs", "status": "modified", "additions": 486, "deletions": 159, "changes": 645, "blob_url": "https://github.com/rust-lang/rust/blob/cd7b26c6eb9b873ebe2a43ad7a51fb7554640e6a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd7b26c6eb9b873ebe2a43ad7a51fb7554640e6a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=cd7b26c6eb9b873ebe2a43ad7a51fb7554640e6a", "patch": "@@ -1,17 +1,158 @@\n use ast::make;\n-use hir::{HasSource, PathResolution, TypeInfo};\n-use ide_db::{defs::Definition, path_transform::PathTransform, search::FileReference};\n-use itertools::izip;\n+use either::Either;\n+use hir::{db::HirDatabase, HasSource, PathResolution, Semantics, TypeInfo};\n+use ide_db::{\n+    base_db::{FileId, FileRange},\n+    defs::Definition,\n+    helpers::insert_use::remove_path_if_in_use_stmt,\n+    path_transform::PathTransform,\n+    search::{FileReference, SearchScope},\n+    RootDatabase,\n+};\n+use itertools::{izip, Itertools};\n use syntax::{\n     ast::{self, edit_in_place::Indent, ArgListOwner},\n-    ted, AstNode,\n+    ted, AstNode, SyntaxNode,\n };\n \n use crate::{\n     assist_context::{AssistContext, Assists},\n     AssistId, AssistKind,\n };\n \n+// Assist: inline_into_callers\n+//\n+// Inline a function or method body into all of its callers where possible, creating a `let` statement per parameter\n+// unless the parameter can be inlined. The parameter will be inlined either if it the supplied argument is a simple local\n+// or if the parameter is only accessed inside the function body once.\n+// If all calls can be inlined the function will be removed.\n+//\n+// ```\n+// fn print(_: &str) {}\n+// fn foo$0(word: &str) {\n+//     if !word.is_empty() {\n+//         print(word);\n+//     }\n+// }\n+// fn bar() {\n+//     foo(\"\uc548\ub155\ud558\uc138\uc694\");\n+//     foo(\"\uc5ec\ub7ec\ubd84\");\n+// }\n+// ```\n+// ->\n+// ```\n+// fn print(_: &str) {}\n+//\n+// fn bar() {\n+//     {\n+//         let word = \"\uc548\ub155\ud558\uc138\uc694\";\n+//         if !word.is_empty() {\n+//             print(word);\n+//         }\n+//     };\n+//     {\n+//         let word = \"\uc5ec\ub7ec\ubd84\";\n+//         if !word.is_empty() {\n+//             print(word);\n+//         }\n+//     };\n+// }\n+// ```\n+pub(crate) fn inline_into_callers(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let def_file = ctx.frange.file_id;\n+    let name = ctx.find_node_at_offset::<ast::Name>()?;\n+    let ast_func = name.syntax().parent().and_then(ast::Fn::cast)?;\n+    let func_body = ast_func.body()?;\n+    let param_list = ast_func.param_list()?;\n+\n+    let function = ctx.sema.to_def(&ast_func)?;\n+\n+    let params = get_fn_params(ctx.sema.db, function, &param_list)?;\n+\n+    let usages = Definition::ModuleDef(hir::ModuleDef::Function(function)).usages(&ctx.sema);\n+    if !usages.at_least_one() {\n+        return None;\n+    }\n+\n+    let is_recursive_fn = usages\n+        .clone()\n+        .in_scope(SearchScope::file_range(FileRange {\n+            file_id: def_file,\n+            range: func_body.syntax().text_range(),\n+        }))\n+        .at_least_one();\n+    if is_recursive_fn {\n+        cov_mark::hit!(inline_into_callers_recursive);\n+        return None;\n+    }\n+\n+    acc.add(\n+        AssistId(\"inline_into_callers\", AssistKind::RefactorInline),\n+        \"Inline into all callers\",\n+        name.syntax().text_range(),\n+        |builder| {\n+            let mut usages = usages.all();\n+            let current_file_usage = usages.references.remove(&def_file);\n+\n+            let mut remove_def = true;\n+            let mut inline_refs_for_file = |file_id, refs: Vec<FileReference>| {\n+                builder.edit_file(file_id);\n+                let count = refs.len();\n+                // The collects are required as we are otherwise iterating while mutating \ud83d\ude45\u200d\u2640\ufe0f\ud83d\ude45\u200d\u2642\ufe0f\n+                let (name_refs, name_refs_use): (Vec<_>, Vec<_>) = refs\n+                    .into_iter()\n+                    .filter_map(|file_ref| match file_ref.name {\n+                        ast::NameLike::NameRef(name_ref) => Some(name_ref),\n+                        _ => None,\n+                    })\n+                    .partition_map(|name_ref| {\n+                        match name_ref.syntax().ancestors().find_map(ast::UseTree::cast) {\n+                            Some(use_tree) => Either::Right(builder.make_mut(use_tree)),\n+                            None => Either::Left(name_ref),\n+                        }\n+                    });\n+                let call_infos: Vec<_> = name_refs\n+                    .into_iter()\n+                    .filter_map(CallInfo::from_name_ref)\n+                    .map(|call_info| {\n+                        let mut_node = builder.make_syntax_mut(call_info.node.syntax().clone());\n+                        (call_info, mut_node)\n+                    })\n+                    .collect();\n+                let replaced = call_infos\n+                    .into_iter()\n+                    .map(|(call_info, mut_node)| {\n+                        let replacement =\n+                            inline(&ctx.sema, def_file, function, &func_body, &params, &call_info);\n+                        ted::replace(mut_node, replacement.syntax());\n+                    })\n+                    .count();\n+                if replaced + name_refs_use.len() == count {\n+                    // we replaced all usages in this file, so we can remove the imports\n+                    name_refs_use.into_iter().for_each(|use_tree| {\n+                        if let Some(path) = use_tree.path() {\n+                            remove_path_if_in_use_stmt(&path);\n+                        }\n+                    })\n+                } else {\n+                    remove_def = false;\n+                }\n+            };\n+            for (file_id, refs) in usages.into_iter() {\n+                inline_refs_for_file(file_id, refs);\n+            }\n+            if let Some(refs) = current_file_usage {\n+                inline_refs_for_file(def_file, refs);\n+            } else {\n+                builder.edit_file(def_file);\n+            }\n+            if remove_def {\n+                builder.delete(ast_func.syntax().text_range());\n+            }\n+        },\n+    )\n+}\n+\n // Assist: inline_call\n //\n // Inlines a function or method body creating a `let` statement per parameter unless the parameter\n@@ -34,54 +175,117 @@ use crate::{\n // }\n // ```\n pub(crate) fn inline_call(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let (label, function, arguments, generic_arg_list, expr) =\n-        if let Some(path_expr) = ctx.find_node_at_offset::<ast::PathExpr>() {\n-            let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n-            let path = path_expr.path()?;\n-\n+    let name_ref: ast::NameRef = ctx.find_node_at_offset()?;\n+    let call_info = CallInfo::from_name_ref(name_ref.clone())?;\n+    let (function, label) = match &call_info.node {\n+        CallExprNode::Call(call) => {\n+            let path = match call.expr()? {\n+                ast::Expr::PathExpr(path) => path.path(),\n+                _ => None,\n+            }?;\n             let function = match ctx.sema.resolve_path(&path)? {\n-                PathResolution::Def(hir::ModuleDef::Function(f))\n-                | PathResolution::AssocItem(hir::AssocItem::Function(f)) => f,\n+                PathResolution::Def(hir::ModuleDef::Function(f)) => f,\n+                PathResolution::AssocItem(hir::AssocItem::Function(f)) => f,\n                 _ => return None,\n             };\n-            (\n-                format!(\"Inline `{}`\", path),\n-                function,\n-                call.arg_list()?.args().collect(),\n-                path.segment().and_then(|it| it.generic_arg_list()),\n-                ast::Expr::CallExpr(call),\n-            )\n-        } else {\n-            let name_ref: ast::NameRef = ctx.find_node_at_offset()?;\n-            let call = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast)?;\n+            (function, format!(\"Inline `{}`\", path))\n+        }\n+        CallExprNode::MethodCallExpr(call) => {\n+            (ctx.sema.resolve_method_call(call)?, format!(\"Inline `{}`\", name_ref))\n+        }\n+    };\n+\n+    let fn_source = function.source(ctx.db())?;\n+    let fn_body = fn_source.value.body()?;\n+    let param_list = fn_source.value.param_list()?;\n+\n+    let FileRange { file_id, range } = fn_source.syntax().original_file_range(ctx.sema.db);\n+    if file_id == ctx.frange.file_id && range.contains(ctx.frange.range.start()) {\n+        cov_mark::hit!(inline_call_recursive);\n+        return None;\n+    }\n+    let params = get_fn_params(ctx.sema.db, function, &param_list)?;\n+\n+    if call_info.arguments.len() != params.len() {\n+        // Can't inline the function because they've passed the wrong number of\n+        // arguments to this function\n+        cov_mark::hit!(inline_call_incorrect_number_of_arguments);\n+        return None;\n+    }\n+\n+    let syntax = call_info.node.syntax().clone();\n+    acc.add(\n+        AssistId(\"inline_call\", AssistKind::RefactorInline),\n+        label,\n+        syntax.text_range(),\n+        |builder| {\n+            let replacement = inline(&ctx.sema, file_id, function, &fn_body, &params, &call_info);\n+\n+            builder.replace_ast(\n+                match call_info.node {\n+                    CallExprNode::Call(it) => ast::Expr::CallExpr(it),\n+                    CallExprNode::MethodCallExpr(it) => ast::Expr::MethodCallExpr(it),\n+                },\n+                replacement,\n+            );\n+        },\n+    )\n+}\n+\n+enum CallExprNode {\n+    Call(ast::CallExpr),\n+    MethodCallExpr(ast::MethodCallExpr),\n+}\n+\n+impl CallExprNode {\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            CallExprNode::Call(it) => it.syntax(),\n+            CallExprNode::MethodCallExpr(it) => it.syntax(),\n+        }\n+    }\n+}\n+\n+struct CallInfo {\n+    node: CallExprNode,\n+    arguments: Vec<ast::Expr>,\n+    generic_arg_list: Option<ast::GenericArgList>,\n+}\n+\n+impl CallInfo {\n+    fn from_name_ref(name_ref: ast::NameRef) -> Option<CallInfo> {\n+        let parent = name_ref.syntax().parent()?;\n+        if let Some(call) = ast::MethodCallExpr::cast(parent.clone()) {\n             let receiver = call.receiver()?;\n-            let function = ctx.sema.resolve_method_call(&call)?;\n             let mut arguments = vec![receiver];\n             arguments.extend(call.arg_list()?.args());\n-            (\n-                format!(\"Inline `{}`\", name_ref),\n-                function,\n+            Some(CallInfo {\n+                generic_arg_list: call.generic_arg_list(),\n+                node: CallExprNode::MethodCallExpr(call),\n                 arguments,\n-                call.generic_arg_list(),\n-                ast::Expr::MethodCallExpr(call),\n-            )\n-        };\n+            })\n+        } else if let Some(segment) = ast::PathSegment::cast(parent) {\n+            let path = segment.syntax().parent().and_then(ast::Path::cast)?;\n+            let path = path.syntax().parent().and_then(ast::PathExpr::cast)?;\n+            let call = path.syntax().parent().and_then(ast::CallExpr::cast)?;\n \n-    inline_(acc, ctx, label, function, arguments, expr, generic_arg_list)\n+            Some(CallInfo {\n+                arguments: call.arg_list()?.args().collect(),\n+                node: CallExprNode::Call(call),\n+                generic_arg_list: segment.generic_arg_list(),\n+            })\n+        } else {\n+            None\n+        }\n+    }\n }\n \n-pub(crate) fn inline_(\n-    acc: &mut Assists,\n-    ctx: &AssistContext,\n-    label: String,\n+fn get_fn_params(\n+    db: &dyn HirDatabase,\n     function: hir::Function,\n-    arg_list: Vec<ast::Expr>,\n-    expr: ast::Expr,\n-    generic_arg_list: Option<ast::GenericArgList>,\n-) -> Option<()> {\n-    let hir::InFile { value: function_source, file_id } = function.source(ctx.db())?;\n-    let param_list = function_source.param_list()?;\n-    let mut assoc_fn_params = function.assoc_fn_params(ctx.sema.db).into_iter();\n+    param_list: &ast::ParamList,\n+) -> Option<Vec<(ast::Pat, Option<ast::Type>, hir::Param)>> {\n+    let mut assoc_fn_params = function.assoc_fn_params(db).into_iter();\n \n     let mut params = Vec::new();\n     if let Some(self_param) = param_list.self_param() {\n@@ -101,131 +305,116 @@ pub(crate) fn inline_(\n         params.push((param.pat()?, param.ty(), assoc_fn_params.next()?));\n     }\n \n-    if arg_list.len() != params.len() {\n-        // Can't inline the function because they've passed the wrong number of\n-        // arguments to this function\n-        cov_mark::hit!(inline_call_incorrect_number_of_arguments);\n-        return None;\n-    }\n-\n-    let fn_body = function_source.body()?;\n+    Some(params)\n+}\n \n-    acc.add(\n-        AssistId(\"inline_call\", AssistKind::RefactorInline),\n-        label,\n-        expr.syntax().text_range(),\n-        |builder| {\n-            let body = fn_body.clone_for_update();\n-\n-            let file_id = file_id.original_file(ctx.sema.db);\n-            let usages_for_locals = |local| {\n-                Definition::Local(local)\n-                    .usages(&ctx.sema)\n-                    .all()\n-                    .references\n-                    .remove(&file_id)\n-                    .unwrap_or_default()\n-                    .into_iter()\n-            };\n-            // Contains the nodes of usages of parameters.\n-            // If the inner Vec for a parameter is empty it either means there are no usages or that the parameter\n-            // has a pattern that does not allow inlining\n-            let param_use_nodes: Vec<Vec<_>> = params\n-                .iter()\n-                .map(|(pat, _, param)| {\n-                    if !matches!(pat, ast::Pat::IdentPat(pat) if pat.is_simple_ident()) {\n-                        return Vec::new();\n-                    }\n-                    usages_for_locals(param.as_local(ctx.sema.db))\n-                        .map(|FileReference { name, range, .. }| match name {\n-                            ast::NameLike::NameRef(_) => body\n-                                .syntax()\n-                                .covering_element(range)\n-                                .ancestors()\n-                                .nth(3)\n-                                .and_then(ast::PathExpr::cast),\n-                            _ => None,\n-                        })\n-                        .collect::<Option<Vec<_>>>()\n-                        .unwrap_or_default()\n-                })\n-                .collect();\n-\n-            // Rewrite `self` to `this`\n-            if param_list.self_param().is_some() {\n-                let this = || make::name_ref(\"this\").syntax().clone_for_update();\n-                usages_for_locals(params[0].2.as_local(ctx.sema.db))\n-                    .flat_map(|FileReference { name, range, .. }| match name {\n-                        ast::NameLike::NameRef(_) => Some(body.syntax().covering_element(range)),\n-                        _ => None,\n-                    })\n-                    .for_each(|it| {\n-                        ted::replace(it, &this());\n-                    })\n+fn inline(\n+    sema: &Semantics<RootDatabase>,\n+    function_def_file_id: FileId,\n+    function: hir::Function,\n+    fn_body: &ast::BlockExpr,\n+    params: &[(ast::Pat, Option<ast::Type>, hir::Param)],\n+    CallInfo { node, arguments, generic_arg_list }: &CallInfo,\n+) -> ast::Expr {\n+    let body = fn_body.clone_for_update();\n+    let usages_for_locals = |local| {\n+        Definition::Local(local)\n+            .usages(&sema)\n+            .all()\n+            .references\n+            .remove(&function_def_file_id)\n+            .unwrap_or_default()\n+            .into_iter()\n+    };\n+    let param_use_nodes: Vec<Vec<_>> = params\n+        .iter()\n+        .map(|(pat, _, param)| {\n+            if !matches!(pat, ast::Pat::IdentPat(pat) if pat.is_simple_ident()) {\n+                return Vec::new();\n             }\n-\n-            // Inline parameter expressions or generate `let` statements depending on whether inlining works or not.\n-            for ((pat, param_ty, _), usages, expr) in izip!(params, param_use_nodes, arg_list).rev()\n+            usages_for_locals(param.as_local(sema.db))\n+                .map(|FileReference { name, range, .. }| match name {\n+                    ast::NameLike::NameRef(_) => body\n+                        .syntax()\n+                        .covering_element(range)\n+                        .ancestors()\n+                        .nth(3)\n+                        .and_then(ast::PathExpr::cast),\n+                    _ => None,\n+                })\n+                .collect::<Option<Vec<_>>>()\n+                .unwrap_or_default()\n+        })\n+        .collect();\n+    if function.self_param(sema.db).is_some() {\n+        let this = || make::name_ref(\"this\").syntax().clone_for_update();\n+        usages_for_locals(params[0].2.as_local(sema.db))\n+            .flat_map(|FileReference { name, range, .. }| match name {\n+                ast::NameLike::NameRef(_) => Some(body.syntax().covering_element(range)),\n+                _ => None,\n+            })\n+            .for_each(|it| {\n+                ted::replace(it, &this());\n+            })\n+    }\n+    // Inline parameter expressions or generate `let` statements depending on whether inlining works or not.\n+    for ((pat, param_ty, _), usages, expr) in izip!(params, param_use_nodes, arguments).rev() {\n+        let expr_is_name_ref = matches!(&expr,\n+            ast::Expr::PathExpr(expr)\n+                if expr.path().and_then(|path| path.as_single_name_ref()).is_some()\n+        );\n+        match &*usages {\n+            // inline single use closure arguments\n+            [usage]\n+                if matches!(expr, ast::Expr::ClosureExpr(_))\n+                    && usage.syntax().parent().and_then(ast::Expr::cast).is_some() =>\n             {\n-                let expr_is_name_ref = matches!(&expr,\n-                    ast::Expr::PathExpr(expr)\n-                        if expr.path().and_then(|path| path.as_single_name_ref()).is_some()\n-                );\n-                match &*usages {\n-                    // inline single use closure arguments\n-                    [usage]\n-                        if matches!(expr, ast::Expr::ClosureExpr(_))\n-                            && usage.syntax().parent().and_then(ast::Expr::cast).is_some() =>\n-                    {\n-                        cov_mark::hit!(inline_call_inline_closure);\n-                        let expr = make::expr_paren(expr);\n-                        ted::replace(usage.syntax(), expr.syntax().clone_for_update());\n-                    }\n-                    // inline single use literals\n-                    [usage] if matches!(expr, ast::Expr::Literal(_)) => {\n-                        cov_mark::hit!(inline_call_inline_literal);\n-                        ted::replace(usage.syntax(), expr.syntax().clone_for_update());\n-                    }\n-                    // inline direct local arguments\n-                    [_, ..] if expr_is_name_ref => {\n-                        cov_mark::hit!(inline_call_inline_locals);\n-                        usages.into_iter().for_each(|usage| {\n-                            ted::replace(usage.syntax(), &expr.syntax().clone_for_update());\n-                        });\n-                    }\n-                    // cant inline, emit a let statement\n-                    _ => {\n-                        let ty = ctx\n-                            .sema\n-                            .type_of_expr(&expr)\n-                            .filter(TypeInfo::has_adjustment)\n-                            .and(param_ty);\n-                        body.push_front(\n-                            make::let_stmt(pat, ty, Some(expr)).clone_for_update().into(),\n-                        )\n-                    }\n-                }\n+                cov_mark::hit!(inline_call_inline_closure);\n+                let expr = make::expr_paren(expr.clone());\n+                ted::replace(usage.syntax(), expr.syntax().clone_for_update());\n             }\n-            if let Some(generic_arg_list) = generic_arg_list {\n-                PathTransform::function_call(\n-                    &ctx.sema.scope(expr.syntax()),\n-                    &ctx.sema.scope(fn_body.syntax()),\n-                    function,\n-                    generic_arg_list,\n+            // inline single use literals\n+            [usage] if matches!(expr, ast::Expr::Literal(_)) => {\n+                cov_mark::hit!(inline_call_inline_literal);\n+                ted::replace(usage.syntax(), expr.syntax().clone_for_update());\n+            }\n+            // inline direct local arguments\n+            [_, ..] if expr_is_name_ref => {\n+                cov_mark::hit!(inline_call_inline_locals);\n+                usages.into_iter().for_each(|usage| {\n+                    ted::replace(usage.syntax(), &expr.syntax().clone_for_update());\n+                });\n+            }\n+            // cant inline, emit a let statement\n+            _ => {\n+                let ty =\n+                    sema.type_of_expr(expr).filter(TypeInfo::has_adjustment).and(param_ty.clone());\n+                body.push_front(\n+                    make::let_stmt(pat.clone(), ty, Some(expr.clone())).clone_for_update().into(),\n                 )\n-                .apply(body.syntax());\n             }\n+        }\n+    }\n+    if let Some(generic_arg_list) = generic_arg_list.clone() {\n+        PathTransform::function_call(\n+            &sema.scope(node.syntax()),\n+            &sema.scope(fn_body.syntax()),\n+            function,\n+            generic_arg_list,\n+        )\n+        .apply(body.syntax());\n+    }\n \n-            let original_indentation = expr.indent_level();\n-            body.reindent_to(original_indentation);\n+    let original_indentation = match node {\n+        CallExprNode::Call(it) => it.indent_level(),\n+        CallExprNode::MethodCallExpr(it) => it.indent_level(),\n+    };\n+    body.reindent_to(original_indentation);\n \n-            let replacement = match body.tail_expr() {\n-                Some(expr) if body.statements().next().is_none() => expr,\n-                _ => ast::Expr::BlockExpr(body),\n-            };\n-            builder.replace_ast(expr, replacement);\n-        },\n-    )\n+    match body.tail_expr() {\n+        Some(expr) if body.statements().next().is_none() => expr,\n+        _ => ast::Expr::BlockExpr(body),\n+    }\n }\n \n #[cfg(test)]\n@@ -678,7 +867,7 @@ fn foo<T, const N: usize>() {\n fn bar<U, const M: usize>() {}\n \n fn main() {\n-    foo::<usize, {0}>$0();\n+    foo$0::<usize, {0}>();\n }\n \"#,\n             r#\"\n@@ -691,6 +880,144 @@ fn bar<U, const M: usize>() {}\n fn main() {\n     bar::<usize, N>();\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_callers() {\n+        check_assist(\n+            inline_into_callers,\n+            r#\"\n+fn do_the_math$0(b: u32) -> u32 {\n+    let foo = 10;\n+    foo * b + foo\n+}\n+fn foo() {\n+    do_the_math(0);\n+    let bar = 10;\n+    do_the_math(bar);\n+}\n+\"#,\n+            r#\"\n+\n+fn foo() {\n+    {\n+        let foo = 10;\n+        foo * 0 + foo\n+    };\n+    let bar = 10;\n+    {\n+        let foo = 10;\n+        foo * bar + foo\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_callers_across_files() {\n+        check_assist(\n+            inline_into_callers,\n+            r#\"\n+//- /lib.rs\n+mod foo;\n+fn do_the_math$0(b: u32) -> u32 {\n+    let foo = 10;\n+    foo * b + foo\n+}\n+//- /foo.rs\n+use super::do_the_math;\n+fn foo() {\n+    do_the_math(0);\n+    let bar = 10;\n+    do_the_math(bar);\n+}\n+\"#,\n+            r#\"\n+//- /lib.rs\n+mod foo;\n+\n+//- /foo.rs\n+fn foo() {\n+    {\n+        let foo = 10;\n+        foo * 0 + foo\n+    };\n+    let bar = 10;\n+    {\n+        let foo = 10;\n+        foo * bar + foo\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_callers_across_files_with_def_file() {\n+        check_assist(\n+            inline_into_callers,\n+            r#\"\n+//- /lib.rs\n+mod foo;\n+fn do_the_math$0(b: u32) -> u32 {\n+    let foo = 10;\n+    foo * b + foo\n+}\n+fn bar(a: u32, b: u32) -> u32 {\n+    do_the_math(0);\n+}\n+//- /foo.rs\n+use super::do_the_math;\n+fn foo() {\n+    do_the_math(0);\n+}\n+\"#,\n+            r#\"\n+//- /lib.rs\n+mod foo;\n+\n+fn bar(a: u32, b: u32) -> u32 {\n+    {\n+        let foo = 10;\n+        foo * 0 + foo\n+    };\n+}\n+//- /foo.rs\n+fn foo() {\n+    {\n+        let foo = 10;\n+        foo * 0 + foo\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_callers_recursive() {\n+        cov_mark::check!(inline_into_callers_recursive);\n+        check_assist_not_applicable(\n+            inline_into_callers,\n+            r#\"\n+fn foo$0() {\n+    foo();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_call_recursive() {\n+        cov_mark::check!(inline_call_recursive);\n+        check_assist_not_applicable(\n+            inline_call,\n+            r#\"\n+fn foo() {\n+    foo$0();\n+}\n \"#,\n         );\n     }"}, {"sha": "255ff47b8017389518fb795e7b2248b820826683", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cd7b26c6eb9b873ebe2a43ad7a51fb7554640e6a/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd7b26c6eb9b873ebe2a43ad7a51fb7554640e6a/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=cd7b26c6eb9b873ebe2a43ad7a51fb7554640e6a", "patch": "@@ -217,6 +217,7 @@ mod handlers {\n             generate_is_empty_from_len::generate_is_empty_from_len,\n             generate_new::generate_new,\n             inline_call::inline_call,\n+            inline_call::inline_into_callers,\n             inline_local_variable::inline_local_variable,\n             introduce_named_generic::introduce_named_generic,\n             introduce_named_lifetime::introduce_named_lifetime,"}, {"sha": "87b3be34984cf63d3606361a7a3e79f747a3f1bf", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cd7b26c6eb9b873ebe2a43ad7a51fb7554640e6a/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd7b26c6eb9b873ebe2a43ad7a51fb7554640e6a/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=cd7b26c6eb9b873ebe2a43ad7a51fb7554640e6a", "patch": "@@ -1051,6 +1051,43 @@ fn foo(name: Option<&str>) {\n     )\n }\n \n+#[test]\n+fn doctest_inline_into_callers() {\n+    check_doc_test(\n+        \"inline_into_callers\",\n+        r#####\"\n+fn print(_: &str) {}\n+fn foo$0(word: &str) {\n+    if !word.is_empty() {\n+        print(word);\n+    }\n+}\n+fn bar() {\n+    foo(\"\uc548\ub155\ud558\uc138\uc694\");\n+    foo(\"\uc5ec\ub7ec\ubd84\");\n+}\n+\"#####,\n+        r#####\"\n+fn print(_: &str) {}\n+\n+fn bar() {\n+    {\n+        let word = \"\uc548\ub155\ud558\uc138\uc694\";\n+        if !word.is_empty() {\n+            print(word);\n+        }\n+    };\n+    {\n+        let word = \"\uc5ec\ub7ec\ubd84\";\n+        if !word.is_empty() {\n+            print(word);\n+        }\n+    };\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_inline_local_variable() {\n     check_doc_test("}, {"sha": "8acad6a8ca441b6d37d7addb4f2aed5b1247a717", "filename": "crates/ide_db/src/helpers/insert_use.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cd7b26c6eb9b873ebe2a43ad7a51fb7554640e6a/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd7b26c6eb9b873ebe2a43ad7a51fb7554640e6a/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs?ref=cd7b26c6eb9b873ebe2a43ad7a51fb7554640e6a", "patch": "@@ -220,6 +220,23 @@ pub fn insert_use(scope: &ImportScope, path: ast::Path, cfg: &InsertUseConfig) {\n     insert_use_(scope, &path, cfg.group, use_item);\n }\n \n+pub fn remove_path_if_in_use_stmt(path: &ast::Path) {\n+    // FIXME: improve this\n+    if path.parent_path().is_some() {\n+        return;\n+    }\n+    if let Some(use_tree) = path.syntax().parent().and_then(ast::UseTree::cast) {\n+        if use_tree.use_tree_list().is_some() || use_tree.star_token().is_some() {\n+            return;\n+        }\n+        if let Some(use_) = use_tree.syntax().parent().and_then(ast::Use::cast) {\n+            use_.remove();\n+            return;\n+        }\n+        use_tree.remove();\n+    }\n+}\n+\n #[derive(Eq, PartialEq, PartialOrd, Ord)]\n enum ImportGroup {\n     // the order here defines the order of new group inserts"}, {"sha": "00acfde243e2dac9e060d58027c47f490ea1b75e", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cd7b26c6eb9b873ebe2a43ad7a51fb7554640e6a/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd7b26c6eb9b873ebe2a43ad7a51fb7554640e6a/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=cd7b26c6eb9b873ebe2a43ad7a51fb7554640e6a", "patch": "@@ -315,6 +315,7 @@ impl Definition {\n     }\n }\n \n+#[derive(Clone)]\n pub struct FindUsages<'a> {\n     def: Definition,\n     sema: &'a Semantics<'a, RootDatabase>,\n@@ -341,7 +342,7 @@ impl<'a> FindUsages<'a> {\n         self\n     }\n \n-    pub fn at_least_one(self) -> bool {\n+    pub fn at_least_one(&self) -> bool {\n         let mut found = false;\n         self.search(&mut |_, _| {\n             found = true;\n@@ -359,7 +360,7 @@ impl<'a> FindUsages<'a> {\n         res\n     }\n \n-    fn search(self, sink: &mut dyn FnMut(FileId, FileReference) -> bool) {\n+    fn search(&self, sink: &mut dyn FnMut(FileId, FileReference) -> bool) {\n         let _p = profile::span(\"FindUsages:search\");\n         let sema = self.sema;\n "}]}