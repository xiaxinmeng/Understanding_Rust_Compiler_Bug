{"sha": "700d3e23748c10c4203491856186333dd2952ebf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwMGQzZTIzNzQ4YzEwYzQyMDM0OTE4NTYxODYzMzNkZDI5NTJlYmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-02T03:39:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-02T03:39:33Z"}, "message": "Auto merge of #33190 - jseyfried:improve_diagnostics, r=nrc\n\nresolve: improve diagnostics and lay groundwork for resolving before ast->hir\n\nThis PR improves diagnostics in `resolve` and lays some groundwork for resolving before ast->hir.\n\nMore specifically,\n - It removes an API in `resolve` intended for external refactoring tools (see #27493) that appears not to be in active use. The API is incompatible with resolving before ast->hir, but could be rewritten in a more compatible and less intrusive way.\n - It improves the diagnostics for pattern bindings that conflict with `const`s.\n - It improves the diagnostics for modules used as expressions (fixes #33186).\n - It refactors away some uses of the hir map, which is unavavailable before ast->hir lowering.\n\nr? @eddyb", "tree": {"sha": "d5aadc6d3c0529e01467131b60dcc48ca58c732e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5aadc6d3c0529e01467131b60dcc48ca58c732e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/700d3e23748c10c4203491856186333dd2952ebf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/700d3e23748c10c4203491856186333dd2952ebf", "html_url": "https://github.com/rust-lang/rust/commit/700d3e23748c10c4203491856186333dd2952ebf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/700d3e23748c10c4203491856186333dd2952ebf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "855fb6192263a5c059325bb4b4e10b55e4e8ddbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/855fb6192263a5c059325bb4b4e10b55e4e8ddbb", "html_url": "https://github.com/rust-lang/rust/commit/855fb6192263a5c059325bb4b4e10b55e4e8ddbb"}, {"sha": "a70e42a953d71e356e170de8b6bd525d4a32dc4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a70e42a953d71e356e170de8b6bd525d4a32dc4d", "html_url": "https://github.com/rust-lang/rust/commit/a70e42a953d71e356e170de8b6bd525d4a32dc4d"}], "stats": {"total": 199, "additions": 73, "deletions": 126}, "files": [{"sha": "b83d6e9363e9c30465b2e1eeb7ca59f060f58ec2", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 63, "deletions": 120, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/700d3e23748c10c4203491856186333dd2952ebf/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700d3e23748c10c4203491856186333dd2952ebf/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=700d3e23748c10c4203491856186333dd2952ebf", "patch": "@@ -68,7 +68,7 @@ use rustc::hir::intravisit::{self, FnKind, Visitor};\n use rustc::hir;\n use rustc::hir::{Arm, BindByRef, BindByValue, BindingMode, Block};\n use rustc::hir::Crate;\n-use rustc::hir::{Expr, ExprAgain, ExprBreak, ExprCall, ExprField};\n+use rustc::hir::{Expr, ExprAgain, ExprBreak, ExprField};\n use rustc::hir::{ExprLoop, ExprWhile, ExprMethodCall};\n use rustc::hir::{ExprPath, ExprStruct, FnDecl};\n use rustc::hir::{ForeignItemFn, ForeignItemStatic, Generics};\n@@ -97,17 +97,6 @@ mod check_unused;\n mod build_reduced_graph;\n mod resolve_imports;\n \n-// Perform the callback, not walking deeper if the return is true\n-macro_rules! execute_callback {\n-    ($node: expr, $walker: expr) => (\n-        if let Some(ref callback) = $walker.callback {\n-            if callback($node, &mut $walker.resolved) {\n-                return;\n-            }\n-        }\n-    )\n-}\n-\n enum SuggestionType {\n     Macro(String),\n     Function(token::InternedString),\n@@ -152,7 +141,7 @@ enum ResolutionError<'a> {\n     /// error E0413: declaration shadows an enum variant or unit-like struct in scope\n     DeclarationShadowsEnumVariantOrUnitLikeStruct(Name),\n     /// error E0414: only irrefutable patterns allowed here\n-    OnlyIrrefutablePatternsAllowedHere(DefId, Name),\n+    OnlyIrrefutablePatternsAllowedHere(Name),\n     /// error E0415: identifier is bound more than once in this parameter list\n     IdentifierBoundMoreThanOnceInParameterList(&'a str),\n     /// error E0416: identifier is bound more than once in the same pattern\n@@ -174,7 +163,7 @@ enum ResolutionError<'a> {\n     /// error E0424: `self` is not available in a static method\n     SelfNotAvailableInStaticMethod,\n     /// error E0425: unresolved name\n-    UnresolvedName(&'a str, &'a str, UnresolvedNameContext),\n+    UnresolvedName(&'a str, &'a str, UnresolvedNameContext<'a>),\n     /// error E0426: use of undeclared label\n     UndeclaredLabel(&'a str),\n     /// error E0427: cannot use `ref` binding mode with ...\n@@ -197,12 +186,12 @@ enum ResolutionError<'a> {\n \n /// Context of where `ResolutionError::UnresolvedName` arose.\n #[derive(Clone, PartialEq, Eq, Debug)]\n-enum UnresolvedNameContext {\n-    /// `PathIsMod(id)` indicates that a given path, used in\n+enum UnresolvedNameContext<'a> {\n+    /// `PathIsMod(parent)` indicates that a given path, used in\n     /// expression context, actually resolved to a module rather than\n-    /// a value. The `id` attached to the variant is the node id of\n-    /// the erroneous path expression.\n-    PathIsMod(ast::NodeId),\n+    /// a value. The optional expression attached to the variant is the\n+    /// the parent of the erroneous path expression.\n+    PathIsMod(Option<&'a Expr>),\n \n     /// `Other` means we have no extra information about the context\n     /// of the unresolved name error. (Maybe we could eliminate all\n@@ -334,22 +323,18 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                               or unit-like struct in scope\",\n                              name)\n         }\n-        ResolutionError::OnlyIrrefutablePatternsAllowedHere(did, name) => {\n+        ResolutionError::OnlyIrrefutablePatternsAllowedHere(name) => {\n             let mut err = struct_span_err!(resolver.session,\n                                            span,\n                                            E0414,\n                                            \"only irrefutable patterns allowed here\");\n             err.span_note(span,\n                           \"there already is a constant in scope sharing the same \\\n                            name as this pattern\");\n-            if let Some(sp) = resolver.ast_map.span_if_local(did) {\n-                err.span_note(sp, \"constant defined here\");\n-            }\n             if let Some(binding) = resolver.current_module\n                                            .resolve_name_in_lexical_scope(name, ValueNS) {\n-                if binding.is_import() {\n-                    err.span_note(binding.span, \"constant imported here\");\n-                }\n+                let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n+                err.span_note(binding.span, &format!(\"constant {} here\", participle));\n             }\n             err\n         }\n@@ -434,39 +419,25 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n \n             match context {\n                 UnresolvedNameContext::Other => { } // no help available\n-                UnresolvedNameContext::PathIsMod(id) => {\n-                    let mut help_msg = String::new();\n-                    let parent_id = resolver.ast_map.get_parent_node(id);\n-                    if let Some(hir_map::Node::NodeExpr(e)) = resolver.ast_map.find(parent_id) {\n-                        match e.node {\n-                            ExprField(_, ident) => {\n-                                help_msg = format!(\"To reference an item from the \\\n-                                                    `{module}` module, use \\\n-                                                    `{module}::{ident}`\",\n-                                                   module = path,\n-                                                   ident = ident.node);\n-                            }\n-                            ExprMethodCall(ident, _, _) => {\n-                                help_msg = format!(\"To call a function from the \\\n-                                                    `{module}` module, use \\\n-                                                    `{module}::{ident}(..)`\",\n-                                                   module = path,\n-                                                   ident = ident.node);\n-                            }\n-                            ExprCall(_, _) => {\n-                                help_msg = format!(\"No function corresponds to `{module}(..)`\",\n-                                                   module = path);\n-                            }\n-                            _ => { } // no help available\n+                UnresolvedNameContext::PathIsMod(parent) => {\n+                    err.fileline_help(span, &match parent.map(|parent| &parent.node) {\n+                        Some(&ExprField(_, ident)) => {\n+                            format!(\"To reference an item from the `{module}` module, \\\n+                                     use `{module}::{ident}`\",\n+                                    module = path,\n+                                    ident = ident.node)\n                         }\n-                    } else {\n-                        help_msg = format!(\"Module `{module}` cannot be the value of an expression\",\n-                                           module = path);\n-                    }\n-\n-                    if !help_msg.is_empty() {\n-                        err.fileline_help(span, &help_msg);\n-                    }\n+                        Some(&ExprMethodCall(ident, _, _)) => {\n+                            format!(\"To call a function from the `{module}` module, \\\n+                                     use `{module}::{ident}(..)`\",\n+                                    module = path,\n+                                    ident = ident.node)\n+                        }\n+                        _ => {\n+                            format!(\"Module `{module}` cannot be used as an expression\",\n+                                    module = path)\n+                        }\n+                    });\n                 }\n             }\n             err\n@@ -559,22 +530,18 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n         self.visit_item(self.ast_map.expect_item(item.id))\n     }\n     fn visit_item(&mut self, item: &Item) {\n-        execute_callback!(hir_map::Node::NodeItem(item), self);\n         self.resolve_item(item);\n     }\n     fn visit_arm(&mut self, arm: &Arm) {\n         self.resolve_arm(arm);\n     }\n     fn visit_block(&mut self, block: &Block) {\n-        execute_callback!(hir_map::Node::NodeBlock(block), self);\n         self.resolve_block(block);\n     }\n     fn visit_expr(&mut self, expr: &Expr) {\n-        execute_callback!(hir_map::Node::NodeExpr(expr), self);\n-        self.resolve_expr(expr);\n+        self.resolve_expr(expr, None);\n     }\n     fn visit_local(&mut self, local: &Local) {\n-        execute_callback!(hir_map::Node::NodeLocal(&local.pat), self);\n         self.resolve_local(local);\n     }\n     fn visit_ty(&mut self, ty: &Ty) {\n@@ -597,7 +564,6 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n                      variant: &hir::Variant,\n                      generics: &Generics,\n                      item_id: ast::NodeId) {\n-        execute_callback!(hir_map::Node::NodeVariant(variant), self);\n         if let Some(ref dis_expr) = variant.node.disr_expr {\n             // resolve the discriminator expr as a constant\n             self.with_constant_rib(|this| {\n@@ -613,7 +579,6 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n                                 variant.span);\n     }\n     fn visit_foreign_item(&mut self, foreign_item: &hir::ForeignItem) {\n-        execute_callback!(hir_map::Node::NodeForeignItem(foreign_item), self);\n         let type_parameters = match foreign_item.node {\n             ForeignItemFn(_, ref generics) => {\n                 HasTypeParameters(generics, FnSpace, ItemRibKind)\n@@ -1080,11 +1045,6 @@ pub struct Resolver<'a, 'tcx: 'a> {\n     used_imports: HashSet<(NodeId, Namespace)>,\n     used_crates: HashSet<CrateNum>,\n \n-    // Callback function for intercepting walks\n-    callback: Option<Box<Fn(hir_map::Node, &mut bool) -> bool>>,\n-    // The intention is that the callback modifies this flag.\n-    // Once set, the resolver falls out of the walk, preserving the ribs.\n-    resolved: bool,\n     privacy_errors: Vec<PrivacyError<'a>>,\n \n     arenas: &'a ResolverArenas<'a>,\n@@ -1186,8 +1146,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             make_glob_map: make_glob_map == MakeGlobMap::Yes,\n             glob_map: NodeMap(),\n \n-            callback: None,\n-            resolved: false,\n             privacy_errors: Vec::new(),\n \n             arenas: arenas,\n@@ -1758,13 +1716,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         f(self);\n \n-        match type_parameters {\n-            HasTypeParameters(..) => {\n-                if !self.resolved {\n-                    self.type_ribs.pop();\n-                }\n-            }\n-            NoTypeParameters => {}\n+        if let HasTypeParameters(..) = type_parameters {\n+            self.type_ribs.pop();\n         }\n     }\n \n@@ -1773,9 +1726,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     {\n         self.label_ribs.push(Rib::new(NormalRibKind));\n         f(self);\n-        if !self.resolved {\n-            self.label_ribs.pop();\n-        }\n+        self.label_ribs.pop();\n     }\n \n     fn with_constant_rib<F>(&mut self, f: F)\n@@ -1784,10 +1735,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         self.value_ribs.push(Rib::new(ConstantItemRibKind));\n         self.type_ribs.push(Rib::new(ConstantItemRibKind));\n         f(self);\n-        if !self.resolved {\n-            self.type_ribs.pop();\n-            self.value_ribs.pop();\n-        }\n+        self.type_ribs.pop();\n+        self.value_ribs.pop();\n     }\n \n     fn resolve_function(&mut self, rib_kind: RibKind<'a>, declaration: &FnDecl, block: &Block) {\n@@ -1813,10 +1762,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         debug!(\"(resolving function) leaving function\");\n \n-        if !self.resolved {\n-            self.label_ribs.pop();\n-            self.value_ribs.pop();\n-        }\n+        self.label_ribs.pop();\n+        self.value_ribs.pop();\n     }\n \n     fn resolve_trait_reference(&mut self,\n@@ -1950,9 +1897,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         self_type_rib.bindings.insert(keywords::SelfType.name(), self_def);\n         self.type_ribs.push(self_type_rib);\n         f(self);\n-        if !self.resolved {\n-            self.type_ribs.pop();\n-        }\n+        self.type_ribs.pop();\n     }\n \n     fn resolve_implementation(&mut self,\n@@ -2117,9 +2062,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         walk_list!(self, visit_expr, &arm.guard);\n         self.visit_expr(&arm.body);\n \n-        if !self.resolved {\n-            self.value_ribs.pop();\n-        }\n+        self.value_ribs.pop();\n     }\n \n     fn resolve_block(&mut self, block: &Block) {\n@@ -2141,12 +2084,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         intravisit::walk_block(self, block);\n \n         // Move back up.\n-        if !self.resolved {\n-            self.current_module = orig_module;\n-            self.value_ribs.pop();\n-            if let Some(_) = anonymous_module {\n-                self.type_ribs.pop();\n-            }\n+        self.current_module = orig_module;\n+        self.value_ribs.pop();\n+        if let Some(_) = anonymous_module {\n+            self.type_ribs.pop();\n         }\n         debug!(\"(resolving block) leaving block\");\n     }\n@@ -2289,12 +2230,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                 depth: 0,\n                                             });\n                         }\n-                        FoundConst(def, name) => {\n+                        FoundConst(_, name) => {\n                             resolve_error(\n                                 self,\n                                 pattern.span,\n-                                ResolutionError::OnlyIrrefutablePatternsAllowedHere(def.def_id(),\n-                                                                                    name)\n+                                ResolutionError::OnlyIrrefutablePatternsAllowedHere(name)\n                             );\n                             self.record_def(pattern.id, err_path_resolution());\n                         }\n@@ -2896,7 +2836,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         } SuggestionType::NotFound\n     }\n \n-    fn resolve_expr(&mut self, expr: &Expr) {\n+    fn resolve_expr(&mut self, expr: &Expr, parent: Option<&Expr>) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n \n@@ -3041,7 +2981,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                                    UseLexicalScope,\n                                                                    expr.span) {\n                                         Success(_) => {\n-                                            context = UnresolvedNameContext::PathIsMod(expr.id);\n+                                            context = UnresolvedNameContext::PathIsMod(parent);\n                                         },\n                                         _ => {},\n                                     };\n@@ -3115,6 +3055,19 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n             }\n+            ExprField(ref subexpression, _) => {\n+                self.resolve_expr(subexpression, Some(expr));\n+            }\n+            ExprMethodCall(_, ref types, ref arguments) => {\n+                let mut arguments = arguments.iter();\n+                self.resolve_expr(arguments.next().unwrap(), Some(expr));\n+                for argument in arguments {\n+                    self.resolve_expr(argument, None);\n+                }\n+                for ty in types.iter() {\n+                    self.visit_ty(ty);\n+                }\n+            }\n \n             _ => {\n                 intravisit::walk_expr(self, expr);\n@@ -3588,7 +3541,7 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n \n     let krate = ast_map.krate();\n     let arenas = Resolver::arenas();\n-    let mut resolver = create_resolver(session, ast_map, krate, make_glob_map, &arenas, None);\n+    let mut resolver = create_resolver(session, ast_map, krate, make_glob_map, &arenas);\n \n     resolver.resolve_crate(krate);\n \n@@ -3608,25 +3561,15 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n     }\n }\n \n-/// Builds a name resolution walker to be used within this module,\n-/// or used externally, with an optional callback function.\n-///\n-/// The callback takes a &mut bool which allows callbacks to end a\n-/// walk when set to true, passing through the rest of the walk, while\n-/// preserving the ribs + current module. This allows resolve_path\n-/// calls to be made with the correct scope info. The node in the\n-/// callback corresponds to the current node in the walk.\n+/// Builds a name resolution walker.\n fn create_resolver<'a, 'tcx>(session: &'a Session,\n                              ast_map: &'a hir_map::Map<'tcx>,\n                              krate: &'a Crate,\n                              make_glob_map: MakeGlobMap,\n-                             arenas: &'a ResolverArenas<'a>,\n-                             callback: Option<Box<Fn(hir_map::Node, &mut bool) -> bool>>)\n+                             arenas: &'a ResolverArenas<'a>)\n                              -> Resolver<'a, 'tcx> {\n     let mut resolver = Resolver::new(session, ast_map, make_glob_map, arenas);\n \n-    resolver.callback = callback;\n-\n     resolver.build_reduced_graph(krate);\n \n     resolve_imports::resolve_imports(&mut resolver);"}, {"sha": "825c39011fcc182cb714f8ab327bc2e2bad98913", "filename": "src/test/compile-fail/const-pattern-irrefutable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/700d3e23748c10c4203491856186333dd2952ebf/src%2Ftest%2Fcompile-fail%2Fconst-pattern-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700d3e23748c10c4203491856186333dd2952ebf/src%2Ftest%2Fcompile-fail%2Fconst-pattern-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-pattern-irrefutable.rs?ref=700d3e23748c10c4203491856186333dd2952ebf", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n mod foo {\n-    pub const b: u8 = 2; //~ NOTE constant defined here\n-    pub const d: u8 = 2; //~ NOTE constant defined here\n+    pub const b: u8 = 2;\n+    pub const d: u8 = 2;\n }\n \n use foo::b as c; //~ NOTE constant imported here"}, {"sha": "412c90fd214c17ae5c3a585e0cd3d22fc032d4d9", "filename": "src/test/compile-fail/suggest-path-instead-of-mod-dot-item.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/700d3e23748c10c4203491856186333dd2952ebf/src%2Ftest%2Fcompile-fail%2Fsuggest-path-instead-of-mod-dot-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700d3e23748c10c4203491856186333dd2952ebf/src%2Ftest%2Fcompile-fail%2Fsuggest-path-instead-of-mod-dot-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsuggest-path-instead-of-mod-dot-item.rs?ref=700d3e23748c10c4203491856186333dd2952ebf", "patch": "@@ -47,10 +47,14 @@ fn h4() -> i32 {\n         //~| HELP To reference an item from the `a::b` module, use `a::b::J`\n }\n \n-fn h5() -> i32 {\n-    a.b.f()\n+fn h5() {\n+    a.b.f();\n         //~^ ERROR E0425\n         //~| HELP To reference an item from the `a` module, use `a::b`\n+    let v = Vec::new();\n+    v.push(a::b);\n+        //~^ ERROR E0425\n+        //~| HELP Module `a::b` cannot be used as an expression\n }\n \n fn h6() -> i32 {\n@@ -62,11 +66,11 @@ fn h6() -> i32 {\n fn h7() {\n     a::b\n         //~^ ERROR E0425\n-        //~| HELP Module `a::b` cannot be the value of an expression\n+        //~| HELP Module `a::b` cannot be used as an expression\n }\n \n fn h8() -> i32 {\n     a::b()\n         //~^ ERROR E0425\n-        //~| HELP No function corresponds to `a::b(..)`\n+        //~| HELP Module `a::b` cannot be used as an expression\n }"}]}