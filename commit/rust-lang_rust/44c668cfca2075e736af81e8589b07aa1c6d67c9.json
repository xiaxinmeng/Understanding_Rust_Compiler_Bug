{"sha": "44c668cfca2075e736af81e8589b07aa1c6d67c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0YzY2OGNmY2EyMDc1ZTczNmFmODFlODU4OWIwN2FhMWM2ZDY3Yzk=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-01-23T19:16:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-23T19:16:12Z"}, "message": "Rollup merge of #81281 - a1phyr:inline_path, r=dtolnay\n\nInline methods of Path and OsString\n\nThese methods are not generic, and therefore aren't candidates for cross-crate inlining without an `#[inline]` attribute.", "tree": {"sha": "58fca35de5a3bddb20f3f67c326505befdf66b79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58fca35de5a3bddb20f3f67c326505befdf66b79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44c668cfca2075e736af81e8589b07aa1c6d67c9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgDHX8CRBK7hj4Ov3rIwAAdHIIAC0BBQGnEMxyqsjHVE1Mb43B\nCt1eHDBPoguU8ghiItQIeJ7vTXPGMvODwy9Irrs78kOHem/AtRriCYH+Twgz5w4/\n+qm/7oJF0sBFej11EUi8re07DYAT0U2w3DuyKzHLPEZbEgVmOmOHVkjCcMUmEJnO\nQvcIFBJWYQtRxZZsof/LWJXdOZExzlznnpPTvvHFn0Eka/3jM3VXZL0Vd6Vklrtj\nfsEgwBqdCPkyEVg0nlNW1Xc+nQbNL/k3ULybO3md0bD3NxxM+NF+C2rS44x3VlnP\njge8JT3Wfec8Xy699pNfpEfr+HwrGbnJPR9D5IFrwbv688WEt/fDEu+6ZcsYjsU=\n=hNX1\n-----END PGP SIGNATURE-----\n", "payload": "tree 58fca35de5a3bddb20f3f67c326505befdf66b79\nparent 81647c627a8d84f970399513ea08a285b167c666\nparent 9880560a1cb64ec099886eb11ce3d34de8070bca\nauthor Jonas Schievink <jonasschievink@gmail.com> 1611429372 +0100\ncommitter GitHub <noreply@github.com> 1611429372 +0100\n\nRollup merge of #81281 - a1phyr:inline_path, r=dtolnay\n\nInline methods of Path and OsString\n\nThese methods are not generic, and therefore aren't candidates for cross-crate inlining without an `#[inline]` attribute.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44c668cfca2075e736af81e8589b07aa1c6d67c9", "html_url": "https://github.com/rust-lang/rust/commit/44c668cfca2075e736af81e8589b07aa1c6d67c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44c668cfca2075e736af81e8589b07aa1c6d67c9/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81647c627a8d84f970399513ea08a285b167c666", "url": "https://api.github.com/repos/rust-lang/rust/commits/81647c627a8d84f970399513ea08a285b167c666", "html_url": "https://github.com/rust-lang/rust/commit/81647c627a8d84f970399513ea08a285b167c666"}, {"sha": "9880560a1cb64ec099886eb11ce3d34de8070bca", "url": "https://api.github.com/repos/rust-lang/rust/commits/9880560a1cb64ec099886eb11ce3d34de8070bca", "html_url": "https://github.com/rust-lang/rust/commit/9880560a1cb64ec099886eb11ce3d34de8070bca"}], "stats": {"total": 103, "additions": 103, "deletions": 0}, "files": [{"sha": "32f0f8a52f820cb0c7e710db8ec385af58abbfd3", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/44c668cfca2075e736af81e8589b07aa1c6d67c9/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44c668cfca2075e736af81e8589b07aa1c6d67c9/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=44c668cfca2075e736af81e8589b07aa1c6d67c9", "patch": "@@ -111,6 +111,7 @@ impl OsString {\n     /// let os_string = OsString::new();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn new() -> OsString {\n         OsString { inner: Buf::from_string(String::new()) }\n     }\n@@ -127,6 +128,7 @@ impl OsString {\n     /// assert_eq!(os_string.as_os_str(), os_str);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn as_os_str(&self) -> &OsStr {\n         self\n     }\n@@ -145,6 +147,7 @@ impl OsString {\n     /// assert_eq!(string, Ok(String::from(\"foo\")));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn into_string(self) -> Result<String, OsString> {\n         self.inner.into_string().map_err(|buf| OsString { inner: buf })\n     }\n@@ -163,6 +166,7 @@ impl OsString {\n     /// assert_eq!(&os_string, \"foobar\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn push<T: AsRef<OsStr>>(&mut self, s: T) {\n         self.inner.push_slice(&s.as_ref().inner)\n     }\n@@ -189,6 +193,7 @@ impl OsString {\n     /// assert_eq!(capacity, os_string.capacity());\n     /// ```\n     #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n+    #[inline]\n     pub fn with_capacity(capacity: usize) -> OsString {\n         OsString { inner: Buf::with_capacity(capacity) }\n     }\n@@ -207,6 +212,7 @@ impl OsString {\n     /// assert_eq!(&os_string, \"\");\n     /// ```\n     #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n+    #[inline]\n     pub fn clear(&mut self) {\n         self.inner.clear()\n     }\n@@ -224,6 +230,7 @@ impl OsString {\n     /// assert!(os_string.capacity() >= 10);\n     /// ```\n     #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n+    #[inline]\n     pub fn capacity(&self) -> usize {\n         self.inner.capacity()\n     }\n@@ -243,6 +250,7 @@ impl OsString {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n+    #[inline]\n     pub fn reserve(&mut self, additional: usize) {\n         self.inner.reserve(additional)\n     }\n@@ -265,6 +273,7 @@ impl OsString {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n+    #[inline]\n     pub fn reserve_exact(&mut self, additional: usize) {\n         self.inner.reserve_exact(additional)\n     }\n@@ -285,6 +294,7 @@ impl OsString {\n     /// assert_eq!(3, s.capacity());\n     /// ```\n     #[stable(feature = \"osstring_shrink_to_fit\", since = \"1.19.0\")]\n+    #[inline]\n     pub fn shrink_to_fit(&mut self) {\n         self.inner.shrink_to_fit()\n     }\n@@ -342,6 +352,7 @@ impl From<String> for OsString {\n     /// Converts a [`String`] into a [`OsString`].\n     ///\n     /// The conversion copies the data, and includes an allocation on the heap.\n+    #[inline]\n     fn from(s: String) -> OsString {\n         OsString { inner: Buf::from_string(s) }\n     }\n@@ -408,34 +419,39 @@ impl fmt::Debug for OsString {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq for OsString {\n+    #[inline]\n     fn eq(&self, other: &OsString) -> bool {\n         &**self == &**other\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq<str> for OsString {\n+    #[inline]\n     fn eq(&self, other: &str) -> bool {\n         &**self == other\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq<OsString> for str {\n+    #[inline]\n     fn eq(&self, other: &OsString) -> bool {\n         &**other == self\n     }\n }\n \n #[stable(feature = \"os_str_str_ref_eq\", since = \"1.29.0\")]\n impl PartialEq<&str> for OsString {\n+    #[inline]\n     fn eq(&self, other: &&str) -> bool {\n         **self == **other\n     }\n }\n \n #[stable(feature = \"os_str_str_ref_eq\", since = \"1.29.0\")]\n impl<'a> PartialEq<OsString> for &'a str {\n+    #[inline]\n     fn eq(&self, other: &OsString) -> bool {\n         **other == **self\n     }\n@@ -539,6 +555,7 @@ impl OsStr {\n     /// assert_eq!(os_str.to_str(), Some(\"foo\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn to_str(&self) -> Option<&str> {\n         self.inner.to_str()\n     }\n@@ -589,6 +606,7 @@ impl OsStr {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn to_string_lossy(&self) -> Cow<'_, str> {\n         self.inner.to_string_lossy()\n     }\n@@ -605,6 +623,7 @@ impl OsStr {\n     /// assert_eq!(os_string, OsString::from(\"foo\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn to_os_string(&self) -> OsString {\n         OsString { inner: self.inner.to_owned() }\n     }\n@@ -655,6 +674,7 @@ impl OsStr {\n     /// ```\n     #[doc(alias = \"length\")]\n     #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n+    #[inline]\n     pub fn len(&self) -> usize {\n         self.inner.inner.len()\n     }\n@@ -696,6 +716,7 @@ impl OsStr {\n     /// assert_eq!(\"gr\u00dc\u00dfe, j\u00dcrgen \u2764\", s);\n     /// ```\n     #[unstable(feature = \"osstring_ascii\", issue = \"70516\")]\n+    #[inline]\n     pub fn make_ascii_lowercase(&mut self) {\n         self.inner.make_ascii_lowercase()\n     }\n@@ -721,6 +742,7 @@ impl OsStr {\n     /// assert_eq!(\"GR\u00fc\u00dfE, J\u00fcRGEN \u2764\", s);\n     /// ```\n     #[unstable(feature = \"osstring_ascii\", issue = \"70516\")]\n+    #[inline]\n     pub fn make_ascii_uppercase(&mut self) {\n         self.inner.make_ascii_uppercase()\n     }\n@@ -784,6 +806,7 @@ impl OsStr {\n     /// assert!(!non_ascii.is_ascii());\n     /// ```\n     #[unstable(feature = \"osstring_ascii\", issue = \"70516\")]\n+    #[inline]\n     pub fn is_ascii(&self) -> bool {\n         self.inner.is_ascii()\n     }\n@@ -811,6 +834,7 @@ impl OsStr {\n \n #[stable(feature = \"box_from_os_str\", since = \"1.17.0\")]\n impl From<&OsStr> for Box<OsStr> {\n+    #[inline]\n     fn from(s: &OsStr) -> Box<OsStr> {\n         let rw = Box::into_raw(s.inner.into_box()) as *mut OsStr;\n         unsafe { Box::from_raw(rw) }\n@@ -832,6 +856,7 @@ impl From<Cow<'_, OsStr>> for Box<OsStr> {\n impl From<Box<OsStr>> for OsString {\n     /// Converts a [`Box`]`<`[`OsStr`]`>` into a `OsString` without copying or\n     /// allocating.\n+    #[inline]\n     fn from(boxed: Box<OsStr>) -> OsString {\n         boxed.into_os_string()\n     }\n@@ -840,6 +865,7 @@ impl From<Box<OsStr>> for OsString {\n #[stable(feature = \"box_from_os_string\", since = \"1.20.0\")]\n impl From<OsString> for Box<OsStr> {\n     /// Converts a [`OsString`] into a [`Box`]`<OsStr>` without copying or allocating.\n+    #[inline]\n     fn from(s: OsString) -> Box<OsStr> {\n         s.into_boxed_os_str()\n     }\n@@ -925,6 +951,7 @@ impl<'a> From<Cow<'a, OsStr>> for OsString {\n \n #[stable(feature = \"box_default_extra\", since = \"1.17.0\")]\n impl Default for Box<OsStr> {\n+    #[inline]\n     fn default() -> Box<OsStr> {\n         let rw = Box::into_raw(Slice::empty_box()) as *mut OsStr;\n         unsafe { Box::from_raw(rw) }\n@@ -1075,6 +1102,7 @@ impl OsStr {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Borrow<OsStr> for OsString {\n+    #[inline]\n     fn borrow(&self) -> &OsStr {\n         &self[..]\n     }\n@@ -1083,16 +1111,19 @@ impl Borrow<OsStr> for OsString {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ToOwned for OsStr {\n     type Owned = OsString;\n+    #[inline]\n     fn to_owned(&self) -> OsString {\n         self.to_os_string()\n     }\n+    #[inline]\n     fn clone_into(&self, target: &mut OsString) {\n         self.inner.clone_into(&mut target.inner)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<OsStr> for OsStr {\n+    #[inline]\n     fn as_ref(&self) -> &OsStr {\n         self\n     }\n@@ -1123,12 +1154,14 @@ impl AsRef<OsStr> for String {\n }\n \n impl FromInner<Buf> for OsString {\n+    #[inline]\n     fn from_inner(buf: Buf) -> OsString {\n         OsString { inner: buf }\n     }\n }\n \n impl IntoInner<Buf> for OsString {\n+    #[inline]\n     fn into_inner(self) -> Buf {\n         self.inner\n     }\n@@ -1145,6 +1178,7 @@ impl AsInner<Slice> for OsStr {\n impl FromStr for OsString {\n     type Err = core::convert::Infallible;\n \n+    #[inline]\n     fn from_str(s: &str) -> Result<Self, Self::Err> {\n         Ok(OsString::from(s))\n     }"}, {"sha": "1889e549338676dcbed5b8faeac53538f2e05aec", "filename": "library/std/src/path.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/44c668cfca2075e736af81e8589b07aa1c6d67c9/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44c668cfca2075e736af81e8589b07aa1c6d67c9/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=44c668cfca2075e736af81e8589b07aa1c6d67c9", "patch": "@@ -401,33 +401,38 @@ impl<'a> PrefixComponent<'a> {\n     /// See [`Prefix`]'s documentation for more information on the different\n     /// kinds of prefixes.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn kind(&self) -> Prefix<'a> {\n         self.parsed\n     }\n \n     /// Returns the raw [`OsStr`] slice for this prefix.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn as_os_str(&self) -> &'a OsStr {\n         self.raw\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> cmp::PartialEq for PrefixComponent<'a> {\n+    #[inline]\n     fn eq(&self, other: &PrefixComponent<'a>) -> bool {\n         cmp::PartialEq::eq(&self.parsed, &other.parsed)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> cmp::PartialOrd for PrefixComponent<'a> {\n+    #[inline]\n     fn partial_cmp(&self, other: &PrefixComponent<'a>) -> Option<cmp::Ordering> {\n         cmp::PartialOrd::partial_cmp(&self.parsed, &other.parsed)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::Ord for PrefixComponent<'_> {\n+    #[inline]\n     fn cmp(&self, other: &Self) -> cmp::Ordering {\n         cmp::Ord::cmp(&self.parsed, &other.parsed)\n     }\n@@ -522,13 +527,15 @@ impl<'a> Component<'a> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<OsStr> for Component<'_> {\n+    #[inline]\n     fn as_ref(&self) -> &OsStr {\n         self.as_os_str()\n     }\n }\n \n #[stable(feature = \"path_component_asref\", since = \"1.25.0\")]\n impl AsRef<Path> for Component<'_> {\n+    #[inline]\n     fn as_ref(&self) -> &Path {\n         self.as_os_str().as_ref()\n     }\n@@ -750,13 +757,15 @@ impl<'a> Components<'a> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<Path> for Components<'_> {\n+    #[inline]\n     fn as_ref(&self) -> &Path {\n         self.as_path()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<OsStr> for Components<'_> {\n+    #[inline]\n     fn as_ref(&self) -> &OsStr {\n         self.as_path().as_os_str()\n     }\n@@ -792,20 +801,23 @@ impl<'a> Iter<'a> {\n     /// assert_eq!(Path::new(\"foo/bar.txt\"), iter.as_path());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn as_path(&self) -> &'a Path {\n         self.inner.as_path()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<Path> for Iter<'_> {\n+    #[inline]\n     fn as_ref(&self) -> &Path {\n         self.as_path()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<OsStr> for Iter<'_> {\n+    #[inline]\n     fn as_ref(&self) -> &OsStr {\n         self.as_path().as_os_str()\n     }\n@@ -815,13 +827,15 @@ impl AsRef<OsStr> for Iter<'_> {\n impl<'a> Iterator for Iter<'a> {\n     type Item = &'a OsStr;\n \n+    #[inline]\n     fn next(&mut self) -> Option<&'a OsStr> {\n         self.inner.next().map(Component::as_os_str)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for Iter<'a> {\n+    #[inline]\n     fn next_back(&mut self) -> Option<&'a OsStr> {\n         self.inner.next_back().map(Component::as_os_str)\n     }\n@@ -935,6 +949,7 @@ impl FusedIterator for Components<'_> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> cmp::PartialEq for Components<'a> {\n+    #[inline]\n     fn eq(&self, other: &Components<'a>) -> bool {\n         Iterator::eq(self.clone(), other.clone())\n     }\n@@ -945,13 +960,15 @@ impl cmp::Eq for Components<'_> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> cmp::PartialOrd for Components<'a> {\n+    #[inline]\n     fn partial_cmp(&self, other: &Components<'a>) -> Option<cmp::Ordering> {\n         Iterator::partial_cmp(self.clone(), other.clone())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::Ord for Components<'_> {\n+    #[inline]\n     fn cmp(&self, other: &Self) -> cmp::Ordering {\n         Iterator::cmp(self.clone(), other.clone())\n     }\n@@ -985,6 +1002,7 @@ pub struct Ancestors<'a> {\n impl<'a> Iterator for Ancestors<'a> {\n     type Item = &'a Path;\n \n+    #[inline]\n     fn next(&mut self) -> Option<Self::Item> {\n         let next = self.next;\n         self.next = next.and_then(Path::parent);\n@@ -1060,6 +1078,7 @@ pub struct PathBuf {\n }\n \n impl PathBuf {\n+    #[inline]\n     fn as_mut_vec(&mut self) -> &mut Vec<u8> {\n         unsafe { &mut *(self as *mut PathBuf as *mut Vec<u8>) }\n     }\n@@ -1074,6 +1093,7 @@ impl PathBuf {\n     /// let path = PathBuf::new();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn new() -> PathBuf {\n         PathBuf { inner: OsString::new() }\n     }\n@@ -1097,6 +1117,7 @@ impl PathBuf {\n     ///\n     /// [`with_capacity`]: OsString::with_capacity\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n+    #[inline]\n     pub fn with_capacity(capacity: usize) -> PathBuf {\n         PathBuf { inner: OsString::with_capacity(capacity) }\n     }\n@@ -1112,6 +1133,7 @@ impl PathBuf {\n     /// assert_eq!(Path::new(\"/test\"), p.as_path());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn as_path(&self) -> &Path {\n         self\n     }\n@@ -1315,12 +1337,14 @@ impl PathBuf {\n     /// let os_str = p.into_os_string();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn into_os_string(self) -> OsString {\n         self.inner\n     }\n \n     /// Converts this `PathBuf` into a [boxed](Box) [`Path`].\n     #[stable(feature = \"into_boxed_path\", since = \"1.20.0\")]\n+    #[inline]\n     pub fn into_boxed_path(self) -> Box<Path> {\n         let rw = Box::into_raw(self.inner.into_boxed_os_str()) as *mut Path;\n         unsafe { Box::from_raw(rw) }\n@@ -1330,6 +1354,7 @@ impl PathBuf {\n     ///\n     /// [`capacity`]: OsString::capacity\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n+    #[inline]\n     pub fn capacity(&self) -> usize {\n         self.inner.capacity()\n     }\n@@ -1338,6 +1363,7 @@ impl PathBuf {\n     ///\n     /// [`clear`]: OsString::clear\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n+    #[inline]\n     pub fn clear(&mut self) {\n         self.inner.clear()\n     }\n@@ -1346,6 +1372,7 @@ impl PathBuf {\n     ///\n     /// [`reserve`]: OsString::reserve\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n+    #[inline]\n     pub fn reserve(&mut self, additional: usize) {\n         self.inner.reserve(additional)\n     }\n@@ -1354,6 +1381,7 @@ impl PathBuf {\n     ///\n     /// [`reserve_exact`]: OsString::reserve_exact\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n+    #[inline]\n     pub fn reserve_exact(&mut self, additional: usize) {\n         self.inner.reserve_exact(additional)\n     }\n@@ -1362,6 +1390,7 @@ impl PathBuf {\n     ///\n     /// [`shrink_to_fit`]: OsString::shrink_to_fit\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n+    #[inline]\n     pub fn shrink_to_fit(&mut self) {\n         self.inner.shrink_to_fit()\n     }\n@@ -1370,6 +1399,7 @@ impl PathBuf {\n     ///\n     /// [`shrink_to`]: OsString::shrink_to\n     #[unstable(feature = \"shrink_to\", issue = \"56431\")]\n+    #[inline]\n     pub fn shrink_to(&mut self, min_capacity: usize) {\n         self.inner.shrink_to(min_capacity)\n     }\n@@ -1400,6 +1430,7 @@ impl From<Box<Path>> for PathBuf {\n     /// Converts a `Box<Path>` into a `PathBuf`\n     ///\n     /// This conversion does not allocate or copy memory.\n+    #[inline]\n     fn from(boxed: Box<Path>) -> PathBuf {\n         boxed.into_path_buf()\n     }\n@@ -1411,6 +1442,7 @@ impl From<PathBuf> for Box<Path> {\n     ///\n     /// This conversion currently should not allocate memory,\n     /// but this behavior is not guaranteed on all platforms or in all future versions.\n+    #[inline]\n     fn from(p: PathBuf) -> Box<Path> {\n         p.into_boxed_path()\n     }\n@@ -1426,6 +1458,7 @@ impl Clone for Box<Path> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + AsRef<OsStr>> From<&T> for PathBuf {\n+    #[inline]\n     fn from(s: &T) -> PathBuf {\n         PathBuf::from(s.as_ref().to_os_string())\n     }\n@@ -1447,6 +1480,7 @@ impl From<PathBuf> for OsString {\n     /// Converts a `PathBuf` into a `OsString`\n     ///\n     /// This conversion does not allocate or copy memory.\n+    #[inline]\n     fn from(path_buf: PathBuf) -> OsString {\n         path_buf.inner\n     }\n@@ -1457,6 +1491,7 @@ impl From<String> for PathBuf {\n     /// Converts a `String` into a `PathBuf`\n     ///\n     /// This conversion does not allocate or copy memory.\n+    #[inline]\n     fn from(s: String) -> PathBuf {\n         PathBuf::from(OsString::from(s))\n     }\n@@ -1466,6 +1501,7 @@ impl From<String> for PathBuf {\n impl FromStr for PathBuf {\n     type Err = core::convert::Infallible;\n \n+    #[inline]\n     fn from_str(s: &str) -> Result<Self, Self::Err> {\n         Ok(PathBuf::from(s))\n     }\n@@ -1510,13 +1546,15 @@ impl ops::Deref for PathBuf {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Borrow<Path> for PathBuf {\n+    #[inline]\n     fn borrow(&self) -> &Path {\n         self.deref()\n     }\n }\n \n #[stable(feature = \"default_for_pathbuf\", since = \"1.17.0\")]\n impl Default for PathBuf {\n+    #[inline]\n     fn default() -> Self {\n         PathBuf::new()\n     }\n@@ -1597,16 +1635,19 @@ impl From<&Path> for Rc<Path> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ToOwned for Path {\n     type Owned = PathBuf;\n+    #[inline]\n     fn to_owned(&self) -> PathBuf {\n         self.to_path_buf()\n     }\n+    #[inline]\n     fn clone_into(&self, target: &mut PathBuf) {\n         self.inner.clone_into(&mut target.inner);\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::PartialEq for PathBuf {\n+    #[inline]\n     fn eq(&self, other: &PathBuf) -> bool {\n         self.components() == other.components()\n     }\n@@ -1624,20 +1665,23 @@ impl cmp::Eq for PathBuf {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::PartialOrd for PathBuf {\n+    #[inline]\n     fn partial_cmp(&self, other: &PathBuf) -> Option<cmp::Ordering> {\n         self.components().partial_cmp(other.components())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::Ord for PathBuf {\n+    #[inline]\n     fn cmp(&self, other: &PathBuf) -> cmp::Ordering {\n         self.components().cmp(other.components())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<OsStr> for PathBuf {\n+    #[inline]\n     fn as_ref(&self) -> &OsStr {\n         &self.inner[..]\n     }\n@@ -1745,6 +1789,7 @@ impl Path {\n     /// assert_eq!(os_str, std::ffi::OsStr::new(\"foo.txt\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn as_os_str(&self) -> &OsStr {\n         &self.inner\n     }\n@@ -1766,6 +1811,7 @@ impl Path {\n     /// assert_eq!(path.to_str(), Some(\"foo.txt\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn to_str(&self) -> Option<&str> {\n         self.inner.to_str()\n     }\n@@ -1791,6 +1837,7 @@ impl Path {\n     /// Had `path` contained invalid unicode, the `to_string_lossy` call might\n     /// have returned `\"fo\ufffd.txt\"`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn to_string_lossy(&self) -> Cow<'_, str> {\n         self.inner.to_string_lossy()\n     }\n@@ -1854,6 +1901,7 @@ impl Path {\n     ///\n     /// [`is_absolute`]: Path::is_absolute\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn is_relative(&self) -> bool {\n         !self.is_absolute()\n     }\n@@ -1879,6 +1927,7 @@ impl Path {\n     /// assert!(Path::new(\"/etc/passwd\").has_root());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn has_root(&self) -> bool {\n         self.components().has_root()\n     }\n@@ -1941,6 +1990,7 @@ impl Path {\n     ///\n     /// [`parent`]: Path::parent\n     #[stable(feature = \"path_ancestors\", since = \"1.28.0\")]\n+    #[inline]\n     pub fn ancestors(&self) -> Ancestors<'_> {\n         Ancestors { next: Some(&self) }\n     }\n@@ -2265,6 +2315,7 @@ impl Path {\n     /// assert_eq!(it.next(), None)\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn iter(&self) -> Iter<'_> {\n         Iter { inner: self.components() }\n     }\n@@ -2284,6 +2335,7 @@ impl Path {\n     /// println!(\"{}\", path.display());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn display(&self) -> Display<'_> {\n         Display { path: self }\n     }\n@@ -2305,6 +2357,7 @@ impl Path {\n     /// println!(\"{:?}\", metadata.file_type());\n     /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n+    #[inline]\n     pub fn metadata(&self) -> io::Result<fs::Metadata> {\n         fs::metadata(self)\n     }\n@@ -2323,6 +2376,7 @@ impl Path {\n     /// println!(\"{:?}\", metadata.file_type());\n     /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n+    #[inline]\n     pub fn symlink_metadata(&self) -> io::Result<fs::Metadata> {\n         fs::symlink_metadata(self)\n     }\n@@ -2341,6 +2395,7 @@ impl Path {\n     /// assert_eq!(path.canonicalize().unwrap(), PathBuf::from(\"/foo/test/bar.rs\"));\n     /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n+    #[inline]\n     pub fn canonicalize(&self) -> io::Result<PathBuf> {\n         fs::canonicalize(self)\n     }\n@@ -2358,6 +2413,7 @@ impl Path {\n     /// let path_link = path.read_link().expect(\"read_link call failed\");\n     /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n+    #[inline]\n     pub fn read_link(&self) -> io::Result<PathBuf> {\n         fs::read_link(self)\n     }\n@@ -2382,6 +2438,7 @@ impl Path {\n     /// }\n     /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n+    #[inline]\n     pub fn read_dir(&self) -> io::Result<fs::ReadDir> {\n         fs::read_dir(self)\n     }\n@@ -2406,6 +2463,7 @@ impl Path {\n     /// This is a convenience function that coerces errors to false. If you want to\n     /// check errors, call [`fs::metadata`].\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n+    #[inline]\n     pub fn exists(&self) -> bool {\n         fs::metadata(self).is_ok()\n     }\n@@ -2480,6 +2538,7 @@ impl Path {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<OsStr> for Path {\n+    #[inline]\n     fn as_ref(&self) -> &OsStr {\n         &self.inner\n     }\n@@ -2531,6 +2590,7 @@ impl fmt::Display for Display<'_> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::PartialEq for Path {\n+    #[inline]\n     fn eq(&self, other: &Path) -> bool {\n         self.components().eq(other.components())\n     }\n@@ -2550,41 +2610,47 @@ impl cmp::Eq for Path {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::PartialOrd for Path {\n+    #[inline]\n     fn partial_cmp(&self, other: &Path) -> Option<cmp::Ordering> {\n         self.components().partial_cmp(other.components())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::Ord for Path {\n+    #[inline]\n     fn cmp(&self, other: &Path) -> cmp::Ordering {\n         self.components().cmp(other.components())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<Path> for Path {\n+    #[inline]\n     fn as_ref(&self) -> &Path {\n         self\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<Path> for OsStr {\n+    #[inline]\n     fn as_ref(&self) -> &Path {\n         Path::new(self)\n     }\n }\n \n #[stable(feature = \"cow_os_str_as_ref_path\", since = \"1.8.0\")]\n impl AsRef<Path> for Cow<'_, OsStr> {\n+    #[inline]\n     fn as_ref(&self) -> &Path {\n         Path::new(self)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<Path> for OsString {\n+    #[inline]\n     fn as_ref(&self) -> &Path {\n         Path::new(self)\n     }\n@@ -2600,6 +2666,7 @@ impl AsRef<Path> for str {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<Path> for String {\n+    #[inline]\n     fn as_ref(&self) -> &Path {\n         Path::new(self)\n     }\n@@ -2617,6 +2684,7 @@ impl AsRef<Path> for PathBuf {\n impl<'a> IntoIterator for &'a PathBuf {\n     type Item = &'a OsStr;\n     type IntoIter = Iter<'a>;\n+    #[inline]\n     fn into_iter(self) -> Iter<'a> {\n         self.iter()\n     }\n@@ -2626,6 +2694,7 @@ impl<'a> IntoIterator for &'a PathBuf {\n impl<'a> IntoIterator for &'a Path {\n     type Item = &'a OsStr;\n     type IntoIter = Iter<'a>;\n+    #[inline]\n     fn into_iter(self) -> Iter<'a> {\n         self.iter()\n     }"}]}