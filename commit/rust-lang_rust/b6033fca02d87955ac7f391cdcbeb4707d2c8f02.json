{"sha": "b6033fca02d87955ac7f391cdcbeb4707d2c8f02", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2MDMzZmNhMDJkODc5NTVhYzdmMzkxY2RjYmViNDcwN2QyYzhmMDI=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-24T19:09:06Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-26T08:40:51Z"}, "message": "Retire DepGraphSafe and HashStableContext.", "tree": {"sha": "2079c0a46f8e313b5b0e5b063ff3b0dfaa4aa26a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2079c0a46f8e313b5b0e5b063ff3b0dfaa4aa26a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6033fca02d87955ac7f391cdcbeb4707d2c8f02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6033fca02d87955ac7f391cdcbeb4707d2c8f02", "html_url": "https://github.com/rust-lang/rust/commit/b6033fca02d87955ac7f391cdcbeb4707d2c8f02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6033fca02d87955ac7f391cdcbeb4707d2c8f02/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "228ca8ef0a2087d5000aa28f821f31c0d675be1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/228ca8ef0a2087d5000aa28f821f31c0d675be1f", "html_url": "https://github.com/rust-lang/rust/commit/228ca8ef0a2087d5000aa28f821f31c0d675be1f"}], "stats": {"total": 180, "additions": 29, "deletions": 151}, "files": [{"sha": "de94b6b1850d7ea63771bdc8553e2334bf1cb656", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b6033fca02d87955ac7f391cdcbeb4707d2c8f02/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6033fca02d87955ac7f391cdcbeb4707d2c8f02/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=b6033fca02d87955ac7f391cdcbeb4707d2c8f02", "patch": "@@ -8,7 +8,6 @@ use rustc_errors::Diagnostic;\n use rustc_hir::def_id::DefId;\n \n mod dep_node;\n-mod safe;\n \n pub(crate) use rustc_query_system::dep_graph::DepNodeParams;\n pub use rustc_query_system::dep_graph::{\n@@ -17,8 +16,6 @@ pub use rustc_query_system::dep_graph::{\n };\n \n pub use dep_node::{label_strs, DepConstructor, DepKind, DepNode, DepNodeExt};\n-pub use safe::AssertDepGraphSafe;\n-pub use safe::DepGraphSafe;\n \n pub type DepGraph = rustc_query_system::dep_graph::DepGraph<DepKind>;\n pub type TaskDeps = rustc_query_system::dep_graph::TaskDeps<DepKind>;\n@@ -189,17 +186,3 @@ impl rustc_query_system::HashStableContext for StableHashingContext<'_> {\n         self.sess().opts.debugging_opts.dep_tasks\n     }\n }\n-\n-impl rustc_query_system::HashStableContextProvider<StableHashingContext<'tcx>> for TyCtxt<'tcx> {\n-    fn get_stable_hashing_context(&self) -> StableHashingContext<'tcx> {\n-        self.create_stable_hashing_context()\n-    }\n-}\n-\n-impl rustc_query_system::HashStableContextProvider<StableHashingContext<'a>>\n-    for StableHashingContext<'a>\n-{\n-    fn get_stable_hashing_context(&self) -> Self {\n-        self.clone()\n-    }\n-}"}, {"sha": "47a1c09672ff60aad8fa8c5f84b788d0e34b1b02", "filename": "src/librustc/dep_graph/safe.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/228ca8ef0a2087d5000aa28f821f31c0d675be1f/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/228ca8ef0a2087d5000aa28f821f31c0d675be1f/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fsafe.rs?ref=228ca8ef0a2087d5000aa28f821f31c0d675be1f", "patch": "@@ -1,9 +0,0 @@\n-//! The `DepGraphSafe` trait\n-\n-use crate::ty::TyCtxt;\n-\n-pub use rustc_query_system::dep_graph::{AssertDepGraphSafe, DepGraphSafe};\n-\n-/// The type context itself can be used to access all kinds of tracked\n-/// state, but those accesses should always generate read events.\n-impl<'tcx> DepGraphSafe for TyCtxt<'tcx> {}"}, {"sha": "ac3faae072b68c6a535c478d8cbf6c9ae2690950", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6033fca02d87955ac7f391cdcbeb4707d2c8f02/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6033fca02d87955ac7f391cdcbeb4707d2c8f02/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=b6033fca02d87955ac7f391cdcbeb4707d2c8f02", "patch": "@@ -194,8 +194,6 @@ impl<'a> StableHashingContextProvider<'a> for StableHashingContext<'a> {\n     }\n }\n \n-impl<'a> crate::dep_graph::DepGraphSafe for StableHashingContext<'a> {}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for ast::NodeId {\n     fn hash_stable(&self, _: &mut StableHashingContext<'a>, _: &mut StableHasher) {\n         panic!(\"Node IDs should not appear in incremental state\");"}, {"sha": "7e87f45ba4bb1b48ab548b0aac4563b51f3f72fc", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b6033fca02d87955ac7f391cdcbeb4707d2c8f02/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6033fca02d87955ac7f391cdcbeb4707d2c8f02/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=b6033fca02d87955ac7f391cdcbeb4707d2c8f02", "patch": "@@ -7,7 +7,6 @@ use crate::type_::Type;\n use crate::value::Value;\n \n use rustc::bug;\n-use rustc::dep_graph::DepGraphSafe;\n use rustc::mir::mono::CodegenUnit;\n use rustc::ty::layout::{\n     HasParamEnv, LayoutError, LayoutOf, PointeeInfo, Size, TyLayout, VariantIdx,\n@@ -90,8 +89,6 @@ pub struct CodegenCx<'ll, 'tcx> {\n     local_gen_sym_counter: Cell<usize>,\n }\n \n-impl<'ll, 'tcx> DepGraphSafe for CodegenCx<'ll, 'tcx> {}\n-\n pub fn get_reloc_model(sess: &Session) -> llvm::RelocMode {\n     let reloc_model_arg = match sess.opts.cg.relocation_model {\n         Some(ref s) => &s[..],"}, {"sha": "60c5dcda42515e8fdfbd91920df5fa4521222ecb", "filename": "src/librustc_query_system/dep_graph/graph.rs", "status": "modified", "additions": 17, "deletions": 30, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b6033fca02d87955ac7f391cdcbeb4707d2c8f02/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6033fca02d87955ac7f391cdcbeb4707d2c8f02/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs?ref=b6033fca02d87955ac7f391cdcbeb4707d2c8f02", "patch": "@@ -20,10 +20,9 @@ use std::sync::atomic::Ordering::Relaxed;\n use super::debug::EdgeFilter;\n use super::prev::PreviousDepGraph;\n use super::query::DepGraphQuery;\n-use super::safe::DepGraphSafe;\n use super::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n use super::{DepContext, DepKind, DepNode, WorkProductId};\n-use crate::{HashStableContext, HashStableContextProvider};\n+use crate::HashStableContext;\n \n #[derive(Clone)]\n pub struct DepGraph<K: DepKind> {\n@@ -191,18 +190,14 @@ impl<K: DepKind> DepGraph<K> {\n     ///   `arg` parameter.\n     ///\n     /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/incremental-compilation.html\n-    pub fn with_task<H, C, A, R>(\n+    pub fn with_task<Ctxt: DepContext<DepKind = K>, A, R>(\n         &self,\n         key: DepNode<K>,\n-        cx: C,\n+        cx: Ctxt,\n         arg: A,\n-        task: fn(C, A) -> R,\n-        hash_result: impl FnOnce(&mut H, &R) -> Option<Fingerprint>,\n-    ) -> (R, DepNodeIndex)\n-    where\n-        C: DepGraphSafe + HashStableContextProvider<H>,\n-        H: HashStableContext,\n-    {\n+        task: fn(Ctxt, A) -> R,\n+        hash_result: impl FnOnce(&mut Ctxt::StableHashingContext, &R) -> Option<Fingerprint>,\n+    ) -> (R, DepNodeIndex) {\n         self.with_task_impl(\n             key,\n             cx,\n@@ -223,26 +218,22 @@ impl<K: DepKind> DepGraph<K> {\n         )\n     }\n \n-    fn with_task_impl<H, C, A, R>(\n+    fn with_task_impl<Ctxt: DepContext<DepKind = K>, A, R>(\n         &self,\n         key: DepNode<K>,\n-        cx: C,\n+        cx: Ctxt,\n         arg: A,\n         no_tcx: bool,\n-        task: fn(C, A) -> R,\n+        task: fn(Ctxt, A) -> R,\n         create_task: fn(DepNode<K>) -> Option<TaskDeps<K>>,\n         finish_task_and_alloc_depnode: fn(\n             &CurrentDepGraph<K>,\n             DepNode<K>,\n             Fingerprint,\n             Option<TaskDeps<K>>,\n         ) -> DepNodeIndex,\n-        hash_result: impl FnOnce(&mut H, &R) -> Option<Fingerprint>,\n-    ) -> (R, DepNodeIndex)\n-    where\n-        C: DepGraphSafe + HashStableContextProvider<H>,\n-        H: HashStableContext,\n-    {\n+        hash_result: impl FnOnce(&mut Ctxt::StableHashingContext, &R) -> Option<Fingerprint>,\n+    ) -> (R, DepNodeIndex) {\n         if let Some(ref data) = self.data {\n             let task_deps = create_task(key).map(Lock::new);\n \n@@ -251,7 +242,7 @@ impl<K: DepKind> DepGraph<K> {\n             // anyway so that\n             //  - we make sure that the infrastructure works and\n             //  - we can get an idea of the runtime cost.\n-            let mut hcx = cx.get_stable_hashing_context();\n+            let mut hcx = cx.create_stable_hashing_context();\n \n             let result = if no_tcx {\n                 task(cx, arg)\n@@ -335,18 +326,14 @@ impl<K: DepKind> DepGraph<K> {\n \n     /// Executes something within an \"eval-always\" task which is a task\n     /// that runs whenever anything changes.\n-    pub fn with_eval_always_task<H, C, A, R>(\n+    pub fn with_eval_always_task<Ctxt: DepContext<DepKind = K>, A, R>(\n         &self,\n         key: DepNode<K>,\n-        cx: C,\n+        cx: Ctxt,\n         arg: A,\n-        task: fn(C, A) -> R,\n-        hash_result: impl FnOnce(&mut H, &R) -> Option<Fingerprint>,\n-    ) -> (R, DepNodeIndex)\n-    where\n-        C: DepGraphSafe + HashStableContextProvider<H>,\n-        H: HashStableContext,\n-    {\n+        task: fn(Ctxt, A) -> R,\n+        hash_result: impl FnOnce(&mut Ctxt::StableHashingContext, &R) -> Option<Fingerprint>,\n+    ) -> (R, DepNodeIndex) {\n         self.with_task_impl(\n             key,\n             cx,"}, {"sha": "f215dadc6608ff08c0a7e155ab7a8a6a41085b56", "filename": "src/librustc_query_system/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b6033fca02d87955ac7f391cdcbeb4707d2c8f02/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6033fca02d87955ac7f391cdcbeb4707d2c8f02/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs?ref=b6033fca02d87955ac7f391cdcbeb4707d2c8f02", "patch": "@@ -3,16 +3,13 @@ mod dep_node;\n mod graph;\n mod prev;\n mod query;\n-mod safe;\n mod serialized;\n \n pub use dep_node::{DepNode, DepNodeParams, WorkProductId};\n pub use graph::WorkProductFileKind;\n pub use graph::{hash_result, DepGraph, DepNodeColor, DepNodeIndex, TaskDeps, WorkProduct};\n pub use prev::PreviousDepGraph;\n pub use query::DepGraphQuery;\n-pub use safe::AssertDepGraphSafe;\n-pub use safe::DepGraphSafe;\n pub use serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n \n use rustc_data_structures::profiling::SelfProfilerRef;\n@@ -23,7 +20,7 @@ use rustc_errors::Diagnostic;\n use std::fmt;\n use std::hash::Hash;\n \n-pub trait DepContext: Copy + DepGraphSafe {\n+pub trait DepContext: Copy {\n     type DepKind: self::DepKind;\n     type StableHashingContext: crate::HashStableContext;\n "}, {"sha": "7bba348f8841f70c46019f9aa8ba64612f9c3190", "filename": "src/librustc_query_system/dep_graph/safe.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/228ca8ef0a2087d5000aa28f821f31c0d675be1f/src%2Flibrustc_query_system%2Fdep_graph%2Fsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/228ca8ef0a2087d5000aa28f821f31c0d675be1f/src%2Flibrustc_query_system%2Fdep_graph%2Fsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fsafe.rs?ref=228ca8ef0a2087d5000aa28f821f31c0d675be1f", "patch": "@@ -1,51 +0,0 @@\n-//! The `DepGraphSafe` trait\n-\n-use rustc_ast::ast::NodeId;\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::BodyId;\n-\n-/// The `DepGraphSafe` trait is used to specify what kinds of values\n-/// are safe to \"leak\" into a task. The idea is that this should be\n-/// only be implemented for things like the tcx as well as various id\n-/// types, which will create reads in the dep-graph whenever the trait\n-/// loads anything that might depend on the input program.\n-pub trait DepGraphSafe {}\n-\n-/// A `BodyId` on its own doesn't give access to any particular state.\n-/// You must fetch the state from the various maps or generate\n-/// on-demand queries, all of which create reads.\n-impl DepGraphSafe for BodyId {}\n-\n-/// A `NodeId` on its own doesn't give access to any particular state.\n-/// You must fetch the state from the various maps or generate\n-/// on-demand queries, all of which create reads.\n-impl DepGraphSafe for NodeId {}\n-\n-/// A `DefId` on its own doesn't give access to any particular state.\n-/// You must fetch the state from the various maps or generate\n-/// on-demand queries, all of which create reads.\n-impl DepGraphSafe for DefId {}\n-\n-/// Tuples make it easy to build up state.\n-impl<A, B> DepGraphSafe for (A, B)\n-where\n-    A: DepGraphSafe,\n-    B: DepGraphSafe,\n-{\n-}\n-\n-/// Shared ref to dep-graph-safe stuff should still be dep-graph-safe.\n-impl<'a, A> DepGraphSafe for &'a A where A: DepGraphSafe {}\n-\n-/// Mut ref to dep-graph-safe stuff should still be dep-graph-safe.\n-impl<'a, A> DepGraphSafe for &'a mut A where A: DepGraphSafe {}\n-\n-/// No data here! :)\n-impl DepGraphSafe for () {}\n-\n-/// A convenient override that lets you pass arbitrary state into a\n-/// task. Every use should be accompanied by a comment explaining why\n-/// it makes sense (or how it could be refactored away in the future).\n-pub struct AssertDepGraphSafe<T>(pub T);\n-\n-impl<T> DepGraphSafe for AssertDepGraphSafe<T> {}"}, {"sha": "1f7fde642eb41306db340b5c7287c5676ece2134", "filename": "src/librustc_query_system/lib.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b6033fca02d87955ac7f391cdcbeb4707d2c8f02/src%2Flibrustc_query_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6033fca02d87955ac7f391cdcbeb4707d2c8f02/src%2Flibrustc_query_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Flib.rs?ref=b6033fca02d87955ac7f391cdcbeb4707d2c8f02", "patch": "@@ -19,20 +19,3 @@ pub mod query;\n pub trait HashStableContext {\n     fn debug_dep_tasks(&self) -> bool;\n }\n-\n-/// Something that can provide a stable hashing context.\n-pub trait HashStableContextProvider<Ctxt> {\n-    fn get_stable_hashing_context(&self) -> Ctxt;\n-}\n-\n-impl<Ctxt, T: HashStableContextProvider<Ctxt>> HashStableContextProvider<Ctxt> for &T {\n-    fn get_stable_hashing_context(&self) -> Ctxt {\n-        (**self).get_stable_hashing_context()\n-    }\n-}\n-\n-impl<Ctxt, T: HashStableContextProvider<Ctxt>> HashStableContextProvider<Ctxt> for &mut T {\n-    fn get_stable_hashing_context(&self) -> Ctxt {\n-        (**self).get_stable_hashing_context()\n-    }\n-}"}, {"sha": "f025a056512b98a40e4ceea9e36d922564949717", "filename": "src/librustc_query_system/query/plumbing.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b6033fca02d87955ac7f391cdcbeb4707d2c8f02/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6033fca02d87955ac7f391cdcbeb4707d2c8f02/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fquery%2Fplumbing.rs?ref=b6033fca02d87955ac7f391cdcbeb4707d2c8f02", "patch": "@@ -2,12 +2,11 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use crate::dep_graph::{DepContext, DepKind, DepNode};\n+use crate::dep_graph::{DepKind, DepNode};\n use crate::dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n use crate::query::caches::QueryCache;\n use crate::query::config::{QueryContext, QueryDescription};\n use crate::query::job::{QueryInfo, QueryJob, QueryJobId, QueryJobInfo, QueryShardJobId};\n-use crate::HashStableContextProvider;\n \n #[cfg(not(parallel_compiler))]\n use rustc_data_structures::cold_path;\n@@ -382,17 +381,15 @@ where\n }\n \n #[inline(always)]\n-fn try_execute_query<Q, CTX, K>(\n+fn try_execute_query<Q, CTX>(\n     tcx: CTX,\n     span: Span,\n     key: Q::Key,\n     lookup: QueryLookup<'_, CTX, Q::Key, <Q::Cache as QueryCache<CTX>>::Sharded>,\n ) -> Q::Value\n where\n     Q: QueryDescription<CTX>,\n-    CTX: QueryContext<DepKind = K>,\n-    CTX: HashStableContextProvider<<CTX as DepContext>::StableHashingContext>,\n-    K: DepKind,\n+    CTX: QueryContext,\n {\n     let job = match JobOwner::try_start::<Q, _>(tcx, span, &key, lookup) {\n         TryGetJob::NotYetStarted(job) => job,\n@@ -408,7 +405,7 @@ where\n     // expensive for some `DepKind`s.\n     if !tcx.dep_graph().is_fully_enabled() {\n         let null_dep_node = DepNode::new_no_params(DepKind::NULL);\n-        return force_query_with_job::<Q, _, _>(tcx, key, job, null_dep_node).0;\n+        return force_query_with_job::<Q, _>(tcx, key, job, null_dep_node).0;\n     }\n \n     if Q::ANON {\n@@ -460,7 +457,7 @@ where\n         }\n     }\n \n-    let (result, dep_node_index) = force_query_with_job::<Q, _, _>(tcx, key, job, dep_node);\n+    let (result, dep_node_index) = force_query_with_job::<Q, _>(tcx, key, job, dep_node);\n     tcx.dep_graph().read_index(dep_node_index);\n     result\n }\n@@ -554,17 +551,15 @@ fn incremental_verify_ich<Q, CTX>(\n }\n \n #[inline(always)]\n-fn force_query_with_job<Q, CTX, K>(\n+fn force_query_with_job<Q, CTX>(\n     tcx: CTX,\n     key: Q::Key,\n     job: JobOwner<'_, CTX, Q::Cache>,\n     dep_node: DepNode<CTX::DepKind>,\n ) -> (Q::Value, DepNodeIndex)\n where\n     Q: QueryDescription<CTX>,\n-    CTX: QueryContext<DepKind = K>,\n-    CTX: HashStableContextProvider<<CTX as DepContext>::StableHashingContext>,\n-    K: DepKind,\n+    CTX: QueryContext,\n {\n     // If the following assertion triggers, it can have two reasons:\n     // 1. Something is wrong with DepNode creation, either here or\n@@ -631,11 +626,9 @@ pub trait QueryGetter: QueryContext {\n     );\n }\n \n-impl<CTX, K> QueryGetter for CTX\n+impl<CTX> QueryGetter for CTX\n where\n-    CTX: QueryContext<DepKind = K>,\n-    CTX: HashStableContextProvider<<CTX as DepContext>::StableHashingContext>,\n-    K: DepKind,\n+    CTX: QueryContext,\n {\n     #[inline(never)]\n     fn get_query<Q: QueryDescription<Self>>(self, span: Span, key: Q::Key) -> Q::Value {\n@@ -649,7 +642,7 @@ where\n                 self.dep_graph().read_index(index);\n                 value.clone()\n             },\n-            |key, lookup| try_execute_query::<Q, _, _>(self, span, key, lookup),\n+            |key, lookup| try_execute_query::<Q, _>(self, span, key, lookup),\n         )\n     }\n \n@@ -710,7 +703,7 @@ where\n                     #[cfg(parallel_compiler)]\n                     TryGetJob::JobCompleted(_) => return,\n                 };\n-                force_query_with_job::<Q, _, _>(self, key, job, dep_node);\n+                force_query_with_job::<Q, _>(self, key, job, dep_node);\n             },\n         );\n     }"}]}