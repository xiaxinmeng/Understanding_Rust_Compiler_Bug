{"sha": "61365c06250e2ba6e0a578ae990f055ac5339107", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxMzY1YzA2MjUwZTJiYTZlMGE1NzhhZTk5MGYwNTVhYzUzMzkxMDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-11T15:34:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-11T15:34:01Z"}, "message": "Auto merge of #82495 - LeSeulArtichaut:eager-thir, r=oli-obk\n\nEagerly construct bodies of THIR\n\nWith this PR:\n - the THIR is no longer constructed lazily, but is entirely built before being passed to the MIR Builder\n - the THIR is now allocated in arenas instead of `Box`es\n\nHowever, this PR doesn't make any changes to the way patterns are constructed: they are still boxed, and exhaustiveness checking is unchanged.\n\nImplements MCP rust-lang/compiler-team#409.\nCloses rust-lang/project-thir-unsafeck#1.\nr? `@ghost` cc `@nikomatsakis` `@oli-obk`", "tree": {"sha": "62d05029146ad72ec2831eb470ac095814e01506", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62d05029146ad72ec2831eb470ac095814e01506"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61365c06250e2ba6e0a578ae990f055ac5339107", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61365c06250e2ba6e0a578ae990f055ac5339107", "html_url": "https://github.com/rust-lang/rust/commit/61365c06250e2ba6e0a578ae990f055ac5339107", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61365c06250e2ba6e0a578ae990f055ac5339107/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c6d3bf3896b465e15550f49c2861e3d18102270", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c6d3bf3896b465e15550f49c2861e3d18102270", "html_url": "https://github.com/rust-lang/rust/commit/5c6d3bf3896b465e15550f49c2861e3d18102270"}, {"sha": "d6c737adb50e194beca9cf0c0a87037738ae8a58", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6c737adb50e194beca9cf0c0a87037738ae8a58", "html_url": "https://github.com/rust-lang/rust/commit/d6c737adb50e194beca9cf0c0a87037738ae8a58"}], "stats": {"total": 3310, "additions": 1560, "deletions": 1750}, "files": [{"sha": "808c6e3ff644b76b358f4ec6d3b03e675fcbbd1d", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=61365c06250e2ba6e0a578ae990f055ac5339107", "patch": "@@ -2,7 +2,6 @@ use crate::build::matches::ArmHasGuard;\n use crate::build::ForGuard::OutsideGuard;\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n use crate::thir::*;\n-use rustc_hir as hir;\n use rustc_middle::mir::*;\n use rustc_session::lint::builtin::UNSAFE_OP_IN_UNSAFE_FN;\n use rustc_session::lint::Level;\n@@ -13,7 +12,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         destination: Place<'tcx>,\n         block: BasicBlock,\n-        ast_block: &'tcx hir::Block<'tcx>,\n+        ast_block: &Block<'_, 'tcx>,\n         source_info: SourceInfo,\n     ) -> BlockAnd<()> {\n         let Block {\n@@ -24,7 +23,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             expr,\n             targeted_by_break,\n             safety_mode,\n-        } = self.hir.mirror(ast_block);\n+        } = *ast_block;\n         self.in_opt_scope(opt_destruction_scope.map(|de| (de, source_info)), move |this| {\n             this.in_scope((region_scope, source_info), LintLevel::Inherited, move |this| {\n                 if targeted_by_break {\n@@ -50,8 +49,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         destination: Place<'tcx>,\n         mut block: BasicBlock,\n         span: Span,\n-        stmts: Vec<StmtRef<'tcx>>,\n-        expr: Option<ExprRef<'tcx>>,\n+        stmts: &[Stmt<'_, 'tcx>],\n+        expr: Option<&Expr<'_, 'tcx>>,\n         safety_mode: BlockSafety,\n     ) -> BlockAnd<()> {\n         let this = self;\n@@ -79,18 +78,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         this.update_source_scope_for_safety_mode(span, safety_mode);\n \n         let source_info = this.source_info(span);\n-        for stmt in stmts {\n-            let Stmt { kind, opt_destruction_scope } = this.hir.mirror(stmt);\n+        for Stmt { kind, opt_destruction_scope } in stmts {\n             match kind {\n-                StmtKind::Expr { scope, expr } => {\n+                &StmtKind::Expr { scope, expr } => {\n                     this.block_context.push(BlockFrame::Statement { ignores_expr_result: true });\n                     unpack!(\n                         block = this.in_opt_scope(\n                             opt_destruction_scope.map(|de| (de, source_info)),\n                             |this| {\n                                 let si = (scope, source_info);\n                                 this.in_scope(si, LintLevel::Inherited, |this| {\n-                                    let expr = this.hir.mirror(expr);\n                                     this.stmt_expr(block, expr, Some(scope))\n                                 })\n                             }\n@@ -102,45 +99,44 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     this.block_context.push(BlockFrame::Statement { ignores_expr_result });\n \n                     // Enter the remainder scope, i.e., the bindings' destruction scope.\n-                    this.push_scope((remainder_scope, source_info));\n+                    this.push_scope((*remainder_scope, source_info));\n                     let_scope_stack.push(remainder_scope);\n \n                     // Declare the bindings, which may create a source scope.\n-                    let remainder_span =\n-                        remainder_scope.span(this.hir.tcx(), &this.hir.region_scope_tree);\n+                    let remainder_span = remainder_scope.span(this.tcx, this.region_scope_tree);\n \n                     let visibility_scope =\n                         Some(this.new_source_scope(remainder_span, LintLevel::Inherited, None));\n \n                     // Evaluate the initializer, if present.\n                     if let Some(init) = initializer {\n-                        let initializer_span = init.span();\n+                        let initializer_span = init.span;\n \n                         unpack!(\n                             block = this.in_opt_scope(\n                                 opt_destruction_scope.map(|de| (de, source_info)),\n                                 |this| {\n-                                    let scope = (init_scope, source_info);\n-                                    this.in_scope(scope, lint_level, |this| {\n+                                    let scope = (*init_scope, source_info);\n+                                    this.in_scope(scope, *lint_level, |this| {\n                                         this.declare_bindings(\n                                             visibility_scope,\n                                             remainder_span,\n-                                            &pattern,\n+                                            pattern,\n                                             ArmHasGuard(false),\n                                             Some((None, initializer_span)),\n                                         );\n-                                        this.expr_into_pattern(block, pattern, init)\n+                                        this.expr_into_pattern(block, pattern.clone(), init)\n                                     })\n                                 }\n                             )\n                         );\n                     } else {\n-                        let scope = (init_scope, source_info);\n-                        unpack!(this.in_scope(scope, lint_level, |this| {\n+                        let scope = (*init_scope, source_info);\n+                        unpack!(this.in_scope(scope, *lint_level, |this| {\n                             this.declare_bindings(\n                                 visibility_scope,\n                                 remainder_span,\n-                                &pattern,\n+                                pattern,\n                                 ArmHasGuard(false),\n                                 None,\n                             );\n@@ -171,18 +167,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         // Then, the block may have an optional trailing expression which is a \u201creturn\u201d value\n         // of the block, which is stored into `destination`.\n-        let tcx = this.hir.tcx();\n+        let tcx = this.tcx;\n         let destination_ty = destination.ty(&this.local_decls, tcx).ty;\n         if let Some(expr) = expr {\n             let tail_result_is_ignored =\n                 destination_ty.is_unit() || this.block_context.currently_ignores_tail_results();\n-            let span = match expr {\n-                ExprRef::Thir(expr) => expr.span,\n-                ExprRef::Mirror(ref expr) => expr.span,\n-            };\n-            this.block_context.push(BlockFrame::TailExpr { tail_result_is_ignored, span });\n+            this.block_context\n+                .push(BlockFrame::TailExpr { tail_result_is_ignored, span: expr.span });\n \n-            unpack!(block = this.into(destination, block, expr));\n+            unpack!(block = this.expr_into_dest(destination, block, expr));\n             let popped = this.block_context.pop();\n \n             assert!(popped.map_or(false, |bf| bf.is_tail_expr()));\n@@ -194,13 +187,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             if destination_ty.is_unit() {\n                 // We only want to assign an implicit `()` as the return value of the block if the\n                 // block does not diverge. (Otherwise, we may try to assign a unit to a `!`-type.)\n-                this.cfg.push_assign_unit(block, source_info, destination, this.hir.tcx());\n+                this.cfg.push_assign_unit(block, source_info, destination, this.tcx);\n             }\n         }\n         // Finally, we pop all the let scopes before exiting out from the scope of block\n         // itself.\n         for scope in let_scope_stack.into_iter().rev() {\n-            unpack!(block = this.pop_scope((scope, source_info), block));\n+            unpack!(block = this.pop_scope((*scope, source_info), block));\n         }\n         // Restore the original source scope.\n         this.source_scope = outer_source_scope;\n@@ -220,7 +213,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     Safety::Safe => {}\n                     // no longer treat `unsafe fn`s as `unsafe` contexts (see RFC #2585)\n                     Safety::FnUnsafe\n-                        if self.hir.tcx().lint_level_at_node(UNSAFE_OP_IN_UNSAFE_FN, hir_id).0\n+                        if self.tcx.lint_level_at_node(UNSAFE_OP_IN_UNSAFE_FN, hir_id).0\n                             != Level::Allow => {}\n                     _ => return,\n                 }"}, {"sha": "727aedb0ef854df15fe5c121eea1bcee7b31155d", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=61365c06250e2ba6e0a578ae990f055ac5339107", "patch": "@@ -8,17 +8,9 @@ use rustc_middle::ty::CanonicalUserTypeAnnotation;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, yielding a compile-time constant. Assumes that\n     /// `expr` is a valid compile-time constant!\n-    crate fn as_constant<M>(&mut self, expr: M) -> Constant<'tcx>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n-        let expr = self.hir.mirror(expr);\n-        self.expr_as_constant(expr)\n-    }\n-\n-    fn expr_as_constant(&mut self, expr: Expr<'tcx>) -> Constant<'tcx> {\n+    crate fn as_constant(&mut self, expr: &Expr<'_, 'tcx>) -> Constant<'tcx> {\n         let this = self;\n-        let Expr { ty, temp_lifetime: _, span, kind } = expr;\n+        let Expr { ty, temp_lifetime: _, span, ref kind } = *expr;\n         match kind {\n             ExprKind::Scope { region_scope: _, lint_level: _, value } => this.as_constant(value),\n             ExprKind::Literal { literal, user_ty, const_id: _ } => {\n@@ -33,7 +25,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 Constant { span, user_ty, literal }\n             }\n             ExprKind::StaticRef { literal, .. } => Constant { span, user_ty: None, literal },\n-            ExprKind::ConstBlock { value } => Constant { span, user_ty: None, literal: value },\n+            ExprKind::ConstBlock { value } => {\n+                Constant { span: span, user_ty: None, literal: value }\n+            }\n             _ => span_bug!(span, \"expression is not a valid constant {:?}\", kind),\n         }\n     }"}, {"sha": "c393878e0b9957b3a2ec3f4d080eb61191b9095d", "filename": "compiler/rustc_mir_build/src/build/expr/as_operand.rs", "status": "modified", "additions": 20, "deletions": 49, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs?ref=61365c06250e2ba6e0a578ae990f055ac5339107", "patch": "@@ -14,10 +14,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// after the current enclosing `ExprKind::Scope` has ended, so\n     /// please do *not* return it from functions to avoid bad\n     /// miscompiles.\n-    crate fn as_local_operand<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Operand<'tcx>>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n+    crate fn as_local_operand(\n+        &mut self,\n+        block: BasicBlock,\n+        expr: &Expr<'_, 'tcx>,\n+    ) -> BlockAnd<Operand<'tcx>> {\n         let local_scope = self.local_scope();\n         self.as_operand(block, Some(local_scope), expr)\n     }\n@@ -70,14 +71,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// value to the stack.\n     ///\n     /// See #68034 for more details.\n-    crate fn as_local_call_operand<M>(\n+    crate fn as_local_call_operand(\n         &mut self,\n         block: BasicBlock,\n-        expr: M,\n-    ) -> BlockAnd<Operand<'tcx>>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n+        expr: &Expr<'_, 'tcx>,\n+    ) -> BlockAnd<Operand<'tcx>> {\n         let local_scope = self.local_scope();\n         self.as_call_operand(block, Some(local_scope), expr)\n     }\n@@ -88,41 +86,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// this time.\n     ///\n     /// The operand is known to be live until the end of `scope`.\n-    crate fn as_operand<M>(\n-        &mut self,\n-        block: BasicBlock,\n-        scope: Option<region::Scope>,\n-        expr: M,\n-    ) -> BlockAnd<Operand<'tcx>>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n-        let expr = self.hir.mirror(expr);\n-        self.expr_as_operand(block, scope, expr)\n-    }\n-\n+    ///\n     /// Like `as_local_call_operand`, except that the argument will\n     /// not be valid once `scope` ends.\n-    fn as_call_operand<M>(\n-        &mut self,\n-        block: BasicBlock,\n-        scope: Option<region::Scope>,\n-        expr: M,\n-    ) -> BlockAnd<Operand<'tcx>>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n-        let expr = self.hir.mirror(expr);\n-        self.expr_as_call_operand(block, scope, expr)\n-    }\n-\n-    fn expr_as_operand(\n+    crate fn as_operand(\n         &mut self,\n         mut block: BasicBlock,\n         scope: Option<region::Scope>,\n-        expr: Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n     ) -> BlockAnd<Operand<'tcx>> {\n-        debug!(\"expr_as_operand(block={:?}, expr={:?})\", block, expr);\n+        debug!(\"as_operand(block={:?}, expr={:?})\", block, expr);\n         let this = self;\n \n         if let ExprKind::Scope { region_scope, lint_level, value } = expr.kind {\n@@ -133,7 +106,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         let category = Category::of(&expr.kind).unwrap();\n-        debug!(\"expr_as_operand: category={:?} for={:?}\", category, expr.kind);\n+        debug!(\"as_operand: category={:?} for={:?}\", category, expr.kind);\n         match category {\n             Category::Constant => {\n                 let constant = this.as_constant(expr);\n@@ -146,13 +119,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    fn expr_as_call_operand(\n+    crate fn as_call_operand(\n         &mut self,\n         mut block: BasicBlock,\n         scope: Option<region::Scope>,\n-        expr: Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n     ) -> BlockAnd<Operand<'tcx>> {\n-        debug!(\"expr_as_call_operand(block={:?}, expr={:?})\", block, expr);\n+        debug!(\"as_call_operand(block={:?}, expr={:?})\", block, expr);\n         let this = self;\n \n         if let ExprKind::Scope { region_scope, lint_level, value } = expr.kind {\n@@ -163,22 +136,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             });\n         }\n \n-        let tcx = this.hir.tcx();\n+        let tcx = this.tcx;\n \n         if tcx.features().unsized_fn_params {\n             let ty = expr.ty;\n             let span = expr.span;\n-            let param_env = this.hir.param_env;\n+            let param_env = this.param_env;\n \n             if !ty.is_sized(tcx.at(span), param_env) {\n                 // !sized means !copy, so this is an unsized move\n                 assert!(!ty.is_copy_modulo_regions(tcx.at(span), param_env));\n \n                 // As described above, detect the case where we are passing a value of unsized\n                 // type, and that value is coming from the deref of a box.\n-                if let ExprKind::Deref { ref arg } = expr.kind {\n-                    let arg = this.hir.mirror(arg.clone());\n-\n+                if let ExprKind::Deref { arg } = expr.kind {\n                     // Generate let tmp0 = arg0\n                     let operand = unpack!(block = this.as_temp(block, scope, arg, Mutability::Mut));\n \n@@ -193,6 +164,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n \n-        this.expr_as_operand(block, scope, expr)\n+        this.as_operand(block, scope, expr)\n     }\n }"}, {"sha": "532c725c823ef143524635a0306b34be176a3ae1", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 29, "deletions": 49, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=61365c06250e2ba6e0a578ae990f055ac5339107", "patch": "@@ -347,25 +347,22 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Extra care is needed if any user code is allowed to run between calling\n     /// this method and using it, as is the case for `match` and index\n     /// expressions.\n-    crate fn as_place<M>(&mut self, mut block: BasicBlock, expr: M) -> BlockAnd<Place<'tcx>>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n+    crate fn as_place(\n+        &mut self,\n+        mut block: BasicBlock,\n+        expr: &Expr<'_, 'tcx>,\n+    ) -> BlockAnd<Place<'tcx>> {\n         let place_builder = unpack!(block = self.as_place_builder(block, expr));\n-        block.and(place_builder.into_place(self.hir.tcx(), self.hir.typeck_results()))\n+        block.and(place_builder.into_place(self.tcx, self.typeck_results))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n     /// intermediate `Place` values until we know the full set of projections.\n-    crate fn as_place_builder<M>(\n+    crate fn as_place_builder(\n         &mut self,\n         block: BasicBlock,\n-        expr: M,\n-    ) -> BlockAnd<PlaceBuilder<'tcx>>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n-        let expr = self.hir.mirror(expr);\n+        expr: &Expr<'_, 'tcx>,\n+    ) -> BlockAnd<PlaceBuilder<'tcx>> {\n         self.expr_as_place(block, expr, Mutability::Mut, None)\n     }\n \n@@ -374,16 +371,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// place. The place itself may or may not be mutable:\n     /// * If this expr is a place expr like a.b, then we will return that place.\n     /// * Otherwise, a temporary is created: in that event, it will be an immutable temporary.\n-    crate fn as_read_only_place<M>(\n+    crate fn as_read_only_place(\n         &mut self,\n         mut block: BasicBlock,\n-        expr: M,\n-    ) -> BlockAnd<Place<'tcx>>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n+        expr: &Expr<'_, 'tcx>,\n+    ) -> BlockAnd<Place<'tcx>> {\n         let place_builder = unpack!(block = self.as_read_only_place_builder(block, expr));\n-        block.and(place_builder.into_place(self.hir.tcx(), self.hir.typeck_results()))\n+        block.and(place_builder.into_place(self.tcx, self.typeck_results))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n@@ -392,22 +386,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// place. The place itself may or may not be mutable:\n     /// * If this expr is a place expr like a.b, then we will return that place.\n     /// * Otherwise, a temporary is created: in that event, it will be an immutable temporary.\n-    fn as_read_only_place_builder<M>(\n+    fn as_read_only_place_builder(\n         &mut self,\n         block: BasicBlock,\n-        expr: M,\n-    ) -> BlockAnd<PlaceBuilder<'tcx>>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n-        let expr = self.hir.mirror(expr);\n+        expr: &Expr<'_, 'tcx>,\n+    ) -> BlockAnd<PlaceBuilder<'tcx>> {\n         self.expr_as_place(block, expr, Mutability::Not, None)\n     }\n \n     fn expr_as_place(\n         &mut self,\n         mut block: BasicBlock,\n-        expr: Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n         mutability: Mutability,\n         fake_borrow_temps: Option<&mut Vec<Local>>,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n@@ -419,18 +409,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         match expr.kind {\n             ExprKind::Scope { region_scope, lint_level, value } => {\n                 this.in_scope((region_scope, source_info), lint_level, |this| {\n-                    let value = this.hir.mirror(value);\n                     this.expr_as_place(block, value, mutability, fake_borrow_temps)\n                 })\n             }\n             ExprKind::Field { lhs, name } => {\n-                let lhs = this.hir.mirror(lhs);\n                 let place_builder =\n                     unpack!(block = this.expr_as_place(block, lhs, mutability, fake_borrow_temps,));\n                 block.and(place_builder.field(name, expr.ty))\n             }\n             ExprKind::Deref { arg } => {\n-                let arg = this.hir.mirror(arg);\n                 let place_builder =\n                     unpack!(block = this.expr_as_place(block, arg, mutability, fake_borrow_temps,));\n                 block.and(place_builder.deref())\n@@ -462,7 +449,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             ExprKind::PlaceTypeAscription { source, user_ty } => {\n-                let source = this.hir.mirror(source);\n                 let place_builder = unpack!(\n                     block = this.expr_as_place(block, source, mutability, fake_borrow_temps,)\n                 );\n@@ -474,8 +460,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             inferred_ty: expr.ty,\n                         });\n \n-                    let place =\n-                        place_builder.clone().into_place(this.hir.tcx(), this.hir.typeck_results());\n+                    let place = place_builder.clone().into_place(this.tcx, this.typeck_results);\n                     this.cfg.push(\n                         block,\n                         Statement {\n@@ -493,7 +478,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block.and(place_builder)\n             }\n             ExprKind::ValueTypeAscription { source, user_ty } => {\n-                let source = this.hir.mirror(source);\n                 let temp =\n                     unpack!(block = this.as_temp(block, source.temp_lifetime, source, mutability));\n                 if let Some(user_ty) = user_ty {\n@@ -570,12 +554,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         upvar_id: ty::UpvarId,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n         let closure_ty = self\n-            .hir\n-            .typeck_results()\n-            .node_type(self.hir.tcx().hir().local_def_id_to_hir_id(upvar_id.closure_expr_id));\n+            .typeck_results\n+            .node_type(self.tcx.hir().local_def_id_to_hir_id(upvar_id.closure_expr_id));\n \n         let closure_kind = if let ty::Closure(_, closure_substs) = closure_ty.kind() {\n-            self.hir.infcx().closure_kind(closure_substs).unwrap()\n+            self.infcx.closure_kind(closure_substs).unwrap()\n         } else {\n             // Generators are considered FnOnce.\n             ty::ClosureKind::FnOnce\n@@ -599,22 +582,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn lower_index_expression(\n         &mut self,\n         mut block: BasicBlock,\n-        base: ExprRef<'tcx>,\n-        index: ExprRef<'tcx>,\n+        base: &Expr<'_, 'tcx>,\n+        index: &Expr<'_, 'tcx>,\n         mutability: Mutability,\n         fake_borrow_temps: Option<&mut Vec<Local>>,\n         temp_lifetime: Option<region::Scope>,\n         expr_span: Span,\n         source_info: SourceInfo,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n-        let lhs = self.hir.mirror(base);\n-\n         let base_fake_borrow_temps = &mut Vec::new();\n         let is_outermost_index = fake_borrow_temps.is_none();\n         let fake_borrow_temps = fake_borrow_temps.unwrap_or(base_fake_borrow_temps);\n \n         let mut base_place =\n-            unpack!(block = self.expr_as_place(block, lhs, mutability, Some(fake_borrow_temps),));\n+            unpack!(block = self.expr_as_place(block, base, mutability, Some(fake_borrow_temps),));\n \n         // Making this a *fresh* temporary means we do not have to worry about\n         // the index changing later: Nothing will ever change this temporary.\n@@ -623,7 +604,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         block = self.bounds_check(\n             block,\n-            base_place.clone().into_place(self.hir.tcx(), self.hir.typeck_results()),\n+            base_place.clone().into_place(self.tcx, self.typeck_results),\n             idx,\n             expr_span,\n             source_info,\n@@ -632,8 +613,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         if is_outermost_index {\n             self.read_fake_borrows(block, fake_borrow_temps, source_info)\n         } else {\n-            base_place =\n-                base_place.expect_upvars_resolved(self.hir.tcx(), self.hir.typeck_results());\n+            base_place = base_place.expect_upvars_resolved(self.tcx, self.typeck_results);\n             self.add_fake_borrows_of_base(\n                 &base_place,\n                 block,\n@@ -654,8 +634,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         expr_span: Span,\n         source_info: SourceInfo,\n     ) -> BasicBlock {\n-        let usize_ty = self.hir.usize_ty();\n-        let bool_ty = self.hir.bool_ty();\n+        let usize_ty = self.tcx.types.usize;\n+        let bool_ty = self.tcx.types.bool;\n         // bounds check:\n         let len = self.temp(usize_ty, expr_span);\n         let lt = self.temp(bool_ty, expr_span);\n@@ -685,7 +665,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         expr_span: Span,\n         source_info: SourceInfo,\n     ) {\n-        let tcx = self.hir.tcx();\n+        let tcx = self.tcx;\n         let local = match base_place.base {\n             PlaceBase::Local(local) => local,\n             PlaceBase::Upvar { .. } => bug!(\"Expected PlacseBase::Local found Upvar\"),"}, {"sha": "d73e5eef70ca6c2b03083d5e8179cbe4ad5ee9ed", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 28, "deletions": 39, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=61365c06250e2ba6e0a578ae990f055ac5339107", "patch": "@@ -19,33 +19,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// The operand returned from this function will *not be valid* after\n     /// an ExprKind::Scope is passed, so please do *not* return it from\n     /// functions to avoid bad miscompiles.\n-    crate fn as_local_rvalue<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Rvalue<'tcx>>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n+    crate fn as_local_rvalue(\n+        &mut self,\n+        block: BasicBlock,\n+        expr: &Expr<'_, 'tcx>,\n+    ) -> BlockAnd<Rvalue<'tcx>> {\n         let local_scope = self.local_scope();\n         self.as_rvalue(block, Some(local_scope), expr)\n     }\n \n     /// Compile `expr`, yielding an rvalue.\n-    fn as_rvalue<M>(\n-        &mut self,\n-        block: BasicBlock,\n-        scope: Option<region::Scope>,\n-        expr: M,\n-    ) -> BlockAnd<Rvalue<'tcx>>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n-        let expr = self.hir.mirror(expr);\n-        self.expr_as_rvalue(block, scope, expr)\n-    }\n-\n-    fn expr_as_rvalue(\n+    crate fn as_rvalue(\n         &mut self,\n         mut block: BasicBlock,\n         scope: Option<region::Scope>,\n-        expr: Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n     ) -> BlockAnd<Rvalue<'tcx>> {\n         debug!(\"expr_as_rvalue(block={:?}, scope={:?}, expr={:?})\", block, scope, expr);\n \n@@ -71,8 +59,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             ExprKind::Unary { op, arg } => {\n                 let arg = unpack!(block = this.as_operand(block, scope, arg));\n                 // Check for -MIN on signed integers\n-                if this.hir.check_overflow() && op == UnOp::Neg && expr.ty.is_signed() {\n-                    let bool_ty = this.hir.bool_ty();\n+                if this.check_overflow && op == UnOp::Neg && expr.ty.is_signed() {\n+                    let bool_ty = this.tcx.types.bool;\n \n                     let minval = this.minval_literal(expr_span, expr.ty);\n                     let is_min = this.temp(bool_ty, expr_span);\n@@ -95,7 +83,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block.and(Rvalue::UnaryOp(op, arg))\n             }\n             ExprKind::Box { value } => {\n-                let value = this.hir.mirror(value);\n                 // The `Box<T>` temporary created here is not a part of the HIR,\n                 // and therefore is not considered during generator auto-trait\n                 // determination. See the comment about `box` at `yield_in_scope`.\n@@ -115,8 +102,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 // initialize the box contents:\n                 unpack!(\n-                    block =\n-                        this.into(this.hir.tcx().mk_place_deref(Place::from(result)), block, value)\n+                    block = this.expr_into_dest(\n+                        this.tcx.mk_place_deref(Place::from(result)),\n+                        block,\n+                        value\n+                    )\n                 );\n                 block.and(Rvalue::Use(Operand::Move(Place::from(result))))\n             }\n@@ -156,7 +146,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 //     to the same MIR as `let x = ();`.\n \n                 // first process the set of fields\n-                let el_ty = expr.ty.sequence_element_type(this.hir.tcx());\n+                let el_ty = expr.ty.sequence_element_type(this.tcx);\n                 let fields: Vec<_> = fields\n                     .into_iter()\n                     .map(|f| unpack!(block = this.as_operand(block, scope, f)))\n@@ -179,7 +169,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let operands: Vec<_> = upvars\n                     .into_iter()\n                     .map(|upvar| {\n-                        let upvar = this.hir.mirror(upvar);\n                         match Category::of(&upvar.kind) {\n                             // Use as_place to avoid creating a temporary when\n                             // moving a variable into a closure, so that\n@@ -230,7 +219,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block.and(Rvalue::Use(Operand::Constant(box Constant {\n                     span: expr_span,\n                     user_ty: None,\n-                    literal: ty::Const::zero_sized(this.hir.tcx(), this.hir.tcx().types.unit),\n+                    literal: ty::Const::zero_sized(this.tcx, this.tcx.types.unit),\n                 })))\n             }\n             ExprKind::Yield { .. }\n@@ -282,9 +271,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         rhs: Operand<'tcx>,\n     ) -> BlockAnd<Rvalue<'tcx>> {\n         let source_info = self.source_info(span);\n-        let bool_ty = self.hir.bool_ty();\n-        if self.hir.check_overflow() && op.is_checkable() && ty.is_integral() {\n-            let result_tup = self.hir.tcx().intern_tup(&[ty, bool_ty]);\n+        let bool_ty = self.tcx.types.bool;\n+        if self.check_overflow && op.is_checkable() && ty.is_integral() {\n+            let result_tup = self.tcx.intern_tup(&[ty, bool_ty]);\n             let result_value = self.temp(result_tup, span);\n \n             self.cfg.push_assign(\n@@ -296,7 +285,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let val_fld = Field::new(0);\n             let of_fld = Field::new(1);\n \n-            let tcx = self.hir.tcx();\n+            let tcx = self.tcx;\n             let val = tcx.mk_place_field(result_value, val_fld, ty);\n             let of = tcx.mk_place_field(result_value, of_fld, bool_ty);\n \n@@ -377,7 +366,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         upvar_ty: Ty<'tcx>,\n         temp_lifetime: Option<region::Scope>,\n         mut block: BasicBlock,\n-        arg: ExprRef<'tcx>,\n+        arg: &Expr<'_, 'tcx>,\n     ) -> BlockAnd<Operand<'tcx>> {\n         let this = self;\n \n@@ -398,7 +387,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // is same as that of the capture in the parent closure.\n             PlaceBase::Upvar { .. } => {\n                 let enclosing_upvars_resolved =\n-                    arg_place_builder.clone().into_place(this.hir.tcx(), this.hir.typeck_results());\n+                    arg_place_builder.clone().into_place(this.tcx, this.typeck_results);\n \n                 match enclosing_upvars_resolved.as_ref() {\n                     PlaceRef {\n@@ -435,13 +424,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             Mutability::Mut => BorrowKind::Mut { allow_two_phase_borrow: false },\n         };\n \n-        let arg_place = arg_place_builder.into_place(this.hir.tcx(), this.hir.typeck_results());\n+        let arg_place = arg_place_builder.into_place(this.tcx, this.typeck_results);\n \n         this.cfg.push_assign(\n             block,\n             source_info,\n             Place::from(temp),\n-            Rvalue::Ref(this.hir.tcx().lifetimes.re_erased, borrow_kind, arg_place),\n+            Rvalue::Ref(this.tcx.lifetimes.re_erased, borrow_kind, arg_place),\n         );\n \n         // See the comment in `expr_as_temp` and on the `rvalue_scopes` field for why\n@@ -456,9 +445,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     // Helper to get a `-1` value of the appropriate type\n     fn neg_1_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n         let param_ty = ty::ParamEnv::empty().and(ty);\n-        let bits = self.hir.tcx().layout_of(param_ty).unwrap().size.bits();\n+        let bits = self.tcx.layout_of(param_ty).unwrap().size.bits();\n         let n = (!0u128) >> (128 - bits);\n-        let literal = ty::Const::from_bits(self.hir.tcx(), n, param_ty);\n+        let literal = ty::Const::from_bits(self.tcx, n, param_ty);\n \n         self.literal_operand(span, literal)\n     }\n@@ -467,9 +456,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn minval_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n         assert!(ty.is_signed());\n         let param_ty = ty::ParamEnv::empty().and(ty);\n-        let bits = self.hir.tcx().layout_of(param_ty).unwrap().size.bits();\n+        let bits = self.tcx.layout_of(param_ty).unwrap().size.bits();\n         let n = 1 << (bits - 1);\n-        let literal = ty::Const::from_bits(self.hir.tcx(), n, param_ty);\n+        let literal = ty::Const::from_bits(self.tcx, n, param_ty);\n \n         self.literal_operand(span, literal)\n     }"}, {"sha": "98b910ab21c16d683d9f063580c87052e9d22a42", "filename": "compiler/rustc_mir_build/src/build/expr/as_temp.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs?ref=61365c06250e2ba6e0a578ae990f055ac5339107", "patch": "@@ -4,40 +4,34 @@ use crate::build::scope::DropKind;\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::thir::*;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_hir as hir;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr` into a fresh temporary. This is used when building\n     /// up rvalues so as to freeze the value that will be consumed.\n-    crate fn as_temp<M>(\n+    crate fn as_temp(\n         &mut self,\n         block: BasicBlock,\n         temp_lifetime: Option<region::Scope>,\n-        expr: M,\n+        expr: &Expr<'_, 'tcx>,\n         mutability: Mutability,\n-    ) -> BlockAnd<Local>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n-        let expr = self.hir.mirror(expr);\n-        //\n+    ) -> BlockAnd<Local> {\n         // this is the only place in mir building that we need to truly need to worry about\n         // infinite recursion. Everything else does recurse, too, but it always gets broken up\n         // at some point by inserting an intermediate temporary\n-        ensure_sufficient_stack(|| self.expr_as_temp(block, temp_lifetime, expr, mutability))\n+        ensure_sufficient_stack(|| self.as_temp_inner(block, temp_lifetime, expr, mutability))\n     }\n \n-    fn expr_as_temp(\n+    fn as_temp_inner(\n         &mut self,\n         mut block: BasicBlock,\n         temp_lifetime: Option<region::Scope>,\n-        expr: Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n         mutability: Mutability,\n     ) -> BlockAnd<Local> {\n         debug!(\n-            \"expr_as_temp(block={:?}, temp_lifetime={:?}, expr={:?}, mutability={:?})\",\n+            \"as_temp(block={:?}, temp_lifetime={:?}, expr={:?}, mutability={:?})\",\n             block, temp_lifetime, expr, mutability\n         );\n         let this = self;\n@@ -65,13 +59,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n             match expr.kind {\n                 ExprKind::StaticRef { def_id, .. } => {\n-                    assert!(!this.hir.tcx().is_thread_local_static(def_id));\n+                    assert!(!this.tcx.is_thread_local_static(def_id));\n                     local_decl.internal = true;\n                     local_decl.local_info =\n                         Some(box LocalInfo::StaticRef { def_id, is_thread_local: false });\n                 }\n                 ExprKind::ThreadLocalRef(def_id) => {\n-                    assert!(this.hir.tcx().is_thread_local_static(def_id));\n+                    assert!(this.tcx.is_thread_local_static(def_id));\n                     local_decl.internal = true;\n                     local_decl.local_info =\n                         Some(box LocalInfo::StaticRef { def_id, is_thread_local: true });\n@@ -89,7 +83,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // Don't bother with StorageLive and Dead for these temporaries,\n             // they are never assigned.\n             ExprKind::Break { .. } | ExprKind::Continue { .. } | ExprKind::Return { .. } => (),\n-            ExprKind::Block { body: hir::Block { expr: None, targeted_by_break: false, .. } }\n+            ExprKind::Block { body: Block { expr: None, targeted_by_break: false, .. } }\n                 if expr_ty.is_never() => {}\n             _ => {\n                 this.cfg\n@@ -114,7 +108,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n \n-        unpack!(block = this.into(temp_place, block, expr));\n+        unpack!(block = this.expr_into_dest(temp_place, block, expr));\n \n         if let Some(temp_lifetime) = temp_lifetime {\n             this.schedule_drop(expr_span, temp_lifetime, temp, DropKind::Value);"}, {"sha": "0cadfa2f0a1afd809ca253434b826d75d3235abf", "filename": "compiler/rustc_mir_build/src/build/expr/category.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs?ref=61365c06250e2ba6e0a578ae990f055ac5339107", "patch": "@@ -31,7 +31,7 @@ crate enum RvalueFunc {\n /// Determines the category for a given expression. Note that scope\n /// and paren expressions have no category.\n impl Category {\n-    crate fn of(ek: &ExprKind<'_>) -> Option<Category> {\n+    crate fn of(ek: &ExprKind<'_, '_>) -> Option<Category> {\n         match *ek {\n             ExprKind::Scope { .. } => None,\n "}, {"sha": "47f75825fb6af61dcc202effc3f940ae2ddd7be4", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 37, "deletions": 27, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=61365c06250e2ba6e0a578ae990f055ac5339107", "patch": "@@ -7,19 +7,20 @@ use rustc_ast::InlineAsmOptions;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir as hir;\n+use rustc_index::vec::Idx;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::CanonicalUserTypeAnnotation;\n+use rustc_middle::ty::{self, CanonicalUserTypeAnnotation};\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n     /// is assumed to be uninitialized.\n-    crate fn into_expr(\n+    crate fn expr_into_dest(\n         &mut self,\n         destination: Place<'tcx>,\n         mut block: BasicBlock,\n-        expr: Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n     ) -> BlockAnd<()> {\n-        debug!(\"into_expr(destination={:?}, block={:?}, expr={:?})\", destination, block, expr);\n+        debug!(\"expr_into_dest(destination={:?}, block={:?}, expr={:?})\", destination, block, expr);\n \n         // since we frequently have to reference `self` from within a\n         // closure, where `self` would be shadowed, it's easier to\n@@ -40,11 +41,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let region_scope = (region_scope, source_info);\n                 ensure_sufficient_stack(|| {\n                     this.in_scope(region_scope, lint_level, |this| {\n-                        this.into(destination, block, value)\n+                        this.expr_into_dest(destination, block, value)\n                     })\n                 })\n             }\n-            ExprKind::Block { body: ast_block } => {\n+            ExprKind::Block { body: ref ast_block } => {\n                 this.ast_block(destination, block, ast_block, source_info)\n             }\n             ExprKind::Match { scrutinee, arms } => {\n@@ -58,17 +59,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 let mut then_block = this.cfg.start_new_block();\n                 let mut else_block = this.cfg.start_new_block();\n-                let term = TerminatorKind::if_(this.hir.tcx(), operand, then_block, else_block);\n+                let term = TerminatorKind::if_(this.tcx, operand, then_block, else_block);\n                 this.cfg.terminate(block, source_info, term);\n \n-                unpack!(then_block = this.into(destination, then_block, then));\n+                unpack!(then_block = this.expr_into_dest(destination, then_block, then));\n                 else_block = if let Some(else_opt) = else_opt {\n-                    unpack!(this.into(destination, else_block, else_opt))\n+                    unpack!(this.expr_into_dest(destination, else_block, else_opt))\n                 } else {\n                     // Body of the `if` expression without an `else` clause must return `()`, thus\n                     // we implicitly generate a `else {}` if it is not specified.\n                     let correct_si = this.source_info(expr_span.shrink_to_hi());\n-                    this.cfg.push_assign_unit(else_block, correct_si, destination, this.hir.tcx());\n+                    this.cfg.push_assign_unit(else_block, correct_si, destination, this.tcx);\n                     else_block\n                 };\n \n@@ -87,7 +88,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 join_block.unit()\n             }\n             ExprKind::NeverToAny { source } => {\n-                let source = this.hir.mirror(source);\n                 let is_call =\n                     matches!(source.kind, ExprKind::Call { .. } | ExprKind::InlineAsm { .. });\n \n@@ -132,25 +132,33 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     LogicalOp::And => (else_block, false_block),\n                     LogicalOp::Or => (true_block, else_block),\n                 };\n-                let term = TerminatorKind::if_(this.hir.tcx(), lhs, blocks.0, blocks.1);\n+                let term = TerminatorKind::if_(this.tcx, lhs, blocks.0, blocks.1);\n                 this.cfg.terminate(block, source_info, term);\n \n                 let rhs = unpack!(else_block = this.as_local_operand(else_block, rhs));\n-                let term = TerminatorKind::if_(this.hir.tcx(), rhs, true_block, false_block);\n+                let term = TerminatorKind::if_(this.tcx, rhs, true_block, false_block);\n                 this.cfg.terminate(else_block, source_info, term);\n \n                 this.cfg.push_assign_constant(\n                     true_block,\n                     source_info,\n                     destination,\n-                    Constant { span: expr_span, user_ty: None, literal: this.hir.true_literal() },\n+                    Constant {\n+                        span: expr_span,\n+                        user_ty: None,\n+                        literal: ty::Const::from_bool(this.tcx, true),\n+                    },\n                 );\n \n                 this.cfg.push_assign_constant(\n                     false_block,\n                     source_info,\n                     destination,\n-                    Constant { span: expr_span, user_ty: None, literal: this.hir.false_literal() },\n+                    Constant {\n+                        span: expr_span,\n+                        user_ty: None,\n+                        literal: ty::Const::from_bool(this.tcx, false),\n+                    },\n                 );\n \n                 // Link up both branches:\n@@ -188,7 +196,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     // introduce a unit temporary as the destination for the loop body.\n                     let tmp = this.get_unit_temp();\n                     // Execute the body, branching back to the test.\n-                    let body_block_end = unpack!(this.into(tmp, body_block, body));\n+                    let body_block_end = unpack!(this.expr_into_dest(tmp, body_block, body));\n                     this.cfg.goto(body_block_end, source_info, loop_block);\n \n                     // Loops are only exited by `break` expressions.\n@@ -206,7 +214,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 this.record_operands_moved(&args);\n \n-                debug!(\"into_expr: fn_span={:?}\", fn_span);\n+                debug!(\"expr_into_dest: fn_span={:?}\", fn_span);\n \n                 this.cfg.terminate(\n                     block,\n@@ -230,7 +238,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 this.diverge_from(block);\n                 success.unit()\n             }\n-            ExprKind::Use { source } => this.into(destination, block, source),\n+            ExprKind::Use { source } => this.expr_into_dest(destination, block, source),\n             ExprKind::Borrow { arg, borrow_kind } => {\n                 // We don't do this in `as_rvalue` because we use `as_place`\n                 // for borrow expressions, so we cannot create an `RValue` that\n@@ -241,8 +249,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     BorrowKind::Shared => unpack!(block = this.as_read_only_place(block, arg)),\n                     _ => unpack!(block = this.as_place(block, arg)),\n                 };\n-                let borrow =\n-                    Rvalue::Ref(this.hir.tcx().lifetimes.re_erased, borrow_kind, arg_place);\n+                let borrow = Rvalue::Ref(this.tcx.lifetimes.re_erased, borrow_kind, arg_place);\n                 this.cfg.push_assign(block, source_info, destination, borrow);\n                 block.unit()\n             }\n@@ -255,7 +262,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 this.cfg.push_assign(block, source_info, destination, address_of);\n                 block.unit()\n             }\n-            ExprKind::Adt { adt_def, variant_index, substs, user_ty, fields, base } => {\n+            ExprKind::Adt { adt_def, variant_index, substs, user_ty, fields, ref base } => {\n                 // See the notes for `ExprKind::Array` in `as_rvalue` and for\n                 // `ExprKind::Borrow` above.\n                 let is_union = adt_def.is_union();\n@@ -270,7 +277,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     .map(|f| (f.name, unpack!(block = this.as_operand(block, Some(scope), f.expr))))\n                     .collect();\n \n-                let field_names = this.hir.all_fields(adt_def, variant_index);\n+                let field_names: Vec<_> =\n+                    (0..adt_def.variants[variant_index].fields.len()).map(Field::new).collect();\n \n                 let fields: Vec<_> = if let Some(FruInfo { base, field_types }) = base {\n                     let place_builder = unpack!(block = this.as_place_builder(block, base));\n@@ -288,7 +296,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                 this.consume_by_copy_or_move(\n                                     place_builder\n                                         .field(n, ty)\n-                                        .into_place(this.hir.tcx(), this.hir.typeck_results()),\n+                                        .into_place(this.tcx, this.typeck_results),\n                                 )\n                             }\n                         })\n@@ -325,7 +333,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 use rustc_middle::mir;\n                 let operands = operands\n                     .into_iter()\n-                    .map(|op| match op {\n+                    .map(|op| match *op {\n                         thir::InlineAsmOperand::In { reg, expr } => mir::InlineAsmOperand::In {\n                             reg,\n                             value: unpack!(block = this.as_local_operand(block, expr)),\n@@ -334,7 +342,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             mir::InlineAsmOperand::Out {\n                                 reg,\n                                 late,\n-                                place: expr.map(|expr| unpack!(block = this.as_place(block, expr))),\n+                                place: expr\n+                                    .as_ref()\n+                                    .map(|expr| unpack!(block = this.as_place(block, expr))),\n                             }\n                         }\n                         thir::InlineAsmOperand::InOut { reg, late, expr } => {\n@@ -352,7 +362,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                 reg,\n                                 late,\n                                 in_value: unpack!(block = this.as_local_operand(block, in_expr)),\n-                                out_place: out_expr.map(|out_expr| {\n+                                out_place: out_expr.as_ref().map(|out_expr| {\n                                     unpack!(block = this.as_place(block, out_expr))\n                                 }),\n                             }\n@@ -394,7 +404,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::AssignOp { .. }\n             | ExprKind::LlvmInlineAsm { .. } => {\n                 unpack!(block = this.stmt_expr(block, expr, None));\n-                this.cfg.push_assign_unit(block, source_info, destination, this.hir.tcx());\n+                this.cfg.push_assign_unit(block, source_info, destination, this.tcx);\n                 block.unit()\n             }\n "}, {"sha": "07338928eb8efa777ae72103a4f640f461d05848", "filename": "compiler/rustc_mir_build/src/build/expr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fmod.rs?ref=61365c06250e2ba6e0a578ae990f055ac5339107", "patch": "@@ -9,7 +9,7 @@\n //! a type that is not `Copy`, then using any of these functions will\n //! \"move\" the value out of its current home (if any).\n //!\n-//! - `into` -- writes the value into a specific location, which\n+//! - `expr_into_dest` -- writes the value into a specific location, which\n //!   should be uninitialized\n //! - `as_operand` -- evaluates the value and yields an `Operand`,\n //!   suitable for use as an argument to an `Rvalue`"}, {"sha": "f01315fc5db04fa05219b1403e5915320704c806", "filename": "compiler/rustc_mir_build/src/build/expr/stmt.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs?ref=61365c06250e2ba6e0a578ae990f055ac5339107", "patch": "@@ -13,37 +13,33 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn stmt_expr(\n         &mut self,\n         mut block: BasicBlock,\n-        expr: Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n         statement_scope: Option<region::Scope>,\n     ) -> BlockAnd<()> {\n         let this = self;\n         let expr_span = expr.span;\n         let source_info = this.source_info(expr.span);\n         // Handle a number of expressions that don't need a destination at all. This\n         // avoids needing a mountain of temporary `()` variables.\n-        let expr2 = expr.clone();\n         match expr.kind {\n             ExprKind::Scope { region_scope, lint_level, value } => {\n-                let value = this.hir.mirror(value);\n                 this.in_scope((region_scope, source_info), lint_level, |this| {\n                     this.stmt_expr(block, value, statement_scope)\n                 })\n             }\n             ExprKind::Assign { lhs, rhs } => {\n-                let lhs = this.hir.mirror(lhs);\n-                let rhs = this.hir.mirror(rhs);\n                 let lhs_span = lhs.span;\n \n                 // Note: we evaluate assignments right-to-left. This\n                 // is better for borrowck interaction with overloaded\n                 // operators like x[j] = x[i].\n \n-                debug!(\"stmt_expr Assign block_context.push(SubExpr) : {:?}\", expr2);\n+                debug!(\"stmt_expr Assign block_context.push(SubExpr) : {:?}\", expr);\n                 this.block_context.push(BlockFrame::SubExpr);\n \n                 // Generate better code for things that don't need to be\n                 // dropped.\n-                if this.hir.needs_drop(lhs.ty) {\n+                if lhs.ty.needs_drop(this.tcx, this.param_env) {\n                     let rhs = unpack!(block = this.as_local_operand(block, rhs));\n                     let lhs = unpack!(block = this.as_place(block, lhs));\n                     unpack!(block = this.build_drop_and_replace(block, lhs_span, lhs, rhs));\n@@ -65,10 +61,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // only affects weird things like `x += {x += 1; x}`\n                 // -- is that equal to `x + (x + 1)` or `2*(x+1)`?\n \n-                let lhs = this.hir.mirror(lhs);\n                 let lhs_ty = lhs.ty;\n \n-                debug!(\"stmt_expr AssignOp block_context.push(SubExpr) : {:?}\", expr2);\n+                debug!(\"stmt_expr AssignOp block_context.push(SubExpr) : {:?}\", expr);\n                 this.block_context.push(BlockFrame::SubExpr);\n \n                 // As above, RTL.\n@@ -90,24 +85,27 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             ExprKind::Continue { label } => {\n                 this.break_scope(block, None, BreakableTarget::Continue(label), source_info)\n             }\n-            ExprKind::Break { label, value } => {\n-                this.break_scope(block, value, BreakableTarget::Break(label), source_info)\n-            }\n+            ExprKind::Break { label, value } => this.break_scope(\n+                block,\n+                value.as_deref(),\n+                BreakableTarget::Break(label),\n+                source_info,\n+            ),\n             ExprKind::Return { value } => {\n-                this.break_scope(block, value, BreakableTarget::Return, source_info)\n+                this.break_scope(block, value.as_deref(), BreakableTarget::Return, source_info)\n             }\n             ExprKind::LlvmInlineAsm { asm, outputs, inputs } => {\n-                debug!(\"stmt_expr LlvmInlineAsm block_context.push(SubExpr) : {:?}\", expr2);\n+                debug!(\"stmt_expr LlvmInlineAsm block_context.push(SubExpr) : {:?}\", expr);\n                 this.block_context.push(BlockFrame::SubExpr);\n                 let outputs = outputs\n                     .into_iter()\n-                    .map(|output| unpack!(block = this.as_place(block, output)))\n+                    .map(|output| unpack!(block = this.as_place(block, &output)))\n                     .collect::<Vec<_>>()\n                     .into_boxed_slice();\n                 let inputs = inputs\n                     .into_iter()\n                     .map(|input| {\n-                        (input.span(), unpack!(block = this.as_local_operand(block, input)))\n+                        (input.span, unpack!(block = this.as_local_operand(block, &input)))\n                     })\n                     .collect::<Vec<_>>()\n                     .into_boxed_slice();\n@@ -140,15 +138,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // it is usually better to focus on `the_value` rather\n                 // than the entirety of block(s) surrounding it.\n                 let adjusted_span = (|| {\n-                    if let ExprKind::Block { body } = expr.kind {\n+                    if let ExprKind::Block { body } = &expr.kind {\n                         if let Some(tail_expr) = &body.expr {\n-                            let mut expr = tail_expr;\n-                            while let rustc_hir::ExprKind::Block(subblock, _label) = &expr.kind {\n-                                if let Some(subtail_expr) = &subblock.expr {\n-                                    expr = subtail_expr\n-                                } else {\n-                                    break;\n-                                }\n+                            let mut expr = &*tail_expr;\n+                            while let ExprKind::Block {\n+                                body: Block { expr: Some(nested_expr), .. },\n+                            }\n+                            | ExprKind::Scope { value: nested_expr, .. } = &expr.kind\n+                            {\n+                                expr = nested_expr;\n                             }\n                             this.block_context.push(BlockFrame::TailExpr {\n                                 tail_result_is_ignored: true,"}, {"sha": "7264e495b84fd0dc6026c67f156f4cb25c40a428", "filename": "compiler/rustc_mir_build/src/build/into.rs", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5c6d3bf3896b465e15550f49c2861e3d18102270/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6d3bf3896b465e15550f49c2861e3d18102270/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Finto.rs?ref=5c6d3bf3896b465e15550f49c2861e3d18102270", "patch": "@@ -1,55 +0,0 @@\n-//! In general, there are a number of things for which it's convenient\n-//! to just call `builder.into` and have it emit its result into a\n-//! given location. This is basically for expressions or things that can be\n-//! wrapped up as expressions (e.g., blocks). To make this ergonomic, we use this\n-//! latter `EvalInto` trait.\n-\n-use crate::build::{BlockAnd, Builder};\n-use crate::thir::*;\n-use rustc_middle::mir::*;\n-\n-pub(in crate::build) trait EvalInto<'tcx> {\n-    fn eval_into(\n-        self,\n-        builder: &mut Builder<'_, 'tcx>,\n-        destination: Place<'tcx>,\n-        block: BasicBlock,\n-    ) -> BlockAnd<()>;\n-}\n-\n-impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    crate fn into<E>(\n-        &mut self,\n-        destination: Place<'tcx>,\n-        block: BasicBlock,\n-        expr: E,\n-    ) -> BlockAnd<()>\n-    where\n-        E: EvalInto<'tcx>,\n-    {\n-        expr.eval_into(self, destination, block)\n-    }\n-}\n-\n-impl<'tcx> EvalInto<'tcx> for ExprRef<'tcx> {\n-    fn eval_into(\n-        self,\n-        builder: &mut Builder<'_, 'tcx>,\n-        destination: Place<'tcx>,\n-        block: BasicBlock,\n-    ) -> BlockAnd<()> {\n-        let expr = builder.hir.mirror(self);\n-        builder.into_expr(destination, block, expr)\n-    }\n-}\n-\n-impl<'tcx> EvalInto<'tcx> for Expr<'tcx> {\n-    fn eval_into(\n-        self,\n-        builder: &mut Builder<'_, 'tcx>,\n-        destination: Place<'tcx>,\n-        block: BasicBlock,\n-    ) -> BlockAnd<()> {\n-        builder.into_expr(destination, block, self)\n-    }\n-}"}, {"sha": "6c31528be73f7fb7f324de631336385a292d5027", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 28, "deletions": 31, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=61365c06250e2ba6e0a578ae990f055ac5339107", "patch": "@@ -89,10 +89,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         destination: Place<'tcx>,\n         span: Span,\n         mut block: BasicBlock,\n-        scrutinee: ExprRef<'tcx>,\n-        arms: Vec<Arm<'tcx>>,\n+        scrutinee: &Expr<'_, 'tcx>,\n+        arms: &[Arm<'_, 'tcx>],\n     ) -> BlockAnd<()> {\n-        let scrutinee_span = scrutinee.span();\n+        let scrutinee_span = scrutinee.span;\n         let scrutinee_place =\n             unpack!(block = self.lower_scrutinee(block, scrutinee, scrutinee_span,));\n \n@@ -119,7 +119,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn lower_scrutinee(\n         &mut self,\n         mut block: BasicBlock,\n-        scrutinee: ExprRef<'tcx>,\n+        scrutinee: &Expr<'_, 'tcx>,\n         scrutinee_span: Span,\n     ) -> BlockAnd<Place<'tcx>> {\n         let scrutinee_place = unpack!(block = self.as_place(block, scrutinee));\n@@ -149,8 +149,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn create_match_candidates<'pat>(\n         &mut self,\n         scrutinee: Place<'tcx>,\n-        arms: &'pat [Arm<'tcx>],\n-    ) -> Vec<(&'pat Arm<'tcx>, Candidate<'pat, 'tcx>)> {\n+        arms: &'pat [Arm<'pat, 'tcx>],\n+    ) -> Vec<(&'pat Arm<'pat, 'tcx>, Candidate<'pat, 'tcx>)> {\n         // Assemble a list of candidates: there is one candidate per pattern,\n         // which means there may be more than one candidate *per arm*.\n         arms.iter()\n@@ -224,7 +224,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         destination: Place<'tcx>,\n         scrutinee_place: Place<'tcx>,\n         scrutinee_span: Span,\n-        arm_candidates: Vec<(&'_ Arm<'tcx>, Candidate<'_, 'tcx>)>,\n+        arm_candidates: Vec<(&'_ Arm<'_, 'tcx>, Candidate<'_, 'tcx>)>,\n         outer_source_info: SourceInfo,\n         fake_borrow_temps: Vec<(Place<'tcx>, Local)>,\n     ) -> BlockAnd<()> {\n@@ -236,7 +236,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let arm_source_info = self.source_info(arm.span);\n                 let arm_scope = (arm.scope, arm_source_info);\n                 self.in_scope(arm_scope, arm.lint_level, |this| {\n-                    let body = this.hir.mirror(arm.body.clone());\n                     let scope = this.declare_bindings(\n                         None,\n                         arm.span,\n@@ -259,7 +258,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         this.source_scope = source_scope;\n                     }\n \n-                    this.into(destination, arm_block, body)\n+                    this.expr_into_dest(destination, arm_block, &arm.body)\n                 })\n             })\n             .collect();\n@@ -286,7 +285,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         outer_source_info: SourceInfo,\n         candidate: Candidate<'_, 'tcx>,\n-        guard: Option<&Guard<'tcx>>,\n+        guard: Option<&Guard<'_, 'tcx>>,\n         fake_borrow_temps: &Vec<(Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n         arm_span: Option<Span>,\n@@ -362,14 +361,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         mut block: BasicBlock,\n         irrefutable_pat: Pat<'tcx>,\n-        initializer: ExprRef<'tcx>,\n+        initializer: &Expr<'_, 'tcx>,\n     ) -> BlockAnd<()> {\n         match *irrefutable_pat.kind {\n             // Optimize the case of `let x = ...` to write directly into `x`\n             PatKind::Binding { mode: BindingMode::ByValue, var, subpattern: None, .. } => {\n                 let place =\n                     self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard, true);\n-                unpack!(block = self.into(place, block, initializer));\n+                unpack!(block = self.expr_into_dest(place, block, initializer));\n \n                 // Inject a fake read, see comments on `FakeReadCause::ForLet`.\n                 let source_info = self.source_info(irrefutable_pat.span);\n@@ -404,7 +403,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             } => {\n                 let place =\n                     self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard, true);\n-                unpack!(block = self.into(place, block, initializer));\n+                unpack!(block = self.expr_into_dest(place, block, initializer));\n \n                 // Inject a fake read, see comments on `FakeReadCause::ForLet`.\n                 let pattern_source_info = self.source_info(irrefutable_pat.span);\n@@ -414,7 +413,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let ty_source_info = self.source_info(user_ty_span);\n                 let user_ty = pat_ascription_ty.user_ty(\n                     &mut self.canonical_user_type_annotations,\n-                    place.ty(&self.local_decls, self.hir.tcx()).ty,\n+                    place.ty(&self.local_decls, self.tcx).ty,\n                     ty_source_info.span,\n                 );\n                 self.cfg.push(\n@@ -556,7 +555,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let local_id = self.var_local_id(var, for_guard);\n         let source_info = self.source_info(span);\n         self.cfg.push(block, Statement { source_info, kind: StatementKind::StorageLive(local_id) });\n-        let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n+        let region_scope = self.region_scope_tree.var_scope(var.local_id);\n         if schedule_drop {\n             self.schedule_drop(span, region_scope, local_id, DropKind::Storage);\n         }\n@@ -565,7 +564,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     crate fn schedule_drop_for_binding(&mut self, var: HirId, span: Span, for_guard: ForGuard) {\n         let local_id = self.var_local_id(var, for_guard);\n-        let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n+        let region_scope = self.region_scope_tree.var_scope(var.local_id);\n         self.schedule_drop(span, region_scope, local_id, DropKind::Value);\n     }\n \n@@ -1071,7 +1070,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                     fake_borrows.insert(Place {\n                         local: source.local,\n-                        projection: self.hir.tcx().intern_place_elems(proj_base),\n+                        projection: self.tcx.intern_place_elems(proj_base),\n                     });\n                 }\n             }\n@@ -1550,7 +1549,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         fake_borrows: &'b FxHashSet<Place<'tcx>>,\n         temp_span: Span,\n     ) -> Vec<(Place<'tcx>, Local)> {\n-        let tcx = self.hir.tcx();\n+        let tcx = self.tcx;\n \n         debug!(\"add_fake_borrows fake_borrows = {:?}\", fake_borrows);\n \n@@ -1613,7 +1612,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         candidate: Candidate<'pat, 'tcx>,\n         parent_bindings: &[(Vec<Binding<'tcx>>, Vec<Ascription<'tcx>>)],\n-        guard: Option<&Guard<'tcx>>,\n+        guard: Option<&Guard<'_, 'tcx>>,\n         fake_borrows: &Vec<(Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n         arm_span: Option<Span>,\n@@ -1727,7 +1726,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         //    * So we eagerly create the reference for the arm and then take a\n         //      reference to that.\n         if let Some(guard) = guard {\n-            let tcx = self.hir.tcx();\n+            let tcx = self.tcx;\n             let bindings = parent_bindings\n                 .iter()\n                 .flat_map(|(bindings, _)| bindings)\n@@ -1749,15 +1748,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             let (guard_span, (post_guard_block, otherwise_post_guard_block)) = match guard {\n                 Guard::If(e) => {\n-                    let e = self.hir.mirror(e.clone());\n                     let source_info = self.source_info(e.span);\n                     (e.span, self.test_bool(block, e, source_info))\n                 }\n                 Guard::IfLet(pat, scrutinee) => {\n-                    let scrutinee_span = scrutinee.span();\n-                    let scrutinee_place = unpack!(\n-                        block = self.lower_scrutinee(block, scrutinee.clone(), scrutinee_span)\n-                    );\n+                    let scrutinee_span = scrutinee.span;\n+                    let scrutinee_place =\n+                        unpack!(block = self.lower_scrutinee(block, scrutinee, scrutinee_span));\n                     let mut guard_candidate = Candidate::new(scrutinee_place, &pat, false);\n                     let wildcard = Pat::wildcard_from_ty(pat.ty);\n                     let mut otherwise_candidate = Candidate::new(scrutinee_place, &wildcard, false);\n@@ -1772,14 +1769,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         pat.span.to(arm_span.unwrap()),\n                         pat,\n                         ArmHasGuard(false),\n-                        Some((Some(&scrutinee_place), scrutinee.span())),\n+                        Some((Some(&scrutinee_place), scrutinee.span)),\n                     );\n                     let post_guard_block = self.bind_pattern(\n                         self.source_info(pat.span),\n                         guard_candidate,\n                         None,\n                         &fake_borrow_temps,\n-                        scrutinee.span(),\n+                        scrutinee.span,\n                         None,\n                         None,\n                     );\n@@ -1888,7 +1885,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             let user_ty = ascription.user_ty.clone().user_ty(\n                 &mut self.canonical_user_type_annotations,\n-                ascription.source.ty(&self.local_decls, self.hir.tcx()).ty,\n+                ascription.source.ty(&self.local_decls, self.tcx).ty,\n                 source_info.span,\n             );\n             self.cfg.push(\n@@ -1917,7 +1914,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // Assign each of the bindings. Since we are binding for a\n         // guard expression, this will never trigger moves out of the\n         // candidate.\n-        let re_erased = self.hir.tcx().lifetimes.re_erased;\n+        let re_erased = self.tcx.lifetimes.re_erased;\n         for binding in bindings {\n             debug!(\"bind_matched_candidate_for_guard(binding={:?})\", binding);\n             let source_info = self.source_info(binding.span);\n@@ -1966,7 +1963,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     {\n         debug!(\"bind_matched_candidate_for_arm_body(block={:?})\", block);\n \n-        let re_erased = self.hir.tcx().lifetimes.re_erased;\n+        let re_erased = self.tcx.lifetimes.re_erased;\n         // Assign each of the bindings. This may trigger moves out of the candidate.\n         for binding in bindings {\n             let source_info = self.source_info(binding.span);\n@@ -2015,7 +2012,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             var_id, name, mode, var_ty, visibility_scope, source_info\n         );\n \n-        let tcx = self.hir.tcx();\n+        let tcx = self.tcx;\n         let debug_source_info = SourceInfo { span: source_info.span, scope: visibility_scope };\n         let binding_mode = match mode {\n             BindingMode::ByValue => ty::BindingMode::BindByValue(mutability),"}, {"sha": "9931cdf3b9e9113049ddbcb3633efeb638a16968", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=61365c06250e2ba6e0a578ae990f055ac5339107", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         match_pair: MatchPair<'pat, 'tcx>,\n         candidate: &mut Candidate<'pat, 'tcx>,\n     ) -> Result<(), MatchPair<'pat, 'tcx>> {\n-        let tcx = self.hir.tcx();\n+        let tcx = self.tcx;\n         match *match_pair.pattern.kind {\n             PatKind::AscribeUserType {\n                 ref subpattern,\n@@ -251,13 +251,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             PatKind::Variant { adt_def, substs, variant_index, ref subpatterns } => {\n                 let irrefutable = adt_def.variants.iter_enumerated().all(|(i, v)| {\n                     i == variant_index || {\n-                        self.hir.tcx().features().exhaustive_patterns\n+                        self.tcx.features().exhaustive_patterns\n                             && !v\n                                 .uninhabited_from(\n-                                    self.hir.tcx(),\n+                                    self.tcx,\n                                     substs,\n                                     adt_def.adt_kind(),\n-                                    self.hir.param_env,\n+                                    self.param_env,\n                                 )\n                                 .is_empty()\n                     }"}, {"sha": "48abaa8d35f82b5cd9d62a6a9e56d99b5b302ff7", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 47, "deletions": 28, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=61365c06250e2ba6e0a578ae990f055ac5339107", "patch": "@@ -13,9 +13,11 @@ use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir::{LangItem, RangeEnd};\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::*;\n+use rustc_middle::ty::subst::{GenericArg, Subst};\n use rustc_middle::ty::util::IntTypeExt;\n-use rustc_middle::ty::{self, adjustment::PointerCast, Ty};\n-use rustc_span::symbol::sym;\n+use rustc_middle::ty::{self, adjustment::PointerCast, Ty, TyCtxt};\n+use rustc_span::def_id::DefId;\n+use rustc_span::symbol::{sym, Symbol};\n use rustc_target::abi::VariantIdx;\n \n use std::cmp::Ordering;\n@@ -93,9 +95,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         match *match_pair.pattern.kind {\n             PatKind::Constant { value } => {\n-                options.entry(value).or_insert_with(|| {\n-                    value.eval_bits(self.hir.tcx(), self.hir.param_env, switch_ty)\n-                });\n+                options\n+                    .entry(value)\n+                    .or_insert_with(|| value.eval_bits(self.tcx, self.param_env, switch_ty));\n                 true\n             }\n             PatKind::Variant { .. } => {\n@@ -157,7 +159,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             \"perform_test({:?}, {:?}: {:?}, {:?})\",\n             block,\n             place,\n-            place.ty(&self.local_decls, self.hir.tcx()),\n+            place.ty(&self.local_decls, self.tcx),\n             test\n         );\n \n@@ -169,7 +171,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let num_enum_variants = adt_def.variants.len();\n                 debug_assert_eq!(target_blocks.len(), num_enum_variants + 1);\n                 let otherwise_block = *target_blocks.last().unwrap();\n-                let tcx = self.hir.tcx();\n+                let tcx = self.tcx;\n                 let switch_targets = SwitchTargets::new(\n                     adt_def.discriminants(tcx).filter_map(|(idx, discr)| {\n                         if variants.contains(idx) {\n@@ -217,7 +219,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             0 => (second_bb, first_bb),\n                             v => span_bug!(test.span, \"expected boolean value but got {:?}\", v),\n                         };\n-                        TerminatorKind::if_(self.hir.tcx(), Operand::Copy(place), true_bb, false_bb)\n+                        TerminatorKind::if_(self.tcx, Operand::Copy(place), true_bb, false_bb)\n                     } else {\n                         bug!(\"`TestKind::SwitchInt` on `bool` should have two targets\")\n                     }\n@@ -292,7 +294,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             TestKind::Len { len, op } => {\n                 let target_blocks = make_target_blocks(self);\n \n-                let usize_ty = self.hir.usize_ty();\n+                let usize_ty = self.tcx.types.usize;\n                 let actual = self.temp(usize_ty, test.span);\n \n                 // actual = len(place)\n@@ -331,7 +333,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         left: Operand<'tcx>,\n         right: Operand<'tcx>,\n     ) {\n-        let bool_ty = self.hir.bool_ty();\n+        let bool_ty = self.tcx.types.bool;\n         let result = self.temp(bool_ty, source_info.span);\n \n         // result = op(left, right)\n@@ -341,7 +343,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.cfg.terminate(\n             block,\n             source_info,\n-            TerminatorKind::if_(self.hir.tcx(), Operand::Move(result), success_block, fail_block),\n+            TerminatorKind::if_(self.tcx, Operand::Move(result), success_block, fail_block),\n         );\n     }\n \n@@ -377,7 +379,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // nothing to do, neither is an array\n             (None, None) => {}\n             (Some((region, elem_ty, _)), _) | (None, Some((region, elem_ty, _))) => {\n-                let tcx = self.hir.tcx();\n+                let tcx = self.tcx;\n                 // make both a slice\n                 ty = tcx.mk_imm_ref(region, tcx.mk_slice(elem_ty));\n                 if opt_ref_ty.is_some() {\n@@ -408,10 +410,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             _ => bug!(\"non_scalar_compare called on non-reference type: {}\", ty),\n         };\n \n-        let eq_def_id = self.hir.tcx().require_lang_item(LangItem::PartialEq, None);\n-        let method = self.hir.trait_method(eq_def_id, sym::eq, deref_ty, &[deref_ty.into()]);\n+        let eq_def_id = self.tcx.require_lang_item(LangItem::PartialEq, None);\n+        let method = trait_method(self.tcx, eq_def_id, sym::eq, deref_ty, &[deref_ty.into()]);\n \n-        let bool_ty = self.hir.bool_ty();\n+        let bool_ty = self.tcx.types.bool;\n         let eq_result = self.temp(bool_ty, source_info.span);\n         let eq_block = self.cfg.start_new_block();\n         self.cfg.terminate(\n@@ -443,12 +445,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.cfg.terminate(\n                 eq_block,\n                 source_info,\n-                TerminatorKind::if_(\n-                    self.hir.tcx(),\n-                    Operand::Move(eq_result),\n-                    success_block,\n-                    fail_block,\n-                ),\n+                TerminatorKind::if_(self.tcx, Operand::Move(eq_result), success_block, fail_block),\n             );\n         } else {\n             bug!(\"`TestKind::Eq` should have two target blocks\")\n@@ -632,11 +629,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     use rustc_hir::RangeEnd::*;\n                     use std::cmp::Ordering::*;\n \n-                    let tcx = self.hir.tcx();\n+                    let tcx = self.tcx;\n \n                     let test_ty = test.lo.ty;\n-                    let lo = compare_const_vals(tcx, test.lo, pat.hi, self.hir.param_env, test_ty)?;\n-                    let hi = compare_const_vals(tcx, test.hi, pat.lo, self.hir.param_env, test_ty)?;\n+                    let lo = compare_const_vals(tcx, test.lo, pat.hi, self.param_env, test_ty)?;\n+                    let hi = compare_const_vals(tcx, test.hi, pat.lo, self.param_env, test_ty)?;\n \n                     match (test.end, pat.end, lo, hi) {\n                         // pat < test\n@@ -731,7 +728,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         candidate: &mut Candidate<'pat, 'tcx>,\n     ) {\n         let match_pair = candidate.match_pairs.remove(match_pair_index);\n-        let tcx = self.hir.tcx();\n+        let tcx = self.tcx;\n \n         // So, if we have a match-pattern like `x @ Enum::Variant(P1, P2)`,\n         // we want to create a set of derived match-patterns like\n@@ -762,10 +759,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) -> Option<bool> {\n         use std::cmp::Ordering::*;\n \n-        let tcx = self.hir.tcx();\n+        let tcx = self.tcx;\n \n-        let a = compare_const_vals(tcx, range.lo, value, self.hir.param_env, range.lo.ty)?;\n-        let b = compare_const_vals(tcx, value, range.hi, self.hir.param_env, range.lo.ty)?;\n+        let a = compare_const_vals(tcx, range.lo, value, self.param_env, range.lo.ty)?;\n+        let b = compare_const_vals(tcx, value, range.hi, self.param_env, range.lo.ty)?;\n \n         match (b, range.end) {\n             (Less, _) | (Equal, RangeEnd::Included) if a != Greater => Some(true),\n@@ -815,3 +812,25 @@ impl Test<'_> {\n fn is_switch_ty(ty: Ty<'_>) -> bool {\n     ty.is_integral() || ty.is_char() || ty.is_bool()\n }\n+\n+fn trait_method<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_def_id: DefId,\n+    method_name: Symbol,\n+    self_ty: Ty<'tcx>,\n+    params: &[GenericArg<'tcx>],\n+) -> &'tcx ty::Const<'tcx> {\n+    let substs = tcx.mk_substs_trait(self_ty, params);\n+\n+    // The unhygienic comparison here is acceptable because this is only\n+    // used on known traits.\n+    let item = tcx\n+        .associated_items(trait_def_id)\n+        .filter_by_name_unhygienic(method_name)\n+        .find(|item| item.kind == ty::AssocKind::Fn)\n+        .expect(\"trait method not found\");\n+\n+    let method_ty = tcx.type_of(item.def_id);\n+    let method_ty = method_ty.subst(tcx, substs);\n+    ty::Const::zero_sized(tcx, method_ty)\n+}"}, {"sha": "15aca0203aa0117e8efc69a465c17a36788b8275", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=61365c06250e2ba6e0a578ae990f055ac5339107", "patch": "@@ -15,8 +15,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         subpatterns\n             .iter()\n             .map(|fieldpat| {\n-                let place =\n-                    self.hir.tcx().mk_place_field(place, fieldpat.field, fieldpat.pattern.ty);\n+                let place = self.tcx.mk_place_field(place, fieldpat.field, fieldpat.pattern.ty);\n                 MatchPair::new(place, &fieldpat.pattern)\n             })\n             .collect()\n@@ -30,9 +29,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         opt_slice: Option<&'pat Pat<'tcx>>,\n         suffix: &'pat [Pat<'tcx>],\n     ) {\n-        let tcx = self.hir.tcx();\n+        let tcx = self.tcx;\n         let (min_length, exact_size) = match place.ty(&self.local_decls, tcx).ty.kind() {\n-            ty::Array(_, length) => (length.eval_usize(tcx, self.hir.param_env), true),\n+            ty::Array(_, length) => (length.eval_usize(tcx, self.param_env), true),\n             _ => ((prefix.len() + suffix.len()).try_into().unwrap(), false),\n         };\n "}, {"sha": "62c217a12aaad1c6cad879f23298aaa09b2f16c1", "filename": "compiler/rustc_mir_build/src/build/misc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs?ref=61365c06250e2ba6e0a578ae990f055ac5339107", "patch": "@@ -3,10 +3,10 @@\n \n use crate::build::Builder;\n \n-use rustc_middle::ty::{self, Ty};\n-\n use rustc_middle::mir::*;\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::{Span, DUMMY_SP};\n+use rustc_trait_selection::infer::InferCtxtExt;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Adds a new temporary value of type `ty` storing the result of\n@@ -37,7 +37,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     // Returns a zero literal operand for the appropriate type, works for\n     // bool, char and integers.\n     crate fn zero_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n-        let literal = ty::Const::from_bits(self.hir.tcx(), 0, ty::ParamEnv::empty().and(ty));\n+        let literal = ty::Const::from_bits(self.tcx, 0, ty::ParamEnv::empty().and(ty));\n \n         self.literal_operand(span, literal)\n     }\n@@ -48,7 +48,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         source_info: SourceInfo,\n         value: u64,\n     ) -> Place<'tcx> {\n-        let usize_ty = self.hir.usize_ty();\n+        let usize_ty = self.tcx.types.usize;\n         let temp = self.temp(usize_ty, source_info.span);\n         self.cfg.push_assign_constant(\n             block,\n@@ -57,16 +57,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             Constant {\n                 span: source_info.span,\n                 user_ty: None,\n-                literal: self.hir.usize_literal(value),\n+                literal: ty::Const::from_usize(self.tcx, value),\n             },\n         );\n         temp\n     }\n \n     crate fn consume_by_copy_or_move(&self, place: Place<'tcx>) -> Operand<'tcx> {\n-        let tcx = self.hir.tcx();\n+        let tcx = self.tcx;\n         let ty = place.ty(&self.local_decls, tcx).ty;\n-        if !self.hir.type_is_copy_modulo_regions(ty, DUMMY_SP) {\n+        if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, DUMMY_SP) {\n             Operand::Move(place)\n         } else {\n             Operand::Copy(place)"}, {"sha": "b633fe32674be54978728d4a8f7922a169cecdbd", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 105, "deletions": 73, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=61365c06250e2ba6e0a578ae990f055ac5339107", "patch": "@@ -1,21 +1,21 @@\n use crate::build;\n use crate::build::scope::DropKind;\n-use crate::thir::cx::Cx;\n-use crate::thir::{BindingMode, LintLevel, PatKind};\n+use crate::thir::cx::build_thir;\n+use crate::thir::{Arena, BindingMode, Expr, LintLevel, Pat, PatKind};\n use rustc_attr::{self as attr, UnwindAttr};\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{GeneratorKind, HirIdMap, Node};\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::Subst;\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc_span::symbol::kw;\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeckResults};\n+use rustc_span::symbol::{kw, sym};\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n use rustc_target::spec::PanicStrategy;\n@@ -42,6 +42,8 @@ crate fn mir_built<'tcx>(\n /// Construct the MIR for a given `DefId`.\n fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_> {\n     let id = tcx.hir().local_def_id_to_hir_id(def.did);\n+    let body_owner_kind = tcx.hir().body_owner_kind(id);\n+    let typeck_results = tcx.typeck_opt_const_arg(def);\n \n     // Figure out what primary body this item has.\n     let (body_id, return_ty_span, span_with_body) = match tcx.hir().get(id) {\n@@ -86,15 +88,15 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n     // If we don't have a specialized span for the body, just use the\n     // normal def span.\n     let span_with_body = span_with_body.unwrap_or_else(|| tcx.hir().span(id));\n+    let arena = Arena::default();\n \n     tcx.infer_ctxt().enter(|infcx| {\n-        let cx = Cx::new(&infcx, def, id);\n-        let body = if let Some(ErrorReported) = cx.typeck_results().tainted_by_errors {\n-            build::construct_error(cx, body_id)\n-        } else if cx.body_owner_kind.is_fn_or_closure() {\n+        let body = if let Some(ErrorReported) = typeck_results.tainted_by_errors {\n+            build::construct_error(&infcx, def, id, body_id, body_owner_kind)\n+        } else if body_owner_kind.is_fn_or_closure() {\n             // fetch the fully liberated fn signature (that is, all bound\n             // types/lifetimes replaced)\n-            let fn_sig = cx.typeck_results().liberated_fn_sigs()[id];\n+            let fn_sig = typeck_results.liberated_fn_sigs()[id];\n             let fn_def_id = tcx.hir().local_def_id(id);\n \n             let safety = match fn_sig.unsafety {\n@@ -103,6 +105,7 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n             };\n \n             let body = tcx.hir().body(body_id);\n+            let thir = build_thir(tcx, def, &arena, &body.value);\n             let ty = tcx.type_of(fn_def_id);\n             let mut abi = fn_sig.abi;\n             let implicit_argument = match ty.kind() {\n@@ -178,14 +181,16 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n             };\n \n             let mut mir = build::construct_fn(\n-                cx,\n+                &infcx,\n+                def,\n                 id,\n                 arguments,\n                 safety,\n                 abi,\n                 return_ty,\n                 return_ty_span,\n                 body,\n+                thir,\n                 span_with_body,\n             );\n             if yield_ty.is_some() {\n@@ -205,9 +210,12 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n             // place to be the type of the constant because NLL typeck will\n             // equate them.\n \n-            let return_ty = cx.typeck_results().node_type(id);\n+            let return_ty = typeck_results.node_type(id);\n \n-            build::construct_const(cx, body_id, return_ty, return_ty_span)\n+            let ast_expr = &tcx.hir().body(body_id).value;\n+            let thir = build_thir(tcx, def, &arena, ast_expr);\n+\n+            build::construct_const(&infcx, thir, def, id, return_ty, return_ty_span)\n         };\n \n         lints::check(tcx, &body);\n@@ -304,10 +312,17 @@ impl BlockFrame {\n struct BlockContext(Vec<BlockFrame>);\n \n struct Builder<'a, 'tcx> {\n-    hir: Cx<'a, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    typeck_results: &'tcx TypeckResults<'tcx>,\n+    region_scope_tree: &'tcx region::ScopeTree,\n+    param_env: ty::ParamEnv<'tcx>,\n+\n     cfg: CFG<'tcx>,\n \n     def_id: DefId,\n+    hir_id: hir::HirId,\n+    check_overflow: bool,\n     fn_span: Span,\n     arg_count: usize,\n     generator_kind: Option<GeneratorKind>,\n@@ -607,31 +622,31 @@ struct ArgInfo<'tcx>(\n     Option<ImplicitSelfKind>,\n );\n \n-fn construct_fn<'a, 'tcx, A>(\n-    hir: Cx<'a, 'tcx>,\n+fn construct_fn<'tcx, A>(\n+    infcx: &InferCtxt<'_, 'tcx>,\n+    fn_def: ty::WithOptConstParam<LocalDefId>,\n     fn_id: hir::HirId,\n     arguments: A,\n     safety: Safety,\n     abi: Abi,\n     return_ty: Ty<'tcx>,\n     return_ty_span: Span,\n     body: &'tcx hir::Body<'tcx>,\n+    expr: &Expr<'_, 'tcx>,\n     span_with_body: Span,\n ) -> Body<'tcx>\n where\n     A: Iterator<Item = ArgInfo<'tcx>>,\n {\n     let arguments: Vec<_> = arguments.collect();\n \n-    let tcx = hir.tcx();\n-    let tcx_hir = tcx.hir();\n-    let span = tcx_hir.span(fn_id);\n-\n-    let fn_def_id = tcx_hir.local_def_id(fn_id);\n+    let tcx = infcx.tcx;\n+    let span = tcx.hir().span(fn_id);\n \n     let mut builder = Builder::new(\n-        hir,\n-        fn_def_id.to_def_id(),\n+        infcx,\n+        fn_def,\n+        fn_id,\n         span_with_body,\n         arguments.len(),\n         safety,\n@@ -655,16 +670,16 @@ where\n                 Some(builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n                     builder.args_and_body(\n                         START_BLOCK,\n-                        fn_def_id.to_def_id(),\n+                        fn_def.did.to_def_id(),\n                         &arguments,\n                         arg_scope,\n-                        &body.value,\n+                        expr,\n                     )\n                 }))\n             }));\n         let source_info = builder.source_info(fn_end);\n         builder.cfg.terminate(return_block, source_info, TerminatorKind::Return);\n-        let should_abort = should_abort_on_panic(tcx, fn_def_id, abi);\n+        let should_abort = should_abort_on_panic(tcx, fn_def.did, abi);\n         builder.build_drop_trees(should_abort);\n         return_block.unit()\n     }));\n@@ -675,30 +690,28 @@ where\n     } else {\n         None\n     };\n-    debug!(\"fn_id {:?} has attrs {:?}\", fn_def_id, tcx.get_attrs(fn_def_id.to_def_id()));\n+    debug!(\"fn_id {:?} has attrs {:?}\", fn_def, tcx.get_attrs(fn_def.did.to_def_id()));\n \n     let mut body = builder.finish();\n     body.spread_arg = spread_arg;\n     body\n }\n \n fn construct_const<'a, 'tcx>(\n-    hir: Cx<'a, 'tcx>,\n-    body_id: hir::BodyId,\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    expr: &Expr<'_, 'tcx>,\n+    def: ty::WithOptConstParam<LocalDefId>,\n+    hir_id: hir::HirId,\n     const_ty: Ty<'tcx>,\n     const_ty_span: Span,\n ) -> Body<'tcx> {\n-    let tcx = hir.tcx();\n-    let owner_id = tcx.hir().body_owner(body_id);\n-    let def_id = tcx.hir().local_def_id(owner_id);\n-    let span = tcx.hir().span(owner_id);\n+    let tcx = infcx.tcx;\n+    let span = tcx.hir().span(hir_id);\n     let mut builder =\n-        Builder::new(hir, def_id.to_def_id(), span, 0, Safety::Safe, const_ty, const_ty_span, None);\n+        Builder::new(infcx, def, hir_id, span, 0, Safety::Safe, const_ty, const_ty_span, None);\n \n     let mut block = START_BLOCK;\n-    let ast_expr = &tcx.hir().body(body_id).value;\n-    let expr = builder.hir.mirror(ast_expr);\n-    unpack!(block = builder.into_expr(Place::return_place(), block, expr));\n+    unpack!(block = builder.expr_into_dest(Place::return_place(), block, &expr));\n \n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(block, source_info, TerminatorKind::Return);\n@@ -712,38 +725,34 @@ fn construct_const<'a, 'tcx>(\n ///\n /// This is required because we may still want to run MIR passes on an item\n /// with type errors, but normal MIR construction can't handle that in general.\n-fn construct_error<'a, 'tcx>(hir: Cx<'a, 'tcx>, body_id: hir::BodyId) -> Body<'tcx> {\n-    let tcx = hir.tcx();\n-    let owner_id = tcx.hir().body_owner(body_id);\n-    let def_id = tcx.hir().local_def_id(owner_id);\n-    let span = tcx.hir().span(owner_id);\n+fn construct_error<'a, 'tcx>(\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    def: ty::WithOptConstParam<LocalDefId>,\n+    hir_id: hir::HirId,\n+    body_id: hir::BodyId,\n+    body_owner_kind: hir::BodyOwnerKind,\n+) -> Body<'tcx> {\n+    let tcx = infcx.tcx;\n+    let span = tcx.hir().span(hir_id);\n     let ty = tcx.ty_error();\n     let generator_kind = tcx.hir().body(body_id).generator_kind;\n-    let num_params = match hir.body_owner_kind {\n-        hir::BodyOwnerKind::Fn => tcx.hir().fn_decl_by_hir_id(owner_id).unwrap().inputs.len(),\n+    let num_params = match body_owner_kind {\n+        hir::BodyOwnerKind::Fn => tcx.hir().fn_decl_by_hir_id(hir_id).unwrap().inputs.len(),\n         hir::BodyOwnerKind::Closure => {\n             if generator_kind.is_some() {\n                 // Generators have an implicit `self` parameter *and* a possibly\n                 // implicit resume parameter.\n                 2\n             } else {\n                 // The implicit self parameter adds another local in MIR.\n-                1 + tcx.hir().fn_decl_by_hir_id(owner_id).unwrap().inputs.len()\n+                1 + tcx.hir().fn_decl_by_hir_id(hir_id).unwrap().inputs.len()\n             }\n         }\n         hir::BodyOwnerKind::Const => 0,\n         hir::BodyOwnerKind::Static(_) => 0,\n     };\n-    let mut builder = Builder::new(\n-        hir,\n-        def_id.to_def_id(),\n-        span,\n-        num_params,\n-        Safety::Safe,\n-        ty,\n-        span,\n-        generator_kind,\n-    );\n+    let mut builder =\n+        Builder::new(infcx, def, hir_id, span, num_params, Safety::Safe, ty, span, generator_kind);\n     let source_info = builder.source_info(span);\n     // Some MIR passes will expect the number of parameters to match the\n     // function declaration.\n@@ -758,19 +767,40 @@ fn construct_error<'a, 'tcx>(hir: Cx<'a, 'tcx>, body_id: hir::BodyId) -> Body<'t\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn new(\n-        hir: Cx<'a, 'tcx>,\n-        def_id: DefId,\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n+        def: ty::WithOptConstParam<LocalDefId>,\n+        hir_id: hir::HirId,\n         span: Span,\n         arg_count: usize,\n         safety: Safety,\n         return_ty: Ty<'tcx>,\n         return_span: Span,\n         generator_kind: Option<GeneratorKind>,\n     ) -> Builder<'a, 'tcx> {\n-        let lint_level = LintLevel::Explicit(hir.root_lint_level);\n+        let tcx = infcx.tcx;\n+        let attrs = tcx.hir().attrs(hir_id);\n+        // Some functions always have overflow checks enabled,\n+        // however, they may not get codegen'd, depending on\n+        // the settings for the crate they are codegened in.\n+        let mut check_overflow = tcx.sess.contains_name(attrs, sym::rustc_inherit_overflow_checks);\n+        // Respect -C overflow-checks.\n+        check_overflow |= tcx.sess.overflow_checks();\n+        // Constants always need overflow checks.\n+        check_overflow |= matches!(\n+            tcx.hir().body_owner_kind(hir_id),\n+            hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_)\n+        );\n+\n+        let lint_level = LintLevel::Explicit(hir_id);\n         let mut builder = Builder {\n-            hir,\n-            def_id,\n+            tcx,\n+            infcx,\n+            typeck_results: tcx.typeck_opt_const_arg(def),\n+            region_scope_tree: tcx.region_scope_tree(def.did),\n+            param_env: tcx.param_env(def.did),\n+            def_id: def.did.to_def_id(),\n+            hir_id,\n+            check_overflow,\n             cfg: CFG { basic_blocks: IndexVec::new() },\n             fn_span: span,\n             arg_count,\n@@ -826,7 +856,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         fn_def_id: DefId,\n         arguments: &[ArgInfo<'tcx>],\n         argument_scope: region::Scope,\n-        ast_body: &'tcx hir::Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n     ) -> BlockAnd<()> {\n         // Allocate locals for the function arguments\n         for &ArgInfo(ty, _, arg_opt, _) in arguments.iter() {\n@@ -846,9 +876,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n \n-        let tcx = self.hir.tcx();\n+        let tcx = self.tcx;\n         let tcx_hir = tcx.hir();\n-        let hir_typeck_results = self.hir.typeck_results();\n+        let hir_typeck_results = self.typeck_results;\n \n         // In analyze_closure() in upvar.rs we gathered a list of upvars used by a\n         // indexed closure and we stored in a map called closure_captures in TypeckResults\n@@ -924,14 +954,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             // Make sure we drop (parts of) the argument even when not matched on.\n             self.schedule_drop(\n-                arg_opt.as_ref().map_or(ast_body.span, |arg| arg.pat.span),\n+                arg_opt.as_ref().map_or(expr.span, |arg| arg.pat.span),\n                 argument_scope,\n                 local,\n                 DropKind::Value,\n             );\n \n             if let Some(arg) = arg_opt {\n-                let pattern = self.hir.pattern_from_hir(&arg.pat);\n+                let pat = match tcx.hir().get(arg.pat.hir_id) {\n+                    Node::Pat(pat) | Node::Binding(pat) => pat,\n+                    node => bug!(\"pattern became {:?}\", node),\n+                };\n+                let pattern = Pat::from_hir(tcx, self.param_env, self.typeck_results, pat);\n                 let original_source_scope = self.source_scope;\n                 let span = pattern.span;\n                 self.set_correct_source_scope_for_arg(arg.hir_id, original_source_scope, span);\n@@ -966,7 +1000,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     _ => {\n                         scope = self.declare_bindings(\n                             scope,\n-                            ast_body.span,\n+                            expr.span,\n                             &pattern,\n                             matches::ArmHasGuard(false),\n                             Some((Some(&place), span)),\n@@ -983,8 +1017,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.source_scope = source_scope;\n         }\n \n-        let body = self.hir.mirror(ast_body);\n-        self.into(Place::return_place(), block, body)\n+        self.expr_into_dest(Place::return_place(), block, &expr)\n     }\n \n     fn set_correct_source_scope_for_arg(\n@@ -993,15 +1026,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         original_source_scope: SourceScope,\n         pattern_span: Span,\n     ) {\n-        let tcx = self.hir.tcx();\n-        let current_root = tcx.maybe_lint_level_root_bounded(arg_hir_id, self.hir.root_lint_level);\n+        let tcx = self.tcx;\n+        let current_root = tcx.maybe_lint_level_root_bounded(arg_hir_id, self.hir_id);\n         let parent_root = tcx.maybe_lint_level_root_bounded(\n             self.source_scopes[original_source_scope]\n                 .local_data\n                 .as_ref()\n                 .assert_crate_local()\n                 .lint_root,\n-            self.hir.root_lint_level,\n+            self.hir_id,\n         );\n         if current_root != parent_root {\n             self.source_scope =\n@@ -1013,7 +1046,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         match self.unit_temp {\n             Some(tmp) => tmp,\n             None => {\n-                let ty = self.hir.unit_ty();\n+                let ty = self.tcx.mk_unit();\n                 let fn_span = self.fn_span;\n                 let tmp = self.temp(ty, fn_span);\n                 self.unit_temp = Some(tmp);\n@@ -1031,7 +1064,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n mod block;\n mod cfg;\n mod expr;\n-mod into;\n mod matches;\n mod misc;\n mod scope;"}, {"sha": "b637b9b70bdc6d8c9c3461946151392a203f429a", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=61365c06250e2ba6e0a578ae990f055ac5339107", "patch": "@@ -82,7 +82,7 @@ that contains only loops and breakable blocks. It tracks where a `break`,\n */\n \n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder, CFG};\n-use crate::thir::{Expr, ExprRef, LintLevel};\n+use crate::thir::{Expr, LintLevel};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::IndexVec;\n use rustc_middle::middle::region;\n@@ -516,18 +516,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     {\n         debug!(\"in_scope(region_scope={:?})\", region_scope);\n         let source_scope = self.source_scope;\n-        let tcx = self.hir.tcx();\n+        let tcx = self.tcx;\n         if let LintLevel::Explicit(current_hir_id) = lint_level {\n             // Use `maybe_lint_level_root_bounded` with `root_lint_level` as a bound\n             // to avoid adding Hir dependences on our parents.\n             // We estimate the true lint roots here to avoid creating a lot of source scopes.\n \n             let parent_root = tcx.maybe_lint_level_root_bounded(\n                 self.source_scopes[source_scope].local_data.as_ref().assert_crate_local().lint_root,\n-                self.hir.root_lint_level,\n+                self.hir_id,\n             );\n-            let current_root =\n-                tcx.maybe_lint_level_root_bounded(current_hir_id, self.hir.root_lint_level);\n+            let current_root = tcx.maybe_lint_level_root_bounded(current_hir_id, self.hir_id);\n \n             if parent_root != current_root {\n                 self.source_scope = self.new_source_scope(\n@@ -575,7 +574,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn break_scope(\n         &mut self,\n         mut block: BasicBlock,\n-        value: Option<ExprRef<'tcx>>,\n+        value: Option<&Expr<'_, 'tcx>>,\n         target: BreakableTarget,\n         source_info: SourceInfo,\n     ) -> BlockAnd<()> {\n@@ -612,10 +611,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             if let Some(value) = value {\n                 debug!(\"stmt_expr Break val block_context.push(SubExpr)\");\n                 self.block_context.push(BlockFrame::SubExpr);\n-                unpack!(block = self.into(destination, block, value));\n+                unpack!(block = self.expr_into_dest(destination, block, value));\n                 self.block_context.pop();\n             } else {\n-                self.cfg.push_assign_unit(block, source_info, destination, self.hir.tcx())\n+                self.cfg.push_assign_unit(block, source_info, destination, self.tcx)\n             }\n         } else {\n             assert!(value.is_none(), \"`return` and `break` should have a destination\");\n@@ -763,7 +762,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) {\n         let needs_drop = match drop_kind {\n             DropKind::Value => {\n-                if !self.hir.needs_drop(self.local_decls[local].ty) {\n+                if !self.local_decls[local].ty.needs_drop(self.tcx, self.param_env) {\n                     return;\n                 }\n                 true\n@@ -834,10 +833,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             if scope.region_scope == region_scope {\n-                let region_scope_span =\n-                    region_scope.span(self.hir.tcx(), &self.hir.region_scope_tree);\n+                let region_scope_span = region_scope.span(self.tcx, &self.region_scope_tree);\n                 // Attribute scope exit drops to scope's closing brace.\n-                let scope_end = self.hir.tcx().sess.source_map().end_point(region_scope_span);\n+                let scope_end = self.tcx.sess.source_map().end_point(region_scope_span);\n \n                 scope.drops.push(DropData {\n                     source_info: SourceInfo { span: scope_end, scope: scope.source_scope },\n@@ -920,13 +918,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn test_bool(\n         &mut self,\n         mut block: BasicBlock,\n-        condition: Expr<'tcx>,\n+        condition: &Expr<'_, 'tcx>,\n         source_info: SourceInfo,\n     ) -> (BasicBlock, BasicBlock) {\n         let cond = unpack!(block = self.as_local_operand(block, condition));\n         let true_block = self.cfg.start_new_block();\n         let false_block = self.cfg.start_new_block();\n-        let term = TerminatorKind::if_(self.hir.tcx(), cond.clone(), true_block, false_block);\n+        let term = TerminatorKind::if_(self.tcx, cond.clone(), true_block, false_block);\n         self.cfg.terminate(block, source_info, term);\n \n         match cond {"}, {"sha": "aacc7b12a42f94bf67caf19e88b80249b5f585db", "filename": "compiler/rustc_mir_build/src/thir/arena.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Farena.rs?ref=61365c06250e2ba6e0a578ae990f055ac5339107", "patch": "@@ -0,0 +1,98 @@\n+use crate::thir::*;\n+\n+macro_rules! declare_arena {\n+    ([], [$($a:tt $name:ident: $ty:ty,)*]) => {\n+        #[derive(Default)]\n+        pub struct Arena<'thir, 'tcx> {\n+            pub dropless: rustc_arena::DroplessArena,\n+            drop: rustc_arena::DropArena,\n+            $($name: rustc_arena::arena_for_type!($a[$ty]),)*\n+        }\n+\n+        pub trait ArenaAllocatable<'thir, 'tcx, T = Self>: Sized {\n+            fn allocate_on(self, arena: &'thir Arena<'thir, 'tcx>) -> &'thir mut Self;\n+            fn allocate_from_iter(\n+                arena: &'thir Arena<'thir, 'tcx>,\n+                iter: impl ::std::iter::IntoIterator<Item = Self>,\n+            ) -> &'thir mut [Self];\n+        }\n+\n+        impl<'thir, 'tcx, T: Copy> ArenaAllocatable<'thir, 'tcx, ()> for T {\n+            #[inline]\n+            fn allocate_on(self, arena: &'thir Arena<'thir, 'tcx>) -> &'thir mut Self {\n+                arena.dropless.alloc(self)\n+            }\n+            #[inline]\n+            fn allocate_from_iter(\n+                arena: &'thir Arena<'thir, 'tcx>,\n+                iter: impl ::std::iter::IntoIterator<Item = Self>,\n+            ) -> &'thir mut [Self] {\n+                arena.dropless.alloc_from_iter(iter)\n+            }\n+\n+        }\n+        $(\n+            impl<'thir, 'tcx> ArenaAllocatable<'thir, 'tcx, $ty> for $ty {\n+                #[inline]\n+                fn allocate_on(self, arena: &'thir Arena<'thir, 'tcx>) -> &'thir mut Self {\n+                    if !::std::mem::needs_drop::<Self>() {\n+                        return arena.dropless.alloc(self);\n+                    }\n+                    match rustc_arena::which_arena_for_type!($a[&arena.$name]) {\n+                        ::std::option::Option::<&rustc_arena::TypedArena<Self>>::Some(ty_arena) => {\n+                            ty_arena.alloc(self)\n+                        }\n+                        ::std::option::Option::None => unsafe { arena.drop.alloc(self) },\n+                    }\n+                }\n+\n+                #[inline]\n+                fn allocate_from_iter(\n+                    arena: &'thir Arena<'thir, 'tcx>,\n+                    iter: impl ::std::iter::IntoIterator<Item = Self>,\n+                ) -> &'thir mut [Self] {\n+                    if !::std::mem::needs_drop::<Self>() {\n+                        return arena.dropless.alloc_from_iter(iter);\n+                    }\n+                    match rustc_arena::which_arena_for_type!($a[&arena.$name]) {\n+                        ::std::option::Option::<&rustc_arena::TypedArena<Self>>::Some(ty_arena) => {\n+                            ty_arena.alloc_from_iter(iter)\n+                        }\n+                        ::std::option::Option::None => unsafe { arena.drop.alloc_from_iter(iter) },\n+                    }\n+                }\n+            }\n+        )*\n+\n+        impl<'thir, 'tcx> Arena<'thir, 'tcx> {\n+            #[inline]\n+            pub fn alloc<T: ArenaAllocatable<'thir, 'tcx, U>, U>(&'thir self, value: T) -> &'thir mut T {\n+                value.allocate_on(self)\n+            }\n+\n+            #[allow(dead_code)] // function is never used\n+            #[inline]\n+            pub fn alloc_slice<T: ::std::marker::Copy>(&'thir self, value: &[T]) -> &'thir mut [T] {\n+                if value.is_empty() {\n+                    return &mut [];\n+                }\n+                self.dropless.alloc_slice(value)\n+            }\n+\n+            pub fn alloc_from_iter<T: ArenaAllocatable<'thir, 'tcx, U>, U>(\n+                &'thir self,\n+                iter: impl ::std::iter::IntoIterator<Item = T>,\n+            ) -> &'thir mut [T] {\n+                T::allocate_from_iter(self, iter)\n+            }\n+        }\n+    }\n+}\n+\n+declare_arena!([], [\n+    [] arm: Arm<'thir, 'tcx>,\n+    [] expr: Expr<'thir, 'tcx>,\n+    [] field_expr: FieldExpr<'thir, 'tcx>,\n+    [few] inline_asm_operand: InlineAsmOperand<'thir, 'tcx>,\n+    [] stmt: Stmt<'thir, 'tcx>,\n+]);"}, {"sha": "d450f8a265d994e2dfb433131f6870c2067ffea1", "filename": "compiler/rustc_mir_build/src/thir/cx/block.rs", "status": "modified", "additions": 67, "deletions": 83, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs?ref=61365c06250e2ba6e0a578ae990f055ac5339107", "patch": "@@ -1,4 +1,3 @@\n-use crate::thir::cx::to_ref::ToRef;\n use crate::thir::cx::Cx;\n use crate::thir::{self, *};\n \n@@ -8,110 +7,95 @@ use rustc_middle::ty;\n \n use rustc_index::vec::Idx;\n \n-impl<'tcx> Mirror<'tcx> for &'tcx hir::Block<'tcx> {\n-    type Output = Block<'tcx>;\n-\n-    fn make_mirror(self, cx: &mut Cx<'_, 'tcx>) -> Block<'tcx> {\n+impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n+    crate fn mirror_block(&mut self, block: &'tcx hir::Block<'tcx>) -> Block<'thir, 'tcx> {\n         // We have to eagerly lower the \"spine\" of the statements\n         // in order to get the lexical scoping correctly.\n-        let stmts = mirror_stmts(cx, self.hir_id.local_id, &*self.stmts);\n+        let stmts = self.mirror_stmts(block.hir_id.local_id, block.stmts);\n         let opt_destruction_scope =\n-            cx.region_scope_tree.opt_destruction_scope(self.hir_id.local_id);\n+            self.region_scope_tree.opt_destruction_scope(block.hir_id.local_id);\n         Block {\n-            targeted_by_break: self.targeted_by_break,\n-            region_scope: region::Scope { id: self.hir_id.local_id, data: region::ScopeData::Node },\n+            targeted_by_break: block.targeted_by_break,\n+            region_scope: region::Scope {\n+                id: block.hir_id.local_id,\n+                data: region::ScopeData::Node,\n+            },\n             opt_destruction_scope,\n-            span: self.span,\n+            span: block.span,\n             stmts,\n-            expr: self.expr.to_ref(),\n-            safety_mode: match self.rules {\n+            expr: block.expr.map(|expr| self.mirror_expr(expr)),\n+            safety_mode: match block.rules {\n                 hir::BlockCheckMode::DefaultBlock => BlockSafety::Safe,\n-                hir::BlockCheckMode::UnsafeBlock(..) => BlockSafety::ExplicitUnsafe(self.hir_id),\n+                hir::BlockCheckMode::UnsafeBlock(..) => BlockSafety::ExplicitUnsafe(block.hir_id),\n                 hir::BlockCheckMode::PushUnsafeBlock(..) => BlockSafety::PushUnsafe,\n                 hir::BlockCheckMode::PopUnsafeBlock(..) => BlockSafety::PopUnsafe,\n             },\n         }\n     }\n-}\n \n-fn mirror_stmts<'a, 'tcx>(\n-    cx: &mut Cx<'a, 'tcx>,\n-    block_id: hir::ItemLocalId,\n-    stmts: &'tcx [hir::Stmt<'tcx>],\n-) -> Vec<StmtRef<'tcx>> {\n-    let mut result = vec![];\n-    for (index, stmt) in stmts.iter().enumerate() {\n-        let hir_id = stmt.hir_id;\n-        let opt_dxn_ext = cx.region_scope_tree.opt_destruction_scope(hir_id.local_id);\n-        match stmt.kind {\n-            hir::StmtKind::Expr(ref expr) | hir::StmtKind::Semi(ref expr) => {\n-                result.push(StmtRef::Mirror(Box::new(Stmt {\n+    fn mirror_stmts(\n+        &mut self,\n+        block_id: hir::ItemLocalId,\n+        stmts: &'tcx [hir::Stmt<'tcx>],\n+    ) -> &'thir [Stmt<'thir, 'tcx>] {\n+        self.arena.alloc_from_iter(stmts.iter().enumerate().filter_map(|(index, stmt)| {\n+            let hir_id = stmt.hir_id;\n+            let opt_dxn_ext = self.region_scope_tree.opt_destruction_scope(hir_id.local_id);\n+            match stmt.kind {\n+                hir::StmtKind::Expr(ref expr) | hir::StmtKind::Semi(ref expr) => Some(Stmt {\n                     kind: StmtKind::Expr {\n                         scope: region::Scope { id: hir_id.local_id, data: region::ScopeData::Node },\n-                        expr: expr.to_ref(),\n+                        expr: self.mirror_expr(expr),\n                     },\n                     opt_destruction_scope: opt_dxn_ext,\n-                })))\n-            }\n-            hir::StmtKind::Item(..) => {\n-                // ignore for purposes of the MIR\n-            }\n-            hir::StmtKind::Local(ref local) => {\n-                let remainder_scope = region::Scope {\n-                    id: block_id,\n-                    data: region::ScopeData::Remainder(region::FirstStatementIndex::new(index)),\n-                };\n+                }),\n+                hir::StmtKind::Item(..) => {\n+                    // ignore for purposes of the MIR\n+                    None\n+                }\n+                hir::StmtKind::Local(ref local) => {\n+                    let remainder_scope = region::Scope {\n+                        id: block_id,\n+                        data: region::ScopeData::Remainder(region::FirstStatementIndex::new(index)),\n+                    };\n \n-                let mut pattern = cx.pattern_from_hir(&local.pat);\n+                    let mut pattern = self.pattern_from_hir(local.pat);\n \n-                if let Some(ty) = &local.ty {\n-                    if let Some(&user_ty) = cx.typeck_results.user_provided_types().get(ty.hir_id) {\n-                        debug!(\"mirror_stmts: user_ty={:?}\", user_ty);\n-                        pattern = Pat {\n-                            ty: pattern.ty,\n-                            span: pattern.span,\n-                            kind: Box::new(PatKind::AscribeUserType {\n-                                ascription: thir::pattern::Ascription {\n-                                    user_ty: PatTyProj::from_user_type(user_ty),\n-                                    user_ty_span: ty.span,\n-                                    variance: ty::Variance::Covariant,\n-                                },\n-                                subpattern: pattern,\n-                            }),\n-                        };\n+                    if let Some(ty) = &local.ty {\n+                        if let Some(&user_ty) =\n+                            self.typeck_results.user_provided_types().get(ty.hir_id)\n+                        {\n+                            debug!(\"mirror_stmts: user_ty={:?}\", user_ty);\n+                            pattern = Pat {\n+                                ty: pattern.ty,\n+                                span: pattern.span,\n+                                kind: Box::new(PatKind::AscribeUserType {\n+                                    ascription: thir::pattern::Ascription {\n+                                        user_ty: PatTyProj::from_user_type(user_ty),\n+                                        user_ty_span: ty.span,\n+                                        variance: ty::Variance::Covariant,\n+                                    },\n+                                    subpattern: pattern,\n+                                }),\n+                            };\n+                        }\n                     }\n-                }\n \n-                result.push(StmtRef::Mirror(Box::new(Stmt {\n-                    kind: StmtKind::Let {\n-                        remainder_scope,\n-                        init_scope: region::Scope {\n-                            id: hir_id.local_id,\n-                            data: region::ScopeData::Node,\n+                    Some(Stmt {\n+                        kind: StmtKind::Let {\n+                            remainder_scope,\n+                            init_scope: region::Scope {\n+                                id: hir_id.local_id,\n+                                data: region::ScopeData::Node,\n+                            },\n+                            pattern,\n+                            initializer: local.init.map(|init| self.mirror_expr(init)),\n+                            lint_level: LintLevel::Explicit(local.hir_id),\n                         },\n-                        pattern,\n-                        initializer: local.init.to_ref(),\n-                        lint_level: LintLevel::Explicit(local.hir_id),\n-                    },\n-                    opt_destruction_scope: opt_dxn_ext,\n-                })));\n+                        opt_destruction_scope: opt_dxn_ext,\n+                    })\n+                }\n             }\n-        }\n+        }))\n     }\n-    result\n-}\n-\n-crate fn to_expr_ref<'a, 'tcx>(\n-    cx: &mut Cx<'a, 'tcx>,\n-    block: &'tcx hir::Block<'tcx>,\n-) -> ExprRef<'tcx> {\n-    let block_ty = cx.typeck_results().node_type(block.hir_id);\n-    let temp_lifetime = cx.region_scope_tree.temporary_scope(block.hir_id.local_id);\n-    let expr = Expr {\n-        ty: block_ty,\n-        temp_lifetime,\n-        span: block.span,\n-        kind: ExprKind::Block { body: block },\n-    };\n-    expr.to_ref()\n }"}, {"sha": "dfcb52c83c0d77934d53b10ede6130f7b3d48e21", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 900, "deletions": 821, "changes": 1721, "blob_url": "https://github.com/rust-lang/rust/blob/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=61365c06250e2ba6e0a578ae990f055ac5339107", "patch": "@@ -1,8 +1,7 @@\n-use crate::thir::cx::block;\n-use crate::thir::cx::to_ref::ToRef;\n use crate::thir::cx::Cx;\n use crate::thir::util::UserAnnotatedTyHelpers;\n use crate::thir::*;\n+use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_index::vec::Idx;\n@@ -17,45 +16,71 @@ use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n use rustc_middle::ty::{self, AdtKind, Ty};\n use rustc_span::Span;\n \n-impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr<'tcx> {\n-    type Output = Expr<'tcx>;\n+use std::iter;\n \n-    fn make_mirror(self, cx: &mut Cx<'_, 'tcx>) -> Expr<'tcx> {\n-        let temp_lifetime = cx.region_scope_tree.temporary_scope(self.hir_id.local_id);\n-        let expr_scope = region::Scope { id: self.hir_id.local_id, data: region::ScopeData::Node };\n+impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n+    /// Mirrors and allocates a single [`hir::Expr`]. If you need to mirror a whole slice\n+    /// of expressions, prefer using [`mirror_exprs`].\n+    ///\n+    /// [`mirror_exprs`]: Self::mirror_exprs\n+    crate fn mirror_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) -> &'thir Expr<'thir, 'tcx> {\n+        // `mirror_expr` is recursing very deep. Make sure the stack doesn't overflow.\n+        ensure_sufficient_stack(|| self.arena.alloc(self.mirror_expr_inner(expr)))\n+    }\n+\n+    /// Mirrors and allocates a slice of [`hir::Expr`]s. They will be allocated as a\n+    /// contiguous sequence in memory.\n+    crate fn mirror_exprs(&mut self, exprs: &'tcx [hir::Expr<'tcx>]) -> &'thir [Expr<'thir, 'tcx>] {\n+        self.arena.alloc_from_iter(exprs.iter().map(|expr| self.mirror_expr_inner(expr)))\n+    }\n \n-        debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.hir_id, self.span);\n+    /// Mirrors a [`hir::Expr`] without allocating it into the arena.\n+    /// This is a separate, private function so that [`mirror_expr`] and [`mirror_exprs`] can\n+    /// decide how to allocate this expression (alone or within a slice).\n+    ///\n+    /// [`mirror_expr`]: Self::mirror_expr\n+    /// [`mirror_exprs`]: Self::mirror_exprs\n+    pub(super) fn mirror_expr_inner(\n+        &mut self,\n+        hir_expr: &'tcx hir::Expr<'tcx>,\n+    ) -> Expr<'thir, 'tcx> {\n+        let temp_lifetime = self.region_scope_tree.temporary_scope(hir_expr.hir_id.local_id);\n+        let expr_scope =\n+            region::Scope { id: hir_expr.hir_id.local_id, data: region::ScopeData::Node };\n \n-        let mut expr = make_mirror_unadjusted(cx, self);\n+        debug!(\"Expr::make_mirror(): id={}, span={:?}\", hir_expr.hir_id, hir_expr.span);\n+\n+        let mut expr = self.make_mirror_unadjusted(hir_expr);\n \n         // Now apply adjustments, if any.\n-        for adjustment in cx.typeck_results().expr_adjustments(self) {\n+        for adjustment in self.typeck_results.expr_adjustments(hir_expr) {\n             debug!(\"make_mirror: expr={:?} applying adjustment={:?}\", expr, adjustment);\n-            expr = apply_adjustment(cx, self, expr, adjustment);\n+            expr = self.apply_adjustment(hir_expr, expr, adjustment);\n         }\n \n         // Next, wrap this up in the expr's scope.\n         expr = Expr {\n             temp_lifetime,\n             ty: expr.ty,\n-            span: self.span,\n+            span: hir_expr.span,\n             kind: ExprKind::Scope {\n                 region_scope: expr_scope,\n-                value: expr.to_ref(),\n-                lint_level: LintLevel::Explicit(self.hir_id),\n+                value: self.arena.alloc(expr),\n+                lint_level: LintLevel::Explicit(hir_expr.hir_id),\n             },\n         };\n \n         // Finally, create a destruction scope, if any.\n-        if let Some(region_scope) = cx.region_scope_tree.opt_destruction_scope(self.hir_id.local_id)\n+        if let Some(region_scope) =\n+            self.region_scope_tree.opt_destruction_scope(hir_expr.hir_id.local_id)\n         {\n             expr = Expr {\n                 temp_lifetime,\n                 ty: expr.ty,\n-                span: self.span,\n+                span: hir_expr.span,\n                 kind: ExprKind::Scope {\n                     region_scope,\n-                    value: expr.to_ref(),\n+                    value: self.arena.alloc(expr),\n                     lint_level: LintLevel::Inherited,\n                 },\n             };\n@@ -64,364 +89,393 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr<'tcx> {\n         // OK, all done!\n         expr\n     }\n-}\n \n-fn apply_adjustment<'a, 'tcx>(\n-    cx: &mut Cx<'a, 'tcx>,\n-    hir_expr: &'tcx hir::Expr<'tcx>,\n-    mut expr: Expr<'tcx>,\n-    adjustment: &Adjustment<'tcx>,\n-) -> Expr<'tcx> {\n-    let Expr { temp_lifetime, mut span, .. } = expr;\n-\n-    // Adjust the span from the block, to the last expression of the\n-    // block. This is a better span when returning a mutable reference\n-    // with too short a lifetime. The error message will use the span\n-    // from the assignment to the return place, which should only point\n-    // at the returned value, not the entire function body.\n-    //\n-    // fn return_short_lived<'a>(x: &'a mut i32) -> &'static mut i32 {\n-    //      x\n-    //   // ^ error message points at this expression.\n-    // }\n-    let mut adjust_span = |expr: &mut Expr<'tcx>| {\n-        if let ExprKind::Block { body } = expr.kind {\n-            if let Some(ref last_expr) = body.expr {\n-                span = last_expr.span;\n-                expr.span = span;\n+    fn apply_adjustment(\n+        &mut self,\n+        hir_expr: &'tcx hir::Expr<'tcx>,\n+        mut expr: Expr<'thir, 'tcx>,\n+        adjustment: &Adjustment<'tcx>,\n+    ) -> Expr<'thir, 'tcx> {\n+        let Expr { temp_lifetime, mut span, .. } = expr;\n+\n+        // Adjust the span from the block, to the last expression of the\n+        // block. This is a better span when returning a mutable reference\n+        // with too short a lifetime. The error message will use the span\n+        // from the assignment to the return place, which should only point\n+        // at the returned value, not the entire function body.\n+        //\n+        // fn return_short_lived<'a>(x: &'a mut i32) -> &'static mut i32 {\n+        //      x\n+        //   // ^ error message points at this expression.\n+        // }\n+        let mut adjust_span = |expr: &mut Expr<'thir, 'tcx>| {\n+            if let ExprKind::Block { body } = &expr.kind {\n+                if let Some(ref last_expr) = body.expr {\n+                    span = last_expr.span;\n+                    expr.span = span;\n+                }\n             }\n-        }\n-    };\n+        };\n \n-    let kind = match adjustment.kind {\n-        Adjust::Pointer(PointerCast::Unsize) => {\n-            adjust_span(&mut expr);\n-            ExprKind::Pointer { cast: PointerCast::Unsize, source: expr.to_ref() }\n-        }\n-        Adjust::Pointer(cast) => ExprKind::Pointer { cast, source: expr.to_ref() },\n-        Adjust::NeverToAny => ExprKind::NeverToAny { source: expr.to_ref() },\n-        Adjust::Deref(None) => {\n-            adjust_span(&mut expr);\n-            ExprKind::Deref { arg: expr.to_ref() }\n-        }\n-        Adjust::Deref(Some(deref)) => {\n-            // We don't need to do call adjust_span here since\n-            // deref coercions always start with a built-in deref.\n-            let call = deref.method_call(cx.tcx(), expr.ty);\n+        let kind = match adjustment.kind {\n+            Adjust::Pointer(PointerCast::Unsize) => {\n+                adjust_span(&mut expr);\n+                ExprKind::Pointer { cast: PointerCast::Unsize, source: self.arena.alloc(expr) }\n+            }\n+            Adjust::Pointer(cast) => ExprKind::Pointer { cast, source: self.arena.alloc(expr) },\n+            Adjust::NeverToAny => ExprKind::NeverToAny { source: self.arena.alloc(expr) },\n+            Adjust::Deref(None) => {\n+                adjust_span(&mut expr);\n+                ExprKind::Deref { arg: self.arena.alloc(expr) }\n+            }\n+            Adjust::Deref(Some(deref)) => {\n+                // We don't need to do call adjust_span here since\n+                // deref coercions always start with a built-in deref.\n+                let call = deref.method_call(self.tcx(), expr.ty);\n \n-            expr = Expr {\n-                temp_lifetime,\n-                ty: cx.tcx.mk_ref(deref.region, ty::TypeAndMut { ty: expr.ty, mutbl: deref.mutbl }),\n-                span,\n-                kind: ExprKind::Borrow {\n-                    borrow_kind: deref.mutbl.to_borrow_kind(),\n-                    arg: expr.to_ref(),\n-                },\n-            };\n+                expr = Expr {\n+                    temp_lifetime,\n+                    ty: self\n+                        .tcx\n+                        .mk_ref(deref.region, ty::TypeAndMut { ty: expr.ty, mutbl: deref.mutbl }),\n+                    span,\n+                    kind: ExprKind::Borrow {\n+                        borrow_kind: deref.mutbl.to_borrow_kind(),\n+                        arg: self.arena.alloc(expr),\n+                    },\n+                };\n \n-            overloaded_place(\n-                cx,\n-                hir_expr,\n-                adjustment.target,\n-                Some(call),\n-                vec![expr.to_ref()],\n-                deref.span,\n-            )\n-        }\n-        Adjust::Borrow(AutoBorrow::Ref(_, m)) => {\n-            ExprKind::Borrow { borrow_kind: m.to_borrow_kind(), arg: expr.to_ref() }\n-        }\n-        Adjust::Borrow(AutoBorrow::RawPtr(mutability)) => {\n-            ExprKind::AddressOf { mutability, arg: expr.to_ref() }\n-        }\n-    };\n+                self.overloaded_place(\n+                    hir_expr,\n+                    adjustment.target,\n+                    Some(call),\n+                    self.arena.alloc_from_iter(iter::once(expr)),\n+                    deref.span,\n+                )\n+            }\n+            Adjust::Borrow(AutoBorrow::Ref(_, m)) => {\n+                ExprKind::Borrow { borrow_kind: m.to_borrow_kind(), arg: self.arena.alloc(expr) }\n+            }\n+            Adjust::Borrow(AutoBorrow::RawPtr(mutability)) => {\n+                ExprKind::AddressOf { mutability, arg: self.arena.alloc(expr) }\n+            }\n+        };\n \n-    Expr { temp_lifetime, ty: adjustment.target, span, kind }\n-}\n+        Expr { temp_lifetime, ty: adjustment.target, span, kind }\n+    }\n \n-fn make_mirror_unadjusted<'a, 'tcx>(\n-    cx: &mut Cx<'a, 'tcx>,\n-    expr: &'tcx hir::Expr<'tcx>,\n-) -> Expr<'tcx> {\n-    let expr_ty = cx.typeck_results().expr_ty(expr);\n-    let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-\n-    let kind = match expr.kind {\n-        // Here comes the interesting stuff:\n-        hir::ExprKind::MethodCall(_, method_span, ref args, fn_span) => {\n-            // Rewrite a.b(c) into UFCS form like Trait::b(a, c)\n-            let expr = method_callee(cx, expr, method_span, None);\n-            let args = args.iter().map(|e| e.to_ref()).collect();\n-            ExprKind::Call { ty: expr.ty, fun: expr.to_ref(), args, from_hir_call: true, fn_span }\n-        }\n+    fn make_mirror_unadjusted(&mut self, expr: &'tcx hir::Expr<'tcx>) -> Expr<'thir, 'tcx> {\n+        let expr_ty = self.typeck_results().expr_ty(expr);\n+        let temp_lifetime = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n \n-        hir::ExprKind::Call(ref fun, ref args) => {\n-            if cx.typeck_results().is_method_call(expr) {\n-                // The callee is something implementing Fn, FnMut, or FnOnce.\n-                // Find the actual method implementation being called and\n-                // build the appropriate UFCS call expression with the\n-                // callee-object as expr parameter.\n+        let kind = match expr.kind {\n+            // Here comes the interesting stuff:\n+            hir::ExprKind::MethodCall(_, method_span, ref args, fn_span) => {\n+                // Rewrite a.b(c) into UFCS form like Trait::b(a, c)\n+                let expr = self.method_callee(expr, method_span, None);\n+                let args = self.mirror_exprs(args);\n+                ExprKind::Call {\n+                    ty: expr.ty,\n+                    fun: self.arena.alloc(expr),\n+                    args,\n+                    from_hir_call: true,\n+                    fn_span,\n+                }\n+            }\n \n-                // rewrite f(u, v) into FnOnce::call_once(f, (u, v))\n+            hir::ExprKind::Call(ref fun, ref args) => {\n+                if self.typeck_results().is_method_call(expr) {\n+                    // The callee is something implementing Fn, FnMut, or FnOnce.\n+                    // Find the actual method implementation being called and\n+                    // build the appropriate UFCS call expression with the\n+                    // callee-object as expr parameter.\n \n-                let method = method_callee(cx, expr, fun.span, None);\n+                    // rewrite f(u, v) into FnOnce::call_once(f, (u, v))\n \n-                let arg_tys = args.iter().map(|e| cx.typeck_results().expr_ty_adjusted(e));\n-                let tupled_args = Expr {\n-                    ty: cx.tcx.mk_tup(arg_tys),\n-                    temp_lifetime,\n-                    span: expr.span,\n-                    kind: ExprKind::Tuple { fields: args.iter().map(ToRef::to_ref).collect() },\n-                };\n+                    let method = self.method_callee(expr, fun.span, None);\n \n-                ExprKind::Call {\n-                    ty: method.ty,\n-                    fun: method.to_ref(),\n-                    args: vec![fun.to_ref(), tupled_args.to_ref()],\n-                    from_hir_call: true,\n-                    fn_span: expr.span,\n-                }\n-            } else {\n-                let adt_data =\n-                    if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = fun.kind {\n-                        // Tuple-like ADTs are represented as ExprKind::Call. We convert them here.\n-                        expr_ty.ty_adt_def().and_then(|adt_def| match path.res {\n-                            Res::Def(DefKind::Ctor(_, CtorKind::Fn), ctor_id) => {\n-                                Some((adt_def, adt_def.variant_index_with_ctor_id(ctor_id)))\n-                            }\n-                            Res::SelfCtor(..) => Some((adt_def, VariantIdx::new(0))),\n-                            _ => None,\n-                        })\n-                    } else {\n-                        None\n+                    let arg_tys = args.iter().map(|e| self.typeck_results().expr_ty_adjusted(e));\n+                    let tupled_args = Expr {\n+                        ty: self.tcx.mk_tup(arg_tys),\n+                        temp_lifetime,\n+                        span: expr.span,\n+                        kind: ExprKind::Tuple { fields: self.mirror_exprs(args) },\n                     };\n-                if let Some((adt_def, index)) = adt_data {\n-                    let substs = cx.typeck_results().node_substs(fun.hir_id);\n-                    let user_provided_types = cx.typeck_results().user_provided_types();\n-                    let user_ty = user_provided_types.get(fun.hir_id).copied().map(|mut u_ty| {\n-                        if let UserType::TypeOf(ref mut did, _) = &mut u_ty.value {\n-                            *did = adt_def.did;\n-                        }\n-                        u_ty\n-                    });\n-                    debug!(\"make_mirror_unadjusted: (call) user_ty={:?}\", user_ty);\n-\n-                    let field_refs = args\n-                        .iter()\n-                        .enumerate()\n-                        .map(|(idx, e)| FieldExprRef { name: Field::new(idx), expr: e.to_ref() })\n-                        .collect();\n-                    ExprKind::Adt {\n-                        adt_def,\n-                        substs,\n-                        variant_index: index,\n-                        fields: field_refs,\n-                        user_ty,\n-                        base: None,\n-                    }\n-                } else {\n+\n                     ExprKind::Call {\n-                        ty: cx.typeck_results().node_type(fun.hir_id),\n-                        fun: fun.to_ref(),\n-                        args: args.to_ref(),\n+                        ty: method.ty,\n+                        fun: self.arena.alloc(method),\n+                        args: self\n+                            .arena\n+                            .alloc_from_iter(vec![self.mirror_expr_inner(fun), tupled_args]),\n                         from_hir_call: true,\n                         fn_span: expr.span,\n                     }\n+                } else {\n+                    let adt_data =\n+                        if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = fun.kind {\n+                            // Tuple-like ADTs are represented as ExprKind::Call. We convert them here.\n+                            expr_ty.ty_adt_def().and_then(|adt_def| match path.res {\n+                                Res::Def(DefKind::Ctor(_, CtorKind::Fn), ctor_id) => {\n+                                    Some((adt_def, adt_def.variant_index_with_ctor_id(ctor_id)))\n+                                }\n+                                Res::SelfCtor(..) => Some((adt_def, VariantIdx::new(0))),\n+                                _ => None,\n+                            })\n+                        } else {\n+                            None\n+                        };\n+                    if let Some((adt_def, index)) = adt_data {\n+                        let substs = self.typeck_results().node_substs(fun.hir_id);\n+                        let user_provided_types = self.typeck_results().user_provided_types();\n+                        let user_ty =\n+                            user_provided_types.get(fun.hir_id).copied().map(|mut u_ty| {\n+                                if let UserType::TypeOf(ref mut did, _) = &mut u_ty.value {\n+                                    *did = adt_def.did;\n+                                }\n+                                u_ty\n+                            });\n+                        debug!(\"make_mirror_unadjusted: (call) user_ty={:?}\", user_ty);\n+\n+                        let field_refs =\n+                            self.arena.alloc_from_iter(args.iter().enumerate().map(|(idx, e)| {\n+                                FieldExpr { name: Field::new(idx), expr: self.mirror_expr(e) }\n+                            }));\n+                        ExprKind::Adt {\n+                            adt_def,\n+                            substs,\n+                            variant_index: index,\n+                            fields: field_refs,\n+                            user_ty,\n+                            base: None,\n+                        }\n+                    } else {\n+                        ExprKind::Call {\n+                            ty: self.typeck_results().node_type(fun.hir_id),\n+                            fun: self.mirror_expr(fun),\n+                            args: self.mirror_exprs(args),\n+                            from_hir_call: true,\n+                            fn_span: expr.span,\n+                        }\n+                    }\n                 }\n             }\n-        }\n \n-        hir::ExprKind::AddrOf(hir::BorrowKind::Ref, mutbl, ref arg) => {\n-            ExprKind::Borrow { borrow_kind: mutbl.to_borrow_kind(), arg: arg.to_ref() }\n-        }\n+            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, mutbl, ref arg) => {\n+                ExprKind::Borrow { borrow_kind: mutbl.to_borrow_kind(), arg: self.mirror_expr(arg) }\n+            }\n \n-        hir::ExprKind::AddrOf(hir::BorrowKind::Raw, mutability, ref arg) => {\n-            ExprKind::AddressOf { mutability, arg: arg.to_ref() }\n-        }\n+            hir::ExprKind::AddrOf(hir::BorrowKind::Raw, mutability, ref arg) => {\n+                ExprKind::AddressOf { mutability, arg: self.mirror_expr(arg) }\n+            }\n \n-        hir::ExprKind::Block(ref blk, _) => ExprKind::Block { body: &blk },\n+            hir::ExprKind::Block(ref blk, _) => ExprKind::Block { body: self.mirror_block(blk) },\n \n-        hir::ExprKind::Assign(ref lhs, ref rhs, _) => {\n-            ExprKind::Assign { lhs: lhs.to_ref(), rhs: rhs.to_ref() }\n-        }\n+            hir::ExprKind::Assign(ref lhs, ref rhs, _) => {\n+                ExprKind::Assign { lhs: self.mirror_expr(lhs), rhs: self.mirror_expr(rhs) }\n+            }\n \n-        hir::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n-            if cx.typeck_results().is_method_call(expr) {\n-                overloaded_operator(cx, expr, vec![lhs.to_ref(), rhs.to_ref()])\n-            } else {\n-                ExprKind::AssignOp { op: bin_op(op.node), lhs: lhs.to_ref(), rhs: rhs.to_ref() }\n+            hir::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n+                if self.typeck_results().is_method_call(expr) {\n+                    let lhs = self.mirror_expr_inner(lhs);\n+                    let rhs = self.mirror_expr_inner(rhs);\n+                    self.overloaded_operator(expr, self.arena.alloc_from_iter(vec![lhs, rhs]))\n+                } else {\n+                    ExprKind::AssignOp {\n+                        op: bin_op(op.node),\n+                        lhs: self.mirror_expr(lhs),\n+                        rhs: self.mirror_expr(rhs),\n+                    }\n+                }\n             }\n-        }\n \n-        hir::ExprKind::Lit(ref lit) => ExprKind::Literal {\n-            literal: cx.const_eval_literal(&lit.node, expr_ty, lit.span, false),\n-            user_ty: None,\n-            const_id: None,\n-        },\n-\n-        hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n-            if cx.typeck_results().is_method_call(expr) {\n-                overloaded_operator(cx, expr, vec![lhs.to_ref(), rhs.to_ref()])\n-            } else {\n-                // FIXME overflow\n-                match (op.node, cx.constness) {\n-                    (hir::BinOpKind::And, _) => ExprKind::LogicalOp {\n-                        op: LogicalOp::And,\n-                        lhs: lhs.to_ref(),\n-                        rhs: rhs.to_ref(),\n-                    },\n-                    (hir::BinOpKind::Or, _) => ExprKind::LogicalOp {\n-                        op: LogicalOp::Or,\n-                        lhs: lhs.to_ref(),\n-                        rhs: rhs.to_ref(),\n-                    },\n+            hir::ExprKind::Lit(ref lit) => ExprKind::Literal {\n+                literal: self.const_eval_literal(&lit.node, expr_ty, lit.span, false),\n+                user_ty: None,\n+                const_id: None,\n+            },\n \n-                    _ => {\n-                        let op = bin_op(op.node);\n-                        ExprKind::Binary { op, lhs: lhs.to_ref(), rhs: rhs.to_ref() }\n+            hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n+                if self.typeck_results().is_method_call(expr) {\n+                    let lhs = self.mirror_expr_inner(lhs);\n+                    let rhs = self.mirror_expr_inner(rhs);\n+                    self.overloaded_operator(expr, self.arena.alloc_from_iter(vec![lhs, rhs]))\n+                } else {\n+                    // FIXME overflow\n+                    match op.node {\n+                        hir::BinOpKind::And => ExprKind::LogicalOp {\n+                            op: LogicalOp::And,\n+                            lhs: self.mirror_expr(lhs),\n+                            rhs: self.mirror_expr(rhs),\n+                        },\n+                        hir::BinOpKind::Or => ExprKind::LogicalOp {\n+                            op: LogicalOp::Or,\n+                            lhs: self.mirror_expr(lhs),\n+                            rhs: self.mirror_expr(rhs),\n+                        },\n+\n+                        _ => {\n+                            let op = bin_op(op.node);\n+                            ExprKind::Binary {\n+                                op,\n+                                lhs: self.mirror_expr(lhs),\n+                                rhs: self.mirror_expr(rhs),\n+                            }\n+                        }\n                     }\n                 }\n             }\n-        }\n \n-        hir::ExprKind::Index(ref lhs, ref index) => {\n-            if cx.typeck_results().is_method_call(expr) {\n-                overloaded_place(\n-                    cx,\n-                    expr,\n-                    expr_ty,\n-                    None,\n-                    vec![lhs.to_ref(), index.to_ref()],\n-                    expr.span,\n-                )\n-            } else {\n-                ExprKind::Index { lhs: lhs.to_ref(), index: index.to_ref() }\n+            hir::ExprKind::Index(ref lhs, ref index) => {\n+                if self.typeck_results().is_method_call(expr) {\n+                    let lhs = self.mirror_expr_inner(lhs);\n+                    let index = self.mirror_expr_inner(index);\n+                    self.overloaded_place(\n+                        expr,\n+                        expr_ty,\n+                        None,\n+                        self.arena.alloc_from_iter(vec![lhs, index]),\n+                        expr.span,\n+                    )\n+                } else {\n+                    ExprKind::Index { lhs: self.mirror_expr(lhs), index: self.mirror_expr(index) }\n+                }\n             }\n-        }\n \n-        hir::ExprKind::Unary(hir::UnOp::Deref, ref arg) => {\n-            if cx.typeck_results().is_method_call(expr) {\n-                overloaded_place(cx, expr, expr_ty, None, vec![arg.to_ref()], expr.span)\n-            } else {\n-                ExprKind::Deref { arg: arg.to_ref() }\n+            hir::ExprKind::Unary(hir::UnOp::Deref, ref arg) => {\n+                if self.typeck_results().is_method_call(expr) {\n+                    let arg = self.mirror_expr_inner(arg);\n+                    self.overloaded_place(\n+                        expr,\n+                        expr_ty,\n+                        None,\n+                        self.arena.alloc_from_iter(iter::once(arg)),\n+                        expr.span,\n+                    )\n+                } else {\n+                    ExprKind::Deref { arg: self.mirror_expr(arg) }\n+                }\n             }\n-        }\n \n-        hir::ExprKind::Unary(hir::UnOp::Not, ref arg) => {\n-            if cx.typeck_results().is_method_call(expr) {\n-                overloaded_operator(cx, expr, vec![arg.to_ref()])\n-            } else {\n-                ExprKind::Unary { op: UnOp::Not, arg: arg.to_ref() }\n+            hir::ExprKind::Unary(hir::UnOp::Not, ref arg) => {\n+                if self.typeck_results().is_method_call(expr) {\n+                    let arg = self.mirror_expr_inner(arg);\n+                    self.overloaded_operator(expr, self.arena.alloc_from_iter(iter::once(arg)))\n+                } else {\n+                    ExprKind::Unary { op: UnOp::Not, arg: self.mirror_expr(arg) }\n+                }\n             }\n-        }\n \n-        hir::ExprKind::Unary(hir::UnOp::Neg, ref arg) => {\n-            if cx.typeck_results().is_method_call(expr) {\n-                overloaded_operator(cx, expr, vec![arg.to_ref()])\n-            } else if let hir::ExprKind::Lit(ref lit) = arg.kind {\n-                ExprKind::Literal {\n-                    literal: cx.const_eval_literal(&lit.node, expr_ty, lit.span, true),\n-                    user_ty: None,\n-                    const_id: None,\n+            hir::ExprKind::Unary(hir::UnOp::Neg, ref arg) => {\n+                if self.typeck_results().is_method_call(expr) {\n+                    let arg = self.mirror_expr_inner(arg);\n+                    self.overloaded_operator(expr, self.arena.alloc_from_iter(iter::once(arg)))\n+                } else if let hir::ExprKind::Lit(ref lit) = arg.kind {\n+                    ExprKind::Literal {\n+                        literal: self.const_eval_literal(&lit.node, expr_ty, lit.span, true),\n+                        user_ty: None,\n+                        const_id: None,\n+                    }\n+                } else {\n+                    ExprKind::Unary { op: UnOp::Neg, arg: self.mirror_expr(arg) }\n                 }\n-            } else {\n-                ExprKind::Unary { op: UnOp::Neg, arg: arg.to_ref() }\n             }\n-        }\n \n-        hir::ExprKind::Struct(ref qpath, ref fields, ref base) => match expr_ty.kind() {\n-            ty::Adt(adt, substs) => match adt.adt_kind() {\n-                AdtKind::Struct | AdtKind::Union => {\n-                    let user_provided_types = cx.typeck_results().user_provided_types();\n-                    let user_ty = user_provided_types.get(expr.hir_id).copied();\n-                    debug!(\"make_mirror_unadjusted: (struct/union) user_ty={:?}\", user_ty);\n-                    ExprKind::Adt {\n-                        adt_def: adt,\n-                        variant_index: VariantIdx::new(0),\n-                        substs,\n-                        user_ty,\n-                        fields: field_refs(cx, fields),\n-                        base: base.as_ref().map(|base| FruInfo {\n-                            base: base.to_ref(),\n-                            field_types: cx.typeck_results().fru_field_types()[expr.hir_id].clone(),\n-                        }),\n+            hir::ExprKind::Struct(ref qpath, ref fields, ref base) => match expr_ty.kind() {\n+                ty::Adt(adt, substs) => match adt.adt_kind() {\n+                    AdtKind::Struct | AdtKind::Union => {\n+                        let user_provided_types = self.typeck_results().user_provided_types();\n+                        let user_ty = user_provided_types.get(expr.hir_id).copied();\n+                        debug!(\"make_mirror_unadjusted: (struct/union) user_ty={:?}\", user_ty);\n+                        ExprKind::Adt {\n+                            adt_def: adt,\n+                            variant_index: VariantIdx::new(0),\n+                            substs,\n+                            user_ty,\n+                            fields: self.field_refs(fields),\n+                            base: base.as_ref().map(|base| FruInfo {\n+                                base: self.mirror_expr(base),\n+                                field_types: self.arena.alloc_from_iter(\n+                                    self.typeck_results().fru_field_types()[expr.hir_id]\n+                                        .iter()\n+                                        .cloned(),\n+                                ),\n+                            }),\n+                        }\n                     }\n-                }\n-                AdtKind::Enum => {\n-                    let res = cx.typeck_results().qpath_res(qpath, expr.hir_id);\n-                    match res {\n-                        Res::Def(DefKind::Variant, variant_id) => {\n-                            assert!(base.is_none());\n-\n-                            let index = adt.variant_index_with_id(variant_id);\n-                            let user_provided_types = cx.typeck_results().user_provided_types();\n-                            let user_ty = user_provided_types.get(expr.hir_id).copied();\n-                            debug!(\"make_mirror_unadjusted: (variant) user_ty={:?}\", user_ty);\n-                            ExprKind::Adt {\n-                                adt_def: adt,\n-                                variant_index: index,\n-                                substs,\n-                                user_ty,\n-                                fields: field_refs(cx, fields),\n-                                base: None,\n+                    AdtKind::Enum => {\n+                        let res = self.typeck_results().qpath_res(qpath, expr.hir_id);\n+                        match res {\n+                            Res::Def(DefKind::Variant, variant_id) => {\n+                                assert!(base.is_none());\n+\n+                                let index = adt.variant_index_with_id(variant_id);\n+                                let user_provided_types =\n+                                    self.typeck_results().user_provided_types();\n+                                let user_ty = user_provided_types.get(expr.hir_id).copied();\n+                                debug!(\"make_mirror_unadjusted: (variant) user_ty={:?}\", user_ty);\n+                                ExprKind::Adt {\n+                                    adt_def: adt,\n+                                    variant_index: index,\n+                                    substs,\n+                                    user_ty,\n+                                    fields: self.field_refs(fields),\n+                                    base: None,\n+                                }\n+                            }\n+                            _ => {\n+                                span_bug!(expr.span, \"unexpected res: {:?}\", res);\n                             }\n-                        }\n-                        _ => {\n-                            span_bug!(expr.span, \"unexpected res: {:?}\", res);\n                         }\n                     }\n-                }\n-            },\n-            _ => {\n-                span_bug!(expr.span, \"unexpected type for struct literal: {:?}\", expr_ty);\n-            }\n-        },\n-\n-        hir::ExprKind::Closure(..) => {\n-            let closure_ty = cx.typeck_results().expr_ty(expr);\n-            let (def_id, substs, movability) = match *closure_ty.kind() {\n-                ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs), None),\n-                ty::Generator(def_id, substs, movability) => {\n-                    (def_id, UpvarSubsts::Generator(substs), Some(movability))\n-                }\n+                },\n                 _ => {\n-                    span_bug!(expr.span, \"closure expr w/o closure type: {:?}\", closure_ty);\n+                    span_bug!(expr.span, \"unexpected type for struct literal: {:?}\", expr_ty);\n                 }\n-            };\n+            },\n \n-            let upvars = cx\n-                .typeck_results()\n-                .closure_min_captures_flattened(def_id)\n-                .zip(substs.upvar_tys())\n-                .map(|(captured_place, ty)| capture_upvar(cx, expr, captured_place, ty))\n-                .collect();\n-            ExprKind::Closure { closure_id: def_id, substs, upvars, movability }\n-        }\n+            hir::ExprKind::Closure(..) => {\n+                let closure_ty = self.typeck_results().expr_ty(expr);\n+                let (def_id, substs, movability) = match *closure_ty.kind() {\n+                    ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs), None),\n+                    ty::Generator(def_id, substs, movability) => {\n+                        (def_id, UpvarSubsts::Generator(substs), Some(movability))\n+                    }\n+                    _ => {\n+                        span_bug!(expr.span, \"closure expr w/o closure type: {:?}\", closure_ty);\n+                    }\n+                };\n \n-        hir::ExprKind::Path(ref qpath) => {\n-            let res = cx.typeck_results().qpath_res(qpath, expr.hir_id);\n-            convert_path_expr(cx, expr, res)\n-        }\n+                let upvars = self.arena.alloc_from_iter(\n+                    self.typeck_results\n+                        .closure_min_captures_flattened(def_id)\n+                        .zip(substs.upvar_tys())\n+                        .map(|(captured_place, ty)| self.capture_upvar(expr, captured_place, ty)),\n+                );\n+                ExprKind::Closure { closure_id: def_id, substs, upvars, movability }\n+            }\n+\n+            hir::ExprKind::Path(ref qpath) => {\n+                let res = self.typeck_results().qpath_res(qpath, expr.hir_id);\n+                self.convert_path_expr(expr, res)\n+            }\n \n-        hir::ExprKind::InlineAsm(ref asm) => ExprKind::InlineAsm {\n-            template: asm.template,\n-            operands: asm\n-                .operands\n-                .iter()\n-                .map(|(op, _op_sp)| {\n+            hir::ExprKind::InlineAsm(ref asm) => ExprKind::InlineAsm {\n+                template: asm.template,\n+                operands: self.arena.alloc_from_iter(asm.operands.iter().map(|(op, _op_sp)| {\n                     match *op {\n                         hir::InlineAsmOperand::In { reg, ref expr } => {\n-                            InlineAsmOperand::In { reg, expr: expr.to_ref() }\n+                            InlineAsmOperand::In { reg, expr: self.mirror_expr(expr) }\n                         }\n                         hir::InlineAsmOperand::Out { reg, late, ref expr } => {\n                             InlineAsmOperand::Out {\n                                 reg,\n                                 late,\n-                                expr: expr.as_ref().map(|expr| expr.to_ref()),\n+                                expr: expr.as_ref().map(|expr| self.mirror_expr(expr)),\n                             }\n                         }\n                         hir::InlineAsmOperand::InOut { reg, late, ref expr } => {\n-                            InlineAsmOperand::InOut { reg, late, expr: expr.to_ref() }\n+                            InlineAsmOperand::InOut { reg, late, expr: self.mirror_expr(expr) }\n                         }\n                         hir::InlineAsmOperand::SplitInOut {\n                             reg,\n@@ -431,11 +485,11 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                         } => InlineAsmOperand::SplitInOut {\n                             reg,\n                             late,\n-                            in_expr: in_expr.to_ref(),\n-                            out_expr: out_expr.as_ref().map(|expr| expr.to_ref()),\n+                            in_expr: self.mirror_expr(in_expr),\n+                            out_expr: out_expr.as_ref().map(|expr| self.mirror_expr(expr)),\n                         },\n                         hir::InlineAsmOperand::Const { ref expr } => {\n-                            InlineAsmOperand::Const { expr: expr.to_ref() }\n+                            InlineAsmOperand::Const { expr: self.mirror_expr(expr) }\n                         }\n                         hir::InlineAsmOperand::Sym { ref expr } => {\n                             let qpath = match expr.kind {\n@@ -447,25 +501,24 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                                 ),\n                             };\n                             let temp_lifetime =\n-                                cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-                            let res = cx.typeck_results().qpath_res(qpath, expr.hir_id);\n+                                self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n+                            let res = self.typeck_results().qpath_res(qpath, expr.hir_id);\n                             let ty;\n                             match res {\n                                 Res::Def(DefKind::Fn, _) | Res::Def(DefKind::AssocFn, _) => {\n-                                    ty = cx.typeck_results().node_type(expr.hir_id);\n-                                    let user_ty = user_substs_applied_to_res(cx, expr.hir_id, res);\n+                                    ty = self.typeck_results().node_type(expr.hir_id);\n+                                    let user_ty = self.user_substs_applied_to_res(expr.hir_id, res);\n                                     InlineAsmOperand::SymFn {\n-                                        expr: Expr {\n+                                        expr: self.arena.alloc(Expr {\n                                             ty,\n                                             temp_lifetime,\n                                             span: expr.span,\n                                             kind: ExprKind::Literal {\n-                                                literal: ty::Const::zero_sized(cx.tcx, ty),\n+                                                literal: ty::Const::zero_sized(self.tcx, ty),\n                                                 user_ty,\n                                                 const_id: None,\n                                             },\n-                                        }\n-                                        .to_ref(),\n+                                        }),\n                                     }\n                                 }\n \n@@ -474,277 +527,568 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                                 }\n \n                                 _ => {\n-                                    cx.tcx.sess.span_err(\n+                                    self.tcx.sess.span_err(\n                                         expr.span,\n                                         \"asm `sym` operand must point to a fn or static\",\n                                     );\n \n                                     // Not a real fn, but we're not reaching codegen anyways...\n-                                    ty = cx.tcx.ty_error();\n+                                    ty = self.tcx.ty_error();\n                                     InlineAsmOperand::SymFn {\n-                                        expr: Expr {\n+                                        expr: self.arena.alloc(Expr {\n                                             ty,\n                                             temp_lifetime,\n                                             span: expr.span,\n                                             kind: ExprKind::Literal {\n-                                                literal: ty::Const::zero_sized(cx.tcx, ty),\n+                                                literal: ty::Const::zero_sized(self.tcx, ty),\n                                                 user_ty: None,\n                                                 const_id: None,\n                                             },\n-                                        }\n-                                        .to_ref(),\n+                                        }),\n                                     }\n                                 }\n                             }\n                         }\n                     }\n-                })\n-                .collect(),\n-            options: asm.options,\n-            line_spans: asm.line_spans,\n-        },\n-\n-        hir::ExprKind::LlvmInlineAsm(ref asm) => ExprKind::LlvmInlineAsm {\n-            asm: &asm.inner,\n-            outputs: asm.outputs_exprs.to_ref(),\n-            inputs: asm.inputs_exprs.to_ref(),\n-        },\n-\n-        hir::ExprKind::ConstBlock(ref anon_const) => {\n-            let anon_const_def_id = cx.tcx.hir().local_def_id(anon_const.hir_id);\n-            let value = ty::Const::from_anon_const(cx.tcx, anon_const_def_id);\n-\n-            ExprKind::ConstBlock { value }\n-        }\n-        // Now comes the rote stuff:\n-        hir::ExprKind::Repeat(ref v, ref count) => {\n-            let count_def_id = cx.tcx.hir().local_def_id(count.hir_id);\n-            let count = ty::Const::from_anon_const(cx.tcx, count_def_id);\n+                })),\n+                options: asm.options,\n+                line_spans: asm.line_spans,\n+            },\n \n-            ExprKind::Repeat { value: v.to_ref(), count }\n-        }\n-        hir::ExprKind::Ret(ref v) => ExprKind::Return { value: v.to_ref() },\n-        hir::ExprKind::Break(dest, ref value) => match dest.target_id {\n-            Ok(target_id) => ExprKind::Break {\n-                label: region::Scope { id: target_id.local_id, data: region::ScopeData::Node },\n-                value: value.to_ref(),\n+            hir::ExprKind::LlvmInlineAsm(ref asm) => ExprKind::LlvmInlineAsm {\n+                asm: &asm.inner,\n+                outputs: self.mirror_exprs(asm.outputs_exprs),\n+                inputs: self.mirror_exprs(asm.inputs_exprs),\n             },\n-            Err(err) => bug!(\"invalid loop id for break: {}\", err),\n-        },\n-        hir::ExprKind::Continue(dest) => match dest.target_id {\n-            Ok(loop_id) => ExprKind::Continue {\n-                label: region::Scope { id: loop_id.local_id, data: region::ScopeData::Node },\n+\n+            hir::ExprKind::ConstBlock(ref anon_const) => {\n+                let anon_const_def_id = self.tcx.hir().local_def_id(anon_const.hir_id);\n+                let value = ty::Const::from_anon_const(self.tcx, anon_const_def_id);\n+\n+                ExprKind::ConstBlock { value }\n+            }\n+            // Now comes the rote stuff:\n+            hir::ExprKind::Repeat(ref v, ref count) => {\n+                let count_def_id = self.tcx.hir().local_def_id(count.hir_id);\n+                let count = ty::Const::from_anon_const(self.tcx, count_def_id);\n+\n+                ExprKind::Repeat { value: self.mirror_expr(v), count }\n+            }\n+            hir::ExprKind::Ret(ref v) => {\n+                ExprKind::Return { value: v.as_ref().map(|v| self.mirror_expr(v)) }\n+            }\n+            hir::ExprKind::Break(dest, ref value) => match dest.target_id {\n+                Ok(target_id) => ExprKind::Break {\n+                    label: region::Scope { id: target_id.local_id, data: region::ScopeData::Node },\n+                    value: value.as_ref().map(|value| self.mirror_expr(value)),\n+                },\n+                Err(err) => bug!(\"invalid loop id for break: {}\", err),\n             },\n-            Err(err) => bug!(\"invalid loop id for continue: {}\", err),\n-        },\n-        hir::ExprKind::If(cond, then, else_opt) => ExprKind::If {\n-            cond: cond.to_ref(),\n-            then: then.to_ref(),\n-            else_opt: else_opt.map(|el| el.to_ref()),\n-        },\n-        hir::ExprKind::Match(ref discr, ref arms, _) => ExprKind::Match {\n-            scrutinee: discr.to_ref(),\n-            arms: arms.iter().map(|a| convert_arm(cx, a)).collect(),\n-        },\n-        hir::ExprKind::Loop(ref body, ..) => ExprKind::Loop { body: block::to_expr_ref(cx, body) },\n-        hir::ExprKind::Field(ref source, ..) => ExprKind::Field {\n-            lhs: source.to_ref(),\n-            name: Field::new(cx.tcx.field_index(expr.hir_id, cx.typeck_results)),\n-        },\n-        hir::ExprKind::Cast(ref source, ref cast_ty) => {\n-            // Check for a user-given type annotation on this `cast`\n-            let user_provided_types = cx.typeck_results.user_provided_types();\n-            let user_ty = user_provided_types.get(cast_ty.hir_id);\n-\n-            debug!(\n-                \"cast({:?}) has ty w/ hir_id {:?} and user provided ty {:?}\",\n-                expr, cast_ty.hir_id, user_ty,\n-            );\n-\n-            // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n-            // using a coercion (or is a no-op).\n-            let cast = if cx.typeck_results().is_coercion_cast(source.hir_id) {\n-                // Convert the lexpr to a vexpr.\n-                ExprKind::Use { source: source.to_ref() }\n-            } else if cx.typeck_results().expr_ty(source).is_region_ptr() {\n-                // Special cased so that we can type check that the element\n-                // type of the source matches the pointed to type of the\n-                // destination.\n-                ExprKind::Pointer { source: source.to_ref(), cast: PointerCast::ArrayToPointer }\n-            } else {\n-                // check whether this is casting an enum variant discriminant\n-                // to prevent cycles, we refer to the discriminant initializer\n-                // which is always an integer and thus doesn't need to know the\n-                // enum's layout (or its tag type) to compute it during const eval\n-                // Example:\n-                // enum Foo {\n-                //     A,\n-                //     B = A as isize + 4,\n-                // }\n-                // The correct solution would be to add symbolic computations to miri,\n-                // so we wouldn't have to compute and store the actual value\n-                let var = if let hir::ExprKind::Path(ref qpath) = source.kind {\n-                    let res = cx.typeck_results().qpath_res(qpath, source.hir_id);\n-                    cx.typeck_results().node_type(source.hir_id).ty_adt_def().and_then(|adt_def| {\n-                        match res {\n-                            Res::Def(\n-                                DefKind::Ctor(CtorOf::Variant, CtorKind::Const),\n-                                variant_ctor_id,\n-                            ) => {\n-                                let idx = adt_def.variant_index_with_ctor_id(variant_ctor_id);\n-                                let (d, o) = adt_def.discriminant_def_for_variant(idx);\n-                                use rustc_middle::ty::util::IntTypeExt;\n-                                let ty = adt_def.repr.discr_type();\n-                                let ty = ty.to_ty(cx.tcx());\n-                                Some((d, o, ty))\n-                            }\n-                            _ => None,\n-                        }\n-                    })\n+            hir::ExprKind::Continue(dest) => match dest.target_id {\n+                Ok(loop_id) => ExprKind::Continue {\n+                    label: region::Scope { id: loop_id.local_id, data: region::ScopeData::Node },\n+                },\n+                Err(err) => bug!(\"invalid loop id for continue: {}\", err),\n+            },\n+            hir::ExprKind::If(cond, then, else_opt) => ExprKind::If {\n+                cond: self.mirror_expr(cond),\n+                then: self.mirror_expr(then),\n+                else_opt: else_opt.map(|el| self.mirror_expr(el)),\n+            },\n+            hir::ExprKind::Match(ref discr, ref arms, _) => ExprKind::Match {\n+                scrutinee: self.mirror_expr(discr),\n+                arms: self.arena.alloc_from_iter(arms.iter().map(|a| self.convert_arm(a))),\n+            },\n+            hir::ExprKind::Loop(ref body, ..) => {\n+                let block_ty = self.typeck_results().node_type(body.hir_id);\n+                let temp_lifetime = self.region_scope_tree.temporary_scope(body.hir_id.local_id);\n+                let block = self.mirror_block(body);\n+                let body = self.arena.alloc(Expr {\n+                    ty: block_ty,\n+                    temp_lifetime,\n+                    span: block.span,\n+                    kind: ExprKind::Block { body: block },\n+                });\n+                ExprKind::Loop { body }\n+            }\n+            hir::ExprKind::Field(ref source, ..) => ExprKind::Field {\n+                lhs: self.mirror_expr(source),\n+                name: Field::new(self.tcx.field_index(expr.hir_id, self.typeck_results)),\n+            },\n+            hir::ExprKind::Cast(ref source, ref cast_ty) => {\n+                // Check for a user-given type annotation on this `cast`\n+                let user_provided_types = self.typeck_results.user_provided_types();\n+                let user_ty = user_provided_types.get(cast_ty.hir_id);\n+\n+                debug!(\n+                    \"cast({:?}) has ty w/ hir_id {:?} and user provided ty {:?}\",\n+                    expr, cast_ty.hir_id, user_ty,\n+                );\n+\n+                // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n+                // using a coercion (or is a no-op).\n+                let cast = if self.typeck_results().is_coercion_cast(source.hir_id) {\n+                    // Convert the lexpr to a vexpr.\n+                    ExprKind::Use { source: self.mirror_expr(source) }\n+                } else if self.typeck_results().expr_ty(source).is_region_ptr() {\n+                    // Special cased so that we can type check that the element\n+                    // type of the source matches the pointed to type of the\n+                    // destination.\n+                    ExprKind::Pointer {\n+                        source: self.mirror_expr(source),\n+                        cast: PointerCast::ArrayToPointer,\n+                    }\n                 } else {\n-                    None\n-                };\n-\n-                let source = if let Some((did, offset, var_ty)) = var {\n-                    let mk_const = |literal| {\n-                        Expr {\n-                            temp_lifetime,\n-                            ty: var_ty,\n-                            span: expr.span,\n-                            kind: ExprKind::Literal { literal, user_ty: None, const_id: None },\n-                        }\n-                        .to_ref()\n+                    // check whether this is casting an enum variant discriminant\n+                    // to prevent cycles, we refer to the discriminant initializer\n+                    // which is always an integer and thus doesn't need to know the\n+                    // enum's layout (or its tag type) to compute it during const eval\n+                    // Example:\n+                    // enum Foo {\n+                    //     A,\n+                    //     B = A as isize + 4,\n+                    // }\n+                    // The correct solution would be to add symbolic computations to miri,\n+                    // so we wouldn't have to compute and store the actual value\n+                    let var = if let hir::ExprKind::Path(ref qpath) = source.kind {\n+                        let res = self.typeck_results().qpath_res(qpath, source.hir_id);\n+                        self.typeck_results().node_type(source.hir_id).ty_adt_def().and_then(\n+                            |adt_def| match res {\n+                                Res::Def(\n+                                    DefKind::Ctor(CtorOf::Variant, CtorKind::Const),\n+                                    variant_ctor_id,\n+                                ) => {\n+                                    let idx = adt_def.variant_index_with_ctor_id(variant_ctor_id);\n+                                    let (d, o) = adt_def.discriminant_def_for_variant(idx);\n+                                    use rustc_middle::ty::util::IntTypeExt;\n+                                    let ty = adt_def.repr.discr_type();\n+                                    let ty = ty.to_ty(self.tcx());\n+                                    Some((d, o, ty))\n+                                }\n+                                _ => None,\n+                            },\n+                        )\n+                    } else {\n+                        None\n                     };\n-                    let offset = mk_const(ty::Const::from_bits(\n-                        cx.tcx,\n-                        offset as u128,\n-                        cx.param_env.and(var_ty),\n-                    ));\n-                    match did {\n-                        Some(did) => {\n-                            // in case we are offsetting from a computed discriminant\n-                            // and not the beginning of discriminants (which is always `0`)\n-                            let substs = InternalSubsts::identity_for_item(cx.tcx(), did);\n-                            let lhs = mk_const(cx.tcx().mk_const(ty::Const {\n-                                val: ty::ConstKind::Unevaluated(\n-                                    ty::WithOptConstParam::unknown(did),\n-                                    substs,\n-                                    None,\n-                                ),\n+\n+                    let source = if let Some((did, offset, var_ty)) = var {\n+                        let mk_const = |literal| {\n+                            self.arena.alloc(Expr {\n+                                temp_lifetime,\n                                 ty: var_ty,\n-                            }));\n-                            let bin = ExprKind::Binary { op: BinOp::Add, lhs, rhs: offset };\n-                            Expr { temp_lifetime, ty: var_ty, span: expr.span, kind: bin }.to_ref()\n+                                span: expr.span,\n+                                kind: ExprKind::Literal { literal, user_ty: None, const_id: None },\n+                            })\n+                        };\n+                        let offset = mk_const(ty::Const::from_bits(\n+                            self.tcx,\n+                            offset as u128,\n+                            self.param_env.and(var_ty),\n+                        ));\n+                        match did {\n+                            Some(did) => {\n+                                // in case we are offsetting from a computed discriminant\n+                                // and not the beginning of discriminants (which is always `0`)\n+                                let substs = InternalSubsts::identity_for_item(self.tcx(), did);\n+                                let lhs = mk_const(self.tcx().mk_const(ty::Const {\n+                                    val: ty::ConstKind::Unevaluated(\n+                                        ty::WithOptConstParam::unknown(did),\n+                                        substs,\n+                                        None,\n+                                    ),\n+                                    ty: var_ty,\n+                                }));\n+                                let bin =\n+                                    ExprKind::Binary { op: BinOp::Add, lhs: lhs, rhs: offset };\n+                                self.arena.alloc(Expr {\n+                                    temp_lifetime,\n+                                    ty: var_ty,\n+                                    span: expr.span,\n+                                    kind: bin,\n+                                })\n+                            }\n+                            None => offset,\n                         }\n-                        None => offset,\n-                    }\n-                } else {\n-                    source.to_ref()\n-                };\n+                    } else {\n+                        self.mirror_expr(source)\n+                    };\n \n-                ExprKind::Cast { source }\n-            };\n+                    ExprKind::Cast { source: source }\n+                };\n \n-            if let Some(user_ty) = user_ty {\n-                // NOTE: Creating a new Expr and wrapping a Cast inside of it may be\n-                //       inefficient, revisit this when performance becomes an issue.\n-                let cast_expr = Expr { temp_lifetime, ty: expr_ty, span: expr.span, kind: cast };\n-                debug!(\"make_mirror_unadjusted: (cast) user_ty={:?}\", user_ty);\n+                if let Some(user_ty) = user_ty {\n+                    // NOTE: Creating a new Expr and wrapping a Cast inside of it may be\n+                    //       inefficient, revisit this when performance becomes an issue.\n+                    let cast_expr = self.arena.alloc(Expr {\n+                        temp_lifetime,\n+                        ty: expr_ty,\n+                        span: expr.span,\n+                        kind: cast,\n+                    });\n+                    debug!(\"make_mirror_unadjusted: (cast) user_ty={:?}\", user_ty);\n \n-                ExprKind::ValueTypeAscription {\n-                    source: cast_expr.to_ref(),\n-                    user_ty: Some(*user_ty),\n+                    ExprKind::ValueTypeAscription { source: cast_expr, user_ty: Some(*user_ty) }\n+                } else {\n+                    cast\n                 }\n-            } else {\n-                cast\n             }\n-        }\n-        hir::ExprKind::Type(ref source, ref ty) => {\n-            let user_provided_types = cx.typeck_results.user_provided_types();\n-            let user_ty = user_provided_types.get(ty.hir_id).copied();\n-            debug!(\"make_mirror_unadjusted: (type) user_ty={:?}\", user_ty);\n-            if source.is_syntactic_place_expr() {\n-                ExprKind::PlaceTypeAscription { source: source.to_ref(), user_ty }\n-            } else {\n-                ExprKind::ValueTypeAscription { source: source.to_ref(), user_ty }\n+            hir::ExprKind::Type(ref source, ref ty) => {\n+                let user_provided_types = self.typeck_results.user_provided_types();\n+                let user_ty = user_provided_types.get(ty.hir_id).copied();\n+                debug!(\"make_mirror_unadjusted: (type) user_ty={:?}\", user_ty);\n+                let mirrored = self.mirror_expr(source);\n+                if source.is_syntactic_place_expr() {\n+                    ExprKind::PlaceTypeAscription { source: mirrored, user_ty }\n+                } else {\n+                    ExprKind::ValueTypeAscription { source: mirrored, user_ty }\n+                }\n+            }\n+            hir::ExprKind::DropTemps(ref source) => {\n+                ExprKind::Use { source: self.mirror_expr(source) }\n+            }\n+            hir::ExprKind::Box(ref value) => ExprKind::Box { value: self.mirror_expr(value) },\n+            hir::ExprKind::Array(ref fields) => {\n+                ExprKind::Array { fields: self.mirror_exprs(fields) }\n             }\n+            hir::ExprKind::Tup(ref fields) => ExprKind::Tuple { fields: self.mirror_exprs(fields) },\n+\n+            hir::ExprKind::Yield(ref v, _) => ExprKind::Yield { value: self.mirror_expr(v) },\n+            hir::ExprKind::Err => unreachable!(),\n+        };\n+\n+        Expr { temp_lifetime, ty: expr_ty, span: expr.span, kind }\n+    }\n+\n+    fn user_substs_applied_to_res(\n+        &mut self,\n+        hir_id: hir::HirId,\n+        res: Res,\n+    ) -> Option<ty::CanonicalUserType<'tcx>> {\n+        debug!(\"user_substs_applied_to_res: res={:?}\", res);\n+        let user_provided_type = match res {\n+            // A reference to something callable -- e.g., a fn, method, or\n+            // a tuple-struct or tuple-variant. This has the type of a\n+            // `Fn` but with the user-given substitutions.\n+            Res::Def(DefKind::Fn, _)\n+            | Res::Def(DefKind::AssocFn, _)\n+            | Res::Def(DefKind::Ctor(_, CtorKind::Fn), _)\n+            | Res::Def(DefKind::Const, _)\n+            | Res::Def(DefKind::AssocConst, _) => {\n+                self.typeck_results().user_provided_types().get(hir_id).copied()\n+            }\n+\n+            // A unit struct/variant which is used as a value (e.g.,\n+            // `None`). This has the type of the enum/struct that defines\n+            // this variant -- but with the substitutions given by the\n+            // user.\n+            Res::Def(DefKind::Ctor(_, CtorKind::Const), _) => {\n+                self.user_substs_applied_to_ty_of_hir_id(hir_id)\n+            }\n+\n+            // `Self` is used in expression as a tuple struct constructor or an unit struct constructor\n+            Res::SelfCtor(_) => self.user_substs_applied_to_ty_of_hir_id(hir_id),\n+\n+            _ => bug!(\"user_substs_applied_to_res: unexpected res {:?} at {:?}\", res, hir_id),\n+        };\n+        debug!(\"user_substs_applied_to_res: user_provided_type={:?}\", user_provided_type);\n+        user_provided_type\n+    }\n+\n+    fn method_callee(\n+        &mut self,\n+        expr: &hir::Expr<'_>,\n+        span: Span,\n+        overloaded_callee: Option<(DefId, SubstsRef<'tcx>)>,\n+    ) -> Expr<'thir, 'tcx> {\n+        let temp_lifetime = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n+        let (def_id, substs, user_ty) = match overloaded_callee {\n+            Some((def_id, substs)) => (def_id, substs, None),\n+            None => {\n+                let (kind, def_id) =\n+                    self.typeck_results().type_dependent_def(expr.hir_id).unwrap_or_else(|| {\n+                        span_bug!(expr.span, \"no type-dependent def for method callee\")\n+                    });\n+                let user_ty = self.user_substs_applied_to_res(expr.hir_id, Res::Def(kind, def_id));\n+                debug!(\"method_callee: user_ty={:?}\", user_ty);\n+                (def_id, self.typeck_results().node_substs(expr.hir_id), user_ty)\n+            }\n+        };\n+        let ty = self.tcx().mk_fn_def(def_id, substs);\n+        Expr {\n+            temp_lifetime,\n+            ty,\n+            span,\n+            kind: ExprKind::Literal {\n+                literal: ty::Const::zero_sized(self.tcx(), ty),\n+                user_ty,\n+                const_id: None,\n+            },\n+        }\n+    }\n+\n+    fn convert_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) -> Arm<'thir, 'tcx> {\n+        Arm {\n+            pattern: self.pattern_from_hir(&arm.pat),\n+            guard: arm.guard.as_ref().map(|g| match g {\n+                hir::Guard::If(ref e) => Guard::If(self.mirror_expr(e)),\n+                hir::Guard::IfLet(ref pat, ref e) => {\n+                    Guard::IfLet(self.pattern_from_hir(pat), self.mirror_expr(e))\n+                }\n+            }),\n+            body: self.mirror_expr(arm.body),\n+            lint_level: LintLevel::Explicit(arm.hir_id),\n+            scope: region::Scope { id: arm.hir_id.local_id, data: region::ScopeData::Node },\n+            span: arm.span,\n         }\n-        hir::ExprKind::DropTemps(ref source) => ExprKind::Use { source: source.to_ref() },\n-        hir::ExprKind::Box(ref value) => ExprKind::Box { value: value.to_ref() },\n-        hir::ExprKind::Array(ref fields) => ExprKind::Array { fields: fields.to_ref() },\n-        hir::ExprKind::Tup(ref fields) => ExprKind::Tuple { fields: fields.to_ref() },\n+    }\n \n-        hir::ExprKind::Yield(ref v, _) => ExprKind::Yield { value: v.to_ref() },\n-        hir::ExprKind::Err => unreachable!(),\n-    };\n+    fn convert_path_expr(\n+        &mut self,\n+        expr: &'tcx hir::Expr<'tcx>,\n+        res: Res,\n+    ) -> ExprKind<'thir, 'tcx> {\n+        let substs = self.typeck_results().node_substs(expr.hir_id);\n+        match res {\n+            // A regular function, constructor function or a constant.\n+            Res::Def(DefKind::Fn, _)\n+            | Res::Def(DefKind::AssocFn, _)\n+            | Res::Def(DefKind::Ctor(_, CtorKind::Fn), _)\n+            | Res::SelfCtor(..) => {\n+                let user_ty = self.user_substs_applied_to_res(expr.hir_id, res);\n+                debug!(\"convert_path_expr: user_ty={:?}\", user_ty);\n+                ExprKind::Literal {\n+                    literal: ty::Const::zero_sized(\n+                        self.tcx,\n+                        self.typeck_results().node_type(expr.hir_id),\n+                    ),\n+                    user_ty,\n+                    const_id: None,\n+                }\n+            }\n \n-    Expr { temp_lifetime, ty: expr_ty, span: expr.span, kind }\n-}\n+            Res::Def(DefKind::ConstParam, def_id) => {\n+                let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+                let item_id = self.tcx.hir().get_parent_node(hir_id);\n+                let item_def_id = self.tcx.hir().local_def_id(item_id);\n+                let generics = self.tcx.generics_of(item_def_id);\n+                let index = generics.param_def_id_to_index[&def_id];\n+                let name = self.tcx.hir().name(hir_id);\n+                let val = ty::ConstKind::Param(ty::ParamConst::new(index, name));\n+                ExprKind::Literal {\n+                    literal: self.tcx.mk_const(ty::Const {\n+                        val,\n+                        ty: self.typeck_results().node_type(expr.hir_id),\n+                    }),\n+                    user_ty: None,\n+                    const_id: Some(def_id),\n+                }\n+            }\n+\n+            Res::Def(DefKind::Const, def_id) | Res::Def(DefKind::AssocConst, def_id) => {\n+                let user_ty = self.user_substs_applied_to_res(expr.hir_id, res);\n+                debug!(\"convert_path_expr: (const) user_ty={:?}\", user_ty);\n+                ExprKind::Literal {\n+                    literal: self.tcx.mk_const(ty::Const {\n+                        val: ty::ConstKind::Unevaluated(\n+                            ty::WithOptConstParam::unknown(def_id),\n+                            substs,\n+                            None,\n+                        ),\n+                        ty: self.typeck_results().node_type(expr.hir_id),\n+                    }),\n+                    user_ty,\n+                    const_id: Some(def_id),\n+                }\n+            }\n \n-fn user_substs_applied_to_res<'tcx>(\n-    cx: &mut Cx<'_, 'tcx>,\n-    hir_id: hir::HirId,\n-    res: Res,\n-) -> Option<ty::CanonicalUserType<'tcx>> {\n-    debug!(\"user_substs_applied_to_res: res={:?}\", res);\n-    let user_provided_type = match res {\n-        // A reference to something callable -- e.g., a fn, method, or\n-        // a tuple-struct or tuple-variant. This has the type of a\n-        // `Fn` but with the user-given substitutions.\n-        Res::Def(DefKind::Fn, _)\n-        | Res::Def(DefKind::AssocFn, _)\n-        | Res::Def(DefKind::Ctor(_, CtorKind::Fn), _)\n-        | Res::Def(DefKind::Const, _)\n-        | Res::Def(DefKind::AssocConst, _) => {\n-            cx.typeck_results().user_provided_types().get(hir_id).copied()\n+            Res::Def(DefKind::Ctor(_, CtorKind::Const), def_id) => {\n+                let user_provided_types = self.typeck_results.user_provided_types();\n+                let user_provided_type = user_provided_types.get(expr.hir_id).copied();\n+                debug!(\"convert_path_expr: user_provided_type={:?}\", user_provided_type);\n+                let ty = self.typeck_results().node_type(expr.hir_id);\n+                match ty.kind() {\n+                    // A unit struct/variant which is used as a value.\n+                    // We return a completely different ExprKind here to account for this special case.\n+                    ty::Adt(adt_def, substs) => ExprKind::Adt {\n+                        adt_def,\n+                        variant_index: adt_def.variant_index_with_ctor_id(def_id),\n+                        substs,\n+                        user_ty: user_provided_type,\n+                        fields: self.arena.alloc_from_iter(iter::empty()),\n+                        base: None,\n+                    },\n+                    _ => bug!(\"unexpected ty: {:?}\", ty),\n+                }\n+            }\n+\n+            // We encode uses of statics as a `*&STATIC` where the `&STATIC` part is\n+            // a constant reference (or constant raw pointer for `static mut`) in MIR\n+            Res::Def(DefKind::Static, id) => {\n+                let ty = self.tcx.static_ptr_ty(id);\n+                let temp_lifetime = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n+                let kind = if self.tcx.is_thread_local_static(id) {\n+                    ExprKind::ThreadLocalRef(id)\n+                } else {\n+                    let ptr = self.tcx.create_static_alloc(id);\n+                    ExprKind::StaticRef {\n+                        literal: ty::Const::from_scalar(self.tcx, Scalar::Ptr(ptr.into()), ty),\n+                        def_id: id,\n+                    }\n+                };\n+                ExprKind::Deref {\n+                    arg: self.arena.alloc(Expr { ty, temp_lifetime, span: expr.span, kind }),\n+                }\n+            }\n+\n+            Res::Local(var_hir_id) => self.convert_var(var_hir_id),\n+\n+            _ => span_bug!(expr.span, \"res `{:?}` not yet implemented\", res),\n         }\n+    }\n \n-        // A unit struct/variant which is used as a value (e.g.,\n-        // `None`). This has the type of the enum/struct that defines\n-        // this variant -- but with the substitutions given by the\n-        // user.\n-        Res::Def(DefKind::Ctor(_, CtorKind::Const), _) => {\n-            cx.user_substs_applied_to_ty_of_hir_id(hir_id)\n+    fn convert_var(&mut self, var_hir_id: hir::HirId) -> ExprKind<'thir, 'tcx> {\n+        // We want upvars here not captures.\n+        // Captures will be handled in MIR.\n+        let is_upvar = self\n+            .tcx\n+            .upvars_mentioned(self.body_owner)\n+            .map_or(false, |upvars| upvars.contains_key(&var_hir_id));\n+\n+        debug!(\n+            \"convert_var({:?}): is_upvar={}, body_owner={:?}\",\n+            var_hir_id, is_upvar, self.body_owner\n+        );\n+\n+        if is_upvar {\n+            ExprKind::UpvarRef { closure_def_id: self.body_owner, var_hir_id }\n+        } else {\n+            ExprKind::VarRef { id: var_hir_id }\n         }\n+    }\n \n-        // `Self` is used in expression as a tuple struct constructor or an unit struct constructor\n-        Res::SelfCtor(_) => cx.user_substs_applied_to_ty_of_hir_id(hir_id),\n+    fn overloaded_operator(\n+        &mut self,\n+        expr: &'tcx hir::Expr<'tcx>,\n+        args: &'thir [Expr<'thir, 'tcx>],\n+    ) -> ExprKind<'thir, 'tcx> {\n+        let fun = self.arena.alloc(self.method_callee(expr, expr.span, None));\n+        ExprKind::Call { ty: fun.ty, fun, args, from_hir_call: false, fn_span: expr.span }\n+    }\n \n-        _ => bug!(\"user_substs_applied_to_res: unexpected res {:?} at {:?}\", res, hir_id),\n-    };\n-    debug!(\"user_substs_applied_to_res: user_provided_type={:?}\", user_provided_type);\n-    user_provided_type\n-}\n+    fn overloaded_place(\n+        &mut self,\n+        expr: &'tcx hir::Expr<'tcx>,\n+        place_ty: Ty<'tcx>,\n+        overloaded_callee: Option<(DefId, SubstsRef<'tcx>)>,\n+        args: &'thir [Expr<'thir, 'tcx>],\n+        span: Span,\n+    ) -> ExprKind<'thir, 'tcx> {\n+        // For an overloaded *x or x[y] expression of type T, the method\n+        // call returns an &T and we must add the deref so that the types\n+        // line up (this is because `*x` and `x[y]` represent places):\n+\n+        // Reconstruct the output assuming it's a reference with the\n+        // same region and mutability as the receiver. This holds for\n+        // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n+        let (region, mutbl) = match *args[0].ty.kind() {\n+            ty::Ref(region, _, mutbl) => (region, mutbl),\n+            _ => span_bug!(span, \"overloaded_place: receiver is not a reference\"),\n+        };\n+        let ref_ty = self.tcx.mk_ref(region, ty::TypeAndMut { ty: place_ty, mutbl });\n+\n+        // construct the complete expression `foo()` for the overloaded call,\n+        // which will yield the &T type\n+        let temp_lifetime = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n+        let fun = self.arena.alloc(self.method_callee(expr, span, overloaded_callee));\n+        let ref_expr = self.arena.alloc(Expr {\n+            temp_lifetime,\n+            ty: ref_ty,\n+            span,\n+            kind: ExprKind::Call { ty: fun.ty, fun, args, from_hir_call: false, fn_span: span },\n+        });\n \n-fn method_callee<'a, 'tcx>(\n-    cx: &mut Cx<'a, 'tcx>,\n-    expr: &hir::Expr<'_>,\n-    span: Span,\n-    overloaded_callee: Option<(DefId, SubstsRef<'tcx>)>,\n-) -> Expr<'tcx> {\n-    let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-    let (def_id, substs, user_ty) = match overloaded_callee {\n-        Some((def_id, substs)) => (def_id, substs, None),\n-        None => {\n-            let (kind, def_id) = cx\n-                .typeck_results()\n-                .type_dependent_def(expr.hir_id)\n-                .unwrap_or_else(|| span_bug!(expr.span, \"no type-dependent def for method callee\"));\n-            let user_ty = user_substs_applied_to_res(cx, expr.hir_id, Res::Def(kind, def_id));\n-            debug!(\"method_callee: user_ty={:?}\", user_ty);\n-            (def_id, cx.typeck_results().node_substs(expr.hir_id), user_ty)\n+        // construct and return a deref wrapper `*foo()`\n+        ExprKind::Deref { arg: ref_expr }\n+    }\n+\n+    fn capture_upvar(\n+        &mut self,\n+        closure_expr: &'tcx hir::Expr<'tcx>,\n+        captured_place: &'tcx ty::CapturedPlace<'tcx>,\n+        upvar_ty: Ty<'tcx>,\n+    ) -> Expr<'thir, 'tcx> {\n+        let upvar_capture = captured_place.info.capture_kind;\n+        let temp_lifetime = self.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n+        let var_ty = captured_place.place.base_ty;\n+\n+        // The result of capture analysis in `rustc_typeck/check/upvar.rs`represents a captured path\n+        // as it's seen for use within the closure and not at the time of closure creation.\n+        //\n+        // That is we see expect to see it start from a captured upvar and not something that is local\n+        // to the closure's parent.\n+        let var_hir_id = match captured_place.place.base {\n+            HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n+            base => bug!(\"Expected an upvar, found {:?}\", base),\n+        };\n+\n+        let mut captured_place_expr = Expr {\n+            temp_lifetime,\n+            ty: var_ty,\n+            span: closure_expr.span,\n+            kind: self.convert_var(var_hir_id),\n+        };\n+\n+        for proj in captured_place.place.projections.iter() {\n+            let kind = match proj.kind {\n+                HirProjectionKind::Deref => {\n+                    ExprKind::Deref { arg: self.arena.alloc(captured_place_expr) }\n+                }\n+                HirProjectionKind::Field(field, ..) => {\n+                    // Variant index will always be 0, because for multi-variant\n+                    // enums, we capture the enum entirely.\n+                    ExprKind::Field {\n+                        lhs: self.arena.alloc(captured_place_expr),\n+                        name: Field::new(field as usize),\n+                    }\n+                }\n+                HirProjectionKind::Index | HirProjectionKind::Subslice => {\n+                    // We don't capture these projections, so we can ignore them here\n+                    continue;\n+                }\n+            };\n+\n+            captured_place_expr =\n+                Expr { temp_lifetime, ty: proj.ty, span: closure_expr.span, kind };\n+        }\n+\n+        match upvar_capture {\n+            ty::UpvarCapture::ByValue(_) => captured_place_expr,\n+            ty::UpvarCapture::ByRef(upvar_borrow) => {\n+                let borrow_kind = match upvar_borrow.kind {\n+                    ty::BorrowKind::ImmBorrow => BorrowKind::Shared,\n+                    ty::BorrowKind::UniqueImmBorrow => BorrowKind::Unique,\n+                    ty::BorrowKind::MutBorrow => BorrowKind::Mut { allow_two_phase_borrow: false },\n+                };\n+                Expr {\n+                    temp_lifetime,\n+                    ty: upvar_ty,\n+                    span: closure_expr.span,\n+                    kind: ExprKind::Borrow {\n+                        borrow_kind,\n+                        arg: self.arena.alloc(captured_place_expr),\n+                    },\n+                }\n+            }\n         }\n-    };\n-    let ty = cx.tcx().mk_fn_def(def_id, substs);\n-    Expr {\n-        temp_lifetime,\n-        ty,\n-        span,\n-        kind: ExprKind::Literal {\n-            literal: ty::Const::zero_sized(cx.tcx(), ty),\n-            user_ty,\n-            const_id: None,\n-        },\n+    }\n+\n+    /// Converts a list of named fields (i.e., for struct-like struct/enum ADTs) into FieldExpr.\n+    fn field_refs(&mut self, fields: &'tcx [hir::Field<'tcx>]) -> &'thir [FieldExpr<'thir, 'tcx>] {\n+        self.arena.alloc_from_iter(fields.iter().map(|field| FieldExpr {\n+            name: Field::new(self.tcx.field_index(field.hir_id, self.typeck_results)),\n+            expr: self.mirror_expr(field.expr),\n+        }))\n     }\n }\n \n@@ -776,135 +1120,6 @@ impl ToBorrowKind for hir::Mutability {\n     }\n }\n \n-fn convert_arm<'tcx>(cx: &mut Cx<'_, 'tcx>, arm: &'tcx hir::Arm<'tcx>) -> Arm<'tcx> {\n-    Arm {\n-        pattern: cx.pattern_from_hir(&arm.pat),\n-        guard: arm.guard.as_ref().map(|g| match g {\n-            hir::Guard::If(ref e) => Guard::If(e.to_ref()),\n-            hir::Guard::IfLet(ref pat, ref e) => Guard::IfLet(cx.pattern_from_hir(pat), e.to_ref()),\n-        }),\n-        body: arm.body.to_ref(),\n-        lint_level: LintLevel::Explicit(arm.hir_id),\n-        scope: region::Scope { id: arm.hir_id.local_id, data: region::ScopeData::Node },\n-        span: arm.span,\n-    }\n-}\n-\n-fn convert_path_expr<'a, 'tcx>(\n-    cx: &mut Cx<'a, 'tcx>,\n-    expr: &'tcx hir::Expr<'tcx>,\n-    res: Res,\n-) -> ExprKind<'tcx> {\n-    let substs = cx.typeck_results().node_substs(expr.hir_id);\n-    match res {\n-        // A regular function, constructor function or a constant.\n-        Res::Def(DefKind::Fn, _)\n-        | Res::Def(DefKind::AssocFn, _)\n-        | Res::Def(DefKind::Ctor(_, CtorKind::Fn), _)\n-        | Res::SelfCtor(..) => {\n-            let user_ty = user_substs_applied_to_res(cx, expr.hir_id, res);\n-            debug!(\"convert_path_expr: user_ty={:?}\", user_ty);\n-            ExprKind::Literal {\n-                literal: ty::Const::zero_sized(cx.tcx, cx.typeck_results().node_type(expr.hir_id)),\n-                user_ty,\n-                const_id: None,\n-            }\n-        }\n-\n-        Res::Def(DefKind::ConstParam, def_id) => {\n-            let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-            let item_id = cx.tcx.hir().get_parent_node(hir_id);\n-            let item_def_id = cx.tcx.hir().local_def_id(item_id);\n-            let generics = cx.tcx.generics_of(item_def_id);\n-            let index = generics.param_def_id_to_index[&def_id];\n-            let name = cx.tcx.hir().name(hir_id);\n-            let val = ty::ConstKind::Param(ty::ParamConst::new(index, name));\n-            ExprKind::Literal {\n-                literal: cx\n-                    .tcx\n-                    .mk_const(ty::Const { val, ty: cx.typeck_results().node_type(expr.hir_id) }),\n-                user_ty: None,\n-                const_id: Some(def_id),\n-            }\n-        }\n-\n-        Res::Def(DefKind::Const, def_id) | Res::Def(DefKind::AssocConst, def_id) => {\n-            let user_ty = user_substs_applied_to_res(cx, expr.hir_id, res);\n-            debug!(\"convert_path_expr: (const) user_ty={:?}\", user_ty);\n-            ExprKind::Literal {\n-                literal: cx.tcx.mk_const(ty::Const {\n-                    val: ty::ConstKind::Unevaluated(\n-                        ty::WithOptConstParam::unknown(def_id),\n-                        substs,\n-                        None,\n-                    ),\n-                    ty: cx.typeck_results().node_type(expr.hir_id),\n-                }),\n-                user_ty,\n-                const_id: Some(def_id),\n-            }\n-        }\n-\n-        Res::Def(DefKind::Ctor(_, CtorKind::Const), def_id) => {\n-            let user_provided_types = cx.typeck_results.user_provided_types();\n-            let user_provided_type = user_provided_types.get(expr.hir_id).copied();\n-            debug!(\"convert_path_expr: user_provided_type={:?}\", user_provided_type);\n-            let ty = cx.typeck_results().node_type(expr.hir_id);\n-            match ty.kind() {\n-                // A unit struct/variant which is used as a value.\n-                // We return a completely different ExprKind here to account for this special case.\n-                ty::Adt(adt_def, substs) => ExprKind::Adt {\n-                    adt_def,\n-                    variant_index: adt_def.variant_index_with_ctor_id(def_id),\n-                    substs,\n-                    user_ty: user_provided_type,\n-                    fields: vec![],\n-                    base: None,\n-                },\n-                _ => bug!(\"unexpected ty: {:?}\", ty),\n-            }\n-        }\n-\n-        // We encode uses of statics as a `*&STATIC` where the `&STATIC` part is\n-        // a constant reference (or constant raw pointer for `static mut`) in MIR\n-        Res::Def(DefKind::Static, id) => {\n-            let ty = cx.tcx.static_ptr_ty(id);\n-            let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-            let kind = if cx.tcx.is_thread_local_static(id) {\n-                ExprKind::ThreadLocalRef(id)\n-            } else {\n-                let ptr = cx.tcx.create_static_alloc(id);\n-                ExprKind::StaticRef {\n-                    literal: ty::Const::from_scalar(cx.tcx, Scalar::Ptr(ptr.into()), ty),\n-                    def_id: id,\n-                }\n-            };\n-            ExprKind::Deref { arg: Expr { ty, temp_lifetime, span: expr.span, kind }.to_ref() }\n-        }\n-\n-        Res::Local(var_hir_id) => convert_var(cx, var_hir_id),\n-\n-        _ => span_bug!(expr.span, \"res `{:?}` not yet implemented\", res),\n-    }\n-}\n-\n-fn convert_var<'tcx>(cx: &mut Cx<'_, 'tcx>, var_hir_id: hir::HirId) -> ExprKind<'tcx> {\n-    // We want upvars here not captures.\n-    // Captures will be handled in MIR.\n-    let is_upvar = cx\n-        .tcx\n-        .upvars_mentioned(cx.body_owner)\n-        .map_or(false, |upvars| upvars.contains_key(&var_hir_id));\n-\n-    debug!(\"convert_var({:?}): is_upvar={}, body_owner={:?}\", var_hir_id, is_upvar, cx.body_owner);\n-\n-    if is_upvar {\n-        ExprKind::UpvarRef { closure_def_id: cx.body_owner, var_hir_id }\n-    } else {\n-        ExprKind::VarRef { id: var_hir_id }\n-    }\n-}\n-\n fn bin_op(op: hir::BinOpKind) -> BinOp {\n     match op {\n         hir::BinOpKind::Add => BinOp::Add,\n@@ -926,139 +1141,3 @@ fn bin_op(op: hir::BinOpKind) -> BinOp {\n         _ => bug!(\"no equivalent for ast binop {:?}\", op),\n     }\n }\n-\n-fn overloaded_operator<'a, 'tcx>(\n-    cx: &mut Cx<'a, 'tcx>,\n-    expr: &'tcx hir::Expr<'tcx>,\n-    args: Vec<ExprRef<'tcx>>,\n-) -> ExprKind<'tcx> {\n-    let fun = method_callee(cx, expr, expr.span, None);\n-    ExprKind::Call { ty: fun.ty, fun: fun.to_ref(), args, from_hir_call: false, fn_span: expr.span }\n-}\n-\n-fn overloaded_place<'a, 'tcx>(\n-    cx: &mut Cx<'a, 'tcx>,\n-    expr: &'tcx hir::Expr<'tcx>,\n-    place_ty: Ty<'tcx>,\n-    overloaded_callee: Option<(DefId, SubstsRef<'tcx>)>,\n-    args: Vec<ExprRef<'tcx>>,\n-    span: Span,\n-) -> ExprKind<'tcx> {\n-    // For an overloaded *x or x[y] expression of type T, the method\n-    // call returns an &T and we must add the deref so that the types\n-    // line up (this is because `*x` and `x[y]` represent places):\n-\n-    let recv_ty = match args[0] {\n-        ExprRef::Thir(e) => cx.typeck_results().expr_ty_adjusted(e),\n-        ExprRef::Mirror(ref e) => e.ty,\n-    };\n-\n-    // Reconstruct the output assuming it's a reference with the\n-    // same region and mutability as the receiver. This holds for\n-    // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n-    let (region, mutbl) = match *recv_ty.kind() {\n-        ty::Ref(region, _, mutbl) => (region, mutbl),\n-        _ => span_bug!(span, \"overloaded_place: receiver is not a reference\"),\n-    };\n-    let ref_ty = cx.tcx.mk_ref(region, ty::TypeAndMut { ty: place_ty, mutbl });\n-\n-    // construct the complete expression `foo()` for the overloaded call,\n-    // which will yield the &T type\n-    let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-    let fun = method_callee(cx, expr, span, overloaded_callee);\n-    let ref_expr = Expr {\n-        temp_lifetime,\n-        ty: ref_ty,\n-        span,\n-        kind: ExprKind::Call {\n-            ty: fun.ty,\n-            fun: fun.to_ref(),\n-            args,\n-            from_hir_call: false,\n-            fn_span: span,\n-        },\n-    };\n-\n-    // construct and return a deref wrapper `*foo()`\n-    ExprKind::Deref { arg: ref_expr.to_ref() }\n-}\n-\n-fn capture_upvar<'a, 'tcx>(\n-    cx: &mut Cx<'_, 'tcx>,\n-    closure_expr: &'tcx hir::Expr<'tcx>,\n-    captured_place: &'a ty::CapturedPlace<'tcx>,\n-    upvar_ty: Ty<'tcx>,\n-) -> ExprRef<'tcx> {\n-    let upvar_capture = captured_place.info.capture_kind;\n-    let temp_lifetime = cx.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n-    let var_ty = captured_place.place.base_ty;\n-\n-    // The result of capture analysis in `rustc_typeck/check/upvar.rs`represents a captured path\n-    // as it's seen for use within the closure and not at the time of closure creation.\n-    //\n-    // That is we see expect to see it start from a captured upvar and not something that is local\n-    // to the closure's parent.\n-    let var_hir_id = match captured_place.place.base {\n-        HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n-        base => bug!(\"Expected an upvar, found {:?}\", base),\n-    };\n-\n-    let mut captured_place_expr = Expr {\n-        temp_lifetime,\n-        ty: var_ty,\n-        span: closure_expr.span,\n-        kind: convert_var(cx, var_hir_id),\n-    };\n-\n-    for proj in captured_place.place.projections.iter() {\n-        let kind = match proj.kind {\n-            HirProjectionKind::Deref => ExprKind::Deref { arg: captured_place_expr.to_ref() },\n-            HirProjectionKind::Field(field, ..) => {\n-                // Variant index will always be 0, because for multi-variant\n-                // enums, we capture the enum entirely.\n-                ExprKind::Field {\n-                    lhs: captured_place_expr.to_ref(),\n-                    name: Field::new(field as usize),\n-                }\n-            }\n-            HirProjectionKind::Index | HirProjectionKind::Subslice => {\n-                // We don't capture these projections, so we can ignore them here\n-                continue;\n-            }\n-        };\n-\n-        captured_place_expr = Expr { temp_lifetime, ty: proj.ty, span: closure_expr.span, kind };\n-    }\n-\n-    match upvar_capture {\n-        ty::UpvarCapture::ByValue(_) => captured_place_expr.to_ref(),\n-        ty::UpvarCapture::ByRef(upvar_borrow) => {\n-            let borrow_kind = match upvar_borrow.kind {\n-                ty::BorrowKind::ImmBorrow => BorrowKind::Shared,\n-                ty::BorrowKind::UniqueImmBorrow => BorrowKind::Unique,\n-                ty::BorrowKind::MutBorrow => BorrowKind::Mut { allow_two_phase_borrow: false },\n-            };\n-            Expr {\n-                temp_lifetime,\n-                ty: upvar_ty,\n-                span: closure_expr.span,\n-                kind: ExprKind::Borrow { borrow_kind, arg: captured_place_expr.to_ref() },\n-            }\n-            .to_ref()\n-        }\n-    }\n-}\n-\n-/// Converts a list of named fields (i.e., for struct-like struct/enum ADTs) into FieldExprRef.\n-fn field_refs<'a, 'tcx>(\n-    cx: &mut Cx<'a, 'tcx>,\n-    fields: &'tcx [hir::Field<'tcx>],\n-) -> Vec<FieldExprRef<'tcx>> {\n-    fields\n-        .iter()\n-        .map(|field| FieldExprRef {\n-            name: Field::new(cx.tcx.field_index(field.hir_id, cx.typeck_results)),\n-            expr: field.expr.to_ref(),\n-        })\n-        .collect()\n-}"}, {"sha": "66c11ea95286d242e8f5902fdd3db11d0d4c6f38", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 21, "deletions": 142, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=61365c06250e2ba6e0a578ae990f055ac5339107", "patch": "@@ -2,125 +2,56 @@\n //! structures into the THIR. The `builder` is generally ignorant of the tcx,\n //! etc., and instead goes through the `Cx` for most of its work.\n \n+use crate::thir::arena::Arena;\n use crate::thir::util::UserAnnotatedTyHelpers;\n use crate::thir::*;\n \n use rustc_ast as ast;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::Node;\n-use rustc_index::vec::Idx;\n-use rustc_infer::infer::InferCtxt;\n use rustc_middle::middle::region;\n use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n-use rustc_middle::ty::subst::Subst;\n-use rustc_middle::ty::subst::{GenericArg, InternalSubsts};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_span::symbol::{sym, Symbol};\n-use rustc_target::abi::VariantIdx;\n-use rustc_trait_selection::infer::InferCtxtExt;\n \n-#[derive(Clone)]\n-crate struct Cx<'a, 'tcx> {\n+crate fn build_thir<'thir, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+    owner_def: ty::WithOptConstParam<LocalDefId>,\n+    arena: &'thir Arena<'thir, 'tcx>,\n+    expr: &'tcx hir::Expr<'tcx>,\n+) -> &'thir Expr<'thir, 'tcx> {\n+    Cx::new(tcx, owner_def, &arena).mirror_expr(expr)\n+}\n \n-    crate root_lint_level: hir::HirId,\n-    crate param_env: ty::ParamEnv<'tcx>,\n+struct Cx<'thir, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    arena: &'thir Arena<'thir, 'tcx>,\n \n-    /// Identity `InternalSubsts` for use with const-evaluation.\n-    crate identity_substs: &'tcx InternalSubsts<'tcx>,\n+    crate param_env: ty::ParamEnv<'tcx>,\n \n     crate region_scope_tree: &'tcx region::ScopeTree,\n-    crate typeck_results: &'a ty::TypeckResults<'tcx>,\n-\n-    /// This is `Constness::Const` if we are compiling a `static`,\n-    /// `const`, or the body of a `const fn`.\n-    constness: hir::Constness,\n+    crate typeck_results: &'tcx ty::TypeckResults<'tcx>,\n \n     /// The `DefId` of the owner of this body.\n     body_owner: DefId,\n-\n-    /// What kind of body is being compiled.\n-    crate body_owner_kind: hir::BodyOwnerKind,\n-\n-    /// Whether this constant/function needs overflow checks.\n-    check_overflow: bool,\n }\n \n-impl<'a, 'tcx> Cx<'a, 'tcx> {\n-    crate fn new(\n-        infcx: &'a InferCtxt<'a, 'tcx>,\n+impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n+    fn new(\n+        tcx: TyCtxt<'tcx>,\n         def: ty::WithOptConstParam<LocalDefId>,\n-        src_id: hir::HirId,\n-    ) -> Cx<'a, 'tcx> {\n-        let tcx = infcx.tcx;\n+        arena: &'thir Arena<'thir, 'tcx>,\n+    ) -> Cx<'thir, 'tcx> {\n         let typeck_results = tcx.typeck_opt_const_arg(def);\n-        let body_owner_kind = tcx.hir().body_owner_kind(src_id);\n-\n-        let constness = match body_owner_kind {\n-            hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) => hir::Constness::Const,\n-            hir::BodyOwnerKind::Closure | hir::BodyOwnerKind::Fn => hir::Constness::NotConst,\n-        };\n-\n-        let attrs = tcx.hir().attrs(src_id);\n-\n-        // Some functions always have overflow checks enabled,\n-        // however, they may not get codegen'd, depending on\n-        // the settings for the crate they are codegened in.\n-        let mut check_overflow = tcx.sess.contains_name(attrs, sym::rustc_inherit_overflow_checks);\n-\n-        // Respect -C overflow-checks.\n-        check_overflow |= tcx.sess.overflow_checks();\n-\n-        // Constants always need overflow checks.\n-        check_overflow |= constness == hir::Constness::Const;\n-\n         Cx {\n             tcx,\n-            infcx,\n-            root_lint_level: src_id,\n+            arena,\n             param_env: tcx.param_env(def.did),\n-            identity_substs: InternalSubsts::identity_for_item(tcx, def.did.to_def_id()),\n             region_scope_tree: tcx.region_scope_tree(def.did),\n             typeck_results,\n-            constness,\n             body_owner: def.did.to_def_id(),\n-            body_owner_kind,\n-            check_overflow,\n         }\n     }\n-}\n-\n-impl<'a, 'tcx> Cx<'a, 'tcx> {\n-    /// Normalizes `ast` into the appropriate \"mirror\" type.\n-    crate fn mirror<M: Mirror<'tcx>>(&mut self, ast: M) -> M::Output {\n-        ast.make_mirror(self)\n-    }\n-\n-    crate fn usize_ty(&mut self) -> Ty<'tcx> {\n-        self.tcx.types.usize\n-    }\n-\n-    crate fn usize_literal(&mut self, value: u64) -> &'tcx ty::Const<'tcx> {\n-        ty::Const::from_usize(self.tcx, value)\n-    }\n-\n-    crate fn bool_ty(&mut self) -> Ty<'tcx> {\n-        self.tcx.types.bool\n-    }\n-\n-    crate fn unit_ty(&mut self) -> Ty<'tcx> {\n-        self.tcx.mk_unit()\n-    }\n-\n-    crate fn true_literal(&mut self) -> &'tcx ty::Const<'tcx> {\n-        ty::Const::from_bool(self.tcx, true)\n-    }\n-\n-    crate fn false_literal(&mut self) -> &'tcx ty::Const<'tcx> {\n-        ty::Const::from_bool(self.tcx, false)\n-    }\n \n     crate fn const_eval_literal(\n         &mut self,\n@@ -154,69 +85,17 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n         };\n         Pat::from_hir(self.tcx, self.param_env, self.typeck_results(), p)\n     }\n-\n-    crate fn trait_method(\n-        &mut self,\n-        trait_def_id: DefId,\n-        method_name: Symbol,\n-        self_ty: Ty<'tcx>,\n-        params: &[GenericArg<'tcx>],\n-    ) -> &'tcx ty::Const<'tcx> {\n-        let substs = self.tcx.mk_substs_trait(self_ty, params);\n-\n-        // The unhygienic comparison here is acceptable because this is only\n-        // used on known traits.\n-        let item = self\n-            .tcx\n-            .associated_items(trait_def_id)\n-            .filter_by_name_unhygienic(method_name)\n-            .find(|item| item.kind == ty::AssocKind::Fn)\n-            .expect(\"trait method not found\");\n-\n-        let method_ty = self.tcx.type_of(item.def_id);\n-        let method_ty = method_ty.subst(self.tcx, substs);\n-        ty::Const::zero_sized(self.tcx, method_ty)\n-    }\n-\n-    crate fn all_fields(&mut self, adt_def: &ty::AdtDef, variant_index: VariantIdx) -> Vec<Field> {\n-        (0..adt_def.variants[variant_index].fields.len()).map(Field::new).collect()\n-    }\n-\n-    crate fn needs_drop(&mut self, ty: Ty<'tcx>) -> bool {\n-        ty.needs_drop(self.tcx, self.param_env)\n-    }\n-\n-    crate fn infcx(&self) -> &'a InferCtxt<'a, 'tcx> {\n-        self.infcx\n-    }\n-\n-    crate fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    crate fn typeck_results(&self) -> &'a ty::TypeckResults<'tcx> {\n-        self.typeck_results\n-    }\n-\n-    crate fn check_overflow(&self) -> bool {\n-        self.check_overflow\n-    }\n-\n-    crate fn type_is_copy_modulo_regions(&self, ty: Ty<'tcx>, span: Span) -> bool {\n-        self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span)\n-    }\n }\n \n impl<'tcx> UserAnnotatedTyHelpers<'tcx> for Cx<'_, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx()\n+        self.tcx\n     }\n \n     fn typeck_results(&self) -> &ty::TypeckResults<'tcx> {\n-        self.typeck_results()\n+        self.typeck_results\n     }\n }\n \n mod block;\n mod expr;\n-mod to_ref;"}, {"sha": "53a988ebb79e2aec4fc453028b0513a7352845e2", "filename": "compiler/rustc_mir_build/src/thir/cx/to_ref.rs", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5c6d3bf3896b465e15550f49c2861e3d18102270/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fto_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6d3bf3896b465e15550f49c2861e3d18102270/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fto_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fto_ref.rs?ref=5c6d3bf3896b465e15550f49c2861e3d18102270", "patch": "@@ -1,65 +0,0 @@\n-use crate::thir::*;\n-\n-use rustc_hir as hir;\n-\n-crate trait ToRef {\n-    type Output;\n-    fn to_ref(self) -> Self::Output;\n-}\n-\n-impl<'tcx> ToRef for &'tcx hir::Expr<'tcx> {\n-    type Output = ExprRef<'tcx>;\n-\n-    fn to_ref(self) -> ExprRef<'tcx> {\n-        ExprRef::Thir(self)\n-    }\n-}\n-\n-impl<'tcx> ToRef for &'tcx &'tcx hir::Expr<'tcx> {\n-    type Output = ExprRef<'tcx>;\n-\n-    fn to_ref(self) -> ExprRef<'tcx> {\n-        ExprRef::Thir(&**self)\n-    }\n-}\n-\n-impl<'tcx> ToRef for Expr<'tcx> {\n-    type Output = ExprRef<'tcx>;\n-\n-    fn to_ref(self) -> ExprRef<'tcx> {\n-        ExprRef::Mirror(Box::new(self))\n-    }\n-}\n-\n-impl<'tcx, T, U> ToRef for &'tcx Option<T>\n-where\n-    &'tcx T: ToRef<Output = U>,\n-{\n-    type Output = Option<U>;\n-\n-    fn to_ref(self) -> Option<U> {\n-        self.as_ref().map(|expr| expr.to_ref())\n-    }\n-}\n-\n-impl<'tcx, T, U> ToRef for &'tcx Vec<T>\n-where\n-    &'tcx T: ToRef<Output = U>,\n-{\n-    type Output = Vec<U>;\n-\n-    fn to_ref(self) -> Vec<U> {\n-        self.iter().map(|expr| expr.to_ref()).collect()\n-    }\n-}\n-\n-impl<'tcx, T, U> ToRef for &'tcx [T]\n-where\n-    &'tcx T: ToRef<Output = U>,\n-{\n-    type Output = Vec<U>;\n-\n-    fn to_ref(self) -> Vec<U> {\n-        self.iter().map(|expr| expr.to_ref()).collect()\n-    }\n-}"}, {"sha": "27a7e99951c3b0d989490608511f6f508d0621cd", "filename": "compiler/rustc_mir_build/src/thir/mod.rs", "status": "modified", "additions": 91, "deletions": 175, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61365c06250e2ba6e0a578ae990f055ac5339107/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs?ref=61365c06250e2ba6e0a578ae990f055ac5339107", "patch": "@@ -4,7 +4,6 @@\n //! unit-tested and separated from the Rust source and compiler data\n //! structures.\n \n-use self::cx::Cx;\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -25,6 +24,9 @@ crate mod pattern;\n crate use self::pattern::PatTyProj;\n crate use self::pattern::{BindingMode, FieldPat, Pat, PatKind, PatRange};\n \n+mod arena;\n+crate use arena::Arena;\n+\n mod util;\n \n #[derive(Copy, Clone, Debug)]\n@@ -33,14 +35,14 @@ crate enum LintLevel {\n     Explicit(hir::HirId),\n }\n \n-#[derive(Clone, Debug)]\n-crate struct Block<'tcx> {\n+#[derive(Debug)]\n+crate struct Block<'thir, 'tcx> {\n     crate targeted_by_break: bool,\n     crate region_scope: region::Scope,\n     crate opt_destruction_scope: Option<region::Scope>,\n     crate span: Span,\n-    crate stmts: Vec<StmtRef<'tcx>>,\n-    crate expr: Option<ExprRef<'tcx>>,\n+    crate stmts: &'thir [Stmt<'thir, 'tcx>],\n+    crate expr: Option<&'thir Expr<'thir, 'tcx>>,\n     crate safety_mode: BlockSafety,\n }\n \n@@ -52,25 +54,20 @@ crate enum BlockSafety {\n     PopUnsafe,\n }\n \n-#[derive(Clone, Debug)]\n-crate enum StmtRef<'tcx> {\n-    Mirror(Box<Stmt<'tcx>>),\n-}\n-\n-#[derive(Clone, Debug)]\n-crate struct Stmt<'tcx> {\n-    crate kind: StmtKind<'tcx>,\n+#[derive(Debug)]\n+crate struct Stmt<'thir, 'tcx> {\n+    crate kind: StmtKind<'thir, 'tcx>,\n     crate opt_destruction_scope: Option<region::Scope>,\n }\n \n-#[derive(Clone, Debug)]\n-crate enum StmtKind<'tcx> {\n+#[derive(Debug)]\n+crate enum StmtKind<'thir, 'tcx> {\n     Expr {\n         /// scope for this statement; may be used as lifetime of temporaries\n         scope: region::Scope,\n \n         /// expression being evaluated in this statement\n-        expr: ExprRef<'tcx>,\n+        expr: &'thir Expr<'thir, 'tcx>,\n     },\n \n     Let {\n@@ -88,7 +85,7 @@ crate enum StmtKind<'tcx> {\n         pattern: Pat<'tcx>,\n \n         /// let pat: ty = <INIT> ...\n-        initializer: Option<ExprRef<'tcx>>,\n+        initializer: Option<&'thir Expr<'thir, 'tcx>>,\n \n         /// the lint level for this let-statement\n         lint_level: LintLevel,\n@@ -97,12 +94,12 @@ crate enum StmtKind<'tcx> {\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Expr<'_>, 168);\n+rustc_data_structures::static_assert_size!(Expr<'_, '_>, 144);\n \n /// The Thir trait implementor lowers their expressions (`&'tcx H::Expr`)\n /// into instances of this `Expr` enum. This lowering can be done\n /// basically as lazily or as eagerly as desired: every recursive\n-/// reference to an expression in this enum is an `ExprRef<'tcx>`, which\n+/// reference to an expression in this enum is an `&'thir Expr<'thir, 'tcx>`, which\n /// may in turn be another instance of this enum (boxed), or else an\n /// unlowered `&'tcx H::Expr`. Note that instances of `Expr` are very\n /// short-lived. They are created by `Thir::to_expr`, analyzed and\n@@ -113,8 +110,8 @@ rustc_data_structures::static_assert_size!(Expr<'_>, 168);\n /// MIR simplifications are already done in the impl of `Thir`. For\n /// example, method calls and overloaded operators are absent: they are\n /// expected to be converted into `Expr::Call` instances.\n-#[derive(Clone, Debug)]\n-crate struct Expr<'tcx> {\n+#[derive(Debug)]\n+crate struct Expr<'thir, 'tcx> {\n     /// type of this expression\n     crate ty: Ty<'tcx>,\n \n@@ -126,92 +123,92 @@ crate struct Expr<'tcx> {\n     crate span: Span,\n \n     /// kind of expression\n-    crate kind: ExprKind<'tcx>,\n+    crate kind: ExprKind<'thir, 'tcx>,\n }\n \n-#[derive(Clone, Debug)]\n-crate enum ExprKind<'tcx> {\n+#[derive(Debug)]\n+crate enum ExprKind<'thir, 'tcx> {\n     Scope {\n         region_scope: region::Scope,\n         lint_level: LintLevel,\n-        value: ExprRef<'tcx>,\n+        value: &'thir Expr<'thir, 'tcx>,\n     },\n     Box {\n-        value: ExprRef<'tcx>,\n+        value: &'thir Expr<'thir, 'tcx>,\n     },\n     If {\n-        cond: ExprRef<'tcx>,\n-        then: ExprRef<'tcx>,\n-        else_opt: Option<ExprRef<'tcx>>,\n+        cond: &'thir Expr<'thir, 'tcx>,\n+        then: &'thir Expr<'thir, 'tcx>,\n+        else_opt: Option<&'thir Expr<'thir, 'tcx>>,\n     },\n     Call {\n         ty: Ty<'tcx>,\n-        fun: ExprRef<'tcx>,\n-        args: Vec<ExprRef<'tcx>>,\n-        // Whether this is from a call in HIR, rather than from an overloaded\n-        // operator. True for overloaded function call.\n+        fun: &'thir Expr<'thir, 'tcx>,\n+        args: &'thir [Expr<'thir, 'tcx>],\n+        /// Whether this is from a call in HIR, rather than from an overloaded\n+        /// operator. `true` for overloaded function call.\n         from_hir_call: bool,\n         /// This `Span` is the span of the function, without the dot and receiver\n         /// (e.g. `foo(a, b)` in `x.foo(a, b)`\n         fn_span: Span,\n     },\n     Deref {\n-        arg: ExprRef<'tcx>,\n+        arg: &'thir Expr<'thir, 'tcx>,\n     }, // NOT overloaded!\n     Binary {\n         op: BinOp,\n-        lhs: ExprRef<'tcx>,\n-        rhs: ExprRef<'tcx>,\n+        lhs: &'thir Expr<'thir, 'tcx>,\n+        rhs: &'thir Expr<'thir, 'tcx>,\n     }, // NOT overloaded!\n     LogicalOp {\n         op: LogicalOp,\n-        lhs: ExprRef<'tcx>,\n-        rhs: ExprRef<'tcx>,\n+        lhs: &'thir Expr<'thir, 'tcx>,\n+        rhs: &'thir Expr<'thir, 'tcx>,\n     }, // NOT overloaded!\n     // LogicalOp is distinct from BinaryOp because of lazy evaluation of the operands.\n     Unary {\n         op: UnOp,\n-        arg: ExprRef<'tcx>,\n+        arg: &'thir Expr<'thir, 'tcx>,\n     }, // NOT overloaded!\n     Cast {\n-        source: ExprRef<'tcx>,\n+        source: &'thir Expr<'thir, 'tcx>,\n     },\n     Use {\n-        source: ExprRef<'tcx>,\n+        source: &'thir Expr<'thir, 'tcx>,\n     }, // Use a lexpr to get a vexpr.\n     NeverToAny {\n-        source: ExprRef<'tcx>,\n+        source: &'thir Expr<'thir, 'tcx>,\n     },\n     Pointer {\n         cast: PointerCast,\n-        source: ExprRef<'tcx>,\n+        source: &'thir Expr<'thir, 'tcx>,\n     },\n     Loop {\n-        body: ExprRef<'tcx>,\n+        body: &'thir Expr<'thir, 'tcx>,\n     },\n     Match {\n-        scrutinee: ExprRef<'tcx>,\n-        arms: Vec<Arm<'tcx>>,\n+        scrutinee: &'thir Expr<'thir, 'tcx>,\n+        arms: &'thir [Arm<'thir, 'tcx>],\n     },\n     Block {\n-        body: &'tcx hir::Block<'tcx>,\n+        body: Block<'thir, 'tcx>,\n     },\n     Assign {\n-        lhs: ExprRef<'tcx>,\n-        rhs: ExprRef<'tcx>,\n+        lhs: &'thir Expr<'thir, 'tcx>,\n+        rhs: &'thir Expr<'thir, 'tcx>,\n     },\n     AssignOp {\n         op: BinOp,\n-        lhs: ExprRef<'tcx>,\n-        rhs: ExprRef<'tcx>,\n+        lhs: &'thir Expr<'thir, 'tcx>,\n+        rhs: &'thir Expr<'thir, 'tcx>,\n     },\n     Field {\n-        lhs: ExprRef<'tcx>,\n+        lhs: &'thir Expr<'thir, 'tcx>,\n         name: Field,\n     },\n     Index {\n-        lhs: ExprRef<'tcx>,\n-        index: ExprRef<'tcx>,\n+        lhs: &'thir Expr<'thir, 'tcx>,\n+        index: &'thir Expr<'thir, 'tcx>,\n     },\n     VarRef {\n         id: hir::HirId,\n@@ -226,35 +223,35 @@ crate enum ExprKind<'tcx> {\n     },\n     Borrow {\n         borrow_kind: BorrowKind,\n-        arg: ExprRef<'tcx>,\n+        arg: &'thir Expr<'thir, 'tcx>,\n     },\n     /// A `&raw [const|mut] $place_expr` raw borrow resulting in type `*[const|mut] T`.\n     AddressOf {\n         mutability: hir::Mutability,\n-        arg: ExprRef<'tcx>,\n+        arg: &'thir Expr<'thir, 'tcx>,\n     },\n     Break {\n         label: region::Scope,\n-        value: Option<ExprRef<'tcx>>,\n+        value: Option<&'thir Expr<'thir, 'tcx>>,\n     },\n     Continue {\n         label: region::Scope,\n     },\n     Return {\n-        value: Option<ExprRef<'tcx>>,\n+        value: Option<&'thir Expr<'thir, 'tcx>>,\n     },\n     ConstBlock {\n         value: &'tcx Const<'tcx>,\n     },\n     Repeat {\n-        value: ExprRef<'tcx>,\n+        value: &'thir Expr<'thir, 'tcx>,\n         count: &'tcx Const<'tcx>,\n     },\n     Array {\n-        fields: Vec<ExprRef<'tcx>>,\n+        fields: &'thir [Expr<'thir, 'tcx>],\n     },\n     Tuple {\n-        fields: Vec<ExprRef<'tcx>>,\n+        fields: &'thir [Expr<'thir, 'tcx>],\n     },\n     Adt {\n         adt_def: &'tcx AdtDef,\n@@ -265,23 +262,23 @@ crate enum ExprKind<'tcx> {\n         /// Bar::<T> { ... }`.\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n \n-        fields: Vec<FieldExprRef<'tcx>>,\n-        base: Option<FruInfo<'tcx>>,\n+        fields: &'thir [FieldExpr<'thir, 'tcx>],\n+        base: Option<FruInfo<'thir, 'tcx>>,\n     },\n     PlaceTypeAscription {\n-        source: ExprRef<'tcx>,\n+        source: &'thir Expr<'thir, 'tcx>,\n         /// Type that the user gave to this expression\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n     },\n     ValueTypeAscription {\n-        source: ExprRef<'tcx>,\n+        source: &'thir Expr<'thir, 'tcx>,\n         /// Type that the user gave to this expression\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n     },\n     Closure {\n         closure_id: DefId,\n         substs: UpvarSubsts<'tcx>,\n-        upvars: Vec<ExprRef<'tcx>>,\n+        upvars: &'thir [Expr<'thir, 'tcx>],\n         movability: Option<hir::Movability>,\n     },\n     Literal {\n@@ -302,54 +299,48 @@ crate enum ExprKind<'tcx> {\n     },\n     InlineAsm {\n         template: &'tcx [InlineAsmTemplatePiece],\n-        operands: Vec<InlineAsmOperand<'tcx>>,\n+        operands: &'thir [InlineAsmOperand<'thir, 'tcx>],\n         options: InlineAsmOptions,\n         line_spans: &'tcx [Span],\n     },\n     /// An expression taking a reference to a thread local.\n     ThreadLocalRef(DefId),\n     LlvmInlineAsm {\n         asm: &'tcx hir::LlvmInlineAsmInner,\n-        outputs: Vec<ExprRef<'tcx>>,\n-        inputs: Vec<ExprRef<'tcx>>,\n+        outputs: &'thir [Expr<'thir, 'tcx>],\n+        inputs: &'thir [Expr<'thir, 'tcx>],\n     },\n     Yield {\n-        value: ExprRef<'tcx>,\n+        value: &'thir Expr<'thir, 'tcx>,\n     },\n }\n \n-#[derive(Clone, Debug)]\n-crate enum ExprRef<'tcx> {\n-    Thir(&'tcx hir::Expr<'tcx>),\n-    Mirror(Box<Expr<'tcx>>),\n-}\n-\n-#[derive(Clone, Debug)]\n-crate struct FieldExprRef<'tcx> {\n+#[derive(Debug)]\n+crate struct FieldExpr<'thir, 'tcx> {\n     crate name: Field,\n-    crate expr: ExprRef<'tcx>,\n+    crate expr: &'thir Expr<'thir, 'tcx>,\n }\n \n-#[derive(Clone, Debug)]\n-crate struct FruInfo<'tcx> {\n-    crate base: ExprRef<'tcx>,\n-    crate field_types: Vec<Ty<'tcx>>,\n+#[derive(Debug)]\n+crate struct FruInfo<'thir, 'tcx> {\n+    crate base: &'thir Expr<'thir, 'tcx>,\n+    crate field_types: &'thir [Ty<'tcx>],\n }\n \n-#[derive(Clone, Debug)]\n-crate struct Arm<'tcx> {\n+#[derive(Debug)]\n+crate struct Arm<'thir, 'tcx> {\n     crate pattern: Pat<'tcx>,\n-    crate guard: Option<Guard<'tcx>>,\n-    crate body: ExprRef<'tcx>,\n+    crate guard: Option<Guard<'thir, 'tcx>>,\n+    crate body: &'thir Expr<'thir, 'tcx>,\n     crate lint_level: LintLevel,\n     crate scope: region::Scope,\n     crate span: Span,\n }\n \n-#[derive(Clone, Debug)]\n-crate enum Guard<'tcx> {\n-    If(ExprRef<'tcx>),\n-    IfLet(Pat<'tcx>, ExprRef<'tcx>),\n+#[derive(Debug)]\n+crate enum Guard<'thir, 'tcx> {\n+    If(&'thir Expr<'thir, 'tcx>),\n+    IfLet(Pat<'tcx>, &'thir Expr<'thir, 'tcx>),\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -358,110 +349,35 @@ crate enum LogicalOp {\n     Or,\n }\n \n-impl<'tcx> ExprRef<'tcx> {\n-    crate fn span(&self) -> Span {\n-        match self {\n-            ExprRef::Thir(expr) => expr.span,\n-            ExprRef::Mirror(expr) => expr.span,\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug)]\n-crate enum InlineAsmOperand<'tcx> {\n+#[derive(Debug)]\n+crate enum InlineAsmOperand<'thir, 'tcx> {\n     In {\n         reg: InlineAsmRegOrRegClass,\n-        expr: ExprRef<'tcx>,\n+        expr: &'thir Expr<'thir, 'tcx>,\n     },\n     Out {\n         reg: InlineAsmRegOrRegClass,\n         late: bool,\n-        expr: Option<ExprRef<'tcx>>,\n+        expr: Option<&'thir Expr<'thir, 'tcx>>,\n     },\n     InOut {\n         reg: InlineAsmRegOrRegClass,\n         late: bool,\n-        expr: ExprRef<'tcx>,\n+        expr: &'thir Expr<'thir, 'tcx>,\n     },\n     SplitInOut {\n         reg: InlineAsmRegOrRegClass,\n         late: bool,\n-        in_expr: ExprRef<'tcx>,\n-        out_expr: Option<ExprRef<'tcx>>,\n+        in_expr: &'thir Expr<'thir, 'tcx>,\n+        out_expr: Option<&'thir Expr<'thir, 'tcx>>,\n     },\n     Const {\n-        expr: ExprRef<'tcx>,\n+        expr: &'thir Expr<'thir, 'tcx>,\n     },\n     SymFn {\n-        expr: ExprRef<'tcx>,\n+        expr: &'thir Expr<'thir, 'tcx>,\n     },\n     SymStatic {\n         def_id: DefId,\n     },\n }\n-\n-///////////////////////////////////////////////////////////////////////////\n-// The Mirror trait\n-\n-/// \"Mirroring\" is the process of converting from a HIR type into one\n-/// of the THIR types defined in this file. This is basically a \"on\n-/// the fly\" desugaring step that hides a lot of the messiness in the\n-/// tcx. For example, the mirror of a `&'tcx hir::Expr` is an\n-/// `Expr<'tcx>`.\n-///\n-/// Mirroring is gradual: when you mirror an outer expression like `e1\n-/// + e2`, the references to the inner expressions `e1` and `e2` are\n-/// `ExprRef<'tcx>` instances, and they may or may not be eagerly\n-/// mirrored. This allows a single AST node from the compiler to\n-/// expand into one or more Thir nodes, which lets the Thir nodes be\n-/// simpler.\n-crate trait Mirror<'tcx> {\n-    type Output;\n-\n-    fn make_mirror(self, cx: &mut Cx<'_, 'tcx>) -> Self::Output;\n-}\n-\n-impl<'tcx> Mirror<'tcx> for Expr<'tcx> {\n-    type Output = Expr<'tcx>;\n-\n-    fn make_mirror(self, _: &mut Cx<'_, 'tcx>) -> Expr<'tcx> {\n-        self\n-    }\n-}\n-\n-impl<'tcx> Mirror<'tcx> for ExprRef<'tcx> {\n-    type Output = Expr<'tcx>;\n-\n-    fn make_mirror(self, hir: &mut Cx<'_, 'tcx>) -> Expr<'tcx> {\n-        match self {\n-            ExprRef::Thir(h) => h.make_mirror(hir),\n-            ExprRef::Mirror(m) => *m,\n-        }\n-    }\n-}\n-\n-impl<'tcx> Mirror<'tcx> for Stmt<'tcx> {\n-    type Output = Stmt<'tcx>;\n-\n-    fn make_mirror(self, _: &mut Cx<'_, 'tcx>) -> Stmt<'tcx> {\n-        self\n-    }\n-}\n-\n-impl<'tcx> Mirror<'tcx> for StmtRef<'tcx> {\n-    type Output = Stmt<'tcx>;\n-\n-    fn make_mirror(self, _: &mut Cx<'_, 'tcx>) -> Stmt<'tcx> {\n-        match self {\n-            StmtRef::Mirror(m) => *m,\n-        }\n-    }\n-}\n-\n-impl<'tcx> Mirror<'tcx> for Block<'tcx> {\n-    type Output = Block<'tcx>;\n-\n-    fn make_mirror(self, _: &mut Cx<'_, 'tcx>) -> Block<'tcx> {\n-        self\n-    }\n-}"}]}