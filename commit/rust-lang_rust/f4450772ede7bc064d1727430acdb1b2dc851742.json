{"sha": "f4450772ede7bc064d1727430acdb1b2dc851742", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0NDUwNzcyZWRlN2JjMDY0ZDE3Mjc0MzBhY2RiMWIyZGM4NTE3NDI=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2020-02-26T01:39:18Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2020-03-09T13:50:40Z"}, "message": "Remove the `no_force` query attribute", "tree": {"sha": "82c5b7e3f808e016575c3172972a7e86fed407ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82c5b7e3f808e016575c3172972a7e86fed407ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4450772ede7bc064d1727430acdb1b2dc851742", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4450772ede7bc064d1727430acdb1b2dc851742", "html_url": "https://github.com/rust-lang/rust/commit/f4450772ede7bc064d1727430acdb1b2dc851742", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4450772ede7bc064d1727430acdb1b2dc851742/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbce21767b757b209c4d4df6792995fecf02c7fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbce21767b757b209c4d4df6792995fecf02c7fa", "html_url": "https://github.com/rust-lang/rust/commit/cbce21767b757b209c4d4df6792995fecf02c7fa"}], "stats": {"total": 54, "additions": 0, "deletions": 54}, "files": [{"sha": "11e9acf3a3912828fd6657eab393a6b5c5ed5be6", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f4450772ede7bc064d1727430acdb1b2dc851742/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4450772ede7bc064d1727430acdb1b2dc851742/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=f4450772ede7bc064d1727430acdb1b2dc851742", "patch": "@@ -200,7 +200,6 @@ rustc_queries! {\n             // queries). Making it anonymous avoids hashing the result, which\n             // may save a bit of time.\n             anon\n-            no_force\n             desc { \"erasing regions from `{:?}`\", ty }\n         }\n \n@@ -209,7 +208,6 @@ rustc_queries! {\n         }\n \n         query program_clauses_for_env(_: traits::Environment<'tcx>) -> Clauses<'tcx> {\n-            no_force\n             desc { \"generating chalk-style clauses for environment\" }\n         }\n \n@@ -252,7 +250,6 @@ rustc_queries! {\n         /// To avoid cycles within the predicates of a single item we compute\n         /// per-type-parameter predicates for resolving `T::AssocTy`.\n         query type_param_predicates(key: (DefId, DefId)) -> ty::GenericPredicates<'tcx> {\n-            no_force\n             desc { |tcx| \"computing the bounds for type parameter `{}`\", {\n                 let id = tcx.hir().as_local_hir_id(key.1).unwrap();\n                 tcx.hir().ty_param_name(id)\n@@ -508,7 +505,6 @@ rustc_queries! {\n         /// form to be used outside of const eval.\n         query const_eval_raw(key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n             -> ConstEvalRawResult<'tcx> {\n-            no_force\n             desc { |tcx|\n                 \"const-evaluating `{}`\",\n                 tcx.def_path_str(key.value.instance.def.def_id())\n@@ -525,7 +521,6 @@ rustc_queries! {\n         /// `tcx.const_eval_resolve`, `tcx.const_eval_instance`, or `tcx.const_eval_global_id`.\n         query const_eval_validated(key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n             -> ConstEvalResult<'tcx> {\n-            no_force\n             desc { |tcx|\n                 \"const-evaluating + checking `{}`\",\n                 tcx.def_path_str(key.value.instance.def.def_id())\n@@ -540,7 +535,6 @@ rustc_queries! {\n         query const_field(\n             key: ty::ParamEnvAnd<'tcx, (&'tcx ty::Const<'tcx>, mir::Field)>\n         ) -> ConstValue<'tcx> {\n-            no_force\n             desc { \"extract field of const\" }\n         }\n \n@@ -549,19 +543,16 @@ rustc_queries! {\n         query destructure_const(\n             key: ty::ParamEnvAnd<'tcx, &'tcx ty::Const<'tcx>>\n         ) -> mir::DestructuredConst<'tcx> {\n-            no_force\n             desc { \"destructure constant\" }\n         }\n \n         query const_caller_location(key: (rustc_span::Symbol, u32, u32)) -> ConstValue<'tcx> {\n-            no_force\n             desc { \"get a &core::panic::Location referring to a span\" }\n         }\n \n         query lit_to_const(\n             key: LitToConstInput<'tcx>\n         ) -> Result<&'tcx ty::Const<'tcx>, LitToConstError> {\n-            no_force\n             desc { \"converting literal to const\" }\n         }\n     }\n@@ -592,15 +583,13 @@ rustc_queries! {\n         query region_scope_tree(_: DefId) -> &'tcx region::ScopeTree {}\n \n         query mir_shims(key: ty::InstanceDef<'tcx>) -> &'tcx mir::BodyAndCache<'tcx> {\n-            no_force\n             desc { |tcx| \"generating MIR shim for `{}`\", tcx.def_path_str(key.def_id()) }\n         }\n \n         /// The `symbol_name` query provides the symbol name for calling a\n         /// given instance from the local crate. In particular, it will also\n         /// look up the correct symbol name of instances from upstream crates.\n         query symbol_name(key: ty::Instance<'tcx>) -> ty::SymbolName {\n-            no_force\n             desc { \"computing the symbol for `{}`\", key }\n             cache_on_disk_if { true }\n         }\n@@ -647,7 +636,6 @@ rustc_queries! {\n     Other {\n         query vtable_methods(key: ty::PolyTraitRef<'tcx>)\n                             -> &'tcx [Option<(DefId, SubstsRef<'tcx>)>] {\n-            no_force\n             desc { |tcx| \"finding all methods for trait {}\", tcx.def_path_str(key.def_id()) }\n         }\n     }\n@@ -656,7 +644,6 @@ rustc_queries! {\n         query codegen_fulfill_obligation(\n             key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)\n         ) -> Option<Vtable<'tcx, ()>> {\n-            no_force\n             cache_on_disk_if { true }\n             desc { |tcx|\n                 \"checking if `{}` fulfills its obligations\",\n@@ -688,22 +675,18 @@ rustc_queries! {\n         /// Trait selection queries. These are best used by invoking `ty.is_copy_modulo_regions()`,\n         /// `ty.is_copy()`, etc, since that will prune the environment where possible.\n         query is_copy_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-            no_force\n             desc { \"computing whether `{}` is `Copy`\", env.value }\n         }\n         /// Query backing `TyS::is_sized`.\n         query is_sized_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-            no_force\n             desc { \"computing whether `{}` is `Sized`\", env.value }\n         }\n         /// Query backing `TyS::is_freeze`.\n         query is_freeze_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-            no_force\n             desc { \"computing whether `{}` is freeze\", env.value }\n         }\n         /// Query backing `TyS::needs_drop`.\n         query needs_drop_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-            no_force\n             desc { \"computing whether `{}` needs drop\", env.value }\n         }\n \n@@ -717,7 +700,6 @@ rustc_queries! {\n         query layout_raw(\n             env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n         ) -> Result<&'tcx ty::layout::LayoutDetails, ty::layout::LayoutError<'tcx>> {\n-            no_force\n             desc { \"computing layout of `{}`\", env.value }\n         }\n     }\n@@ -773,7 +755,6 @@ rustc_queries! {\n \n     TypeChecking {\n         query specializes(_: (DefId, DefId)) -> bool {\n-            no_force\n             desc { \"computing whether impls specialize one another\" }\n         }\n         query in_scope_traits_map(_: DefIndex)\n@@ -858,7 +839,6 @@ rustc_queries! {\n         ///       (like `Clone::clone` for example).\n         query upstream_drop_glue_for(substs: SubstsRef<'tcx>) -> Option<CrateNum> {\n             desc { \"available upstream drop-glue for `{:?}`\", substs }\n-            no_force\n         }\n     }\n \n@@ -903,7 +883,6 @@ rustc_queries! {\n     TypeChecking {\n         query implementations_of_trait(_: (CrateNum, DefId))\n             -> &'tcx [DefId] {\n-            no_force\n             desc { \"looking up implementations of a trait in a crate\" }\n         }\n         query all_trait_implementations(_: CrateNum)\n@@ -1070,7 +1049,6 @@ rustc_queries! {\n         }\n         query is_codegened_item(_: DefId) -> bool {}\n         query codegen_unit(_: Symbol) -> Arc<CodegenUnit<'tcx>> {\n-            no_force\n             desc { \"codegen_unit\" }\n         }\n         query backend_optimization_level(_: CrateNum) -> OptLevel {\n@@ -1093,15 +1071,13 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, NormalizationResult<'tcx>>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"normalizing `{:?}`\", goal }\n         }\n \n         /// Do not call this query directly: invoke `normalize_erasing_regions` instead.\n         query normalize_ty_after_erasing_regions(\n             goal: ParamEnvAnd<'tcx, Ty<'tcx>>\n         ) -> Ty<'tcx> {\n-            no_force\n             desc { \"normalizing `{:?}`\", goal }\n         }\n \n@@ -1111,7 +1087,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, Vec<OutlivesBound<'tcx>>>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"computing implied outlives bounds for `{:?}`\", goal }\n         }\n \n@@ -1122,7 +1097,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, DropckOutlivesResult<'tcx>>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"computing dropck types for `{:?}`\", goal }\n         }\n \n@@ -1131,7 +1105,6 @@ rustc_queries! {\n         query evaluate_obligation(\n             goal: CanonicalPredicateGoal<'tcx>\n         ) -> Result<traits::EvaluationResult, traits::OverflowError> {\n-            no_force\n             desc { \"evaluating trait selection obligation `{}`\", goal.value.value }\n         }\n \n@@ -1142,7 +1115,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"evaluating `type_op_ascribe_user_type` `{:?}`\", goal }\n         }\n \n@@ -1153,7 +1125,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"evaluating `type_op_eq` `{:?}`\", goal }\n         }\n \n@@ -1164,7 +1135,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"evaluating `type_op_subtype` `{:?}`\", goal }\n         }\n \n@@ -1175,7 +1145,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"evaluating `type_op_prove_predicate` `{:?}`\", goal }\n         }\n \n@@ -1186,7 +1155,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, Ty<'tcx>>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"normalizing `{:?}`\", goal }\n         }\n \n@@ -1197,7 +1165,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ty::Predicate<'tcx>>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"normalizing `{:?}`\", goal }\n         }\n \n@@ -1208,7 +1175,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ty::PolyFnSig<'tcx>>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"normalizing `{:?}`\", goal }\n         }\n \n@@ -1219,12 +1185,10 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ty::FnSig<'tcx>>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"normalizing `{:?}`\", goal }\n         }\n \n         query substitute_normalize_and_test_predicates(key: (DefId, SubstsRef<'tcx>)) -> bool {\n-            no_force\n             desc { |tcx|\n                 \"testing substituted normalized predicates:`{}`\",\n                 tcx.def_path_str(key.0)\n@@ -1234,7 +1198,6 @@ rustc_queries! {\n         query method_autoderef_steps(\n             goal: CanonicalTyGoal<'tcx>\n         ) -> MethodAutoderefStepsResult<'tcx> {\n-            no_force\n             desc { \"computing autoderef types for `{:?}`\", goal }\n         }\n     }\n@@ -1248,7 +1211,6 @@ rustc_queries! {\n         // Get an estimate of the size of an InstanceDef based on its MIR for CGU partitioning.\n         query instance_def_size_estimate(def: ty::InstanceDef<'tcx>)\n             -> usize {\n-            no_force\n             desc { |tcx| \"estimating size for `{}`\", tcx.def_path_str(def.def_id()) }\n         }\n "}, {"sha": "56b7be2f7e2d531912a1aa88c04a7dbd868dc871", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f4450772ede7bc064d1727430acdb1b2dc851742/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4450772ede7bc064d1727430acdb1b2dc851742/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=f4450772ede7bc064d1727430acdb1b2dc851742", "patch": "@@ -51,9 +51,6 @@ enum QueryModifier {\n     /// Don't hash the result, instead just mark a query red if it runs\n     NoHash,\n \n-    /// Don't force the query\n-    NoForce,\n-\n     /// Generate a dep node based on the dependencies of the query\n     Anon,\n \n@@ -118,8 +115,6 @@ impl Parse for QueryModifier {\n             Ok(QueryModifier::CycleDelayBug)\n         } else if modifier == \"no_hash\" {\n             Ok(QueryModifier::NoHash)\n-        } else if modifier == \"no_force\" {\n-            Ok(QueryModifier::NoForce)\n         } else if modifier == \"anon\" {\n             Ok(QueryModifier::Anon)\n         } else if modifier == \"eval_always\" {\n@@ -222,9 +217,6 @@ struct QueryModifiers {\n     /// Don't hash the result, instead just mark a query red if it runs\n     no_hash: bool,\n \n-    /// Don't force the query\n-    no_force: bool,\n-\n     /// Generate a dep node based on the dependencies of the query\n     anon: bool,\n \n@@ -241,7 +233,6 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n     let mut fatal_cycle = false;\n     let mut cycle_delay_bug = false;\n     let mut no_hash = false;\n-    let mut no_force = false;\n     let mut anon = false;\n     let mut eval_always = false;\n     for modifier in query.modifiers.0.drain(..) {\n@@ -288,12 +279,6 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n                 }\n                 no_hash = true;\n             }\n-            QueryModifier::NoForce => {\n-                if no_force {\n-                    panic!(\"duplicate modifier `no_force` for query `{}`\", query.name);\n-                }\n-                no_force = true;\n-            }\n             QueryModifier::Anon => {\n                 if anon {\n                     panic!(\"duplicate modifier `anon` for query `{}`\", query.name);\n@@ -316,7 +301,6 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n         fatal_cycle,\n         cycle_delay_bug,\n         no_hash,\n-        no_force,\n         anon,\n         eval_always,\n     }"}]}