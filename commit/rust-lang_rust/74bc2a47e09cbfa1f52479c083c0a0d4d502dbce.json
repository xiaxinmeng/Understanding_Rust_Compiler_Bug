{"sha": "74bc2a47e09cbfa1f52479c083c0a0d4d502dbce", "node_id": "C_kwDOAAsO6NoAKDc0YmMyYTQ3ZTA5Y2JmYTFmNTI0NzljMDgzYzBhMGQ0ZDUwMmRiY2U", "commit": {"author": {"name": "Luna Razzaghipour", "email": "lunarazzaghipour@gmail.com", "date": "2023-05-26T17:18:17Z"}, "committer": {"name": "Luna Razzaghipour", "email": "lunarazzaghipour@gmail.com", "date": "2023-05-28T10:37:38Z"}, "message": "Wrap platform-specific QoS in r-a-specific \u201cthread intent\u201d", "tree": {"sha": "d925e7ccb1480b7fb305ca852d3168a2be0bdd81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d925e7ccb1480b7fb305ca852d3168a2be0bdd81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN SSH SIGNATURE-----\nU1NIU0lHAAAAAQAAAGgAAAATZWNkc2Etc2hhMi1uaXN0cDI1NgAAAAhuaXN0cDI1NgAAAE\nEEtPEPU+w9oQ90uLBc4R0g0O7C/w+fcT4a+R4nvkvJXioSPGOafBHNQJufyTj3tLLeNtO4\n1H9ztJfn/DlLu2mXigAAAANnaXQAAAAAAAAABnNoYTUxMgAAAGQAAAATZWNkc2Etc2hhMi\n1uaXN0cDI1NgAAAEkAAAAgRg0occnvpMvNIuDmH+iYnKFurqvu+ReBG3xW5LibQMoAAAAh\nAIXSfrE5sfwMwBIWnG+Ig0hW+pa2W2jGDkJ4QQotgM7V\n-----END SSH SIGNATURE-----", "payload": "tree d925e7ccb1480b7fb305ca852d3168a2be0bdd81\nparent d0b001eed242ff8e2278f033db38f5ae0b3040e9\nauthor Luna Razzaghipour <lunarazzaghipour@gmail.com> 1685121497 +1000\ncommitter Luna Razzaghipour <lunarazzaghipour@gmail.com> 1685270258 +1000\n\nWrap platform-specific QoS in r-a-specific \u201cthread intent\u201d\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce", "html_url": "https://github.com/rust-lang/rust/commit/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/comments", "author": {"login": "lunacookies", "id": 31783266, "node_id": "MDQ6VXNlcjMxNzgzMjY2", "avatar_url": "https://avatars.githubusercontent.com/u/31783266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lunacookies", "html_url": "https://github.com/lunacookies", "followers_url": "https://api.github.com/users/lunacookies/followers", "following_url": "https://api.github.com/users/lunacookies/following{/other_user}", "gists_url": "https://api.github.com/users/lunacookies/gists{/gist_id}", "starred_url": "https://api.github.com/users/lunacookies/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lunacookies/subscriptions", "organizations_url": "https://api.github.com/users/lunacookies/orgs", "repos_url": "https://api.github.com/users/lunacookies/repos", "events_url": "https://api.github.com/users/lunacookies/events{/privacy}", "received_events_url": "https://api.github.com/users/lunacookies/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lunacookies", "id": 31783266, "node_id": "MDQ6VXNlcjMxNzgzMjY2", "avatar_url": "https://avatars.githubusercontent.com/u/31783266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lunacookies", "html_url": "https://github.com/lunacookies", "followers_url": "https://api.github.com/users/lunacookies/followers", "following_url": "https://api.github.com/users/lunacookies/following{/other_user}", "gists_url": "https://api.github.com/users/lunacookies/gists{/gist_id}", "starred_url": "https://api.github.com/users/lunacookies/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lunacookies/subscriptions", "organizations_url": "https://api.github.com/users/lunacookies/orgs", "repos_url": "https://api.github.com/users/lunacookies/repos", "events_url": "https://api.github.com/users/lunacookies/events{/privacy}", "received_events_url": "https://api.github.com/users/lunacookies/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0b001eed242ff8e2278f033db38f5ae0b3040e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0b001eed242ff8e2278f033db38f5ae0b3040e9", "html_url": "https://github.com/rust-lang/rust/commit/d0b001eed242ff8e2278f033db38f5ae0b3040e9"}], "stats": {"total": 649, "additions": 354, "deletions": 295}, "files": [{"sha": "fbb943ccb99ddb78664ff6b3a60ef156eb2ff800", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=74bc2a47e09cbfa1f52479c083c0a0d4d502dbce", "patch": "@@ -90,7 +90,7 @@ impl FlycheckHandle {\n     ) -> FlycheckHandle {\n         let actor = FlycheckActor::new(id, sender, config, workspace_root);\n         let (sender, receiver) = unbounded::<StateChange>();\n-        let thread = stdx::thread::Builder::new(stdx::thread::QoSClass::Utility)\n+        let thread = stdx::thread::Builder::new(stdx::thread::ThreadIntent::Worker)\n             .name(\"Flycheck\".to_owned())\n             .spawn(move || actor.run(receiver))\n             .expect(\"failed to spawn thread\");\n@@ -409,7 +409,7 @@ impl CargoHandle {\n \n         let (sender, receiver) = unbounded();\n         let actor = CargoActor::new(sender, stdout, stderr);\n-        let thread = stdx::thread::Builder::new(stdx::thread::QoSClass::Utility)\n+        let thread = stdx::thread::Builder::new(stdx::thread::ThreadIntent::Worker)\n             .name(\"CargoHandle\".to_owned())\n             .spawn(move || actor.run())\n             .expect(\"failed to spawn thread\");"}, {"sha": "d704d12a05b238b58827aeab8d366af4cd78550d", "filename": "crates/ide/src/prime_caches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Fide%2Fsrc%2Fprime_caches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Fide%2Fsrc%2Fprime_caches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fprime_caches.rs?ref=74bc2a47e09cbfa1f52479c083c0a0d4d502dbce", "patch": "@@ -81,7 +81,7 @@ pub(crate) fn parallel_prime_caches(\n             let worker = prime_caches_worker.clone();\n             let db = db.snapshot();\n \n-            stdx::thread::Builder::new(stdx::thread::QoSClass::Utility)\n+            stdx::thread::Builder::new(stdx::thread::ThreadIntent::Worker)\n                 .allow_leak(true)\n                 .spawn(move || Cancelled::catch(|| worker(db)))\n                 .expect(\"failed to spawn thread\");"}, {"sha": "91911dd180962f45b86d6c0051e96c7332f0c2f9", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=74bc2a47e09cbfa1f52479c083c0a0d4d502dbce", "patch": "@@ -79,13 +79,15 @@ fn try_main(flags: flags::RustAnalyzer) -> Result<()> {\n                 return Ok(());\n             }\n \n-            // rust-analyzer\u2019s \u201cmain thread\u201d is actually a secondary thread\n-            // with an increased stack size at the User Initiated QoS class.\n-            // We use this QoS class because any delay in the main loop\n+            // rust-analyzer\u2019s \u201cmain thread\u201d is actually\n+            // a secondary latency-sensitive thread with an increased stack size.\n+            // We use this thread intent because any delay in the main loop\n             // will make actions like hitting enter in the editor slow.\n-            // rust-analyzer does not block the editor\u2019s render loop,\n-            // so we don\u2019t use User Interactive.\n-            with_extra_thread(\"LspServer\", stdx::thread::QoSClass::UserInitiated, run_server)?;\n+            with_extra_thread(\n+                \"LspServer\",\n+                stdx::thread::ThreadIntent::LatencySensitive,\n+                run_server,\n+            )?;\n         }\n         flags::RustAnalyzerCmd::Parse(cmd) => cmd.run()?,\n         flags::RustAnalyzerCmd::Symbols(cmd) => cmd.run()?,\n@@ -143,10 +145,10 @@ const STACK_SIZE: usize = 1024 * 1024 * 8;\n /// space.\n fn with_extra_thread(\n     thread_name: impl Into<String>,\n-    qos_class: stdx::thread::QoSClass,\n+    thread_intent: stdx::thread::ThreadIntent,\n     f: impl FnOnce() -> Result<()> + Send + 'static,\n ) -> Result<()> {\n-    let handle = stdx::thread::Builder::new(qos_class)\n+    let handle = stdx::thread::Builder::new(thread_intent)\n         .name(thread_name.into())\n         .stack_size(STACK_SIZE)\n         .spawn(f)?;"}, {"sha": "ebe77b8dfe72186690fe3ac4c7915dd960521c74", "filename": "crates/rust-analyzer/src/dispatch.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs?ref=74bc2a47e09cbfa1f52479c083c0a0d4d502dbce", "patch": "@@ -4,7 +4,7 @@ use std::{fmt, panic, thread};\n use ide::Cancelled;\n use lsp_server::ExtractError;\n use serde::{de::DeserializeOwned, Serialize};\n-use stdx::thread::QoSClass;\n+use stdx::thread::ThreadIntent;\n \n use crate::{\n     global_state::{GlobalState, GlobalStateSnapshot},\n@@ -104,7 +104,7 @@ impl<'a> RequestDispatcher<'a> {\n             None => return self,\n         };\n \n-        self.global_state.task_pool.handle.spawn(QoSClass::Utility, {\n+        self.global_state.task_pool.handle.spawn(ThreadIntent::Worker, {\n             let world = self.global_state.snapshot();\n             move || {\n                 let result = panic::catch_unwind(move || {\n@@ -135,7 +135,7 @@ impl<'a> RequestDispatcher<'a> {\n         R::Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug,\n         R::Result: Serialize,\n     {\n-        self.on_with_qos::<R>(QoSClass::Utility, f)\n+        self.on_with_thread_intent::<R>(ThreadIntent::Worker, f)\n     }\n \n     /// Dispatches a latency-sensitive request onto the thread pool.\n@@ -148,7 +148,7 @@ impl<'a> RequestDispatcher<'a> {\n         R::Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug,\n         R::Result: Serialize,\n     {\n-        self.on_with_qos::<R>(QoSClass::UserInitiated, f)\n+        self.on_with_thread_intent::<R>(ThreadIntent::LatencySensitive, f)\n     }\n \n     pub(crate) fn finish(&mut self) {\n@@ -163,9 +163,9 @@ impl<'a> RequestDispatcher<'a> {\n         }\n     }\n \n-    fn on_with_qos<R>(\n+    fn on_with_thread_intent<R>(\n         &mut self,\n-        qos_class: QoSClass,\n+        intent: ThreadIntent,\n         f: fn(GlobalStateSnapshot, R::Params) -> Result<R::Result>,\n     ) -> &mut Self\n     where\n@@ -178,7 +178,7 @@ impl<'a> RequestDispatcher<'a> {\n             None => return self,\n         };\n \n-        self.global_state.task_pool.handle.spawn(qos_class, {\n+        self.global_state.task_pool.handle.spawn(intent, {\n             let world = self.global_state.snapshot();\n             move || {\n                 let result = panic::catch_unwind(move || {"}, {"sha": "09de6900c8fb5b1b4b766e645ad20bdf6da50dc4", "filename": "crates/rust-analyzer/src/handlers/notification.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Fnotification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Fnotification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Fnotification.rs?ref=74bc2a47e09cbfa1f52479c083c0a0d4d502dbce", "patch": "@@ -291,7 +291,7 @@ fn run_flycheck(state: &mut GlobalState, vfs_path: VfsPath) -> bool {\n             }\n             Ok(())\n         };\n-        state.task_pool.handle.spawn_with_sender(stdx::thread::QoSClass::Utility, move |_| {\n+        state.task_pool.handle.spawn_with_sender(stdx::thread::ThreadIntent::Worker, move |_| {\n             if let Err(e) = std::panic::catch_unwind(task) {\n                 tracing::error!(\"flycheck task panicked: {e:?}\")\n             }"}, {"sha": "34947fcd6f95b1f801ea4142873776a98c566cff", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=74bc2a47e09cbfa1f52479c083c0a0d4d502dbce", "patch": "@@ -397,7 +397,7 @@ impl GlobalState {\n         tracing::debug!(%cause, \"will prime caches\");\n         let num_worker_threads = self.config.prime_caches_num_threads();\n \n-        self.task_pool.handle.spawn_with_sender(stdx::thread::QoSClass::Utility, {\n+        self.task_pool.handle.spawn_with_sender(stdx::thread::ThreadIntent::Worker, {\n             let analysis = self.snapshot().analysis;\n             move |sender| {\n                 sender.send(Task::PrimeCaches(PrimeCachesProgress::Begin)).unwrap();\n@@ -680,7 +680,7 @@ impl GlobalState {\n             .on_sync::<lsp_ext::OnTypeFormatting>(handlers::handle_on_type_formatting)\n             // We can\u2019t run latency-sensitive request handlers which do semantic\n             // analysis on the main thread because that would block other\n-            // requests. Instead, we run these request handlers on higher QoS\n+            // requests. Instead, we run these request handlers on higher priority\n             // threads in the threadpool.\n             .on_latency_sensitive::<lsp_types::request::Completion>(handlers::handle_completion)\n             .on_latency_sensitive::<lsp_types::request::ResolveCompletionItem>(\n@@ -789,8 +789,8 @@ impl GlobalState {\n         let snapshot = self.snapshot();\n \n         // Diagnostics are triggered by the user typing\n-        // so we want computing them to run at the User Initiated QoS.\n-        self.task_pool.handle.spawn(stdx::thread::QoSClass::UserInitiated, move || {\n+        // so we run them on a latency sensitive thread.\n+        self.task_pool.handle.spawn(stdx::thread::ThreadIntent::LatencySensitive, move || {\n             let _p = profile::span(\"publish_diagnostics\");\n             let diagnostics = subscriptions\n                 .into_iter()"}, {"sha": "6e8c8ea91a1b35b5ec6e3685d41480bff58df06e", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=74bc2a47e09cbfa1f52479c083c0a0d4d502dbce", "patch": "@@ -27,7 +27,7 @@ use ide_db::{\n use itertools::Itertools;\n use proc_macro_api::{MacroDylib, ProcMacroServer};\n use project_model::{PackageRoot, ProjectWorkspace, WorkspaceBuildScripts};\n-use stdx::format_to;\n+use stdx::{format_to, thread::ThreadIntent};\n use syntax::SmolStr;\n use triomphe::Arc;\n use vfs::{file_set::FileSetConfig, AbsPath, AbsPathBuf, ChangeKind};\n@@ -185,7 +185,7 @@ impl GlobalState {\n     pub(crate) fn fetch_workspaces(&mut self, cause: Cause) {\n         tracing::info!(%cause, \"will fetch workspaces\");\n \n-        self.task_pool.handle.spawn_with_sender(stdx::thread::QoSClass::Utility, {\n+        self.task_pool.handle.spawn_with_sender(ThreadIntent::Worker, {\n             let linked_projects = self.config.linked_projects();\n             let detached_files = self.config.detached_files().to_vec();\n             let cargo_config = self.config.cargo();\n@@ -260,7 +260,7 @@ impl GlobalState {\n         tracing::info!(%cause, \"will fetch build data\");\n         let workspaces = Arc::clone(&self.workspaces);\n         let config = self.config.cargo();\n-        self.task_pool.handle.spawn_with_sender(stdx::thread::QoSClass::Utility, move |sender| {\n+        self.task_pool.handle.spawn_with_sender(ThreadIntent::Worker, move |sender| {\n             sender.send(Task::FetchBuildData(BuildDataProgress::Begin)).unwrap();\n \n             let progress = {\n@@ -280,7 +280,7 @@ impl GlobalState {\n         let dummy_replacements = self.config.dummy_replacements().clone();\n         let proc_macro_clients = self.proc_macro_clients.clone();\n \n-        self.task_pool.handle.spawn_with_sender(stdx::thread::QoSClass::Utility, move |sender| {\n+        self.task_pool.handle.spawn_with_sender(ThreadIntent::Worker, move |sender| {\n             sender.send(Task::LoadProcMacros(ProcMacroProgress::Begin)).unwrap();\n \n             let dummy_replacements = &dummy_replacements;"}, {"sha": "a5a10e86914e0fbcab3f96dbfee7984bccebf914", "filename": "crates/rust-analyzer/src/task_pool.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Frust-analyzer%2Fsrc%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Frust-analyzer%2Fsrc%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Ftask_pool.rs?ref=74bc2a47e09cbfa1f52479c083c0a0d4d502dbce", "patch": "@@ -2,7 +2,7 @@\n //! It is used in [`crate::global_state::GlobalState`] throughout the main loop.\n \n use crossbeam_channel::Sender;\n-use stdx::thread::{Pool, QoSClass};\n+use stdx::thread::{Pool, ThreadIntent};\n \n pub(crate) struct TaskPool<T> {\n     sender: Sender<T>,\n@@ -14,23 +14,23 @@ impl<T> TaskPool<T> {\n         TaskPool { sender, pool: Pool::new(threads) }\n     }\n \n-    pub(crate) fn spawn<F>(&mut self, qos_class: QoSClass, task: F)\n+    pub(crate) fn spawn<F>(&mut self, intent: ThreadIntent, task: F)\n     where\n         F: FnOnce() -> T + Send + 'static,\n         T: Send + 'static,\n     {\n-        self.pool.spawn(qos_class, {\n+        self.pool.spawn(intent, {\n             let sender = self.sender.clone();\n             move || sender.send(task()).unwrap()\n         })\n     }\n \n-    pub(crate) fn spawn_with_sender<F>(&mut self, qos_class: QoSClass, task: F)\n+    pub(crate) fn spawn_with_sender<F>(&mut self, intent: ThreadIntent, task: F)\n     where\n         F: FnOnce(Sender<T>) + Send + 'static,\n         T: Send + 'static,\n     {\n-        self.pool.spawn(qos_class, {\n+        self.pool.spawn(intent, {\n             let sender = self.sender.clone();\n             move || task(sender)\n         })"}, {"sha": "b2a8041ae9b57ba904d6d383de1a3f09e81ecd1b", "filename": "crates/rust-analyzer/tests/slow-tests/support.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs?ref=74bc2a47e09cbfa1f52479c083c0a0d4d502dbce", "patch": "@@ -165,7 +165,7 @@ impl Server {\n     fn new(dir: TestDir, config: Config) -> Server {\n         let (connection, client) = Connection::memory();\n \n-        let _thread = stdx::thread::Builder::new(stdx::thread::QoSClass::Utility)\n+        let _thread = stdx::thread::Builder::new(stdx::thread::ThreadIntent::Worker)\n             .name(\"test server\".to_string())\n             .spawn(move || main_loop(config, connection).unwrap())\n             .expect(\"failed to spawn a thread\");"}, {"sha": "e577eb4313714fd3dc596a5aa3976b619fcc59c1", "filename": "crates/stdx/src/thread.rs", "status": "modified", "additions": 17, "deletions": 244, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Fstdx%2Fsrc%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Fstdx%2Fsrc%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Fthread.rs?ref=74bc2a47e09cbfa1f52479c083c0a0d4d502dbce", "patch": "@@ -1,39 +1,46 @@\n //! A utility module for working with threads that automatically joins threads upon drop\n-//! and provides functionality for interfacing with operating system quality of service (QoS) APIs.\n+//! and abstracts over operating system quality of service (QoS) APIs\n+//! through the concept of a \u201cthread intent\u201d.\n+//!\n+//! The intent of a thread is frozen at thread creation time,\n+//! i.e. there is no API to change the intent of a thread once it has been spawned.\n //!\n //! As a system, rust-analyzer should have the property that\n //! old manual scheduling APIs are replaced entirely by QoS.\n //! To maintain this invariant, we panic when it is clear that\n //! old scheduling APIs have been used.\n //!\n-//! Moreover, we also want to ensure that every thread has a QoS set explicitly\n+//! Moreover, we also want to ensure that every thread has an intent set explicitly\n //! to force a decision about its importance to the system.\n-//! Thus, [`QoSClass`] has no default value\n-//! and every entry point to creating a thread requires a [`QoSClass`] upfront.\n+//! Thus, [`ThreadIntent`] has no default value\n+//! and every entry point to creating a thread requires a [`ThreadIntent`] upfront.\n \n use std::fmt;\n \n+mod intent;\n mod pool;\n+\n+pub use intent::ThreadIntent;\n pub use pool::Pool;\n \n-pub fn spawn<F, T>(qos_class: QoSClass, f: F) -> JoinHandle<T>\n+pub fn spawn<F, T>(intent: ThreadIntent, f: F) -> JoinHandle<T>\n where\n     F: FnOnce() -> T,\n     F: Send + 'static,\n     T: Send + 'static,\n {\n-    Builder::new(qos_class).spawn(f).expect(\"failed to spawn thread\")\n+    Builder::new(intent).spawn(f).expect(\"failed to spawn thread\")\n }\n \n pub struct Builder {\n-    qos_class: QoSClass,\n+    intent: ThreadIntent,\n     inner: jod_thread::Builder,\n     allow_leak: bool,\n }\n \n impl Builder {\n-    pub fn new(qos_class: QoSClass) -> Builder {\n-        Builder { qos_class, inner: jod_thread::Builder::new(), allow_leak: false }\n+    pub fn new(intent: ThreadIntent) -> Builder {\n+        Builder { intent, inner: jod_thread::Builder::new(), allow_leak: false }\n     }\n \n     pub fn name(self, name: String) -> Builder {\n@@ -55,7 +62,7 @@ impl Builder {\n         T: Send + 'static,\n     {\n         let inner_handle = self.inner.spawn(move || {\n-            set_current_thread_qos_class(self.qos_class);\n+            self.intent.apply_to_current_thread();\n             f()\n         })?;\n \n@@ -93,237 +100,3 @@ impl<T> fmt::Debug for JoinHandle<T> {\n         f.pad(\"JoinHandle { .. }\")\n     }\n }\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n-// Please maintain order from least to most priority for the derived `Ord` impl.\n-pub enum QoSClass {\n-    // Documentation adapted from https://github.com/apple-oss-distributions/libpthread/blob/67e155c94093be9a204b69637d198eceff2c7c46/include/sys/qos.h#L55\n-    //\n-    /// TLDR: invisible maintenance tasks\n-    ///\n-    /// Contract:\n-    ///\n-    /// * **You do not care about how long it takes for work to finish.**\n-    /// * **You do not care about work being deferred temporarily.**\n-    ///   (e.g. if the device\u2019s battery is in a critical state)\n-    ///\n-    /// Examples:\n-    ///\n-    /// * in a video editor:\n-    ///   creating periodic backups of project files\n-    /// * in a browser:\n-    ///   cleaning up cached sites which have not been accessed in a long time\n-    /// * in a collaborative word processor:\n-    ///   creating a searchable index of all documents\n-    ///\n-    /// Use this QoS class for background tasks\n-    /// which the user did not initiate themselves\n-    /// and which are invisible to the user.\n-    /// It is expected that this work will take significant time to complete:\n-    /// minutes or even hours.\n-    ///\n-    /// This QoS class provides the most energy and thermally-efficient execution possible.\n-    /// All other work is prioritized over background tasks.\n-    Background,\n-\n-    /// TLDR: tasks that don\u2019t block using your app\n-    ///\n-    /// Contract:\n-    ///\n-    /// * **Your app remains useful even as the task is executing.**\n-    ///\n-    /// Examples:\n-    ///\n-    /// * in a video editor:\n-    ///   exporting a video to disk \u2013\n-    ///   the user can still work on the timeline\n-    /// * in a browser:\n-    ///   automatically extracting a downloaded zip file \u2013\n-    ///   the user can still switch tabs\n-    /// * in a collaborative word processor:\n-    ///   downloading images embedded in a document \u2013\n-    ///   the user can still make edits\n-    ///\n-    /// Use this QoS class for tasks which\n-    /// may or may not be initiated by the user,\n-    /// but whose result is visible.\n-    /// It is expected that this work will take a few seconds to a few minutes.\n-    /// Typically your app will include a progress bar\n-    /// for tasks using this class.\n-    ///\n-    /// This QoS class provides a balance between\n-    /// performance, responsiveness and efficiency.\n-    Utility,\n-\n-    /// TLDR: tasks that block using your app\n-    ///\n-    /// Contract:\n-    ///\n-    /// * **You need this work to complete\n-    ///   before the user can keep interacting with your app.**\n-    /// * **Your work will not take more than a few seconds to complete.**\n-    ///\n-    /// Examples:\n-    ///\n-    /// * in a video editor:\n-    ///   opening a saved project\n-    /// * in a browser:\n-    ///   loading a list of the user\u2019s bookmarks and top sites\n-    ///   when a new tab is created\n-    /// * in a collaborative word processor:\n-    ///   running a search on the document\u2019s content\n-    ///\n-    /// Use this QoS class for tasks which were initiated by the user\n-    /// and block the usage of your app while they are in progress.\n-    /// It is expected that this work will take a few seconds or less to complete;\n-    /// not long enough to cause the user to switch to something else.\n-    /// Your app will likely indicate progress on these tasks\n-    /// through the display of placeholder content or modals.\n-    ///\n-    /// This QoS class is not energy-efficient.\n-    /// Rather, it provides responsiveness\n-    /// by prioritizing work above other tasks on the system\n-    /// except for critical user-interactive work.\n-    UserInitiated,\n-\n-    /// TLDR: render loops and nothing else\n-    ///\n-    /// Contract:\n-    ///\n-    /// * **You absolutely need this work to complete immediately\n-    ///   or your app will appear to freeze.**\n-    /// * **Your work will always complete virtually instantaneously.**\n-    ///\n-    /// Examples:\n-    ///\n-    /// * the main thread in a GUI application\n-    /// * the update & render loop in a game\n-    /// * a secondary thread which progresses an animation\n-    ///\n-    /// Use this QoS class for any work which, if delayed,\n-    /// will make your user interface unresponsive.\n-    /// It is expected that this work will be virtually instantaneous.\n-    ///\n-    /// This QoS class is not energy-efficient.\n-    /// Specifying this class is a request to run with\n-    /// nearly all available system CPU and I/O bandwidth even under contention.\n-    UserInteractive,\n-}\n-\n-pub const IS_QOS_AVAILABLE: bool = imp::IS_QOS_AVAILABLE;\n-\n-pub fn set_current_thread_qos_class(class: QoSClass) {\n-    imp::set_current_thread_qos_class(class)\n-}\n-\n-pub fn get_current_thread_qos_class() -> Option<QoSClass> {\n-    imp::get_current_thread_qos_class()\n-}\n-\n-// All Apple platforms use XNU as their kernel\n-// and thus have the concept of QoS.\n-#[cfg(target_vendor = \"apple\")]\n-mod imp {\n-    use super::QoSClass;\n-\n-    pub(super) const IS_QOS_AVAILABLE: bool = true;\n-\n-    pub(super) fn set_current_thread_qos_class(class: QoSClass) {\n-        let c = match class {\n-            QoSClass::UserInteractive => libc::qos_class_t::QOS_CLASS_USER_INTERACTIVE,\n-            QoSClass::UserInitiated => libc::qos_class_t::QOS_CLASS_USER_INITIATED,\n-            QoSClass::Utility => libc::qos_class_t::QOS_CLASS_UTILITY,\n-            QoSClass::Background => libc::qos_class_t::QOS_CLASS_BACKGROUND,\n-        };\n-\n-        let code = unsafe { libc::pthread_set_qos_class_self_np(c, 0) };\n-\n-        if code == 0 {\n-            return;\n-        }\n-\n-        let errno = unsafe { *libc::__error() };\n-\n-        match errno {\n-            libc::EPERM => {\n-                // This thread has been excluded from the QoS system\n-                // due to a previous call to a function such as `pthread_setschedparam`\n-                // which is incompatible with QoS.\n-                //\n-                // Panic instead of returning an error\n-                // to maintain the invariant that we only use QoS APIs.\n-                panic!(\"tried to set QoS of thread which has opted out of QoS (os error {errno})\")\n-            }\n-\n-            libc::EINVAL => {\n-                // This is returned if we pass something other than a qos_class_t\n-                // to `pthread_set_qos_class_self_np`.\n-                //\n-                // This is impossible, so again panic.\n-                unreachable!(\n-                    \"invalid qos_class_t value was passed to pthread_set_qos_class_self_np\"\n-                )\n-            }\n-\n-            _ => {\n-                // `pthread_set_qos_class_self_np`\u2019s documentation\n-                // does not mention any other errors.\n-                unreachable!(\"`pthread_set_qos_class_self_np` returned unexpected error {errno}\")\n-            }\n-        }\n-    }\n-\n-    pub(super) fn get_current_thread_qos_class() -> Option<QoSClass> {\n-        let current_thread = unsafe { libc::pthread_self() };\n-        let mut qos_class_raw = libc::qos_class_t::QOS_CLASS_UNSPECIFIED;\n-        let code = unsafe {\n-            libc::pthread_get_qos_class_np(current_thread, &mut qos_class_raw, std::ptr::null_mut())\n-        };\n-\n-        if code != 0 {\n-            // `pthread_get_qos_class_np`\u2019s documentation states that\n-            // an error value is placed into errno if the return code is not zero.\n-            // However, it never states what errors are possible.\n-            // Inspecting the source[0] shows that, as of this writing, it always returns zero.\n-            //\n-            // Whatever errors the function could report in future are likely to be\n-            // ones which we cannot handle anyway\n-            //\n-            // 0: https://github.com/apple-oss-distributions/libpthread/blob/67e155c94093be9a204b69637d198eceff2c7c46/src/qos.c#L171-L177\n-            let errno = unsafe { *libc::__error() };\n-            unreachable!(\"`pthread_get_qos_class_np` failed unexpectedly (os error {errno})\");\n-        }\n-\n-        match qos_class_raw {\n-            libc::qos_class_t::QOS_CLASS_USER_INTERACTIVE => Some(QoSClass::UserInteractive),\n-            libc::qos_class_t::QOS_CLASS_USER_INITIATED => Some(QoSClass::UserInitiated),\n-            libc::qos_class_t::QOS_CLASS_DEFAULT => None, // QoS has never been set\n-            libc::qos_class_t::QOS_CLASS_UTILITY => Some(QoSClass::Utility),\n-            libc::qos_class_t::QOS_CLASS_BACKGROUND => Some(QoSClass::Background),\n-\n-            libc::qos_class_t::QOS_CLASS_UNSPECIFIED => {\n-                // Using manual scheduling APIs causes threads to \u201copt out\u201d of QoS.\n-                // At this point they become incompatible with QoS,\n-                // and as such have the \u201cunspecified\u201d QoS class.\n-                //\n-                // Panic instead of returning an error\n-                // to maintain the invariant that we only use QoS APIs.\n-                panic!(\"tried to get QoS of thread which has opted out of QoS\")\n-            }\n-        }\n-    }\n-}\n-\n-// FIXME: Windows has QoS APIs, we should use them!\n-#[cfg(not(target_vendor = \"apple\"))]\n-mod imp {\n-    use super::QoSClass;\n-\n-    pub(super) const IS_QOS_AVAILABLE: bool = false;\n-\n-    pub(super) fn set_current_thread_qos_class(_: QoSClass) {}\n-\n-    pub(super) fn get_current_thread_qos_class() -> Option<QoSClass> {\n-        None\n-    }\n-}"}, {"sha": "7b65db30cc5b02ce3a4110def5f32bba7f64363d", "filename": "crates/stdx/src/thread/intent.rs", "status": "added", "additions": 287, "deletions": 0, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Fstdx%2Fsrc%2Fthread%2Fintent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Fstdx%2Fsrc%2Fthread%2Fintent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Fthread%2Fintent.rs?ref=74bc2a47e09cbfa1f52479c083c0a0d4d502dbce", "patch": "@@ -0,0 +1,287 @@\n+//! An opaque fa\u00e7ade around platform-specific QoS APIs.\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+// Please maintain order from least to most priority for the derived `Ord` impl.\n+pub enum ThreadIntent {\n+    /// Any thread which does work that isn\u2019t in the critical path of the user typing\n+    /// (e.g. processing Go To Definition).\n+    Worker,\n+\n+    /// Any thread which does work caused by the user typing\n+    /// (e.g. processing syntax highlighting).\n+    LatencySensitive,\n+}\n+\n+impl ThreadIntent {\n+    // These APIs must remain private;\n+    // we only want consumers to set thread intent\n+    // either during thread creation or using our pool impl.\n+\n+    pub(super) fn apply_to_current_thread(self) {\n+        let class = thread_intent_to_qos_class(self);\n+        set_current_thread_qos_class(class);\n+    }\n+\n+    pub(super) fn assert_is_used_on_current_thread(self) {\n+        if IS_QOS_AVAILABLE {\n+            let class = thread_intent_to_qos_class(self);\n+            assert_eq!(get_current_thread_qos_class(), Some(class));\n+        }\n+    }\n+}\n+\n+use imp::QoSClass;\n+\n+const IS_QOS_AVAILABLE: bool = imp::IS_QOS_AVAILABLE;\n+\n+fn set_current_thread_qos_class(class: QoSClass) {\n+    imp::set_current_thread_qos_class(class)\n+}\n+\n+fn get_current_thread_qos_class() -> Option<QoSClass> {\n+    imp::get_current_thread_qos_class()\n+}\n+\n+fn thread_intent_to_qos_class(intent: ThreadIntent) -> QoSClass {\n+    imp::thread_intent_to_qos_class(intent)\n+}\n+\n+// All Apple platforms use XNU as their kernel\n+// and thus have the concept of QoS.\n+#[cfg(target_vendor = \"apple\")]\n+mod imp {\n+    use super::ThreadIntent;\n+\n+    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+    // Please maintain order from least to most priority for the derived `Ord` impl.\n+    pub(super) enum QoSClass {\n+        // Documentation adapted from https://github.com/apple-oss-distributions/libpthread/blob/67e155c94093be9a204b69637d198eceff2c7c46/include/sys/qos.h#L55\n+        //\n+        /// TLDR: invisible maintenance tasks\n+        ///\n+        /// Contract:\n+        ///\n+        /// * **You do not care about how long it takes for work to finish.**\n+        /// * **You do not care about work being deferred temporarily.**\n+        ///   (e.g. if the device\u2019s battery is in a critical state)\n+        ///\n+        /// Examples:\n+        ///\n+        /// * in a video editor:\n+        ///   creating periodic backups of project files\n+        /// * in a browser:\n+        ///   cleaning up cached sites which have not been accessed in a long time\n+        /// * in a collaborative word processor:\n+        ///   creating a searchable index of all documents\n+        ///\n+        /// Use this QoS class for background tasks\n+        /// which the user did not initiate themselves\n+        /// and which are invisible to the user.\n+        /// It is expected that this work will take significant time to complete:\n+        /// minutes or even hours.\n+        ///\n+        /// This QoS class provides the most energy and thermally-efficient execution possible.\n+        /// All other work is prioritized over background tasks.\n+        Background,\n+\n+        /// TLDR: tasks that don\u2019t block using your app\n+        ///\n+        /// Contract:\n+        ///\n+        /// * **Your app remains useful even as the task is executing.**\n+        ///\n+        /// Examples:\n+        ///\n+        /// * in a video editor:\n+        ///   exporting a video to disk \u2013\n+        ///   the user can still work on the timeline\n+        /// * in a browser:\n+        ///   automatically extracting a downloaded zip file \u2013\n+        ///   the user can still switch tabs\n+        /// * in a collaborative word processor:\n+        ///   downloading images embedded in a document \u2013\n+        ///   the user can still make edits\n+        ///\n+        /// Use this QoS class for tasks which\n+        /// may or may not be initiated by the user,\n+        /// but whose result is visible.\n+        /// It is expected that this work will take a few seconds to a few minutes.\n+        /// Typically your app will include a progress bar\n+        /// for tasks using this class.\n+        ///\n+        /// This QoS class provides a balance between\n+        /// performance, responsiveness and efficiency.\n+        Utility,\n+\n+        /// TLDR: tasks that block using your app\n+        ///\n+        /// Contract:\n+        ///\n+        /// * **You need this work to complete\n+        ///   before the user can keep interacting with your app.**\n+        /// * **Your work will not take more than a few seconds to complete.**\n+        ///\n+        /// Examples:\n+        ///\n+        /// * in a video editor:\n+        ///   opening a saved project\n+        /// * in a browser:\n+        ///   loading a list of the user\u2019s bookmarks and top sites\n+        ///   when a new tab is created\n+        /// * in a collaborative word processor:\n+        ///   running a search on the document\u2019s content\n+        ///\n+        /// Use this QoS class for tasks which were initiated by the user\n+        /// and block the usage of your app while they are in progress.\n+        /// It is expected that this work will take a few seconds or less to complete;\n+        /// not long enough to cause the user to switch to something else.\n+        /// Your app will likely indicate progress on these tasks\n+        /// through the display of placeholder content or modals.\n+        ///\n+        /// This QoS class is not energy-efficient.\n+        /// Rather, it provides responsiveness\n+        /// by prioritizing work above other tasks on the system\n+        /// except for critical user-interactive work.\n+        UserInitiated,\n+\n+        /// TLDR: render loops and nothing else\n+        ///\n+        /// Contract:\n+        ///\n+        /// * **You absolutely need this work to complete immediately\n+        ///   or your app will appear to freeze.**\n+        /// * **Your work will always complete virtually instantaneously.**\n+        ///\n+        /// Examples:\n+        ///\n+        /// * the main thread in a GUI application\n+        /// * the update & render loop in a game\n+        /// * a secondary thread which progresses an animation\n+        ///\n+        /// Use this QoS class for any work which, if delayed,\n+        /// will make your user interface unresponsive.\n+        /// It is expected that this work will be virtually instantaneous.\n+        ///\n+        /// This QoS class is not energy-efficient.\n+        /// Specifying this class is a request to run with\n+        /// nearly all available system CPU and I/O bandwidth even under contention.\n+        UserInteractive,\n+    }\n+\n+    pub(super) const IS_QOS_AVAILABLE: bool = true;\n+\n+    pub(super) fn set_current_thread_qos_class(class: QoSClass) {\n+        let c = match class {\n+            QoSClass::UserInteractive => libc::qos_class_t::QOS_CLASS_USER_INTERACTIVE,\n+            QoSClass::UserInitiated => libc::qos_class_t::QOS_CLASS_USER_INITIATED,\n+            QoSClass::Utility => libc::qos_class_t::QOS_CLASS_UTILITY,\n+            QoSClass::Background => libc::qos_class_t::QOS_CLASS_BACKGROUND,\n+        };\n+\n+        let code = unsafe { libc::pthread_set_qos_class_self_np(c, 0) };\n+\n+        if code == 0 {\n+            return;\n+        }\n+\n+        let errno = unsafe { *libc::__error() };\n+\n+        match errno {\n+            libc::EPERM => {\n+                // This thread has been excluded from the QoS system\n+                // due to a previous call to a function such as `pthread_setschedparam`\n+                // which is incompatible with QoS.\n+                //\n+                // Panic instead of returning an error\n+                // to maintain the invariant that we only use QoS APIs.\n+                panic!(\"tried to set QoS of thread which has opted out of QoS (os error {errno})\")\n+            }\n+\n+            libc::EINVAL => {\n+                // This is returned if we pass something other than a qos_class_t\n+                // to `pthread_set_qos_class_self_np`.\n+                //\n+                // This is impossible, so again panic.\n+                unreachable!(\n+                    \"invalid qos_class_t value was passed to pthread_set_qos_class_self_np\"\n+                )\n+            }\n+\n+            _ => {\n+                // `pthread_set_qos_class_self_np`\u2019s documentation\n+                // does not mention any other errors.\n+                unreachable!(\"`pthread_set_qos_class_self_np` returned unexpected error {errno}\")\n+            }\n+        }\n+    }\n+\n+    pub(super) fn get_current_thread_qos_class() -> Option<QoSClass> {\n+        let current_thread = unsafe { libc::pthread_self() };\n+        let mut qos_class_raw = libc::qos_class_t::QOS_CLASS_UNSPECIFIED;\n+        let code = unsafe {\n+            libc::pthread_get_qos_class_np(current_thread, &mut qos_class_raw, std::ptr::null_mut())\n+        };\n+\n+        if code != 0 {\n+            // `pthread_get_qos_class_np`\u2019s documentation states that\n+            // an error value is placed into errno if the return code is not zero.\n+            // However, it never states what errors are possible.\n+            // Inspecting the source[0] shows that, as of this writing, it always returns zero.\n+            //\n+            // Whatever errors the function could report in future are likely to be\n+            // ones which we cannot handle anyway\n+            //\n+            // 0: https://github.com/apple-oss-distributions/libpthread/blob/67e155c94093be9a204b69637d198eceff2c7c46/src/qos.c#L171-L177\n+            let errno = unsafe { *libc::__error() };\n+            unreachable!(\"`pthread_get_qos_class_np` failed unexpectedly (os error {errno})\");\n+        }\n+\n+        match qos_class_raw {\n+            libc::qos_class_t::QOS_CLASS_USER_INTERACTIVE => Some(QoSClass::UserInteractive),\n+            libc::qos_class_t::QOS_CLASS_USER_INITIATED => Some(QoSClass::UserInitiated),\n+            libc::qos_class_t::QOS_CLASS_DEFAULT => None, // QoS has never been set\n+            libc::qos_class_t::QOS_CLASS_UTILITY => Some(QoSClass::Utility),\n+            libc::qos_class_t::QOS_CLASS_BACKGROUND => Some(QoSClass::Background),\n+\n+            libc::qos_class_t::QOS_CLASS_UNSPECIFIED => {\n+                // Using manual scheduling APIs causes threads to \u201copt out\u201d of QoS.\n+                // At this point they become incompatible with QoS,\n+                // and as such have the \u201cunspecified\u201d QoS class.\n+                //\n+                // Panic instead of returning an error\n+                // to maintain the invariant that we only use QoS APIs.\n+                panic!(\"tried to get QoS of thread which has opted out of QoS\")\n+            }\n+        }\n+    }\n+\n+    pub(super) fn thread_intent_to_qos_class(intent: ThreadIntent) -> QoSClass {\n+        match intent {\n+            ThreadIntent::Worker => QoSClass::Utility,\n+            ThreadIntent::LatencySensitive => QoSClass::UserInitiated,\n+        }\n+    }\n+}\n+\n+// FIXME: Windows has QoS APIs, we should use them!\n+#[cfg(not(target_vendor = \"apple\"))]\n+mod imp {\n+    use super::ThreadIntent;\n+\n+    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+    pub(super) enum QoSClass {\n+        Default,\n+    }\n+\n+    pub(super) const IS_QOS_AVAILABLE: bool = false;\n+\n+    pub(super) fn set_current_thread_qos_class(_: QoSClass) {}\n+\n+    pub(super) fn get_current_thread_qos_class() -> Option<QoSClass> {\n+        None\n+    }\n+\n+    pub(super) fn thread_intent_to_qos_class(_: ThreadIntent) -> QoSClass {\n+        QoSClass::Default\n+    }\n+}"}, {"sha": "2ddd7da74c291d29d73c2c15a215e52239028ed3", "filename": "crates/stdx/src/thread/pool.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Fstdx%2Fsrc%2Fthread%2Fpool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Fstdx%2Fsrc%2Fthread%2Fpool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Fthread%2Fpool.rs?ref=74bc2a47e09cbfa1f52479c083c0a0d4d502dbce", "patch": "@@ -1,6 +1,7 @@\n //! [`Pool`] implements a basic custom thread pool\n //! inspired by the [`threadpool` crate](http://docs.rs/threadpool).\n-//! It allows the spawning of tasks under different QoS classes.\n+//! When you spawn a task you specify a thread intent\n+//! so the pool can schedule it to run on a thread with that intent.\n //! rust-analyzer uses this to prioritize work based on latency requirements.\n //!\n //! The thread pool is implemented entirely using\n@@ -13,10 +14,7 @@ use std::sync::{\n \n use crossbeam_channel::{Receiver, Sender};\n \n-use super::{\n-    get_current_thread_qos_class, set_current_thread_qos_class, Builder, JoinHandle, QoSClass,\n-    IS_QOS_AVAILABLE,\n-};\n+use super::{Builder, JoinHandle, ThreadIntent};\n \n pub struct Pool {\n     // `_handles` is never read: the field is present\n@@ -32,32 +30,32 @@ pub struct Pool {\n }\n \n struct Job {\n-    requested_qos_class: QoSClass,\n+    requested_intent: ThreadIntent,\n     f: Box<dyn FnOnce() + Send + 'static>,\n }\n \n impl Pool {\n     pub fn new(threads: usize) -> Pool {\n         const STACK_SIZE: usize = 8 * 1024 * 1024;\n-        const INITIAL_QOS_CLASS: QoSClass = QoSClass::Utility;\n+        const INITIAL_INTENT: ThreadIntent = ThreadIntent::Worker;\n \n         let (job_sender, job_receiver) = crossbeam_channel::unbounded();\n         let extant_tasks = Arc::new(AtomicUsize::new(0));\n \n         let mut handles = Vec::with_capacity(threads);\n         for _ in 0..threads {\n-            let handle = Builder::new(INITIAL_QOS_CLASS)\n+            let handle = Builder::new(INITIAL_INTENT)\n                 .stack_size(STACK_SIZE)\n                 .name(\"Worker\".into())\n                 .spawn({\n                     let extant_tasks = Arc::clone(&extant_tasks);\n                     let job_receiver: Receiver<Job> = job_receiver.clone();\n                     move || {\n-                        let mut current_qos_class = INITIAL_QOS_CLASS;\n+                        let mut current_intent = INITIAL_INTENT;\n                         for job in job_receiver {\n-                            if job.requested_qos_class != current_qos_class {\n-                                set_current_thread_qos_class(job.requested_qos_class);\n-                                current_qos_class = job.requested_qos_class;\n+                            if job.requested_intent != current_intent {\n+                                job.requested_intent.apply_to_current_thread();\n+                                current_intent = job.requested_intent;\n                             }\n                             extant_tasks.fetch_add(1, Ordering::SeqCst);\n                             (job.f)();\n@@ -73,19 +71,18 @@ impl Pool {\n         Pool { _handles: handles, extant_tasks, job_sender }\n     }\n \n-    pub fn spawn<F>(&self, qos_class: QoSClass, f: F)\n+    pub fn spawn<F>(&self, intent: ThreadIntent, f: F)\n     where\n         F: FnOnce() + Send + 'static,\n     {\n         let f = Box::new(move || {\n-            if IS_QOS_AVAILABLE {\n-                debug_assert_eq!(get_current_thread_qos_class(), Some(qos_class));\n+            if cfg!(debug_assertions) {\n+                intent.assert_is_used_on_current_thread();\n             }\n-\n             f()\n         });\n \n-        let job = Job { requested_qos_class: qos_class, f };\n+        let job = Job { requested_intent: intent, f };\n         self.job_sender.send(job).unwrap();\n     }\n "}, {"sha": "abfc51dfec66f587795382430854b21cafe63507", "filename": "crates/vfs-notify/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bc2a47e09cbfa1f52479c083c0a0d4d502dbce/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs-notify%2Fsrc%2Flib.rs?ref=74bc2a47e09cbfa1f52479c083c0a0d4d502dbce", "patch": "@@ -34,7 +34,7 @@ impl loader::Handle for NotifyHandle {\n     fn spawn(sender: loader::Sender) -> NotifyHandle {\n         let actor = NotifyActor::new(sender);\n         let (sender, receiver) = unbounded::<Message>();\n-        let thread = stdx::thread::Builder::new(stdx::thread::QoSClass::Utility)\n+        let thread = stdx::thread::Builder::new(stdx::thread::ThreadIntent::Worker)\n             .name(\"VfsLoader\".to_owned())\n             .spawn(move || actor.run(receiver))\n             .expect(\"failed to spawn thread\");"}]}