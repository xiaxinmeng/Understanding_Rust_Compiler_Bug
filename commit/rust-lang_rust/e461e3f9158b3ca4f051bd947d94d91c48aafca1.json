{"sha": "e461e3f9158b3ca4f051bd947d94d91c48aafca1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0NjFlM2Y5MTU4YjNjYTRmMDUxYmQ5NDdkOTRkOTFjNDhhYWZjYTE=", "commit": {"author": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2017-09-16T22:45:28Z"}, "committer": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2017-09-16T22:45:28Z"}, "message": "Format loops.rs with latest stable rustfmt", "tree": {"sha": "22981a9c8b48733a0ed99494a7a24473e23cf432", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22981a9c8b48733a0ed99494a7a24473e23cf432"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e461e3f9158b3ca4f051bd947d94d91c48aafca1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e461e3f9158b3ca4f051bd947d94d91c48aafca1", "html_url": "https://github.com/rust-lang/rust/commit/e461e3f9158b3ca4f051bd947d94d91c48aafca1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e461e3f9158b3ca4f051bd947d94d91c48aafca1/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "708a81809498780760d6992ee86dd0aa47d32bde", "url": "https://api.github.com/repos/rust-lang/rust/commits/708a81809498780760d6992ee86dd0aa47d32bde", "html_url": "https://github.com/rust-lang/rust/commit/708a81809498780760d6992ee86dd0aa47d32bde"}], "stats": {"total": 237, "additions": 134, "deletions": 103}, "files": [{"sha": "260f9b8884b9e29b1b5a818bb2347bedf458f888", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 134, "deletions": 103, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/e461e3f9158b3ca4f051bd947d94d91c48aafca1/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e461e3f9158b3ca4f051bd947d94d91c48aafca1/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=e461e3f9158b3ca4f051bd947d94d91c48aafca1", "patch": "@@ -361,8 +361,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n         // check for never_loop\n         match expr.node {\n-            ExprWhile(_, ref block, _) | ExprLoop(ref block, _, _) => if never_loop(block, &expr.id) {\n-                span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\");\n+            ExprWhile(_, ref block, _) |\n+            ExprLoop(ref block, _, _) => {\n+                if never_loop(block, &expr.id) {\n+                    span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\");\n+                }\n             },\n             _ => (),\n         }\n@@ -389,7 +392,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 if let ExprMatch(ref matchexpr, ref arms, ref source) = inner.node {\n                     // ensure \"if let\" compatible match structure\n                     match *source {\n-                        MatchSource::Normal | MatchSource::IfLetDesugar { .. } => {\n+                        MatchSource::Normal |\n+                        MatchSource::IfLetDesugar { .. } => {\n                             if arms.len() == 2 && arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n                                 arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n                                 is_simple_break_expr(&arms[1].body)\n@@ -424,10 +428,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         }\n         if let ExprMatch(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.node {\n             let pat = &arms[0].pats[0].node;\n-            if let (\n-                &PatKind::TupleStruct(ref qpath, ref pat_args, _),\n-                &ExprMethodCall(ref method_path, _, ref method_args),\n-            ) = (pat, &match_expr.node)\n+            if let (&PatKind::TupleStruct(ref qpath, ref pat_args, _),\n+                    &ExprMethodCall(ref method_path, _, ref method_args)) = (pat, &match_expr.node)\n             {\n                 let iter_expr = &method_args[0];\n                 let lhs_constructor = last_path_segment(qpath);\n@@ -474,25 +476,28 @@ fn never_loop(block: &Block, id: &NodeId) -> bool {\n \n fn contains_continue_block(block: &Block, dest: &NodeId) -> bool {\n     block.stmts.iter().any(|e| contains_continue_stmt(e, dest)) ||\n-        block\n-            .expr\n-            .as_ref()\n-            .map_or(false, |e| contains_continue_expr(e, dest))\n+        block.expr.as_ref().map_or(\n+            false,\n+            |e| contains_continue_expr(e, dest),\n+        )\n }\n \n fn contains_continue_stmt(stmt: &Stmt, dest: &NodeId) -> bool {\n     match stmt.node {\n-        StmtSemi(ref e, _) | StmtExpr(ref e, _) => contains_continue_expr(e, dest),\n+        StmtSemi(ref e, _) |\n+        StmtExpr(ref e, _) => contains_continue_expr(e, dest),\n         StmtDecl(ref d, _) => contains_continue_decl(d, dest),\n     }\n }\n \n fn contains_continue_decl(decl: &Decl, dest: &NodeId) -> bool {\n     match decl.node {\n-        DeclLocal(ref local) => local\n-            .init\n-            .as_ref()\n-            .map_or(false, |e| contains_continue_expr(e, dest)),\n+        DeclLocal(ref local) => {\n+            local.init.as_ref().map_or(\n+                false,\n+                |e| contains_continue_expr(e, dest),\n+            )\n+        },\n         _ => false,\n     }\n }\n@@ -508,27 +513,33 @@ fn contains_continue_expr(expr: &Expr, dest: &NodeId) -> bool {\n         ExprTupField(ref e, _) |\n         ExprAddrOf(_, ref e) |\n         ExprRepeat(ref e, _) => contains_continue_expr(e, dest),\n-        ExprArray(ref es) | ExprMethodCall(_, _, ref es) | ExprTup(ref es) => {\n-            es.iter().any(|e| contains_continue_expr(e, dest))\n-        },\n+        ExprArray(ref es) |\n+        ExprMethodCall(_, _, ref es) |\n+        ExprTup(ref es) => es.iter().any(|e| contains_continue_expr(e, dest)),\n         ExprCall(ref e, ref es) => {\n             contains_continue_expr(e, dest) || es.iter().any(|e| contains_continue_expr(e, dest))\n         },\n         ExprBinary(_, ref e1, ref e2) |\n         ExprAssign(ref e1, ref e2) |\n         ExprAssignOp(_, ref e1, ref e2) |\n         ExprIndex(ref e1, ref e2) => [e1, e2].iter().any(|e| contains_continue_expr(e, dest)),\n-        ExprIf(ref e, ref e2, ref e3) => [e, e2]\n-            .iter()\n-            .chain(e3.as_ref().iter())\n-            .any(|e| contains_continue_expr(e, dest)),\n+        ExprIf(ref e, ref e2, ref e3) => {\n+            [e, e2].iter().chain(e3.as_ref().iter()).any(|e| {\n+                contains_continue_expr(e, dest)\n+            })\n+        },\n         ExprWhile(ref e, ref b, _) => contains_continue_expr(e, dest) || contains_continue_block(b, dest),\n         ExprMatch(ref e, ref arms, _) => {\n             contains_continue_expr(e, dest) || arms.iter().any(|a| contains_continue_expr(&a.body, dest))\n         },\n-        ExprBlock(ref block) | ExprLoop(ref block, ..) => contains_continue_block(block, dest),\n-        ExprStruct(_, _, ref base) => base.as_ref()\n-            .map_or(false, |e| contains_continue_expr(e, dest)),\n+        ExprBlock(ref block) |\n+        ExprLoop(ref block, ..) => contains_continue_block(block, dest),\n+        ExprStruct(_, _, ref base) => {\n+            base.as_ref().map_or(\n+                false,\n+                |e| contains_continue_expr(e, dest),\n+            )\n+        },\n         ExprAgain(d) => d.target_id.opt_id().map_or(false, |id| id == *dest),\n         _ => false,\n     }\n@@ -540,7 +551,8 @@ fn loop_exit_block(block: &Block) -> bool {\n \n fn loop_exit_stmt(stmt: &Stmt) -> bool {\n     match stmt.node {\n-        StmtSemi(ref e, _) | StmtExpr(ref e, _) => loop_exit_expr(e),\n+        StmtSemi(ref e, _) |\n+        StmtExpr(ref e, _) => loop_exit_expr(e),\n         StmtDecl(ref d, _) => loop_exit_decl(d),\n     }\n }\n@@ -562,7 +574,9 @@ fn loop_exit_expr(expr: &Expr) -> bool {\n         ExprTupField(ref e, _) |\n         ExprAddrOf(_, ref e) |\n         ExprRepeat(ref e, _) => loop_exit_expr(e),\n-        ExprArray(ref es) | ExprMethodCall(_, _, ref es) | ExprTup(ref es) => es.iter().any(|e| loop_exit_expr(e)),\n+        ExprArray(ref es) |\n+        ExprMethodCall(_, _, ref es) |\n+        ExprTup(ref es) => es.iter().any(|e| loop_exit_expr(e)),\n         ExprCall(ref e, ref es) => loop_exit_expr(e) || es.iter().any(|e| loop_exit_expr(e)),\n         ExprBinary(_, ref e1, ref e2) |\n         ExprAssign(ref e1, ref e2) |\n@@ -648,9 +662,11 @@ fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty) -> bool {\n fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: ast::NodeId) -> Option<FixedOffsetVar> {\n     fn extract_offset<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &Expr, var: ast::NodeId) -> Option<String> {\n         match e.node {\n-            ExprLit(ref l) => match l.node {\n-                ast::LitKind::Int(x, _ty) => Some(x.to_string()),\n-                _ => None,\n+            ExprLit(ref l) => {\n+                match l.node {\n+                    ast::LitKind::Int(x, _ty) => Some(x.to_string()),\n+                    _ => None,\n+                }\n             },\n             ExprPath(..) if !same_var(cx, e, var) => Some(snippet_opt(cx, e.span).unwrap_or_else(|| \"??\".into())),\n             _ => None,\n@@ -664,25 +680,29 @@ fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var:\n         }\n \n         let offset = match idx.node {\n-            ExprBinary(op, ref lhs, ref rhs) => match op.node {\n-                BinOp_::BiAdd => {\n-                    let offset_opt = if same_var(cx, lhs, var) {\n-                        extract_offset(cx, rhs, var)\n-                    } else if same_var(cx, rhs, var) {\n-                        extract_offset(cx, lhs, var)\n-                    } else {\n-                        None\n-                    };\n+            ExprBinary(op, ref lhs, ref rhs) => {\n+                match op.node {\n+                    BinOp_::BiAdd => {\n+                        let offset_opt = if same_var(cx, lhs, var) {\n+                            extract_offset(cx, rhs, var)\n+                        } else if same_var(cx, rhs, var) {\n+                            extract_offset(cx, lhs, var)\n+                        } else {\n+                            None\n+                        };\n \n-                    offset_opt.map(Offset::positive)\n-                },\n-                BinOp_::BiSub if same_var(cx, lhs, var) => extract_offset(cx, rhs, var).map(Offset::negative),\n-                _ => None,\n+                        offset_opt.map(Offset::positive)\n+                    },\n+                    BinOp_::BiSub if same_var(cx, lhs, var) => extract_offset(cx, rhs, var).map(Offset::negative),\n+                    _ => None,\n+                }\n             },\n-            ExprPath(..) => if same_var(cx, idx, var) {\n-                Some(Offset::positive(\"0\".into()))\n-            } else {\n-                None\n+            ExprPath(..) => {\n+                if same_var(cx, idx, var) {\n+                    Some(Offset::positive(\"0\".into()))\n+                } else {\n+                    None\n+                }\n             },\n             _ => None,\n         };\n@@ -729,13 +749,12 @@ fn get_indexed_assignments<'a, 'tcx>(\n             .iter()\n             .map(|stmt| match stmt.node {\n                 Stmt_::StmtDecl(..) => None,\n-                Stmt_::StmtExpr(ref e, _node_id) | Stmt_::StmtSemi(ref e, _node_id) => Some(get_assignment(cx, e, var)),\n+                Stmt_::StmtExpr(ref e, _node_id) |\n+                Stmt_::StmtSemi(ref e, _node_id) => Some(get_assignment(cx, e, var)),\n             })\n-            .chain(\n-                expr.as_ref()\n-                    .into_iter()\n-                    .map(|e| Some(get_assignment(cx, &*e, var))),\n-            )\n+            .chain(expr.as_ref().into_iter().map(|e| {\n+                Some(get_assignment(cx, &*e, var))\n+            }))\n             .filter_map(|op| op)\n             .collect::<Option<Vec<_>>>()\n             .unwrap_or_else(|| vec![])\n@@ -754,18 +773,20 @@ fn detect_manual_memcpy<'a, 'tcx>(\n     expr: &'tcx Expr,\n ) {\n     if let Some(higher::Range {\n-        start: Some(start),\n-        ref end,\n-        limits,\n-    }) = higher::range(arg)\n+                    start: Some(start),\n+                    ref end,\n+                    limits,\n+                }) = higher::range(arg)\n     {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, _, _) = pat.node {\n             let print_sum = |arg1: &Offset, arg2: &Offset| -> String {\n                 match (&arg1.value[..], arg1.negate, &arg2.value[..], arg2.negate) {\n                     (\"0\", _, \"0\", _) => \"\".into(),\n-                    (\"0\", _, x, false) | (x, false, \"0\", false) => x.into(),\n-                    (\"0\", _, x, true) | (x, false, \"0\", true) => format!(\"-{}\", x),\n+                    (\"0\", _, x, false) |\n+                    (x, false, \"0\", false) => x.into(),\n+                    (\"0\", _, x, true) |\n+                    (x, false, \"0\", true) => format!(\"-{}\", x),\n                     (x, false, y, false) => format!(\"({} + {})\", x, y),\n                     (x, false, y, true) => format!(\"({} - {})\", x, y),\n                     (x, true, y, false) => format!(\"({} - {})\", y, x),\n@@ -847,10 +868,10 @@ fn check_for_loop_range<'a, 'tcx>(\n     expr: &'tcx Expr,\n ) {\n     if let Some(higher::Range {\n-        start: Some(start),\n-        ref end,\n-        limits,\n-    }) = higher::range(arg)\n+                    start: Some(start),\n+                    ref end,\n+                    limits,\n+                }) = higher::range(arg)\n     {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, ref ident, _) = pat.node {\n@@ -865,11 +886,9 @@ fn check_for_loop_range<'a, 'tcx>(\n \n             // linting condition: we only indexed one variable\n             if visitor.indexed.len() == 1 {\n-                let (indexed, indexed_extent) = visitor\n-                    .indexed\n-                    .into_iter()\n-                    .next()\n-                    .expect(\"already checked that we have exactly 1 element\");\n+                let (indexed, indexed_extent) = visitor.indexed.into_iter().next().expect(\n+                    \"already checked that we have exactly 1 element\",\n+                );\n \n                 // ensure that the indexed variable was declared before the loop, see #601\n                 if let Some(indexed_extent) = indexed_extent {\n@@ -973,10 +992,10 @@ fn is_len_call(expr: &Expr, var: &Name) -> bool {\n fn check_for_loop_reverse_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arg: &'tcx Expr, expr: &'tcx Expr) {\n     // if this for loop is iterating over a two-sided range...\n     if let Some(higher::Range {\n-        start: Some(start),\n-        end: Some(end),\n-        limits,\n-    }) = higher::range(arg)\n+                    start: Some(start),\n+                    end: Some(end),\n+                    limits,\n+                }) = higher::range(arg)\n     {\n         // ...and both sides are compile-time constant integers...\n         let parent_item = cx.tcx.hir.get_parent(arg.id);\n@@ -990,7 +1009,8 @@ fn check_for_loop_reverse_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arg: &'tcx\n                 // who think that this will iterate from the larger value to the\n                 // smaller value.\n                 let (sup, eq) = match (start_idx, end_idx) {\n-                    (&ty::Const{ val: ConstVal::Integral(start_idx), .. }, &ty::Const{ val: ConstVal::Integral(end_idx), .. }) => {\n+                    (&ty::Const { val: ConstVal::Integral(start_idx), .. },\n+                     &ty::Const { val: ConstVal::Integral(end_idx), .. }) => {\n                         (start_idx > end_idx, start_idx == end_idx)\n                     },\n                     _ => (false, false),\n@@ -1162,14 +1182,14 @@ fn check_for_loop_explicit_counter<'a, 'tcx>(\n     // For each candidate, check the parent block to see if\n     // it's initialized to zero at the start of the loop.\n     let map = &cx.tcx.hir;\n-    let parent_scope = map.get_enclosing_scope(expr.id)\n-        .and_then(|id| map.get_enclosing_scope(id));\n+    let parent_scope = map.get_enclosing_scope(expr.id).and_then(|id| {\n+        map.get_enclosing_scope(id)\n+    });\n     if let Some(parent_id) = parent_scope {\n         if let NodeBlock(block) = map.get(parent_id) {\n-            for (id, _) in visitor\n-                .states\n-                .iter()\n-                .filter(|&(_, v)| *v == VarState::IncrOnce)\n+            for (id, _) in visitor.states.iter().filter(\n+                |&(_, v)| *v == VarState::IncrOnce,\n+            )\n             {\n                 let mut visitor2 = InitializeVisitor {\n                     cx: cx,\n@@ -1216,10 +1236,12 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n         if pat.len() == 2 {\n             let arg_span = arg.span;\n             let (new_pat_span, kind, ty, mutbl) = match cx.tables.expr_ty(arg).sty {\n-                ty::TyRef(_, ref tam) => match (&pat[0].node, &pat[1].node) {\n-                    (key, _) if pat_is_wild(key, body) => (pat[1].span, \"value\", tam.ty, tam.mutbl),\n-                    (_, value) if pat_is_wild(value, body) => (pat[0].span, \"key\", tam.ty, MutImmutable),\n-                    _ => return,\n+                ty::TyRef(_, ref tam) => {\n+                    match (&pat[0].node, &pat[1].node) {\n+                        (key, _) if pat_is_wild(key, body) => (pat[1].span, \"value\", tam.ty, tam.mutbl),\n+                        (_, value) if pat_is_wild(value, body) => (pat[0].span, \"key\", tam.ty, MutImmutable),\n+                        _ => return,\n+                    }\n                 },\n                 _ => return,\n             };\n@@ -1282,7 +1304,7 @@ fn match_var(expr: &Expr, var: Name) -> bool {\n \n struct UsedVisitor {\n     var: ast::Name, // var to look for\n-    used: bool,     // has the var been used otherwise?\n+    used: bool, // has the var been used otherwise?\n }\n \n impl<'tcx> Visitor<'tcx> for UsedVisitor {\n@@ -1299,7 +1321,7 @@ impl<'tcx> Visitor<'tcx> for UsedVisitor {\n     }\n }\n \n-struct LocalUsedVisitor <'a, 'tcx: 'a> {\n+struct LocalUsedVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n     local: ast::NodeId,\n     used: bool,\n@@ -1492,15 +1514,19 @@ fn extract_expr_from_first_stmt(block: &Block) -> Option<&Expr> {\n fn extract_first_expr(block: &Block) -> Option<&Expr> {\n     match block.expr {\n         Some(ref expr) if block.stmts.is_empty() => Some(expr),\n-        None if !block.stmts.is_empty() => match block.stmts[0].node {\n-            StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => Some(expr),\n-            StmtDecl(..) => None,\n+        None if !block.stmts.is_empty() => {\n+            match block.stmts[0].node {\n+                StmtExpr(ref expr, _) |\n+                StmtSemi(ref expr, _) => Some(expr),\n+                StmtDecl(..) => None,\n+            }\n         },\n         _ => None,\n     }\n }\n \n-/// Return true if expr contains a single break expr without destination label and\n+/// Return true if expr contains a single break expr without destination label\n+/// and\n /// passed expression. The expression may be within a block.\n fn is_simple_break_expr(expr: &Expr) -> bool {\n     match expr.node {\n@@ -1520,7 +1546,7 @@ fn is_simple_break_expr(expr: &Expr) -> bool {\n // at the start of the loop.\n #[derive(PartialEq)]\n enum VarState {\n-    Initial,  // Not examined yet\n+    Initial, // Not examined yet\n     IncrOnce, // Incremented exactly once, may be a loop counter\n     Declared, // Declared but not (yet) initialized to zero\n     Warn,\n@@ -1529,9 +1555,9 @@ enum VarState {\n \n /// Scan a for loop for variables that are incremented exactly once.\n struct IncrementVisitor<'a, 'tcx: 'a> {\n-    cx: &'a LateContext<'a, 'tcx>,     // context reference\n+    cx: &'a LateContext<'a, 'tcx>, // context reference\n     states: HashMap<NodeId, VarState>, // incremented variables\n-    depth: u32,                        // depth of conditional expressions\n+    depth: u32, // depth of conditional expressions\n     done: bool,\n }\n \n@@ -1585,7 +1611,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n /// Check whether a variable is initialized to zero at the start of a loop.\n struct InitializeVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>, // context reference\n-    end_expr: &'tcx Expr,          // the for loop. Stop scanning here.\n+    end_expr: &'tcx Expr, // the for loop. Stop scanning here.\n     var_id: NodeId,\n     state: VarState,\n     name: Option<Name>,\n@@ -1716,11 +1742,13 @@ fn is_loop_nested(cx: &LateContext, loop_expr: &Expr, iter_expr: &Expr) -> bool\n             return false;\n         }\n         match cx.tcx.hir.find(parent) {\n-            Some(NodeExpr(expr)) => match expr.node {\n-                ExprLoop(..) | ExprWhile(..) => {\n-                    return true;\n-                },\n-                _ => (),\n+            Some(NodeExpr(expr)) => {\n+                match expr.node {\n+                    ExprLoop(..) | ExprWhile(..) => {\n+                        return true;\n+                    },\n+                    _ => (),\n+                }\n             },\n             Some(NodeBlock(block)) => {\n                 let mut block_visitor = LoopNestVisitor {\n@@ -1744,8 +1772,8 @@ fn is_loop_nested(cx: &LateContext, loop_expr: &Expr, iter_expr: &Expr) -> bool\n \n #[derive(PartialEq, Eq)]\n enum Nesting {\n-    Unknown,     // no nesting detected yet\n-    RuledOut,    // the iterator is initialized or assigned within scope\n+    Unknown, // no nesting detected yet\n+    RuledOut, // the iterator is initialized or assigned within scope\n     LookFurther, // no nesting detected, no further walk required\n }\n \n@@ -1775,8 +1803,11 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n             return;\n         }\n         match expr.node {\n-            ExprAssign(ref path, _) | ExprAssignOp(_, ref path, _) => if match_var(path, self.iterator) {\n-                self.nesting = RuledOut;\n+            ExprAssign(ref path, _) |\n+            ExprAssignOp(_, ref path, _) => {\n+                if match_var(path, self.iterator) {\n+                    self.nesting = RuledOut;\n+                }\n             },\n             _ => walk_expr(self, expr),\n         }"}]}