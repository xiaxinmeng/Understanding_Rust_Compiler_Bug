{"sha": "1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlMWYyNWUzMWIxZDI2YmQ2MmFhZjVhNDU1NGQyNWMzM2Y3NWEwZDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-08T04:35:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-08T04:35:03Z"}, "message": "Auto merge of #65196 - Centril:rollup-q06lcxm, r=Centril\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #64726 (rewrite documentation for unimplemented! to clarify use)\n - #65040 (syntax: more cleanups in item and function signature parsing)\n - #65046 (Make `Cell::new` method come first in documentation)\n - #65098 (Add long error explanation for E0561)\n - #65150 (Suggest dereferencing boolean reference when used in 'if' or 'while')\n - #65154 (Fix const generic arguments not displaying in types mismatch diagnostic)\n - #65181 (fix bug in folding for constants)\n - #65187 (use 'invalid argument' for vxWorks)\n\nFailed merges:\n\n - #65179 (Add long error explanation for E0567)\n\nr? @ghost", "tree": {"sha": "b4242094c538f122a5b11143b6a979add704963b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4242094c538f122a5b11143b6a979add704963b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "html_url": "https://github.com/rust-lang/rust/commit/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d304f5c1ff0b86b07f643e733f9fe2d9cd13753e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d304f5c1ff0b86b07f643e733f9fe2d9cd13753e", "html_url": "https://github.com/rust-lang/rust/commit/d304f5c1ff0b86b07f643e733f9fe2d9cd13753e"}, {"sha": "bc7df81642fccf42c4250760e8a4c1ff298feec8", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc7df81642fccf42c4250760e8a4c1ff298feec8", "html_url": "https://github.com/rust-lang/rust/commit/bc7df81642fccf42c4250760e8a4c1ff298feec8"}], "stats": {"total": 778, "additions": 469, "deletions": 309}, "files": [{"sha": "fda103a52d8bc851b8fa4d07f277eb27302d425f", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -229,52 +229,6 @@ pub struct Cell<T: ?Sized> {\n     value: UnsafeCell<T>,\n }\n \n-impl<T:Copy> Cell<T> {\n-    /// Returns a copy of the contained value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::cell::Cell;\n-    ///\n-    /// let c = Cell::new(5);\n-    ///\n-    /// let five = c.get();\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get(&self) -> T {\n-        unsafe{ *self.value.get() }\n-    }\n-\n-    /// Updates the contained value using a function and returns the new value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(cell_update)]\n-    ///\n-    /// use std::cell::Cell;\n-    ///\n-    /// let c = Cell::new(5);\n-    /// let new = c.update(|x| x + 1);\n-    ///\n-    /// assert_eq!(new, 6);\n-    /// assert_eq!(c.get(), 6);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"cell_update\", issue = \"50186\")]\n-    pub fn update<F>(&self, f: F) -> T\n-    where\n-        F: FnOnce(T) -> T,\n-    {\n-        let old = self.get();\n-        let new = f(old);\n-        self.set(new);\n-        new\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: ?Sized> Send for Cell<T> where T: Send {}\n \n@@ -448,6 +402,52 @@ impl<T> Cell<T> {\n     }\n }\n \n+impl<T:Copy> Cell<T> {\n+    /// Returns a copy of the contained value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    ///\n+    /// let five = c.get();\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get(&self) -> T {\n+        unsafe{ *self.value.get() }\n+    }\n+\n+    /// Updates the contained value using a function and returns the new value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(cell_update)]\n+    ///\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    /// let new = c.update(|x| x + 1);\n+    ///\n+    /// assert_eq!(new, 6);\n+    /// assert_eq!(c.get(), 6);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"cell_update\", issue = \"50186\")]\n+    pub fn update<F>(&self, f: F) -> T\n+    where\n+        F: FnOnce(T) -> T,\n+    {\n+        let old = self.get();\n+        let new = f(old);\n+        self.set(new);\n+        new\n+    }\n+}\n+\n impl<T: ?Sized> Cell<T> {\n     /// Returns a raw pointer to the underlying data in this cell.\n     ///"}, {"sha": "1320e63df0635289d00b1ba756bb35182605de92", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -520,57 +520,74 @@ macro_rules! unreachable {\n     });\n }\n \n-/// Indicates unfinished code.\n+/// Indicates unfinished code by panicking with a message of \"not yet implemented\".\n ///\n-/// This can be useful if you are prototyping and are just looking to have your\n-/// code type-check, or if you're implementing a trait that requires multiple\n-/// methods, and you're only planning on using one of them.\n+/// This allows the your code to type-check, which is useful if you are prototyping or\n+/// implementing a trait that requires multiple methods which you don't plan of using all of.\n ///\n /// There is no difference between `unimplemented!` and `todo!` apart from the\n /// name.\n ///\n /// # Panics\n ///\n-/// This will always [panic!](macro.panic.html)\n+/// This will always [panic!](macro.panic.html) because `unimplemented!` is just a\n+/// shorthand for `panic!` with a fixed, specific message.\n+///\n+/// Like `panic!`, this macro has a second form for displaying custom values.\n ///\n /// # Examples\n ///\n /// Here's an example of some in-progress code. We have a trait `Foo`:\n ///\n /// ```\n /// trait Foo {\n-///     fn bar(&self);\n+///     fn bar(&self) -> u8;\n ///     fn baz(&self);\n+///     fn qux(&self) -> Result<u64, ()>;\n /// }\n /// ```\n ///\n-/// We want to implement `Foo` on one of our types, but we also want to work on\n-/// just `bar()` first. In order for our code to compile, we need to implement\n-/// `baz()`, so we can use `unimplemented!`:\n+/// We want to implement `Foo` for 'MyStruct', but so far we only know how to\n+/// implement the `bar()` function. `baz()` and `qux()` will still need to be defined\n+/// in our implementation of `Foo`, but we can use `unimplemented!` in their definitions\n+/// to allow our code to compile.\n+///\n+/// In the meantime, we want to have our program stop running once these\n+/// unimplemented functions are reached.\n ///\n /// ```\n /// # trait Foo {\n-/// #     fn bar(&self);\n+/// #     fn bar(&self) -> u8;\n /// #     fn baz(&self);\n+/// #     fn qux(&self) -> Result<u64, ()>;\n /// # }\n /// struct MyStruct;\n ///\n /// impl Foo for MyStruct {\n-///     fn bar(&self) {\n-///         // implementation goes here\n+///     fn bar(&self) -> u8 {\n+///         1 + 1\n ///     }\n ///\n ///     fn baz(&self) {\n-///         // let's not worry about implementing baz() for now\n+///         // We aren't sure how to even start writing baz yet,\n+///         // so we have no logic here at all.\n+///         // This will display \"thread 'main' panicked at 'not yet implemented'\".\n ///         unimplemented!();\n ///     }\n+///\n+///     fn qux(&self) -> Result<u64, ()> {\n+///         let n = self.bar();\n+///         // We have some logic here,\n+///         // so we can use unimplemented! to display what we have so far.\n+///         // This will display:\n+///         // \"thread 'main' panicked at 'not yet implemented: we need to divide by 2'\".\n+///         unimplemented!(\"we need to divide by {}\", n);\n+///     }\n /// }\n ///\n /// fn main() {\n ///     let s = MyStruct;\n ///     s.bar();\n-///\n-///     // we aren't even using baz() yet, so this is fine.\n /// }\n /// ```\n #[macro_export]"}, {"sha": "f1192c7ce10a9577858ea98883b977e91831a69e", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -935,6 +935,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         .filter(|(a, b)| a == b)\n                         .count();\n                     let len = sub1.len() - common_default_params;\n+                    let consts_offset = len - sub1.consts().count();\n \n                     // Only draw `<...>` if there're lifetime/type arguments.\n                     if len > 0 {\n@@ -981,7 +982,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     //         ^ elided type as this type argument was the same in both sides\n                     let type_arguments = sub1.types().zip(sub2.types());\n                     let regions_len = sub1.regions().count();\n-                    for (i, (ta1, ta2)) in type_arguments.take(len).enumerate() {\n+                    let num_display_types = consts_offset - regions_len;\n+                    for (i, (ta1, ta2)) in type_arguments.take(num_display_types).enumerate() {\n                         let i = i + regions_len;\n                         if ta1 == ta2 {\n                             values.0.push_normal(\"_\");\n@@ -994,6 +996,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         self.push_comma(&mut values.0, &mut values.1, len, i);\n                     }\n \n+                    // Do the same for const arguments, if they are equal, do not highlight and\n+                    // elide them from the output.\n+                    let const_arguments = sub1.consts().zip(sub2.consts());\n+                    for (i, (ca1, ca2)) in const_arguments.enumerate() {\n+                        let i = i + consts_offset;\n+                        if ca1 == ca2 {\n+                            values.0.push_normal(\"_\");\n+                            values.1.push_normal(\"_\");\n+                        } else {\n+                            values.0.push_highlighted(ca1.to_string());\n+                            values.1.push_highlighted(ca2.to_string());\n+                        }\n+                        self.push_comma(&mut values.0, &mut values.1, len, i);\n+                    }\n+\n                     // Close the type argument bracket.\n                     // Only draw `<...>` if there're lifetime/type arguments.\n                     if len > 0 {"}, {"sha": "d3a3f51cfa47b7a8abb7aa106cbec3556d0b91bd", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -250,7 +250,9 @@ impl FlagComputation {\n             ConstValue::Placeholder(_) => {\n                 self.add_flags(TypeFlags::HAS_FREE_REGIONS | TypeFlags::HAS_CT_PLACEHOLDER);\n             }\n-            _ => {},\n+            ConstValue::Scalar(_) => { }\n+            ConstValue::Slice { data: _, start: _, end: _ } => { }\n+            ConstValue::ByRef { alloc: _, offset: _ } => { }\n         }\n     }\n "}, {"sha": "5192075c26e9871068aedc5d7f17fda753228b73", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -911,13 +911,15 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n     }\n \n     fn visit_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> bool {\n-        if let ty::Const {\n-            val: ConstValue::Infer(ty::InferConst::Canonical(debruijn, _)),\n-            ..\n-        } = *ct {\n-            debruijn >= self.outer_index\n-        } else {\n-            false\n+        // we don't have a `visit_infer_const` callback, so we have to\n+        // hook in here to catch this case (annoying...), but\n+        // otherwise we do want to remember to visit the rest of the\n+        // const, as it has types/regions embedded in a lot of other\n+        // places.\n+        match ct.val {\n+            ConstValue::Infer(ty::InferConst::Canonical(debruijn, _))\n+                if debruijn >= self.outer_index => true,\n+            _ => ct.super_visit_with(self),\n         }\n     }\n }"}, {"sha": "07c63a92b39dd891cf128c0c94c49c913bc47673", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -689,7 +689,7 @@ pub trait PrettyPrinter<'tcx>:\n                 if self.tcx().sess.verbose() {\n                     p!(write(\n                         \" closure_kind_ty={:?} closure_sig_ty={:?}\",\n-                        substs.as_closure().kind(did, self.tcx()),\n+                        substs.as_closure().kind_ty(did, self.tcx()),\n                         substs.as_closure().sig_ty(did, self.tcx())\n                     ));\n                 }\n@@ -698,7 +698,9 @@ pub trait PrettyPrinter<'tcx>:\n             },\n             ty::Array(ty, sz) => {\n                 p!(write(\"[\"), print(ty), write(\"; \"));\n-                if let ConstValue::Unevaluated(..) = sz.val {\n+                if self.tcx().sess.verbose() {\n+                    p!(write(\"{:?}\", sz));\n+                } else if let ConstValue::Unevaluated(..) = sz.val {\n                     // do not try to evalute unevaluated constants. If we are const evaluating an\n                     // array length anon const, rustc will (with debug assertions) print the\n                     // constant's path. Which will end up here again.\n@@ -855,6 +857,11 @@ pub trait PrettyPrinter<'tcx>:\n     ) -> Result<Self::Const, Self::Error> {\n         define_scoped_cx!(self);\n \n+        if self.tcx().sess.verbose() {\n+            p!(write(\"Const({:?}: {:?})\", ct.val, ct.ty));\n+            return Ok(self);\n+        }\n+\n         let u8 = self.tcx().types.u8;\n         if let ty::FnDef(did, substs) = ct.ty.kind {\n             p!(print_value_path(did, substs));"}, {"sha": "4af73fa389a7db87f26b353981a38697cab8020f", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -2203,7 +2203,9 @@ impl<'tcx> TyS<'tcx> {\n                 _ => bug!(\"cannot convert type `{:?}` to a closure kind\", self),\n             },\n \n-            Infer(_) => None,\n+            // \"Bound\" types appear in canonical queries when the\n+            // closure type is not yet known\n+            Bound(..) | Infer(_) => None,\n \n             Error => Some(ty::ClosureKind::Fn),\n "}, {"sha": "a3c46f7a6fc9d6015773e9d1d4fe98d5575d5859", "filename": "src/librustc_passes/error_codes.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibrustc_passes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibrustc_passes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Ferror_codes.rs?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -286,6 +286,34 @@ fn main() {\n ```\n \"##,\n \n+E0561: r##\"\n+A non-ident or non-wildcard pattern has been used as a parameter of a function\n+pointer type.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0561\n+type A1 = fn(mut param: u8); // error!\n+type A2 = fn(&param: u32); // error!\n+```\n+\n+When using an alias over a function type, you cannot e.g. denote a parameter as\n+being mutable.\n+\n+To fix the issue, remove patterns (`_` is allowed though). Example:\n+\n+```\n+type A1 = fn(param: u8); // ok!\n+type A2 = fn(_: u32); // ok!\n+```\n+\n+You can also omit the parameter name:\n+\n+```\n+type A3 = fn(i16); // ok!\n+```\n+\"##,\n+\n E0571: r##\"\n A `break` statement with an argument appeared in a non-`loop` loop.\n \n@@ -503,7 +531,6 @@ Switch to the Rust 2018 edition to use `async fn`.\n ;\n     E0226, // only a single explicit lifetime bound is permitted\n     E0472, // asm! is unsupported on this target\n-    E0561, // patterns aren't allowed in function pointer types\n     E0567, // auto traits can not have generic parameters\n     E0568, // auto traits can not have super traits\n     E0666, // nested `impl Trait` is illegal"}, {"sha": "dc7eeead30cbeb639657770cf614293a75913618", "filename": "src/librustc_traits/evaluate_obligation.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fevaluate_obligation.rs?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -17,10 +17,12 @@ fn evaluate_obligation<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     canonical_goal: CanonicalPredicateGoal<'tcx>,\n ) -> Result<EvaluationResult, OverflowError> {\n+    debug!(\"evaluate_obligation(canonical_goal={:#?})\", canonical_goal);\n     tcx.infer_ctxt().enter_with_canonical(\n         DUMMY_SP,\n         &canonical_goal,\n         |ref infcx, goal, _canonical_inference_vars| {\n+            debug!(\"evaluate_obligation: goal={:#?}\", goal);\n             let ParamEnvAnd {\n                 param_env,\n                 value: predicate,"}, {"sha": "78bd4508e21a4ff986bbdfdfa5820d406ef9dbb0", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -349,7 +349,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // If the span is from a macro, then it's hard to extract the text\n         // and make a good suggestion, so don't bother.\n-        let is_macro = sp.from_expansion();\n+        let is_desugaring = match sp.desugaring_kind() {\n+            Some(k) => sp.is_desugaring(k),\n+            None => false\n+        };\n+        let is_macro = sp.from_expansion() && !is_desugaring;\n \n         match (&expr.kind, &expected.kind, &checked_ty.kind) {\n             (_, &ty::Ref(_, exp, _), &ty::Ref(_, check, _)) => match (&exp.kind, &check.kind) {"}, {"sha": "aa26c74967a1e0807bc6567932e6f336e02bffb9", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -87,6 +87,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n+            self.suggest_ref_or_into(&mut err, expr, expected_ty, ty);\n+\n             let expr = match &expr.kind {\n                 ExprKind::DropTemps(expr) => expr,\n                 _ => expr,"}, {"sha": "fc26dcb321148c1765cf00c5987d5c621b066ca1", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -3112,8 +3112,10 @@ mod tests {\n \n         #[cfg(windows)]\n         let invalid_options = 87; // ERROR_INVALID_PARAMETER\n-        #[cfg(unix)]\n+        #[cfg(all(unix, not(target_os = \"vxworks\")))]\n         let invalid_options = \"Invalid argument\";\n+        #[cfg(target_os = \"vxworks\")]\n+        let invalid_options = \"invalid argument\";\n \n         // Test various combinations of creation modes and access modes.\n         //"}, {"sha": "4a457f5a43caa651dd34e0bab0ccf7ffc8dc4b38", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 38, "deletions": 58, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -11,7 +11,7 @@ mod stmt;\n mod generics;\n \n use crate::ast::{\n-    self, DUMMY_NODE_ID, AttrStyle, Attribute, BindingMode, CrateSugar, FnDecl, Ident,\n+    self, DUMMY_NODE_ID, AttrStyle, Attribute, BindingMode, CrateSugar, Ident,\n     IsAsync, MacDelimiter, Mutability, Param, StrStyle, SelfKind, TyKind, Visibility,\n     VisibilityKind, Unsafety,\n };\n@@ -56,6 +56,17 @@ crate enum BlockMode {\n     Ignore,\n }\n \n+/// The parsing configuration used to parse a parameter list (see `parse_fn_params`).\n+struct ParamCfg {\n+    /// Is `self` is allowed as the first parameter?\n+    is_self_allowed: bool,\n+    /// Is `...` allowed as the tail of the parameter list?\n+    allow_c_variadic: bool,\n+    /// `is_name_required` decides if, per-parameter,\n+    /// the parameter must have a pattern or just a type.\n+    is_name_required: fn(&token::Token) -> bool,\n+}\n+\n /// Like `maybe_whole_expr`, but for things other than expressions.\n #[macro_export]\n macro_rules! maybe_whole {\n@@ -1094,26 +1105,18 @@ impl<'a> Parser<'a> {\n         res\n     }\n \n-    fn parse_fn_params(\n-        &mut self,\n-        named_params: bool,\n-        allow_c_variadic: bool,\n-    ) -> PResult<'a, Vec<Param>> {\n+    /// Parses the parameter list of a function, including the `(` and `)` delimiters.\n+    fn parse_fn_params(&mut self, mut cfg: ParamCfg) -> PResult<'a, Vec<Param>> {\n         let sp = self.token.span;\n-        let do_not_enforce_named_params_for_c_variadic = |token: &token::Token| {\n-            match token.kind {\n-                token::DotDotDot => false,\n-                _ => named_params,\n-            }\n-        };\n+        let is_trait_item = cfg.is_self_allowed;\n         let mut c_variadic = false;\n+        // Parse the arguments, starting out with `self` being possibly allowed...\n         let (params, _) = self.parse_paren_comma_seq(|p| {\n-            match p.parse_param_general(\n-                false,\n-                false,\n-                allow_c_variadic,\n-                do_not_enforce_named_params_for_c_variadic,\n-            ) {\n+            let param = p.parse_param_general(&cfg, is_trait_item);\n+            // ...now that we've parsed the first argument, `self` is no longer allowed.\n+            cfg.is_self_allowed = false;\n+\n+            match param {\n                 Ok(param) => Ok(\n                     if let TyKind::CVarArgs = param.ty.kind {\n                         c_variadic = true;\n@@ -1144,7 +1147,10 @@ impl<'a> Parser<'a> {\n             }\n         })?;\n \n-        let params: Vec<_> = params.into_iter().filter_map(|x| x).collect();\n+        let mut params: Vec<_> = params.into_iter().filter_map(|x| x).collect();\n+\n+        // Replace duplicated recovered params with `_` pattern to avoid unecessary errors.\n+        self.deduplicate_recovered_params_names(&mut params);\n \n         if c_variadic && params.len() <= 1 {\n             self.span_err(\n@@ -1156,79 +1162,53 @@ impl<'a> Parser<'a> {\n         Ok(params)\n     }\n \n-    /// Parses the parameter list and result type of a function that may have a `self` parameter.\n-    fn parse_fn_decl_with_self(\n-        &mut self,\n-        is_name_required: impl Copy + Fn(&token::Token) -> bool,\n-    ) -> PResult<'a, P<FnDecl>> {\n-        // Parse the arguments, starting out with `self` being allowed...\n-        let mut is_self_allowed = true;\n-        let (mut inputs, _): (Vec<_>, _) = self.parse_paren_comma_seq(|p| {\n-            let res = p.parse_param_general(is_self_allowed, true, false, is_name_required);\n-            // ...but now that we've parsed the first argument, `self` is no longer allowed.\n-            is_self_allowed = false;\n-            res\n-        })?;\n-\n-        // Replace duplicated recovered params with `_` pattern to avoid unecessary errors.\n-        self.deduplicate_recovered_params_names(&mut inputs);\n-\n-        Ok(P(FnDecl {\n-            inputs,\n-            output: self.parse_ret_ty(true)?,\n-        }))\n-    }\n-\n     /// Skips unexpected attributes and doc comments in this position and emits an appropriate\n     /// error.\n     /// This version of parse param doesn't necessarily require identifier names.\n-    fn parse_param_general(\n-        &mut self,\n-        is_self_allowed: bool,\n-        is_trait_item: bool,\n-        allow_c_variadic: bool,\n-        is_name_required: impl Fn(&token::Token) -> bool,\n-    ) -> PResult<'a, Param> {\n+    fn parse_param_general(&mut self, cfg: &ParamCfg, is_trait_item: bool) -> PResult<'a, Param> {\n         let lo = self.token.span;\n         let attrs = self.parse_outer_attributes()?;\n \n         // Possibly parse `self`. Recover if we parsed it and it wasn't allowed here.\n         if let Some(mut param) = self.parse_self_param()? {\n             param.attrs = attrs.into();\n-            return if is_self_allowed {\n+            return if cfg.is_self_allowed {\n                 Ok(param)\n             } else {\n                 self.recover_bad_self_param(param, is_trait_item)\n             };\n         }\n \n-        let is_name_required = is_name_required(&self.token);\n+        let is_name_required = match self.token.kind {\n+            token::DotDotDot => false,\n+            _ => (cfg.is_name_required)(&self.token),\n+        };\n         let (pat, ty) = if is_name_required || self.is_named_param() {\n             debug!(\"parse_param_general parse_pat (is_name_required:{})\", is_name_required);\n \n             let pat = self.parse_fn_param_pat()?;\n             if let Err(mut err) = self.expect(&token::Colon) {\n-                if let Some(ident) = self.parameter_without_type(\n+                return if let Some(ident) = self.parameter_without_type(\n                     &mut err,\n                     pat,\n                     is_name_required,\n-                    is_self_allowed,\n+                    cfg.is_self_allowed,\n                     is_trait_item,\n                 ) {\n                     err.emit();\n-                    return Ok(dummy_arg(ident));\n+                    Ok(dummy_arg(ident))\n                 } else {\n-                    return Err(err);\n-                }\n+                    Err(err)\n+                };\n             }\n \n             self.eat_incorrect_doc_comment_for_param_type();\n-            (pat, self.parse_ty_common(true, true, allow_c_variadic)?)\n+            (pat, self.parse_ty_common(true, true, cfg.allow_c_variadic)?)\n         } else {\n             debug!(\"parse_param_general ident_to_pat\");\n             let parser_snapshot_before_ty = self.clone();\n             self.eat_incorrect_doc_comment_for_param_type();\n-            let mut ty = self.parse_ty_common(true, true, allow_c_variadic);\n+            let mut ty = self.parse_ty_common(true, true, cfg.allow_c_variadic);\n             if ty.is_ok() && self.token != token::Comma &&\n                self.token != token::CloseDelim(token::Paren) {\n                 // This wasn't actually a type, but a pattern looking like a type,"}, {"sha": "3c60c88e2aa5887b2001a173ca7b5356f894cfca", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 152, "deletions": 141, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -1,10 +1,10 @@\n-use super::{Parser, PResult, PathStyle, SemiColonMode, BlockMode};\n+use super::{Parser, PResult, PathStyle, SemiColonMode, BlockMode, ParamCfg};\n \n use crate::maybe_whole;\n use crate::ptr::P;\n use crate::ast::{\n     self, DUMMY_NODE_ID, Ident, Attribute, AttrStyle,\n-    Item, ItemKind, ImplItem, TraitItem, TraitItemKind,\n+    Item, ItemKind, ImplItem, ImplItemKind, TraitItem, TraitItemKind,\n     UseTree, UseTreeKind, PathSegment,\n     IsAuto, Constness, IsAsync, Unsafety, Defaultness,\n     Visibility, VisibilityKind, Mutability, FnDecl, FnHeader, MethodSig, Block,\n@@ -98,23 +98,22 @@ impl<'a> Parser<'a> {\n \n         let lo = self.token.span;\n \n-        let visibility = self.parse_visibility(false)?;\n+        let vis = self.parse_visibility(false)?;\n \n         if self.eat_keyword(kw::Use) {\n             // USE ITEM\n             let item_ = ItemKind::Use(P(self.parse_use_tree()?));\n             self.expect(&token::Semi)?;\n \n             let span = lo.to(self.prev_span);\n-            let item =\n-                self.mk_item(span, Ident::invalid(), item_, visibility, attrs);\n+            let item = self.mk_item(span, Ident::invalid(), item_, vis, attrs);\n             return Ok(Some(item));\n         }\n \n         if self.eat_keyword(kw::Extern) {\n             let extern_sp = self.prev_span;\n             if self.eat_keyword(kw::Crate) {\n-                return Ok(Some(self.parse_item_extern_crate(lo, visibility, attrs)?));\n+                return Ok(Some(self.parse_item_extern_crate(lo, vis, attrs)?));\n             }\n \n             let opt_abi = self.parse_opt_abi()?;\n@@ -128,10 +127,10 @@ impl<'a> Parser<'a> {\n                     constness: respan(fn_span, Constness::NotConst),\n                     abi: opt_abi.unwrap_or(Abi::C),\n                 };\n-                return self.parse_item_fn(lo, visibility, attrs, header);\n+                return self.parse_item_fn(lo, vis, attrs, header);\n             } else if self.check(&token::OpenDelim(token::Brace)) {\n                 return Ok(Some(\n-                    self.parse_item_foreign_mod(lo, opt_abi, visibility, attrs, extern_sp)?,\n+                    self.parse_item_foreign_mod(lo, opt_abi, vis, attrs, extern_sp)?,\n                 ));\n             }\n \n@@ -142,16 +141,14 @@ impl<'a> Parser<'a> {\n             self.bump();\n             // STATIC ITEM\n             let m = self.parse_mutability();\n-            let (ident, item_, extra_attrs) = self.parse_item_const(Some(m))?;\n-            let span = lo.to(self.prev_span);\n-            let attrs = maybe_append(attrs, extra_attrs);\n-            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n+            let info = self.parse_item_const(Some(m))?;\n+            return self.mk_item_with_info(attrs, lo, vis, info);\n         }\n+\n         if self.eat_keyword(kw::Const) {\n             let const_span = self.prev_span;\n             if [kw::Fn, kw::Unsafe, kw::Extern].iter().any(|k| self.check_keyword(*k)) {\n                 // CONST FUNCTION ITEM\n-\n                 let unsafety = self.parse_unsafety();\n \n                 if self.check_keyword(kw::Extern) {\n@@ -160,15 +157,15 @@ impl<'a> Parser<'a> {\n                     );\n                 }\n                 let abi = self.parse_extern_abi()?;\n-                self.bump(); // 'fn'\n+                self.bump(); // `fn`\n \n                 let header = FnHeader {\n                     unsafety,\n                     asyncness: respan(const_span, IsAsync::NotAsync),\n                     constness: respan(const_span, Constness::Const),\n                     abi,\n                 };\n-                return self.parse_item_fn(lo, visibility, attrs, header);\n+                return self.parse_item_fn(lo, vis, attrs, header);\n             }\n \n             // CONST ITEM\n@@ -184,10 +181,9 @@ impl<'a> Parser<'a> {\n                     )\n                     .emit();\n             }\n-            let (ident, item_, extra_attrs) = self.parse_item_const(None)?;\n-            let span = lo.to(self.prev_span);\n-            let attrs = maybe_append(attrs, extra_attrs);\n-            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n+\n+            let info = self.parse_item_const(None)?;\n+            return self.mk_item_with_info(attrs, lo, vis, info);\n         }\n \n         // Parses `async unsafe? fn`.\n@@ -212,40 +208,33 @@ impl<'a> Parser<'a> {\n                     constness: respan(fn_span, Constness::NotConst),\n                     abi: Abi::Rust,\n                 };\n-                return self.parse_item_fn(lo, visibility, attrs, header);\n+                return self.parse_item_fn(lo, vis, attrs, header);\n             }\n         }\n+\n         if self.check_keyword(kw::Unsafe) &&\n             self.is_keyword_ahead(1, &[kw::Trait, kw::Auto])\n         {\n             // UNSAFE TRAIT ITEM\n             self.bump(); // `unsafe`\n-            let is_auto = if self.eat_keyword(kw::Trait) {\n-                IsAuto::No\n-            } else {\n-                self.expect_keyword(kw::Auto)?;\n-                self.expect_keyword(kw::Trait)?;\n-                IsAuto::Yes\n-            };\n-            let (ident, item_, extra_attrs) = self.parse_item_trait(is_auto, Unsafety::Unsafe)?;\n-            let span = lo.to(self.prev_span);\n-            let attrs = maybe_append(attrs, extra_attrs);\n-            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n+            let info = self.parse_item_trait(Unsafety::Unsafe)?;\n+            return self.mk_item_with_info(attrs, lo, vis, info);\n         }\n+\n         if self.check_keyword(kw::Impl) ||\n            self.check_keyword(kw::Unsafe) &&\n                 self.is_keyword_ahead(1, &[kw::Impl]) ||\n            self.check_keyword(kw::Default) &&\n-                self.is_keyword_ahead(1, &[kw::Impl, kw::Unsafe]) {\n+                self.is_keyword_ahead(1, &[kw::Impl, kw::Unsafe])\n+        {\n             // IMPL ITEM\n             let defaultness = self.parse_defaultness();\n             let unsafety = self.parse_unsafety();\n             self.expect_keyword(kw::Impl)?;\n-            let (ident, item_, extra_attrs) = self.parse_item_impl(unsafety, defaultness)?;\n-            let span = lo.to(self.prev_span);\n-            let attrs = maybe_append(attrs, extra_attrs);\n-            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n+            let info = self.parse_item_impl(unsafety, defaultness)?;\n+            return self.mk_item_with_info(attrs, lo, vis, info);\n         }\n+\n         if self.check_keyword(kw::Fn) {\n             // FUNCTION ITEM\n             self.bump();\n@@ -256,10 +245,12 @@ impl<'a> Parser<'a> {\n                 constness: respan(fn_span, Constness::NotConst),\n                 abi: Abi::Rust,\n             };\n-            return self.parse_item_fn(lo, visibility, attrs, header);\n+            return self.parse_item_fn(lo, vis, attrs, header);\n         }\n+\n         if self.check_keyword(kw::Unsafe)\n-            && self.look_ahead(1, |t| *t != token::OpenDelim(token::Brace)) {\n+            && self.look_ahead(1, |t| *t != token::OpenDelim(token::Brace))\n+        {\n             // UNSAFE FUNCTION ITEM\n             self.bump(); // `unsafe`\n             // `{` is also expected after `unsafe`; in case of error, include it in the diagnostic.\n@@ -273,15 +264,15 @@ impl<'a> Parser<'a> {\n                 constness: respan(fn_span, Constness::NotConst),\n                 abi,\n             };\n-            return self.parse_item_fn(lo, visibility, attrs, header);\n+            return self.parse_item_fn(lo, vis, attrs, header);\n         }\n+\n         if self.eat_keyword(kw::Mod) {\n             // MODULE ITEM\n-            let (ident, item_, extra_attrs) = self.parse_item_mod(&attrs[..])?;\n-            let span = lo.to(self.prev_span);\n-            let attrs = maybe_append(attrs, extra_attrs);\n-            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n+            let info = self.parse_item_mod(&attrs[..])?;\n+            return self.mk_item_with_info(attrs, lo, vis, info);\n         }\n+\n         if let Some(type_) = self.eat_type() {\n             let (ident, alias, generics) = type_?;\n             // TYPE ITEM\n@@ -290,54 +281,44 @@ impl<'a> Parser<'a> {\n                 AliasKind::OpaqueTy(bounds) => ItemKind::OpaqueTy(bounds, generics),\n             };\n             let span = lo.to(self.prev_span);\n-            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n+            return Ok(Some(self.mk_item(span, ident, item_, vis, attrs)));\n         }\n+\n         if self.eat_keyword(kw::Enum) {\n             // ENUM ITEM\n-            let (ident, item_, extra_attrs) = self.parse_item_enum()?;\n-            let span = lo.to(self.prev_span);\n-            let attrs = maybe_append(attrs, extra_attrs);\n-            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n+            let info = self.parse_item_enum()?;\n+            return self.mk_item_with_info(attrs, lo, vis, info);\n         }\n+\n         if self.check_keyword(kw::Trait)\n             || (self.check_keyword(kw::Auto)\n                 && self.is_keyword_ahead(1, &[kw::Trait]))\n         {\n-            let is_auto = if self.eat_keyword(kw::Trait) {\n-                IsAuto::No\n-            } else {\n-                self.expect_keyword(kw::Auto)?;\n-                self.expect_keyword(kw::Trait)?;\n-                IsAuto::Yes\n-            };\n             // TRAIT ITEM\n-            let (ident, item_, extra_attrs) = self.parse_item_trait(is_auto, Unsafety::Normal)?;\n-            let span = lo.to(self.prev_span);\n-            let attrs = maybe_append(attrs, extra_attrs);\n-            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n+            let info = self.parse_item_trait(Unsafety::Normal)?;\n+            return self.mk_item_with_info(attrs, lo, vis, info);\n         }\n+\n         if self.eat_keyword(kw::Struct) {\n             // STRUCT ITEM\n-            let (ident, item_, extra_attrs) = self.parse_item_struct()?;\n-            let span = lo.to(self.prev_span);\n-            let attrs = maybe_append(attrs, extra_attrs);\n-            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n+            let info = self.parse_item_struct()?;\n+            return self.mk_item_with_info(attrs, lo, vis, info);\n         }\n+\n         if self.is_union_item() {\n             // UNION ITEM\n             self.bump();\n-            let (ident, item_, extra_attrs) = self.parse_item_union()?;\n-            let span = lo.to(self.prev_span);\n-            let attrs = maybe_append(attrs, extra_attrs);\n-            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n+            let info = self.parse_item_union()?;\n+            return self.mk_item_with_info(attrs, lo, vis, info);\n         }\n-        if let Some(macro_def) = self.eat_macro_def(&attrs, &visibility, lo)? {\n+\n+        if let Some(macro_def) = self.eat_macro_def(&attrs, &vis, lo)? {\n             return Ok(Some(macro_def));\n         }\n \n         // Verify whether we have encountered a struct or method definition where the user forgot to\n         // add the `struct` or `fn` keyword after writing `pub`: `pub S {}`\n-        if visibility.node.is_pub() &&\n+        if vis.node.is_pub() &&\n             self.check_ident() &&\n             self.look_ahead(1, |t| *t != token::Not)\n         {\n@@ -428,7 +409,20 @@ impl<'a> Parser<'a> {\n                 return Err(err);\n             }\n         }\n-        self.parse_macro_use_or_failure(attrs, macros_allowed, attributes_allowed, lo, visibility)\n+        self.parse_macro_use_or_failure(attrs, macros_allowed, attributes_allowed, lo, vis)\n+    }\n+\n+    fn mk_item_with_info(\n+        &self,\n+        attrs: Vec<Attribute>,\n+        lo: Span,\n+        vis: Visibility,\n+        info: ItemInfo,\n+    ) -> PResult<'a, Option<P<Item>>> {\n+        let (ident, item, extra_attrs) = info;\n+        let span = lo.to(self.prev_span);\n+        let attrs = maybe_append(attrs, extra_attrs);\n+        Ok(Some(self.mk_item(span, ident, item, vis, attrs)))\n     }\n \n     fn recover_first_param(&mut self) -> &'static str {\n@@ -727,16 +721,7 @@ impl<'a> Parser<'a> {\n             };\n             (name, kind, generics)\n         } else if self.is_const_item() {\n-            // This parses the grammar:\n-            //     ImplItemConst = \"const\" Ident \":\" Ty \"=\" Expr \";\"\n-            self.expect_keyword(kw::Const)?;\n-            let name = self.parse_ident()?;\n-            self.expect(&token::Colon)?;\n-            let typ = self.parse_ty()?;\n-            self.expect(&token::Eq)?;\n-            let expr = self.parse_expr()?;\n-            self.expect(&token::Semi)?;\n-            (name, ast::ImplItemKind::Const(typ, expr), Generics::default())\n+            self.parse_impl_const()?\n         } else {\n             let (name, inner_attrs, generics, kind) = self.parse_impl_method(&vis, at_end)?;\n             attrs.extend(inner_attrs);\n@@ -785,12 +770,25 @@ impl<'a> Parser<'a> {\n             !self.is_keyword_ahead(1, &[kw::Fn, kw::Unsafe])\n     }\n \n+    /// This parses the grammar:\n+    ///     ImplItemConst = \"const\" Ident \":\" Ty \"=\" Expr \";\"\n+    fn parse_impl_const(&mut self) -> PResult<'a, (Ident, ImplItemKind, Generics)> {\n+        self.expect_keyword(kw::Const)?;\n+        let name = self.parse_ident()?;\n+        self.expect(&token::Colon)?;\n+        let typ = self.parse_ty()?;\n+        self.expect(&token::Eq)?;\n+        let expr = self.parse_expr()?;\n+        self.expect(&token::Semi)?;\n+        Ok((name, ImplItemKind::Const(typ, expr), Generics::default()))\n+    }\n+\n     /// Parses a method or a macro invocation in a trait impl.\n     fn parse_impl_method(\n         &mut self,\n         vis: &Visibility,\n         at_end: &mut bool\n-    ) -> PResult<'a, (Ident, Vec<Attribute>, Generics, ast::ImplItemKind)> {\n+    ) -> PResult<'a, (Ident, Vec<Attribute>, Generics, ImplItemKind)> {\n         // FIXME: code copied from `parse_macro_use_or_failure` -- use abstraction!\n         if let Some(mac) = self.parse_assoc_macro_invoc(\"impl\", Some(vis), at_end)? {\n             // method macro\n@@ -807,14 +805,15 @@ impl<'a> Parser<'a> {\n     /// of a method. The body is not parsed as that differs between `trait`s and `impl`s.\n     fn parse_method_sig(\n         &mut self,\n-        is_name_required: impl Copy + Fn(&token::Token) -> bool,\n+        is_name_required: fn(&token::Token) -> bool,\n     ) -> PResult<'a, (Ident, MethodSig, Generics)> {\n         let header = self.parse_fn_front_matter()?;\n-        let (ident, mut generics) = self.parse_fn_header()?;\n-        let decl = self.parse_fn_decl_with_self(is_name_required)?;\n-        let sig = MethodSig { header, decl };\n-        generics.where_clause = self.parse_where_clause()?;\n-        Ok((ident, sig, generics))\n+        let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n+            is_self_allowed: true,\n+            allow_c_variadic: false,\n+            is_name_required,\n+        })?;\n+        Ok((ident, MethodSig { header, decl }, generics))\n     }\n \n     /// Parses all the \"front matter\" for a `fn` declaration, up to\n@@ -849,8 +848,16 @@ impl<'a> Parser<'a> {\n         Ok(FnHeader { constness, unsafety, asyncness, abi })\n     }\n \n-    /// Parses `trait Foo { ... }` or `trait Foo = Bar;`.\n-    fn parse_item_trait(&mut self, is_auto: IsAuto, unsafety: Unsafety) -> PResult<'a, ItemInfo> {\n+    /// Parses `auto? trait Foo { ... }` or `trait Foo = Bar;`.\n+    fn parse_item_trait(&mut self, unsafety: Unsafety) -> PResult<'a, ItemInfo> {\n+        // Parse optional `auto` prefix.\n+        let is_auto = if self.eat_keyword(kw::Auto) {\n+            IsAuto::Yes\n+        } else {\n+            IsAuto::No\n+        };\n+\n+        self.expect_keyword(kw::Trait)?;\n         let ident = self.parse_ident()?;\n         let mut tps = self.parse_generics()?;\n \n@@ -935,38 +942,28 @@ impl<'a> Parser<'a> {\n         Ok(item)\n     }\n \n-    fn parse_trait_item_(&mut self,\n-                         at_end: &mut bool,\n-                         mut attrs: Vec<Attribute>) -> PResult<'a, TraitItem> {\n+    fn parse_trait_item_(\n+        &mut self,\n+        at_end: &mut bool,\n+        mut attrs: Vec<Attribute>,\n+    ) -> PResult<'a, TraitItem> {\n         let lo = self.token.span;\n         self.eat_bad_pub();\n         let (name, kind, generics) = if self.eat_keyword(kw::Type) {\n             self.parse_trait_item_assoc_ty()?\n         } else if self.is_const_item() {\n-            self.expect_keyword(kw::Const)?;\n-            let ident = self.parse_ident()?;\n-            self.expect(&token::Colon)?;\n-            let ty = self.parse_ty()?;\n-            let default = if self.eat(&token::Eq) {\n-                let expr = self.parse_expr()?;\n-                self.expect(&token::Semi)?;\n-                Some(expr)\n-            } else {\n-                self.expect(&token::Semi)?;\n-                None\n-            };\n-            (ident, TraitItemKind::Const(ty, default), Generics::default())\n+            self.parse_trait_item_const()?\n         } else if let Some(mac) = self.parse_assoc_macro_invoc(\"trait\", None, &mut false)? {\n             // trait item macro.\n-            (Ident::invalid(), ast::TraitItemKind::Macro(mac), Generics::default())\n+            (Ident::invalid(), TraitItemKind::Macro(mac), Generics::default())\n         } else {\n             // This is somewhat dubious; We don't want to allow\n             // argument names to be left off if there is a definition...\n             //\n             // We don't allow argument names to be left off in edition 2018.\n             let (ident, sig, generics) = self.parse_method_sig(|t| t.span.rust_2018())?;\n             let body = self.parse_trait_method_body(at_end, &mut attrs)?;\n-            (ident, ast::TraitItemKind::Method(sig, body), generics)\n+            (ident, TraitItemKind::Method(sig, body), generics)\n         };\n \n         Ok(TraitItem {\n@@ -980,6 +977,20 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    fn parse_trait_item_const(&mut self) -> PResult<'a, (Ident, TraitItemKind, Generics)> {\n+        self.expect_keyword(kw::Const)?;\n+        let ident = self.parse_ident()?;\n+        self.expect(&token::Colon)?;\n+        let ty = self.parse_ty()?;\n+        let default = if self.eat(&token::Eq) {\n+            Some(self.parse_expr()?)\n+        } else {\n+            None\n+        };\n+        self.expect(&token::Semi)?;\n+        Ok((ident, TraitItemKind::Const(ty, default), Generics::default()))\n+    }\n+\n     /// Parse the \"body\" of a method in a trait item definition.\n     /// This can either be `;` when there's no body,\n     /// or e.g. a block when the method is a provided one.\n@@ -1020,8 +1031,7 @@ impl<'a> Parser<'a> {\n     /// Parses the following grammar:\n     ///\n     ///     TraitItemAssocTy = Ident [\"<\"...\">\"] [\":\" [GenericBounds]] [\"where\" ...] [\"=\" Ty]\n-    fn parse_trait_item_assoc_ty(&mut self)\n-        -> PResult<'a, (Ident, TraitItemKind, Generics)> {\n+    fn parse_trait_item_assoc_ty(&mut self) -> PResult<'a, (Ident, TraitItemKind, Generics)> {\n         let ident = self.parse_ident()?;\n         let mut generics = self.parse_generics()?;\n \n@@ -1067,21 +1077,13 @@ impl<'a> Parser<'a> {\n                 );\n             }\n \n-            if self.eat(&token::BinOp(token::Star)) {\n-                UseTreeKind::Glob\n-            } else {\n-                UseTreeKind::Nested(self.parse_use_tree_list()?)\n-            }\n+            self.parse_use_tree_glob_or_nested()?\n         } else {\n             // `use path::*;` or `use path::{...};` or `use path;` or `use path as bar;`\n             prefix = self.parse_path(PathStyle::Mod)?;\n \n             if self.eat(&token::ModSep) {\n-                if self.eat(&token::BinOp(token::Star)) {\n-                    UseTreeKind::Glob\n-                } else {\n-                    UseTreeKind::Nested(self.parse_use_tree_list()?)\n-                }\n+                self.parse_use_tree_glob_or_nested()?\n             } else {\n                 UseTreeKind::Simple(self.parse_rename()?, DUMMY_NODE_ID, DUMMY_NODE_ID)\n             }\n@@ -1090,6 +1092,15 @@ impl<'a> Parser<'a> {\n         Ok(UseTree { prefix, kind, span: lo.to(self.prev_span) })\n     }\n \n+    /// Parses `*` or `{...}`.\n+    fn parse_use_tree_glob_or_nested(&mut self) -> PResult<'a, UseTreeKind> {\n+        Ok(if self.eat(&token::BinOp(token::Star)) {\n+            UseTreeKind::Glob\n+        } else {\n+            UseTreeKind::Nested(self.parse_use_tree_list()?)\n+        })\n+    }\n+\n     /// Parses a `UseTreeKind::Nested(list)`.\n     ///\n     /// ```\n@@ -1191,38 +1202,34 @@ impl<'a> Parser<'a> {\n         attrs: Vec<Attribute>,\n         header: FnHeader,\n     ) -> PResult<'a, Option<P<Item>>> {\n-        let allow_c_variadic = header.abi == Abi::C && header.unsafety == Unsafety::Unsafe;\n-        let (ident, decl, generics) = self.parse_fn_sig(allow_c_variadic)?;\n+        let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n+            is_self_allowed: false,\n+            allow_c_variadic: header.abi == Abi::C && header.unsafety == Unsafety::Unsafe,\n+            is_name_required: |_| true,\n+        })?;\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-        let span = lo.to(self.prev_span);\n         let kind = ItemKind::Fn(decl, header, generics, body);\n-        let attrs = maybe_append(attrs, Some(inner_attrs));\n-        Ok(Some(self.mk_item(span, ident, kind, vis, attrs)))\n+        self.mk_item_with_info(attrs, lo, vis, (ident, kind, Some(inner_attrs)))\n     }\n \n     /// Parse the \"signature\", including the identifier, parameters, and generics of a function.\n-    fn parse_fn_sig(\n-        &mut self,\n-        allow_c_variadic: bool,\n-    ) -> PResult<'a, (Ident, P<FnDecl>, Generics)> {\n-        let (ident, mut generics) = self.parse_fn_header()?;\n-        let decl = self.parse_fn_decl(allow_c_variadic)?;\n+    fn parse_fn_sig(&mut self, cfg: ParamCfg) -> PResult<'a, (Ident, P<FnDecl>, Generics)> {\n+        let ident = self.parse_ident()?;\n+        let mut generics = self.parse_generics()?;\n+        let decl = self.parse_fn_decl(cfg, true)?;\n         generics.where_clause = self.parse_where_clause()?;\n         Ok((ident, decl, generics))\n     }\n \n-    /// Parses the name and optional generic types of a function header.\n-    fn parse_fn_header(&mut self) -> PResult<'a, (Ident, Generics)> {\n-        let id = self.parse_ident()?;\n-        let generics = self.parse_generics()?;\n-        Ok((id, generics))\n-    }\n-\n     /// Parses the parameter list and result type of a function declaration.\n-    fn parse_fn_decl(&mut self, allow_c_variadic: bool) -> PResult<'a, P<FnDecl>> {\n+    pub(super) fn parse_fn_decl(\n+        &mut self,\n+        cfg: ParamCfg,\n+        ret_allow_plus: bool,\n+    ) -> PResult<'a, P<FnDecl>> {\n         Ok(P(FnDecl {\n-            inputs: self.parse_fn_params(true, allow_c_variadic)?,\n-            output: self.parse_ret_ty(true)?,\n+            inputs: self.parse_fn_params(cfg)?,\n+            output: self.parse_ret_ty(ret_allow_plus)?,\n         }))\n     }\n \n@@ -1346,7 +1353,11 @@ impl<'a> Parser<'a> {\n         extern_sp: Span,\n     ) -> PResult<'a, ForeignItem> {\n         self.expect_keyword(kw::Fn)?;\n-        let (ident, decl, generics) = self.parse_fn_sig(true)?;\n+        let (ident, decl, generics) = self.parse_fn_sig(super::ParamCfg {\n+            is_self_allowed: false,\n+            allow_c_variadic: true,\n+            is_name_required: |_| true,\n+        })?;\n         let span = lo.to(self.token.span);\n         self.parse_semi_or_incorrect_foreign_fn_body(&ident, extern_sp)?;\n         Ok(ast::ForeignItem {"}, {"sha": "018b5951e6e2e797a923a9a80738e37255692ad0", "filename": "src/libsyntax/parse/parser/ty.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -4,13 +4,11 @@ use crate::{maybe_whole, maybe_recover_from_interpolated_ty_qpath};\n use crate::ptr::P;\n use crate::ast::{self, Ty, TyKind, MutTy, BareFnTy, FunctionRetTy, GenericParam, Lifetime, Ident};\n use crate::ast::{TraitBoundModifier, TraitObjectSyntax, GenericBound, GenericBounds, PolyTraitRef};\n-use crate::ast::{Mutability, AnonConst, FnDecl, Mac};\n+use crate::ast::{Mutability, AnonConst, Mac};\n use crate::parse::token::{self, Token};\n use crate::source_map::Span;\n use crate::symbol::{kw};\n \n-use rustc_target::spec::abi::Abi;\n-\n use errors::{Applicability, pluralise};\n \n /// Returns `true` if `IDENT t` can start a type -- `IDENT::a::b`, `IDENT<u8, u8>`,\n@@ -281,19 +279,14 @@ impl<'a> Parser<'a> {\n         */\n \n         let unsafety = self.parse_unsafety();\n-        let abi = if self.eat_keyword(kw::Extern) {\n-            self.parse_opt_abi()?.unwrap_or(Abi::C)\n-        } else {\n-            Abi::Rust\n-        };\n-\n+        let abi = self.parse_extern_abi()?;\n         self.expect_keyword(kw::Fn)?;\n-        let inputs = self.parse_fn_params(false, true)?;\n-        let ret_ty = self.parse_ret_ty(false)?;\n-        let decl = P(FnDecl {\n-            inputs,\n-            output: ret_ty,\n-        });\n+        let cfg = super::ParamCfg {\n+            is_self_allowed: false,\n+            allow_c_variadic: true,\n+            is_name_required: |_| false,\n+        };\n+        let decl = self.parse_fn_decl(cfg, false)?;\n         Ok(TyKind::BareFn(P(BareFnTy {\n             abi,\n             unsafety,"}, {"sha": "380a70d664e05939a032bf5041b79ffd158a82f5", "filename": "src/test/ui/const-generics/slice-const-param-mismatch.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Ftest%2Fui%2Fconst-generics%2Fslice-const-param-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Ftest%2Fui%2Fconst-generics%2Fslice-const-param-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fslice-const-param-mismatch.stderr?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -12,26 +12,26 @@ error[E0308]: mismatched types\n LL |     let _: ConstString<\"Hello\"> = ConstString::<\"World\">;\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^ expected `\"Hello\"`, found `\"World\"`\n    |\n-   = note: expected type `ConstString<>`\n-              found type `ConstString<>`\n+   = note: expected type `ConstString<\"Hello\">`\n+              found type `ConstString<\"World\">`\n \n error[E0308]: mismatched types\n   --> $DIR/slice-const-param-mismatch.rs:11:33\n    |\n LL |     let _: ConstString<\"\u2107\u31c8\u21a6\"> = ConstString::<\"\u2107\u31c8\u21a5\">;\n    |                                  ^^^^^^^^^^^^^^^^^^^^^ expected `\"\u2107\u31c8\u21a6\"`, found `\"\u2107\u31c8\u21a5\"`\n    |\n-   = note: expected type `ConstString<>`\n-              found type `ConstString<>`\n+   = note: expected type `ConstString<\"\u2107\u31c8\u21a6\">`\n+              found type `ConstString<\"\u2107\u31c8\u21a5\">`\n \n error[E0308]: mismatched types\n   --> $DIR/slice-const-param-mismatch.rs:13:33\n    |\n LL |     let _: ConstBytes<b\"AAA\"> = ConstBytes::<b\"BBB\">;\n    |                                 ^^^^^^^^^^^^^^^^^^^^ expected `b\"AAA\"`, found `b\"BBB\"`\n    |\n-   = note: expected type `ConstBytes<>`\n-              found type `ConstBytes<>`\n+   = note: expected type `ConstBytes<b\"AAA\">`\n+              found type `ConstBytes<b\"BBB\">`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "b25b7331017e72dc7a5f7753d6099e9673211708", "filename": "src/test/ui/const-generics/types-mismatch-const-args.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.rs?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -0,0 +1,19 @@\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+// tests the diagnostic output of type mismatches for types that have const generics arguments.\n+\n+use std::marker::PhantomData;\n+\n+struct A<'a, T, const X: u32, const Y: u32> {\n+    data: PhantomData<&'a T>\n+}\n+\n+fn a<'a, 'b>() {\n+    let _: A<'a, u32, {2u32}, {3u32}> = A::<'a, u32, {4u32}, {3u32}> { data: PhantomData };\n+    //~^ ERROR mismatched types\n+    let _: A<'a, u16, {2u32}, {3u32}> = A::<'b, u32, {2u32}, {3u32}> { data: PhantomData };\n+    //~^ ERROR mismatched types\n+}\n+\n+pub fn main() {}"}, {"sha": "805a3067d3b6bff0237906ca30537bee5495c4a1", "filename": "src/test/ui/const-generics/types-mismatch-const-args.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.stderr?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -0,0 +1,29 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/types-mismatch-const-args.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0308]: mismatched types\n+  --> $DIR/types-mismatch-const-args.rs:13:41\n+   |\n+LL |     let _: A<'a, u32, {2u32}, {3u32}> = A::<'a, u32, {4u32}, {3u32}> { data: PhantomData };\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `2u32`, found `4u32`\n+   |\n+   = note: expected type `A<'_, _, 2u32, _>`\n+              found type `A<'_, _, 4u32, _>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/types-mismatch-const-args.rs:15:41\n+   |\n+LL |     let _: A<'a, u16, {2u32}, {3u32}> = A::<'b, u32, {2u32}, {3u32}> { data: PhantomData };\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected u16, found u32\n+   |\n+   = note: expected type `A<'a, u16, _, _>`\n+              found type `A<'b, u32, _, _>`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "53b7aafc430a284daa028b0359dc562c2a39746e", "filename": "src/test/ui/if/if-no-match-bindings.stderr", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Ftest%2Fui%2Fif%2Fif-no-match-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Ftest%2Fui%2Fif%2Fif-no-match-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fif-no-match-bindings.stderr?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -2,7 +2,10 @@ error[E0308]: mismatched types\n   --> $DIR/if-no-match-bindings.rs:18:8\n    |\n LL |     if b_ref() {}\n-   |        ^^^^^^^ expected bool, found &bool\n+   |        ^^^^^^^\n+   |        |\n+   |        expected bool, found &bool\n+   |        help: consider dereferencing the borrow: `*b_ref()`\n    |\n    = note: expected type `bool`\n               found type `&bool`\n@@ -11,7 +14,10 @@ error[E0308]: mismatched types\n   --> $DIR/if-no-match-bindings.rs:19:8\n    |\n LL |     if b_mut_ref() {}\n-   |        ^^^^^^^^^^^ expected bool, found &mut bool\n+   |        ^^^^^^^^^^^\n+   |        |\n+   |        expected bool, found &mut bool\n+   |        help: consider dereferencing the borrow: `*b_mut_ref()`\n    |\n    = note: expected type `bool`\n               found type `&mut bool`\n@@ -20,7 +26,10 @@ error[E0308]: mismatched types\n   --> $DIR/if-no-match-bindings.rs:20:8\n    |\n LL |     if &true {}\n-   |        ^^^^^ expected bool, found &bool\n+   |        ^^^^^\n+   |        |\n+   |        expected bool, found &bool\n+   |        help: consider dereferencing the borrow: `*&true`\n    |\n    = note: expected type `bool`\n               found type `&bool`\n@@ -29,7 +38,10 @@ error[E0308]: mismatched types\n   --> $DIR/if-no-match-bindings.rs:21:8\n    |\n LL |     if &mut true {}\n-   |        ^^^^^^^^^ expected bool, found &mut bool\n+   |        ^^^^^^^^^\n+   |        |\n+   |        expected bool, found &mut bool\n+   |        help: consider dereferencing the borrow: `*&mut true`\n    |\n    = note: expected type `bool`\n               found type `&mut bool`\n@@ -38,7 +50,10 @@ error[E0308]: mismatched types\n   --> $DIR/if-no-match-bindings.rs:24:11\n    |\n LL |     while b_ref() {}\n-   |           ^^^^^^^ expected bool, found &bool\n+   |           ^^^^^^^\n+   |           |\n+   |           expected bool, found &bool\n+   |           help: consider dereferencing the borrow: `*b_ref()`\n    |\n    = note: expected type `bool`\n               found type `&bool`\n@@ -47,7 +62,10 @@ error[E0308]: mismatched types\n   --> $DIR/if-no-match-bindings.rs:25:11\n    |\n LL |     while b_mut_ref() {}\n-   |           ^^^^^^^^^^^ expected bool, found &mut bool\n+   |           ^^^^^^^^^^^\n+   |           |\n+   |           expected bool, found &mut bool\n+   |           help: consider dereferencing the borrow: `*b_mut_ref()`\n    |\n    = note: expected type `bool`\n               found type `&mut bool`\n@@ -56,7 +74,10 @@ error[E0308]: mismatched types\n   --> $DIR/if-no-match-bindings.rs:26:11\n    |\n LL |     while &true {}\n-   |           ^^^^^ expected bool, found &bool\n+   |           ^^^^^\n+   |           |\n+   |           expected bool, found &bool\n+   |           help: consider dereferencing the borrow: `*&true`\n    |\n    = note: expected type `bool`\n               found type `&bool`\n@@ -65,7 +86,10 @@ error[E0308]: mismatched types\n   --> $DIR/if-no-match-bindings.rs:27:11\n    |\n LL |     while &mut true {}\n-   |           ^^^^^^^^^ expected bool, found &mut bool\n+   |           ^^^^^^^^^\n+   |           |\n+   |           expected bool, found &mut bool\n+   |           help: consider dereferencing the borrow: `*&mut true`\n    |\n    = note: expected type `bool`\n               found type `&mut bool`"}, {"sha": "f21df68d5a2cc52e5fca6f26879ed9b86ac0da08", "filename": "src/test/ui/no-patterns-in-args-macro.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Ftest%2Fui%2Fno-patterns-in-args-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Ftest%2Fui%2Fno-patterns-in-args-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-patterns-in-args-macro.stderr?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -18,5 +18,5 @@ LL |     m!((bad, pat));\n \n error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0130, E0642.\n+Some errors have detailed explanations: E0130, E0561, E0642.\n For more information about an error, try `rustc --explain E0130`."}, {"sha": "1c2ce86646787e65eecc1462a06d16b20f35f52c", "filename": "src/test/ui/no-patterns-in-args.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Ftest%2Fui%2Fno-patterns-in-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Ftest%2Fui%2Fno-patterns-in-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-patterns-in-args.stderr?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -30,4 +30,5 @@ LL | type A2 = fn(&arg: u8);\n \n error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0130`.\n+Some errors have detailed explanations: E0130, E0561.\n+For more information about an error, try `rustc --explain E0130`."}, {"sha": "7291732cebe4a3751062346c6920758f349d38c5", "filename": "src/test/ui/parser/issue-33413.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Ftest%2Fui%2Fparser%2Fissue-33413.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Ftest%2Fui%2Fparser%2Fissue-33413.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-33413.rs?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -3,6 +3,7 @@ struct S;\n impl S {\n     fn f(*, a: u8) -> u8 {}\n     //~^ ERROR expected parameter name, found `*`\n+    //~| ERROR mismatched types\n }\n \n fn main() {}"}, {"sha": "7e5c348e36ceac5073e18730a04b066186b5f148", "filename": "src/test/ui/parser/issue-33413.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Ftest%2Fui%2Fparser%2Fissue-33413.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Ftest%2Fui%2Fparser%2Fissue-33413.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-33413.stderr?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -4,5 +4,17 @@ error: expected parameter name, found `*`\n LL |     fn f(*, a: u8) -> u8 {}\n    |          ^ expected parameter name\n \n-error: aborting due to previous error\n+error[E0308]: mismatched types\n+  --> $DIR/issue-33413.rs:4:23\n+   |\n+LL |     fn f(*, a: u8) -> u8 {}\n+   |        -              ^^ expected u8, found ()\n+   |        |\n+   |        implicitly returns `()` as its body has no tail or `return` expression\n+   |\n+   = note: expected type `u8`\n+              found type `()`\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "619f9c85b24dbab4b7baf7adde1c554a7a1d686a", "filename": "src/test/ui/rfc-2497-if-let-chains/disallowed-positions.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr?ref=1e1f25e31b1d26bd62aaf5a4554d25c33f75a0d1", "patch": "@@ -517,7 +517,10 @@ error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:32:8\n    |\n LL |     if &let 0 = 0 {}\n-   |        ^^^^^^^^^^ expected bool, found &bool\n+   |        ^^^^^^^^^^\n+   |        |\n+   |        expected bool, found &bool\n+   |        help: consider dereferencing the borrow: `*&let 0 = 0`\n    |\n    = note: expected type `bool`\n               found type `&bool`\n@@ -702,7 +705,10 @@ error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:96:11\n    |\n LL |     while &let 0 = 0 {}\n-   |           ^^^^^^^^^^ expected bool, found &bool\n+   |           ^^^^^^^^^^\n+   |           |\n+   |           expected bool, found &bool\n+   |           help: consider dereferencing the borrow: `*&let 0 = 0`\n    |\n    = note: expected type `bool`\n               found type `&bool`"}]}