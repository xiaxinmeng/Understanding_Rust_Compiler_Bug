{"sha": "c0d507d73b1cc51dd052abe96580f1c3d233ed25", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwZDUwN2Q3M2IxY2M1MWRkMDUyYWJlOTY1ODBmMWMzZDIzM2VkMjU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-02-13T17:12:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-02-13T17:12:31Z"}, "message": "Rollup merge of #58272 - fitzgen:num-format-code-size, r=Mark-Simulacrum\n\nCut down on number formating code size\n\nr? @alexcrichton", "tree": {"sha": "b00c0e95587eeb0f319a86e6584606423f1a1052", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b00c0e95587eeb0f319a86e6584606423f1a1052"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0d507d73b1cc51dd052abe96580f1c3d233ed25", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcZE//CRBK7hj4Ov3rIwAAdHIIABqM2CdLPb/tL3X4kMVVPvSV\nVUZbTiviBqRA044/SYncfiNsnk8PAn8C8uf22GcKmqbTkSX/Ow2GMQ6/U6gouTRv\nSUKpRC6Aac6m/6xfUZ4Hh42vbZ3SNEKqYBBl6N3GU3s7F/TgHXgEKFkusmIH/Bfc\nNyVsGE57x0T6XZMQPkfZN+7SjgbfrM+TvWy+gFOgGnRretsxWrU+WC248R4V/8/r\n8mT3NT/HsQMqaNn5wlSfUGvwJ1YtcNKjslCQ+boSBKwhqEPnUcMSBVe9HyCw5aAQ\nTEkZ0jHHTWxCO8nFD+nF8yS5vOaB41tprJeyX5NIJTYXd2MLW6ohLyqqeo7waIw=\n=r+lA\n-----END PGP SIGNATURE-----\n", "payload": "tree b00c0e95587eeb0f319a86e6584606423f1a1052\nparent 193c3773c245132f0c113fe9d957524b75a0eaa0\nparent f00f0e676887c8970858897836aa1e8a81d8aa60\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1550077951 +0100\ncommitter GitHub <noreply@github.com> 1550077951 +0100\n\nRollup merge of #58272 - fitzgen:num-format-code-size, r=Mark-Simulacrum\n\nCut down on number formating code size\n\nr? @alexcrichton\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0d507d73b1cc51dd052abe96580f1c3d233ed25", "html_url": "https://github.com/rust-lang/rust/commit/c0d507d73b1cc51dd052abe96580f1c3d233ed25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0d507d73b1cc51dd052abe96580f1c3d233ed25/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "193c3773c245132f0c113fe9d957524b75a0eaa0", "url": "https://api.github.com/repos/rust-lang/rust/commits/193c3773c245132f0c113fe9d957524b75a0eaa0", "html_url": "https://github.com/rust-lang/rust/commit/193c3773c245132f0c113fe9d957524b75a0eaa0"}, {"sha": "f00f0e676887c8970858897836aa1e8a81d8aa60", "url": "https://api.github.com/repos/rust-lang/rust/commits/f00f0e676887c8970858897836aa1e8a81d8aa60", "html_url": "https://github.com/rust-lang/rust/commit/f00f0e676887c8970858897836aa1e8a81d8aa60"}], "stats": {"total": 231, "additions": 157, "deletions": 74}, "files": [{"sha": "7efb7f31298bf194fea3657d7555519e26a04a46", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 62, "deletions": 39, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/c0d507d73b1cc51dd052abe96580f1c3d233ed25/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d507d73b1cc51dd052abe96580f1c3d233ed25/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=c0d507d73b1cc51dd052abe96580f1c3d233ed25", "patch": "@@ -1036,6 +1036,27 @@ pub fn write(output: &mut dyn Write, args: Arguments) -> Result {\n     Ok(())\n }\n \n+/// Padding after the end of something. Returned by `Formatter::padding`.\n+#[must_use = \"don't forget to write the post padding\"]\n+struct PostPadding {\n+    fill: char,\n+    padding: usize,\n+}\n+\n+impl PostPadding {\n+    fn new(fill: char, padding: usize) -> PostPadding {\n+        PostPadding { fill, padding }\n+    }\n+\n+    /// Write this post padding.\n+    fn write(self, buf: &mut dyn Write) -> Result {\n+        for _ in 0..self.padding {\n+            buf.write_char(self.fill)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl<'a> Formatter<'a> {\n     fn wrap_buf<'b, 'c, F>(&'b mut self, wrap: F) -> Formatter<'c>\n         where 'b: 'c, F: FnOnce(&'b mut (dyn Write+'b)) -> &'c mut (dyn Write+'c)\n@@ -1153,47 +1174,56 @@ impl<'a> Formatter<'a> {\n             sign = Some('+'); width += 1;\n         }\n \n-        let prefixed = self.alternate();\n-        if prefixed {\n+        let prefix = if self.alternate() {\n             width += prefix.chars().count();\n-        }\n+            Some(prefix)\n+        } else {\n+            None\n+        };\n \n         // Writes the sign if it exists, and then the prefix if it was requested\n-        let write_prefix = |f: &mut Formatter| {\n+        #[inline(never)]\n+        fn write_prefix(f: &mut Formatter, sign: Option<char>, prefix: Option<&str>) -> Result {\n             if let Some(c) = sign {\n                 f.buf.write_char(c)?;\n             }\n-            if prefixed { f.buf.write_str(prefix) }\n-            else { Ok(()) }\n-        };\n+            if let Some(prefix) = prefix {\n+                f.buf.write_str(prefix)\n+            } else {\n+                Ok(())\n+            }\n+        }\n \n         // The `width` field is more of a `min-width` parameter at this point.\n         match self.width {\n             // If there's no minimum length requirements then we can just\n             // write the bytes.\n             None => {\n-                write_prefix(self)?; self.buf.write_str(buf)\n+                write_prefix(self, sign, prefix)?;\n+                self.buf.write_str(buf)\n             }\n             // Check if we're over the minimum width, if so then we can also\n             // just write the bytes.\n             Some(min) if width >= min => {\n-                write_prefix(self)?; self.buf.write_str(buf)\n+                write_prefix(self, sign, prefix)?;\n+                self.buf.write_str(buf)\n             }\n             // The sign and prefix goes before the padding if the fill character\n             // is zero\n             Some(min) if self.sign_aware_zero_pad() => {\n                 self.fill = '0';\n                 self.align = rt::v1::Alignment::Right;\n-                write_prefix(self)?;\n-                self.with_padding(min - width, rt::v1::Alignment::Right, |f| {\n-                    f.buf.write_str(buf)\n-                })\n+                write_prefix(self, sign, prefix)?;\n+                let post_padding = self.padding(min - width, rt::v1::Alignment::Right)?;\n+                self.buf.write_str(buf)?;\n+                post_padding.write(self.buf)\n             }\n             // Otherwise, the sign and prefix goes after the padding\n             Some(min) => {\n-                self.with_padding(min - width, rt::v1::Alignment::Right, |f| {\n-                    write_prefix(f)?; f.buf.write_str(buf)\n-                })\n+                let post_padding = self.padding(min - width, rt::v1::Alignment::Right)?;\n+                write_prefix(self, sign, prefix)?;\n+                self.buf.write_str(buf)?;\n+                post_padding.write(self.buf)\n             }\n         }\n     }\n@@ -1264,19 +1294,21 @@ impl<'a> Formatter<'a> {\n             // up the minimum width with the specified string + some alignment.\n             Some(width) => {\n                 let align = rt::v1::Alignment::Left;\n-                self.with_padding(width - s.chars().count(), align, |me| {\n-                    me.buf.write_str(s)\n-                })\n+                let post_padding = self.padding(width - s.chars().count(), align)?;\n+                self.buf.write_str(s)?;\n+                post_padding.write(self.buf)\n             }\n         }\n     }\n \n-    /// Runs a callback, emitting the correct padding either before or\n-    /// afterwards depending on whether right or left alignment is requested.\n-    fn with_padding<F>(&mut self, padding: usize, default: rt::v1::Alignment,\n-                       f: F) -> Result\n-        where F: FnOnce(&mut Formatter) -> Result,\n-    {\n+    /// Write the pre-padding and return the unwritten post-padding. Callers are\n+    /// responsible for ensuring post-padding is written after the thing that is\n+    /// being padded.\n+    fn padding(\n+        &mut self,\n+        padding: usize,\n+        default: rt::v1::Alignment\n+    ) -> result::Result<PostPadding, Error> {\n         let align = match self.align {\n             rt::v1::Alignment::Unknown => default,\n             _ => self.align\n@@ -1289,20 +1321,11 @@ impl<'a> Formatter<'a> {\n             rt::v1::Alignment::Center => (padding / 2, (padding + 1) / 2),\n         };\n \n-        let mut fill = [0; 4];\n-        let fill = self.fill.encode_utf8(&mut fill);\n-\n         for _ in 0..pre_pad {\n-            self.buf.write_str(fill)?;\n-        }\n-\n-        f(self)?;\n-\n-        for _ in 0..post_pad {\n-            self.buf.write_str(fill)?;\n+            self.buf.write_char(self.fill)?;\n         }\n \n-        Ok(())\n+        Ok(PostPadding::new(self.fill, post_pad))\n     }\n \n     /// Takes the formatted parts and applies the padding.\n@@ -1334,9 +1357,9 @@ impl<'a> Formatter<'a> {\n             let ret = if width <= len { // no padding\n                 self.write_formatted_parts(&formatted)\n             } else {\n-                self.with_padding(width - len, align, |f| {\n-                    f.write_formatted_parts(&formatted)\n-                })\n+                let post_padding = self.padding(width - len, align)?;\n+                self.write_formatted_parts(&formatted)?;\n+                post_padding.write(self.buf)\n             };\n             self.fill = old_fill;\n             self.align = old_align;"}, {"sha": "b9fa3640371082148624f625ad1e0eabbea9faa7", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 52, "deletions": 35, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/c0d507d73b1cc51dd052abe96580f1c3d233ed25/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d507d73b1cc51dd052abe96580f1c3d233ed25/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=c0d507d73b1cc51dd052abe96580f1c3d233ed25", "patch": "@@ -178,45 +178,36 @@ integer! { i32, u32 }\n integer! { i64, u64 }\n integer! { i128, u128 }\n \n-const DEC_DIGITS_LUT: &'static[u8] =\n+\n+static DEC_DIGITS_LUT: &[u8; 200] =\n     b\"0001020304050607080910111213141516171819\\\n       2021222324252627282930313233343536373839\\\n       4041424344454647484950515253545556575859\\\n       6061626364656667686970717273747576777879\\\n       8081828384858687888990919293949596979899\";\n \n macro_rules! impl_Display {\n-    ($($t:ident),*: $conv_fn:ident) => ($(\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl fmt::Display for $t {\n-        #[allow(unused_comparisons)]\n-        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-            let is_nonnegative = *self >= 0;\n-            let mut n = if is_nonnegative {\n-                self.$conv_fn()\n-            } else {\n-                // convert the negative num to positive by summing 1 to it's 2 complement\n-                (!self.$conv_fn()).wrapping_add(1)\n-            };\n+    ($($t:ident),* as $u:ident via $conv_fn:ident named $name:ident) => {\n+        fn $name(mut n: $u, is_nonnegative: bool, f: &mut fmt::Formatter) -> fmt::Result {\n             let mut buf = uninitialized_array![u8; 39];\n             let mut curr = buf.len() as isize;\n             let buf_ptr = MaybeUninit::first_ptr_mut(&mut buf);\n             let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n \n             unsafe {\n                 // need at least 16 bits for the 4-characters-at-a-time to work.\n-                if ::mem::size_of::<$t>() >= 2 {\n-                    // eagerly decode 4 characters at a time\n-                    while n >= 10000 {\n-                        let rem = (n % 10000) as isize;\n-                        n /= 10000;\n-\n-                        let d1 = (rem / 100) << 1;\n-                        let d2 = (rem % 100) << 1;\n-                        curr -= 4;\n-                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n-                        ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n-                    }\n+                assert!(::mem::size_of::<$u>() >= 2);\n+\n+                // eagerly decode 4 characters at a time\n+                while n >= 10000 {\n+                    let rem = (n % 10000) as isize;\n+                    n /= 10000;\n+\n+                    let d1 = (rem / 100) << 1;\n+                    let d2 = (rem % 100) << 1;\n+                    curr -= 4;\n+                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n+                    ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n                 }\n \n                 // if we reach here numbers are <= 9999, so at most 4 chars long\n@@ -247,15 +238,41 @@ macro_rules! impl_Display {\n             };\n             f.pad_integral(is_nonnegative, \"\", buf_slice)\n         }\n-    })*);\n+\n+        $(\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl fmt::Display for $t {\n+                #[allow(unused_comparisons)]\n+                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                    let is_nonnegative = *self >= 0;\n+                    let n = if is_nonnegative {\n+                        self.$conv_fn()\n+                    } else {\n+                        // convert the negative num to positive by summing 1 to it's 2 complement\n+                        (!self.$conv_fn()).wrapping_add(1)\n+                    };\n+                    $name(n, is_nonnegative, f)\n+                }\n+            })*\n+    };\n+}\n+\n+// Include wasm32 in here since it doesn't reflect the native pointer size, and\n+// often cares strongly about getting a smaller code size.\n+#[cfg(any(target_pointer_width = \"64\", target_arch = \"wasm32\"))]\n+mod imp {\n+    use super::*;\n+    impl_Display!(\n+        i8, u8, i16, u16, i32, u32, i64, u64, usize, isize\n+            as u64 via to_u64 named fmt_u64\n+    );\n+}\n+\n+#[cfg(not(any(target_pointer_width = \"64\", target_arch = \"wasm32\")))]\n+mod imp {\n+    use super::*;\n+    impl_Display!(i8, u8, i16, u16, i32, u32, isize, usize as u32 via to_u32 named fmt_u32);\n+    impl_Display!(i64, u64 as u64 via to_u64 named fmt_u64);\n }\n \n-impl_Display!(i8, u8, i16, u16, i32, u32: to_u32);\n-impl_Display!(i64, u64: to_u64);\n-impl_Display!(i128, u128: to_u128);\n-#[cfg(target_pointer_width = \"16\")]\n-impl_Display!(isize, usize: to_u16);\n-#[cfg(target_pointer_width = \"32\")]\n-impl_Display!(isize, usize: to_u32);\n-#[cfg(target_pointer_width = \"64\")]\n-impl_Display!(isize, usize: to_u64);\n+impl_Display!(i128, u128 as u128 via to_u128 named fmt_u128);"}, {"sha": "26de6a0c6899054c98f7890befd0639573a70e13", "filename": "src/test/run-make/wasm-stringify-ints-small/Makefile", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0d507d73b1cc51dd052abe96580f1c3d233ed25/src%2Ftest%2Frun-make%2Fwasm-stringify-ints-small%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c0d507d73b1cc51dd052abe96580f1c3d233ed25/src%2Ftest%2Frun-make%2Fwasm-stringify-ints-small%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwasm-stringify-ints-small%2FMakefile?ref=c0d507d73b1cc51dd052abe96580f1c3d233ed25", "patch": "@@ -0,0 +1,10 @@\n+-include ../../run-make-fulldeps/tools.mk\n+\n+ifeq ($(TARGET),wasm32-unknown-unknown)\n+all:\n+\t$(RUSTC) foo.rs -C lto -O --target wasm32-unknown-unknown\n+\twc -c < $(TMPDIR)/foo.wasm\n+\t[ \"`wc -c < $(TMPDIR)/foo.wasm`\" -lt \"20500\" ]\n+else\n+all:\n+endif"}, {"sha": "7a947f013ad486f1adc58f027e2a88253f501e9b", "filename": "src/test/run-make/wasm-stringify-ints-small/foo.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c0d507d73b1cc51dd052abe96580f1c3d233ed25/src%2Ftest%2Frun-make%2Fwasm-stringify-ints-small%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d507d73b1cc51dd052abe96580f1c3d233ed25/src%2Ftest%2Frun-make%2Fwasm-stringify-ints-small%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwasm-stringify-ints-small%2Ffoo.rs?ref=c0d507d73b1cc51dd052abe96580f1c3d233ed25", "patch": "@@ -0,0 +1,33 @@\n+#![crate_type = \"cdylib\"]\n+\n+extern \"C\" {\n+    fn observe(ptr: *const u8, len: usize);\n+}\n+\n+macro_rules! s {\n+    ( $( $f:ident -> $t:ty );* $(;)* ) => {\n+        $(\n+            extern \"C\" {\n+                fn $f() -> $t;\n+            }\n+            let s = $f().to_string();\n+            observe(s.as_ptr(), s.len());\n+        )*\n+    };\n+}\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn foo() {\n+    s! {\n+        get_u8 -> u8;\n+        get_i8 -> i8;\n+        get_u16 -> u16;\n+        get_i16 -> i16;\n+        get_u32 -> u32;\n+        get_i32 -> i32;\n+        get_u64 -> u64;\n+        get_i64 -> i64;\n+        get_usize -> usize;\n+        get_isize -> isize;\n+    }\n+}"}]}